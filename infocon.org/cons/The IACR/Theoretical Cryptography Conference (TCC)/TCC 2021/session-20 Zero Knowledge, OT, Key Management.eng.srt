1
00:00:00,240 --> 00:00:02,240
session of the day on zero knowledge

2
00:00:02,240 --> 00:00:04,560
oblivious transfer and key management

3
00:00:04,560 --> 00:00:08,400
our first talk is by is a tight security

4
00:00:08,400 --> 00:00:11,120
bounce for mikali snarks

5
00:00:11,120 --> 00:00:12,080
and

6
00:00:12,080 --> 00:00:14,799
this is a joint work by alessandro and

7
00:00:14,799 --> 00:00:18,960
elon and elon is going to give the talk

8
00:00:19,359 --> 00:00:21,840
yeah hi everyone let me first just

9
00:00:21,840 --> 00:00:25,039
apologize i lost my voice yesterday and

10
00:00:25,039 --> 00:00:29,599
i just found it but like half half okay

11
00:00:29,599 --> 00:00:32,479
so i'll uh i'll start the talk so this

12
00:00:32,479 --> 00:00:35,600
is tight security bounce on kali snargs

13
00:00:35,600 --> 00:00:37,600
um

14
00:00:37,600 --> 00:00:39,920
okay so the subject is going to be

15
00:00:39,920 --> 00:00:42,000
succinct non-interactive arguments in

16
00:00:42,000 --> 00:00:44,640
the random oracle model so let me just

17
00:00:44,640 --> 00:00:47,200
very briefly uh remind everyone what i'm

18
00:00:47,200 --> 00:00:48,640
talking about

19
00:00:48,640 --> 00:00:50,800
so these are snarks this is going to be

20
00:00:50,800 --> 00:00:53,120
a proof system it's a non-interactive

21
00:00:53,120 --> 00:00:55,360
pool system for some language l we have

22
00:00:55,360 --> 00:00:57,280
a pool and a verifier

23
00:00:57,280 --> 00:00:59,920
approval sends a single message pi

24
00:00:59,920 --> 00:01:02,160
and the goal here is to really get a

25
00:01:02,160 --> 00:01:04,400
success communication okay so this

26
00:01:04,400 --> 00:01:06,240
matches message is going to be very

27
00:01:06,240 --> 00:01:08,560
small in particular much smaller than

28
00:01:08,560 --> 00:01:12,320
just sending let's say the np weakness

29
00:01:12,320 --> 00:01:14,640
and the the way we're going to do this

30
00:01:14,640 --> 00:01:16,479
is by relaxing the sound is to be

31
00:01:16,479 --> 00:01:19,119
computational and in the random local

32
00:01:19,119 --> 00:01:21,439
model so i'm just going to define this

33
00:01:21,439 --> 00:01:23,680
slightly more very

34
00:01:23,680 --> 00:01:26,560
precisely so the provenance verifier

35
00:01:26,560 --> 00:01:28,960
will share this random function in the

36
00:01:28,960 --> 00:01:31,200
sky okay this random orchid

37
00:01:31,200 --> 00:01:34,240
and we define t epsilon security

38
00:01:34,240 --> 00:01:35,439
if for any

39
00:01:35,439 --> 00:01:37,680
a x not in the language

40
00:01:37,680 --> 00:01:39,759
and for every t query unbounded

41
00:01:39,759 --> 00:01:41,840
adversary p

42
00:01:41,840 --> 00:01:42,560
a

43
00:01:42,560 --> 00:01:44,960
the probability that this unbounded

44
00:01:44,960 --> 00:01:46,720
adversary that performs at most big

45
00:01:46,720 --> 00:01:48,880
queries talks to the random oracle and

46
00:01:48,880 --> 00:01:51,439
outputs a proof phi that convinces the

47
00:01:51,439 --> 00:01:53,439
verifier that interacts with the same

48
00:01:53,439 --> 00:01:55,119
alkaloids at most

49
00:01:55,119 --> 00:01:56,240
epsilon

50
00:01:56,240 --> 00:01:58,880
okay the just definition of snugs in the

51
00:01:58,880 --> 00:02:00,960
random local model

52
00:02:00,960 --> 00:02:02,479
um

53
00:02:02,479 --> 00:02:03,920
okay

54
00:02:03,920 --> 00:02:06,079
so

55
00:02:07,680 --> 00:02:08,639
so

56
00:02:08,639 --> 00:02:10,399
why do i focus on the random oracle

57
00:02:10,399 --> 00:02:13,120
model there are a lot of snugs in in the

58
00:02:13,120 --> 00:02:15,920
standard model but really it's a very

59
00:02:15,920 --> 00:02:18,720
elegant information theoretic model

60
00:02:18,720 --> 00:02:21,599
we have very beautiful constructions and

61
00:02:21,599 --> 00:02:23,840
i'm going to slightly talk about mikali

62
00:02:23,840 --> 00:02:25,520
uh of course once you have a

63
00:02:25,520 --> 00:02:26,879
construction in this model you can

64
00:02:26,879 --> 00:02:28,720
heuristically you know

65
00:02:28,720 --> 00:02:31,120
instantiate the random oracle using some

66
00:02:31,120 --> 00:02:33,840
relatively lightweight crypto

67
00:02:33,840 --> 00:02:36,160
and as a result what you get is this is

68
00:02:36,160 --> 00:02:37,920
a very nice way to get

69
00:02:37,920 --> 00:02:41,360
fast uh okay so like fast schemes around

70
00:02:41,360 --> 00:02:43,920
the pool and very far quite fast they

71
00:02:43,920 --> 00:02:46,879
are probably post quantum secure

72
00:02:46,879 --> 00:02:49,840
and they require no trust etc

73
00:02:49,840 --> 00:02:53,040
okay so this is all snugs and all

74
00:02:53,040 --> 00:02:54,000
um

75
00:02:54,000 --> 00:02:56,400
now i want to focus on maybe the first

76
00:02:56,400 --> 00:02:58,400
and most popular slug and all mikali's

77
00:02:58,400 --> 00:02:59,599
construction

78
00:02:59,599 --> 00:03:01,120
and i'm not going to go into all the

79
00:03:01,120 --> 00:03:02,800
details of the construction i assume you

80
00:03:02,800 --> 00:03:06,080
guys at least held it uh but what mikali

81
00:03:06,080 --> 00:03:08,560
did he said okay let's take a pcp

82
00:03:08,560 --> 00:03:09,440
okay

83
00:03:09,440 --> 00:03:11,599
and let's commit to a pcp string for the

84
00:03:11,599 --> 00:03:13,680
language using a miracle tree

85
00:03:13,680 --> 00:03:15,840
okay that's a portal local opening

86
00:03:15,840 --> 00:03:18,000
and then using the feature mail we're

87
00:03:18,000 --> 00:03:21,200
gonna uh derive randomness for the pcp

88
00:03:21,200 --> 00:03:23,760
verifier and just give all the pcpm

89
00:03:23,760 --> 00:03:25,760
sales uh along with the authentication

90
00:03:25,760 --> 00:03:28,000
passes in the in the tree and these are

91
00:03:28,000 --> 00:03:30,480
this is the snark

92
00:03:30,480 --> 00:03:32,480
and um

93
00:03:32,480 --> 00:03:34,000
what is the sound is that we get from

94
00:03:34,000 --> 00:03:35,920
this uh from the scheme

95
00:03:35,920 --> 00:03:37,200
so uh

96
00:03:37,200 --> 00:03:39,040
you know i have to use some pcp so let's

97
00:03:39,040 --> 00:03:40,159
say it has

98
00:03:40,159 --> 00:03:43,200
it had errol epsilon pcp then the best

99
00:03:43,200 --> 00:03:46,319
sound is ever that we know due to bcs is

100
00:03:46,319 --> 00:03:49,120
this epstein arg which is going to be

101
00:03:49,120 --> 00:03:52,159
three times epsilon pcp okay so we have

102
00:03:52,159 --> 00:03:54,640
the error of the pcp and the uh cheating

103
00:03:54,640 --> 00:03:56,879
prover can try t times to attack this

104
00:03:56,879 --> 00:03:59,040
okay so this is where we have this or

105
00:03:59,040 --> 00:04:00,400
they can try to attack the random

106
00:04:00,400 --> 00:04:01,599
orbital

107
00:04:01,599 --> 00:04:03,439
okay and in the analysis you want to

108
00:04:03,439 --> 00:04:05,360
assume that he didn't find collisions

109
00:04:05,360 --> 00:04:07,439
and stuff like that so you get this t

110
00:04:07,439 --> 00:04:09,439
squared over to the lambda and this is

111
00:04:09,439 --> 00:04:12,840
due to the birthday paradox

112
00:04:12,840 --> 00:04:14,879
okay and

113
00:04:14,879 --> 00:04:17,199
one question is is this tight is this

114
00:04:17,199 --> 00:04:19,440
expression tight

115
00:04:19,440 --> 00:04:20,639
um

116
00:04:20,639 --> 00:04:23,199
so this part is actually tight like if

117
00:04:23,199 --> 00:04:25,759
you really have a error of absolutely of

118
00:04:25,759 --> 00:04:28,400
episode on pcp you can try 80 times okay

119
00:04:28,400 --> 00:04:30,639
because this is the budget the adversary

120
00:04:30,639 --> 00:04:34,479
has and so you actually get this error

121
00:04:34,479 --> 00:04:36,880
but this part it's very unclear if it's

122
00:04:36,880 --> 00:04:39,440
tight okay in particular

123
00:04:39,440 --> 00:04:41,600
this was used to assume that he didn't

124
00:04:41,600 --> 00:04:44,080
find any collisions but if he has one

125
00:04:44,080 --> 00:04:45,520
collision

126
00:04:45,520 --> 00:04:47,120
does this mean that he can attack the

127
00:04:47,120 --> 00:04:48,639
skin

128
00:04:48,639 --> 00:04:51,120
um so i'll just mention that a negative

129
00:04:51,120 --> 00:04:53,280
answer to this question is good news

130
00:04:53,280 --> 00:04:55,199
because if this is not right then we can

131
00:04:55,199 --> 00:04:56,560
actually prove something better and

132
00:04:56,560 --> 00:04:58,639
we'll get better security which means a

133
00:04:58,639 --> 00:05:01,280
smaller argument size

134
00:05:01,280 --> 00:05:03,120
okay so before i tell you our results

135
00:05:03,120 --> 00:05:05,520
let me just pinpoint the question

136
00:05:05,520 --> 00:05:08,000
so the actual answer slightly depends on

137
00:05:08,000 --> 00:05:10,400
the fine details of the construction

138
00:05:10,400 --> 00:05:12,160
so if you're slightly careless with the

139
00:05:12,160 --> 00:05:14,080
implementation actually a single

140
00:05:14,080 --> 00:05:16,080
collision is very harmful

141
00:05:16,080 --> 00:05:18,639
so if you just use a let's say a binary

142
00:05:18,639 --> 00:05:20,080
pcp

143
00:05:20,080 --> 00:05:21,520
okay and you do

144
00:05:21,520 --> 00:05:23,280
nothing you just hash everything let's

145
00:05:23,280 --> 00:05:25,360
say a burner pcb padded to the length of

146
00:05:25,360 --> 00:05:27,600
them and the market you can actually use

147
00:05:27,600 --> 00:05:29,759
a single a collision between zero and

148
00:05:29,759 --> 00:05:32,160
one okay in the leaves and you can just

149
00:05:32,160 --> 00:05:35,440
reuse this collision for the entire

150
00:05:35,440 --> 00:05:36,880
for all the leaves

151
00:05:36,880 --> 00:05:38,880
and then actually that velocity is like

152
00:05:38,880 --> 00:05:40,560
he's not committed to anything like

153
00:05:40,560 --> 00:05:42,639
every leaf he can open to zero one which

154
00:05:42,639 --> 00:05:44,960
gives them like full power

155
00:05:44,960 --> 00:05:47,039
okay and then the soundness is optimal

156
00:05:47,039 --> 00:05:48,400
but

157
00:05:48,400 --> 00:05:50,960
um this can be trivially avoided if we

158
00:05:50,960 --> 00:05:54,160
just added a prefixes okay if we just

159
00:05:54,160 --> 00:05:56,560
add prefix to every query okay so when

160
00:05:56,560 --> 00:05:58,880
he hashes here we just add the prefix

161
00:05:58,880 --> 00:06:01,280
one one and here's the one okay this

162
00:06:01,280 --> 00:06:02,960
means that any collision here is just

163
00:06:02,960 --> 00:06:04,880
not useful here because the collision

164
00:06:04,880 --> 00:06:06,479
here would have a different prefix so he

165
00:06:06,479 --> 00:06:09,120
would have to walk again

166
00:06:09,120 --> 00:06:11,440
and now with this domain separated the

167
00:06:11,440 --> 00:06:14,000
version of bikali we can ask is this

168
00:06:14,000 --> 00:06:15,199
optimal

169
00:06:15,199 --> 00:06:17,360
and our main result is that

170
00:06:17,360 --> 00:06:19,520
a negative answer this is not absolute

171
00:06:19,520 --> 00:06:22,160
and we actually give a tight

172
00:06:22,160 --> 00:06:24,479
tight security band from nikali

173
00:06:24,479 --> 00:06:27,520
um so the the soundness is this thing

174
00:06:27,520 --> 00:06:29,440
that we said that is already optimal

175
00:06:29,440 --> 00:06:32,880
plus some small expression c okay which

176
00:06:32,880 --> 00:06:35,039
is this let's see know this for now

177
00:06:35,039 --> 00:06:37,520
t over two to the lambda okay where the

178
00:06:37,520 --> 00:06:39,440
previous analysis said that we needed t

179
00:06:39,440 --> 00:06:42,400
squared okay over two lambda

180
00:06:42,400 --> 00:06:44,639
uh and this expression is like we show a

181
00:06:44,639 --> 00:06:46,639
matching low bound

182
00:06:46,639 --> 00:06:47,600
um

183
00:06:47,600 --> 00:06:50,160
so the implication that if you want key

184
00:06:50,160 --> 00:06:52,560
epsilon security before you had to set

185
00:06:52,560 --> 00:06:54,319
the random overkill to be

186
00:06:54,319 --> 00:06:55,120
logged

187
00:06:55,120 --> 00:06:56,479
over epsilon

188
00:06:56,479 --> 00:06:58,800
okay to get the absolute security and

189
00:06:58,800 --> 00:07:00,639
the argument size

190
00:07:00,639 --> 00:07:02,720
depends on this lambda

191
00:07:02,720 --> 00:07:04,479
and using our analysis you can set

192
00:07:04,479 --> 00:07:06,639
lambda to be the max of this is

193
00:07:06,639 --> 00:07:08,639
expression let's focus let's say on this

194
00:07:08,639 --> 00:07:10,560
one so which one is bigger depends on

195
00:07:10,560 --> 00:07:12,800
the actual values of t in epsilon so you

196
00:07:12,800 --> 00:07:15,680
can just use a lambda to be log t

197
00:07:15,680 --> 00:07:17,680
squared instead of log t squared over

198
00:07:17,680 --> 00:07:18,720
epsilon

199
00:07:18,720 --> 00:07:21,120
okay and the argument size is roughly q

200
00:07:21,120 --> 00:07:23,599
q is the number of pcp queries times

201
00:07:23,599 --> 00:07:25,520
lambda times again okay so these are

202
00:07:25,520 --> 00:07:27,360
paths every path

203
00:07:27,360 --> 00:07:29,919
has a longer nodes and nodes number bits

204
00:07:29,919 --> 00:07:33,198
and you have a few of them

205
00:07:33,360 --> 00:07:36,240
um it's not only a theoretical result it

206
00:07:36,240 --> 00:07:38,160
actually gives concrete

207
00:07:38,160 --> 00:07:40,240
benefits so we really worked very hard

208
00:07:40,240 --> 00:07:42,639
on the constants of these theorems

209
00:07:42,639 --> 00:07:45,520
um so you can see we we compared our

210
00:07:45,520 --> 00:07:48,000
analysis with the standard analysis of

211
00:07:48,000 --> 00:07:51,120
of the micalli on some standard pcp that

212
00:07:51,120 --> 00:07:53,840
we repeated and you can see the the

213
00:07:53,840 --> 00:07:56,000
gains that we that we get as a function

214
00:07:56,000 --> 00:07:58,479
of ft

215
00:07:58,479 --> 00:08:00,960
so between like 20 and 40

216
00:08:00,960 --> 00:08:03,120
improvement

217
00:08:03,120 --> 00:08:06,160
yeah just one quick slide on the on the

218
00:08:06,160 --> 00:08:07,199
both

219
00:08:07,199 --> 00:08:08,160
if the

220
00:08:08,160 --> 00:08:10,000
prior analysis said how do we get

221
00:08:10,000 --> 00:08:11,919
security for mikali we just assumed that

222
00:08:11,919 --> 00:08:13,840
the bill that the proverbial founder

223
00:08:13,840 --> 00:08:16,000
collisions already in belgium and this

224
00:08:16,000 --> 00:08:18,400
cost us in the probability okay so we

225
00:08:18,400 --> 00:08:20,800
had to condition on this event and once

226
00:08:20,800 --> 00:08:23,440
you did that you could just um reduce

227
00:08:23,440 --> 00:08:25,680
back to the ptp soundness

228
00:08:25,680 --> 00:08:28,160
what we do we actually give

229
00:08:28,160 --> 00:08:30,080
we cannot just stop the analysis once we

230
00:08:30,080 --> 00:08:31,520
found the collisions we're going to

231
00:08:31,520 --> 00:08:32,880
score how many correlation and

232
00:08:32,880 --> 00:08:35,200
evaluations he did

233
00:08:35,200 --> 00:08:37,919
and we gave a probability for each scope

234
00:08:37,919 --> 00:08:39,440
and then we reduced it to a different

235
00:08:39,440 --> 00:08:40,640
game that we introduced with the

236
00:08:40,640 --> 00:08:42,159
soundness game

237
00:08:42,159 --> 00:08:45,279
uh and we reduced this game to a very

238
00:08:45,279 --> 00:08:47,839
simple and but more stronger in the pcp

239
00:08:47,839 --> 00:08:49,519
reveals on this game and this one we

240
00:08:49,519 --> 00:08:52,880
built from p60 sounds

241
00:08:52,880 --> 00:08:54,720
um

242
00:08:54,720 --> 00:08:55,680
oops

243
00:08:55,680 --> 00:08:57,600
okay sorry

244
00:08:57,600 --> 00:09:01,440
yeah so that's it i'm done with this

245
00:09:01,440 --> 00:09:03,760
thank you

246
00:09:07,040 --> 00:09:09,839
we have any questions

247
00:09:14,399 --> 00:09:16,480
from the chat

248
00:09:16,480 --> 00:09:20,279
all right thank you so much

249
00:09:20,530 --> 00:09:22,560
[Music]

250
00:09:22,560 --> 00:09:26,160
next talk is a fully succinct publicly

251
00:09:26,160 --> 00:09:28,320
verifiable delegation from constantine

252
00:09:28,320 --> 00:09:29,600
consumption

253
00:09:29,600 --> 00:09:32,800
by alonso alexandros and alonso is going

254
00:09:32,800 --> 00:09:34,320
to give the talk

255
00:09:34,320 --> 00:09:35,440
okay

256
00:09:35,440 --> 00:09:37,200
hello everybody

257
00:09:37,200 --> 00:09:38,160
um

258
00:09:38,160 --> 00:09:40,480
i suppose you can hear me

259
00:09:40,480 --> 00:09:43,760
um okay so let's start with here

260
00:09:43,760 --> 00:09:46,080
so this work is about delegation and in

261
00:09:46,080 --> 00:09:48,399
navigation scheme we have a

262
00:09:48,399 --> 00:09:50,399
verifier which has some

263
00:09:50,399 --> 00:09:52,000
heavy but still pretty normal time

264
00:09:52,000 --> 00:09:53,200
computation

265
00:09:53,200 --> 00:09:55,519
and this verifier would like to delegate

266
00:09:55,519 --> 00:09:57,680
this computation to a more powerful but

267
00:09:57,680 --> 00:10:00,240
also still polynomial time proven okay

268
00:10:00,240 --> 00:10:02,640
so the computation here is some circuit

269
00:10:02,640 --> 00:10:04,560
we should input x

270
00:10:04,560 --> 00:10:07,040
should output y okay so the approver has

271
00:10:07,040 --> 00:10:09,120
more time and do the computation and

272
00:10:09,120 --> 00:10:10,880
also produce some proof

273
00:10:10,880 --> 00:10:12,959
which is sent to the verifier and the

274
00:10:12,959 --> 00:10:15,040
verifier checks the proof and checking

275
00:10:15,040 --> 00:10:16,560
the proof will

276
00:10:16,560 --> 00:10:18,079
convince the verifier that the

277
00:10:18,079 --> 00:10:20,160
computation was done correctly but

278
00:10:20,160 --> 00:10:21,360
importantly

279
00:10:21,360 --> 00:10:23,760
it's more it must be much cheaper than

280
00:10:23,760 --> 00:10:27,200
uh just evaluating the secret okay

281
00:10:27,200 --> 00:10:28,160
so

282
00:10:28,160 --> 00:10:29,920
um

283
00:10:29,920 --> 00:10:31,839
so in other words delegation scheme is

284
00:10:31,839 --> 00:10:33,519
not for for p

285
00:10:33,519 --> 00:10:35,920
okay so we can compare with other

286
00:10:35,920 --> 00:10:38,480
construction for example a smartphone p

287
00:10:38,480 --> 00:10:40,399
we can start with something which is

288
00:10:40,399 --> 00:10:42,079
very interesting in practice because

289
00:10:42,079 --> 00:10:44,480
it's quite efficient such as growth

290
00:10:44,480 --> 00:10:46,399
system so it's a snack

291
00:10:46,399 --> 00:10:48,560
for any np statement

292
00:10:48,560 --> 00:10:50,240
and it's attractive because the size of

293
00:10:50,240 --> 00:10:52,399
the proof is what we call here fully

294
00:10:52,399 --> 00:10:54,160
succinct so the size of the proof is

295
00:10:54,160 --> 00:10:56,640
just a constant number of groups of

296
00:10:56,640 --> 00:10:58,560
elements in a linear group and

297
00:10:58,560 --> 00:11:00,240
verification is just a constant number

298
00:11:00,240 --> 00:11:02,160
of pairings but the problem is that the

299
00:11:02,160 --> 00:11:03,440
assumption

300
00:11:03,440 --> 00:11:06,079
is not falsifiable any pain indeed so

301
00:11:06,079 --> 00:11:07,839
you need an unfalsifial assumption for a

302
00:11:07,839 --> 00:11:10,399
snark for mp

303
00:11:10,399 --> 00:11:11,600
if you

304
00:11:11,600 --> 00:11:13,200
want to avoid

305
00:11:13,200 --> 00:11:14,720
non-falsifiable assumptions so you need

306
00:11:14,720 --> 00:11:16,560
to reduce the exclusivity

307
00:11:16,560 --> 00:11:19,600
and you get with some kind of so

308
00:11:19,600 --> 00:11:21,680
you start to work with delegation

309
00:11:21,680 --> 00:11:23,600
and for example we have the work of

310
00:11:23,600 --> 00:11:26,079
kalei panjang at stock19

311
00:11:26,079 --> 00:11:28,560
where they get a better assumption so we

312
00:11:28,560 --> 00:11:30,399
don't they don't uh have an

313
00:11:30,399 --> 00:11:32,079
unfalsifiable assumption but uh q

314
00:11:32,079 --> 00:11:33,600
assumptions an assumption that grows

315
00:11:33,600 --> 00:11:35,760
with the size of the problem but now the

316
00:11:35,760 --> 00:11:37,200
the size of the proof is not fully

317
00:11:37,200 --> 00:11:39,680
succinct but grows a little with the

318
00:11:39,680 --> 00:11:42,240
with the size of the computation okay we

319
00:11:42,240 --> 00:11:44,399
also have the work of uh panetta and

320
00:11:44,399 --> 00:11:46,079
tottenham which is

321
00:11:46,079 --> 00:11:48,720
uh so this work is based on this one and

322
00:11:48,720 --> 00:11:51,120
has a another assumption which is based

323
00:11:51,120 --> 00:11:51,839
on

324
00:11:51,839 --> 00:11:54,720
sophistication or

325
00:11:54,959 --> 00:11:56,639
um montenegro the good thing is that

326
00:11:56,639 --> 00:11:58,240
this is based on on

327
00:11:58,240 --> 00:12:00,320
non-falsifiable assumptions okay but

328
00:12:00,320 --> 00:12:01,680
still we would would like to have

329
00:12:01,680 --> 00:12:03,760
something like blood system but based on

330
00:12:03,760 --> 00:12:05,920
falsifiable assumptions and the only

331
00:12:05,920 --> 00:12:07,440
thing that there is in in the literature

332
00:12:07,440 --> 00:12:09,839
like which is like that is what is known

333
00:12:09,839 --> 00:12:11,839
as quasi-adaptive interactive knowledge

334
00:12:11,839 --> 00:12:12,800
proofs

335
00:12:12,800 --> 00:12:14,880
and they have similar proof size and

336
00:12:14,880 --> 00:12:16,639
verification time

337
00:12:16,639 --> 00:12:18,560
um it's based on very good assumptions

338
00:12:18,560 --> 00:12:21,680
so basically mbds or delete

339
00:12:21,680 --> 00:12:23,200
but the problem is that the expressivity

340
00:12:23,200 --> 00:12:25,120
is quite low it's just for linear

341
00:12:25,120 --> 00:12:27,279
languages and some very specific

342
00:12:27,279 --> 00:12:29,120
quadratic languages so what we do in

343
00:12:29,120 --> 00:12:32,320
this work we take qnc and using these

344
00:12:32,320 --> 00:12:34,959
techniques from from this work and

345
00:12:34,959 --> 00:12:37,519
some other words we extend exclusivity

346
00:12:37,519 --> 00:12:39,200
until we reach uh

347
00:12:39,200 --> 00:12:40,959
p you know and we get a delegation

348
00:12:40,959 --> 00:12:42,480
scheme

349
00:12:42,480 --> 00:12:44,320
and our approach is as follows so we

350
00:12:44,320 --> 00:12:45,200
start

351
00:12:45,200 --> 00:12:47,120
our building block is going to be qn6

352
00:12:47,120 --> 00:12:48,800
because they have what we want you know

353
00:12:48,800 --> 00:12:50,320
so we want a very

354
00:12:50,320 --> 00:12:52,399
very short proof size

355
00:12:52,399 --> 00:12:54,000
and also verification a very good

356
00:12:54,000 --> 00:12:56,160
verification time and be based on

357
00:12:56,160 --> 00:12:58,720
constant size assumptions such as vds or

358
00:12:58,720 --> 00:13:01,120
the decisional limiting assumption

359
00:13:01,120 --> 00:13:03,600
and we use the technique of penetrating

360
00:13:03,600 --> 00:13:05,440
clipping yank of no seeing any

361
00:13:05,440 --> 00:13:06,639
extraction

362
00:13:06,639 --> 00:13:07,600
and

363
00:13:07,600 --> 00:13:09,040
so and we combine the techniques with

364
00:13:09,040 --> 00:13:12,480
qamc so that um

365
00:13:12,480 --> 00:13:14,160
we can get this

366
00:13:14,160 --> 00:13:16,320
this argument with no signal extraction

367
00:13:16,320 --> 00:13:17,920
with good proof size and good

368
00:13:17,920 --> 00:13:20,800
assumptions and we use the technique to

369
00:13:20,800 --> 00:13:22,399
build a delegation scheme but for

370
00:13:22,399 --> 00:13:24,639
bounded with circuits okay and

371
00:13:24,639 --> 00:13:25,519
so

372
00:13:25,519 --> 00:13:27,360
and we get a delegation for bonding with

373
00:13:27,360 --> 00:13:29,440
circuits from the limb

374
00:13:29,440 --> 00:13:31,519
and to get delegation for any circuit we

375
00:13:31,519 --> 00:13:34,399
use also our work from asic 19 which is

376
00:13:34,399 --> 00:13:36,639
delegation for bounded circuit which has

377
00:13:36,639 --> 00:13:39,440
some limitation was based on

378
00:13:39,440 --> 00:13:40,959
on key assumptions

379
00:13:40,959 --> 00:13:43,040
and we extend this technique to

380
00:13:43,040 --> 00:13:45,279
to be based on constant size assumption

381
00:13:45,279 --> 00:13:47,600
and from that we are able to build fully

382
00:13:47,600 --> 00:13:49,279
16 delegation

383
00:13:49,279 --> 00:13:51,360
from the lean and with very

384
00:13:51,360 --> 00:13:52,480
so

385
00:13:52,480 --> 00:13:55,440
with fully 16 proofs and verification

386
00:13:55,440 --> 00:13:57,600
and we proceed as follows so we start

387
00:13:57,600 --> 00:13:58,639
from

388
00:13:58,639 --> 00:14:01,199
from a very very high level overview we

389
00:14:01,199 --> 00:14:04,000
start from from a circuit

390
00:14:04,000 --> 00:14:06,000
and we use the our techniques for

391
00:14:06,000 --> 00:14:08,160
matching 18

392
00:14:08,160 --> 00:14:10,160
for compressing the

393
00:14:10,160 --> 00:14:11,839
for compressing the circuit so kind of

394
00:14:11,839 --> 00:14:13,839
compressing the width you know and we

395
00:14:13,839 --> 00:14:16,560
end up with some some proof which is

396
00:14:16,560 --> 00:14:19,199
which grows only with the depth and not

397
00:14:19,199 --> 00:14:21,519
with the with the width of the silk

398
00:14:21,519 --> 00:14:23,199
and then um

399
00:14:23,199 --> 00:14:26,079
we apply the techniques of calipanian so

400
00:14:26,079 --> 00:14:28,480
and we adapt also the techniques to

401
00:14:28,480 --> 00:14:30,800
to be based on on constant size

402
00:14:30,800 --> 00:14:34,560
assumption and we basically give uh

403
00:14:34,560 --> 00:14:36,560
um

404
00:14:36,560 --> 00:14:37,360
a

405
00:14:37,360 --> 00:14:40,240
proof for this statement and now we end

406
00:14:40,240 --> 00:14:44,160
up with a very short

407
00:14:44,160 --> 00:14:45,600
very short proof

408
00:14:45,600 --> 00:14:47,839
for this concept

409
00:14:47,839 --> 00:14:50,800
and this is the epic

410
00:14:57,120 --> 00:15:01,279
thank you alonso any question for alonso

411
00:15:03,600 --> 00:15:06,480
okay so we have no questions from

412
00:15:06,480 --> 00:15:09,120
the audience

413
00:15:09,920 --> 00:15:11,760
okay thank you so much alex again for

414
00:15:11,760 --> 00:15:14,160
your talk

415
00:15:19,920 --> 00:15:23,440
next paper is unexpected polynomial

416
00:15:23,440 --> 00:15:25,519
runtime in cryptography

417
00:15:25,519 --> 00:15:27,120
by michael claus

418
00:15:27,120 --> 00:15:28,079
cross

419
00:15:28,079 --> 00:15:32,319
and michael is going to give the talk

420
00:15:33,040 --> 00:15:35,040
i can see the slides

421
00:15:35,040 --> 00:15:36,560
yes

422
00:15:36,560 --> 00:15:38,720
okay yeah thank you for the introduction

423
00:15:38,720 --> 00:15:40,639
i'm going to talk about expected body

424
00:15:40,639 --> 00:15:42,720
time and cryptography

425
00:15:42,720 --> 00:15:44,959
and so why do we care about expected

426
00:15:44,959 --> 00:15:46,320
party time

427
00:15:46,320 --> 00:15:48,720
in zero knowledge so the reason is that

428
00:15:48,720 --> 00:15:49,839
we know that

429
00:15:49,839 --> 00:15:52,560
we can't we can we cannot have strict

430
00:15:52,560 --> 00:15:54,399
polytime simulation

431
00:15:54,399 --> 00:15:56,639
for constant round black boxer knowledge

432
00:15:56,639 --> 00:15:58,800
with negligible soundless error in the

433
00:15:58,800 --> 00:16:00,240
plane model

434
00:16:00,240 --> 00:16:02,560
and that's the reason to relax in

435
00:16:02,560 --> 00:16:05,199
relation to expected polytime simulation

436
00:16:05,199 --> 00:16:07,040
but still keep the verifier strict

437
00:16:07,040 --> 00:16:08,639
pulley

438
00:16:08,639 --> 00:16:09,680
now

439
00:16:09,680 --> 00:16:11,839
this kind of breaks the promise of zero

440
00:16:11,839 --> 00:16:13,759
knowledge because the verifier cannot

441
00:16:13,759 --> 00:16:15,759
actually run the simulator in its head

442
00:16:15,759 --> 00:16:18,079
anymore and also we run into

443
00:16:18,079 --> 00:16:20,720
composibility problems because if we

444
00:16:20,720 --> 00:16:23,040
apply a simulation to an adversary we

445
00:16:23,040 --> 00:16:24,959
obtain a new adversary which is now

446
00:16:24,959 --> 00:16:27,839
expected probably so we cannot

447
00:16:27,839 --> 00:16:29,839
run a simulation on this again because

448
00:16:29,839 --> 00:16:31,360
we cannot handle expected poly

449
00:16:31,360 --> 00:16:32,560
adversaries

450
00:16:32,560 --> 00:16:34,880
so what we try to do now is we try to

451
00:16:34,880 --> 00:16:38,079
deal with expected poly adversaries

452
00:16:38,079 --> 00:16:39,920
the first thing is we actually have

453
00:16:39,920 --> 00:16:41,920
several possible definitions of what it

454
00:16:41,920 --> 00:16:44,560
means to be an expected poli adversary

455
00:16:44,560 --> 00:16:46,959
and the definition we use are what we

456
00:16:46,959 --> 00:16:49,040
call designated adversaries that is an

457
00:16:49,040 --> 00:16:50,800
adversary which is efficient in the

458
00:16:50,800 --> 00:16:53,519
protocol it is designed to attack

459
00:16:53,519 --> 00:16:56,240
but not necessarily in any other context

460
00:16:56,240 --> 00:16:58,480
so this is a very natural definition

461
00:16:58,480 --> 00:17:01,040
with strict ppt bones you

462
00:17:01,040 --> 00:17:02,959
usually just assume that the

463
00:17:02,959 --> 00:17:04,319
adversary will be efficient in any

464
00:17:04,319 --> 00:17:05,599
context because you have this strict

465
00:17:05,599 --> 00:17:07,919
bound and you can just they just say it

466
00:17:07,919 --> 00:17:10,319
will never run longer than

467
00:17:10,319 --> 00:17:11,599
poli steps

468
00:17:11,599 --> 00:17:14,400
but without this strict bound you you

469
00:17:14,400 --> 00:17:17,199
yeah you need some way to say

470
00:17:17,199 --> 00:17:19,199
how how efficient it is and when it's

471
00:17:19,199 --> 00:17:22,000
efficient and we use this a very

472
00:17:22,000 --> 00:17:24,720
admissible definition

473
00:17:24,720 --> 00:17:27,599
so now let's look at why things go wrong

474
00:17:27,599 --> 00:17:29,919
when we try to deal with designated

475
00:17:29,919 --> 00:17:32,480
expected poly adversaries and for this

476
00:17:32,480 --> 00:17:34,799
we look at this very simplified example

477
00:17:34,799 --> 00:17:36,160
so we have this algorithm a which

478
00:17:36,160 --> 00:17:38,400
computes the identity by first sampling

479
00:17:38,400 --> 00:17:40,640
a long random string and if the string

480
00:17:40,640 --> 00:17:42,559
happens to be all zeros it will return x

481
00:17:42,559 --> 00:17:44,720
otherwise it will also return x now

482
00:17:44,720 --> 00:17:46,960
clearly a is efficient

483
00:17:46,960 --> 00:17:49,280
and this variation b

484
00:17:49,280 --> 00:17:50,720
does the same except it will loop

485
00:17:50,720 --> 00:17:52,640
forever if this random string is all

486
00:17:52,640 --> 00:17:55,200
zeros and clearly b is not efficient um

487
00:17:55,200 --> 00:17:57,200
b is not strictly bounded b is not even

488
00:17:57,200 --> 00:17:59,520
expected poly but it's b really not

489
00:17:59,520 --> 00:18:00,640
efficient

490
00:18:00,640 --> 00:18:01,440
so

491
00:18:01,440 --> 00:18:03,360
if you want to use

492
00:18:03,360 --> 00:18:05,280
a or b as a subroutine

493
00:18:05,280 --> 00:18:07,120
you would only care about the i o

494
00:18:07,120 --> 00:18:09,440
behavior and the resources these

495
00:18:09,440 --> 00:18:11,520
routines need and the resource we care

496
00:18:11,520 --> 00:18:13,280
about is time

497
00:18:13,280 --> 00:18:15,840
and well as as black boxes where you can

498
00:18:15,840 --> 00:18:18,240
see how much resources they use so as

499
00:18:18,240 --> 00:18:20,160
timed black boxes here these are

500
00:18:20,160 --> 00:18:22,400
actually indistinguishable

501
00:18:22,400 --> 00:18:24,720
at least for poly many tries

502
00:18:24,720 --> 00:18:26,799
and well this is the core problem we run

503
00:18:26,799 --> 00:18:27,600
into

504
00:18:27,600 --> 00:18:29,280
indistinguishability does not preserve

505
00:18:29,280 --> 00:18:31,520
efficiency and we actually just saw that

506
00:18:31,520 --> 00:18:33,120
statistical indistinguishability does

507
00:18:33,120 --> 00:18:34,960
not preserve efficiency

508
00:18:34,960 --> 00:18:37,600
and this raises the question

509
00:18:37,600 --> 00:18:39,280
if an algorithm is indistinguishable

510
00:18:39,280 --> 00:18:42,799
from efficient isn't it efficient and

511
00:18:42,799 --> 00:18:44,240
this is

512
00:18:44,240 --> 00:18:45,840
the core idea

513
00:18:45,840 --> 00:18:47,840
which inspired our relaxation of

514
00:18:47,840 --> 00:18:50,160
expected polytime namely we define

515
00:18:50,160 --> 00:18:52,559
computationally expected polytime and

516
00:18:52,559 --> 00:18:54,559
for this we just need to clarify a few

517
00:18:54,559 --> 00:18:57,600
things namely what do we mean by runtime

518
00:18:57,600 --> 00:18:59,520
a runtime is just a family of random

519
00:18:59,520 --> 00:19:02,320
variables and what is expected polytime

520
00:19:02,320 --> 00:19:04,240
well expected product time just means

521
00:19:04,240 --> 00:19:06,799
that the expectation of this family is

522
00:19:06,799 --> 00:19:08,720
bounded by a polynomial in the security

523
00:19:08,720 --> 00:19:10,240
parameter and here we only have

524
00:19:10,240 --> 00:19:12,240
asymptotics in the security parameter

525
00:19:12,240 --> 00:19:14,320
nothing else

526
00:19:14,320 --> 00:19:16,559
now computationally expected polytime or

527
00:19:16,559 --> 00:19:17,440
set

528
00:19:17,440 --> 00:19:18,240
is

529
00:19:18,240 --> 00:19:19,840
defined as follows

530
00:19:19,840 --> 00:19:22,720
by a few equivalent

531
00:19:22,720 --> 00:19:24,960
conditions so t is set

532
00:19:24,960 --> 00:19:28,000
if there exists a runtime s

533
00:19:28,000 --> 00:19:29,360
which is

534
00:19:29,360 --> 00:19:31,520
perfectly expected poly in the usual

535
00:19:31,520 --> 00:19:33,919
sense and t and s are computationally

536
00:19:33,919 --> 00:19:37,360
indistinguishable so what i mean here is

537
00:19:37,360 --> 00:19:39,600
ppd distinguishes so the distinguisher

538
00:19:39,600 --> 00:19:42,080
has bounded runtime

539
00:19:42,080 --> 00:19:44,799
and it actually gets repeated access or

540
00:19:44,799 --> 00:19:46,559
poly many samples

541
00:19:46,559 --> 00:19:48,160
we could also allow sap distinguishes

542
00:19:48,160 --> 00:19:49,600
here but then the definition gets kind

543
00:19:49,600 --> 00:19:51,280
of recursive

544
00:19:51,280 --> 00:19:54,320
and this is also equivalent to allowing

545
00:19:54,320 --> 00:19:55,919
statistically indistinguishability which

546
00:19:55,919 --> 00:19:58,400
means poly many samples but unbounded

547
00:19:58,400 --> 00:20:00,559
runtime for this signature

548
00:20:00,559 --> 00:20:01,919
and this is equivalent to another

549
00:20:01,919 --> 00:20:04,080
definition which says that there exists

550
00:20:04,080 --> 00:20:05,919
a set of good events which has

551
00:20:05,919 --> 00:20:09,200
overwhelming probability and conditioned

552
00:20:09,200 --> 00:20:11,120
on this set of good events the

553
00:20:11,120 --> 00:20:13,600
expectation of t is actually bounded by

554
00:20:13,600 --> 00:20:16,080
a polynomial so in particular this last

555
00:20:16,080 --> 00:20:17,600
point says that

556
00:20:17,600 --> 00:20:20,559
sept is very close to the usual ept

557
00:20:20,559 --> 00:20:21,840
notion

558
00:20:21,840 --> 00:20:24,559
and whereas the point one says

559
00:20:24,559 --> 00:20:26,080
that you can

560
00:20:26,080 --> 00:20:28,640
under indistinguishable transitions you

561
00:20:28,640 --> 00:20:30,320
preserve set

562
00:20:30,320 --> 00:20:32,640
and with this let's come to our

563
00:20:32,640 --> 00:20:34,880
contribution so we define

564
00:20:34,880 --> 00:20:37,679
sept this relaxation of ept we provide

565
00:20:37,679 --> 00:20:39,360
some basic tools for obtaining

566
00:20:39,360 --> 00:20:41,520
efficiency from indistinguishability

567
00:20:41,520 --> 00:20:44,159
namely we provided adaptations of the

568
00:20:44,159 --> 00:20:46,400
usual standard reduction so a direct

569
00:20:46,400 --> 00:20:47,679
reduction

570
00:20:47,679 --> 00:20:49,679
and the hybrid lemma

571
00:20:49,679 --> 00:20:51,120
in this setting of designated

572
00:20:51,120 --> 00:20:52,559
adversaries

573
00:20:52,559 --> 00:20:54,640
and we show that we can now handle

574
00:20:54,640 --> 00:20:57,360
designated set adversaries in sap so we

575
00:20:57,360 --> 00:20:59,600
have symmetric runtime classes for

576
00:20:59,600 --> 00:21:01,840
simulator and verifier

577
00:21:01,840 --> 00:21:03,840
or adversary

578
00:21:03,840 --> 00:21:05,600
and finally let me know that we do pay a

579
00:21:05,600 --> 00:21:07,919
price for these nice properties because

580
00:21:07,919 --> 00:21:10,720
if you cannot rely on these basic tools

581
00:21:10,720 --> 00:21:14,799
um arguing efficiency can be quite hairy

582
00:21:14,799 --> 00:21:15,520
so

583
00:21:15,520 --> 00:21:17,840
thank you

584
00:21:22,240 --> 00:21:24,799
thank you michael hey i have a question

585
00:21:24,799 --> 00:21:27,440
yes yeah

586
00:21:27,440 --> 00:21:28,240
so

587
00:21:28,240 --> 00:21:29,919
can you go back to the slide with all

588
00:21:29,919 --> 00:21:32,080
the definitions

589
00:21:32,080 --> 00:21:33,520
yes

590
00:21:33,520 --> 00:21:36,159
no just one people didn't yeah

591
00:21:36,159 --> 00:21:38,480
um

592
00:21:39,200 --> 00:21:41,440
so you could also have a definition

593
00:21:41,440 --> 00:21:42,640
where

594
00:21:42,640 --> 00:21:45,919
you have a this bad event and condition

595
00:21:45,919 --> 00:21:48,080
i'm not bringing in the bad event

596
00:21:48,080 --> 00:21:52,158
the running time is strictly polynomial

597
00:21:53,840 --> 00:21:55,679
yeah you can

598
00:21:55,679 --> 00:21:58,320
define a computationally uh strict

599
00:21:58,320 --> 00:21:59,840
polytime

600
00:21:59,840 --> 00:22:01,440
you mean

601
00:22:01,440 --> 00:22:03,840
no i mean like equivalent to definition

602
00:22:03,840 --> 00:22:05,600
three

603
00:22:05,600 --> 00:22:09,840
only where i instead of expected

604
00:22:10,159 --> 00:22:12,640
instead of the expectation of tk

605
00:22:12,640 --> 00:22:15,840
i want to say that tk given gk is is

606
00:22:15,840 --> 00:22:18,959
strictly polynomial

607
00:22:19,280 --> 00:22:21,360
so ppt

608
00:22:21,360 --> 00:22:23,919
yeah strictly uh and a bound on the

609
00:22:23,919 --> 00:22:27,840
supreme yes you can do that

610
00:22:28,240 --> 00:22:30,480
yes

611
00:22:32,000 --> 00:22:33,760
but actually there's a prior work um

612
00:22:33,760 --> 00:22:36,960
whose techniques i also use um by

613
00:22:36,960 --> 00:22:39,840
hoefeins unrwa and malacata which calls

614
00:22:39,840 --> 00:22:41,360
that notion

615
00:22:41,360 --> 00:22:44,240
or a very very simulated it's basically

616
00:22:44,240 --> 00:22:46,880
this notion

617
00:22:46,880 --> 00:22:49,200
it's called ppt with overwhelming

618
00:22:49,200 --> 00:22:52,919
probability i think

619
00:22:55,919 --> 00:22:58,640
does this answer your question or

620
00:22:58,640 --> 00:23:00,320
yeah i didn't have a real question just

621
00:23:00,320 --> 00:23:02,000
wondering about this definition and

622
00:23:02,000 --> 00:23:04,799
where it sits like in this

623
00:23:04,799 --> 00:23:06,240
you know

624
00:23:06,240 --> 00:23:08,080
between all the equivalence they've

625
00:23:08,080 --> 00:23:10,320
showed

626
00:23:10,960 --> 00:23:12,400
yeah uh

627
00:23:12,400 --> 00:23:14,240
that would be i mean if you use a strict

628
00:23:14,240 --> 00:23:16,559
bound here you would you would move out

629
00:23:16,559 --> 00:23:19,200
of expected time of course um you would

630
00:23:19,200 --> 00:23:21,679
now be a small relaxation of strict time

631
00:23:21,679 --> 00:23:23,520
and actually this relaxation is used in

632
00:23:23,520 --> 00:23:27,360
some places so this offense um

633
00:23:27,679 --> 00:23:29,280
that one which is

634
00:23:29,280 --> 00:23:30,880
most closely related to this work

635
00:23:30,880 --> 00:23:33,679
definitely um but i've also seen it in

636
00:23:33,679 --> 00:23:36,919
other places

637
00:23:38,640 --> 00:23:40,320
all right guys

638
00:23:40,320 --> 00:23:43,760
are there more questions for michael

639
00:23:43,760 --> 00:23:46,300
okay thank you michael again

640
00:23:46,300 --> 00:23:49,629
[Applause]

641
00:23:50,799 --> 00:23:53,760
next talk is

642
00:23:54,000 --> 00:23:57,440
amortizing rate one ot and applications

643
00:23:57,440 --> 00:24:00,000
to pir and psi

644
00:24:00,000 --> 00:24:02,799
by melissa chase santanger muhammad

645
00:24:02,799 --> 00:24:05,799
azerbaiy

646
00:24:08,159 --> 00:24:10,000
is giving the talk

647
00:24:10,000 --> 00:24:11,760
thank you um

648
00:24:11,760 --> 00:24:14,240
thank you alexandra for the introduction

649
00:24:14,240 --> 00:24:17,360
um can you see my slides yes

650
00:24:17,360 --> 00:24:19,840
all right

651
00:24:20,080 --> 00:24:22,080
um so we start with the problem of

652
00:24:22,080 --> 00:24:24,799
oblivious transfer or ot for short which

653
00:24:24,799 --> 00:24:26,720
is a protocol between two parties a

654
00:24:26,720 --> 00:24:28,960
sender and a receiver where the sender

655
00:24:28,960 --> 00:24:32,640
has two messages m0 m1 each of length n

656
00:24:32,640 --> 00:24:34,799
and the receiver has a single bit b as

657
00:24:34,799 --> 00:24:37,520
input and from the ot protocol the

658
00:24:37,520 --> 00:24:39,679
receiver gets one of the two messages

659
00:24:39,679 --> 00:24:42,240
depending on his choice bit namely m sub

660
00:24:42,240 --> 00:24:45,200
b and the sender gets nothing

661
00:24:45,200 --> 00:24:46,960
in this work we're interested in two

662
00:24:46,960 --> 00:24:49,360
message ot where there are two messages

663
00:24:49,360 --> 00:24:51,279
sent between the two parties

664
00:24:51,279 --> 00:24:53,360
in particular in the first round the

665
00:24:53,360 --> 00:24:56,159
receiver will somehow encrypt his bit b

666
00:24:56,159 --> 00:24:57,919
and send to the sender and keep some

667
00:24:57,919 --> 00:24:59,360
secret state

668
00:24:59,360 --> 00:25:01,600
and then in the second round the the

669
00:25:01,600 --> 00:25:03,679
sender somehow encrypts

670
00:25:03,679 --> 00:25:05,840
her two messages and sent to the

671
00:25:05,840 --> 00:25:08,000
receiver and then the receiver can use

672
00:25:08,000 --> 00:25:11,440
the secret state to recover m sub b

673
00:25:11,440 --> 00:25:13,440
if we look at the message sent from the

674
00:25:13,440 --> 00:25:16,080
sender which we'll call ots

675
00:25:16,080 --> 00:25:18,159
and consider the ratio between the

676
00:25:18,159 --> 00:25:21,039
length of a single message m0 to the

677
00:25:21,039 --> 00:25:22,960
length of ots

678
00:25:22,960 --> 00:25:24,720
we know that information theoretically

679
00:25:24,720 --> 00:25:28,400
ots cannot be shorter than m0 so this

680
00:25:28,400 --> 00:25:30,720
ratio is at most one

681
00:25:30,720 --> 00:25:33,120
and in fact rate half is fairly easy to

682
00:25:33,120 --> 00:25:35,039
achieve in a generic way

683
00:25:35,039 --> 00:25:36,880
but in this work we are particularly

684
00:25:36,880 --> 00:25:39,120
interested in rate one ot where this

685
00:25:39,120 --> 00:25:42,799
ratio goes to one as n goes to infinity

686
00:25:42,799 --> 00:25:45,039
but then you might be wondering why why

687
00:25:45,039 --> 00:25:47,520
do we care about two message of t and y

688
00:25:47,520 --> 00:25:50,000
in particular right one

689
00:25:50,000 --> 00:25:51,760
let's look at the example of one out of

690
00:25:51,760 --> 00:25:53,919
four ot where the sender has four

691
00:25:53,919 --> 00:25:56,159
messages and the receiver wants to get

692
00:25:56,159 --> 00:25:59,279
one of them in particular m sub bc

693
00:25:59,279 --> 00:26:02,320
so the receiver has two uh choice bits b

694
00:26:02,320 --> 00:26:03,760
and c

695
00:26:03,760 --> 00:26:06,240
and we can uh we can achieve a one out

696
00:26:06,240 --> 00:26:08,720
of four ot from two message ot in the

697
00:26:08,720 --> 00:26:10,400
following way

698
00:26:10,400 --> 00:26:11,919
in the first round

699
00:26:11,919 --> 00:26:14,559
the receiver encrypts his two choice

700
00:26:14,559 --> 00:26:17,600
bits b and c and sent to the

701
00:26:17,600 --> 00:26:19,200
sender and keep

702
00:26:19,200 --> 00:26:22,480
two secret states stb and stc

703
00:26:22,480 --> 00:26:25,039
and then the sender first uses the

704
00:26:25,039 --> 00:26:27,360
encryption of c and this pair of

705
00:26:27,360 --> 00:26:30,400
messages to generate the ots message

706
00:26:30,400 --> 00:26:32,480
and then she generates another ots

707
00:26:32,480 --> 00:26:34,880
message using the encryption c and

708
00:26:34,880 --> 00:26:36,799
another pair of messages

709
00:26:36,799 --> 00:26:40,320
and then she will treat these two ots

710
00:26:40,320 --> 00:26:43,279
messages as a pair of messages to

711
00:26:43,279 --> 00:26:45,760
generate another ots message using the

712
00:26:45,760 --> 00:26:49,279
encryption b and sent to the receiver

713
00:26:49,279 --> 00:26:51,520
and then the receiver can first use stb

714
00:26:51,520 --> 00:26:54,799
to recover one of these ots messages

715
00:26:54,799 --> 00:26:57,600
and then use stc to recover the desired

716
00:26:57,600 --> 00:26:58,799
message

717
00:26:58,799 --> 00:27:01,039
so if you think about it the two message

718
00:27:01,039 --> 00:27:04,080
rt allows us to do one ot inside another

719
00:27:04,080 --> 00:27:06,720
ot inside another ot it allows for

720
00:27:06,720 --> 00:27:08,240
nested ot

721
00:27:08,240 --> 00:27:10,960
and the rate 1 property guarantees that

722
00:27:10,960 --> 00:27:13,760
the final ots message is not too much

723
00:27:13,760 --> 00:27:16,080
longer than the initial messages

724
00:27:16,080 --> 00:27:18,799
so the actual communication cost only

725
00:27:18,799 --> 00:27:21,679
grows linearly in the number of

726
00:27:21,679 --> 00:27:25,200
sequential ot's not exponentially

727
00:27:25,200 --> 00:27:27,679
the two message rate on ot allows us to

728
00:27:27,679 --> 00:27:30,960
do uh nestedot with low communication

729
00:27:30,960 --> 00:27:33,039
and this leads to more advanced

730
00:27:33,039 --> 00:27:35,120
applications where the sender has a

731
00:27:35,120 --> 00:27:37,440
large database and the receiver is

732
00:27:37,440 --> 00:27:39,279
interested in a particular location of

733
00:27:39,279 --> 00:27:40,960
the database but he doesn't want to

734
00:27:40,960 --> 00:27:44,000
reveal this location to the sender

735
00:27:44,000 --> 00:27:46,159
in these applications we can achieve

736
00:27:46,159 --> 00:27:48,960
this much communication where d is the

737
00:27:48,960 --> 00:27:50,960
size of the database and lambda is a

738
00:27:50,960 --> 00:27:53,279
security parameter so it doesn't have to

739
00:27:53,279 --> 00:27:55,840
grow linearly in the size of

740
00:27:55,840 --> 00:27:59,120
the database but only logarithmically

741
00:27:59,120 --> 00:28:00,880
and here is a list of more concrete

742
00:28:00,880 --> 00:28:03,760
applications including single server pir

743
00:28:03,760 --> 00:28:06,640
with polylog communication and psi with

744
00:28:06,640 --> 00:28:09,039
unbalanced sets where the communication

745
00:28:09,039 --> 00:28:10,399
only grows

746
00:28:10,399 --> 00:28:12,960
polylog in the size of the larger set

747
00:28:12,960 --> 00:28:15,279
and so on

748
00:28:15,279 --> 00:28:18,320
now can we achieve rate on ot

749
00:28:18,320 --> 00:28:20,080
the answer is yes

750
00:28:20,080 --> 00:28:22,640
the dam guard uric cryptosystem achieves

751
00:28:22,640 --> 00:28:25,360
rate on ot from the dcr assumption and

752
00:28:25,360 --> 00:28:28,320
the recent work by totally adol in 2019

753
00:28:28,320 --> 00:28:30,640
constructed right one of t from

754
00:28:30,640 --> 00:28:32,480
another primitive called travel hash

755
00:28:32,480 --> 00:28:34,960
functions which can be realized from

756
00:28:34,960 --> 00:28:37,760
various assumptions

757
00:28:37,760 --> 00:28:39,679
now let's take a step back and look at

758
00:28:39,679 --> 00:28:41,600
returnability again

759
00:28:41,600 --> 00:28:43,760
so far we have only focused on the

760
00:28:43,760 --> 00:28:46,159
standard communication which is rate one

761
00:28:46,159 --> 00:28:48,480
this is the best we can hope for

762
00:28:48,480 --> 00:28:52,240
but how about receiver communication

763
00:28:52,240 --> 00:28:53,919
so if we look at the rate on ot

764
00:28:53,919 --> 00:28:55,039
construction

765
00:28:55,039 --> 00:28:57,120
from ddh

766
00:28:57,120 --> 00:28:59,679
for the first bit of the messages

767
00:28:59,679 --> 00:29:02,159
the receiver needs to send order n

768
00:29:02,159 --> 00:29:04,080
group elements

769
00:29:04,080 --> 00:29:06,320
and this repeats for every bit of the

770
00:29:06,320 --> 00:29:08,640
messages so the overall receiver

771
00:29:08,640 --> 00:29:10,000
communication

772
00:29:10,000 --> 00:29:12,240
is roughly order n squared group

773
00:29:12,240 --> 00:29:14,080
elements

774
00:29:14,080 --> 00:29:16,320
a recent work by hyderabadi and

775
00:29:16,320 --> 00:29:18,799
ostrowski improved the communication

776
00:29:18,799 --> 00:29:21,279
from order n squared to order n group

777
00:29:21,279 --> 00:29:23,440
elements based on the power ddh

778
00:29:23,440 --> 00:29:24,480
assumption

779
00:29:24,480 --> 00:29:26,240
and the high level idea is to use a

780
00:29:26,240 --> 00:29:29,039
sliding window where the first bit uses

781
00:29:29,039 --> 00:29:31,679
these group elements the second bit uses

782
00:29:31,679 --> 00:29:34,480
these and so on

783
00:29:34,480 --> 00:29:37,600
so if you look at the 104 ot example the

784
00:29:37,600 --> 00:29:40,559
receiver needs to send two ot messages

785
00:29:40,559 --> 00:29:42,960
and each ot message consists of order

786
00:29:42,960 --> 00:29:45,679
and square group elements from ddh or

787
00:29:45,679 --> 00:29:49,039
order n group elements from power ddh

788
00:29:49,039 --> 00:29:51,360
and in the more advanced applications

789
00:29:51,360 --> 00:29:53,200
the receiver needs to send more ot

790
00:29:53,200 --> 00:29:56,240
messages particular and some polylogging

791
00:29:56,240 --> 00:29:58,799
and a party log in d and the number of

792
00:29:58,799 --> 00:30:01,520
ots is also some party login b so this

793
00:30:01,520 --> 00:30:04,320
becomes more expensive

794
00:30:04,320 --> 00:30:06,720
and in this work we ask the question of

795
00:30:06,720 --> 00:30:08,399
whether we can further reduce the

796
00:30:08,399 --> 00:30:10,799
receiver communication to save another

797
00:30:10,799 --> 00:30:12,720
polylog factor

798
00:30:12,720 --> 00:30:15,600
or if you think about it in another way

799
00:30:15,600 --> 00:30:17,760
can we somehow reuse some of the

800
00:30:17,760 --> 00:30:20,240
elements from the first ot message in

801
00:30:20,240 --> 00:30:22,799
the other ot messages to save a polylog

802
00:30:22,799 --> 00:30:24,559
factor

803
00:30:24,559 --> 00:30:25,919
and here is what

804
00:30:25,919 --> 00:30:27,360
we achieved

805
00:30:27,360 --> 00:30:29,520
so we proposed a new primitive called

806
00:30:29,520 --> 00:30:32,159
amortized storytellity which works as

807
00:30:32,159 --> 00:30:33,520
follows

808
00:30:33,520 --> 00:30:36,159
there are two phases an offline phase

809
00:30:36,159 --> 00:30:38,240
and an online phase

810
00:30:38,240 --> 00:30:40,320
in the offline phase the receiver sends

811
00:30:40,320 --> 00:30:42,000
order and square group elements to the

812
00:30:42,000 --> 00:30:44,880
sender and keeps some secret state

813
00:30:44,880 --> 00:30:46,880
and then in the online phase the sender

814
00:30:46,880 --> 00:30:48,960
is given a pair of messages and the

815
00:30:48,960 --> 00:30:51,200
receiver is given a choice bit then the

816
00:30:51,200 --> 00:30:54,000
receiver can use the secret state to

817
00:30:54,000 --> 00:30:56,559
generate an ot message and the sender

818
00:30:56,559 --> 00:30:58,799
will send back ots

819
00:30:58,799 --> 00:31:00,399
then the receiver can use the secret

820
00:31:00,399 --> 00:31:02,080
state to recover

821
00:31:02,080 --> 00:31:05,679
m sub b we still require the rate 1

822
00:31:05,679 --> 00:31:07,519
profit but now

823
00:31:07,519 --> 00:31:09,519
the communication from the receiver in

824
00:31:09,519 --> 00:31:12,080
the online phase becomes only a constant

825
00:31:12,080 --> 00:31:14,240
number of group elements

826
00:31:14,240 --> 00:31:16,240
and the online phase is not just a one

827
00:31:16,240 --> 00:31:18,559
time it can be reused for arbitrary

828
00:31:18,559 --> 00:31:20,080
number of times

829
00:31:20,080 --> 00:31:22,080
for example they're given another pair

830
00:31:22,080 --> 00:31:24,159
of messages and then and another choice

831
00:31:24,159 --> 00:31:26,480
bit and they can do this again for

832
00:31:26,480 --> 00:31:29,039
arbitrary number of times

833
00:31:29,039 --> 00:31:30,559
another nice property in our

834
00:31:30,559 --> 00:31:32,880
construction is that the secret state

835
00:31:32,880 --> 00:31:35,200
remains unchanged throughout the entire

836
00:31:35,200 --> 00:31:37,519
execution and this is crucial for some

837
00:31:37,519 --> 00:31:40,080
of our psi applications

838
00:31:40,080 --> 00:31:42,960
so this is amortized return ot and we

839
00:31:42,960 --> 00:31:44,480
can achieve

840
00:31:44,480 --> 00:31:46,880
this primitive based on the bilinear sx

841
00:31:46,880 --> 00:31:49,200
dh assumption where we assume a bilinear

842
00:31:49,200 --> 00:31:53,200
map where both g1 and g2 are ddh hard

843
00:31:53,200 --> 00:31:55,200
and we can further reduce the receiver

844
00:31:55,200 --> 00:31:57,679
offline communication to order n group

845
00:31:57,679 --> 00:32:00,159
elements based on the bilinear power ddh

846
00:32:00,159 --> 00:32:02,399
assumption where we additionally assume

847
00:32:02,399 --> 00:32:05,360
g1 is power dhart

848
00:32:05,360 --> 00:32:07,919
and using this primitive

849
00:32:07,919 --> 00:32:09,200
we can reduce

850
00:32:09,200 --> 00:32:10,480
the

851
00:32:10,480 --> 00:32:12,559
receiver communication in the more

852
00:32:12,559 --> 00:32:14,799
advanced applications to save a polylog

853
00:32:14,799 --> 00:32:16,000
factor

854
00:32:16,000 --> 00:32:18,399
or if you think about another way

855
00:32:18,399 --> 00:32:20,000
there's an offline phase where the

856
00:32:20,000 --> 00:32:21,440
receiver sends

857
00:32:21,440 --> 00:32:24,080
polylog group elements to the sender

858
00:32:24,080 --> 00:32:25,679
and then the receiver's online

859
00:32:25,679 --> 00:32:28,240
communication is reduced by a polylog

860
00:32:28,240 --> 00:32:30,320
factor and thus can repeat for arbitrary

861
00:32:30,320 --> 00:32:32,720
number of times

862
00:32:32,720 --> 00:32:35,200
so to summarize um

863
00:32:35,200 --> 00:32:37,200
we proposed a new primitive called

864
00:32:37,200 --> 00:32:39,360
amortized storage 100t where the

865
00:32:39,360 --> 00:32:41,760
receiver's offline communication

866
00:32:41,760 --> 00:32:44,159
is order n square group elements

867
00:32:44,159 --> 00:32:45,760
and then in the online phase the

868
00:32:45,760 --> 00:32:47,600
receiver's communication is just

869
00:32:47,600 --> 00:32:49,840
constant number of good elements and

870
00:32:49,840 --> 00:32:52,159
this can be done from the bilinear sx dh

871
00:32:52,159 --> 00:32:53,200
assumption

872
00:32:53,200 --> 00:32:55,120
we can further reduce the receiver's

873
00:32:55,120 --> 00:32:56,399
online communication

874
00:32:56,399 --> 00:32:58,720
to order and group elements based on the

875
00:32:58,720 --> 00:33:00,960
bilinear power ddh assumption

876
00:33:00,960 --> 00:33:03,519
and using this new primitive we can save

877
00:33:03,519 --> 00:33:05,519
the receiver's communication in a lot of

878
00:33:05,519 --> 00:33:08,640
applications including single server pir

879
00:33:08,640 --> 00:33:11,360
and unbalanced psi and so on and we'll

880
00:33:11,360 --> 00:33:15,120
have more optimizations in the paper

881
00:33:15,120 --> 00:33:18,158
that's it thank you

882
00:33:22,399 --> 00:33:24,959
any questions

883
00:33:30,240 --> 00:33:32,159
okay so there are no questions thank you

884
00:33:32,159 --> 00:33:34,480
again

885
00:33:37,600 --> 00:33:39,760
all right so next stop

886
00:33:39,760 --> 00:33:42,000
is um ring-based identity-based

887
00:33:42,000 --> 00:33:43,279
encryption

888
00:33:43,279 --> 00:33:46,159
asymptotically shorter mpk and tighter

889
00:33:46,159 --> 00:33:47,440
security

890
00:33:47,440 --> 00:33:49,760
this is a joint work uh

891
00:33:49,760 --> 00:33:50,799
perhaps

892
00:33:50,799 --> 00:33:53,039
thank

893
00:33:59,200 --> 00:34:02,240
thank you for the introduction

894
00:34:02,240 --> 00:34:04,880
uh can you can you see the screen now

895
00:34:04,880 --> 00:34:07,840
yes

896
00:34:09,280 --> 00:34:11,040
okay

897
00:34:11,040 --> 00:34:13,520
might be

898
00:34:14,320 --> 00:34:16,159
this little bit

899
00:34:16,159 --> 00:34:18,000
stopped now

900
00:34:18,000 --> 00:34:19,359
okay

901
00:34:19,359 --> 00:34:21,599
uh our paper is about lattice-based

902
00:34:21,599 --> 00:34:23,359
identity-based encryption asymptotically

903
00:34:23,359 --> 00:34:25,679
shorter than pk and the title security i

904
00:34:25,679 --> 00:34:28,079
am perhaps

905
00:34:28,079 --> 00:34:30,719
in our paper uh our contributions are

906
00:34:30,719 --> 00:34:32,480
reconstructed the

907
00:34:32,480 --> 00:34:33,679
lattice-based

908
00:34:33,679 --> 00:34:36,879
was more compact apk and improved

909
00:34:36,879 --> 00:34:38,879
improved security analysis of

910
00:34:38,879 --> 00:34:42,159
identity-based encryptions

911
00:34:42,320 --> 00:34:44,800
uh the lattice-based

912
00:34:44,800 --> 00:34:48,079
ibe with adaptively secure security is

913
00:34:48,079 --> 00:34:49,040
firstly

914
00:34:49,040 --> 00:34:52,399
introduced in the abb10 in which the mpk

915
00:34:52,399 --> 00:34:55,679
is consists of satellite matrixes and

916
00:34:55,679 --> 00:34:57,839
then there are many improvements

917
00:34:57,839 --> 00:34:58,640
and

918
00:34:58,640 --> 00:35:00,480
currently the most

919
00:35:00,480 --> 00:35:03,119
advanced construction is given by yamada

920
00:35:03,119 --> 00:35:06,480
17 in which the mpk is consists of omega

921
00:35:06,480 --> 00:35:07,599
lambda

922
00:35:07,599 --> 00:35:10,000
log lambda matrixes

923
00:35:10,000 --> 00:35:12,320
but their construction is implicit that

924
00:35:12,320 --> 00:35:14,240
means that we can give a concrete

925
00:35:14,240 --> 00:35:17,200
parameter for for his construction

926
00:35:17,200 --> 00:35:19,040
in our paper we give a ring-based

927
00:35:19,040 --> 00:35:21,040
identity based encryption uh in which

928
00:35:21,040 --> 00:35:24,320
the mpk is consists of omega 1

929
00:35:24,320 --> 00:35:26,960
ring vectors and we can give a concrete

930
00:35:26,960 --> 00:35:28,839
parameters for the

931
00:35:28,839 --> 00:35:30,800
ib uh

932
00:35:30,800 --> 00:35:32,880
the most important part for the

933
00:35:32,880 --> 00:35:36,400
construction of constructing a ibe

934
00:35:36,400 --> 00:35:38,800
is construct a partition function and

935
00:35:38,800 --> 00:35:40,400
the homomorphically evaluates of

936
00:35:40,400 --> 00:35:42,800
addition function so we because we first

937
00:35:42,800 --> 00:35:45,760
constructed a uh our partition function

938
00:35:45,760 --> 00:35:47,280
uh in which

939
00:35:47,280 --> 00:35:50,880
we give a basic hash and the basic rg is

940
00:35:50,880 --> 00:35:54,320
is this uh h of z is the ecc of c and

941
00:35:54,320 --> 00:35:56,880
alpha and we choose

942
00:35:56,880 --> 00:35:59,760
the r first place of the ecc and minus a

943
00:35:59,760 --> 00:36:01,760
random element beta

944
00:36:01,760 --> 00:36:03,839
which is in zp

945
00:36:03,839 --> 00:36:05,280
this is uh

946
00:36:05,280 --> 00:36:09,200
unsatisfies for the partitioning and we

947
00:36:09,200 --> 00:36:11,920
currently repeat the basic hash and we

948
00:36:11,920 --> 00:36:13,599
get a vector

949
00:36:13,599 --> 00:36:16,480
now this hash function is satisfies a

950
00:36:16,480 --> 00:36:19,040
partition partitioning property but we

951
00:36:19,040 --> 00:36:22,320
cannot able to construct a compact ibe

952
00:36:22,320 --> 00:36:25,119
so we embed this vector

953
00:36:25,119 --> 00:36:27,440
which is in zp

954
00:36:27,440 --> 00:36:29,680
in each element and we

955
00:36:29,680 --> 00:36:32,240
we just embed this vector into the x to

956
00:36:32,240 --> 00:36:33,599
the exponent

957
00:36:33,599 --> 00:36:36,480
here and we can construct using this uh

958
00:36:36,480 --> 00:36:38,640
one ring element we can construct the ib

959
00:36:38,640 --> 00:36:39,599
use

960
00:36:39,599 --> 00:36:42,000
more compact mpk

961
00:36:42,000 --> 00:36:44,560
for this to uh to homomorphically

962
00:36:44,560 --> 00:36:46,800
evaluate our hash function we introduced

963
00:36:46,800 --> 00:36:50,400
a a new technique we use a equality test

964
00:36:50,400 --> 00:36:52,240
the equality test is given the encoding

965
00:36:52,240 --> 00:36:56,079
of alpha i which is in zn and at j which

966
00:36:56,079 --> 00:36:57,680
is in z n

967
00:36:57,680 --> 00:36:59,599
it's a clear text

968
00:36:59,599 --> 00:37:02,640
and we want to homomorphically evaluate

969
00:37:02,640 --> 00:37:05,359
the equality test of this j and the r

970
00:37:05,359 --> 00:37:08,720
phi the previous techniques are uh

971
00:37:08,720 --> 00:37:11,200
firstly they they want a bit uh

972
00:37:11,200 --> 00:37:14,400
decompose uh the alpha i and

973
00:37:14,400 --> 00:37:17,040
bitwise compare with the j

974
00:37:17,040 --> 00:37:19,440
and we observe that in in the ring

975
00:37:19,440 --> 00:37:22,560
setting i when r is equals to z x over x

976
00:37:22,560 --> 00:37:25,200
to the n and it's a circular second

977
00:37:25,200 --> 00:37:28,320
atomic ring there's a function f of v

978
00:37:28,320 --> 00:37:29,760
which is one

979
00:37:29,760 --> 00:37:32,480
plus v to the v to the m minus one

980
00:37:32,480 --> 00:37:36,000
and if v is equal to x to the 0 and the

981
00:37:36,000 --> 00:37:38,000
sum is equals to m

982
00:37:38,000 --> 00:37:41,119
if v is not equal to x to 0

983
00:37:41,119 --> 00:37:42,640
this mistake

984
00:37:42,640 --> 00:37:45,520
and the sum is equals to 0 because the x

985
00:37:45,520 --> 00:37:48,400
to the m is 1 and the sum is equal to 0.

986
00:37:48,400 --> 00:37:51,280
so if you uh multiply it by m m inverse

987
00:37:51,280 --> 00:37:53,599
to the the harsh evaluation of x to the

988
00:37:53,599 --> 00:37:56,640
i so we can partition uh partitions

989
00:37:56,640 --> 00:37:59,359
whether the v is equal to alpha x to the

990
00:37:59,359 --> 00:38:01,839
r 0 or not

991
00:38:01,839 --> 00:38:04,560
so if we given the x to the alpha minus

992
00:38:04,560 --> 00:38:07,200
j so we can homomorphically come uh

993
00:38:07,200 --> 00:38:10,000
evaluate the the function f and then we

994
00:38:10,000 --> 00:38:12,240
can homomorphically write the equality

995
00:38:12,240 --> 00:38:14,720
test of this function so over

996
00:38:14,720 --> 00:38:17,119
homomorphic evaluation is only one ring

997
00:38:17,119 --> 00:38:19,280
vector this is the encoding of x does

998
00:38:19,280 --> 00:38:21,280
alpha minus one

999
00:38:21,280 --> 00:38:22,480
the previous

1000
00:38:22,480 --> 00:38:24,880
schemes are need log n

1001
00:38:24,880 --> 00:38:28,880
encoding or a gsw type encoding

1002
00:38:28,880 --> 00:38:30,960
and because they need a bit bitty

1003
00:38:30,960 --> 00:38:33,440
composition of rfi

1004
00:38:33,440 --> 00:38:35,359
or second the contribution is uh

1005
00:38:35,359 --> 00:38:38,240
improvement on the ibe security the

1006
00:38:38,240 --> 00:38:40,800
previous techniques are with using the

1007
00:38:40,800 --> 00:38:42,800
artificial board technique or without

1008
00:38:42,800 --> 00:38:44,560
artificial level technique

1009
00:38:44,560 --> 00:38:46,960
if if the reduction uses artificial

1010
00:38:46,960 --> 00:38:49,040
abort technique then the running time of

1011
00:38:49,040 --> 00:38:51,760
the reduction will increase a one hour

1012
00:38:51,760 --> 00:38:53,200
epsilon square

1013
00:38:53,200 --> 00:38:56,160
uh at this addition and if if the

1014
00:38:56,160 --> 00:38:58,240
reduction use the without artificial

1015
00:38:58,240 --> 00:39:00,880
upper technique then the advantage of

1016
00:39:00,880 --> 00:39:04,880
the reduction will last another epsilon

1017
00:39:04,880 --> 00:39:07,760
or our security analysis improves both

1018
00:39:07,760 --> 00:39:09,280
service artificial abort and without

1019
00:39:09,280 --> 00:39:11,200
artificial our technique

1020
00:39:11,200 --> 00:39:12,720
or analysis

1021
00:39:12,720 --> 00:39:13,599
needs

1022
00:39:13,599 --> 00:39:15,599
only one over absolute blow up in the

1023
00:39:15,599 --> 00:39:17,200
running time if you use this artificial

1024
00:39:17,200 --> 00:39:21,599
labor technique uh and only uh lost a

1025
00:39:21,599 --> 00:39:23,359
absence squared

1026
00:39:23,359 --> 00:39:26,560
if used without a visual upper technique

1027
00:39:26,560 --> 00:39:28,960
to give a better security analyst we use

1028
00:39:28,960 --> 00:39:31,359
the security framework of messenger and

1029
00:39:31,359 --> 00:39:32,720
walter

1030
00:39:32,720 --> 00:39:33,920
in which the challenge that the

1031
00:39:33,920 --> 00:39:37,599
adversary will able to abort the game

1032
00:39:37,599 --> 00:39:38,640
uh and

1033
00:39:38,640 --> 00:39:41,520
if is that alpha is not abort broadcast

1034
00:39:41,520 --> 00:39:42,960
probability and the beta is a

1035
00:39:42,960 --> 00:39:45,040
conditional success probability then the

1036
00:39:45,040 --> 00:39:47,599
advantage of the adversary is defined as

1037
00:39:47,599 --> 00:39:48,560
epsilon

1038
00:39:48,560 --> 00:39:52,160
alpha times 2 beta minus 1 squared

1039
00:39:52,160 --> 00:39:54,160
so use this framework

1040
00:39:54,160 --> 00:39:56,400
we can improve the previous uh

1041
00:39:56,400 --> 00:39:58,960
lattice-based identity-based encryptions

1042
00:39:58,960 --> 00:40:02,320
as the most important thing is analysis

1043
00:40:02,320 --> 00:40:04,480
game zero to game one where we use the

1044
00:40:04,480 --> 00:40:07,040
partitioning and other games are used i

1045
00:40:07,040 --> 00:40:10,319
just use the statistical distance or the

1046
00:40:10,319 --> 00:40:13,920
assumption of bringing out w e or lwe

1047
00:40:13,920 --> 00:40:15,119
so

1048
00:40:15,119 --> 00:40:17,680
in game zero the the reduction should

1049
00:40:17,680 --> 00:40:20,000
say random partitional function h

1050
00:40:20,000 --> 00:40:23,119
by randomly choosing the indexes and

1051
00:40:23,119 --> 00:40:24,960
and the reduction may use with

1052
00:40:24,960 --> 00:40:26,720
artificial labor technique or without

1053
00:40:26,720 --> 00:40:29,359
attraction level technique

1054
00:40:29,359 --> 00:40:31,520
so

1055
00:40:32,720 --> 00:40:33,920
sorry

1056
00:40:33,920 --> 00:40:35,599
and we give a

1057
00:40:35,599 --> 00:40:39,359
important uh lemma which is a alpha one

1058
00:40:39,359 --> 00:40:40,800
which is uh

1059
00:40:40,800 --> 00:40:43,200
the non-abortion anonymous uh

1060
00:40:43,200 --> 00:40:46,240
probability of adversary in game one is

1061
00:40:46,240 --> 00:40:48,560
larger than gamma amin which is a lower

1062
00:40:48,560 --> 00:40:50,560
bond of gamma the gamma is a

1063
00:40:50,560 --> 00:40:52,400
partitioning probability

1064
00:40:52,400 --> 00:40:55,359
for first id star which is

1065
00:40:55,359 --> 00:40:57,839
the challenge identity the hash of id

1066
00:40:57,839 --> 00:41:00,400
star is zero and the other identities is

1067
00:41:00,400 --> 00:41:02,960
the hash of identity is non-zero and

1068
00:41:02,960 --> 00:41:05,119
beta1 is larger than the ratio of a

1069
00:41:05,119 --> 00:41:08,880
gamma mean of gamma max times beta0

1070
00:41:08,880 --> 00:41:11,520
so if we let the ratio this ratio is

1071
00:41:11,520 --> 00:41:12,800
equals to one

1072
00:41:12,800 --> 00:41:15,119
one minus delta over four

1073
00:41:15,119 --> 00:41:17,280
then the epsilon one the advantage of

1074
00:41:17,280 --> 00:41:20,240
the adversary in game one is

1075
00:41:20,240 --> 00:41:22,240
approximately larger than epsilon zero

1076
00:41:22,240 --> 00:41:24,240
times gamma mean

1077
00:41:24,240 --> 00:41:26,400
so if the reduction will use this

1078
00:41:26,400 --> 00:41:29,599
artificial level technique

1079
00:41:29,680 --> 00:41:32,319
then the ratio is almost equals to one

1080
00:41:32,319 --> 00:41:33,599
over two

1081
00:41:33,599 --> 00:41:36,079
and to increase the ratio to 1 over

1082
00:41:36,079 --> 00:41:37,520
delta over 4

1083
00:41:37,520 --> 00:41:39,119
the reduction in

1084
00:41:39,119 --> 00:41:42,079
samples one over epsilon samples

1085
00:41:42,079 --> 00:41:43,520
if the reduction is the result of

1086
00:41:43,520 --> 00:41:45,680
division of our technique then the ratio

1087
00:41:45,680 --> 00:41:47,920
is exactly what we wanted and the

1088
00:41:47,920 --> 00:41:50,400
reduction loss will increase by a vector

1089
00:41:50,400 --> 00:41:51,599
of

1090
00:41:51,599 --> 00:41:53,040
epsilon squared

1091
00:41:53,040 --> 00:41:55,280
i know that the previous reductions will

1092
00:41:55,280 --> 00:41:58,400
need a one over epsilon square samples

1093
00:41:58,400 --> 00:42:00,319
or increase the reduction loss with a

1094
00:42:00,319 --> 00:42:03,359
factor of epsilon so we improve both

1095
00:42:03,359 --> 00:42:06,160
with artificial and without artificial

1096
00:42:06,160 --> 00:42:08,960
approved techniques

1097
00:42:08,960 --> 00:42:10,400
and thank you

1098
00:42:10,400 --> 00:42:13,640
any questions

1099
00:42:25,599 --> 00:42:27,359
thank you again

1100
00:42:27,359 --> 00:42:30,400
thank you

1101
00:42:30,400 --> 00:42:32,400
like so it will take five minutes to

1102
00:42:32,400 --> 00:42:34,319
read the others

1103
00:42:34,319 --> 00:42:37,040
it's our crafting key trees

1104
00:42:37,040 --> 00:42:38,880
efficiency management for overlapping

1105
00:42:38,880 --> 00:42:39,839
groups

1106
00:42:39,839 --> 00:42:42,400
is a joint work by joelle allman

1107
00:42:42,400 --> 00:42:44,880
benedict

1108
00:42:53,200 --> 00:42:56,400
mikhail or michael walter and benedict

1109
00:42:56,400 --> 00:42:59,040
will give the talk

1110
00:42:59,040 --> 00:43:01,119
thank you for the introduction

1111
00:43:01,119 --> 00:43:02,800
so yeah i'm going to present our paper

1112
00:43:02,800 --> 00:43:04,079
crafting key trees efficient key

1113
00:43:04,079 --> 00:43:05,680
management for overlapping groups and

1114
00:43:05,680 --> 00:43:08,160
this is joint work with joel ahat miguel

1115
00:43:08,160 --> 00:43:11,118
carbon guillermo

1116
00:43:11,440 --> 00:43:13,680
okay i'm going to start with a

1117
00:43:13,680 --> 00:43:16,160
quick reminder on what key trees are and

1118
00:43:16,160 --> 00:43:17,760
what they are used for

1119
00:43:17,760 --> 00:43:20,079
so the setting we are interested in we

1120
00:43:20,079 --> 00:43:22,160
there we have a group of users who wants

1121
00:43:22,160 --> 00:43:25,040
to agree on some group key and this key

1122
00:43:25,040 --> 00:43:26,480
is then supposed to secure the

1123
00:43:26,480 --> 00:43:28,560
communication within the group

1124
00:43:28,560 --> 00:43:30,240
and we assume this group to be long

1125
00:43:30,240 --> 00:43:33,599
lived so the users want to be able to

1126
00:43:33,599 --> 00:43:36,400
regularly refresh the key material known

1127
00:43:36,400 --> 00:43:37,680
to them

1128
00:43:37,680 --> 00:43:39,280
this is on one hand to achieve forward

1129
00:43:39,280 --> 00:43:41,200
secrecy but on the other hand

1130
00:43:41,200 --> 00:43:44,240
to recover from potential corruption

1131
00:43:44,240 --> 00:43:46,480
and a tool that is used quite often in

1132
00:43:46,480 --> 00:43:48,720
the setting are key trees so this would

1133
00:43:48,720 --> 00:43:50,960
be a directed tree

1134
00:43:50,960 --> 00:43:53,440
where the root corresponds to the group

1135
00:43:53,440 --> 00:43:55,920
key and the leaves correspond to the

1136
00:43:55,920 --> 00:43:57,119
users

1137
00:43:57,119 --> 00:43:58,640
and every node in this tree is

1138
00:43:58,640 --> 00:44:01,280
associated with a key pair of an

1139
00:44:01,280 --> 00:44:03,599
asymmetric encryption scheme

1140
00:44:03,599 --> 00:44:05,760
where the idea is that a user knows

1141
00:44:05,760 --> 00:44:09,119
exactly the secret keys of nodes which

1142
00:44:09,119 --> 00:44:12,160
lie on the path from their leaf to the

1143
00:44:12,160 --> 00:44:13,440
root

1144
00:44:13,440 --> 00:44:15,359
now if we assume

1145
00:44:15,359 --> 00:44:17,359
that one user got corrupted and now

1146
00:44:17,359 --> 00:44:19,680
wants to perform an update they could do

1147
00:44:19,680 --> 00:44:20,839
this as

1148
00:44:20,839 --> 00:44:23,440
follows so first they would

1149
00:44:23,440 --> 00:44:24,720
simply

1150
00:44:24,720 --> 00:44:27,359
generate fresh keys for every node on

1151
00:44:27,359 --> 00:44:29,359
their update path but then of course

1152
00:44:29,359 --> 00:44:31,200
they have to communicate this change to

1153
00:44:31,200 --> 00:44:32,640
the rest of the group

1154
00:44:32,640 --> 00:44:35,440
so to do so they would encrypt the new

1155
00:44:35,440 --> 00:44:38,160
key of a node to its to the public key

1156
00:44:38,160 --> 00:44:39,920
of its co-parent so this would be the

1157
00:44:39,920 --> 00:44:42,319
parent of this node which does not lie

1158
00:44:42,319 --> 00:44:45,440
on the update path but now users below

1159
00:44:45,440 --> 00:44:48,079
this node can decrypt recover the secret

1160
00:44:48,079 --> 00:44:49,760
key and then in turn recover the secret

1161
00:44:49,760 --> 00:44:52,880
keys up to the root

1162
00:44:52,960 --> 00:44:55,599
okay so the update cost in in this case

1163
00:44:55,599 --> 00:44:57,280
is simply the number of cipher texts

1164
00:44:57,280 --> 00:44:59,280
that have to be sent out so this would

1165
00:44:59,280 --> 00:45:02,000
be the length of the update path so if

1166
00:45:02,000 --> 00:45:04,240
we use balanced binary trees then this

1167
00:45:04,240 --> 00:45:05,680
would be logarithmic in the number of

1168
00:45:05,680 --> 00:45:08,078
users

1169
00:45:08,160 --> 00:45:09,760
and such key trees are used in the

1170
00:45:09,760 --> 00:45:11,520
construction for example of continuous

1171
00:45:11,520 --> 00:45:14,079
group key agreement so for example in

1172
00:45:14,079 --> 00:45:15,040
the

1173
00:45:15,040 --> 00:45:16,480
current message layer security

1174
00:45:16,480 --> 00:45:19,280
standardization effort but also for

1175
00:45:19,280 --> 00:45:21,040
building multicast encryption schemes so

1176
00:45:21,040 --> 00:45:22,960
here one would use symmetric encryption

1177
00:45:22,960 --> 00:45:24,079
instead

1178
00:45:24,079 --> 00:45:26,000
and as we've seen the update cost per

1179
00:45:26,000 --> 00:45:27,760
user is

1180
00:45:27,760 --> 00:45:29,920
logarithmic in the number of users and

1181
00:45:29,920 --> 00:45:32,160
this actually turns out to be optimal

1182
00:45:32,160 --> 00:45:35,760
with respect to the average update cost

1183
00:45:35,760 --> 00:45:38,000
now in this work we're interested in the

1184
00:45:38,000 --> 00:45:38,960
question

1185
00:45:38,960 --> 00:45:40,800
what if we have multiple potentially

1186
00:45:40,800 --> 00:45:42,400
overlapping groups

1187
00:45:42,400 --> 00:45:45,200
and in particular can we find solutions

1188
00:45:45,200 --> 00:45:47,440
that have a lower update cost

1189
00:45:47,440 --> 00:45:49,200
and then the trivial solution which

1190
00:45:49,200 --> 00:45:51,280
would be to simply build one balanced

1191
00:45:51,280 --> 00:45:54,720
tree for every single group

1192
00:45:54,720 --> 00:45:55,599
okay

1193
00:45:55,599 --> 00:45:57,920
so to this end we

1194
00:45:57,920 --> 00:46:00,400
introduce key graphs so in our setting

1195
00:46:00,400 --> 00:46:03,040
we have n users and we have k groups

1196
00:46:03,040 --> 00:46:05,200
each of which consists of some of the

1197
00:46:05,200 --> 00:46:06,240
users

1198
00:46:06,240 --> 00:46:09,280
and now a key graph for such a system

1199
00:46:09,280 --> 00:46:12,319
would require one sync for every

1200
00:46:12,319 --> 00:46:14,880
group which would serve as the group key

1201
00:46:14,880 --> 00:46:17,440
and for every user we would have want to

1202
00:46:17,440 --> 00:46:19,359
have one source

1203
00:46:19,359 --> 00:46:20,960
and now of course we have to

1204
00:46:20,960 --> 00:46:23,440
somehow enforce correctness and security

1205
00:46:23,440 --> 00:46:26,000
of this construction and i think what

1206
00:46:26,000 --> 00:46:28,560
it's quite naturally what we require is

1207
00:46:28,560 --> 00:46:30,160
that there should be a path from a

1208
00:46:30,160 --> 00:46:32,960
user's source to one of the things

1209
00:46:32,960 --> 00:46:34,800
exactly if the user is a member of the

1210
00:46:34,800 --> 00:46:35,920
corresponding

1211
00:46:35,920 --> 00:46:38,160
group

1212
00:46:38,880 --> 00:46:41,599
and our goal is to find now graphs which

1213
00:46:41,599 --> 00:46:44,000
have a small update cost so the update

1214
00:46:44,000 --> 00:46:46,560
cost of one user turns out to be just

1215
00:46:46,560 --> 00:46:47,839
the number of

1216
00:46:47,839 --> 00:46:50,560
nodes in in the graph they can reach

1217
00:46:50,560 --> 00:46:52,960
and we're interested in minimizing the

1218
00:46:52,960 --> 00:46:54,640
total update cost so this would be

1219
00:46:54,640 --> 00:46:57,440
simply the sum of the update cost of all

1220
00:46:57,440 --> 00:46:59,920
users

1221
00:46:59,920 --> 00:47:02,319
so okay let me spend the remaining time

1222
00:47:02,319 --> 00:47:04,079
to just give you a very rough idea of

1223
00:47:04,079 --> 00:47:05,760
our contributions

1224
00:47:05,760 --> 00:47:08,319
so we tackle this question in two

1225
00:47:08,319 --> 00:47:10,319
different settings the first one is an

1226
00:47:10,319 --> 00:47:11,920
asymptotic setting

1227
00:47:11,920 --> 00:47:13,280
so here we

1228
00:47:13,280 --> 00:47:17,040
have some fixed system of k groups

1229
00:47:17,040 --> 00:47:19,200
and now we let the number of users grow

1230
00:47:19,200 --> 00:47:21,680
in a way that leaves the relative size

1231
00:47:21,680 --> 00:47:23,440
of the groups but also the relative size

1232
00:47:23,440 --> 00:47:27,920
of their inter intersections constant

1233
00:47:27,920 --> 00:47:30,480
and in this setting we can compute the

1234
00:47:30,480 --> 00:47:33,040
optimal update cost of key graphs by

1235
00:47:33,040 --> 00:47:35,040
first approving a lower bound and then

1236
00:47:35,040 --> 00:47:36,079
giving a

1237
00:47:36,079 --> 00:47:38,880
matching construction and interestingly

1238
00:47:38,880 --> 00:47:40,960
as you can see in the table it turns out

1239
00:47:40,960 --> 00:47:42,319
that

1240
00:47:42,319 --> 00:47:44,400
this setting uh this this optimal update

1241
00:47:44,400 --> 00:47:45,920
cost actually does not depend on the

1242
00:47:45,920 --> 00:47:47,599
particular group system

1243
00:47:47,599 --> 00:47:50,160
but only on the number of users

1244
00:47:50,160 --> 00:47:52,720
and also as you can see um

1245
00:47:52,720 --> 00:47:54,400
we can save a factor which corresponds

1246
00:47:54,400 --> 00:47:55,920
to the average number of groups that

1247
00:47:55,920 --> 00:47:57,839
users are members of compared to the

1248
00:47:57,839 --> 00:47:59,920
trivial solution

1249
00:47:59,920 --> 00:48:03,119
but all of this comes with some caveats

1250
00:48:03,119 --> 00:48:05,440
so on one hand this asymptotic effect

1251
00:48:05,440 --> 00:48:08,160
actually can kick in quite slowly and on

1252
00:48:08,160 --> 00:48:10,240
the other hand those two solutions

1253
00:48:10,240 --> 00:48:11,920
from the channel actually perform quite

1254
00:48:11,920 --> 00:48:14,880
bad for certain natural

1255
00:48:14,880 --> 00:48:17,040
group systems

1256
00:48:17,040 --> 00:48:19,119
so we also investigate this question for

1257
00:48:19,119 --> 00:48:20,800
complete group systems

1258
00:48:20,800 --> 00:48:22,480
and there we have two

1259
00:48:22,480 --> 00:48:25,520
contributions so first we propose an

1260
00:48:25,520 --> 00:48:28,480
algorithm which computes key graphs

1261
00:48:28,480 --> 00:48:30,960
which seem better suited for complete

1262
00:48:30,960 --> 00:48:32,480
systems

1263
00:48:32,480 --> 00:48:34,960
and we then compute bounce on its update

1264
00:48:34,960 --> 00:48:36,400
costs that make it quite easy to compare

1265
00:48:36,400 --> 00:48:38,720
it to the trivial and the asymptotically

1266
00:48:38,720 --> 00:48:40,400
optimal solution

1267
00:48:40,400 --> 00:48:42,960
and it seems to do indeed better but

1268
00:48:42,960 --> 00:48:44,720
unfortunately due to some rounding

1269
00:48:44,720 --> 00:48:47,520
issues we cannot formally prove that

1270
00:48:47,520 --> 00:48:50,319
and overall i think the the question of

1271
00:48:50,319 --> 00:48:52,000
um optimality for

1272
00:48:52,000 --> 00:48:53,760
concrete group systems is an interesting

1273
00:48:53,760 --> 00:48:55,440
open question for future work so this

1274
00:48:55,440 --> 00:48:56,720
would be something like does our

1275
00:48:56,720 --> 00:48:58,000
algorithm

1276
00:48:58,000 --> 00:49:00,400
always produce an optimal solution or

1277
00:49:00,400 --> 00:49:02,240
maybe more general is it actually

1278
00:49:02,240 --> 00:49:04,720
possible to efficiently find the optimal

1279
00:49:04,720 --> 00:49:08,319
solution giving some root system

1280
00:49:08,319 --> 00:49:10,640
and finally the second contribution in

1281
00:49:10,640 --> 00:49:12,319
this for concrete systems is that we

1282
00:49:12,319 --> 00:49:14,319
derive lower bounds on the update cost

1283
00:49:14,319 --> 00:49:16,400
of continuous group key agreement

1284
00:49:16,400 --> 00:49:19,359
schemes and multicast encryption schemes

1285
00:49:19,359 --> 00:49:21,119
for multiple groups

1286
00:49:21,119 --> 00:49:23,359
and we do this in a symbolic model in

1287
00:49:23,359 --> 00:49:25,920
the style of dolef and yao

1288
00:49:25,920 --> 00:49:28,319
so here we consider schemes built from

1289
00:49:28,319 --> 00:49:30,319
certain building blocks concretely this

1290
00:49:30,319 --> 00:49:32,400
would be encryption schemes prgs and

1291
00:49:32,400 --> 00:49:34,720
sequent sharing and we model those

1292
00:49:34,720 --> 00:49:38,720
building blocks as idealized primitives

1293
00:49:38,720 --> 00:49:41,200
okay so i hope this gives some idea of

1294
00:49:41,200 --> 00:49:43,200
what we do in this work and if you're

1295
00:49:43,200 --> 00:49:45,680
interested please check out the longer

1296
00:49:45,680 --> 00:49:46,880
talk

1297
00:49:46,880 --> 00:49:48,960
and i'm happy to take questions thank

1298
00:49:48,960 --> 00:49:51,119
you

1299
00:49:54,079 --> 00:49:56,160
thank you verdict

1300
00:49:56,160 --> 00:49:59,118
do you have any questions

1301
00:50:02,319 --> 00:50:04,720
okay so there are no questions thank you

1302
00:50:04,720 --> 00:50:07,040
again

1303
00:50:10,160 --> 00:50:13,280
okay so last talk of the of this session

1304
00:50:13,280 --> 00:50:16,000
computational robust fast extractors for

1305
00:50:16,000 --> 00:50:18,880
crs dependent sources with minimal mean

1306
00:50:18,880 --> 00:50:20,079
entropy

1307
00:50:20,079 --> 00:50:21,760
this is a joint work by

1308
00:50:21,760 --> 00:50:23,119
henwen feng

1309
00:50:23,119 --> 00:50:23,920
and

1310
00:50:23,920 --> 00:50:25,119
kyung tang

1311
00:50:25,119 --> 00:50:28,720
and hanguin is going to give the talk

1312
00:50:32,720 --> 00:50:35,280
and when we cannot hear you

1313
00:50:35,280 --> 00:50:36,319
okay

1314
00:50:36,319 --> 00:50:39,119
okay can you hear me okay

1315
00:50:39,119 --> 00:50:40,720
thanks from introduction

1316
00:50:40,720 --> 00:50:41,599
um

1317
00:50:41,599 --> 00:50:43,839
like an environment structure a robotic

1318
00:50:43,839 --> 00:50:46,240
tracker can produce a perfect secret

1319
00:50:46,240 --> 00:50:49,280
from a weaker secret it also outputs a

1320
00:50:49,280 --> 00:50:52,480
public health stream and with it we can

1321
00:50:52,480 --> 00:50:55,520
later reproduce the same perfect secret

1322
00:50:55,520 --> 00:50:56,880
and this kept string in either

1323
00:50:56,880 --> 00:50:58,800
generalize the sale in conventional

1324
00:50:58,800 --> 00:51:00,480
realness tracker

1325
00:51:00,480 --> 00:51:03,040
regarding security besides privacy its

1326
00:51:03,040 --> 00:51:04,720
additional property low button

1327
00:51:04,720 --> 00:51:06,640
robustness insurance and any

1328
00:51:06,640 --> 00:51:08,720
manipulation on this half string will be

1329
00:51:08,720 --> 00:51:10,880
detected and rejected by the

1330
00:51:10,880 --> 00:51:13,280
reproduction algorithm so this primitive

1331
00:51:13,280 --> 00:51:15,760
is powerful and can serve as a one

1332
00:51:15,760 --> 00:51:17,760
message authentic authenticated

1333
00:51:17,760 --> 00:51:20,160
authenticated key exchange portal from

1334
00:51:20,160 --> 00:51:22,960
weak secret and if the weak circuit used

1335
00:51:22,960 --> 00:51:25,200
in the reproduction algorithm can be

1336
00:51:25,200 --> 00:51:27,359
closed but not identical to the original

1337
00:51:27,359 --> 00:51:29,280
one we can call this

1338
00:51:29,280 --> 00:51:32,880
this primitive robust valid tracker

1339
00:51:32,880 --> 00:51:34,960
for clean model and information

1340
00:51:34,960 --> 00:51:37,359
theoretically robust extractors there is

1341
00:51:37,359 --> 00:51:39,920
a tesla bound that is if there is a

1342
00:51:39,920 --> 00:51:42,240
construction working for all secret

1343
00:51:42,240 --> 00:51:44,480
sources with ambitions and the game

1344
00:51:44,480 --> 00:51:45,599
entropy

1345
00:51:45,599 --> 00:51:47,760
then the entropy rate k over n must be

1346
00:51:47,760 --> 00:51:50,000
larger than half which is sharply in

1347
00:51:50,000 --> 00:51:51,839
contrast to conventional damage

1348
00:51:51,839 --> 00:51:53,920
structure that could work for sources

1349
00:51:53,920 --> 00:51:55,839
with superlogging entropy

1350
00:51:55,839 --> 00:51:57,920
on the other hand we can get around this

1351
00:51:57,920 --> 00:52:00,559
lower bound by using a random row or in

1352
00:52:00,559 --> 00:52:02,559
the most another crc model we have

1353
00:52:02,559 --> 00:52:04,720
constructions for sas dependent

1354
00:52:04,720 --> 00:52:06,240
resources with minimal entropy

1355
00:52:06,240 --> 00:52:08,000
requirement

1356
00:52:08,000 --> 00:52:10,480
but cis independence is hard to justify

1357
00:52:10,480 --> 00:52:13,920
and unnecessarily restrictive so we are

1358
00:52:13,920 --> 00:52:16,880
curious can we have a robust tracker for

1359
00:52:16,880 --> 00:52:19,359
crs cia's different sources without

1360
00:52:19,359 --> 00:52:22,079
rising extra entropy requirement

1361
00:52:22,079 --> 00:52:23,200
in this work

1362
00:52:23,200 --> 00:52:25,599
we give a negative answer to information

1363
00:52:25,599 --> 00:52:27,280
series constructions

1364
00:52:27,280 --> 00:52:29,200
and present a

1365
00:52:29,200 --> 00:52:30,800
positive answer to computational

1366
00:52:30,800 --> 00:52:33,599
constructions and we also extend our

1367
00:52:33,599 --> 00:52:37,040
solution to the file case

1368
00:52:37,040 --> 00:52:39,359
a crs model robotic tracker can be

1369
00:52:39,359 --> 00:52:42,240
described by a crs sampling algorithm

1370
00:52:42,240 --> 00:52:44,160
along with a generation algorithm and

1371
00:52:44,160 --> 00:52:46,160
the reproduction algorithm then take a

1372
00:52:46,160 --> 00:52:47,680
crs and input

1373
00:52:47,680 --> 00:52:50,640
and it's secure if for any source an

1374
00:52:50,640 --> 00:52:52,720
anniversary cannot break the security

1375
00:52:52,720 --> 00:52:55,920
goals with respect to a randomly chosen

1376
00:52:55,920 --> 00:52:57,040
crs

1377
00:52:57,040 --> 00:52:59,599
in this world we prove that if it is

1378
00:52:59,599 --> 00:53:02,400
secure for any unbounded order and any

1379
00:53:02,400 --> 00:53:03,359
cis

1380
00:53:03,359 --> 00:53:05,440
crs dependent sources

1381
00:53:05,440 --> 00:53:08,079
there should be a fixed crs such that

1382
00:53:08,079 --> 00:53:09,839
the generation algorithm and the

1383
00:53:09,839 --> 00:53:12,160
reproduction algorithm with this fixed

1384
00:53:12,160 --> 00:53:14,640
crs actually defines a secure plane

1385
00:53:14,640 --> 00:53:16,400
model robotic tracker

1386
00:53:16,400 --> 00:53:17,200
so

1387
00:53:17,200 --> 00:53:19,440
the interest rate of admissible sources

1388
00:53:19,440 --> 00:53:21,359
should be larger than the half it means

1389
00:53:21,359 --> 00:53:24,640
the same norbound zero plus zero

1390
00:53:24,640 --> 00:53:26,880
our second result is the

1391
00:53:26,880 --> 00:53:29,839
computational robust tracker our idea is

1392
00:53:29,839 --> 00:53:32,800
to take the weak secret and the k on mac

1393
00:53:32,800 --> 00:53:35,839
and use the map to authenticate the

1394
00:53:35,839 --> 00:53:38,559
state of the underlying random tracker

1395
00:53:38,559 --> 00:53:41,040
such that active attackers cannot change

1396
00:53:41,040 --> 00:53:43,920
the hype stream without being detected

1397
00:53:43,920 --> 00:53:44,960
however

1398
00:53:44,960 --> 00:53:46,960
since the weak circulation is used for

1399
00:53:46,960 --> 00:53:49,440
both for random extraction and for

1400
00:53:49,440 --> 00:53:51,680
magnetic generation the map should

1401
00:53:51,680 --> 00:53:53,920
provide some level of a composition

1402
00:53:53,920 --> 00:53:56,720
security to ensure our construction

1403
00:53:56,720 --> 00:53:58,559
works

1404
00:53:58,559 --> 00:54:01,599
more specifically to avoid being told to

1405
00:54:01,599 --> 00:54:04,319
avoid affecting the reality extraction

1406
00:54:04,319 --> 00:54:06,880
the map should provide a key privacy

1407
00:54:06,880 --> 00:54:09,119
that is the max hack should not need

1408
00:54:09,119 --> 00:54:10,559
partial information about the weak

1409
00:54:10,559 --> 00:54:11,680
secret

1410
00:54:11,680 --> 00:54:14,720
and secondly to avoid being affected by

1411
00:54:14,720 --> 00:54:16,559
the random distraction

1412
00:54:16,559 --> 00:54:19,760
the map should be auxiliary to secure

1413
00:54:19,760 --> 00:54:21,920
covering the case and anniversary

1414
00:54:21,920 --> 00:54:23,599
already have some other information

1415
00:54:23,599 --> 00:54:25,200
about the weak secret

1416
00:54:25,200 --> 00:54:26,960
and since we directly use the weak

1417
00:54:26,960 --> 00:54:28,880
secret and the mckee

1418
00:54:28,880 --> 00:54:31,839
the mckay should be structureless

1419
00:54:31,839 --> 00:54:34,000
and putting all properties together we

1420
00:54:34,000 --> 00:54:36,319
define a new mac primitive called copper

1421
00:54:36,319 --> 00:54:37,440
mac

1422
00:54:37,440 --> 00:54:40,160
and in the construction are ideally to

1423
00:54:40,160 --> 00:54:42,480
use an auxiliary input to secure digital

1424
00:54:42,480 --> 00:54:45,359
signature scheme as a mac

1425
00:54:45,359 --> 00:54:47,839
but since the copy map only

1426
00:54:47,839 --> 00:54:49,520
copy map requires the key to be

1427
00:54:49,520 --> 00:54:51,520
structured is we cannot put the

1428
00:54:51,520 --> 00:54:53,760
verification key and part of mackie but

1429
00:54:53,760 --> 00:54:56,640
how to be but have to put the put it as

1430
00:54:56,640 --> 00:54:58,720
a part of the map tab

1431
00:54:58,720 --> 00:55:01,040
and consequently we need to address the

1432
00:55:01,040 --> 00:55:02,799
following channels regarding

1433
00:55:02,799 --> 00:55:05,040
affordability anniversary may have

1434
00:55:05,040 --> 00:55:07,359
actual advantage by modifying this very

1435
00:55:07,359 --> 00:55:10,000
fixing verification key and regarding

1436
00:55:10,000 --> 00:55:12,799
key privacy or virtually minor passing

1437
00:55:12,799 --> 00:55:15,280
information from this verification key

1438
00:55:15,280 --> 00:55:17,599
and to address them we strengthen the

1439
00:55:17,599 --> 00:55:19,920
class and the location signature which

1440
00:55:19,920 --> 00:55:22,400
is a answering to the secure signature

1441
00:55:22,400 --> 00:55:24,160
and multiple places

1442
00:55:24,160 --> 00:55:26,000
and our final construction can be from

1443
00:55:26,000 --> 00:55:29,280
nic and deterministic public encryption

1444
00:55:29,280 --> 00:55:31,520
with specific properties and our

1445
00:55:31,520 --> 00:55:33,520
construction can be finally based on

1446
00:55:33,520 --> 00:55:36,000
explaining exponentially hard ddh and

1447
00:55:36,000 --> 00:55:38,480
other standard assumptions

1448
00:55:38,480 --> 00:55:41,040
we are extending to the file case

1449
00:55:41,040 --> 00:55:43,440
we prove that if our copy map

1450
00:55:43,440 --> 00:55:45,040
additionally satisfies fuzzy

1451
00:55:45,040 --> 00:55:47,839
unfoldability it can be used to convert

1452
00:55:47,839 --> 00:55:50,640
a fuzzy extractor into a robust valley

1453
00:55:50,640 --> 00:55:52,079
charter

1454
00:55:52,079 --> 00:55:54,319
and more interestingly we prove our

1455
00:55:54,319 --> 00:55:56,400
copper map construction already

1456
00:55:56,400 --> 00:55:58,480
satisfies this fuzzy opportunity so we

1457
00:55:58,480 --> 00:56:00,799
don't need to other compression

1458
00:56:00,799 --> 00:56:04,160
then thanks for listening

1459
00:56:08,480 --> 00:56:10,319
thank you

1460
00:56:10,319 --> 00:56:13,799
got any questions

1461
00:56:17,200 --> 00:56:18,480
all right looks like we have no

1462
00:56:18,480 --> 00:56:21,520
questions from the chat either

1463
00:56:21,520 --> 00:56:24,000
okay so this concludes this session and

1464
00:56:24,000 --> 00:56:26,640
thanks to all

