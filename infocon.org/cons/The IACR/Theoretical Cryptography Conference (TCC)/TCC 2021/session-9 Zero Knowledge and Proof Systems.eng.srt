1
00:00:00,080 --> 00:00:02,480
knowledge our first talk will be about

2
00:00:02,480 --> 00:00:04,240
somewhere statistical soundness and

3
00:00:04,240 --> 00:00:07,120
post-quantum security and snarks uh it's

4
00:00:07,120 --> 00:00:10,400
a work by uh yelp thomas

5
00:00:10,400 --> 00:00:12,000
and richard zhang and rachel will give

6
00:00:12,000 --> 00:00:13,920
the talk

7
00:00:13,920 --> 00:00:15,920
hi everyone um yeah so today i'll be

8
00:00:15,920 --> 00:00:17,359
talking about somewhere statistical

9
00:00:17,359 --> 00:00:18,560
soundness plus quantum security and

10
00:00:18,560 --> 00:00:20,240
snarks um because talk is only five

11
00:00:20,240 --> 00:00:21,199
minutes but we'll talk about the last

12
00:00:21,199 --> 00:00:22,880
two um so the fact you started the last

13
00:00:22,880 --> 00:00:25,119
one so that's how it starts

14
00:00:25,119 --> 00:00:27,359
um

15
00:00:27,760 --> 00:00:30,080
okay ah okay yeah so sarge is a succinct

16
00:00:30,080 --> 00:00:32,800
non-interactive argument um the idea is

17
00:00:32,800 --> 00:00:34,480
that approver wants to convince a

18
00:00:34,480 --> 00:00:37,200
verifier that some statement acts in a

19
00:00:37,200 --> 00:00:40,000
language um and she does this by sending

20
00:00:40,000 --> 00:00:42,559
a short certificate apply for this fact

21
00:00:42,559 --> 00:00:44,399
um you want correctness to hold and you

22
00:00:44,399 --> 00:00:45,440
know silence you hold against

23
00:00:45,440 --> 00:00:46,719
computation bounded sorry

24
00:00:46,719 --> 00:00:49,440
computationally bounded cheating provers

25
00:00:49,440 --> 00:00:50,960
but you also want additional property

26
00:00:50,960 --> 00:00:52,719
classic thickness um which is that if

27
00:00:52,719 --> 00:00:55,360
the computation takes time t to do then

28
00:00:55,360 --> 00:00:56,719
verifying it should take time way less

29
00:00:56,719 --> 00:01:00,879
than t um so as i'll be excited to talk

30
00:01:00,879 --> 00:01:02,239
about earlier today i'm solving prior

31
00:01:02,239 --> 00:01:04,479
work on constructing snarks um so snarks

32
00:01:04,479 --> 00:01:06,159
for mp have been cooked under really

33
00:01:06,159 --> 00:01:07,360
strong assumptions such as the random

34
00:01:07,360 --> 00:01:09,520
oracle model or knowledge assumptions um

35
00:01:09,520 --> 00:01:10,960
in the last seven years or so there's

36
00:01:10,960 --> 00:01:12,000
been work constructing stocks for

37
00:01:12,000 --> 00:01:14,560
deterministic languages um so for p

38
00:01:14,560 --> 00:01:16,080
there's been snow constructed underneath

39
00:01:16,080 --> 00:01:19,439
the potential i o or by linear groups um

40
00:01:19,439 --> 00:01:20,640
ideally though we want a snow area

41
00:01:20,640 --> 00:01:22,159
that's like post quantum secure and so

42
00:01:22,159 --> 00:01:24,080
like ideally you want to snark under um

43
00:01:24,080 --> 00:01:26,799
like lwe for instance um so in a recent

44
00:01:26,799 --> 00:01:28,960
work there's been um stories from bottom

45
00:01:28,960 --> 00:01:30,479
deaf computations conducted

46
00:01:30,479 --> 00:01:31,920
by venezuela

47
00:01:31,920 --> 00:01:33,759
um and the concurrent work by chattery

48
00:01:33,759 --> 00:01:35,439
jane and jin um they can start just

49
00:01:35,439 --> 00:01:38,479
natural batch np and p from lw

50
00:01:38,479 --> 00:01:40,240
um so in this work we're going to look

51
00:01:40,240 --> 00:01:41,759
at this connection between structured

52
00:01:41,759 --> 00:01:43,360
batch and ps4p

53
00:01:43,360 --> 00:01:45,920
um so our first result is that um we can

54
00:01:45,920 --> 00:01:47,600
get a snark for any language that has a

55
00:01:47,600 --> 00:01:49,920
computational nonsense in pcp assuming

56
00:01:49,920 --> 00:01:52,000
the distance of a snark or batch np um

57
00:01:52,000 --> 00:01:52,720
so

58
00:01:52,720 --> 00:01:53,920
when i say language i have competition

59
00:01:53,920 --> 00:01:55,680
not something pcp i mean language like

60
00:01:55,680 --> 00:01:58,000
classes of languages such as p and tsp

61
00:01:58,000 --> 00:02:00,399
which is like um time t and space s

62
00:02:00,399 --> 00:02:02,640
language not like language like sorry

63
00:02:02,640 --> 00:02:04,640
space sorry time t and space as

64
00:02:04,640 --> 00:02:05,439
computation that can be done

65
00:02:05,439 --> 00:02:07,439
non-intermedically um and there's like

66
00:02:07,439 --> 00:02:08,959
possibly other classes of languages that

67
00:02:08,959 --> 00:02:11,440
have these um this property um but for

68
00:02:11,440 --> 00:02:13,440
now these are the classes we know um and

69
00:02:13,440 --> 00:02:15,120
the second result that seems kind of

70
00:02:15,120 --> 00:02:17,040
unrelated for now is that we show that

71
00:02:17,040 --> 00:02:19,680
killian's protocol which is a short four

72
00:02:19,680 --> 00:02:21,680
round succinct argument um associated

73
00:02:21,680 --> 00:02:23,360
with the computational signaling pcp and

74
00:02:23,360 --> 00:02:25,760
parallel ssb hash families is post

75
00:02:25,760 --> 00:02:27,760
quantum sound um and this gives us a

76
00:02:27,760 --> 00:02:29,520
post quantum system argument for the

77
00:02:29,520 --> 00:02:31,920
affirmation classes i'm sorry p ntsp et

78
00:02:31,920 --> 00:02:33,120
cetera

79
00:02:33,120 --> 00:02:34,640
um so there's also been a recent work by

80
00:02:34,640 --> 00:02:37,120
chiasa ma spooner and the injury that

81
00:02:37,120 --> 00:02:39,280
shows that kilian is post quantum sound

82
00:02:39,280 --> 00:02:41,840
for any pcp using ssb hash functions

83
00:02:41,840 --> 00:02:43,360
will they do this using advanced quantum

84
00:02:43,360 --> 00:02:45,440
techniques um so the benefit of our

85
00:02:45,440 --> 00:02:47,440
construction or our proof is that it

86
00:02:47,440 --> 00:02:49,120
will be very simple to understand um

87
00:02:49,120 --> 00:02:50,160
like you know you don't need to use all

88
00:02:50,160 --> 00:02:51,200
the experience you're writing quantum

89
00:02:51,200 --> 00:02:52,640
techniques um you can understand it just

90
00:02:52,640 --> 00:02:54,160
by you know like if you don't know any

91
00:02:54,160 --> 00:02:55,599
kind of factor at all

92
00:02:55,599 --> 00:02:56,640
um

93
00:02:56,640 --> 00:02:58,720
so yeah so let me tell you about so like

94
00:02:58,720 --> 00:02:59,680
both these were those are going to have

95
00:02:59,680 --> 00:03:01,599
the same like overarching like idea

96
00:03:01,599 --> 00:03:02,879
behind them so let me tell you what that

97
00:03:02,879 --> 00:03:05,200
is now um so we're going to combine two

98
00:03:05,200 --> 00:03:07,280
protocols um so here's the first one the

99
00:03:07,280 --> 00:03:10,319
first is a bmw paradigm it's a privately

100
00:03:10,319 --> 00:03:13,200
verifiable two round protocol um and so

101
00:03:13,200 --> 00:03:15,040
here's how it works so the verifier is

102
00:03:15,040 --> 00:03:17,920
going to compute a set of pcp queries

103
00:03:17,920 --> 00:03:20,080
as well as some public and secret keys

104
00:03:20,080 --> 00:03:23,360
um for fhe or pure scheme um he's going

105
00:03:23,360 --> 00:03:25,200
to send encrypted queries um in the

106
00:03:25,200 --> 00:03:27,200
public keys to the approver and keeps

107
00:03:27,200 --> 00:03:28,480
the secret keys at the trapdoor for

108
00:03:28,480 --> 00:03:29,760
himself

109
00:03:29,760 --> 00:03:32,159
the proverb is going to generate the pcp

110
00:03:32,159 --> 00:03:33,120
pi

111
00:03:33,120 --> 00:03:35,360
um and she's going to compute under the

112
00:03:35,360 --> 00:03:37,840
hood i'm using the fht scheme the

113
00:03:37,840 --> 00:03:39,440
answers to the pcp

114
00:03:39,440 --> 00:03:41,680
um the pcp queries um and send them to

115
00:03:41,680 --> 00:03:43,280
the verifier now the verifier can take

116
00:03:43,280 --> 00:03:44,560
this like trapdoor that he has kept in

117
00:03:44,560 --> 00:03:46,480
his head um you know invert all these

118
00:03:46,480 --> 00:03:48,239
encrypted answers and verify the pcp

119
00:03:48,239 --> 00:03:50,159
queries um so the question is like you

120
00:03:50,159 --> 00:03:52,159
know for which pcps is this paradigm

121
00:03:52,159 --> 00:03:54,480
zone um it's known that in general it's

122
00:03:54,480 --> 00:03:56,159
probably not sound for any given pcp

123
00:03:56,159 --> 00:03:58,319
unless mp is not actually that hard

124
00:03:58,319 --> 00:04:00,400
but it is known to be sound if you know

125
00:04:00,400 --> 00:04:02,560
the pcp has a condition a property known

126
00:04:02,560 --> 00:04:03,840
as computation

127
00:04:03,840 --> 00:04:05,200
um so first of this talk when we say

128
00:04:05,200 --> 00:04:06,640
computational signaling pcp which just

129
00:04:06,640 --> 00:04:08,720
means that the bmw's like paradigm is

130
00:04:08,720 --> 00:04:10,239
secure

131
00:04:10,239 --> 00:04:11,840
okay so the second protocol i want to go

132
00:04:11,840 --> 00:04:13,599
over is the killian protocol um so this

133
00:04:13,599 --> 00:04:15,200
is a publicly verifiable four round

134
00:04:15,200 --> 00:04:17,040
sixteenth argument um and the way this

135
00:04:17,040 --> 00:04:19,358
works is that um the verifier is going

136
00:04:19,358 --> 00:04:20,959
to give the approver a hash function

137
00:04:20,959 --> 00:04:22,320
which the approver is going to use to

138
00:04:22,320 --> 00:04:24,080
commit to the pcp pi

139
00:04:24,080 --> 00:04:26,160
um and so that then she sends the

140
00:04:26,160 --> 00:04:28,320
commitment route to the verifier um now

141
00:04:28,320 --> 00:04:30,400
the verifier is going to ask the

142
00:04:30,400 --> 00:04:33,199
approver for a random pcp query um and

143
00:04:33,199 --> 00:04:35,199
the printer will generate answers as

144
00:04:35,199 --> 00:04:37,199
well as these openings which are just

145
00:04:37,199 --> 00:04:37,919
like

146
00:04:37,919 --> 00:04:40,479
basically um just um

147
00:04:40,479 --> 00:04:42,080
like sorry openings which are just um

148
00:04:42,080 --> 00:04:43,759
like basically proofs that the answers

149
00:04:43,759 --> 00:04:45,360
are consistent with the original

150
00:04:45,360 --> 00:04:47,840
commitment um

151
00:04:47,840 --> 00:04:49,759
and like it's to the verifier who then

152
00:04:49,759 --> 00:04:51,040
check the answers along with like the

153
00:04:51,040 --> 00:04:52,160
fact that these like openings are

154
00:04:52,160 --> 00:04:54,240
actually correct um

155
00:04:54,240 --> 00:04:56,400
and so our main

156
00:04:56,400 --> 00:04:58,639
con like our main like like the thing we

157
00:04:58,639 --> 00:05:00,320
noticed in this work is that the first

158
00:05:00,320 --> 00:05:01,360
two rounds look a lot like an

159
00:05:01,360 --> 00:05:04,000
instantiation of the bmw paradigm um so

160
00:05:04,000 --> 00:05:05,039
in particular if you use this

161
00:05:05,039 --> 00:05:07,199
computation non-signaling pcp and some

162
00:05:07,199 --> 00:05:09,280
sort of like locally openable like pure

163
00:05:09,280 --> 00:05:11,360
scheme then the first round are actually

164
00:05:11,360 --> 00:05:12,960
a sound instantiation of bmw so it's

165
00:05:12,960 --> 00:05:15,360
like a krr protocol um

166
00:05:15,360 --> 00:05:17,520
okay and so in particular okay i'm sorry

167
00:05:17,520 --> 00:05:19,600
and so these like locally open for pure

168
00:05:19,600 --> 00:05:21,199
schemes um are known to exist are known

169
00:05:21,199 --> 00:05:22,960
as ssb somewhere specifically binding

170
00:05:22,960 --> 00:05:24,320
hash functions um and they're going to

171
00:05:24,320 --> 00:05:26,320
exist assuming otherwise

172
00:05:26,320 --> 00:05:28,160
um so now killian's protocol looks as

173
00:05:28,160 --> 00:05:29,759
follows um the verifier can send over

174
00:05:29,759 --> 00:05:32,080
encrypted queries um and the approver is

175
00:05:32,080 --> 00:05:33,280
going to respond with these encrypted

176
00:05:33,280 --> 00:05:36,160
answers um and now the key point is that

177
00:05:36,160 --> 00:05:39,199
that if the verifier asks um the

178
00:05:39,199 --> 00:05:41,360
approver for the queries that are in

179
00:05:41,360 --> 00:05:42,880
code like sorry encrypted in the

180
00:05:42,880 --> 00:05:45,039
original message then

181
00:05:45,039 --> 00:05:46,400
um because the privilege has like

182
00:05:46,400 --> 00:05:48,320
committed to the answers already in the

183
00:05:48,320 --> 00:05:50,960
commitment then like you know she can't

184
00:05:50,960 --> 00:05:52,560
generate any accepting answers and

185
00:05:52,560 --> 00:05:54,400
openings like they don't exist um so in

186
00:05:54,400 --> 00:05:56,000
particular all powerful adverse

187
00:05:56,000 --> 00:05:57,680
adversary you cannot find accepting

188
00:05:57,680 --> 00:05:59,840
answers in openings

189
00:05:59,840 --> 00:06:02,319
um so that's our main observation um so

190
00:06:02,319 --> 00:06:04,000
there's like two consequences uh what i

191
00:06:04,000 --> 00:06:06,560
said earlier the two results um so the

192
00:06:06,560 --> 00:06:08,319
first is that we want to construct a

193
00:06:08,319 --> 00:06:10,319
snog um and so

194
00:06:10,319 --> 00:06:11,680
the first two rounds like you can put

195
00:06:11,680 --> 00:06:13,680
the first round as like the crs right

196
00:06:13,680 --> 00:06:14,800
and so the second round the second

197
00:06:14,800 --> 00:06:16,080
message from the previous verifier is

198
00:06:16,080 --> 00:06:18,560
like you know one round um so if we just

199
00:06:18,560 --> 00:06:19,680
get rid of the last two rounds of

200
00:06:19,680 --> 00:06:21,520
killing protocol then we would have a

201
00:06:21,520 --> 00:06:23,039
snug um and so the question is how do

202
00:06:23,039 --> 00:06:25,360
you do this um and so we just noticed

203
00:06:25,360 --> 00:06:28,000
that like if the prover could

204
00:06:28,000 --> 00:06:29,520
convince a verifier that for all

205
00:06:29,520 --> 00:06:31,759
possible queries queue there exist these

206
00:06:31,759 --> 00:06:32,960
answers and openings then we would be

207
00:06:32,960 --> 00:06:34,720
done um so we're going to go back to

208
00:06:34,720 --> 00:06:36,479
that she's going to send over a snark

209
00:06:36,479 --> 00:06:37,840
for the fact that we're all queries

210
00:06:37,840 --> 00:06:39,039
there are these accepting answers and

211
00:06:39,039 --> 00:06:42,240
things and so we have a snark um so yay

212
00:06:42,240 --> 00:06:44,240
okay um

213
00:06:44,240 --> 00:06:45,120
yeah i think that's all i want to say

214
00:06:45,120 --> 00:06:46,880
about that um let's talk oh and this is

215
00:06:46,880 --> 00:06:48,800
like a batch np statement so yeah so he

216
00:06:48,800 --> 00:06:50,240
does not provide b

217
00:06:50,240 --> 00:06:51,440
um

218
00:06:51,440 --> 00:06:52,639
cool so the second thing i want to talk

219
00:06:52,639 --> 00:06:55,599
about is post quantum security um so

220
00:06:55,599 --> 00:06:56,720
we started again with the killian

221
00:06:56,720 --> 00:06:59,120
protocol um and so if you want to argue

222
00:06:59,120 --> 00:07:00,479
soundness of this killian protocol

223
00:07:00,479 --> 00:07:02,240
instantiated with you know it's not

224
00:07:02,240 --> 00:07:05,120
non-signaling pcp um and ssd hash

225
00:07:05,120 --> 00:07:06,880
functions um what you might do is you

226
00:07:06,880 --> 00:07:08,479
would say okay look if the certain

227
00:07:08,479 --> 00:07:10,880
message is q star then the protocol

228
00:07:10,880 --> 00:07:12,639
sound like um you know the query is

229
00:07:12,639 --> 00:07:14,960
going to reject okay well if you um then

230
00:07:14,960 --> 00:07:16,639
over random queue well you don't know

231
00:07:16,639 --> 00:07:17,680
what was in the first message it could

232
00:07:17,680 --> 00:07:19,280
have been cute from the q star who knows

233
00:07:19,280 --> 00:07:21,199
right so by the distinguishability it

234
00:07:21,199 --> 00:07:23,840
must still be sound um so that's what we

235
00:07:23,840 --> 00:07:25,599
call straight line proof of soundness

236
00:07:25,599 --> 00:07:27,199
which is that a social straight line

237
00:07:27,199 --> 00:07:28,479
reduction is one that interacts with the

238
00:07:28,479 --> 00:07:30,160
cheating proverb exactly once doesn't

239
00:07:30,160 --> 00:07:32,000
rewind and uses that to break some

240
00:07:32,000 --> 00:07:33,280
assumptions

241
00:07:33,280 --> 00:07:35,120
and we show that any argument system

242
00:07:35,120 --> 00:07:36,479
that's proven sound via straight line

243
00:07:36,479 --> 00:07:38,560
reduction is also post quantum sound um

244
00:07:38,560 --> 00:07:39,759
because it doesn't use any like weird

245
00:07:39,759 --> 00:07:40,720
like classical techniques that don't

246
00:07:40,720 --> 00:07:42,880
hold quantum adversaries um and you have

247
00:07:42,880 --> 00:07:43,919
to assume that the underlying exemption

248
00:07:43,919 --> 00:07:45,840
is also a straight line position

249
00:07:45,840 --> 00:07:48,560
um this is true for kilian so we have as

250
00:07:48,560 --> 00:07:49,759
a corollary that kilian was a

251
00:07:49,759 --> 00:07:51,440
competition nothing like pcp and a

252
00:07:51,440 --> 00:07:54,000
parallel ssb hash function is possible

253
00:07:54,000 --> 00:07:54,879
um

254
00:07:54,879 --> 00:07:56,960
yeah so this is my summary page but i

255
00:07:56,960 --> 00:07:58,240
said everything in the last like two

256
00:07:58,240 --> 00:08:00,160
minutes so i'll say it again um thank

257
00:08:00,160 --> 00:08:01,170
you

258
00:08:01,170 --> 00:08:04,429
[Applause]

259
00:08:10,720 --> 00:08:12,639
one quick question for me so pcb's

260
00:08:12,639 --> 00:08:14,479
generally have this like probabilistic

261
00:08:14,479 --> 00:08:16,479
aspect that if you that if the statement

262
00:08:16,479 --> 00:08:18,080
is wrong there's like many queries where

263
00:08:18,080 --> 00:08:19,360
you'll catch it but here you're asking

264
00:08:19,360 --> 00:08:21,759
all the queries in the set queue uh does

265
00:08:21,759 --> 00:08:23,680
that let you do something easier than

266
00:08:23,680 --> 00:08:27,360
pcp or does it give you an extra power

267
00:08:27,360 --> 00:08:28,720
um

268
00:08:28,720 --> 00:08:30,560
i think i answered the question

269
00:08:30,560 --> 00:08:32,719
well here in the protocol like you

270
00:08:32,719 --> 00:08:34,559
you're you're actually showing you're

271
00:08:34,559 --> 00:08:36,640
using the batch np to show that every

272
00:08:36,640 --> 00:08:38,320
possible query would answer correctly

273
00:08:38,320 --> 00:08:40,559
not just like most of them yeah

274
00:08:40,559 --> 00:08:41,839
so it sounds like you don't need like

275
00:08:41,839 --> 00:08:43,599
this probabilistic aspect of pcp where

276
00:08:43,599 --> 00:08:45,440
like most things are correct right does

277
00:08:45,440 --> 00:08:46,959
that kind of let you do something a

278
00:08:46,959 --> 00:08:48,640
little easier like not use the pro power

279
00:08:48,640 --> 00:08:49,680
pcb

280
00:08:49,680 --> 00:08:50,640
i don't know that's a really good

281
00:08:50,640 --> 00:08:52,399
question i've not thought about that so

282
00:08:52,399 --> 00:08:55,640
i have no idea

283
00:08:55,839 --> 00:08:58,320
thank you

284
00:09:04,160 --> 00:09:07,160
um

285
00:09:13,600 --> 00:09:16,600
hmm

286
00:09:19,150 --> 00:09:22,750
[Music]

287
00:09:32,959 --> 00:09:37,560
oh it has to open the yeah

288
00:09:46,000 --> 00:09:49,560
and then i shared

289
00:09:56,710 --> 00:09:59,789
[Music]

290
00:09:59,920 --> 00:10:02,240
excellent all right our second talk will

291
00:10:02,240 --> 00:10:04,399
be on black box and possibility of

292
00:10:04,399 --> 00:10:06,240
obtaining two round weak zero knowledge

293
00:10:06,240 --> 00:10:08,720
and strong wi for polynomial hardness by

294
00:10:08,720 --> 00:10:12,120
susum kiyoshina

295
00:10:28,800 --> 00:10:31,040
all right so

296
00:10:31,040 --> 00:10:33,839
it is working

297
00:10:34,160 --> 00:10:37,360
all right so hello everyone

298
00:10:39,920 --> 00:10:42,399
all right so in this work we study with

299
00:10:42,399 --> 00:10:44,480
zero knowledge and the strong double a

300
00:10:44,480 --> 00:10:45,760
which oppose

301
00:10:45,760 --> 00:10:47,440
through the privacy notion of

302
00:10:47,440 --> 00:10:49,839
interactive proof and argument such that

303
00:10:49,839 --> 00:10:51,279
first they are weaker than zero

304
00:10:51,279 --> 00:10:53,360
knowledge so we can avoid the severe

305
00:10:53,360 --> 00:10:55,600
unknown possibility of cell knowledge

306
00:10:55,600 --> 00:10:57,120
and second they are stronger than the

307
00:10:57,120 --> 00:10:59,360
brain so they are meaningful even in

308
00:10:59,360 --> 00:11:01,760
some application where standard device

309
00:11:01,760 --> 00:11:04,160
is useless

310
00:11:04,160 --> 00:11:05,760
so in more detail

311
00:11:05,760 --> 00:11:08,480
first week zero knowledge is defined by

312
00:11:08,480 --> 00:11:10,399
switching the order of controller in the

313
00:11:10,399 --> 00:11:12,480
definition of withdrawal knowledge

314
00:11:12,480 --> 00:11:14,720
so specifically with zero knowledge only

315
00:11:14,720 --> 00:11:17,360
require that uh for any verifier uh

316
00:11:17,360 --> 00:11:19,519
android for any distinguisher at the

317
00:11:19,519 --> 00:11:21,680
existing simulator such that the real

318
00:11:21,680 --> 00:11:24,000
simulation distinction so the difference

319
00:11:24,000 --> 00:11:25,920
from standard zero knowledge is that now

320
00:11:25,920 --> 00:11:27,680
the simulator is allowed to depend on

321
00:11:27,680 --> 00:11:30,240
the distinguisher

322
00:11:30,240 --> 00:11:32,640
so clearly you know big zero knowledge

323
00:11:32,640 --> 00:11:34,320
is a very natural weakening of zero

324
00:11:34,320 --> 00:11:35,760
knowledge so it is interesting

325
00:11:35,760 --> 00:11:38,560
theoretically and in addition it is

326
00:11:38,560 --> 00:11:40,959
known that the externality is useful

327
00:11:40,959 --> 00:11:42,880
when it is used at the building build in

328
00:11:42,880 --> 00:11:46,320
some other larger protocols

329
00:11:47,040 --> 00:11:50,240
and next uh strong wi is defined by

330
00:11:50,240 --> 00:11:52,320
requiring that the proofs about the

331
00:11:52,320 --> 00:11:54,160
indistinguishable statement are also

332
00:11:54,160 --> 00:11:55,760
indistinguishable

333
00:11:55,760 --> 00:11:58,639
so specifically it is required that for

334
00:11:58,639 --> 00:12:00,800
any two distribution of our statement

335
00:12:00,800 --> 00:12:02,160
written sphere

336
00:12:02,160 --> 00:12:04,399
if two statement chosen from these

337
00:12:04,399 --> 00:12:07,360
distributions are indistinguishable then

338
00:12:07,360 --> 00:12:09,600
they remain in distinction if when proof

339
00:12:09,600 --> 00:12:13,360
about them are given to the periphery

340
00:12:13,440 --> 00:12:15,120
so a key difference from a standard

341
00:12:15,120 --> 00:12:17,200
write is that strong double is

342
00:12:17,200 --> 00:12:18,959
meaningful even for unique business

343
00:12:18,959 --> 00:12:21,440
validation so for example strong divide

344
00:12:21,440 --> 00:12:23,920
can be used to prove a statement about

345
00:12:23,920 --> 00:12:27,599
the statistically binding movement

346
00:12:28,240 --> 00:12:30,240
and in previous work it has been shown

347
00:12:30,240 --> 00:12:32,320
that the two-round week zero on average

348
00:12:32,320 --> 00:12:34,000
and the strong wi can be obtained

349
00:12:34,000 --> 00:12:36,160
forcing the delay deep setting and the

350
00:12:36,160 --> 00:12:38,720
standard non-derivative setting

351
00:12:38,720 --> 00:12:41,040
and here standard non-deleted setting

352
00:12:41,040 --> 00:12:43,279
means that the statement is fixed at the

353
00:12:43,279 --> 00:12:45,839
beginning of the protocol whereas uh

354
00:12:45,839 --> 00:12:47,680
depositing means that the statement is

355
00:12:47,680 --> 00:12:52,279
chosen by the variable in the last round

356
00:12:52,959 --> 00:12:55,040
and these potential results about drone

357
00:12:55,040 --> 00:12:57,440
construction are of course really great

358
00:12:57,440 --> 00:12:59,440
but the major weak point about them is

359
00:12:59,440 --> 00:13:01,519
that uh currently all of them are based

360
00:13:01,519 --> 00:13:03,920
on uh super boring hard assumptions such

361
00:13:03,920 --> 00:13:05,680
as a assumption against the sub

362
00:13:05,680 --> 00:13:08,560
experience time out of us

363
00:13:08,560 --> 00:13:09,360
so

364
00:13:09,360 --> 00:13:11,120
in this work we study preservatives

365
00:13:11,120 --> 00:13:12,880
impossible to obtain turnaround weak

366
00:13:12,880 --> 00:13:14,720
terminology and strong double eye and

367
00:13:14,720 --> 00:13:17,120
the standard polynomial had assumption

368
00:13:17,120 --> 00:13:19,040
when we then use

369
00:13:19,040 --> 00:13:20,959
when mvp security using standard

370
00:13:20,959 --> 00:13:23,440
techniques and here standard assumption

371
00:13:23,440 --> 00:13:25,120
the standard techniques are formalized

372
00:13:25,120 --> 00:13:26,959
by using the notes of the force 5

373
00:13:26,959 --> 00:13:28,880
assumption and the black box reduction

374
00:13:28,880 --> 00:13:30,320
respectively

375
00:13:30,320 --> 00:13:32,399
and if you're not familiar with this

376
00:13:32,399 --> 00:13:34,160
notion you can just think that the

377
00:13:34,160 --> 00:13:36,959
polish assumption include any

378
00:13:36,959 --> 00:13:38,320
game-based assumptions that are

379
00:13:38,320 --> 00:13:40,720
considered standard in cryptography and

380
00:13:40,720 --> 00:13:42,720
black working reduction include you know

381
00:13:42,720 --> 00:13:44,800
common proof techniques that is

382
00:13:44,800 --> 00:13:47,800
adversarial

383
00:13:48,000 --> 00:13:50,480
now let me explain our result and let's

384
00:13:50,480 --> 00:13:53,199
start from a weak zero knowledge

385
00:13:53,199 --> 00:13:55,040
so first i know that the classical

386
00:13:55,040 --> 00:13:56,639
impossibility of three round black box

387
00:13:56,639 --> 00:13:58,880
zero knowledge also hold for vector

388
00:13:58,880 --> 00:14:01,120
knowledge in the standard non-derivative

389
00:14:01,120 --> 00:14:02,800
setting

390
00:14:02,800 --> 00:14:04,959
and in this work we show that the

391
00:14:04,959 --> 00:14:06,800
200-week zero knowledge in the

392
00:14:06,800 --> 00:14:09,680
derivative setting is impossible if

393
00:14:09,680 --> 00:14:11,519
soundness is proved by blackboard

394
00:14:11,519 --> 00:14:14,079
reduction under qualified polynomial

395
00:14:14,079 --> 00:14:15,279
assumptions

396
00:14:15,279 --> 00:14:17,440
and i know that this result heard even

397
00:14:17,440 --> 00:14:19,279
when number of techniques are using the

398
00:14:19,279 --> 00:14:22,639
proof of weak zero knowledge

399
00:14:23,440 --> 00:14:26,639
so now next let's put the strong dubai

400
00:14:26,639 --> 00:14:28,800
and first i showed that we showed that

401
00:14:28,800 --> 00:14:30,480
the two runs from the bar in the

402
00:14:30,480 --> 00:14:32,480
standard non-relative setting is

403
00:14:32,480 --> 00:14:35,360
impossible if a strong debris is probed

404
00:14:35,360 --> 00:14:36,959
by block reduction

405
00:14:36,959 --> 00:14:39,839
under 45 000 assumption i mean

406
00:14:39,839 --> 00:14:41,680
and next uh we show that the turran's

407
00:14:41,680 --> 00:14:43,680
thunderbolt in the gradient setting is

408
00:14:43,680 --> 00:14:46,399
also impossible if is a stronger eye

409
00:14:46,399 --> 00:14:49,040
it's proved by production and because

410
00:14:49,040 --> 00:14:50,160
the protocols that have public

411
00:14:50,160 --> 00:14:53,199
verifiability or both strong double eye

412
00:14:53,199 --> 00:14:57,040
and the soundness approved by blackboard

413
00:14:57,519 --> 00:14:59,600
and here i know that this video actually

414
00:14:59,600 --> 00:15:01,680
requires a reduction for strong device a

415
00:15:01,680 --> 00:15:03,680
black box in a strong sense essentially

416
00:15:03,680 --> 00:15:06,160
required that they are black not only

417
00:15:06,160 --> 00:15:08,079
about the cheating verifier but also

418
00:15:08,079 --> 00:15:10,880
about the distribution of the statement

419
00:15:10,880 --> 00:15:13,199
but this is very natural property and

420
00:15:13,199 --> 00:15:14,639
all the prior

421
00:15:14,639 --> 00:15:16,240
reduction for strong double eyes that

422
00:15:16,240 --> 00:15:19,040
indeed satisfy this problem

423
00:15:19,040 --> 00:15:21,199
so in summary our result implies that

424
00:15:21,199 --> 00:15:23,199
the number of techniques necessary for

425
00:15:23,199 --> 00:15:25,600
both with their knowledge and strong for

426
00:15:25,600 --> 00:15:27,360
embosser deleted to settings and

427
00:15:27,360 --> 00:15:29,360
standard non-deleted settings

428
00:15:29,360 --> 00:15:30,959
and a clear open question is of course

429
00:15:30,959 --> 00:15:32,560
to obtain it around with the narratives

430
00:15:32,560 --> 00:15:35,440
to apply under hardness uh by using the

431
00:15:35,440 --> 00:15:37,920
number of techniques and this concludes

432
00:15:37,920 --> 00:15:41,839
my talk so thank you

433
00:15:46,079 --> 00:15:49,079
questions

434
00:16:01,600 --> 00:16:03,680
and so our next talk will be an online

435
00:16:03,680 --> 00:16:06,079
talk

436
00:16:06,240 --> 00:16:07,150
view

437
00:16:07,150 --> 00:16:10,220
[Music]

438
00:16:15,519 --> 00:16:18,160
uh miguel are you online

439
00:16:18,160 --> 00:16:19,279
yes

440
00:16:19,279 --> 00:16:20,720
sorry i didn't know

441
00:16:20,720 --> 00:16:22,959
i was

442
00:16:29,220 --> 00:16:32,729
[Music]

443
00:16:35,440 --> 00:16:37,440
can you see it

444
00:16:37,440 --> 00:16:38,399
yes

445
00:16:38,399 --> 00:16:40,079
um

446
00:16:40,079 --> 00:16:41,040
yes

447
00:16:41,040 --> 00:16:42,399
all right excellent so our next talk

448
00:16:42,399 --> 00:16:44,720
will be on acyclicity programming for

449
00:16:44,720 --> 00:16:48,079
sigma protocols uh by masa abe ambrosia

450
00:16:48,079 --> 00:16:51,439
bogdanov okubo

451
00:16:52,160 --> 00:16:55,279
miguel will give the talk

452
00:16:55,279 --> 00:16:58,079
okay thank you for the introduction

453
00:16:58,079 --> 00:16:59,920
so in this world we present a new

454
00:16:59,920 --> 00:17:03,120
technique for combining sigma protocols

455
00:17:03,120 --> 00:17:05,199
so i'm going to start

456
00:17:05,199 --> 00:17:07,039
briefly describing what a signal

457
00:17:07,039 --> 00:17:08,799
protocol is basically it's a three-move

458
00:17:08,799 --> 00:17:10,160
protocol

459
00:17:10,160 --> 00:17:11,439
that can be used to obtain very

460
00:17:11,439 --> 00:17:13,919
efficiency or knowledge brief systems

461
00:17:13,919 --> 00:17:16,000
or in the first round um

462
00:17:16,000 --> 00:17:18,160
the prover creates a certain message

463
00:17:18,160 --> 00:17:19,760
called a

464
00:17:19,760 --> 00:17:21,520
that will be produced by using some

465
00:17:21,520 --> 00:17:24,480
randomness then the verifier will sample

466
00:17:24,480 --> 00:17:26,720
a random challenge e

467
00:17:26,720 --> 00:17:29,200
uniformly from a big set of challenges

468
00:17:29,200 --> 00:17:30,880
and finally the problem will respond

469
00:17:30,880 --> 00:17:33,360
with a valued set which the very ver the

470
00:17:33,360 --> 00:17:36,400
verifier may accept or reject

471
00:17:36,400 --> 00:17:38,160
the symbol protocol is specified by

472
00:17:38,160 --> 00:17:40,559
these three algorithms c

473
00:17:40,559 --> 00:17:43,520
said and v as well as a full algorithm s

474
00:17:43,520 --> 00:17:46,640
which stands for simulator that produces

475
00:17:46,640 --> 00:17:48,720
or simulates valid transcripts without

476
00:17:48,720 --> 00:17:50,160
the witness

477
00:17:50,160 --> 00:17:53,679
when given the challenge in advance

478
00:17:53,679 --> 00:17:55,360
so the properties that a single protocol

479
00:17:55,360 --> 00:17:57,679
must satisfy are weaker than those of a

480
00:17:57,679 --> 00:17:59,520
serial knowledge proof system and this

481
00:17:59,520 --> 00:18:02,160
makes them much easier to analyze and

482
00:18:02,160 --> 00:18:02,960
build

483
00:18:02,960 --> 00:18:05,360
however with without much effort they

484
00:18:05,360 --> 00:18:06,640
can be transformed into actual

485
00:18:06,640 --> 00:18:08,720
zero-knowledge brief systems so one way

486
00:18:08,720 --> 00:18:10,320
to do so is to use the theastromark

487
00:18:10,320 --> 00:18:11,600
heuristic

488
00:18:11,600 --> 00:18:13,919
which consists of replacing the verifier

489
00:18:13,919 --> 00:18:16,480
by a hash function

490
00:18:16,480 --> 00:18:18,400
and if this has function is modeled as a

491
00:18:18,400 --> 00:18:20,960
programmable random article

492
00:18:20,960 --> 00:18:22,559
then the resulting protocol is a

493
00:18:22,559 --> 00:18:24,320
non-interactive knowledge argument of

494
00:18:24,320 --> 00:18:25,679
knowledge

495
00:18:25,679 --> 00:18:27,200
so it's a natural question to ask

496
00:18:27,200 --> 00:18:30,000
whether it is possible to compose

497
00:18:30,000 --> 00:18:32,000
several sigma protocols

498
00:18:32,000 --> 00:18:34,720
and the cds 94 composition technique

499
00:18:34,720 --> 00:18:36,559
provides very good tools to do so by

500
00:18:36,559 --> 00:18:39,440
manipulating the challenge string e

501
00:18:39,440 --> 00:18:41,280
but in this work we study a different

502
00:18:41,280 --> 00:18:43,039
composition technique known as

503
00:18:43,039 --> 00:18:45,760
sequential composition

504
00:18:45,760 --> 00:18:46,880
which

505
00:18:46,880 --> 00:18:48,799
it's essentially a generalization of the

506
00:18:48,799 --> 00:18:50,480
field sharing heuristic

507
00:18:50,480 --> 00:18:52,400
this technique allows us to combine two

508
00:18:52,400 --> 00:18:54,480
signal protocols in this junction

509
00:18:54,480 --> 00:18:57,200
by applying uh the fiasco heuristic in a

510
00:18:57,200 --> 00:18:58,400
crosstal

511
00:18:58,400 --> 00:19:00,160
way among the transcripts that is

512
00:19:00,160 --> 00:19:01,840
challenge e2

513
00:19:01,840 --> 00:19:03,600
will be computed

514
00:19:03,600 --> 00:19:05,600
as the hash of a1

515
00:19:05,600 --> 00:19:07,440
and challenge e1 will be completed as

516
00:19:07,440 --> 00:19:10,799
the hash of a2

517
00:19:10,799 --> 00:19:12,960
in particular knowing one witness is

518
00:19:12,960 --> 00:19:14,400
enough to efficiently produce a valid

519
00:19:14,400 --> 00:19:15,760
proofs as we pause the program only

520
00:19:15,760 --> 00:19:18,320
known as witness w1 for for the first

521
00:19:18,320 --> 00:19:20,799
statement x1 the approver can compute

522
00:19:20,799 --> 00:19:23,600
the first message a1 normally

523
00:19:23,600 --> 00:19:26,320
and this will unlock the value of e2 the

524
00:19:26,320 --> 00:19:28,080
second challenge

525
00:19:28,080 --> 00:19:30,799
from which the prover can now simulate

526
00:19:30,799 --> 00:19:32,240
the second transcript without the

527
00:19:32,240 --> 00:19:33,440
weakness

528
00:19:33,440 --> 00:19:36,000
and this will set the value for e1

529
00:19:36,000 --> 00:19:38,000
so now the program can finish the first

530
00:19:38,000 --> 00:19:39,760
transcript

531
00:19:39,760 --> 00:19:41,760
observe that this technique can be

532
00:19:41,760 --> 00:19:43,840
generalized to cycles of other lengths

533
00:19:43,840 --> 00:19:46,080
not just two so for example we could

534
00:19:46,080 --> 00:19:47,679
join three single protocols in this

535
00:19:47,679 --> 00:19:49,360
junction with the following challenge

536
00:19:49,360 --> 00:19:51,520
dependencies

537
00:19:51,520 --> 00:19:53,120
and this approach

538
00:19:53,120 --> 00:19:55,280
leads to rinsing to ring signature

539
00:19:55,280 --> 00:19:57,280
schemes that can be used to combine

540
00:19:57,280 --> 00:20:00,720
snore and rsi signatures one of the main

541
00:20:00,720 --> 00:20:02,559
applications mentioned in in the work by

542
00:20:02,559 --> 00:20:03,679
abe

543
00:20:03,679 --> 00:20:05,600
okubo and suzuki

544
00:20:05,600 --> 00:20:07,679
furthermore this technique has been

545
00:20:07,679 --> 00:20:09,440
efficiently uh has been

546
00:20:09,440 --> 00:20:11,760
recently revisited and shown to be

547
00:20:11,760 --> 00:20:12,880
useful

548
00:20:12,880 --> 00:20:14,320
for proving affordability in the

549
00:20:14,320 --> 00:20:15,919
non-programmable random

550
00:20:15,919 --> 00:20:16,880
model

551
00:20:16,880 --> 00:20:18,640
so what do we do in this work well in

552
00:20:18,640 --> 00:20:21,840
this work um the work i'm presenting

553
00:20:21,840 --> 00:20:24,640
we extend this technique of composition

554
00:20:24,640 --> 00:20:26,799
of sigma protocols

555
00:20:26,799 --> 00:20:28,640
and consider more general structures

556
00:20:28,640 --> 00:20:29,760
than just

557
00:20:29,760 --> 00:20:32,559
just a circle so for example uh say we

558
00:20:32,559 --> 00:20:34,080
have four sigma protocols each of them

559
00:20:34,080 --> 00:20:36,080
represented by a node in the following

560
00:20:36,080 --> 00:20:37,120
graph

561
00:20:37,120 --> 00:20:38,799
where the arrows represent challenge

562
00:20:38,799 --> 00:20:40,960
dependencies so for example

563
00:20:40,960 --> 00:20:42,799
given that node um

564
00:20:42,799 --> 00:20:44,240
node three

565
00:20:44,240 --> 00:20:46,720
has incoming arrows from node one and

566
00:20:46,720 --> 00:20:48,240
node 4

567
00:20:48,240 --> 00:20:49,760
then the third challenge which is the

568
00:20:49,760 --> 00:20:50,960
challenge corresponding to the

569
00:20:50,960 --> 00:20:54,159
transcript of sigma protocol 3

570
00:20:54,159 --> 00:20:56,640
must be completed as the hash of a1 and

571
00:20:56,640 --> 00:20:58,960
a4 the first message of the first

572
00:20:58,960 --> 00:21:00,080
transcript

573
00:21:00,080 --> 00:21:01,840
and the first message of the fourth

574
00:21:01,840 --> 00:21:03,200
transcript

575
00:21:03,200 --> 00:21:05,760
it turns out that doing so will

576
00:21:05,760 --> 00:21:08,080
give us a proving system for a compose

577
00:21:08,080 --> 00:21:09,760
statement of the signal protocol

578
00:21:09,760 --> 00:21:12,080
predicates but what is that compose

579
00:21:12,080 --> 00:21:13,120
statement

580
00:21:13,120 --> 00:21:14,480
well that's

581
00:21:14,480 --> 00:21:16,480
what we study in this paper

582
00:21:16,480 --> 00:21:18,159
we provide mechanisms to understand the

583
00:21:18,159 --> 00:21:20,320
predicate induced by by a

584
00:21:20,320 --> 00:21:22,960
certain graph and vice versa

585
00:21:22,960 --> 00:21:24,880
so we study how to build a graph that

586
00:21:24,880 --> 00:21:28,000
captures a predicate of our choice

587
00:21:28,000 --> 00:21:30,080
furthermore we show that this technique

588
00:21:30,080 --> 00:21:32,159
can capture any predicate that can be

589
00:21:32,159 --> 00:21:33,840
efficiently expressed

590
00:21:33,840 --> 00:21:36,960
as what we call an eclicity program

591
00:21:36,960 --> 00:21:38,720
so a significant programming is a new

592
00:21:38,720 --> 00:21:40,400
model of computation that we introduce

593
00:21:40,400 --> 00:21:41,919
in this work

594
00:21:41,919 --> 00:21:43,600
and essentially

595
00:21:43,600 --> 00:21:45,120
we can say that a monologue on a

596
00:21:45,120 --> 00:21:46,960
simplicity program

597
00:21:46,960 --> 00:21:49,440
is just a directed graph whose nodes are

598
00:21:49,440 --> 00:21:52,320
labeled by variables

599
00:21:52,320 --> 00:21:54,960
and the program accept accepts a set of

600
00:21:54,960 --> 00:21:56,000
variables

601
00:21:56,000 --> 00:21:56,880
s

602
00:21:56,880 --> 00:21:59,520
if the graph resulting from removing all

603
00:21:59,520 --> 00:22:02,080
nodes associated with variables in s

604
00:22:02,080 --> 00:22:05,280
contains no cycles

605
00:22:05,280 --> 00:22:07,200
the one thing that we show in this paper

606
00:22:07,200 --> 00:22:08,240
is that

607
00:22:08,240 --> 00:22:10,480
asic clicity programming is polynomially

608
00:22:10,480 --> 00:22:13,120
equivalent to branching programs

609
00:22:13,120 --> 00:22:14,880
and this makes our

610
00:22:14,880 --> 00:22:16,320
our new composition technique

611
00:22:16,320 --> 00:22:20,000
incomparable to the cds 941

612
00:22:20,000 --> 00:22:21,760
because there exists languages that can

613
00:22:21,760 --> 00:22:24,080
be officially described by as equalistic

614
00:22:24,080 --> 00:22:25,120
programs

615
00:22:25,120 --> 00:22:26,799
but whose monotone spam program

616
00:22:26,799 --> 00:22:29,280
representation is super polynomial

617
00:22:29,280 --> 00:22:30,799
and vice versa

618
00:22:30,799 --> 00:22:33,520
this monotone span programs is basically

619
00:22:33,520 --> 00:22:36,799
the class of predicates that cds94

620
00:22:36,799 --> 00:22:38,559
can handle

621
00:22:38,559 --> 00:22:40,720
this diagram shows polynomial

622
00:22:40,720 --> 00:22:42,480
simulatability and relations among

623
00:22:42,480 --> 00:22:45,840
different predicate representations

624
00:22:45,840 --> 00:22:49,280
so we can say that both methods cts 94

625
00:22:49,280 --> 00:22:51,200
and our new technique are

626
00:22:51,200 --> 00:22:53,679
orthogonal in terms of complexity and

627
00:22:53,679 --> 00:22:56,240
they complement each other however it's

628
00:22:56,240 --> 00:22:57,200
um

629
00:22:57,200 --> 00:22:58,559
i would like to say that there is a

630
00:22:58,559 --> 00:23:00,320
major difference

631
00:23:00,320 --> 00:23:02,400
which is that cds 94 preserves the

632
00:23:02,400 --> 00:23:04,480
second protocol structure

633
00:23:04,480 --> 00:23:06,799
while our composition leads inerrantly

634
00:23:06,799 --> 00:23:08,559
to a non-interactive

635
00:23:08,559 --> 00:23:11,280
uh brief system given that we use the

636
00:23:11,280 --> 00:23:13,440
the fear sharing heuristic

637
00:23:13,440 --> 00:23:15,200
and therefore we also require the right

638
00:23:15,200 --> 00:23:17,919
markov model

639
00:23:18,880 --> 00:23:21,840
okay so i would also like to mention

640
00:23:21,840 --> 00:23:22,799
another

641
00:23:22,799 --> 00:23:25,520
technique that we propose in this work

642
00:23:25,520 --> 00:23:26,960
which allows us to compose signal

643
00:23:26,960 --> 00:23:29,280
protocols and predicate predicates

644
00:23:29,280 --> 00:23:32,080
expressed as monotone circuits

645
00:23:32,080 --> 00:23:34,080
and we refer to the paper for more

646
00:23:34,080 --> 00:23:35,600
details but we encourage you to have a

647
00:23:35,600 --> 00:23:36,960
look because we believe this is a very

648
00:23:36,960 --> 00:23:39,919
powerful composition technique

649
00:23:39,919 --> 00:23:43,120
which requires at the cost of having a

650
00:23:43,120 --> 00:23:45,039
computational assumption

651
00:23:45,039 --> 00:23:48,320
but still very interesting in my opinion

652
00:23:48,320 --> 00:23:50,960
so just to finish um

653
00:23:50,960 --> 00:23:53,200
let me say again that uh

654
00:23:53,200 --> 00:23:54,799
what we do in this work is to study

655
00:23:54,799 --> 00:23:56,400
another technique for combining skin

656
00:23:56,400 --> 00:23:58,320
protocols

657
00:23:58,320 --> 00:24:00,080
into non-interactive serum knowledge

658
00:24:00,080 --> 00:24:02,480
spray systems that can be proven in the

659
00:24:02,480 --> 00:24:04,960
programmable order and the micro model

660
00:24:04,960 --> 00:24:07,039
and our our new technique allows us to

661
00:24:07,039 --> 00:24:09,679
combine signal protocols and predicate

662
00:24:09,679 --> 00:24:10,960
expressed

663
00:24:10,960 --> 00:24:12,960
in a new model of computation which is a

664
00:24:12,960 --> 00:24:14,559
simplicity programming

665
00:24:14,559 --> 00:24:16,480
that is not comparable to existing

666
00:24:16,480 --> 00:24:18,000
techniques

667
00:24:18,000 --> 00:24:21,440
thank you very much for your attention

668
00:24:30,159 --> 00:24:33,840
questions from the audience

669
00:24:35,120 --> 00:24:36,320
all right great let's thank the girl

670
00:24:36,320 --> 00:24:36,920
again

671
00:24:36,920 --> 00:24:40,469
[Applause]

672
00:24:44,080 --> 00:24:44,880
our

673
00:24:44,880 --> 00:24:47,360
next speaker

674
00:24:47,360 --> 00:24:50,600
is live

675
00:25:01,360 --> 00:25:04,840
here we go

676
00:25:16,320 --> 00:25:18,159
great so our next talk will be on

677
00:25:18,159 --> 00:25:20,400
statistical zabs from group-based

678
00:25:20,400 --> 00:25:24,000
assumptions is by jeffrey kattah

679
00:25:24,000 --> 00:25:28,960
katsumata allah sadagi and bogdan ursu

680
00:25:30,400 --> 00:25:33,390
thank you for the introduction

681
00:25:33,390 --> 00:25:34,880
[Music]

682
00:25:34,880 --> 00:25:36,720
thank you

683
00:25:36,720 --> 00:25:38,880
so first i want to

684
00:25:38,880 --> 00:25:41,120
recall the definition of slab protocols

685
00:25:41,120 --> 00:25:42,880
to make sure that everyone here knows

686
00:25:42,880 --> 00:25:44,960
what we're talking about

687
00:25:44,960 --> 00:25:47,200
so

688
00:25:52,480 --> 00:25:53,520
okay

689
00:25:53,520 --> 00:25:54,240
so

690
00:25:54,240 --> 00:25:57,360
as that protocol uh is similar to a

691
00:25:57,360 --> 00:25:59,200
non-interactive zero knowledge protocol

692
00:25:59,200 --> 00:26:01,520
with some slight differences

693
00:26:01,520 --> 00:26:04,080
uh z protocol is a true message protocol

694
00:26:04,080 --> 00:26:06,000
in the plane model so

695
00:26:06,000 --> 00:26:08,880
uh there is no trusted setup to generate

696
00:26:08,880 --> 00:26:11,360
the cr sphere for us and the protocol

697
00:26:11,360 --> 00:26:12,720
involves two

698
00:26:12,720 --> 00:26:14,799
parties approval and verifier and

699
00:26:14,799 --> 00:26:17,200
approver after receiving a message from

700
00:26:17,200 --> 00:26:18,799
the verifier

701
00:26:18,799 --> 00:26:20,880
wants to prove that some statement like

702
00:26:20,880 --> 00:26:23,360
x is in some language later

703
00:26:23,360 --> 00:26:26,400
the protocol has three main properties

704
00:26:26,400 --> 00:26:28,960
which the first two is completeness and

705
00:26:28,960 --> 00:26:30,400
soundness as

706
00:26:30,400 --> 00:26:33,120
and they're similar to the definition in

707
00:26:33,120 --> 00:26:35,360
the interactive zero knowledge protocols

708
00:26:35,360 --> 00:26:38,480
and the last one is a relaxation of the

709
00:26:38,480 --> 00:26:40,640
zebra knowledge property which is called

710
00:26:40,640 --> 00:26:43,039
witness indistinguishability which says

711
00:26:43,039 --> 00:26:45,120
that if there exists two businesses like

712
00:26:45,120 --> 00:26:48,799
w0 and w1 for the same statement x the

713
00:26:48,799 --> 00:26:50,640
verifier should not be able to

714
00:26:50,640 --> 00:26:53,200
distinguish between two words that in

715
00:26:53,200 --> 00:26:56,400
one proverb uses w0 to produce the proof

716
00:26:56,400 --> 00:26:58,640
and in the other approval uses w1 to

717
00:26:58,640 --> 00:27:01,440
produce the rules

718
00:27:01,440 --> 00:27:04,159
there are two types of that protocols

719
00:27:04,159 --> 00:27:06,720
first is computational zebras which we

720
00:27:06,720 --> 00:27:08,320
have statistical soundness and

721
00:27:08,320 --> 00:27:09,480
computational witness

722
00:27:09,480 --> 00:27:11,679
indistinguishability in them and the

723
00:27:11,679 --> 00:27:13,919
other is the statistical zap arguments

724
00:27:13,919 --> 00:27:15,840
which we have computational soundness

725
00:27:15,840 --> 00:27:17,039
and statistical witnessing

726
00:27:17,039 --> 00:27:19,279
distinguishability in them

727
00:27:19,279 --> 00:27:20,880
the reason that we care about the

728
00:27:20,880 --> 00:27:23,360
statistical zap arguments in particular

729
00:27:23,360 --> 00:27:25,679
is that soundness is some unlike

730
00:27:25,679 --> 00:27:28,080
security notion which means that

731
00:27:28,080 --> 00:27:29,919
if this is the

732
00:27:29,919 --> 00:27:31,520
time period that the proof is being

733
00:27:31,520 --> 00:27:33,919
generated in the protocol the adversary

734
00:27:33,919 --> 00:27:36,399
wants to attack soundness during this

735
00:27:36,399 --> 00:27:39,600
period of time and after the proof is

736
00:27:39,600 --> 00:27:41,600
being generated we don't care about

737
00:27:41,600 --> 00:27:43,799
soundness anymore but witnessing

738
00:27:43,799 --> 00:27:45,919
distinguishability is the property that

739
00:27:45,919 --> 00:27:48,159
we wanted to be realizing because the

740
00:27:48,159 --> 00:27:50,640
adversary wants to attack it even after

741
00:27:50,640 --> 00:27:52,720
the proof is being generated

742
00:27:52,720 --> 00:27:55,440
so between these two properties we want

743
00:27:55,440 --> 00:27:57,200
to we want status

744
00:27:57,200 --> 00:27:59,279
we want witness in distinguishability to

745
00:27:59,279 --> 00:28:02,399
be statistical

746
00:28:02,399 --> 00:28:03,760
there has been constructions of

747
00:28:03,760 --> 00:28:06,000
computational lab groups from different

748
00:28:06,000 --> 00:28:07,520
assumptions such as trapdoor

749
00:28:07,520 --> 00:28:11,760
permutations bilinear maps i or lwe

750
00:28:11,760 --> 00:28:14,000
and from a recent work there has been a

751
00:28:14,000 --> 00:28:16,559
construction of zappos and

752
00:28:16,559 --> 00:28:19,120
statistical lab arguments

753
00:28:19,120 --> 00:28:20,960
based on quality polynomial hardness of

754
00:28:20,960 --> 00:28:22,880
lwe

755
00:28:22,880 --> 00:28:24,640
but the question of can we have

756
00:28:24,640 --> 00:28:26,480
statistical zap arguments from

757
00:28:26,480 --> 00:28:29,520
assumptions other than lwe remains open

758
00:28:29,520 --> 00:28:32,240
in our work we introduce a framework for

759
00:28:32,240 --> 00:28:35,120
constructing statistical zaps for mp and

760
00:28:35,120 --> 00:28:36,720
we gave two instantiations of

761
00:28:36,720 --> 00:28:39,520
statistical steps one in pairing groups

762
00:28:39,520 --> 00:28:42,000
based on explicit hardness of pdh and

763
00:28:42,000 --> 00:28:44,720
kernel difficult assumption and other in

764
00:28:44,720 --> 00:28:46,960
paving through groups based on explicit

765
00:28:46,960 --> 00:28:50,320
hardness of ddh and strong one-way kdm

766
00:28:50,320 --> 00:28:52,799
security of elgamal encryption

767
00:28:52,799 --> 00:28:54,880
and in a concurrent and independent

768
00:28:54,880 --> 00:28:56,640
world there has been a construction of

769
00:28:56,640 --> 00:28:58,799
the statisticals zap arguments based on

770
00:28:58,799 --> 00:29:01,360
sub-exponential harness of ddh impeding

771
00:29:01,360 --> 00:29:02,799
free groups

772
00:29:02,799 --> 00:29:05,279
which we heard a little about it from an

773
00:29:05,279 --> 00:29:08,799
audio type by abhishek j

774
00:29:08,880 --> 00:29:12,000
so to give you the idea of our work we

775
00:29:12,000 --> 00:29:14,080
want to start with some unconditional

776
00:29:14,080 --> 00:29:16,559
music in the hidden bits model and get a

777
00:29:16,559 --> 00:29:18,320
statistical zap for emptying the play

778
00:29:18,320 --> 00:29:21,279
model from it and in order to make this

779
00:29:21,279 --> 00:29:23,360
transformation we needed some kind of

780
00:29:23,360 --> 00:29:25,520
freedom which generator which we call it

781
00:29:25,520 --> 00:29:29,120
interactive generator in our paper

782
00:29:29,120 --> 00:29:31,120
our starting point was some previous

783
00:29:31,120 --> 00:29:32,480
construction

784
00:29:32,480 --> 00:29:33,159
of

785
00:29:33,159 --> 00:29:36,399
lpw and in their work

786
00:29:36,399 --> 00:29:37,440
they

787
00:29:37,440 --> 00:29:40,000
get a download designated verifier music

788
00:29:40,000 --> 00:29:42,080
in the series model from and is it in

789
00:29:42,080 --> 00:29:43,919
the hidden bits model

790
00:29:43,919 --> 00:29:46,880
by using a dual mode designated verifier

791
00:29:46,880 --> 00:29:49,039
heat embeds generator

792
00:29:49,039 --> 00:29:52,240
in order to use their work and

793
00:29:52,240 --> 00:29:53,679
in the zap

794
00:29:53,679 --> 00:29:55,840
uh we wanted to maintain the download

795
00:29:55,840 --> 00:29:58,240
property of the hidden risk generator

796
00:29:58,240 --> 00:30:00,640
and uh we wanted to

797
00:30:00,640 --> 00:30:02,960
do it in in a way to be publicly

798
00:30:02,960 --> 00:30:05,120
verifiable instead of designated very

799
00:30:05,120 --> 00:30:07,600
far setting so we needed to be a little

800
00:30:07,600 --> 00:30:08,960
creative here

801
00:30:08,960 --> 00:30:09,840
uh

802
00:30:09,840 --> 00:30:12,720
the idea to uh maintain the dual mode

803
00:30:12,720 --> 00:30:14,799
property of the hideous generator was to

804
00:30:14,799 --> 00:30:16,720
first let the verifiers sample the

805
00:30:16,720 --> 00:30:19,279
service which is a common approach and

806
00:30:19,279 --> 00:30:22,000
then let the approver to tweak the crs

807
00:30:22,000 --> 00:30:24,080
to protect itself from ammunition's

808
00:30:24,080 --> 00:30:26,720
verifier and we needed to come up with

809
00:30:26,720 --> 00:30:28,720
some bill chosen to each here

810
00:30:28,720 --> 00:30:31,120
and in order to make the construction

811
00:30:31,120 --> 00:30:33,360
publicly verifiable we used a

812
00:30:33,360 --> 00:30:36,159
statistical zap for some simple language

813
00:30:36,159 --> 00:30:38,320
and by combining these ideas we were

814
00:30:38,320 --> 00:30:41,200
able to get a statistical zap foreign

815
00:30:41,200 --> 00:30:43,440
model farm and unconditional music in

816
00:30:43,440 --> 00:30:45,279
the hidden model

817
00:30:45,279 --> 00:30:48,399
for more details i refer to the actual

818
00:30:48,399 --> 00:30:49,600
paper

819
00:30:49,600 --> 00:30:51,919
i want to finish my touch with some open

820
00:30:51,919 --> 00:30:53,679
problems in this area

821
00:30:53,679 --> 00:30:55,120
so first

822
00:30:55,120 --> 00:30:57,360
is that can we have constructions of

823
00:30:57,360 --> 00:30:59,600
statistical zap arguments only from

824
00:30:59,600 --> 00:31:02,000
search assumptions our construction

825
00:31:02,000 --> 00:31:05,120
relied on ddh so one possible question

826
00:31:05,120 --> 00:31:08,240
can be can we relax cdh cbh

827
00:31:08,240 --> 00:31:10,240
another question that can come to mind

828
00:31:10,240 --> 00:31:12,320
is that can we have constructions of

829
00:31:12,320 --> 00:31:14,640
slabs in general from assumptions that

830
00:31:14,640 --> 00:31:17,440
is not known to imply pka

831
00:31:17,440 --> 00:31:19,360
i would be happy to

832
00:31:19,360 --> 00:31:23,559
take any questions thank you

833
00:31:32,640 --> 00:31:35,519
i'll give you a question

834
00:31:38,240 --> 00:31:39,519
actually i have a question so what do

835
00:31:39,519 --> 00:31:42,240
you mean by explicit hardness of ddh is

836
00:31:42,240 --> 00:31:43,600
that different than sub-exponential

837
00:31:43,600 --> 00:31:46,000
hardness uh so by exclusive harvest i

838
00:31:46,000 --> 00:31:48,559
mean that will require a an explicit

839
00:31:48,559 --> 00:31:50,640
bound for the advantage of the ppt

840
00:31:50,640 --> 00:31:53,440
adversary against consumption

841
00:31:53,440 --> 00:31:58,279
is it exponential uh it's uh

842
00:32:00,000 --> 00:32:02,040
thank you

843
00:32:02,040 --> 00:32:05,369
[Applause]

844
00:32:26,080 --> 00:32:29,240
this one

845
00:32:30,420 --> 00:32:33,569
[Music]

846
00:32:47,039 --> 00:32:48,559
all right great so our last thought will

847
00:32:48,559 --> 00:32:50,159
be on generalized clues of knowledge

848
00:32:50,159 --> 00:32:53,039
with fully dynamic setup by uh christian

849
00:32:53,039 --> 00:32:55,679
badger daniel joes and ulimar and daniel

850
00:32:55,679 --> 00:32:58,399
will get the talk

851
00:32:58,640 --> 00:33:02,000
okay so welcome everybody to my talk so

852
00:33:02,000 --> 00:33:04,240
this is generous proof of knowledge with

853
00:33:04,240 --> 00:33:06,080
fully dynamic sata

854
00:33:06,080 --> 00:33:07,679
which is trying to work with christian

855
00:33:07,679 --> 00:33:11,799
badger and wally mourinho

856
00:33:12,640 --> 00:33:14,320
okay

857
00:33:14,320 --> 00:33:16,480
so

858
00:33:16,960 --> 00:33:18,799
as you probably all know proof of

859
00:33:18,799 --> 00:33:20,559
knowledge is one of the most influential

860
00:33:20,559 --> 00:33:22,720
abstraction in cryptography which has

861
00:33:22,720 --> 00:33:25,760
tons and tons of tons of applications

862
00:33:25,760 --> 00:33:28,159
so in a proof of knowledge people there

863
00:33:28,159 --> 00:33:30,000
there's some kind of relation there's

864
00:33:30,000 --> 00:33:31,760
approver that has a witness for that

865
00:33:31,760 --> 00:33:33,679
relation and wants to convince the

866
00:33:33,679 --> 00:33:36,159
verifier that he knows a witness

867
00:33:36,159 --> 00:33:38,080
and typically it's supposed to be zero

868
00:33:38,080 --> 00:33:39,360
knowledge so

869
00:33:39,360 --> 00:33:41,200
the approver doesn't just want to reveal

870
00:33:41,200 --> 00:33:42,799
the witness but

871
00:33:42,799 --> 00:33:44,799
they run some kind of interactive

872
00:33:44,799 --> 00:33:47,039
protocol

873
00:33:47,039 --> 00:33:49,519
unfortunately there are applications

874
00:33:49,519 --> 00:33:51,360
where this very general notion of proof

875
00:33:51,360 --> 00:33:54,080
of knowledge is still not just general

876
00:33:54,080 --> 00:33:55,760
enough and

877
00:33:55,760 --> 00:33:56,960
yeah so

878
00:33:56,960 --> 00:33:59,679
let me give some you some examples so

879
00:33:59,679 --> 00:34:01,840
one of them is let's say you want to do

880
00:34:01,840 --> 00:34:03,760
some password-based authentication

881
00:34:03,760 --> 00:34:06,480
protocol where you have a user that has

882
00:34:06,480 --> 00:34:08,480
a username and a password that wants to

883
00:34:08,480 --> 00:34:11,119
log into some server

884
00:34:11,119 --> 00:34:12,960
so essentially the user wants to prove

885
00:34:12,960 --> 00:34:14,480
to the server that they know their

886
00:34:14,480 --> 00:34:16,000
password

887
00:34:16,000 --> 00:34:18,159
another example would be a so-called

888
00:34:18,159 --> 00:34:20,480
proof of ownership there you have a

889
00:34:20,480 --> 00:34:22,000
server with

890
00:34:22,000 --> 00:34:24,239
which stores a bunch of files and the

891
00:34:24,239 --> 00:34:26,639
user wants to prove to the server that

892
00:34:26,639 --> 00:34:28,560
they know the content of one of those

893
00:34:28,560 --> 00:34:30,879
files hopefully in a much more efficient

894
00:34:30,879 --> 00:34:33,280
way than just uploading the whole file

895
00:34:33,280 --> 00:34:35,359
to the server

896
00:34:35,359 --> 00:34:36,079
so

897
00:34:36,079 --> 00:34:38,000
again essentially the approver wants to

898
00:34:38,000 --> 00:34:40,000
prove that they know the content of the

899
00:34:40,000 --> 00:34:41,280
file

900
00:34:41,280 --> 00:34:44,159
yet for neither of the two applications

901
00:34:44,159 --> 00:34:46,480
we can formalize this using the standard

902
00:34:46,480 --> 00:34:48,320
proof of knowledge abstraction because

903
00:34:48,320 --> 00:34:50,159
it just doesn't seem to be generic

904
00:34:50,159 --> 00:34:51,599
enough

905
00:34:51,599 --> 00:34:55,520
instead for both topics sort of entropy

906
00:34:55,520 --> 00:34:58,160
based security definition which seem to

907
00:34:58,160 --> 00:35:00,400
be fairly tailor-made the particular

908
00:35:00,400 --> 00:35:03,440
application have emerged

909
00:35:03,440 --> 00:35:06,320
and indeed there's actually quite a long

910
00:35:06,320 --> 00:35:08,640
list of generalizations of proof of

911
00:35:08,640 --> 00:35:09,680
knowledge

912
00:35:09,680 --> 00:35:12,240
that tackle various aspects

913
00:35:12,240 --> 00:35:14,400
for instance in a proof of knowledge

914
00:35:14,400 --> 00:35:17,839
we have a very static statement and

915
00:35:17,839 --> 00:35:19,920
witness which are just bit strings that

916
00:35:19,920 --> 00:35:22,400
are assumed to be given to the parties

917
00:35:22,400 --> 00:35:24,720
but in many applications it seems like

918
00:35:24,720 --> 00:35:27,040
you have just two parties that approach

919
00:35:27,040 --> 00:35:28,960
each other they first need to sort of

920
00:35:28,960 --> 00:35:31,280
talk to each other and then see what

921
00:35:31,280 --> 00:35:33,280
kind of statements they actually want to

922
00:35:33,280 --> 00:35:35,520
prove

923
00:35:35,520 --> 00:35:38,000
another thing is that in the standard

924
00:35:38,000 --> 00:35:40,480
proof of knowledge notion the relation

925
00:35:40,480 --> 00:35:42,240
is assumed to be fixed and known

926
00:35:42,240 --> 00:35:44,640
beforehand so we can build a protocol

927
00:35:44,640 --> 00:35:47,359
for a specific relation which is also

928
00:35:47,359 --> 00:35:49,520
not always the case

929
00:35:49,520 --> 00:35:50,880
then third

930
00:35:50,880 --> 00:35:52,640
there could be setup which is not

931
00:35:52,640 --> 00:35:54,880
something accounted for in proof of

932
00:35:54,880 --> 00:35:55,920
knowledge

933
00:35:55,920 --> 00:35:58,960
and in particular um in this work with

934
00:35:58,960 --> 00:36:01,200
the first one that actually look at

935
00:36:01,200 --> 00:36:03,599
setup dependent relations and fully

936
00:36:03,599 --> 00:36:05,440
generalization so previous

937
00:36:05,440 --> 00:36:07,599
generalization just looked at like one

938
00:36:07,599 --> 00:36:09,839
kind of setup and made proof of

939
00:36:09,839 --> 00:36:13,799
knowledge for this setup

940
00:36:13,920 --> 00:36:15,280
so

941
00:36:15,280 --> 00:36:18,320
in a bit more detail i mean this work we

942
00:36:18,320 --> 00:36:20,640
introduce a generalization notion of

943
00:36:20,640 --> 00:36:24,000
proof of knowledge which income passes

944
00:36:24,000 --> 00:36:26,560
dynamic setup

945
00:36:26,560 --> 00:36:29,680
a dynamic agreement phase where parties

946
00:36:29,680 --> 00:36:32,160
agree first on the statements then we

947
00:36:32,160 --> 00:36:34,880
treat dynamic and fully

948
00:36:34,880 --> 00:36:38,079
reactive setups and we call this notion

949
00:36:38,079 --> 00:36:40,560
agreement proof it unifies essentially

950
00:36:40,560 --> 00:36:41,920
all the existing proof of knowledge

951
00:36:41,920 --> 00:36:44,560
generalization and it obviously comes

952
00:36:44,560 --> 00:36:46,720
with clear semantics with respect to

953
00:36:46,720 --> 00:36:49,839
correct assignments and zero knowledge

954
00:36:49,839 --> 00:36:52,000
in our work we then apply this framework

955
00:36:52,000 --> 00:36:54,560
to two applications one of them is this

956
00:36:54,560 --> 00:36:56,880
proof of ownership and the other one is

957
00:36:56,880 --> 00:36:58,000
two-factor

958
00:36:58,000 --> 00:37:00,640
entity authentication which is actually

959
00:37:00,640 --> 00:37:02,800
a generalization of password-based login

960
00:37:02,800 --> 00:37:04,160
where you assume that there's also some

961
00:37:04,160 --> 00:37:06,400
kind of abstract hardware token where

962
00:37:06,400 --> 00:37:08,640
the user wants to prove that they have

963
00:37:08,640 --> 00:37:10,800
access to this token and can interact

964
00:37:10,800 --> 00:37:12,800
with it correctly

965
00:37:12,800 --> 00:37:15,760
um finally in recent work vidiq and song

966
00:37:15,760 --> 00:37:18,079
in eurocrypt 21 also adapted our

967
00:37:18,079 --> 00:37:22,880
framework to the quantum setting

968
00:37:23,119 --> 00:37:25,280
so just to give you a very high level

969
00:37:25,280 --> 00:37:27,440
two minutes description of our notion

970
00:37:27,440 --> 00:37:29,359
essentially what we do is we split the

971
00:37:29,359 --> 00:37:32,079
program to verify both in two phases

972
00:37:32,079 --> 00:37:34,160
we have a so-called agreement phase in

973
00:37:34,160 --> 00:37:37,040
which they agree on a statement x

974
00:37:37,040 --> 00:37:39,760
and then they both output the state and

975
00:37:39,760 --> 00:37:41,599
the second phase then actually does the

976
00:37:41,599 --> 00:37:43,920
proof and they output the bit saying

977
00:37:43,920 --> 00:37:45,599
whether the proof has been accepted or

978
00:37:45,599 --> 00:37:46,800
not

979
00:37:46,800 --> 00:37:48,960
all of those four algorithms interact

980
00:37:48,960 --> 00:37:51,119
with general setup and i should say this

981
00:37:51,119 --> 00:37:54,000
is really a uc type general setup that

982
00:37:54,000 --> 00:37:55,440
is stateful

983
00:37:55,440 --> 00:37:57,520
and that can provide different kind of

984
00:37:57,520 --> 00:37:59,520
interfaces to both the prover and the

985
00:37:59,520 --> 00:38:01,920
verifier and so on

986
00:38:01,920 --> 00:38:03,920
finally there's also what we call an

987
00:38:03,920 --> 00:38:06,960
input generation algorithm that just

988
00:38:06,960 --> 00:38:10,400
interacts with the setup beforehand and

989
00:38:10,400 --> 00:38:12,480
gives an initial input to both the

990
00:38:12,480 --> 00:38:15,760
program the verifier

991
00:38:16,720 --> 00:38:18,720
based on this template we then define

992
00:38:18,720 --> 00:38:21,040
what correctness mean basically if a

993
00:38:21,040 --> 00:38:22,960
non-misapproval and anonymous verifier

994
00:38:22,960 --> 00:38:24,400
interact with each other they should

995
00:38:24,400 --> 00:38:27,040
both agree on the same statement

996
00:38:27,040 --> 00:38:28,400
and then

997
00:38:28,400 --> 00:38:30,720
they should also both accept unless

998
00:38:30,720 --> 00:38:33,040
their statement was explicitly abort

999
00:38:33,040 --> 00:38:34,960
which could be in case they just don't

1000
00:38:34,960 --> 00:38:37,280
have a common ground where approve would

1001
00:38:37,280 --> 00:38:39,520
be successful

1002
00:38:39,520 --> 00:38:42,320
our notion is also parameterized in what

1003
00:38:42,320 --> 00:38:45,040
we call an agreement notion that

1004
00:38:45,040 --> 00:38:47,280
specifies essentially which kind of

1005
00:38:47,280 --> 00:38:50,560
statement are valid given two parties

1006
00:38:50,560 --> 00:38:53,359
um states at the very beginning of the

1007
00:38:53,359 --> 00:38:55,040
protocol so given their view on the

1008
00:38:55,040 --> 00:38:57,839
setup and given their auxiliary inputs

1009
00:38:57,839 --> 00:38:59,839
this is mainly done to rule out real

1010
00:38:59,839 --> 00:39:01,680
protocols where for instance they could

1011
00:39:01,680 --> 00:39:04,000
just always agree on a board

1012
00:39:04,000 --> 00:39:06,000
or they could always agree on one

1013
00:39:06,000 --> 00:39:08,079
particular statement for which the proof

1014
00:39:08,079 --> 00:39:11,280
would be much easier

1015
00:39:11,760 --> 00:39:13,680
then obviously because this is proof of

1016
00:39:13,680 --> 00:39:15,920
knowledge tie generalization of proof of

1017
00:39:15,920 --> 00:39:17,200
knowledge does have a soundness

1018
00:39:17,200 --> 00:39:18,640
experiment

1019
00:39:18,640 --> 00:39:21,839
and there um we have a proof relation

1020
00:39:21,839 --> 00:39:23,920
which is really just the analogous to

1021
00:39:23,920 --> 00:39:26,240
the relation of proof of knowledge

1022
00:39:26,240 --> 00:39:28,720
but here it can really it can depend on

1023
00:39:28,720 --> 00:39:31,040
the setup and that means we formalize

1024
00:39:31,040 --> 00:39:32,800
this as an

1025
00:39:32,800 --> 00:39:35,520
as a stateless algorithm that can make

1026
00:39:35,520 --> 00:39:38,079
oracle invocations to the setup and also

1027
00:39:38,079 --> 00:39:40,839
gets the statement and the

1028
00:39:40,839 --> 00:39:44,320
witness so in this song is experiment we

1029
00:39:44,320 --> 00:39:46,960
run the agreement phase just once that

1030
00:39:46,960 --> 00:39:48,560
gives us the

1031
00:39:48,560 --> 00:39:50,960
statement and then we say okay whenever

1032
00:39:50,960 --> 00:39:51,760
they

1033
00:39:51,760 --> 00:39:53,359
whenever with this statement the

1034
00:39:53,359 --> 00:39:55,119
dishonest proof can convince the

1035
00:39:55,119 --> 00:39:57,520
verifier then this group must have known

1036
00:39:57,520 --> 00:39:59,760
a witness for that for that particular

1037
00:39:59,760 --> 00:40:01,119
statement

1038
00:40:01,119 --> 00:40:02,640
and we formalized this using an

1039
00:40:02,640 --> 00:40:05,040
extractor that has black box rewinding

1040
00:40:05,040 --> 00:40:07,520
access to the second grouper and in

1041
00:40:07,520 --> 00:40:09,520
addition it also gets the communication

1042
00:40:09,520 --> 00:40:11,920
transcript of the first phase as well as

1043
00:40:11,920 --> 00:40:13,920
all the setup queries the first phase

1044
00:40:13,920 --> 00:40:15,040
made

1045
00:40:15,040 --> 00:40:17,520
this is mainly made so that we can

1046
00:40:17,520 --> 00:40:19,599
have more efficient protocol where if

1047
00:40:19,599 --> 00:40:22,640
you have a very involved first phase

1048
00:40:22,640 --> 00:40:25,200
then you don't need to have a full um

1049
00:40:25,200 --> 00:40:27,440
maybe not the full proof of knowledge as

1050
00:40:27,440 --> 00:40:29,280
a second phase but can do something more

1051
00:40:29,280 --> 00:40:31,280
efficient

1052
00:40:31,280 --> 00:40:33,359
and then there's some technicalities for

1053
00:40:33,359 --> 00:40:35,680
instance we need because this proof

1054
00:40:35,680 --> 00:40:37,920
relation is no longer necessarily public

1055
00:40:37,920 --> 00:40:39,920
we need to give the extractor access to

1056
00:40:39,920 --> 00:40:40,800
this

1057
00:40:40,800 --> 00:40:42,640
it also needs to have

1058
00:40:42,640 --> 00:40:45,119
access to um the setup functionality

1059
00:40:45,119 --> 00:40:46,960
from the view of the viewer and so on

1060
00:40:46,960 --> 00:40:48,160
but i

1061
00:40:48,160 --> 00:40:49,839
i really refer you to the paper for

1062
00:40:49,839 --> 00:40:50,839
those

1063
00:40:50,839 --> 00:40:53,680
details finally i should mention that we

1064
00:40:53,680 --> 00:40:55,680
obviously then formalize zero knowledge

1065
00:40:55,680 --> 00:40:58,319
and actually here we have two versions

1066
00:40:58,319 --> 00:41:00,000
of zero knowledge for both the prover

1067
00:41:00,000 --> 00:41:01,440
and the verifier

1068
00:41:01,440 --> 00:41:03,119
so whereas in standard proof of

1069
00:41:03,119 --> 00:41:05,040
knowledge the verifier has no secret

1070
00:41:05,040 --> 00:41:07,599
just the public statement here in

1071
00:41:07,599 --> 00:41:09,760
principle the verifier can just have

1072
00:41:09,760 --> 00:41:11,440
secrets as well as the program for

1073
00:41:11,440 --> 00:41:13,440
instance his view on the setup function

1074
00:41:13,440 --> 00:41:15,920
could be very different and he does not

1075
00:41:15,920 --> 00:41:19,119
want to real secret information there

1076
00:41:19,119 --> 00:41:21,520
also we parameterize our notion in

1077
00:41:21,520 --> 00:41:23,839
explicit leakage so if you have protocol

1078
00:41:23,839 --> 00:41:25,359
that's maybe not perfectly zero

1079
00:41:25,359 --> 00:41:26,640
knowledge but has some kind of

1080
00:41:26,640 --> 00:41:28,560
well-defined leakage you can also use

1081
00:41:28,560 --> 00:41:31,280
our framework to model that

1082
00:41:31,280 --> 00:41:33,760
finally we consider both programmable

1083
00:41:33,760 --> 00:41:36,800
and non-programmable setup and we also

1084
00:41:36,800 --> 00:41:39,520
show some very limited composability

1085
00:41:39,520 --> 00:41:42,000
results

1086
00:41:42,000 --> 00:41:44,960
so to wrap up in our work we form we

1087
00:41:44,960 --> 00:41:46,640
introduced this

1088
00:41:46,640 --> 00:41:48,400
generalization of proof of knowledge

1089
00:41:48,400 --> 00:41:50,400
that's the first one that treats fully

1090
00:41:50,400 --> 00:41:52,000
dynamic setup

1091
00:41:52,000 --> 00:41:54,560
dynamic and setup dependent relations

1092
00:41:54,560 --> 00:41:55,359
and

1093
00:41:55,359 --> 00:41:56,720
dynamic

1094
00:41:56,720 --> 00:41:58,319
statements

1095
00:41:58,319 --> 00:42:01,359
dynamic statement agreement phase

1096
00:42:01,359 --> 00:42:04,240
and we show the usefulness of this work

1097
00:42:04,240 --> 00:42:05,119
by

1098
00:42:05,119 --> 00:42:07,119
modeling two applications that

1099
00:42:07,119 --> 00:42:09,280
previously could not be modeled as a

1100
00:42:09,280 --> 00:42:10,720
proof of knowledge

1101
00:42:10,720 --> 00:42:13,040
in our framework

1102
00:42:13,040 --> 00:42:16,839
thank you for your attention

1103
00:42:25,359 --> 00:42:27,440
do you have any examples maybe of uh

1104
00:42:27,440 --> 00:42:29,280
where kind of standard notions of zero

1105
00:42:29,280 --> 00:42:30,560
knowledge group of knowledge would not

1106
00:42:30,560 --> 00:42:32,880
suffice but kind of you need this extra

1107
00:42:32,880 --> 00:42:34,560
strengthening from the work you can like

1108
00:42:34,560 --> 00:42:37,760
actually show something goes wrong

1109
00:42:37,760 --> 00:42:39,839
so one example is for instance this

1110
00:42:39,839 --> 00:42:42,880
password-based authentication you

1111
00:42:42,880 --> 00:42:45,359
generally the relation between the

1112
00:42:45,359 --> 00:42:47,760
username and their password their digest

1113
00:42:47,760 --> 00:42:49,440
their password is just not an np

1114
00:42:49,440 --> 00:42:51,920
relation that you can assume to be fixed

1115
00:42:51,920 --> 00:42:55,280
beforehand you design the protocol so

1116
00:42:55,280 --> 00:42:57,520
instead yeah and also it's definitely

1117
00:42:57,520 --> 00:42:59,760
not something that's public so you don't

1118
00:42:59,760 --> 00:43:02,960
want that the brewer can verify password

1119
00:43:02,960 --> 00:43:05,520
guesses themselves so there we really

1120
00:43:05,520 --> 00:43:07,359
need this

1121
00:43:07,359 --> 00:43:10,079
we need that our functionality can model

1122
00:43:10,079 --> 00:43:12,160
some kind of user database where

1123
00:43:12,160 --> 00:43:14,640
different parties have different views

1124
00:43:14,640 --> 00:43:16,560
on it and can interact with you

1125
00:43:16,560 --> 00:43:19,200
differently

1126
00:43:21,520 --> 00:43:23,359
questions

1127
00:43:23,359 --> 00:43:27,078
all right thank you

1128
00:43:49,760 --> 00:43:51,839
you

