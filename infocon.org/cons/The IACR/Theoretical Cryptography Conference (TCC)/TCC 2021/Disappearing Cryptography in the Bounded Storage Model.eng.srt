1
00:00:00,960 --> 00:00:03,760
hi everyone my name is jashin guan and

2
00:00:03,760 --> 00:00:05,279
in this video i'll be talking about our

3
00:00:05,279 --> 00:00:07,279
work disappearing cryptography in the

4
00:00:07,279 --> 00:00:09,040
boundary storage model

5
00:00:09,040 --> 00:00:11,440
this is a joint work with mark zandry

6
00:00:11,440 --> 00:00:13,280
both of us are from princeton university

7
00:00:13,280 --> 00:00:16,079
and ntt research

8
00:00:16,079 --> 00:00:18,160
you can tell our title consists of two

9
00:00:18,160 --> 00:00:20,160
parts the first part being disappearing

10
00:00:20,160 --> 00:00:21,439
cryptography

11
00:00:21,439 --> 00:00:23,600
so what do we mean by disappearing

12
00:00:23,600 --> 00:00:25,119
cryptography does it mean that the

13
00:00:25,119 --> 00:00:26,800
crypto just disappear

14
00:00:26,800 --> 00:00:29,279
not really so let me show you what we

15
00:00:29,279 --> 00:00:33,039
mean through a series of stories

16
00:00:33,040 --> 00:00:34,800
let us invite out our favorite friends

17
00:00:34,800 --> 00:00:36,079
edison bob

18
00:00:36,079 --> 00:00:37,760
so suppose alice is sending already

19
00:00:37,760 --> 00:00:39,520
encrypted message to bob

20
00:00:39,520 --> 00:00:42,320
and there comes our eavesdropper eve who

21
00:00:42,320 --> 00:00:44,160
is listening on the channel and

22
00:00:44,160 --> 00:00:46,480
intercepts a message so what you can do

23
00:00:46,480 --> 00:00:47,760
is that he can make a copy of the

24
00:00:47,760 --> 00:00:48,719
message

25
00:00:48,719 --> 00:00:51,920
and at a later time if could through

26
00:00:51,920 --> 00:00:55,280
social engineering or interrogation

27
00:00:55,280 --> 00:00:57,600
extracts the secret key from bob and

28
00:00:57,600 --> 00:00:59,920
then use that secret key to decrypt the

29
00:00:59,920 --> 00:01:02,320
message and then maybe retrieve a cute

30
00:01:02,320 --> 00:01:03,840
picture of a cat

31
00:01:03,840 --> 00:01:05,119
so

32
00:01:05,119 --> 00:01:08,159
what we want is that even if eve is able

33
00:01:08,159 --> 00:01:10,799
to get the secret key in the future we

34
00:01:10,799 --> 00:01:13,200
want the previously transmitted messages

35
00:01:13,200 --> 00:01:14,799
to be still secure

36
00:01:14,799 --> 00:01:16,560
this is what's referred to as forward

37
00:01:16,560 --> 00:01:19,439
secrecy essentially meaning that a

38
00:01:19,439 --> 00:01:21,280
leaked secret key in the future should

39
00:01:21,280 --> 00:01:22,880
not compromise the security of the

40
00:01:22,880 --> 00:01:24,799
messages that has been transmitted

41
00:01:24,799 --> 00:01:27,200
before that

42
00:01:27,200 --> 00:01:29,680
let's consider the following scenario

43
00:01:29,680 --> 00:01:31,280
so again alice is sending over some

44
00:01:31,280 --> 00:01:33,040
incredible messages to bob and here

45
00:01:33,040 --> 00:01:35,119
comes our instructor eve who makes a

46
00:01:35,119 --> 00:01:38,159
copy of the encrypt of the cipher text

47
00:01:38,159 --> 00:01:40,720
so here assume that through some magic

48
00:01:40,720 --> 00:01:42,399
which we don't care about how it happens

49
00:01:42,399 --> 00:01:44,320
or how it's implemented

50
00:01:44,320 --> 00:01:46,479
um that the cipher text just magically

51
00:01:46,479 --> 00:01:48,640
disappears

52
00:01:48,640 --> 00:01:50,640
so then at a later time

53
00:01:50,640 --> 00:01:52,560
he is able to get the private key from

54
00:01:52,560 --> 00:01:53,520
bob

55
00:01:53,520 --> 00:01:55,040
but then there's really nothing that he

56
00:01:55,040 --> 00:01:56,880
can do because there is not even a

57
00:01:56,880 --> 00:02:00,159
cipher text for him to decrypt

58
00:02:00,159 --> 00:02:02,000
so what we have seen on this page

59
00:02:02,000 --> 00:02:04,399
actually trivially fulfills what we call

60
00:02:04,399 --> 00:02:06,799
receiver deniable encryption so what is

61
00:02:06,799 --> 00:02:09,280
receiver deniable encryption well it is

62
00:02:09,280 --> 00:02:11,520
a public encryption scheme where alice

63
00:02:11,520 --> 00:02:13,040
sends over a whole bunch of messages to

64
00:02:13,040 --> 00:02:13,920
bob

65
00:02:13,920 --> 00:02:15,680
and then there's the eavesdropper eve

66
00:02:15,680 --> 00:02:18,400
who makes a copy of these cipher texts

67
00:02:18,400 --> 00:02:21,120
then at a later time bob is required to

68
00:02:21,120 --> 00:02:23,599
reveal a private key to eve which will

69
00:02:23,599 --> 00:02:25,520
which he will use to decrypt the

70
00:02:25,520 --> 00:02:28,160
recorded cipher text

71
00:02:28,160 --> 00:02:30,720
the scheme is called is called receiver

72
00:02:30,720 --> 00:02:32,160
deniable

73
00:02:32,160 --> 00:02:34,640
if bob is able to provide a fake private

74
00:02:34,640 --> 00:02:36,879
key which will lead the cipher text to

75
00:02:36,879 --> 00:02:39,360
decrypt to fake messages

76
00:02:39,360 --> 00:02:41,360
notice that if the cipher text

77
00:02:41,360 --> 00:02:43,840
disappears then this is this vacuously

78
00:02:43,840 --> 00:02:45,120
host because

79
00:02:45,120 --> 00:02:47,120
the ebstruber eve cannot record any

80
00:02:47,120 --> 00:02:50,519
cipher text

81
00:02:50,879 --> 00:02:53,120
now let's consider a different story

82
00:02:53,120 --> 00:02:55,120
so it's friday night and alex is holding

83
00:02:55,120 --> 00:02:57,360
a party at her house and she wants to

84
00:02:57,360 --> 00:02:58,800
invite bob over

85
00:02:58,800 --> 00:03:01,120
so alice sends over a message saying

86
00:03:01,120 --> 00:03:03,680
there's a party happening tonight and

87
00:03:03,680 --> 00:03:05,200
in order to convince bob that the

88
00:03:05,200 --> 00:03:07,519
message indeed come from alice alice

89
00:03:07,519 --> 00:03:11,280
also attaches a signature on the message

90
00:03:11,280 --> 00:03:13,120
and here comes our annoying instructor

91
00:03:13,120 --> 00:03:14,159
eve

92
00:03:14,159 --> 00:03:16,319
who makes a copy of the message together

93
00:03:16,319 --> 00:03:17,680
with the signature

94
00:03:17,680 --> 00:03:18,959
but if doesn't do anything else

95
00:03:18,959 --> 00:03:21,680
malicious now yet but then at a later

96
00:03:21,680 --> 00:03:24,080
time say it's tuesday night

97
00:03:24,080 --> 00:03:27,040
and eve will simply replay the message

98
00:03:27,040 --> 00:03:29,680
together with the signature to bond

99
00:03:29,680 --> 00:03:32,879
so from bob's point of view he receives

100
00:03:32,879 --> 00:03:34,560
a message saying there's a party tonight

101
00:03:34,560 --> 00:03:36,879
and the signature is indeed alice's

102
00:03:36,879 --> 00:03:39,280
valley's signature on the message

103
00:03:39,280 --> 00:03:41,200
leading bob to believe that there is

104
00:03:41,200 --> 00:03:43,120
another party going on tuesday night in

105
00:03:43,120 --> 00:03:45,200
alice's house so bob went over to

106
00:03:45,200 --> 00:03:47,040
alice's place only to find there's

107
00:03:47,040 --> 00:03:49,599
actually no party going on

108
00:03:49,599 --> 00:03:51,280
so in order to prevent these sort of

109
00:03:51,280 --> 00:03:53,760
replay attacks in the standard model we

110
00:03:53,760 --> 00:03:56,159
would either require the receiver

111
00:03:56,159 --> 00:03:59,040
in bob in this case to keep a state or

112
00:03:59,040 --> 00:04:00,879
we would require interaction between

113
00:04:00,879 --> 00:04:04,959
alice and bob for the signature protocol

114
00:04:05,760 --> 00:04:08,080
but now let's consider a hypothetical

115
00:04:08,080 --> 00:04:10,640
scenario again alice sends over some

116
00:04:10,640 --> 00:04:13,519
message together with a signature to bob

117
00:04:13,519 --> 00:04:15,040
dropper makes a copy of the message

118
00:04:15,040 --> 00:04:16,720
together with the signature

119
00:04:16,720 --> 00:04:18,238
now guess what

120
00:04:18,238 --> 00:04:20,238
yeah the signature just magically

121
00:04:20,238 --> 00:04:22,079
disappears

122
00:04:22,079 --> 00:04:24,720
then the eavesdropper maybe attempt to

123
00:04:24,720 --> 00:04:27,840
replay the message to bob but but the

124
00:04:27,840 --> 00:04:29,280
eavesdropper doesn't have the valid

125
00:04:29,280 --> 00:04:32,000
signature for it so it can never lead to

126
00:04:32,000 --> 00:04:34,800
the ball to believe that the message

127
00:04:34,800 --> 00:04:37,199
being replayed is actually sent from

128
00:04:37,199 --> 00:04:39,840
alice again

129
00:04:40,400 --> 00:04:42,240
okay so now let's consider the last

130
00:04:42,240 --> 00:04:45,199
story so there is a software company who

131
00:04:45,199 --> 00:04:48,960
sends over a program p to its users

132
00:04:48,960 --> 00:04:50,240
and the user

133
00:04:50,240 --> 00:04:53,520
has in his mind a couple of inputs x1 x2

134
00:04:53,520 --> 00:04:55,680
and so on that it wants to evaluate the

135
00:04:55,680 --> 00:04:56,960
program on

136
00:04:56,960 --> 00:04:59,440
so when the program is being sent

137
00:04:59,440 --> 00:05:01,280
then the user can simply run the program

138
00:05:01,280 --> 00:05:04,240
on x1 x2 and obtain the corresponding

139
00:05:04,240 --> 00:05:05,520
results

140
00:05:05,520 --> 00:05:06,960
but then guess what

141
00:05:06,960 --> 00:05:10,800
yeah magically the program disappears

142
00:05:10,800 --> 00:05:13,280
so at a later time the user might have

143
00:05:13,280 --> 00:05:15,120
another input x prime that it wants to

144
00:05:15,120 --> 00:05:16,800
evaluate the program on but now that the

145
00:05:16,800 --> 00:05:19,520
program is gone there is no way for the

146
00:05:19,520 --> 00:05:22,720
user to obtain p of x prime

147
00:05:22,720 --> 00:05:24,639
notice that this can be easily turned

148
00:05:24,639 --> 00:05:27,199
into a software subscription system

149
00:05:27,199 --> 00:05:28,800
where the user

150
00:05:28,800 --> 00:05:30,720
loses access to the program once the

151
00:05:30,720 --> 00:05:33,199
subscription expires

152
00:05:33,199 --> 00:05:34,479
here we don't need to worry about the

153
00:05:34,479 --> 00:05:36,639
user storing the program because

154
00:05:36,639 --> 00:05:38,639
the program will disappear

155
00:05:38,639 --> 00:05:43,120
once after the transmission ends

156
00:05:43,120 --> 00:05:45,680
so now you probably are asking how

157
00:05:45,680 --> 00:05:46,800
indeed

158
00:05:46,800 --> 00:05:49,680
do we have these disappearing cipher

159
00:05:49,680 --> 00:05:52,479
text disappearing signatures and

160
00:05:52,479 --> 00:05:54,880
disappearing programs

161
00:05:54,880 --> 00:05:56,960
indeed that is not possible in the

162
00:05:56,960 --> 00:05:59,039
standard model because you can simply

163
00:05:59,039 --> 00:06:02,400
just write down what is being said

164
00:06:02,400 --> 00:06:03,840
that's why

165
00:06:03,840 --> 00:06:05,919
we rely on the boundary storage model

166
00:06:05,919 --> 00:06:08,160
which is first put forward by judy mara

167
00:06:08,160 --> 00:06:11,440
in 1992

168
00:06:11,440 --> 00:06:13,360
so traditionally when we talk about an

169
00:06:13,360 --> 00:06:16,080
adversary in cryptography the atmosphere

170
00:06:16,080 --> 00:06:17,919
is bounded by time

171
00:06:17,919 --> 00:06:20,560
namely the adversary need to perform the

172
00:06:20,560 --> 00:06:23,199
attack within time that is polynomial in

173
00:06:23,199 --> 00:06:25,600
the security parameter end

174
00:06:25,600 --> 00:06:28,000
however in the boundary storage model

175
00:06:28,000 --> 00:06:30,160
the adversary can take as long it wants

176
00:06:30,160 --> 00:06:32,319
to finish the attack

177
00:06:32,319 --> 00:06:33,759
but

178
00:06:33,759 --> 00:06:35,520
the average rate is bounded by the

179
00:06:35,520 --> 00:06:38,319
amount of storage that it uses

180
00:06:38,319 --> 00:06:40,319
namely we will require that the average

181
00:06:40,319 --> 00:06:43,440
rate to use a memory of at most p of n

182
00:06:43,440 --> 00:06:47,120
for some fixed polynomial p

183
00:06:47,120 --> 00:06:49,199
now how would this help us in

184
00:06:49,199 --> 00:06:51,840
constructing disappearing cryptography

185
00:06:51,840 --> 00:06:53,680
well we can imagine that except for

186
00:06:53,680 --> 00:06:55,120
example in the case of disappearing

187
00:06:55,120 --> 00:06:57,039
ciphertext the ciphertext being

188
00:06:57,039 --> 00:06:59,280
transmitted is so large that it exceeds

189
00:06:59,280 --> 00:07:01,440
the adversary's storage bound

190
00:07:01,440 --> 00:07:03,840
then to for an average rate that is

191
00:07:03,840 --> 00:07:05,680
bounded by space

192
00:07:05,680 --> 00:07:08,080
the cipher text cannot be written down

193
00:07:08,080 --> 00:07:10,479
and just effectively disappears after

194
00:07:10,479 --> 00:07:13,039
the transmission

195
00:07:13,039 --> 00:07:15,120
so in our work we initiate the study of

196
00:07:15,120 --> 00:07:16,639
disappearing cryptography in the

197
00:07:16,639 --> 00:07:18,400
boundary storage model

198
00:07:18,400 --> 00:07:20,720
we investigate four different schemes

199
00:07:20,720 --> 00:07:23,199
so the first is disappearing public key

200
00:07:23,199 --> 00:07:25,039
encryption as we have seen in the first

201
00:07:25,039 --> 00:07:27,520
story we further extend it to a

202
00:07:27,520 --> 00:07:29,199
disappearing functional encryption

203
00:07:29,199 --> 00:07:30,560
scheme

204
00:07:30,560 --> 00:07:32,400
and then we study disappearing

205
00:07:32,400 --> 00:07:34,400
signatures which corresponds to the

206
00:07:34,400 --> 00:07:35,840
second story

207
00:07:35,840 --> 00:07:39,440
and lastly we define online obfuscation

208
00:07:39,440 --> 00:07:41,039
in a boundary storage model which

209
00:07:41,039 --> 00:07:44,319
corresponds to the last the last story

210
00:07:44,319 --> 00:07:47,599
where we have the disappearing program

211
00:07:47,599 --> 00:07:50,240
in fact we show that online obfuscation

212
00:07:50,240 --> 00:07:52,720
can be a really useful tool by showing

213
00:07:52,720 --> 00:07:55,199
how to construct the prior three schemes

214
00:07:55,199 --> 00:07:57,280
using online obfuscation

215
00:07:57,280 --> 00:07:59,360
as a component

216
00:07:59,360 --> 00:08:01,520
lastly we have also given we have also

217
00:08:01,520 --> 00:08:03,520
given two candidate constructions for

218
00:08:03,520 --> 00:08:05,199
online offlocation

219
00:08:05,199 --> 00:08:07,280
the first construction uses matrix

220
00:08:07,280 --> 00:08:09,680
branching programs which are is a common

221
00:08:09,680 --> 00:08:11,639
technique used for constructing

222
00:08:11,639 --> 00:08:13,840
indistinguishability obfuscation in the

223
00:08:13,840 --> 00:08:15,599
standard model

224
00:08:15,599 --> 00:08:17,120
and the second candidate construction

225
00:08:17,120 --> 00:08:19,199
comes from time stamping schemes in a

226
00:08:19,199 --> 00:08:21,199
boundary storage model which is due to

227
00:08:21,199 --> 00:08:24,080
moren shatio and tajma

228
00:08:24,080 --> 00:08:26,160
we want to point out that we were not

229
00:08:26,160 --> 00:08:28,800
able to get full security proof of these

230
00:08:28,800 --> 00:08:30,800
candidate constructions and that's why

231
00:08:30,800 --> 00:08:32,799
we leave them as interesting open

232
00:08:32,799 --> 00:08:34,240
problems

233
00:08:34,240 --> 00:08:37,360
so in our in this video in this video

234
00:08:37,360 --> 00:08:39,599
we will first of all talk about how we

235
00:08:39,599 --> 00:08:41,919
define online authentication

236
00:08:41,919 --> 00:08:44,000
and then we will show how we use it to

237
00:08:44,000 --> 00:08:46,800
construct disappearing public encryption

238
00:08:46,800 --> 00:08:48,800
and lastly how it can be used to

239
00:08:48,800 --> 00:08:52,560
construct disappearing signatures

240
00:08:52,959 --> 00:08:55,440
so moving on we will start with online

241
00:08:55,440 --> 00:08:58,160
obfuscation

242
00:08:59,279 --> 00:09:01,279
towards defining online obfuscation we

243
00:09:01,279 --> 00:09:03,360
imagine a following syntax

244
00:09:03,360 --> 00:09:05,440
so there is an obfuscator that takes as

245
00:09:05,440 --> 00:09:08,320
input a circuit c and outputs an

246
00:09:08,320 --> 00:09:10,000
obfuscated program p

247
00:09:10,000 --> 00:09:11,920
which is so large that the adversary

248
00:09:11,920 --> 00:09:14,080
cannot possibly write it down in its

249
00:09:14,080 --> 00:09:15,360
entirety

250
00:09:15,360 --> 00:09:18,640
however this large program p can be sent

251
00:09:18,640 --> 00:09:21,600
out in a streaming manner bit by bit so

252
00:09:21,600 --> 00:09:24,000
that the honest parties which also has

253
00:09:24,000 --> 00:09:25,680
limited amount of storage

254
00:09:25,680 --> 00:09:29,279
can indeed run the program on its honest

255
00:09:29,279 --> 00:09:31,920
input in an online manner

256
00:09:31,920 --> 00:09:33,680
notice that in this talk we will use

257
00:09:33,680 --> 00:09:36,399
this background blue color to indicate

258
00:09:36,399 --> 00:09:38,560
that a message is a

259
00:09:38,560 --> 00:09:42,479
message or a variable is a stream

260
00:09:42,720 --> 00:09:44,959
and then there's the corresponding eval

261
00:09:44,959 --> 00:09:47,120
method which takes as input

262
00:09:47,120 --> 00:09:49,360
of the obfuscated program p which is a

263
00:09:49,360 --> 00:09:51,760
stream together with an input x and

264
00:09:51,760 --> 00:09:54,560
we'll output the y which is by

265
00:09:54,560 --> 00:09:56,640
evaluating the program p in an online

266
00:09:56,640 --> 00:09:59,200
manner on the input x

267
00:09:59,200 --> 00:10:01,200
so we require correctness which

268
00:10:01,200 --> 00:10:03,519
essentially says that the result of

269
00:10:03,519 --> 00:10:06,240
evaluating the obfuscated program p on

270
00:10:06,240 --> 00:10:09,360
input x is indeed the same as evaluating

271
00:10:09,360 --> 00:10:12,560
the original circuit on the input x

272
00:10:12,560 --> 00:10:15,200
so to define security we consider two

273
00:10:15,200 --> 00:10:17,200
different experiments so in the first

274
00:10:17,200 --> 00:10:19,040
experiment the challenger interacts with

275
00:10:19,040 --> 00:10:20,880
an adversary and in the second

276
00:10:20,880 --> 00:10:22,880
experiment the challenger interacts with

277
00:10:22,880 --> 00:10:25,279
a simulator

278
00:10:25,279 --> 00:10:27,440
so both experiments consists of an

279
00:10:27,440 --> 00:10:29,440
arbitrary number of rounds and in each

280
00:10:29,440 --> 00:10:31,519
round either one of these two cases

281
00:10:31,519 --> 00:10:34,000
happens so each round is either an

282
00:10:34,000 --> 00:10:36,640
interaction round or what we call a

283
00:10:36,640 --> 00:10:38,079
streaming round

284
00:10:38,079 --> 00:10:40,000
so the interaction rounds is the same

285
00:10:40,000 --> 00:10:42,640
for both experiments so in interaction

286
00:10:42,640 --> 00:10:44,240
rounds the challenger interacts with the

287
00:10:44,240 --> 00:10:47,040
adversary or the simulator arbitrarily

288
00:10:47,040 --> 00:10:48,800
there is no limitation on how they

289
00:10:48,800 --> 00:10:51,120
communicate whatsoever

290
00:10:51,120 --> 00:10:52,959
and in a streaming round

291
00:10:52,959 --> 00:10:55,040
is slightly different so in the

292
00:10:55,040 --> 00:10:56,800
streaming run for adversary and

293
00:10:56,800 --> 00:10:58,240
challenger game

294
00:10:58,240 --> 00:11:01,360
the average 3 gets a fresh stream of a

295
00:11:01,360 --> 00:11:03,839
obfuscated program p

296
00:11:03,839 --> 00:11:05,920
and the challenger is notified that a

297
00:11:05,920 --> 00:11:07,760
streaming has happened

298
00:11:07,760 --> 00:11:09,920
however in the for the simulator it

299
00:11:09,920 --> 00:11:12,160
doesn't have access to the streaming of

300
00:11:12,160 --> 00:11:15,040
of scada pro p but instead

301
00:11:15,040 --> 00:11:17,920
it's allowed to make adaptive queries to

302
00:11:17,920 --> 00:11:19,839
the original circuit c

303
00:11:19,839 --> 00:11:21,519
and it's only allowed the total number

304
00:11:21,519 --> 00:11:24,560
of queries is bounded by poly of lambda

305
00:11:24,560 --> 00:11:26,959
where lambda is the security parameter

306
00:11:26,959 --> 00:11:29,120
again similarly the challenger is

307
00:11:29,120 --> 00:11:32,399
notified that a streaming has happened

308
00:11:32,399 --> 00:11:34,720
notice that these rounds do not need to

309
00:11:34,720 --> 00:11:36,640
happen in order so it can be interaction

310
00:11:36,640 --> 00:11:38,320
round first and then followed by some

311
00:11:38,320 --> 00:11:39,839
streaming rounds and then some

312
00:11:39,839 --> 00:11:41,519
interaction runs again and then some

313
00:11:41,519 --> 00:11:43,040
more streaming rounds they don't need to

314
00:11:43,040 --> 00:11:45,040
happen in the specific ordering of

315
00:11:45,040 --> 00:11:47,040
interaction interaction round and then

316
00:11:47,040 --> 00:11:48,320
streaming around

317
00:11:48,320 --> 00:11:50,800
however we do require we do bound to the

318
00:11:50,800 --> 00:11:52,480
total number of streaming rounds to be

319
00:11:52,480 --> 00:11:54,000
at most k

320
00:11:54,000 --> 00:11:54,959
so

321
00:11:54,959 --> 00:11:58,160
if if if ever that the challenger sees

322
00:11:58,160 --> 00:12:00,000
that there is more than k streaming

323
00:12:00,000 --> 00:12:01,440
rounds the challenger will abort the

324
00:12:01,440 --> 00:12:03,920
experiment and just output zero

325
00:12:03,920 --> 00:12:06,480
additionally at any time of the

326
00:12:06,480 --> 00:12:08,320
experiment the challenger can terminate

327
00:12:08,320 --> 00:12:10,079
the development can terminate the

328
00:12:10,079 --> 00:12:12,959
experiment by outputting a single bit 0

329
00:12:12,959 --> 00:12:14,880
or 1.

330
00:12:14,880 --> 00:12:16,000
so

331
00:12:16,000 --> 00:12:17,600
using these two experiments we're able

332
00:12:17,600 --> 00:12:20,399
to define security that we want the main

333
00:12:20,399 --> 00:12:22,720
security definition that we will use for

334
00:12:22,720 --> 00:12:24,399
the applications

335
00:12:24,399 --> 00:12:26,800
is similar to a

336
00:12:26,800 --> 00:12:29,279
virtual grade box security

337
00:12:29,279 --> 00:12:32,079
so what is say for k time word bgb

338
00:12:32,079 --> 00:12:34,880
security is that for any challenger and

339
00:12:34,880 --> 00:12:37,680
any adversary that has a spacebound s

340
00:12:37,680 --> 00:12:41,040
there exists a computationally unbounded

341
00:12:41,040 --> 00:12:42,480
simulator

342
00:12:42,480 --> 00:12:44,800
such that the challenger cannot tell

343
00:12:44,800 --> 00:12:46,480
whether it's interacting with the

344
00:12:46,480 --> 00:12:48,560
adversary which has access to the

345
00:12:48,560 --> 00:12:51,680
obfuscated program p or its interaction

346
00:12:51,680 --> 00:12:53,279
with the it's interacting with a

347
00:12:53,279 --> 00:12:56,160
simulator which only have uh adaptive

348
00:12:56,160 --> 00:12:57,760
queries to the circuit c in the

349
00:12:57,760 --> 00:12:59,680
streaming route

350
00:12:59,680 --> 00:13:01,360
so if you're watching the video maybe

351
00:13:01,360 --> 00:13:03,920
take a take a minute to pause and uh

352
00:13:03,920 --> 00:13:07,839
think through the this definition

353
00:13:09,279 --> 00:13:11,680
similarly we can also define different

354
00:13:11,680 --> 00:13:13,440
flavors of obfuscation we can also

355
00:13:13,440 --> 00:13:15,839
define an indistinguishability

356
00:13:15,839 --> 00:13:18,560
obfuscation obfuscation here

357
00:13:18,560 --> 00:13:21,040
where we will change the total number of

358
00:13:21,040 --> 00:13:23,839
adaptive queries to the circuit c so now

359
00:13:23,839 --> 00:13:26,560
instead of them being a poly lambda now

360
00:13:26,560 --> 00:13:28,560
they can be super poly lambda for the

361
00:13:28,560 --> 00:13:30,880
simulator in the streaming routes

362
00:13:30,880 --> 00:13:33,200
and similarly we can also define

363
00:13:33,200 --> 00:13:36,000
vbb security virtual black box security

364
00:13:36,000 --> 00:13:38,000
where the simulator is no longer

365
00:13:38,000 --> 00:13:40,720
computationally inbounded but it is now

366
00:13:40,720 --> 00:13:43,040
a ppt simulator

367
00:13:43,040 --> 00:13:45,760
in fact we have also shown that just

368
00:13:45,760 --> 00:13:48,560
like vbb obfuscation is impossible in

369
00:13:48,560 --> 00:13:50,639
the standard model we have also shown

370
00:13:50,639 --> 00:13:52,000
that vbb

371
00:13:52,000 --> 00:13:54,560
obfuscation is also impossible

372
00:13:54,560 --> 00:13:58,000
in the boundary storage model

373
00:14:00,560 --> 00:14:02,880
now with the definition of the vgb

374
00:14:02,880 --> 00:14:05,680
security of an online office creator now

375
00:14:05,680 --> 00:14:08,959
we can proceed to see how we define a

376
00:14:08,959 --> 00:14:11,600
disappearing public encryption and how

377
00:14:11,600 --> 00:14:13,360
we are able to construct it using an

378
00:14:13,360 --> 00:14:16,000
online off-scaler

379
00:14:16,000 --> 00:14:17,440
now let's consider the security

380
00:14:17,440 --> 00:14:19,600
definition of a public key encryption

381
00:14:19,600 --> 00:14:21,440
scheme or actually one of the security

382
00:14:21,440 --> 00:14:23,680
definitions of a public encryption

383
00:14:23,680 --> 00:14:26,240
scheme in the standard model

384
00:14:26,240 --> 00:14:28,160
so there's the challenger which first of

385
00:14:28,160 --> 00:14:30,560
all samples a public key secret key pair

386
00:14:30,560 --> 00:14:32,880
together with a random bit b

387
00:14:32,880 --> 00:14:34,560
and then the challenger is going to send

388
00:14:34,560 --> 00:14:37,199
over the public key to the adversary

389
00:14:37,199 --> 00:14:39,120
and the absolute sends over a pair of

390
00:14:39,120 --> 00:14:42,000
challenge messages m0 and m1

391
00:14:42,000 --> 00:14:42,880
and

392
00:14:42,880 --> 00:14:45,040
and the challenger will encrypt a random

393
00:14:45,040 --> 00:14:46,880
one according to b

394
00:14:46,880 --> 00:14:48,880
and then the allowance rate needs to

395
00:14:48,880 --> 00:14:50,959
make a guess for the bit b essentially b

396
00:14:50,959 --> 00:14:52,000
prime here

397
00:14:52,000 --> 00:14:54,240
so the ch the atmosphere wins the game

398
00:14:54,240 --> 00:14:58,240
if b prime is equal to b

399
00:14:58,240 --> 00:15:00,639
uh so our definition for the

400
00:15:00,639 --> 00:15:03,120
disappearing public key encryption only

401
00:15:03,120 --> 00:15:05,440
involves two minor changes uh to this

402
00:15:05,440 --> 00:15:07,440
definition so first of all

403
00:15:07,440 --> 00:15:09,440
the the encryption the encryption now

404
00:15:09,440 --> 00:15:12,160
the cipher text is uh is going to

405
00:15:12,160 --> 00:15:14,399
disappear which means it's now a stream

406
00:15:14,399 --> 00:15:16,320
which is too large for the absolute to

407
00:15:16,320 --> 00:15:17,839
write down

408
00:15:17,839 --> 00:15:19,360
and then secondly

409
00:15:19,360 --> 00:15:20,560
before

410
00:15:20,560 --> 00:15:22,240
the adversary makes the guess for the

411
00:15:22,240 --> 00:15:25,120
bit b the answer is actually given the

412
00:15:25,120 --> 00:15:26,720
secret key

413
00:15:26,720 --> 00:15:29,040
to of of the of the encryption

414
00:15:29,040 --> 00:15:31,360
notice that if in the standard model the

415
00:15:31,360 --> 00:15:33,360
abstract is given a secret key then it

416
00:15:33,360 --> 00:15:35,360
can trivially just deprive the message

417
00:15:35,360 --> 00:15:37,279
to learn what the bit b is

418
00:15:37,279 --> 00:15:38,000
but

419
00:15:38,000 --> 00:15:39,519
here because we're in the boundary

420
00:15:39,519 --> 00:15:41,839
storage model and the cipher text has

421
00:15:41,839 --> 00:15:44,160
effectively disappeared

422
00:15:44,160 --> 00:15:46,160
even with the secret key

423
00:15:46,160 --> 00:15:48,560
uh the there is nothing for the for the

424
00:15:48,560 --> 00:15:50,880
abstract to decrypt

425
00:15:50,880 --> 00:15:51,680
so

426
00:15:51,680 --> 00:15:54,000
let's take a moment to

427
00:15:54,000 --> 00:15:54,800
see

428
00:15:54,800 --> 00:15:58,880
why this security definition makes sense

429
00:15:59,600 --> 00:16:01,680
so to construct a

430
00:16:01,680 --> 00:16:03,920
disappearing public key encryption

431
00:16:03,920 --> 00:16:05,519
scheme as we have seen on the previous

432
00:16:05,519 --> 00:16:08,000
page we require one additional tool

433
00:16:08,000 --> 00:16:10,399
other than online obfuscation

434
00:16:10,399 --> 00:16:12,639
we require lossy functions which is a

435
00:16:12,639 --> 00:16:15,279
subset of lossy trapdoor functions which

436
00:16:15,279 --> 00:16:17,279
was first put forward by picard and

437
00:16:17,279 --> 00:16:20,079
waters in 2008.

438
00:16:20,079 --> 00:16:22,000
here we no longer need the trapdoor

439
00:16:22,000 --> 00:16:24,800
feature so we only so what we really

440
00:16:24,800 --> 00:16:27,440
only need is lossy functions so what are

441
00:16:27,440 --> 00:16:29,519
lossy functions well there are a class

442
00:16:29,519 --> 00:16:31,440
of functions which you can sample from

443
00:16:31,440 --> 00:16:33,199
in two different modes

444
00:16:33,199 --> 00:16:35,440
so in the in the injective mode we can

445
00:16:35,440 --> 00:16:38,560
sample a injective function from the

446
00:16:38,560 --> 00:16:40,800
domain to the range

447
00:16:40,800 --> 00:16:43,120
and there is another lossy mode which we

448
00:16:43,120 --> 00:16:45,360
can sample a lossy function from the

449
00:16:45,360 --> 00:16:47,920
same domain but to a much much smaller

450
00:16:47,920 --> 00:16:50,079
range so there is guaranteed to be

451
00:16:50,079 --> 00:16:52,638
collisions

452
00:16:53,040 --> 00:16:56,000
and the lossy functions require that

453
00:16:56,000 --> 00:16:58,720
whether a function is sampled in the

454
00:16:58,720 --> 00:17:00,720
injection mode or a function is in the

455
00:17:00,720 --> 00:17:03,120
lossy mode are computationally

456
00:17:03,120 --> 00:17:05,359
indistinguishable

457
00:17:05,359 --> 00:17:07,919
so with this in mind we now proceed to

458
00:17:07,919 --> 00:17:09,760
see how we construct the public

459
00:17:09,760 --> 00:17:12,559
encryption scheme

460
00:17:12,559 --> 00:17:14,480
so here's our construction

461
00:17:14,480 --> 00:17:17,839
to sample a public key private key pair

462
00:17:17,839 --> 00:17:19,839
alice will first of all sample an

463
00:17:19,839 --> 00:17:21,439
injective function from the velocity

464
00:17:21,439 --> 00:17:24,240
function using the injective mode

465
00:17:24,240 --> 00:17:26,799
together with a uniformly random private

466
00:17:26,799 --> 00:17:28,240
key sk

467
00:17:28,240 --> 00:17:30,080
so what is a pro what is a public key

468
00:17:30,080 --> 00:17:31,679
you might ask well the public key has

469
00:17:31,679 --> 00:17:34,000
two parts the first part is simply the

470
00:17:34,000 --> 00:17:37,679
image of sk using the injective function

471
00:17:37,679 --> 00:17:40,000
and the second part is just the the

472
00:17:40,000 --> 00:17:41,679
injective function itself

473
00:17:41,679 --> 00:17:43,760
so let's say the image of the injective

474
00:17:43,760 --> 00:17:46,480
function on sk is called y and the

475
00:17:46,480 --> 00:17:48,640
public key is just y and the injector

476
00:17:48,640 --> 00:17:50,320
function

477
00:17:50,320 --> 00:17:52,559
then suppose bob has a message m that it

478
00:17:52,559 --> 00:17:55,039
wants to encrypt using the public key so

479
00:17:55,039 --> 00:17:57,039
what bob will do as the first step of

480
00:17:57,039 --> 00:17:59,200
the encryption procedure is to create

481
00:17:59,200 --> 00:18:00,880
the following program

482
00:18:00,880 --> 00:18:03,120
so the program p is going to take an

483
00:18:03,120 --> 00:18:06,720
input x and checks if the image of x on

484
00:18:06,720 --> 00:18:09,120
the function on the injective function

485
00:18:09,120 --> 00:18:11,679
is equal to y if that is the case the fo

486
00:18:11,679 --> 00:18:14,559
the program simply outputs the message m

487
00:18:14,559 --> 00:18:18,000
otherwise the program outputs nothing

488
00:18:18,000 --> 00:18:19,919
and the cipher text is just in the

489
00:18:19,919 --> 00:18:23,440
obfuscated version of the program p

490
00:18:23,440 --> 00:18:25,440
notice that this office obfuscated

491
00:18:25,440 --> 00:18:28,000
program is a long stream which is too

492
00:18:28,000 --> 00:18:30,000
large for the apps to write down and is

493
00:18:30,000 --> 00:18:32,320
sent over to alice in a bit too bit

494
00:18:32,320 --> 00:18:34,320
streaming manner

495
00:18:34,320 --> 00:18:37,039
uh is the end to decrypt the message to

496
00:18:37,039 --> 00:18:38,720
decrypt the ciphertext

497
00:18:38,720 --> 00:18:42,080
alex will simply evaluate the streamed

498
00:18:42,080 --> 00:18:43,360
program

499
00:18:43,360 --> 00:18:47,120
on the on the by using the secret key sk

500
00:18:47,120 --> 00:18:48,400
as input

501
00:18:48,400 --> 00:18:50,400
and as we can see if the input to the

502
00:18:50,400 --> 00:18:51,600
program p

503
00:18:51,600 --> 00:18:52,320
uh

504
00:18:52,320 --> 00:18:54,799
x is equal to sk then we're in the first

505
00:18:54,799 --> 00:18:57,280
case and the program will simply output

506
00:18:57,280 --> 00:18:58,880
m as desired

507
00:18:58,880 --> 00:19:00,799
it is easy to verify that if the

508
00:19:00,799 --> 00:19:02,480
obfuscator is

509
00:19:02,480 --> 00:19:05,200
is has correctness then this scheme is

510
00:19:05,200 --> 00:19:07,679
secure

511
00:19:07,840 --> 00:19:09,280
we will show security of our

512
00:19:09,280 --> 00:19:10,880
construction through a sequence of

513
00:19:10,880 --> 00:19:12,160
hybrids

514
00:19:12,160 --> 00:19:14,240
so now let's look at the or let's plug

515
00:19:14,240 --> 00:19:16,640
our construction into the original

516
00:19:16,640 --> 00:19:18,480
security experiment

517
00:19:18,480 --> 00:19:20,320
so our challenger is going to first

518
00:19:20,320 --> 00:19:22,160
sample an injective function from the

519
00:19:22,160 --> 00:19:24,000
lossy function together with a uniform

520
00:19:24,000 --> 00:19:26,400
private key sk together with the random

521
00:19:26,400 --> 00:19:28,160
uniform bit b

522
00:19:28,160 --> 00:19:29,520
the challenger is going to send over the

523
00:19:29,520 --> 00:19:31,760
public key consisting of the of these

524
00:19:31,760 --> 00:19:33,039
two parts

525
00:19:33,039 --> 00:19:35,200
and then the adversary is going to send

526
00:19:35,200 --> 00:19:39,120
over the challenge messages m0 and m1

527
00:19:39,120 --> 00:19:41,039
and the challenger is going to pick a

528
00:19:41,039 --> 00:19:43,679
random one of them to encrypt and to

529
00:19:43,679 --> 00:19:45,440
encrypt mb

530
00:19:45,440 --> 00:19:46,960
it will first construct the following

531
00:19:46,960 --> 00:19:48,000
program

532
00:19:48,000 --> 00:19:50,480
as we have seen and sends over the

533
00:19:50,480 --> 00:19:52,559
office created version of the program

534
00:19:52,559 --> 00:19:55,360
back to the app sorry

535
00:19:55,360 --> 00:19:56,640
additionally

536
00:19:56,640 --> 00:19:58,400
at a later time

537
00:19:58,400 --> 00:20:00,720
the the challenger will also send over

538
00:20:00,720 --> 00:20:02,480
the private key sk

539
00:20:02,480 --> 00:20:03,919
and then the

540
00:20:03,919 --> 00:20:05,919
adversary needs to make a guess for the

541
00:20:05,919 --> 00:20:08,799
bit b prime

542
00:20:10,159 --> 00:20:12,960
so in our first hybrid notice that since

543
00:20:12,960 --> 00:20:16,000
the function is an injective function

544
00:20:16,000 --> 00:20:18,320
so instead of checking whether the image

545
00:20:18,320 --> 00:20:21,440
of x is equal to the image of s k

546
00:20:21,440 --> 00:20:24,320
we can directly check if x is equal to s

547
00:20:24,320 --> 00:20:26,640
k simply because the function is an

548
00:20:26,640 --> 00:20:28,000
injective one

549
00:20:28,000 --> 00:20:30,640
so we make this modification in the in

550
00:20:30,640 --> 00:20:32,240
the obfuscated in the program being

551
00:20:32,240 --> 00:20:33,600
obfuscated

552
00:20:33,600 --> 00:20:36,240
and because the functionality is exactly

553
00:20:36,240 --> 00:20:37,360
the same

554
00:20:37,360 --> 00:20:40,000
so using the i o security which is

555
00:20:40,000 --> 00:20:42,400
implied by the vgb security of the

556
00:20:42,400 --> 00:20:44,720
online obfuscator

557
00:20:44,720 --> 00:20:46,880
these two these two experiments should

558
00:20:46,880 --> 00:20:49,840
be indistinguishable

559
00:20:49,840 --> 00:20:52,080
in the next hybrid instead of sampling

560
00:20:52,080 --> 00:20:53,679
in the injective mode of the lossy

561
00:20:53,679 --> 00:20:56,159
function we now sample in the lossy mode

562
00:20:56,159 --> 00:20:58,240
of the lossy function

563
00:20:58,240 --> 00:21:00,080
and then just by the security of the

564
00:21:00,080 --> 00:21:03,520
lossy function itself no ppt adversaries

565
00:21:03,520 --> 00:21:05,120
should be able to distinguish whether

566
00:21:05,120 --> 00:21:07,440
we're sampling in lossy mode or in

567
00:21:07,440 --> 00:21:10,240
injective mode

568
00:21:10,480 --> 00:21:13,360
lastly we change the ciphertext program

569
00:21:13,360 --> 00:21:15,520
again this time we change it so that the

570
00:21:15,520 --> 00:21:18,480
ciphertest program never outputs m

571
00:21:18,480 --> 00:21:20,080
notice that this only affects the

572
00:21:20,080 --> 00:21:23,039
program's behavior on a single point sk

573
00:21:23,039 --> 00:21:25,760
but notice that since now this function

574
00:21:25,760 --> 00:21:28,159
f is a lossy function

575
00:21:28,159 --> 00:21:31,039
the sk is actually statistically hidden

576
00:21:31,039 --> 00:21:34,400
from the adversary who only knows pk

577
00:21:34,400 --> 00:21:36,720
when the cipher text is being streamed

578
00:21:36,720 --> 00:21:38,640
this means that the abstracts will not

579
00:21:38,640 --> 00:21:42,080
be able to query the obfuscated program

580
00:21:42,080 --> 00:21:45,039
the obfuscated program on the input sk

581
00:21:45,039 --> 00:21:47,360
and therefore the f3 is not able to

582
00:21:47,360 --> 00:21:51,280
detect the change made in this hybrid

583
00:21:51,280 --> 00:21:53,360
notice that although the average rate is

584
00:21:53,360 --> 00:21:56,480
later on given sk in the in the plane

585
00:21:56,480 --> 00:21:57,520
but

586
00:21:57,520 --> 00:21:59,520
at that time the apps will be no longer

587
00:21:59,520 --> 00:22:01,039
to obfuscate it

588
00:22:01,039 --> 00:22:02,720
will be no longer to query the alpha

589
00:22:02,720 --> 00:22:04,880
scada program because that stream has

590
00:22:04,880 --> 00:22:06,480
already happened and the program has

591
00:22:06,480 --> 00:22:09,039
disappeared

592
00:22:11,120 --> 00:22:13,280
therefore through a sequence of hybrids

593
00:22:13,280 --> 00:22:15,280
we have shown that assuming the

594
00:22:15,280 --> 00:22:18,159
existence of lossy functions and

595
00:22:18,159 --> 00:22:20,400
online obfuscation with virtual grade

596
00:22:20,400 --> 00:22:22,000
box security

597
00:22:22,000 --> 00:22:25,440
no ppt adversary with a space bounce can

598
00:22:25,440 --> 00:22:27,760
win the disappearing public key

599
00:22:27,760 --> 00:22:31,039
encryption security game

600
00:22:34,720 --> 00:22:37,280
next up let us move on to disappearing

601
00:22:37,280 --> 00:22:40,280
signatures

602
00:22:40,559 --> 00:22:43,120
let us begin by first looking at how we

603
00:22:43,120 --> 00:22:45,039
define security for the disappearing

604
00:22:45,039 --> 00:22:46,720
signature scheme

605
00:22:46,720 --> 00:22:49,120
so it's quite similar to the

606
00:22:49,120 --> 00:22:51,840
to the unforgeability security of a

607
00:22:51,840 --> 00:22:54,559
standard model signature scheme so let's

608
00:22:54,559 --> 00:22:56,799
recall what that is so in a standard

609
00:22:56,799 --> 00:22:58,880
model signature scheme the security is

610
00:22:58,880 --> 00:23:00,720
defined in following way

611
00:23:00,720 --> 00:23:02,799
so the challenger samples the public key

612
00:23:02,799 --> 00:23:04,559
secret key pair but it's going to be

613
00:23:04,559 --> 00:23:06,720
used for the signature and sends over

614
00:23:06,720 --> 00:23:09,200
the public key to the adversary and the

615
00:23:09,200 --> 00:23:12,320
answer is sends over a message query m

616
00:23:12,320 --> 00:23:13,360
mi

617
00:23:13,360 --> 00:23:16,000
and will receive a corresponding

618
00:23:16,000 --> 00:23:18,000
signature on that message

619
00:23:18,000 --> 00:23:19,520
using the public key

620
00:23:19,520 --> 00:23:21,280
and the app story can repeat the process

621
00:23:21,280 --> 00:23:23,520
over and over by obtaining as many

622
00:23:23,520 --> 00:23:25,840
messages and message and signature pairs

623
00:23:25,840 --> 00:23:27,840
as it wants

624
00:23:27,840 --> 00:23:30,159
but then at a later time the abstract

625
00:23:30,159 --> 00:23:32,320
needs to produce another message

626
00:23:32,320 --> 00:23:33,919
signature pair

627
00:23:33,919 --> 00:23:37,039
where the message and prime is not one

628
00:23:37,039 --> 00:23:39,120
of the messages that has been queried

629
00:23:39,120 --> 00:23:40,799
before

630
00:23:40,799 --> 00:23:42,880
and the answer wins if the

631
00:23:42,880 --> 00:23:44,720
if the message signature period it

632
00:23:44,720 --> 00:23:47,039
outputs is a valid message signature

633
00:23:47,039 --> 00:23:48,000
pair

634
00:23:48,000 --> 00:23:50,080
so how will we modify it for the

635
00:23:50,080 --> 00:23:52,480
disappearing signature scheme uh well

636
00:23:52,480 --> 00:23:54,320
first of all the signatures themselves

637
00:23:54,320 --> 00:23:56,559
are now going to be streams a long

638
00:23:56,559 --> 00:23:57,840
stream that is so large that the

639
00:23:57,840 --> 00:24:00,799
absolute cannot possibly store

640
00:24:00,799 --> 00:24:03,200
so now notice that

641
00:24:03,200 --> 00:24:05,520
although the adversaries

642
00:24:05,520 --> 00:24:07,760
have received these signatures

643
00:24:07,760 --> 00:24:09,760
but it can only see these integers as

644
00:24:09,760 --> 00:24:11,279
they are streaming but they can never

645
00:24:11,279 --> 00:24:13,200
write these signatures down

646
00:24:13,200 --> 00:24:14,480
so

647
00:24:14,480 --> 00:24:16,480
when the adversary submits the message

648
00:24:16,480 --> 00:24:18,720
signature pair m prime and sigma prime

649
00:24:18,720 --> 00:24:20,640
notice that sigma prime is now also a

650
00:24:20,640 --> 00:24:21,840
stream

651
00:24:21,840 --> 00:24:24,320
we no longer require that the message m

652
00:24:24,320 --> 00:24:26,400
prime is unique from

653
00:24:26,400 --> 00:24:28,559
any of the previously prairie messages

654
00:24:28,559 --> 00:24:31,120
actually now m prime can be any message

655
00:24:31,120 --> 00:24:33,440
even if it is one of the messages that

656
00:24:33,440 --> 00:24:35,679
has been queried before

657
00:24:35,679 --> 00:24:37,360
notice that in the standard model this

658
00:24:37,360 --> 00:24:39,440
is strictly this is

659
00:24:39,440 --> 00:24:42,240
not not possible because uh the l3 can

660
00:24:42,240 --> 00:24:44,880
simply just replay one of the previous

661
00:24:44,880 --> 00:24:47,520
signatures but in the boundary storage

662
00:24:47,520 --> 00:24:49,440
model the previous signatures is a

663
00:24:49,440 --> 00:24:51,919
stream and it cannot be written down so

664
00:24:51,919 --> 00:24:54,080
if the averagery is going to use

665
00:24:54,080 --> 00:24:55,600
an old message

666
00:24:55,600 --> 00:24:56,320
but

667
00:24:56,320 --> 00:24:58,159
he still needs to come up with a fresh

668
00:24:58,159 --> 00:24:59,760
signature because the old signature

669
00:24:59,760 --> 00:25:01,840
cannot be stored and replayed at a later

670
00:25:01,840 --> 00:25:04,158
time

671
00:25:05,120 --> 00:25:07,360
so with that definition in mind

672
00:25:07,360 --> 00:25:09,360
let's look at our construction so for

673
00:25:09,360 --> 00:25:11,120
our construction we need one additional

674
00:25:11,120 --> 00:25:13,039
tool which is prefix punctuable

675
00:25:13,039 --> 00:25:15,679
signature which was first put forward by

676
00:25:15,679 --> 00:25:19,120
belair and foxbower in 2014

677
00:25:19,120 --> 00:25:20,640
so

678
00:25:20,640 --> 00:25:22,720
a previous functional signature scheme

679
00:25:22,720 --> 00:25:24,640
is a signature scheme where the message

680
00:25:24,640 --> 00:25:28,080
space looks like this so instead of uh

681
00:25:28,080 --> 00:25:29,840
just having a message there is an

682
00:25:29,840 --> 00:25:32,559
additional prefix x which is attached to

683
00:25:32,559 --> 00:25:34,960
the beginning of the message

684
00:25:34,960 --> 00:25:36,960
the key generation the signature and the

685
00:25:36,960 --> 00:25:38,960
verification procedures have the exact

686
00:25:38,960 --> 00:25:41,840
same syntax as what you would expect

687
00:25:41,840 --> 00:25:44,960
from a normal signature scheme however

688
00:25:44,960 --> 00:25:47,520
there is one additional procedure which

689
00:25:47,520 --> 00:25:49,840
is called puncture which takes as input

690
00:25:49,840 --> 00:25:52,080
the private key sk

691
00:25:52,080 --> 00:25:54,640
and a prefix x star and gives you a

692
00:25:54,640 --> 00:25:58,320
punctured key sk sub x star so what this

693
00:25:58,320 --> 00:25:59,360
punctured

694
00:25:59,360 --> 00:26:01,600
private key allows you to do is that it

695
00:26:01,600 --> 00:26:05,440
allows you to sign any message except

696
00:26:05,440 --> 00:26:09,440
once that is that has a prefix x star

697
00:26:09,440 --> 00:26:11,360
so you can you can use it to sign a

698
00:26:11,360 --> 00:26:14,000
message that is say for example x one m

699
00:26:14,000 --> 00:26:17,440
x two m uh whatever but you cannot use

700
00:26:17,440 --> 00:26:21,600
it to sign a message which is x star n

701
00:26:21,600 --> 00:26:23,679
so for this punctured

702
00:26:23,679 --> 00:26:25,360
private key we require strong

703
00:26:25,360 --> 00:26:27,919
correctness essentially saying that

704
00:26:27,919 --> 00:26:31,039
the signature you get by using this

705
00:26:31,039 --> 00:26:34,480
punctured key on any message that has a

706
00:26:34,480 --> 00:26:36,559
prefix different from x-star

707
00:26:36,559 --> 00:26:38,640
is exactly the same

708
00:26:38,640 --> 00:26:40,960
as what you will get from a from the

709
00:26:40,960 --> 00:26:43,520
original private key notice that this is

710
00:26:43,520 --> 00:26:45,840
a strengthening of the original result

711
00:26:45,840 --> 00:26:48,640
in um by belair and power in

712
00:26:48,640 --> 00:26:50,720
2014. originally the only required

713
00:26:50,720 --> 00:26:53,600
correctness is saying that the

714
00:26:53,600 --> 00:26:56,640
signature produced by the by the by the

715
00:26:56,640 --> 00:26:58,799
by the puncture key

716
00:26:58,799 --> 00:27:01,279
verifies to be a valid signature but it

717
00:27:01,279 --> 00:27:03,120
does not require that the signature to

718
00:27:03,120 --> 00:27:05,520
be exactly the same as you will get from

719
00:27:05,520 --> 00:27:08,080
the original private key but for the for

720
00:27:08,080 --> 00:27:09,600
our application we will actually need

721
00:27:09,600 --> 00:27:11,279
this strong correctness and we show in

722
00:27:11,279 --> 00:27:13,679
the paper how to strengthen their result

723
00:27:13,679 --> 00:27:14,960
to get this strong correctness

724
00:27:14,960 --> 00:27:16,880
requirement

725
00:27:16,880 --> 00:27:18,960
additionally we require puncture key

726
00:27:18,960 --> 00:27:21,360
security which says that

727
00:27:21,360 --> 00:27:23,919
for any there is no

728
00:27:23,919 --> 00:27:26,159
ppt adversary that takes as input the

729
00:27:26,159 --> 00:27:28,080
punctured key

730
00:27:28,080 --> 00:27:30,080
together with the public key and

731
00:27:30,080 --> 00:27:32,559
the prefix that the key is punctured on

732
00:27:32,559 --> 00:27:35,679
and produces a puncture and produces a

733
00:27:35,679 --> 00:27:38,000
valid signature on a message which

734
00:27:38,000 --> 00:27:41,039
starts with the prefix x star

735
00:27:41,039 --> 00:27:42,559
this is essentially saying that you

736
00:27:42,559 --> 00:27:45,360
cannot use the puncture key to sign a

737
00:27:45,360 --> 00:27:49,520
message where the prefix was punctured

738
00:27:49,520 --> 00:27:50,799
so

739
00:27:50,799 --> 00:27:54,880
let's jump into our construction

740
00:27:54,880 --> 00:27:57,039
so for our construction it works as

741
00:27:57,039 --> 00:27:58,480
follows

742
00:27:58,480 --> 00:28:00,880
so there is the public key secret key

743
00:28:00,880 --> 00:28:03,600
pair is just simply generated by using

744
00:28:03,600 --> 00:28:06,960
the prefix punctuable signature scheme

745
00:28:06,960 --> 00:28:08,960
it's just the public key and secret key

746
00:28:08,960 --> 00:28:10,640
you will get from the

747
00:28:10,640 --> 00:28:13,440
prefix punctual signature key

748
00:28:13,440 --> 00:28:15,360
and then alice is just going to going to

749
00:28:15,360 --> 00:28:17,760
send over the public key to bob

750
00:28:17,760 --> 00:28:18,960
and

751
00:28:18,960 --> 00:28:21,760
when alice tries to send to sign a

752
00:28:21,760 --> 00:28:23,919
message what alex will do is to

753
00:28:23,919 --> 00:28:25,919
construct the following program so the

754
00:28:25,919 --> 00:28:28,880
program will embed the the private key

755
00:28:28,880 --> 00:28:31,919
sk and the message m

756
00:28:31,919 --> 00:28:35,360
and essentially uh the the the program

757
00:28:35,360 --> 00:28:38,559
will use the input as a prefix and sign

758
00:28:38,559 --> 00:28:40,399
the message attached with the with the

759
00:28:40,399 --> 00:28:41,600
prefix

760
00:28:41,600 --> 00:28:45,919
using the embedded private key sk

761
00:28:45,919 --> 00:28:47,279
and then alice will send over the

762
00:28:47,279 --> 00:28:48,960
message together with the signature

763
00:28:48,960 --> 00:28:50,640
which is now a stream

764
00:28:50,640 --> 00:28:52,320
which is the obfuscated version of the

765
00:28:52,320 --> 00:28:54,080
program obviously

766
00:28:54,080 --> 00:28:55,919
over to bob

767
00:28:55,919 --> 00:28:56,960
and

768
00:28:56,960 --> 00:29:00,080
for bob to verify the signature

769
00:29:00,080 --> 00:29:02,159
bob will first of all sample a random

770
00:29:02,159 --> 00:29:04,559
prefix x star

771
00:29:04,559 --> 00:29:07,520
and then evaluate the

772
00:29:07,520 --> 00:29:10,640
the streamed obfuscated program

773
00:29:10,640 --> 00:29:13,279
using eval in an online manner on the

774
00:29:13,279 --> 00:29:16,399
input x star which is the random prefix

775
00:29:16,399 --> 00:29:19,440
that bob has just fixed has just picked

776
00:29:19,440 --> 00:29:20,960
and correspondingly received the

777
00:29:20,960 --> 00:29:24,000
signature sigma star

778
00:29:24,000 --> 00:29:26,880
and the output of bob is just by running

779
00:29:26,880 --> 00:29:29,679
the verification algorithm of the prefix

780
00:29:29,679 --> 00:29:32,320
punctual signature scheme uh using the

781
00:29:32,320 --> 00:29:34,320
public key together with the with the

782
00:29:34,320 --> 00:29:36,399
message where the message is set to be

783
00:29:36,399 --> 00:29:38,080
the original message m

784
00:29:38,080 --> 00:29:41,279
attached with a with the prefix x-star

785
00:29:41,279 --> 00:29:42,399
in the front

786
00:29:42,399 --> 00:29:44,480
notice that the correctness is easily

787
00:29:44,480 --> 00:29:46,880
implied by the correctness of the

788
00:29:46,880 --> 00:29:49,840
prefix punctual signature scheme

789
00:29:49,840 --> 00:29:52,480
in the in the

790
00:29:52,840 --> 00:29:55,919
construction so now let's look at how

791
00:29:55,919 --> 00:29:57,760
this construction fulfills our

792
00:29:57,760 --> 00:30:01,440
unfoldability security requirement

793
00:30:01,440 --> 00:30:03,919
so let's let us first plug our

794
00:30:03,919 --> 00:30:05,360
construction into the original

795
00:30:05,360 --> 00:30:07,919
experiment so the challenger will first

796
00:30:07,919 --> 00:30:09,760
of all sample the public key secret

797
00:30:09,760 --> 00:30:12,080
repair using the prefix punctual

798
00:30:12,080 --> 00:30:13,440
signature scheme

799
00:30:13,440 --> 00:30:15,760
and then send over the public key to the

800
00:30:15,760 --> 00:30:18,399
adversary and the apps requires a whole

801
00:30:18,399 --> 00:30:20,000
bunch of messages

802
00:30:20,000 --> 00:30:24,080
and to answer these queries um the the

803
00:30:24,080 --> 00:30:25,600
the challenger will

804
00:30:25,600 --> 00:30:27,279
create the following program which is

805
00:30:27,279 --> 00:30:29,360
essentially just the signing procedure

806
00:30:29,360 --> 00:30:31,520
of the of the prefix configurable

807
00:30:31,520 --> 00:30:32,960
signature scheme

808
00:30:32,960 --> 00:30:34,960
and then sends over the signatures which

809
00:30:34,960 --> 00:30:37,600
are now office kda programs which are

810
00:30:37,600 --> 00:30:40,080
streams over to the amsterdam and the

811
00:30:40,080 --> 00:30:41,840
absolute of course queries as many

812
00:30:41,840 --> 00:30:44,559
messages as it wants and in the end the

813
00:30:44,559 --> 00:30:46,960
absolute outputs a message signature

814
00:30:46,960 --> 00:30:50,720
pair for any message

815
00:30:50,720 --> 00:30:53,600
and notice that to verify the the

816
00:30:53,600 --> 00:30:57,039
adversary's output the challenger will

817
00:30:57,039 --> 00:30:58,880
sample first of all sample a random

818
00:30:58,880 --> 00:31:00,480
prefix x star

819
00:31:00,480 --> 00:31:03,360
and then run the evaluate the obfuscated

820
00:31:03,360 --> 00:31:06,640
program on the input x star and obtain a

821
00:31:06,640 --> 00:31:08,960
a short signature sigma prime other

822
00:31:08,960 --> 00:31:10,960
sorry sigma star

823
00:31:10,960 --> 00:31:13,360
and the output of the of the experiment

824
00:31:13,360 --> 00:31:15,679
is simply by running the verification of

825
00:31:15,679 --> 00:31:18,240
the prefix punctual signature scheme on

826
00:31:18,240 --> 00:31:21,120
x-star m

827
00:31:21,760 --> 00:31:23,919
again we will show the security using a

828
00:31:23,919 --> 00:31:26,080
sequence of hybrids so in the first

829
00:31:26,080 --> 00:31:28,159
hybrid notice that

830
00:31:28,159 --> 00:31:30,720
the the challenger needs to sample this

831
00:31:30,720 --> 00:31:33,600
random prefix x star but now instead of

832
00:31:33,600 --> 00:31:35,600
sampling it after receiving the message

833
00:31:35,600 --> 00:31:37,840
signature pair from the absolute we

834
00:31:37,840 --> 00:31:40,000
sample it at the very beginning of the

835
00:31:40,000 --> 00:31:42,320
experiment right after we sample the

836
00:31:42,320 --> 00:31:44,640
public key secret pair

837
00:31:44,640 --> 00:31:47,120
and right after we sample the prefix

838
00:31:47,120 --> 00:31:50,000
x-star we also sample a punctured

839
00:31:50,000 --> 00:31:52,799
private key sk sub x-star

840
00:31:52,799 --> 00:31:55,279
but we don't use this punctured key

841
00:31:55,279 --> 00:31:58,640
anywhere so notice that

842
00:31:58,640 --> 00:32:01,840
we here we're just reordering stuff and

843
00:32:01,840 --> 00:32:05,279
we're not using the the puncture key so

844
00:32:05,279 --> 00:32:06,880
this hybrid should be

845
00:32:06,880 --> 00:32:08,320
indistinguishable

846
00:32:08,320 --> 00:32:11,200
from the adversary

847
00:32:11,519 --> 00:32:14,240
and then next step we will gradually

848
00:32:14,240 --> 00:32:17,600
modify the obfuscated programs

849
00:32:17,600 --> 00:32:20,000
starting from the last query by the

850
00:32:20,000 --> 00:32:21,919
adversary all the way back to the first

851
00:32:21,919 --> 00:32:23,279
query

852
00:32:23,279 --> 00:32:25,039
so how do we modify these programs we

853
00:32:25,039 --> 00:32:27,200
will modify these programs

854
00:32:27,200 --> 00:32:30,960
so that they reject on the prefix x star

855
00:32:30,960 --> 00:32:33,360
but now notice that since we reject only

856
00:32:33,360 --> 00:32:35,760
on the prefix x star we only need to

857
00:32:35,760 --> 00:32:38,720
sign the messages which has a prefix

858
00:32:38,720 --> 00:32:41,039
different from x star so we can easily

859
00:32:41,039 --> 00:32:43,120
sign these using the puncture private

860
00:32:43,120 --> 00:32:45,279
key sk sub x star

861
00:32:45,279 --> 00:32:47,279
so instead of embedding the original

862
00:32:47,279 --> 00:32:49,760
private key sk in the program we now

863
00:32:49,760 --> 00:32:52,720
embed the punctured private key sk sub x

864
00:32:52,720 --> 00:32:54,720
star in these programs

865
00:32:54,720 --> 00:32:56,559
notice that this step is

866
00:32:56,559 --> 00:32:58,399
indistinguishable from the atmosphere

867
00:32:58,399 --> 00:32:59,519
because

868
00:32:59,519 --> 00:33:01,279
x star is still information

869
00:33:01,279 --> 00:33:03,360
theoretically hidden from the f3 because

870
00:33:03,360 --> 00:33:06,879
it's not used anywhere else

871
00:33:07,200 --> 00:33:09,200
but now in this scenario notice that the

872
00:33:09,200 --> 00:33:11,519
entire view of the adversary can be

873
00:33:11,519 --> 00:33:14,799
simulated using only the private using

874
00:33:14,799 --> 00:33:17,519
only the puncture private key sk sub x

875
00:33:17,519 --> 00:33:18,559
star

876
00:33:18,559 --> 00:33:20,720
but at the end the adversary is able to

877
00:33:20,720 --> 00:33:23,840
come up with a valid signature with the

878
00:33:23,840 --> 00:33:25,600
prefix x star

879
00:33:25,600 --> 00:33:28,000
which violates the prefix punctuable

880
00:33:28,000 --> 00:33:29,200
signature

881
00:33:29,200 --> 00:33:31,120
security requirement

882
00:33:31,120 --> 00:33:34,000
therefore we have shown that

883
00:33:34,000 --> 00:33:36,720
if we assume online obfuscation with vgb

884
00:33:36,720 --> 00:33:39,679
security together with prefix punctuable

885
00:33:39,679 --> 00:33:42,480
signatures then no ppt atmosphere with a

886
00:33:42,480 --> 00:33:44,000
space bound

887
00:33:44,000 --> 00:33:46,559
can break our disappearing signature

888
00:33:46,559 --> 00:33:49,200
security gain

889
00:33:49,200 --> 00:33:50,480
to conclude

890
00:33:50,480 --> 00:33:52,240
we initiate the study of disappearing

891
00:33:52,240 --> 00:33:54,240
cryptography in a boundary storage model

892
00:33:54,240 --> 00:33:56,159
by investigating these four different

893
00:33:56,159 --> 00:33:58,240
schemes corresponding to disappearing

894
00:33:58,240 --> 00:34:00,640
cipher text disappearing signatures and

895
00:34:00,640 --> 00:34:03,200
disappearing programs as we have seen in

896
00:34:03,200 --> 00:34:06,320
examples at the beginning of the talk

897
00:34:06,320 --> 00:34:08,399
usually when the way people use the

898
00:34:08,399 --> 00:34:10,879
boundary storage model is to use it to

899
00:34:10,879 --> 00:34:13,599
prove things information theoretically

900
00:34:13,599 --> 00:34:16,239
however here by combining the boundary

901
00:34:16,239 --> 00:34:18,560
storage model with computational

902
00:34:18,560 --> 00:34:20,879
assumptions we're able to achieve never

903
00:34:20,879 --> 00:34:23,760
before possible results for example in

904
00:34:23,760 --> 00:34:26,639
the disappear in the disappearing pke

905
00:34:26,639 --> 00:34:27,599
scheme

906
00:34:27,599 --> 00:34:30,079
we achieve a form of forward secrecy

907
00:34:30,079 --> 00:34:32,079
which is only possible in the standard

908
00:34:32,079 --> 00:34:35,520
model if we update the private keys but

909
00:34:35,520 --> 00:34:38,079
updating the keys can be undesirable and

910
00:34:38,079 --> 00:34:42,720
can be undesirable in many circumstances

911
00:34:42,960 --> 00:34:45,359
secondly we also initiate the study of

912
00:34:45,359 --> 00:34:47,119
obfuscation in the boundary storage

913
00:34:47,119 --> 00:34:48,960
model just as standard model

914
00:34:48,960 --> 00:34:50,639
authentication has proven to be a

915
00:34:50,639 --> 00:34:52,879
central tool in the study of standard

916
00:34:52,879 --> 00:34:55,520
model cryptography our work demonstrates

917
00:34:55,520 --> 00:34:58,240
that online obfuscation in the boundary

918
00:34:58,240 --> 00:35:00,960
storage model is analogously a central

919
00:35:00,960 --> 00:35:02,800
tool in the study of disappearing

920
00:35:02,800 --> 00:35:04,480
cryptography

921
00:35:04,480 --> 00:35:06,480
and just as gender model obfuscation

922
00:35:06,480 --> 00:35:09,200
schemes started out as conjectures we

923
00:35:09,200 --> 00:35:11,359
hope that future work will improve the

924
00:35:11,359 --> 00:35:13,920
status of our candidate constructions or

925
00:35:13,920 --> 00:35:16,160
come up with a proof a full security

926
00:35:16,160 --> 00:35:18,320
proof of our candidate constructions we

927
00:35:18,320 --> 00:35:20,079
believe these are interesting open

928
00:35:20,079 --> 00:35:22,880
questions to explore

929
00:35:22,880 --> 00:35:25,599
lastly thank you for your time and here

930
00:35:25,599 --> 00:35:28,240
is a link to our e-print version of the

931
00:35:28,240 --> 00:35:29,200
paper

932
00:35:29,200 --> 00:35:30,560
you can give it a read if you're

933
00:35:30,560 --> 00:35:32,720
interested and contact me if you have

934
00:35:32,720 --> 00:35:37,480
any questions thank you for your time

