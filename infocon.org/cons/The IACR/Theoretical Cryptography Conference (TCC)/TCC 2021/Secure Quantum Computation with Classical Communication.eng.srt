1
00:00:02,240 --> 00:00:04,080
okay i'll be discussing this work called

2
00:00:04,080 --> 00:00:05,520
secure quantum computation with

3
00:00:05,520 --> 00:00:07,600
classical communication

4
00:00:07,600 --> 00:00:08,960
uh and this is a work about the notion

5
00:00:08,960 --> 00:00:11,360
of secure multi-party computation which

6
00:00:11,360 --> 00:00:13,120
studies the setting where we have

7
00:00:13,120 --> 00:00:15,120
multiple parties each with a private

8
00:00:15,120 --> 00:00:17,440
input x i that wish to compute some

9
00:00:17,440 --> 00:00:19,119
public circuit c over their private

10
00:00:19,119 --> 00:00:21,279
inputs um by communicating with each

11
00:00:21,279 --> 00:00:24,240
other and all learning um the output y

12
00:00:24,240 --> 00:00:27,039
okay and so we don't want

13
00:00:27,039 --> 00:00:28,720
these private inputs to be leaked to

14
00:00:28,720 --> 00:00:30,480
other parties and so for security more

15
00:00:30,480 --> 00:00:32,960
formally we say that um

16
00:00:32,960 --> 00:00:34,559
any adversary that corrupts any subset

17
00:00:34,559 --> 00:00:37,040
of these parties so for example uh party

18
00:00:37,040 --> 00:00:38,879
two and party three that they won't

19
00:00:38,879 --> 00:00:40,320
learn anything about the honest party

20
00:00:40,320 --> 00:00:43,040
inputs x1 or x4 except what they

21
00:00:43,040 --> 00:00:44,239
already could have learned from just the

22
00:00:44,239 --> 00:00:45,840
output of the circuit

23
00:00:45,840 --> 00:00:47,840
okay and this is you know

24
00:00:47,840 --> 00:00:50,000
a very well studied notion it goes back

25
00:00:50,000 --> 00:00:52,239
um the study of mpc goes back to kind of

26
00:00:52,239 --> 00:00:53,680
near the beginning of modern

27
00:00:53,680 --> 00:00:55,199
cryptography

28
00:00:55,199 --> 00:00:57,120
and um

29
00:00:57,120 --> 00:00:58,960
you know another notion that's been

30
00:00:58,960 --> 00:01:00,399
studied at least now for a couple

31
00:01:00,399 --> 00:01:02,559
decades is um

32
00:01:02,559 --> 00:01:04,799
uh it's the generalization of mpc to

33
00:01:04,799 --> 00:01:06,400
this the setting of multi-party quantum

34
00:01:06,400 --> 00:01:08,320
computation which is uh where every

35
00:01:08,320 --> 00:01:10,400
party can be quantum

36
00:01:10,400 --> 00:01:11,920
and maybe they each have quantum inputs

37
00:01:11,920 --> 00:01:13,840
and they want to compute a

38
00:01:13,840 --> 00:01:15,439
quantum functionality over their inputs

39
00:01:15,439 --> 00:01:17,119
okay and you can define security in the

40
00:01:17,119 --> 00:01:18,400
same way

41
00:01:18,400 --> 00:01:19,600
okay

42
00:01:19,600 --> 00:01:20,720
but

43
00:01:20,720 --> 00:01:22,080
the starting point for this work is

44
00:01:22,080 --> 00:01:23,600
noticing that so far

45
00:01:23,600 --> 00:01:25,360
npc has really been studied in one of

46
00:01:25,360 --> 00:01:27,119
these two settings either like every

47
00:01:27,119 --> 00:01:28,799
party is classical

48
00:01:28,799 --> 00:01:31,680
or every party is quantum okay

49
00:01:31,680 --> 00:01:32,640
um

50
00:01:32,640 --> 00:01:34,000
but i mean

51
00:01:34,000 --> 00:01:36,159
you know quantum technology is

52
00:01:36,159 --> 00:01:37,680
seemingly quite difficult to to

53
00:01:37,680 --> 00:01:38,960
construct so

54
00:01:38,960 --> 00:01:41,200
for the time being uh it's going to be

55
00:01:41,200 --> 00:01:42,479
the case that there's only going to be a

56
00:01:42,479 --> 00:01:44,240
few quantum computers out there in the

57
00:01:44,240 --> 00:01:46,640
world right so a pretty natural question

58
00:01:46,640 --> 00:01:50,320
uh to ask is well can we um you know

59
00:01:50,320 --> 00:01:52,399
achieve npc or can we do npc can we

60
00:01:52,399 --> 00:01:54,960
achieve any notion of it um when we have

61
00:01:54,960 --> 00:01:56,399
some mixture of classical and quantum

62
00:01:56,399 --> 00:01:58,320
parties right

63
00:01:58,320 --> 00:02:02,479
um so can we do some like secure can we

64
00:02:02,479 --> 00:02:04,000
can we do npc for quantum

65
00:02:04,000 --> 00:02:05,920
functionalities where not every quantum

66
00:02:05,920 --> 00:02:07,759
or not every party has to be quantum

67
00:02:07,759 --> 00:02:09,199
right

68
00:02:09,199 --> 00:02:10,878
so

69
00:02:10,878 --> 00:02:12,319
uh for example

70
00:02:12,319 --> 00:02:14,160
um you could consider the this following

71
00:02:14,160 --> 00:02:15,920
notion where we maybe have one quantum

72
00:02:15,920 --> 00:02:18,080
server uh the party one that's

73
00:02:18,080 --> 00:02:19,440
interacting with a bunch of classical

74
00:02:19,440 --> 00:02:20,720
clients and they all want to come

75
00:02:20,720 --> 00:02:22,000
together to compete some quantum

76
00:02:22,000 --> 00:02:24,160
functionality over their private inputs

77
00:02:24,160 --> 00:02:25,040
okay

78
00:02:25,040 --> 00:02:26,640
and so this is the type of notion that

79
00:02:26,640 --> 00:02:29,040
um i like to study in this work

80
00:02:29,040 --> 00:02:30,879
and so we can again define security the

81
00:02:30,879 --> 00:02:32,480
same way an adversary that corrupts any

82
00:02:32,480 --> 00:02:34,160
subset of parties like including like

83
00:02:34,160 --> 00:02:36,640
collusions between clients and server uh

84
00:02:36,640 --> 00:02:37,840
that they won't learn anything about the

85
00:02:37,840 --> 00:02:39,360
honest party's inputs

86
00:02:39,360 --> 00:02:41,599
okay

87
00:02:41,760 --> 00:02:43,280
um

88
00:02:43,280 --> 00:02:44,400
right so

89
00:02:44,400 --> 00:02:46,319
this is what uh this work studies and

90
00:02:46,319 --> 00:02:50,080
the starting point is some prior work on

91
00:02:50,080 --> 00:02:52,400
kind of protocols that can be uh you

92
00:02:52,400 --> 00:02:54,480
know that can be interpreted as

93
00:02:54,480 --> 00:02:56,640
basically like single client single

94
00:02:56,640 --> 00:02:59,760
server um two-party protocols right so

95
00:02:59,760 --> 00:03:01,440
in this setting we have like one one

96
00:03:01,440 --> 00:03:03,440
client with a quantum circuit

97
00:03:03,440 --> 00:03:05,920
queue um classical input x so this

98
00:03:05,920 --> 00:03:07,920
client is classical we have a quantum

99
00:03:07,920 --> 00:03:08,800
server

100
00:03:08,800 --> 00:03:10,720
and uh you know they interact back and

101
00:03:10,720 --> 00:03:11,920
forth and at the end of this interaction

102
00:03:11,920 --> 00:03:14,400
the quant the client outputs q of x okay

103
00:03:14,400 --> 00:03:15,440
and

104
00:03:15,440 --> 00:03:17,920
um in particular i want to cover you

105
00:03:17,920 --> 00:03:19,599
know mention two protocols that were

106
00:03:19,599 --> 00:03:22,000
constructed a couple years ago for this

107
00:03:22,000 --> 00:03:25,760
setting so mahadev in 2018

108
00:03:25,760 --> 00:03:28,000
gave a protocol for quantum fully

109
00:03:28,000 --> 00:03:30,000
homomorphic encryption

110
00:03:30,000 --> 00:03:31,120
okay

111
00:03:31,120 --> 00:03:32,720
which

112
00:03:32,720 --> 00:03:34,319
basically achieves the cryptographic

113
00:03:34,319 --> 00:03:36,159
notion of blindness in the setting which

114
00:03:36,159 --> 00:03:38,239
means that a malicious server is not

115
00:03:38,239 --> 00:03:39,599
going to be able to learn the client's

116
00:03:39,599 --> 00:03:41,200
input x

117
00:03:41,200 --> 00:03:43,120
while interacting in this protocol

118
00:03:43,120 --> 00:03:44,640
okay

119
00:03:44,640 --> 00:03:46,239
so another cryptographic notion that you

120
00:03:46,239 --> 00:03:49,040
could uh or another security notion uh

121
00:03:49,040 --> 00:03:50,560
that you could hope for is kind of more

122
00:03:50,560 --> 00:03:52,560
of a correctness notion which means that

123
00:03:52,560 --> 00:03:54,239
the malicious server cannot cause the

124
00:03:54,239 --> 00:03:56,400
client to output a false outcome and

125
00:03:56,400 --> 00:03:58,799
indeed mahadevan 2018 constructed this

126
00:03:58,799 --> 00:04:00,959
protocol called classical verification

127
00:04:00,959 --> 00:04:02,560
of quantum computation that achieves

128
00:04:02,560 --> 00:04:05,120
exactly this so i'll call this soundness

129
00:04:05,120 --> 00:04:06,720
where a malicious server cannot cause

130
00:04:06,720 --> 00:04:09,280
the client to output um a wrong output y

131
00:04:09,280 --> 00:04:11,760
not equal to q of x okay you know so

132
00:04:11,760 --> 00:04:13,439
prior to this work there exists these

133
00:04:13,439 --> 00:04:15,360
two these two protocols

134
00:04:15,360 --> 00:04:17,040
uh two different protocols in this kind

135
00:04:17,040 --> 00:04:18,798
of like single client single server

136
00:04:18,798 --> 00:04:20,880
setting okay

137
00:04:20,880 --> 00:04:23,120
but if we want to achieve like the full

138
00:04:23,120 --> 00:04:25,919
full notion of secure computation um or

139
00:04:25,919 --> 00:04:27,120
mpc

140
00:04:27,120 --> 00:04:28,720
it really requires a protocol that

141
00:04:28,720 --> 00:04:30,479
achieves both blindness and soundness

142
00:04:30,479 --> 00:04:32,320
simultaneously parties need to hide

143
00:04:32,320 --> 00:04:33,680
their inputs from other parties and they

144
00:04:33,680 --> 00:04:34,720
need to be

145
00:04:34,720 --> 00:04:36,400
ensured of the correctness of the output

146
00:04:36,400 --> 00:04:37,840
okay so we need kind of one protocol

147
00:04:37,840 --> 00:04:40,720
that combines both of these

148
00:04:40,720 --> 00:04:41,680
okay

149
00:04:41,680 --> 00:04:42,560
so

150
00:04:42,560 --> 00:04:44,240
you know let's try to do that

151
00:04:44,240 --> 00:04:46,000
actually so

152
00:04:46,000 --> 00:04:47,280
let's look at like this let's look more

153
00:04:47,280 --> 00:04:49,360
closely at first this this blind like

154
00:04:49,360 --> 00:04:51,520
qfhe protocol right and so syntactically

155
00:04:51,520 --> 00:04:53,120
what happens is there's only a two

156
00:04:53,120 --> 00:04:54,560
message protocol

157
00:04:54,560 --> 00:04:56,080
you know the client will just kind of

158
00:04:56,080 --> 00:04:58,320
choose a public key um we'll encrypt

159
00:04:58,320 --> 00:05:00,000
their input x under the public key send

160
00:05:00,000 --> 00:05:01,520
it to the server the server will

161
00:05:01,520 --> 00:05:03,120
evaluate the functionality under the

162
00:05:03,120 --> 00:05:05,199
encryption and then return the evaluated

163
00:05:05,199 --> 00:05:06,800
cipher text back to the client which the

164
00:05:06,800 --> 00:05:09,360
client can then decrypt okay

165
00:05:09,360 --> 00:05:11,520
so this is the syntactically what qfhe

166
00:05:11,520 --> 00:05:14,080
is syntactically what cvqc is the the

167
00:05:14,080 --> 00:05:16,320
sound notion um here i'll give kind of

168
00:05:16,320 --> 00:05:18,160
an example of like what a two message

169
00:05:18,160 --> 00:05:19,680
protocol could look like but in general

170
00:05:19,680 --> 00:05:21,680
it could be more than two messages

171
00:05:21,680 --> 00:05:23,840
here we have a client that

172
00:05:23,840 --> 00:05:25,600
you know constructs some public

173
00:05:25,600 --> 00:05:27,360
parameters based on

174
00:05:27,360 --> 00:05:29,280
the circuit and their input and

175
00:05:29,280 --> 00:05:31,360
we have no notion of hiding for these

176
00:05:31,360 --> 00:05:32,720
public parameters they could include

177
00:05:32,720 --> 00:05:34,400
like in the clear descriptions of q and

178
00:05:34,400 --> 00:05:35,919
x right

179
00:05:35,919 --> 00:05:36,720
but

180
00:05:36,720 --> 00:05:38,400
what the server can do is run some like

181
00:05:38,400 --> 00:05:40,880
prove algorithm that that outputs

182
00:05:40,880 --> 00:05:43,919
uh the evaluated circuit q of x along

183
00:05:43,919 --> 00:05:46,160
with uh some proof of correctness and so

184
00:05:46,160 --> 00:05:48,479
now the ver the client can go and verify

185
00:05:48,479 --> 00:05:50,560
that this proof is correct if it is then

186
00:05:50,560 --> 00:05:52,479
they will happily output q of x and

187
00:05:52,479 --> 00:05:54,560
otherwise they're going to abort so this

188
00:05:54,560 --> 00:05:57,280
is this is the um syntactically what the

189
00:05:57,280 --> 00:05:59,759
cbqc protocol looks like

190
00:05:59,759 --> 00:06:01,360
so

191
00:06:01,360 --> 00:06:03,840
recall that basically as a first step we

192
00:06:03,840 --> 00:06:05,680
just want to combine both protocols we

193
00:06:05,680 --> 00:06:07,120
want to get a notion of both blindness

194
00:06:07,120 --> 00:06:09,680
and soundness at the same time okay so

195
00:06:09,680 --> 00:06:11,120
there's a really natural way to try to

196
00:06:11,120 --> 00:06:15,199
do this like let's simply run

197
00:06:15,199 --> 00:06:17,520
the cvqc protocol under the hood of a

198
00:06:17,520 --> 00:06:19,680
quantum fhe okay

199
00:06:19,680 --> 00:06:21,680
so i'll call this like a blind cvtc

200
00:06:21,680 --> 00:06:23,520
protocol and again you know what does

201
00:06:23,520 --> 00:06:25,280
this look like the client just chooses

202
00:06:25,280 --> 00:06:27,440
some public parameters encrypted under

203
00:06:27,440 --> 00:06:30,720
the fhe public key and now this the

204
00:06:30,720 --> 00:06:32,720
server can evaluate the proving

205
00:06:32,720 --> 00:06:34,880
algorithm under fhe give it back to the

206
00:06:34,880 --> 00:06:35,919
client

207
00:06:35,919 --> 00:06:38,080
the client then just does two steps

208
00:06:38,080 --> 00:06:40,960
right first it decrypts the ciphertext

209
00:06:40,960 --> 00:06:42,639
to get to the q of x along with the

210
00:06:42,639 --> 00:06:44,479
proof then it verifies the proof

211
00:06:44,479 --> 00:06:46,400
okay so this seems like a pretty

212
00:06:46,400 --> 00:06:48,000
reasonable protocol that would that

213
00:06:48,000 --> 00:06:49,840
achieves both blindness and soundness at

214
00:06:49,840 --> 00:06:51,440
the same time

215
00:06:51,440 --> 00:06:52,800
right

216
00:06:52,800 --> 00:06:54,080
okay

217
00:06:54,080 --> 00:06:57,280
so let's try to use this protocol um to

218
00:06:57,280 --> 00:06:59,039
you know construct what i you want to

219
00:06:59,039 --> 00:07:00,639
construct one what i mentioned that i

220
00:07:00,639 --> 00:07:01,919
wanted to construct at the beginning of

221
00:07:01,919 --> 00:07:04,720
this talk right which is just a you know

222
00:07:04,720 --> 00:07:06,800
a notion of npc between multiple

223
00:07:06,800 --> 00:07:08,560
classical clients and one quantum server

224
00:07:08,560 --> 00:07:09,360
okay

225
00:07:09,360 --> 00:07:11,039
so let's say we have three classical

226
00:07:11,039 --> 00:07:13,120
clients we have one quantum server

227
00:07:13,120 --> 00:07:16,000
um a pretty natural idea now is to say

228
00:07:16,000 --> 00:07:18,960
well let's use classical npc

229
00:07:18,960 --> 00:07:21,120
to emulate a single client interacting

230
00:07:21,120 --> 00:07:23,520
in this like client this blind cvqc

231
00:07:23,520 --> 00:07:26,160
protocol that i just mentioned okay

232
00:07:26,160 --> 00:07:27,440
so they're going to basically use

233
00:07:27,440 --> 00:07:30,639
classical npc to become a single client

234
00:07:30,639 --> 00:07:33,039
that has you know as input the

235
00:07:33,039 --> 00:07:34,560
concatenation of the three private

236
00:07:34,560 --> 00:07:36,000
inputs of these parties okay and what

237
00:07:36,000 --> 00:07:36,960
does this look like then they can

238
00:07:36,960 --> 00:07:38,319
interact with the server right they can

239
00:07:38,319 --> 00:07:40,960
encrypt these inputs

240
00:07:40,960 --> 00:07:42,960
in the blind cvc protocol the server can

241
00:07:42,960 --> 00:07:45,759
run the the prove algorithm under qfhe

242
00:07:45,759 --> 00:07:47,599
and then they can use classical npc to

243
00:07:47,599 --> 00:07:48,960
kind of uh

244
00:07:48,960 --> 00:07:51,759
you know decrypt and verify the output

245
00:07:51,759 --> 00:07:53,360
and then all these clients can either

246
00:07:53,360 --> 00:07:55,280
output like you know the correct output

247
00:07:55,280 --> 00:07:56,720
or in a book

248
00:07:56,720 --> 00:07:57,759
okay

249
00:07:57,759 --> 00:07:59,520
so

250
00:07:59,520 --> 00:08:02,000
right so this is i don't know

251
00:08:02,000 --> 00:08:05,039
like are we done this is like this is uh

252
00:08:05,039 --> 00:08:06,639
the first attempt basically it's saying

253
00:08:06,639 --> 00:08:08,560
like well let's just put blind cb let's

254
00:08:08,560 --> 00:08:10,879
just put qfhe cvqc together let's put

255
00:08:10,879 --> 00:08:12,639
classical npc on top of it does this

256
00:08:12,639 --> 00:08:14,560
give us actually what we want like a

257
00:08:14,560 --> 00:08:15,599
protocol

258
00:08:15,599 --> 00:08:17,919
for secure npc

259
00:08:17,919 --> 00:08:18,800
um

260
00:08:18,800 --> 00:08:20,960
and so it turns out that it's not the

261
00:08:20,960 --> 00:08:22,240
case there's actually an attack on this

262
00:08:22,240 --> 00:08:23,360
protocol

263
00:08:23,360 --> 00:08:24,319
okay

264
00:08:24,319 --> 00:08:27,360
and to see this uh let's say that like

265
00:08:27,360 --> 00:08:30,000
all buts uh one client are corrupted

266
00:08:30,000 --> 00:08:32,000
okay so the server is corrupted and

267
00:08:32,000 --> 00:08:34,000
they're colluding with you know some

268
00:08:34,000 --> 00:08:36,640
some client okay

269
00:08:36,640 --> 00:08:37,679
so

270
00:08:37,679 --> 00:08:38,479
um

271
00:08:38,479 --> 00:08:40,559
since the server is corrupted what they

272
00:08:40,559 --> 00:08:42,240
can do is they can you know

273
00:08:42,240 --> 00:08:44,560
they can produce a false proof here and

274
00:08:44,560 --> 00:08:46,800
they can do this under the fhe okay so

275
00:08:46,800 --> 00:08:48,399
what is the server going to do

276
00:08:48,399 --> 00:08:51,040
like under this fhe they're going to

277
00:08:51,040 --> 00:08:53,200
compete a valid proof like how an honest

278
00:08:53,200 --> 00:08:55,440
prover would would compute it

279
00:08:55,440 --> 00:08:57,920
uh depending on like whether

280
00:08:57,920 --> 00:08:59,839
like depending on the

281
00:08:59,839 --> 00:09:01,920
uh the input x3 so this is the honest

282
00:09:01,920 --> 00:09:04,080
party's input x3 and the server can kind

283
00:09:04,080 --> 00:09:06,560
of operate on this input under fhe right

284
00:09:06,560 --> 00:09:09,040
so let's say they can compute a valid

285
00:09:09,040 --> 00:09:11,120
proof of x3 is equal to zero and an

286
00:09:11,120 --> 00:09:13,920
invalid proof of x3 is equal to one

287
00:09:13,920 --> 00:09:15,440
but what does this mean

288
00:09:15,440 --> 00:09:17,360
that means that when the clients like

289
00:09:17,360 --> 00:09:18,800
kind of decrypt the output they'll see

290
00:09:18,800 --> 00:09:21,760
the correct output q of x1 x2 x3 if x3

291
00:09:21,760 --> 00:09:23,519
is equal to zero and on the other hand

292
00:09:23,519 --> 00:09:25,760
they'll see a bot or an abort if x3 is

293
00:09:25,760 --> 00:09:26,959
equal to one

294
00:09:26,959 --> 00:09:28,959
and you know recall that like these

295
00:09:28,959 --> 00:09:31,519
clients can see this output and so you

296
00:09:31,519 --> 00:09:33,200
know this means that this adversary like

297
00:09:33,200 --> 00:09:35,120
this adversarial clients

298
00:09:35,120 --> 00:09:37,279
can completely learn any bit of x3 just

299
00:09:37,279 --> 00:09:39,839
based on the output of this protocol

300
00:09:39,839 --> 00:09:41,920
okay

301
00:09:41,920 --> 00:09:43,200
you know so this is kind of an attack

302
00:09:43,200 --> 00:09:44,560
that completely breaks the security of

303
00:09:44,560 --> 00:09:46,320
the protocol any more generally like

304
00:09:46,320 --> 00:09:47,839
kind of any predicate on any honest

305
00:09:47,839 --> 00:09:49,519
party's input can be

306
00:09:49,519 --> 00:09:51,440
can be learned using you know this is

307
00:09:51,440 --> 00:09:54,000
basically what's called a selective

308
00:09:54,000 --> 00:09:55,360
abort attack

309
00:09:55,360 --> 00:09:57,600
okay

310
00:09:58,480 --> 00:10:00,399
um

311
00:10:00,399 --> 00:10:02,079
all right

312
00:10:02,079 --> 00:10:04,800
so the takeaway um is that really if you

313
00:10:04,800 --> 00:10:05,760
just

314
00:10:05,760 --> 00:10:07,279
just try to match together standard

315
00:10:07,279 --> 00:10:08,560
blindness and soundness it's not going

316
00:10:08,560 --> 00:10:10,560
to be sufficient for for building

317
00:10:10,560 --> 00:10:13,040
achieving like the full notion of of npc

318
00:10:13,040 --> 00:10:14,000
okay

319
00:10:14,000 --> 00:10:16,079
in particular what it really boils down

320
00:10:16,079 --> 00:10:17,519
to is that we need this notion of

321
00:10:17,519 --> 00:10:19,760
blindness to hold even if the server can

322
00:10:19,760 --> 00:10:20,880
observe

323
00:10:20,880 --> 00:10:23,120
whether the client accepted its proof

324
00:10:23,120 --> 00:10:24,399
okay

325
00:10:24,399 --> 00:10:26,720
um

326
00:10:26,880 --> 00:10:28,959
like you know note that like what we

327
00:10:28,959 --> 00:10:30,000
just

328
00:10:30,000 --> 00:10:31,360
the problem with what we just saw is

329
00:10:31,360 --> 00:10:32,720
that like the adversary or like the

330
00:10:32,720 --> 00:10:34,480
approver as as soon as like we allow

331
00:10:34,480 --> 00:10:36,079
them to see like what the honest client

332
00:10:36,079 --> 00:10:38,079
or honest client's output um as soon as

333
00:10:38,079 --> 00:10:39,519
we allow that then they could kind of

334
00:10:39,519 --> 00:10:41,200
use that information to break privacy

335
00:10:41,200 --> 00:10:43,040
okay so we need to explicitly prevent

336
00:10:43,040 --> 00:10:44,839
this from happening

337
00:10:44,839 --> 00:10:46,800
um and

338
00:10:46,800 --> 00:10:49,360
this sort of thing can be um can be

339
00:10:49,360 --> 00:10:51,680
captured via you know what i via the

340
00:10:51,680 --> 00:10:54,079
notion of um what i call a composable

341
00:10:54,079 --> 00:10:55,839
blind cbqc

342
00:10:55,839 --> 00:10:58,240
and this is like basically a blind cvqc

343
00:10:58,240 --> 00:11:01,440
protocol that satisfies a or

344
00:11:01,440 --> 00:11:04,320
a particular ideal functionality okay

345
00:11:04,320 --> 00:11:06,079
this ideal functionality is going to be

346
00:11:06,079 --> 00:11:08,000
parameterized by the public circuits

347
00:11:08,000 --> 00:11:08,880
queue

348
00:11:08,880 --> 00:11:10,880
it's going to take a private input from

349
00:11:10,880 --> 00:11:12,959
the client and just a bit b from the

350
00:11:12,959 --> 00:11:14,560
server indicating whether the server is

351
00:11:14,560 --> 00:11:16,320
being honest or malicious okay if the

352
00:11:16,320 --> 00:11:17,920
server is being honest it'll just output

353
00:11:17,920 --> 00:11:20,240
key of x honestly back to the client if

354
00:11:20,240 --> 00:11:21,920
the server is being malicious it'll just

355
00:11:21,920 --> 00:11:23,920
abort okay

356
00:11:23,920 --> 00:11:26,240
and so

357
00:11:26,240 --> 00:11:28,320
so what does it mean to emulate this

358
00:11:28,320 --> 00:11:30,000
like or to satisfy this this ideal

359
00:11:30,000 --> 00:11:32,000
functionality that means if we have a

360
00:11:32,000 --> 00:11:33,760
protocol between a client and a server

361
00:11:33,760 --> 00:11:35,760
kind of like a real world protocol here

362
00:11:35,760 --> 00:11:37,680
where the client you know has some

363
00:11:37,680 --> 00:11:39,839
output y the adversarial server has some

364
00:11:39,839 --> 00:11:41,839
arbitrary output

365
00:11:41,839 --> 00:11:43,600
quantum state psi

366
00:11:43,600 --> 00:11:44,720
then

367
00:11:44,720 --> 00:11:45,600
um

368
00:11:45,600 --> 00:11:47,200
you know this output is going to be

369
00:11:47,200 --> 00:11:49,600
indistinguishable from a execution in

370
00:11:49,600 --> 00:11:51,519
this idealized world right where the

371
00:11:51,519 --> 00:11:53,360
client just all they do is they submit

372
00:11:53,360 --> 00:11:55,040
their input x to this ideal

373
00:11:55,040 --> 00:11:56,720
functionality

374
00:11:56,720 --> 00:11:58,880
there's a simulator that just inputs to

375
00:11:58,880 --> 00:12:01,279
ideal functionality whether this whether

376
00:12:01,279 --> 00:12:02,480
the

377
00:12:02,480 --> 00:12:04,560
server is being honest or malicious and

378
00:12:04,560 --> 00:12:06,959
then the client's output is determined

379
00:12:06,959 --> 00:12:09,279
by the idea functionality

380
00:12:09,279 --> 00:12:11,120
and so we want to say these are you know

381
00:12:11,120 --> 00:12:12,320
these are indistinguishable and this

382
00:12:12,320 --> 00:12:15,440
really captures this this notion of um

383
00:12:15,440 --> 00:12:18,079
the stronger notion of blindness

384
00:12:18,079 --> 00:12:20,399
um really because

385
00:12:20,399 --> 00:12:22,800
note that like basically whether the sim

386
00:12:22,800 --> 00:12:24,639
whether um

387
00:12:24,639 --> 00:12:26,639
the server is being honest malicious or

388
00:12:26,639 --> 00:12:29,440
malicious like this bit um cannot depend

389
00:12:29,440 --> 00:12:32,639
at all on um the client's input x okay

390
00:12:32,639 --> 00:12:34,800
so they cannot um determine whether or

391
00:12:34,800 --> 00:12:36,240
not the client aborts based on the

392
00:12:36,240 --> 00:12:37,440
client's input and that's kind of like

393
00:12:37,440 --> 00:12:38,720
captured within

394
00:12:38,720 --> 00:12:41,040
this this real ideal world

395
00:12:41,040 --> 00:12:43,120
paradigm for implementing this ideal

396
00:12:43,120 --> 00:12:46,160
functionality okay

397
00:12:46,399 --> 00:12:47,600
so

398
00:12:47,600 --> 00:12:49,600
you know the i guess the

399
00:12:49,600 --> 00:12:51,360
the goal of the rest of this talk is to

400
00:12:51,360 --> 00:12:53,360
basically discuss how to

401
00:12:53,360 --> 00:12:56,399
construct such a composable blind cvqc

402
00:12:56,399 --> 00:12:58,399
before i do that i'll just give a little

403
00:12:58,399 --> 00:13:00,079
bit of

404
00:13:00,079 --> 00:13:01,279
you know i'll note that actually this is

405
00:13:01,279 --> 00:13:03,519
this notion has been studied before

406
00:13:03,519 --> 00:13:05,120
so in particular

407
00:13:05,120 --> 00:13:07,760
this work of 2014 showed that um

408
00:13:07,760 --> 00:13:10,160
there are a couple protocols

409
00:13:10,160 --> 00:13:11,279
of

410
00:13:11,279 --> 00:13:13,839
mormon fk 17

411
00:13:13,839 --> 00:13:15,600
that are composable blind and sound

412
00:13:15,600 --> 00:13:17,279
delegation protocols in the setting

413
00:13:17,279 --> 00:13:19,200
where the verifier is quantum but

414
00:13:19,200 --> 00:13:22,000
performs limited quantum operations okay

415
00:13:22,000 --> 00:13:23,680
and these are protocols that achieve

416
00:13:23,680 --> 00:13:25,440
information theoretic security okay so

417
00:13:25,440 --> 00:13:26,720
these are like basically protocols

418
00:13:26,720 --> 00:13:30,000
between a limited quantum verifier and a

419
00:13:30,000 --> 00:13:32,000
fully quantum

420
00:13:32,000 --> 00:13:34,480
server okay and you want to achieve both

421
00:13:34,480 --> 00:13:36,800
like compo both blindness and soundness

422
00:13:36,800 --> 00:13:39,120
and in a composable way okay so this is

423
00:13:39,120 --> 00:13:41,760
this notion has been studied before

424
00:13:41,760 --> 00:13:44,560
um and more recently so gv and 19

425
00:13:44,560 --> 00:13:46,399
actually what they they did construct a

426
00:13:46,399 --> 00:13:48,399
composable blind classical verification

427
00:13:48,399 --> 00:13:50,639
of quantum computation protocol

428
00:13:50,639 --> 00:13:51,920
which is exactly the notion that i'm

429
00:13:51,920 --> 00:13:53,279
interested in

430
00:13:53,279 --> 00:13:55,120
assuming quantum hardness of learning

431
00:13:55,120 --> 00:13:56,240
with errors

432
00:13:56,240 --> 00:13:57,839
except that they do have like their

433
00:13:57,839 --> 00:13:59,120
their security is kind of is

434
00:13:59,120 --> 00:14:00,399
non-standard in the sense that they

435
00:14:00,399 --> 00:14:01,839
don't achieve and they don't achieve

436
00:14:01,839 --> 00:14:04,639
like standard negligible security okay

437
00:14:04,639 --> 00:14:06,560
in particular like the difference

438
00:14:06,560 --> 00:14:08,079
between that real and ideal world is

439
00:14:08,079 --> 00:14:10,240
going to be some inverse like you could

440
00:14:10,240 --> 00:14:11,519
distinguish them with something

441
00:14:11,519 --> 00:14:13,120
responsible probability and where that

442
00:14:13,120 --> 00:14:14,800
polynomial grows with the communication

443
00:14:14,800 --> 00:14:16,800
complexity of the protocol okay and

444
00:14:16,800 --> 00:14:19,279
moreover their their protocol um

445
00:14:19,279 --> 00:14:21,040
is highly interactive and takes part

446
00:14:21,040 --> 00:14:23,440
only many rounds okay

447
00:14:23,440 --> 00:14:25,530
so that's kind of the prior work um

448
00:14:25,530 --> 00:14:27,040
[Music]

449
00:14:27,040 --> 00:14:28,800
so now i can really say what the main

450
00:14:28,800 --> 00:14:30,800
results of this work are

451
00:14:30,800 --> 00:14:32,639
and the main technical contribution is

452
00:14:32,639 --> 00:14:34,560
this are new constructions of this

453
00:14:34,560 --> 00:14:36,720
composable blind cbqc

454
00:14:36,720 --> 00:14:39,120
primitive and in particular we do we

455
00:14:39,120 --> 00:14:40,800
obtain like a four message protocol

456
00:14:40,800 --> 00:14:42,639
that's like fully you know negligibly

457
00:14:42,639 --> 00:14:43,839
secure

458
00:14:43,839 --> 00:14:45,279
from the quantum hardness of learning of

459
00:14:45,279 --> 00:14:46,240
theirs

460
00:14:46,240 --> 00:14:47,600
and we can also compress it to two

461
00:14:47,600 --> 00:14:49,680
messages and even kind of distribute the

462
00:14:49,680 --> 00:14:52,880
setup among multiple parties um

463
00:14:52,880 --> 00:14:54,320
again from

464
00:14:54,320 --> 00:14:57,040
qlwe but um also

465
00:14:57,040 --> 00:14:58,320
operating in the quantum mechanical

466
00:14:58,320 --> 00:15:01,279
model okay

467
00:15:01,760 --> 00:15:03,199
um and so this is again this is the main

468
00:15:03,199 --> 00:15:04,480
technical contribution the main

469
00:15:04,480 --> 00:15:06,399
applications is to show

470
00:15:06,399 --> 00:15:08,240
then how to use like these composable

471
00:15:08,240 --> 00:15:12,399
blind cvtc protocols to construct mpc um

472
00:15:12,399 --> 00:15:14,240
between quantum and classical parties as

473
00:15:14,240 --> 00:15:15,600
i mentioned at the beginning of the talk

474
00:15:15,600 --> 00:15:17,199
right and so our protocols are going to

475
00:15:17,199 --> 00:15:17,920
be

476
00:15:17,920 --> 00:15:19,120
you know

477
00:15:19,120 --> 00:15:20,399
we're starting the notion of like

478
00:15:20,399 --> 00:15:22,639
militia security um although we're going

479
00:15:22,639 --> 00:15:23,519
to

480
00:15:23,519 --> 00:15:24,399
allow

481
00:15:24,399 --> 00:15:25,839
for you know

482
00:15:25,839 --> 00:15:28,240
execution in the crs model where you can

483
00:15:28,240 --> 00:15:31,360
have a a common random string setup

484
00:15:31,360 --> 00:15:33,040
and the functionalities that our

485
00:15:33,040 --> 00:15:35,040
protocols are going to support

486
00:15:35,040 --> 00:15:36,639
is what i call like pseudo-deterministic

487
00:15:36,639 --> 00:15:38,000
quantum functionalities okay so these

488
00:15:38,000 --> 00:15:39,279
are quantum functionalities that have

489
00:15:39,279 --> 00:15:41,440
classical inputs and outputs

490
00:15:41,440 --> 00:15:43,360
and that are like pseudo-deterministic

491
00:15:43,360 --> 00:15:45,199
in the sense that for each for each

492
00:15:45,199 --> 00:15:46,240
input

493
00:15:46,240 --> 00:15:47,040
um

494
00:15:47,040 --> 00:15:49,360
there's going to be one

495
00:15:49,360 --> 00:15:51,759
one output that's output by q except

496
00:15:51,759 --> 00:15:55,839
with negative probability okay

497
00:15:56,480 --> 00:15:57,440
and so

498
00:15:57,440 --> 00:15:59,519
like there's various settings that that

499
00:15:59,519 --> 00:16:01,199
we study so

500
00:16:01,199 --> 00:16:02,560
one setting is where we have multiple

501
00:16:02,560 --> 00:16:04,800
classical clients and one quantum server

502
00:16:04,800 --> 00:16:06,160
and you know they all want to interact

503
00:16:06,160 --> 00:16:07,440
and then all the clients want to output

504
00:16:07,440 --> 00:16:09,600
the result of the circuit and we give a

505
00:16:09,600 --> 00:16:13,040
six round protocol from qlwe and we can

506
00:16:13,040 --> 00:16:14,639
also give like a three round protocol

507
00:16:14,639 --> 00:16:16,959
basically like one round from

508
00:16:16,959 --> 00:16:18,959
clients to server one round from server

509
00:16:18,959 --> 00:16:20,320
to clients and then one round for kind

510
00:16:20,320 --> 00:16:22,639
of a joint decryption um in the in the

511
00:16:22,639 --> 00:16:24,480
qram okay

512
00:16:24,480 --> 00:16:26,800
and then we also study the notion of uh

513
00:16:26,800 --> 00:16:28,639
just this two-party setting with like

514
00:16:28,639 --> 00:16:30,240
one classical client one quantum server

515
00:16:30,240 --> 00:16:31,519
and we give basically what's called a

516
00:16:31,519 --> 00:16:32,800
nisk or a non-attractive secure

517
00:16:32,800 --> 00:16:35,440
computation protocol for the setting

518
00:16:35,440 --> 00:16:37,759
um again from lw and the qram so that

519
00:16:37,759 --> 00:16:39,199
just means basically a two message

520
00:16:39,199 --> 00:16:41,360
protocol so kind of a round optimal two

521
00:16:41,360 --> 00:16:43,600
message protocol for this setting

522
00:16:43,600 --> 00:16:45,920
okay

523
00:16:46,399 --> 00:16:48,160
um

524
00:16:48,160 --> 00:16:49,680
right and so for the remainder of the

525
00:16:49,680 --> 00:16:50,480
talk

526
00:16:50,480 --> 00:16:53,040
i'm just going to be focusing on this um

527
00:16:53,040 --> 00:16:55,759
composable blind cvtc protocol

528
00:16:55,759 --> 00:16:57,920
um and then yeah i would say if you want

529
00:16:57,920 --> 00:16:59,600
to see exactly how

530
00:16:59,600 --> 00:17:01,199
like this protocol is used to build

531
00:17:01,199 --> 00:17:02,880
these mpc applications i'll encourage

532
00:17:02,880 --> 00:17:04,959
you to see the paper for that

533
00:17:04,959 --> 00:17:06,720
okay

534
00:17:06,720 --> 00:17:08,799
and really what uh you know the starting

535
00:17:08,799 --> 00:17:10,319
point of this is is to notice that the

536
00:17:10,319 --> 00:17:11,119
issue

537
00:17:11,119 --> 00:17:12,640
with this previous approach that led to

538
00:17:12,640 --> 00:17:14,880
this kind of abort attack was the fact

539
00:17:14,880 --> 00:17:15,679
that

540
00:17:15,679 --> 00:17:18,880
in the blind cv qc protocol uh the the

541
00:17:18,880 --> 00:17:20,640
verifier when they received the previous

542
00:17:20,640 --> 00:17:22,959
message what they first did was decrypt

543
00:17:22,959 --> 00:17:25,359
and then they verified which means that

544
00:17:25,359 --> 00:17:27,119
like if you if you want to like fully

545
00:17:27,119 --> 00:17:30,400
verify the proof um and be

546
00:17:30,400 --> 00:17:31,760
sure that the proof is being honest you

547
00:17:31,760 --> 00:17:33,280
actually need the decryption key to do

548
00:17:33,280 --> 00:17:34,880
that because you first decrypt and then

549
00:17:34,880 --> 00:17:36,480
verify

550
00:17:36,480 --> 00:17:37,440
right

551
00:17:37,440 --> 00:17:38,799
um and this is

552
00:17:38,799 --> 00:17:40,160
you know what was preventing us from

553
00:17:40,160 --> 00:17:42,400
arguing that like this protocol um

554
00:17:42,400 --> 00:17:44,080
satisfies blindness in the stronger

555
00:17:44,080 --> 00:17:45,280
sense

556
00:17:45,280 --> 00:17:47,200
right so

557
00:17:47,200 --> 00:17:48,080
um

558
00:17:48,080 --> 00:17:49,919
a paradigm that's been useful

559
00:17:49,919 --> 00:17:51,520
uh for getting around this problem like

560
00:17:51,520 --> 00:17:52,880
in the classical setting that's been

561
00:17:52,880 --> 00:17:55,039
used before is you know can we switch

562
00:17:55,039 --> 00:17:57,600
can we first verify and then decrypt

563
00:17:57,600 --> 00:17:58,559
right

564
00:17:58,559 --> 00:18:00,720
um so in this way you wouldn't need the

565
00:18:00,720 --> 00:18:02,720
decryption key for verification and so

566
00:18:02,720 --> 00:18:04,960
like even if the prover can see whether

567
00:18:04,960 --> 00:18:06,720
uh the proof verified or not they might

568
00:18:06,720 --> 00:18:08,400
not be able to break blindness because

569
00:18:08,400 --> 00:18:10,960
the decryption key was not necessary for

570
00:18:10,960 --> 00:18:13,440
for showing verification right so this

571
00:18:13,440 --> 00:18:15,039
is the goal basically can we verify then

572
00:18:15,039 --> 00:18:17,200
decrypt in our setting that means can we

573
00:18:17,200 --> 00:18:20,640
actually use the cbqc protocol to first

574
00:18:20,640 --> 00:18:23,200
prove a correct evaluation of pfhe and

575
00:18:23,200 --> 00:18:26,000
then only after that decrypt the qfhe

576
00:18:26,000 --> 00:18:27,280
okay

577
00:18:27,280 --> 00:18:29,200
so unfortunately it's not actually this

578
00:18:29,200 --> 00:18:30,720
straightforward

579
00:18:30,720 --> 00:18:32,960
and the reason is that um this protocol

580
00:18:32,960 --> 00:18:35,520
of mahadev the cvqc protocol that we're

581
00:18:35,520 --> 00:18:37,200
using actually only supports

582
00:18:37,200 --> 00:18:39,600
pseudo-deterministic circuits q okay and

583
00:18:39,600 --> 00:18:41,039
i kind of explained informally what that

584
00:18:41,039 --> 00:18:43,679
was on the last slide but more formally

585
00:18:43,679 --> 00:18:45,840
q is pseudo-deterministic if for for all

586
00:18:45,840 --> 00:18:47,440
classical inputs x there exists a

587
00:18:47,440 --> 00:18:49,600
classical output y such that like q of x

588
00:18:49,600 --> 00:18:51,360
equals y except with a negligible

589
00:18:51,360 --> 00:18:54,320
probability okay

590
00:18:54,320 --> 00:18:55,679
and so we know how to do like you know

591
00:18:55,679 --> 00:18:58,400
mahadev showed how to do cbqc for such

592
00:18:58,400 --> 00:19:00,320
such uh functionalities

593
00:19:00,320 --> 00:19:01,280
um

594
00:19:01,280 --> 00:19:03,679
the issue is that if like the qfhe

595
00:19:03,679 --> 00:19:04,960
evaluation the thing that we actually

596
00:19:04,960 --> 00:19:07,039
want to apply this protocol to is not

597
00:19:07,039 --> 00:19:09,360
pseudo-deterministic okay

598
00:19:09,360 --> 00:19:11,600
and the reason is that

599
00:19:11,600 --> 00:19:12,400
well

600
00:19:12,400 --> 00:19:13,919
like what happens is that like if you

601
00:19:13,919 --> 00:19:16,160
take a ciphertext encrypting x and you

602
00:19:16,160 --> 00:19:18,000
evaluate it evaluate q on that

603
00:19:18,000 --> 00:19:19,360
ciphertext what you obtain is a

604
00:19:19,360 --> 00:19:21,200
distribution over output ciphertext

605
00:19:21,200 --> 00:19:22,880
encrypting q of x so even if q is

606
00:19:22,880 --> 00:19:25,679
deterministic this ciphertext is

607
00:19:25,679 --> 00:19:27,520
actually a distribution over the random

608
00:19:27,520 --> 00:19:28,880
coins r

609
00:19:28,880 --> 00:19:30,559
okay

610
00:19:30,559 --> 00:19:31,360
so

611
00:19:31,360 --> 00:19:32,960
you know this is this is why it doesn't

612
00:19:32,960 --> 00:19:34,720
like work you can't just like kind of

613
00:19:34,720 --> 00:19:36,400
switch switch these and just like plug

614
00:19:36,400 --> 00:19:37,919
in cv you it to prove the correct

615
00:19:37,919 --> 00:19:39,840
evaluation of qfhe because it doesn't

616
00:19:39,840 --> 00:19:42,320
work syntactically

617
00:19:42,320 --> 00:19:44,160
but

618
00:19:44,160 --> 00:19:46,000
we'll still try to follow this verify

619
00:19:46,000 --> 00:19:48,880
then decrypt paradigm and instead of

620
00:19:48,880 --> 00:19:51,039
directly using you know mahadev cvc

621
00:19:51,039 --> 00:19:52,559
protocol what we're going to do is we're

622
00:19:52,559 --> 00:19:53,760
going to use a

623
00:19:53,760 --> 00:19:56,320
a more recent protocol due to trungath

624
00:19:56,320 --> 00:19:57,919
cllw

625
00:19:57,919 --> 00:20:00,559
that can actually handle in some sense

626
00:20:00,559 --> 00:20:03,440
it can handle like

627
00:20:03,600 --> 00:20:05,280
verification for what's what are called

628
00:20:05,280 --> 00:20:07,120
quantum sampling circuits okay so this

629
00:20:07,120 --> 00:20:09,200
is the high level idea

630
00:20:09,200 --> 00:20:11,840
okay and again this is exactly our goal

631
00:20:11,840 --> 00:20:14,000
is to construct a blind cpc protocol

632
00:20:14,000 --> 00:20:15,760
following this verify then decrypt

633
00:20:15,760 --> 00:20:17,679
paradigm

634
00:20:17,679 --> 00:20:18,720
okay

635
00:20:18,720 --> 00:20:20,400
and before i actually explain like the

636
00:20:20,400 --> 00:20:22,240
steps for doing that let's just

637
00:20:22,240 --> 00:20:24,159
let's just like dive a little bit

638
00:20:24,159 --> 00:20:27,039
um farther into just like mahadev cvtc

639
00:20:27,039 --> 00:20:29,200
protocol okay

640
00:20:29,200 --> 00:20:30,480
and so really

641
00:20:30,480 --> 00:20:33,840
what her protocol is is a combination of

642
00:20:33,840 --> 00:20:36,640
of two sub protocols so one is this fh

643
00:20:36,640 --> 00:20:39,280
fhm delegation protocol and one is

644
00:20:39,280 --> 00:20:40,559
what's called the measurement protocol

645
00:20:40,559 --> 00:20:42,080
which is which which actually makes up

646
00:20:42,080 --> 00:20:43,520
the bulk of

647
00:20:43,520 --> 00:20:45,919
mahadev's work okay

648
00:20:45,919 --> 00:20:47,600
so

649
00:20:47,600 --> 00:20:49,520
this this underlying delegation protocol

650
00:20:49,520 --> 00:20:50,799
that's being used

651
00:20:50,799 --> 00:20:52,720
um considers

652
00:20:52,720 --> 00:20:54,880
um basically a quantum prover and a

653
00:20:54,880 --> 00:20:56,320
quantum verifier

654
00:20:56,320 --> 00:20:57,919
and it supports pseudo deterministic

655
00:20:57,919 --> 00:21:00,080
circuits q this is actually where the

656
00:21:00,080 --> 00:21:01,679
rich just the restriction to c to

657
00:21:01,679 --> 00:21:04,320
deterministic circuits is coming from

658
00:21:04,320 --> 00:21:05,520
um

659
00:21:05,520 --> 00:21:06,799
you know soundness is actually

660
00:21:06,799 --> 00:21:07,840
information theoretic there's no

661
00:21:07,840 --> 00:21:09,679
cryptographic assumptions um the

662
00:21:09,679 --> 00:21:11,679
drawback is that the verifier is quantum

663
00:21:11,679 --> 00:21:13,440
okay and so what happens is it's just a

664
00:21:13,440 --> 00:21:15,039
one message protocol the previous sends

665
00:21:15,039 --> 00:21:16,400
over a quantum state

666
00:21:16,400 --> 00:21:18,559
the verifier

667
00:21:18,559 --> 00:21:20,240
basically just immediately measures this

668
00:21:20,240 --> 00:21:23,200
state in a series a sequence of bases so

669
00:21:23,200 --> 00:21:25,600
either standard either standard hadamard

670
00:21:25,600 --> 00:21:27,440
bases and so this notation is basically

671
00:21:27,440 --> 00:21:30,240
meaning that like for an bit for an n

672
00:21:30,240 --> 00:21:34,159
qubit state psi and an n-bit string h

673
00:21:34,159 --> 00:21:36,480
you basically measure each qubit of psi

674
00:21:36,480 --> 00:21:37,280
in

675
00:21:37,280 --> 00:21:38,720
either the standard or the hadamard

676
00:21:38,720 --> 00:21:40,960
basis depending on whether the bit of h

677
00:21:40,960 --> 00:21:43,039
of i is equal to zero or one okay so

678
00:21:43,039 --> 00:21:44,799
basically the verifier just takes this

679
00:21:44,799 --> 00:21:46,400
the state immediately measures

680
00:21:46,400 --> 00:21:48,320
everything to get a string y-hat and

681
00:21:48,320 --> 00:21:49,520
then apply some classical

682
00:21:49,520 --> 00:21:51,280
post-processing on that to obtain the

683
00:21:51,280 --> 00:21:52,480
output y

684
00:21:52,480 --> 00:21:53,440
okay

685
00:21:53,440 --> 00:21:55,600
and so this is kind of the delegation

686
00:21:55,600 --> 00:21:57,760
protocol that we're starting with

687
00:21:57,760 --> 00:21:59,919
what armilla showed how to do is how to

688
00:21:59,919 --> 00:22:00,750
take um

689
00:22:00,750 --> 00:22:02,159
[Music]

690
00:22:02,159 --> 00:22:04,559
such a protocol and basically outsource

691
00:22:04,559 --> 00:22:06,159
this measurement part of it to the

692
00:22:06,159 --> 00:22:07,280
prover

693
00:22:07,280 --> 00:22:08,880
in the end turning the verifier

694
00:22:08,880 --> 00:22:10,480
completely classical

695
00:22:10,480 --> 00:22:11,600
right

696
00:22:11,600 --> 00:22:12,480
so

697
00:22:12,480 --> 00:22:14,640
you know the a measurement protocol what

698
00:22:14,640 --> 00:22:16,080
it does is it allows a classical

699
00:22:16,080 --> 00:22:17,840
verifier to delegate standard and

700
00:22:17,840 --> 00:22:19,520
hadamard basis measurements to a quantum

701
00:22:19,520 --> 00:22:21,760
improver right so you know now the

702
00:22:21,760 --> 00:22:23,760
verifier has as input it's

703
00:22:23,760 --> 00:22:25,440
it's measurement basis h the previewer

704
00:22:25,440 --> 00:22:27,440
has as input a

705
00:22:27,440 --> 00:22:29,280
quantum state psi and at the end of the

706
00:22:29,280 --> 00:22:31,600
protocol the verifier outputs the result

707
00:22:31,600 --> 00:22:33,600
of measuring psi and h

708
00:22:33,600 --> 00:22:35,918
okay

709
00:22:36,559 --> 00:22:38,799
and so let's you know let's

710
00:22:38,799 --> 00:22:41,600
kind of review the issue with

711
00:22:41,600 --> 00:22:43,200
um

712
00:22:43,200 --> 00:22:44,720
you know this this final protocol is

713
00:22:44,720 --> 00:22:46,320
that this underlying fhm delegation

714
00:22:46,320 --> 00:22:47,520
actually only supports

715
00:22:47,520 --> 00:22:50,640
pseudo-deterministic circuits okay

716
00:22:50,640 --> 00:22:52,880
now i did mention there's kind of a

717
00:22:52,880 --> 00:22:55,760
newer work of cllw what they do

718
00:22:55,760 --> 00:22:57,120
is they

719
00:22:57,120 --> 00:22:58,640
what one of the things that that they do

720
00:22:58,640 --> 00:23:00,960
is they construct a underlying protocol

721
00:23:00,960 --> 00:23:02,640
here that has a couple different

722
00:23:02,640 --> 00:23:04,400
properties it actually supports sampling

723
00:23:04,400 --> 00:23:05,840
circuits q

724
00:23:05,840 --> 00:23:07,679
which are you know quantum circuits the

725
00:23:07,679 --> 00:23:09,440
output some arbitrary distribution over

726
00:23:09,440 --> 00:23:11,760
classical outputs okay

727
00:23:11,760 --> 00:23:13,600
um so that's good because like that in

728
00:23:13,600 --> 00:23:16,240
particular captures qfhe evaluation

729
00:23:16,240 --> 00:23:19,280
but unfortunately um the soundness it's

730
00:23:19,280 --> 00:23:21,200
still information theoretic but it is

731
00:23:21,200 --> 00:23:23,200
relaxed to an inverse polynomial sounds

732
00:23:23,200 --> 00:23:24,720
it's not standard negligible soundness

733
00:23:24,720 --> 00:23:26,559
anymore okay

734
00:23:26,559 --> 00:23:27,440
so

735
00:23:27,440 --> 00:23:30,559
again this is you know um the idea is

736
00:23:30,559 --> 00:23:32,080
still to basically take their protocol

737
00:23:32,080 --> 00:23:33,039
and combine it with the measurement

738
00:23:33,039 --> 00:23:34,080
protocol but we're gonna have to be

739
00:23:34,080 --> 00:23:36,400
careful and try to

740
00:23:36,400 --> 00:23:37,919
you know our eventual goal is to get the

741
00:23:37,919 --> 00:23:40,960
standard notion of of delegation and mpc

742
00:23:40,960 --> 00:23:43,279
with negligibles on this okay

743
00:23:43,279 --> 00:23:44,159
so

744
00:23:44,159 --> 00:23:46,240
um this construction basically proceeds

745
00:23:46,240 --> 00:23:47,520
in three steps

746
00:23:47,520 --> 00:23:51,279
okay so we start with the cllw protocol

747
00:23:51,279 --> 00:23:52,240
okay

748
00:23:52,240 --> 00:23:53,679
and we note that

749
00:23:53,679 --> 00:23:55,360
so in general it only has inverse

750
00:23:55,360 --> 00:23:57,600
polynomial sound as error but if we

751
00:23:57,600 --> 00:23:58,880
apply it to the special case of

752
00:23:58,880 --> 00:24:01,600
verifying a qfhe evaluation

753
00:24:01,600 --> 00:24:04,880
of an underlying pseudo-stated circuit

754
00:24:04,880 --> 00:24:06,559
then actually we can obtain a negatively

755
00:24:06,559 --> 00:24:08,000
sound protocol

756
00:24:08,000 --> 00:24:10,080
by basically parallel repeating it

757
00:24:10,080 --> 00:24:12,159
okay and of course the resulting

758
00:24:12,159 --> 00:24:14,960
protocol still has a quantum verifier

759
00:24:14,960 --> 00:24:16,640
but our second step is then to combine

760
00:24:16,640 --> 00:24:18,799
this with you know mahadev's measurement

761
00:24:18,799 --> 00:24:20,400
protocol to obtain a protocol with the

762
00:24:20,400 --> 00:24:21,919
classical verifier

763
00:24:21,919 --> 00:24:23,360
and right away this only gives like a

764
00:24:23,360 --> 00:24:25,520
one-half sound protocol because of

765
00:24:25,520 --> 00:24:27,120
structure of this measurement protocol

766
00:24:27,120 --> 00:24:29,120
we have to parallel repeat that again

767
00:24:29,120 --> 00:24:30,720
to finally obtain a negative like

768
00:24:30,720 --> 00:24:31,760
finally what we want which is a

769
00:24:31,760 --> 00:24:33,520
negatively sound protocol with classical

770
00:24:33,520 --> 00:24:36,720
verifier okay

771
00:24:39,520 --> 00:24:40,880
right so i'll go like through each of

772
00:24:40,880 --> 00:24:44,159
these steps in a little bit more detail

773
00:24:44,559 --> 00:24:45,679
so first

774
00:24:45,679 --> 00:24:48,799
what we want is a you know

775
00:24:48,799 --> 00:24:50,799
a protocol with negligible soundness and

776
00:24:50,799 --> 00:24:53,760
a quantum verifier so

777
00:24:53,760 --> 00:24:54,960
you know what we're going to do is we're

778
00:24:54,960 --> 00:24:56,000
going to have

779
00:24:56,000 --> 00:24:58,320
the verifier you know take the input x

780
00:24:58,320 --> 00:25:00,240
first encrypt it under qfhe and send it

781
00:25:00,240 --> 00:25:03,120
over and here's where the cllw comes in

782
00:25:03,120 --> 00:25:05,279
what we're going to have the prover do

783
00:25:05,279 --> 00:25:06,799
is you know

784
00:25:06,799 --> 00:25:11,360
basically run the cllw approver

785
00:25:12,000 --> 00:25:13,520
you know to prove

786
00:25:13,520 --> 00:25:16,480
you know to evaluate um the cipher text

787
00:25:16,480 --> 00:25:19,520
to basically an encryption of q of x and

788
00:25:19,520 --> 00:25:21,840
send over a quantum state basically

789
00:25:21,840 --> 00:25:23,360
proving that this evaluation was done

790
00:25:23,360 --> 00:25:25,360
correctly and so the verifier can run

791
00:25:25,360 --> 00:25:27,600
the cllw verifier

792
00:25:27,600 --> 00:25:29,679
to obtain a correctly distributed

793
00:25:29,679 --> 00:25:31,279
ciphertext

794
00:25:31,279 --> 00:25:32,159
right

795
00:25:32,159 --> 00:25:35,520
you know up to some error

796
00:25:35,760 --> 00:25:38,799
you know and the cllw soundness error we

797
00:25:38,799 --> 00:25:40,240
can set to any parameter but it has to

798
00:25:40,240 --> 00:25:41,760
be inverse polynomial so let's just say

799
00:25:41,760 --> 00:25:43,520
we set it to one fourth

800
00:25:43,520 --> 00:25:44,799
you know what this guarantees is that

801
00:25:44,799 --> 00:25:46,720
the ciphertext output by the verifier is

802
00:25:46,720 --> 00:25:48,400
distributed

803
00:25:48,400 --> 00:25:50,480
kind of let's say let's say within one

804
00:25:50,480 --> 00:25:52,240
fourth statistical distance of what it

805
00:25:52,240 --> 00:25:53,840
should be which is an encryption of q of

806
00:25:53,840 --> 00:25:55,760
x so what that means is that when the

807
00:25:55,760 --> 00:25:57,360
verifier then goes and decrypts that

808
00:25:57,360 --> 00:25:59,600
cipher text we're guaranteed that they

809
00:25:59,600 --> 00:26:01,120
decrypt it to the correct value with

810
00:26:01,120 --> 00:26:03,520
probability at least three quarters

811
00:26:03,520 --> 00:26:04,880
okay

812
00:26:04,880 --> 00:26:05,600
so

813
00:26:05,600 --> 00:26:07,039
this is where the parallel repetition

814
00:26:07,039 --> 00:26:08,799
comes in right we have like a three

815
00:26:08,799 --> 00:26:11,039
quarter sound protocol all we can do is

816
00:26:11,039 --> 00:26:13,520
just parallel repeat the cllw protocol

817
00:26:13,520 --> 00:26:14,799
lambda times

818
00:26:14,799 --> 00:26:17,120
now the verifier obtains lambda

819
00:26:17,120 --> 00:26:18,559
different cipher text they do crypt all

820
00:26:18,559 --> 00:26:20,240
lambda cipher text to get a bunch of

821
00:26:20,240 --> 00:26:22,159
like values of y i

822
00:26:22,159 --> 00:26:23,600
and a natural thing to do is just to

823
00:26:23,600 --> 00:26:25,919
have them you know take the majority out

824
00:26:25,919 --> 00:26:28,000
of the y eyes that they decrypt so just

825
00:26:28,000 --> 00:26:29,520
like whichever is the most frequently

826
00:26:29,520 --> 00:26:31,200
occurring y in the set they say that

827
00:26:31,200 --> 00:26:33,200
that's the output and you can show that

828
00:26:33,200 --> 00:26:35,760
basically essentially by turn off it

829
00:26:35,760 --> 00:26:37,120
follows that like the probability that

830
00:26:37,120 --> 00:26:38,720
this output y is equal to the correct

831
00:26:38,720 --> 00:26:42,400
answer is is um overwhelming

832
00:26:42,400 --> 00:26:43,200
um

833
00:26:43,200 --> 00:26:44,720
and i say turn off star because you need

834
00:26:44,720 --> 00:26:45,919
like a little bit

835
00:26:45,919 --> 00:26:46,880
like

836
00:26:46,880 --> 00:26:50,159
um not everything is independent like

837
00:26:50,159 --> 00:26:52,080
um because like for example the prover

838
00:26:52,080 --> 00:26:54,000
could be entangling these states um but

839
00:26:54,000 --> 00:26:55,520
kind of like basically a very similar

840
00:26:55,520 --> 00:26:57,360
argument to just like standard qma

841
00:26:57,360 --> 00:26:58,640
amplification shows that you can

842
00:26:58,640 --> 00:27:01,120
actually get this um turn off

843
00:27:01,120 --> 00:27:03,039
like argument to work

844
00:27:03,039 --> 00:27:04,640
okay and so importantly what we've

845
00:27:04,640 --> 00:27:05,760
constructed

846
00:27:05,760 --> 00:27:07,440
it has a couple important properties

847
00:27:07,440 --> 00:27:09,760
first the verifier like first verifies

848
00:27:09,760 --> 00:27:11,840
right and only once it's convinced that

849
00:27:11,840 --> 00:27:13,440
like you know all these you know all

850
00:27:13,440 --> 00:27:15,520
these cllw sub protocols accept then

851
00:27:15,520 --> 00:27:17,600
they just decrypt okay

852
00:27:17,600 --> 00:27:19,440
so there's no mixture of these steps and

853
00:27:19,440 --> 00:27:20,799
in the end they obtain we obtain a

854
00:27:20,799 --> 00:27:23,840
negatively sound protocol okay

855
00:27:23,840 --> 00:27:25,200
so

856
00:27:25,200 --> 00:27:26,480
if you're called the next step is to

857
00:27:26,480 --> 00:27:28,799
basically make this verifier classical

858
00:27:28,799 --> 00:27:32,159
so let's look at this verify procedure

859
00:27:32,159 --> 00:27:34,559
recall that um

860
00:27:34,559 --> 00:27:36,399
you know due to the structure of the

861
00:27:36,399 --> 00:27:39,120
cllw protocol all this is is all the

862
00:27:39,120 --> 00:27:40,799
verifier does is they first like

863
00:27:40,799 --> 00:27:42,480
immediately measure all the provers

864
00:27:42,480 --> 00:27:44,559
states and some bases h and then they

865
00:27:44,559 --> 00:27:46,480
apply classical post-processing circuits

866
00:27:46,480 --> 00:27:49,039
the results to produce the ciphertext so

867
00:27:49,039 --> 00:27:50,880
this is like the part where you know

868
00:27:50,880 --> 00:27:52,480
we're going to outsource to the prover

869
00:27:52,480 --> 00:27:53,840
using um

870
00:27:53,840 --> 00:27:56,159
uh mahadev's measurement protocol

871
00:27:56,159 --> 00:27:57,760
and syntactically what this looks like

872
00:27:57,760 --> 00:28:00,799
then is that

873
00:28:00,799 --> 00:28:02,559
like mahadas protocol is basically this

874
00:28:02,559 --> 00:28:04,080
forum message like commit challenge

875
00:28:04,080 --> 00:28:06,799
response type of protocol okay

876
00:28:06,799 --> 00:28:08,799
where here so here of course the

877
00:28:08,799 --> 00:28:10,480
verifier sends the encryption of x like

878
00:28:10,480 --> 00:28:12,559
before but then they engage with the

879
00:28:12,559 --> 00:28:14,000
prover in this kind of form message

880
00:28:14,000 --> 00:28:15,919
protocol which at the end of which the

881
00:28:15,919 --> 00:28:17,760
verify either like if their challenge

882
00:28:17,760 --> 00:28:19,840
was zero either just accepts or rejects

883
00:28:19,840 --> 00:28:21,919
or if their challenge was one um

884
00:28:21,919 --> 00:28:23,919
actually goes and obtains like an output

885
00:28:23,919 --> 00:28:25,520
ciphertext which they can then pass to

886
00:28:25,520 --> 00:28:28,480
the decrypt procedure okay

887
00:28:28,480 --> 00:28:29,919
so i'm not really going to go into more

888
00:28:29,919 --> 00:28:31,360
details about how this measurement

889
00:28:31,360 --> 00:28:32,720
protocol works

890
00:28:32,720 --> 00:28:34,080
but this is kind of syntactically what

891
00:28:34,080 --> 00:28:35,120
you get

892
00:28:35,120 --> 00:28:36,399
okay

893
00:28:36,399 --> 00:28:37,919
and because this challenge is only one

894
00:28:37,919 --> 00:28:39,039
bit long

895
00:28:39,039 --> 00:28:41,200
you actually write it like

896
00:28:41,200 --> 00:28:43,360
right now we actually only end up with a

897
00:28:43,360 --> 00:28:46,320
one half sounds protocol okay

898
00:28:46,320 --> 00:28:48,080
so the final step is to boost this

899
00:28:48,080 --> 00:28:49,919
one-half sound protocol to a negatively

900
00:28:49,919 --> 00:28:51,600
sound protocol and again we're going to

901
00:28:51,600 --> 00:28:54,480
do this with parallel repetition okay

902
00:28:54,480 --> 00:28:56,559
and again naturally you know what we're

903
00:28:56,559 --> 00:28:57,360
going to do is we're just going to

904
00:28:57,360 --> 00:28:59,039
repeat this measurement protocol in

905
00:28:59,039 --> 00:29:01,120
parallel lambda times

906
00:29:01,120 --> 00:29:02,320
okay

907
00:29:02,320 --> 00:29:03,679
and so

908
00:29:03,679 --> 00:29:04,960
you know what happens when we repeat it

909
00:29:04,960 --> 00:29:06,320
lambda times how do we define the

910
00:29:06,320 --> 00:29:08,799
verifier well

911
00:29:08,799 --> 00:29:10,720
so you look at all these challenges you

912
00:29:10,720 --> 00:29:13,039
know some of them are zero

913
00:29:13,039 --> 00:29:15,360
if any of the sub protocols were set if

914
00:29:15,360 --> 00:29:18,080
any of the sub protocols um reject on a

915
00:29:18,080 --> 00:29:19,840
zero challenge we just the verifier just

916
00:29:19,840 --> 00:29:22,559
rejects um you know otherwise the

917
00:29:22,559 --> 00:29:24,240
verifier collects all the outputs on

918
00:29:24,240 --> 00:29:26,480
like the one sub-protocols

919
00:29:26,480 --> 00:29:29,039
passes them to the decrypt procedure and

920
00:29:29,039 --> 00:29:32,159
still take a majority of those okay

921
00:29:32,159 --> 00:29:34,080
so again we still maintain this this

922
00:29:34,080 --> 00:29:35,520
crucial structure that there's first

923
00:29:35,520 --> 00:29:37,360
this verification procedure which like

924
00:29:37,360 --> 00:29:40,480
doesn't use the fhe secret key at all it

925
00:29:40,480 --> 00:29:43,200
just like basically uses the underlying

926
00:29:43,200 --> 00:29:45,600
measurement protocol right

927
00:29:45,600 --> 00:29:47,360
it just basically either rejects or

928
00:29:47,360 --> 00:29:49,679
accepts and passes along the ciphertext

929
00:29:49,679 --> 00:29:51,679
and at this point the ver there's no the

930
00:29:51,679 --> 00:29:53,440
verifier no longer has an option to

931
00:29:53,440 --> 00:29:55,200
abort it just simply decrypts and then

932
00:29:55,200 --> 00:29:57,360
outputs the most frequently occurring y

933
00:29:57,360 --> 00:29:59,360
in its set of decryptions

934
00:29:59,360 --> 00:30:01,120
okay

935
00:30:01,120 --> 00:30:03,279
all right so

936
00:30:03,279 --> 00:30:05,279
it basically remains to show that this

937
00:30:05,279 --> 00:30:07,039
parallel repeated protocol is indeed

938
00:30:07,039 --> 00:30:08,720
negligibly sound

939
00:30:08,720 --> 00:30:09,840
okay

940
00:30:09,840 --> 00:30:10,720
and

941
00:30:10,720 --> 00:30:13,279
there is some prior work on showing that

942
00:30:13,279 --> 00:30:14,799
the parallel repetition of these sorts

943
00:30:14,799 --> 00:30:16,480
of protocols is sound

944
00:30:16,480 --> 00:30:18,559
okay and one such work is

945
00:30:18,559 --> 00:30:21,279
is this work of acgh and they gave

946
00:30:21,279 --> 00:30:22,720
basically the following parallel

947
00:30:22,720 --> 00:30:25,039
repetition parallel repetition theorem

948
00:30:25,039 --> 00:30:26,399
okay

949
00:30:26,399 --> 00:30:27,919
they said okay

950
00:30:27,919 --> 00:30:30,240
let's say that your under your single

951
00:30:30,240 --> 00:30:31,840
repetition protocol like over here

952
00:30:31,840 --> 00:30:34,000
satisfies the following property

953
00:30:34,000 --> 00:30:36,559
so the property that

954
00:30:36,559 --> 00:30:39,120
for any you know malicious but efficient

955
00:30:39,120 --> 00:30:40,880
improver p star

956
00:30:40,880 --> 00:30:43,440
if it's the case that they are

957
00:30:43,440 --> 00:30:45,520
almost always accepted

958
00:30:45,520 --> 00:30:48,240
on like a zero round so if you know if

959
00:30:48,240 --> 00:30:49,600
they're almost always accepted when the

960
00:30:49,600 --> 00:30:51,039
challenge is zero

961
00:30:51,039 --> 00:30:51,919
then

962
00:30:51,919 --> 00:30:53,919
uh the probability that they can cause a

963
00:30:53,919 --> 00:30:56,240
false outcome

964
00:30:56,240 --> 00:30:57,519
when the challenge is equal to one is

965
00:30:57,519 --> 00:30:58,799
negligible

966
00:30:58,799 --> 00:31:00,159
okay so it's kind of like if they're

967
00:31:00,159 --> 00:31:02,320
like passing one of these challenges

968
00:31:02,320 --> 00:31:05,360
then they're like um

969
00:31:05,360 --> 00:31:06,799
if they're passing like the zero

970
00:31:06,799 --> 00:31:08,159
challenge with overwhelming probability

971
00:31:08,159 --> 00:31:09,600
then they only have a negative chance of

972
00:31:09,600 --> 00:31:11,120
cheating into one challenge so they're

973
00:31:11,120 --> 00:31:12,559
saying okay let's assume your underlying

974
00:31:12,559 --> 00:31:14,720
protocol satisfies this property

975
00:31:14,720 --> 00:31:15,679
then

976
00:31:15,679 --> 00:31:17,440
in your parallel your parallel repeated

977
00:31:17,440 --> 00:31:20,000
protocol satisfies this property namely

978
00:31:20,000 --> 00:31:21,440
that

979
00:31:21,440 --> 00:31:23,600
you know again for any efficient but

980
00:31:23,600 --> 00:31:25,760
malicious approver

981
00:31:25,760 --> 00:31:27,519
it holds that the probability that the

982
00:31:27,519 --> 00:31:29,919
previous simultaneously accepted on all

983
00:31:29,919 --> 00:31:31,679
zero challenges

984
00:31:31,679 --> 00:31:33,840
and can cheat on all of the one

985
00:31:33,840 --> 00:31:35,760
challenges is negligible

986
00:31:35,760 --> 00:31:37,440
okay so they show that this is this is

987
00:31:37,440 --> 00:31:38,880
going to hold

988
00:31:38,880 --> 00:31:40,080
okay

989
00:31:40,080 --> 00:31:41,919
and so this is actually good enough for

990
00:31:41,919 --> 00:31:43,760
like just basically parallel repeating

991
00:31:43,760 --> 00:31:45,840
like uh

992
00:31:45,840 --> 00:31:47,679
cbqc

993
00:31:47,679 --> 00:31:48,880
but it turns out this is actually not

994
00:31:48,880 --> 00:31:50,720
good enough for our setting and so why

995
00:31:50,720 --> 00:31:52,399
is that

996
00:31:52,399 --> 00:31:53,760
note that in this parallel repeated

997
00:31:53,760 --> 00:31:56,559
protocol if the previous sheets on half

998
00:31:56,559 --> 00:31:58,159
of these one

999
00:31:58,159 --> 00:32:00,080
instances

1000
00:32:00,080 --> 00:32:01,760
then i can make the verifier accept a

1001
00:32:01,760 --> 00:32:03,360
false outcome right all it has to do is

1002
00:32:03,360 --> 00:32:04,399
like change

1003
00:32:04,399 --> 00:32:06,320
more than half of these yi's to be some

1004
00:32:06,320 --> 00:32:08,480
other zi and then the verifier will

1005
00:32:08,480 --> 00:32:12,399
output like a wrong around z right

1006
00:32:12,399 --> 00:32:14,880
so actually what we really want to say

1007
00:32:14,880 --> 00:32:16,640
is that we want the stronger property

1008
00:32:16,640 --> 00:32:17,600
that

1009
00:32:17,600 --> 00:32:20,159
um you know for any efficient p star it

1010
00:32:20,159 --> 00:32:21,840
holds that they're simultaneously

1011
00:32:21,840 --> 00:32:24,080
accepted on all zero rounds

1012
00:32:24,080 --> 00:32:24,960
and

1013
00:32:24,960 --> 00:32:26,559
can cheat on

1014
00:32:26,559 --> 00:32:29,120
like even half of the one rounds still

1015
00:32:29,120 --> 00:32:30,480
with negligible probabilities so this is

1016
00:32:30,480 --> 00:32:32,399
kind of a stronger parallel repetition

1017
00:32:32,399 --> 00:32:34,000
theorem that we want which is what we

1018
00:32:34,000 --> 00:32:35,600
show in this work

1019
00:32:35,600 --> 00:32:37,279
okay and this is then enough to show the

1020
00:32:37,279 --> 00:32:40,080
soundness of this this protocol

1021
00:32:40,080 --> 00:32:41,200
and so

1022
00:32:41,200 --> 00:32:43,840
i can give like a slightly closer uh

1023
00:32:43,840 --> 00:32:47,279
look at this parallel repetition theorem

1024
00:32:47,279 --> 00:32:48,240
so

1025
00:32:48,240 --> 00:32:49,760
you know abstractly what we're looking

1026
00:32:49,760 --> 00:32:51,440
at is is the following situation it's

1027
00:32:51,440 --> 00:32:53,279
kind of like a quantum prover sigma

1028
00:32:53,279 --> 00:32:54,960
protocol with classical communication

1029
00:32:54,960 --> 00:32:56,880
okay so we have a commit

1030
00:32:56,880 --> 00:32:58,480
phase like a one bit challenge and then

1031
00:32:58,480 --> 00:33:00,480
a response and this prover you know

1032
00:33:00,480 --> 00:33:01,760
we're this is all classical

1033
00:33:01,760 --> 00:33:03,039
communication but we're allowing like a

1034
00:33:03,039 --> 00:33:05,279
malicious proverb to be quantum

1035
00:33:05,279 --> 00:33:06,399
okay

1036
00:33:06,399 --> 00:33:08,480
and we can set up some notation so

1037
00:33:08,480 --> 00:33:10,080
basically the state of the prover after

1038
00:33:10,080 --> 00:33:13,440
this commit phase we'll call psi sub p

1039
00:33:13,440 --> 00:33:14,640
and then we can associate with this

1040
00:33:14,640 --> 00:33:16,720
verifier two projections that would be

1041
00:33:16,720 --> 00:33:19,039
applied to size of p which is basically

1042
00:33:19,039 --> 00:33:21,679
like pi zero is the projection that

1043
00:33:21,679 --> 00:33:24,799
projection onto the space

1044
00:33:24,799 --> 00:33:26,159
where the verifier accepts when the

1045
00:33:26,159 --> 00:33:27,840
challenge is zero pi one is a projection

1046
00:33:27,840 --> 00:33:29,279
onto this onto the space where the

1047
00:33:29,279 --> 00:33:30,720
verifier accepts when the challenge is

1048
00:33:30,720 --> 00:33:31,760
one

1049
00:33:31,760 --> 00:33:32,799
okay

1050
00:33:32,799 --> 00:33:33,600
so

1051
00:33:33,600 --> 00:33:36,480
what acgh did was they basically

1052
00:33:36,480 --> 00:33:38,559
you know a rephrasing of of kind of the

1053
00:33:38,559 --> 00:33:39,840
property of the single repetition

1054
00:33:39,840 --> 00:33:41,360
protocol that i had in the last slide is

1055
00:33:41,360 --> 00:33:42,640
the following

1056
00:33:42,640 --> 00:33:43,679
and it's called what they call a

1057
00:33:43,679 --> 00:33:45,440
computational orthogonal projector

1058
00:33:45,440 --> 00:33:46,480
property

1059
00:33:46,480 --> 00:33:48,640
it's if for any efficient p

1060
00:33:48,640 --> 00:33:51,679
the you know the expectation of this um

1061
00:33:51,679 --> 00:33:53,679
expression is negligible right so

1062
00:33:53,679 --> 00:33:56,320
basically that like this prover state

1063
00:33:56,320 --> 00:33:59,279
cannot essentially satisfy both of these

1064
00:33:59,279 --> 00:34:02,880
projections pi one and pi zero okay

1065
00:34:02,880 --> 00:34:04,799
and so this is in particular this this

1066
00:34:04,799 --> 00:34:06,480
property implies that the protocol it's

1067
00:34:06,480 --> 00:34:08,159
like stronger than saying it's just one

1068
00:34:08,159 --> 00:34:09,520
half soundness it's kind of an extra

1069
00:34:09,520 --> 00:34:11,599
structural property on on the security

1070
00:34:11,599 --> 00:34:13,199
of this protocol but in particular it

1071
00:34:13,199 --> 00:34:14,719
does imply that the protocols won't have

1072
00:34:14,719 --> 00:34:16,800
sound

1073
00:34:16,800 --> 00:34:19,199
and so what they show is that okay let's

1074
00:34:19,199 --> 00:34:20,800
parallel repeat this protocol lambda

1075
00:34:20,800 --> 00:34:23,440
times so let's sample the challenge um

1076
00:34:23,440 --> 00:34:25,040
you know randomly from the space of all

1077
00:34:25,040 --> 00:34:26,719
lambda bit strings

1078
00:34:26,719 --> 00:34:29,679
then what you can define is a different

1079
00:34:29,679 --> 00:34:32,079
acceptance projector for each challenge

1080
00:34:32,079 --> 00:34:33,359
okay so now there's like two to the

1081
00:34:33,359 --> 00:34:35,839
lambda of these acceptance projectors um

1082
00:34:35,839 --> 00:34:37,199
which are basically

1083
00:34:37,199 --> 00:34:39,520
um formed by tensoring like all the

1084
00:34:39,520 --> 00:34:42,800
accepting projectors of uh you know

1085
00:34:42,800 --> 00:34:43,918
for each of the

1086
00:34:43,918 --> 00:34:44,800
single

1087
00:34:44,800 --> 00:34:46,079
um

1088
00:34:46,079 --> 00:34:48,000
each of the underlying single repetition

1089
00:34:48,000 --> 00:34:49,839
single instances right

1090
00:34:49,839 --> 00:34:52,239
and so okay what they proved is actually

1091
00:34:52,239 --> 00:34:54,639
that you know if the single repetition

1092
00:34:54,639 --> 00:34:56,480
protocol has computational orthogonal

1093
00:34:56,480 --> 00:34:59,359
projectors then all two lambda of these

1094
00:34:59,359 --> 00:35:01,119
projectors defined here are all kind of

1095
00:35:01,119 --> 00:35:03,520
mutually computational orthogonal

1096
00:35:03,520 --> 00:35:04,320
okay

1097
00:35:04,320 --> 00:35:06,320
and you can use that to to prove that

1098
00:35:06,320 --> 00:35:07,839
the parallel repeated protocol is

1099
00:35:07,839 --> 00:35:10,240
negligibly sound

1100
00:35:10,240 --> 00:35:11,280
it's not really important to follow

1101
00:35:11,280 --> 00:35:13,200
these details but basically

1102
00:35:13,200 --> 00:35:14,240
what you

1103
00:35:14,240 --> 00:35:15,599
are proving is that basically the

1104
00:35:15,599 --> 00:35:17,599
expected value

1105
00:35:17,599 --> 00:35:19,440
of you know

1106
00:35:19,440 --> 00:35:22,720
of like basically the

1107
00:35:22,720 --> 00:35:24,720
um this expression

1108
00:35:24,720 --> 00:35:26,000
basically

1109
00:35:26,000 --> 00:35:27,520
which represents like the prover

1110
00:35:27,520 --> 00:35:29,599
accepting on challenge like

1111
00:35:29,599 --> 00:35:31,839
ch right so the expected value over a

1112
00:35:31,839 --> 00:35:33,040
random choice of the challenge you want

1113
00:35:33,040 --> 00:35:34,880
to show is negligible which you can

1114
00:35:34,880 --> 00:35:36,800
basically write out this expression

1115
00:35:36,800 --> 00:35:38,560
um kind of square it and write out all

1116
00:35:38,560 --> 00:35:41,920
all the terms and what you use is

1117
00:35:41,920 --> 00:35:43,440
like crucially what you use is the fact

1118
00:35:43,440 --> 00:35:45,040
that each of these cross terms is

1119
00:35:45,040 --> 00:35:47,040
negligible due to the computational

1120
00:35:47,040 --> 00:35:48,960
orthogonal projector property of the

1121
00:35:48,960 --> 00:35:51,440
underlying protocol okay so this is what

1122
00:35:51,440 --> 00:35:53,599
acgh showed

1123
00:35:53,599 --> 00:35:55,359
so in our setting

1124
00:35:55,359 --> 00:35:56,800
you know we would like to do the same

1125
00:35:56,800 --> 00:35:58,880
thing the crucial difference in our

1126
00:35:58,880 --> 00:36:00,480
setting is that

1127
00:36:00,480 --> 00:36:02,000
we have to define these acceptance

1128
00:36:02,000 --> 00:36:03,680
projectors for the parallel repeated

1129
00:36:03,680 --> 00:36:05,440
protocol slightly differently

1130
00:36:05,440 --> 00:36:06,800
okay

1131
00:36:06,800 --> 00:36:10,000
we can't just like tensor the individual

1132
00:36:10,000 --> 00:36:11,520
projectors together because we have a

1133
00:36:11,520 --> 00:36:14,079
different accepting um condition you

1134
00:36:14,079 --> 00:36:16,880
know the verifier accepts actually

1135
00:36:16,880 --> 00:36:18,480
if you know

1136
00:36:18,480 --> 00:36:20,800
um

1137
00:36:21,040 --> 00:36:24,079
you know if all of the challenge zero

1138
00:36:24,079 --> 00:36:26,560
projectors accept and at least half of

1139
00:36:26,560 --> 00:36:28,320
the challenge equals one

1140
00:36:28,320 --> 00:36:30,720
projectors except okay and so what this

1141
00:36:30,720 --> 00:36:32,960
means is that we no longer have

1142
00:36:32,960 --> 00:36:35,680
the um guarantee that all of these like

1143
00:36:35,680 --> 00:36:37,200
pi challenges are all mutually

1144
00:36:37,200 --> 00:36:39,280
computational orthogonal okay in

1145
00:36:39,280 --> 00:36:41,440
particular the prover can kind of pass

1146
00:36:41,440 --> 00:36:42,800
two different like projectors

1147
00:36:42,800 --> 00:36:44,160
corresponding to different challenges if

1148
00:36:44,160 --> 00:36:45,520
the challenges are kind of close enough

1149
00:36:45,520 --> 00:36:47,119
and hamming distance

1150
00:36:47,119 --> 00:36:48,880
so to very like at a high level

1151
00:36:48,880 --> 00:36:50,320
basically what we end up doing is we set

1152
00:36:50,320 --> 00:36:52,160
parameters actually we change a little

1153
00:36:52,160 --> 00:36:54,800
bit how this challenge is

1154
00:36:54,800 --> 00:36:57,119
distributed

1155
00:36:57,119 --> 00:37:00,640
and we set parameters basically

1156
00:37:00,800 --> 00:37:01,839
so that

1157
00:37:01,839 --> 00:37:03,680
it's not that all of the

1158
00:37:03,680 --> 00:37:04,880
um

1159
00:37:04,880 --> 00:37:06,640
all of these projectors are mutually

1160
00:37:06,640 --> 00:37:08,800
computational orthogonal but it's it

1161
00:37:08,800 --> 00:37:10,000
still holds that an overwhelming

1162
00:37:10,000 --> 00:37:11,520
fraction of them are and that's still

1163
00:37:11,520 --> 00:37:13,040
good enough to get the entire get the

1164
00:37:13,040 --> 00:37:14,560
final proof to go through and show

1165
00:37:14,560 --> 00:37:17,119
negligible sounds okay so we end up with

1166
00:37:17,119 --> 00:37:19,359
a situation where an overwhelming

1167
00:37:19,359 --> 00:37:21,839
fraction of these pairs of of

1168
00:37:21,839 --> 00:37:23,599
projectors are indeed computationally

1169
00:37:23,599 --> 00:37:24,720
orthogonal

1170
00:37:24,720 --> 00:37:25,680
okay

1171
00:37:25,680 --> 00:37:27,839
and so that was just what i wanted to

1172
00:37:27,839 --> 00:37:29,839
say like diving a little bit deeper into

1173
00:37:29,839 --> 00:37:31,760
the um kind of the strength and parallel

1174
00:37:31,760 --> 00:37:34,240
repetition there

1175
00:37:34,240 --> 00:37:35,200
um

1176
00:37:35,200 --> 00:37:37,280
okay and now i'll just give a quick uh

1177
00:37:37,280 --> 00:37:40,560
recap of what i've discussed so you know

1178
00:37:40,560 --> 00:37:42,000
the main goal

1179
00:37:42,000 --> 00:37:43,359
of this paper and what i was discussing

1180
00:37:43,359 --> 00:37:45,520
is to construct a blind cvqc protocol

1181
00:37:45,520 --> 00:37:47,440
following this verify and then decrypt

1182
00:37:47,440 --> 00:37:49,520
paradigm right

1183
00:37:49,520 --> 00:37:51,280
because like this is exactly what's

1184
00:37:51,280 --> 00:37:53,599
useful for um achieving what i call this

1185
00:37:53,599 --> 00:37:56,640
composable blind cbqc

1186
00:37:56,640 --> 00:37:58,480
and you know

1187
00:37:58,480 --> 00:38:00,000
such a protocol then has many

1188
00:38:00,000 --> 00:38:02,240
applications to npc um in this new

1189
00:38:02,240 --> 00:38:03,920
setting this kind of like this new

1190
00:38:03,920 --> 00:38:06,079
setting of like you want to compute

1191
00:38:06,079 --> 00:38:07,440
quantum functionalities between some

1192
00:38:07,440 --> 00:38:08,720
quantum parties and some classical

1193
00:38:08,720 --> 00:38:11,520
parties okay

1194
00:38:11,520 --> 00:38:13,200
um and so the building blocks that we

1195
00:38:13,200 --> 00:38:16,240
use are kind of this qfhe protocol the

1196
00:38:16,240 --> 00:38:18,160
measurement protocol and then like

1197
00:38:18,160 --> 00:38:20,480
crucially the cllw delegation protocol

1198
00:38:20,480 --> 00:38:22,560
for quantum sampling circuits

1199
00:38:22,560 --> 00:38:24,400
and again the three steps

1200
00:38:24,400 --> 00:38:26,800
were to first parallel repeat cllw to

1201
00:38:26,800 --> 00:38:28,240
get a negatively sound protocol with

1202
00:38:28,240 --> 00:38:29,920
quantum verifier

1203
00:38:29,920 --> 00:38:31,359
then we add the measurement protocol on

1204
00:38:31,359 --> 00:38:32,800
top of that to make the verifier

1205
00:38:32,800 --> 00:38:34,960
classical um but we end up with only a

1206
00:38:34,960 --> 00:38:36,720
one-half sound protocol and then we can

1207
00:38:36,720 --> 00:38:38,320
parallel repeat that using a

1208
00:38:38,320 --> 00:38:40,480
strengthened version of the acgh theorem

1209
00:38:40,480 --> 00:38:42,800
okay and we end up with what we want

1210
00:38:42,800 --> 00:38:44,480
which is actually just a four-round

1211
00:38:44,480 --> 00:38:46,079
negative result protocol with classical

1212
00:38:46,079 --> 00:38:47,680
verifier

1213
00:38:47,680 --> 00:38:48,640
um

1214
00:38:48,640 --> 00:38:49,680
and that's

1215
00:38:49,680 --> 00:38:51,680
that's all i wanted to say here so thank

1216
00:38:51,680 --> 00:38:55,000
you for listening

