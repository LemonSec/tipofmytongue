1
00:00:01,280 --> 00:00:03,679
hi everyone i'm michael in this video

2
00:00:03,679 --> 00:00:05,440
i'll talk about my work on expected

3
00:00:05,440 --> 00:00:08,080
polynomial runtime in cryptography

4
00:00:08,080 --> 00:00:10,320
our main focus are zero knowledge proof

5
00:00:10,320 --> 00:00:11,840
systems so

6
00:00:11,840 --> 00:00:14,080
a quick recap we have approver and

7
00:00:14,080 --> 00:00:16,400
verifier and this language this np

8
00:00:16,400 --> 00:00:18,080
language

9
00:00:18,080 --> 00:00:20,640
where the prover has a statement and a

10
00:00:20,640 --> 00:00:22,400
witness and the verifier wants to be

11
00:00:22,400 --> 00:00:24,240
convinced that x lies in the language

12
00:00:24,240 --> 00:00:25,840
and they interact and in the end the

13
00:00:25,840 --> 00:00:27,920
verifier outputs its verdict whether it

14
00:00:27,920 --> 00:00:29,760
accepts the claim or not

15
00:00:29,760 --> 00:00:31,679
and their knowledge says that

16
00:00:31,679 --> 00:00:33,920
the verifier cannot learn anything from

17
00:00:33,920 --> 00:00:35,760
this interaction and it's usually

18
00:00:35,760 --> 00:00:36,960
formulated

19
00:00:36,960 --> 00:00:40,000
as follows so it's usually formulated as

20
00:00:40,000 --> 00:00:41,840
existential zero knowledge

21
00:00:41,840 --> 00:00:43,200
which says that

22
00:00:43,200 --> 00:00:44,399
for every

23
00:00:44,399 --> 00:00:47,280
verifier there exists a simulator

24
00:00:47,280 --> 00:00:49,760
such that the output of the real

25
00:00:49,760 --> 00:00:52,079
protocol of the verifier

26
00:00:52,079 --> 00:00:54,320
and the output of the simulator are

27
00:00:54,320 --> 00:00:56,160
indistinguishable and the simulator does

28
00:00:56,160 --> 00:00:58,719
not get the witnesses input

29
00:00:58,719 --> 00:01:00,960
a stronger notion of zero knowledge is

30
00:01:00,960 --> 00:01:03,280
universal zero knowledge here

31
00:01:03,280 --> 00:01:06,080
the order of the quantifiers are swapped

32
00:01:06,080 --> 00:01:08,000
so the simulator

33
00:01:08,000 --> 00:01:09,680
is universal

34
00:01:09,680 --> 00:01:11,439
for all adversaries there exists one

35
00:01:11,439 --> 00:01:12,400
simulator

36
00:01:12,400 --> 00:01:14,640
and this is given the code of the

37
00:01:14,640 --> 00:01:16,320
adversary and then it works for any

38
00:01:16,320 --> 00:01:17,840
adversary

39
00:01:17,840 --> 00:01:19,600
and an even stronger notion of student

40
00:01:19,600 --> 00:01:21,360
is black boxer knowledge here the

41
00:01:21,360 --> 00:01:23,200
simulator is universal and it does not

42
00:01:23,200 --> 00:01:24,479
even get to see the code of the

43
00:01:24,479 --> 00:01:27,040
adversary it just gets access to the

44
00:01:27,040 --> 00:01:30,240
adversary as a black box

45
00:01:30,240 --> 00:01:31,520
and

46
00:01:31,520 --> 00:01:34,159
i've closed over one detail here

47
00:01:34,159 --> 00:01:35,759
namely

48
00:01:35,759 --> 00:01:37,920
the running times

49
00:01:37,920 --> 00:01:38,960
so

50
00:01:38,960 --> 00:01:41,840
i use expected poly time simulation here

51
00:01:41,840 --> 00:01:43,759
but strict poly time adversaries and

52
00:01:43,759 --> 00:01:47,119
this actually induces an asymmetry

53
00:01:47,119 --> 00:01:48,079
and

54
00:01:48,079 --> 00:01:50,399
this is this kind of breaks the promise

55
00:01:50,399 --> 00:01:52,880
of zero knowledge which states that

56
00:01:52,880 --> 00:01:55,360
everything the verifier

57
00:01:55,360 --> 00:01:58,159
learns it could simulate itself

58
00:01:58,159 --> 00:02:00,479
because this verifier cannot run the

59
00:02:00,479 --> 00:02:01,600
simulator

60
00:02:01,600 --> 00:02:03,600
and also you run into composability

61
00:02:03,600 --> 00:02:05,840
issues because after

62
00:02:05,840 --> 00:02:07,600
replacing an adversary

63
00:02:07,600 --> 00:02:10,639
by a simulator once

64
00:02:10,639 --> 00:02:12,560
you will now have an expected time

65
00:02:12,560 --> 00:02:15,200
adversary which you cannot handle

66
00:02:15,200 --> 00:02:17,280
anymore because

67
00:02:17,280 --> 00:02:19,200
we cannot only handle ppt adversaries

68
00:02:19,200 --> 00:02:20,239
here

69
00:02:20,239 --> 00:02:21,040
so

70
00:02:21,040 --> 00:02:23,200
there are two ways out we could require

71
00:02:23,200 --> 00:02:25,280
the simulator to be ppt

72
00:02:25,280 --> 00:02:26,480
or we could

73
00:02:26,480 --> 00:02:29,360
allow the adversary to be ept

74
00:02:29,360 --> 00:02:32,319
and we'll look at the letter

75
00:02:32,319 --> 00:02:34,879
and with this choice another implicit

76
00:02:34,879 --> 00:02:38,239
assumption becomes more apparent namely

77
00:02:38,239 --> 00:02:40,239
with ppt adversaries one usually assumes

78
00:02:40,239 --> 00:02:41,760
that they are well behaved in any

79
00:02:41,760 --> 00:02:43,920
environment so there is this one

80
00:02:43,920 --> 00:02:46,400
polynomial bound and it will hold no

81
00:02:46,400 --> 00:02:47,280
matter

82
00:02:47,280 --> 00:02:48,640
what machines

83
00:02:48,640 --> 00:02:50,400
the verifier interacts with

84
00:02:50,400 --> 00:02:52,879
for expected polygon verifiers this is

85
00:02:52,879 --> 00:02:55,200
not so clear anymore

86
00:02:55,200 --> 00:02:57,680
and well let's see why we look at this

87
00:02:57,680 --> 00:02:59,360
setting

88
00:02:59,360 --> 00:03:00,400
and

89
00:03:00,400 --> 00:03:02,959
what setting we look at now exactly so

90
00:03:02,959 --> 00:03:06,159
what do we want to look at expected time

91
00:03:06,159 --> 00:03:07,360
simulation

92
00:03:07,360 --> 00:03:09,440
the main reason is that

93
00:03:09,440 --> 00:03:11,200
strict body time simulation is

94
00:03:11,200 --> 00:03:13,680
impossible in the plane model

95
00:03:13,680 --> 00:03:15,440
for constant round black box zero

96
00:03:15,440 --> 00:03:17,040
knowledge with negligible soundness

97
00:03:17,040 --> 00:03:18,720
error which is a result due to barrack

98
00:03:18,720 --> 00:03:20,239
and lindell

99
00:03:20,239 --> 00:03:21,760
and they also show that similar

100
00:03:21,760 --> 00:03:23,920
impossibilities hold for proofs of

101
00:03:23,920 --> 00:03:25,440
knowledge

102
00:03:25,440 --> 00:03:26,480
and

103
00:03:26,480 --> 00:03:28,799
the relaxation of adversaries or the

104
00:03:28,799 --> 00:03:30,319
strengthening of adversaries onto

105
00:03:30,319 --> 00:03:32,560
designated adversaries which only need

106
00:03:32,560 --> 00:03:34,480
to be efficient in the protocol

107
00:03:34,480 --> 00:03:36,319
they are designed to attack as it's very

108
00:03:36,319 --> 00:03:38,799
natural in the expected policy setting

109
00:03:38,799 --> 00:03:40,720
but it turns out to be somewhat tricky

110
00:03:40,720 --> 00:03:41,840
to deal with

111
00:03:41,840 --> 00:03:44,640
but in some sense you do have to to

112
00:03:44,640 --> 00:03:46,319
deal with this you have to decide on a

113
00:03:46,319 --> 00:03:49,120
notion and we go with this very natural

114
00:03:49,120 --> 00:03:50,799
notion

115
00:03:50,799 --> 00:03:52,239
and then the rest of this talk will

116
00:03:52,239 --> 00:03:54,319
mainly focus on expected polytime

117
00:03:54,319 --> 00:03:55,680
verifiers

118
00:03:55,680 --> 00:03:58,959
and the designated verify aspect comes

119
00:03:58,959 --> 00:04:00,799
naturally

120
00:04:00,799 --> 00:04:03,280
we will as our running example

121
00:04:03,280 --> 00:04:04,400
use the

122
00:04:04,400 --> 00:04:06,480
graph recovering protocol

123
00:04:06,480 --> 00:04:08,560
so a quick reminder this is the classic

124
00:04:08,560 --> 00:04:10,400
graph recovering protocol we have a

125
00:04:10,400 --> 00:04:12,959
verifier and approver and the prover

126
00:04:12,959 --> 00:04:14,400
knows the graph

127
00:04:14,400 --> 00:04:16,238
and the three coloring

128
00:04:16,238 --> 00:04:18,160
and it will first randomize this three

129
00:04:18,160 --> 00:04:20,478
coloring and then commit to all the

130
00:04:20,478 --> 00:04:21,519
colors

131
00:04:21,519 --> 00:04:23,759
and send these to the verifier the

132
00:04:23,759 --> 00:04:25,360
verifier will choose a random challenge

133
00:04:25,360 --> 00:04:26,240
edge

134
00:04:26,240 --> 00:04:29,040
and the brewer will then open the colors

135
00:04:29,040 --> 00:04:32,720
for these notes the commitments

136
00:04:32,720 --> 00:04:34,720
and the verifier will check if these

137
00:04:34,720 --> 00:04:36,800
commitments were correctly opened and if

138
00:04:36,800 --> 00:04:38,800
the colors are different and if this is

139
00:04:38,800 --> 00:04:40,720
the case it will accept

140
00:04:40,720 --> 00:04:42,400
now this is a constant run protocol but

141
00:04:42,400 --> 00:04:44,400
it has a huge soundness error

142
00:04:44,400 --> 00:04:45,919
so to drive down the soundless error we

143
00:04:45,919 --> 00:04:47,520
would like to use parallel repetitions

144
00:04:47,520 --> 00:04:49,600
so that it remains constant round

145
00:04:49,600 --> 00:04:50,639
but

146
00:04:50,639 --> 00:04:52,560
then we lose zero knowledge so we

147
00:04:52,560 --> 00:04:54,320
actually use a different protocol we use

148
00:04:54,320 --> 00:04:56,960
the protocol by gold like kahan which is

149
00:04:56,960 --> 00:04:58,639
a modification of the graph 3 coloring

150
00:04:58,639 --> 00:05:00,800
proof as follows

151
00:05:00,800 --> 00:05:01,680
we

152
00:05:01,680 --> 00:05:04,320
choose the challenges as the very first

153
00:05:04,320 --> 00:05:06,479
step and then the verifier commits to

154
00:05:06,479 --> 00:05:08,639
its challenge choices

155
00:05:08,639 --> 00:05:10,400
and the rest is basically the same the

156
00:05:10,400 --> 00:05:12,160
verifier will open its challenge now and

157
00:05:12,160 --> 00:05:13,919
the approver will check this opening but

158
00:05:13,919 --> 00:05:18,400
otherwise the the protocol is unchanged

159
00:05:18,400 --> 00:05:19,199
so

160
00:05:19,199 --> 00:05:21,919
with this we can now do an enfold

161
00:05:21,919 --> 00:05:24,320
parallel repetition of this almost

162
00:05:24,320 --> 00:05:26,639
standard graph recovering protocol

163
00:05:26,639 --> 00:05:28,560
with challenges committed beforehand and

164
00:05:28,560 --> 00:05:30,479
we get a constant round protocol which

165
00:05:30,479 --> 00:05:32,720
has negligible soundness error and it

166
00:05:32,720 --> 00:05:34,880
can be shown that this is black box zero

167
00:05:34,880 --> 00:05:36,000
knowledge

168
00:05:36,000 --> 00:05:38,160
but the proof that this is true is

169
00:05:38,160 --> 00:05:40,080
somewhat tricky

170
00:05:40,080 --> 00:05:42,400
and we will see the reason in a minute

171
00:05:42,400 --> 00:05:45,600
but before let's look at an alternative

172
00:05:45,600 --> 00:05:47,360
security proof

173
00:05:47,360 --> 00:05:49,039
which even holds for designated

174
00:05:49,039 --> 00:05:50,240
verifiers

175
00:05:50,240 --> 00:05:52,320
and expected time verifiers and the

176
00:05:52,320 --> 00:05:55,520
proof is clean it's simple but it's

177
00:05:55,520 --> 00:05:58,240
wrong and maybe you can spot the mistake

178
00:05:58,240 --> 00:05:59,520
already

179
00:05:59,520 --> 00:06:01,759
so the proof is actually based on the

180
00:06:01,759 --> 00:06:04,160
naive simulator so that's the reason

181
00:06:04,160 --> 00:06:05,360
it's simple it's really the

182
00:06:05,360 --> 00:06:07,919
straightforward choice of simulator

183
00:06:07,919 --> 00:06:09,759
this simulator will first

184
00:06:09,759 --> 00:06:11,360
run the verifier to receive the

185
00:06:11,360 --> 00:06:13,600
commitments to the changes it will then

186
00:06:13,600 --> 00:06:16,000
send a garbage commitment to all zeros

187
00:06:16,000 --> 00:06:17,520
just so that in the next step it

188
00:06:17,520 --> 00:06:19,199
receives openings of the verifiers

189
00:06:19,199 --> 00:06:22,240
challenges and if the verifier fails in

190
00:06:22,240 --> 00:06:24,560
this step well the simulator can just

191
00:06:24,560 --> 00:06:26,639
abort like the arms prover would

192
00:06:26,639 --> 00:06:27,360
so

193
00:06:27,360 --> 00:06:29,440
now we have openings to the

194
00:06:29,440 --> 00:06:31,360
committee challenges

195
00:06:31,360 --> 00:06:33,520
and the verifier the simulator will now

196
00:06:33,520 --> 00:06:36,880
rewind the verifier back to before it

197
00:06:36,880 --> 00:06:38,720
send the garbage commitment and now it

198
00:06:38,720 --> 00:06:40,880
will send pseudo colorings so a

199
00:06:40,880 --> 00:06:43,120
commitment to colors which

200
00:06:43,120 --> 00:06:45,280
answer the challenge query correctly but

201
00:06:45,280 --> 00:06:46,840
otherwise are just all

202
00:06:46,840 --> 00:06:49,520
zeroes it will rewind the verifier until

203
00:06:49,520 --> 00:06:51,680
it answers again

204
00:06:51,680 --> 00:06:52,720
with

205
00:06:52,720 --> 00:06:55,440
a valid opening to the commitments

206
00:06:55,440 --> 00:06:56,479
and

207
00:06:56,479 --> 00:06:58,720
if this valid opening happens to to be

208
00:06:58,720 --> 00:07:01,039
different from the opening before the

209
00:07:01,039 --> 00:07:02,639
simulator will board because now the

210
00:07:02,639 --> 00:07:04,240
binding property was broken and the

211
00:07:04,240 --> 00:07:06,720
simulator doesn't know what to do

212
00:07:06,720 --> 00:07:09,120
otherwise the simulator can just open

213
00:07:09,120 --> 00:07:12,080
its challenge coloring and

214
00:07:12,080 --> 00:07:13,840
it's fine because it's up to the

215
00:07:13,840 --> 00:07:15,360
coloring

216
00:07:15,360 --> 00:07:17,440
so now the simulator can run the verify

217
00:07:17,440 --> 00:07:18,720
to the end and output whatever the

218
00:07:18,720 --> 00:07:20,800
verifier outputs

219
00:07:20,800 --> 00:07:23,120
so this is the knife simulator

220
00:07:23,120 --> 00:07:25,360
and let's have a look at the security

221
00:07:25,360 --> 00:07:27,120
proof

222
00:07:27,120 --> 00:07:28,080
so

223
00:07:28,080 --> 00:07:30,639
we use game hops we start with the

224
00:07:30,639 --> 00:07:33,039
honest game the honest execution and at

225
00:07:33,039 --> 00:07:35,039
the very first step we will introduce

226
00:07:35,039 --> 00:07:36,800
all the rewinding

227
00:07:36,800 --> 00:07:39,759
so it's not hard to see that introducing

228
00:07:39,759 --> 00:07:41,759
the rewinding at most doubles the

229
00:07:41,759 --> 00:07:44,240
runtime because we have expected one

230
00:07:44,240 --> 00:07:45,440
rewind

231
00:07:45,440 --> 00:07:48,319
and note here that we do not compute

232
00:07:48,319 --> 00:07:51,120
garbage commit garbage commitments here

233
00:07:51,120 --> 00:07:52,560
because the commitments and everything

234
00:07:52,560 --> 00:07:54,560
else is computed honestly here we

235
00:07:54,560 --> 00:07:57,280
basically run the honest prover

236
00:07:57,280 --> 00:07:59,199
with all its inputs except fresh

237
00:07:59,199 --> 00:08:01,039
randomness

238
00:08:01,039 --> 00:08:03,759
in the next step we abort if the second

239
00:08:03,759 --> 00:08:05,440
opening of the challenge would be

240
00:08:05,440 --> 00:08:07,840
different from the first one

241
00:08:07,840 --> 00:08:09,199
this is

242
00:08:09,199 --> 00:08:11,120
not a big change because it can be

243
00:08:11,120 --> 00:08:13,039
reduced to the binding property that

244
00:08:13,039 --> 00:08:15,360
this happens

245
00:08:15,360 --> 00:08:16,720
and the reduction is actually

246
00:08:16,720 --> 00:08:18,800
straightforward here

247
00:08:18,800 --> 00:08:21,199
in the next step we will replace the

248
00:08:21,199 --> 00:08:22,639
first commitment

249
00:08:22,639 --> 00:08:24,240
used with the garbage commitment the

250
00:08:24,240 --> 00:08:25,759
simulator uses

251
00:08:25,759 --> 00:08:26,960
again this is a straightforward

252
00:08:26,960 --> 00:08:28,879
reduction to the hiding property of the

253
00:08:28,879 --> 00:08:30,400
commitment scheme

254
00:08:30,400 --> 00:08:32,320
and in the last step we do the same for

255
00:08:32,320 --> 00:08:34,320
the pseudo coloring commitments

256
00:08:34,320 --> 00:08:36,479
and here we use that we already know the

257
00:08:36,479 --> 00:08:37,440
challenge

258
00:08:37,440 --> 00:08:38,799
but otherwise this is again a

259
00:08:38,799 --> 00:08:40,559
straightforward reduction so

260
00:08:40,559 --> 00:08:43,440
nothing really happened here

261
00:08:43,440 --> 00:08:46,000
but something went wrong so did you spot

262
00:08:46,000 --> 00:08:47,920
the mistake

263
00:08:47,920 --> 00:08:51,120
and the problem is maybe unsurprisingly

264
00:08:51,120 --> 00:08:53,760
that we have a runtime explosion

265
00:08:53,760 --> 00:08:54,560
so

266
00:08:54,560 --> 00:08:56,640
let's have a look at a very simple

267
00:08:56,640 --> 00:08:58,480
adversary which will make the runtime

268
00:08:58,480 --> 00:08:59,839
explode

269
00:08:59,839 --> 00:09:02,480
and this is an example to do figa

270
00:09:02,480 --> 00:09:04,240
and the idea is to just run the honest

271
00:09:04,240 --> 00:09:06,160
verifier and in the end with tiny

272
00:09:06,160 --> 00:09:08,480
probability let's brute force the

273
00:09:08,480 --> 00:09:10,000
previous commitments

274
00:09:10,000 --> 00:09:12,080
and if this verifier sees a

275
00:09:12,080 --> 00:09:15,360
pseudo-coloring it will run forever

276
00:09:15,360 --> 00:09:18,000
and otherwise it will output some value

277
00:09:18,000 --> 00:09:20,880
d according to some distribution b

278
00:09:20,880 --> 00:09:23,279
so when running with the honest prover

279
00:09:23,279 --> 00:09:25,440
the verifier will be efficient because

280
00:09:25,440 --> 00:09:27,760
the tiny probability

281
00:09:27,760 --> 00:09:29,680
is not a problem for expected product

282
00:09:29,680 --> 00:09:31,120
time v

283
00:09:31,120 --> 00:09:33,120
and it will never see up to the coloring

284
00:09:33,120 --> 00:09:34,080
however

285
00:09:34,080 --> 00:09:36,880
if we run this verify with the simulator

286
00:09:36,880 --> 00:09:39,920
then it might happen that the verifier

287
00:09:39,920 --> 00:09:40,959
breaks

288
00:09:40,959 --> 00:09:42,640
the commitment scheme and sees the

289
00:09:42,640 --> 00:09:44,800
pseudo coloring and in that case the

290
00:09:44,800 --> 00:09:47,120
simulator would run the

291
00:09:47,120 --> 00:09:50,959
verifier to its end which is forever and

292
00:09:50,959 --> 00:09:52,320
so the simulator itself would run

293
00:09:52,320 --> 00:09:53,600
forever

294
00:09:53,600 --> 00:09:54,720
now there's an

295
00:09:54,720 --> 00:09:57,120
obvious solution to this we could try to

296
00:09:57,120 --> 00:09:57,920
just

297
00:09:57,920 --> 00:09:59,760
truncate the verified's execution this

298
00:09:59,760 --> 00:10:02,000
is not fully black box anymore but

299
00:10:02,000 --> 00:10:04,560
it's it's a clear solution but it

300
00:10:04,560 --> 00:10:07,279
doesn't really work um because if this

301
00:10:07,279 --> 00:10:08,640
distribution d

302
00:10:08,640 --> 00:10:11,040
is not approximable in strict polytime

303
00:10:11,040 --> 00:10:13,040
then we cannot truncate the verifier to

304
00:10:13,040 --> 00:10:15,680
strict polytime so at least the the most

305
00:10:15,680 --> 00:10:17,279
obvious fix

306
00:10:17,279 --> 00:10:19,120
fails

307
00:10:19,120 --> 00:10:21,200
but this can be salvaged because castle

308
00:10:21,200 --> 00:10:23,360
and dell show that using super

309
00:10:23,360 --> 00:10:25,120
polynomial truncation and some more

310
00:10:25,120 --> 00:10:27,920
techniques you can actually prove that

311
00:10:27,920 --> 00:10:29,920
the simulation works and you can handle

312
00:10:29,920 --> 00:10:33,200
expected quality time verifiers

313
00:10:33,200 --> 00:10:35,200
there's also another take on this we

314
00:10:35,200 --> 00:10:36,800
could say that while these designated

315
00:10:36,800 --> 00:10:38,480
adversaries are just not worth it and we

316
00:10:38,480 --> 00:10:40,240
want that the adversary is better

317
00:10:40,240 --> 00:10:42,079
behaved so we could say that the

318
00:10:42,079 --> 00:10:44,640
adversary should be expected poorly in

319
00:10:44,640 --> 00:10:46,800
any interaction

320
00:10:46,800 --> 00:10:49,279
and maybe surprisingly this also is not

321
00:10:49,279 --> 00:10:51,920
good enough because cassandra del show

322
00:10:51,920 --> 00:10:52,959
that

323
00:10:52,959 --> 00:10:56,320
basically due to the rewinding which

324
00:10:56,320 --> 00:10:58,560
happens in the simulation but never in

325
00:10:58,560 --> 00:11:00,399
the real protocol you can have a

326
00:11:00,399 --> 00:11:02,480
verifier which will make the simulation

327
00:11:02,480 --> 00:11:05,600
runtime explode but no real interaction

328
00:11:05,600 --> 00:11:06,880
even with

329
00:11:06,880 --> 00:11:09,120
arbitrary environments

330
00:11:09,120 --> 00:11:10,560
again this can be salvaged and this is

331
00:11:10,560 --> 00:11:12,320
what goldrich does

332
00:11:12,320 --> 00:11:14,800
he says that the adversary should be

333
00:11:14,800 --> 00:11:16,880
expected polytime with respect to any

334
00:11:16,880 --> 00:11:19,040
reset attack so basically even if you

335
00:11:19,040 --> 00:11:21,839
try to make the verifier run very very

336
00:11:21,839 --> 00:11:24,560
long you will fail because it is so well

337
00:11:24,560 --> 00:11:26,839
behaved it just will never run for too

338
00:11:26,839 --> 00:11:28,480
long

339
00:11:28,480 --> 00:11:30,320
and this

340
00:11:30,320 --> 00:11:32,000
this approach basically says that we do

341
00:11:32,000 --> 00:11:33,360
not want to deal with designated

342
00:11:33,360 --> 00:11:35,680
adversaries so this is not the path we

343
00:11:35,680 --> 00:11:37,200
take

344
00:11:37,200 --> 00:11:38,720
our path is

345
00:11:38,720 --> 00:11:40,560
on a very high level similar to the

346
00:11:40,560 --> 00:11:43,440
truncation idea and before we explain

347
00:11:43,440 --> 00:11:44,959
our take on this

348
00:11:44,959 --> 00:11:47,440
we'll simplify the situation more so

349
00:11:47,440 --> 00:11:49,839
that we can really see the the core

350
00:11:49,839 --> 00:11:51,279
problems here

351
00:11:51,279 --> 00:11:54,000
and consider this simplified

352
00:11:54,000 --> 00:11:55,680
situation where we just have an

353
00:11:55,680 --> 00:11:57,360
algorithm a

354
00:11:57,360 --> 00:11:59,200
which computes the identity by sampling

355
00:11:59,200 --> 00:12:01,200
a random string and in any case

356
00:12:01,200 --> 00:12:04,240
outputting x

357
00:12:04,240 --> 00:12:06,320
and this is clearly efficient

358
00:12:06,320 --> 00:12:09,279
so there's nothing problematic here

359
00:12:09,279 --> 00:12:11,680
but this variation here b

360
00:12:11,680 --> 00:12:13,839
which loops forever if this random

361
00:12:13,839 --> 00:12:15,839
string happens to be zero

362
00:12:15,839 --> 00:12:19,279
this is clearly not efficient

363
00:12:19,279 --> 00:12:21,360
because its expected time is infinite

364
00:12:21,360 --> 00:12:23,040
for example

365
00:12:23,040 --> 00:12:25,600
but this really makes sense to say that

366
00:12:25,600 --> 00:12:27,839
this is not efficient

367
00:12:27,839 --> 00:12:28,800
because

368
00:12:28,800 --> 00:12:31,440
even if we get access to these

369
00:12:31,440 --> 00:12:34,000
algorithms as black boxes and we're told

370
00:12:34,000 --> 00:12:36,720
how long they run whenever we query them

371
00:12:36,720 --> 00:12:38,560
we could not distinguish them

372
00:12:38,560 --> 00:12:42,639
at least not with a poly number of tries

373
00:12:42,639 --> 00:12:44,160
and this

374
00:12:44,160 --> 00:12:46,360
this is the core problem

375
00:12:46,360 --> 00:12:48,639
indistinguishability does not preserve

376
00:12:48,639 --> 00:12:49,920
efficiency

377
00:12:49,920 --> 00:12:51,200
and we actually saw that not even

378
00:12:51,200 --> 00:12:52,720
statistically and distinguishability

379
00:12:52,720 --> 00:12:55,040
preserves efficiency

380
00:12:55,040 --> 00:12:57,760
and this leads us to the question

381
00:12:57,760 --> 00:12:59,519
if an algorithm is indistinguishable

382
00:12:59,519 --> 00:13:00,720
from efficient

383
00:13:00,720 --> 00:13:02,959
isn't it efficient

384
00:13:02,959 --> 00:13:06,160
and this is the idea which inspires our

385
00:13:06,160 --> 00:13:09,279
solution and in a very abstract

386
00:13:09,279 --> 00:13:12,399
view we can look at it as follows

387
00:13:12,399 --> 00:13:14,480
we can say that a runtime class so set

388
00:13:14,480 --> 00:13:16,160
of runtimes

389
00:13:16,160 --> 00:13:17,760
which are by definition efficient

390
00:13:17,760 --> 00:13:20,399
runtimes is distinguishing closed

391
00:13:20,399 --> 00:13:21,440
if

392
00:13:21,440 --> 00:13:23,600
any runtime which cannot be efficiently

393
00:13:23,600 --> 00:13:26,079
distinguished from efficient must also

394
00:13:26,079 --> 00:13:29,360
be efficient or in formulas for any

395
00:13:29,360 --> 00:13:30,560
runtime u

396
00:13:30,560 --> 00:13:32,959
if there exists a runtime s which lies

397
00:13:32,959 --> 00:13:35,760
in t and u and s are t time

398
00:13:35,760 --> 00:13:37,519
indistinguishable so no efficient

399
00:13:37,519 --> 00:13:39,519
algorithm can distinguish uns

400
00:13:39,519 --> 00:13:42,079
then you must also lie in t so you must

401
00:13:42,079 --> 00:13:44,800
also be efficient

402
00:13:44,800 --> 00:13:46,959
with this we now turn to our relaxation

403
00:13:46,959 --> 00:13:48,800
of expected polytime which is called

404
00:13:48,800 --> 00:13:51,279
computationally expected polytime and

405
00:13:51,279 --> 00:13:53,680
first we define what we mean by expected

406
00:13:53,680 --> 00:13:56,079
polytime more precisely and now setting

407
00:13:56,079 --> 00:13:57,600
things only depend on the security

408
00:13:57,600 --> 00:14:00,639
parameter and around time t is expected

409
00:14:00,639 --> 00:14:02,399
poly if

410
00:14:02,399 --> 00:14:04,320
the expectation is bounded by a

411
00:14:04,320 --> 00:14:07,279
polynomial in the security parameter

412
00:14:07,279 --> 00:14:08,320
and

413
00:14:08,320 --> 00:14:10,000
computationally expected polytime is now

414
00:14:10,000 --> 00:14:13,760
defined as this runtime t is sapped

415
00:14:13,760 --> 00:14:16,800
if there exists an expected polytime s

416
00:14:16,800 --> 00:14:19,279
and t and s are indistinguishable

417
00:14:19,279 --> 00:14:20,320
so

418
00:14:20,320 --> 00:14:22,320
i have to remark two things here we

419
00:14:22,320 --> 00:14:24,399
actually use ppt and distinguishability

420
00:14:24,399 --> 00:14:27,120
instead of septic distinguishability

421
00:14:27,120 --> 00:14:29,120
but it turns out that this

422
00:14:29,120 --> 00:14:30,560
indistinguishability notions are

423
00:14:30,560 --> 00:14:33,199
equivalent anyway

424
00:14:33,199 --> 00:14:35,600
and what we use here is not

425
00:14:35,600 --> 00:14:37,120
one shot in distinguishability where you

426
00:14:37,120 --> 00:14:39,760
just get one sample but we use

427
00:14:39,760 --> 00:14:41,920
repeated samples so

428
00:14:41,920 --> 00:14:44,560
implicitly we mean here t and s are

429
00:14:44,560 --> 00:14:47,199
indistinguishable given repeated samples

430
00:14:47,199 --> 00:14:48,399
because

431
00:14:48,399 --> 00:14:50,639
otherwise it doesn't really make sense

432
00:14:50,639 --> 00:14:53,040
in the setting of algorithms which you

433
00:14:53,040 --> 00:14:54,480
want to run and which you can run many

434
00:14:54,480 --> 00:14:56,480
times because you have access to this

435
00:14:56,480 --> 00:14:58,959
algorithm and you just want to make sure

436
00:14:58,959 --> 00:14:59,920
that

437
00:14:59,920 --> 00:15:02,240
it's efficient

438
00:15:02,240 --> 00:15:04,320
so this is the natural choice to have

439
00:15:04,320 --> 00:15:06,880
repeated samples here

440
00:15:06,880 --> 00:15:08,959
and this definition might not look so

441
00:15:08,959 --> 00:15:10,079
nice

442
00:15:10,079 --> 00:15:12,000
but we do have a characterization which

443
00:15:12,000 --> 00:15:14,079
shows that it's actually a rather neat

444
00:15:14,079 --> 00:15:15,360
definition

445
00:15:15,360 --> 00:15:18,880
um so this characterization says that

446
00:15:18,880 --> 00:15:21,199
t accept if well it satisfies the

447
00:15:21,199 --> 00:15:23,199
original definition so there is an

448
00:15:23,199 --> 00:15:25,839
expected time s and tns are

449
00:15:25,839 --> 00:15:28,000
computationally indistinguishable

450
00:15:28,000 --> 00:15:30,240
under repeated samples

451
00:15:30,240 --> 00:15:31,279
the same

452
00:15:31,279 --> 00:15:32,720
holds for statistical and

453
00:15:32,720 --> 00:15:35,040
distinguishability again under repeated

454
00:15:35,040 --> 00:15:37,600
samples which is denoted as ppt query

455
00:15:37,600 --> 00:15:39,199
here

456
00:15:39,199 --> 00:15:40,959
and with a third characterization which

457
00:15:40,959 --> 00:15:42,480
is somewhat different

458
00:15:42,480 --> 00:15:45,680
namely there exists a set of good events

459
00:15:45,680 --> 00:15:48,079
which has overwhelming probability

460
00:15:48,079 --> 00:15:50,399
and conditioned on this set of good

461
00:15:50,399 --> 00:15:53,120
events the expectation of t is bounded

462
00:15:53,120 --> 00:15:55,040
by a polynomial

463
00:15:55,040 --> 00:15:57,279
this good event characterization is very

464
00:15:57,279 --> 00:15:59,040
useful for

465
00:15:59,040 --> 00:16:00,959
unconditional things

466
00:16:00,959 --> 00:16:02,560
for example the introduction of

467
00:16:02,560 --> 00:16:06,440
rewinding to see that it does not break

468
00:16:06,440 --> 00:16:09,440
sept um whereas the first point is very

469
00:16:09,440 --> 00:16:12,800
useful for indistinguishability hops

470
00:16:12,800 --> 00:16:14,639
and actually we have a

471
00:16:14,639 --> 00:16:16,079
lemma which

472
00:16:16,079 --> 00:16:19,759
basically just states restates the

473
00:16:19,759 --> 00:16:22,079
usual direct reduction in this

474
00:16:22,079 --> 00:16:24,880
designated verifier setting with sept

475
00:16:24,880 --> 00:16:26,720
and provides efficiency from

476
00:16:26,720 --> 00:16:29,199
indistinguishability in some sense and

477
00:16:29,199 --> 00:16:31,279
in this standard reduction

478
00:16:31,279 --> 00:16:33,279
we consider two oracles and a

479
00:16:33,279 --> 00:16:34,639
distinguished d

480
00:16:34,639 --> 00:16:36,480
and now suppose the distinguisher can

481
00:16:36,480 --> 00:16:39,360
distinguish o0 and a 1 with advantage at

482
00:16:39,360 --> 00:16:41,680
least one hour poly

483
00:16:41,680 --> 00:16:44,079
and also assume that the distinguisher

484
00:16:44,079 --> 00:16:46,959
is sapped when running with o0 so we

485
00:16:46,959 --> 00:16:49,519
make no assumption about o1 and when we

486
00:16:49,519 --> 00:16:51,600
say sep we only count the steps of the

487
00:16:51,600 --> 00:16:54,480
distinguisher the oracles might not be

488
00:16:54,480 --> 00:16:56,959
efficient

489
00:16:57,120 --> 00:16:59,279
then this lemma says

490
00:16:59,279 --> 00:17:01,759
there exists a strict ppt distinguisher

491
00:17:01,759 --> 00:17:02,800
a

492
00:17:02,800 --> 00:17:04,959
whose advantage is at least one over

493
00:17:04,959 --> 00:17:07,439
four poly

494
00:17:07,439 --> 00:17:08,480
and

495
00:17:08,480 --> 00:17:10,079
why does this imply efficiency from

496
00:17:10,079 --> 00:17:12,079
indistinguishability well d could

497
00:17:12,079 --> 00:17:14,720
basically use its runtime

498
00:17:14,720 --> 00:17:16,799
it could measure its own runtime and use

499
00:17:16,799 --> 00:17:18,880
this as a distinguishing characteristic

500
00:17:18,880 --> 00:17:19,679
so

501
00:17:19,679 --> 00:17:22,319
we see that if d is sap then we could

502
00:17:22,319 --> 00:17:24,079
replace it with an

503
00:17:24,079 --> 00:17:26,959
ppt adversary strict ppt adversary and

504
00:17:26,959 --> 00:17:29,600
still have non-negligible advantage

505
00:17:29,600 --> 00:17:32,559
and actually the proof reflects this so

506
00:17:32,559 --> 00:17:35,360
the proof idea is to just truncate

507
00:17:35,360 --> 00:17:37,919
the distinguisher d

508
00:17:37,919 --> 00:17:41,360
so that when running with o0 a and d

509
00:17:41,360 --> 00:17:43,919
have statistically closed output so it's

510
00:17:43,919 --> 00:17:47,280
at most one over four poly polyfarm

511
00:17:47,280 --> 00:17:49,600
now the problem is that the timer

512
00:17:49,600 --> 00:17:51,200
probability

513
00:17:51,200 --> 00:17:53,039
could be very different when a is

514
00:17:53,039 --> 00:17:55,679
running with a1 or o00

515
00:17:55,679 --> 00:17:57,679
but if it's too different if it's at

516
00:17:57,679 --> 00:18:01,200
least 104 poly far then again we get

517
00:18:01,200 --> 00:18:03,280
this we get a distinguisher

518
00:18:03,280 --> 00:18:05,919
by just using the timeout event as the

519
00:18:05,919 --> 00:18:08,320
distinguishing characteristic

520
00:18:08,320 --> 00:18:11,280
and otherwise it's easy to see that a

521
00:18:11,280 --> 00:18:15,200
still has 104 poly advantage and now a

522
00:18:15,200 --> 00:18:18,000
is strict ppt by construction

523
00:18:18,000 --> 00:18:19,919
so this is the core result one can use

524
00:18:19,919 --> 00:18:22,559
to replace direct reductions

525
00:18:22,559 --> 00:18:24,480
and we will now apply this to the graph

526
00:18:24,480 --> 00:18:26,240
recoloring protocol but first let's

527
00:18:26,240 --> 00:18:28,000
clarify what we mean by zero knowledge

528
00:18:28,000 --> 00:18:30,880
in this designated adversary setting

529
00:18:30,880 --> 00:18:32,400
and here is the knowledge for proof

530
00:18:32,400 --> 00:18:34,720
system pv means we have a universal

531
00:18:34,720 --> 00:18:36,480
simulator

532
00:18:36,480 --> 00:18:38,960
and we define these two oracles o0 and

533
00:18:38,960 --> 00:18:42,320
a1 where o0 is the honest interaction

534
00:18:42,320 --> 00:18:44,240
and one is the simulation

535
00:18:44,240 --> 00:18:45,760
and we require

536
00:18:45,760 --> 00:18:47,760
that o0 is

537
00:18:47,760 --> 00:18:50,320
indistinguishable from o1

538
00:18:50,320 --> 00:18:52,160
which just means that well the

539
00:18:52,160 --> 00:18:54,160
simulator's output and the real output

540
00:18:54,160 --> 00:18:55,840
are

541
00:18:55,840 --> 00:18:58,320
and we also require that a1 is efficient

542
00:18:58,320 --> 00:19:00,400
relative to o0

543
00:19:00,400 --> 00:19:02,160
which just means that well if the

544
00:19:02,160 --> 00:19:05,039
verifier is efficient so if if it's an

545
00:19:05,039 --> 00:19:06,640
efficient attack

546
00:19:06,640 --> 00:19:08,000
then the simulation must also be

547
00:19:08,000 --> 00:19:09,039
efficient

548
00:19:09,039 --> 00:19:11,360
which is the minimum requirement we need

549
00:19:11,360 --> 00:19:14,160
for for efficiency of simulation

550
00:19:14,160 --> 00:19:16,559
and if the attack is inefficient we

551
00:19:16,559 --> 00:19:18,480
don't really care about whether that

552
00:19:18,480 --> 00:19:20,559
simulation is efficient

553
00:19:20,559 --> 00:19:22,640
so this relative efficiency is something

554
00:19:22,640 --> 00:19:25,280
which is very natural or which comes

555
00:19:25,280 --> 00:19:27,200
comes naturally in this designated

556
00:19:27,200 --> 00:19:28,640
advisory setting

557
00:19:28,640 --> 00:19:29,440
and

558
00:19:29,440 --> 00:19:30,799
we'll see that

559
00:19:30,799 --> 00:19:33,520
actually we do satisfy this um

560
00:19:33,520 --> 00:19:36,559
by going through the proof again

561
00:19:36,559 --> 00:19:38,320
now we will have a look at the runtime

562
00:19:38,320 --> 00:19:40,480
here in this column

563
00:19:40,480 --> 00:19:40,890
and

564
00:19:40,890 --> 00:19:42,480
[Music]

565
00:19:42,480 --> 00:19:44,880
we start with the honest protocol as

566
00:19:44,880 --> 00:19:46,559
usual

567
00:19:46,559 --> 00:19:48,880
it is sapped or apt by assumption

568
00:19:48,880 --> 00:19:51,520
because we want an efficient adversary

569
00:19:51,520 --> 00:19:53,200
now in the first game we introduced the

570
00:19:53,200 --> 00:19:55,600
rewinding it can be seen that this

571
00:19:55,600 --> 00:19:57,600
preserves apt and zapped and for sap we

572
00:19:57,600 --> 00:19:58,640
use the negligible event

573
00:19:58,640 --> 00:20:00,320
characterization

574
00:20:00,320 --> 00:20:01,679
in the second step we fixate the

575
00:20:01,679 --> 00:20:03,520
openings now here really nothing of

576
00:20:03,520 --> 00:20:06,080
interest happens to the runtime so this

577
00:20:06,080 --> 00:20:09,039
is a very straightforward reduction

578
00:20:09,039 --> 00:20:11,600
in the third step we use the hiding

579
00:20:11,600 --> 00:20:13,120
property to replace commitments by

580
00:20:13,120 --> 00:20:14,960
garbage commitments and we know that app

581
00:20:14,960 --> 00:20:17,039
is not preserved but sept is preserved

582
00:20:17,039 --> 00:20:19,280
and to see and to see this we can just

583
00:20:19,280 --> 00:20:22,400
use the standard reduction

584
00:20:22,400 --> 00:20:24,400
and similarly in the next step where we

585
00:20:24,400 --> 00:20:26,080
replace the

586
00:20:26,080 --> 00:20:28,080
colorings by pseudo colorings

587
00:20:28,080 --> 00:20:29,840
app is not preserved but zap is

588
00:20:29,840 --> 00:20:31,600
preserved

589
00:20:31,600 --> 00:20:33,440
and actually what we see here in this

590
00:20:33,440 --> 00:20:35,440
chain of reasoning we started with an

591
00:20:35,440 --> 00:20:37,200
adversary which was efficient in the

592
00:20:37,200 --> 00:20:38,480
real protocol

593
00:20:38,480 --> 00:20:40,960
and we ended with a simulation which was

594
00:20:40,960 --> 00:20:43,440
also efficient so we actually showed

595
00:20:43,440 --> 00:20:45,280
that this works for designated sap

596
00:20:45,280 --> 00:20:47,600
adversaries

597
00:20:47,600 --> 00:20:49,360
now with the standard reduction we have

598
00:20:49,360 --> 00:20:51,919
provided the first and probably the most

599
00:20:51,919 --> 00:20:54,240
important tool in cryptography

600
00:20:54,240 --> 00:20:56,480
but there's also another very important

601
00:20:56,480 --> 00:20:58,640
tool which is used in almost all

602
00:20:58,640 --> 00:21:00,720
security reductions namely the hybrid

603
00:21:00,720 --> 00:21:02,720
lemma

604
00:21:02,720 --> 00:21:04,080
and we can also

605
00:21:04,080 --> 00:21:05,600
transport the hybrid lemma into this

606
00:21:05,600 --> 00:21:08,320
designated adversary set setting

607
00:21:08,320 --> 00:21:11,440
and we have formulated it abstractly as

608
00:21:11,440 --> 00:21:13,440
shown here so we write

609
00:21:13,440 --> 00:21:16,320
rep oracle to denote repeated access to

610
00:21:16,320 --> 00:21:17,760
to an oracle

611
00:21:17,760 --> 00:21:18,880
which just

612
00:21:18,880 --> 00:21:20,640
can be seen as a generalization of

613
00:21:20,640 --> 00:21:22,799
repeated sampling and the hybrid lemma

614
00:21:22,799 --> 00:21:25,039
then says that if two oracles are

615
00:21:25,039 --> 00:21:27,280
indistinguishable and r1 is efficient

616
00:21:27,280 --> 00:21:28,720
relative to zero

617
00:21:28,720 --> 00:21:32,000
then the repeated oracle 0 and the

618
00:21:32,000 --> 00:21:33,760
repeated oracle 01 are still

619
00:21:33,760 --> 00:21:35,840
computationally indistinguishable

620
00:21:35,840 --> 00:21:38,400
and the repeated oracle 01 is efficient

621
00:21:38,400 --> 00:21:41,679
relative to the repeated oracle 0.

622
00:21:41,679 --> 00:21:43,760
and it turns out that the hybrid gem is

623
00:21:43,760 --> 00:21:45,200
actually not that easy to prove and we

624
00:21:45,200 --> 00:21:47,600
will give a very very high level

625
00:21:47,600 --> 00:21:48,720
sketch of

626
00:21:48,720 --> 00:21:51,200
the obstacles and the solution

627
00:21:51,200 --> 00:21:54,000
and the obstacle basically is or the

628
00:21:54,000 --> 00:21:55,520
main obstacle is the super constant

629
00:21:55,520 --> 00:21:58,080
invocation of relative efficiency

630
00:21:58,080 --> 00:21:59,760
is something we cannot

631
00:21:59,760 --> 00:22:00,960
do

632
00:22:00,960 --> 00:22:02,880
because relative efficiency comes with a

633
00:22:02,880 --> 00:22:04,880
polynomial slack in

634
00:22:04,880 --> 00:22:06,960
in the runtime so runtime might increase

635
00:22:06,960 --> 00:22:09,120
by polynomial factor for example

636
00:22:09,120 --> 00:22:11,440
um and we can certainly not allow this

637
00:22:11,440 --> 00:22:14,240
for more than a constant number of times

638
00:22:14,240 --> 00:22:16,080
another problem is that the reduction

639
00:22:16,080 --> 00:22:17,840
can actually not see the time spent in

640
00:22:17,840 --> 00:22:19,679
the challenge oracle which makes

641
00:22:19,679 --> 00:22:22,000
reasoning more complex

642
00:22:22,000 --> 00:22:24,480
and there's a very neat solution due to

643
00:22:24,480 --> 00:22:26,400
how finds

644
00:22:26,400 --> 00:22:28,159
um who looked at

645
00:22:28,159 --> 00:22:30,159
a sort of designated adversary in in the

646
00:22:30,159 --> 00:22:33,760
uc setting for poli-time adversaries

647
00:22:33,760 --> 00:22:35,039
and they

648
00:22:35,039 --> 00:22:37,840
randomized the order of the oracles in

649
00:22:37,840 --> 00:22:39,760
the hybrid argument

650
00:22:39,760 --> 00:22:42,000
and doing this now all the oracles will

651
00:22:42,000 --> 00:22:44,960
have the same runtime distribution

652
00:22:44,960 --> 00:22:47,120
so this kind of solves the super

653
00:22:47,120 --> 00:22:48,960
constant invocation because one can now

654
00:22:48,960 --> 00:22:50,559
argue with a constant number of

655
00:22:50,559 --> 00:22:53,039
invocations of this relative efficiency

656
00:22:53,039 --> 00:22:55,200
and what's very easy to see is one can

657
00:22:55,200 --> 00:22:56,320
now watch

658
00:22:56,320 --> 00:22:59,200
the runtime of non-challenge oracles to

659
00:22:59,200 --> 00:23:00,960
actually approximate the runtime of the

660
00:23:00,960 --> 00:23:02,799
churned oracle

661
00:23:02,799 --> 00:23:04,640
and with this and

662
00:23:04,640 --> 00:23:07,200
quite a lot of technical reasoning

663
00:23:07,200 --> 00:23:09,200
one can actually derive this hybrid

664
00:23:09,200 --> 00:23:10,880
lemma

665
00:23:10,880 --> 00:23:12,880
so to summarize

666
00:23:12,880 --> 00:23:13,760
we've

667
00:23:13,760 --> 00:23:17,520
presented sept a small relaxation of ept

668
00:23:17,520 --> 00:23:20,000
we stated some basic tools

669
00:23:20,000 --> 00:23:21,919
which show that one can actually work

670
00:23:21,919 --> 00:23:23,840
with set even though

671
00:23:23,840 --> 00:23:25,679
it's kind of different from usual

672
00:23:25,679 --> 00:23:28,080
notions of efficiency

673
00:23:28,080 --> 00:23:29,440
we showed that

674
00:23:29,440 --> 00:23:31,360
one can handle designated set

675
00:23:31,360 --> 00:23:32,559
adversaries

676
00:23:32,559 --> 00:23:35,200
incept so now we have symmetric runtime

677
00:23:35,200 --> 00:23:36,400
classes for

678
00:23:36,400 --> 00:23:40,000
the adversary and the simulator

679
00:23:40,000 --> 00:23:43,200
we make no non-essential restrictions on

680
00:23:43,200 --> 00:23:45,440
the star because we consider designated

681
00:23:45,440 --> 00:23:46,640
adversaries

682
00:23:46,640 --> 00:23:48,320
and actually now the naive simulator for

683
00:23:48,320 --> 00:23:50,559
graph recoloring works even in the gold

684
00:23:50,559 --> 00:23:53,919
like hand protocol which is quite nice

685
00:23:53,919 --> 00:23:56,640
we can also see that this proof strategy

686
00:23:56,640 --> 00:24:00,080
generalizes and we do this explicitly in

687
00:24:00,080 --> 00:24:02,000
our work

688
00:24:02,000 --> 00:24:04,320
and as the last thing we should say that

689
00:24:04,320 --> 00:24:06,960
we do pay a price because

690
00:24:06,960 --> 00:24:09,039
arguing efficiency can become quite

691
00:24:09,039 --> 00:24:11,279
hairy if you cannot rely on

692
00:24:11,279 --> 00:24:12,640
the standard reduction of the hybrid

693
00:24:12,640 --> 00:24:14,640
lemma and actually when proving the

694
00:24:14,640 --> 00:24:17,279
hybrid lemma one one has to go through

695
00:24:17,279 --> 00:24:20,000
quite a bit of technical details

696
00:24:20,000 --> 00:24:22,480
and to see that things work out

697
00:24:22,480 --> 00:24:24,799
and this finishes the talk thank you for

698
00:24:24,799 --> 00:24:26,640
watching and you can see the full paper

699
00:24:26,640 --> 00:24:29,799
on apron

