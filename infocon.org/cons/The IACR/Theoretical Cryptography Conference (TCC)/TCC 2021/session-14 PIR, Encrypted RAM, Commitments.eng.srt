1
00:00:08,720 --> 00:00:11,360
so let's jump right in uh let me start

2
00:00:11,360 --> 00:00:13,360
by reminding you what private

3
00:00:13,360 --> 00:00:16,480
information retrieval is

4
00:00:16,480 --> 00:00:18,880
this is a setting where you have a

5
00:00:18,880 --> 00:00:21,039
server with a database which for

6
00:00:21,039 --> 00:00:22,800
simplicity will think of as just a

7
00:00:22,800 --> 00:00:24,400
string of bits

8
00:00:24,400 --> 00:00:26,800
and a client that wants to fetch one of

9
00:00:26,800 --> 00:00:29,039
these entries in the database without

10
00:00:29,039 --> 00:00:31,519
the server learning which entry was

11
00:00:31,519 --> 00:00:32,640
fetched

12
00:00:32,640 --> 00:00:35,280
and the point is we want a non-trivial

13
00:00:35,280 --> 00:00:37,600
protocol which is better than in terms

14
00:00:37,600 --> 00:00:39,440
of bandwidth

15
00:00:39,440 --> 00:00:41,360
better than the client just downloading

16
00:00:41,360 --> 00:00:43,360
the entire database to get the bit that

17
00:00:43,360 --> 00:00:44,960
it wants

18
00:00:44,960 --> 00:00:47,039
the first solutions were

19
00:00:47,039 --> 00:00:49,680
relied on multiple non-convening servers

20
00:00:49,680 --> 00:00:51,199
but then

21
00:00:51,199 --> 00:00:53,039
just a few years after the notion was

22
00:00:53,039 --> 00:00:54,239
introduced

23
00:00:54,239 --> 00:00:56,079
uh crucial evidence in ostrovsky showed

24
00:00:56,079 --> 00:00:58,320
that you can do that using cryptography

25
00:00:58,320 --> 00:00:59,280
also

26
00:00:59,280 --> 00:01:01,920
uh in the single server setting and

27
00:01:01,920 --> 00:01:05,199
since then there was a ton of work on uh

28
00:01:05,199 --> 00:01:06,560
research and private information

29
00:01:06,560 --> 00:01:08,080
material

30
00:01:08,080 --> 00:01:10,240
in this work we are looking at these

31
00:01:10,240 --> 00:01:12,799
protocols with a little bit of a twist

32
00:01:12,799 --> 00:01:14,880
uh we're looking at the setting where

33
00:01:14,880 --> 00:01:17,200
the client wants any

34
00:01:17,200 --> 00:01:19,840
entry a random entry from the database

35
00:01:19,840 --> 00:01:21,840
not any specific one

36
00:01:21,840 --> 00:01:23,920
but it's still important that the server

37
00:01:23,920 --> 00:01:26,720
doesn't know which one was retrieved

38
00:01:26,720 --> 00:01:29,680
so think of a lottery you have people

39
00:01:29,680 --> 00:01:31,840
registering with the server and

40
00:01:31,840 --> 00:01:33,840
depositing their address telephone

41
00:01:33,840 --> 00:01:36,000
number or contact information then the

42
00:01:36,000 --> 00:01:38,880
client needs to choose a random

43
00:01:38,880 --> 00:01:41,759
participant to get the uh jackpot but

44
00:01:41,759 --> 00:01:43,520
they you don't want the server to know

45
00:01:43,520 --> 00:01:45,600
who was chosen because

46
00:01:45,600 --> 00:01:47,360
i don't know maybe the server operator

47
00:01:47,360 --> 00:01:49,840
will then go and blackmail something

48
00:01:49,840 --> 00:01:52,479
um so this is the type of thing that we

49
00:01:52,479 --> 00:01:54,640
want to do we call it a random index

50
00:01:54,640 --> 00:01:57,840
spiral up here for short

51
00:01:57,840 --> 00:02:01,280
uh why looking at this well

52
00:02:01,280 --> 00:02:03,200
for one thing it's a weaker primitive so

53
00:02:03,200 --> 00:02:05,439
maybe you can think that it's easier to

54
00:02:05,439 --> 00:02:07,600
build maybe you can do it more efficient

55
00:02:07,600 --> 00:02:09,679
or with your assumptions or more

56
00:02:09,679 --> 00:02:11,840
settings and things like that

57
00:02:11,840 --> 00:02:14,319
on the other hand it's also uh

58
00:02:14,319 --> 00:02:16,480
sufficient for some applications

59
00:02:16,480 --> 00:02:17,760
so the

60
00:02:17,760 --> 00:02:19,040
lottery application that i just

61
00:02:19,040 --> 00:02:20,400
described

62
00:02:20,400 --> 00:02:23,280
the motivating application for us was uh

63
00:02:23,280 --> 00:02:25,760
a way to use it in this uh secrets on a

64
00:02:25,760 --> 00:02:28,400
blockchain architecture of the community

65
00:02:28,400 --> 00:02:31,200
from last year's tcc

66
00:02:31,200 --> 00:02:33,599
uh and in this work we did uh two things

67
00:02:33,599 --> 00:02:35,040
that are essentially orthogonal to each

68
00:02:35,040 --> 00:02:37,440
other one looking at rpm as a primitive

69
00:02:37,440 --> 00:02:39,200
in its own right and asking the type of

70
00:02:39,200 --> 00:02:40,560
questions that you ask about new

71
00:02:40,560 --> 00:02:41,519
primitive

72
00:02:41,519 --> 00:02:44,080
and the other one uh looking at how to

73
00:02:44,080 --> 00:02:46,160
use it in the context of the application

74
00:02:46,160 --> 00:02:48,239
to secrets in a blockchain

75
00:02:48,239 --> 00:02:50,000
and i'll say a few words about each of

76
00:02:50,000 --> 00:02:51,200
them

77
00:02:51,200 --> 00:02:53,440
so as a primitive well we provide

78
00:02:53,440 --> 00:02:55,519
definitions but only in the semi honest

79
00:02:55,519 --> 00:02:57,599
it's actually quite non-trivial to

80
00:02:57,599 --> 00:02:59,840
figure out even what is it that you want

81
00:02:59,840 --> 00:03:01,680
uh if you were to define it as a

82
00:03:01,680 --> 00:03:03,200
primitive in the malicious setting so we

83
00:03:03,200 --> 00:03:04,560
don't do that

84
00:03:04,560 --> 00:03:06,560
uh it's not still open

85
00:03:06,560 --> 00:03:08,959
uh we show that it's actually equivalent

86
00:03:08,959 --> 00:03:10,480
to here

87
00:03:10,480 --> 00:03:12,480
so you cannot really hope to achieve it

88
00:03:12,480 --> 00:03:14,879
from weaker assumptions for example

89
00:03:14,879 --> 00:03:17,440
you can build here from our pier

90
00:03:17,440 --> 00:03:18,720
up to a small increase in the

91
00:03:18,720 --> 00:03:20,879
communication rounds

92
00:03:20,879 --> 00:03:22,480
and the bandwidth

93
00:03:22,480 --> 00:03:23,760
on the other hand there are settings

94
00:03:23,760 --> 00:03:26,000
where you can do rpl where you cannot do

95
00:03:26,000 --> 00:03:27,760
here for example one of them that we

96
00:03:27,760 --> 00:03:30,080
show is a non-interactive setting well

97
00:03:30,080 --> 00:03:32,799
perhaps you have a one-time setup

98
00:03:32,799 --> 00:03:35,599
uh before the database and then and

99
00:03:35,599 --> 00:03:37,519
anything else are known

100
00:03:37,519 --> 00:03:39,840
uh but after that every time the server

101
00:03:39,840 --> 00:03:41,840
that server wants to give a random entry

102
00:03:41,840 --> 00:03:43,680
to the client they just send a single

103
00:03:43,680 --> 00:03:46,640
message to the client and that's it

104
00:03:46,640 --> 00:03:49,440
and the specific techniques that we use

105
00:03:49,440 --> 00:03:51,680
have a cute little application to peer

106
00:03:51,680 --> 00:03:53,519
with preprocessing which you can find in

107
00:03:53,519 --> 00:03:55,840
paper

108
00:03:56,080 --> 00:03:58,799
let me give you just a taste of how you

109
00:03:58,799 --> 00:04:01,280
show that rpl and p are equivalent so

110
00:04:01,280 --> 00:04:03,120
this is a very simple protocol for

111
00:04:03,120 --> 00:04:05,519
building full-blown peer out of an rp

112
00:04:05,519 --> 00:04:06,560
protocol

113
00:04:06,560 --> 00:04:08,480
so what you want is appear so the client

114
00:04:08,480 --> 00:04:10,400
has a particular index i that it wants

115
00:04:10,400 --> 00:04:12,400
to fetch but what you have at your

116
00:04:12,400 --> 00:04:15,040
disposal up here so you just run it and

117
00:04:15,040 --> 00:04:17,600
and the client gets some other index j

118
00:04:17,600 --> 00:04:19,918
not necessarily the same as i

119
00:04:19,918 --> 00:04:22,639
uh then it just computes the exclusive

120
00:04:22,639 --> 00:04:25,199
or of the two indexes think of them as

121
00:04:25,199 --> 00:04:26,840
log n bit

122
00:04:26,840 --> 00:04:30,240
strings send that delta to the server

123
00:04:30,240 --> 00:04:33,040
uh what that does is it lets the server

124
00:04:33,040 --> 00:04:34,400
partition the

125
00:04:34,400 --> 00:04:36,800
entries into n over two pairs

126
00:04:36,800 --> 00:04:39,280
and then the server can just send the xo

127
00:04:39,280 --> 00:04:41,120
two bits in each pair back to the client

128
00:04:41,120 --> 00:04:43,360
that's n over two bits and the client

129
00:04:43,360 --> 00:04:46,080
can then get the bit that it wanted

130
00:04:46,080 --> 00:04:47,759
so it adds two more rounds of

131
00:04:47,759 --> 00:04:49,759
communication log n b's from the client

132
00:04:49,759 --> 00:04:51,520
and n over two bits from the server so

133
00:04:51,520 --> 00:04:54,000
it's an already a non-trivial uh

134
00:04:54,000 --> 00:04:56,080
protocol and you can recurse on that if

135
00:04:56,080 --> 00:04:59,520
you want to get better performance

136
00:04:59,680 --> 00:05:02,000
uh let me spend a few minutes say

137
00:05:02,000 --> 00:05:03,600
talking about the application to secrets

138
00:05:03,600 --> 00:05:05,600
on the blockchain so in that context

139
00:05:05,600 --> 00:05:07,360
blockchain is just a code word for a

140
00:05:07,360 --> 00:05:09,280
system with a huge number of nodes

141
00:05:09,280 --> 00:05:12,639
honest majority and a broadcast channel

142
00:05:12,639 --> 00:05:14,479
and in this kind of a setting we want to

143
00:05:14,479 --> 00:05:18,000
implement mpc as a server or vss as a

144
00:05:18,000 --> 00:05:19,520
service if you would

145
00:05:19,520 --> 00:05:21,759
uh and it's important that the

146
00:05:21,759 --> 00:05:23,840
communication is sub-linear in number of

147
00:05:23,840 --> 00:05:25,520
nodes because the number of nodes is

148
00:05:25,520 --> 00:05:27,360
huge

149
00:05:27,360 --> 00:05:29,919
uh so a natural thing to try is to have

150
00:05:29,919 --> 00:05:31,680
the work done by a small random

151
00:05:31,680 --> 00:05:33,759
committee which is sub sample from the

152
00:05:33,759 --> 00:05:35,520
entire universe

153
00:05:35,520 --> 00:05:37,520
but we want resilience against some kind

154
00:05:37,520 --> 00:05:39,440
of a mobile address at least a mobile

155
00:05:39,440 --> 00:05:41,360
fail stop i just say that as soon as it

156
00:05:41,360 --> 00:05:43,600
knows that some node has a role it can

157
00:05:43,600 --> 00:05:46,800
kill it with a denial of services

158
00:05:46,800 --> 00:05:49,199
and the approach is to run a dynamically

159
00:05:49,199 --> 00:05:51,039
changing set of committees

160
00:05:51,039 --> 00:05:53,120
where each committee is anonymous to the

161
00:05:53,120 --> 00:05:54,960
adversary until they do the job then

162
00:05:54,960 --> 00:05:57,280
they broadcast a message uh and then

163
00:05:57,280 --> 00:05:59,199
they're off the the hook so there's no

164
00:05:59,199 --> 00:06:00,720
point in the adversary trying to kill

165
00:06:00,720 --> 00:06:04,080
them anymore uh it also goes by the

166
00:06:04,080 --> 00:06:06,800
code name yoso which was a paper from

167
00:06:06,800 --> 00:06:09,120
crypto this year

168
00:06:09,120 --> 00:06:11,120
uh but when you want to implement this

169
00:06:11,120 --> 00:06:13,360
thing there is a challenge and you need

170
00:06:13,360 --> 00:06:14,720
to

171
00:06:14,720 --> 00:06:16,960
to make it possible for people to send

172
00:06:16,960 --> 00:06:19,600
messages to future committees so anybody

173
00:06:19,600 --> 00:06:21,039
should be able to send an encrypted

174
00:06:21,039 --> 00:06:22,800
message to the if party in the next

175
00:06:22,800 --> 00:06:24,479
committee but without actually knowing

176
00:06:24,479 --> 00:06:26,560
who that is

177
00:06:26,560 --> 00:06:28,720
uh and how to establish these uh

178
00:06:28,720 --> 00:06:30,560
channels is difficult and the difficult

179
00:06:30,560 --> 00:06:32,800
part is to actually choose who is the

180
00:06:32,800 --> 00:06:34,560
target of that channel this anonymous

181
00:06:34,560 --> 00:06:35,759
channel

182
00:06:35,759 --> 00:06:38,080
and the way you can do that

183
00:06:38,080 --> 00:06:38,880
uh

184
00:06:38,880 --> 00:06:39,680
is

185
00:06:39,680 --> 00:06:43,919
you can actually run an rpl under an mpc

186
00:06:43,919 --> 00:06:46,639
so that way you get sub-linear

187
00:06:46,639 --> 00:06:49,919
communication because the rpl has

188
00:06:49,919 --> 00:06:52,240
a lot not a lot of communication

189
00:06:52,240 --> 00:06:54,000
and you get anonymity against the

190
00:06:54,000 --> 00:06:55,440
adversary because this previous

191
00:06:55,440 --> 00:06:56,880
committee was mostly honest and the

192
00:06:56,880 --> 00:06:58,000
other side doesn't know what the

193
00:06:58,000 --> 00:07:00,160
committee as a whole chose

194
00:07:00,160 --> 00:07:02,720
uh let me just mention that here you

195
00:07:02,720 --> 00:07:04,639
require uh

196
00:07:04,639 --> 00:07:07,280
rpo with small client circuit

197
00:07:07,280 --> 00:07:09,199
which is almost the same as a small

198
00:07:09,199 --> 00:07:11,120
bandwidth but not exactly the same but

199
00:07:11,120 --> 00:07:12,880
this is it's a little bit stronger

200
00:07:12,880 --> 00:07:14,560
requirement

201
00:07:14,560 --> 00:07:17,440
um okay that's all i wanted to say thank

202
00:07:17,440 --> 00:07:19,890
you this uh available on it

203
00:07:19,890 --> 00:07:23,050
[Applause]

204
00:07:24,080 --> 00:07:26,800
any questions

205
00:07:28,240 --> 00:07:31,840
okay are there any questions in the chat

206
00:07:34,400 --> 00:07:36,080
no not currently

207
00:07:36,080 --> 00:07:39,080
okay

208
00:08:08,960 --> 00:08:10,960
okay so the second talk is on forward

209
00:08:10,960 --> 00:08:13,120
secret encrypted ram lower bounds and

210
00:08:13,120 --> 00:08:14,319
applications

211
00:08:14,319 --> 00:08:16,720
by alex and joint work with evgeny and

212
00:08:16,720 --> 00:08:19,680
kevin and alex

213
00:08:21,120 --> 00:08:22,800
okay yeah uh thank you for the

214
00:08:22,800 --> 00:08:25,280
introduction uh thanks for coming to my

215
00:08:25,280 --> 00:08:29,679
talk uh so first uh

216
00:08:32,240 --> 00:08:34,880
okay so what is forward secret encrypted

217
00:08:34,880 --> 00:08:38,399
ram or fse ram uh well it's a primitive

218
00:08:38,399 --> 00:08:41,279
that has been extensively studied for

219
00:08:41,279 --> 00:08:43,279
the past few decades

220
00:08:43,279 --> 00:08:45,680
and basically the goal is to privately

221
00:08:45,680 --> 00:08:48,320
and forward secrets secretly outsource

222
00:08:48,320 --> 00:08:50,880
the storage of a large data array using

223
00:08:50,880 --> 00:08:53,600
small local client storage

224
00:08:53,600 --> 00:08:55,360
so what does this mean uh more

225
00:08:55,360 --> 00:08:57,760
specifically the adversary

226
00:08:57,760 --> 00:09:00,080
always sees the server storage

227
00:09:00,080 --> 00:09:03,040
and we want forward secrecy meaning that

228
00:09:03,040 --> 00:09:05,120
if the adversary additionally leaks the

229
00:09:05,120 --> 00:09:06,720
client storage

230
00:09:06,720 --> 00:09:08,560
although everything that is currently

231
00:09:08,560 --> 00:09:11,120
stored will of course be revealed uh we

232
00:09:11,120 --> 00:09:13,120
want everything that has since been

233
00:09:13,120 --> 00:09:17,279
overwritten or deleted uh to be secure

234
00:09:17,279 --> 00:09:19,279
okay and of course we want efficient

235
00:09:19,279 --> 00:09:20,720
reads and rights

236
00:09:20,720 --> 00:09:23,040
and we want to use practical

237
00:09:23,040 --> 00:09:25,839
namely symmetric crypto

238
00:09:25,839 --> 00:09:28,320
okay so yeah there's a folklore solution

239
00:09:28,320 --> 00:09:30,959
that has existed for a long time

240
00:09:30,959 --> 00:09:33,760
uh and so if we have eight data elements

241
00:09:33,760 --> 00:09:35,360
in our array like this

242
00:09:35,360 --> 00:09:38,320
uh basically we have a tree based

243
00:09:38,320 --> 00:09:40,000
solution where

244
00:09:40,000 --> 00:09:42,959
the client stores this key k epsilon uh

245
00:09:42,959 --> 00:09:44,240
at the root

246
00:09:44,240 --> 00:09:47,440
uh and it encrypts its two children

247
00:09:47,440 --> 00:09:50,000
k zero and k one and we store these

248
00:09:50,000 --> 00:09:52,640
ciphertexts on the server

249
00:09:52,640 --> 00:09:55,279
and then we go down the tree so k0

250
00:09:55,279 --> 00:09:56,320
encrypts

251
00:09:56,320 --> 00:09:58,800
keys at its two children as well

252
00:09:58,800 --> 00:10:01,680
until we have basically at the leaves

253
00:10:01,680 --> 00:10:03,839
encryptions of the data

254
00:10:03,839 --> 00:10:05,360
by the keys

255
00:10:05,360 --> 00:10:07,440
at their parents and

256
00:10:07,440 --> 00:10:09,360
yeah basically we store

257
00:10:09,360 --> 00:10:10,720
this whole tree

258
00:10:10,720 --> 00:10:12,720
except for the root on the server and

259
00:10:12,720 --> 00:10:15,440
the client uh stores this route

260
00:10:15,440 --> 00:10:17,360
okay so how do we read let's say we want

261
00:10:17,360 --> 00:10:20,320
to read element four and of course we

262
00:10:20,320 --> 00:10:23,279
just simply download the uh ciphertext

263
00:10:23,279 --> 00:10:24,800
on the direct path

264
00:10:24,800 --> 00:10:27,040
uh of cell four to the root and just

265
00:10:27,040 --> 00:10:28,800
decrypt down the path

266
00:10:28,800 --> 00:10:30,640
okay so of course this is nice

267
00:10:30,640 --> 00:10:32,880
logarithmic overhead

268
00:10:32,880 --> 00:10:34,959
and now how do we write so let's say we

269
00:10:34,959 --> 00:10:37,680
want to overwrite the fourth cell with

270
00:10:37,680 --> 00:10:39,440
data d4 prime

271
00:10:39,440 --> 00:10:41,440
basically we just decrypt the code path

272
00:10:41,440 --> 00:10:43,200
so we get these

273
00:10:43,200 --> 00:10:44,959
green guys here

274
00:10:44,959 --> 00:10:47,360
forget everything else and then just

275
00:10:47,360 --> 00:10:50,079
resample the keys so k zero one prime k

276
00:10:50,079 --> 00:10:52,480
zero prime and k epsilon prime and just

277
00:10:52,480 --> 00:10:55,360
re-encrypt uh uh the two children of all

278
00:10:55,360 --> 00:10:58,720
these keys uh replacing d4 prime uh of

279
00:10:58,720 --> 00:11:00,480
course

280
00:11:00,480 --> 00:11:02,720
okay so of course this is also uh

281
00:11:02,720 --> 00:11:04,800
logarithmic complexity

282
00:11:04,800 --> 00:11:06,079
uh and

283
00:11:06,079 --> 00:11:07,920
of course we have forward secrecy

284
00:11:07,920 --> 00:11:08,880
because

285
00:11:08,880 --> 00:11:12,079
all information on d4 is gone since you

286
00:11:12,079 --> 00:11:13,360
know the parent

287
00:11:13,360 --> 00:11:15,920
the key at the parent of d4 is gone and

288
00:11:15,920 --> 00:11:17,920
inductively up the tree uh everything

289
00:11:17,920 --> 00:11:20,800
along the path is gone

290
00:11:20,800 --> 00:11:24,240
okay so uh for efficiency uh if we

291
00:11:24,240 --> 00:11:26,480
assume we have client storage big-o of s

292
00:11:26,480 --> 00:11:27,440
meaning

293
00:11:27,440 --> 00:11:29,440
the client can store

294
00:11:29,440 --> 00:11:32,399
s keys then basically we can just have

295
00:11:32,399 --> 00:11:34,800
s of these trees and we have big o of n

296
00:11:34,800 --> 00:11:36,800
server storage and

297
00:11:36,800 --> 00:11:39,120
log n over s overhead for reads and

298
00:11:39,120 --> 00:11:40,640
writes

299
00:11:40,640 --> 00:11:42,480
so the main question that we answer in

300
00:11:42,480 --> 00:11:43,839
this work is

301
00:11:43,839 --> 00:11:46,560
is this optimal and this was unknown for

302
00:11:46,560 --> 00:11:49,200
two plus decades and our answer in this

303
00:11:49,200 --> 00:11:51,120
work is yes

304
00:11:51,120 --> 00:11:53,120
uh so i'll give some high level

305
00:11:53,120 --> 00:11:54,959
intuition first starting with the model

306
00:11:54,959 --> 00:11:56,720
that we use

307
00:11:56,720 --> 00:11:57,760
so

308
00:11:57,760 --> 00:12:00,000
sort of the holy grail in private data

309
00:12:00,000 --> 00:12:02,320
structure lower bounds is this cell

310
00:12:02,320 --> 00:12:04,000
probe model

311
00:12:04,000 --> 00:12:06,160
but it turned out for our case

312
00:12:06,160 --> 00:12:09,040
that this model was a bit too powerful

313
00:12:09,040 --> 00:12:12,160
and basically so in this model uh the

314
00:12:12,160 --> 00:12:13,600
protocol

315
00:12:13,600 --> 00:12:15,600
is essentially only charged for cell

316
00:12:15,600 --> 00:12:18,079
probes meaning basically the number of

317
00:12:18,079 --> 00:12:19,600
uh

318
00:12:19,600 --> 00:12:21,920
cells that it downloads from the server

319
00:12:21,920 --> 00:12:24,399
but besides from that uh it can actually

320
00:12:24,399 --> 00:12:27,200
have unbounded computation so

321
00:12:27,200 --> 00:12:29,839
there's like a trivial solution for uh

322
00:12:29,839 --> 00:12:31,600
fse ram

323
00:12:31,600 --> 00:12:33,760
okay and another model that's been used

324
00:12:33,760 --> 00:12:35,920
is the balls and built balls and bins

325
00:12:35,920 --> 00:12:38,240
model uh but it's actually too weak for

326
00:12:38,240 --> 00:12:39,279
us

327
00:12:39,279 --> 00:12:41,120
and that's because essentially it only

328
00:12:41,120 --> 00:12:44,000
allows encrypted data to be stored on

329
00:12:44,000 --> 00:12:47,360
the server so for example you can't

330
00:12:47,360 --> 00:12:49,200
encrypt other keys and store them on the

331
00:12:49,200 --> 00:12:50,160
server

332
00:12:50,160 --> 00:12:51,839
so then even the folklore construction

333
00:12:51,839 --> 00:12:53,600
was not captured

334
00:12:53,600 --> 00:12:56,000
okay so instead we use the symbolic

335
00:12:56,000 --> 00:12:56,959
model

336
00:12:56,959 --> 00:12:59,680
which is sort of a perfect in between

337
00:12:59,680 --> 00:13:01,839
uh and in this model

338
00:13:01,839 --> 00:13:04,079
server cells can hold strings that are

339
00:13:04,079 --> 00:13:06,399
arbitrarily derived from some structured

340
00:13:06,399 --> 00:13:07,839
grammar

341
00:13:07,839 --> 00:13:10,560
so this includes encryption and you know

342
00:13:10,560 --> 00:13:12,800
possibly dual prf keys

343
00:13:12,800 --> 00:13:15,360
uh the data entries themselves

344
00:13:15,360 --> 00:13:17,279
arbitrarily nested encryptions of the

345
00:13:17,279 --> 00:13:18,399
above

346
00:13:18,399 --> 00:13:21,279
and also secret shares of the above

347
00:13:21,279 --> 00:13:23,200
uh so yeah we we

348
00:13:23,200 --> 00:13:25,120
encompass the folklore construction of

349
00:13:25,120 --> 00:13:27,279
course and also hopefully things that

350
00:13:27,279 --> 00:13:30,480
are more general uh and also yeah we

351
00:13:30,480 --> 00:13:32,959
don't allow trivial protocols as in the

352
00:13:32,959 --> 00:13:35,279
cell probe model

353
00:13:35,279 --> 00:13:37,680
okay so some very high level intuition

354
00:13:37,680 --> 00:13:39,440
for the main theorem

355
00:13:39,440 --> 00:13:42,240
uh the first step is we abstract the

356
00:13:42,240 --> 00:13:46,320
keys data in cipher text into some graph

357
00:13:46,320 --> 00:13:48,800
and for this talk i will just ignore

358
00:13:48,800 --> 00:13:50,880
secret sharing uh

359
00:13:50,880 --> 00:13:53,279
but basically the keys and the data

360
00:13:53,279 --> 00:13:55,600
items in this graph are the vertices

361
00:13:55,600 --> 00:13:57,920
uh and let's say we have some nested

362
00:13:57,920 --> 00:13:59,040
encryption

363
00:13:59,040 --> 00:14:01,839
uh of a cure data then basically for

364
00:14:01,839 --> 00:14:03,760
each key that is actually used to

365
00:14:03,760 --> 00:14:04,800
encrypt

366
00:14:04,800 --> 00:14:07,600
uh we have an edge from that key to

367
00:14:07,600 --> 00:14:10,000
the plain text so the data or key that's

368
00:14:10,000 --> 00:14:11,920
the plain text

369
00:14:11,920 --> 00:14:14,959
okay uh and so in this graph we'll have

370
00:14:14,959 --> 00:14:18,240
basically s sources which correspond to

371
00:14:18,240 --> 00:14:20,720
the keys in the client storage and n

372
00:14:20,720 --> 00:14:24,480
syncs which correspond to the data items

373
00:14:24,480 --> 00:14:27,440
okay and so then with this graph we

374
00:14:27,440 --> 00:14:28,800
prove

375
00:14:28,800 --> 00:14:30,959
actually a general graph theoretic lemma

376
00:14:30,959 --> 00:14:33,839
on graphs of this form uh which says

377
00:14:33,839 --> 00:14:36,800
that the expected indegree of a random

378
00:14:36,800 --> 00:14:39,440
source to sync path is big omega log n

379
00:14:39,440 --> 00:14:40,560
over s

380
00:14:40,560 --> 00:14:43,519
i mean roughly something like this

381
00:14:43,519 --> 00:14:45,760
okay and so then the theorem is

382
00:14:45,760 --> 00:14:48,399
basically composing these ideas

383
00:14:48,399 --> 00:14:51,120
and we say that uh every protocol must

384
00:14:51,120 --> 00:14:53,519
produce a graph of this form after each

385
00:14:53,519 --> 00:14:54,480
writes

386
00:14:54,480 --> 00:14:56,800
and then basically an in degree to to a

387
00:14:56,800 --> 00:15:00,320
random sync is essentially equal to uh

388
00:15:00,320 --> 00:15:02,320
the overhead needed to

389
00:15:02,320 --> 00:15:04,880
overwrite a random data element at a

390
00:15:04,880 --> 00:15:06,880
sink

391
00:15:06,880 --> 00:15:10,000
okay so in addition to this

392
00:15:10,000 --> 00:15:12,399
lower bound we also show some

393
00:15:12,399 --> 00:15:14,399
applications which in some sense

394
00:15:14,399 --> 00:15:16,880
circumvent this lower bound

395
00:15:16,880 --> 00:15:20,800
okay and so we focus on other primitives

396
00:15:20,800 --> 00:15:23,199
that have uh efficient

397
00:15:23,199 --> 00:15:25,680
log n tree based constructions and

398
00:15:25,680 --> 00:15:29,199
basically add forward secrecy to them

399
00:15:29,199 --> 00:15:31,519
so first we start with uh forward secret

400
00:15:31,519 --> 00:15:33,040
memory checkers

401
00:15:33,040 --> 00:15:34,959
where memory checkers you can

402
00:15:34,959 --> 00:15:37,600
essentially imagine a miracle tree so

403
00:15:37,600 --> 00:15:39,440
they guarantee the

404
00:15:39,440 --> 00:15:41,920
integrity of the outsourced data right

405
00:15:41,920 --> 00:15:44,399
and we just uh yeah add forward secrecy

406
00:15:44,399 --> 00:15:46,560
to this as well

407
00:15:46,560 --> 00:15:48,800
okay then uh we also have oblivious

408
00:15:48,800 --> 00:15:52,720
forward secret encrypted ram uh where

409
00:15:52,720 --> 00:15:56,639
we hide access patterns to the data

410
00:15:56,639 --> 00:15:59,920
and also add for forward secrecy here

411
00:15:59,920 --> 00:16:02,320
and finally uh forward secret multicast

412
00:16:02,320 --> 00:16:03,440
encryption

413
00:16:03,440 --> 00:16:06,000
uh where multicast is basically a

414
00:16:06,000 --> 00:16:08,560
dynamic group key agreement primitive uh

415
00:16:08,560 --> 00:16:11,440
with an omnipotent group manager so a

416
00:16:11,440 --> 00:16:13,120
group manager that performs all

417
00:16:13,120 --> 00:16:14,399
operations

418
00:16:14,399 --> 00:16:17,040
and we add a forward secrecy

419
00:16:17,040 --> 00:16:19,600
to this primitive as well and also allow

420
00:16:19,600 --> 00:16:22,639
the group manager to have small uh local

421
00:16:22,639 --> 00:16:23,920
storage

422
00:16:23,920 --> 00:16:26,160
and yeah i refer you to the full paper

423
00:16:26,160 --> 00:16:28,959
for details and all those

424
00:16:28,959 --> 00:16:31,759
okay and so the naive composition of

425
00:16:31,759 --> 00:16:34,320
basically just doing our forward secret

426
00:16:34,320 --> 00:16:36,399
encrypted ram on top of

427
00:16:36,399 --> 00:16:37,759
the structures

428
00:16:37,759 --> 00:16:39,759
uh already existing in the protocols

429
00:16:39,759 --> 00:16:41,839
through these primitives would result in

430
00:16:41,839 --> 00:16:43,199
log squared

431
00:16:43,199 --> 00:16:44,800
overhead of course

432
00:16:44,800 --> 00:16:46,720
and so then basically our main intuition

433
00:16:46,720 --> 00:16:48,800
is just to carefully

434
00:16:48,800 --> 00:16:52,399
over overlay the uh fse ram tree

435
00:16:52,399 --> 00:16:54,480
with the tree that is already existent

436
00:16:54,480 --> 00:16:56,720
in the corresponding constructions

437
00:16:56,720 --> 00:16:59,199
to get uh login overhead

438
00:16:59,199 --> 00:17:01,839
so i guess just pictorially

439
00:17:01,839 --> 00:17:04,480
if the red tree is the primitives tree

440
00:17:04,480 --> 00:17:06,559
and the blue tree is the fse ram tree we

441
00:17:06,559 --> 00:17:08,240
sort of just combine them to get this

442
00:17:08,240 --> 00:17:10,079
purple tree

443
00:17:10,079 --> 00:17:15,079
okay thanks that's it for today

444
00:17:22,819 --> 00:17:24,319
[Music]

445
00:17:24,319 --> 00:17:25,919
yeah i mean in fact there's actually

446
00:17:25,919 --> 00:17:27,359
like uh sorry can you repeat the

447
00:17:27,359 --> 00:17:29,919
question oh uh he he was asking if uh

448
00:17:29,919 --> 00:17:32,240
the lower bound can be circumvented

449
00:17:32,240 --> 00:17:34,799
using like stronger primitives um and

450
00:17:34,799 --> 00:17:36,160
yeah i mean

451
00:17:36,160 --> 00:17:37,039
so

452
00:17:37,039 --> 00:17:38,720
for example there's like punctuable

453
00:17:38,720 --> 00:17:40,559
encryption which is like

454
00:17:40,559 --> 00:17:41,840
basically

455
00:17:41,840 --> 00:17:43,760
uh forward secret encrypted ram i guess

456
00:17:43,760 --> 00:17:46,799
like a public key version of it

457
00:17:46,799 --> 00:17:49,120
so i guess we we see

458
00:17:49,120 --> 00:17:51,440
also our result as sort of a lower bound

459
00:17:51,440 --> 00:17:54,240
from you know maybe symmetric primitives

460
00:17:54,240 --> 00:17:57,200
uh simple symmetric primitives for these

461
00:17:57,200 --> 00:18:01,039
primitives as well yeah

462
00:18:01,039 --> 00:18:03,840
any other questions

463
00:18:05,039 --> 00:18:08,039
okay

464
00:18:40,559 --> 00:18:42,559
okay the next talk is on iconic private

465
00:18:42,559 --> 00:18:44,880
set intersection and applications

466
00:18:44,880 --> 00:18:47,120
um

467
00:18:47,120 --> 00:18:49,200
who's the first speaker here

468
00:18:49,200 --> 00:18:52,200
um

469
00:18:58,400 --> 00:19:00,720
okay um yes so

470
00:19:00,720 --> 00:19:03,520
i'll talk about laconic psi

471
00:19:03,520 --> 00:19:07,120
and this is a joint work with navidad

472
00:19:07,120 --> 00:19:11,719
niko dokling sanjay muhammadin

473
00:19:14,720 --> 00:19:17,039
okay so first what is a

474
00:19:17,039 --> 00:19:18,880
laconic psi

475
00:19:18,880 --> 00:19:22,160
it is essentially a flavor of unbalanced

476
00:19:22,160 --> 00:19:23,280
psi

477
00:19:23,280 --> 00:19:25,520
where we have a small crs

478
00:19:25,520 --> 00:19:27,679
and the receiver

479
00:19:27,679 --> 00:19:29,679
on on the right

480
00:19:29,679 --> 00:19:33,280
starts by hashing a large input set into

481
00:19:33,280 --> 00:19:35,840
a small hash value h

482
00:19:35,840 --> 00:19:39,600
then the sender with a small input y

483
00:19:39,600 --> 00:19:41,440
computes a message m and this allows the

484
00:19:41,440 --> 00:19:43,280
receiver to compute

485
00:19:43,280 --> 00:19:46,799
the intersection between both sets

486
00:19:46,799 --> 00:19:48,960
okay so in terms of security as usual

487
00:19:48,960 --> 00:19:50,080
for

488
00:19:50,080 --> 00:19:52,320
psi protocols we want that the sender

489
00:19:52,320 --> 00:19:55,600
learns nothing about the receiver set

490
00:19:55,600 --> 00:19:57,840
and also that the receiver

491
00:19:57,840 --> 00:19:59,520
learns nothing about the sender set

492
00:19:59,520 --> 00:20:01,360
apart from what is leaked by the

493
00:20:01,360 --> 00:20:04,000
intersection

494
00:20:04,159 --> 00:20:06,240
in terms of communication we require

495
00:20:06,240 --> 00:20:09,360
that the size of the crs the size of the

496
00:20:09,360 --> 00:20:11,360
receiver's message and the size of the

497
00:20:11,360 --> 00:20:14,159
sender's message to depend only uh poly

498
00:20:14,159 --> 00:20:15,919
logarithmically in the size of the

499
00:20:15,919 --> 00:20:18,240
receiver set

500
00:20:18,240 --> 00:20:20,240
and in terms of computation we want that

501
00:20:20,240 --> 00:20:21,520
the uh

502
00:20:21,520 --> 00:20:24,480
key the crs generation and the sender

503
00:20:24,480 --> 00:20:27,520
algorithm to run uh also in time polygon

504
00:20:27,520 --> 00:20:28,240
in

505
00:20:28,240 --> 00:20:30,000
the size of x

506
00:20:30,000 --> 00:20:31,600
so we

507
00:20:31,600 --> 00:20:33,919
loconic psi can be useful for settings

508
00:20:33,919 --> 00:20:36,640
where for example the receiver

509
00:20:36,640 --> 00:20:39,039
is let's say a

510
00:20:39,039 --> 00:20:40,799
big tech company

511
00:20:40,799 --> 00:20:43,840
uh with a huge database and it it wants

512
00:20:43,840 --> 00:20:45,760
to perform

513
00:20:45,760 --> 00:20:48,159
psi with users

514
00:20:48,159 --> 00:20:50,240
non-interactively and with communication

515
00:20:50,240 --> 00:20:52,240
sub-linear in the in the size of the

516
00:20:52,240 --> 00:20:54,799
database

517
00:20:55,520 --> 00:20:57,520
okay so what do we know about laconic

518
00:20:57,520 --> 00:20:59,120
psi

519
00:20:59,120 --> 00:21:00,559
we know that

520
00:21:00,559 --> 00:21:03,120
laconic psi can be built from electronic

521
00:21:03,120 --> 00:21:05,120
function evaluation

522
00:21:05,120 --> 00:21:07,840
but this comes at the cost of efficiency

523
00:21:07,840 --> 00:21:08,880
and

524
00:21:08,880 --> 00:21:11,440
assuming lw with super polynomial

525
00:21:11,440 --> 00:21:14,720
modules to noise ratio

526
00:21:14,720 --> 00:21:17,039
so this raises two questions

527
00:21:17,039 --> 00:21:19,360
uh the first one is whether we can build

528
00:21:19,360 --> 00:21:22,000
volcanic psi from assumptions other than

529
00:21:22,000 --> 00:21:23,280
lw

530
00:21:23,280 --> 00:21:25,120
and the second one is

531
00:21:25,120 --> 00:21:28,000
whether we can do it

532
00:21:28,840 --> 00:21:31,039
efficiently so our first result is a

533
00:21:31,039 --> 00:21:33,360
feasibility is a feasibility result and

534
00:21:33,360 --> 00:21:36,080
here we uh show that

535
00:21:36,080 --> 00:21:38,240
we can build laconic psi

536
00:21:38,240 --> 00:21:40,240
uh secure against semi arms adversaries

537
00:21:40,240 --> 00:21:43,440
by assuming either cdh or lwb with

538
00:21:43,440 --> 00:21:46,480
polynomial modulus nice ratio

539
00:21:46,480 --> 00:21:48,320
so how do we do this

540
00:21:48,320 --> 00:21:51,280
we use a primitive called anonymous

541
00:21:51,280 --> 00:21:53,440
encryption together with this gargled

542
00:21:53,440 --> 00:21:54,720
circuit

543
00:21:54,720 --> 00:21:57,440
on merkle tree based approach

544
00:21:57,440 --> 00:22:00,000
used in many many previous works

545
00:22:00,000 --> 00:22:02,880
and in particular we show how to uh

546
00:22:02,880 --> 00:22:05,200
how to uh extend this garbled circuit

547
00:22:05,200 --> 00:22:08,159
approach to allow for uh

548
00:22:08,159 --> 00:22:10,400
to allow for binary search over a set of

549
00:22:10,400 --> 00:22:13,679
sorted values

550
00:22:13,679 --> 00:22:16,320
since anonymous hash encryption can can

551
00:22:16,320 --> 00:22:18,320
be built from either cdh or otherwise

552
00:22:18,320 --> 00:22:22,080
then so does our final protocol

553
00:22:22,080 --> 00:22:23,039
but the

554
00:22:23,039 --> 00:22:25,600
resulting protocol is not efficient

555
00:22:25,600 --> 00:22:26,960
in the sense that

556
00:22:26,960 --> 00:22:30,240
uh it makes uh non-black box use of

557
00:22:30,240 --> 00:22:32,240
cryptographic units in particular we

558
00:22:32,240 --> 00:22:34,960
need to evaluate the uh the uh the hash

559
00:22:34,960 --> 00:22:39,039
decryption inside the global circuits

560
00:22:39,039 --> 00:22:41,919
so our second result

561
00:22:41,919 --> 00:22:44,000
we showed that uh we can build an

562
00:22:44,000 --> 00:22:46,159
efficient loconic dsi

563
00:22:46,159 --> 00:22:48,320
secure against seminoles bursaries by

564
00:22:48,320 --> 00:22:50,400
assuming the fire hiding assumption and

565
00:22:50,400 --> 00:22:52,799
by efficient i mean that

566
00:22:52,799 --> 00:22:54,960
we only use black box techniques in the

567
00:22:54,960 --> 00:22:57,120
sense that we never go to the circuit

568
00:22:57,120 --> 00:22:59,520
level description of uh cryptographic

569
00:22:59,520 --> 00:23:02,158
primitives

570
00:23:02,400 --> 00:23:05,200
we then uh show how to extend this

571
00:23:05,200 --> 00:23:08,159
protocol into a reusable one where the

572
00:23:08,159 --> 00:23:10,159
first message of the receiver can be

573
00:23:10,159 --> 00:23:11,520
reused across

574
00:23:11,520 --> 00:23:13,440
several executions

575
00:23:13,440 --> 00:23:15,120
and which is secure against malicious

576
00:23:15,120 --> 00:23:18,559
senders by additionally assuming the dcr

577
00:23:18,559 --> 00:23:22,080
and the pairing based assumption

578
00:23:22,080 --> 00:23:24,000
and along the way we show

579
00:23:24,000 --> 00:23:26,400
uh how to build an efficient divi music

580
00:23:26,400 --> 00:23:28,720
scheme that allows us to prove equality

581
00:23:28,720 --> 00:23:30,320
of plaintext across different

582
00:23:30,320 --> 00:23:32,640
cryptosystems in our case the

583
00:23:32,640 --> 00:23:37,320
damgard uric and the bgn cryptosystems

584
00:23:38,240 --> 00:23:41,279
okay to conclude we show an application

585
00:23:41,279 --> 00:23:43,760
of laconic psi by building a

586
00:23:43,760 --> 00:23:45,440
primitive that we call self-detecting

587
00:23:45,440 --> 00:23:47,600
encryption

588
00:23:47,600 --> 00:23:49,600
so essentially this is a public key

589
00:23:49,600 --> 00:23:51,679
encryption scheme with one additional

590
00:23:51,679 --> 00:23:53,039
property

591
00:23:53,039 --> 00:23:56,159
it allows an authority to check if an

592
00:23:56,159 --> 00:23:58,320
encrypted plaintext is in a special

593
00:23:58,320 --> 00:24:00,000
database and we can think of this

594
00:24:00,000 --> 00:24:02,400
special database as a set of illegal

595
00:24:02,400 --> 00:24:04,480
messages right or for example illegal

596
00:24:04,480 --> 00:24:06,880
videos

597
00:24:06,880 --> 00:24:09,360
of course if the plaintext is not on the

598
00:24:09,360 --> 00:24:12,080
database then we want that uh semantic

599
00:24:12,080 --> 00:24:15,279
security is preserved

600
00:24:15,279 --> 00:24:17,520
so how can we build this from laconic

601
00:24:17,520 --> 00:24:19,120
psi

602
00:24:19,120 --> 00:24:21,840
well first the authority uses the

603
00:24:21,840 --> 00:24:24,320
lpsi hash algorithm to compress the

604
00:24:24,320 --> 00:24:26,960
database and publishes the ash

605
00:24:26,960 --> 00:24:29,279
and now every ciphertext

606
00:24:29,279 --> 00:24:31,679
is essentially a

607
00:24:31,679 --> 00:24:33,760
this message in the electronic psi

608
00:24:33,760 --> 00:24:35,200
product

609
00:24:35,200 --> 00:24:39,039
with respect to this hash value

610
00:24:39,120 --> 00:24:41,520
so now the authority can use the

611
00:24:41,520 --> 00:24:43,200
receiver's algorithm to check if the

612
00:24:43,200 --> 00:24:45,679
message is in the database

613
00:24:45,679 --> 00:24:47,440
and

614
00:24:47,440 --> 00:24:49,919
because of the security of the protocol

615
00:24:49,919 --> 00:24:51,200
of the electronic

616
00:24:51,200 --> 00:24:53,279
psi protocol it learns nothing if the

617
00:24:53,279 --> 00:24:57,279
message is not on the database

618
00:24:57,360 --> 00:24:58,720
okay that's it

619
00:24:58,720 --> 00:25:01,840
thank you

620
00:25:05,360 --> 00:25:08,678
any questions

621
00:25:15,840 --> 00:25:17,440
can you repeat the question

622
00:25:17,440 --> 00:25:20,240
so he's asking if um

623
00:25:20,240 --> 00:25:22,320
in the last application

624
00:25:22,320 --> 00:25:23,279
uh

625
00:25:23,279 --> 00:25:24,720
if the last application is secure

626
00:25:24,720 --> 00:25:28,240
against malicious authorities and

627
00:25:41,039 --> 00:25:42,880
you done it just from carbon circuits

628
00:25:42,880 --> 00:25:44,400
like

629
00:25:44,400 --> 00:25:46,640
yeah i suppose so but yeah here it's

630
00:25:46,640 --> 00:25:49,679
really about efficiency

631
00:25:51,919 --> 00:25:56,120
okay let's thank pedro again

632
00:26:24,320 --> 00:26:26,320
okay the next talk is on non-visible

633
00:26:26,320 --> 00:26:28,480
vector commitments via local

634
00:26:28,480 --> 00:26:31,679
equivocability by leo venkil and leo

635
00:26:31,679 --> 00:26:34,400
will give the talk

636
00:26:35,200 --> 00:26:36,400
okay thank you so yeah we're going to

637
00:26:36,400 --> 00:26:38,159
talk about non-multiple vector

638
00:26:38,159 --> 00:26:39,760
commitments and this is joint work with

639
00:26:39,760 --> 00:26:42,000
joe

640
00:26:43,919 --> 00:26:44,720
okay

641
00:26:44,720 --> 00:26:46,960
so vector commitments are essentially a

642
00:26:46,960 --> 00:26:48,640
vector or a commitment scheme that

643
00:26:48,640 --> 00:26:50,320
allows the sender to commit to a

644
00:26:50,320 --> 00:26:52,480
non-vector values and then at a later

645
00:26:52,480 --> 00:26:55,760
stage locally open any of the entries

646
00:26:55,760 --> 00:26:56,960
while

647
00:26:56,960 --> 00:26:59,039
retaining the hiding property for the

648
00:26:59,039 --> 00:27:01,360
remaining entries of the vector

649
00:27:01,360 --> 00:27:04,080
the security property that we want our

650
00:27:04,080 --> 00:27:05,760
commitments to satisfy his position

651
00:27:05,760 --> 00:27:08,880
binding which essentially states that

652
00:27:08,880 --> 00:27:10,559
each entry of the committed vector can

653
00:27:10,559 --> 00:27:13,919
only be opened to at most a single value

654
00:27:13,919 --> 00:27:15,520
so for example the malicious sender

655
00:27:15,520 --> 00:27:16,480
cannot

656
00:27:16,480 --> 00:27:20,559
open the second entry to both 54 and 32.

657
00:27:20,559 --> 00:27:22,559
so this can obviously be constructed

658
00:27:22,559 --> 00:27:24,880
trivially by simply committing to each

659
00:27:24,880 --> 00:27:26,399
entry of the table of the vector

660
00:27:26,399 --> 00:27:28,000
separately

661
00:27:28,000 --> 00:27:29,919
so typically we're interested in

662
00:27:29,919 --> 00:27:31,760
non-trivial constructions that are

663
00:27:31,760 --> 00:27:33,679
succinct in the sense that both the

664
00:27:33,679 --> 00:27:36,480
commitment and the local openings are

665
00:27:36,480 --> 00:27:39,200
size which is sublinear in the number

666
00:27:39,200 --> 00:27:42,559
key of elements in the iron line vector

667
00:27:42,559 --> 00:27:44,799
so perhaps the earliest construction or

668
00:27:44,799 --> 00:27:46,799
vector commitments

669
00:27:46,799 --> 00:27:49,440
are miracle trees that have constant

670
00:27:49,440 --> 00:27:51,919
size commitments this constant in the

671
00:27:51,919 --> 00:27:53,440
number of underlying elements in the

672
00:27:53,440 --> 00:27:54,399
vector

673
00:27:54,399 --> 00:27:57,200
and the openings local openings which

674
00:27:57,200 --> 00:27:58,799
are of size which is logarithmic in the

675
00:27:58,799 --> 00:28:00,720
number of key of elements

676
00:28:00,720 --> 00:28:02,480
more recent constructions based on

677
00:28:02,480 --> 00:28:05,679
algebraic or let's based assumptions uh

678
00:28:05,679 --> 00:28:07,760
can satisfy both constant size

679
00:28:07,760 --> 00:28:09,840
commitments and constant size local

680
00:28:09,840 --> 00:28:12,399
openings and they also enjoy additional

681
00:28:12,399 --> 00:28:14,880
driver properties like updatability of

682
00:28:14,880 --> 00:28:16,960
the underlying vector sub vector

683
00:28:16,960 --> 00:28:19,120
openings that allow you to somehow open

684
00:28:19,120 --> 00:28:21,200
to a sub vector more efficiently than

685
00:28:21,200 --> 00:28:24,240
simply uh opening each of its entries

686
00:28:24,240 --> 00:28:27,840
and more properties as well

687
00:28:27,840 --> 00:28:29,520
now a different

688
00:28:29,520 --> 00:28:31,679
line of research regarding commitment

689
00:28:31,679 --> 00:28:34,320
schemes that has been rigorously studied

690
00:28:34,320 --> 00:28:36,799
for the past 30 years

691
00:28:36,799 --> 00:28:38,720
is that of non-valuable commitments

692
00:28:38,720 --> 00:28:41,120
introduced by the left work and or back

693
00:28:41,120 --> 00:28:44,240
in 91 for their seminal work

694
00:28:44,240 --> 00:28:46,320
so with this work we're interested

695
00:28:46,320 --> 00:28:48,880
mainly in non-interactive commitments so

696
00:28:48,880 --> 00:28:51,360
informally uh non-violability of such

697
00:28:51,360 --> 00:28:53,679
commitments uh states that the men in

698
00:28:53,679 --> 00:28:56,320
the middle adversary that observes a

699
00:28:56,320 --> 00:28:59,120
commitment to some value v

700
00:28:59,120 --> 00:29:01,760
cannot produce a commitment to some

701
00:29:01,760 --> 00:29:03,360
value v prime which is somehow

702
00:29:03,360 --> 00:29:05,279
non-trivial related to the original

703
00:29:05,279 --> 00:29:07,200
value v

704
00:29:07,200 --> 00:29:09,760
and indeed as i mentioned this notion

705
00:29:09,760 --> 00:29:11,600
has been rigorously studied and there

706
00:29:11,600 --> 00:29:13,200
has been there have been numerous

707
00:29:13,200 --> 00:29:15,520
constructions from various assumptions

708
00:29:15,520 --> 00:29:18,480
uh satisfying various security notions

709
00:29:18,480 --> 00:29:22,000
and uh efficiency trade-offs

710
00:29:22,000 --> 00:29:23,520
now what has

711
00:29:23,520 --> 00:29:26,720
not been uh rigorously studied is the

712
00:29:26,720 --> 00:29:28,640
intersection of both of these notions of

713
00:29:28,640 --> 00:29:31,200
acidity

714
00:29:31,440 --> 00:29:33,679
overflow

715
00:29:33,679 --> 00:29:34,880
is the intersection of both of these

716
00:29:34,880 --> 00:29:36,000
notions

717
00:29:36,000 --> 00:29:37,279
which is non-malleable vector

718
00:29:37,279 --> 00:29:39,120
commitments

719
00:29:39,120 --> 00:29:40,720
so specifically

720
00:29:40,720 --> 00:29:42,720
uh the existing frameworks and security

721
00:29:42,720 --> 00:29:45,200
definitions for uh non-valuable uh

722
00:29:45,200 --> 00:29:47,039
non-interactive commitments

723
00:29:47,039 --> 00:29:50,320
uh do not take into consideration uh the

724
00:29:50,320 --> 00:29:52,480
security implications of an adversary

725
00:29:52,480 --> 00:29:55,520
that observes some local openings

726
00:29:55,520 --> 00:29:56,960
for the underlying vector before

727
00:29:56,960 --> 00:29:59,840
producing uh what he hopes is a

728
00:29:59,840 --> 00:30:02,240
commitment to a related vector

729
00:30:02,240 --> 00:30:04,799
um and it turns out that you know taking

730
00:30:04,799 --> 00:30:06,640
this into consideration is quite

731
00:30:06,640 --> 00:30:08,559
important and

732
00:30:08,559 --> 00:30:10,559
it somehow disallows

733
00:30:10,559 --> 00:30:13,279
uh some of the more trivial solutions as

734
00:30:13,279 --> 00:30:16,240
we show in the paper

735
00:30:16,399 --> 00:30:18,320
what has been studied is a related

736
00:30:18,320 --> 00:30:19,360
notion

737
00:30:19,360 --> 00:30:20,399
which is called non-valuable

738
00:30:20,399 --> 00:30:22,880
zero-knowledge sets so informally you

739
00:30:22,880 --> 00:30:24,720
can think of a zero-knowledge set as a

740
00:30:24,720 --> 00:30:26,240
vector commitment

741
00:30:26,240 --> 00:30:28,799
that supports non-membership proofs

742
00:30:28,799 --> 00:30:30,720
so the sender can prove that let's say

743
00:30:30,720 --> 00:30:35,039
32 is not in the underlying vector

744
00:30:35,039 --> 00:30:37,120
and non-valuable zero knowledge sets

745
00:30:37,120 --> 00:30:38,799
were constructed starting from the work

746
00:30:38,799 --> 00:30:41,279
of general and mikali back in 06.

747
00:30:41,279 --> 00:30:42,640
um

748
00:30:42,640 --> 00:30:44,960
but one of the problems of all of these

749
00:30:44,960 --> 00:30:46,880
constructions is that in order to

750
00:30:46,880 --> 00:30:50,080
support these uh non-membership proofs

751
00:30:50,080 --> 00:30:52,240
they rely on some intermediate notion

752
00:30:52,240 --> 00:30:53,760
which is called the multicraft or

753
00:30:53,760 --> 00:30:55,840
mercurial predator commitments

754
00:30:55,840 --> 00:30:57,679
and this is a relatively intricate

755
00:30:57,679 --> 00:31:00,240
notion just to define the syntax of this

756
00:31:00,240 --> 00:31:03,039
notion requires 11 algorithms

757
00:31:03,039 --> 00:31:05,760
and the constructions are

758
00:31:05,760 --> 00:31:08,000
complicated specifically to accommodate

759
00:31:08,000 --> 00:31:09,120
this

760
00:31:09,120 --> 00:31:12,159
functionality of non-membership proofs

761
00:31:12,159 --> 00:31:14,159
so this leads over the question of

762
00:31:14,159 --> 00:31:16,480
can we construct non-malleable vector

763
00:31:16,480 --> 00:31:18,640
commitments that do not necessarily

764
00:31:18,640 --> 00:31:20,960
accommodate uh non-merchant proofs

765
00:31:20,960 --> 00:31:23,600
within a simplified framework hopefully

766
00:31:23,600 --> 00:31:25,519
uh simplifying the construction both

767
00:31:25,519 --> 00:31:26,799
conceptually

768
00:31:26,799 --> 00:31:29,279
and maybe even gaining something

769
00:31:29,279 --> 00:31:31,679
technically

770
00:31:31,679 --> 00:31:32,399
so

771
00:31:32,399 --> 00:31:33,760
in line of this question in light of

772
00:31:33,760 --> 00:31:35,679
this question our contributions in this

773
00:31:35,679 --> 00:31:37,919
work are the following

774
00:31:37,919 --> 00:31:40,480
uh so first we put forth a notion for

775
00:31:40,480 --> 00:31:42,640
normal ability of vector commitments

776
00:31:42,640 --> 00:31:44,480
with the aim of striking a balance

777
00:31:44,480 --> 00:31:47,039
between the weaker notion of standard

778
00:31:47,039 --> 00:31:48,720
non-valuable non-interactive commitments

779
00:31:48,720 --> 00:31:50,720
that do not take into account

780
00:31:50,720 --> 00:31:53,039
uh the notion of local openings and the

781
00:31:53,039 --> 00:31:54,960
stronger notion of the normal level zero

782
00:31:54,960 --> 00:31:57,200
knowledge sets which accommodates also

783
00:31:57,200 --> 00:31:59,120
non-membership proofs which are not

784
00:31:59,120 --> 00:32:01,600
necessary for vector commitments

785
00:32:01,600 --> 00:32:03,360
uh and

786
00:32:03,360 --> 00:32:05,039
then what we do is we put forth a

787
00:32:05,039 --> 00:32:06,640
general framework for constructing

788
00:32:06,640 --> 00:32:08,399
non-valuable vcs satisfying our

789
00:32:08,399 --> 00:32:09,760
definition

790
00:32:09,760 --> 00:32:11,679
uh so essentially we show how to

791
00:32:11,679 --> 00:32:14,000
transform any vector commitment into a

792
00:32:14,000 --> 00:32:15,600
non-valuable one

793
00:32:15,600 --> 00:32:18,159
by relying on a new intermediate notion

794
00:32:18,159 --> 00:32:20,000
that we put forth which we call locally

795
00:32:20,000 --> 00:32:21,760
provokable commitments with all but one

796
00:32:21,760 --> 00:32:22,960
binding

797
00:32:22,960 --> 00:32:25,300
so this is also a mouthful but

798
00:32:25,300 --> 00:32:26,559
[Music]

799
00:32:26,559 --> 00:32:30,080
it is a simpler notion conceptually

800
00:32:30,080 --> 00:32:32,159
than multi-trapped or mercurial

801
00:32:32,159 --> 00:32:33,360
commitments

802
00:32:33,360 --> 00:32:34,480
and

803
00:32:34,480 --> 00:32:36,960
it also admits somewhat more efficient

804
00:32:36,960 --> 00:32:40,640
instantiations as we show in the paper

805
00:32:40,640 --> 00:32:43,039
and an important point is that our

806
00:32:43,039 --> 00:32:44,960
construction essentially preserves the

807
00:32:44,960 --> 00:32:46,399
efficiency of the underlying vector

808
00:32:46,399 --> 00:32:48,159
commitment both in terms of the

809
00:32:48,159 --> 00:32:50,399
commitment size and in terms of the

810
00:32:50,399 --> 00:32:52,159
local openings

811
00:32:52,159 --> 00:32:56,159
so all of this is in the extended talk

812
00:32:56,159 --> 00:32:57,600
also in the paper but not in the

813
00:32:57,600 --> 00:32:59,519
extended talk

814
00:32:59,519 --> 00:33:01,840
are a few additional contributions so

815
00:33:01,840 --> 00:33:03,039
first of all

816
00:33:03,039 --> 00:33:04,799
we consider an extension

817
00:33:04,799 --> 00:33:06,720
of our notion and construction to

818
00:33:06,720 --> 00:33:08,960
dynamic vector commitments that can be

819
00:33:08,960 --> 00:33:10,559
updated

820
00:33:10,559 --> 00:33:13,360
privately by whoever produced the vector

821
00:33:13,360 --> 00:33:14,399
commitment

822
00:33:14,399 --> 00:33:16,000
and we also show that merkle trees

823
00:33:16,000 --> 00:33:17,840
satisfy our notion of normal ability in

824
00:33:17,840 --> 00:33:19,440
the random oracle model

825
00:33:19,440 --> 00:33:21,200
uh which is not the case in the standard

826
00:33:21,200 --> 00:33:23,200
model essentially due to the potential

827
00:33:23,200 --> 00:33:24,720
malleability of the underlying hash

828
00:33:24,720 --> 00:33:25,919
function

829
00:33:25,919 --> 00:33:27,039
and finally we discussed our

830
00:33:27,039 --> 00:33:28,640
applications

831
00:33:28,640 --> 00:33:29,919
both for

832
00:33:29,919 --> 00:33:31,679
cross-transaction independence in

833
00:33:31,679 --> 00:33:33,760
blockchains and for simultaneous

834
00:33:33,760 --> 00:33:36,640
multi-run options

835
00:33:36,640 --> 00:33:41,480
okay so with that with it thank you

836
00:34:05,039 --> 00:34:06,640
could you repeat the question please for

837
00:34:06,640 --> 00:34:08,320
those of us online

838
00:34:08,320 --> 00:34:10,159
yeah so the question was what notion of

839
00:34:10,159 --> 00:34:12,560
normal ability to consider or consider

840
00:34:12,560 --> 00:34:14,239
one-to-one non-emolliability or

841
00:34:14,239 --> 00:34:15,280
many-to-one

842
00:34:15,280 --> 00:34:16,560
essentially

843
00:34:16,560 --> 00:34:17,679
whether the

844
00:34:17,679 --> 00:34:19,440
adversary observes one commitment or

845
00:34:19,440 --> 00:34:21,839
many commitments before producing

846
00:34:21,839 --> 00:34:24,560
their own commitment so in this work

847
00:34:24,560 --> 00:34:27,520
we study one to one valuability believe

848
00:34:27,520 --> 00:34:29,359
over the question of the

849
00:34:29,359 --> 00:34:30,480
many to one

850
00:34:30,480 --> 00:34:34,239
nonverbal future

851
00:34:34,239 --> 00:34:36,159
is that like a reasonable notion of

852
00:34:36,159 --> 00:34:38,320
normal ability for a hash function that

853
00:34:38,320 --> 00:34:40,800
would make like a multi-three

854
00:34:40,800 --> 00:34:44,239
uh more valuable equipment i mean like

855
00:34:44,239 --> 00:34:46,800
some properties

856
00:34:46,800 --> 00:34:48,639
so i'm sure that there is we haven't

857
00:34:48,639 --> 00:34:50,000
taken a look at it but i'm sure that you

858
00:34:50,000 --> 00:34:51,520
can some so the question was whether or

859
00:34:51,520 --> 00:34:53,839
not there's like a standard model

860
00:34:53,839 --> 00:34:55,839
specific property of uh of the random

861
00:34:55,839 --> 00:34:57,119
oracle

862
00:34:57,119 --> 00:34:58,720
such that if this hash function

863
00:34:58,720 --> 00:35:01,440
satisfies this uh specific property you

864
00:35:01,440 --> 00:35:03,520
can argue that the resulting miracle

865
00:35:03,520 --> 00:35:05,280
tree is not vulnerable

866
00:35:05,280 --> 00:35:07,680
so you know my guess is that there is

867
00:35:07,680 --> 00:35:10,000
but we haven't taken it

868
00:35:10,000 --> 00:35:12,240
actually i have one one question um with

869
00:35:12,240 --> 00:35:14,000
the notion of uh non-vulnerability with

870
00:35:14,000 --> 00:35:16,160
these local openings that you define be

871
00:35:16,160 --> 00:35:17,920
non-trivial even if you didn't require

872
00:35:17,920 --> 00:35:21,200
compactness in the commitments

873
00:35:21,200 --> 00:35:22,640
um

874
00:35:22,640 --> 00:35:24,320
so it would be non-trivial also

875
00:35:24,320 --> 00:35:26,160
essentially the trivial solution of

876
00:35:26,160 --> 00:35:27,200
simply

877
00:35:27,200 --> 00:35:30,640
committing to each other on its own

878
00:35:36,079 --> 00:35:38,240
my guess is that uh

879
00:35:38,240 --> 00:35:39,680
you know it might still be easier to

880
00:35:39,680 --> 00:35:42,960
construct but yeah it's not trivial

881
00:35:42,960 --> 00:35:47,119
okay yeah any more questions

882
00:35:48,320 --> 00:35:50,650
okay let's thank you again

883
00:35:50,650 --> 00:35:53,769
[Applause]

884
00:36:09,200 --> 00:36:10,640
the next talk is on vector and

885
00:36:10,640 --> 00:36:13,119
functional commitments from lattices

886
00:36:13,119 --> 00:36:15,839
the work is by chris zach and chad and

887
00:36:15,839 --> 00:36:18,720
chad will give the talk

888
00:36:19,040 --> 00:36:20,800
hello everyone

889
00:36:20,800 --> 00:36:22,079
so today i'll be presenting vector and

890
00:36:22,079 --> 00:36:24,780
functional equipment from lattices

891
00:36:24,780 --> 00:36:27,599
[Music]

892
00:36:27,599 --> 00:36:30,000
okay uh well i didn't uh figure that i

893
00:36:30,000 --> 00:36:31,920
would be going after another talk on

894
00:36:31,920 --> 00:36:33,200
vector commitment so i also have a

895
00:36:33,200 --> 00:36:34,800
description of what vector equipments

896
00:36:34,800 --> 00:36:37,520
are um but just to go over it very

897
00:36:37,520 --> 00:36:39,760
briefly again vector commitments are

898
00:36:39,760 --> 00:36:41,119
similar to a regular commitment scheme

899
00:36:41,119 --> 00:36:42,480
except rather than committing to a

900
00:36:42,480 --> 00:36:44,240
single value you commit to a sequence of

901
00:36:44,240 --> 00:36:45,119
them

902
00:36:45,119 --> 00:36:47,680
uh and then when it comes time to open

903
00:36:47,680 --> 00:36:48,480
uh

904
00:36:48,480 --> 00:36:49,680
rather than opening you know the whole

905
00:36:49,680 --> 00:36:50,960
vector at once you can open it at a

906
00:36:50,960 --> 00:36:54,480
specific position um and receive a a a a

907
00:36:54,480 --> 00:36:56,560
witness that uh the ith entry is equal

908
00:36:56,560 --> 00:36:57,839
to m sub i

909
00:36:57,839 --> 00:37:01,200
um we additionally require uh um for

910
00:37:01,200 --> 00:37:02,400
non-triviality we require the

911
00:37:02,400 --> 00:37:04,240
commitments and proofs are um much

912
00:37:04,240 --> 00:37:05,920
smaller than the vectors maybe the

913
00:37:05,920 --> 00:37:08,720
constant size or or poly liquid like

914
00:37:08,720 --> 00:37:10,959
um

915
00:37:11,119 --> 00:37:12,880
and then there's a we have a verify

916
00:37:12,880 --> 00:37:14,240
algorithm

917
00:37:14,240 --> 00:37:15,920
that checks the opening against the

918
00:37:15,920 --> 00:37:17,040
commitment

919
00:37:17,040 --> 00:37:19,119
uh and then the security uh property

920
00:37:19,119 --> 00:37:21,839
here is called position binding so hbnp

921
00:37:21,839 --> 00:37:23,440
is able to open a commitment at position

922
00:37:23,440 --> 00:37:26,240
i at two different uh message entries

923
00:37:26,240 --> 00:37:28,400
uh and then uh um

924
00:37:28,400 --> 00:37:29,839
additionally an additional feature you

925
00:37:29,839 --> 00:37:31,040
might want from electric moments are

926
00:37:31,040 --> 00:37:32,880
what are called stateless updates so

927
00:37:32,880 --> 00:37:35,599
here uh um say we have a commitment to

928
00:37:35,599 --> 00:37:38,480
the vector m and we want to update the

929
00:37:38,480 --> 00:37:41,200
jth entry um we want to increment it by

930
00:37:41,200 --> 00:37:43,599
delta so delta being the the difference

931
00:37:43,599 --> 00:37:45,680
between the old entry and the new entry

932
00:37:45,680 --> 00:37:47,680
um then we have an algorithm update c to

933
00:37:47,680 --> 00:37:49,119
produce a new commitment

934
00:37:49,119 --> 00:37:50,880
to this new vector

935
00:37:50,880 --> 00:37:52,560
and then by analogy there's a similar

936
00:37:52,560 --> 00:37:54,160
algorithm for updating bruce to reflect

937
00:37:54,160 --> 00:37:56,880
changes in the underlying vector

938
00:37:56,880 --> 00:37:58,079
uh then

939
00:37:58,079 --> 00:38:00,079
as a generalization of vector movements

940
00:38:00,079 --> 00:38:01,040
we have what are called functional

941
00:38:01,040 --> 00:38:02,720
commitments so functional commitments

942
00:38:02,720 --> 00:38:04,560
rather than opening a vector at a

943
00:38:04,560 --> 00:38:08,320
particular position we open a vector um

944
00:38:08,320 --> 00:38:10,640
we can prove um

945
00:38:10,640 --> 00:38:12,000
the output of a particular function on

946
00:38:12,000 --> 00:38:13,359
that vector so you can imagine vector

947
00:38:13,359 --> 00:38:15,280
commitments as being

948
00:38:15,280 --> 00:38:16,880
a case where

949
00:38:16,880 --> 00:38:18,880
a case where the class of functions that

950
00:38:18,880 --> 00:38:20,000
we have a functional equipment scheme

951
00:38:20,000 --> 00:38:22,560
for is um the class of like projections

952
00:38:22,560 --> 00:38:25,200
down to down to single entries um and so

953
00:38:25,200 --> 00:38:27,040
it looks just like a vacuum cleaner

954
00:38:27,040 --> 00:38:29,119
scheme except open takes a function and

955
00:38:29,119 --> 00:38:31,040
then when it comes time to verify we

956
00:38:31,040 --> 00:38:34,320
accept if f m is equal to y

957
00:38:34,320 --> 00:38:36,320
uh and then the uh security property by

958
00:38:36,320 --> 00:38:37,839
analogy is called function binding so it

959
00:38:37,839 --> 00:38:39,359
should be invisible to open equipment

960
00:38:39,359 --> 00:38:40,560
add a function

961
00:38:40,560 --> 00:38:42,720
a function f at two different outputs y

962
00:38:42,720 --> 00:38:45,440
not equal to y prime

963
00:38:45,440 --> 00:38:47,280
uh so as for like the prior work the

964
00:38:47,280 --> 00:38:49,520
existing state of things uh merkel trees

965
00:38:49,520 --> 00:38:51,280
um uh we're sort of

966
00:38:51,280 --> 00:38:52,320
something you might be familiar with

967
00:38:52,320 --> 00:38:54,480
sort of the first uh um you know vector

968
00:38:54,480 --> 00:38:56,320
commitment like thing but that we

969
00:38:56,320 --> 00:38:58,079
they're not statelessly updatable um so

970
00:38:58,079 --> 00:38:59,440
so in other words to get a new

971
00:38:59,440 --> 00:39:00,640
commitment to reflect an underlying

972
00:39:00,640 --> 00:39:02,320
change in the message you basically just

973
00:39:02,320 --> 00:39:03,520
have to you know commit to the new

974
00:39:03,520 --> 00:39:04,320
vector you have to know what the

975
00:39:04,320 --> 00:39:05,839
original vector was or where the new

976
00:39:05,839 --> 00:39:07,280
vector is

977
00:39:07,280 --> 00:39:08,480
um

978
00:39:08,480 --> 00:39:11,040
then uh the statelessly available vcs

979
00:39:11,040 --> 00:39:12,880
sort of come onto the scene based on rsa

980
00:39:12,880 --> 00:39:16,240
and pairings and ly10 and cf13

981
00:39:16,240 --> 00:39:18,880
um that there's as far as post quantum

982
00:39:18,880 --> 00:39:21,520
work um there's a sort of merkle like uh

983
00:39:21,520 --> 00:39:23,040
statelessly updatable vc scheme it's

984
00:39:23,040 --> 00:39:24,320
based on the short energy solution

985
00:39:24,320 --> 00:39:25,359
problem

986
00:39:25,359 --> 00:39:27,599
um it basically is a merkle tree except

987
00:39:27,599 --> 00:39:29,359
uh it takes advantage of some of the

988
00:39:29,359 --> 00:39:32,079
structure of the sas hash function um to

989
00:39:32,079 --> 00:39:34,240
give you to stole for stateless updates

990
00:39:34,240 --> 00:39:35,680
um and then there are numerous

991
00:39:35,680 --> 00:39:37,520
applications for ec schemes like

992
00:39:37,520 --> 00:39:38,800
verifiable outsourcing and storage

993
00:39:38,800 --> 00:39:40,960
you've got a space constrained client um

994
00:39:40,960 --> 00:39:43,359
and uh you know sort of an untrusted

995
00:39:43,359 --> 00:39:45,839
database um and uh

996
00:39:45,839 --> 00:39:47,200
the client keeps a commitment to the

997
00:39:47,200 --> 00:39:49,440
database uh and then can you know ask

998
00:39:49,440 --> 00:39:50,960
for updates or you know ask for

999
00:39:50,960 --> 00:39:53,280
retrieval um

1000
00:39:53,280 --> 00:39:54,839
and then can verify them using the

1001
00:39:54,839 --> 00:39:57,440
scheme um as far as functional equipment

1002
00:39:57,440 --> 00:39:59,760
schemes um so that we there's an fc

1003
00:39:59,760 --> 00:40:01,680
scheme for linear functions based on

1004
00:40:01,680 --> 00:40:05,040
pairings um there are fc schemes for the

1005
00:40:05,040 --> 00:40:06,079
with this paper called sparse

1006
00:40:06,079 --> 00:40:08,160
polynomials um and there are many more

1007
00:40:08,160 --> 00:40:09,760
than just these two for many other

1008
00:40:09,760 --> 00:40:11,599
classes of functions um but one thing

1009
00:40:11,599 --> 00:40:13,359
that all of them at least the ones based

1010
00:40:13,359 --> 00:40:15,280
on vulnerable assumptions have in common

1011
00:40:15,280 --> 00:40:16,960
is that they only work for function

1012
00:40:16,960 --> 00:40:18,480
classes that are linearizable which

1013
00:40:18,480 --> 00:40:20,240
means that every function in the class

1014
00:40:20,240 --> 00:40:22,319
can be broken down into

1015
00:40:22,319 --> 00:40:25,280
a linear function operating on some uh

1016
00:40:25,280 --> 00:40:26,480
like polynomial time fixed

1017
00:40:26,480 --> 00:40:28,079
pre-processing of the message and that

1018
00:40:28,079 --> 00:40:30,319
preresting is is um

1019
00:40:30,319 --> 00:40:32,720
fixed across the whole function class

1020
00:40:32,720 --> 00:40:34,000
um so you can imagine like for for

1021
00:40:34,000 --> 00:40:35,760
polynomial evaluation that this

1022
00:40:35,760 --> 00:40:37,200
preprocessing would be taking like

1023
00:40:37,200 --> 00:40:38,720
powers of the

1024
00:40:38,720 --> 00:40:40,960
powers of the message

1025
00:40:40,960 --> 00:40:43,280
um so snarks for np let us go further

1026
00:40:43,280 --> 00:40:45,359
than linearizable functions um but we

1027
00:40:45,359 --> 00:40:46,880
can't do these we can't get these from

1028
00:40:46,880 --> 00:40:48,160
falsifiable assumptions at least not in

1029
00:40:48,160 --> 00:40:50,000
the black box way

1030
00:40:50,000 --> 00:40:51,760
um and then you know and surprisingly

1031
00:40:51,760 --> 00:40:53,760
there are numerous applications for uh

1032
00:40:53,760 --> 00:40:55,599
fc schemes

1033
00:40:55,599 --> 00:40:57,839
um so the contributions in in this work

1034
00:40:57,839 --> 00:41:00,240
are we give a new post quantum uh um

1035
00:41:00,240 --> 00:41:02,319
stairlessly updatable vc scheme that has

1036
00:41:02,319 --> 00:41:03,920
significantly shorter proofs than the

1037
00:41:03,920 --> 00:41:06,480
other one the psty um and so in

1038
00:41:06,480 --> 00:41:08,640
particular here if we have a message

1039
00:41:08,640 --> 00:41:10,319
that's of uh um

1040
00:41:10,319 --> 00:41:13,119
length d to the h um then we lose a

1041
00:41:13,119 --> 00:41:16,160
vector d uh in the proof size um and d

1042
00:41:16,160 --> 00:41:17,440
typically if you optimize these print if

1043
00:41:17,440 --> 00:41:18,319
you upgrade these parameters

1044
00:41:18,319 --> 00:41:19,440
appropriately d is going to be a small

1045
00:41:19,440 --> 00:41:20,560
polynomial

1046
00:41:20,560 --> 00:41:23,040
um and this this uh savings and proof

1047
00:41:23,040 --> 00:41:24,720
size is sort of paid for by larger

1048
00:41:24,720 --> 00:41:26,560
public parameters again by a factor of d

1049
00:41:26,560 --> 00:41:28,079
but typically you're gonna have one set

1050
00:41:28,079 --> 00:41:29,520
of proof parameters one set of public

1051
00:41:29,520 --> 00:41:31,359
parameters and many proofs so this seems

1052
00:41:31,359 --> 00:41:32,800
like a worthy trade-off

1053
00:41:32,800 --> 00:41:35,119
we also lose public setup

1054
00:41:35,119 --> 00:41:35,920
um

1055
00:41:35,920 --> 00:41:39,200
and then uh we also give a new sas based

1056
00:41:39,200 --> 00:41:40,319
functional equipment scheme for

1057
00:41:40,319 --> 00:41:42,240
arbitrary bounded boolean circuits so

1058
00:41:42,240 --> 00:41:43,359
this is based on the falsifiable

1059
00:41:43,359 --> 00:41:45,359
assumption and it goes much farther than

1060
00:41:45,359 --> 00:41:47,920
these linearizable function classes um

1061
00:41:47,920 --> 00:41:49,440
that i just talked about

1062
00:41:49,440 --> 00:41:51,440
um so it's the first based on false

1063
00:41:51,440 --> 00:41:53,040
bible assumptions to go beyond uh

1064
00:41:53,040 --> 00:41:54,319
linearizable functions and it's the

1065
00:41:54,319 --> 00:41:56,160
first post quantum sc scheme from a

1066
00:41:56,160 --> 00:41:58,720
falsifiable assumption

1067
00:41:58,720 --> 00:42:01,440
however the sort of downside is that we

1068
00:42:01,440 --> 00:42:03,280
have to introduce a new model um in

1069
00:42:03,280 --> 00:42:06,000
which the uh the trusted authority that

1070
00:42:06,000 --> 00:42:08,000
set up the public parameters stays

1071
00:42:08,000 --> 00:42:11,280
online um and clients ask for opening

1072
00:42:11,280 --> 00:42:13,760
keys which are these public reusable uh

1073
00:42:13,760 --> 00:42:16,160
keys that allow you to open the vector

1074
00:42:16,160 --> 00:42:17,680
at a particular function

1075
00:42:17,680 --> 00:42:18,880
um

1076
00:42:18,880 --> 00:42:20,880
so in particular what that looks like is

1077
00:42:20,880 --> 00:42:22,079
is uh

1078
00:42:22,079 --> 00:42:23,520
if you imagine the the diagram from

1079
00:42:23,520 --> 00:42:25,440
before the change here is that the

1080
00:42:25,440 --> 00:42:27,119
permanently online authority has this

1081
00:42:27,119 --> 00:42:30,240
algorithm extract um clients go to it uh

1082
00:42:30,240 --> 00:42:32,079
give it a function and then get back an

1083
00:42:32,079 --> 00:42:33,359
opening key which has been fed to the

1084
00:42:33,359 --> 00:42:35,440
open algorithm

1085
00:42:35,440 --> 00:42:36,319
then there are a few secondary

1086
00:42:36,319 --> 00:42:37,680
contributions which these aren't covered

1087
00:42:37,680 --> 00:42:38,480
in the

1088
00:42:38,480 --> 00:42:40,079
main talk um

1089
00:42:40,079 --> 00:42:41,920
we give a formal definition in the

1090
00:42:41,920 --> 00:42:43,920
generic construction what we call zero

1091
00:42:43,920 --> 00:42:45,760
knowledge vector equipment scheme and

1092
00:42:45,760 --> 00:42:47,359
then we do a formal analysis of sort of

1093
00:42:47,359 --> 00:42:49,119
a long-standing folklore

1094
00:42:49,119 --> 00:42:50,880
merkel-like tree transformation a vector

1095
00:42:50,880 --> 00:42:53,040
from in schemes um where it's basically

1096
00:42:53,040 --> 00:42:54,960
a miracle tree but rather than hash

1097
00:42:54,960 --> 00:42:56,560
functions all the way down it's a vector

1098
00:42:56,560 --> 00:42:57,680
complement scheme and so you don't have

1099
00:42:57,680 --> 00:43:00,000
to give sibling information to update um

1100
00:43:00,000 --> 00:43:03,440
uh to update uh to um

1101
00:43:03,440 --> 00:43:05,680
to open at a particular index

1102
00:43:05,680 --> 00:43:08,160
uh and then uh there are a few open

1103
00:43:08,160 --> 00:43:09,440
questions that arise from this work so

1104
00:43:09,440 --> 00:43:11,440
one is is whether it's possible to get

1105
00:43:11,440 --> 00:43:13,359
uh um constant size commitments and

1106
00:43:13,359 --> 00:43:15,760
proofs um from uh pq assumption we can

1107
00:43:15,760 --> 00:43:18,240
get these from rsa and pairings and some

1108
00:43:18,240 --> 00:43:19,119
of the other schemes that i mentioned

1109
00:43:19,119 --> 00:43:21,920
before but ours are still um logarithmic

1110
00:43:21,920 --> 00:43:23,599
in the size of the vector

1111
00:43:23,599 --> 00:43:25,359
and then um the the the other broad

1112
00:43:25,359 --> 00:43:27,200
question is is can we get a functional

1113
00:43:27,200 --> 00:43:29,119
commitment scheme for arbitrary boolean

1114
00:43:29,119 --> 00:43:30,880
circuits from a false level assumption

1115
00:43:30,880 --> 00:43:32,800
without this permanent online authority

1116
00:43:32,800 --> 00:43:34,480
or whether that's possible whether you

1117
00:43:34,480 --> 00:43:36,560
know the the alternative would be um

1118
00:43:36,560 --> 00:43:38,800
that somehow you can construct a a smart

1119
00:43:38,800 --> 00:43:40,560
friend piece from this in which case it

1120
00:43:40,560 --> 00:43:42,000
wouldn't be possible

1121
00:43:42,000 --> 00:43:43,839
um but that's my talk so for full

1122
00:43:43,839 --> 00:43:47,680
information please uh see the paper

1123
00:43:52,800 --> 00:43:55,839
any questions

1124
00:43:59,359 --> 00:44:03,640
okay then let's type chat again

1125
00:44:20,880 --> 00:44:22,720
okay the last stop of the session is on

1126
00:44:22,720 --> 00:44:24,400
upgradable public encryption in the

1127
00:44:24,400 --> 00:44:26,240
standard model the work is by your

1128
00:44:26,240 --> 00:44:27,550
beginning

1129
00:44:27,550 --> 00:44:30,649
[Music]

1130
00:44:31,680 --> 00:44:33,599
thanks for the introduction

1131
00:44:33,599 --> 00:44:36,319
um so as uh abhishek said this is my

1132
00:44:36,319 --> 00:44:37,680
point of data for public key encryption

1133
00:44:37,680 --> 00:44:39,440
in the standard model this is joint work

1134
00:44:39,440 --> 00:44:43,440
with kenny and daniel um so

1135
00:44:44,480 --> 00:44:45,760
okay

1136
00:44:45,760 --> 00:44:48,160
ah okay so

1137
00:44:48,160 --> 00:44:50,079
um so the broad outline of the dockers

1138
00:44:50,079 --> 00:44:51,359
we will look at

1139
00:44:51,359 --> 00:44:53,280
uh forward secure public encryption just

1140
00:44:53,280 --> 00:44:55,280
a quick recap and use that to motivate

1141
00:44:55,280 --> 00:44:57,440
the perimeter and then look at further

1142
00:44:57,440 --> 00:44:58,319
about the primitive and the

1143
00:44:58,319 --> 00:45:00,160
constructions and so on

1144
00:45:00,160 --> 00:45:00,960
um

1145
00:45:00,960 --> 00:45:03,680
so fspke there is alice and bob

1146
00:45:03,680 --> 00:45:06,560
publishes to communicate palace and

1147
00:45:06,560 --> 00:45:07,920
facilitate that alice generates a

1148
00:45:07,920 --> 00:45:10,079
publicly secretly paired keep secret key

1149
00:45:10,079 --> 00:45:12,240
for herself and sends publicly to bob

1150
00:45:12,240 --> 00:45:13,839
bob the public

1151
00:45:13,839 --> 00:45:15,599
not can update a message i'm not to get

1152
00:45:15,599 --> 00:45:17,599
cipher text and descent

1153
00:45:17,599 --> 00:45:20,079
to alice in addition

1154
00:45:20,079 --> 00:45:21,680
bob evolves the public key from p k

1155
00:45:21,680 --> 00:45:23,200
naught to p k one

1156
00:45:23,200 --> 00:45:25,680
uh alice s k naught c naught the math

1157
00:45:25,680 --> 00:45:27,280
goes that it gets m naught and then

1158
00:45:27,280 --> 00:45:29,440
involves the secret key to sk1 this

1159
00:45:29,440 --> 00:45:32,319
keeps happening and note that all of the

1160
00:45:32,319 --> 00:45:33,520
conversation is happening in the

1161
00:45:33,520 --> 00:45:35,440
presence of an adversary eve and let's

1162
00:45:35,440 --> 00:45:36,640
assume that e

1163
00:45:36,640 --> 00:45:39,040
as corrupted as k2 the requirement of

1164
00:45:39,040 --> 00:45:41,200
fspk is that m naught and m one remains

1165
00:45:41,200 --> 00:45:43,839
secured um because they were decrypted

1166
00:45:43,839 --> 00:45:46,240
before the compromise happened um and

1167
00:45:46,240 --> 00:45:47,680
the correctness requirement is anything

1168
00:45:47,680 --> 00:45:49,599
that's encrypted by pki is decryptable

1169
00:45:49,599 --> 00:45:51,119
by ski

1170
00:45:51,119 --> 00:45:53,440
and uh um so pretty much state of the

1171
00:45:53,440 --> 00:45:55,680
art is about with by canada at all where

1172
00:45:55,680 --> 00:45:56,880
they build constructions from

1173
00:45:56,880 --> 00:45:58,960
hierarchical identity-based encryption

1174
00:45:58,960 --> 00:46:00,720
but there's always this gap between

1175
00:46:00,720 --> 00:46:02,640
height schemes and pk schemes from

1176
00:46:02,640 --> 00:46:05,200
similar assumptions and the question we

1177
00:46:05,200 --> 00:46:06,880
confront is can we somehow close the

1178
00:46:06,880 --> 00:46:09,520
efficiency gap by somehow weakening the

1179
00:46:09,520 --> 00:46:11,119
security definition

1180
00:46:11,119 --> 00:46:13,280
specifically we want to use ci to

1181
00:46:13,280 --> 00:46:15,280
somehow achieve a weaker notion of

1182
00:46:15,280 --> 00:46:17,280
forward secrecy ci

1183
00:46:17,280 --> 00:46:18,960
in case you forgot this is just a cipher

1184
00:46:18,960 --> 00:46:22,400
text and in this talk we say yes and the

1185
00:46:22,400 --> 00:46:24,079
idea is basically

1186
00:46:24,079 --> 00:46:25,839
the ciphertext for aid in producing the

1187
00:46:25,839 --> 00:46:28,560
sequential change rather than naively

1188
00:46:28,560 --> 00:46:30,480
contain the secret key themselves and

1189
00:46:30,480 --> 00:46:31,680
the security goal that we want to

1190
00:46:31,680 --> 00:46:32,960
achieve is

1191
00:46:32,960 --> 00:46:34,480
reasonable security even with

1192
00:46:34,480 --> 00:46:36,079
compromised senders

1193
00:46:36,079 --> 00:46:38,400
um so that brings us to updatable public

1194
00:46:38,400 --> 00:46:41,200
key encryption so what is it upgradeable

1195
00:46:41,200 --> 00:46:42,800
public key encryptions

1196
00:46:42,800 --> 00:46:43,920
um

1197
00:46:43,920 --> 00:46:46,000
the setting is another sequence of

1198
00:46:46,000 --> 00:46:48,400
ciphertext that's decrypted uh that's to

1199
00:46:48,400 --> 00:46:50,079
be decrypted by the receiver we can

1200
00:46:50,079 --> 00:46:52,079
either assume there is just one sender

1201
00:46:52,079 --> 00:46:54,240
or somehow assume a serialization

1202
00:46:54,240 --> 00:46:56,240
mechanism to make sure that everyone

1203
00:46:56,240 --> 00:46:58,079
receives a consistent view

1204
00:46:58,079 --> 00:47:00,640
um in a nutshell what happens is the

1205
00:47:00,640 --> 00:47:03,040
senders will produce a public teaching

1206
00:47:03,040 --> 00:47:04,960
the ciphertext will produce will help

1207
00:47:04,960 --> 00:47:07,040
the receiver produce a secret keychain

1208
00:47:07,040 --> 00:47:09,359
both the chains need to be consistent

1209
00:47:09,359 --> 00:47:12,160
and the fact is that the public keychain

1210
00:47:12,160 --> 00:47:14,160
is not fixed a priority

1211
00:47:14,160 --> 00:47:15,119
um

1212
00:47:15,119 --> 00:47:17,520
um so and what's the security any good

1213
00:47:17,520 --> 00:47:19,040
ciphertext and we'll quantify good

1214
00:47:19,040 --> 00:47:20,880
ciphertext in just a few slides we'll

1215
00:47:20,880 --> 00:47:22,839
restore security irrespective of what

1216
00:47:22,839 --> 00:47:24,160
happens between

1217
00:47:24,160 --> 00:47:26,559
um so what is the primitive update of

1218
00:47:26,559 --> 00:47:27,760
the public key encryption as the name

1219
00:47:27,760 --> 00:47:29,680
suggests is a public encryption so you

1220
00:47:29,680 --> 00:47:31,200
have the key gen algorithm the

1221
00:47:31,200 --> 00:47:32,800
encryption algorithm and the decryption

1222
00:47:32,800 --> 00:47:36,000
algorithm in addition we have

1223
00:47:36,000 --> 00:47:37,760
an algorithm that is randomized and

1224
00:47:37,760 --> 00:47:40,000
we'll take an old public key and we'll

1225
00:47:40,000 --> 00:47:42,400
produce a new public epk prime and also

1226
00:47:42,400 --> 00:47:44,880
produce the update ciphertext up

1227
00:47:44,880 --> 00:47:47,440
updates our secret key will take this uh

1228
00:47:47,440 --> 00:47:50,000
update ciphertext up and the old secret

1229
00:47:50,000 --> 00:47:52,319
key to produce a new secret key um i

1230
00:47:52,319 --> 00:47:54,079
mean the colors are basically indicative

1231
00:47:54,079 --> 00:47:56,160
of the fact that they are consistent

1232
00:47:56,160 --> 00:47:57,040
um

1233
00:47:57,040 --> 00:48:00,880
and uh so what is the security game uh

1234
00:48:00,880 --> 00:48:03,040
it's uh within this slide we'll look at

1235
00:48:03,040 --> 00:48:06,240
something called as indcrc start i know

1236
00:48:06,240 --> 00:48:08,559
this the c r is a new abbreviation we

1237
00:48:08,559 --> 00:48:10,480
will explain in a few slides but let's

1238
00:48:10,480 --> 00:48:12,079
just look at the game you have

1239
00:48:12,079 --> 00:48:14,319
challenger give an adversary the

1240
00:48:14,319 --> 00:48:16,480
challenger will generate pk not sk not

1241
00:48:16,480 --> 00:48:18,800
keeps a skin out for uh itself and sends

1242
00:48:18,800 --> 00:48:20,800
speaking out to the adversary

1243
00:48:20,800 --> 00:48:23,440
now the adversary responds with a set of

1244
00:48:23,440 --> 00:48:24,960
rise

1245
00:48:24,960 --> 00:48:26,720
and m naught star and m one star which

1246
00:48:26,720 --> 00:48:28,880
are basically the challenge messages

1247
00:48:28,880 --> 00:48:31,200
now this is the part that's interesting

1248
00:48:31,200 --> 00:48:32,960
is that the char this challenger will

1249
00:48:32,960 --> 00:48:35,280
consume this ri thinking of it as the

1250
00:48:35,280 --> 00:48:37,200
randomness for the update publicly and

1251
00:48:37,200 --> 00:48:39,200
update secret k algorithm to produce

1252
00:48:39,200 --> 00:48:42,000
keys as follows so update pk takes pk

1253
00:48:42,000 --> 00:48:45,200
naught r1 produces a new public epk1 and

1254
00:48:45,200 --> 00:48:47,040
updates ciphertext up one

1255
00:48:47,040 --> 00:48:49,280
which is consumed by update secret key

1256
00:48:49,280 --> 00:48:51,920
ah to produce sk1 this happens multiple

1257
00:48:51,920 --> 00:48:53,040
times

1258
00:48:53,040 --> 00:48:56,240
and at this point you have pkq and skq

1259
00:48:56,240 --> 00:48:57,839
now this is the definition of good

1260
00:48:57,839 --> 00:48:59,920
ciphertext so the other the challenger

1261
00:48:59,920 --> 00:49:02,559
will basically choose a randomness r

1262
00:49:02,559 --> 00:49:04,640
start of its choice and update public

1263
00:49:04,640 --> 00:49:07,760
key pknot pkq and skq to some values p k

1264
00:49:07,760 --> 00:49:09,359
star and s k star

1265
00:49:09,359 --> 00:49:10,480
so now

1266
00:49:10,480 --> 00:49:11,599
the um

1267
00:49:11,599 --> 00:49:14,640
uh the address read receives p k star

1268
00:49:14,640 --> 00:49:16,880
s k star up star

1269
00:49:16,880 --> 00:49:19,440
and the challenge cipher text

1270
00:49:19,440 --> 00:49:21,359
the adversity response with b prime and

1271
00:49:21,359 --> 00:49:23,839
vincent b prime is equal to b

1272
00:49:23,839 --> 00:49:25,599
now there are some subtleties when the

1273
00:49:25,599 --> 00:49:28,720
previous verb are in the definition so

1274
00:49:28,720 --> 00:49:31,440
uh the work by um just and others they

1275
00:49:31,440 --> 00:49:32,880
did not provide for a malicious

1276
00:49:32,880 --> 00:49:35,280
randomness but instead allowed for an

1277
00:49:35,280 --> 00:49:37,839
adversity to expose the randomness and

1278
00:49:37,839 --> 00:49:38,880
uh just

1279
00:49:38,880 --> 00:49:40,640
a pedantic point is that the work by

1280
00:49:40,640 --> 00:49:44,559
alvin and others uh included mi um there

1281
00:49:44,559 --> 00:49:46,480
which is not our definition so that's

1282
00:49:46,480 --> 00:49:48,400
why we don't have mi here

1283
00:49:48,400 --> 00:49:50,880
uh so what is this start

1284
00:49:50,880 --> 00:49:53,680
so this chosen randomness is what cr

1285
00:49:53,680 --> 00:49:56,480
stands for so i've ruined the surprise

1286
00:49:56,480 --> 00:49:58,960
uh but the fact is that the adversity

1287
00:49:58,960 --> 00:50:01,119
chooses the randomness here

1288
00:50:01,119 --> 00:50:04,160
and indc rcp star is the simplified

1289
00:50:04,160 --> 00:50:06,800
model presented here because we assume

1290
00:50:06,800 --> 00:50:08,240
that the secret key is revealed right

1291
00:50:08,240 --> 00:50:09,440
after the message

1292
00:50:09,440 --> 00:50:11,359
the challenge space however the more

1293
00:50:11,359 --> 00:50:12,559
general version would allow the

1294
00:50:12,559 --> 00:50:14,480
adversary to also provide additional

1295
00:50:14,480 --> 00:50:17,119
randomness to somehow uh evolve the keys

1296
00:50:17,119 --> 00:50:19,359
adversarially before finally asking for

1297
00:50:19,359 --> 00:50:20,800
the corruption

1298
00:50:20,800 --> 00:50:22,800
and we present this strong

1299
00:50:22,800 --> 00:50:24,960
more general version of the pool uh in

1300
00:50:24,960 --> 00:50:26,559
the full version of the paper and we

1301
00:50:26,559 --> 00:50:28,800
also introduced indcr cca which allows

1302
00:50:28,800 --> 00:50:31,359
for uh decryption queries a stronger

1303
00:50:31,359 --> 00:50:33,200
security model is something called as a

1304
00:50:33,200 --> 00:50:35,119
chosen update where rather than

1305
00:50:35,119 --> 00:50:37,599
providing the rise the adversary

1306
00:50:37,599 --> 00:50:40,319
provides an update uh which is basically

1307
00:50:40,319 --> 00:50:41,920
an update ciphertext and a public key

1308
00:50:41,920 --> 00:50:44,720
that's consistent with the update um

1309
00:50:44,720 --> 00:50:47,040
and this is a stronger model

1310
00:50:47,040 --> 00:50:49,680
and this is also covered in the paper

1311
00:50:49,680 --> 00:50:53,280
where we discuss imdc ucpa and the cucc

1312
00:50:53,280 --> 00:50:55,119
anyway anyway enough of

1313
00:50:55,119 --> 00:50:57,760
the alphabet jargon let's look at where

1314
00:50:57,760 --> 00:51:00,559
things stand um so we compare all three

1315
00:51:00,559 --> 00:51:02,800
axes efficiency assumptions and powered

1316
00:51:02,800 --> 00:51:04,400
secrecy um

1317
00:51:04,400 --> 00:51:06,319
public key is very efficient they have a

1318
00:51:06,319 --> 00:51:08,000
whole bunch of assumptions and by

1319
00:51:08,000 --> 00:51:09,599
definition it's

1320
00:51:09,599 --> 00:51:12,559
not powered secure uh fspke is

1321
00:51:12,559 --> 00:51:14,559
inefficient you build it from hype uh

1322
00:51:14,559 --> 00:51:16,319
again a whole bunch of assumptions by

1323
00:51:16,319 --> 00:51:18,480
definition is forward secure

1324
00:51:18,480 --> 00:51:19,520
and

1325
00:51:19,520 --> 00:51:22,800
the upk that was proposed by just others

1326
00:51:22,800 --> 00:51:24,800
is very efficient about our sufficient

1327
00:51:24,800 --> 00:51:26,720
spke it's

1328
00:51:26,720 --> 00:51:28,480
uh forward secure but it has additional

1329
00:51:28,480 --> 00:51:30,480
synchronization as we just saw

1330
00:51:30,480 --> 00:51:32,160
and it was uh

1331
00:51:32,160 --> 00:51:35,280
proven secure in the cdh assumption

1332
00:51:35,280 --> 00:51:38,000
but in the random oracle but it will

1333
00:51:38,000 --> 00:51:40,640
hopefully serve as a useful launchpad

1334
00:51:40,640 --> 00:51:43,040
and i know i have seven minutes and i'm

1335
00:51:43,040 --> 00:51:44,640
standing between you and the lunch so we

1336
00:51:44,640 --> 00:51:45,760
all wrap up

1337
00:51:45,760 --> 00:51:48,000
um so the upk uh

1338
00:51:48,000 --> 00:51:49,920
oh sorry there is a session in between

1339
00:51:49,920 --> 00:51:51,520
that and the lunch my mind goes to lunch

1340
00:51:51,520 --> 00:51:55,119
my apologies um so uh the upk the

1341
00:51:55,119 --> 00:51:57,280
intuition that was discussed in the

1342
00:51:57,280 --> 00:51:58,960
uh the

1343
00:51:58,960 --> 00:52:01,359
random oracle solution the key idea here

1344
00:52:01,359 --> 00:52:02,960
is uh

1345
00:52:02,960 --> 00:52:05,280
that say i want to update the secret key

1346
00:52:05,280 --> 00:52:07,119
by some factor r1

1347
00:52:07,119 --> 00:52:09,200
and somehow the update public key will

1348
00:52:09,200 --> 00:52:11,119
just encrypt this r1 to produce the

1349
00:52:11,119 --> 00:52:14,240
update ciphertext and the fact is that

1350
00:52:14,240 --> 00:52:15,760
we use a powerful home mortgage

1351
00:52:15,760 --> 00:52:18,559
technique to just use the public key and

1352
00:52:18,559 --> 00:52:20,480
the fact that the update publicly knows

1353
00:52:20,480 --> 00:52:23,280
r1 to somehow evolve the public key to

1354
00:52:23,280 --> 00:52:24,640
the new public key

1355
00:52:24,640 --> 00:52:26,000
so this is pretty much the idea that

1356
00:52:26,000 --> 00:52:29,359
people work on but why is this secure

1357
00:52:29,359 --> 00:52:30,319
so

1358
00:52:30,319 --> 00:52:32,000
this is based on a standard high shelter

1359
00:52:32,000 --> 00:52:33,119
encryption

1360
00:52:33,119 --> 00:52:35,119
so why is it secure let's take a simple

1361
00:52:35,119 --> 00:52:36,880
look at the game where the university

1362
00:52:36,880 --> 00:52:38,880
provides no updates so no randomness

1363
00:52:38,880 --> 00:52:40,960
from the adversity so it's a challenger

1364
00:52:40,960 --> 00:52:43,119
and the adversary the adversary receives

1365
00:52:43,119 --> 00:52:45,280
pknot and provides just the challenge

1366
00:52:45,280 --> 00:52:48,079
messages m naught star and m one star

1367
00:52:48,079 --> 00:52:51,200
and uh the adversary receives p k star s

1368
00:52:51,200 --> 00:52:54,960
k star c star nub star okay again uh we

1369
00:52:54,960 --> 00:52:57,760
will look at why these terms matter here

1370
00:52:57,760 --> 00:53:00,319
and then b prime that's the usual so

1371
00:53:00,319 --> 00:53:02,400
let's take a look at sk star so recall

1372
00:53:02,400 --> 00:53:04,079
that sk star is nothing but the old

1373
00:53:04,079 --> 00:53:07,280
secret key uh plus a randomly chosen

1374
00:53:07,280 --> 00:53:08,640
delta star

1375
00:53:08,640 --> 00:53:10,880
okay so what this is is essentially a

1376
00:53:10,880 --> 00:53:11,920
leakage

1377
00:53:11,920 --> 00:53:12,960
on

1378
00:53:12,960 --> 00:53:15,599
the old secret tsk

1379
00:53:15,599 --> 00:53:17,839
upstar is basically

1380
00:53:17,839 --> 00:53:20,559
an encryption of delta star which we can

1381
00:53:20,559 --> 00:53:23,200
think of it as sk the oldest case the

1382
00:53:23,200 --> 00:53:25,520
new sk start minus the old sk so it's

1383
00:53:25,520 --> 00:53:29,200
somehow dependent on the message so

1384
00:53:29,200 --> 00:53:30,720
fortunately delta star is random

1385
00:53:30,720 --> 00:53:32,720
therefore the leakage is trivial

1386
00:53:32,720 --> 00:53:35,200
and the hash function which is modeled

1387
00:53:35,200 --> 00:53:37,200
as a random oracle will ensure ktm

1388
00:53:37,200 --> 00:53:38,640
security

1389
00:53:38,640 --> 00:53:40,880
um so how do we go from here to what

1390
00:53:40,880 --> 00:53:42,800
standard mode

1391
00:53:42,800 --> 00:53:45,839
ktm security uh allows an adversary to

1392
00:53:45,839 --> 00:53:47,760
obtain an encryption of a function g of

1393
00:53:47,760 --> 00:53:49,280
the secret piece under a particular

1394
00:53:49,280 --> 00:53:53,040
public key uh um so bernard all showed

1395
00:53:53,040 --> 00:53:54,720
kdm security for refined functions and

1396
00:53:54,720 --> 00:53:56,960
they provided constructions from the ddh

1397
00:53:56,960 --> 00:53:58,000
assumption

1398
00:53:58,000 --> 00:53:59,920
how we need only circular security that

1399
00:53:59,920 --> 00:54:02,319
is an encryption of a secret key

1400
00:54:02,319 --> 00:54:04,160
sort of in ask scheme bit by bit and

1401
00:54:04,160 --> 00:54:06,240
homomorphisms

1402
00:54:06,240 --> 00:54:09,200
so here a secret key is a vector

1403
00:54:09,200 --> 00:54:11,040
and we will use both vhs of

1404
00:54:11,040 --> 00:54:12,319
cryptosystems and human backup

1405
00:54:12,319 --> 00:54:15,440
cryptosystem um and here we will only

1406
00:54:15,440 --> 00:54:18,079
we'll encrypt delta a bit by bit

1407
00:54:18,079 --> 00:54:20,000
and this seems to be inherent we'll see

1408
00:54:20,000 --> 00:54:20,960
why

1409
00:54:20,960 --> 00:54:23,359
and the problem now is that leakage per

1410
00:54:23,359 --> 00:54:25,440
bit is non-trivial because delta i is

1411
00:54:25,440 --> 00:54:27,119
either zero or one and you can pretty

1412
00:54:27,119 --> 00:54:30,079
much guess um

1413
00:54:30,079 --> 00:54:32,880
recovered so what we need is to show

1414
00:54:32,880 --> 00:54:34,480
that the schemes are simultaneously

1415
00:54:34,480 --> 00:54:35,839
secure

1416
00:54:35,839 --> 00:54:36,960
both

1417
00:54:36,960 --> 00:54:39,359
cs and lr secure so circular secured and

1418
00:54:39,359 --> 00:54:42,240
leakage visibility um so what is this

1419
00:54:42,240 --> 00:54:44,160
security definition for this game that

1420
00:54:44,160 --> 00:54:44,880
i'm

1421
00:54:44,880 --> 00:54:47,119
throwing in right now the game is pretty

1422
00:54:47,119 --> 00:54:50,319
simple challenger adversary pksk is

1423
00:54:50,319 --> 00:54:53,280
generated keeps pk pass k for itself

1424
00:54:53,280 --> 00:54:56,000
sends pk along adversary provides

1425
00:54:56,000 --> 00:54:57,440
challenge messages and a leakage

1426
00:54:57,440 --> 00:54:59,040
function l

1427
00:54:59,040 --> 00:55:01,680
now the adversary tosses a bit sorry the

1428
00:55:01,680 --> 00:55:03,200
challenger tosses a bit

1429
00:55:03,200 --> 00:55:04,880
uh and then there's a challenge

1430
00:55:04,880 --> 00:55:07,520
ciphertext which is an encryption of mb

1431
00:55:07,520 --> 00:55:09,599
and then there is an encryption

1432
00:55:09,599 --> 00:55:11,920
of the secret key uh under the public

1433
00:55:11,920 --> 00:55:13,839
key which is also provided to the

1434
00:55:13,839 --> 00:55:15,760
adversary along with the leakage

1435
00:55:15,760 --> 00:55:17,680
function l

1436
00:55:17,680 --> 00:55:19,440
and then the adversary guesses a bit b

1437
00:55:19,440 --> 00:55:22,240
prime and we want semantic security

1438
00:55:22,240 --> 00:55:24,160
so the pro point here is that the

1439
00:55:24,160 --> 00:55:26,880
leakage function here um can even be a

1440
00:55:26,880 --> 00:55:29,040
probabilistic and just means that

1441
00:55:29,040 --> 00:55:30,480
uh there is some amount of residual

1442
00:55:30,480 --> 00:55:32,720
entropy that most lambda bits of entropy

1443
00:55:32,720 --> 00:55:33,440
are

1444
00:55:33,440 --> 00:55:35,200
drained from the system

1445
00:55:35,200 --> 00:55:37,200
okay um so

1446
00:55:37,200 --> 00:55:39,440
what are our contributions

1447
00:55:39,440 --> 00:55:42,160
um so

1448
00:55:42,160 --> 00:55:44,160
we present two upk constructions in a

1449
00:55:44,160 --> 00:55:45,920
standard bottle

1450
00:55:45,920 --> 00:55:47,599
one from the radius assumption which is

1451
00:55:47,599 --> 00:55:49,760
based on the ph of cryptosystem

1452
00:55:49,760 --> 00:55:51,520
uh where we will update

1453
00:55:51,520 --> 00:55:54,240
uh pkn uh encrypt

1454
00:55:54,240 --> 00:55:55,839
sorry update pk will encrypt bit by bit

1455
00:55:55,839 --> 00:55:58,079
in the exponent as you see over here and

1456
00:55:58,079 --> 00:55:59,520
then the update secret key will be in a

1457
00:55:59,520 --> 00:56:01,520
position to decrypt it and this is where

1458
00:56:01,520 --> 00:56:03,599
the fact that we are in we have a big

1459
00:56:03,599 --> 00:56:04,960
string hell comes into play because

1460
00:56:04,960 --> 00:56:06,960
delta is either zero or one so i can

1461
00:56:06,960 --> 00:56:09,440
take discrete log efficiently uh and one

1462
00:56:09,440 --> 00:56:10,880
from the lw assumption which is based on

1463
00:56:10,880 --> 00:56:12,880
the dual degree crypto system i just

1464
00:56:12,880 --> 00:56:16,160
believe to be post quantum secure and

1465
00:56:16,160 --> 00:56:17,920
update public key will now encrypt bit

1466
00:56:17,920 --> 00:56:19,359
by bit as such

1467
00:56:19,359 --> 00:56:21,680
um and then we show that the two schemes

1468
00:56:21,680 --> 00:56:22,559
that we're considering are

1469
00:56:22,559 --> 00:56:24,000
simultaneously circular secure and

1470
00:56:24,000 --> 00:56:26,000
leakage recipient we also introduce

1471
00:56:26,000 --> 00:56:27,680
stronger security models and present

1472
00:56:27,680 --> 00:56:30,720
constructions satisfy these models and

1473
00:56:30,720 --> 00:56:32,720
there is a possible abstraction here to

1474
00:56:32,720 --> 00:56:36,240
go from upk to upke we have identified

1475
00:56:36,240 --> 00:56:37,920
some kind of circular security kits

1476
00:56:37,920 --> 00:56:40,319
receiving simultaneous security

1477
00:56:40,319 --> 00:56:42,960
we need homomorphism and we seem to need

1478
00:56:42,960 --> 00:56:45,280
me as a journal of autism uh and our

1479
00:56:45,280 --> 00:56:47,680
constructions are all follow the same

1480
00:56:47,680 --> 00:56:49,280
blueprint but they're not genetic

1481
00:56:49,280 --> 00:56:50,960
construction so there are some inherent

1482
00:56:50,960 --> 00:56:52,640
subtleties in the construction itself

1483
00:56:52,640 --> 00:56:54,880
which makes it not peaceable to have a

1484
00:56:54,880 --> 00:56:57,280
genetic composition uh result

1485
00:56:57,280 --> 00:57:00,960
and this is the table so we obviously do

1486
00:57:00,960 --> 00:57:03,760
inherit uh some some performance loss

1487
00:57:03,760 --> 00:57:06,000
because when we go to the standard model

1488
00:57:06,000 --> 00:57:08,079
uh but we do have

1489
00:57:08,079 --> 00:57:10,160
both from ddh and lwe

1490
00:57:10,160 --> 00:57:11,280
so

1491
00:57:11,280 --> 00:57:13,040
on the dot at 12 i'm done that's all

1492
00:57:13,040 --> 00:57:15,599
folks thank you

1493
00:57:19,599 --> 00:57:21,680
okay we don't have time for questions

1494
00:57:21,680 --> 00:57:22,880
that's the end of the session let's

1495
00:57:22,880 --> 00:57:26,359
thank all the speakers

1496
00:57:26,880 --> 00:57:28,960
i

