1
00:00:00,880 --> 00:00:02,960
hello everybody my name is giovanni

2
00:00:02,960 --> 00:00:04,799
delegios

3
00:00:04,799 --> 00:00:08,639
i'm a phd student at eth in zurich and

4
00:00:08,639 --> 00:00:10,160
it's a pleasure for me today to be

5
00:00:10,160 --> 00:00:11,920
presenting joint work that was carried

6
00:00:11,920 --> 00:00:14,639
out with martin hirt and chandleyudzhang

7
00:00:14,639 --> 00:00:17,359
while at eth the title of the work is

8
00:00:17,359 --> 00:00:19,279
round efficient synchronous byzantine

9
00:00:19,279 --> 00:00:22,000
agreement and multi-party computation

10
00:00:22,000 --> 00:00:24,160
with asynchronous fallback

11
00:00:24,160 --> 00:00:26,160
i'll begin by providing some motivation

12
00:00:26,160 --> 00:00:28,160
for our work and then i'll dive into

13
00:00:28,160 --> 00:00:31,439
some more detail into the main results

14
00:00:31,439 --> 00:00:33,440
we deal with two prominent problems in

15
00:00:33,440 --> 00:00:36,000
distributed computing and cryptography

16
00:00:36,000 --> 00:00:37,600
namely the problem of byzantine

17
00:00:37,600 --> 00:00:39,680
agreement and the problem of multi-party

18
00:00:39,680 --> 00:00:41,200
computation

19
00:00:41,200 --> 00:00:43,440
a quick reminder in byzantine agreement

20
00:00:43,440 --> 00:00:46,079
a set of n parties each holding an input

21
00:00:46,079 --> 00:00:48,399
vi in 0 or 1

22
00:00:48,399 --> 00:00:51,199
want to agree on a common output

23
00:00:51,199 --> 00:00:52,960
in 0 or 1

24
00:00:52,960 --> 00:00:55,199
despite the fact that a fraction of the

25
00:00:55,199 --> 00:00:56,879
parties might be corrupted by an

26
00:00:56,879 --> 00:00:59,359
adversary and actively misbehaving and

27
00:00:59,359 --> 00:01:01,680
deviating from the protocol

28
00:01:01,680 --> 00:01:04,080
in multi-party computation which is a

29
00:01:04,080 --> 00:01:05,760
more general problem which includes

30
00:01:05,760 --> 00:01:08,880
byzantine agreement as a special case

31
00:01:08,880 --> 00:01:11,040
a set of n parties each holding an input

32
00:01:11,040 --> 00:01:13,520
in 0 or 1 wants to compute

33
00:01:13,520 --> 00:01:15,200
a common function of their inputs

34
00:01:15,200 --> 00:01:16,960
without revealing anything about their

35
00:01:16,960 --> 00:01:19,200
inputs that could not be inferred by

36
00:01:19,200 --> 00:01:21,040
looking directly at the output of the

37
00:01:21,040 --> 00:01:22,720
computation

38
00:01:22,720 --> 00:01:24,840
when designing protocols to solve these

39
00:01:24,840 --> 00:01:27,439
problems one needs to make assumptions

40
00:01:27,439 --> 00:01:29,759
about the network infrastructure that is

41
00:01:29,759 --> 00:01:32,079
available to the parties performing

42
00:01:32,079 --> 00:01:33,680
these protocols

43
00:01:33,680 --> 00:01:35,759
and typically in the literature two of

44
00:01:35,759 --> 00:01:37,520
the most prominent models that are

45
00:01:37,520 --> 00:01:40,479
considered are the synchronous model

46
00:01:40,479 --> 00:01:42,399
in which parties are assumed to have

47
00:01:42,399 --> 00:01:44,320
synchronized clocks

48
00:01:44,320 --> 00:01:47,360
and furthermore it's assumed that each

49
00:01:47,360 --> 00:01:49,840
message sent by a party is delivered

50
00:01:49,840 --> 00:01:53,040
within a certain known delay delta

51
00:01:53,040 --> 00:01:55,200
which is known to all parties and can be

52
00:01:55,200 --> 00:01:57,840
used in the design of protocols

53
00:01:57,840 --> 00:02:00,079
or another prominent model that is also

54
00:02:00,079 --> 00:02:02,479
assumed is the asynchronous model

55
00:02:02,479 --> 00:02:04,079
in which both of these assumptions are

56
00:02:04,079 --> 00:02:06,240
dropped and we assume that the adversary

57
00:02:06,240 --> 00:02:09,119
has the power of arbitrarily delivering

58
00:02:09,119 --> 00:02:10,720
the messages that are sent by honest

59
00:02:10,720 --> 00:02:12,000
parties

60
00:02:12,000 --> 00:02:14,000
and parties do not have access to

61
00:02:14,000 --> 00:02:16,000
synchronized clocks and the only

62
00:02:16,000 --> 00:02:17,920
assumption that we keep in this case is

63
00:02:17,920 --> 00:02:20,400
that all messages sent by honest parties

64
00:02:20,400 --> 00:02:21,760
are eventually delivered by the

65
00:02:21,760 --> 00:02:23,040
adversary

66
00:02:23,040 --> 00:02:24,640
it is not uncommon in both of these

67
00:02:24,640 --> 00:02:26,319
scenarios to assume that parties have

68
00:02:26,319 --> 00:02:27,920
access to authenticated channels and

69
00:02:27,920 --> 00:02:29,599
we're gonna keep this assumption as well

70
00:02:29,599 --> 00:02:31,599
the security guarantees that can be

71
00:02:31,599 --> 00:02:33,360
achieved in these two different models

72
00:02:33,360 --> 00:02:34,879
are different

73
00:02:34,879 --> 00:02:37,440
and in the synchronous models both ba

74
00:02:37,440 --> 00:02:39,760
and npc protocols can be achieved which

75
00:02:39,760 --> 00:02:43,120
are secure up to and half's corruptions

76
00:02:43,120 --> 00:02:44,959
but the problem is that as soon as the

77
00:02:44,959 --> 00:02:46,560
synchrony assumptions on the network are

78
00:02:46,560 --> 00:02:48,879
violated then all security guarantees

79
00:02:48,879 --> 00:02:51,680
tend to be lost pretty quickly

80
00:02:51,680 --> 00:02:53,599
and in the asynchronous model on the

81
00:02:53,599 --> 00:02:54,800
other hand

82
00:02:54,800 --> 00:02:56,879
the protocols that are designed are

83
00:02:56,879 --> 00:02:59,040
robust even in unpredictable networks

84
00:02:59,040 --> 00:03:00,560
but on the other hand the security

85
00:03:00,560 --> 00:03:02,080
guarantees that can be achieved are

86
00:03:02,080 --> 00:03:04,879
significantly weaker for example ba and

87
00:03:04,879 --> 00:03:07,599
npc protocols can only be achieved up to

88
00:03:07,599 --> 00:03:10,159
and third corruptions so when deploying

89
00:03:10,159 --> 00:03:12,640
protocols in real life networks which

90
00:03:12,640 --> 00:03:15,360
can be typically fast but experience

91
00:03:15,360 --> 00:03:17,519
occasional congestures or failures or

92
00:03:17,519 --> 00:03:18,480
delays

93
00:03:18,480 --> 00:03:20,400
then one is faced with a dilemma or

94
00:03:20,400 --> 00:03:22,319
whether modeling this network as a

95
00:03:22,319 --> 00:03:23,920
synchronous network and deploying

96
00:03:23,920 --> 00:03:25,200
protocols that are designed in the

97
00:03:25,200 --> 00:03:26,640
synchronous model

98
00:03:26,640 --> 00:03:28,879
therefore risking catastrophic security

99
00:03:28,879 --> 00:03:30,640
failures when the network experiences

100
00:03:30,640 --> 00:03:33,760
delays or whether to model this network

101
00:03:33,760 --> 00:03:35,760
as an asynchronous network and deploy

102
00:03:35,760 --> 00:03:38,000
the more robust protocols that are

103
00:03:38,000 --> 00:03:40,400
designed in the asynchronous model

104
00:03:40,400 --> 00:03:43,200
and then do not exploit

105
00:03:43,200 --> 00:03:45,200
the extra security guarantees that one

106
00:03:45,200 --> 00:03:47,440
could achieve by the fact that the

107
00:03:47,440 --> 00:03:50,159
network is usually fast so it's quite

108
00:03:50,159 --> 00:03:52,480
natural to ask the question of whether

109
00:03:52,480 --> 00:03:53,280
one

110
00:03:53,280 --> 00:03:55,280
could be able to design ba and mpc

111
00:03:55,280 --> 00:03:58,640
protocols that are secure for the

112
00:03:58,640 --> 00:04:01,120
maximum threshold corruptions in both

113
00:04:01,120 --> 00:04:02,799
the synchronous model and the

114
00:04:02,799 --> 00:04:05,519
asynchronous model a recent line of work

115
00:04:05,519 --> 00:04:07,920
starting in 2019 with the work of bloom

116
00:04:07,920 --> 00:04:10,239
cuts and loss and that was carried on in

117
00:04:10,239 --> 00:04:12,480
2020 by the work of bloom liu zhang and

118
00:04:12,480 --> 00:04:14,400
loss answered both of these questions

119
00:04:14,400 --> 00:04:16,079
affirmatively

120
00:04:16,079 --> 00:04:17,918
under some proven to be optimal

121
00:04:17,918 --> 00:04:19,600
threshold assumption and that is that

122
00:04:19,600 --> 00:04:21,279
the number of corruptions when the

123
00:04:21,279 --> 00:04:23,840
network is asynchronous plus two times

124
00:04:23,840 --> 00:04:25,040
the number of corruptions when the

125
00:04:25,040 --> 00:04:26,800
network is synchronous

126
00:04:26,800 --> 00:04:28,639
must be smaller than n

127
00:04:28,639 --> 00:04:30,560
and that the number of corruptions when

128
00:04:30,560 --> 00:04:32,880
the network is asynchronous must be

129
00:04:32,880 --> 00:04:34,479
smaller or equal than the number of

130
00:04:34,479 --> 00:04:35,600
corruption when the network is

131
00:04:35,600 --> 00:04:37,040
asynchronous

132
00:04:37,040 --> 00:04:38,639
when the network is asynchronous we

133
00:04:38,639 --> 00:04:40,400
refer to around

134
00:04:40,400 --> 00:04:42,720
as a time interval of length delta and

135
00:04:42,720 --> 00:04:43,840
since parties have access to

136
00:04:43,840 --> 00:04:46,000
synchronized clocks then they also have

137
00:04:46,000 --> 00:04:47,600
agreement on the current round they are

138
00:04:47,600 --> 00:04:48,960
currently in

139
00:04:48,960 --> 00:04:50,800
round complexity that is the number of

140
00:04:50,800 --> 00:04:52,639
rounds required by a protocol to

141
00:04:52,639 --> 00:04:53,680
terminate

142
00:04:53,680 --> 00:04:55,680
is often used as a measure of efficiency

143
00:04:55,680 --> 00:04:58,479
of protocols and our goal in this

144
00:04:58,479 --> 00:04:59,520
project

145
00:04:59,520 --> 00:05:01,919
is to improve on the round efficiency of

146
00:05:01,919 --> 00:05:04,479
known ba and mpc protocols

147
00:05:04,479 --> 00:05:06,639
known in the hybrid rehab

148
00:05:06,639 --> 00:05:09,039
so super quick i would like to give an

149
00:05:09,039 --> 00:05:11,199
overview or where the room for

150
00:05:11,199 --> 00:05:14,160
improvement in these protocols is

151
00:05:14,160 --> 00:05:15,840
let's start talking about byzantine

152
00:05:15,840 --> 00:05:17,759
agreement protocols so purely

153
00:05:17,759 --> 00:05:19,759
synchronous byzantine protocols

154
00:05:19,759 --> 00:05:22,080
achieving constant rounds are divided

155
00:05:22,080 --> 00:05:24,800
into two main categories there are monte

156
00:05:24,800 --> 00:05:27,120
carlo type protocols which run in a

157
00:05:27,120 --> 00:05:28,880
fixed number of rounds and achieve

158
00:05:28,880 --> 00:05:32,639
security up to a small error probability

159
00:05:32,639 --> 00:05:34,800
so this type of protocol

160
00:05:34,800 --> 00:05:36,720
has around complexity which is constant

161
00:05:36,720 --> 00:05:38,400
in a security parameter

162
00:05:38,400 --> 00:05:40,080
and then there's las vegas type

163
00:05:40,080 --> 00:05:42,479
protocols and these are protocols that

164
00:05:42,479 --> 00:05:44,160
whenever they terminate they achieve

165
00:05:44,160 --> 00:05:46,800
security but they only terminate with

166
00:05:46,800 --> 00:05:49,120
probability one and in this case they

167
00:05:49,120 --> 00:05:51,919
run with an expected constant number of

168
00:05:51,919 --> 00:05:55,440
rounds on the contrast protocols for ba

169
00:05:55,440 --> 00:05:58,000
that function in this hybrid realm that

170
00:05:58,000 --> 00:05:59,520
we've introduced

171
00:05:59,520 --> 00:06:01,199
they have around complexity which is

172
00:06:01,199 --> 00:06:02,479
linear in the number of party

173
00:06:02,479 --> 00:06:04,960
participating in the protocol so this is

174
00:06:04,960 --> 00:06:06,319
one of the places where there's room for

175
00:06:06,319 --> 00:06:08,400
improvement and now if we have a look at

176
00:06:08,400 --> 00:06:11,360
mpc protocols whose round complexity is

177
00:06:11,360 --> 00:06:13,680
typically calculated in terms of all to

178
00:06:13,680 --> 00:06:16,479
all broadcast rounds in the literature

179
00:06:16,479 --> 00:06:18,479
purely synchronous mpc protocols

180
00:06:18,479 --> 00:06:20,400
typically require a constant number of

181
00:06:20,400 --> 00:06:23,120
all 12 broadcast rounds while the known

182
00:06:23,120 --> 00:06:25,759
mpc protocols in the hybrid realm

183
00:06:25,759 --> 00:06:27,520
require a number of broadcast rounds

184
00:06:27,520 --> 00:06:29,199
that is linear in the depth

185
00:06:29,199 --> 00:06:30,960
multiplicative depth of the circuit to

186
00:06:30,960 --> 00:06:32,800
evaluate

187
00:06:32,800 --> 00:06:34,319
so this is the second place where there

188
00:06:34,319 --> 00:06:36,240
is room for improvement

189
00:06:36,240 --> 00:06:39,199
and in both cases we provide positive

190
00:06:39,199 --> 00:06:41,280
results meaning that

191
00:06:41,280 --> 00:06:44,240
we show the first known va protocol

192
00:06:44,240 --> 00:06:45,759
which is secure when run over a

193
00:06:45,759 --> 00:06:47,600
synchronous network and is also secure

194
00:06:47,600 --> 00:06:50,000
when run over an asynchronous network

195
00:06:50,000 --> 00:06:51,759
and that requires a constant number of

196
00:06:51,759 --> 00:06:53,520
rounds when the network is asynchronous

197
00:06:53,520 --> 00:06:56,080
and we provide both flavor of these ba

198
00:06:56,080 --> 00:06:58,080
protocols that is a version with

199
00:06:58,080 --> 00:07:00,720
probabilistic termination and a version

200
00:07:00,720 --> 00:07:02,960
running in a fixed number of rounds

201
00:07:02,960 --> 00:07:05,199
and for mpc we provided the first known

202
00:07:05,199 --> 00:07:07,360
mpc protocol

203
00:07:07,360 --> 00:07:09,199
which is secure when run over a

204
00:07:09,199 --> 00:07:10,880
synchronous network can remain secure

205
00:07:10,880 --> 00:07:13,120
when run over an asynchronous network

206
00:07:13,120 --> 00:07:16,000
and at the same time as a number of all

207
00:07:16,000 --> 00:07:18,080
told broadcast rounds which does not

208
00:07:18,080 --> 00:07:19,360
depend

209
00:07:19,360 --> 00:07:21,759
uh on the depth of the circuit to

210
00:07:21,759 --> 00:07:24,240
evaluate i will now dive into a little

211
00:07:24,240 --> 00:07:26,560
bit more depth in our constructions for

212
00:07:26,560 --> 00:07:29,440
byzantine agreement protocols but

213
00:07:29,440 --> 00:07:31,759
before i do that i think it's useful if

214
00:07:31,759 --> 00:07:33,520
we briefly recall

215
00:07:33,520 --> 00:07:35,759
the main properties that are desirable

216
00:07:35,759 --> 00:07:38,479
from a vicinity agreement protocol

217
00:07:38,479 --> 00:07:40,080
as you recall a byzantine agreement

218
00:07:40,080 --> 00:07:42,080
protocol is run between end parties of

219
00:07:42,080 --> 00:07:44,240
which each party holds an input in zero

220
00:07:44,240 --> 00:07:46,800
one and each party produces an output

221
00:07:46,800 --> 00:07:49,680
upon terminating the protocol and that

222
00:07:49,680 --> 00:07:52,240
output is gonna be either a bit zero one

223
00:07:52,240 --> 00:07:54,240
and we allow for an extra symbol called

224
00:07:54,240 --> 00:07:55,280
top

225
00:07:55,280 --> 00:07:57,120
that is gonna have the function of

226
00:07:57,120 --> 00:07:59,680
basically signaling when parties detect

227
00:07:59,680 --> 00:08:01,520
then the network they are running the

228
00:08:01,520 --> 00:08:04,960
protocol in is indeed asynchronous

229
00:08:04,960 --> 00:08:06,560
typically there are two main properties

230
00:08:06,560 --> 00:08:08,560
we require the validity property and the

231
00:08:08,560 --> 00:08:10,240
consistency property

232
00:08:10,240 --> 00:08:12,800
the validity property guarantees that if

233
00:08:12,800 --> 00:08:14,720
parties honest parties at least have

234
00:08:14,720 --> 00:08:17,360
pre-agreement on a certain bit before

235
00:08:17,360 --> 00:08:19,759
executing a ba protocol then they're

236
00:08:19,759 --> 00:08:21,919
going to preserve this agreement

237
00:08:21,919 --> 00:08:24,000
and they're all going to output this bit

238
00:08:24,000 --> 00:08:25,759
at the end of the protocol while the

239
00:08:25,759 --> 00:08:28,000
consistency property guarantees that

240
00:08:28,000 --> 00:08:29,919
even if parties are not in agreement

241
00:08:29,919 --> 00:08:32,640
before executing a protocol they will be

242
00:08:32,640 --> 00:08:35,120
upon terminating the protocol

243
00:08:35,120 --> 00:08:37,200
so it guarantees that each honest party

244
00:08:37,200 --> 00:08:39,360
outputs the same bit

245
00:08:39,360 --> 00:08:42,799
and in our case also we we allow for

246
00:08:42,799 --> 00:08:44,720
parties to all output the same top

247
00:08:44,720 --> 00:08:45,600
symbol

248
00:08:45,600 --> 00:08:46,800
since we're going to allow in our

249
00:08:46,800 --> 00:08:48,880
protocols for this unusual output

250
00:08:48,880 --> 00:08:51,040
behavior we introduce the liveness

251
00:08:51,040 --> 00:08:53,200
property which guarantees that under

252
00:08:53,200 --> 00:08:55,760
certain conditions parties do not output

253
00:08:55,760 --> 00:08:58,160
this extra symbol top and that is they

254
00:08:58,160 --> 00:09:00,480
really output a bit in zero one and

255
00:09:00,480 --> 00:09:02,000
we're going to see that we require

256
00:09:02,000 --> 00:09:03,920
protocols to have this liveness property

257
00:09:03,920 --> 00:09:06,160
only when the network is asynchronous so

258
00:09:06,160 --> 00:09:07,680
that when the network is asynchronous

259
00:09:07,680 --> 00:09:09,519
and then the va protocols achieve the

260
00:09:09,519 --> 00:09:11,040
same guarantees that are usually

261
00:09:11,040 --> 00:09:12,640
achieved by synchronous protocols in the

262
00:09:12,640 --> 00:09:14,240
literature

263
00:09:14,240 --> 00:09:16,560
another kind of validity property that

264
00:09:16,560 --> 00:09:18,720
we can require from va protocols is a

265
00:09:18,720 --> 00:09:20,800
weak validity and that means that if

266
00:09:20,800 --> 00:09:22,959
parties do have agreement on a bit

267
00:09:22,959 --> 00:09:25,279
before executing a protocol then they

268
00:09:25,279 --> 00:09:27,440
either output this bit or they output

269
00:09:27,440 --> 00:09:29,680
this top symbol and we're gonna see that

270
00:09:29,680 --> 00:09:31,760
we require this weaker form of validity

271
00:09:31,760 --> 00:09:33,360
from protocols when the network is

272
00:09:33,360 --> 00:09:36,000
asynchronous to achieve a ba protocol

273
00:09:36,000 --> 00:09:38,480
that is secure up to ts corruption when

274
00:09:38,480 --> 00:09:40,320
the network is asynchronous and that is

275
00:09:40,320 --> 00:09:42,080
also secure up to

276
00:09:42,080 --> 00:09:43,839
ta corruption when the network is

277
00:09:43,839 --> 00:09:46,399
asynchronous and i recall that by secure

278
00:09:46,399 --> 00:09:48,160
we mean that it achieves the validity

279
00:09:48,160 --> 00:09:50,640
and consistency guarantees the main idea

280
00:09:50,640 --> 00:09:53,040
is to run two ba protocols in succession

281
00:09:53,040 --> 00:09:55,360
and this idea is due to bloom cuts and

282
00:09:55,360 --> 00:09:58,800
loss and it was first published in 2019

283
00:09:58,800 --> 00:10:01,279
and from the synchronous ba protocol we

284
00:10:01,279 --> 00:10:02,880
require security when the network is

285
00:10:02,880 --> 00:10:04,880
synchronous up to ts corruptions and

286
00:10:04,880 --> 00:10:06,480
from the asynchronous protocol we

287
00:10:06,480 --> 00:10:08,560
require security when the network is

288
00:10:08,560 --> 00:10:10,640
asynchronous up to ta corruptions but

289
00:10:10,640 --> 00:10:12,560
also from these two protocols we require

290
00:10:12,560 --> 00:10:14,560
some extra security guarantees that

291
00:10:14,560 --> 00:10:16,560
protocols would not typically achieve

292
00:10:16,560 --> 00:10:18,320
and that is that from the synchronous

293
00:10:18,320 --> 00:10:20,320
protocol we require that when the

294
00:10:20,320 --> 00:10:22,880
network is asynchronous it also achieves

295
00:10:22,880 --> 00:10:24,480
this form of weak validity that we

296
00:10:24,480 --> 00:10:26,079
discussed before

297
00:10:26,079 --> 00:10:28,560
and from the asynchronous protocol we

298
00:10:28,560 --> 00:10:30,560
require that when the network is

299
00:10:30,560 --> 00:10:32,720
synchronous it achieves validity and

300
00:10:32,720 --> 00:10:36,720
termination up to ts corruptions and

301
00:10:36,720 --> 00:10:39,360
please recall that ts is

302
00:10:39,360 --> 00:10:42,079
generally larger than ta so this this is

303
00:10:42,079 --> 00:10:44,079
not a trivial property to achieve for an

304
00:10:44,079 --> 00:10:46,480
asynchronous protocol

305
00:10:46,480 --> 00:10:48,640
if indeed we have protocols with these

306
00:10:48,640 --> 00:10:50,880
extra properties then we can do a quick

307
00:10:50,880 --> 00:10:52,640
analysis to show that indeed this

308
00:10:52,640 --> 00:10:55,200
construction actually achieves security

309
00:10:55,200 --> 00:10:57,440
so if parties do have pre-agreement on a

310
00:10:57,440 --> 00:11:00,399
bit and the network is asynchronous

311
00:11:00,399 --> 00:11:01,519
then

312
00:11:01,519 --> 00:11:02,959
this pre-agreement is going to be

313
00:11:02,959 --> 00:11:04,880
maintained so the parties will all

314
00:11:04,880 --> 00:11:07,440
output a bit and then we'll run

315
00:11:07,440 --> 00:11:09,279
the asynchronous protocol again with

316
00:11:09,279 --> 00:11:11,120
pre-agreement and thanks to the validity

317
00:11:11,120 --> 00:11:13,120
plus termination property they're going

318
00:11:13,120 --> 00:11:15,200
to output the same bit

319
00:11:15,200 --> 00:11:16,560
on the other hand if the network is

320
00:11:16,560 --> 00:11:18,160
synchronous and parties do not have

321
00:11:18,160 --> 00:11:20,000
agreement on a bit

322
00:11:20,000 --> 00:11:22,640
then they will have agreement on a bit

323
00:11:22,640 --> 00:11:24,640
by the end of the synchronous protocol

324
00:11:24,640 --> 00:11:24,990
because

325
00:11:24,990 --> 00:11:26,720
[Music]

326
00:11:26,720 --> 00:11:28,399
this protocol is secure

327
00:11:28,399 --> 00:11:29,920
and then this agreement is going to be

328
00:11:29,920 --> 00:11:32,800
preserved by the asynchronous protocol

329
00:11:32,800 --> 00:11:34,959
and its validity

330
00:11:34,959 --> 00:11:36,720
property when the network is

331
00:11:36,720 --> 00:11:39,360
asynchronous on the other hand

332
00:11:39,360 --> 00:11:41,279
basically all the security guarantees

333
00:11:41,279 --> 00:11:44,000
fall on the asynchronous protocol and

334
00:11:44,000 --> 00:11:46,160
the only thing that the synchronous

335
00:11:46,160 --> 00:11:48,720
protocol guarantees is that indeed if

336
00:11:48,720 --> 00:11:50,800
parties do have pre-agreement on a bit

337
00:11:50,800 --> 00:11:53,200
then this agreement is not broken by

338
00:11:53,200 --> 00:11:54,959
running the synchronous protocol because

339
00:11:54,959 --> 00:11:56,959
this protocol achieves weak validity in

340
00:11:56,959 --> 00:11:59,279
an asynchronous network that means that

341
00:11:59,279 --> 00:12:01,200
if parties output the symbol top from

342
00:12:01,200 --> 00:12:02,639
this protocol

343
00:12:02,639 --> 00:12:04,560
then they're gonna go back and use their

344
00:12:04,560 --> 00:12:06,959
previous input vi as inputs to the

345
00:12:06,959 --> 00:12:09,279
second asynchronous protocol so they're

346
00:12:09,279 --> 00:12:11,200
still going to have pre-agreement upon

347
00:12:11,200 --> 00:12:13,680
entering the asynchronous protocol

348
00:12:13,680 --> 00:12:16,240
and then the security of the

349
00:12:16,240 --> 00:12:17,760
asynchronous protocol is going to

350
00:12:17,760 --> 00:12:19,920
guarantee that indeed

351
00:12:19,920 --> 00:12:21,440
security is achieved for the whole

352
00:12:21,440 --> 00:12:23,440
construction

353
00:12:23,440 --> 00:12:24,959
and now that we have introduced this

354
00:12:24,959 --> 00:12:26,480
high level idea

355
00:12:26,480 --> 00:12:28,160
we're going to observe that in the

356
00:12:28,160 --> 00:12:30,160
original construction by bloom cuts and

357
00:12:30,160 --> 00:12:33,279
loss these two ba protocols with extra

358
00:12:33,279 --> 00:12:35,920
properties were actually instantiated

359
00:12:35,920 --> 00:12:38,000
through some construction

360
00:12:38,000 --> 00:12:40,560
and the synchronous one in particular

361
00:12:40,560 --> 00:12:43,680
was achieved by a slight modification of

362
00:12:43,680 --> 00:12:47,760
the original du lev strong protocol

363
00:12:47,760 --> 00:12:50,240
which requires a linear number of rounds

364
00:12:50,240 --> 00:12:52,399
in the number of parties participating

365
00:12:52,399 --> 00:12:53,839
in the protocol

366
00:12:53,839 --> 00:12:56,240
um on the other hand the asynchronous

367
00:12:56,240 --> 00:12:58,480
protocol that they use already achieves

368
00:12:58,480 --> 00:13:00,000
a constant number of rounds when the

369
00:13:00,000 --> 00:13:03,760
network is asynchronous so the focus of

370
00:13:03,760 --> 00:13:06,079
our work is going to be of actually

371
00:13:06,079 --> 00:13:07,680
providing a construction for the

372
00:13:07,680 --> 00:13:10,000
synchronous portion of this compiler

373
00:13:10,000 --> 00:13:12,720
that runs in constant rounds and we're

374
00:13:12,720 --> 00:13:14,240
going to have to show

375
00:13:14,240 --> 00:13:16,079
a ba protocol that is securing a

376
00:13:16,079 --> 00:13:18,480
synchronous network up to ts corruptions

377
00:13:18,480 --> 00:13:21,200
and that achieves ta weak validity also

378
00:13:21,200 --> 00:13:24,160
when the network is asynchronous

379
00:13:24,160 --> 00:13:26,639
so this is what i'm going to do next

380
00:13:26,639 --> 00:13:28,880
but to discuss our construction i first

381
00:13:28,880 --> 00:13:30,880
have to introduce a different type of

382
00:13:30,880 --> 00:13:32,639
agreement primitive

383
00:13:32,639 --> 00:13:34,000
which is sometimes known in the

384
00:13:34,000 --> 00:13:37,279
literature as crusaders agreement

385
00:13:37,279 --> 00:13:39,279
but that has mostly been called lately

386
00:13:39,279 --> 00:13:41,680
weak consensus and weak consensus

387
00:13:41,680 --> 00:13:43,839
primitives they are very similar to

388
00:13:43,839 --> 00:13:46,399
byzantine agreement primitives but they

389
00:13:46,399 --> 00:13:50,320
have a relaxed consistency property so

390
00:13:50,320 --> 00:13:52,959
instead of asking for all honest parties

391
00:13:52,959 --> 00:13:55,920
to output the same the same output at

392
00:13:55,920 --> 00:13:57,920
the end of the protocol we're going to

393
00:13:57,920 --> 00:13:59,680
relax this property and we're only going

394
00:13:59,680 --> 00:14:01,920
to require that parties do not output

395
00:14:01,920 --> 00:14:03,680
contradicting bits at the end of the

396
00:14:03,680 --> 00:14:04,720
protocol

397
00:14:04,720 --> 00:14:05,760
now

398
00:14:05,760 --> 00:14:07,839
if the output

399
00:14:07,839 --> 00:14:10,320
set was only 0 and 1 this would be the

400
00:14:10,320 --> 00:14:11,839
same as asking the traditional

401
00:14:11,839 --> 00:14:14,480
consistency property but if we enlarge

402
00:14:14,480 --> 00:14:16,880
the output set to include other values

403
00:14:16,880 --> 00:14:18,800
in particular we allow the top value

404
00:14:18,800 --> 00:14:20,639
from before and now also a new value

405
00:14:20,639 --> 00:14:21,839
bottom

406
00:14:21,839 --> 00:14:24,160
then this property is strictly weaker

407
00:14:24,160 --> 00:14:28,240
than requiring normal consistency

408
00:14:28,240 --> 00:14:30,480
i now introduce our construction which

409
00:14:30,480 --> 00:14:32,399
is an adaptation of an idea originally

410
00:14:32,399 --> 00:14:34,320
due to feldman and mikali in the purely

411
00:14:34,320 --> 00:14:36,320
synchronous setting

412
00:14:36,320 --> 00:14:38,720
the idea is the following part is run in

413
00:14:38,720 --> 00:14:41,040
succession many iterations each

414
00:14:41,040 --> 00:14:43,600
iteration consists of an execution of a

415
00:14:43,600 --> 00:14:46,240
weak consensus protocol followed by a

416
00:14:46,240 --> 00:14:48,720
common coin toss invocation

417
00:14:48,720 --> 00:14:50,240
a common coin toss is simply a

418
00:14:50,240 --> 00:14:52,480
functionality that outputs a uniformly

419
00:14:52,480 --> 00:14:54,079
common random bit

420
00:14:54,079 --> 00:14:55,279
and that

421
00:14:55,279 --> 00:14:57,360
can only invoke if at least one honest

422
00:14:57,360 --> 00:14:59,839
party wishes to do so these kind of

423
00:14:59,839 --> 00:15:01,440
functionalities can easily be

424
00:15:01,440 --> 00:15:03,199
implemented through distributed

425
00:15:03,199 --> 00:15:05,920
protocols but in our paper we assume an

426
00:15:05,920 --> 00:15:07,360
ideal functionality with these

427
00:15:07,360 --> 00:15:08,800
properties

428
00:15:08,800 --> 00:15:10,399
in the purely synchronous setting the

429
00:15:10,399 --> 00:15:12,160
idea behind this construction is that if

430
00:15:12,160 --> 00:15:13,920
parties output a bit from the weak

431
00:15:13,920 --> 00:15:16,160
consensus protocol then they keep this

432
00:15:16,160 --> 00:15:18,320
bit as output of the whole iteration on

433
00:15:18,320 --> 00:15:20,639
the other hand if parties output the

434
00:15:20,639 --> 00:15:22,320
bottom symbol as output of the weak

435
00:15:22,320 --> 00:15:24,720
consensus protocol then they're gonna

436
00:15:24,720 --> 00:15:27,120
take the common coin value as output of

437
00:15:27,120 --> 00:15:29,279
the whole iteration instead

438
00:15:29,279 --> 00:15:31,279
now since weak consensus preserves

439
00:15:31,279 --> 00:15:33,199
pre-agreement if parties do have

440
00:15:33,199 --> 00:15:35,759
pre-agreement on a common bit then this

441
00:15:35,759 --> 00:15:37,440
this pre-agreement is never gonna be

442
00:15:37,440 --> 00:15:39,279
broken because they will just ignore the

443
00:15:39,279 --> 00:15:41,279
value of the common coin on the other

444
00:15:41,279 --> 00:15:42,800
hand if parties do not have

445
00:15:42,800 --> 00:15:44,720
pre-agreement on a bit

446
00:15:44,720 --> 00:15:47,120
then in each iterations they will reach

447
00:15:47,120 --> 00:15:48,959
agreement with probability at least one

448
00:15:48,959 --> 00:15:51,680
half that is the probability that the

449
00:15:51,680 --> 00:15:55,199
common coin value matches the output of

450
00:15:55,199 --> 00:15:56,959
the parties that did output a bit from

451
00:15:56,959 --> 00:15:59,120
the weak consensus protocol and remember

452
00:15:59,120 --> 00:16:01,759
that parties never output contradicting

453
00:16:01,759 --> 00:16:03,759
bits from a weak consensus protocol so

454
00:16:03,759 --> 00:16:05,680
all parties output the same bit or the

455
00:16:05,680 --> 00:16:07,600
bottom symbol

456
00:16:07,600 --> 00:16:08,560
so

457
00:16:08,560 --> 00:16:10,160
the problem is that when trying to

458
00:16:10,160 --> 00:16:11,920
transport this construction in the

459
00:16:11,920 --> 00:16:13,759
setting where you don't know what the

460
00:16:13,759 --> 00:16:15,759
network conditions are before executing

461
00:16:15,759 --> 00:16:18,079
the protocol you have no way of knowing

462
00:16:18,079 --> 00:16:18,959
whether

463
00:16:18,959 --> 00:16:20,720
if you don't receive a message you

464
00:16:20,720 --> 00:16:22,240
didn't receive this message because the

465
00:16:22,240 --> 00:16:23,680
network is asynchronous and the

466
00:16:23,680 --> 00:16:26,480
adversary drops this message or

467
00:16:26,480 --> 00:16:28,079
if the network is asynchronous and

468
00:16:28,079 --> 00:16:29,839
simply the party sending the message was

469
00:16:29,839 --> 00:16:32,079
corrupted and he never sent the message

470
00:16:32,079 --> 00:16:33,680
in the first place

471
00:16:33,680 --> 00:16:36,240
so the way we circumvent this problem is

472
00:16:36,240 --> 00:16:38,079
as follows instead of just allowing

473
00:16:38,079 --> 00:16:40,639
parties to have one abort behavior in

474
00:16:40,639 --> 00:16:42,880
the weak consensus protocol that is by

475
00:16:42,880 --> 00:16:45,120
outputting the bottom symbol we allow

476
00:16:45,120 --> 00:16:48,560
honest parties to have two different um

477
00:16:48,560 --> 00:16:51,040
abort behaviors in the weak consensus

478
00:16:51,040 --> 00:16:53,519
protocol that is either output a bottom

479
00:16:53,519 --> 00:16:55,920
symbol or outputting a top symbol and

480
00:16:55,920 --> 00:16:58,160
the difference is that we're able to

481
00:16:58,160 --> 00:16:59,600
throw some kind of detection in the

482
00:16:59,600 --> 00:17:02,079
protocol to make sure that when the

483
00:17:02,079 --> 00:17:04,319
network is synchronous parties never

484
00:17:04,319 --> 00:17:06,240
output the top symbol and when the

485
00:17:06,240 --> 00:17:08,400
network is asynchronous parties never

486
00:17:08,400 --> 00:17:10,720
output the bottom symbol so now the way

487
00:17:10,720 --> 00:17:12,640
we can recover the previous construction

488
00:17:12,640 --> 00:17:14,799
is as follows when parties output the

489
00:17:14,799 --> 00:17:16,720
bottom symbol they will take as output

490
00:17:16,720 --> 00:17:19,039
of the whole iteration simply the value

491
00:17:19,039 --> 00:17:20,480
of the common coin

492
00:17:20,480 --> 00:17:22,240
and when the parties output the top

493
00:17:22,240 --> 00:17:23,919
symbol they will simply take their

494
00:17:23,919 --> 00:17:26,319
original input as output of the whole

495
00:17:26,319 --> 00:17:28,559
iteration now remember that when the

496
00:17:28,559 --> 00:17:30,559
network is asynchronous we only care for

497
00:17:30,559 --> 00:17:33,679
weak validity so this makes sure that if

498
00:17:33,679 --> 00:17:35,600
parties have pre-agreement they will all

499
00:17:35,600 --> 00:17:38,080
output either the

500
00:17:38,080 --> 00:17:40,880
three agreed upon bit or the top symbol

501
00:17:40,880 --> 00:17:42,799
and in in either case they will take

502
00:17:42,799 --> 00:17:44,640
their original input as output of the

503
00:17:44,640 --> 00:17:47,120
iteration and preserve the pre-agreement

504
00:17:47,120 --> 00:17:49,760
through successive iterations

505
00:17:49,760 --> 00:17:51,760
so next i'm going to present our

506
00:17:51,760 --> 00:17:53,760
construction one of our constructions

507
00:17:53,760 --> 00:17:56,320
for such a weak consensus protocol try

508
00:17:56,320 --> 00:17:58,240
to go into some details and also argue

509
00:17:58,240 --> 00:18:00,320
informally about the security of such a

510
00:18:00,320 --> 00:18:03,039
protocol but i hope that the way this

511
00:18:03,039 --> 00:18:04,960
protocol fits into the bigger picture is

512
00:18:04,960 --> 00:18:06,080
now clear

513
00:18:06,080 --> 00:18:08,000
the protocol is actually quite short and

514
00:18:08,000 --> 00:18:10,000
simple in this we assume that parties

515
00:18:10,000 --> 00:18:11,280
have access to a public key

516
00:18:11,280 --> 00:18:13,760
infrastructure which allows them to sign

517
00:18:13,760 --> 00:18:16,320
messages but most importantly allows to

518
00:18:16,320 --> 00:18:18,720
forward cryptographic evidence that a

519
00:18:18,720 --> 00:18:20,799
certain message was received by another

520
00:18:20,799 --> 00:18:23,120
party in a previous round

521
00:18:23,120 --> 00:18:24,720
one of the big challenges in designing

522
00:18:24,720 --> 00:18:26,480
these protocols is that

523
00:18:26,480 --> 00:18:28,720
if the network condition is not known

524
00:18:28,720 --> 00:18:31,280
when parties begin the protocol then if

525
00:18:31,280 --> 00:18:33,120
a message is not received that was

526
00:18:33,120 --> 00:18:35,280
supposed to be received by a party this

527
00:18:35,280 --> 00:18:36,880
party has no way to know whether the

528
00:18:36,880 --> 00:18:38,480
message was dropped by the adversary

529
00:18:38,480 --> 00:18:40,080
because the network is asynchronous for

530
00:18:40,080 --> 00:18:41,120
example

531
00:18:41,120 --> 00:18:42,960
or if the party sending the message is

532
00:18:42,960 --> 00:18:45,200
corrupted by the adversary and did not

533
00:18:45,200 --> 00:18:47,440
send the message in the first place

534
00:18:47,440 --> 00:18:49,440
so the high level idea of how to deal

535
00:18:49,440 --> 00:18:51,600
with these is to carefully consider the

536
00:18:51,600 --> 00:18:53,919
thresholds of messages that a party

537
00:18:53,919 --> 00:18:56,000
needs to receive in order to decide that

538
00:18:56,000 --> 00:18:58,240
the network is synchronous

539
00:18:58,240 --> 00:19:00,160
in this protocol

540
00:19:00,160 --> 00:19:01,919
at the beginning each party signs their

541
00:19:01,919 --> 00:19:04,000
bit using their private key and send the

542
00:19:04,000 --> 00:19:06,480
sign bit to all other parties and then

543
00:19:06,480 --> 00:19:07,919
the parties

544
00:19:07,919 --> 00:19:09,600
collect the messages they receive and

545
00:19:09,600 --> 00:19:12,720
divide them into two sets the messages

546
00:19:12,720 --> 00:19:15,360
that were received with bit one and the

547
00:19:15,360 --> 00:19:16,880
messages that were received with bit

548
00:19:16,880 --> 00:19:20,240
zero so the first thing parties do is to

549
00:19:20,240 --> 00:19:21,760
look at the total number of messages

550
00:19:21,760 --> 00:19:23,120
they received

551
00:19:23,120 --> 00:19:25,280
and if the total number of messages they

552
00:19:25,280 --> 00:19:27,919
received is below a cutoff which is set

553
00:19:27,919 --> 00:19:30,960
to n minus ts and remember ta and ts in

554
00:19:30,960 --> 00:19:32,400
this case are parameters for the

555
00:19:32,400 --> 00:19:33,520
protocol

556
00:19:33,520 --> 00:19:35,440
then they simply set their intended

557
00:19:35,440 --> 00:19:37,760
output to top and they don't do any of

558
00:19:37,760 --> 00:19:39,919
the following steps if instead they

559
00:19:39,919 --> 00:19:41,840
received enough messages that is at

560
00:19:41,840 --> 00:19:43,760
least n minus ts

561
00:19:43,760 --> 00:19:46,160
then they check if they received a bit

562
00:19:46,160 --> 00:19:48,320
enough times and enough times we mean at

563
00:19:48,320 --> 00:19:51,440
least n minus ts minus ta times

564
00:19:51,440 --> 00:19:54,080
if this is the case they set their

565
00:19:54,080 --> 00:19:56,320
intended output to this bit

566
00:19:56,320 --> 00:19:58,240
and they collect all the signatures they

567
00:19:58,240 --> 00:20:01,039
received on this bit and they send

568
00:20:01,039 --> 00:20:02,960
the set of signatures to all other

569
00:20:02,960 --> 00:20:04,080
parties

570
00:20:04,080 --> 00:20:06,159
then if they receive no collection of

571
00:20:06,159 --> 00:20:08,159
signatures on the opposite bit of the

572
00:20:08,159 --> 00:20:10,720
one they receive they simply output the

573
00:20:10,720 --> 00:20:13,520
bits they decided and otherwise if they

574
00:20:13,520 --> 00:20:15,600
do receive a collection of signature on

575
00:20:15,600 --> 00:20:18,159
the opposite bit to the one they decided

576
00:20:18,159 --> 00:20:19,840
then they set their intended output to

577
00:20:19,840 --> 00:20:21,520
the bottom symbol and they output the

578
00:20:21,520 --> 00:20:23,200
bottom symbol

579
00:20:23,200 --> 00:20:25,679
so why does this construction work

580
00:20:25,679 --> 00:20:28,080
when we argue about the security of

581
00:20:28,080 --> 00:20:30,320
protocols that are run alternatively in

582
00:20:30,320 --> 00:20:32,559
synchronous and asynchronous networks we

583
00:20:32,559 --> 00:20:34,240
always need to consider both cases

584
00:20:34,240 --> 00:20:35,440
separately

585
00:20:35,440 --> 00:20:37,520
decide which properties we require from

586
00:20:37,520 --> 00:20:39,440
our protocols in the synchronous case

587
00:20:39,440 --> 00:20:41,600
and in the asynchronous case and then

588
00:20:41,600 --> 00:20:44,000
indeed prove that if this assumption

589
00:20:44,000 --> 00:20:46,159
hold then the desired properties are

590
00:20:46,159 --> 00:20:47,280
achieved

591
00:20:47,280 --> 00:20:49,120
when we argue in asynchronous networks

592
00:20:49,120 --> 00:20:50,720
we're going to assume that most ta

593
00:20:50,720 --> 00:20:52,480
parties are corrupted in execution of

594
00:20:52,480 --> 00:20:54,320
the protocol and when we argue in

595
00:20:54,320 --> 00:20:55,600
synchronous networks we're going to

596
00:20:55,600 --> 00:20:57,280
assume that most ts parties are

597
00:20:57,280 --> 00:20:58,720
corrupted in an execution of the

598
00:20:58,720 --> 00:21:00,640
protocol and we're also going to keep

599
00:21:00,640 --> 00:21:02,159
the assumption that i'm going to discuss

600
00:21:02,159 --> 00:21:05,679
later that ta plus 2ts is smaller than n

601
00:21:05,679 --> 00:21:08,880
and that ta is smaller or equal than ts

602
00:21:08,880 --> 00:21:10,320
and under these assumptions now i'm

603
00:21:10,320 --> 00:21:11,840
going to argue about the security of the

604
00:21:11,840 --> 00:21:14,320
protocol let's start by considering the

605
00:21:14,320 --> 00:21:16,080
synchronous case so let's first assume

606
00:21:16,080 --> 00:21:17,919
the network is asynchronous the

607
00:21:17,919 --> 00:21:20,559
properties we want to prove is

608
00:21:20,559 --> 00:21:22,640
validity of this protocol and weak

609
00:21:22,640 --> 00:21:24,720
consistency of this protocol and also we

610
00:21:24,720 --> 00:21:26,159
require then when the network is

611
00:21:26,159 --> 00:21:28,880
asynchronous parties do not output the

612
00:21:28,880 --> 00:21:31,520
symbol top

613
00:21:31,520 --> 00:21:32,320
so

614
00:21:32,320 --> 00:21:33,919
let's first check that when the network

615
00:21:33,919 --> 00:21:35,679
is asynchronous parties do not output

616
00:21:35,679 --> 00:21:37,520
the symbol top if the network is

617
00:21:37,520 --> 00:21:39,600
asynchronous then in step two each part

618
00:21:39,600 --> 00:21:41,919
is gonna send a validly signed message

619
00:21:41,919 --> 00:21:44,960
which means that in step three um

620
00:21:44,960 --> 00:21:46,640
the amount of messages each party

621
00:21:46,640 --> 00:21:49,039
receives it's gonna be at least n minus

622
00:21:49,039 --> 00:21:51,200
ts which means that parties are gonna

623
00:21:51,200 --> 00:21:54,480
set the intent output to bottom and

624
00:21:54,480 --> 00:21:56,240
since there's no other part in the

625
00:21:56,240 --> 00:21:58,080
protocol after these where parties might

626
00:21:58,080 --> 00:22:00,159
send their input to top then this

627
00:22:00,159 --> 00:22:01,760
property holds

628
00:22:01,760 --> 00:22:03,200
let's check now that if parties have

629
00:22:03,200 --> 00:22:05,120
pre-agreement on a certain bit and the

630
00:22:05,120 --> 00:22:06,799
network is asynchronous

631
00:22:06,799 --> 00:22:10,000
then indeed they will output this bit

632
00:22:10,000 --> 00:22:11,840
so if part is a pre-agreement let's say

633
00:22:11,840 --> 00:22:14,640
on bit 1 without loss of generality then

634
00:22:14,640 --> 00:22:16,559
in step 2 each part is going to send a

635
00:22:16,559 --> 00:22:19,600
validly signed bit 1 to other parties

636
00:22:19,600 --> 00:22:21,840
which means that in step 3 not only will

637
00:22:21,840 --> 00:22:24,480
parties receive enough values 1 that is

638
00:22:24,480 --> 00:22:27,840
n minus ts but they will also receive

639
00:22:27,840 --> 00:22:30,480
enough values so that they set their

640
00:22:30,480 --> 00:22:33,280
intended output to 1 because n minus ts

641
00:22:33,280 --> 00:22:35,280
is greater or equal than n minus ts

642
00:22:35,280 --> 00:22:36,880
minus ta

643
00:22:36,880 --> 00:22:38,799
and please notice that there is no way

644
00:22:38,799 --> 00:22:40,720
that corrupted parties can generate

645
00:22:40,720 --> 00:22:43,520
enough signatures on the opposite bit to

646
00:22:43,520 --> 00:22:45,360
convince honest parties to output the

647
00:22:45,360 --> 00:22:47,840
symbol bottom in step four because this

648
00:22:47,840 --> 00:22:51,280
would mean that ts is actually

649
00:22:51,280 --> 00:22:53,440
greater or equal than n minus ts minus

650
00:22:53,440 --> 00:22:55,919
ta and the assumption we have on our

651
00:22:55,919 --> 00:22:57,760
thresholds actually guarantee that this

652
00:22:57,760 --> 00:22:59,760
is not true so indeed when the network

653
00:22:59,760 --> 00:23:02,400
is asynchronous validity holds up to ts

654
00:23:02,400 --> 00:23:04,000
core options

655
00:23:04,000 --> 00:23:05,840
let's now check that when the network is

656
00:23:05,840 --> 00:23:07,760
asynchronous and at most ts parties are

657
00:23:07,760 --> 00:23:09,600
corrupted then the weak consistency

658
00:23:09,600 --> 00:23:10,960
property holds

659
00:23:10,960 --> 00:23:12,720
remember that weak consistency means

660
00:23:12,720 --> 00:23:15,039
that if a certain party outputs a bit

661
00:23:15,039 --> 00:23:17,280
then no party will output the opposite

662
00:23:17,280 --> 00:23:18,480
bit

663
00:23:18,480 --> 00:23:20,159
this property holds because let's assume

664
00:23:20,159 --> 00:23:21,840
a party outputs 1 without loss of

665
00:23:21,840 --> 00:23:25,120
generality this means that they received

666
00:23:25,120 --> 00:23:28,720
at least n minus ts messages minus ta

667
00:23:28,720 --> 00:23:32,080
with bit 1 in step 3

668
00:23:32,080 --> 00:23:34,000
which means they collect the signatures

669
00:23:34,000 --> 00:23:35,520
on these messages and they send them to

670
00:23:35,520 --> 00:23:37,919
all other parties in the following step

671
00:23:37,919 --> 00:23:39,840
so even if a party had decided on the

672
00:23:39,840 --> 00:23:41,679
opposite bit in step three then in step

673
00:23:41,679 --> 00:23:43,760
four they're gonna set their output to

674
00:23:43,760 --> 00:23:46,320
bottom because indeed these are valid

675
00:23:46,320 --> 00:23:48,400
signatures on bit one and this

676
00:23:48,400 --> 00:23:50,720
guarantees that no honest part is output

677
00:23:50,720 --> 00:23:52,720
contradicting bits

678
00:23:52,720 --> 00:23:54,720
this concludes the security when the

679
00:23:54,720 --> 00:23:57,039
network is synchronous now when network

680
00:23:57,039 --> 00:23:58,880
is asynchronous we still care about the

681
00:23:58,880 --> 00:24:01,039
weak validity property

682
00:24:01,039 --> 00:24:02,640
and let's assume the network is

683
00:24:02,640 --> 00:24:04,799
asynchronous that at most ta parties are

684
00:24:04,799 --> 00:24:06,240
corrupted in an execution of this

685
00:24:06,240 --> 00:24:07,440
protocol

686
00:24:07,440 --> 00:24:09,039
then

687
00:24:09,039 --> 00:24:10,960
we can easily check that if all parties

688
00:24:10,960 --> 00:24:13,360
have pre-agreement on a certain bit

689
00:24:13,360 --> 00:24:14,640
then

690
00:24:14,640 --> 00:24:16,400
they're gonna set their output to top

691
00:24:16,400 --> 00:24:18,480
and the only way they set their output

692
00:24:18,480 --> 00:24:20,240
to

693
00:24:20,240 --> 00:24:22,320
something other than top if it's in step

694
00:24:22,320 --> 00:24:24,400
three they reside they receive at least

695
00:24:24,400 --> 00:24:26,480
n minus ts messages

696
00:24:26,480 --> 00:24:28,880
since of these messages at least n minus

697
00:24:28,880 --> 00:24:31,520
ts minus ta are gonna come from honest

698
00:24:31,520 --> 00:24:33,279
parties since there are only ta

699
00:24:33,279 --> 00:24:36,000
corrupted parties then if indeed they do

700
00:24:36,000 --> 00:24:38,159
set their output to something other than

701
00:24:38,159 --> 00:24:40,080
bottom then they're gonna set this

702
00:24:40,080 --> 00:24:42,640
output to the

703
00:24:42,640 --> 00:24:44,240
to the

704
00:24:44,240 --> 00:24:47,039
agreed upon bit and also dishonest

705
00:24:47,039 --> 00:24:48,960
parties do not have the power to

706
00:24:48,960 --> 00:24:51,520
generate um

707
00:24:51,520 --> 00:24:53,440
enough signatures on the opposite bait

708
00:24:53,440 --> 00:24:55,919
to convince honest parties in step four

709
00:24:55,919 --> 00:24:58,320
to output the bottom symbol because this

710
00:24:58,320 --> 00:25:00,880
would mean then t a is greater or equal

711
00:25:00,880 --> 00:25:03,760
than n minus ts minus ta and this is

712
00:25:03,760 --> 00:25:06,000
false thanks to the assumptions we made

713
00:25:06,000 --> 00:25:07,840
on the thresholds

714
00:25:07,840 --> 00:25:09,440
plugging this construction for weak

715
00:25:09,440 --> 00:25:10,960
consensus into the high level

716
00:25:10,960 --> 00:25:13,279
construction we described before this

717
00:25:13,279 --> 00:25:15,760
already yields a ba protocol which is

718
00:25:15,760 --> 00:25:17,360
secure both in synchronous and

719
00:25:17,360 --> 00:25:19,600
asynchronous networks and that can run

720
00:25:19,600 --> 00:25:21,440
alternatively in fixed rounds or in

721
00:25:21,440 --> 00:25:23,520
expected constant rounds

722
00:25:23,520 --> 00:25:25,679
even though i'm not gonna go into detail

723
00:25:25,679 --> 00:25:27,440
of any other construction we provide in

724
00:25:27,440 --> 00:25:29,279
the paper we did investigate some other

725
00:25:29,279 --> 00:25:31,679
problems for example we investigated the

726
00:25:31,679 --> 00:25:33,840
optimality of the threshold assumptions

727
00:25:33,840 --> 00:25:35,440
we've just described

728
00:25:35,440 --> 00:25:37,520
when instead of asking full security in

729
00:25:37,520 --> 00:25:39,120
both synchronous and asynchronous

730
00:25:39,120 --> 00:25:41,200
networks for example we weakened the

731
00:25:41,200 --> 00:25:44,080
validity guarantees we require in

732
00:25:44,080 --> 00:25:46,000
asynchronous networks and indeed we

733
00:25:46,000 --> 00:25:48,480
prove that in this case these threshold

734
00:25:48,480 --> 00:25:50,559
assumptions are too strong and that one

735
00:25:50,559 --> 00:25:52,080
can actually achieve protocols with

736
00:25:52,080 --> 00:25:54,559
weaker threshold assumptions and this is

737
00:25:54,559 --> 00:25:56,080
interesting because sometimes these

738
00:25:56,080 --> 00:25:58,240
protocols with only weak validity can be

739
00:25:58,240 --> 00:26:00,720
used in bigger construction such as for

740
00:26:00,720 --> 00:26:02,799
example

741
00:26:02,799 --> 00:26:04,559
mpc or

742
00:26:04,559 --> 00:26:06,799
protocols that try to achieve different

743
00:26:06,799 --> 00:26:08,799
security guarantees in both synchronous

744
00:26:08,799 --> 00:26:10,559
and asynchronous networks

745
00:26:10,559 --> 00:26:12,559
we also provided some insight into the

746
00:26:12,559 --> 00:26:15,679
equivalence of the broadcast problem and

747
00:26:15,679 --> 00:26:18,000
the byzantine agreement protocol which

748
00:26:18,000 --> 00:26:19,600
indeed holds when the networks are

749
00:26:19,600 --> 00:26:21,360
synchronous and which is known not to

750
00:26:21,360 --> 00:26:23,520
hold when the networks are asynchronous

751
00:26:23,520 --> 00:26:26,159
and we show how to achieve respectively

752
00:26:26,159 --> 00:26:28,159
byzantine and broadcast protocols with

753
00:26:28,159 --> 00:26:29,679
these weak validity guarantees in

754
00:26:29,679 --> 00:26:32,559
asynchronous networks from one another

755
00:26:32,559 --> 00:26:35,440
thus solving this equivalence problem

756
00:26:35,440 --> 00:26:37,600
to finish we also worked in the mpc

757
00:26:37,600 --> 00:26:40,080
setting where we improved on on previous

758
00:26:40,080 --> 00:26:42,480
results by providing the first mpc

759
00:26:42,480 --> 00:26:44,080
protocol which is secure both in

760
00:26:44,080 --> 00:26:46,320
synchronous and asynchronous networks

761
00:26:46,320 --> 00:26:48,240
and that only requires a number of

762
00:26:48,240 --> 00:26:50,960
broadcast rounds all 12 broadcast rounds

763
00:26:50,960 --> 00:26:52,559
which is independent

764
00:26:52,559 --> 00:26:54,159
of the multiplicative depth of the

765
00:26:54,159 --> 00:26:55,919
circuit to evaluate

766
00:26:55,919 --> 00:26:57,840
to achieve this we used previous known

767
00:26:57,840 --> 00:27:00,720
results due to bloom yields and loss and

768
00:27:00,720 --> 00:27:02,559
also some known results about garbling

769
00:27:02,559 --> 00:27:04,799
circuits in the multi-party setting

770
00:27:04,799 --> 00:27:07,360
and indeed if we implement the broadcast

771
00:27:07,360 --> 00:27:09,120
channels in this protocol using our

772
00:27:09,120 --> 00:27:10,799
construction for broadcast which is

773
00:27:10,799 --> 00:27:12,159
secure in both synchronous and

774
00:27:12,159 --> 00:27:13,919
asynchronous networks

775
00:27:13,919 --> 00:27:15,919
then these broadcast channels can be

776
00:27:15,919 --> 00:27:17,600
implemented in such a way that the

777
00:27:17,600 --> 00:27:20,720
number of rounds required is constant in

778
00:27:20,720 --> 00:27:22,480
the number of parties participating in

779
00:27:22,480 --> 00:27:23,679
the protocol

780
00:27:23,679 --> 00:27:25,520
so this is it for this presentation

781
00:27:25,520 --> 00:27:27,600
thank you for listening so far it was a

782
00:27:27,600 --> 00:27:29,120
pleasure for me to be able to present

783
00:27:29,120 --> 00:27:31,520
this work here at tcc and

784
00:27:31,520 --> 00:27:33,039
please refer to the full version of

785
00:27:33,039 --> 00:27:35,279
these papers for all details and feel

786
00:27:35,279 --> 00:27:37,520
free to email me about questions and

787
00:27:37,520 --> 00:27:39,440
discussions about this work thank you

788
00:27:39,440 --> 00:27:42,600
very much

