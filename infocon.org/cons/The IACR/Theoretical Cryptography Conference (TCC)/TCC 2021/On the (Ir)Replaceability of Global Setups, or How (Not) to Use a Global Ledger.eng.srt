1
00:00:00,960 --> 00:00:04,240
hi my name is julia hesser i work at ibm

2
00:00:04,240 --> 00:00:07,359
research in zurich and i will be talking

3
00:00:07,359 --> 00:00:09,440
about the irreplaceability of global

4
00:00:09,440 --> 00:00:12,639
setups or how to not use a global ledger

5
00:00:12,639 --> 00:00:14,400
this is joint work with christian

6
00:00:14,400 --> 00:00:16,560
badager of iohk

7
00:00:16,560 --> 00:00:18,480
and visitors seekers of purdue

8
00:00:18,480 --> 00:00:21,199
university

9
00:00:22,640 --> 00:00:24,800
our work is about

10
00:00:24,800 --> 00:00:27,359
pitfalls in analyzing the security of

11
00:00:27,359 --> 00:00:31,359
protocols that run in concurrent systems

12
00:00:31,359 --> 00:00:34,160
so let me first give you some context

13
00:00:34,160 --> 00:00:35,280
when we

14
00:00:35,280 --> 00:00:37,760
define security of a protocol between

15
00:00:37,760 --> 00:00:39,760
alice and carol

16
00:00:39,760 --> 00:00:41,760
we ideally do not look at the protocol

17
00:00:41,760 --> 00:00:44,320
in isolation but we want to capture also

18
00:00:44,320 --> 00:00:47,120
the context of the protocol execution

19
00:00:47,120 --> 00:00:49,840
for example we want to specify how the

20
00:00:49,840 --> 00:00:51,840
adversary can influence the run of the

21
00:00:51,840 --> 00:00:53,440
protocol

22
00:00:53,440 --> 00:00:55,680
for even stronger security we want to

23
00:00:55,680 --> 00:00:57,760
also consider the protocol's context for

24
00:00:57,760 --> 00:01:00,719
example the behavior of other protocols

25
00:01:00,719 --> 00:01:02,800
that are accessed by ours

26
00:01:02,800 --> 00:01:04,720
for example public key infrastructure

27
00:01:04,720 --> 00:01:06,560
and even completely unrelated other

28
00:01:06,560 --> 00:01:09,040
protocols that might impact our protocol

29
00:01:09,040 --> 00:01:11,280
run

30
00:01:11,680 --> 00:01:13,600
for a

31
00:01:13,600 --> 00:01:15,920
protocol run over the internet the more

32
00:01:15,920 --> 00:01:18,320
context we capture the more relevant our

33
00:01:18,320 --> 00:01:21,520
analysis will become

34
00:01:21,759 --> 00:01:24,000
now essentially we have two options on

35
00:01:24,000 --> 00:01:26,080
how to actually define security of a

36
00:01:26,080 --> 00:01:27,280
protocol

37
00:01:27,280 --> 00:01:30,240
the first is so-called game-based

38
00:01:30,240 --> 00:01:32,880
security notions which are

39
00:01:32,880 --> 00:01:34,079
good for

40
00:01:34,079 --> 00:01:36,000
checking specific properties of a

41
00:01:36,000 --> 00:01:38,880
protocol for example the inability of

42
00:01:38,880 --> 00:01:41,680
the attacker to produce a signature

43
00:01:41,680 --> 00:01:43,520
fortunately

44
00:01:43,520 --> 00:01:46,159
the second way is simulation-based

45
00:01:46,159 --> 00:01:47,439
security

46
00:01:47,439 --> 00:01:48,320
um

47
00:01:48,320 --> 00:01:50,640
or simulation-based and notions which

48
00:01:50,640 --> 00:01:53,600
are good for specifying

49
00:01:53,600 --> 00:01:56,079
the expected behavior of a protocol in

50
00:01:56,079 --> 00:01:57,920
arbitrary contexts

51
00:01:57,920 --> 00:01:59,600
in this talk we focus on

52
00:01:59,600 --> 00:02:03,039
simulation-based security

53
00:02:04,320 --> 00:02:06,240
let's first do a quick recap of

54
00:02:06,240 --> 00:02:08,800
simulation-based security

55
00:02:08,800 --> 00:02:10,800
simulation-based security is a real

56
00:02:10,800 --> 00:02:12,000
ideal

57
00:02:12,000 --> 00:02:15,520
notion in which a real protocol run

58
00:02:15,520 --> 00:02:16,560
here

59
00:02:16,560 --> 00:02:18,959
on the left-hand side of protocol row

60
00:02:18,959 --> 00:02:21,120
has to look like an ideal idealized

61
00:02:21,120 --> 00:02:23,520
version of it you see the real execution

62
00:02:23,520 --> 00:02:25,040
on the left and the ideal one on the

63
00:02:25,040 --> 00:02:26,080
right

64
00:02:26,080 --> 00:02:28,879
the idealization is captured by a

65
00:02:28,879 --> 00:02:31,360
so-called ideal functionality f

66
00:02:31,360 --> 00:02:33,440
which you can simply imagine to be a

67
00:02:33,440 --> 00:02:36,000
code run by a trusted party which takes

68
00:02:36,000 --> 00:02:38,720
secret inputs of parties computes

69
00:02:38,720 --> 00:02:40,959
protocol outputs from the inputs and

70
00:02:40,959 --> 00:02:43,120
then securely hands parties back their

71
00:02:43,120 --> 00:02:44,879
outputs

72
00:02:44,879 --> 00:02:47,040
the protocol row is set to securely

73
00:02:47,040 --> 00:02:49,680
realize such functionality f

74
00:02:49,680 --> 00:02:51,760
if all attacks that can be conducted

75
00:02:51,760 --> 00:02:52,879
against

76
00:02:52,879 --> 00:02:55,120
an execution of row

77
00:02:55,120 --> 00:02:56,560
in the real world

78
00:02:56,560 --> 00:02:59,040
can be simulated in the world where the

79
00:02:59,040 --> 00:03:02,239
ideal functionality f is executed

80
00:03:02,239 --> 00:03:04,959
you can see here that the simulator

81
00:03:04,959 --> 00:03:07,360
takes the place of

82
00:03:07,360 --> 00:03:10,080
of the of the adversary

83
00:03:10,080 --> 00:03:12,319
um in the ideal world which is why the

84
00:03:12,319 --> 00:03:14,560
simulator is often also called the ideal

85
00:03:14,560 --> 00:03:17,800
world adversary

86
00:03:18,640 --> 00:03:20,800
the simulator needs to

87
00:03:20,800 --> 00:03:23,599
simulate essentially the effect of

88
00:03:23,599 --> 00:03:25,920
an execution of row also on other

89
00:03:25,920 --> 00:03:27,519
protocols

90
00:03:27,519 --> 00:03:30,840
for example the pki to ensure that the

91
00:03:30,840 --> 00:03:33,760
state of the of the pki is not

92
00:03:33,760 --> 00:03:35,680
distinguishable from

93
00:03:35,680 --> 00:03:37,599
uh well essentially the counterpart of

94
00:03:37,599 --> 00:03:40,239
the pki and the in the real world over

95
00:03:40,239 --> 00:03:42,480
here

96
00:03:44,080 --> 00:03:45,920
um the distinguisher who tests

97
00:03:45,920 --> 00:03:48,319
assimilation uh is allowed to determine

98
00:03:48,319 --> 00:03:51,120
the inputs uh of the of the parties it's

99
00:03:51,120 --> 00:03:53,360
also allowed to see the outputs and uh

100
00:03:53,360 --> 00:03:55,200
most importantly to interact with the

101
00:03:55,200 --> 00:03:57,760
adversary which is a in the real world

102
00:03:57,760 --> 00:04:00,319
and the simulator in the ideal world for

103
00:04:00,319 --> 00:04:02,480
example the distinguisher might ask the

104
00:04:02,480 --> 00:04:05,840
adversary about the state of the pki

105
00:04:05,840 --> 00:04:09,040
the protocol is said to be secure or

106
00:04:09,040 --> 00:04:11,840
securely realizing the function rdf if

107
00:04:11,840 --> 00:04:13,760
the distinguisher cannot tell who he

108
00:04:13,760 --> 00:04:17,199
runs with so either he runs with

109
00:04:17,199 --> 00:04:19,358
the real protocol row and the real world

110
00:04:19,358 --> 00:04:21,199
adversary or he runs with the ideal

111
00:04:21,199 --> 00:04:24,800
functionality and the

112
00:04:27,600 --> 00:04:28,639
to simulator

113
00:04:28,639 --> 00:04:31,199
security of our protocol in a simulation

114
00:04:31,199 --> 00:04:33,440
based framework we need to

115
00:04:33,440 --> 00:04:37,040
specify an ideal functionality that

116
00:04:37,040 --> 00:04:40,160
captures the security and functionality

117
00:04:40,160 --> 00:04:42,400
of the primitive

118
00:04:42,400 --> 00:04:44,960
in an abstract way i did this example

119
00:04:44,960 --> 00:04:47,520
here for the case of commitments

120
00:04:47,520 --> 00:04:48,479
um

121
00:04:48,479 --> 00:04:50,560
the this commitment functionality ofcom

122
00:04:50,560 --> 00:04:52,560
essentially carries out um

123
00:04:52,560 --> 00:04:54,880
well an ideal commitment scheme as it

124
00:04:54,880 --> 00:04:58,080
would be performed by a trusted party

125
00:04:58,080 --> 00:05:01,360
essentially it takes um it records a

126
00:05:01,360 --> 00:05:04,160
message from alice and whenever alice

127
00:05:04,160 --> 00:05:07,120
would send an opening command

128
00:05:07,120 --> 00:05:11,759
it would send the message to carol

129
00:05:11,759 --> 00:05:14,160
the functionality also specifies

130
00:05:14,160 --> 00:05:15,840
which attacks on the commitment scheme

131
00:05:15,840 --> 00:05:17,840
are unavoidable even

132
00:05:17,840 --> 00:05:20,240
in an ideal world by providing this

133
00:05:20,240 --> 00:05:22,880
adversarial interface here to the to

134
00:05:22,880 --> 00:05:25,039
this interface here to the adversary as

135
00:05:25,039 --> 00:05:26,320
you can see

136
00:05:26,320 --> 00:05:28,720
um we define a secure commitment by only

137
00:05:28,720 --> 00:05:30,720
notifying the adversary essentially that

138
00:05:30,720 --> 00:05:33,440
the protocol steps took place

139
00:05:33,440 --> 00:05:35,280
most importantly we

140
00:05:35,280 --> 00:05:37,280
ensure that the commitment is hiding by

141
00:05:37,280 --> 00:05:39,280
not leaking the message m to the

142
00:05:39,280 --> 00:05:41,680
adversary and by also not letting the

143
00:05:41,680 --> 00:05:44,240
adversary influence the message that is

144
00:05:44,240 --> 00:05:45,840
output

145
00:05:45,840 --> 00:05:48,719
output to carol

146
00:05:50,000 --> 00:05:52,000
it should be fairly obvious that any

147
00:05:52,000 --> 00:05:54,160
extension to this adverse adversarial

148
00:05:54,160 --> 00:05:56,880
interface makes the simulation and hence

149
00:05:56,880 --> 00:05:59,199
also

150
00:05:59,360 --> 00:06:02,639
proving easier but at the same time it

151
00:06:02,639 --> 00:06:07,240
of course weakens a security statement

152
00:06:08,160 --> 00:06:10,400
this relates to the following artifact

153
00:06:10,400 --> 00:06:12,319
of simulation by security

154
00:06:12,319 --> 00:06:15,520
a protocol row that securely realizes

155
00:06:15,520 --> 00:06:17,600
this commitment functionality from the

156
00:06:17,600 --> 00:06:18,840
last slide

157
00:06:18,840 --> 00:06:23,680
also securely realizes an insecure non

158
00:06:23,680 --> 00:06:25,840
for example non-hiding

159
00:06:25,840 --> 00:06:27,360
commitment functionality where the

160
00:06:27,360 --> 00:06:29,680
message is leaked to the to the to the

161
00:06:29,680 --> 00:06:31,600
adversary this is essentially because

162
00:06:31,600 --> 00:06:33,199
the simulator

163
00:06:33,199 --> 00:06:35,039
from the former statement also works for

164
00:06:35,039 --> 00:06:36,639
the letter the simulator will simply

165
00:06:36,639 --> 00:06:38,000
ignore knowledge knowledge of the

166
00:06:38,000 --> 00:06:39,360
message that it obtains from the

167
00:06:39,360 --> 00:06:41,440
functionality

168
00:06:41,440 --> 00:06:44,240
this means that

169
00:06:44,319 --> 00:06:47,039
if a protocol row securely realizes the

170
00:06:47,039 --> 00:06:48,960
commitment functionality have come from

171
00:06:48,960 --> 00:06:52,000
the previous slide then it also securely

172
00:06:52,000 --> 00:06:53,919
realizes any functionality that is

173
00:06:53,919 --> 00:06:57,520
strictly weaker than fcom

174
00:06:57,520 --> 00:07:00,240
of course the latter statement

175
00:07:00,240 --> 00:07:01,680
is not very interesting because it's

176
00:07:01,680 --> 00:07:03,120
quite weak

177
00:07:03,120 --> 00:07:04,240
but it demonstrates that

178
00:07:04,240 --> 00:07:06,560
simulation-based security is what we

179
00:07:06,560 --> 00:07:08,400
will in this

180
00:07:08,400 --> 00:07:11,919
talk call an at least a secure notion

181
00:07:11,919 --> 00:07:13,840
we demonstrate that the protocol is at

182
00:07:13,840 --> 00:07:15,440
least as secure as the ideal

183
00:07:15,440 --> 00:07:17,840
functionality

184
00:07:18,880 --> 00:07:20,639
i also want you to note that the gap

185
00:07:20,639 --> 00:07:23,680
between both sides might be arbitrarily

186
00:07:23,680 --> 00:07:26,080
large

187
00:07:29,199 --> 00:07:31,440
simulation based notions have a great

188
00:07:31,440 --> 00:07:33,680
benefit over game-based notions

189
00:07:33,680 --> 00:07:35,759
they come with composition theorems so

190
00:07:35,759 --> 00:07:37,680
let me show how such a theorem can be

191
00:07:37,680 --> 00:07:39,039
applied

192
00:07:39,039 --> 00:07:41,280
assume you designed a voting protocol

193
00:07:41,280 --> 00:07:44,240
role which uses a commitment scheme as a

194
00:07:44,240 --> 00:07:46,879
building block

195
00:07:48,560 --> 00:07:50,879
you conducted a security analysis which

196
00:07:50,879 --> 00:07:53,039
demonstrates that your protocol securely

197
00:07:53,039 --> 00:07:56,000
realizes the ideal voting functionality

198
00:07:56,000 --> 00:07:57,759
of voting

199
00:07:57,759 --> 00:08:00,000
and in this proof you abstract it from

200
00:08:00,000 --> 00:08:01,840
the commitment scheme that is used by

201
00:08:01,840 --> 00:08:03,280
the protocol

202
00:08:03,280 --> 00:08:04,560
by

203
00:08:04,560 --> 00:08:07,199
simply using this ideal

204
00:08:07,199 --> 00:08:09,520
commitment functionality from our slide

205
00:08:09,520 --> 00:08:11,759
before

206
00:08:11,759 --> 00:08:12,560
now

207
00:08:12,560 --> 00:08:14,080
what you also do is you search the

208
00:08:14,080 --> 00:08:16,560
literature and find for example that

209
00:08:16,560 --> 00:08:19,199
peterson commitments securely realize

210
00:08:19,199 --> 00:08:22,960
the ideal commitment functionality

211
00:08:23,599 --> 00:08:26,639
now the composition theorem tells you

212
00:08:26,639 --> 00:08:29,199
that you can essentially combine both

213
00:08:29,199 --> 00:08:31,360
proofs while preserving your original

214
00:08:31,360 --> 00:08:32,399
statement

215
00:08:32,399 --> 00:08:34,399
namely that row is a secure voting

216
00:08:34,399 --> 00:08:36,799
protocol so this is what we call or

217
00:08:36,799 --> 00:08:38,479
would call like a modular security

218
00:08:38,479 --> 00:08:40,958
analysis and it essentially saves you

219
00:08:40,958 --> 00:08:44,159
from implicitly proving

220
00:08:44,159 --> 00:08:46,320
security of paterson commitments while

221
00:08:46,320 --> 00:08:48,000
you prove security of your voting

222
00:08:48,000 --> 00:08:50,560
protocol

223
00:08:53,040 --> 00:08:56,399
now remember what i said um before about

224
00:08:56,399 --> 00:08:58,640
secure realization translating to at

225
00:08:58,640 --> 00:09:00,399
least a secure

226
00:09:00,399 --> 00:09:02,560
this is actually a key component in the

227
00:09:02,560 --> 00:09:04,880
proof of a composition theorem

228
00:09:04,880 --> 00:09:06,399
on this slide we have

229
00:09:06,399 --> 00:09:08,399
exactly the same setting as before with

230
00:09:08,399 --> 00:09:11,200
a voting protocol row

231
00:09:11,200 --> 00:09:13,519
which uses a commitment protocol as a

232
00:09:13,519 --> 00:09:16,240
building block

233
00:09:16,399 --> 00:09:19,120
so the commitment protocol pi is

234
00:09:19,120 --> 00:09:21,519
securely realizes fcom which translates

235
00:09:21,519 --> 00:09:25,040
to pi is at least as secure as f-com or

236
00:09:25,040 --> 00:09:27,519
pi admits less attacks than the ideal

237
00:09:27,519 --> 00:09:30,080
commitment functionality

238
00:09:30,080 --> 00:09:32,880
that means um that we can

239
00:09:32,880 --> 00:09:35,360
if we can if we replace

240
00:09:35,360 --> 00:09:37,519
the commitment functionality in our

241
00:09:37,519 --> 00:09:40,000
security statement

242
00:09:40,000 --> 00:09:42,320
and by the protocol pi

243
00:09:42,320 --> 00:09:44,720
the adversary a prime here

244
00:09:44,720 --> 00:09:47,600
becomes restricted because it can

245
00:09:47,600 --> 00:09:49,680
essentially mount lesser attacks than

246
00:09:49,680 --> 00:09:52,560
against pi than it could here against

247
00:09:52,560 --> 00:09:53,519
f-com

248
00:09:53,519 --> 00:09:55,360
right and for this restricted adversary

249
00:09:55,360 --> 00:09:58,080
it seems quite well quite intuitively

250
00:09:58,080 --> 00:10:00,080
that we can find a simulator which we

251
00:10:00,080 --> 00:10:02,320
now can essentially combine from this

252
00:10:02,320 --> 00:10:04,800
simulator here and the simulator for the

253
00:10:04,800 --> 00:10:07,599
commitment here

254
00:10:08,640 --> 00:10:10,399
so it's really the restricted number of

255
00:10:10,399 --> 00:10:13,120
attacks um compared to the original

256
00:10:13,120 --> 00:10:14,160
original

257
00:10:14,160 --> 00:10:16,839
original security proof

258
00:10:16,839 --> 00:10:20,000
um which

259
00:10:20,000 --> 00:10:21,200
lets us

260
00:10:21,200 --> 00:10:24,640
in general replace

261
00:10:25,279 --> 00:10:27,839
protocol building blocks by more secure

262
00:10:27,839 --> 00:10:30,839
realizations

263
00:10:34,640 --> 00:10:36,880
that essentially concludes our recap of

264
00:10:36,880 --> 00:10:39,680
simulation-based security

265
00:10:39,680 --> 00:10:43,120
and composition theorems our work is

266
00:10:43,120 --> 00:10:45,519
about replacement of specific types of

267
00:10:45,519 --> 00:10:47,279
protocol building blocks that are

268
00:10:47,279 --> 00:10:49,760
commonly called setups

269
00:10:49,760 --> 00:10:52,480
so you see a setup here

270
00:10:52,480 --> 00:10:54,800
they are usually abstracted as ideal

271
00:10:54,800 --> 00:10:57,600
functionalities and can be called by

272
00:10:57,600 --> 00:10:59,360
well essentially the parties parties

273
00:10:59,360 --> 00:11:00,959
running the protocol alice and carol

274
00:11:00,959 --> 00:11:02,079
here

275
00:11:02,079 --> 00:11:04,320
you might be familiar with some of them

276
00:11:04,320 --> 00:11:06,399
for example

277
00:11:06,399 --> 00:11:08,240
public key infrastructure a bulletin

278
00:11:08,240 --> 00:11:10,640
board a common reference string or a

279
00:11:10,640 --> 00:11:14,040
random oracle

280
00:11:14,079 --> 00:11:16,720
there's essentially two ways of

281
00:11:16,720 --> 00:11:19,920
modeling protocol setups first there's

282
00:11:19,920 --> 00:11:22,320
normal or local setups that are

283
00:11:22,320 --> 00:11:24,640
exclusively available

284
00:11:24,640 --> 00:11:28,160
only to the protocol that we consider so

285
00:11:28,160 --> 00:11:29,920
only to the protocol row of which we

286
00:11:29,920 --> 00:11:31,279
want to prove security only this

287
00:11:31,279 --> 00:11:33,600
protocol can access this

288
00:11:33,600 --> 00:11:35,680
this ideal crs functionality common

289
00:11:35,680 --> 00:11:39,040
reference string functionality

290
00:11:40,160 --> 00:11:41,279
um

291
00:11:41,279 --> 00:11:44,240
since the state of the crs for example

292
00:11:44,240 --> 00:11:46,640
at which point it is set or how often

293
00:11:46,640 --> 00:11:49,040
often it was retrieved by the parties is

294
00:11:49,040 --> 00:11:51,360
only manipulated by the protocol row in

295
00:11:51,360 --> 00:11:55,200
the real world in the ideal world

296
00:11:55,200 --> 00:11:56,959
um the simulator

297
00:11:56,959 --> 00:11:57,839
um

298
00:11:57,839 --> 00:11:59,440
now essentially

299
00:11:59,440 --> 00:12:00,800
has to

300
00:12:00,800 --> 00:12:04,000
simulate the impact of only row on the

301
00:12:04,000 --> 00:12:06,720
crs functionality

302
00:12:06,720 --> 00:12:08,480
but this is actually

303
00:12:08,480 --> 00:12:10,399
a great relief for the simulator because

304
00:12:10,399 --> 00:12:14,720
it can now completely control the crs

305
00:12:14,720 --> 00:12:16,639
it can essentially choose it freely it

306
00:12:16,639 --> 00:12:20,079
can even plant a trapdoor

307
00:12:20,480 --> 00:12:21,600
and

308
00:12:21,600 --> 00:12:24,240
essentially such local setups they they

309
00:12:24,240 --> 00:12:25,760
really never make the life of the

310
00:12:25,760 --> 00:12:28,079
simulator harder and even often they

311
00:12:28,079 --> 00:12:30,320
make it way easier to find to find

312
00:12:30,320 --> 00:12:33,440
working simulators

313
00:12:34,000 --> 00:12:35,920
in many concrete simulation based

314
00:12:35,920 --> 00:12:37,839
frameworks there exist various

315
00:12:37,839 --> 00:12:39,200
impossibility results about

316
00:12:39,200 --> 00:12:41,279
functionalities that do not even have

317
00:12:41,279 --> 00:12:43,440
secure realizations in the absence of

318
00:12:43,440 --> 00:12:45,200
any local setup

319
00:12:45,200 --> 00:12:47,279
commitments are one example they require

320
00:12:47,279 --> 00:12:50,079
usually at least a crs to

321
00:12:50,079 --> 00:12:53,839
to achieve simulation based security

322
00:12:54,560 --> 00:12:57,360
so as i said this paper is about setups

323
00:12:57,360 --> 00:12:59,600
um but it is really about replacing

324
00:12:59,600 --> 00:13:01,760
setups by another protocol

325
00:13:01,760 --> 00:13:03,839
on this slide you could for example ask

326
00:13:03,839 --> 00:13:05,920
whether it's possible to replace the

327
00:13:05,920 --> 00:13:09,600
ideal crs functionality fcrs

328
00:13:09,600 --> 00:13:11,760
which essentially chooses a string at

329
00:13:11,760 --> 00:13:13,360
random and gives it to everybody who

330
00:13:13,360 --> 00:13:15,440
asked for it

331
00:13:15,440 --> 00:13:17,040
you could ask whether you could replace

332
00:13:17,040 --> 00:13:18,079
this

333
00:13:18,079 --> 00:13:20,959
distrusted trusted building block with

334
00:13:20,959 --> 00:13:23,040
an interactive protocol that lets alice

335
00:13:23,040 --> 00:13:25,839
and and carol somehow agree on a truly

336
00:13:25,839 --> 00:13:27,120
random string

337
00:13:27,120 --> 00:13:29,839
right and the answer is actually already

338
00:13:29,839 --> 00:13:31,600
given by standard by the standard

339
00:13:31,600 --> 00:13:34,079
composition composition theorem that i

340
00:13:34,079 --> 00:13:36,639
that i showed you before we can safely

341
00:13:36,639 --> 00:13:39,680
replace the local fcrs by any protocol

342
00:13:39,680 --> 00:13:42,079
that securely realizes it just that we

343
00:13:42,079 --> 00:13:44,880
did as we did for an ideal commitment

344
00:13:44,880 --> 00:13:48,279
building block

345
00:13:49,920 --> 00:13:53,279
so a local setup is really nothing else

346
00:13:53,279 --> 00:13:54,959
than a normal

347
00:13:54,959 --> 00:13:57,120
abstract protocol building block and its

348
00:13:57,120 --> 00:14:00,079
replacement is possible using standard

349
00:14:00,079 --> 00:14:03,079
composition

350
00:14:06,079 --> 00:14:08,639
there's another type of

351
00:14:08,639 --> 00:14:10,240
of setup

352
00:14:10,240 --> 00:14:11,440
which

353
00:14:11,440 --> 00:14:14,000
is the global setup

354
00:14:14,000 --> 00:14:16,000
i will denote global setups with this

355
00:14:16,000 --> 00:14:18,160
curly curly

356
00:14:18,160 --> 00:14:20,800
curly letter g on the slides

357
00:14:20,800 --> 00:14:22,800
um and the difference to a local setup

358
00:14:22,800 --> 00:14:25,519
is that global setups can be essentially

359
00:14:25,519 --> 00:14:28,160
accessed by other protocols as well

360
00:14:28,160 --> 00:14:29,920
so consider for example the public key

361
00:14:29,920 --> 00:14:33,760
infrastructure that is used for both

362
00:14:33,760 --> 00:14:36,079
for both digital signing and for secure

363
00:14:36,079 --> 00:14:38,880
communication or a bit more subtle a crs

364
00:14:38,880 --> 00:14:40,480
that is used by many

365
00:14:40,480 --> 00:14:42,880
uh concurrent executions of the very

366
00:14:42,880 --> 00:14:44,959
same protocol row

367
00:14:44,959 --> 00:14:46,959
so the definition of a global setup is

368
00:14:46,959 --> 00:14:49,199
really that it is not local to one

369
00:14:49,199 --> 00:14:51,760
protocol

370
00:14:52,240 --> 00:14:54,840
considering our list of examples

371
00:14:54,840 --> 00:14:57,040
[Music]

372
00:14:57,040 --> 00:14:58,399
for setups before

373
00:14:58,399 --> 00:15:00,639
we can see that essentially in reality

374
00:15:00,639 --> 00:15:03,199
most of them are likely to be reused by

375
00:15:03,199 --> 00:15:05,600
many different applications since it is

376
00:15:05,600 --> 00:15:08,639
essentially too expensive to create an

377
00:15:08,639 --> 00:15:12,079
individual copy for each protocol run

378
00:15:12,079 --> 00:15:14,800
and even more all these setups once we

379
00:15:14,800 --> 00:15:17,440
deploy them in practice they do not even

380
00:15:17,440 --> 00:15:21,120
have any control over how users

381
00:15:21,120 --> 00:15:23,360
use the information that they provide

382
00:15:23,360 --> 00:15:25,199
for example

383
00:15:25,199 --> 00:15:27,600
if you consider the pki a user

384
00:15:27,600 --> 00:15:29,519
well essentially registers

385
00:15:29,519 --> 00:15:32,639
her key pair but how the user afterwards

386
00:15:32,639 --> 00:15:35,759
uses the secret key

387
00:15:35,839 --> 00:15:38,560
the pki has essentially no influence on

388
00:15:38,560 --> 00:15:41,920
that and i mean i don't probably don't

389
00:15:41,920 --> 00:15:44,240
even have to mention um the number of

390
00:15:44,240 --> 00:15:46,160
applications that have been proposed to

391
00:15:46,160 --> 00:15:47,920
run with the

392
00:15:47,920 --> 00:15:49,680
well essentially if you ignore forking

393
00:15:49,680 --> 00:15:53,560
the single bitcoin blockchain

394
00:15:55,360 --> 00:15:58,959
um in this talk we are going to focus uh

395
00:15:58,959 --> 00:16:00,959
hands on the following question is there

396
00:16:00,959 --> 00:16:03,680
any way to replace a global setup in a

397
00:16:03,680 --> 00:16:06,240
security statement by a

398
00:16:06,240 --> 00:16:09,839
an interactive protocol

399
00:16:11,199 --> 00:16:13,839
let's first see why that might be more

400
00:16:13,839 --> 00:16:16,240
difficult than with global setups which

401
00:16:16,240 --> 00:16:18,880
as we have seen can be replaced using

402
00:16:18,880 --> 00:16:20,399
the standard composition composition

403
00:16:20,399 --> 00:16:22,160
crms

404
00:16:22,160 --> 00:16:23,839
so here's

405
00:16:23,839 --> 00:16:26,000
the topology of a simulation based

406
00:16:26,000 --> 00:16:28,800
security statement where the crs is

407
00:16:28,800 --> 00:16:32,639
modeled as a global setup

408
00:16:33,759 --> 00:16:36,399
first we see that now we have arbitrary

409
00:16:36,399 --> 00:16:38,720
other protocols

410
00:16:38,720 --> 00:16:40,639
accessing

411
00:16:40,639 --> 00:16:42,959
accessing the crs here

412
00:16:42,959 --> 00:16:43,940
and

413
00:16:43,940 --> 00:16:46,160
[Music]

414
00:16:46,160 --> 00:16:48,079
in the simulation we do not get to

415
00:16:48,079 --> 00:16:49,600
completely

416
00:16:49,600 --> 00:16:52,480
make up the crs as we could before when

417
00:16:52,480 --> 00:16:54,639
the crs was local to the protocol the

418
00:16:54,639 --> 00:16:56,320
fact that it might already have been

419
00:16:56,320 --> 00:16:58,399
retrieved by other protocols means that

420
00:16:58,399 --> 00:17:00,480
we cannot plant a chapter anymore right

421
00:17:00,480 --> 00:17:03,279
so in some sense the crs

422
00:17:03,279 --> 00:17:06,319
might might pre-exist and it might be

423
00:17:06,319 --> 00:17:09,678
well in an arbitrary state

424
00:17:12,640 --> 00:17:16,000
so when going from local to global we

425
00:17:16,000 --> 00:17:18,400
clearly make the life of the simulator

426
00:17:18,400 --> 00:17:20,400
harder and consequently the security

427
00:17:20,400 --> 00:17:22,480
statements proven with respect to global

428
00:17:22,480 --> 00:17:24,799
variants of the setup are usually

429
00:17:24,799 --> 00:17:26,799
stronger than statements proven with

430
00:17:26,799 --> 00:17:30,679
respect to local variants

431
00:17:35,120 --> 00:17:37,760
okay so now let's look at what happens

432
00:17:37,760 --> 00:17:40,640
if we attempt to replace a global setup

433
00:17:40,640 --> 00:17:43,520
let's say we designed a protocol for

434
00:17:43,520 --> 00:17:45,840
online poker and have proven that it

435
00:17:45,840 --> 00:17:48,240
securely realizes

436
00:17:48,240 --> 00:17:49,200
some

437
00:17:49,200 --> 00:17:52,080
ideal functionality of poker assuming

438
00:17:52,080 --> 00:17:56,240
the parties have access to a global

439
00:17:56,240 --> 00:17:59,039
ideal ledger functionality

440
00:17:59,039 --> 00:18:01,360
we also know from the literature that

441
00:18:01,360 --> 00:18:04,000
the for example the bitcoin blockchain

442
00:18:04,000 --> 00:18:09,120
securely realizes uh our ideal ledger

443
00:18:09,120 --> 00:18:12,640
so now we could attempt to um replace

444
00:18:12,640 --> 00:18:15,360
this global ideal ledger in our security

445
00:18:15,360 --> 00:18:18,080
statement and please note that here the

446
00:18:18,080 --> 00:18:20,080
replacement does not only happen in the

447
00:18:20,080 --> 00:18:22,240
real world but it also

448
00:18:22,240 --> 00:18:24,559
happens in the ideal world

449
00:18:24,559 --> 00:18:26,720
right

450
00:18:26,720 --> 00:18:29,720
um

451
00:18:30,799 --> 00:18:33,679
so in particular in the ideal world the

452
00:18:33,679 --> 00:18:36,320
interface of the simulator at the ideal

453
00:18:36,320 --> 00:18:38,960
setup might have changed right so before

454
00:18:38,960 --> 00:18:41,919
the simulator was interfacing with the g

455
00:18:41,919 --> 00:18:44,640
g ledger functionality now

456
00:18:44,640 --> 00:18:46,720
this connection is essentially gone and

457
00:18:46,720 --> 00:18:50,640
replaced by a new interface

458
00:18:50,640 --> 00:18:53,360
adversarial interface

459
00:18:53,360 --> 00:18:57,080
of the bitcoin protocol

460
00:18:59,039 --> 00:19:00,480
now i told you before that the

461
00:19:00,480 --> 00:19:03,120
realization of g ledger the bitcoin

462
00:19:03,120 --> 00:19:04,480
blockchain in this

463
00:19:04,480 --> 00:19:07,679
example is at as least as secure as the

464
00:19:07,679 --> 00:19:09,039
ideal ledger

465
00:19:09,039 --> 00:19:10,799
this means that there are less attacks

466
00:19:10,799 --> 00:19:13,919
on bitcoin than on the letter

467
00:19:13,919 --> 00:19:16,960
essentially this interface might simply

468
00:19:16,960 --> 00:19:20,320
shrink somehow and our simulator might

469
00:19:20,320 --> 00:19:23,879
run into failure

470
00:19:25,919 --> 00:19:28,480
um so actually this is a problem

471
00:19:28,480 --> 00:19:30,960
depending on how extensively our

472
00:19:30,960 --> 00:19:33,679
simulator has used the adversarial

473
00:19:33,679 --> 00:19:36,160
interface of g letter and also depending

474
00:19:36,160 --> 00:19:38,720
on how large the difference is between

475
00:19:38,720 --> 00:19:41,039
security-wise between bitcoin and

476
00:19:41,039 --> 00:19:43,919
g-letter we cannot do the replacement

477
00:19:43,919 --> 00:19:44,880
right

478
00:19:44,880 --> 00:19:47,280
and normally ideal setups are really

479
00:19:47,280 --> 00:19:49,600
abstractions of the primitive and differ

480
00:19:49,600 --> 00:19:51,600
quite a lot from the protocols realizing

481
00:19:51,600 --> 00:19:53,360
them take the letter for example an

482
00:19:53,360 --> 00:19:55,919
ideal ledger lets the adversary fully

483
00:19:55,919 --> 00:19:57,919
determine the order of transactions in

484
00:19:57,919 --> 00:20:00,320
each block but nobody so far has found

485
00:20:00,320 --> 00:20:02,480
an attack on bitcoin that achieves

486
00:20:02,480 --> 00:20:04,720
arbitrary reordering when the majority

487
00:20:04,720 --> 00:20:07,440
of mining resources is honest

488
00:20:07,440 --> 00:20:09,679
so

489
00:20:10,880 --> 00:20:14,799
if you if you if you carefully watched

490
00:20:14,960 --> 00:20:16,960
two slides ago you might have spotted

491
00:20:16,960 --> 00:20:19,039
something that i ignored so far

492
00:20:19,039 --> 00:20:21,039
essentially when we replace the global

493
00:20:21,039 --> 00:20:24,159
setup the adversary in the real world

494
00:20:24,159 --> 00:20:26,880
gets restricted as well

495
00:20:26,880 --> 00:20:28,880
unfortunately this does not really help

496
00:20:28,880 --> 00:20:31,039
us

497
00:20:31,200 --> 00:20:33,919
because when we replace a

498
00:20:33,919 --> 00:20:36,400
setup we want to preserve the original

499
00:20:36,400 --> 00:20:38,400
statement meaning that

500
00:20:38,400 --> 00:20:40,240
we want our alt simulator to work for

501
00:20:40,240 --> 00:20:42,799
the replace setting as well

502
00:20:42,799 --> 00:20:45,039
in particular we do not want to verify

503
00:20:45,039 --> 00:20:47,440
whether the restricted simulator works

504
00:20:47,440 --> 00:20:49,360
for the restricted adversary so

505
00:20:49,360 --> 00:20:50,960
otherwise we might as well do the proof

506
00:20:50,960 --> 00:20:53,520
from scratch

507
00:20:58,640 --> 00:20:59,760
okay that

508
00:20:59,760 --> 00:21:02,799
was quite bad news regarding replacement

509
00:21:02,799 --> 00:21:04,640
of global setups so does it mean that we

510
00:21:04,640 --> 00:21:07,760
cannot replace them at all

511
00:21:07,760 --> 00:21:10,320
um it turns out we can replace them in

512
00:21:10,320 --> 00:21:14,080
2014 canadian showed that a global setup

513
00:21:14,080 --> 00:21:16,320
can be replaced by a protocol that is

514
00:21:16,320 --> 00:21:18,000
equivalent to it

515
00:21:18,000 --> 00:21:21,679
equivalent here means that is it is um

516
00:21:21,679 --> 00:21:24,720
well equally secure instead of what we

517
00:21:24,720 --> 00:21:27,520
had before at least as secure

518
00:21:27,520 --> 00:21:29,280
and the intuition is kind of obvious

519
00:21:29,280 --> 00:21:31,440
equivalence implies that the adversarial

520
00:21:31,440 --> 00:21:34,000
interface does not change and hence the

521
00:21:34,000 --> 00:21:36,080
simulator cannot run into failure and

522
00:21:36,080 --> 00:21:39,840
still works for the replaced setting

523
00:21:40,080 --> 00:21:41,760
okay but this result might seem a bit

524
00:21:41,760 --> 00:21:43,520
useless in the beginning why would we

525
00:21:43,520 --> 00:21:45,440
want to replace a

526
00:21:45,440 --> 00:21:47,200
setup by um

527
00:21:47,200 --> 00:21:49,280
by an equivalent setup

528
00:21:49,280 --> 00:21:50,640
um

529
00:21:50,640 --> 00:21:52,880
but it actually has its merits if you

530
00:21:52,880 --> 00:21:54,799
have proven your protocol with respect

531
00:21:54,799 --> 00:21:58,240
to a global setup you can use this this

532
00:21:58,240 --> 00:22:00,880
composition theorem of canadian dial to

533
00:22:00,880 --> 00:22:02,320
securely

534
00:22:02,320 --> 00:22:04,559
deploy your protocol on the internet and

535
00:22:04,559 --> 00:22:06,799
simply let a trusted authority run a

536
00:22:06,799 --> 00:22:09,760
code that is functionally and security

537
00:22:09,760 --> 00:22:12,799
wise equivalent to

538
00:22:12,799 --> 00:22:15,039
your ideal setup that you use in the

539
00:22:15,039 --> 00:22:17,600
proof and in practice this could be for

540
00:22:17,600 --> 00:22:19,679
example a centralized pki service

541
00:22:19,679 --> 00:22:21,840
offered by a trusted cloud provider it

542
00:22:21,840 --> 00:22:23,760
could be a state lottery that is live

543
00:22:23,760 --> 00:22:25,840
streamed for people to watch or a

544
00:22:25,840 --> 00:22:29,520
government running a bulletin board

545
00:22:31,440 --> 00:22:33,679
um okay so far so good there is one

546
00:22:33,679 --> 00:22:36,240
notable example where such equivalence

547
00:22:36,240 --> 00:22:38,960
replacements has essentially no merit

548
00:22:38,960 --> 00:22:40,000
and

549
00:22:40,000 --> 00:22:42,240
this is

550
00:22:42,240 --> 00:22:44,400
essentially blockchains

551
00:22:44,400 --> 00:22:46,400
as you might know we by now have

552
00:22:46,400 --> 00:22:48,799
countless blockchain protocols um

553
00:22:48,799 --> 00:22:51,600
providing us with publicly or privately

554
00:22:51,600 --> 00:22:54,720
accessible immutable transaction ledgers

555
00:22:54,720 --> 00:22:58,320
and even beyond my um my not so serious

556
00:22:58,320 --> 00:23:01,039
example of online poker before there are

557
00:23:01,039 --> 00:23:03,520
many serious applications for this new

558
00:23:03,520 --> 00:23:04,320
well

559
00:23:04,320 --> 00:23:06,159
type of data structure

560
00:23:06,159 --> 00:23:08,159
if you check the literature many of

561
00:23:08,159 --> 00:23:10,320
these have a security analysis in a

562
00:23:10,320 --> 00:23:12,480
simulation-based framework carried out

563
00:23:12,480 --> 00:23:14,640
with respect to a global ideal ledger

564
00:23:14,640 --> 00:23:16,799
functionality

565
00:23:16,799 --> 00:23:18,799
now the whole point of the blockchain

566
00:23:18,799 --> 00:23:21,760
era is to not implement the ideal ledger

567
00:23:21,760 --> 00:23:23,760
by a trusted authority

568
00:23:23,760 --> 00:23:25,120
but

569
00:23:25,120 --> 00:23:26,960
essentially by a decentralized and

570
00:23:26,960 --> 00:23:28,960
interactive protocol emulating such

571
00:23:28,960 --> 00:23:30,400
central trust

572
00:23:30,400 --> 00:23:33,440
if we want any proven security guarantee

573
00:23:33,440 --> 00:23:35,200
of these applications to be meaningful

574
00:23:35,200 --> 00:23:37,280
in practice we need to be able to

575
00:23:37,280 --> 00:23:39,520
replace the global ideal ledger by one

576
00:23:39,520 --> 00:23:42,640
of these blockchains which are all

577
00:23:42,640 --> 00:23:44,880
not equivalent to the ideal ledger so we

578
00:23:44,880 --> 00:23:48,159
cannot use equivalent replacement of the

579
00:23:48,159 --> 00:23:51,640
previous slides

580
00:23:51,840 --> 00:23:54,080
so in our paper we investigate when

581
00:23:54,080 --> 00:23:56,480
global replacement by non-equivalent

582
00:23:56,480 --> 00:23:58,559
protocols is possible

583
00:23:58,559 --> 00:24:00,720
i hope that from what i showed

584
00:24:00,720 --> 00:24:03,039
you before the intuition is now quite

585
00:24:03,039 --> 00:24:05,440
clear the replacement works essentially

586
00:24:05,440 --> 00:24:08,080
whenever the simulator is not disturbed

587
00:24:08,080 --> 00:24:10,480
by it

588
00:24:12,559 --> 00:24:14,799
we give two new composition theorems

589
00:24:14,799 --> 00:24:17,200
that allow to replace global setups by

590
00:24:17,200 --> 00:24:18,720
stronger

591
00:24:18,720 --> 00:24:21,200
stronger protocols the first one works

592
00:24:21,200 --> 00:24:24,240
for what we call agnostic simulations

593
00:24:24,240 --> 00:24:26,320
this is essentially a simulator who only

594
00:24:26,320 --> 00:24:28,559
accesses the letter as an honest party

595
00:24:28,559 --> 00:24:30,640
would do

596
00:24:30,640 --> 00:24:32,640
this means the simulator of the security

597
00:24:32,640 --> 00:24:34,400
proof for the poker protocol for example

598
00:24:34,400 --> 00:24:36,640
does not make use of the adversarial

599
00:24:36,640 --> 00:24:38,960
interface of the ledger

600
00:24:38,960 --> 00:24:41,279
it essentially just submits transactions

601
00:24:41,279 --> 00:24:43,760
on behalf of alice and carol

602
00:24:43,760 --> 00:24:44,720
for

603
00:24:44,720 --> 00:24:47,440
global setups which do not provide any

604
00:24:47,440 --> 00:24:50,880
extra adversarial interface this serum

605
00:24:50,880 --> 00:24:53,600
yields black box replacement meaning

606
00:24:53,600 --> 00:24:56,000
that we do not even have to look into

607
00:24:56,000 --> 00:24:57,520
the

608
00:24:57,520 --> 00:24:58,480
um

609
00:24:58,480 --> 00:25:00,400
the simulator here of the underlying

610
00:25:00,400 --> 00:25:02,880
statement

611
00:25:03,520 --> 00:25:05,760
otherwise the theorem is non-black box

612
00:25:05,760 --> 00:25:08,000
and it really depends on this simulator

613
00:25:08,000 --> 00:25:09,279
here

614
00:25:09,279 --> 00:25:11,200
of our pocket security proof whether we

615
00:25:11,200 --> 00:25:15,679
can replace the global ledger or not

616
00:25:15,679 --> 00:25:16,480
our

617
00:25:16,480 --> 00:25:18,720
second composition crm can capture an

618
00:25:18,720 --> 00:25:20,320
even broader setting but its

619
00:25:20,320 --> 00:25:23,600
preconditions are more tedious to check

620
00:25:23,600 --> 00:25:25,840
we define a set of so-called admissible

621
00:25:25,840 --> 00:25:27,440
attacks which are

622
00:25:27,440 --> 00:25:30,080
attacks that are allowed on both the

623
00:25:30,080 --> 00:25:32,559
global ledger and bitcoin

624
00:25:32,559 --> 00:25:34,640
for example it might be possible for a

625
00:25:34,640 --> 00:25:37,200
network adversary to postpone publishing

626
00:25:37,200 --> 00:25:39,039
of an honest transaction in bitcoin by

627
00:25:39,039 --> 00:25:42,240
one block and hence we can allow such

628
00:25:42,240 --> 00:25:44,960
postponing also to our simulator

629
00:25:44,960 --> 00:25:45,840
when we

630
00:25:45,840 --> 00:25:47,520
replace the global ledger functionality

631
00:25:47,520 --> 00:25:50,080
by bitcoin the simulator is still able

632
00:25:50,080 --> 00:25:51,919
to conduct this attack and the

633
00:25:51,919 --> 00:25:54,640
simulation does not fail at this point

634
00:25:54,640 --> 00:25:57,039
so in some sense we need to identify

635
00:25:57,039 --> 00:25:58,640
attacks where the global ledger

636
00:25:58,640 --> 00:26:00,880
functionality and bitcoin do not differ

637
00:26:00,880 --> 00:26:02,400
significantly

638
00:26:02,400 --> 00:26:04,320
and then we can essentially unlock all

639
00:26:04,320 --> 00:26:06,960
those attacks and allow our poker

640
00:26:06,960 --> 00:26:09,360
simulator to use these attacks in the

641
00:26:09,360 --> 00:26:12,399
simulation as well

642
00:26:13,120 --> 00:26:14,480
um

643
00:26:14,480 --> 00:26:16,159
so this concludes essentially the

644
00:26:16,159 --> 00:26:19,360
presentation of our uh results um i do

645
00:26:19,360 --> 00:26:21,679
want to point out that um

646
00:26:21,679 --> 00:26:23,600
while conducting this this whole

647
00:26:23,600 --> 00:26:26,000
analysis we had to spend a

648
00:26:26,000 --> 00:26:28,559
considerable amount of time um looking

649
00:26:28,559 --> 00:26:31,679
into global setups um and our paper

650
00:26:31,679 --> 00:26:35,279
essentially provides uh lots of insights

651
00:26:35,279 --> 00:26:36,240
into

652
00:26:36,240 --> 00:26:38,640
well these types of setups even beyond

653
00:26:38,640 --> 00:26:40,720
replacement so i want to want to give

654
00:26:40,720 --> 00:26:43,200
you one example of this assume that you

655
00:26:43,200 --> 00:26:45,760
invented a blockchain based

656
00:26:45,760 --> 00:26:48,240
time stamping protocol and you want to

657
00:26:48,240 --> 00:26:50,559
demonstrate its security so you would of

658
00:26:50,559 --> 00:26:52,799
course model security with respect to a

659
00:26:52,799 --> 00:26:54,559
global ledger because you want to be

660
00:26:54,559 --> 00:26:57,120
more realistic in your analysis and then

661
00:26:57,120 --> 00:26:59,360
you attempt to realize say

662
00:26:59,360 --> 00:27:03,918
this ideal time stamping functionality f

663
00:27:05,440 --> 00:27:07,840
on the slide i only show the ideal

664
00:27:07,840 --> 00:27:10,159
setting here that a real uh your real

665
00:27:10,159 --> 00:27:12,080
time stamping protocol needs to be

666
00:27:12,080 --> 00:27:14,400
distinguished from or indistinguisha

667
00:27:14,400 --> 00:27:16,640
needs to be indistinguishable from

668
00:27:16,640 --> 00:27:19,039
um so obviously secure time stamping

669
00:27:19,039 --> 00:27:21,279
needs to preserve the order of things

670
00:27:21,279 --> 00:27:23,200
and you ensure this in this

671
00:27:23,200 --> 00:27:25,440
functionality of time stamping that you

672
00:27:25,440 --> 00:27:26,850
write

673
00:27:26,850 --> 00:27:28,399
[Music]

674
00:27:28,399 --> 00:27:30,399
by essentially not letting the adversary

675
00:27:30,399 --> 00:27:32,320
reorder any entries

676
00:27:32,320 --> 00:27:34,480
however there are many ideal ledger

677
00:27:34,480 --> 00:27:36,320
functionalities in the literature which

678
00:27:36,320 --> 00:27:41,279
let the adversary reorder transactions

679
00:27:41,520 --> 00:27:43,760
uh well in a limited fashion so let's

680
00:27:43,760 --> 00:27:45,200
say at least

681
00:27:45,200 --> 00:27:46,559
well

682
00:27:46,559 --> 00:27:48,880
within the last or the current block

683
00:27:48,880 --> 00:27:49,919
right

684
00:27:49,919 --> 00:27:50,880
um

685
00:27:50,880 --> 00:27:53,360
so the simulation could actually so your

686
00:27:53,360 --> 00:27:56,159
simulation here um of your security

687
00:27:56,159 --> 00:27:57,840
proof of your time stamping protocol it

688
00:27:57,840 --> 00:28:00,720
could essentially exploit this weakness

689
00:28:00,720 --> 00:28:02,720
of

690
00:28:02,720 --> 00:28:05,919
of the the global ledger this means that

691
00:28:05,919 --> 00:28:08,960
such a security notion

692
00:28:08,960 --> 00:28:10,880
f timestamp here combined with the

693
00:28:10,880 --> 00:28:12,640
global g ledger

694
00:28:12,640 --> 00:28:15,279
it can potentially be realized by a very

695
00:28:15,279 --> 00:28:17,360
insecure timestamping protocol right

696
00:28:17,360 --> 00:28:20,080
where um it's not really timestamping if

697
00:28:20,080 --> 00:28:23,120
you can shift the order of things

698
00:28:23,120 --> 00:28:25,200
so we learn from that that with global

699
00:28:25,200 --> 00:28:27,760
setups we need to always look at both f

700
00:28:27,760 --> 00:28:30,799
and g here to read security guarantees

701
00:28:30,799 --> 00:28:33,039
right so this simple example shows that

702
00:28:33,039 --> 00:28:35,679
looking only at f might completely blur

703
00:28:35,679 --> 00:28:38,640
the security guarantees

704
00:28:38,640 --> 00:28:42,480
of the protocol under consideration

705
00:28:43,200 --> 00:28:45,200
uh let me also stress that while i

706
00:28:45,200 --> 00:28:47,600
presented the results mostly in terms of

707
00:28:47,600 --> 00:28:50,320
examples such as the global letter the

708
00:28:50,320 --> 00:28:52,159
paper provides of course general

709
00:28:52,159 --> 00:28:53,760
theorems that apply to any kind of

710
00:28:53,760 --> 00:28:55,679
global setups

711
00:28:55,679 --> 00:28:56,480
for

712
00:28:56,480 --> 00:28:58,480
writing down and proving the theorems we

713
00:28:58,480 --> 00:29:01,600
also had to fix a simulation based model

714
00:29:01,600 --> 00:29:04,240
and we choose chose the uc model of

715
00:29:04,240 --> 00:29:08,159
canadi uh which is uh well at at the

716
00:29:08,159 --> 00:29:09,840
point where we wrote a paper seemed to

717
00:29:09,840 --> 00:29:12,480
be simply the best

718
00:29:12,480 --> 00:29:14,880
developed or furthest developed model

719
00:29:14,880 --> 00:29:16,880
regarding the formalization of global

720
00:29:16,880 --> 00:29:18,240
setups

721
00:29:18,240 --> 00:29:22,559
our paper kind of implicitly answers

722
00:29:22,559 --> 00:29:24,799
a question that is often often asked by

723
00:29:24,799 --> 00:29:26,880
researchers what is a good global setup

724
00:29:26,880 --> 00:29:28,399
to to use

725
00:29:28,399 --> 00:29:30,640
and essentially we think that a good

726
00:29:30,640 --> 00:29:33,679
global setup is one that has a

727
00:29:33,679 --> 00:29:35,919
well let's say quite realistic

728
00:29:35,919 --> 00:29:38,720
adversarial interface such that our

729
00:29:38,720 --> 00:29:40,880
composition crms can be applied to

730
00:29:40,880 --> 00:29:42,080
replace it

731
00:29:42,080 --> 00:29:44,399
other types of global setups can still

732
00:29:44,399 --> 00:29:47,120
be used but the proven statements have

733
00:29:47,120 --> 00:29:51,120
well essentially more theoretical value

734
00:29:51,760 --> 00:29:54,240
okay so i hope you gain some insights in

735
00:29:54,240 --> 00:29:56,159
how to use and

736
00:29:56,159 --> 00:29:58,480
also how to not use global setups in

737
00:29:58,480 --> 00:30:00,559
your security proofs please have a look

738
00:30:00,559 --> 00:30:03,279
at the full paper which is um

739
00:30:03,279 --> 00:30:06,799
equipped with lots of examples and it is

740
00:30:06,799 --> 00:30:10,559
actually not as hard to read as um

741
00:30:10,559 --> 00:30:11,279
you

742
00:30:11,279 --> 00:30:12,159
you

743
00:30:12,159 --> 00:30:14,080
probably imagine it to be

744
00:30:14,080 --> 00:30:16,559
if you have any questions please

745
00:30:16,559 --> 00:30:18,720
write us an email and thank you for

746
00:30:18,720 --> 00:30:21,720
watching

