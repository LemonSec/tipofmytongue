1
00:00:03,919 --> 00:00:06,240
welcome to my talk on generalized proof

2
00:00:06,240 --> 00:00:08,880
of knowledge with fully dynamic setup

3
00:00:08,880 --> 00:00:10,719
this is joint work with christian

4
00:00:10,719 --> 00:00:14,480
potential and wally maurer

5
00:00:15,040 --> 00:00:17,920
let me start by giving you a brief recap

6
00:00:17,920 --> 00:00:20,400
of interactive proof systems and proof

7
00:00:20,400 --> 00:00:22,800
of knowledge in particular

8
00:00:22,800 --> 00:00:24,720
so an interactive proof system is

9
00:00:24,720 --> 00:00:27,680
essentially um a protocol between a

10
00:00:27,680 --> 00:00:30,720
prover p and the verifier v

11
00:00:30,720 --> 00:00:32,719
where the prover wants to convince the

12
00:00:32,719 --> 00:00:35,680
verifier v of some fact

13
00:00:35,680 --> 00:00:37,680
in the case of a proof of knowledge this

14
00:00:37,680 --> 00:00:40,879
fact is that for a given relation r and

15
00:00:40,879 --> 00:00:43,040
the statement x

16
00:00:43,040 --> 00:00:45,600
the prover knows a witness w that

17
00:00:45,600 --> 00:00:49,440
satisfies the given relation

18
00:00:49,440 --> 00:00:51,920
this notion has turned out to be one of

19
00:00:51,920 --> 00:00:54,320
the most influential and successful

20
00:00:54,320 --> 00:00:57,120
abstraction in cryptography and has a

21
00:00:57,120 --> 00:00:59,760
long history of formalization

22
00:00:59,760 --> 00:01:02,320
ultimately with the one by velaryon

23
00:01:02,320 --> 00:01:05,119
goldrive from 1993

24
00:01:05,119 --> 00:01:07,680
turning out to be the one that's nowaday

25
00:01:07,680 --> 00:01:10,479
accepted

26
00:01:10,640 --> 00:01:11,680
however

27
00:01:11,680 --> 00:01:14,000
throughout the years there have been

28
00:01:14,000 --> 00:01:16,080
quite a number of situation where it

29
00:01:16,080 --> 00:01:19,040
showed that despite being quite general

30
00:01:19,040 --> 00:01:20,880
with having this general

31
00:01:20,880 --> 00:01:22,479
relation r

32
00:01:22,479 --> 00:01:24,640
proof of knowledge might not be general

33
00:01:24,640 --> 00:01:28,080
enough in certain application especially

34
00:01:28,080 --> 00:01:30,079
it might not be general enough when

35
00:01:30,079 --> 00:01:32,400
trying to formalize in the goal of

36
00:01:32,400 --> 00:01:35,200
higher level applications

37
00:01:35,200 --> 00:01:38,400
let me give you some examples

38
00:01:38,400 --> 00:01:40,479
for instance consider password-based

39
00:01:40,479 --> 00:01:42,320
authentication

40
00:01:42,320 --> 00:01:45,040
there a user wants to prove to a server

41
00:01:45,040 --> 00:01:48,240
that they know their password

42
00:01:48,240 --> 00:01:51,840
or consider proof of ownership in the

43
00:01:51,840 --> 00:01:53,040
in

44
00:01:53,040 --> 00:01:56,200
that's comes from client-side file

45
00:01:56,200 --> 00:01:57,759
deduplication

46
00:01:57,759 --> 00:02:00,240
in the proof of ownership approver wants

47
00:02:00,240 --> 00:02:02,320
to prove to a server that they know the

48
00:02:02,320 --> 00:02:04,799
content of a certain file

49
00:02:04,799 --> 00:02:07,920
so in both application it sounds like

50
00:02:07,920 --> 00:02:09,919
essentially a proof of knowledge the

51
00:02:09,919 --> 00:02:11,520
prover wants to prove they know

52
00:02:11,520 --> 00:02:12,879
something

53
00:02:12,879 --> 00:02:15,599
yet neither of those two applications

54
00:02:15,599 --> 00:02:18,080
could just be formalized using the

55
00:02:18,080 --> 00:02:22,879
common proof of knowledge formalization

56
00:02:22,879 --> 00:02:24,239
instead

57
00:02:24,239 --> 00:02:27,120
both of those applications come with

58
00:02:27,120 --> 00:02:29,120
tailor-made

59
00:02:29,120 --> 00:02:32,160
security definitions that are entropy

60
00:02:32,160 --> 00:02:35,599
based typically and often also fairly at

61
00:02:35,599 --> 00:02:37,840
home

62
00:02:38,879 --> 00:02:43,360
so let us briefly revisit like

63
00:02:43,360 --> 00:02:45,599
in which aspect the proof of knowledge

64
00:02:45,599 --> 00:02:47,680
might be more general and what has been

65
00:02:47,680 --> 00:02:51,519
done about this so far

66
00:02:51,519 --> 00:02:53,920
so first we observe that in the proof of

67
00:02:53,920 --> 00:02:56,239
knowledge the statement and witness are

68
00:02:56,239 --> 00:02:59,200
essentially rigid objects that are just

69
00:02:59,200 --> 00:03:03,040
given as inputs to the various parties

70
00:03:03,040 --> 00:03:05,280
and essentially the underlying

71
00:03:05,280 --> 00:03:08,000
assumption is that if that should not be

72
00:03:08,000 --> 00:03:10,800
true then obviously we can first

73
00:03:10,800 --> 00:03:13,840
run some kind of negotiation protocol

74
00:03:13,840 --> 00:03:15,200
where we

75
00:03:15,200 --> 00:03:17,599
negotiate first on let's say the

76
00:03:17,599 --> 00:03:20,000
statement and then we run the general

77
00:03:20,000 --> 00:03:22,640
proof of knowledge

78
00:03:22,640 --> 00:03:25,599
however it has been observed that

79
00:03:25,599 --> 00:03:29,280
there arise non-trivial aspects if you

80
00:03:29,280 --> 00:03:32,959
consider such a negotiation phase

81
00:03:32,959 --> 00:03:35,360
first on a more practical

82
00:03:35,360 --> 00:03:36,959
side

83
00:03:36,959 --> 00:03:39,200
um if you have a very involved

84
00:03:39,200 --> 00:03:42,239
negotiation phase that requires the

85
00:03:42,239 --> 00:03:46,239
approval already to do a lot of work and

86
00:03:46,239 --> 00:03:49,680
then maybe we can get away later with a

87
00:03:49,680 --> 00:03:52,480
more efficient protocol rather than a

88
00:03:52,480 --> 00:03:54,879
general proof of knowledge

89
00:03:54,879 --> 00:03:56,560
while still having the verifier

90
00:03:56,560 --> 00:03:58,720
convinced that the brewer must know a

91
00:03:58,720 --> 00:04:01,760
given witness

92
00:04:01,760 --> 00:04:03,840
then on a more um

93
00:04:03,840 --> 00:04:06,319
theoretical point of view

94
00:04:06,319 --> 00:04:09,680
there might also be non-trivial um

95
00:04:09,680 --> 00:04:12,239
interactions with respect to security

96
00:04:12,239 --> 00:04:14,159
guarantees

97
00:04:14,159 --> 00:04:16,320
maybe as a fairly

98
00:04:16,320 --> 00:04:19,199
naive example let's say you have a zero

99
00:04:19,199 --> 00:04:22,240
knowledge proof of knowledge but then

100
00:04:22,240 --> 00:04:24,960
throughout this negotiation phase the

101
00:04:24,960 --> 00:04:27,520
prover actually really reveals their

102
00:04:27,520 --> 00:04:29,600
full um weakness

103
00:04:29,600 --> 00:04:31,600
then obviously the proof of knowledge

104
00:04:31,600 --> 00:04:32,720
being

105
00:04:32,720 --> 00:04:35,520
zero knowledge is of no use so

106
00:04:35,520 --> 00:04:37,840
it seems like

107
00:04:37,840 --> 00:04:39,919
in the end we really want that the

108
00:04:39,919 --> 00:04:42,240
combined protocol is pseudo knowledge

109
00:04:42,240 --> 00:04:46,320
and not just the proof phase

110
00:04:46,639 --> 00:04:49,840
so to remedy this this problem kamanesh

111
00:04:49,840 --> 00:04:53,520
adal in 2009 actually introduced a

112
00:04:53,520 --> 00:04:55,360
generalized proof of knowledge notion

113
00:04:55,360 --> 00:04:57,919
that reflects this two-stage process

114
00:04:57,919 --> 00:05:00,000
where in the first stage

115
00:05:00,000 --> 00:05:03,120
parties negotiate the statement and then

116
00:05:03,120 --> 00:05:06,400
there is a second phase where they prove

117
00:05:06,400 --> 00:05:10,840
the actual knowledge of a witness

118
00:05:12,160 --> 00:05:15,120
second the standard proof of knowledge

119
00:05:15,120 --> 00:05:18,479
notion does not consider setup

120
00:05:18,479 --> 00:05:21,440
again however having both proven

121
00:05:21,440 --> 00:05:24,320
verifier access to setup might lead to

122
00:05:24,320 --> 00:05:25,759
non-trivial

123
00:05:25,759 --> 00:05:27,440
effects on

124
00:05:27,440 --> 00:05:29,680
many of the fundamental concept of a

125
00:05:29,680 --> 00:05:32,080
proof of knowledge for instance on the

126
00:05:32,080 --> 00:05:35,120
notion of rewinding as part of the

127
00:05:35,120 --> 00:05:37,680
soundness game

128
00:05:37,680 --> 00:05:40,000
indeed in prior work

129
00:05:40,000 --> 00:05:42,400
bernard at all considered proof of

130
00:05:42,400 --> 00:05:45,199
knowledge in the random oracle model

131
00:05:45,199 --> 00:05:47,520
and in more recent work

132
00:05:47,520 --> 00:05:49,919
should we at al considered proof of

133
00:05:49,919 --> 00:05:51,039
knowledge

134
00:05:51,039 --> 00:05:53,280
in the blockchain setting where all the

135
00:05:53,280 --> 00:05:56,080
parties are assumed to have access to a

136
00:05:56,080 --> 00:05:58,479
public blockchain ledger

137
00:05:58,479 --> 00:06:01,199
and in particular in their work

138
00:06:01,199 --> 00:06:04,160
they assumed that the extractor cannot

139
00:06:04,160 --> 00:06:06,560
rewind this

140
00:06:06,560 --> 00:06:08,479
public lecture which obviously then

141
00:06:08,479 --> 00:06:09,919
leads to many

142
00:06:09,919 --> 00:06:12,319
non-trivial effects that might not be

143
00:06:12,319 --> 00:06:14,160
reflected in a standard proof of

144
00:06:14,160 --> 00:06:15,360
knowledge

145
00:06:15,360 --> 00:06:18,000
where the extractor is always assumed to

146
00:06:18,000 --> 00:06:20,880
be able to rewind

147
00:06:20,880 --> 00:06:24,639
the entire world essentially

148
00:06:25,840 --> 00:06:27,840
then third

149
00:06:27,840 --> 00:06:29,759
also the standard proof of knowledge

150
00:06:29,759 --> 00:06:31,680
notion considers the

151
00:06:31,680 --> 00:06:36,240
proof relation to be static and fixed

152
00:06:36,240 --> 00:06:37,039
so

153
00:06:37,039 --> 00:06:39,440
that means that for a proof of knowledge

154
00:06:39,440 --> 00:06:40,639
protocol

155
00:06:40,639 --> 00:06:43,360
first you assume that

156
00:06:43,360 --> 00:06:45,440
the relation is fixed and then you

157
00:06:45,440 --> 00:06:48,000
design a specific protocol for that

158
00:06:48,000 --> 00:06:49,840
fixed relation

159
00:06:49,840 --> 00:06:52,880
and it has been observed very early on

160
00:06:52,880 --> 00:06:56,000
by for instance victor but also dam

161
00:06:56,000 --> 00:06:57,680
cartel

162
00:06:57,680 --> 00:07:00,400
that in many cases this might be too

163
00:07:00,400 --> 00:07:03,280
limiting and they put forward

164
00:07:03,280 --> 00:07:05,919
the so-called notion of

165
00:07:05,919 --> 00:07:08,319
relation generators that is essentially

166
00:07:08,319 --> 00:07:11,520
an algorithm that first generates

167
00:07:11,520 --> 00:07:13,520
the relation

168
00:07:13,520 --> 00:07:15,520
and then outputs

169
00:07:15,520 --> 00:07:18,160
an explicit description of this relation

170
00:07:18,160 --> 00:07:19,919
to all the parties

171
00:07:19,919 --> 00:07:22,080
so

172
00:07:22,080 --> 00:07:24,000
a given protocol does not just have to

173
00:07:24,000 --> 00:07:26,800
work for one specific relation

174
00:07:26,800 --> 00:07:29,680
but for some kind of probabilistic

175
00:07:29,680 --> 00:07:34,160
relation generation mechanism

176
00:07:34,639 --> 00:07:37,560
however it's worth noting that in this

177
00:07:37,560 --> 00:07:40,560
generalization the relation is still um

178
00:07:40,560 --> 00:07:42,639
assumed to be a true relation that is

179
00:07:42,639 --> 00:07:44,720
some kind of

180
00:07:44,720 --> 00:07:46,720
circuit

181
00:07:46,720 --> 00:07:48,479
and

182
00:07:48,479 --> 00:07:50,800
in particular this relation cannot

183
00:07:50,800 --> 00:07:53,840
depend on general dynamic setup so for

184
00:07:53,840 --> 00:07:55,360
instance

185
00:07:55,360 --> 00:07:56,479
if you

186
00:07:56,479 --> 00:07:58,400
if your relation

187
00:07:58,400 --> 00:08:01,280
depends on some kind of hashing and you

188
00:08:01,280 --> 00:08:04,000
need to model this hashing as a random

189
00:08:04,000 --> 00:08:06,800
oracle you're still out of luck

190
00:08:06,800 --> 00:08:09,440
additionally it's still assumed that

191
00:08:09,440 --> 00:08:12,000
this relation is public and everybody in

192
00:08:12,000 --> 00:08:13,520
the world can

193
00:08:13,520 --> 00:08:18,560
evaluate it once it has been generated

194
00:08:18,960 --> 00:08:22,000
so to summarize there has been quite a

195
00:08:22,000 --> 00:08:23,280
number of

196
00:08:23,280 --> 00:08:26,639
potential generalization identified and

197
00:08:26,639 --> 00:08:28,160
with work

198
00:08:28,160 --> 00:08:30,160
tackling those

199
00:08:30,160 --> 00:08:32,640
however each of the work so far

200
00:08:32,640 --> 00:08:34,479
essentially tackled a single

201
00:08:34,479 --> 00:08:37,599
generalization of a proof of knowledge

202
00:08:37,599 --> 00:08:40,719
and in our work we're the first one that

203
00:08:40,719 --> 00:08:43,440
tackle all of the generalization at the

204
00:08:43,440 --> 00:08:44,959
same time

205
00:08:44,959 --> 00:08:47,360
in particular with the first one that

206
00:08:47,360 --> 00:08:50,000
consider a

207
00:08:50,000 --> 00:08:52,560
general setup rather than just one type

208
00:08:52,560 --> 00:08:54,640
of specific setup

209
00:08:54,640 --> 00:08:57,519
and we're the first one to consider a

210
00:08:57,519 --> 00:09:02,959
proof relation that depends on the setup

211
00:09:04,800 --> 00:09:08,240
a bit more concretely we in our work we

212
00:09:08,240 --> 00:09:10,480
introduce a generalized notion of proof

213
00:09:10,480 --> 00:09:12,720
of knowledge that encompasses both

214
00:09:12,720 --> 00:09:14,720
dynamic setup

215
00:09:14,720 --> 00:09:17,040
and

216
00:09:17,040 --> 00:09:20,720
and relation as well as this interactive

217
00:09:20,720 --> 00:09:22,560
two-phase process

218
00:09:22,560 --> 00:09:25,600
where one first agrees on the statement

219
00:09:25,600 --> 00:09:29,279
and then actually runs the proof

220
00:09:29,279 --> 00:09:32,480
we call our notion agreeing proof and we

221
00:09:32,480 --> 00:09:35,120
observe that it actually unifies all the

222
00:09:35,120 --> 00:09:36,480
existing proof of knowledge

223
00:09:36,480 --> 00:09:38,160
generalization

224
00:09:38,160 --> 00:09:40,000
and our notion comes with clear

225
00:09:40,000 --> 00:09:42,959
semantics of correctness soundness and

226
00:09:42,959 --> 00:09:46,399
obviously zero knowledge

227
00:09:47,839 --> 00:09:51,360
so to demonstrate the usefulness of our

228
00:09:51,360 --> 00:09:54,560
notion as a definitional framework for

229
00:09:54,560 --> 00:09:57,120
high level applications that have some

230
00:09:57,120 --> 00:09:59,200
kind of proof of knowledge flavor to

231
00:09:59,200 --> 00:10:00,080
them

232
00:10:00,080 --> 00:10:03,760
we then go on and show two applications

233
00:10:03,760 --> 00:10:06,800
first we considered proof of ownerships

234
00:10:06,800 --> 00:10:09,600
and second we consider two-factor entity

235
00:10:09,600 --> 00:10:11,760
authentication

236
00:10:11,760 --> 00:10:14,480
i would also like to mention that in

237
00:10:14,480 --> 00:10:18,640
recent work bittik and sang also used

238
00:10:18,640 --> 00:10:20,800
our proof of

239
00:10:20,800 --> 00:10:23,120
our agreement proof notion in their work

240
00:10:23,120 --> 00:10:26,480
at euro group this year

241
00:10:28,000 --> 00:10:30,640
with that being said now let's actually

242
00:10:30,640 --> 00:10:34,160
introduce our agreement proven notion

243
00:10:34,160 --> 00:10:36,000
an agreement proof protocol is

244
00:10:36,000 --> 00:10:38,160
essentially a fourth couple of protocols

245
00:10:38,160 --> 00:10:40,560
where both the prover and the verifier

246
00:10:40,560 --> 00:10:43,360
are split into two phases

247
00:10:43,360 --> 00:10:45,440
in the first phase the so-called

248
00:10:45,440 --> 00:10:48,560
agreement phase the first prover

249
00:10:48,560 --> 00:10:51,040
interacts with the first verifier

250
00:10:51,040 --> 00:10:53,440
and at the end of the phase they both

251
00:10:53,440 --> 00:10:57,120
output a statement x as well as a state

252
00:10:57,120 --> 00:10:59,760
for the second phase

253
00:10:59,760 --> 00:11:02,160
in the second phase the proof phase then

254
00:11:02,160 --> 00:11:03,920
they use the state

255
00:11:03,920 --> 00:11:05,440
um to

256
00:11:05,440 --> 00:11:08,720
execute the actual proof and the phase

257
00:11:08,720 --> 00:11:12,240
ends with both parties outputting a bit

258
00:11:12,240 --> 00:11:14,480
indicating whether the proof has been

259
00:11:14,480 --> 00:11:17,279
successful or not

260
00:11:17,279 --> 00:11:20,160
now as already mentioned we want this to

261
00:11:20,160 --> 00:11:22,240
happen in the presence of a generalized

262
00:11:22,240 --> 00:11:24,959
setup function f so

263
00:11:24,959 --> 00:11:26,720
in our

264
00:11:26,720 --> 00:11:29,680
notion all the four protocols have

265
00:11:29,680 --> 00:11:32,560
oracle access to such a general setup

266
00:11:32,560 --> 00:11:35,600
functionality f

267
00:11:35,600 --> 00:11:37,839
moreover there's also

268
00:11:37,839 --> 00:11:40,640
a so-called

269
00:11:40,640 --> 00:11:43,360
input generation algorithm i

270
00:11:43,360 --> 00:11:44,160
that

271
00:11:44,160 --> 00:11:46,560
beforehand interacts with the setup

272
00:11:46,560 --> 00:11:48,800
functionality and generates auxiliary

273
00:11:48,800 --> 00:11:50,959
inputs for both the prover and the

274
00:11:50,959 --> 00:11:53,760
verifier

275
00:11:54,000 --> 00:11:58,959
it's it's worth notion mentioning that

276
00:11:58,959 --> 00:12:01,200
the input generation algorithm is not

277
00:12:01,200 --> 00:12:04,399
part of a protocol but rather a protocol

278
00:12:04,399 --> 00:12:07,200
has to work for any input in a

279
00:12:07,200 --> 00:12:10,399
narration algorithm i

280
00:12:10,399 --> 00:12:13,279
so essentially anything you want to make

281
00:12:13,279 --> 00:12:15,120
an assumption on

282
00:12:15,120 --> 00:12:17,680
you should model as part of

283
00:12:17,680 --> 00:12:20,079
the setup functionality f

284
00:12:20,079 --> 00:12:23,360
whereas any part of the prior knowledge

285
00:12:23,360 --> 00:12:25,279
or the state of the system you don't

286
00:12:25,279 --> 00:12:27,680
want to make an assumption on you can

287
00:12:27,680 --> 00:12:30,079
model as part of the input generation

288
00:12:30,079 --> 00:12:32,959
algorithm i

289
00:12:34,800 --> 00:12:37,360
then i should mention that the setup

290
00:12:37,360 --> 00:12:39,839
functionality is really some kind of

291
00:12:39,839 --> 00:12:40,880
general

292
00:12:40,880 --> 00:12:43,920
uc like functionality that is a stateful

293
00:12:43,920 --> 00:12:46,480
probabilistic itm

294
00:12:46,480 --> 00:12:49,360
in particular when making a query

295
00:12:49,360 --> 00:12:52,160
a party actually provides two arguments

296
00:12:52,160 --> 00:12:56,560
the first one indicating who they are so

297
00:12:56,560 --> 00:12:59,040
the setup functionality knows whether

298
00:12:59,040 --> 00:13:01,360
they're interacting with the prover the

299
00:13:01,360 --> 00:13:03,120
verifier or

300
00:13:03,120 --> 00:13:06,639
the input generation and can

301
00:13:06,639 --> 00:13:09,920
provide different interfaces to each of

302
00:13:09,920 --> 00:13:12,079
them so we cannot just model something

303
00:13:12,079 --> 00:13:12,880
like

304
00:13:12,880 --> 00:13:16,560
a random oracle or a crs that is the

305
00:13:16,560 --> 00:13:19,040
same for other parties but also more

306
00:13:19,040 --> 00:13:22,079
involved setup functionality where maybe

307
00:13:22,079 --> 00:13:24,079
the verifier gets

308
00:13:24,079 --> 00:13:26,399
additional information compared to the

309
00:13:26,399 --> 00:13:31,760
prover or different information or so on

310
00:13:33,600 --> 00:13:36,079
okay let us now consider briefly the

311
00:13:36,079 --> 00:13:38,079
correctness game

312
00:13:38,079 --> 00:13:41,279
um in correctness when an honest prover

313
00:13:41,279 --> 00:13:43,600
interacts with an honest verifier we

314
00:13:43,600 --> 00:13:46,000
obviously want that they agree on the

315
00:13:46,000 --> 00:13:50,560
statements they want to run the proof on

316
00:13:50,560 --> 00:13:53,440
additionally we also introduce

317
00:13:53,440 --> 00:13:57,440
a general agreement condition c

318
00:13:57,440 --> 00:14:00,480
that specifies whether a given statement

319
00:14:00,480 --> 00:14:02,399
is valid given

320
00:14:02,399 --> 00:14:04,560
the state of the system

321
00:14:04,560 --> 00:14:07,199
such as the auxiliary inputs as well as

322
00:14:07,199 --> 00:14:10,160
the setup functionality

323
00:14:10,160 --> 00:14:12,880
this is mainly there so that somebody

324
00:14:12,880 --> 00:14:15,839
who wants to use our framework can rule

325
00:14:15,839 --> 00:14:19,600
out trivial protocols in which

326
00:14:19,600 --> 00:14:22,560
the protocol would always agree on some

327
00:14:22,560 --> 00:14:24,240
kind of

328
00:14:24,240 --> 00:14:26,639
dummy statement for which

329
00:14:26,639 --> 00:14:29,600
the proof becomes very easy or even

330
00:14:29,600 --> 00:14:32,240
trivial

331
00:14:35,600 --> 00:14:38,320
in particular we assume that there is

332
00:14:38,320 --> 00:14:41,839
some kind of special statement aboard

333
00:14:41,839 --> 00:14:44,880
that means they could prover and verify

334
00:14:44,880 --> 00:14:47,360
or could not agree on a statement for

335
00:14:47,360 --> 00:14:50,480
which they can run the proof

336
00:14:50,480 --> 00:14:53,360
for instance in the

337
00:14:53,360 --> 00:14:56,320
password-based authentication example

338
00:14:56,320 --> 00:14:59,040
if the prover is not given a valid not

339
00:14:59,040 --> 00:15:01,680
given a password but only some garbage

340
00:15:01,680 --> 00:15:03,760
has auxiliary input

341
00:15:03,760 --> 00:15:06,959
then they might decide to abort on the

342
00:15:06,959 --> 00:15:09,199
other hand if the prover is actually

343
00:15:09,199 --> 00:15:10,839
given a valid

344
00:15:10,839 --> 00:15:13,040
password then

345
00:15:13,040 --> 00:15:16,000
a correct protocol should have

346
00:15:16,000 --> 00:15:19,839
should succeed and not the board

347
00:15:19,839 --> 00:15:20,639
so

348
00:15:20,639 --> 00:15:22,880
in case

349
00:15:22,880 --> 00:15:24,800
the

350
00:15:24,800 --> 00:15:27,600
statement is not a board then a correct

351
00:15:27,600 --> 00:15:29,680
protocol must actually end with the

352
00:15:29,680 --> 00:15:31,600
second phase both

353
00:15:31,600 --> 00:15:35,759
outputting that the protocol succeeded

354
00:15:35,759 --> 00:15:38,079
and i should mention here that the

355
00:15:38,079 --> 00:15:40,399
prover also outputting

356
00:15:40,399 --> 00:15:43,600
this the result is mainly done for so

357
00:15:43,600 --> 00:15:46,720
that we know that they both agree on

358
00:15:46,720 --> 00:15:48,800
what the outcome was

359
00:15:48,800 --> 00:15:51,199
and worst case this can always be

360
00:15:51,199 --> 00:15:53,440
achieved at the expense of an additional

361
00:15:53,440 --> 00:15:56,800
round of communication

362
00:15:59,120 --> 00:16:01,440
okay let's now look at the more

363
00:16:01,440 --> 00:16:02,800
interesting

364
00:16:02,800 --> 00:16:05,360
experiment which is some is which we

365
00:16:05,360 --> 00:16:07,519
formalize as an extraction game

366
00:16:07,519 --> 00:16:11,680
analogous to standard proof of knowledge

367
00:16:11,680 --> 00:16:13,759
so analogous to standard proof of

368
00:16:13,759 --> 00:16:17,279
knowledge there's the proof relation r

369
00:16:17,279 --> 00:16:20,079
and the only difference is really that

370
00:16:20,079 --> 00:16:24,079
for us r is not actually a relation but

371
00:16:24,079 --> 00:16:26,000
a stateless

372
00:16:26,000 --> 00:16:28,959
deterministic algorithm that has oracle

373
00:16:28,959 --> 00:16:33,199
access to the setup functionality

374
00:16:33,360 --> 00:16:34,720
this really gives us a lot of

375
00:16:34,720 --> 00:16:38,800
flexibility because now the goal of

376
00:16:38,800 --> 00:16:40,959
a proof of knowledge can be phrased

377
00:16:40,959 --> 00:16:45,680
depending on the set of functionality f

378
00:16:46,480 --> 00:16:47,519
so

379
00:16:47,519 --> 00:16:48,399
in

380
00:16:48,399 --> 00:16:51,040
this extraction game however the

381
00:16:51,040 --> 00:16:54,720
agreement phase is run exactly once

382
00:16:54,720 --> 00:16:56,240
and

383
00:16:56,240 --> 00:16:58,480
so the agreement phase determines the

384
00:16:58,480 --> 00:17:01,600
statement x and only after this is done

385
00:17:01,600 --> 00:17:04,240
the extractor comes in and has to

386
00:17:04,240 --> 00:17:06,959
extract a witness for that statement x

387
00:17:06,959 --> 00:17:09,760
from the second phase proverb

388
00:17:09,760 --> 00:17:12,079
this is really important because

389
00:17:12,079 --> 00:17:13,520
otherwise

390
00:17:13,520 --> 00:17:16,559
the extractor might try to rewind the

391
00:17:16,559 --> 00:17:19,199
first phase of text

392
00:17:19,199 --> 00:17:21,119
protocol until

393
00:17:21,119 --> 00:17:24,240
they result in a statement for which

394
00:17:24,240 --> 00:17:25,359
maybe

395
00:17:25,359 --> 00:17:28,480
extraction of a valid witness is much

396
00:17:28,480 --> 00:17:31,039
easier something like this

397
00:17:31,039 --> 00:17:35,280
here we really want that if

398
00:17:35,280 --> 00:17:38,240
the verifier the honest verifier at the

399
00:17:38,240 --> 00:17:39,760
end of phase one

400
00:17:39,760 --> 00:17:41,120
thinks

401
00:17:41,120 --> 00:17:43,520
we're running um the proof for a given

402
00:17:43,520 --> 00:17:46,559
statement x and afterwards this proof

403
00:17:46,559 --> 00:17:48,000
succeeds

404
00:17:48,000 --> 00:17:48,960
then

405
00:17:48,960 --> 00:17:51,039
the plural must have known a witness

406
00:17:51,039 --> 00:17:54,000
that for that particular x and not some

407
00:17:54,000 --> 00:17:57,120
arbitrary x

408
00:17:57,280 --> 00:17:59,760
so in the extraction game

409
00:17:59,760 --> 00:18:02,799
unless the statement is a board

410
00:18:02,799 --> 00:18:06,799
then the extractor has to extract

411
00:18:06,799 --> 00:18:10,799
a witness for that statement x and

412
00:18:10,799 --> 00:18:13,840
it in addition to just to black box

413
00:18:13,840 --> 00:18:16,240
rewinding access to the second phase

414
00:18:16,240 --> 00:18:17,280
prover

415
00:18:17,280 --> 00:18:19,679
we also provide the extractor with

416
00:18:19,679 --> 00:18:21,679
access to the communication transcript

417
00:18:21,679 --> 00:18:24,720
of the first phase as well as all the

418
00:18:24,720 --> 00:18:29,039
setup queries the first phase made

419
00:18:29,039 --> 00:18:31,600
this is really needed if we want to have

420
00:18:31,600 --> 00:18:35,919
this aspect that maybe a very involved

421
00:18:35,919 --> 00:18:38,400
agreement phase can lead to a more

422
00:18:38,400 --> 00:18:41,440
efficient proof phase so

423
00:18:41,440 --> 00:18:42,400
let's say

424
00:18:42,400 --> 00:18:44,640
in the agreement phase the prover

425
00:18:44,640 --> 00:18:46,799
actually send our

426
00:18:46,799 --> 00:18:50,160
the witness in order to communicate the

427
00:18:50,160 --> 00:18:53,280
statement for whatever reason then now

428
00:18:53,280 --> 00:18:54,880
the proof

429
00:18:54,880 --> 00:19:00,160
is trivial and so is the extraction

430
00:19:00,799 --> 00:19:03,600
in addition the extractor also gets

431
00:19:03,600 --> 00:19:06,080
oracle access to the setup functionality

432
00:19:06,080 --> 00:19:09,200
but here only in the role of the prover

433
00:19:09,200 --> 00:19:10,880
obviously because

434
00:19:10,880 --> 00:19:13,440
just because the verifier can query

435
00:19:13,440 --> 00:19:15,840
something from the

436
00:19:15,840 --> 00:19:18,160
setup functionality doesn't mean that

437
00:19:18,160 --> 00:19:20,240
the proof will knew this value because

438
00:19:20,240 --> 00:19:23,200
we have this possibility that prover and

439
00:19:23,200 --> 00:19:25,840
verify have different views on the setup

440
00:19:25,840 --> 00:19:28,000
functionality

441
00:19:28,000 --> 00:19:31,039
finally because the proof relation is no

442
00:19:31,039 --> 00:19:33,440
longer a public object we also have to

443
00:19:33,440 --> 00:19:35,520
give the extractor

444
00:19:35,520 --> 00:19:37,840
black box access to the proof relation

445
00:19:37,840 --> 00:19:40,320
so that for instance in a standard

446
00:19:40,320 --> 00:19:42,160
extraction the

447
00:19:42,160 --> 00:19:44,480
extractor knows whether they need to

448
00:19:44,480 --> 00:19:47,919
repeat to to rewind once more or whether

449
00:19:47,919 --> 00:19:49,760
they're done so

450
00:19:49,760 --> 00:19:52,720
maybe even so maybe even if the brewer

451
00:19:52,720 --> 00:19:55,039
themself does not necessarily know

452
00:19:55,039 --> 00:19:56,640
whether

453
00:19:56,640 --> 00:19:58,320
um

454
00:19:58,320 --> 00:19:59,760
this is

455
00:19:59,760 --> 00:20:01,520
valid

456
00:20:01,520 --> 00:20:05,440
in most cases the extractor still seems

457
00:20:05,440 --> 00:20:08,559
need to know and obviously you can tweak

458
00:20:08,559 --> 00:20:10,880
our notion by saying that

459
00:20:10,880 --> 00:20:13,200
the extractor should not get access to

460
00:20:13,200 --> 00:20:16,480
this and stuff like this

461
00:20:16,480 --> 00:20:17,840
and

462
00:20:17,840 --> 00:20:19,600
yeah there are a lot of different

463
00:20:19,600 --> 00:20:22,400
variants but i think what we put forward

464
00:20:22,400 --> 00:20:25,280
makes sense for most applications

465
00:20:25,280 --> 00:20:29,360
but obviously feel free to tweak

466
00:20:29,360 --> 00:20:31,200
so this

467
00:20:31,200 --> 00:20:35,200
finalizes the two main experiments and i

468
00:20:35,200 --> 00:20:37,840
really encourage for you for the formal

469
00:20:37,840 --> 00:20:40,400
definition to look at the actual paper

470
00:20:40,400 --> 00:20:43,120
that's available either on eprint or in

471
00:20:43,120 --> 00:20:46,559
the conference proceeding

472
00:20:46,799 --> 00:20:49,039
in additional we also consider some

473
00:20:49,039 --> 00:20:51,520
additional properties

474
00:20:51,520 --> 00:20:53,919
mainly zero knowledge

475
00:20:53,919 --> 00:20:56,320
and for sino zero knowledge we actually

476
00:20:56,320 --> 00:20:58,880
consider two experiments that formalize

477
00:20:58,880 --> 00:21:02,320
both plural and verifier zero knowledge

478
00:21:02,320 --> 00:21:04,480
which is really in contrast to standard

479
00:21:04,480 --> 00:21:06,799
proof of knowledge

480
00:21:06,799 --> 00:21:07,679
but

481
00:21:07,679 --> 00:21:09,280
the difference here is really that in

482
00:21:09,280 --> 00:21:11,919
standard proof of knowledge the verifier

483
00:21:11,919 --> 00:21:14,000
does not have any secrets all the

484
00:21:14,000 --> 00:21:16,159
verifier knows is essentially the

485
00:21:16,159 --> 00:21:19,200
statement and the auxiliary inputs

486
00:21:19,200 --> 00:21:22,320
that the pro knows anyway so there's no

487
00:21:22,320 --> 00:21:25,280
need to formalize that the dishonest pro

488
00:21:25,280 --> 00:21:27,440
does not learn in secret from the

489
00:21:27,440 --> 00:21:29,200
verifier

490
00:21:29,200 --> 00:21:30,799
however

491
00:21:30,799 --> 00:21:33,039
in our setting where we have

492
00:21:33,039 --> 00:21:36,000
a setup functionality where the verifier

493
00:21:36,000 --> 00:21:37,440
might

494
00:21:37,440 --> 00:21:39,600
have different access than the proverb

495
00:21:39,600 --> 00:21:41,440
we also want to formalize that to

496
00:21:41,440 --> 00:21:44,320
dishonest proverb does not know learn

497
00:21:44,320 --> 00:21:45,679
additional

498
00:21:45,679 --> 00:21:48,799
information from about

499
00:21:48,799 --> 00:21:51,840
this information

500
00:21:51,919 --> 00:21:53,760
so for instance

501
00:21:53,760 --> 00:21:56,159
in password-based authentication the the

502
00:21:56,159 --> 00:21:58,880
verifier might have access to the entire

503
00:21:58,880 --> 00:22:00,720
password

504
00:22:00,720 --> 00:22:03,600
database but the prover does not so

505
00:22:03,600 --> 00:22:05,200
obviously we want to be able to

506
00:22:05,200 --> 00:22:07,919
formalize that during the protocol the

507
00:22:07,919 --> 00:22:10,480
verifier does not leak information about

508
00:22:10,480 --> 00:22:12,720
other users password to a dishonest

509
00:22:12,720 --> 00:22:15,280
program

510
00:22:15,280 --> 00:22:16,080
and

511
00:22:16,080 --> 00:22:18,559
to make our notion more general we

512
00:22:18,559 --> 00:22:21,200
actually do not just formalize zero

513
00:22:21,200 --> 00:22:24,159
knowledge but we formalize proof of

514
00:22:24,159 --> 00:22:25,919
we formalize zero knowledge with

515
00:22:25,919 --> 00:22:28,400
explicit leakage so

516
00:22:28,400 --> 00:22:30,799
even if you have as a protocol or

517
00:22:30,799 --> 00:22:33,120
situation where perfect zero knowledge

518
00:22:33,120 --> 00:22:35,600
is not achievable but you have maybe

519
00:22:35,600 --> 00:22:38,640
some kind of explicit leakage or bounded

520
00:22:38,640 --> 00:22:40,480
leakage

521
00:22:40,480 --> 00:22:42,000
our notion

522
00:22:42,000 --> 00:22:44,799
has you covered by allowing you to

523
00:22:44,799 --> 00:22:48,000
specify an explicitly equatorial that

524
00:22:48,000 --> 00:22:50,720
the simulator then can invoke in order

525
00:22:50,720 --> 00:22:52,960
to learn certain well-defined

526
00:22:52,960 --> 00:22:56,000
information about the other parties

527
00:22:56,000 --> 00:22:58,960
secret inputs that is the other part is

528
00:22:58,960 --> 00:23:02,080
auxiliary input as well as view on the

529
00:23:02,080 --> 00:23:05,439
sector functionality

530
00:23:07,280 --> 00:23:10,320
additionally we consider also

531
00:23:10,320 --> 00:23:12,960
a programmable variant of

532
00:23:12,960 --> 00:23:14,799
our notion where the setup is

533
00:23:14,799 --> 00:23:16,640
programmable

534
00:23:16,640 --> 00:23:19,440
for instance if you have a common

535
00:23:19,440 --> 00:23:22,320
reference string a crs then most of the

536
00:23:22,320 --> 00:23:24,880
time this is only really useful if you

537
00:23:24,880 --> 00:23:26,480
assume that

538
00:23:26,480 --> 00:23:29,120
in the soundness game the extractor can

539
00:23:29,120 --> 00:23:32,480
actually program the crs such that they

540
00:23:32,480 --> 00:23:34,880
know the trapdoor

541
00:23:34,880 --> 00:23:37,679
we formalize this by saying that there

542
00:23:37,679 --> 00:23:41,360
can be a tractor setup functionality

543
00:23:41,360 --> 00:23:44,000
for which the extractor learns trapdoor

544
00:23:44,000 --> 00:23:46,559
but to anybody who does not know the

545
00:23:46,559 --> 00:23:48,120
trapdoor it still looks

546
00:23:48,120 --> 00:23:50,720
indistinguishable from the actual setup

547
00:23:50,720 --> 00:23:52,880
functionality that we assume to be

548
00:23:52,880 --> 00:23:56,400
present in the real world

549
00:23:57,360 --> 00:24:00,159
finally let me also briefly touch

550
00:24:00,159 --> 00:24:03,960
the issue of composability

551
00:24:04,159 --> 00:24:06,720
so in our paper we prove actually two

552
00:24:06,720 --> 00:24:08,720
results

553
00:24:08,720 --> 00:24:12,000
and both of the results are about

554
00:24:12,000 --> 00:24:14,720
a higher level protocol invoking an

555
00:24:14,720 --> 00:24:18,080
agreement proof um

556
00:24:18,080 --> 00:24:21,840
protocol multiple times in sequence and

557
00:24:21,840 --> 00:24:23,120
what our

558
00:24:23,120 --> 00:24:26,240
results show is that

559
00:24:26,240 --> 00:24:28,480
one invocation of degree and proof

560
00:24:28,480 --> 00:24:31,120
protocol does not negatively affect the

561
00:24:31,120 --> 00:24:35,520
security of any of the other invocations

562
00:24:35,520 --> 00:24:40,000
and one of the results is about all the

563
00:24:40,000 --> 00:24:44,320
all the invocation all the

564
00:24:44,880 --> 00:24:47,600
all the protocols using the same setup

565
00:24:47,600 --> 00:24:49,520
functionality whereas the other is all

566
00:24:49,520 --> 00:24:52,000
the it is about all the instances using

567
00:24:52,000 --> 00:24:56,880
their own private setup functionality

568
00:24:57,120 --> 00:24:59,520
and i should maybe stress that while

569
00:24:59,520 --> 00:25:00,400
this

570
00:25:00,400 --> 00:25:03,520
might sound like the sequential

571
00:25:03,520 --> 00:25:05,840
composition theorem you know from proof

572
00:25:05,840 --> 00:25:07,200
of knowledge

573
00:25:07,200 --> 00:25:10,400
it's really quite different in spirit

574
00:25:10,400 --> 00:25:13,120
so in the way i understand it in the

575
00:25:13,120 --> 00:25:15,520
regular proof of knowledge the

576
00:25:15,520 --> 00:25:18,520
composability

577
00:25:18,640 --> 00:25:21,520
notion is really mainly a technical tool

578
00:25:21,520 --> 00:25:24,799
that's used to say that if you have a

579
00:25:24,799 --> 00:25:26,400
proof of knowledge

580
00:25:26,400 --> 00:25:28,640
protocol with a big soundness error you

581
00:25:28,640 --> 00:25:31,919
can just repeat it and get the

582
00:25:31,919 --> 00:25:35,200
knowledge error down without negatively

583
00:25:35,200 --> 00:25:36,480
affecting

584
00:25:36,480 --> 00:25:38,240
um the

585
00:25:38,240 --> 00:25:40,320
zero knowledge property or the

586
00:25:40,320 --> 00:25:44,399
correctness or anything of that

587
00:25:44,880 --> 00:25:46,240
but there

588
00:25:46,240 --> 00:25:48,480
the point is really that sequentially

589
00:25:48,480 --> 00:25:51,440
iterating proof of knowledge protocol

590
00:25:51,440 --> 00:25:54,080
results in a proof of knowledge protocol

591
00:25:54,080 --> 00:25:57,200
that's just better but less efficient

592
00:25:57,200 --> 00:25:59,360
on the other hand

593
00:25:59,360 --> 00:26:01,520
sequentially repeating an agreement

594
00:26:01,520 --> 00:26:03,520
proof protocol is not really a green

595
00:26:03,520 --> 00:26:06,159
improved protocol anymore because each

596
00:26:06,159 --> 00:26:09,120
of the iteration might even agree on a

597
00:26:09,120 --> 00:26:11,279
completely different statement for which

598
00:26:11,279 --> 00:26:12,400
you then

599
00:26:12,400 --> 00:26:15,440
invoke the proof so

600
00:26:15,440 --> 00:26:18,400
the way i see it our protocol is really

601
00:26:18,400 --> 00:26:19,600
more of a

602
00:26:19,600 --> 00:26:21,200
uc style

603
00:26:21,200 --> 00:26:24,240
composability result that says that our

604
00:26:24,240 --> 00:26:27,039
notion is strong enough so that you can

605
00:26:27,039 --> 00:26:28,320
use it

606
00:26:28,320 --> 00:26:31,120
securely

607
00:26:32,000 --> 00:26:35,520
okay so that concludes the second part

608
00:26:35,520 --> 00:26:38,320
of the presentation introducing the

609
00:26:38,320 --> 00:26:40,000
korean proof

610
00:26:40,000 --> 00:26:43,760
notion and its properties

611
00:26:43,760 --> 00:26:46,159
as a fur part let us briefly look at

612
00:26:46,159 --> 00:26:48,240
some of the application

613
00:26:48,240 --> 00:26:51,440
and first we consider client-side

614
00:26:51,440 --> 00:26:53,360
it application

615
00:26:53,360 --> 00:26:54,960
so

616
00:26:54,960 --> 00:26:57,840
in client-side file duplication you have

617
00:26:57,840 --> 00:27:00,720
a server that stores a bunch of files

618
00:27:00,720 --> 00:27:03,120
and the client approaching it trying to

619
00:27:03,120 --> 00:27:06,000
convince the server that they already

620
00:27:06,000 --> 00:27:09,600
know the content of one of those files

621
00:27:09,600 --> 00:27:11,679
this isn't particularly useful if you

622
00:27:11,679 --> 00:27:14,880
think of maybe a hundred users that all

623
00:27:14,880 --> 00:27:17,840
have the same file locally stored and

624
00:27:17,840 --> 00:27:20,399
want to outsource it to the same cloud

625
00:27:20,399 --> 00:27:22,720
storage provider

626
00:27:22,720 --> 00:27:25,440
so rather than each of the user

627
00:27:25,440 --> 00:27:28,240
uploading the file individually and then

628
00:27:28,240 --> 00:27:30,799
maybe deserve doing some kind of

629
00:27:30,799 --> 00:27:33,279
server side the duplication to reduce

630
00:27:33,279 --> 00:27:34,399
storage

631
00:27:34,399 --> 00:27:36,640
we can get something more efficiently by

632
00:27:36,640 --> 00:27:39,760
only the first user actually uploading

633
00:27:39,760 --> 00:27:40,960
the file

634
00:27:40,960 --> 00:27:44,080
whereas all the other users can just run

635
00:27:44,080 --> 00:27:45,919
this

636
00:27:45,919 --> 00:27:48,559
more efficient protocol

637
00:27:48,559 --> 00:27:50,960
but obviously this protocol must be

638
00:27:50,960 --> 00:27:53,679
secure in the sense that a user that

639
00:27:53,679 --> 00:27:56,559
does not know um

640
00:27:56,559 --> 00:28:00,159
a file cannot trick a server into

641
00:28:00,159 --> 00:28:02,320
making the sort of belief that he knew

642
00:28:02,320 --> 00:28:05,440
it and then handing it out the secret

643
00:28:05,440 --> 00:28:08,799
file to the client

644
00:28:09,120 --> 00:28:12,159
indeed this application

645
00:28:12,159 --> 00:28:14,240
this is something that

646
00:28:14,240 --> 00:28:16,240
cloud storage provider are actually

647
00:28:16,240 --> 00:28:19,520
interested in and some of them even

648
00:28:19,520 --> 00:28:21,919
have deployed in practice

649
00:28:21,919 --> 00:28:24,960
unfortunately it turned out that many of

650
00:28:24,960 --> 00:28:26,480
those

651
00:28:26,480 --> 00:28:30,080
protocols are quite insecure in various

652
00:28:30,080 --> 00:28:33,360
subtle or less subtle manners

653
00:28:33,360 --> 00:28:37,039
this provided the televital in 2011 to

654
00:28:37,039 --> 00:28:40,080
actually formalize this task as what we

655
00:28:40,080 --> 00:28:44,840
now always call a proof of ownership

656
00:28:45,360 --> 00:28:48,080
however despite this proof of ownership

657
00:28:48,080 --> 00:28:50,240
sounding like a proof of knowledge they

658
00:28:50,240 --> 00:28:52,080
could not just say it's a specific

659
00:28:52,080 --> 00:28:54,399
instance of a proof of knowledge but

660
00:28:54,399 --> 00:28:56,640
rather had to come up with an entirely

661
00:28:56,640 --> 00:28:58,399
new security definition

662
00:28:58,399 --> 00:29:00,000
which in their

663
00:29:00,000 --> 00:29:04,000
case ended up to be entropy based so

664
00:29:04,000 --> 00:29:06,480
they're not the notion talks about all

665
00:29:06,480 --> 00:29:09,039
the files having high mean entropy and

666
00:29:09,039 --> 00:29:11,600
then security is defined only for such

667
00:29:11,600 --> 00:29:14,720
file and so on

668
00:29:14,720 --> 00:29:19,200
in our working contrast we show that

669
00:29:19,200 --> 00:29:21,360
proof of ownership really can just be

670
00:29:21,360 --> 00:29:24,000
formalized as an instantiation of our

671
00:29:24,000 --> 00:29:26,159
general agreement proof framework that

672
00:29:26,159 --> 00:29:26,960
is

673
00:29:26,960 --> 00:29:29,520
we show that we can provide a specific

674
00:29:29,520 --> 00:29:32,320
setup functionality that formalizes this

675
00:29:32,320 --> 00:29:35,279
file database this all restores

676
00:29:35,279 --> 00:29:38,720
we can formalize a correctness relation

677
00:29:38,720 --> 00:29:40,480
that

678
00:29:40,480 --> 00:29:43,760
that defines that

679
00:29:43,760 --> 00:29:46,720
user that knows such a file must succeed

680
00:29:46,720 --> 00:29:49,360
and we can formalize a

681
00:29:49,360 --> 00:29:53,039
proof relation that formalized that only

682
00:29:53,039 --> 00:29:57,520
user that knows a file must succeed

683
00:29:57,679 --> 00:30:00,480
in particular we can then

684
00:30:00,480 --> 00:30:03,120
also look at the zero knowledge

685
00:30:03,120 --> 00:30:06,399
definition with leakage that we have

686
00:30:06,399 --> 00:30:09,360
and we use that to show

687
00:30:09,360 --> 00:30:13,440
the security of a novel protocol we

688
00:30:13,440 --> 00:30:14,480
provide

689
00:30:14,480 --> 00:30:17,120
we introduce which is essentially the

690
00:30:17,120 --> 00:30:18,880
privacy preserving

691
00:30:18,880 --> 00:30:21,279
analogon of the well-known merkle tree

692
00:30:21,279 --> 00:30:24,399
based proof of ownership protocol

693
00:30:24,399 --> 00:30:25,120
so

694
00:30:25,120 --> 00:30:27,360
this merkle tree

695
00:30:27,360 --> 00:30:29,679
protocol the standard version of it is

696
00:30:29,679 --> 00:30:32,640
not zero knowledge we then make it a set

697
00:30:32,640 --> 00:30:34,960
almost zero knowledge but with some

698
00:30:34,960 --> 00:30:37,360
explicit leakage

699
00:30:37,360 --> 00:30:39,600
in particular the

700
00:30:39,600 --> 00:30:41,520
to give you maybe some example the

701
00:30:41,520 --> 00:30:42,880
leakage that

702
00:30:42,880 --> 00:30:45,120
this entrepreneur might get is

703
00:30:45,120 --> 00:30:47,679
essentially whether the server already

704
00:30:47,679 --> 00:30:51,120
has this file stored or not

705
00:30:51,120 --> 00:30:54,320
and we believe that in the context of

706
00:30:54,320 --> 00:30:56,720
client side filed it application this is

707
00:30:56,720 --> 00:30:59,679
not really an issue because

708
00:30:59,679 --> 00:31:02,640
this seems something a user inherently

709
00:31:02,640 --> 00:31:04,720
has to learn if you want to have

710
00:31:04,720 --> 00:31:07,600
official protocols where if the server

711
00:31:07,600 --> 00:31:10,480
already stores the proto the file we can

712
00:31:10,480 --> 00:31:13,440
skip uploading it but on the other hand

713
00:31:13,440 --> 00:31:15,200
if the server does not know that file

714
00:31:15,200 --> 00:31:18,240
yet then the server the user obviously

715
00:31:18,240 --> 00:31:21,919
has to upload the file

716
00:31:23,039 --> 00:31:25,919
as a second application we consider a

717
00:31:25,919 --> 00:31:28,799
two-factor client authentication that is

718
00:31:28,799 --> 00:31:30,880
a client that wants to login to some

719
00:31:30,880 --> 00:31:33,760
server using both a password as

720
00:31:33,760 --> 00:31:36,399
well as some kind of

721
00:31:36,399 --> 00:31:39,360
second factor which in our case we model

722
00:31:39,360 --> 00:31:43,360
as a abstract hardware token

723
00:31:43,360 --> 00:31:45,039
and again we

724
00:31:45,039 --> 00:31:47,919
formalized this by just instantiating

725
00:31:47,919 --> 00:31:50,559
the setup functionality correctness

726
00:31:50,559 --> 00:31:52,720
relation and proof relation of our

727
00:31:52,720 --> 00:31:54,320
framework

728
00:31:54,320 --> 00:31:57,200
and here i would really like to stress

729
00:31:57,200 --> 00:31:59,039
that this is something that none of the

730
00:31:59,039 --> 00:32:02,720
existing generalization could have done

731
00:32:02,720 --> 00:32:04,559
because this

732
00:32:04,559 --> 00:32:07,200
those relations really depend inherently

733
00:32:07,200 --> 00:32:09,519
on the setup functionality

734
00:32:09,519 --> 00:32:12,000
which in this case is the password

735
00:32:12,000 --> 00:32:14,720
database that stores user names as well

736
00:32:14,720 --> 00:32:17,519
as some kind of digest of the user's

737
00:32:17,519 --> 00:32:19,440
passwords

738
00:32:19,440 --> 00:32:20,799
but

739
00:32:20,799 --> 00:32:22,720
given that obviously users should be

740
00:32:22,720 --> 00:32:25,279
allowed to change their passwords new

741
00:32:25,279 --> 00:32:27,360
users should be allowed to change to

742
00:32:27,360 --> 00:32:29,279
join the systems and so on this is

743
00:32:29,279 --> 00:32:31,120
really something dynamic

744
00:32:31,120 --> 00:32:34,080
that the protocol cannot just assume to

745
00:32:34,080 --> 00:32:36,320
and har code

746
00:32:36,320 --> 00:32:39,200
moreover inherently we do not want that

747
00:32:39,200 --> 00:32:41,519
the prover can

748
00:32:41,519 --> 00:32:42,799
evaluate

749
00:32:42,799 --> 00:32:45,200
the proof relation

750
00:32:45,200 --> 00:32:48,000
themselves because that would mean that

751
00:32:48,000 --> 00:32:50,799
anybody can do offline

752
00:32:50,799 --> 00:32:56,200
brute force attacks towards this system

753
00:32:56,320 --> 00:33:00,480
finally um this example also shows that

754
00:33:00,480 --> 00:33:02,799
our agree improve formalization actually

755
00:33:02,799 --> 00:33:04,480
can not only do

756
00:33:04,480 --> 00:33:07,360
proof of knowledge type of stuff but

757
00:33:07,360 --> 00:33:10,559
also can handle this kind of hardware

758
00:33:10,559 --> 00:33:12,480
token

759
00:33:12,480 --> 00:33:14,720
proof that

760
00:33:14,720 --> 00:33:16,720
is not really a proof of knowledge

761
00:33:16,720 --> 00:33:19,120
because there's nothing to extract but

762
00:33:19,120 --> 00:33:21,039
it's rather some kind of proof of

763
00:33:21,039 --> 00:33:22,799
ability or

764
00:33:22,799 --> 00:33:24,640
approve approver demonstrates that they

765
00:33:24,640 --> 00:33:28,320
have access to something physical which

766
00:33:28,320 --> 00:33:31,039
in our case we model of has in having

767
00:33:31,039 --> 00:33:32,880
specific access to the setup

768
00:33:32,880 --> 00:33:35,760
functionality

769
00:33:36,399 --> 00:33:38,640
to wrap up this talk

770
00:33:38,640 --> 00:33:41,440
we first revisited um

771
00:33:41,440 --> 00:33:43,519
proof of knowledge and

772
00:33:43,519 --> 00:33:44,480
we

773
00:33:44,480 --> 00:33:47,760
seen that there already existed many

774
00:33:47,760 --> 00:33:49,840
generalization

775
00:33:49,840 --> 00:33:52,799
however each of those

776
00:33:52,799 --> 00:33:56,240
sort of tackled a specific aspect where

777
00:33:56,240 --> 00:33:58,240
proof of knowledge were not very general

778
00:33:58,240 --> 00:33:59,679
so far

779
00:33:59,679 --> 00:34:02,080
in this work we present the first proof

780
00:34:02,080 --> 00:34:04,559
of knowledge generalization that unifies

781
00:34:04,559 --> 00:34:06,799
all of those aspects namely fully

782
00:34:06,799 --> 00:34:08,480
dynamic setup

783
00:34:08,480 --> 00:34:12,000
dynamic and setup dependent relations

784
00:34:12,000 --> 00:34:15,359
and third dynamic and setup dependent

785
00:34:15,359 --> 00:34:18,320
statement negotiation with an explicit

786
00:34:18,320 --> 00:34:20,800
agreement phase

787
00:34:20,800 --> 00:34:24,079
finally we showed that our

788
00:34:24,079 --> 00:34:28,000
notion is indeed useful for formalizing

789
00:34:28,000 --> 00:34:30,000
proof of knowledge type

790
00:34:30,000 --> 00:34:32,639
higher level security goals

791
00:34:32,639 --> 00:34:34,560
by giving those two

792
00:34:34,560 --> 00:34:35,918
examples

793
00:34:35,918 --> 00:34:38,399
but of course we believe that our

794
00:34:38,399 --> 00:34:41,918
general framework can be of use for

795
00:34:41,918 --> 00:34:45,520
also many different examples and we'll

796
00:34:45,520 --> 00:34:49,199
leave it up to you to come up with new

797
00:34:49,199 --> 00:34:50,520
exciting

798
00:34:50,520 --> 00:34:54,000
applications and maybe

799
00:34:54,000 --> 00:34:54,800
would

800
00:34:54,800 --> 00:34:57,280
love to hear feedback on whether you

801
00:34:57,280 --> 00:34:59,680
found our notion to be useful or that

802
00:34:59,680 --> 00:35:02,560
you had to maybe slightly tweak it and

803
00:35:02,560 --> 00:35:04,640
so on

804
00:35:04,640 --> 00:35:09,879
with this i thank you for your attention

