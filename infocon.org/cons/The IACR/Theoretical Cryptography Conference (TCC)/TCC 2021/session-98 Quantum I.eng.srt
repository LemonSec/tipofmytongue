1
00:00:00,160 --> 00:00:01,839
another time

2
00:00:01,839 --> 00:00:04,640
um so the first talk is going to be on

3
00:00:04,640 --> 00:00:07,440
uh secure quantum community computation

4
00:00:07,440 --> 00:00:10,160
with classical communication

5
00:00:10,160 --> 00:00:13,120
and by james bartusek and james is going

6
00:00:13,120 --> 00:00:17,400
to give you the talk in person

7
00:00:19,439 --> 00:00:20,640
thank you

8
00:00:20,640 --> 00:00:21,840
um

9
00:00:21,840 --> 00:00:25,359
yeah so this is a talk about um

10
00:00:25,359 --> 00:00:26,800
here quantum computation with positive

11
00:00:26,800 --> 00:00:28,320
communication

12
00:00:28,320 --> 00:00:29,599
trying to

13
00:00:29,599 --> 00:00:30,480
oh

14
00:00:30,480 --> 00:00:33,120
yeah so uh it's about the notion of

15
00:00:33,120 --> 00:00:35,920
secure multi-party computation or mpc

16
00:00:35,920 --> 00:00:38,559
um mpc allows multiple parties each with

17
00:00:38,559 --> 00:00:41,360
a private input to communicate in order

18
00:00:41,360 --> 00:00:43,200
to learn the results of a public circuit

19
00:00:43,200 --> 00:00:46,000
c computed over their private inputs

20
00:00:46,000 --> 00:00:48,320
and for security we require that any

21
00:00:48,320 --> 00:00:49,920
adversary that corrupts some subset of

22
00:00:49,920 --> 00:00:53,039
these parties here two and three um

23
00:00:53,039 --> 00:00:54,800
can't learn anything about the inputs of

24
00:00:54,800 --> 00:00:56,879
the honest parties here one and four

25
00:00:56,879 --> 00:00:58,559
except for what is implied by the output

26
00:00:58,559 --> 00:01:00,000
of this circuit

27
00:01:00,000 --> 00:01:02,239
and npc is clearly a you know

28
00:01:02,239 --> 00:01:03,520
foundational notion in modern

29
00:01:03,520 --> 00:01:04,720
cryptography and it's been really

30
00:01:04,720 --> 00:01:06,640
extensively studied since it was

31
00:01:06,640 --> 00:01:10,159
introduced in the 80s

32
00:01:10,159 --> 00:01:13,760
so um yeah naturally most of the mpc

33
00:01:13,760 --> 00:01:16,320
literature is uh you know about the case

34
00:01:16,320 --> 00:01:18,080
when all of these parties are classical

35
00:01:18,080 --> 00:01:18,960
right

36
00:01:18,960 --> 00:01:21,040
but over the past couple of decades the

37
00:01:21,040 --> 00:01:22,720
notion of secure multi-party quantum

38
00:01:22,720 --> 00:01:24,840
computation has also been

39
00:01:24,840 --> 00:01:26,799
studied and

40
00:01:26,799 --> 00:01:27,600
here

41
00:01:27,600 --> 00:01:29,119
you know we assume that each party is

42
00:01:29,119 --> 00:01:30,079
quantum

43
00:01:30,079 --> 00:01:31,520
they might have potentially quantum

44
00:01:31,520 --> 00:01:32,799
inputs and they'd like to compute some

45
00:01:32,799 --> 00:01:35,280
quantum functionality over these points

46
00:01:35,280 --> 00:01:37,040
and you can define

47
00:01:37,040 --> 00:01:39,040
security in much the same way

48
00:01:39,040 --> 00:01:40,640
okay

49
00:01:40,640 --> 00:01:42,000
um

50
00:01:42,000 --> 00:01:44,799
but until now um it's been the case that

51
00:01:44,799 --> 00:01:47,040
really npc has been studied in uh one of

52
00:01:47,040 --> 00:01:48,960
these two settings either every party is

53
00:01:48,960 --> 00:01:51,680
classical or every party is spontaneous

54
00:01:51,680 --> 00:01:54,799
right and you know so while quantum

55
00:01:54,799 --> 00:01:56,640
computing technology is being developed

56
00:01:56,640 --> 00:01:58,799
it's clearly very resource intensive and

57
00:01:58,799 --> 00:02:00,159
it seems at least for the foreseeable

58
00:02:00,159 --> 00:02:02,240
future that like there really will only

59
00:02:02,240 --> 00:02:03,759
be a few organizations that have any

60
00:02:03,759 --> 00:02:06,240
significant quantum computing ability

61
00:02:06,240 --> 00:02:08,479
so it's natural to wonder whether us

62
00:02:08,479 --> 00:02:10,959
like classical parties um

63
00:02:10,959 --> 00:02:12,879
can you know interact in these secure

64
00:02:12,879 --> 00:02:14,640
computation protocols with these quantum

65
00:02:14,640 --> 00:02:17,200
computers okay and so that's exactly uh

66
00:02:17,200 --> 00:02:19,200
the notion that this work studies

67
00:02:19,200 --> 00:02:20,239
um

68
00:02:20,239 --> 00:02:22,720
mpc for quantum functionalities with

69
00:02:22,720 --> 00:02:24,800
both quantum and classical participants

70
00:02:24,800 --> 00:02:27,520
at the same time okay

71
00:02:27,520 --> 00:02:28,319
um

72
00:02:28,319 --> 00:02:30,160
so the results here consist of some

73
00:02:30,160 --> 00:02:32,480
building blocks and applications

74
00:02:32,480 --> 00:02:33,920
the main building block or the main like

75
00:02:33,920 --> 00:02:35,840
technical contribution

76
00:02:35,840 --> 00:02:37,920
are new constructions of

77
00:02:37,920 --> 00:02:40,080
cvqc or classical verification of

78
00:02:40,080 --> 00:02:42,480
quantum computation protocols that enjoy

79
00:02:42,480 --> 00:02:44,640
some notions of blindness and

80
00:02:44,640 --> 00:02:48,080
composability okay so cbqc considered as

81
00:02:48,080 --> 00:02:50,879
a classical client with an input x

82
00:02:50,879 --> 00:02:53,200
interacting with a quantum server at the

83
00:02:53,200 --> 00:02:55,360
end of which the client learns the value

84
00:02:55,360 --> 00:02:57,200
q of x where q is some quantum

85
00:02:57,200 --> 00:02:58,400
functionality

86
00:02:58,400 --> 00:03:00,959
and the cvpc protocol should always be

87
00:03:00,959 --> 00:03:02,720
sound meaning that a malicious server

88
00:03:02,720 --> 00:03:05,040
cannot cause the client to cut to output

89
00:03:05,040 --> 00:03:07,840
a false output or wrong output

90
00:03:07,840 --> 00:03:09,519
but in this work we're also inter we're

91
00:03:09,519 --> 00:03:11,280
also interested in the notion of

92
00:03:11,280 --> 00:03:12,800
blindness and so we want our protocols

93
00:03:12,800 --> 00:03:15,599
to also simultaneously satisfy blindness

94
00:03:15,599 --> 00:03:16,959
meaning that a malicious server should

95
00:03:16,959 --> 00:03:19,200
learn nothing about the client systems

96
00:03:19,200 --> 00:03:22,080
while interacting this protocol

97
00:03:22,080 --> 00:03:23,320
and finally

98
00:03:23,320 --> 00:03:26,478
[Music]

99
00:03:30,159 --> 00:03:32,159
finally we would like to also ensure

100
00:03:32,159 --> 00:03:34,400
some notion of composability which

101
00:03:34,400 --> 00:03:36,879
intuitively means that like uh we should

102
00:03:36,879 --> 00:03:38,879
be able to use this protocol securely as

103
00:03:38,879 --> 00:03:41,680
a building block within a larger context

104
00:03:41,680 --> 00:03:43,519
potentially in a protocol involving even

105
00:03:43,519 --> 00:03:46,480
more than two parties okay and to ensure

106
00:03:46,480 --> 00:03:48,879
composability will require that our uh

107
00:03:48,879 --> 00:03:52,239
cbtc protocol satisfies or emulates a

108
00:03:52,239 --> 00:03:54,400
appropriate ideal functionality which

109
00:03:54,400 --> 00:03:55,840
will also actually capture the notions

110
00:03:55,840 --> 00:03:57,760
of soundness and blindness

111
00:03:57,760 --> 00:04:01,840
okay so um

112
00:04:03,120 --> 00:04:05,360
yeah so in this work uh we give a four

113
00:04:05,360 --> 00:04:07,519
message protocol for a composable blind

114
00:04:07,519 --> 00:04:08,959
cpqc

115
00:04:08,959 --> 00:04:10,239
from the quantum harness of learning

116
00:04:10,239 --> 00:04:11,439
with aris

117
00:04:11,439 --> 00:04:14,080
and we also give a two message protocol

118
00:04:14,080 --> 00:04:15,680
with some other useful properties i'm in

119
00:04:15,680 --> 00:04:17,600
the quantum and welcome all right and

120
00:04:17,600 --> 00:04:18,959
then we show

121
00:04:18,959 --> 00:04:20,478
applications

122
00:04:20,478 --> 00:04:23,120
to this setting that i described earlier

123
00:04:23,120 --> 00:04:25,120
of npc with both quantum and classical

124
00:04:25,120 --> 00:04:26,880
participants

125
00:04:26,880 --> 00:04:29,520
so here one setting we consider is the

126
00:04:29,520 --> 00:04:32,160
setting of like cloud assisted npc uh

127
00:04:32,160 --> 00:04:34,400
where we have multiple uh classical

128
00:04:34,400 --> 00:04:36,080
clients used with the private input that

129
00:04:36,080 --> 00:04:37,759
would like to utilize the resources of a

130
00:04:37,759 --> 00:04:39,919
quantum server in order to securely

131
00:04:39,919 --> 00:04:41,360
compute a quantum functionality over

132
00:04:41,360 --> 00:04:44,000
their inputs okay and here we give a

133
00:04:44,000 --> 00:04:46,320
six-round protocol from lwe

134
00:04:46,320 --> 00:04:47,440
and we also optimize the round

135
00:04:47,440 --> 00:04:50,960
complexities using the qram and

136
00:04:50,960 --> 00:04:54,560
public infrastructure setup okay

137
00:04:54,560 --> 00:04:56,320
the other main uh setting that we

138
00:04:56,320 --> 00:04:57,840
consider is just this two-party setting

139
00:04:57,840 --> 00:04:59,520
where we have one classical party one

140
00:04:59,520 --> 00:05:01,919
quantum party each with a private input

141
00:05:01,919 --> 00:05:03,840
um and here we give a two message

142
00:05:03,840 --> 00:05:05,680
protocol that delivers output to the

143
00:05:05,680 --> 00:05:06,960
classical party

144
00:05:06,960 --> 00:05:09,120
and this is this type of protocol is

145
00:05:09,120 --> 00:05:10,800
usually referred to as a non-attractive

146
00:05:10,800 --> 00:05:13,360
secure computation protocol or a nisk

147
00:05:13,360 --> 00:05:15,440
and so what this result is is the first

148
00:05:15,440 --> 00:05:17,280
nist with classical communication that

149
00:05:17,280 --> 00:05:20,479
can handle functionalities beyond p so

150
00:05:20,479 --> 00:05:22,000
in particular can handle some class of

151
00:05:22,000 --> 00:05:24,800
quantum functionalities okay and then

152
00:05:24,800 --> 00:05:26,240
finally just to be precise like the

153
00:05:26,240 --> 00:05:27,840
protocols we construct in this work are

154
00:05:27,840 --> 00:05:29,840
maliciously secure against dishonest

155
00:05:29,840 --> 00:05:31,520
majority and they all operate in the

156
00:05:31,520 --> 00:05:33,199
common random string model

157
00:05:33,199 --> 00:05:34,880
and the classes functionalities of

158
00:05:34,880 --> 00:05:36,320
quantum functionalities we can handle

159
00:05:36,320 --> 00:05:37,919
are those with classical input and

160
00:05:37,919 --> 00:05:39,039
output

161
00:05:39,039 --> 00:05:40,800
but that are also restricted to be c to

162
00:05:40,800 --> 00:05:42,400
deterministic meaning that for every

163
00:05:42,400 --> 00:05:44,000
classical input there's like a single

164
00:05:44,000 --> 00:05:46,000
classical output that's obtained

165
00:05:46,000 --> 00:05:48,000
except with negative probability and

166
00:05:48,000 --> 00:05:49,600
it's actually open to extend these

167
00:05:49,600 --> 00:05:50,960
results

168
00:05:50,960 --> 00:05:52,639
and even more basic just verification

169
00:05:52,639 --> 00:05:55,199
results to handle the more general class

170
00:05:55,199 --> 00:05:56,720
of quantum functionalities that output

171
00:05:56,720 --> 00:05:58,960
an arbitrary distribution over classical

172
00:05:58,960 --> 00:06:00,080
strings

173
00:06:00,080 --> 00:06:02,240
and so this is all i wanted to say so

174
00:06:02,240 --> 00:06:05,479
thank you

175
00:06:10,800 --> 00:06:14,080
are there any questions

176
00:06:17,759 --> 00:06:19,840
i have a question uh

177
00:06:19,840 --> 00:06:22,800
it's uh around can i think um

178
00:06:22,800 --> 00:06:25,360
what about uh reactive functionalities i

179
00:06:25,360 --> 00:06:27,919
mean keeping state and can can

180
00:06:27,919 --> 00:06:30,319
particularly can classical parties make

181
00:06:30,319 --> 00:06:32,960
sure that the quantum side keeps staying

182
00:06:32,960 --> 00:06:36,000
as they're supposed to

183
00:06:37,199 --> 00:06:39,120
yeah so you're asking if we construct

184
00:06:39,120 --> 00:06:40,560
protocols that handle like reactive

185
00:06:40,560 --> 00:06:42,400
quantum functionalities

186
00:06:42,400 --> 00:06:43,840
um yes

187
00:06:43,840 --> 00:06:45,039
yeah that's not

188
00:06:45,039 --> 00:06:46,560
right so that's not something that we

189
00:06:46,560 --> 00:06:48,639
handle in this work um

190
00:06:48,639 --> 00:06:50,080
it might be tricky because like maybe

191
00:06:50,080 --> 00:06:52,960
the intermediate okay maybe if each

192
00:06:52,960 --> 00:06:54,160
individual

193
00:06:54,160 --> 00:06:56,160
computation is also deterministic it

194
00:06:56,160 --> 00:06:58,080
should probably extend to that setting

195
00:06:58,080 --> 00:06:59,360
but then once you get into like

196
00:06:59,360 --> 00:07:01,280
intermediate quantum computations that

197
00:07:01,280 --> 00:07:02,880
are maybe more general than

198
00:07:02,880 --> 00:07:04,400
pseudo-deterministic computations then

199
00:07:04,400 --> 00:07:07,520
it would probably not handle that case

200
00:07:07,520 --> 00:07:10,520
thanks

201
00:07:16,800 --> 00:07:20,319
okay any other questions

202
00:07:20,319 --> 00:07:26,199
okay so uh let's thank james again

203
00:07:30,479 --> 00:07:33,479
um

204
00:07:50,160 --> 00:07:54,280
let's just play next

205
00:08:15,919 --> 00:08:18,639
okay so the next talk

206
00:08:18,639 --> 00:08:21,680
is on quantum key length extension

207
00:08:21,680 --> 00:08:24,319
by joseph jager

208
00:08:24,319 --> 00:08:27,280
fan song and stefano tessaro

209
00:08:27,280 --> 00:08:32,280
and joseph is going to give the talk

210
00:08:44,800 --> 00:08:46,640
thanks for that introduction

211
00:08:46,640 --> 00:08:48,399
like you just said i'm joseph and i'll

212
00:08:48,399 --> 00:08:49,920
be talking to you

213
00:08:49,920 --> 00:08:52,320
about my work analyzing the security of

214
00:08:52,320 --> 00:08:55,200
key length extension

215
00:09:06,080 --> 00:09:08,320
quantum computers will have all sorts of

216
00:09:08,320 --> 00:09:10,800
ramifications of cryptography there will

217
00:09:10,800 --> 00:09:12,959
be new types of schemes

218
00:09:12,959 --> 00:09:15,839
some schemes will be completely broken

219
00:09:15,839 --> 00:09:18,160
and for the purposes of minecraft some

220
00:09:18,160 --> 00:09:20,000
schemes won't be completely focused but

221
00:09:20,000 --> 00:09:23,839
they're concrete security

222
00:09:24,430 --> 00:09:32,949
[Music]

223
00:09:34,480 --> 00:09:37,120
which might reduce the scheme from 128

224
00:09:37,120 --> 00:09:40,240
30 to 64

225
00:09:41,440 --> 00:09:44,640
so then we have a question

226
00:09:46,399 --> 00:09:48,640
there are two approaches

227
00:09:48,640 --> 00:09:50,800
the first is to just design scenes which

228
00:09:50,800 --> 00:09:52,880
inherently have locked their keys

229
00:09:52,880 --> 00:09:58,320
moving to aes 256 from as128 for example

230
00:09:58,320 --> 00:10:00,000
the other approaches that i've seen in

231
00:10:00,000 --> 00:10:01,680
my world

232
00:10:01,680 --> 00:10:04,000
is keynote extension techniques where we

233
00:10:04,000 --> 00:10:06,720
take a scheme with short keys and

234
00:10:06,720 --> 00:10:09,519
somehow apply a transformation to it use

235
00:10:09,519 --> 00:10:12,640
more keying material

236
00:10:13,440 --> 00:10:14,720
we've kind of seen this setting

237
00:10:14,720 --> 00:10:16,800
previously with

238
00:10:16,800 --> 00:10:19,800
56

239
00:10:20,079 --> 00:10:21,600
so various different options were

240
00:10:21,600 --> 00:10:24,240
analyzed there

241
00:10:24,240 --> 00:10:26,320
as you would expect from my examples the

242
00:10:26,320 --> 00:10:29,279
security thing you're considering is prp

243
00:10:29,279 --> 00:10:31,440
or prx security

244
00:10:31,440 --> 00:10:32,959
and in particular we're doing it in

245
00:10:32,959 --> 00:10:35,519
ideal models

246
00:10:35,519 --> 00:10:37,279
where we think of the attacker's

247
00:10:37,279 --> 00:10:39,360
computation and all of its various

248
00:10:39,360 --> 00:10:40,800
systems random

249
00:10:40,800 --> 00:10:42,880
idea of cipher as the its local

250
00:10:42,880 --> 00:10:44,399
computation

251
00:10:44,399 --> 00:10:46,640
and the queries it makes to the game are

252
00:10:46,640 --> 00:10:49,440
external computation being used by the

253
00:10:49,440 --> 00:10:51,360
user being attacked

254
00:10:51,360 --> 00:10:53,120
this gives us kind of three levels of

255
00:10:53,120 --> 00:10:55,120
security we might consider

256
00:10:55,120 --> 00:10:57,600
the classical security which we're used

257
00:10:57,600 --> 00:10:59,279
to analyzing

258
00:10:59,279 --> 00:11:00,880
you can also consider a partially

259
00:11:00,880 --> 00:11:03,440
quantum setting where the attacker is

260
00:11:03,440 --> 00:11:06,880
using a quantum computer in its attacks

261
00:11:06,880 --> 00:11:09,839
but the honest users are still classical

262
00:11:09,839 --> 00:11:11,519
this is like these devices for many

263
00:11:11,519 --> 00:11:13,200
applications

264
00:11:13,200 --> 00:11:14,720
and finally there's the fully quantum

265
00:11:14,720 --> 00:11:16,880
setting where all the attackers

266
00:11:16,880 --> 00:11:18,640
performance and the external

267
00:11:18,640 --> 00:11:21,199
computations

268
00:11:23,120 --> 00:11:24,959
we analyze three different techniques

269
00:11:24,959 --> 00:11:25,920
here

270
00:11:25,920 --> 00:11:28,399
the first we consider it called fx where

271
00:11:28,399 --> 00:11:31,040
you augment your block cipher by xoring

272
00:11:31,040 --> 00:11:33,600
a key into the input and then the output

273
00:11:33,600 --> 00:11:35,600
of the block cycle

274
00:11:35,600 --> 00:11:37,839
this is analyzed classically by tuning

275
00:11:37,839 --> 00:11:40,079
in

276
00:11:40,320 --> 00:11:42,160
this is meaningfully more secure than if

277
00:11:42,160 --> 00:11:45,600
you just use the block cipher by itself

278
00:11:45,600 --> 00:11:47,360
however if we move to the fully quantum

279
00:11:47,360 --> 00:11:49,440
setting this is not sound

280
00:11:49,440 --> 00:11:52,480
there's a clever attack

281
00:11:52,480 --> 00:11:54,240
which is able to make this feeling no

282
00:11:54,240 --> 00:11:56,000
more secure than if you're just using

283
00:11:56,000 --> 00:11:57,920
the block system by itself

284
00:11:57,920 --> 00:11:59,920
however these attacks which combine kind

285
00:11:59,920 --> 00:12:01,920
of global search and science seem to

286
00:12:01,920 --> 00:12:03,920
inherently need quantum access to both

287
00:12:03,920 --> 00:12:05,600
of its oracles

288
00:12:05,600 --> 00:12:06,959
and particularly we can make this

289
00:12:06,959 --> 00:12:10,639
rigorous by showing that it is a sound

290
00:12:10,639 --> 00:12:12,560
technique in the partially quantum

291
00:12:12,560 --> 00:12:14,720
center

292
00:12:14,720 --> 00:12:16,800
because of some technical difficulties

293
00:12:16,800 --> 00:12:19,200
that often get run into it with the

294
00:12:19,200 --> 00:12:20,880
quantum analysis of schemes based on

295
00:12:20,880 --> 00:12:23,440
random permutations we were only able to

296
00:12:23,440 --> 00:12:25,600
prove this result against non-adaptive

297
00:12:25,600 --> 00:12:27,920
results attacks

298
00:12:27,920 --> 00:12:29,519
to kind of poke at whether it might be

299
00:12:29,519 --> 00:12:31,600
secure adaptively we looked at a

300
00:12:31,600 --> 00:12:33,360
releasing construction where you replace

301
00:12:33,360 --> 00:12:34,639
the permutation

302
00:12:34,639 --> 00:12:36,240
function

303
00:12:36,240 --> 00:12:38,000
and here we were able to give a fully

304
00:12:38,000 --> 00:12:40,720
adapted proof

305
00:12:41,360 --> 00:12:43,760
finally we look at double encryption

306
00:12:43,760 --> 00:12:45,279
where you just apply your block cipher

307
00:12:45,279 --> 00:12:47,760
twice with independent keys

308
00:12:47,760 --> 00:12:49,760
you may recall classically that this is

309
00:12:49,760 --> 00:12:52,320
no more secure single encryption due to

310
00:12:52,320 --> 00:12:54,160
the median and minimal attack

311
00:12:54,160 --> 00:12:56,480
so it may be somewhat surprising then

312
00:12:56,480 --> 00:12:58,560
that in the fully quantum setting this

313
00:12:58,560 --> 00:13:00,639
actually is a sound

314
00:13:00,639 --> 00:13:03,600
keying exception

315
00:13:04,880 --> 00:13:07,360
high-level intuition which breaks what

316
00:13:07,360 --> 00:13:09,600
might seem like a paradox is the fact

317
00:13:09,600 --> 00:13:11,279
that the savings you get from global

318
00:13:11,279 --> 00:13:13,040
such and the savings you get from the

319
00:13:13,040 --> 00:13:14,720
mean in the middle attack and some

320
00:13:14,720 --> 00:13:16,880
sensors can't be composed on top of each

321
00:13:16,880 --> 00:13:19,880
other

322
00:13:20,000 --> 00:13:22,000
of very briefly touch on the techniques

323
00:13:22,000 --> 00:13:24,000
we use in our proofs

324
00:13:24,000 --> 00:13:26,560
for fx it's a nice application of one

325
00:13:26,560 --> 00:13:28,320
way of hiding levels where we just have

326
00:13:28,320 --> 00:13:30,000
to very carefully figure out how to

327
00:13:30,000 --> 00:13:31,600
express our security

328
00:13:31,600 --> 00:13:34,880
to then directly apply these knobs

329
00:13:34,880 --> 00:13:36,800
for our adapter proof we had to combine

330
00:13:36,800 --> 00:13:39,199
one way to hide it as well as xavier's

331
00:13:39,199 --> 00:13:41,839
techniques for laserly sampling random

332
00:13:41,839 --> 00:13:45,279
functions that are being accessed

333
00:13:45,839 --> 00:13:47,760
somewhat interestingly part of how we do

334
00:13:47,760 --> 00:13:48,560
this

335
00:13:48,560 --> 00:13:50,639
involves applying vanities technique to

336
00:13:50,639 --> 00:13:51,920
an oracle

337
00:13:51,920 --> 00:13:53,839
in this partially quantum setting which

338
00:13:53,839 --> 00:13:56,720
is being accessed

339
00:14:00,240 --> 00:14:02,720
our proof is based on a reduction to a

340
00:14:02,720 --> 00:14:05,279
worst case list destroying this problem

341
00:14:05,279 --> 00:14:07,519
and the new quantum analysis of this

342
00:14:07,519 --> 00:14:10,320
this destruction

343
00:14:11,440 --> 00:14:13,120
i will leave some interesting open

344
00:14:13,120 --> 00:14:16,079
problems one is doing full adaptive

345
00:14:16,079 --> 00:14:18,320
analysis of effects

346
00:14:18,320 --> 00:14:20,639
this seems to require some sort of lazy

347
00:14:20,639 --> 00:14:23,680
sampling for permutations

348
00:14:23,680 --> 00:14:26,240
and it needs to be perfectly sampling as

349
00:14:26,240 --> 00:14:28,399
opposed to recently the assembling

350
00:14:28,399 --> 00:14:30,959
introduced the

351
00:14:31,360 --> 00:14:33,199
whose concrete security isn't good

352
00:14:33,199 --> 00:14:36,240
enough to be meaningful

353
00:14:37,199 --> 00:14:38,959
and the second question is if we can

354
00:14:38,959 --> 00:14:41,199
give tighter analysis for a list

355
00:14:41,199 --> 00:14:42,639
destroying this

356
00:14:42,639 --> 00:14:44,880
so our proof here for this worst k

357
00:14:44,880 --> 00:14:48,959
problem gave us this result with a 6

358
00:14:48,959 --> 00:14:50,720
the kind of function inside of the sixth

359
00:14:50,720 --> 00:14:53,360
root isn't too terrible looking

360
00:14:53,360 --> 00:14:55,920
but a sixth root is really bad for

361
00:14:55,920 --> 00:14:59,160
some parameters

362
00:15:11,040 --> 00:15:15,040
more questions or any questions

363
00:15:15,040 --> 00:15:17,440
yes i have a question

364
00:15:17,440 --> 00:15:18,320
in

365
00:15:18,320 --> 00:15:19,440
fx

366
00:15:19,440 --> 00:15:22,320
did you look at the original design of

367
00:15:22,320 --> 00:15:26,000
des x which had k2 before and k3

368
00:15:26,000 --> 00:15:27,360
afterwards

369
00:15:27,360 --> 00:15:29,279
in other words two different

370
00:15:29,279 --> 00:15:31,440
two different blinding keys one before

371
00:15:31,440 --> 00:15:34,160
and one after

372
00:15:34,720 --> 00:15:37,440
great question um so for how we did our

373
00:15:37,440 --> 00:15:38,399
proof

374
00:15:38,399 --> 00:15:39,680
we kind of thought about what would

375
00:15:39,680 --> 00:15:42,000
happen if these keys were different

376
00:15:42,000 --> 00:15:44,639
and the security round we got wasn't any

377
00:15:44,639 --> 00:15:46,320
better than what we get by using the

378
00:15:46,320 --> 00:15:48,800
same key for the input in the output

379
00:15:48,800 --> 00:15:52,000
which is why we did this

380
00:15:52,480 --> 00:15:54,000
well that was the er that was the

381
00:15:54,000 --> 00:15:56,720
original resolution of des x because it

382
00:15:56,720 --> 00:15:58,240
didn't really matter whether the keys

383
00:15:58,240 --> 00:15:59,279
were different

384
00:15:59,279 --> 00:16:02,320
then my second question would be

385
00:16:02,320 --> 00:16:04,959
uh for double encryption the obvious

386
00:16:04,959 --> 00:16:07,519
extension in dez is triple encryption

387
00:16:07,519 --> 00:16:09,040
ede

388
00:16:09,040 --> 00:16:12,000
did you look at that

389
00:16:12,079 --> 00:16:13,839
um

390
00:16:13,839 --> 00:16:15,680
not really so kind of our proof

391
00:16:15,680 --> 00:16:17,759
technique was based on the introduction

392
00:16:17,759 --> 00:16:20,560
to this destroying this problem

393
00:16:20,560 --> 00:16:23,360
and we didn't have any sort of analog of

394
00:16:23,360 --> 00:16:24,160
that

395
00:16:24,160 --> 00:16:24,959
for

396
00:16:24,959 --> 00:16:26,880
trivial encryption or

397
00:16:26,880 --> 00:16:28,639
beyond

398
00:16:28,639 --> 00:16:30,959
thank you

399
00:16:35,120 --> 00:16:38,160
any other questions

400
00:16:39,680 --> 00:16:45,079
great so let's thank joseph again

401
00:16:48,470 --> 00:16:51,559
[Music]

402
00:16:53,279 --> 00:16:56,320
i apologize i made some

403
00:16:56,320 --> 00:16:57,500
reordering of the

404
00:16:57,500 --> 00:16:58,639
[Music]

405
00:16:58,639 --> 00:17:00,240
um

406
00:17:00,240 --> 00:17:04,160
the talks that was not on purpose um so

407
00:17:04,160 --> 00:17:06,000
the next talk

408
00:17:06,000 --> 00:17:08,240
is going to be on uh

409
00:17:08,240 --> 00:17:10,640
secure software leasing without

410
00:17:10,640 --> 00:17:15,199
assumptions it's a work by and broadband

411
00:17:15,199 --> 00:17:20,000
stacy jeffrey sebastian lord suparta

412
00:17:20,000 --> 00:17:21,919
and aarti

413
00:17:21,919 --> 00:17:23,919
sundaram

414
00:17:23,919 --> 00:17:28,839
and sebastian is going to give the talk

415
00:17:37,840 --> 00:17:39,200
all right hello everyone my name is

416
00:17:39,200 --> 00:17:40,960
sebastian lord and i'm happy to be here

417
00:17:40,960 --> 00:17:43,039
to talk about secure software leasing

418
00:17:43,039 --> 00:17:44,559
without assumptions

419
00:17:44,559 --> 00:17:46,559
this is joint work with my co-authors

420
00:17:46,559 --> 00:17:49,200
and broadband stacy jeffrey super the

421
00:17:49,200 --> 00:17:52,240
potter and artie sandra

422
00:17:52,240 --> 00:17:54,720
so like many interesting stories in

423
00:17:54,720 --> 00:17:56,960
quantum cryptography ours begins with

424
00:17:56,960 --> 00:17:58,640
the no cloning principle which

425
00:17:58,640 --> 00:18:00,720
essentially states that it is impossible

426
00:18:00,720 --> 00:18:03,520
to create perfect copies of arbitrary

427
00:18:03,520 --> 00:18:04,960
quantum states

428
00:18:04,960 --> 00:18:06,880
in other words quantum states aren't

429
00:18:06,880 --> 00:18:07,600
like

430
00:18:07,600 --> 00:18:09,520
you can't clone them

431
00:18:09,520 --> 00:18:11,919
now we use this to achieve many

432
00:18:11,919 --> 00:18:13,919
different security notions that would

433
00:18:13,919 --> 00:18:15,840
otherwise be impossible in the purely

434
00:18:15,840 --> 00:18:17,840
classical setting such as quantum key

435
00:18:17,840 --> 00:18:20,240
distribution and quantum money

436
00:18:20,240 --> 00:18:21,840
and one very interesting research

437
00:18:21,840 --> 00:18:24,240
direction is to ask what else can we

438
00:18:24,240 --> 00:18:27,760
achieve using the no cloning principle

439
00:18:27,760 --> 00:18:30,640
so in 2009 scott aaronson asked the

440
00:18:30,640 --> 00:18:33,039
question can quantum states be used as

441
00:18:33,039 --> 00:18:35,120
copy protected programs which let the

442
00:18:35,120 --> 00:18:38,080
user evaluate some function f but not

443
00:18:38,080 --> 00:18:40,720
create more programs for f

444
00:18:40,720 --> 00:18:42,240
in other words we're looking for

445
00:18:42,240 --> 00:18:44,000
something that kind of looks like this

446
00:18:44,000 --> 00:18:46,480
figure where we have two procedures

447
00:18:46,480 --> 00:18:49,360
protect and eval such that we can feed a

448
00:18:49,360 --> 00:18:51,760
circuit or a function to the protection

449
00:18:51,760 --> 00:18:54,960
procedure obtain some quantum state row

450
00:18:54,960 --> 00:18:56,480
which can then be used with the

451
00:18:56,480 --> 00:18:58,720
evaluation procedure to correctly

452
00:18:58,720 --> 00:19:01,679
compute the function for the circuit

453
00:19:01,679 --> 00:19:03,679
in this work we consider two different

454
00:19:03,679 --> 00:19:06,320
security notions for these types of

455
00:19:06,320 --> 00:19:08,720
schemes namely honest malicious copy

456
00:19:08,720 --> 00:19:12,400
protection and secure software releasing

457
00:19:12,400 --> 00:19:14,640
okay so erinson asked his questions in

458
00:19:14,640 --> 00:19:17,679
2009 and in the past two years there's

459
00:19:17,679 --> 00:19:20,160
been a flurry of results on the topic of

460
00:19:20,160 --> 00:19:22,240
copy protection including other work

461
00:19:22,240 --> 00:19:23,840
that will be presented later at this

462
00:19:23,840 --> 00:19:25,520
conference and i'm quite eager to hear

463
00:19:25,520 --> 00:19:27,760
that talk

464
00:19:27,760 --> 00:19:29,919
however all of these words use standard

465
00:19:29,919 --> 00:19:32,080
assumptions or oracles or some sort of

466
00:19:32,080 --> 00:19:33,840
setups like the common reference frame

467
00:19:33,840 --> 00:19:34,880
model

468
00:19:34,880 --> 00:19:36,640
our main contribution is the

469
00:19:36,640 --> 00:19:38,400
construction of a secure software

470
00:19:38,400 --> 00:19:40,320
leasing scheme for point functions which

471
00:19:40,320 --> 00:19:43,039
is provably secure without assumptions

472
00:19:43,039 --> 00:19:45,840
and against unbounded adversaries

473
00:19:45,840 --> 00:19:47,840
in the process we define this novel

474
00:19:47,840 --> 00:19:50,840
security notion of honest malicious copy

475
00:19:50,840 --> 00:19:53,280
protection now if i was to sketch our

476
00:19:53,280 --> 00:19:55,039
results it would look a bit like this

477
00:19:55,039 --> 00:19:56,640
when we start off with any total

478
00:19:56,640 --> 00:19:59,039
authentication scheme obtain honest

479
00:19:59,039 --> 00:20:00,720
malicious copy protection for point

480
00:20:00,720 --> 00:20:02,640
functions show that this is strong

481
00:20:02,640 --> 00:20:04,640
enough to achieve ssl overpoint

482
00:20:04,640 --> 00:20:06,799
functions and prior work by calla

483
00:20:06,799 --> 00:20:09,360
d'angelo mayans and paramba yields that

484
00:20:09,360 --> 00:20:11,440
ssl for point functions is strong enough

485
00:20:11,440 --> 00:20:14,159
to obtain ssl for compute and compare

486
00:20:14,159 --> 00:20:16,720
functions okay so let's get to the

487
00:20:16,720 --> 00:20:18,880
details of it how do we define honest

488
00:20:18,880 --> 00:20:20,960
malicious copy production well we start

489
00:20:20,960 --> 00:20:23,120
with a copy protection scheme protected

490
00:20:23,120 --> 00:20:25,120
and now and essentially what we want to

491
00:20:25,120 --> 00:20:27,280
do is show that it is impossible to take

492
00:20:27,280 --> 00:20:29,520
a program and create two programs that

493
00:20:29,520 --> 00:20:31,600
would allow evaluation

494
00:20:31,600 --> 00:20:33,919
so we studied this by a gain that is

495
00:20:33,919 --> 00:20:35,679
parameterized by a distribution of

496
00:20:35,679 --> 00:20:37,840
circuits as well as distributions on

497
00:20:37,840 --> 00:20:40,000
pairs of inputs to the circuit

498
00:20:40,000 --> 00:20:41,840
this game will be played by a referee

499
00:20:41,840 --> 00:20:44,400
against a pirate and two evaluators

500
00:20:44,400 --> 00:20:46,640
notably one of the evaluators will be

501
00:20:46,640 --> 00:20:49,039
honest

502
00:20:52,480 --> 00:20:54,080
the malicious evaluator on the other

503
00:20:54,080 --> 00:20:56,080
hand can have a completely arbitrary

504
00:20:56,080 --> 00:20:57,200
behavior

505
00:20:57,200 --> 00:20:59,039
the referee will sample a circuit

506
00:20:59,039 --> 00:21:00,480
protect it using the protection

507
00:21:00,480 --> 00:21:03,039
procedure and the resulting program

508
00:21:03,039 --> 00:21:05,200
stayed off to the pirate the pirate must

509
00:21:05,200 --> 00:21:07,760
split the state between both evaluators

510
00:21:07,760 --> 00:21:09,919
at which point the referee will sample

511
00:21:09,919 --> 00:21:11,840
two inputs hand those off to the

512
00:21:11,840 --> 00:21:15,200
evaluators and the

513
00:21:15,200 --> 00:21:16,200
compute the evaluators

514
00:21:16,960 --> 00:21:18,799
now we say that the scheme is epsilon

515
00:21:18,799 --> 00:21:21,600
honest malicious copy protecting if uh

516
00:21:21,600 --> 00:21:23,600
both malicious evaluators can correctly

517
00:21:23,600 --> 00:21:25,919
compute with at most epsilon advantage

518
00:21:25,919 --> 00:21:28,400
over some trivial guessing probability

519
00:21:28,400 --> 00:21:29,840
and i really want to highlight here that

520
00:21:29,840 --> 00:21:31,679
this is honest malicious because we

521
00:21:31,679 --> 00:21:33,600
require one of the evaluators to behave

522
00:21:33,600 --> 00:21:35,919
honestly uh some other work on coffee

523
00:21:35,919 --> 00:21:38,400
production allow both evaluators to be

524
00:21:38,400 --> 00:21:40,240
malicious

525
00:21:40,240 --> 00:21:42,960
okay so how do we achieve this we start

526
00:21:42,960 --> 00:21:45,200
okay sorry let me put up the definition

527
00:21:45,200 --> 00:21:46,799
for a point function a point function is

528
00:21:46,799 --> 00:21:48,640
the boolean function which is zero on

529
00:21:48,640 --> 00:21:50,799
all the inputs except one particular

530
00:21:50,799 --> 00:21:52,799
input that we will call the point

531
00:21:52,799 --> 00:21:55,280
and our tool is a total authentication

532
00:21:55,280 --> 00:21:57,200
scheme which is an authenticate and

533
00:21:57,200 --> 00:21:59,520
verify scheme for quantum states and the

534
00:21:59,520 --> 00:22:01,760
security guarantee here is that

535
00:22:01,760 --> 00:22:03,360
conditioned on acceptance the

536
00:22:03,360 --> 00:22:05,360
eavesdropper essentially did not

537
00:22:05,360 --> 00:22:07,520
interact with the authenticated city

538
00:22:07,520 --> 00:22:09,039
this is something a bit stronger than

539
00:22:09,039 --> 00:22:11,520
what can uh be achieved in the class in

540
00:22:11,520 --> 00:22:13,520
the classical setting because in the

541
00:22:13,520 --> 00:22:15,120
classical setting and eavesdropper could

542
00:22:15,120 --> 00:22:17,200
always keep a copy of the authenticated

543
00:22:17,200 --> 00:22:19,440
message here the e-structure cannot do

544
00:22:19,440 --> 00:22:20,799
this

545
00:22:20,799 --> 00:22:22,640
the idea is to find a correspondence

546
00:22:22,640 --> 00:22:24,640
between inputs to the point function and

547
00:22:24,640 --> 00:22:27,200
keys to the total authentication

548
00:22:27,200 --> 00:22:29,919
pushing this idea we obtain a protection

549
00:22:29,919 --> 00:22:31,520
procedure that takes the point function

550
00:22:31,520 --> 00:22:32,559
for p

551
00:22:32,559 --> 00:22:34,880
by simply authenticating some fixed

552
00:22:34,880 --> 00:22:37,440
state with p as the key

553
00:22:37,440 --> 00:22:39,919
to evaluate we take a candidate program

554
00:22:39,919 --> 00:22:42,320
state sigma and some input x and we

555
00:22:42,320 --> 00:22:45,360
simply verify sigma with x if the

556
00:22:45,360 --> 00:22:48,159
verification except we output one if it

557
00:22:48,159 --> 00:22:50,960
refuses we output zero

558
00:22:50,960 --> 00:22:52,960
when we analyze this we find that any

559
00:22:52,960 --> 00:22:54,960
epsilon total authentication scheme

560
00:22:54,960 --> 00:22:57,039
yields a three half epsilon square root

561
00:22:57,039 --> 00:22:59,039
of two epsilon honest malicious copy

562
00:22:59,039 --> 00:23:01,200
protection and the proof idea is that

563
00:23:01,200 --> 00:23:03,120
when the honest evaluator correctly

564
00:23:03,120 --> 00:23:05,280
evaluates on the point p this is

565
00:23:05,280 --> 00:23:07,039
essentially the verification procedure

566
00:23:07,039 --> 00:23:08,960
and accepting and so the malicious

567
00:23:08,960 --> 00:23:11,760
evaluator can't hold any information

568
00:23:11,760 --> 00:23:13,600
on the program state

569
00:23:13,600 --> 00:23:15,280
okay how do we connect to secure

570
00:23:15,280 --> 00:23:16,960
software leasing i'm gonna go a bit

571
00:23:16,960 --> 00:23:19,440
quickly here so secure software leasing

572
00:23:19,440 --> 00:23:21,120
is another security notion for coffee

573
00:23:21,120 --> 00:23:23,120
protection it is a bit different there

574
00:23:23,120 --> 00:23:26,000
will not be a second evaluator instead

575
00:23:26,000 --> 00:23:28,240
the referee will verify and either

576
00:23:28,240 --> 00:23:30,320
accept or reject the return of a program

577
00:23:30,320 --> 00:23:31,760
state

578
00:23:31,760 --> 00:23:33,679
if you were to sketch this out as a game

579
00:23:33,679 --> 00:23:36,080
it would look something like this and

580
00:23:36,080 --> 00:23:37,679
very similarly to this previous

581
00:23:37,679 --> 00:23:40,080
definition we say that the ssl scheme is

582
00:23:40,080 --> 00:23:42,320
excellent secure if the probability that

583
00:23:42,320 --> 00:23:44,880
the referee accepts the return program

584
00:23:44,880 --> 00:23:46,799
and that the pirate can afterwards

585
00:23:46,799 --> 00:23:49,039
correctly compute the circuit is at most

586
00:23:49,039 --> 00:23:51,919
epsilon over some trivial probability

587
00:23:51,919 --> 00:23:54,400
now the idea is that we can verify a

588
00:23:54,400 --> 00:23:56,320
return program by simply honestly

589
00:23:56,320 --> 00:23:58,640
evaluating it on some input and so the

590
00:23:58,640 --> 00:24:00,559
verification here is essentially the

591
00:24:00,559 --> 00:24:02,960
honest evaluator of the honest malicious

592
00:24:02,960 --> 00:24:04,320
copy protection

593
00:24:04,320 --> 00:24:06,480
we push this idea and we show a theorem

594
00:24:06,480 --> 00:24:08,480
that any honest malicious copy

595
00:24:08,480 --> 00:24:11,360
protection scheme implies ssl for

596
00:24:11,360 --> 00:24:13,440
certain circuits and distributions

597
00:24:13,440 --> 00:24:15,200
there's a connection between the two if

598
00:24:15,200 --> 00:24:18,240
the details are in the paper

599
00:24:18,240 --> 00:24:20,960
so in conclusion our results we start

600
00:24:20,960 --> 00:24:22,880
with any total authentication scheme we

601
00:24:22,880 --> 00:24:24,880
obtain honest malicious copy protection

602
00:24:24,880 --> 00:24:26,720
for point functions this is enough to

603
00:24:26,720 --> 00:24:29,120
yield ssl for point functions

604
00:24:29,120 --> 00:24:31,039
i just want to put up this game here

605
00:24:31,039 --> 00:24:32,480
which is the honest malicious copy

606
00:24:32,480 --> 00:24:36,290
protection game and with that thank you

607
00:24:36,290 --> 00:24:39,389
[Applause]

608
00:24:41,919 --> 00:24:43,200
thank you

609
00:24:43,200 --> 00:24:46,520
any questions

610
00:24:52,000 --> 00:24:52,960
okay

611
00:24:52,960 --> 00:24:58,200
so uh let's thank the speaker again

612
00:25:07,840 --> 00:25:10,400
so this is going to be the last

613
00:25:10,400 --> 00:25:12,770
talk of the session

614
00:25:12,770 --> 00:25:15,970
[Music]

615
00:25:24,540 --> 00:25:26,720
[Music]

616
00:25:26,720 --> 00:25:29,080
okay

617
00:25:29,080 --> 00:25:32,119
[Music]

618
00:25:39,919 --> 00:25:42,480
hello everyone i'm fatih

619
00:25:42,480 --> 00:25:44,159
i'm presenting joint work with

620
00:25:44,159 --> 00:25:48,640
pravanjana from on cloneable encryption

621
00:25:49,600 --> 00:25:51,120
um

622
00:25:51,120 --> 00:25:54,640
no cloning theorem is

623
00:25:54,640 --> 00:25:56,880
a principle enjoyed exclusively in the

624
00:25:56,880 --> 00:25:58,240
quantum setting

625
00:25:58,240 --> 00:26:01,600
and it yields lots of unclonable

626
00:26:01,600 --> 00:26:03,440
primitives

627
00:26:03,440 --> 00:26:06,159
among these and prominent one

628
00:26:06,159 --> 00:26:07,919
as mentioned in previous talk is copy

629
00:26:07,919 --> 00:26:08,960
protection

630
00:26:08,960 --> 00:26:11,760
which lets you release softwares

631
00:26:11,760 --> 00:26:15,120
that are secure against piracy attacks

632
00:26:15,120 --> 00:26:17,360
and

633
00:26:20,000 --> 00:26:22,640
and more recently

634
00:26:22,640 --> 00:26:25,039
unclonable encryption was introduced by

635
00:26:25,039 --> 00:26:27,600
and broadband and sebastian lord

636
00:26:27,600 --> 00:26:29,760
and it states that

637
00:26:29,760 --> 00:26:32,240
ciphertexts cannot be cloned

638
00:26:32,240 --> 00:26:34,559
uh so it encrypts

639
00:26:34,559 --> 00:26:36,840
classical messages using quantum

640
00:26:36,840 --> 00:26:38,799
functionalities

641
00:26:38,799 --> 00:26:41,120
and

642
00:26:41,360 --> 00:26:44,480
what does it mean to clone a cipher text

643
00:26:44,480 --> 00:26:47,600
it means to succeed in a security game

644
00:26:47,600 --> 00:26:49,200
defined as follows

645
00:26:49,200 --> 00:26:52,640
the adversary gets one cipher text and

646
00:26:52,640 --> 00:26:55,200
then it has to split between two

647
00:26:55,200 --> 00:26:57,679
separate registers held by

648
00:26:57,679 --> 00:26:59,679
bob and charlie

649
00:26:59,679 --> 00:27:01,960
now the goal of bob and charlie is to

650
00:27:01,960 --> 00:27:04,640
simultaneously recover the message

651
00:27:04,640 --> 00:27:07,840
after the key is revealed

652
00:27:09,919 --> 00:27:12,559
and the trivial strategy gives a success

653
00:27:12,559 --> 00:27:15,200
probability of half to the n where n is

654
00:27:15,200 --> 00:27:17,200
the message length so that's the

655
00:27:17,200 --> 00:27:18,640
baseline

656
00:27:18,640 --> 00:27:22,000
to compare success probabilities too

657
00:27:22,000 --> 00:27:23,919
so why is this notion interesting in the

658
00:27:23,919 --> 00:27:25,120
first place

659
00:27:25,120 --> 00:27:27,440
uh there are several scenarios one could

660
00:27:27,440 --> 00:27:30,240
imagine uh to apply this in the real

661
00:27:30,240 --> 00:27:32,799
world one hypothetical such scenario is

662
00:27:32,799 --> 00:27:35,679
the following suppose a client is

663
00:27:35,679 --> 00:27:37,520
storing private data

664
00:27:37,520 --> 00:27:40,240
on a cloud storage

665
00:27:40,240 --> 00:27:42,480
and at some point the client may want to

666
00:27:42,480 --> 00:27:44,240
retrieve the data

667
00:27:44,240 --> 00:27:46,640
and after the retrieval the client may

668
00:27:46,640 --> 00:27:50,559
desire to remove any traces of this data

669
00:27:50,559 --> 00:27:52,960
from the cloud and anywhere else on the

670
00:27:52,960 --> 00:27:54,960
internet

671
00:27:54,960 --> 00:27:57,679
and unclonable encryption actually

672
00:27:57,679 --> 00:28:00,240
assures the client that if the retrieval

673
00:28:00,240 --> 00:28:02,080
is successful there won't be any

674
00:28:02,080 --> 00:28:05,679
meaningful leftovers of the data

675
00:28:05,679 --> 00:28:08,399
and in this setting one could also

676
00:28:08,399 --> 00:28:10,320
imagine that for

677
00:28:10,320 --> 00:28:12,559
practical efficiency and diverse

678
00:28:12,559 --> 00:28:15,039
functionality purposes

679
00:28:15,039 --> 00:28:17,120
it would be desirable to have the

680
00:28:17,120 --> 00:28:18,640
encryption key

681
00:28:18,640 --> 00:28:21,039
reusable and or

682
00:28:21,039 --> 00:28:23,520
public

683
00:28:24,720 --> 00:28:27,600
so in their work broadband and lord gave

684
00:28:27,600 --> 00:28:30,320
two constructions first one conjugate

685
00:28:30,320 --> 00:28:31,360
encryption

686
00:28:31,360 --> 00:28:33,440
is based on the conjugate coding of

687
00:28:33,440 --> 00:28:34,640
weissner

688
00:28:34,640 --> 00:28:36,480
it achieves information theoretic

689
00:28:36,480 --> 00:28:38,000
security

690
00:28:38,000 --> 00:28:39,039
that is

691
00:28:39,039 --> 00:28:40,880
inherited from

692
00:28:40,880 --> 00:28:43,120
an underlying game of monogamy of

693
00:28:43,120 --> 00:28:44,720
entanglement

694
00:28:44,720 --> 00:28:46,720
and the second construction

695
00:28:46,720 --> 00:28:48,480
uh achieves security in the random

696
00:28:48,480 --> 00:28:49,919
oracle model

697
00:28:49,919 --> 00:28:52,480
unfortunately the first construction

698
00:28:52,480 --> 00:28:55,279
uh does not have the reusability

699
00:28:55,279 --> 00:28:57,600
property of the key

700
00:28:57,600 --> 00:28:59,919
in our first result

701
00:28:59,919 --> 00:29:01,840
we show semantically secure

702
00:29:01,840 --> 00:29:04,559
constructions of unclonable encryption

703
00:29:04,559 --> 00:29:06,399
from minimal assumptions

704
00:29:06,399 --> 00:29:08,480
in both the private key and the public

705
00:29:08,480 --> 00:29:11,120
key settings

706
00:29:11,360 --> 00:29:12,799
in other words

707
00:29:12,799 --> 00:29:14,399
we achieve

708
00:29:14,399 --> 00:29:16,720
security against multi-message attacks

709
00:29:16,720 --> 00:29:18,559
without having to resort to the random

710
00:29:18,559 --> 00:29:21,200
local model

711
00:29:23,360 --> 00:29:24,799
later

712
00:29:24,799 --> 00:29:27,200
in our second result we explore

713
00:29:27,200 --> 00:29:30,000
how optimal the security of conjugate

714
00:29:30,000 --> 00:29:31,760
encryption is and how to possibly

715
00:29:31,760 --> 00:29:32,880
improve it

716
00:29:32,880 --> 00:29:35,600
we show a simple cloning attack that

717
00:29:35,600 --> 00:29:38,880
shows uh that conjugate encryption has

718
00:29:38,880 --> 00:29:41,039
security bounded away from the ideal

719
00:29:41,039 --> 00:29:43,440
value

720
00:29:43,919 --> 00:29:46,320
and next we generalize conjugate

721
00:29:46,320 --> 00:29:47,520
encryption

722
00:29:47,520 --> 00:29:48,880
to

723
00:29:48,880 --> 00:29:50,159
let us

724
00:29:50,159 --> 00:29:51,360
use

725
00:29:51,360 --> 00:29:53,520
any monogamy game

726
00:29:53,520 --> 00:29:56,880
from a broader class of games

727
00:29:56,880 --> 00:29:58,320
it remains to

728
00:29:58,320 --> 00:30:01,360
find the monogamy game that has

729
00:30:01,360 --> 00:30:03,679
the value event

730
00:30:03,679 --> 00:30:06,159
and can be proved

731
00:30:06,159 --> 00:30:07,200
but

732
00:30:07,200 --> 00:30:09,440
we

733
00:30:09,440 --> 00:30:13,840
pay the path for that direction

734
00:30:14,000 --> 00:30:16,799
and in our final contribution we show a

735
00:30:16,799 --> 00:30:19,039
relation between unclonable encryption

736
00:30:19,039 --> 00:30:21,279
and copy protection

737
00:30:21,279 --> 00:30:23,600
recall that in unclonable security the

738
00:30:23,600 --> 00:30:26,399
adversary's task is to simultaneously

739
00:30:26,399 --> 00:30:28,240
recover the message after the key has

740
00:30:28,240 --> 00:30:30,000
been revealed

741
00:30:30,000 --> 00:30:31,840
a stronger

742
00:30:31,840 --> 00:30:33,440
notion is unclonable

743
00:30:33,440 --> 00:30:34,960
indistinguishability

744
00:30:34,960 --> 00:30:37,360
which states that the adversary should

745
00:30:37,360 --> 00:30:39,360
not be able to simultaneously

746
00:30:39,360 --> 00:30:42,559
distinguish encryptions of two different

747
00:30:42,559 --> 00:30:46,399
adversarially chosen messages

748
00:30:46,799 --> 00:30:48,880
we showed that

749
00:30:48,880 --> 00:30:50,880
this stronger notion implies copper

750
00:30:50,880 --> 00:30:52,799
protection of point functions in the

751
00:30:52,799 --> 00:30:55,200
plain model

752
00:30:55,200 --> 00:30:56,399
as mentioned

753
00:30:56,399 --> 00:30:58,399
uh copy protection of point functions

754
00:30:58,399 --> 00:31:01,519
has been an open and hot problem

755
00:31:01,519 --> 00:31:03,120
over a decade

756
00:31:03,120 --> 00:31:04,640
and

757
00:31:04,640 --> 00:31:08,000
recently there has been

758
00:31:08,000 --> 00:31:10,080
a construction which was securing their

759
00:31:10,080 --> 00:31:12,960
animal model

760
00:31:13,039 --> 00:31:14,399
and the question in the malicious

761
00:31:14,399 --> 00:31:15,440
malicious

762
00:31:15,440 --> 00:31:17,120
security setting

763
00:31:17,120 --> 00:31:19,279
still remains open

764
00:31:19,279 --> 00:31:21,200
therefore our work

765
00:31:21,200 --> 00:31:22,240
again

766
00:31:22,240 --> 00:31:24,720
reduces that problem

767
00:31:24,720 --> 00:31:25,519
uh

768
00:31:25,519 --> 00:31:28,960
to a new drug new direction which is to

769
00:31:28,960 --> 00:31:30,799
construct a stronger primitive in the

770
00:31:30,799 --> 00:31:33,840
plain model

771
00:31:33,840 --> 00:31:35,600
to summarize

772
00:31:35,600 --> 00:31:38,080
our contribution is threefold

773
00:31:38,080 --> 00:31:39,440
first is

774
00:31:39,440 --> 00:31:41,440
unclonable encryption constructions that

775
00:31:41,440 --> 00:31:43,679
are semantically secured from minimal

776
00:31:43,679 --> 00:31:45,200
assumptions

777
00:31:45,200 --> 00:31:46,799
second is to

778
00:31:46,799 --> 00:31:49,039
analyze and generalize the first

779
00:31:49,039 --> 00:31:51,919
construction of broadband in war

780
00:31:51,919 --> 00:31:53,279
and the third one

781
00:31:53,279 --> 00:31:55,360
is to show an implication

782
00:31:55,360 --> 00:31:57,600
from unclonable encryption to copy

783
00:31:57,600 --> 00:31:59,440
protection of point functions

784
00:31:59,440 --> 00:32:01,360
and with that i conclude my thoughts

785
00:32:01,360 --> 00:32:03,678
okay

786
00:32:08,799 --> 00:32:10,320
thank you

787
00:32:10,320 --> 00:32:11,360
and

788
00:32:11,360 --> 00:32:15,320
so are there any questions

789
00:32:20,880 --> 00:32:22,320
okay so

790
00:32:22,320 --> 00:32:24,880
if there are no questions then let's

791
00:32:24,880 --> 00:32:27,440
thank fatih again and all the speakers

792
00:32:27,440 --> 00:32:29,020
of this session

793
00:32:29,020 --> 00:32:32,180
[Applause]

794
00:32:32,559 --> 00:32:34,399
so

795
00:32:34,399 --> 00:32:36,799
just

