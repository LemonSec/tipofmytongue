1
00:00:00,240 --> 00:00:02,720
hi everyone i'm hendrik weilner and this

2
00:00:02,720 --> 00:00:04,400
talk is about policy compliance

3
00:00:04,400 --> 00:00:06,080
signatures which is joint work with

4
00:00:06,080 --> 00:00:08,559
christian varichar and christianmatt

5
00:00:08,559 --> 00:00:10,240
starting with some motivation we

6
00:00:10,240 --> 00:00:12,160
consider the standard blockchain setting

7
00:00:12,160 --> 00:00:14,320
where we have two parties alice and bob

8
00:00:14,320 --> 00:00:15,599
that are both in possession of a

9
00:00:15,599 --> 00:00:17,920
signature key pair if alice now wants to

10
00:00:17,920 --> 00:00:19,920
create a transaction for bob she uses

11
00:00:19,920 --> 00:00:21,840
her signing key to generate a signature

12
00:00:21,840 --> 00:00:24,080
over the transaction details m and the

13
00:00:24,080 --> 00:00:26,720
verification key of bob the generated

14
00:00:26,720 --> 00:00:28,320
transaction can then be checked for

15
00:00:28,320 --> 00:00:30,560
validity using the verification key of

16
00:00:30,560 --> 00:00:32,640
alice furthermore we require

17
00:00:32,640 --> 00:00:34,880
unforgeability in this setting which

18
00:00:34,880 --> 00:00:36,399
means that no one other than alice

19
00:00:36,399 --> 00:00:37,840
should be able to create a valid

20
00:00:37,840 --> 00:00:39,520
signature in her name

21
00:00:39,520 --> 00:00:41,040
in this talk we consider the more

22
00:00:41,040 --> 00:00:42,879
restricted setting where we require a

23
00:00:42,879 --> 00:00:44,800
valid transaction to also fulfill the

24
00:00:44,800 --> 00:00:47,280
global policy f evaluated over the

25
00:00:47,280 --> 00:00:48,640
attributes of the sender and the

26
00:00:48,640 --> 00:00:50,800
receiver a blockchain that allows for

27
00:00:50,800 --> 00:00:52,879
these types of attribute checks can be

28
00:00:52,879 --> 00:00:54,320
very useful within corporate

29
00:00:54,320 --> 00:00:55,920
environments to only allow for

30
00:00:55,920 --> 00:00:57,840
transactions between employees of

31
00:00:57,840 --> 00:00:59,520
different departments

32
00:00:59,520 --> 00:01:01,520
in this setting the key pairs of alice

33
00:01:01,520 --> 00:01:03,199
and bob are additionally associated with

34
00:01:03,199 --> 00:01:06,400
an attribute set xa and xb to generate a

35
00:01:06,400 --> 00:01:08,400
signature alice proceeds similarly to

36
00:01:08,400 --> 00:01:10,640
the previous case and uses her signing

37
00:01:10,640 --> 00:01:12,159
key together with the transaction

38
00:01:12,159 --> 00:01:15,040
details m and the public key of bob the

39
00:01:15,040 --> 00:01:17,119
generated signature is now deemed valid

40
00:01:17,119 --> 00:01:19,280
if the policy f applied on the attribute

41
00:01:19,280 --> 00:01:22,880
set xa of alice and xb of bob verifies

42
00:01:22,880 --> 00:01:24,400
in this setting we also require

43
00:01:24,400 --> 00:01:26,400
unforgeability which means as in the

44
00:01:26,400 --> 00:01:28,400
previous case that no one other than

45
00:01:28,400 --> 00:01:30,159
alice should be able to create a valid

46
00:01:30,159 --> 00:01:32,720
signature in her name and additionally

47
00:01:32,720 --> 00:01:34,479
that alice and bob should not be able to

48
00:01:34,479 --> 00:01:36,320
create a valid signature if they do not

49
00:01:36,320 --> 00:01:39,040
fulfill the global policy furthermore we

50
00:01:39,040 --> 00:01:41,040
require attribute hiding which means

51
00:01:41,040 --> 00:01:42,720
that nothing about the attributes of the

52
00:01:42,720 --> 00:01:44,159
different parties is leaked by the

53
00:01:44,159 --> 00:01:46,720
public keys and the generated signatures

54
00:01:46,720 --> 00:01:48,399
only reveal that the attributes of the

55
00:01:48,399 --> 00:01:50,960
participating parties fulfill the policy

56
00:01:50,960 --> 00:01:52,640
and nothing beyond that

57
00:01:52,640 --> 00:01:54,479
next we are going to see which existing

58
00:01:54,479 --> 00:01:56,479
cryptographic primitives we could use to

59
00:01:56,479 --> 00:01:58,560
achieve this goal the first primitive

60
00:01:58,560 --> 00:02:00,159
that could be useful in this setting are

61
00:02:00,159 --> 00:02:02,320
digital signatures in a digital

62
00:02:02,320 --> 00:02:04,159
signature scheme there exists a party

63
00:02:04,159 --> 00:02:06,240
carrel that executes the setup procedure

64
00:02:06,240 --> 00:02:08,800
that outputs a verification key vk and a

65
00:02:08,800 --> 00:02:10,318
secret key sk

66
00:02:10,318 --> 00:02:12,319
carol then sends the verification key to

67
00:02:12,319 --> 00:02:14,879
bob and the secret key to alice alice

68
00:02:14,879 --> 00:02:16,879
can use the secret key to sign a message

69
00:02:16,879 --> 00:02:18,560
m and generate the corresponding

70
00:02:18,560 --> 00:02:21,200
signature sigma the verification key can

71
00:02:21,200 --> 00:02:22,879
then be used to check if the signature

72
00:02:22,879 --> 00:02:24,480
sigma is valid with respect to the

73
00:02:24,480 --> 00:02:26,080
message m

74
00:02:26,080 --> 00:02:28,080
unfortunately this primitive does not

75
00:02:28,080 --> 00:02:30,080
incorporate any attributes of the sender

76
00:02:30,080 --> 00:02:31,840
or the receiver and is therefore not

77
00:02:31,840 --> 00:02:33,599
useful in our setting

78
00:02:33,599 --> 00:02:35,519
an extension of digital signatures that

79
00:02:35,519 --> 00:02:37,360
incorporates attributes is the notion of

80
00:02:37,360 --> 00:02:39,360
attribute based signatures in an

81
00:02:39,360 --> 00:02:41,200
attribute based signature scheme carol

82
00:02:41,200 --> 00:02:43,200
executes the setup procedure to generate

83
00:02:43,200 --> 00:02:44,800
a master public key and the master

84
00:02:44,800 --> 00:02:47,280
secret key the master secret key is then

85
00:02:47,280 --> 00:02:49,120
used by carol together with an attribute

86
00:02:49,120 --> 00:02:51,840
set xa to generate the signing key ska

87
00:02:51,840 --> 00:02:54,480
of alice alice then uses her signing key

88
00:02:54,480 --> 00:02:56,959
ska to generate a signature sigma for a

89
00:02:56,959 --> 00:02:59,519
message m and a policy f

90
00:02:59,519 --> 00:03:01,280
this signature can then be verified

91
00:03:01,280 --> 00:03:02,879
using the master public key and the

92
00:03:02,879 --> 00:03:05,519
policy f the signature in this case is

93
00:03:05,519 --> 00:03:07,760
only valid if the attributes xa of ls

94
00:03:07,760 --> 00:03:10,080
fulfill the policy f

95
00:03:10,080 --> 00:03:11,920
the notion of attribute based signatures

96
00:03:11,920 --> 00:03:13,599
incorporates attributes into the

97
00:03:13,599 --> 00:03:15,920
signature generation but unfortunately

98
00:03:15,920 --> 00:03:17,519
only the attributes of the sender are

99
00:03:17,519 --> 00:03:19,519
incorporated which is still insufficient

100
00:03:19,519 --> 00:03:21,120
for our setting

101
00:03:21,120 --> 00:03:22,879
another type of signatures that handles

102
00:03:22,879 --> 00:03:24,720
attributes is the notion of policy based

103
00:03:24,720 --> 00:03:27,200
signatures policy based signatures work

104
00:03:27,200 --> 00:03:29,120
similarly to attribute based signatures

105
00:03:29,120 --> 00:03:30,640
with the difference that signing keys

106
00:03:30,640 --> 00:03:33,120
are generated with respect to a policy f

107
00:03:33,120 --> 00:03:35,040
instead of an attribute set

108
00:03:35,040 --> 00:03:36,400
furthermore during the signature

109
00:03:36,400 --> 00:03:38,080
generation alice needs to provide a

110
00:03:38,080 --> 00:03:40,239
witness w for a relation that involves

111
00:03:40,239 --> 00:03:42,480
the policy f associated with the signing

112
00:03:42,480 --> 00:03:45,120
key and the message that is being signed

113
00:03:45,120 --> 00:03:47,200
a signature now is only deemed valid if

114
00:03:47,200 --> 00:03:49,120
the witness w that has been used in the

115
00:03:49,120 --> 00:03:51,120
signature generation is a valid witness

116
00:03:51,120 --> 00:03:53,200
for the relation involving the policy f

117
00:03:53,200 --> 00:03:55,840
of the signing key and the message m

118
00:03:55,840 --> 00:03:57,760
one way to allow for the incorporation

119
00:03:57,760 --> 00:03:59,680
of bob's attributes in this notion would

120
00:03:59,680 --> 00:04:01,599
be by including some public information

121
00:04:01,599 --> 00:04:03,439
of bob in the message m that is being

122
00:04:03,439 --> 00:04:04,480
signed

123
00:04:04,480 --> 00:04:05,840
the problem here is that for the

124
00:04:05,840 --> 00:04:07,760
signature generation alice needs to know

125
00:04:07,760 --> 00:04:09,439
bob's attributes to prove that both of

126
00:04:09,439 --> 00:04:10,959
their attributes together fulfill the

127
00:04:10,959 --> 00:04:13,360
policy therefore we cannot guarantee

128
00:04:13,360 --> 00:04:15,200
privacy for bob in this setting which

129
00:04:15,200 --> 00:04:16,959
makes this notion unsuitable for our

130
00:04:16,959 --> 00:04:19,279
motivational example

131
00:04:19,279 --> 00:04:20,798
since none of the previous primitives

132
00:04:20,798 --> 00:04:22,800
fit our motivation example we now

133
00:04:22,800 --> 00:04:24,400
introduce the new notion of policy

134
00:04:24,400 --> 00:04:26,240
compliance signatures in a

135
00:04:26,240 --> 00:04:28,320
policy-compliant signature scheme carol

136
00:04:28,320 --> 00:04:30,320
executes the setup procedure which takes

137
00:04:30,320 --> 00:04:32,720
as an input of policy f and outputs a

138
00:04:32,720 --> 00:04:34,639
master public key and the master secret

139
00:04:34,639 --> 00:04:37,120
key she then uses the master secret key

140
00:04:37,120 --> 00:04:38,639
together with an attribute set to

141
00:04:38,639 --> 00:04:41,360
generate a public key secret key pair in

142
00:04:41,360 --> 00:04:43,360
more detail she uses the attribute set

143
00:04:43,360 --> 00:04:45,440
xa to generate the keys for alice and

144
00:04:45,440 --> 00:04:47,280
the attribute set xp to generate the

145
00:04:47,280 --> 00:04:49,680
keys for bob to generate a signature

146
00:04:49,680 --> 00:04:51,600
alice uses her secret key together with

147
00:04:51,600 --> 00:04:53,759
the public key of bob and the message m

148
00:04:53,759 --> 00:04:56,080
in the signing procedure the resulting

149
00:04:56,080 --> 00:04:57,680
message signature pair can then be

150
00:04:57,680 --> 00:04:59,680
verified using the master public key and

151
00:04:59,680 --> 00:05:01,840
the public keys of alice and bob the

152
00:05:01,840 --> 00:05:03,759
signature only verifies if the global

153
00:05:03,759 --> 00:05:06,080
policy f is fulfilled when evaluated

154
00:05:06,080 --> 00:05:08,639
using the attributes xa of alice and xp

155
00:05:08,639 --> 00:05:10,960
of bob we can directly see that the

156
00:05:10,960 --> 00:05:12,800
notion of policy compliance signatures

157
00:05:12,800 --> 00:05:14,240
provides a good solution for our

158
00:05:14,240 --> 00:05:16,400
motivational example

159
00:05:16,400 --> 00:05:18,320
to achieve unforgeability and attribute

160
00:05:18,320 --> 00:05:20,479
hiding in our motivational example our

161
00:05:20,479 --> 00:05:22,400
policy compliance signature scheme also

162
00:05:22,400 --> 00:05:24,720
needs to achieve these notions before we

163
00:05:24,720 --> 00:05:26,240
can talk about how to cheat these

164
00:05:26,240 --> 00:05:28,240
notions we first need to formally define

165
00:05:28,240 --> 00:05:30,080
them we begin with the notion of

166
00:05:30,080 --> 00:05:31,919
unforgiability

167
00:05:31,919 --> 00:05:33,840
in the case of unforgiability we have

168
00:05:33,840 --> 00:05:35,360
three different types of forgeries that

169
00:05:35,360 --> 00:05:37,440
we need to prevent the first type of

170
00:05:37,440 --> 00:05:39,440
forgery is what we call a key generation

171
00:05:39,440 --> 00:05:42,000
forgery in a key generation forgery a

172
00:05:42,000 --> 00:05:43,840
malicious alice is able to generate a

173
00:05:43,840 --> 00:05:45,919
valid signature for a public key that

174
00:05:45,919 --> 00:05:48,240
has not been generated by carol since

175
00:05:48,240 --> 00:05:50,080
carol did not assign any attributes to

176
00:05:50,080 --> 00:05:52,160
this maliciously generated public key it

177
00:05:52,160 --> 00:05:53,840
cannot result in a valid policy

178
00:05:53,840 --> 00:05:55,440
evaluation

179
00:05:55,440 --> 00:05:57,520
in a signature forgery an adversary is

180
00:05:57,520 --> 00:05:59,360
able to create a signature corresponding

181
00:05:59,360 --> 00:06:01,199
to alice's public key without knowing

182
00:06:01,199 --> 00:06:03,360
her secret key this type of attack is

183
00:06:03,360 --> 00:06:04,800
similar to the standard notion of

184
00:06:04,800 --> 00:06:06,880
unforgeability for a digital signature

185
00:06:06,880 --> 00:06:07,840
scheme

186
00:06:07,840 --> 00:06:09,680
in the third and last type of forgery

187
00:06:09,680 --> 00:06:12,000
and attribute forgery a malicious alice

188
00:06:12,000 --> 00:06:13,520
and the malicious bob are able to

189
00:06:13,520 --> 00:06:15,360
jointly create a valid signature even

190
00:06:15,360 --> 00:06:17,199
though the attributes do not fulfill the

191
00:06:17,199 --> 00:06:18,720
policy

192
00:06:18,720 --> 00:06:20,319
after informally talking about the

193
00:06:20,319 --> 00:06:21,840
different types of attacks we need to

194
00:06:21,840 --> 00:06:23,520
prevent we are now going to formally

195
00:06:23,520 --> 00:06:25,919
define unforgeability using a security

196
00:06:25,919 --> 00:06:28,240
game in this security game an adversary

197
00:06:28,240 --> 00:06:30,000
has access to different oracles that are

198
00:06:30,000 --> 00:06:32,080
run by a challenger and can be queried

199
00:06:32,080 --> 00:06:34,400
multiple times the first oracle that the

200
00:06:34,400 --> 00:06:36,000
adversary can access is the key

201
00:06:36,000 --> 00:06:38,400
generation oracle it queries it using an

202
00:06:38,400 --> 00:06:40,639
attribute set x and receives as a reply

203
00:06:40,639 --> 00:06:43,039
the corresponding public key pk

204
00:06:43,039 --> 00:06:44,800
additionally the adversary can also

205
00:06:44,800 --> 00:06:46,720
query a corruption oracle using one of

206
00:06:46,720 --> 00:06:48,000
the public keys that have been

207
00:06:48,000 --> 00:06:50,000
previously output by the key generation

208
00:06:50,000 --> 00:06:51,840
oracle to obtain the corresponding

209
00:06:51,840 --> 00:06:53,120
secret key

210
00:06:53,120 --> 00:06:54,880
the last oracle that the adversary has

211
00:06:54,880 --> 00:06:57,039
access to is the signing oracle

212
00:06:57,039 --> 00:06:59,680
inputting a sender public key pks a

213
00:06:59,680 --> 00:07:02,880
receiver public key pkr and a message m

214
00:07:02,880 --> 00:07:04,880
the adversary obtains a signature sigma

215
00:07:04,880 --> 00:07:06,800
for the message m

216
00:07:06,800 --> 00:07:08,639
after the adversary has interacted with

217
00:07:08,639 --> 00:07:10,479
the different oracles its goal is to

218
00:07:10,479 --> 00:07:13,520
output two public keys pk and pkstar a

219
00:07:13,520 --> 00:07:15,680
message m star and a signature sigma

220
00:07:15,680 --> 00:07:16,400
star

221
00:07:16,400 --> 00:07:18,400
such that the signature sigma star is a

222
00:07:18,400 --> 00:07:20,000
valid signature with respect to the

223
00:07:20,000 --> 00:07:22,639
public keys p k and pk star and the

224
00:07:22,639 --> 00:07:24,400
message m star

225
00:07:24,400 --> 00:07:26,000
for the adversary to provide a valid

226
00:07:26,000 --> 00:07:27,919
signature forgery it needs to provide

227
00:07:27,919 --> 00:07:29,520
one of the different types of attacks

228
00:07:29,520 --> 00:07:31,680
that we have previously described

229
00:07:31,680 --> 00:07:33,440
this is the case if it either holds that

230
00:07:33,440 --> 00:07:35,440
the sender public epk has not been

231
00:07:35,440 --> 00:07:37,599
created to the corruption oracle or if

232
00:07:37,599 --> 00:07:40,000
both of the public keys pk and pk star

233
00:07:40,000 --> 00:07:41,759
have been output by the key generation

234
00:07:41,759 --> 00:07:43,919
oracle and their corresponding attribute

235
00:07:43,919 --> 00:07:46,000
sets x and x star do not fulfill the

236
00:07:46,000 --> 00:07:47,280
policy f

237
00:07:47,280 --> 00:07:49,039
we call a policy compliant signature

238
00:07:49,039 --> 00:07:51,039
scheme unfortunately if it is impossible

239
00:07:51,039 --> 00:07:53,440
for any efficient adversary to produce a

240
00:07:53,440 --> 00:07:55,360
valid signature forgery

241
00:07:55,360 --> 00:07:57,360
after talking about unforgeability we

242
00:07:57,360 --> 00:07:59,520
now focus on attribute hiding where we

243
00:07:59,520 --> 00:08:00,440
distinguish between an

244
00:08:00,440 --> 00:08:02,080
indistinguishability based and a

245
00:08:02,080 --> 00:08:04,319
simulation-based notion we start by

246
00:08:04,319 --> 00:08:05,240
considering the

247
00:08:05,240 --> 00:08:07,360
indistinguishability-based notion

248
00:08:07,360 --> 00:08:09,520
as in the case of unforgibility we

249
00:08:09,520 --> 00:08:11,199
define indistinguishability-based

250
00:08:11,199 --> 00:08:13,680
attribute titling using a security game

251
00:08:13,680 --> 00:08:15,599
in this game the adversary has access to

252
00:08:15,599 --> 00:08:17,840
the same oracles as before but with a

253
00:08:17,840 --> 00:08:20,080
different input output behavior

254
00:08:20,080 --> 00:08:21,840
also in this game the adversary can

255
00:08:21,840 --> 00:08:24,639
query all of the oracles multiple times

256
00:08:24,639 --> 00:08:26,400
the key generation oracle in this game

257
00:08:26,400 --> 00:08:28,319
can be queried using two attribute sets

258
00:08:28,319 --> 00:08:31,120
x0 and x1 the adversary then receives as

259
00:08:31,120 --> 00:08:33,519
a reply to this query a public key pk

260
00:08:33,519 --> 00:08:35,279
that has been generated with respect to

261
00:08:35,279 --> 00:08:38,000
the attribute set xb where b is a bit

262
00:08:38,000 --> 00:08:39,519
that is sampled in the beginning of the

263
00:08:39,519 --> 00:08:41,760
game the goal of the adversary in this

264
00:08:41,760 --> 00:08:43,440
game after it has finished querying the

265
00:08:43,440 --> 00:08:45,440
different oracles is to correctly

266
00:08:45,440 --> 00:08:47,440
determine the bit b by outputting a bit

267
00:08:47,440 --> 00:08:49,920
b prime a policy compliant signature

268
00:08:49,920 --> 00:08:51,600
scheme achieves indistinguishability

269
00:08:51,600 --> 00:08:53,279
based attribute hiding if the

270
00:08:53,279 --> 00:08:55,600
probability that the output bit b prime

271
00:08:55,600 --> 00:08:58,080
is equal to b is close to one half for

272
00:08:58,080 --> 00:09:00,000
all efficient adversaries

273
00:09:00,000 --> 00:09:01,920
besides the key generation oracle the

274
00:09:01,920 --> 00:09:03,360
adversary also has access to a

275
00:09:03,360 --> 00:09:05,519
corruption oracle which it can query

276
00:09:05,519 --> 00:09:07,600
using a public key pk to obtain the

277
00:09:07,600 --> 00:09:09,920
corresponding secret key sk

278
00:09:09,920 --> 00:09:11,680
to not make it trivial for the adversary

279
00:09:11,680 --> 00:09:13,680
to determine the bit b and therefore win

280
00:09:13,680 --> 00:09:15,920
the security game it can only query the

281
00:09:15,920 --> 00:09:17,920
corruption oracle using public keys that

282
00:09:17,920 --> 00:09:19,920
have been the reply to a key generation

283
00:09:19,920 --> 00:09:22,720
query where the attribute sets x0 and x1

284
00:09:22,720 --> 00:09:24,800
are equal if we do not enforce this

285
00:09:24,800 --> 00:09:26,640
restriction that vertery might be able

286
00:09:26,640 --> 00:09:28,880
to directly learn the bit b

287
00:09:28,880 --> 00:09:30,720
the signing oracle in this game behaves

288
00:09:30,720 --> 00:09:32,880
exactly as in the unforgetability game

289
00:09:32,880 --> 00:09:34,320
but we also need to enforce an

290
00:09:34,320 --> 00:09:35,920
additional restriction on the queries of

291
00:09:35,920 --> 00:09:38,399
the adversary here namely we require

292
00:09:38,399 --> 00:09:40,240
that the policy evaluated on the left

293
00:09:40,240 --> 00:09:42,880
charge attributes of the sender key pkx

294
00:09:42,880 --> 00:09:45,120
and the receiver key pky used in the

295
00:09:45,120 --> 00:09:47,360
signing query are equal to the policy

296
00:09:47,360 --> 00:09:48,880
evaluated on the right challenge

297
00:09:48,880 --> 00:09:50,320
attributes of the sender and the

298
00:09:50,320 --> 00:09:51,680
receiver key

299
00:09:51,680 --> 00:09:53,600
otherwise the adversary might again be

300
00:09:53,600 --> 00:09:56,160
able to directly learn the bit b

301
00:09:56,160 --> 00:09:58,000
after defining unforgeability and

302
00:09:58,000 --> 00:09:59,680
indistinguishability based attribute

303
00:09:59,680 --> 00:10:01,279
hiding we can now consider some

304
00:10:01,279 --> 00:10:02,880
construction approaches for policy

305
00:10:02,880 --> 00:10:04,880
compliance signatures

306
00:10:04,880 --> 00:10:06,640
a first approach to realize policy

307
00:10:06,640 --> 00:10:08,480
compliance signatures is by relying on

308
00:10:08,480 --> 00:10:10,720
carol in more detail if alice wants to

309
00:10:10,720 --> 00:10:12,720
generate a signature for bob she submits

310
00:10:12,720 --> 00:10:14,560
her message to carol together with bob's

311
00:10:14,560 --> 00:10:16,880
identifier and receives as a reply the

312
00:10:16,880 --> 00:10:19,680
signature sigma afterwards bob can send

313
00:10:19,680 --> 00:10:21,360
the signature together with a message

314
00:10:21,360 --> 00:10:23,519
and alice identifier to carol who

315
00:10:23,519 --> 00:10:25,760
outputs either 0 or 1.

316
00:10:25,760 --> 00:10:27,760
unfortunately this solution requires the

317
00:10:27,760 --> 00:10:29,440
involvement of carol for every signature

318
00:10:29,440 --> 00:10:31,760
generation and verification but we would

319
00:10:31,760 --> 00:10:33,360
like to have a solution where carol is

320
00:10:33,360 --> 00:10:34,880
only needed for the generation of the

321
00:10:34,880 --> 00:10:36,959
public parameters and the keys of the

322
00:10:36,959 --> 00:10:39,040
different parties such that alice can

323
00:10:39,040 --> 00:10:40,959
generate the signatures on her own and

324
00:10:40,959 --> 00:10:43,440
everyone can verify them on their own

325
00:10:43,440 --> 00:10:45,440
the second approach to realizing policy

326
00:10:45,440 --> 00:10:47,279
compliance signatures is to let carroll

327
00:10:47,279 --> 00:10:49,279
issue signature keys together with a

328
00:10:49,279 --> 00:10:50,880
certificate that corresponds to the

329
00:10:50,880 --> 00:10:53,279
attributes of the corresponding party

330
00:10:53,279 --> 00:10:55,360
for the generation of a signature alice

331
00:10:55,360 --> 00:10:56,959
would then use her signing key to

332
00:10:56,959 --> 00:10:59,279
generate a signature for her message and

333
00:10:59,279 --> 00:11:00,880
additionally proof using both of the

334
00:11:00,880 --> 00:11:03,200
verification keys and the certificates

335
00:11:03,200 --> 00:11:04,720
that her attributes together with the

336
00:11:04,720 --> 00:11:06,399
attributes of bob fulfill the global

337
00:11:06,399 --> 00:11:07,680
policy

338
00:11:07,680 --> 00:11:09,200
when bob obtains the proof and the

339
00:11:09,200 --> 00:11:11,120
signature he can verify the signature

340
00:11:11,120 --> 00:11:13,360
generated for the message as well as the

341
00:11:13,360 --> 00:11:14,880
proof that the attributes of alice and

342
00:11:14,880 --> 00:11:17,440
bob together fulfill the policy

343
00:11:17,440 --> 00:11:19,200
this solution looks like a good solution

344
00:11:19,200 --> 00:11:21,440
at first sight but it has the drawback

345
00:11:21,440 --> 00:11:23,120
that it does not give us any guarantees

346
00:11:23,120 --> 00:11:25,279
in terms of privacy this is due to the

347
00:11:25,279 --> 00:11:26,959
fact that for alice to prove that her

348
00:11:26,959 --> 00:11:28,320
attributes together with bob's

349
00:11:28,320 --> 00:11:30,560
attributes fulfill the global policy she

350
00:11:30,560 --> 00:11:32,320
needs to know bob's attributes which

351
00:11:32,320 --> 00:11:34,800
directly compromises privacy

352
00:11:34,800 --> 00:11:36,640
after considering these first approaches

353
00:11:36,640 --> 00:11:38,480
for the realization of policy compliance

354
00:11:38,480 --> 00:11:40,240
signatures we now introduce the

355
00:11:40,240 --> 00:11:41,680
necessary tools for our final

356
00:11:41,680 --> 00:11:43,200
construction

357
00:11:43,200 --> 00:11:44,640
the first tool that is needed for our

358
00:11:44,640 --> 00:11:46,399
construction is a digital signature

359
00:11:46,399 --> 00:11:48,959
scheme which we have already introduced

360
00:11:48,959 --> 00:11:50,639
additionally our construction also

361
00:11:50,639 --> 00:11:51,839
requires a non-interactive

362
00:11:51,839 --> 00:11:53,760
zero-knowledge proof system which is

363
00:11:53,760 --> 00:11:55,360
similar to the proof system that we have

364
00:11:55,360 --> 00:11:57,040
mentioned in the previous construction

365
00:11:57,040 --> 00:11:58,000
approach

366
00:11:58,000 --> 00:11:59,760
the last primitive that we need for our

367
00:11:59,760 --> 00:12:01,440
construction is a predicate encryption

368
00:12:01,440 --> 00:12:03,360
scheme which allows for the oblivious

369
00:12:03,360 --> 00:12:05,600
evaluation of policies without revealing

370
00:12:05,600 --> 00:12:07,519
the underlying attributes

371
00:12:07,519 --> 00:12:09,120
we now describe the different primitives

372
00:12:09,120 --> 00:12:10,639
in more detail where we begin with

373
00:12:10,639 --> 00:12:13,120
non-interactive zero-knowledge proofs

374
00:12:13,120 --> 00:12:14,639
in the first step of a non-interactive

375
00:12:14,639 --> 00:12:16,399
serial knowledge proof a setup procedure

376
00:12:16,399 --> 00:12:18,639
is executed by carol that outputs a

377
00:12:18,639 --> 00:12:20,399
common reference string which is then

378
00:12:20,399 --> 00:12:23,200
sent to lsn to bob if alice now wants to

379
00:12:23,200 --> 00:12:25,360
prove the validity of a statement x for

380
00:12:25,360 --> 00:12:27,680
which she knows a witness w then she can

381
00:12:27,680 --> 00:12:30,079
generate a proof pi using the crs the

382
00:12:30,079 --> 00:12:32,560
statement x and the witness w

383
00:12:32,560 --> 00:12:34,320
this proof is then sent to bob who can

384
00:12:34,320 --> 00:12:36,240
verify it using the statement x and the

385
00:12:36,240 --> 00:12:38,800
common reference string we require zero

386
00:12:38,800 --> 00:12:40,320
knowledge proof system to achieve

387
00:12:40,320 --> 00:12:42,480
soundness and zero knowledge soundness

388
00:12:42,480 --> 00:12:44,079
ensures that it is not possible for

389
00:12:44,079 --> 00:12:45,839
malicious alice to generate a valid

390
00:12:45,839 --> 00:12:47,839
proof for statements x for which no

391
00:12:47,839 --> 00:12:50,399
witness w exists and zero knowledge in

392
00:12:50,399 --> 00:12:52,079
turn guarantees that when bob obtains

393
00:12:52,079 --> 00:12:54,240
the proof pie he does not learn anything

394
00:12:54,240 --> 00:12:57,040
about the witness w for the statement x

395
00:12:57,040 --> 00:12:58,720
after introducing non-interactive zero

396
00:12:58,720 --> 00:13:00,320
knowledge proofs we can now focus on

397
00:13:00,320 --> 00:13:02,000
predicate encryption

398
00:13:02,000 --> 00:13:03,600
in a predicate encryption scheme the

399
00:13:03,600 --> 00:13:06,000
setup procedure executed by carol

400
00:13:06,000 --> 00:13:07,519
outputs a master public key and the

401
00:13:07,519 --> 00:13:10,000
master secret key the master public key

402
00:13:10,000 --> 00:13:11,680
can then be used by others to generate a

403
00:13:11,680 --> 00:13:14,240
ciphertext ct encrypting an attribute

404
00:13:14,240 --> 00:13:15,360
set x

405
00:13:15,360 --> 00:13:17,440
the master secret key in turn is used by

406
00:13:17,440 --> 00:13:20,000
carol to generate a functional key skf

407
00:13:20,000 --> 00:13:22,560
that is associated with a policy f

408
00:13:22,560 --> 00:13:24,320
when bob uses this functional key to

409
00:13:24,320 --> 00:13:26,959
decrypt the ciphertex ct he obtains as

410
00:13:26,959 --> 00:13:29,040
an output the policy associated with the

411
00:13:29,040 --> 00:13:31,279
functional key applied on the attribute

412
00:13:31,279 --> 00:13:33,680
set encrypted in the cipher text which

413
00:13:33,680 --> 00:13:35,920
in this case is f x

414
00:13:35,920 --> 00:13:37,839
we require a predicate encryption scheme

415
00:13:37,839 --> 00:13:39,680
to be attribute hiding which means that

416
00:13:39,680 --> 00:13:42,079
bob when decrypting a cipher text does

417
00:13:42,079 --> 00:13:43,440
not learn anything more about the

418
00:13:43,440 --> 00:13:45,120
encrypted attribute set than what is

419
00:13:45,120 --> 00:13:48,079
leaked by the evaluation of the policy f

420
00:13:48,079 --> 00:13:50,000
in our construction of policy compliance

421
00:13:50,000 --> 00:13:52,000
signatures we only require the predicate

422
00:13:52,000 --> 00:13:54,240
encryption scheme to be secret key which

423
00:13:54,240 --> 00:13:55,839
means that the setup procedure only

424
00:13:55,839 --> 00:13:58,079
outputs a master secret key that is used

425
00:13:58,079 --> 00:14:00,720
for encryption and key generation

426
00:14:00,720 --> 00:14:02,480
after introducing the necessary tools

427
00:14:02,480 --> 00:14:04,560
for our construction we are now ready to

428
00:14:04,560 --> 00:14:06,320
give a high level overview of how our

429
00:14:06,320 --> 00:14:08,240
construction works

430
00:14:08,240 --> 00:14:10,000
the idea of our construction is to use a

431
00:14:10,000 --> 00:14:11,680
predicate encryption scheme to encrypt

432
00:14:11,680 --> 00:14:13,360
the attributes of the different parties

433
00:14:13,360 --> 00:14:15,040
in the public keys and use the

434
00:14:15,040 --> 00:14:16,959
corresponding functional key as part of

435
00:14:16,959 --> 00:14:18,720
the secret keys of the different parties

436
00:14:18,720 --> 00:14:20,800
for the policy evaluation

437
00:14:20,800 --> 00:14:22,480
to generate a signature the sender

438
00:14:22,480 --> 00:14:24,240
decrypts the ciphertext contained in the

439
00:14:24,240 --> 00:14:26,480
public key of the receiver and proves in

440
00:14:26,480 --> 00:14:28,000
zero knowledge that the decryption

441
00:14:28,000 --> 00:14:30,079
output together with its functional key

442
00:14:30,079 --> 00:14:32,320
shows that the policy is fulfilled it

443
00:14:32,320 --> 00:14:33,839
can then be verified that the global

444
00:14:33,839 --> 00:14:35,519
policy is fulfilled by checking the

445
00:14:35,519 --> 00:14:38,160
validity of the generated proof

446
00:14:38,160 --> 00:14:40,240
in more detail the master public key of

447
00:14:40,240 --> 00:14:41,600
our scheme consists of a common

448
00:14:41,600 --> 00:14:43,120
reference string for non-interactive

449
00:14:43,120 --> 00:14:44,800
zero knowledge proof and two

450
00:14:44,800 --> 00:14:46,480
verification keys for a digital

451
00:14:46,480 --> 00:14:49,519
signature scheme vkp and vks

452
00:14:49,519 --> 00:14:51,199
the corresponding master secret key

453
00:14:51,199 --> 00:14:53,040
consists of the master secret key for

454
00:14:53,040 --> 00:14:54,959
predicate encryption scheme and the

455
00:14:54,959 --> 00:14:57,760
signing keys skp and sks that correspond

456
00:14:57,760 --> 00:15:01,279
to the verification keys vkp and vks

457
00:15:01,279 --> 00:15:02,639
to generate a public key for a

458
00:15:02,639 --> 00:15:04,639
participating party a new digital

459
00:15:04,639 --> 00:15:06,639
signature key pair is sampled where the

460
00:15:06,639 --> 00:15:09,120
verification key vk is included in the

461
00:15:09,120 --> 00:15:11,600
public key furthermore the attributes of

462
00:15:11,600 --> 00:15:13,120
the party are encrypted using the

463
00:15:13,120 --> 00:15:15,040
predicate encryption scheme and the

464
00:15:15,040 --> 00:15:16,880
resulting cipher text is included in the

465
00:15:16,880 --> 00:15:20,079
public key finally a signature sigma p

466
00:15:20,079 --> 00:15:22,800
is generated using the sign-in key skp

467
00:15:22,800 --> 00:15:24,959
for the verification key vk and the

468
00:15:24,959 --> 00:15:26,480
ciphertext ct

469
00:15:26,480 --> 00:15:29,199
and is also included in the public key

470
00:15:29,199 --> 00:15:30,720
the corresponding secret key for the

471
00:15:30,720 --> 00:15:32,639
public key consists of the signing key

472
00:15:32,639 --> 00:15:34,480
sk which has been generated together

473
00:15:34,480 --> 00:15:37,040
with the verification key vk and a

474
00:15:37,040 --> 00:15:39,680
functional key skf that is generated for

475
00:15:39,680 --> 00:15:41,839
the policy f evaluated on the first

476
00:15:41,839 --> 00:15:43,839
component using the attribute set x of

477
00:15:43,839 --> 00:15:45,040
the party

478
00:15:45,040 --> 00:15:47,519
this half-evaluated policy enables us to

479
00:15:47,519 --> 00:15:49,440
obliviously check if the sender and the

480
00:15:49,440 --> 00:15:51,680
receiver together fulfill the policy

481
00:15:51,680 --> 00:15:53,360
without revealing anything about their

482
00:15:53,360 --> 00:15:54,480
attributes

483
00:15:54,480 --> 00:15:56,720
in the last step another signature sigma

484
00:15:56,720 --> 00:15:59,600
s is generated using the signing key sks

485
00:15:59,600 --> 00:16:01,600
for the verification key vk of the

486
00:16:01,600 --> 00:16:04,480
public key and the functional key skf to

487
00:16:04,480 --> 00:16:06,240
bind the public key and the secret key

488
00:16:06,240 --> 00:16:07,680
together

489
00:16:07,680 --> 00:16:09,839
to generate a signature the sender uses

490
00:16:09,839 --> 00:16:11,199
its functional key to decrypt the

491
00:16:11,199 --> 00:16:12,959
ciphertext contained in the public key

492
00:16:12,959 --> 00:16:15,279
of the receiver and produces the proof

493
00:16:15,279 --> 00:16:17,600
pi using the zero knowledge proof system

494
00:16:17,600 --> 00:16:19,040
by proving that the output of the

495
00:16:19,040 --> 00:16:21,120
decryption is 1 and that the functional

496
00:16:21,120 --> 00:16:22,800
key that has been used to generate the

497
00:16:22,800 --> 00:16:24,639
decryption is part of the secret key

498
00:16:24,639 --> 00:16:26,320
that corresponds to the public key of

499
00:16:26,320 --> 00:16:28,720
the sender the generated proof ensures

500
00:16:28,720 --> 00:16:30,560
that the policy is fulfilled by both of

501
00:16:30,560 --> 00:16:32,639
the parties and that the correct key of

502
00:16:32,639 --> 00:16:35,040
the sender has been used in the final

503
00:16:35,040 --> 00:16:37,680
step the sender uses its signing key sk

504
00:16:37,680 --> 00:16:40,240
to generate a signature sigma prime over

505
00:16:40,240 --> 00:16:42,639
the message m and the proof pi the

506
00:16:42,639 --> 00:16:44,959
resulting signature sigma prime can then

507
00:16:44,959 --> 00:16:46,880
be publicly verified by verifying the

508
00:16:46,880 --> 00:16:48,800
zero knowledge proof pi and the

509
00:16:48,800 --> 00:16:50,880
signature sigma of the digital signature

510
00:16:50,880 --> 00:16:51,759
scheme

511
00:16:51,759 --> 00:16:53,199
we highlight that all the primitives

512
00:16:53,199 --> 00:16:54,959
used in our construction can be based on

513
00:16:54,959 --> 00:16:57,040
standard assumptions which in turn

514
00:16:57,040 --> 00:16:58,880
results in the realization of policy

515
00:16:58,880 --> 00:17:00,480
compliance signatures from standard

516
00:17:00,480 --> 00:17:01,839
assumptions

517
00:17:01,839 --> 00:17:03,759
after describing how our construction

518
00:17:03,759 --> 00:17:06,160
works we now discuss its security where

519
00:17:06,160 --> 00:17:08,799
we first focus on unforgeability we can

520
00:17:08,799 --> 00:17:10,799
argue that our scheme is unforgiable by

521
00:17:10,799 --> 00:17:12,559
analyzing the different events in which

522
00:17:12,559 --> 00:17:14,240
an adversary construct a signature

523
00:17:14,240 --> 00:17:16,240
forgery and show that the occurrence

524
00:17:16,240 --> 00:17:18,160
probability of these events are bounded

525
00:17:18,160 --> 00:17:19,839
by the security of our underlying

526
00:17:19,839 --> 00:17:21,119
primitives

527
00:17:21,119 --> 00:17:22,640
the first way for an adversary to

528
00:17:22,640 --> 00:17:24,400
produce a forgery is to generate a

529
00:17:24,400 --> 00:17:26,559
public key on its own for which it is

530
00:17:26,559 --> 00:17:28,880
able to produce a valid signature the

531
00:17:28,880 --> 00:17:30,480
generation of a public key without

532
00:17:30,480 --> 00:17:32,480
carol's involvement would result in a

533
00:17:32,480 --> 00:17:34,240
signature forgery with respect to the

534
00:17:34,240 --> 00:17:37,039
verification key vkp and can therefore

535
00:17:37,039 --> 00:17:38,880
be bounded by the unforgiability of the

536
00:17:38,880 --> 00:17:41,360
digital signature scheme

537
00:17:41,360 --> 00:17:43,360
another possibility for an adversary to

538
00:17:43,360 --> 00:17:45,200
generate a forgery is by forging a

539
00:17:45,200 --> 00:17:47,440
signature for a public key in the system

540
00:17:47,440 --> 00:17:49,120
for which it does not know the secret

541
00:17:49,120 --> 00:17:51,440
key in this case the adversary could use

542
00:17:51,440 --> 00:17:53,440
a proof pie from a previous signature

543
00:17:53,440 --> 00:17:55,840
generated for this key and try to forge

544
00:17:55,840 --> 00:17:57,120
a signature with respect to the

545
00:17:57,120 --> 00:18:00,240
verification key vk for a new message m

546
00:18:00,240 --> 00:18:01,200
prime

547
00:18:01,200 --> 00:18:02,960
if the adversary is successful in this

548
00:18:02,960 --> 00:18:05,120
case it has created a signature forgery

549
00:18:05,120 --> 00:18:07,840
with respect to the verification key vk

550
00:18:07,840 --> 00:18:09,600
therefore the occurrence of this event

551
00:18:09,600 --> 00:18:10,880
can also be bounded by the

552
00:18:10,880 --> 00:18:12,880
unforgivability of the digital signature

553
00:18:12,880 --> 00:18:15,600
scheme a third way for an adversary to

554
00:18:15,600 --> 00:18:17,440
produce a signature forgery is by

555
00:18:17,440 --> 00:18:19,440
generating a valid signature for public

556
00:18:19,440 --> 00:18:21,919
keys that do not fulfill the policy it

557
00:18:21,919 --> 00:18:23,760
can achieve this by either forging a

558
00:18:23,760 --> 00:18:25,919
zero-knowledge proof or by creating a

559
00:18:25,919 --> 00:18:28,320
valid witness on its own in the case

560
00:18:28,320 --> 00:18:29,919
that an adversary forges is your

561
00:18:29,919 --> 00:18:31,280
knowledge proof without knowing a

562
00:18:31,280 --> 00:18:33,600
witness it breaks the extractability

563
00:18:33,600 --> 00:18:34,880
property of the underlying

564
00:18:34,880 --> 00:18:37,280
non-interactive zero-knowledge protocol

565
00:18:37,280 --> 00:18:39,039
extractability requires that an

566
00:18:39,039 --> 00:18:40,799
adversary is not able to generate a

567
00:18:40,799 --> 00:18:43,120
valid proof for a statement if it is not

568
00:18:43,120 --> 00:18:45,360
in possession of a corresponding witness

569
00:18:45,360 --> 00:18:46,880
this is a stronger property than

570
00:18:46,880 --> 00:18:48,880
soundness where it is only required that

571
00:18:48,880 --> 00:18:50,880
an adversary is not able to generate a

572
00:18:50,880 --> 00:18:53,520
valid proof for false statement

573
00:18:53,520 --> 00:18:55,360
one possibility for the adversary to

574
00:18:55,360 --> 00:18:57,200
generate a valid witness is by taking

575
00:18:57,200 --> 00:18:58,880
the secret key of a public key that

576
00:18:58,880 --> 00:19:01,039
fulfills the policy and forge a

577
00:19:01,039 --> 00:19:03,039
signature sigma prime with respect to

578
00:19:03,039 --> 00:19:04,880
the verification key of the public key

579
00:19:04,880 --> 00:19:07,280
that does not fulfill the policy this

580
00:19:07,280 --> 00:19:09,039
forged key can then be used to generate

581
00:19:09,039 --> 00:19:11,280
a valid proof pie with respect to the

582
00:19:11,280 --> 00:19:12,880
public key that does not fulfill the

583
00:19:12,880 --> 00:19:14,960
policy this attack results in a

584
00:19:14,960 --> 00:19:16,720
signature forgery with respect to the

585
00:19:16,720 --> 00:19:19,440
verification key vks and can therefore

586
00:19:19,440 --> 00:19:21,760
be again bounded by the unforgeability

587
00:19:21,760 --> 00:19:23,840
of the digital signature scheme this

588
00:19:23,840 --> 00:19:25,120
concludes the analysis of the

589
00:19:25,120 --> 00:19:27,440
unforgeability of our construction and

590
00:19:27,440 --> 00:19:29,120
we can now take a more detailed look

591
00:19:29,120 --> 00:19:31,440
into the attribute hiding of our scheme

592
00:19:31,440 --> 00:19:33,120
to achieve attribute titling we need to

593
00:19:33,120 --> 00:19:34,799
ensure that nothing about the attributes

594
00:19:34,799 --> 00:19:36,640
of the participating parties is leaked

595
00:19:36,640 --> 00:19:38,400
from the public keys and that the

596
00:19:38,400 --> 00:19:40,160
generated signatures between different

597
00:19:40,160 --> 00:19:42,160
parties only reveal that the attributes

598
00:19:42,160 --> 00:19:44,240
fulfill the policy and nothing beyond

599
00:19:44,240 --> 00:19:45,200
that

600
00:19:45,200 --> 00:19:47,039
since the only part in the public key

601
00:19:47,039 --> 00:19:48,640
that contains information about the

602
00:19:48,640 --> 00:19:50,080
attributes of the party is the

603
00:19:50,080 --> 00:19:52,320
ciphertext ct it follows from the

604
00:19:52,320 --> 00:19:53,840
attribute titling of the predicate

605
00:19:53,840 --> 00:19:55,840
encryption scheme that nothing about the

606
00:19:55,840 --> 00:19:57,600
attributes of the parties is leaked by

607
00:19:57,600 --> 00:19:59,120
the public keys

608
00:19:59,120 --> 00:20:00,960
to ensure that no information beyond the

609
00:20:00,960 --> 00:20:03,200
policy evaluation is leaked by signature

610
00:20:03,200 --> 00:20:05,440
sigma prime we can rely on the zero

611
00:20:05,440 --> 00:20:07,679
knowledge property of our proof system

612
00:20:07,679 --> 00:20:09,440
the zero knowledge property states that

613
00:20:09,440 --> 00:20:11,280
no information beyond the validity of

614
00:20:11,280 --> 00:20:13,039
the statement that is being proven is

615
00:20:13,039 --> 00:20:15,039
leaked which in our case is the

616
00:20:15,039 --> 00:20:17,520
fulfillment of the policy this concludes

617
00:20:17,520 --> 00:20:18,760
our analysis of the indistinguishability

618
00:20:18,760 --> 00:20:20,320
indistinguishability-based attribute

619
00:20:20,320 --> 00:20:21,919
hiding

620
00:20:21,919 --> 00:20:24,080
besides standalone security we also

621
00:20:24,080 --> 00:20:25,760
analyze the security of policy

622
00:20:25,760 --> 00:20:27,520
compliance signatures in the universal

623
00:20:27,520 --> 00:20:30,320
composability framework before doing so

624
00:20:30,320 --> 00:20:32,320
we give a high level overview of the uc

625
00:20:32,320 --> 00:20:33,520
framework

626
00:20:33,520 --> 00:20:35,440
in the uc framework we consider two

627
00:20:35,440 --> 00:20:37,200
different worlds the real world and the

628
00:20:37,200 --> 00:20:39,280
ideal world in the real world we have a

629
00:20:39,280 --> 00:20:41,360
protocol that is executed by alice and

630
00:20:41,360 --> 00:20:43,440
bob and can further be influenced by an

631
00:20:43,440 --> 00:20:45,679
adversary in the ideal world we have

632
00:20:45,679 --> 00:20:47,360
alice and bob that interact with an

633
00:20:47,360 --> 00:20:49,760
ideal functionality f which is also

634
00:20:49,760 --> 00:20:51,600
accessed by an ideal adversary called

635
00:20:51,600 --> 00:20:54,159
the simulator the inputs of ls bob and

636
00:20:54,159 --> 00:20:55,760
the adversary are decided by an

637
00:20:55,760 --> 00:20:58,559
environment z in both of these worlds we

638
00:20:58,559 --> 00:21:00,480
say that the scheme is uc secure if

639
00:21:00,480 --> 00:21:03,039
there exists a simulator such that it is

640
00:21:03,039 --> 00:21:05,360
hard for any efficient environment set

641
00:21:05,360 --> 00:21:07,039
to determine if it interacts with the

642
00:21:07,039 --> 00:21:09,360
real world or the ideal world

643
00:21:09,360 --> 00:21:11,039
the job of the simulator here is to

644
00:21:11,039 --> 00:21:12,960
properly simulate the interaction in the

645
00:21:12,960 --> 00:21:15,200
ideal world such that the environment

646
00:21:15,200 --> 00:21:16,960
cannot see a difference with respect to

647
00:21:16,960 --> 00:21:18,240
the real world

648
00:21:18,240 --> 00:21:20,000
the intuition behind this definition of

649
00:21:20,000 --> 00:21:22,000
security is that all the attacks that

650
00:21:22,000 --> 00:21:24,320
can be executed in a protocol execution

651
00:21:24,320 --> 00:21:26,799
in the real world can also be executed

652
00:21:26,799 --> 00:21:29,440
in the ideal world through the simulator

653
00:21:29,440 --> 00:21:31,520
the same holds in terms of leakage in

654
00:21:31,520 --> 00:21:33,039
more detail it follows that the

655
00:21:33,039 --> 00:21:34,400
information that is leaked in the

656
00:21:34,400 --> 00:21:37,039
protocol execution is the same as the

657
00:21:37,039 --> 00:21:38,799
information that is leaked by the ideal

658
00:21:38,799 --> 00:21:40,240
functionality

659
00:21:40,240 --> 00:21:42,320
this security definition further allows

660
00:21:42,320 --> 00:21:44,320
that whenever the ideal functionality is

661
00:21:44,320 --> 00:21:45,919
used as a subroutine in the bigger

662
00:21:45,919 --> 00:21:48,559
protocol execution it can be replaced by

663
00:21:48,559 --> 00:21:50,559
the specific protocol for which you see

664
00:21:50,559 --> 00:21:52,720
realization has been proven this is

665
00:21:52,720 --> 00:21:55,520
known as the composition theorem

666
00:21:55,520 --> 00:21:56,799
before presenting the ideal

667
00:21:56,799 --> 00:21:58,720
functionality that can be realized using

668
00:21:58,720 --> 00:22:01,120
policy compliance signatures we focus on

669
00:22:01,120 --> 00:22:03,039
the ideal functionality that is realized

670
00:22:03,039 --> 00:22:05,120
by digital signature scheme the

671
00:22:05,120 --> 00:22:07,280
signature functionality has interfaces

672
00:22:07,280 --> 00:22:09,760
to interact with alice and bob alice can

673
00:22:09,760 --> 00:22:11,760
user interface to send a key generation

674
00:22:11,760 --> 00:22:14,159
request to the ideal functionality which

675
00:22:14,159 --> 00:22:15,679
then forwards this request to the

676
00:22:15,679 --> 00:22:18,080
simulator the simulator replies to this

677
00:22:18,080 --> 00:22:20,640
request with a key identifier v that is

678
00:22:20,640 --> 00:22:22,480
then sent back to alice

679
00:22:22,480 --> 00:22:24,640
afterwards for the signature generation

680
00:22:24,640 --> 00:22:26,559
alice sends m as a sign request to the

681
00:22:26,559 --> 00:22:28,880
ideal functionality as in the case of a

682
00:22:28,880 --> 00:22:30,960
key generation request the ideal

683
00:22:30,960 --> 00:22:32,640
functionality forwards the request to

684
00:22:32,640 --> 00:22:34,720
the simulator which replies with the

685
00:22:34,720 --> 00:22:36,880
signature sigma that is then sent to

686
00:22:36,880 --> 00:22:39,280
ellis by the ideal functionality

687
00:22:39,280 --> 00:22:41,039
if bob is in possession of a signature

688
00:22:41,039 --> 00:22:43,520
sigma for a message m of alice he can

689
00:22:43,520 --> 00:22:45,440
send a verify request consisting of

690
00:22:45,440 --> 00:22:47,919
alice identifier the message and the

691
00:22:47,919 --> 00:22:50,320
signature to the ideal functionality the

692
00:22:50,320 --> 00:22:52,000
ideal functionality then forwards the

693
00:22:52,000 --> 00:22:54,320
verification request to the simulator

694
00:22:54,320 --> 00:22:56,320
which replies to the ideal functionality

695
00:22:56,320 --> 00:22:58,640
if the signature is valid or not this

696
00:22:58,640 --> 00:23:00,400
answer is then forwarded to bob by the

697
00:23:00,400 --> 00:23:02,080
ideal functionality

698
00:23:02,080 --> 00:23:03,600
the signature functionality also

699
00:23:03,600 --> 00:23:05,840
guarantees unforgeability which means

700
00:23:05,840 --> 00:23:07,679
that no signature for a message that has

701
00:23:07,679 --> 00:23:09,520
never been used in a sign request by

702
00:23:09,520 --> 00:23:11,600
alice will be deemed valid with respect

703
00:23:11,600 --> 00:23:13,919
to her identifier v

704
00:23:13,919 --> 00:23:16,000
the describe signature functionality can

705
00:23:16,000 --> 00:23:18,000
be realized using a protocol where alice

706
00:23:18,000 --> 00:23:19,840
uses the setup procedure of a digital

707
00:23:19,840 --> 00:23:22,080
signature scheme to generate her key

708
00:23:22,080 --> 00:23:24,000
pair and uses the verification key as

709
00:23:24,000 --> 00:23:26,880
her identifier to sign a message alice

710
00:23:26,880 --> 00:23:28,640
executes the sign procedure using her

711
00:23:28,640 --> 00:23:30,559
signing key bob can then use the

712
00:23:30,559 --> 00:23:32,400
verification procedure together with

713
00:23:32,400 --> 00:23:34,159
alice verification key to check a

714
00:23:34,159 --> 00:23:37,039
signature for its validity the simulator

715
00:23:37,039 --> 00:23:38,640
in the ideal world for the signature

716
00:23:38,640 --> 00:23:40,640
functionality generates a keeper when a

717
00:23:40,640 --> 00:23:42,640
key generation query is forwarded to it

718
00:23:42,640 --> 00:23:44,880
by the signature functionality and

719
00:23:44,880 --> 00:23:46,720
replies with the verification key as the

720
00:23:46,720 --> 00:23:48,799
corresponding identifier

721
00:23:48,799 --> 00:23:50,720
whenever the simulator receives a sign

722
00:23:50,720 --> 00:23:53,120
query it uses the sign procedure of the

723
00:23:53,120 --> 00:23:55,039
signature scheme to generate a signature

724
00:23:55,039 --> 00:23:57,120
with the signing key that corresponds to

725
00:23:57,120 --> 00:23:59,360
the verification key contained in the

726
00:23:59,360 --> 00:24:02,000
sign query and whenever a verification

727
00:24:02,000 --> 00:24:04,400
query is asked the simulator locally

728
00:24:04,400 --> 00:24:06,400
executes the verify procedure using the

729
00:24:06,400 --> 00:24:08,880
corresponding verification key and sends

730
00:24:08,880 --> 00:24:10,640
the output as a reply to the ideal

731
00:24:10,640 --> 00:24:12,000
functionality

732
00:24:12,000 --> 00:24:13,679
the unforgetability of the signature

733
00:24:13,679 --> 00:24:15,520
scheme in this setting ensures that no

734
00:24:15,520 --> 00:24:17,600
one other than alice is able to generate

735
00:24:17,600 --> 00:24:20,080
a valid signature for a new message with

736
00:24:20,080 --> 00:24:22,559
respect to her identifier which matches

737
00:24:22,559 --> 00:24:24,240
the unforgeability guarantee of the

738
00:24:24,240 --> 00:24:26,080
ideal functionality

739
00:24:26,080 --> 00:24:27,520
after focusing on the ideal

740
00:24:27,520 --> 00:24:29,279
functionality for digital signature

741
00:24:29,279 --> 00:24:31,039
scheme we now consider the extended

742
00:24:31,039 --> 00:24:32,559
policy compliance signatures

743
00:24:32,559 --> 00:24:34,000
functionality

744
00:24:34,000 --> 00:24:35,520
the policy compliance signature

745
00:24:35,520 --> 00:24:37,360
functionality consists of an additional

746
00:24:37,360 --> 00:24:39,760
interface to carol carol can use this

747
00:24:39,760 --> 00:24:41,919
interface to submit a policy generation

748
00:24:41,919 --> 00:24:44,159
query for policy f to the ideal

749
00:24:44,159 --> 00:24:46,240
functionality which forwards it to the

750
00:24:46,240 --> 00:24:48,720
simulator the simulator then replies to

751
00:24:48,720 --> 00:24:50,559
the ideal functionality with a master

752
00:24:50,559 --> 00:24:52,320
identifier vm

753
00:24:52,320 --> 00:24:54,400
this master identifier is then forwarded

754
00:24:54,400 --> 00:24:55,440
to carol

755
00:24:55,440 --> 00:24:57,279
when alice issues her key generation

756
00:24:57,279 --> 00:24:58,880
query she additionally submits her

757
00:24:58,880 --> 00:25:00,720
attribute set xa to the ideal

758
00:25:00,720 --> 00:25:03,039
functionality which then notifies the

759
00:25:03,039 --> 00:25:05,039
simulator that the key generation query

760
00:25:05,039 --> 00:25:06,880
has been asked for alice without

761
00:25:06,880 --> 00:25:09,360
revealing the attribute set xa the

762
00:25:09,360 --> 00:25:11,200
simulator then replies to the ideal

763
00:25:11,200 --> 00:25:13,840
functionality with an identifier va

764
00:25:13,840 --> 00:25:16,080
which is then forwarded to alice

765
00:25:16,080 --> 00:25:18,240
when bob issues his key generation query

766
00:25:18,240 --> 00:25:20,480
using the attribute set xb the ideal

767
00:25:20,480 --> 00:25:22,400
functionality and the simulator interact

768
00:25:22,400 --> 00:25:24,320
in the same way as before to obtain the

769
00:25:24,320 --> 00:25:26,240
identifier vb

770
00:25:26,240 --> 00:25:28,159
when alice issues a sign query she

771
00:25:28,159 --> 00:25:30,480
submits bob's identifier vb and the

772
00:25:30,480 --> 00:25:32,640
message m to the ideal functionality

773
00:25:32,640 --> 00:25:34,080
which forwards this query to the

774
00:25:34,080 --> 00:25:35,919
simulator together with the policy

775
00:25:35,919 --> 00:25:38,000
evaluation over the attributes of alice

776
00:25:38,000 --> 00:25:40,320
and bob the simulator then replies with

777
00:25:40,320 --> 00:25:42,559
a signature sigma that is forwarded by

778
00:25:42,559 --> 00:25:44,960
the ideal functionality to alice

779
00:25:44,960 --> 00:25:47,440
for verification query bob submits the

780
00:25:47,440 --> 00:25:49,200
signature together with the message and

781
00:25:49,200 --> 00:25:51,120
the identifier of the sender and the

782
00:25:51,120 --> 00:25:53,520
receiver to the ideal functionality

783
00:25:53,520 --> 00:25:54,880
which forwards this query to the

784
00:25:54,880 --> 00:25:57,279
simulator the simulator then notifies

785
00:25:57,279 --> 00:25:59,279
the ideal functionality if the signature

786
00:25:59,279 --> 00:26:01,360
is valid or not which is forwarded to

787
00:26:01,360 --> 00:26:03,360
bob we highlight that it is also

788
00:26:03,360 --> 00:26:05,279
possible to submit the corrupt gray for

789
00:26:05,279 --> 00:26:06,799
the different parties to the ideal

790
00:26:06,799 --> 00:26:08,960
functionality if a corrupt query is

791
00:26:08,960 --> 00:26:10,640
submitted the simulator learns the

792
00:26:10,640 --> 00:26:12,240
attribute set for the party that is

793
00:26:12,240 --> 00:26:13,919
being corrupted as well as the

794
00:26:13,919 --> 00:26:15,919
evaluation with all the remaining public

795
00:26:15,919 --> 00:26:18,000
keys where the corrupted party acts as

796
00:26:18,000 --> 00:26:20,320
the sender in the case that another key

797
00:26:20,320 --> 00:26:22,080
generation query is asked after a

798
00:26:22,080 --> 00:26:24,240
corruption query the simulator also

799
00:26:24,240 --> 00:26:26,159
learns the policy evaluation for this

800
00:26:26,159 --> 00:26:28,400
new key with all the corrupted parties

801
00:26:28,400 --> 00:26:30,799
acting as senders the policy compliant

802
00:26:30,799 --> 00:26:32,400
signature functionality guarantees

803
00:26:32,400 --> 00:26:34,559
unforgeability and privacy

804
00:26:34,559 --> 00:26:37,039
unforgeability here means that first no

805
00:26:37,039 --> 00:26:38,880
one other than alice is able to generate

806
00:26:38,880 --> 00:26:41,360
a valid signature for her identifier

807
00:26:41,360 --> 00:26:43,039
second that it is not possible to

808
00:26:43,039 --> 00:26:44,720
generate a valid signature for two

809
00:26:44,720 --> 00:26:46,320
identifiers where the corresponding

810
00:26:46,320 --> 00:26:48,799
parties do not fulfill the policy and

811
00:26:48,799 --> 00:26:50,799
third that no ballot signature can be

812
00:26:50,799 --> 00:26:52,799
generated with respect to identifiers

813
00:26:52,799 --> 00:26:54,480
that have not been output by the ideal

814
00:26:54,480 --> 00:26:56,159
functionality

815
00:26:56,159 --> 00:26:57,679
privacy in this setting means that

816
00:26:57,679 --> 00:26:59,279
nothing more about the attributes of the

817
00:26:59,279 --> 00:27:01,039
different parties can be learned than

818
00:27:01,039 --> 00:27:02,880
what is leaked by generated signatures

819
00:27:02,880 --> 00:27:05,039
and corrupted parties

820
00:27:05,039 --> 00:27:06,559
the policy compliance signature

821
00:27:06,559 --> 00:27:08,559
functionality can be realized using a

822
00:27:08,559 --> 00:27:10,080
protocol where the setup and key

823
00:27:10,080 --> 00:27:12,640
generation procedure are executed by

824
00:27:12,640 --> 00:27:14,799
carol to generate the master public key

825
00:27:14,799 --> 00:27:16,880
and the master secret key as well as the

826
00:27:16,880 --> 00:27:18,559
keys for alice and bob

827
00:27:18,559 --> 00:27:20,480
for alice to generate a signature she

828
00:27:20,480 --> 00:27:22,320
can execute the sign procedure using

829
00:27:22,320 --> 00:27:24,640
bob's public key and her secret key to

830
00:27:24,640 --> 00:27:27,120
sign a message m and bob can verify the

831
00:27:27,120 --> 00:27:28,960
signature using the verify procedure of

832
00:27:28,960 --> 00:27:31,360
the policy compliant signature scheme

833
00:27:31,360 --> 00:27:33,600
in the ideal world the simulator needs

834
00:27:33,600 --> 00:27:35,120
to sample all the keys using the

835
00:27:35,120 --> 00:27:36,960
information it obtains from the ideal

836
00:27:36,960 --> 00:27:38,960
functionality as described on the

837
00:27:38,960 --> 00:27:40,640
previous slide

838
00:27:40,640 --> 00:27:42,880
we observed that for the simulator to be

839
00:27:42,880 --> 00:27:44,960
able to accomplish this and to guarantee

840
00:27:44,960 --> 00:27:47,360
privacy it needs to be able to simulate

841
00:27:47,360 --> 00:27:48,799
public keys without knowing the

842
00:27:48,799 --> 00:27:51,120
underlying attribute sets and to be able

843
00:27:51,120 --> 00:27:53,120
to simulate signatures by only knowing

844
00:27:53,120 --> 00:27:55,200
the corresponding policy evaluation of

845
00:27:55,200 --> 00:27:56,960
the involved parties

846
00:27:56,960 --> 00:27:58,480
furthermore it needs to be able to

847
00:27:58,480 --> 00:28:00,240
generate a secret key for a previously

848
00:28:00,240 --> 00:28:02,399
generated public key in the case of a

849
00:28:02,399 --> 00:28:04,240
corruption query by learning the

850
00:28:04,240 --> 00:28:06,000
corresponding attribute set after the

851
00:28:06,000 --> 00:28:08,000
public key has been generated

852
00:28:08,000 --> 00:28:10,000
the existence of such a simulator is not

853
00:28:10,000 --> 00:28:11,240
guaranteed by our current

854
00:28:11,240 --> 00:28:12,960
indistinguishability based attribute

855
00:28:12,960 --> 00:28:15,200
hiding definition contrary

856
00:28:15,200 --> 00:28:16,799
unforgeability in the ideal world

857
00:28:16,799 --> 00:28:18,720
directly follows from the unforgeability

858
00:28:18,720 --> 00:28:20,399
of the policy compliance signature

859
00:28:20,399 --> 00:28:22,320
scheme which is due to the fact that the

860
00:28:22,320 --> 00:28:24,000
unforgeability requirements on the

861
00:28:24,000 --> 00:28:26,399
policy compliance signature scheme

862
00:28:26,399 --> 00:28:28,320
match the unforgeability requirements of

863
00:28:28,320 --> 00:28:30,640
the ideal functionality

864
00:28:30,640 --> 00:28:32,559
to guarantee privacy in the ideal world

865
00:28:32,559 --> 00:28:34,080
we need to consider a stronger

866
00:28:34,080 --> 00:28:36,480
simulation-based attribute hiding notion

867
00:28:36,480 --> 00:28:38,159
that guarantees the existence of a

868
00:28:38,159 --> 00:28:40,080
simulator that is able to simulate the

869
00:28:40,080 --> 00:28:42,240
different keys and signatures in the

870
00:28:42,240 --> 00:28:44,159
simulation-based security game the

871
00:28:44,159 --> 00:28:46,240
adversary has access to the same oracles

872
00:28:46,240 --> 00:28:48,640
as in the indistinguishability based one

873
00:28:48,640 --> 00:28:50,240
but instead of distinguishing between

874
00:28:50,240 --> 00:28:52,240
the left or right attribute set used for

875
00:28:52,240 --> 00:28:54,399
the generation of public keys the task

876
00:28:54,399 --> 00:28:56,000
of the adversary is to distinguish if

877
00:28:56,000 --> 00:28:58,000
the keys and signatures it receives are

878
00:28:58,000 --> 00:29:00,640
simulated or honestly generated for the

879
00:29:00,640 --> 00:29:02,640
simulator to generate these keys it

880
00:29:02,640 --> 00:29:04,720
obtains some additional information in

881
00:29:04,720 --> 00:29:06,640
the case of a key generation query the

882
00:29:06,640 --> 00:29:08,240
simulator learns all the policy

883
00:29:08,240 --> 00:29:10,559
evaluations of the requested key with

884
00:29:10,559 --> 00:29:12,240
all the corrupted keys where the

885
00:29:12,240 --> 00:29:14,960
corrupted keys act as sender keys in the

886
00:29:14,960 --> 00:29:16,960
case of a corruption query the simulator

887
00:29:16,960 --> 00:29:19,039
learns the attributes of the key as well

888
00:29:19,039 --> 00:29:21,200
as all the policy evaluations of this

889
00:29:21,200 --> 00:29:23,520
key acting as the sender key with all

890
00:29:23,520 --> 00:29:25,919
the remaining keys in the case of a sign

891
00:29:25,919 --> 00:29:27,679
query the simulator learns the policy

892
00:29:27,679 --> 00:29:29,679
evaluation of the attributes associated

893
00:29:29,679 --> 00:29:32,480
with the keys that are used in the query

894
00:29:32,480 --> 00:29:34,240
this notion is sufficient for our uc

895
00:29:34,240 --> 00:29:36,240
realization and guarantees the existence

896
00:29:36,240 --> 00:29:38,159
of the simulator that is able to

897
00:29:38,159 --> 00:29:39,600
generate the different keys and

898
00:29:39,600 --> 00:29:41,440
signatures in a proper way

899
00:29:41,440 --> 00:29:43,039
additionally we highlight that if the

900
00:29:43,039 --> 00:29:44,640
simulation based secure predicate

901
00:29:44,640 --> 00:29:46,080
encryption scheme is used as an

902
00:29:46,080 --> 00:29:48,399
instantiation in our construction then

903
00:29:48,399 --> 00:29:50,480
we also obtain a simulation based secure

904
00:29:50,480 --> 00:29:52,559
policy compliance signature scheme

905
00:29:52,559 --> 00:29:54,559
unfortunately we are not aware of any

906
00:29:54,559 --> 00:29:56,000
predicate encryption scheme that

907
00:29:56,000 --> 00:29:57,440
achieves the required notion of

908
00:29:57,440 --> 00:29:59,840
simulation-based security therefore we

909
00:29:59,840 --> 00:30:01,679
leave it as an interesting open question

910
00:30:01,679 --> 00:30:03,600
to construct simulation-based secure

911
00:30:03,600 --> 00:30:05,919
policy compliance signatures

912
00:30:05,919 --> 00:30:07,919
to summarize in this talk we have

913
00:30:07,919 --> 00:30:09,360
introduced the notion of policy

914
00:30:09,360 --> 00:30:11,279
compliance signatures together with the

915
00:30:11,279 --> 00:30:13,440
corresponding notion of unforgiability

916
00:30:13,440 --> 00:30:15,600
and indistinguishability-based attribute

917
00:30:15,600 --> 00:30:18,159
hiding furthermore we presented a policy

918
00:30:18,159 --> 00:30:20,159
compliance signature scheme based on

919
00:30:20,159 --> 00:30:22,240
digital signatures non-interactive zero

920
00:30:22,240 --> 00:30:23,840
knowledge proofs and predicate

921
00:30:23,840 --> 00:30:26,080
encryption that achieves unforgeability

922
00:30:26,080 --> 00:30:28,080
and indistinguishability-based attribute

923
00:30:28,080 --> 00:30:30,559
hiding in the last step we also gave a

924
00:30:30,559 --> 00:30:32,720
uc formulation of our notion and

925
00:30:32,720 --> 00:30:34,480
presented the corresponding simulation

926
00:30:34,480 --> 00:30:36,559
based notion of attribute hiding that is

927
00:30:36,559 --> 00:30:39,200
needed to realize our uc formulation

928
00:30:39,200 --> 00:30:42,880
thank you very much for listening

