1
00:00:00,480 --> 00:00:01,439
um

2
00:00:01,439 --> 00:00:04,680
so this is a chair with a recession on

3
00:00:04,680 --> 00:00:06,600
on parents

4
00:00:06,600 --> 00:00:10,080
I'm Francesco Sica and uh today we have

5
00:00:10,080 --> 00:00:11,099
three

6
00:00:11,099 --> 00:00:13,559
talks so the first one

7
00:00:13,559 --> 00:00:19,740
is by uh Akash data and uh Tapas pal

8
00:00:19,740 --> 00:00:21,720
on decentralized multi-authority

9
00:00:21,720 --> 00:00:25,019
attribute based in a product fee large

10
00:00:25,019 --> 00:00:27,180
universe and unbounded

11
00:00:27,180 --> 00:00:29,820
so Tapas is going to give a talk yeah

12
00:00:29,820 --> 00:00:31,859
thank you thanks for the introduction

13
00:00:31,859 --> 00:00:35,760
okay so I am Tapas from entity Japan so

14
00:00:35,760 --> 00:00:37,680
I will be presenting our paper

15
00:00:37,680 --> 00:00:39,540
decentralized multi-authority attribute

16
00:00:39,540 --> 00:00:42,239
based in our product Fe large universe

17
00:00:42,239 --> 00:00:44,940
and unbounded so it's a joint work with

18
00:00:44,940 --> 00:00:47,100
pratish from entity research

19
00:00:47,100 --> 00:00:48,899
so let's start with the syntax of

20
00:00:48,899 --> 00:00:50,579
functional encryption which is an

21
00:00:50,579 --> 00:00:53,160
advanced form of usual public encryption

22
00:00:53,160 --> 00:00:57,300
so it has four algorithms so in setup uh

23
00:00:57,300 --> 00:00:59,579
Authority takes security parameter

24
00:00:59,579 --> 00:01:02,340
Lambda as input and compute semester

25
00:01:02,340 --> 00:01:06,540
public pnpk and a master secretary km so

26
00:01:06,540 --> 00:01:09,540
using msk the authority generates a

27
00:01:09,540 --> 00:01:11,100
secret key Escape corresponding to any

28
00:01:11,100 --> 00:01:14,400
function if and sends it to the user in

29
00:01:14,400 --> 00:01:16,979
the system using mpk we can encrypt

30
00:01:16,979 --> 00:01:20,939
messaging and publish our psychotex ATM

31
00:01:20,939 --> 00:01:24,479
now a user holding SKS can decrypt ctm

32
00:01:24,479 --> 00:01:25,979
and launch functional value of the

33
00:01:25,979 --> 00:01:27,420
messenger

34
00:01:27,420 --> 00:01:30,659
okay so informally security of a fee

35
00:01:30,659 --> 00:01:33,000
guarantees that a user holding SKF

36
00:01:33,000 --> 00:01:36,240
cannot infer anything else about the

37
00:01:36,240 --> 00:01:38,280
message aim from the cycle text CPM

38
00:01:38,280 --> 00:01:39,960
except the functional value of the

39
00:01:39,960 --> 00:01:42,299
message in

40
00:01:42,299 --> 00:01:44,759
so in our product function encryption or

41
00:01:44,759 --> 00:01:47,460
ipfe is a particular class of function

42
00:01:47,460 --> 00:01:51,060
encryption where secret key and Cipher

43
00:01:51,060 --> 00:01:54,000
text are generated corresponding to some

44
00:01:54,000 --> 00:01:57,119
vectors Y and X here and during

45
00:01:57,119 --> 00:01:59,939
decryption a user recovers in our

46
00:01:59,939 --> 00:02:02,399
product between generators

47
00:02:02,399 --> 00:02:04,860
so due to this functionality sqy reveals

48
00:02:04,860 --> 00:02:06,840
in our product value right so therefore

49
00:02:06,840 --> 00:02:08,758
if we release sufficient number of s two

50
00:02:08,758 --> 00:02:10,560
y i then we can solve this system of

51
00:02:10,560 --> 00:02:13,080
equation for x using simple gaussian

52
00:02:13,080 --> 00:02:15,599
elimination and hence the system it is

53
00:02:15,599 --> 00:02:18,599
completely broken right so uh in other

54
00:02:18,599 --> 00:02:21,480
in in other words that uh

55
00:02:21,480 --> 00:02:25,260
the leakage in ipf is very high that

56
00:02:25,260 --> 00:02:27,300
means we cannot release sky for

57
00:02:27,300 --> 00:02:30,300
inlinearly independent y vectors so to

58
00:02:30,300 --> 00:02:32,040
control this leakage of the lateral in

59
00:02:32,040 --> 00:02:34,620
Asia trip 2020 propose this notion of

60
00:02:34,620 --> 00:02:37,080
attribute best ipfe which provides

61
00:02:37,080 --> 00:02:39,060
attribute based access control on top of

62
00:02:39,060 --> 00:02:42,300
ipfe so here at secret keys and Cipher

63
00:02:42,300 --> 00:02:44,220
texts are additionally associated with

64
00:02:44,220 --> 00:02:47,300
attributes ATT and polycp

65
00:02:47,300 --> 00:02:49,500
respectively and during decryption we

66
00:02:49,500 --> 00:02:51,540
recover The Interpreter value given that

67
00:02:51,540 --> 00:02:53,819
the attribute of the secret key

68
00:02:53,819 --> 00:02:56,400
satisfies the uh policy of the

69
00:02:56,400 --> 00:02:58,260
ciphertext

70
00:02:58,260 --> 00:03:01,379
so in the security model the ipv game

71
00:03:01,379 --> 00:03:03,420
condition in a product of x 0 y i equal

72
00:03:03,420 --> 00:03:06,480
to network of X1 y i uh is required to

73
00:03:06,480 --> 00:03:09,300
hold uh only for the secret keys where

74
00:03:09,300 --> 00:03:11,099
the associated attribute satisfy the

75
00:03:11,099 --> 00:03:14,580
policy of the challenge Cipher text

76
00:03:14,580 --> 00:03:17,280
okay so uh it means that we can control

77
00:03:17,280 --> 00:03:21,480
the leakage uh to some extent meaning

78
00:03:21,480 --> 00:03:24,659
that we can release sky for n linearly

79
00:03:24,659 --> 00:03:26,940
Independent Drive vectors unless all the

80
00:03:26,940 --> 00:03:28,980
associated attributes satisfy the policy

81
00:03:28,980 --> 00:03:31,080
of the Chinese cyber text

82
00:03:31,080 --> 00:03:33,900
okay so let's consider an application of

83
00:03:33,900 --> 00:03:36,780
API in the domain of iomt or Internet of

84
00:03:36,780 --> 00:03:38,400
medical things

85
00:03:38,400 --> 00:03:40,200
so let's say there is a company who

86
00:03:40,200 --> 00:03:43,080
wants to increase the efficiency of uh

87
00:03:43,080 --> 00:03:46,260
variable Health device and for that it

88
00:03:46,260 --> 00:03:49,260
hires a a set of hospitals which one is

89
00:03:49,260 --> 00:03:52,680
two research Labs L1 L2

90
00:03:52,680 --> 00:03:56,099
and the user's data so I mean the case

91
00:03:56,099 --> 00:03:58,140
search data for example blood pressures

92
00:03:58,140 --> 00:04:00,900
are encrypted by the device under a

93
00:04:00,900 --> 00:04:03,299
certain policy p and the ciphertext is

94
00:04:03,299 --> 00:04:05,220
uploaded to the server

95
00:04:05,220 --> 00:04:07,500
now keys are provided to the users of

96
00:04:07,500 --> 00:04:09,420
the system who are the doctors of

97
00:04:09,420 --> 00:04:12,120
hospitals and researcher of the labs uh

98
00:04:12,120 --> 00:04:14,939
corresponding to their attributes

99
00:04:14,939 --> 00:04:18,180
and the user will be able to decrypt the

100
00:04:18,180 --> 00:04:20,639
uh sorry for text that means it can run

101
00:04:20,639 --> 00:04:23,419
some computation over the encrypted

102
00:04:23,419 --> 00:04:26,580
message given the attribute satisfy the

103
00:04:26,580 --> 00:04:30,240
policy uh we are considering here

104
00:04:30,240 --> 00:04:33,180
but the problem in usual apicf is that

105
00:04:33,180 --> 00:04:35,040
all the attributes are controlled by a

106
00:04:35,040 --> 00:04:37,919
single Authority but in reality uh

107
00:04:37,919 --> 00:04:39,360
different attributes are controlled by

108
00:04:39,360 --> 00:04:41,160
different authorities right so for

109
00:04:41,160 --> 00:04:42,960
example hospitals controls attributes

110
00:04:42,960 --> 00:04:45,120
related to their departments Labs

111
00:04:45,120 --> 00:04:46,800
controls attributes related to the

112
00:04:46,800 --> 00:04:49,080
Synergy level of the employees

113
00:04:49,080 --> 00:04:52,139
and another drawback of uh normal avip

114
00:04:52,139 --> 00:04:55,740
is that the if if at any point of time

115
00:04:55,740 --> 00:04:59,820
the authority is corrupted then no

116
00:04:59,820 --> 00:05:04,080
security of users data can be guaranteed

117
00:05:04,080 --> 00:05:08,600
okay so to mitigate this problem uh

118
00:05:08,600 --> 00:05:11,520
21 introduce this notion of multi

119
00:05:11,520 --> 00:05:13,259
Authority Aviation

120
00:05:13,259 --> 00:05:15,240
where we have multiple authorities in

121
00:05:15,240 --> 00:05:18,660
the system each Authority uh is

122
00:05:18,660 --> 00:05:20,220
responsible to generate secretaries

123
00:05:20,220 --> 00:05:22,020
corresponding to their attribute to the

124
00:05:22,020 --> 00:05:24,780
attributes under their control and the

125
00:05:24,780 --> 00:05:26,820
secret keys are associated with a global

126
00:05:26,820 --> 00:05:28,680
identity GID

127
00:05:28,680 --> 00:05:31,560
so during encryption uh I mean

128
00:05:31,560 --> 00:05:34,139
encryption is performed using a set of

129
00:05:34,139 --> 00:05:36,320
public keys of the authorities

130
00:05:36,320 --> 00:05:39,240
who controls some attributes related to

131
00:05:39,240 --> 00:05:41,400
the policy under consideration

132
00:05:41,400 --> 00:05:44,220
and during decryption a user combines a

133
00:05:44,220 --> 00:05:46,080
set of Securities computed under the

134
00:05:46,080 --> 00:05:49,919
same GID and same Y and it can decrypt

135
00:05:49,919 --> 00:05:51,780
the ciphertext only if the associated

136
00:05:51,780 --> 00:05:54,360
attributes satisfy the policy of the

137
00:05:54,360 --> 00:05:56,220
ciphertext

138
00:05:56,220 --> 00:05:58,919
so in the security experiment uh instead

139
00:05:58,919 --> 00:06:01,020
of interacting with one single Authority

140
00:06:01,020 --> 00:06:04,620
the adversary can ask Securities from

141
00:06:04,620 --> 00:06:08,759
many authorities given the I mean and

142
00:06:08,759 --> 00:06:11,400
and the ipv game condition only required

143
00:06:11,400 --> 00:06:14,639
to satisfy if the set of attributes

144
00:06:14,639 --> 00:06:17,699
satisfy the challenge policy

145
00:06:17,699 --> 00:06:20,940
and any additionally here the efforts

146
00:06:20,940 --> 00:06:22,080
that you can code up some of the

147
00:06:22,080 --> 00:06:25,620
authorities given that uh the attribute

148
00:06:25,620 --> 00:06:29,699
squared by the uh adverse study uh from

149
00:06:29,699 --> 00:06:32,580
the honest uh authorities along with the

150
00:06:32,580 --> 00:06:35,460
attributes controlled by some corrupted

151
00:06:35,460 --> 00:06:38,039
authorities uh does not satisfy the

152
00:06:38,039 --> 00:06:40,680
policy of this ciphertext

153
00:06:40,680 --> 00:06:44,400
okay so uh now if we replace a maybe I

154
00:06:44,400 --> 00:06:47,100
mean abip with M80 ipfe in the

155
00:06:47,100 --> 00:06:50,580
application of iomt it means that the

156
00:06:50,580 --> 00:06:52,740
hospitals and labs are now treated as

157
00:06:52,740 --> 00:06:55,319
individual and independent authorities

158
00:06:55,319 --> 00:06:59,100
who controls the attributes which they

159
00:06:59,100 --> 00:07:01,380
are managed manager

160
00:07:01,380 --> 00:07:04,380
so uh for example 80 T1 is controlled by

161
00:07:04,380 --> 00:07:06,180
Hospital one and att2 is controlled by

162
00:07:06,180 --> 00:07:09,539
lab 2. now now if

163
00:07:09,539 --> 00:07:12,600
Hospital 2 and lab one are corrupted the

164
00:07:12,600 --> 00:07:15,840
system remains still secure right

165
00:07:15,840 --> 00:07:19,080
okay but the only existing construction

166
00:07:19,080 --> 00:07:22,020
of nav ipv by our value at all has some

167
00:07:22,020 --> 00:07:25,380
limitations firstly the length of the

168
00:07:25,380 --> 00:07:28,319
vector which is n is bounded I mean is

169
00:07:28,319 --> 00:07:31,199
fixed at the time of setup so as a

170
00:07:31,199 --> 00:07:33,360
result the master public size of each

171
00:07:33,360 --> 00:07:35,759
Authority depends on this mountain and

172
00:07:35,759 --> 00:07:38,160
the cipher textile goes with respect to

173
00:07:38,160 --> 00:07:41,340
the sand even if you have a vector uh

174
00:07:41,340 --> 00:07:43,860
whose size is much less than n

175
00:07:43,860 --> 00:07:46,500
secondly uh each Authority control is

176
00:07:46,500 --> 00:07:48,180
only a bounded number of attributes in

177
00:07:48,180 --> 00:07:50,819
their system so they supports only small

178
00:07:50,819 --> 00:07:54,660
Universe of atoms and lastly they build

179
00:07:54,660 --> 00:07:55,979
the Primitive in the composite order

180
00:07:55,979 --> 00:07:58,139
pairing groups which slow down the

181
00:07:58,139 --> 00:08:00,419
performance more specifically the

182
00:08:00,419 --> 00:08:04,440
encryption time took uh two hours and

183
00:08:04,440 --> 00:08:06,599
decryption time is huge which is five

184
00:08:06,599 --> 00:08:10,919
days uh given we take a vector of length

185
00:08:10,919 --> 00:08:14,580
200 with a reasonable security level

186
00:08:14,580 --> 00:08:19,080
okay so in our work we um we overcome

187
00:08:19,080 --> 00:08:21,419
these limitations in particular we

188
00:08:21,419 --> 00:08:24,360
construct maav ipfe where unbounded

189
00:08:24,360 --> 00:08:26,039
length message and key factors can be

190
00:08:26,039 --> 00:08:28,860
processed meaning that the public key

191
00:08:28,860 --> 00:08:31,860
size of each Authority is constant and

192
00:08:31,860 --> 00:08:33,740
the ciphertext size is input specific

193
00:08:33,740 --> 00:08:35,520
authorities are allowed to control

194
00:08:35,520 --> 00:08:37,979
arbitrary number of attributes and

195
00:08:37,979 --> 00:08:39,779
attributes need not be unumated at the

196
00:08:39,779 --> 00:08:41,399
time of setup that means we support

197
00:08:41,399 --> 00:08:43,860
large Universe of attributes we

198
00:08:43,860 --> 00:08:46,080
construct this primitive in parameter

199
00:08:46,080 --> 00:08:47,700
pairing groups and we Group Security

200
00:08:47,700 --> 00:08:50,820
under Target group based assumption

201
00:08:50,820 --> 00:08:52,620
in particular we prove static security

202
00:08:52,620 --> 00:08:55,260
Under The decisional Binding development

203
00:08:55,260 --> 00:08:57,899
type assumption so here static security

204
00:08:57,899 --> 00:08:59,880
means that adverse study is restricted

205
00:08:59,880 --> 00:09:02,100
to query I mean distributed to submit

206
00:09:02,100 --> 00:09:04,620
all its queries at the time of a system

207
00:09:04,620 --> 00:09:07,200
setup uh the only existing construction

208
00:09:07,200 --> 00:09:12,000
of maavip by a gravel at all satisfy

209
00:09:12,000 --> 00:09:14,399
selective security for a where all the

210
00:09:14,399 --> 00:09:16,860
queries of adversary static except it

211
00:09:16,860 --> 00:09:19,560
can query Keys selectively

212
00:09:19,560 --> 00:09:21,720
okay so this is the roadmap of our paper

213
00:09:21,720 --> 00:09:24,140
we first construct a small Universe

214
00:09:24,140 --> 00:09:27,300
naabuip here U stands for the unbounded

215
00:09:27,300 --> 00:09:29,580
lane vectors uh we construct this

216
00:09:29,580 --> 00:09:31,860
primitive under the standard DVDs

217
00:09:31,860 --> 00:09:33,899
assumption and we prove static Security

218
00:09:33,899 --> 00:09:35,760
in the random Oracle model

219
00:09:35,760 --> 00:09:38,100
then we upgrade the small Universe

220
00:09:38,100 --> 00:09:40,680
scheme into a large Universe scheme uh

221
00:09:40,680 --> 00:09:43,260
under the parameterized version of dvdh

222
00:09:43,260 --> 00:09:45,480
assumption which we call ldbth in of

223
00:09:45,480 --> 00:09:47,700
paper and we also show genetic security

224
00:09:47,700 --> 00:09:49,920
of this assumption in our paper so for

225
00:09:49,920 --> 00:09:51,420
the interest of time I will only focus

226
00:09:51,420 --> 00:09:53,820
on the small University in the stock and

227
00:09:53,820 --> 00:09:55,920
for large University please look into

228
00:09:55,920 --> 00:09:57,660
our paper

229
00:09:57,660 --> 00:10:00,060
okay so as an initial attempt we try to

230
00:10:00,060 --> 00:10:03,240
combine the NAB of uh Dr Commodore scan

231
00:10:03,240 --> 00:10:05,220
Waters with the unbounded ipfa of the

232
00:10:05,220 --> 00:10:08,040
first 100 points as well so the idea is

233
00:10:08,040 --> 00:10:10,920
that first we fix a uh parameter a s

234
00:10:10,920 --> 00:10:12,360
which is the maximum number of gates in

235
00:10:12,360 --> 00:10:14,940
the policy policies are represented as

236
00:10:14,940 --> 00:10:18,120
linear sharing access structures and it

237
00:10:18,120 --> 00:10:20,279
has two components one is the Matrix

238
00:10:20,279 --> 00:10:22,800
same of order L process and rho is the

239
00:10:22,800 --> 00:10:25,800
row leveling function

240
00:10:25,800 --> 00:10:28,980
okay so during setup Authority samples a

241
00:10:28,980 --> 00:10:31,620
few scalars a t u t j generous form two

242
00:10:31,620 --> 00:10:33,660
two s these are the master security for

243
00:10:33,660 --> 00:10:35,700
the authority and the corresponding

244
00:10:35,700 --> 00:10:38,459
group exponentiations are the public key

245
00:10:38,459 --> 00:10:41,100
so during uh secret key generation with

246
00:10:41,100 --> 00:10:45,240
respect to a g i d y and attribute T we

247
00:10:45,240 --> 00:10:48,120
use a hash uh an exponentiation

248
00:10:48,120 --> 00:10:51,540
procedure to factorize the scalars of

249
00:10:51,540 --> 00:10:53,459
Master circuit keys that means we

250
00:10:53,459 --> 00:10:56,399
factorize 80 using hash function H1 and

251
00:10:56,399 --> 00:10:58,560
we factorized in TJ using hash function

252
00:10:58,560 --> 00:11:02,579
H here has function H1 takes T which is

253
00:11:02,579 --> 00:11:04,920
the attribute as input and H takes the

254
00:11:04,920 --> 00:11:08,160
GID and Y as input where K is the common

255
00:11:08,160 --> 00:11:11,100
uh input which is the in this indices of

256
00:11:11,100 --> 00:11:12,300
the vector y

257
00:11:12,300 --> 00:11:15,060
so during encryption the encryptor

258
00:11:15,060 --> 00:11:17,459
sample some Randomness RI and it also

259
00:11:17,459 --> 00:11:20,700
samples two uh matrices V and X where

260
00:11:20,700 --> 00:11:23,040
The Columns of V are distributed shares

261
00:11:23,040 --> 00:11:26,760
of the vector Z and The Columns of X are

262
00:11:26,760 --> 00:11:29,160
the secret share of zero vector

263
00:11:29,160 --> 00:11:31,920
so we first mask the message Vector X

264
00:11:31,920 --> 00:11:35,940
using Z and then we encode the matrices

265
00:11:35,940 --> 00:11:40,380
V and X in the in c 1 I and C3 i j using

266
00:11:40,380 --> 00:11:43,380
a hash and pairing technique with the

267
00:11:43,380 --> 00:11:47,279
help of hash function uh h1nh

268
00:11:47,279 --> 00:11:49,260
okay so now if we have a set of

269
00:11:49,260 --> 00:11:51,720
Securities where the attribute satisfy

270
00:11:51,720 --> 00:11:53,220
the policy of the cipher text then we

271
00:11:53,220 --> 00:11:55,740
can reconstruct the coefficient W and

272
00:11:55,740 --> 00:11:58,440
using this coefficient we can now uh

273
00:11:58,440 --> 00:12:00,180
compute the masking term which is the

274
00:12:00,180 --> 00:12:02,279
inner product between Y and Z using this

275
00:12:02,279 --> 00:12:04,800
uh pairing product equation

276
00:12:04,800 --> 00:12:07,560
okay so uh now you see that there is a

277
00:12:07,560 --> 00:12:09,660
problem in this construction because we

278
00:12:09,660 --> 00:12:12,360
do not know GID and Y at the time of

279
00:12:12,360 --> 00:12:16,860
encryption right so uh in in particular

280
00:12:16,860 --> 00:12:19,440
we we cannot use hash and pairing

281
00:12:19,440 --> 00:12:22,920
mechanism to factorize the component utj

282
00:12:22,920 --> 00:12:24,779
so for that we devise a hash

283
00:12:24,779 --> 00:12:26,579
decomposition mechanism where we write

284
00:12:26,579 --> 00:12:28,380
the hash function H as the product of

285
00:12:28,380 --> 00:12:31,200
two independent hash functions H2 and H3

286
00:12:31,200 --> 00:12:33,779
where the inputs of H2 are known to the

287
00:12:33,779 --> 00:12:36,839
encrypted and inputs of H3 are known to

288
00:12:36,839 --> 00:12:38,640
the authority

289
00:12:38,640 --> 00:12:40,680
so using these two hash functions we

290
00:12:40,680 --> 00:12:43,800
will now can I mean we can factorize U T

291
00:12:43,800 --> 00:12:47,040
J into two vectors U T J 2 using

292
00:12:47,040 --> 00:12:50,940
headphone hash function uh two H2 and U

293
00:12:50,940 --> 00:12:54,300
T J 3 using hash function h

294
00:12:54,300 --> 00:12:57,000
so since these two hash functions can be

295
00:12:57,000 --> 00:12:58,920
computed by The Authority because

296
00:12:58,920 --> 00:13:01,920
Authority knows all the inputs uh then

297
00:13:01,920 --> 00:13:04,079
we can replace this security component

298
00:13:04,079 --> 00:13:07,079
by the element twice wise product of

299
00:13:07,079 --> 00:13:09,000
these two vectors

300
00:13:09,000 --> 00:13:11,040
but we cannot simply replace the hash

301
00:13:11,040 --> 00:13:13,459
function H by H2 during encryption right

302
00:13:13,459 --> 00:13:16,079
because in that case decryption will not

303
00:13:16,079 --> 00:13:18,540
work so for that we look into the

304
00:13:18,540 --> 00:13:20,459
decryption equation in particular the

305
00:13:20,459 --> 00:13:24,000
term uh involving c3ij and we recompute

306
00:13:24,000 --> 00:13:25,980
this pairing with the help of hash

307
00:13:25,980 --> 00:13:27,839
function H2 replacing the hash function

308
00:13:27,839 --> 00:13:28,800
h

309
00:13:28,800 --> 00:13:31,019
now in this situation you see that Y is

310
00:13:31,019 --> 00:13:33,300
not known to the encryptor right so if

311
00:13:33,300 --> 00:13:36,480
we remove y from this equation then C 3

312
00:13:36,480 --> 00:13:39,360
i j k can be efficiently computed by the

313
00:13:39,360 --> 00:13:41,579
encrypter because encrypter knows the

314
00:13:41,579 --> 00:13:45,439
all the inputs of the hash function H2

315
00:13:45,720 --> 00:13:48,660
okay now uh last thing is to handle the

316
00:13:48,660 --> 00:13:51,660
hash function H3 but not all the inputs

317
00:13:51,660 --> 00:13:53,820
are known to the encryptor so for that

318
00:13:53,820 --> 00:13:56,100
we sample another layer of uh secure

319
00:13:56,100 --> 00:13:58,800
sharing of zero uh in the in the in the

320
00:13:58,800 --> 00:14:01,800
form of a vector and encode this Vector

321
00:14:01,800 --> 00:14:06,360
in C4 i j using u t j so these elements

322
00:14:06,360 --> 00:14:07,980
plays an important role in the

323
00:14:07,980 --> 00:14:11,160
cancellation of u t j k three uh of

324
00:14:11,160 --> 00:14:13,320
security during encryption

325
00:14:13,320 --> 00:14:15,600
okay so due to this in introduction of

326
00:14:15,600 --> 00:14:18,420
new hash functions H2 and H3 the

327
00:14:18,420 --> 00:14:20,459
decryption equation will now change it

328
00:14:20,459 --> 00:14:22,800
will involve both hash function H2 and

329
00:14:22,800 --> 00:14:26,579
H3 so H2 is implicit in C3 i j k and

330
00:14:26,579 --> 00:14:30,138
during decryption we will compute

331
00:14:30,779 --> 00:14:33,959
ok so this is the final scheme uh of our

332
00:14:33,959 --> 00:14:37,860
small Universe uh maapu ipfe so here we

333
00:14:37,860 --> 00:14:40,560
note that the size of public key for

334
00:14:40,560 --> 00:14:43,139
each authorities constant secret key

335
00:14:43,139 --> 00:14:46,500
succinct it contains only one G2 element

336
00:14:46,500 --> 00:14:49,380
and the cipher text size is input

337
00:14:49,380 --> 00:14:51,240
specific

338
00:14:51,240 --> 00:14:53,820
yeah so I will conclude my talk in this

339
00:14:53,820 --> 00:14:57,360
slide so uh we we Define and construct a

340
00:14:57,360 --> 00:15:00,260
large universe

341
00:15:00,480 --> 00:15:03,779
with constant size public Keys succinct

342
00:15:03,779 --> 00:15:06,779
Keys secret keys and input specific

343
00:15:06,779 --> 00:15:10,800
Cipher text size we uh we allow each

344
00:15:10,800 --> 00:15:12,899
authority to control arbitrary number of

345
00:15:12,899 --> 00:15:15,300
attributes and we build this primitive

346
00:15:15,300 --> 00:15:17,579
in Prime order pairing groups

347
00:15:17,579 --> 00:15:20,519
and we prove static security under 8

348
00:15:20,519 --> 00:15:22,500
dbdh type assumption which is a target

349
00:15:22,500 --> 00:15:24,420
group assumption and Target group

350
00:15:24,420 --> 00:15:26,220
assumptions are known to be

351
00:15:26,220 --> 00:15:29,220
qualitatively weaker than source group

352
00:15:29,220 --> 00:15:31,560
assumptions considered by previous work

353
00:15:31,560 --> 00:15:33,600
of agrawal at all

354
00:15:33,600 --> 00:15:35,639
okay so I will finish my talk with

355
00:15:35,639 --> 00:15:37,680
couple of open problems

356
00:15:37,680 --> 00:15:39,720
so we achieved static Security in our

357
00:15:39,720 --> 00:15:42,180
paper so it is an interesting direction

358
00:15:42,180 --> 00:15:44,639
to consider selective or adaptive

359
00:15:44,639 --> 00:15:46,740
security under Target group based

360
00:15:46,740 --> 00:15:48,660
assumption for the primitive another

361
00:15:48,660 --> 00:15:51,360
interesting open problem is to uh see

362
00:15:51,360 --> 00:15:53,160
whether we can achieve adaptive

363
00:15:53,160 --> 00:15:55,560
corruption from standard assumptions and

364
00:15:55,560 --> 00:15:58,620
of course uh it is a really challenging

365
00:15:58,620 --> 00:16:00,320
problem to uh

366
00:16:00,320 --> 00:16:03,360
problem to consider that means whether

367
00:16:03,360 --> 00:16:07,500
we can construct any a b ipfe or maav

368
00:16:07,500 --> 00:16:10,199
uip from post Quantum assumptions such

369
00:16:10,199 --> 00:16:11,579
as lattices

370
00:16:11,579 --> 00:16:14,399
yeah with that I will finish my talk so

371
00:16:14,399 --> 00:16:16,320
thank you if you have any question

372
00:16:16,320 --> 00:16:18,680
please

373
00:16:19,980 --> 00:16:23,120
confirm the audience

374
00:16:26,760 --> 00:16:30,360
no so okay like thanks to the speaker

375
00:16:30,360 --> 00:16:32,579
again thank you

376
00:16:32,579 --> 00:16:35,239
thank you

377
00:17:11,579 --> 00:17:14,819
okay so our next the next speaker

378
00:17:14,819 --> 00:17:15,540
um

379
00:17:15,540 --> 00:17:19,859
is nikhil vanjani who with lnc

380
00:17:19,859 --> 00:17:24,480
um is uh presenting um uh work on

381
00:17:24,480 --> 00:17:26,220
multi-client inner product encryption

382
00:17:26,220 --> 00:17:27,900
function hiding instantiation without

383
00:17:27,900 --> 00:17:30,720
the random Oracle so thank you nikhil

384
00:17:30,720 --> 00:17:34,760
your floor is yours yeah

385
00:17:36,179 --> 00:17:37,740
thank you

386
00:17:37,740 --> 00:17:39,660
um I'm nikhil vanjani I'm a second year

387
00:17:39,660 --> 00:17:41,520
PhD student at Carnegie Mellon

388
00:17:41,520 --> 00:17:43,799
University and I'm going to present my

389
00:17:43,799 --> 00:17:45,900
work on multi-client inner product

390
00:17:45,900 --> 00:17:47,760
encryption function hiding

391
00:17:47,760 --> 00:17:50,880
instantiations without random oracles

392
00:17:50,880 --> 00:17:52,740
this is Joint work with my advisor

393
00:17:52,740 --> 00:17:55,140
Elaine she

394
00:17:55,140 --> 00:17:57,179
let me introduce the problem of

395
00:17:57,179 --> 00:17:59,820
multi-client functional encryption with

396
00:17:59,820 --> 00:18:02,340
a motivating example so suppose that

397
00:18:02,340 --> 00:18:03,840
there is a medical research organization

398
00:18:03,840 --> 00:18:06,660
that has partnered up with in hospitals

399
00:18:06,660 --> 00:18:10,500
and it wants to compute some

400
00:18:10,500 --> 00:18:12,480
functionality on the patient data that

401
00:18:12,480 --> 00:18:14,820
it collects from the hospitals

402
00:18:14,820 --> 00:18:17,880
and suppose that this data is streaming

403
00:18:17,880 --> 00:18:20,400
meaning that there are some time steps T

404
00:18:20,400 --> 00:18:22,440
associated with every data that the

405
00:18:22,440 --> 00:18:25,919
hospital sent and uh

406
00:18:25,919 --> 00:18:28,860
the functionality is also based on these

407
00:18:28,860 --> 00:18:31,980
time steps for example uh the data could

408
00:18:31,980 --> 00:18:34,140
be about

409
00:18:34,140 --> 00:18:36,480
daily number of cases

410
00:18:36,480 --> 00:18:39,419
reported by every hospital and the

411
00:18:39,419 --> 00:18:41,240
organization could want to

412
00:18:41,240 --> 00:18:45,000
learn uh some linear regression model to

413
00:18:45,000 --> 00:18:47,640
predict the number of cases in

414
00:18:47,640 --> 00:18:49,200
subsequent days

415
00:18:49,200 --> 00:18:51,780
so if we do not care about the privacy

416
00:18:51,780 --> 00:18:54,120
of patient data what we can do is all

417
00:18:54,120 --> 00:18:55,799
the hospitals can just send the data in

418
00:18:55,799 --> 00:18:56,760
the plane

419
00:18:56,760 --> 00:18:59,460
and the organization can compute the

420
00:18:59,460 --> 00:19:02,340
function as it is but we know that uh

421
00:19:02,340 --> 00:19:05,820
patient data is often sensitive and we

422
00:19:05,820 --> 00:19:08,460
can't give it out to the organization in

423
00:19:08,460 --> 00:19:12,960
plane so what can we do about it

424
00:19:12,960 --> 00:19:13,980
well

425
00:19:13,980 --> 00:19:17,100
a simple idea could be that we can have

426
00:19:17,100 --> 00:19:19,440
all the hospitals encrypt the data and

427
00:19:19,440 --> 00:19:21,419
sent to the organization

428
00:19:21,419 --> 00:19:23,520
but then the challenge is how can the

429
00:19:23,520 --> 00:19:25,380
organization compete on this encrypted

430
00:19:25,380 --> 00:19:26,700
data

431
00:19:26,700 --> 00:19:29,760
we know that traditional encryption

432
00:19:29,760 --> 00:19:31,679
provides You All or Nothing access to

433
00:19:31,679 --> 00:19:34,620
encrypted data meaning that if you have

434
00:19:34,620 --> 00:19:36,840
the decryption key then you can learn

435
00:19:36,840 --> 00:19:38,520
everything about the underlying plain

436
00:19:38,520 --> 00:19:40,080
text or if you do not have the key

437
00:19:40,080 --> 00:19:42,360
you'll learn nothing whereas over here

438
00:19:42,360 --> 00:19:44,100
we need to provide some fine grade

439
00:19:44,100 --> 00:19:46,919
Access Control to the data meaning that

440
00:19:46,919 --> 00:19:48,299
the organization should be able to learn

441
00:19:48,299 --> 00:19:50,640
only a function on the messages not all

442
00:19:50,640 --> 00:19:53,160
the messages themselves and as

443
00:19:53,160 --> 00:19:55,140
introduced in the previous talk uh

444
00:19:55,140 --> 00:19:58,100
functional encryption provides a way to

445
00:19:58,100 --> 00:20:00,840
solve this problem essentially

446
00:20:00,840 --> 00:20:04,140
what we have over here is we can use a

447
00:20:04,140 --> 00:20:06,360
master key to come up with some

448
00:20:06,360 --> 00:20:08,820
functional keys for function f and then

449
00:20:08,820 --> 00:20:11,780
these functional keys can be used to

450
00:20:11,780 --> 00:20:15,419
decrypt a message X to learn only f of x

451
00:20:15,419 --> 00:20:19,280
and know more about the message

452
00:20:20,700 --> 00:20:23,820
and if we want to consider the case of

453
00:20:23,820 --> 00:20:27,059
uh multiple clients then multi-client

454
00:20:27,059 --> 00:20:28,620
functional encryption provides a way to

455
00:20:28,620 --> 00:20:30,360
generalize to this setting

456
00:20:30,360 --> 00:20:33,000
what this means is instead of a single

457
00:20:33,000 --> 00:20:35,940
Cipher text now we have n number of

458
00:20:35,940 --> 00:20:39,299
ciphertexts that we want to decrypt and

459
00:20:39,299 --> 00:20:42,000
the functionalities that we will learn

460
00:20:42,000 --> 00:20:44,400
is f of X1 through x n instead of just f

461
00:20:44,400 --> 00:20:46,760
of x

462
00:20:47,100 --> 00:20:49,679
so uh

463
00:20:49,679 --> 00:20:51,900
over here we have some time step T

464
00:20:51,900 --> 00:20:53,960
associated with all of these messages

465
00:20:53,960 --> 00:20:57,240
the reason over here is that

466
00:20:57,240 --> 00:20:59,220
we want to control what the decrypter

467
00:20:59,220 --> 00:21:01,860
can learn so if the decryption is

468
00:21:01,860 --> 00:21:03,780
performed on N ciphertext corresponding

469
00:21:03,780 --> 00:21:05,400
to the same time step then you can

470
00:21:05,400 --> 00:21:07,380
actually learn the functionality if you

471
00:21:07,380 --> 00:21:09,240
try to mix and match ciphertext from

472
00:21:09,240 --> 00:21:12,360
different time steps then you should not

473
00:21:12,360 --> 00:21:14,340
learn the function output and you should

474
00:21:14,340 --> 00:21:16,320
just get some garbage value this will

475
00:21:16,320 --> 00:21:19,679
ensure that the cipher text I use as

476
00:21:19,679 --> 00:21:22,080
intended

477
00:21:22,080 --> 00:21:25,500
so let me introduce the four algorithms

478
00:21:25,500 --> 00:21:28,440
involved in mcfe with uh the motivating

479
00:21:28,440 --> 00:21:30,960
example I showed so there's a setup

480
00:21:30,960 --> 00:21:32,760
algorithm which is run by a trusted

481
00:21:32,760 --> 00:21:34,620
Authority

482
00:21:34,620 --> 00:21:36,659
it outputs a master key to the trusted

483
00:21:36,659 --> 00:21:38,820
Authority and

484
00:21:38,820 --> 00:21:39,960
and

485
00:21:39,960 --> 00:21:43,320
encryption Keys one to each client in

486
00:21:43,320 --> 00:21:46,260
this case one to each Hospital

487
00:21:46,260 --> 00:21:49,140
now suppose that uh all the hospitals

488
00:21:49,140 --> 00:21:52,020
have their encryption keys and they want

489
00:21:52,020 --> 00:21:54,299
to encrypt a bunch of messages X1

490
00:21:54,299 --> 00:21:56,520
through xn for some time step T what

491
00:21:56,520 --> 00:21:57,900
they can do is they can perform a

492
00:21:57,900 --> 00:22:01,380
locally encryption algorithm with their

493
00:22:01,380 --> 00:22:03,480
keys to come up with these ciphertext

494
00:22:03,480 --> 00:22:06,600
highlighted in this gray boxes

495
00:22:06,600 --> 00:22:09,419
and send the cipher text to the research

496
00:22:09,419 --> 00:22:12,020
organization

497
00:22:13,320 --> 00:22:15,539
now that the research organization has

498
00:22:15,539 --> 00:22:17,940
all the ciphertexts and say it wants to

499
00:22:17,940 --> 00:22:20,220
compute this function f on it

500
00:22:20,220 --> 00:22:22,799
it can send this request to The Trusted

501
00:22:22,799 --> 00:22:25,020
Authority and The Trusted Authority can

502
00:22:25,020 --> 00:22:27,419
use its master key to run a Keygen

503
00:22:27,419 --> 00:22:29,400
algorithm and come up with a

504
00:22:29,400 --> 00:22:31,860
functionality which it can send back to

505
00:22:31,860 --> 00:22:35,039
the research organization

506
00:22:35,039 --> 00:22:37,559
and now that this organization has the

507
00:22:37,559 --> 00:22:39,780
key and all of the cipher texts it can

508
00:22:39,780 --> 00:22:42,659
run a local decryption algorithm to

509
00:22:42,659 --> 00:22:45,360
learn uh the function f of X1 through x

510
00:22:45,360 --> 00:22:48,740
n as required

511
00:22:48,780 --> 00:22:51,600
so this is how we can use multi-client

512
00:22:51,600 --> 00:22:53,280
functional encryption to solve this

513
00:22:53,280 --> 00:22:54,780
problem

514
00:22:54,780 --> 00:22:57,360
now those who are familiar with fully

515
00:22:57,360 --> 00:22:59,100
homomorphic encryption could ask how is

516
00:22:59,100 --> 00:23:01,860
this different from uh that

517
00:23:01,860 --> 00:23:05,100
the difference is that over here in mcfe

518
00:23:05,100 --> 00:23:07,440
when you run some computations on

519
00:23:07,440 --> 00:23:09,900
encrypted data you get F of X1 through x

520
00:23:09,900 --> 00:23:12,720
n in the plane whereas in fhe you get a

521
00:23:12,720 --> 00:23:15,000
encryption of f of X1 through x n so

522
00:23:15,000 --> 00:23:17,100
that's the key difference and that leads

523
00:23:17,100 --> 00:23:18,780
to differences in what are the

524
00:23:18,780 --> 00:23:22,500
application scenarios for both

525
00:23:22,500 --> 00:23:24,419
so I hope by this point of time I have

526
00:23:24,419 --> 00:23:26,820
motivated to you that mcfe is a

527
00:23:26,820 --> 00:23:28,500
interesting cryptographic primitive to

528
00:23:28,500 --> 00:23:30,600
study

529
00:23:30,600 --> 00:23:33,960
now in our paper we study the function

530
00:23:33,960 --> 00:23:37,140
hiding security of mcfe intuitively what

531
00:23:37,140 --> 00:23:38,580
this means is

532
00:23:38,580 --> 00:23:40,919
the ciphertext for X1 should hide the

533
00:23:40,919 --> 00:23:42,960
message X1 and so on for all the N

534
00:23:42,960 --> 00:23:43,919
messages

535
00:23:43,919 --> 00:23:46,260
further and more importantly the

536
00:23:46,260 --> 00:23:47,940
function key for f should hide the

537
00:23:47,940 --> 00:23:49,700
function f

538
00:23:49,700 --> 00:23:52,440
and uh the decrypter should learn only F

539
00:23:52,440 --> 00:23:54,840
of X1 through x n and no more about the

540
00:23:54,840 --> 00:23:57,120
messages X1 through xn and the function

541
00:23:57,120 --> 00:23:59,418
f

542
00:24:00,059 --> 00:24:03,059
secondly uh we study function hiding

543
00:24:03,059 --> 00:24:05,159
security of mcfe for a specific class of

544
00:24:05,159 --> 00:24:08,100
functions called inner product functions

545
00:24:08,100 --> 00:24:10,020
as introduced in the previous talk so

546
00:24:10,020 --> 00:24:12,900
inner products are as follows we have a

547
00:24:12,900 --> 00:24:15,539
vector Y which is uh comprising of Y 1

548
00:24:15,539 --> 00:24:17,220
through y n and the functionality then

549
00:24:17,220 --> 00:24:19,799
is just in a product X1 through x n with

550
00:24:19,799 --> 00:24:22,559
Y 1 through y n and this is just the sum

551
00:24:22,559 --> 00:24:26,960
of x i y i for all I and N

552
00:24:27,240 --> 00:24:29,760
now you may ask why is function hiding

553
00:24:29,760 --> 00:24:32,760
mcip interesting well it's interesting

554
00:24:32,760 --> 00:24:35,280
when we want to perform uh when when we

555
00:24:35,280 --> 00:24:37,260
want to delegate computations to an

556
00:24:37,260 --> 00:24:39,419
understate server

557
00:24:39,419 --> 00:24:41,940
and more specifically when the

558
00:24:41,940 --> 00:24:43,679
decryption inherently needs to be

559
00:24:43,679 --> 00:24:46,080
performed by some understate server this

560
00:24:46,080 --> 00:24:48,720
function hiding security is interesting

561
00:24:48,720 --> 00:24:51,360
let me give you a quick example

562
00:24:51,360 --> 00:24:54,480
so uh she and Wu considered this notion

563
00:24:54,480 --> 00:24:57,059
of non-interactive anonymous routing and

564
00:24:57,059 --> 00:24:58,860
they proposed a new model to capture

565
00:24:58,860 --> 00:25:01,620
Anonymous routing as follows we have n

566
00:25:01,620 --> 00:25:03,539
senders and N receivers who are trying

567
00:25:03,539 --> 00:25:05,159
to communicate anonymously with each

568
00:25:05,159 --> 00:25:06,000
other

569
00:25:06,000 --> 00:25:09,240
and this task needs to be facilitated by

570
00:25:09,240 --> 00:25:11,220
a single untrusted router instead of a

571
00:25:11,220 --> 00:25:13,740
bunch of routers and

572
00:25:13,740 --> 00:25:16,080
they showed how to use multi-client

573
00:25:16,080 --> 00:25:17,400
functional encryption which is function

574
00:25:17,400 --> 00:25:19,559
hiding for a specific class of functions

575
00:25:19,559 --> 00:25:22,320
select that is selection function

576
00:25:22,320 --> 00:25:24,779
and they showed how it can be used the

577
00:25:24,779 --> 00:25:27,059
idea over there is each of the senders

578
00:25:27,059 --> 00:25:28,140
can send

579
00:25:28,140 --> 00:25:30,720
the destinations that they want to talk

580
00:25:30,720 --> 00:25:34,200
to to this trusted Authority and based

581
00:25:34,200 --> 00:25:35,940
on that it can come up with this

582
00:25:35,940 --> 00:25:39,000
permutation pi and a function key for

583
00:25:39,000 --> 00:25:41,820
this permutation Pi which it can send to

584
00:25:41,820 --> 00:25:43,860
this untrusted router

585
00:25:43,860 --> 00:25:47,100
now clearly this function key that is

586
00:25:47,100 --> 00:25:48,720
providing to the untrusted router should

587
00:25:48,720 --> 00:25:51,000
not reveal the function that is the

588
00:25:51,000 --> 00:25:52,980
permutation over here for obvious

589
00:25:52,980 --> 00:25:55,799
reasons because of anonymity and hence

590
00:25:55,799 --> 00:25:58,440
uh in such scenarios function hiding MC

591
00:25:58,440 --> 00:26:01,940
f is interesting

592
00:26:03,419 --> 00:26:06,000
so what do we know about function hiding

593
00:26:06,000 --> 00:26:07,679
mcip

594
00:26:07,679 --> 00:26:10,140
we have only one construction so far by

595
00:26:10,140 --> 00:26:13,140
agrawal goel and domida they showed how

596
00:26:13,140 --> 00:26:14,520
to construct it from standard

597
00:26:14,520 --> 00:26:16,919
assumptions on bilinear maps

598
00:26:16,919 --> 00:26:19,260
and to prove security of their

599
00:26:19,260 --> 00:26:20,159
Construction

600
00:26:20,159 --> 00:26:22,919
uh they had to make two significant

601
00:26:22,919 --> 00:26:24,240
relaxations

602
00:26:24,240 --> 00:26:26,520
the first is they could only show how to

603
00:26:26,520 --> 00:26:29,039
prove it to be selectively secure

604
00:26:29,039 --> 00:26:30,960
we won't go into the specific details of

605
00:26:30,960 --> 00:26:32,820
selective Security today but all you

606
00:26:32,820 --> 00:26:34,500
need to know is selective security is

607
00:26:34,500 --> 00:26:36,659
imposing some strong restriction on the

608
00:26:36,659 --> 00:26:39,360
adversaries capabilities

609
00:26:39,360 --> 00:26:42,120
secondly they showed how to prove it in

610
00:26:42,120 --> 00:26:45,840
the random Oracle model and uh we use

611
00:26:45,840 --> 00:26:48,240
random oracles as a heuristic but we

612
00:26:48,240 --> 00:26:50,100
know that random oracles do not really

613
00:26:50,100 --> 00:26:53,039
exist so the question then is can we

614
00:26:53,039 --> 00:26:55,200
construct a fully secure function hiding

615
00:26:55,200 --> 00:26:57,240
mcip from any standard assumption in the

616
00:26:57,240 --> 00:26:58,620
plane model

617
00:26:58,620 --> 00:27:00,659
and we

618
00:27:00,659 --> 00:27:03,320
show the first such result we prove

619
00:27:03,320 --> 00:27:06,299
fully secure function hiding mcip from

620
00:27:06,299 --> 00:27:08,220
standard assumptions on bilinear maps in

621
00:27:08,220 --> 00:27:10,760
the plane model

622
00:27:12,419 --> 00:27:15,000
so the roadmap Forest of the talk is

623
00:27:15,000 --> 00:27:16,679
going to be as follows to build some

624
00:27:16,679 --> 00:27:20,460
intuition I will uh first uh show some

625
00:27:20,460 --> 00:27:21,960
warm-up exercise

626
00:27:21,960 --> 00:27:24,360
and then I will show how our

627
00:27:24,360 --> 00:27:26,279
construction works and lastly I will

628
00:27:26,279 --> 00:27:27,779
briefly talk about how to prove security

629
00:27:27,779 --> 00:27:30,179
of our Construction

630
00:27:30,179 --> 00:27:33,179
let's start up with the warm-up

631
00:27:33,179 --> 00:27:34,919
first I will tell you about a knife

632
00:27:34,919 --> 00:27:37,140
scheme that is going to be insecure and

633
00:27:37,140 --> 00:27:38,580
then I will briefly talk about how the

634
00:27:38,580 --> 00:27:41,820
previous work uh makes that scheme

635
00:27:41,820 --> 00:27:44,360
secure

636
00:27:44,640 --> 00:27:47,279
so for the night scheme what we will

637
00:27:47,279 --> 00:27:50,340
start with is just uh function hiding in

638
00:27:50,340 --> 00:27:52,500
a product encryption this is a special

639
00:27:52,500 --> 00:27:55,320
case of uh mcfe where there is only a

640
00:27:55,320 --> 00:27:56,640
single client

641
00:27:56,640 --> 00:27:59,520
specifically now what we have is just a

642
00:27:59,520 --> 00:28:01,320
setup algorithm outputs a master key

643
00:28:01,320 --> 00:28:04,140
which also acts as the encryption key

644
00:28:04,140 --> 00:28:05,940
the encryption algorithm is same as

645
00:28:05,940 --> 00:28:07,200
before

646
00:28:07,200 --> 00:28:10,860
and we get a cipher text

647
00:28:10,860 --> 00:28:13,080
the only difference is that now the

648
00:28:13,080 --> 00:28:14,520
encryption algorithm does not have any

649
00:28:14,520 --> 00:28:16,140
time steps T associated with it because

650
00:28:16,140 --> 00:28:19,020
there is only a single client

651
00:28:19,020 --> 00:28:22,500
second the Keygen algorithm is also same

652
00:28:22,500 --> 00:28:24,779
as before the only difference is it

653
00:28:24,779 --> 00:28:27,779
operates on a unary function y1 and

654
00:28:27,779 --> 00:28:30,419
outputs a key for y1 and the decryption

655
00:28:30,419 --> 00:28:33,179
algorithm outputs in a product X1 y1

656
00:28:33,179 --> 00:28:35,640
instead of sum of a bunch of inner

657
00:28:35,640 --> 00:28:38,000
products

658
00:28:38,580 --> 00:28:42,840
so the warm-up that we will do is can we

659
00:28:42,840 --> 00:28:45,120
simply use n instances of inner product

660
00:28:45,120 --> 00:28:46,500
encryption

661
00:28:46,500 --> 00:28:48,960
one instance for each client and what

662
00:28:48,960 --> 00:28:51,419
can we get out of this

663
00:28:51,419 --> 00:28:54,779
so what we can do is in the trusted uh

664
00:28:54,779 --> 00:28:56,520
in the setup algorithm run by The

665
00:28:56,520 --> 00:29:00,120
Trusted Authority it can run one in one

666
00:29:00,120 --> 00:29:02,419
setup of IP for each of the instances

667
00:29:02,419 --> 00:29:05,880
and provide one master key to each of

668
00:29:05,880 --> 00:29:08,100
the clients and the master key of The

669
00:29:08,100 --> 00:29:10,020
Trusted Authority is just the union of

670
00:29:10,020 --> 00:29:12,120
all of these keys

671
00:29:12,120 --> 00:29:15,419
equipped with this Keys the hospitals

672
00:29:15,419 --> 00:29:16,799
can locally

673
00:29:16,799 --> 00:29:17,400
um

674
00:29:17,400 --> 00:29:18,899
compute the encryptions on their

675
00:29:18,899 --> 00:29:20,159
messages

676
00:29:20,159 --> 00:29:22,620
then suppose you want to compute a

677
00:29:22,620 --> 00:29:24,360
functional key for y equal to Y one

678
00:29:24,360 --> 00:29:27,059
through y n what you can do is uh

679
00:29:27,059 --> 00:29:30,120
observe that each y i corresponds to the

680
00:29:30,120 --> 00:29:33,059
ith client so we can use the ith clients

681
00:29:33,059 --> 00:29:36,720
master key of the IP to come up with a

682
00:29:36,720 --> 00:29:39,419
function key and then the function key

683
00:29:39,419 --> 00:29:41,640
for y will be just the union of all of

684
00:29:41,640 --> 00:29:43,679
these keys

685
00:29:43,679 --> 00:29:47,100
and now that the organization has uh all

686
00:29:47,100 --> 00:29:49,260
of these ciphertext and the keys what it

687
00:29:49,260 --> 00:29:50,480
can do is

688
00:29:50,480 --> 00:29:52,919
run the decryption of all of these

689
00:29:52,919 --> 00:29:55,740
instances locally and obtain uh in a

690
00:29:55,740 --> 00:29:58,740
product X1 y1 and so on up to X and Y N

691
00:29:58,740 --> 00:30:01,380
and just sum up all of these values to

692
00:30:01,380 --> 00:30:04,140
obtain the desired output

693
00:30:04,140 --> 00:30:06,539
well uh

694
00:30:06,539 --> 00:30:09,000
the hope then is that if the underlying

695
00:30:09,000 --> 00:30:10,620
IP is function hiding secure then so

696
00:30:10,620 --> 00:30:13,620
should the resulting mcip scheme be

697
00:30:13,620 --> 00:30:15,899
and it turns out that this scheme

698
00:30:15,899 --> 00:30:17,460
actually suffers from three problems

699
00:30:17,460 --> 00:30:20,100
first that it reveals every user's inner

700
00:30:20,100 --> 00:30:21,779
product as we just saw in the decryption

701
00:30:21,779 --> 00:30:24,600
algorithm this is leaking more info than

702
00:30:24,600 --> 00:30:26,940
intended by the functionality

703
00:30:26,940 --> 00:30:28,620
second it allows mix and match of

704
00:30:28,620 --> 00:30:30,419
ciphertext across different time steps

705
00:30:30,419 --> 00:30:32,039
this is because we did not use time

706
00:30:32,039 --> 00:30:34,559
steps in any way so far thirdly it

707
00:30:34,559 --> 00:30:35,940
allows for mix and match of function

708
00:30:35,940 --> 00:30:38,940
secret keys this is because the function

709
00:30:38,940 --> 00:30:41,640
key was just a set of keys and there is

710
00:30:41,640 --> 00:30:44,100
no way to prevent uh mixing across two

711
00:30:44,100 --> 00:30:45,720
different sets

712
00:30:45,720 --> 00:30:47,940
and the previous work uh

713
00:30:47,940 --> 00:30:49,919
resolves all of these three problems by

714
00:30:49,919 --> 00:30:51,179
coming up with some coordinated

715
00:30:51,179 --> 00:30:53,760
Randomness among all the clients

716
00:30:53,760 --> 00:30:56,159
crucially it uh

717
00:30:56,159 --> 00:30:58,260
comes with this coordinated Randomness

718
00:30:58,260 --> 00:31:00,419
using hash functions that need to be

719
00:31:00,419 --> 00:31:03,299
modeled as random Oracle for their paper

720
00:31:03,299 --> 00:31:05,460
so the question then is is there an

721
00:31:05,460 --> 00:31:06,899
alternate way to coordinate Randomness

722
00:31:06,899 --> 00:31:09,179
and how to prove security for such a

723
00:31:09,179 --> 00:31:10,940
scheme

724
00:31:10,940 --> 00:31:15,960
and uh let me show how we can construct

725
00:31:15,960 --> 00:31:17,659
uh our

726
00:31:17,659 --> 00:31:20,520
scheme so to coordinate Randomness we

727
00:31:20,520 --> 00:31:22,799
will use a new building block called

728
00:31:22,799 --> 00:31:25,799
correlated prfs and we will show how it

729
00:31:25,799 --> 00:31:27,000
can be used

730
00:31:27,000 --> 00:31:30,480
so correlated prfs is similar to uh just

731
00:31:30,480 --> 00:31:32,940
normal prfs it has two algorithms set up

732
00:31:32,940 --> 00:31:35,340
and evaluate the setup algorithm outputs

733
00:31:35,340 --> 00:31:37,320
a bunch of prf keys and the evaluation

734
00:31:37,320 --> 00:31:39,600
algorithm can evaluate on some messages

735
00:31:39,600 --> 00:31:41,039
t

736
00:31:41,039 --> 00:31:42,720
the interesting property compared to

737
00:31:42,720 --> 00:31:44,340
normal pseudo random functions is that

738
00:31:44,340 --> 00:31:47,100
the sum of evaluations now on the same

739
00:31:47,100 --> 00:31:50,279
input is going to be zero secondly if

740
00:31:50,279 --> 00:31:52,440
you use different inputs T and try to

741
00:31:52,440 --> 00:31:55,440
sum up uh all these Ki of T values then

742
00:31:55,440 --> 00:31:57,299
the sum is going to be junk

743
00:31:57,299 --> 00:32:00,600
and it was shown in some previous papers

744
00:32:00,600 --> 00:32:03,419
that cprfs can be constructed from

745
00:32:03,419 --> 00:32:04,980
standard prfs

746
00:32:04,980 --> 00:32:09,299
so how can we use cprfs in our uh scheme

747
00:32:09,299 --> 00:32:11,820
the idea is to expand the vectors by one

748
00:32:11,820 --> 00:32:14,460
more slot and now the client one will

749
00:32:14,460 --> 00:32:19,200
encrypt not X1 but X1 comma K1 of T and

750
00:32:19,200 --> 00:32:21,659
over here T is the time step t

751
00:32:21,659 --> 00:32:24,779
and so on for all the end clients

752
00:32:24,779 --> 00:32:28,020
next for the function keys for the first

753
00:32:28,020 --> 00:32:29,940
point it will be corresponding to y1

754
00:32:29,940 --> 00:32:32,039
comma Z and so on for the nth client it

755
00:32:32,039 --> 00:32:34,380
will be for y n comma Z

756
00:32:34,380 --> 00:32:36,779
crucially note over here that Z is

757
00:32:36,779 --> 00:32:38,520
shared by all of the clients which is

758
00:32:38,520 --> 00:32:40,919
okay because the function uh key

759
00:32:40,919 --> 00:32:42,299
generation is performed by a trusted

760
00:32:42,299 --> 00:32:45,179
Authority secondly this is fresh and

761
00:32:45,179 --> 00:32:47,640
random for each of the queries what this

762
00:32:47,640 --> 00:32:49,860
results in is the partial decryptions

763
00:32:49,860 --> 00:32:51,899
have these red masking terms that we see

764
00:32:51,899 --> 00:32:53,520
and

765
00:32:53,520 --> 00:32:56,940
when we sum up all of the values uh the

766
00:32:56,940 --> 00:32:58,799
masking terms cancel out because of the

767
00:32:58,799 --> 00:33:02,279
property of correlated prfs

768
00:33:02,279 --> 00:33:05,039
now is this scheme secure

769
00:33:05,039 --> 00:33:07,620
it turns out that to prove security we

770
00:33:07,620 --> 00:33:09,179
need to argue that each of these masking

771
00:33:09,179 --> 00:33:11,700
terms look random for all honest clients

772
00:33:11,700 --> 00:33:14,220
and

773
00:33:14,220 --> 00:33:16,380
as I mentioned earlier we are using all

774
00:33:16,380 --> 00:33:17,940
of these black boxes are in a product

775
00:33:17,940 --> 00:33:19,260
encryption schemes which are function

776
00:33:19,260 --> 00:33:21,539
hiding secure and all the function

777
00:33:21,539 --> 00:33:23,100
hiding IP schemes we know are from

778
00:33:23,100 --> 00:33:25,860
bilinear maps and when we instantiate

779
00:33:25,860 --> 00:33:28,140
with any of these schemes we run into a

780
00:33:28,140 --> 00:33:30,000
problem that these terms do not look

781
00:33:30,000 --> 00:33:32,580
random due to some ddh style attack so

782
00:33:32,580 --> 00:33:34,919
the solution then is we want to encrypt

783
00:33:34,919 --> 00:33:38,399
each of these kit and what we have now

784
00:33:38,399 --> 00:33:41,279
is the client one will encrypt X1 comma

785
00:33:41,279 --> 00:33:44,100
K1 t plus A1 R1 comma R1

786
00:33:44,100 --> 00:33:46,440
and so on for all the inclines here

787
00:33:46,440 --> 00:33:48,480
these AI values are part of the client

788
00:33:48,480 --> 00:33:51,360
encryption keys and uh RIS are just some

789
00:33:51,360 --> 00:33:52,620
randomness

790
00:33:52,620 --> 00:33:55,080
now how does it look to be an encryption

791
00:33:55,080 --> 00:33:56,340
of kit

792
00:33:56,340 --> 00:33:59,820
uh note over here that the IP scheme we

793
00:33:59,820 --> 00:34:01,500
use is for computing inner products in

794
00:34:01,500 --> 00:34:02,760
the exponent

795
00:34:02,760 --> 00:34:04,740
meaning that what we are actually

796
00:34:04,740 --> 00:34:08,580
Computing is uh encrypting this Vector G

797
00:34:08,580 --> 00:34:11,460
raised to x 1 G raised to K 1 t plus A1

798
00:34:11,460 --> 00:34:13,859
R1 comma G raised to R1 and now the

799
00:34:13,859 --> 00:34:15,780
second and third terms look like alga

800
00:34:15,780 --> 00:34:18,000
Mall style encryption so this

801
00:34:18,000 --> 00:34:19,500
intuitively captures how we are

802
00:34:19,500 --> 00:34:21,899
encrypting these Ki values

803
00:34:21,899 --> 00:34:24,300
and correspondingly for the function

804
00:34:24,300 --> 00:34:26,820
keys now we have y1 comma Z comma minus

805
00:34:26,820 --> 00:34:30,719
Z times A1 and so on for the all n keys

806
00:34:30,719 --> 00:34:32,820
what this ensures is the correctness is

807
00:34:32,820 --> 00:34:35,879
preserved as follows now when we perform

808
00:34:35,879 --> 00:34:38,399
a partial decryption for the first

809
00:34:38,399 --> 00:34:40,440
client we get the first two terms as

810
00:34:40,440 --> 00:34:41,940
Before We additionally get two other

811
00:34:41,940 --> 00:34:44,280
terms which cancel out among themselves

812
00:34:44,280 --> 00:34:47,339
because all of those values are scalars

813
00:34:47,339 --> 00:34:50,159
and hence the correctness still holds so

814
00:34:50,159 --> 00:34:52,560
this is our construction now let me

815
00:34:52,560 --> 00:34:54,060
quickly tell you about Brewing security

816
00:34:54,060 --> 00:34:56,099
it turns out that proving security is

817
00:34:56,099 --> 00:34:59,640
non-trivial and we first prove selected

818
00:34:59,640 --> 00:35:01,440
security of our scheme and then show how

819
00:35:01,440 --> 00:35:03,599
to prove full security

820
00:35:03,599 --> 00:35:05,700
while I won't go into the details of the

821
00:35:05,700 --> 00:35:08,339
security game today uh I can just

822
00:35:08,339 --> 00:35:10,800
mention that full security considers any

823
00:35:10,800 --> 00:35:12,599
sequence of keys and encryption queries

824
00:35:12,599 --> 00:35:14,579
by the adversary whereas selective

825
00:35:14,579 --> 00:35:16,980
security requires all keys and queries

826
00:35:16,980 --> 00:35:19,980
to be sent before any encryption query

827
00:35:19,980 --> 00:35:22,200
and the key Insight then is

828
00:35:22,200 --> 00:35:24,180
because you are sending all Cajun

829
00:35:24,180 --> 00:35:26,940
queries ahead we you can embed the inner

830
00:35:26,940 --> 00:35:28,619
product X1 y1 in the first lines

831
00:35:28,619 --> 00:35:30,720
ciphertext and then try to come up with

832
00:35:30,720 --> 00:35:33,359
a sequence of hybrids to prove security

833
00:35:33,359 --> 00:35:35,220
this new sequence of hybrids that we

834
00:35:35,220 --> 00:35:36,960
have requires a key identically

835
00:35:36,960 --> 00:35:40,140
distributed step and to enable this step

836
00:35:40,140 --> 00:35:43,920
we use the randomness of k1t and Z to

837
00:35:43,920 --> 00:35:45,359
come up with some masking terms to

838
00:35:45,359 --> 00:35:47,220
perform this step

839
00:35:47,220 --> 00:35:49,800
secondly for full security

840
00:35:49,800 --> 00:35:52,079
because keys and queries can't be sent

841
00:35:52,079 --> 00:35:54,720
ahead of uh encryption queries we can't

842
00:35:54,720 --> 00:35:57,599
embed the inner product X1 y1 and client

843
00:35:57,599 --> 00:35:59,940
one's ciphertext anymore so we need to

844
00:35:59,940 --> 00:36:02,760
come up with a new sequence of hybrids

845
00:36:02,760 --> 00:36:04,920
for this new sequence of hybrids we also

846
00:36:04,920 --> 00:36:06,900
have some identically distributed step

847
00:36:06,900 --> 00:36:10,320
but it turns out that these masking

848
00:36:10,320 --> 00:36:14,640
terms we we can't use them as before so

849
00:36:14,640 --> 00:36:16,740
the key Insight then is we open up the

850
00:36:16,740 --> 00:36:19,440
black box of function hiding IP and use

851
00:36:19,440 --> 00:36:22,560
the randomness of the function case in

852
00:36:22,560 --> 00:36:26,220
this IP to enable the identically

853
00:36:26,220 --> 00:36:27,960
distributed step for this new hybrid

854
00:36:27,960 --> 00:36:29,700
sequence

855
00:36:29,700 --> 00:36:32,220
this completes the technical part of the

856
00:36:32,220 --> 00:36:34,260
talk let me quickly tell you about some

857
00:36:34,260 --> 00:36:36,300
other paper uh some other results in our

858
00:36:36,300 --> 00:36:38,880
paper so you can find the formal

859
00:36:38,880 --> 00:36:40,800
security definitions and proofs in the

860
00:36:40,800 --> 00:36:41,820
paper

861
00:36:41,820 --> 00:36:44,339
lastly the scheme I presented to you

862
00:36:44,339 --> 00:36:47,540
today uh was under a certain restricted

863
00:36:47,540 --> 00:36:49,680
uh scenario

864
00:36:49,680 --> 00:36:54,000
it uh requires the adversary to abide to

865
00:36:54,000 --> 00:36:55,740
some All or Nothing admissibility Rule

866
00:36:55,740 --> 00:36:57,480
and in the paper we show how to remove

867
00:36:57,480 --> 00:36:58,800
this rule using All or Nothing

868
00:36:58,800 --> 00:37:00,900
encryption this also requires

869
00:37:00,900 --> 00:37:04,079
constructing a new uh aoni scheme and we

870
00:37:04,079 --> 00:37:08,040
show how it can be constructed

871
00:37:08,040 --> 00:37:12,660
lastly uh I presented to you today a

872
00:37:12,660 --> 00:37:15,420
function hiding secure mcip from

873
00:37:15,420 --> 00:37:17,160
function hiding IP

874
00:37:17,160 --> 00:37:20,640
and correlated prfs in the plane model

875
00:37:20,640 --> 00:37:22,500
this scheme enjoys two really nice

876
00:37:22,500 --> 00:37:25,140
properties it's much simpler than all

877
00:37:25,140 --> 00:37:27,599
the previous schemes and this includes

878
00:37:27,599 --> 00:37:29,400
function revealing schemes that have

879
00:37:29,400 --> 00:37:31,320
been there before secondly the

880
00:37:31,320 --> 00:37:33,720
ciphertext over here are succinct and

881
00:37:33,720 --> 00:37:35,160
this leads to the first function hiding

882
00:37:35,160 --> 00:37:37,020
mcip from non lattice standard

883
00:37:37,020 --> 00:37:38,940
assumptions in the plane model with

884
00:37:38,940 --> 00:37:40,980
success in Cypher text size this was not

885
00:37:40,980 --> 00:37:43,380
known before

886
00:37:43,380 --> 00:37:45,480
and I will leave you with two open

887
00:37:45,480 --> 00:37:47,220
questions how to handle adaptive

888
00:37:47,220 --> 00:37:48,359
Corruptions without performing

889
00:37:48,359 --> 00:37:50,400
complexity leveraging is a challenging

890
00:37:50,400 --> 00:37:52,680
problem and secondly how to decentralize

891
00:37:52,680 --> 00:37:54,780
the trusted and get rid of trusted

892
00:37:54,780 --> 00:37:56,579
authority to come up with Dynamic

893
00:37:56,579 --> 00:37:58,560
decentralized function functional

894
00:37:58,560 --> 00:38:00,900
encryption is also an open problem

895
00:38:00,900 --> 00:38:03,720
and with that I will thank you for your

896
00:38:03,720 --> 00:38:05,899
time

897
00:38:10,579 --> 00:38:13,020
I think we don't have real time for

898
00:38:13,020 --> 00:38:15,480
questions so we move on to the next

899
00:38:15,480 --> 00:38:17,820
speaker

900
00:38:17,820 --> 00:38:21,500
thank you nikhil again

901
00:38:46,140 --> 00:38:48,680
for the next talk will be on Google

902
00:38:48,680 --> 00:38:51,000
generalizing and bound unbounded

903
00:38:51,000 --> 00:38:52,680
attribute based encryption for flexible

904
00:38:52,680 --> 00:38:55,940
efficiency trade-offs

905
00:38:57,260 --> 00:39:00,180
will be will give the talk thank you

906
00:39:00,180 --> 00:39:01,560
very much yes

907
00:39:01,560 --> 00:39:03,660
for introducing me can everyone hear me

908
00:39:03,660 --> 00:39:07,160
correctly or right

909
00:39:07,260 --> 00:39:09,420
so I'mma lose I will be giving our talk

910
00:39:09,420 --> 00:39:13,020
about uh glue generalizing unbounded

911
00:39:13,020 --> 00:39:14,700
attribute-based encryption for flexible

912
00:39:14,700 --> 00:39:17,779
efficiency trade-off

913
00:39:18,060 --> 00:39:20,280
um I always start my talks a bit with

914
00:39:20,280 --> 00:39:22,260
the motivation which is a sort of very

915
00:39:22,260 --> 00:39:24,599
high level summary of the work that I

916
00:39:24,599 --> 00:39:28,500
did and also uh the work that so why we

917
00:39:28,500 --> 00:39:30,540
did this work so if you cannot follow

918
00:39:30,540 --> 00:39:32,160
everything that's fine I will explain

919
00:39:32,160 --> 00:39:34,680
everything in the talk but it gives you

920
00:39:34,680 --> 00:39:37,619
a bit of an idea what to expect from The

921
00:39:37,619 --> 00:39:38,760
Talk

922
00:39:38,760 --> 00:39:41,520
so attribute based encryption or Abe for

923
00:39:41,520 --> 00:39:44,760
short is a very versatile primitive it

924
00:39:44,760 --> 00:39:47,099
can actually enforce access control on a

925
00:39:47,099 --> 00:39:49,740
cryptographic level and for that reason

926
00:39:49,740 --> 00:39:52,020
it's actually been considered pretty

927
00:39:52,020 --> 00:39:54,359
extensively to securely manage access to

928
00:39:54,359 --> 00:39:55,440
data

929
00:39:55,440 --> 00:39:57,480
and what we see in literature is

930
00:39:57,480 --> 00:39:59,700
actually various properties that can be

931
00:39:59,700 --> 00:40:03,180
supported in Abe so you can think of for

932
00:40:03,180 --> 00:40:05,359
instance the unlimited use of attributes

933
00:40:05,359 --> 00:40:09,900
or the support of negations or not

934
00:40:09,900 --> 00:40:12,300
uh and whether I actually need these

935
00:40:12,300 --> 00:40:14,040
properties really depends on the

936
00:40:14,040 --> 00:40:17,339
application in which we want to apply it

937
00:40:17,339 --> 00:40:20,040
um similarly the efficiency requirements

938
00:40:20,040 --> 00:40:22,079
also really depend on the application in

939
00:40:22,079 --> 00:40:24,240
which we want to apply Abe and in

940
00:40:24,240 --> 00:40:26,280
particular it might depend on the

941
00:40:26,280 --> 00:40:28,740
computational devices so for instance if

942
00:40:28,740 --> 00:40:30,480
we have really slow decryption devices

943
00:40:30,480 --> 00:40:32,880
then we want to optimize the decryption

944
00:40:32,880 --> 00:40:35,640
efficiency of the scheme now typically

945
00:40:35,640 --> 00:40:38,520
what we see is that schemes provide a

946
00:40:38,520 --> 00:40:40,740
fixed efficiency trade-off which would

947
00:40:40,740 --> 00:40:43,020
mean not so bad if we had like a lot of

948
00:40:43,020 --> 00:40:46,560
options in terms of schemes but in

949
00:40:46,560 --> 00:40:48,540
particular these schemes typically also

950
00:40:48,540 --> 00:40:51,720
have a very inefficient decryption

951
00:40:51,720 --> 00:40:54,180
algorithm especially if we want to have

952
00:40:54,180 --> 00:40:57,359
many desirable properties

953
00:40:57,359 --> 00:40:59,880
now the goal of our work is to create a

954
00:40:59,880 --> 00:41:01,619
scheme that can support many such

955
00:41:01,619 --> 00:41:04,740
properties such as negations with a

956
00:41:04,740 --> 00:41:06,480
flexible efficiency trade-off so

957
00:41:06,480 --> 00:41:09,240
ultimately we can fine-tune the scheme

958
00:41:09,240 --> 00:41:10,740
so that it has a very efficient

959
00:41:10,740 --> 00:41:13,320
decryption algorithm

960
00:41:13,320 --> 00:41:15,780
so first give an introduction about Abe

961
00:41:15,780 --> 00:41:17,820
So you have some idea on what this is if

962
00:41:17,820 --> 00:41:20,400
you don't know it yet we just had two

963
00:41:20,400 --> 00:41:22,320
talks that were sort of closely related

964
00:41:22,320 --> 00:41:24,079
so I hope you have a bit enough

965
00:41:24,079 --> 00:41:27,240
intuition on it then I will introduce

966
00:41:27,240 --> 00:41:30,960
glue and then I will conclude this stock

967
00:41:30,960 --> 00:41:34,680
so in cyber text policy Abe or cpabe for

968
00:41:34,680 --> 00:41:37,320
short we consider a setting with the two

969
00:41:37,320 --> 00:41:40,020
famous users Ellis and Bob who want to

970
00:41:40,020 --> 00:41:42,119
exchange messages

971
00:41:42,119 --> 00:41:45,420
and we also have that in Abe setting

972
00:41:45,420 --> 00:41:47,460
but in the Abe setting we also have

973
00:41:47,460 --> 00:41:49,560
something like an untrusted platform

974
00:41:49,560 --> 00:41:51,420
such as the cloud and which we want to

975
00:41:51,420 --> 00:41:53,940
store data and we also have an entity

976
00:41:53,940 --> 00:41:56,520
called the key generation Authority or

977
00:41:56,520 --> 00:41:59,400
kga for short who generates the master

978
00:41:59,400 --> 00:42:02,280
key pair and as Master keeper consists

979
00:42:02,280 --> 00:42:04,079
of a master public and a master secret

980
00:42:04,079 --> 00:42:05,420
key

981
00:42:05,420 --> 00:42:08,700
and he can use this master secret key to

982
00:42:08,700 --> 00:42:11,460
generate secret keys for the users

983
00:42:11,460 --> 00:42:14,160
so in this case Bob can request secret

984
00:42:14,160 --> 00:42:16,500
keys for his attributes the doctor and

985
00:42:16,500 --> 00:42:19,200
Johns Hopkins hospital and he can store

986
00:42:19,200 --> 00:42:21,720
them on his computer so you can use them

987
00:42:21,720 --> 00:42:24,359
later to decrypt things

988
00:42:24,359 --> 00:42:26,099
now if someone wants to encrypt

989
00:42:26,099 --> 00:42:29,160
something then she can download the

990
00:42:29,160 --> 00:42:32,099
master public key from the key

991
00:42:32,099 --> 00:42:34,560
generation Authority and then she can

992
00:42:34,560 --> 00:42:37,200
think about okay who does she wants to

993
00:42:37,200 --> 00:42:39,420
share her data with so in this in this

994
00:42:39,420 --> 00:42:41,339
case she might have generated some data

995
00:42:41,339 --> 00:42:43,020
that she wants to share with doctors and

996
00:42:43,020 --> 00:42:45,540
nurses yes you can specify this in a

997
00:42:45,540 --> 00:42:48,300
policy and encrypt the data and put the

998
00:42:48,300 --> 00:42:50,460
ciphertext well for instance in the

999
00:42:50,460 --> 00:42:51,300
cloud

1000
00:42:51,300 --> 00:42:53,520
and in this case everyone can access the

1001
00:42:53,520 --> 00:42:56,640
ciphertext but only people who satisfy

1002
00:42:56,640 --> 00:42:59,160
the policy and have the keys are sort of

1003
00:42:59,160 --> 00:43:02,579
show that can decrypt the ciphertext so

1004
00:43:02,579 --> 00:43:04,200
in this case Bob can decrypt the

1005
00:43:04,200 --> 00:43:06,060
ciphertext because he has a key for the

1006
00:43:06,060 --> 00:43:08,160
attribute doctor

1007
00:43:08,160 --> 00:43:10,200
now if you look at this setting and you

1008
00:43:10,200 --> 00:43:12,839
already kind of feel like okay this is a

1009
00:43:12,839 --> 00:43:14,460
way to cryptographically implement

1010
00:43:14,460 --> 00:43:16,680
access control

1011
00:43:16,680 --> 00:43:18,960
um and it's actually also the reason why

1012
00:43:18,960 --> 00:43:20,940
it's really popular in settings in which

1013
00:43:20,940 --> 00:43:23,400
data has to be stored on untrusted

1014
00:43:23,400 --> 00:43:25,319
platforms

1015
00:43:25,319 --> 00:43:27,900
I would like to highlight two things so

1016
00:43:27,900 --> 00:43:29,640
the European telecommunications

1017
00:43:29,640 --> 00:43:31,920
standards Institute or Etsy for short

1018
00:43:31,920 --> 00:43:34,920
has a couple of years ago published a

1019
00:43:34,920 --> 00:43:38,640
technical report in which they consider

1020
00:43:38,640 --> 00:43:41,400
several use cases in which we can apply

1021
00:43:41,400 --> 00:43:45,000
Abe to enforce access control and some

1022
00:43:45,000 --> 00:43:46,920
use cases that you can think of or the

1023
00:43:46,920 --> 00:43:49,800
cloud but also iot and there are some

1024
00:43:49,800 --> 00:43:52,380
other use cases in that report

1025
00:43:52,380 --> 00:43:55,140
I will also want to

1026
00:43:55,140 --> 00:43:55,680
um

1027
00:43:55,680 --> 00:44:00,300
point out a reason uh advancement so

1028
00:44:00,300 --> 00:44:03,359
cloudflare is presented at last real

1029
00:44:03,359 --> 00:44:05,460
with crypto the new version of the Geo

1030
00:44:05,460 --> 00:44:08,280
key manager it's called perchiness and

1031
00:44:08,280 --> 00:44:10,619
in this system they also Implement

1032
00:44:10,619 --> 00:44:13,440
Access Control using Abe

1033
00:44:13,440 --> 00:44:15,240
so this is actually something that

1034
00:44:15,240 --> 00:44:17,520
nowadays is even used in practice and

1035
00:44:17,520 --> 00:44:20,400
even on a very large scale

1036
00:44:20,400 --> 00:44:22,740
now if we look at all of these use cases

1037
00:44:22,740 --> 00:44:25,200
then we can actually see that many of

1038
00:44:25,200 --> 00:44:26,880
these use cases sort of have these

1039
00:44:26,880 --> 00:44:29,579
common requirements that we need from AV

1040
00:44:29,579 --> 00:44:33,599
and one of them is expressive policy so

1041
00:44:33,599 --> 00:44:35,460
what we want is that this policy that we

1042
00:44:35,460 --> 00:44:37,400
enforce on the ciphertext

1043
00:44:37,400 --> 00:44:40,380
should at least support at least Boolean

1044
00:44:40,380 --> 00:44:42,839
formulas consisting of ends the North

1045
00:44:42,839 --> 00:44:45,240
we also want to support large universes

1046
00:44:45,240 --> 00:44:48,359
so you can basically use any arbitrary

1047
00:44:48,359 --> 00:44:50,040
string as an attribute so you can think

1048
00:44:50,040 --> 00:44:52,520
of names roles within a company

1049
00:44:52,520 --> 00:44:54,720
departments within a hospital Mac

1050
00:44:54,720 --> 00:44:57,599
addresses and we also want the scheme to

1051
00:44:57,599 --> 00:45:00,000
be inbounded so that there are no bounds

1052
00:45:00,000 --> 00:45:02,339
on any of the parameters and typical

1053
00:45:02,339 --> 00:45:04,260
parameters that might have bounds on

1054
00:45:04,260 --> 00:45:06,660
them in Abe would be the length of the

1055
00:45:06,660 --> 00:45:10,700
policies or of the attribute sets

1056
00:45:10,980 --> 00:45:13,079
um there are also some use cases that

1057
00:45:13,079 --> 00:45:17,060
require no monotonicity meaning that

1058
00:45:17,060 --> 00:45:20,280
the scheme can support negations or not

1059
00:45:20,280 --> 00:45:21,420
operators

1060
00:45:21,420 --> 00:45:24,540
and actually something interesting that

1061
00:45:24,540 --> 00:45:27,000
Etsy says is that we cannot enforce

1062
00:45:27,000 --> 00:45:29,160
access control with Abe like to the

1063
00:45:29,160 --> 00:45:30,900
fullest extent because we cannot support

1064
00:45:30,900 --> 00:45:33,359
negations efficiently

1065
00:45:33,359 --> 00:45:37,800
um cloudflare last RWC that negation is

1066
00:45:37,800 --> 00:45:40,500
important please include it so this is

1067
00:45:40,500 --> 00:45:42,300
like one of the reasons why we really

1068
00:45:42,300 --> 00:45:45,180
wanted to build this

1069
00:45:45,180 --> 00:45:47,700
um lastly I would like to point out the

1070
00:45:47,700 --> 00:45:49,260
storage and computational efficiency

1071
00:45:49,260 --> 00:45:51,960
requirements uh which do not actually

1072
00:45:51,960 --> 00:45:54,420
have a really common threat in all of

1073
00:45:54,420 --> 00:45:56,880
these use cases in fact we see that

1074
00:45:56,880 --> 00:45:58,560
they're a little bit different for every

1075
00:45:58,560 --> 00:45:59,880
use case

1076
00:45:59,880 --> 00:46:03,300
so to give some example in the fortunes

1077
00:46:03,300 --> 00:46:05,160
and Cloud settings we really require

1078
00:46:05,160 --> 00:46:07,800
fast decryption algorithm and we may not

1079
00:46:07,800 --> 00:46:09,720
care much about the efficiency of the

1080
00:46:09,720 --> 00:46:12,599
key generation or the encryption

1081
00:46:12,599 --> 00:46:14,400
um but any internet of things for

1082
00:46:14,400 --> 00:46:16,380
instance we want encryption to be really

1083
00:46:16,380 --> 00:46:19,500
fast and the ciphertext to be small

1084
00:46:19,500 --> 00:46:22,020
in this talk I will mostly focus on this

1085
00:46:22,020 --> 00:46:24,119
goal of getting a very fast decryption

1086
00:46:24,119 --> 00:46:26,880
algorithm in your schemes so that's

1087
00:46:26,880 --> 00:46:28,560
something

1088
00:46:28,560 --> 00:46:30,960
so we want fast decryption what's the

1089
00:46:30,960 --> 00:46:33,960
state of the art So currently if we do

1090
00:46:33,960 --> 00:46:36,839
not require negations then we're pretty

1091
00:46:36,839 --> 00:46:39,000
pretty much like there like we have

1092
00:46:39,000 --> 00:46:40,319
really good schemes with really

1093
00:46:40,319 --> 00:46:43,319
efficient decryption algorithm

1094
00:46:43,319 --> 00:46:45,240
um but if we do require Integrations

1095
00:46:45,240 --> 00:46:47,520
then it's a little bit more complicated

1096
00:46:47,520 --> 00:46:50,520
so either we have a very expensive

1097
00:46:50,520 --> 00:46:53,099
decryption algorithm uh and with

1098
00:46:53,099 --> 00:46:54,780
expensive decryption algorithm I mean

1099
00:46:54,780 --> 00:46:56,760
that we require many pairing operations

1100
00:46:56,760 --> 00:46:59,579
during decryption or

1101
00:46:59,579 --> 00:47:01,200
um well some schemes that do support

1102
00:47:01,200 --> 00:47:04,319
negations are more efficient

1103
00:47:04,319 --> 00:47:06,480
um they're also more restricted and then

1104
00:47:06,480 --> 00:47:09,240
we're back to this bounded thing like we

1105
00:47:09,240 --> 00:47:11,040
we want schemes to be unbounded so you

1106
00:47:11,040 --> 00:47:13,980
can flexibly use them in practice uh so

1107
00:47:13,980 --> 00:47:17,400
that's like definitely a drawback there

1108
00:47:17,400 --> 00:47:19,500
and to sort of understand why no

1109
00:47:19,500 --> 00:47:21,720
monotone schemes are much less efficient

1110
00:47:21,720 --> 00:47:24,720
than monotone schemes we we sort of we

1111
00:47:24,720 --> 00:47:27,420
can observe them and we see that

1112
00:47:27,420 --> 00:47:29,819
these schemes actually have a similar

1113
00:47:29,819 --> 00:47:32,400
underlying structure so all of these

1114
00:47:32,400 --> 00:47:34,920
schemes use polynomials in order to

1115
00:47:34,920 --> 00:47:37,800
support large universes and to support

1116
00:47:37,800 --> 00:47:39,839
negations you can exploit this

1117
00:47:39,839 --> 00:47:43,339
polynomial to do that

1118
00:47:44,220 --> 00:47:45,780
um well why are these schemes so

1119
00:47:45,780 --> 00:47:47,700
inefficient well actually there's a very

1120
00:47:47,700 --> 00:47:49,560
strong relationship between these

1121
00:47:49,560 --> 00:47:51,359
polynomials degrees

1122
00:47:51,359 --> 00:47:54,119
and the decryption efficiency

1123
00:47:54,119 --> 00:47:56,280
and what we typically see is at higher

1124
00:47:56,280 --> 00:47:58,380
degrees of the polynomial also lead to

1125
00:47:58,380 --> 00:48:02,099
faster decryption and vice versa

1126
00:48:02,099 --> 00:48:04,560
so to give an example if you look at the

1127
00:48:04,560 --> 00:48:06,780
Russo like as water scheme then they're

1128
00:48:06,780 --> 00:48:09,900
employing in one degree polynomial and

1129
00:48:09,900 --> 00:48:11,700
they require two pairings per attribute

1130
00:48:11,700 --> 00:48:14,819
during decryption and what is 11 scheme

1131
00:48:14,819 --> 00:48:16,380
the large Universe scheme in the

1132
00:48:16,380 --> 00:48:18,800
appendix of the full version

1133
00:48:18,800 --> 00:48:21,720
employs an end degree polynomial and it

1134
00:48:21,720 --> 00:48:24,480
requires two parents per n attributes

1135
00:48:24,480 --> 00:48:26,579
and note that this scheme is bounded so

1136
00:48:26,579 --> 00:48:28,920
you can have at most n attributes in

1137
00:48:28,920 --> 00:48:31,319
your keys and ciphertext combined so

1138
00:48:31,319 --> 00:48:34,079
it's two pairing per decryption uh

1139
00:48:34,079 --> 00:48:37,140
instance basically

1140
00:48:37,140 --> 00:48:40,619
now the reason why unbounded schemes uh

1141
00:48:40,619 --> 00:48:43,020
that support large universes

1142
00:48:43,020 --> 00:48:46,079
um and can support negations

1143
00:48:46,079 --> 00:48:48,720
um are like less efficient is that all

1144
00:48:48,720 --> 00:48:50,460
of these schemes employ a one degree

1145
00:48:50,460 --> 00:48:53,280
polynomial and thus require at least two

1146
00:48:53,280 --> 00:48:54,480
pairings

1147
00:48:54,480 --> 00:48:58,200
per attribute during decryption so the

1148
00:48:58,200 --> 00:49:00,060
high level idea is okay what if we

1149
00:49:00,060 --> 00:49:02,520
generalize the hash we replace it

1150
00:49:02,520 --> 00:49:04,560
instead of doing a one degree polynomial

1151
00:49:04,560 --> 00:49:07,560
we do an end degree polynomial

1152
00:49:07,560 --> 00:49:09,599
and that's actually the idea behind blue

1153
00:49:09,599 --> 00:49:12,540
so in glue we replace the polynomial

1154
00:49:12,540 --> 00:49:14,819
based hash of the russolagus was a 13

1155
00:49:14,819 --> 00:49:17,280
scheme by replacing the one degree

1156
00:49:17,280 --> 00:49:19,500
polynomial with an end degree polynomial

1157
00:49:19,500 --> 00:49:22,800
and um actually the scheme that you get

1158
00:49:22,800 --> 00:49:25,260
by just doing that is not secure so we

1159
00:49:25,260 --> 00:49:27,240
also convey another parameter in the

1160
00:49:27,240 --> 00:49:29,940
Russo Lagos water scheme as a polynomial

1161
00:49:29,940 --> 00:49:31,980
so that we can actually do proof

1162
00:49:31,980 --> 00:49:34,160
security

1163
00:49:34,200 --> 00:49:37,040
um but also note that Russell has like

1164
00:49:37,040 --> 00:49:39,420
Russell like this matters is a monotone

1165
00:49:39,420 --> 00:49:43,200
scheme so actually the reason why we're

1166
00:49:43,200 --> 00:49:44,940
focusing on this scheme is because it's

1167
00:49:44,940 --> 00:49:47,400
basically the basis of all unbounded

1168
00:49:47,400 --> 00:49:50,400
schemes that supports negations and I

1169
00:49:50,400 --> 00:49:52,079
get later to the point where we actually

1170
00:49:52,079 --> 00:49:54,240
construct a scheme that supports

1171
00:49:54,240 --> 00:49:56,339
negations

1172
00:49:56,339 --> 00:49:58,980
now why does like replacing is one

1173
00:49:58,980 --> 00:50:00,839
degree polynomial with an N degree

1174
00:50:00,839 --> 00:50:04,380
polynomial actually leads to a more

1175
00:50:04,380 --> 00:50:07,260
efficient decryption well like this end

1176
00:50:07,260 --> 00:50:09,480
degree polynomial is constructed where n

1177
00:50:09,480 --> 00:50:13,079
is NK plus and C minus one

1178
00:50:13,079 --> 00:50:16,140
and the idea is that you partition the

1179
00:50:16,140 --> 00:50:18,119
sets and policies and small smaller

1180
00:50:18,119 --> 00:50:21,780
subsets of maximum size and KNC and you

1181
00:50:21,780 --> 00:50:23,760
should sort of like share the randomness

1182
00:50:23,760 --> 00:50:26,520
of the polynomial amongst uh every

1183
00:50:26,520 --> 00:50:29,520
partition and in that way we can sort of

1184
00:50:29,520 --> 00:50:31,500
reduce the number of bearings that we

1185
00:50:31,500 --> 00:50:33,960
require during decryption by our

1186
00:50:33,960 --> 00:50:37,800
effector in NK and NC so if nkn and C

1187
00:50:37,800 --> 00:50:40,500
are equal it's actually a factor NK

1188
00:50:40,500 --> 00:50:43,020
smaller compared to Russell lag is what

1189
00:50:43,020 --> 00:50:44,700
is 13.

1190
00:50:44,700 --> 00:50:47,460
so basically the higher the NK and the

1191
00:50:47,460 --> 00:50:49,800
NC are the more efficient decryption is

1192
00:50:49,800 --> 00:50:52,140
but this is not without a cost because

1193
00:50:52,140 --> 00:50:54,720
actually the encryption efficiency will

1194
00:50:54,720 --> 00:51:00,780
decrease when you make nkn and C higher

1195
00:51:00,780 --> 00:51:03,500
but before I get to Performance

1196
00:51:03,500 --> 00:51:06,180
estimates I will first discuss a bit

1197
00:51:06,180 --> 00:51:08,160
about the security of blue

1198
00:51:08,160 --> 00:51:11,040
so in the security proof we combine and

1199
00:51:11,040 --> 00:51:14,520
generalize proof techniques of various

1200
00:51:14,520 --> 00:51:18,000
works so most notably the schemes by

1201
00:51:18,000 --> 00:51:20,520
Waters that I just mentioned the what is

1202
00:51:20,520 --> 00:51:22,260
11 scheme there is a lack of water

1203
00:51:22,260 --> 00:51:25,920
scheme and also another scheme that sort

1204
00:51:25,920 --> 00:51:27,780
of seems unrelated

1205
00:51:27,780 --> 00:51:31,440
as the ac16 scheme it's a scheme with

1206
00:51:31,440 --> 00:51:34,079
short ciphertext

1207
00:51:34,079 --> 00:51:36,960
but we use the tricks that they do to

1208
00:51:36,960 --> 00:51:39,599
sort of make the proof work and we use a

1209
00:51:39,599 --> 00:51:41,400
new trick to sort of make sure that we

1210
00:51:41,400 --> 00:51:42,900
can combine all of these proof

1211
00:51:42,900 --> 00:51:45,119
techniques in a nice way

1212
00:51:45,119 --> 00:51:48,180
we also prove Security in the symbolic

1213
00:51:48,180 --> 00:51:50,760
pairingcodings framework by agrobel and

1214
00:51:50,760 --> 00:51:55,140
Chase introducing your crypto 2017 and

1215
00:51:55,140 --> 00:51:57,180
by doing that we actually achieve

1216
00:51:57,180 --> 00:51:59,760
properties like normal technicity for

1217
00:51:59,760 --> 00:52:02,400
free so we have in this framework if you

1218
00:52:02,400 --> 00:52:04,319
have a secure scheme then you can apply

1219
00:52:04,319 --> 00:52:06,599
certain Transformations and they

1220
00:52:06,599 --> 00:52:09,059
preserve the security of the scheme it

1221
00:52:09,059 --> 00:52:11,880
was actually pretty cool I think

1222
00:52:11,880 --> 00:52:15,000
um well now to The Benchmark so we have

1223
00:52:15,000 --> 00:52:17,460
made some performance estimates for

1224
00:52:17,460 --> 00:52:19,880
various um

1225
00:52:19,880 --> 00:52:22,800
configurations of glue so here you can

1226
00:52:22,800 --> 00:52:25,200
see like the lower you get the higher

1227
00:52:25,200 --> 00:52:27,839
the nkn and C become

1228
00:52:27,839 --> 00:52:30,619
and as you can see on the left side

1229
00:52:30,619 --> 00:52:34,140
the storage costs are not impacted so

1230
00:52:34,140 --> 00:52:36,420
they're actually decreasing the key

1231
00:52:36,420 --> 00:52:38,579
generation costs are also decreasing and

1232
00:52:38,579 --> 00:52:41,099
for decryption we see that the

1233
00:52:41,099 --> 00:52:43,079
decryption costs are much faster than

1234
00:52:43,079 --> 00:52:45,359
versus like as well as 13. so it's like

1235
00:52:45,359 --> 00:52:47,339
a factor five faster here

1236
00:52:47,339 --> 00:52:49,740
so we really want to files decryption

1237
00:52:49,740 --> 00:52:52,680
algorithm we can increase in KN and C of

1238
00:52:52,680 --> 00:52:54,480
course this comes as a cost so if you

1239
00:52:54,480 --> 00:52:56,520
see here the encryption costs actually

1240
00:52:56,520 --> 00:52:59,240
do increase

1241
00:52:59,280 --> 00:53:03,359
um but much less faster than the

1242
00:53:03,359 --> 00:53:06,420
decryption cost decrease but still this

1243
00:53:06,420 --> 00:53:08,400
is not a number that you might find

1244
00:53:08,400 --> 00:53:10,800
interesting for your application so

1245
00:53:10,800 --> 00:53:12,059
there are some tricks to actually

1246
00:53:12,059 --> 00:53:14,280
optimize this

1247
00:53:14,280 --> 00:53:15,780
um and for that I would invite you to

1248
00:53:15,780 --> 00:53:17,640
read the paper or come talk to me about

1249
00:53:17,640 --> 00:53:19,440
it

1250
00:53:19,440 --> 00:53:22,260
um also this is for the Montana the

1251
00:53:22,260 --> 00:53:24,540
monotone schemes for the non-monitoring

1252
00:53:24,540 --> 00:53:26,579
schemes we have similar things but

1253
00:53:26,579 --> 00:53:28,740
actually for negations we see an even

1254
00:53:28,740 --> 00:53:32,959
better speed up in the decryption

1255
00:53:33,900 --> 00:53:37,140
now to wrap up uh so Abe implements

1256
00:53:37,140 --> 00:53:38,940
access control on a cryptographic level

1257
00:53:38,940 --> 00:53:41,460
and it actually can support various

1258
00:53:41,460 --> 00:53:44,160
different properties that you can sort

1259
00:53:44,160 --> 00:53:47,040
of choose for various different use

1260
00:53:47,040 --> 00:53:48,059
cases

1261
00:53:48,059 --> 00:53:49,980
so previously if we wanted to support

1262
00:53:49,980 --> 00:53:53,700
negations uh we couldn't really do that

1263
00:53:53,700 --> 00:53:55,500
without really impacting the decryption

1264
00:53:55,500 --> 00:53:58,440
efficiency and basically glue addresses

1265
00:53:58,440 --> 00:54:00,180
the need for our support for negations

1266
00:54:00,180 --> 00:54:02,220
while also having an efficient

1267
00:54:02,220 --> 00:54:04,500
decryption algorithm

1268
00:54:04,500 --> 00:54:06,420
and with that I would like to end my

1269
00:54:06,420 --> 00:54:08,520
talk so thank you for your attention I'm

1270
00:54:08,520 --> 00:54:11,839
happy to take questions now

1271
00:54:16,500 --> 00:54:20,960
any questions from the audience

1272
00:54:23,220 --> 00:54:25,400
I have a quick one maybe the the

1273
00:54:25,400 --> 00:54:27,420
polynomials you were saying that you

1274
00:54:27,420 --> 00:54:30,420
were increasing the the degree are there

1275
00:54:30,420 --> 00:54:33,720
in one variable or several variables or

1276
00:54:33,720 --> 00:54:36,119
do you have a can you play with a number

1277
00:54:36,119 --> 00:54:37,859
of variables

1278
00:54:37,859 --> 00:54:39,119
um

1279
00:54:39,119 --> 00:54:42,839
so as in the variables of the polynomial

1280
00:54:42,839 --> 00:54:44,940
yeah so we only have one variable now

1281
00:54:44,940 --> 00:54:47,280
I've actually thought about including

1282
00:54:47,280 --> 00:54:49,800
more variables but

1283
00:54:49,800 --> 00:54:52,740
um so right now you use one variable to

1284
00:54:52,740 --> 00:54:56,579
40 40 attribute that you're in embed in

1285
00:54:56,579 --> 00:54:59,520
the policy

1286
00:54:59,520 --> 00:55:02,640
um but if you want for instance uh so

1287
00:55:02,640 --> 00:55:03,900
there are some schemes that sort of

1288
00:55:03,900 --> 00:55:06,059
separate the attribute label from the

1289
00:55:06,059 --> 00:55:08,579
attribute value and then you can

1290
00:55:08,579 --> 00:55:10,380
actually like maybe it will be

1291
00:55:10,380 --> 00:55:12,059
interesting to come to have two

1292
00:55:12,059 --> 00:55:14,640
variables or maybe more variables

1293
00:55:14,640 --> 00:55:16,800
so the I've actually also looked into

1294
00:55:16,800 --> 00:55:19,680
that as a follow-up

1295
00:55:19,680 --> 00:55:21,420
okay

1296
00:55:21,420 --> 00:55:24,500
any other question

1297
00:55:25,500 --> 00:55:28,020
no then uh thank you let's thank the

1298
00:55:28,020 --> 00:55:30,559
speaker again

1299
00:55:34,280 --> 00:55:38,119
the session

1300
00:55:40,500 --> 00:55:43,920
hi everyone so uh next event on our

1301
00:55:43,920 --> 00:55:46,800
calendar is the group photo on the coda

1302
00:55:46,800 --> 00:55:47,880
rooftop

1303
00:55:47,880 --> 00:55:50,160
to not overwhelm the building we're

1304
00:55:50,160 --> 00:55:52,740
going to go in through in separate

1305
00:55:52,740 --> 00:55:54,800
groups slightly delayed from each other

1306
00:55:54,800 --> 00:55:57,660
uh if you're sitting on that side I'll

1307
00:55:57,660 --> 00:56:00,059
call you the Sasha group if you're

1308
00:56:00,059 --> 00:56:01,680
sitting in the middle I'll call you the

1309
00:56:01,680 --> 00:56:03,780
Vlog group and if you're sitting over

1310
00:56:03,780 --> 00:56:05,040
there I'll call you

1311
00:56:05,040 --> 00:56:09,020
my group and uh

1312
00:56:09,540 --> 00:56:13,220
NASA's group I guess we'll go first

