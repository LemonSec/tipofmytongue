1
00:00:00,000 --> 00:00:01,620
ready so

2
00:00:01,620 --> 00:00:03,720
first talk of this session it's on

3
00:00:03,720 --> 00:00:05,339
homomorphic secret sharing from

4
00:00:05,339 --> 00:00:09,720
polynomial modulus lwe and Pedro

5
00:00:09,720 --> 00:00:14,940
copper Tower give the talk

6
00:00:14,940 --> 00:00:17,100
thank you for the introduction uh I'm

7
00:00:17,100 --> 00:00:19,080
happy to be here to present this work

8
00:00:19,080 --> 00:00:21,840
with Thomas hatima and Elisa Cole about

9
00:00:21,840 --> 00:00:24,539
homomorphic secret sharing

10
00:00:24,539 --> 00:00:28,320
so HSS is a type of secret sharing which

11
00:00:28,320 --> 00:00:30,960
allows parties to locally compute

12
00:00:30,960 --> 00:00:34,260
functions over their shares so in the

13
00:00:34,260 --> 00:00:36,780
two-party setting you can imagine we

14
00:00:36,780 --> 00:00:37,800
have

15
00:00:37,800 --> 00:00:41,100
um a secret X shared between Alice and

16
00:00:41,100 --> 00:00:42,480
Bob

17
00:00:42,480 --> 00:00:45,899
and uh given some public function or

18
00:00:45,899 --> 00:00:49,739
program P Alice can apply a homomorphic

19
00:00:49,739 --> 00:00:53,340
evaluation procedure to her share XA to

20
00:00:53,340 --> 00:00:57,120
obtain an output share y a and Bob on

21
00:00:57,120 --> 00:00:59,820
his side can do the same thing and in

22
00:00:59,820 --> 00:01:01,260
the end there is a reconstruction

23
00:01:01,260 --> 00:01:05,760
procedure which obtains the output P of

24
00:01:05,760 --> 00:01:09,060
X of the program P evaluated at the

25
00:01:09,060 --> 00:01:11,580
secret so in terms of security we just

26
00:01:11,580 --> 00:01:14,400
require that each of the shares

27
00:01:14,400 --> 00:01:17,760
individually hides the secret X

28
00:01:17,760 --> 00:01:21,360
and uh this reconstruction function is

29
00:01:21,360 --> 00:01:24,420
typically additive so uh the output

30
00:01:24,420 --> 00:01:27,119
Shares are in some group and

31
00:01:27,119 --> 00:01:29,400
um the Reconstruction function simply

32
00:01:29,400 --> 00:01:31,740
adds them up together

33
00:01:31,740 --> 00:01:33,659
um this is quite a useful form of

34
00:01:33,659 --> 00:01:35,880
reconstruction because for example it

35
00:01:35,880 --> 00:01:38,460
allows you to do linear post-processing

36
00:01:38,460 --> 00:01:40,220
of the shares

37
00:01:40,220 --> 00:01:43,680
but uh in our work we are actually going

38
00:01:43,680 --> 00:01:46,560
to consider a more general form so more

39
00:01:46,560 --> 00:01:48,119
on that later

40
00:01:48,119 --> 00:01:51,659
and um just to give you an idea of HSS

41
00:01:51,659 --> 00:01:55,020
uh the the simplest example we can have

42
00:01:55,020 --> 00:01:57,840
is for linear functions in which the

43
00:01:57,840 --> 00:01:58,920
secret

44
00:01:58,920 --> 00:02:02,280
um is shared as an additive sharing so

45
00:02:02,280 --> 00:02:04,500
two random shares that add up to the

46
00:02:04,500 --> 00:02:07,500
secret and to evaluate some linear

47
00:02:07,500 --> 00:02:10,318
program P homomorphically we simply

48
00:02:10,318 --> 00:02:13,560
apply P to the share and reconstruction

49
00:02:13,560 --> 00:02:16,200
here is also additive

50
00:02:16,200 --> 00:02:18,660
but of course we are interested in

51
00:02:18,660 --> 00:02:21,420
getting HSS for a richer class of

52
00:02:21,420 --> 00:02:23,700
programs which in this case is going to

53
00:02:23,700 --> 00:02:26,819
be the class of branching programs

54
00:02:26,819 --> 00:02:29,459
um which you can think of as arithmetic

55
00:02:29,459 --> 00:02:32,340
circuits so we have the operations of

56
00:02:32,340 --> 00:02:35,340
addition and multiplication but there is

57
00:02:35,340 --> 00:02:38,580
a restriction which states that a

58
00:02:38,580 --> 00:02:40,860
multiplication always has to involve an

59
00:02:40,860 --> 00:02:43,379
input value so we are not allowed to

60
00:02:43,379 --> 00:02:46,980
multiply two intermediate computation

61
00:02:46,980 --> 00:02:49,640
values

62
00:02:50,400 --> 00:02:52,980
um and there is an interesting line of

63
00:02:52,980 --> 00:02:55,739
work on obtaining uh two-party

64
00:02:55,739 --> 00:02:57,780
homomorphic secret sharing for this

65
00:02:57,780 --> 00:02:59,519
class of programs from different

66
00:02:59,519 --> 00:03:02,760
assumptions such as ddh learning with

67
00:03:02,760 --> 00:03:03,840
errors

68
00:03:03,840 --> 00:03:07,500
um by encryption and the starting point

69
00:03:07,500 --> 00:03:09,920
for our work is going to be this paper

70
00:03:09,920 --> 00:03:13,379
by Elle Boyle Lisa Cole and Peter Scholl

71
00:03:13,379 --> 00:03:18,840
on obtaining HSS from lwe

72
00:03:18,840 --> 00:03:22,080
so I won't go into much detail about

73
00:03:22,080 --> 00:03:25,620
this bks construction but I just want to

74
00:03:25,620 --> 00:03:27,900
give you an idea to motivate the main

75
00:03:27,900 --> 00:03:30,060
problem that we are going to be focusing

76
00:03:30,060 --> 00:03:31,019
on

77
00:03:31,019 --> 00:03:34,319
so um recall that we want to implement

78
00:03:34,319 --> 00:03:37,560
two types of operations to have

79
00:03:37,560 --> 00:03:40,200
homomorphically addition which is going

80
00:03:40,200 --> 00:03:42,120
to come essentially for free by

81
00:03:42,120 --> 00:03:45,319
linearity and restricted multiplication

82
00:03:45,319 --> 00:03:48,900
so uh here we have an underlying

83
00:03:48,900 --> 00:03:52,560
encryption scheme based on lwe and our

84
00:03:52,560 --> 00:03:55,440
input values are going to be encoded as

85
00:03:55,440 --> 00:03:58,379
ciphertexts and our intermediate values

86
00:03:58,379 --> 00:04:01,019
are going to be additive shares so Alice

87
00:04:01,019 --> 00:04:03,599
is going to have this value and Bob this

88
00:04:03,599 --> 00:04:07,140
one which add up to Y times the secret

89
00:04:07,140 --> 00:04:08,220
key

90
00:04:08,220 --> 00:04:11,299
and so uh when we want to

91
00:04:11,299 --> 00:04:12,840
homomorphically compute the

92
00:04:12,840 --> 00:04:15,840
multiplication of an input value X and

93
00:04:15,840 --> 00:04:19,139
an intermediate value y we just have to

94
00:04:19,139 --> 00:04:21,660
compute this inner product which by the

95
00:04:21,660 --> 00:04:24,840
properties of the lwe-based encryption

96
00:04:24,840 --> 00:04:27,180
is going to give an additive sharing of

97
00:04:27,180 --> 00:04:28,680
this expression

98
00:04:28,680 --> 00:04:31,560
but what we would like to obtain is the

99
00:04:31,560 --> 00:04:33,780
sharing of this expression instead so

100
00:04:33,780 --> 00:04:36,300
this would be the representation of x

101
00:04:36,300 --> 00:04:38,460
times y

102
00:04:38,460 --> 00:04:40,740
um and so the main technical question is

103
00:04:40,740 --> 00:04:44,280
how to go from here to there and uh this

104
00:04:44,280 --> 00:04:46,680
step is called share conversion and it

105
00:04:46,680 --> 00:04:48,300
actually shows up in some of the other

106
00:04:48,300 --> 00:04:51,300
works that I I mentioned for example for

107
00:04:51,300 --> 00:04:53,820
ddh it's about

108
00:04:53,820 --> 00:04:56,759
um converting multiplicative shares into

109
00:04:56,759 --> 00:04:59,460
additive shares

110
00:04:59,460 --> 00:05:02,280
uh and so let's take a closer look at

111
00:05:02,280 --> 00:05:03,720
this problem with some simplified

112
00:05:03,720 --> 00:05:07,080
notation so uh suppose we have this

113
00:05:07,080 --> 00:05:10,800
initial equation so Alice holds a share

114
00:05:10,800 --> 00:05:14,520
u a and Bob holds the share u b which

115
00:05:14,520 --> 00:05:17,400
add up to this expression Q over P times

116
00:05:17,400 --> 00:05:22,500
a message M plus some error or noise

117
00:05:22,500 --> 00:05:23,220
um

118
00:05:23,220 --> 00:05:26,759
and what we would like them to do is for

119
00:05:26,759 --> 00:05:29,699
Alice to locally convert or share UA

120
00:05:29,699 --> 00:05:33,660
into some value z a and Bob to convert u

121
00:05:33,660 --> 00:05:37,919
b into ZB which sum up to m

122
00:05:37,919 --> 00:05:40,440
so in a way we want to convert this

123
00:05:40,440 --> 00:05:44,039
additive sharing of a noisy encoding of

124
00:05:44,039 --> 00:05:48,539
M into a simple additive sharing of M

125
00:05:48,539 --> 00:05:50,699
so this is the the main technical

126
00:05:50,699 --> 00:05:53,120
question

127
00:05:55,520 --> 00:05:59,039
and uh what they do in the bks paper is

128
00:05:59,039 --> 00:06:02,280
split this transformation into two steps

129
00:06:02,280 --> 00:06:04,860
the first is called rounding and it's

130
00:06:04,860 --> 00:06:07,259
going to give us an additive sharing of

131
00:06:07,259 --> 00:06:10,680
Pam modulo P and then a lifting step

132
00:06:10,680 --> 00:06:13,020
which turns this into a sharing modulo

133
00:06:13,020 --> 00:06:17,180
queue so what are these transformations

134
00:06:17,180 --> 00:06:20,880
rounding over share U is going to scale

135
00:06:20,880 --> 00:06:23,819
it by multiplying it by P over q and

136
00:06:23,819 --> 00:06:25,319
then it's going to round it to the

137
00:06:25,319 --> 00:06:27,600
nearest integer so here you have a

138
00:06:27,600 --> 00:06:29,580
visual representation of that operation

139
00:06:29,580 --> 00:06:33,419
on the outside in green you have the

140
00:06:33,419 --> 00:06:36,660
ring of integers modulo q and on the

141
00:06:36,660 --> 00:06:38,940
inside the ring of integers modulo P

142
00:06:38,940 --> 00:06:42,180
where in this figure p is equal to 2.

143
00:06:42,180 --> 00:06:45,720
so you can see that any value in the top

144
00:06:45,720 --> 00:06:48,180
half of the circle of the circle is

145
00:06:48,180 --> 00:06:50,880
going to get mapped to zero and any

146
00:06:50,880 --> 00:06:53,400
value in the bottom half will be mapped

147
00:06:53,400 --> 00:06:54,919
to 1.

148
00:06:54,919 --> 00:06:57,780
and then the lifting operation is even

149
00:06:57,780 --> 00:07:00,780
simpler it basically does nothing so if

150
00:07:00,780 --> 00:07:03,900
you have some value in z p represented

151
00:07:03,900 --> 00:07:06,660
by an integer you simply get the same

152
00:07:06,660 --> 00:07:10,520
integer as a value in that Q

153
00:07:10,520 --> 00:07:13,020
uh this sounds good but do these

154
00:07:13,020 --> 00:07:15,240
operations actually work do they get

155
00:07:15,240 --> 00:07:18,660
this uh result we want and the answer is

156
00:07:18,660 --> 00:07:21,240
yes most of the time so let's see what

157
00:07:21,240 --> 00:07:23,819
can go wrong uh suppose we have our

158
00:07:23,819 --> 00:07:26,819
initial equation here where our error is

159
00:07:26,819 --> 00:07:29,160
bounded and suppose that our message is

160
00:07:29,160 --> 00:07:33,060
zero uh and let's say that Alice has her

161
00:07:33,060 --> 00:07:36,240
share UA here and Bob has UB over there

162
00:07:36,240 --> 00:07:39,180
now what's going to happen is that since

163
00:07:39,180 --> 00:07:41,280
Alice's share is in the bottom half of

164
00:07:41,280 --> 00:07:44,280
the circle it will be mapped to one and

165
00:07:44,280 --> 00:07:46,139
Bob's share is in the top half so it

166
00:07:46,139 --> 00:07:48,660
will be mapped to zero so in the end if

167
00:07:48,660 --> 00:07:51,539
we sum the shares after rounding we get

168
00:07:51,539 --> 00:07:54,720
1 plus 0 which is one hence not our

169
00:07:54,720 --> 00:07:57,780
original message M which was Zero

170
00:07:57,780 --> 00:08:00,360
and this can happen whenever one of the

171
00:08:00,360 --> 00:08:03,720
shares is in this red bad area

172
00:08:03,720 --> 00:08:05,699
um and the probability of Landing there

173
00:08:05,699 --> 00:08:07,680
is this expression which is proportional

174
00:08:07,680 --> 00:08:09,539
to P over Q

175
00:08:09,539 --> 00:08:12,300
and a similar type of correctness error

176
00:08:12,300 --> 00:08:15,180
can happen in the lifting operation so

177
00:08:15,180 --> 00:08:17,880
overall uh the error probability for

178
00:08:17,880 --> 00:08:20,759
each multiplication operation is going

179
00:08:20,759 --> 00:08:21,780
to be

180
00:08:21,780 --> 00:08:24,240
um of the order of p over Q which comes

181
00:08:24,240 --> 00:08:27,360
from rounding plus b max over P which

182
00:08:27,360 --> 00:08:29,940
comes from lifting where B Max is a

183
00:08:29,940 --> 00:08:32,099
bound on the values that the program can

184
00:08:32,099 --> 00:08:34,200
take

185
00:08:34,200 --> 00:08:37,320
uh and what do they do in the bks paper

186
00:08:37,320 --> 00:08:40,559
well they just say that they choose the

187
00:08:40,559 --> 00:08:43,559
parameters such that this probability is

188
00:08:43,559 --> 00:08:47,519
negligible so uh that means choosing Q

189
00:08:47,519 --> 00:08:50,760
which is the the lwe modulus to be super

190
00:08:50,760 --> 00:08:53,100
polynomially larger than the plain text

191
00:08:53,100 --> 00:08:56,160
modulus p and p to be super polynomially

192
00:08:56,160 --> 00:08:58,620
larger than the bound B Max

193
00:08:58,620 --> 00:09:01,019
and in our paper we actually show that

194
00:09:01,019 --> 00:09:03,660
this is the best you can do if you

195
00:09:03,660 --> 00:09:07,080
insist on having additive reconstruction

196
00:09:07,080 --> 00:09:09,480
so now let's see what we can get if we

197
00:09:09,480 --> 00:09:12,420
relax this restriction

198
00:09:12,420 --> 00:09:15,180
so let's consider an alternative method

199
00:09:15,180 --> 00:09:16,920
of rounding

200
00:09:16,920 --> 00:09:20,880
um in which is asymmetric and now uh

201
00:09:20,880 --> 00:09:25,200
Alice is going to again scale her share

202
00:09:25,200 --> 00:09:28,080
by multiplying by P over q but instead

203
00:09:28,080 --> 00:09:30,180
of rounding to the nearest integer she's

204
00:09:30,180 --> 00:09:32,279
always going to round down

205
00:09:32,279 --> 00:09:35,760
and Bob is always going to round up so

206
00:09:35,760 --> 00:09:37,620
if we go back to our previous example

207
00:09:37,620 --> 00:09:40,800
where Alice had her share here uh now

208
00:09:40,800 --> 00:09:43,019
her share will be rounded down and

209
00:09:43,019 --> 00:09:45,839
mapped to one and Bob's chair will be

210
00:09:45,839 --> 00:09:48,480
rounded up and mapped to one as well so

211
00:09:48,480 --> 00:09:51,000
we get one plus one which is zero as

212
00:09:51,000 --> 00:09:53,279
intended so we have solved the

213
00:09:53,279 --> 00:09:56,640
correctness error we previously had

214
00:09:56,640 --> 00:09:58,860
um but of course this method cannot be

215
00:09:58,860 --> 00:10:01,620
perfect instead of failing in the red

216
00:10:01,620 --> 00:10:03,540
area it's going to fail in some other

217
00:10:03,540 --> 00:10:06,660
area but observe that now we have two

218
00:10:06,660 --> 00:10:09,240
methods one which works everywhere

219
00:10:09,240 --> 00:10:12,060
except the red area and one which works

220
00:10:12,060 --> 00:10:15,120
in the red area so let's try and combine

221
00:10:15,120 --> 00:10:18,000
them and uh let's imagine for a second

222
00:10:18,000 --> 00:10:20,700
that we allowed communication and then

223
00:10:20,700 --> 00:10:22,860
we just one bit of communication we

224
00:10:22,860 --> 00:10:25,380
could solve this problem uh by having

225
00:10:25,380 --> 00:10:28,440
Alice tell Bob whether or not her share

226
00:10:28,440 --> 00:10:31,740
is in the bad area if Alice's share is

227
00:10:31,740 --> 00:10:34,380
outside the back area then they can both

228
00:10:34,380 --> 00:10:36,899
use the standard rounding procedure that

229
00:10:36,899 --> 00:10:40,560
we saw earlier and if it is in the bad

230
00:10:40,560 --> 00:10:43,800
area they use this alternative method so

231
00:10:43,800 --> 00:10:46,920
this uh prevents the error but of course

232
00:10:46,920 --> 00:10:49,440
in HSS we do not allow this type of

233
00:10:49,440 --> 00:10:51,779
communication uh because homomorphic

234
00:10:51,779 --> 00:10:55,260
evaluation has to be local but now

235
00:10:55,260 --> 00:10:58,079
suppose that we were to sort of push

236
00:10:58,079 --> 00:11:00,540
this communication down to the end of

237
00:11:00,540 --> 00:11:02,399
the protocol into the Reconstruction

238
00:11:02,399 --> 00:11:03,980
phase

239
00:11:03,980 --> 00:11:08,760
then Alice could just round according to

240
00:11:08,760 --> 00:11:10,560
whether or not she is in the red area

241
00:11:10,560 --> 00:11:13,680
and at the end she would tell Bob

242
00:11:13,680 --> 00:11:15,720
um if she was or not

243
00:11:15,720 --> 00:11:18,180
well on Bob's side he also has to

244
00:11:18,180 --> 00:11:20,880
perform his homomorphic evaluation and

245
00:11:20,880 --> 00:11:24,060
he doesn't know what Alice is doing so

246
00:11:24,060 --> 00:11:26,940
he has to prepare for both cases right

247
00:11:26,940 --> 00:11:29,399
he has to do the standard rounding and

248
00:11:29,399 --> 00:11:31,500
the alternative rounding

249
00:11:31,500 --> 00:11:33,839
and this is a problem because then he

250
00:11:33,839 --> 00:11:36,540
gets two possible values and for the

251
00:11:36,540 --> 00:11:38,700
next multiplication operation those two

252
00:11:38,700 --> 00:11:41,399
will turn into four and so on and so

253
00:11:41,399 --> 00:11:43,860
Bob's computation cost is going to grow

254
00:11:43,860 --> 00:11:45,779
exponentially in the number of

255
00:11:45,779 --> 00:11:47,880
multiplications which of course is

256
00:11:47,880 --> 00:11:49,920
something we do not want

257
00:11:49,920 --> 00:11:52,980
but now the crucial observation is that

258
00:11:52,980 --> 00:11:55,440
Alice and Bob's Shares are actually

259
00:11:55,440 --> 00:11:58,740
correlated because we know that uh their

260
00:11:58,740 --> 00:12:01,440
sum is very close to a multiple of Q

261
00:12:01,440 --> 00:12:04,140
over P so in this case their sum has to

262
00:12:04,140 --> 00:12:07,200
be either close to zero or close to Q

263
00:12:07,200 --> 00:12:10,920
over 2. so um we can notice that if

264
00:12:10,920 --> 00:12:14,160
Alice's share is in this red area then

265
00:12:14,160 --> 00:12:16,380
Bob's share must be in this slightly

266
00:12:16,380 --> 00:12:18,779
larger yellow area

267
00:12:18,779 --> 00:12:21,899
or in other words if Bob's chair is

268
00:12:21,899 --> 00:12:24,959
outside of the yellow area then Alice's

269
00:12:24,959 --> 00:12:27,180
share must be also outside of the red

270
00:12:27,180 --> 00:12:30,660
area so without communicating they both

271
00:12:30,660 --> 00:12:33,180
know that they can use the standard

272
00:12:33,180 --> 00:12:36,959
rounding method without risk of an error

273
00:12:36,959 --> 00:12:40,440
so uh this is what we use in our

274
00:12:40,440 --> 00:12:43,139
construction so Alice is always going to

275
00:12:43,139 --> 00:12:45,540
check if her share is in the red area

276
00:12:45,540 --> 00:12:48,620
and use the appropriate rounding method

277
00:12:48,620 --> 00:12:52,680
and Bob uh if his chair is in the yellow

278
00:12:52,680 --> 00:12:56,820
is outside the yellow area he knows he

279
00:12:56,820 --> 00:12:59,339
can use uh he knows Alice's share is

280
00:12:59,339 --> 00:13:01,800
also outside so he can just use the

281
00:13:01,800 --> 00:13:04,740
standard rounding but if it is inside

282
00:13:04,740 --> 00:13:07,019
the yellow area then he doesn't know

283
00:13:07,019 --> 00:13:10,800
what Alice is doing so he has to compute

284
00:13:10,800 --> 00:13:12,779
both possible values

285
00:13:12,779 --> 00:13:15,959
but we note that the probability of

286
00:13:15,959 --> 00:13:18,360
Landing in this case where Bob has to do

287
00:13:18,360 --> 00:13:21,180
additional computation is given by this

288
00:13:21,180 --> 00:13:23,579
expression which we can make very small

289
00:13:23,579 --> 00:13:26,399
while still having better parameters

290
00:13:26,399 --> 00:13:29,459
than the previous work

291
00:13:29,459 --> 00:13:32,100
and uh pretty much everything that I

292
00:13:32,100 --> 00:13:34,800
said for the rounding operation also

293
00:13:34,800 --> 00:13:36,899
happens for the lifting operation so

294
00:13:36,899 --> 00:13:38,760
there is a similar type of correctness

295
00:13:38,760 --> 00:13:41,639
error and we can address it in a similar

296
00:13:41,639 --> 00:13:42,959
fashion

297
00:13:42,959 --> 00:13:45,300
so I already mentioned that uh our

298
00:13:45,300 --> 00:13:47,100
reconstruction is not going to be

299
00:13:47,100 --> 00:13:49,320
additive so what does it look like in

300
00:13:49,320 --> 00:13:52,380
the end well Alice is going to have a

301
00:13:52,380 --> 00:13:54,660
share of this form

302
00:13:54,660 --> 00:13:57,540
um an integer value and a sequence of

303
00:13:57,540 --> 00:14:00,420
zeros and ones denoting when she used

304
00:14:00,420 --> 00:14:02,519
the standard rounding and when she used

305
00:14:02,519 --> 00:14:04,560
the alternative rounding

306
00:14:04,560 --> 00:14:07,560
and uh Bob is going to have a list of

307
00:14:07,560 --> 00:14:10,740
shares of the same type one for each

308
00:14:10,740 --> 00:14:14,040
sort of computation path in in the

309
00:14:14,040 --> 00:14:15,959
computation tree

310
00:14:15,959 --> 00:14:18,839
and the Reconstruction function is

311
00:14:18,839 --> 00:14:20,480
simply going to

312
00:14:20,480 --> 00:14:25,560
match the the sequences of flags and sum

313
00:14:25,560 --> 00:14:28,440
up the corresponding integers so as you

314
00:14:28,440 --> 00:14:31,079
can see despite not being linear this is

315
00:14:31,079 --> 00:14:34,980
a relatively simple function

316
00:14:34,980 --> 00:14:36,300
so

317
00:14:36,300 --> 00:14:40,199
um to to summarize our results we

318
00:14:40,199 --> 00:14:43,380
construct a two-party homomorphic secret

319
00:14:43,380 --> 00:14:45,360
sharing scheme for the class of

320
00:14:45,360 --> 00:14:48,060
branching programs from the LW

321
00:14:48,060 --> 00:14:51,480
assumption with a small modulus which in

322
00:14:51,480 --> 00:14:53,459
particular is not required to be super

323
00:14:53,459 --> 00:14:56,459
polynomial and we do this using a new

324
00:14:56,459 --> 00:14:58,860
technique for uh correcting or

325
00:14:58,860 --> 00:15:01,380
preventing errors uh with which we

326
00:15:01,380 --> 00:15:04,620
obtain a perfect correctness

327
00:15:04,620 --> 00:15:07,079
um at the cost of variable running time

328
00:15:07,079 --> 00:15:09,600
because as you recall uh Bob's

329
00:15:09,600 --> 00:15:12,240
computation time is going to depend on

330
00:15:12,240 --> 00:15:16,940
how often he lands in his yellow area

331
00:15:16,940 --> 00:15:20,839
we have a relaxed form of reconstruction

332
00:15:20,839 --> 00:15:23,579
which makes our protocol particularly

333
00:15:23,579 --> 00:15:26,399
suitable for settings in which there is

334
00:15:26,399 --> 00:15:29,279
no security against the party doing the

335
00:15:29,279 --> 00:15:30,839
Reconstruction

336
00:15:30,839 --> 00:15:32,339
um so you can think of private

337
00:15:32,339 --> 00:15:35,040
information retrieval and similar

338
00:15:35,040 --> 00:15:37,440
applications and finally our

339
00:15:37,440 --> 00:15:39,540
construction is more efficient than the

340
00:15:39,540 --> 00:15:42,420
previous work we computed some concrete

341
00:15:42,420 --> 00:15:47,220
parameters based on ring lwe and even

342
00:15:47,220 --> 00:15:50,579
for a rather large programs uh our

343
00:15:50,579 --> 00:15:53,459
Shares are shorter by a factor of four

344
00:15:53,459 --> 00:15:55,820
or five at least

345
00:15:55,820 --> 00:15:58,380
that's everything if you're interested

346
00:15:58,380 --> 00:16:00,300
please check out our paper and thank you

347
00:16:00,300 --> 00:16:02,639
very much for listening

348
00:16:02,639 --> 00:16:05,420
foreign

349
00:16:06,060 --> 00:16:09,060
questions

350
00:16:11,519 --> 00:16:14,040
so one thing I wanted to ask at the

351
00:16:14,040 --> 00:16:15,540
beginning you were talking about each

352
00:16:15,540 --> 00:16:18,120
multiplication has to be connected to an

353
00:16:18,120 --> 00:16:20,339
input was that for the previous scheme

354
00:16:20,339 --> 00:16:23,579
or both for both yes we we our scheme is

355
00:16:23,579 --> 00:16:26,399
for the same class of programs okay yes

356
00:16:26,399 --> 00:16:28,160
and there's

357
00:16:28,160 --> 00:16:32,579
I guess they are just multiply or why

358
00:16:32,579 --> 00:16:34,680
why does connecting it to the input

359
00:16:34,680 --> 00:16:37,079
somehow make just keep the error small

360
00:16:37,079 --> 00:16:39,480
even if it was growing I guess I don't

361
00:16:39,480 --> 00:16:40,920
quite see how the arrow grows in that

362
00:16:40,920 --> 00:16:44,279
yes so it's it's not necessarily about

363
00:16:44,279 --> 00:16:46,320
the the error

364
00:16:46,320 --> 00:16:47,040
um

365
00:16:47,040 --> 00:16:50,820
so this allows us to having this

366
00:16:50,820 --> 00:16:53,040
restriction allows us to

367
00:16:53,040 --> 00:16:56,759
um encode the the shares uh in this form

368
00:16:56,759 --> 00:16:59,880
so we we sort of have you can see here

369
00:16:59,880 --> 00:17:01,680
we have a special type of encryption

370
00:17:01,680 --> 00:17:05,579
where our encrypted value is uh X the

371
00:17:05,579 --> 00:17:08,280
secret x times the secret key so you can

372
00:17:08,280 --> 00:17:09,900
actually generate this ciphertext

373
00:17:09,900 --> 00:17:12,780
without knowledge of the secret key

374
00:17:12,780 --> 00:17:16,260
um and um this secret key is going to

375
00:17:16,260 --> 00:17:19,619
sort of be used up on each uh inner

376
00:17:19,619 --> 00:17:22,679
product so uh that's why you always need

377
00:17:22,679 --> 00:17:25,679
a sort of fresh Cipher text which comes

378
00:17:25,679 --> 00:17:27,720
from an input value

379
00:17:27,720 --> 00:17:29,400
thank you

380
00:17:29,400 --> 00:17:31,080
thank you for the question other

381
00:17:31,080 --> 00:17:34,380
questions anybody

382
00:17:34,380 --> 00:17:37,559
okay if not well thanks thanks speaker

383
00:17:37,559 --> 00:17:39,860
again

384
00:18:06,960 --> 00:18:09,780
and next talk will be discretization

385
00:18:09,780 --> 00:18:12,120
error reduction for high Precision

386
00:18:12,120 --> 00:18:15,419
Taurus fully homomorphic encryption and

387
00:18:15,419 --> 00:18:18,120
Kang Hoon Lee will give the talk

388
00:18:18,120 --> 00:18:22,100
once his microphone is set up

389
00:18:32,940 --> 00:18:35,900
ah

390
00:18:36,780 --> 00:18:39,480
thanks for the introduction uh I'm

391
00:18:39,480 --> 00:18:41,820
kangali from Korean University School of

392
00:18:41,820 --> 00:18:43,919
cyber security I'm here to present our

393
00:18:43,919 --> 00:18:47,039
paper uh discretization and reduction

394
00:18:47,039 --> 00:18:49,020
for high Precision Source volume of big

395
00:18:49,020 --> 00:18:51,480
encryption this is doing work with G1

396
00:18:51,480 --> 00:18:54,299
Yoon who is my advisor

397
00:18:54,299 --> 00:18:57,299
foreign

398
00:18:58,100 --> 00:19:00,480
introduction about homework encryption

399
00:19:00,480 --> 00:19:02,820
which is an encryption scheme that

400
00:19:02,820 --> 00:19:05,160
allows to operate with encrypt data

401
00:19:05,160 --> 00:19:08,580
without decryption so the server or the

402
00:19:08,580 --> 00:19:10,500
cloud gets the encryption of X with the

403
00:19:10,500 --> 00:19:13,080
user secret key and they evaluate the

404
00:19:13,080 --> 00:19:15,900
circuit the circuit for f so they will

405
00:19:15,900 --> 00:19:19,140
cut they will evaluating they will they

406
00:19:19,140 --> 00:19:21,480
will get the encryption of FX without X

407
00:19:21,480 --> 00:19:22,679
revealed

408
00:19:22,679 --> 00:19:25,320
then the user will get the encryption of

409
00:19:25,320 --> 00:19:28,080
FX and then decrypt with his or her

410
00:19:28,080 --> 00:19:31,679
secret key and retrieve the effects

411
00:19:31,679 --> 00:19:33,500
so when it comes to fully homework

412
00:19:33,500 --> 00:19:37,520
encryption uh based they are capable of

413
00:19:37,520 --> 00:19:40,679
evaluating circuit with arbitrary depths

414
00:19:40,679 --> 00:19:43,620
in order to support arbitrary devs they

415
00:19:43,620 --> 00:19:45,419
usually comes with a recryption

416
00:19:45,419 --> 00:19:48,740
procedure called bootstrap

417
00:19:48,740 --> 00:19:51,360
these are the notations we are going to

418
00:19:51,360 --> 00:19:54,780
use throughout the presentation and some

419
00:19:54,780 --> 00:19:57,960
important notation is the large n which

420
00:19:57,960 --> 00:20:01,020
which I assume to be a Power of Two And

421
00:20:01,020 --> 00:20:02,700
I'm going to use it as the ring

422
00:20:02,700 --> 00:20:04,280
Dimension parameter

423
00:20:04,280 --> 00:20:08,280
and the next parameter is the new there

424
00:20:08,280 --> 00:20:10,980
is uh which I call it the extension

425
00:20:10,980 --> 00:20:12,960
parameter uh I'm going to explain it

426
00:20:12,960 --> 00:20:15,059
later

427
00:20:15,059 --> 00:20:18,539
so our work is based on the tfhg scheme

428
00:20:18,539 --> 00:20:21,299
which is a scheme introduced by

429
00:20:21,299 --> 00:20:22,880
julote

430
00:20:22,880 --> 00:20:25,260
its security is based on the learning

431
00:20:25,260 --> 00:20:27,299
with the errors problem and it's worked

432
00:20:27,299 --> 00:20:29,240
with three different Cy protect spaces

433
00:20:29,240 --> 00:20:32,580
namely the Taurus lwe Taurus ring of we

434
00:20:32,580 --> 00:20:35,039
and the tourist ring GSW

435
00:20:35,039 --> 00:20:38,039
I'll just exclude the term Taurus from

436
00:20:38,039 --> 00:20:40,980
now on for Simplicity uh they all the

437
00:20:40,980 --> 00:20:43,380
Wayside protects encrypts a Taurus

438
00:20:43,380 --> 00:20:46,620
element n and it's actually a n plus one

439
00:20:46,620 --> 00:20:50,340
dimensional Vector up towards elements

440
00:20:50,340 --> 00:20:52,380
instead of being a w e server text

441
00:20:52,380 --> 00:20:55,559
encrypts a Taurus polynomial and on part

442
00:20:55,559 --> 00:20:57,840
from these two polynomials the ranges of

443
00:20:57,840 --> 00:20:59,880
server text encrypts a integer

444
00:20:59,880 --> 00:21:03,240
polynomial ZX but in practice they

445
00:21:03,240 --> 00:21:06,240
usually just encrypt a single integer uh

446
00:21:06,240 --> 00:21:12,539
just like PSI the secret key of the user

447
00:21:12,539 --> 00:21:16,320
so tfbg is famous for his uh fast

448
00:21:16,320 --> 00:21:18,360
bootstrapping based on the external

449
00:21:18,360 --> 00:21:19,140
product

450
00:21:19,140 --> 00:21:21,840
uh it is a simple multiplication between

451
00:21:21,840 --> 00:21:23,820
the ring jsw and the regional to

452
00:21:23,820 --> 00:21:25,080
receptor text

453
00:21:25,080 --> 00:21:29,100
so after the external product it returns

454
00:21:29,100 --> 00:21:31,679
a regulatory server text encrypting the

455
00:21:31,679 --> 00:21:34,020
MX multiplied by the interior polynomial

456
00:21:34,020 --> 00:21:35,820
CX

457
00:21:35,820 --> 00:21:37,980
So based on the external product those

458
00:21:37,980 --> 00:21:39,960
tfh bootstrapping homomorphically

459
00:21:39,960 --> 00:21:42,059
decrypts tail to be Cy protects by

460
00:21:42,059 --> 00:21:44,159
calculating the controlled North circuit

461
00:21:44,159 --> 00:21:47,880
for every element in the l2e Cyber text

462
00:21:47,880 --> 00:21:50,400
the control mouse is actually a

463
00:21:50,400 --> 00:21:52,559
homorphic selection algorithm to select

464
00:21:52,559 --> 00:21:55,159
between the rotated accumulator

465
00:21:55,159 --> 00:21:59,400
or the original accumulator based on the

466
00:21:59,400 --> 00:22:00,900
value of Si

467
00:22:00,900 --> 00:22:03,960
if the SI encrypts one it selects the

468
00:22:03,960 --> 00:22:06,419
rotated accumulatory accumulator

469
00:22:06,419 --> 00:22:09,480
multiplied by the X to the power bar a I

470
00:22:09,480 --> 00:22:12,600
or if it encrypts zero it just selects

471
00:22:12,600 --> 00:22:15,659
the original cumulate

472
00:22:15,659 --> 00:22:18,900
after the evaluation the

473
00:22:18,900 --> 00:22:22,380
the the after the evaluation it Returns

474
00:22:22,380 --> 00:22:24,720
the Renault WWE surface encrypting the

475
00:22:24,720 --> 00:22:28,200
rotated MX which is rotated by the

476
00:22:28,200 --> 00:22:30,240
amount of the message to LW exam

477
00:22:30,240 --> 00:22:32,900
protects holes

478
00:22:34,020 --> 00:22:37,380
uh so we Pro uh I'm going to introduce

479
00:22:37,380 --> 00:22:40,200
our major contribution of our uh paper

480
00:22:40,200 --> 00:22:44,299
the extended bootstrapping for tfhe

481
00:22:44,580 --> 00:22:47,280
so given the function f over the tourist

482
00:22:47,280 --> 00:22:49,919
the functional tfh bootstrapping is Con

483
00:22:49,919 --> 00:22:52,740
is actually a series of these four

484
00:22:52,740 --> 00:22:55,500
algorithms starting from the l2b

485
00:22:55,500 --> 00:22:58,140
ciphertext the Taurus elements appeal to

486
00:22:58,140 --> 00:23:00,480
server text are converted into a

487
00:23:00,480 --> 00:23:02,820
insurance based module to n

488
00:23:02,820 --> 00:23:05,580
during this conversion surrounding

489
00:23:05,580 --> 00:23:07,919
errors are added to the Cyber text after

490
00:23:07,919 --> 00:23:10,020
the conversion the homorphic decryption

491
00:23:10,020 --> 00:23:12,299
circuit which I which we call the blind

492
00:23:12,299 --> 00:23:15,419
rotation are evaluated and then the

493
00:23:15,419 --> 00:23:18,240
extracted then the lto reserve protects

494
00:23:18,240 --> 00:23:22,140
are extracted and the key switch back to

495
00:23:22,140 --> 00:23:23,520
its original key

496
00:23:23,520 --> 00:23:26,340
so the user so the cloud will get the

497
00:23:26,340 --> 00:23:30,918
encryption of F M Bar

498
00:23:31,080 --> 00:23:34,559
so our work focus is on the mode the mod

499
00:23:34,559 --> 00:23:36,360
switch and the blind rotation algorithm

500
00:23:36,360 --> 00:23:39,240
in order to reduce the rounding error

501
00:23:39,240 --> 00:23:42,120
that comes from the most which the uh

502
00:23:42,120 --> 00:23:45,320
that comes from the monster

503
00:23:45,380 --> 00:23:48,419
uh we first observed the Precision the

504
00:23:48,419 --> 00:23:51,000
change of precision in kfhg bootstrap

505
00:23:51,000 --> 00:23:52,860
after some homorphic operations

506
00:23:52,860 --> 00:23:57,000
including a addition or duplications uh

507
00:23:57,000 --> 00:23:59,039
the ciphertext is ready to be uh

508
00:23:59,039 --> 00:24:01,320
bootstrapped and at first it is first

509
00:24:01,320 --> 00:24:05,100
mod switch to the Z module two in which

510
00:24:05,100 --> 00:24:08,039
uh which incurs a severe Precision loss

511
00:24:08,039 --> 00:24:10,100
during the

512
00:24:10,100 --> 00:24:14,400
conversion so it's like uh looking up to

513
00:24:14,400 --> 00:24:18,000
the most significant log to m beats and

514
00:24:18,000 --> 00:24:19,200
this

515
00:24:19,200 --> 00:24:22,020
uh this makes us to use a small message

516
00:24:22,020 --> 00:24:24,720
procedure a typical choice for n would

517
00:24:24,720 --> 00:24:27,240
be a 10 to the power of 2 which is about

518
00:24:27,240 --> 00:24:31,080
1000 and in that case we can only use

519
00:24:31,080 --> 00:24:33,120
the message precision as like four to

520
00:24:33,120 --> 00:24:35,400
five bits

521
00:24:35,400 --> 00:24:38,760
so what we aim here is to reduce the

522
00:24:38,760 --> 00:24:40,559
Precision loss that comes from the most

523
00:24:40,559 --> 00:24:44,340
switch by modifying the blind rotation

524
00:24:44,340 --> 00:24:46,980
algorithm and the mod switch at home

525
00:24:46,980 --> 00:24:50,640
so we can use a large message space for

526
00:24:50,640 --> 00:24:53,480
our cycle text

527
00:24:54,059 --> 00:24:57,299
there are some approaches that that aim

528
00:24:57,299 --> 00:25:00,780
to reduce this error uh one the first

529
00:25:00,780 --> 00:25:03,240
approach is to reduce the Hamming rate

530
00:25:03,240 --> 00:25:05,760
of the secret key uh secret key of the

531
00:25:05,760 --> 00:25:07,260
LTB surface

532
00:25:07,260 --> 00:25:10,380
uh the second one is to increase the

533
00:25:10,380 --> 00:25:13,200
ring Dimension and that is we look up to

534
00:25:13,200 --> 00:25:16,500
more bits of the ciphertext uh our work

535
00:25:16,500 --> 00:25:19,200
aims to uh

536
00:25:19,200 --> 00:25:22,080
increase the efficiency of the second

537
00:25:22,080 --> 00:25:25,260
second approach

538
00:25:25,260 --> 00:25:27,900
so enlarging the ring Dimension has its

539
00:25:27,900 --> 00:25:31,980
pros and cons some advantages can uh

540
00:25:31,980 --> 00:25:34,980
will be uh will be able to use a small

541
00:25:34,980 --> 00:25:36,960
standard deviation for the window to be

542
00:25:36,960 --> 00:25:40,200
separate fixed and like I said we can

543
00:25:40,200 --> 00:25:43,320
reduce from the module switch

544
00:25:43,320 --> 00:25:47,700
uh severe disadvantage will be the Quasi

545
00:25:47,700 --> 00:25:48,960
linear growth for the polymer

546
00:25:48,960 --> 00:25:51,720
multiplication uh and since the tfh

547
00:25:51,720 --> 00:25:55,020
bootstrapping has consists of tons of

548
00:25:55,020 --> 00:25:57,600
polynomial multiplication it brings a

549
00:25:57,600 --> 00:26:02,360
severe slowdown for the tfh bootstrap

550
00:26:02,640 --> 00:26:05,400
so our first proposal is a cybertex

551
00:26:05,400 --> 00:26:08,279
intention to a smaller Dimension to a

552
00:26:08,279 --> 00:26:11,400
large servant so our extension parameter

553
00:26:11,400 --> 00:26:14,279
comes here so

554
00:26:14,279 --> 00:26:19,740
okay so if we use a new as zero it will

555
00:26:19,740 --> 00:26:23,640
be just be a simple identity mapping but

556
00:26:23,640 --> 00:26:27,179
if you like use new as one uh we are

557
00:26:27,179 --> 00:26:29,760
sending the polynomial Dimension and 2

558
00:26:29,760 --> 00:26:34,220
times 2N uh which uh in which the

559
00:26:34,220 --> 00:26:37,860
the coefficients of the power of X will

560
00:26:37,860 --> 00:26:40,559
be all zero and the even the wave

561
00:26:40,559 --> 00:26:43,140
coefficients up to even power of X will

562
00:26:43,140 --> 00:26:44,760
be exactly the same as the original

563
00:26:44,760 --> 00:26:47,460
polynomial

564
00:26:47,460 --> 00:26:50,700
so with this zero padding we extend the

565
00:26:50,700 --> 00:26:52,919
Ring of w e and the ring just W side

566
00:26:52,919 --> 00:26:56,159
protects into a larger Dimension uh 2 to

567
00:26:56,159 --> 00:26:57,600
the power of Nu n

568
00:26:57,600 --> 00:27:02,159
so we use the notation sub x to the 2D

569
00:27:02,159 --> 00:27:04,679
node that these polynomials are extended

570
00:27:04,679 --> 00:27:07,820
by a zero pattern

571
00:27:07,820 --> 00:27:10,380
the nice thing about this zero padding

572
00:27:10,380 --> 00:27:12,960
is that the external product naturally

573
00:27:12,960 --> 00:27:15,720
follows to the ring dimension of 2 to

574
00:27:15,720 --> 00:27:17,940
the power of Nu times n

575
00:27:17,940 --> 00:27:20,400
so we can evaluate the control mode

576
00:27:20,400 --> 00:27:22,980
circuit still on this larger ring

577
00:27:22,980 --> 00:27:26,279
Dimension while we while we set the

578
00:27:26,279 --> 00:27:28,919
parameter as n

579
00:27:28,919 --> 00:27:31,200
so in this case we can model the switch

580
00:27:31,200 --> 00:27:34,020
to a larger Dimension 2 to the power of

581
00:27:34,020 --> 00:27:36,179
Nu plus 1 times n

582
00:27:36,179 --> 00:27:39,000
thereby gaining an additional new piece

583
00:27:39,000 --> 00:27:41,640
of precision during the ball switch

584
00:27:41,640 --> 00:27:44,820
however this external product on a

585
00:27:44,820 --> 00:27:47,220
larger Dimension needs to perform the

586
00:27:47,220 --> 00:27:49,559
polynomial multiplication on Dimension

587
00:27:49,559 --> 00:27:53,340
due to the power of Nu times n so it is

588
00:27:53,340 --> 00:27:55,740
quite inefficient

589
00:27:55,740 --> 00:27:59,580
so we introduce our second proposal the

590
00:27:59,580 --> 00:28:02,039
parallel external external front

591
00:28:02,039 --> 00:28:04,140
it is based on the modularized morphism

592
00:28:04,140 --> 00:28:07,320
we call it Tau which place the

593
00:28:07,320 --> 00:28:10,200
polynomial into Vector of polynomial

594
00:28:10,200 --> 00:28:12,539
subtimage n

595
00:28:12,539 --> 00:28:14,700
uh

596
00:28:14,700 --> 00:28:18,840
so we like both the large green LW type

597
00:28:18,840 --> 00:28:22,500
into a multiple being l2b ciphertext of

598
00:28:22,500 --> 00:28:23,580
dimension

599
00:28:23,580 --> 00:28:28,340
with length 2 to the power of Nu

600
00:28:28,700 --> 00:28:32,340
sadly uh the external product does not

601
00:28:32,340 --> 00:28:36,179
follow naturally in this case so uh we

602
00:28:36,179 --> 00:28:40,380
have to uh there so the public key has

603
00:28:40,380 --> 00:28:44,100
to satisfy some conditions uh just

604
00:28:44,100 --> 00:28:47,159
condition one and two so the though both

605
00:28:47,159 --> 00:28:49,320
ranges W cyber text and the ring Adobe

606
00:28:49,320 --> 00:28:52,020
side protects has to be encrypted by the

607
00:28:52,020 --> 00:28:53,400
extended key

608
00:28:53,400 --> 00:28:56,940
also the ring just W ciphertext has to

609
00:28:56,940 --> 00:29:00,480
be an extension from Avengers topic of a

610
00:29:00,480 --> 00:29:03,059
smaller Dimension and and this is the

611
00:29:03,059 --> 00:29:06,000
most important condition that the GSW

612
00:29:06,000 --> 00:29:08,279
separately has to encrypt only the

613
00:29:08,279 --> 00:29:10,980
integer not the integer polynomial

614
00:29:10,980 --> 00:29:13,679
but this condition is quite common in

615
00:29:13,679 --> 00:29:15,659
the official literature because they are

616
00:29:15,659 --> 00:29:17,820
their ordinary Works their ordinary

617
00:29:17,820 --> 00:29:21,899
Works in FIB uh only zeros and one

618
00:29:21,899 --> 00:29:25,740
so we can split the external product in

619
00:29:25,740 --> 00:29:29,399
a larger Dimension to a independent uh

620
00:29:29,399 --> 00:29:32,399
external products in small in smaller

621
00:29:32,399 --> 00:29:35,059
Dimension n

622
00:29:35,059 --> 00:29:37,799
using this parallel external product we

623
00:29:37,799 --> 00:29:39,840
can build a parallel controlled box

624
00:29:39,840 --> 00:29:43,140
circuit that's shaped like this

625
00:29:43,140 --> 00:29:45,899
so each row are independent to each

626
00:29:45,899 --> 00:29:48,600
other and can be parallel and can be

627
00:29:48,600 --> 00:29:50,460
computed in power

628
00:29:50,460 --> 00:29:55,200
so a one zMAX circuit evaluation on the

629
00:29:55,200 --> 00:29:58,140
dimension to 200 times n is equivalent

630
00:29:58,140 --> 00:29:59,880
to running two to the new seam of

631
00:29:59,880 --> 00:30:03,960
circuits of Dimension and Imperial

632
00:30:03,960 --> 00:30:07,140
so in summary we propose a extended

633
00:30:07,140 --> 00:30:09,419
bootstrapping in abbreviation I call it

634
00:30:09,419 --> 00:30:14,340
the EBS for the tfhe so when we even if

635
00:30:14,340 --> 00:30:18,659
we use a small n for the ring we can

636
00:30:18,659 --> 00:30:20,240
always

637
00:30:20,240 --> 00:30:22,860
enlarge the end during the bootstrapping

638
00:30:22,860 --> 00:30:27,360
and gain additional new bits the new is

639
00:30:27,360 --> 00:30:30,720
a negative integer so you can uh Cloud

640
00:30:30,720 --> 00:30:33,779
can always select which uh how big the

641
00:30:33,779 --> 00:30:34,980
new is

642
00:30:34,980 --> 00:30:38,100
and also we are able to keep small ring

643
00:30:38,100 --> 00:30:40,740
Dimension and ring Dimension ends so we

644
00:30:40,740 --> 00:30:44,279
do not have to implement a uh High

645
00:30:44,279 --> 00:30:47,460
Precision fft to support a large

646
00:30:47,460 --> 00:30:50,640
dimensional polynomial multiplication

647
00:30:50,640 --> 00:30:53,340
also our plane rotation is parallelized

648
00:30:53,340 --> 00:30:56,700
so we can also always enjoy the low

649
00:30:56,700 --> 00:30:59,460
latency of the tfh bootstrapping as long

650
00:30:59,460 --> 00:31:03,779
as our computational power allows

651
00:31:03,779 --> 00:31:06,080
so we provide some experimental results

652
00:31:06,080 --> 00:31:09,840
uh we implemented our Eds on top of the

653
00:31:09,840 --> 00:31:13,200
tfpg library along with the three

654
00:31:13,200 --> 00:31:16,080
state-of-the-art full domain functional

655
00:31:16,080 --> 00:31:19,140
boost tracking algorithms they all uses

656
00:31:19,140 --> 00:31:21,120
the tfhg function bootstrapping as a

657
00:31:21,120 --> 00:31:23,880
solve algorithms and the codes are

658
00:31:23,880 --> 00:31:26,940
available publicly at our GitHub page in

659
00:31:26,940 --> 00:31:28,679
the link

660
00:31:28,679 --> 00:31:32,820
and this is our experimental set

661
00:31:32,820 --> 00:31:35,279
so these are the parameters we used for

662
00:31:35,279 --> 00:31:38,279
our paper uh we in this presentation we

663
00:31:38,279 --> 00:31:40,320
are only going to show the results for

664
00:31:40,320 --> 00:31:42,419
the upper half but there's the time

665
00:31:42,419 --> 00:31:45,960
limit uh and the first three parameters

666
00:31:45,960 --> 00:31:49,140
are shared exactly the same parameters

667
00:31:49,140 --> 00:31:51,799
except for the ring entwist

668
00:31:51,799 --> 00:31:57,419
uh we did this to compare whether uh the

669
00:31:57,419 --> 00:32:00,419
selecting small n along with using with

670
00:32:00,419 --> 00:32:03,600
our EBS is better or just selecting a

671
00:32:03,600 --> 00:32:06,120
large dimensional type large dimension

672
00:32:06,120 --> 00:32:09,080
for n is that

673
00:32:09,179 --> 00:32:12,600
so this is the performance of the first

674
00:32:12,600 --> 00:32:15,299
three parameter set which is non-parel

675
00:32:15,299 --> 00:32:18,720
the y-axis uh represents the latency in

676
00:32:18,720 --> 00:32:22,140
milliseconds in the lower remix lower

677
00:32:22,140 --> 00:32:24,960
rhythmic scale of Base 2.

678
00:32:24,960 --> 00:32:28,980
the x-axis uh represents the log 2N plus

679
00:32:28,980 --> 00:32:32,159
the extension parameter Nu that starts

680
00:32:32,159 --> 00:32:33,840
from 0.

681
00:32:33,840 --> 00:32:37,380
as you can see uh using a smaller

682
00:32:37,380 --> 00:32:40,740
dimension for n and using our EBS is

683
00:32:40,740 --> 00:32:43,860
slightly better than using the large

684
00:32:43,860 --> 00:32:47,779
dimension for the ring damage

685
00:32:47,779 --> 00:32:50,700
so this is the performance result for

686
00:32:50,700 --> 00:32:54,659
the parallelized EBS uh we can also see

687
00:32:54,659 --> 00:32:57,539
that our EBS fully benefits from the

688
00:32:57,539 --> 00:33:01,200
proper parallel parallelization

689
00:33:01,200 --> 00:33:04,520
to see that the Precision actually grow

690
00:33:04,520 --> 00:33:08,399
we evaluate some function a simple sign

691
00:33:08,399 --> 00:33:13,879
function over the domain minus 64 to 64.

692
00:33:13,919 --> 00:33:16,440
so we evaluated this with the full

693
00:33:16,440 --> 00:33:17,640
domain functional bootstrapping

694
00:33:17,640 --> 00:33:22,140
algorithms and the red line here is the

695
00:33:22,140 --> 00:33:24,360
max is the maximal Precision we

696
00:33:24,360 --> 00:33:26,399
estimated with our error estimation

697
00:33:26,399 --> 00:33:28,919
formula

698
00:33:28,919 --> 00:33:32,279
we can observe the Precision in the

699
00:33:32,279 --> 00:33:34,019
y-axis

700
00:33:34,019 --> 00:33:36,720
shows a linear growth in precision as

701
00:33:36,720 --> 00:33:38,940
the extension parameter new

702
00:33:38,940 --> 00:33:42,860
in the x-axis rows

703
00:33:43,260 --> 00:33:45,799
they

704
00:33:51,600 --> 00:33:54,678
don't take any questions

705
00:33:59,840 --> 00:34:02,580
can you say again for this extension

706
00:34:02,580 --> 00:34:05,279
parameter how do you choose it or how

707
00:34:05,279 --> 00:34:06,320
does it

708
00:34:06,320 --> 00:34:09,179
extension parameter is a it's just a

709
00:34:09,179 --> 00:34:11,219
non-negative integer that you can select

710
00:34:11,219 --> 00:34:15,839
freely uh so you have to select uh

711
00:34:15,839 --> 00:34:20,639
uh by calc by estimating the error from

712
00:34:20,639 --> 00:34:24,540
the bootstrapping and the mouse so the

713
00:34:24,540 --> 00:34:29,099
uh so using a non as using a positive uh

714
00:34:29,099 --> 00:34:31,980
integer for the extension parameter uh

715
00:34:31,980 --> 00:34:34,800
decreases the mode switch errors so uh

716
00:34:34,800 --> 00:34:36,899
you can increase it as long as the mod

717
00:34:36,899 --> 00:34:39,000
switch error is larger than the

718
00:34:39,000 --> 00:34:40,940
bootstrapping error

719
00:34:40,940 --> 00:34:46,040
and you can calculate that with a error

720
00:34:46,040 --> 00:34:49,199
estimation so what what are like typical

721
00:34:49,199 --> 00:34:52,080
values that you choose for it

722
00:34:52,080 --> 00:34:52,918
um

723
00:34:52,918 --> 00:34:54,780
it's it's really different from

724
00:34:54,780 --> 00:34:57,420
parameter to parameter yes so you have

725
00:34:57,420 --> 00:35:00,660
to manually calculate the matches what's

726
00:35:00,660 --> 00:35:03,180
the range in the in your experiments

727
00:35:03,180 --> 00:35:04,080
what

728
00:35:04,080 --> 00:35:08,040
like oh we used uh zero to eight in this

729
00:35:08,040 --> 00:35:12,020
experiment oh that's the bottom yes yes

730
00:35:15,420 --> 00:35:18,300
and can you talk about it asymptotically

731
00:35:18,300 --> 00:35:21,300
also or is it just is it really it's for

732
00:35:21,300 --> 00:35:23,480
implementing and

733
00:35:23,480 --> 00:35:27,180
uh sorry is there an is there a way to

734
00:35:27,180 --> 00:35:28,740
describe it asymptotically how you

735
00:35:28,740 --> 00:35:30,300
should choose it I mean you're saying

736
00:35:30,300 --> 00:35:31,740
you compare it to the two errors but

737
00:35:31,740 --> 00:35:33,300
you're saying yes I guess not it's

738
00:35:33,300 --> 00:35:36,000
complicated to to calculate where to put

739
00:35:36,000 --> 00:35:37,619
it yeah

740
00:35:37,619 --> 00:35:40,260
okay

741
00:35:40,260 --> 00:35:43,920
any other questions

742
00:35:43,920 --> 00:35:47,359
no thanks speaker

743
00:36:25,980 --> 00:36:28,680
the next talk is verifiable capacity

744
00:36:28,680 --> 00:36:31,320
bound functions a new primitive from

745
00:36:31,320 --> 00:36:33,599
kamogorov complexity and the talk will

746
00:36:33,599 --> 00:36:38,460
be given by Danilo oh boy uh from Kathy

747
00:36:38,460 --> 00:36:40,800
yeah

748
00:36:40,800 --> 00:36:43,020
thank you for the introduction uh this

749
00:36:43,020 --> 00:36:46,220
is John worked with Joseph

750
00:36:49,460 --> 00:36:51,780
uh so let's assume we have a machine

751
00:36:51,780 --> 00:36:54,060
that executed a function on some input

752
00:36:54,060 --> 00:36:56,640
and we want to measure the efficiency of

753
00:36:56,640 --> 00:36:57,720
the function

754
00:36:57,720 --> 00:36:59,460
what we usually do we measure the

755
00:36:59,460 --> 00:37:01,200
efficiency according to the resource

756
00:37:01,200 --> 00:37:03,599
usage like time space and even energy

757
00:37:03,599 --> 00:37:06,020
consumed by the machine

758
00:37:06,020 --> 00:37:08,760
uh we usually want to minimize this

759
00:37:08,760 --> 00:37:10,560
usage but in this talk we're going to do

760
00:37:10,560 --> 00:37:12,119
the top the opposite so we're going to

761
00:37:12,119 --> 00:37:14,700
talk about function that waste resources

762
00:37:14,700 --> 00:37:17,160
to get some kind of production

763
00:37:17,160 --> 00:37:20,099
so let's have an example suppose we have

764
00:37:20,099 --> 00:37:23,040
a database in which we store the hashes

765
00:37:23,040 --> 00:37:25,680
of some passwords now if you get hacked

766
00:37:25,680 --> 00:37:27,900
you can start doing a blue flow an

767
00:37:27,900 --> 00:37:29,339
offline Brute Force attack and you

768
00:37:29,339 --> 00:37:31,680
extract the passwords so a way to block

769
00:37:31,680 --> 00:37:33,599
these attack is to use a research

770
00:37:33,599 --> 00:37:35,579
demanding function so a function that

771
00:37:35,579 --> 00:37:38,460
weighs resources so now if that battery

772
00:37:38,460 --> 00:37:40,680
does have enough resources you

773
00:37:40,680 --> 00:37:42,480
you are safe at least some of the parts

774
00:37:42,480 --> 00:37:45,300
cannot be extracted

775
00:37:45,300 --> 00:37:49,380
um now according to the time we can have

776
00:37:49,380 --> 00:37:51,240
some kind of example like time lock

777
00:37:51,240 --> 00:37:52,320
encryption

778
00:37:52,320 --> 00:37:55,380
for space we have memory card then call

779
00:37:55,380 --> 00:37:57,839
that function a lot of space to be

780
00:37:57,839 --> 00:37:58,859
computed

781
00:37:58,859 --> 00:38:00,839
and also for energy we have an example

782
00:38:00,839 --> 00:38:02,820
that is boundary heart function so it's

783
00:38:02,820 --> 00:38:07,440
a function that waste energy uh while

784
00:38:07,440 --> 00:38:09,060
you you complete a function and we're

785
00:38:09,060 --> 00:38:10,740
gonna see um

786
00:38:10,740 --> 00:38:12,900
then

787
00:38:12,900 --> 00:38:14,400
the intuition behind the construction

788
00:38:14,400 --> 00:38:17,520
ladder so but let's change the setting

789
00:38:17,520 --> 00:38:19,680
now suppose we are in the decentralized

790
00:38:19,680 --> 00:38:21,839
setting in which you have an evaluator

791
00:38:21,839 --> 00:38:23,400
that computes the function and then the

792
00:38:23,400 --> 00:38:25,020
functional the output is sent to the

793
00:38:25,020 --> 00:38:27,240
verifiers to check the validity

794
00:38:27,240 --> 00:38:30,320
this could be like a proof of work and

795
00:38:30,320 --> 00:38:32,940
and the protocol is a blockchain

796
00:38:32,940 --> 00:38:34,680
protocol

797
00:38:34,680 --> 00:38:36,480
um so in this setting you want to

798
00:38:36,480 --> 00:38:38,160
protect yourself from a malicious

799
00:38:38,160 --> 00:38:42,119
Evolution that's for example tries to uh

800
00:38:42,119 --> 00:38:44,400
try different inputs until you find a

801
00:38:44,400 --> 00:38:46,020
particular output that gives you some

802
00:38:46,020 --> 00:38:47,940
kind of Advantage like predicting the

803
00:38:47,940 --> 00:38:49,680
next block of the blockchain

804
00:38:49,680 --> 00:38:51,599
and also on the other hand the verifiers

805
00:38:51,599 --> 00:38:53,160
as the honest parties at least the

806
00:38:53,160 --> 00:38:54,660
majority of them

807
00:38:54,660 --> 00:38:56,520
so you can use for example in this

808
00:38:56,520 --> 00:38:58,260
setting the resource the money function

809
00:38:58,260 --> 00:38:59,880
again but now you have a problem that

810
00:38:59,880 --> 00:39:01,320
the honest part is going to waste

811
00:39:01,320 --> 00:39:02,820
resources because you need to check the

812
00:39:02,820 --> 00:39:04,920
validity by running the function again

813
00:39:04,920 --> 00:39:07,619
so the idea is here is that some

814
00:39:07,619 --> 00:39:09,900
sometimes we need some kind of public

815
00:39:09,900 --> 00:39:12,540
verifiability property that the we need

816
00:39:12,540 --> 00:39:14,099
to verify the correction of the output

817
00:39:14,099 --> 00:39:16,140
without wasting resources so the

818
00:39:16,140 --> 00:39:18,480
verification must be resource free let's

819
00:39:18,480 --> 00:39:19,380
say

820
00:39:19,380 --> 00:39:21,900
so we have an example for time that is a

821
00:39:21,900 --> 00:39:26,160
verifiable belly function uh so uh for

822
00:39:26,160 --> 00:39:28,740
space and energy the recent and what we

823
00:39:28,740 --> 00:39:30,960
do we introduce the notion of verifiable

824
00:39:30,960 --> 00:39:32,820
capacity bound function that is mainly

825
00:39:32,820 --> 00:39:35,520
an energy demanding function

826
00:39:35,520 --> 00:39:38,760
but it's closely related with space as

827
00:39:38,760 --> 00:39:40,079
we're gonna see

828
00:39:40,079 --> 00:39:42,240
so the intuition is that on evaluation

829
00:39:42,240 --> 00:39:43,560
we are going to consume a lot of energy

830
00:39:43,560 --> 00:39:45,839
and the verification is almost energy

831
00:39:45,839 --> 00:39:46,800
free

832
00:39:46,800 --> 00:39:49,740
and now the question is how can we

833
00:39:49,740 --> 00:39:52,560
measure the energy consumed by by your

834
00:39:52,560 --> 00:39:54,720
machine even if we have different kind

835
00:39:54,720 --> 00:39:56,700
of architecture that waste they use

836
00:39:56,700 --> 00:39:58,619
different amount of energy when you do

837
00:39:58,619 --> 00:40:00,300
some kind of computation

838
00:40:00,300 --> 00:40:02,099
so the intuition comes from the Weber

839
00:40:02,099 --> 00:40:03,839
abundant heart function that

840
00:40:03,839 --> 00:40:06,960
show empirically that they have a

841
00:40:06,960 --> 00:40:08,760
bottleneck called that detection and the

842
00:40:08,760 --> 00:40:11,220
bottom is that when you read bits from

843
00:40:11,220 --> 00:40:13,980
the ram either because you move the bits

844
00:40:13,980 --> 00:40:15,900
the cache or to the CPU to perform some

845
00:40:15,900 --> 00:40:17,460
kind of computation you're gonna waste

846
00:40:17,460 --> 00:40:19,619
by unity of energy and the unit is more

847
00:40:19,619 --> 00:40:22,020
or less the same across the all the

848
00:40:22,020 --> 00:40:24,420
architecture we have including Asics for

849
00:40:24,420 --> 00:40:25,920
example

850
00:40:25,920 --> 00:40:28,020
so the idea is for the function is to

851
00:40:28,020 --> 00:40:30,000
maximize this amount on evaluation and

852
00:40:30,000 --> 00:40:33,859
minimize the same amount of verification

853
00:40:33,920 --> 00:40:37,079
uh we we propose some definition to

854
00:40:37,079 --> 00:40:38,760
Define these properties so the first

855
00:40:38,760 --> 00:40:41,280
property is called minimum capacity so

856
00:40:41,280 --> 00:40:43,079
even if you precompute the function if I

857
00:40:43,079 --> 00:40:45,300
give you an input and you compute the

858
00:40:45,300 --> 00:40:47,700
correct output of the function then we

859
00:40:47,700 --> 00:40:49,320
know that the best is going to read and

860
00:40:49,320 --> 00:40:51,320
distinct bits from the memory

861
00:40:51,320 --> 00:40:54,359
and this is this is knife because now if

862
00:40:54,359 --> 00:40:56,520
your cache is of size B you can preload

863
00:40:56,520 --> 00:40:58,200
that must be beats in the cache and now

864
00:40:58,200 --> 00:41:00,119
you're gonna read at least n minus bits

865
00:41:00,119 --> 00:41:02,160
from the main memory and that's the

866
00:41:02,160 --> 00:41:04,320
amount of energy you're going to consume

867
00:41:04,320 --> 00:41:08,280
uh on verification uh we want sound rest

868
00:41:08,280 --> 00:41:10,380
so you can give a proof to check the

869
00:41:10,380 --> 00:41:12,420
correctness of the output it should be

870
00:41:12,420 --> 00:41:15,300
hard to convince the verifier when the

871
00:41:15,300 --> 00:41:17,640
the output is not correct

872
00:41:17,640 --> 00:41:20,040
and also we want the efficiency that

873
00:41:20,040 --> 00:41:22,099
essentially says that the verification

874
00:41:22,099 --> 00:41:24,240
requires really deep bits from the

875
00:41:24,240 --> 00:41:26,460
memory and DC is way smaller than M

876
00:41:26,460 --> 00:41:28,740
where m is the minimum capacity of the

877
00:41:28,740 --> 00:41:30,720
function

878
00:41:30,720 --> 00:41:33,960
so with propose a construction that we

879
00:41:33,960 --> 00:41:36,060
go from come over from Plexi to measure

880
00:41:36,060 --> 00:41:37,859
the space requirement to evaluate the

881
00:41:37,859 --> 00:41:39,359
polynomial

882
00:41:39,359 --> 00:41:42,119
and then we use this polynomial to build

883
00:41:42,119 --> 00:41:43,560
the function

884
00:41:43,560 --> 00:41:45,960
we Face some problems I mean the

885
00:41:45,960 --> 00:41:47,339
construction that we have at some kind

886
00:41:47,339 --> 00:41:48,599
of limitations that we're gonna see

887
00:41:48,599 --> 00:41:50,339
later uh

888
00:41:50,339 --> 00:41:53,040
but I mean the the intuition of the work

889
00:41:53,040 --> 00:41:54,540
is to light the ground of the function

890
00:41:54,540 --> 00:41:55,920
and the definition

891
00:41:55,920 --> 00:41:58,079
so the first part is the following so

892
00:41:58,079 --> 00:42:00,839
let me introduce come over complexity uh

893
00:42:00,839 --> 00:42:02,940
we want to measure the description of an

894
00:42:02,940 --> 00:42:04,020
object

895
00:42:04,020 --> 00:42:06,300
so an object of binary string and a

896
00:42:06,300 --> 00:42:08,280
description of an object is a pair so

897
00:42:08,280 --> 00:42:11,339
it's algorithm T and an input Alpha and

898
00:42:11,339 --> 00:42:13,200
this is about the description if t on

899
00:42:13,200 --> 00:42:16,200
input Alpha outputs the object

900
00:42:16,200 --> 00:42:19,260
now we can look at T like at the

901
00:42:19,260 --> 00:42:21,599
compression algorithm and Alpha's at the

902
00:42:21,599 --> 00:42:23,820
compression of the object for example

903
00:42:23,820 --> 00:42:25,740
now if you fix T we can Define the

904
00:42:25,740 --> 00:42:27,660
column of complexity as the length of

905
00:42:27,660 --> 00:42:30,540
the smallest string that on input that t

906
00:42:30,540 --> 00:42:32,700
on input the string Alpha gives you an

907
00:42:32,700 --> 00:42:34,500
input option it gives you an output

908
00:42:34,500 --> 00:42:35,880
option

909
00:42:35,880 --> 00:42:37,619
now the problem with this notion now

910
00:42:37,619 --> 00:42:39,839
that depends on the algorithm but we

911
00:42:39,839 --> 00:42:40,859
would like to have some kind of

912
00:42:40,859 --> 00:42:42,980
universal estimation of the complexity

913
00:42:42,980 --> 00:42:44,820
especially when we want to prove

914
00:42:44,820 --> 00:42:47,040
security and we can do that by using vs3

915
00:42:47,040 --> 00:42:48,960
machine so we we set the university

916
00:42:48,960 --> 00:42:51,900
machine as the the turing machine of the

917
00:42:51,900 --> 00:42:55,320
complexity so now the description is not

918
00:42:55,320 --> 00:42:57,119
appearing more but it's simply the input

919
00:42:57,119 --> 00:42:59,760
of the universal turing machine

920
00:42:59,760 --> 00:43:02,640
uh so from this notion we can define a

921
00:43:02,640 --> 00:43:04,980
scene compressibility so an object is

922
00:43:04,980 --> 00:43:07,319
incompressible if the golden complexity

923
00:43:07,319 --> 00:43:09,540
of the object is greater or equal than

924
00:43:09,540 --> 00:43:12,839
the size of the object minus C

925
00:43:12,839 --> 00:43:15,180
and the cool fact is that in any given

926
00:43:15,180 --> 00:43:17,160
set arbitrary set if you know the

927
00:43:17,160 --> 00:43:20,040
cardinality M we also know the number of

928
00:43:20,040 --> 00:43:22,440
incompressible objects in the set so

929
00:43:22,440 --> 00:43:24,060
this is the amount that you see on the

930
00:43:24,060 --> 00:43:26,280
slide that is that depends on both

931
00:43:26,280 --> 00:43:29,339
uh the cardinality m and the factor C of

932
00:43:29,339 --> 00:43:31,680
this incompressibility

933
00:43:31,680 --> 00:43:34,740
okay so that we know this notion let me

934
00:43:34,740 --> 00:43:36,780
Define what's the problem we want to

935
00:43:36,780 --> 00:43:39,540
tackle uh so polymer evaluation we have

936
00:43:39,540 --> 00:43:41,280
a polynomial of degree d

937
00:43:41,280 --> 00:43:43,560
and now we have a machine that takes an

938
00:43:43,560 --> 00:43:46,079
input some points and uh gives you an

939
00:43:46,079 --> 00:43:48,839
output evaluation on those points and

940
00:43:48,839 --> 00:43:50,819
what we want to measure is this

941
00:43:50,819 --> 00:43:52,500
bits that you need to read from the

942
00:43:52,500 --> 00:43:54,660
memory to correctly evaluate the the the

943
00:43:54,660 --> 00:43:56,460
polynomial so intuitively what you're

944
00:43:56,460 --> 00:43:57,720
going to read is an encoding of the

945
00:43:57,720 --> 00:43:59,400
polynomial

946
00:43:59,400 --> 00:44:01,200
so what we show in the paper is that

947
00:44:01,200 --> 00:44:02,640
suppose you have this machine on the

948
00:44:02,640 --> 00:44:05,339
right that uh takes in input D plus one

949
00:44:05,339 --> 00:44:08,160
points and reads A String Alpha from the

950
00:44:08,160 --> 00:44:10,380
memory if the machine and assume that

951
00:44:10,380 --> 00:44:12,359
the machine is giving you an output the

952
00:44:12,359 --> 00:44:14,760
correct evaluations so we can say that

953
00:44:14,760 --> 00:44:17,220
Alpha plus the points is a description

954
00:44:17,220 --> 00:44:18,900
for the polynomial because you can

955
00:44:18,900 --> 00:44:21,300
simply take Alpha the inputs

956
00:44:21,300 --> 00:44:23,460
run the machine takes the valuation and

957
00:44:23,460 --> 00:44:25,380
then do interpolation to reconstruct the

958
00:44:25,380 --> 00:44:27,180
polynomial

959
00:44:27,180 --> 00:44:29,579
so this means that Alpha the size of

960
00:44:29,579 --> 00:44:30,839
alpha is related to the golden

961
00:44:30,839 --> 00:44:33,300
complexity of the polynomial and that's

962
00:44:33,300 --> 00:44:36,119
what we show so we showed that if the

963
00:44:36,119 --> 00:44:39,020
polynomial is incompressible then

964
00:44:39,020 --> 00:44:42,119
uh for every table of D plus one points

965
00:44:42,119 --> 00:44:45,359
that are all different then we know that

966
00:44:45,359 --> 00:44:47,339
if you correctly compute the evaluations

967
00:44:47,339 --> 00:44:49,200
then the size of the string that you

968
00:44:49,200 --> 00:44:50,339
read from the memory is more or less

969
00:44:50,339 --> 00:44:52,680
greater than this value here that is D

970
00:44:52,680 --> 00:44:55,380
plus one times the random minus L minus

971
00:44:55,380 --> 00:44:57,420
C so D plus 1 is the number of

972
00:44:57,420 --> 00:44:59,700
coefficients you have Lambda is the size

973
00:44:59,700 --> 00:45:01,440
of a coefficient

974
00:45:01,440 --> 00:45:03,540
the minus L is a loss proportional to

975
00:45:03,540 --> 00:45:05,520
the input because that's part of the

976
00:45:05,520 --> 00:45:06,540
description

977
00:45:06,540 --> 00:45:08,880
and minus C is the loss of this

978
00:45:08,880 --> 00:45:12,599
incompressibility of the polynomial

979
00:45:12,599 --> 00:45:15,540
so now how can we use this to build

980
00:45:15,540 --> 00:45:17,640
verifiable capacity Bank functions so

981
00:45:17,640 --> 00:45:19,800
these are the properties I'm going to

982
00:45:19,800 --> 00:45:22,140
talk about minimum capacity mainly

983
00:45:22,140 --> 00:45:23,700
and the definition that I'm going to

984
00:45:23,700 --> 00:45:25,140
describe here is a weaker definition

985
00:45:25,140 --> 00:45:26,940
than the one that we want to achieve

986
00:45:26,940 --> 00:45:29,280
we're going to see the limitation later

987
00:45:29,280 --> 00:45:31,440
so suppose we have an evaluator that has

988
00:45:31,440 --> 00:45:34,800
access to Taiwan Tau T strings

989
00:45:34,800 --> 00:45:38,400
and each of these strings of size m and

990
00:45:38,400 --> 00:45:40,260
the correct way to interpret the string

991
00:45:40,260 --> 00:45:42,119
is that each tau is an information

992
00:45:42,119 --> 00:45:44,839
encoding to the memory that you can read

993
00:45:44,839 --> 00:45:48,060
interpret and perform a correct uh

994
00:45:48,060 --> 00:45:49,859
computation on it

995
00:45:49,859 --> 00:45:52,980
so in this definition you is okay so

996
00:45:52,980 --> 00:45:55,380
towels are pre-computed by looking at

997
00:45:55,380 --> 00:45:56,819
the function

998
00:45:56,819 --> 00:46:00,240
and now you you get a random point you

999
00:46:00,240 --> 00:46:01,800
can read one of them

1000
00:46:01,800 --> 00:46:04,560
you can put the output and now we say

1001
00:46:04,560 --> 00:46:05,819
that the function is secure if the

1002
00:46:05,819 --> 00:46:07,260
probability of getting the correct

1003
00:46:07,260 --> 00:46:08,460
output

1004
00:46:08,460 --> 00:46:11,460
it's utmost Epsilon and this is nice

1005
00:46:11,460 --> 00:46:13,020
because I suppose you have an upper

1006
00:46:13,020 --> 00:46:15,300
bound on T then the only way to compute

1007
00:46:15,300 --> 00:46:16,440
the function is to read something that

1008
00:46:16,440 --> 00:46:17,700
is greater than m

1009
00:46:17,700 --> 00:46:19,920
that's what we want to do

1010
00:46:19,920 --> 00:46:23,460
uh so now if you fix the function we go

1011
00:46:23,460 --> 00:46:26,700
to the polynomial we

1012
00:46:26,700 --> 00:46:28,980
uh we can prove the following so if T is

1013
00:46:28,980 --> 00:46:31,020
equal to equal to one then we can use

1014
00:46:31,020 --> 00:46:34,319
this theorem we can set m equal to the

1015
00:46:34,319 --> 00:46:36,599
size of alpha of the theorem and now we

1016
00:46:36,599 --> 00:46:37,859
are guaranteed that when you read the

1017
00:46:37,859 --> 00:46:40,319
Tau you can answer mostly points because

1018
00:46:40,319 --> 00:46:42,780
the Y is contradicted theorem and since

1019
00:46:42,780 --> 00:46:45,420
the point is sample random you you have

1020
00:46:45,420 --> 00:46:47,579
disadvantages so it's D over the input

1021
00:46:47,579 --> 00:46:48,960
space

1022
00:46:48,960 --> 00:46:51,720
the size of the impulse pane

1023
00:46:51,720 --> 00:46:55,619
uh now if you have more strings you your

1024
00:46:55,619 --> 00:46:57,000
advantage is going to be multiplied by T

1025
00:46:57,000 --> 00:46:58,680
simply because you can read only one of

1026
00:46:58,680 --> 00:47:01,260
those uh those styles

1027
00:47:01,260 --> 00:47:03,359
uh the missing part is that we need an

1028
00:47:03,359 --> 00:47:04,859
incompressible as incompressible

1029
00:47:04,859 --> 00:47:08,040
polynomial and uh so we know the number

1030
00:47:08,040 --> 00:47:09,599
of seeing compressible objects in a

1031
00:47:09,599 --> 00:47:10,560
given set

1032
00:47:10,560 --> 00:47:12,780
the set here is the set of polynomials

1033
00:47:12,780 --> 00:47:14,520
and by playing with the parameters I

1034
00:47:14,520 --> 00:47:15,359
mean this is the number of

1035
00:47:15,359 --> 00:47:16,800
syncompressive polynomial in the given

1036
00:47:16,800 --> 00:47:17,579
set

1037
00:47:17,579 --> 00:47:19,560
and by playing with the parameters we

1038
00:47:19,560 --> 00:47:22,140
can show that for large enough C but not

1039
00:47:22,140 --> 00:47:24,180
too much we can get

1040
00:47:24,180 --> 00:47:25,800
a scene compressible polynomial by

1041
00:47:25,800 --> 00:47:27,660
simply a random from the set

1042
00:47:27,660 --> 00:47:29,460
and this means that the function is

1043
00:47:29,460 --> 00:47:31,020
going to have a setup to honestly

1044
00:47:31,020 --> 00:47:33,300
generate the polynomial or

1045
00:47:33,300 --> 00:47:36,119
honestly because we need to be to have

1046
00:47:36,119 --> 00:47:38,220
an honest sampling of the polynomial and

1047
00:47:38,220 --> 00:47:40,859
this is reminiscent from the PDF also

1048
00:47:40,859 --> 00:47:43,260
that has a processor

1049
00:47:43,260 --> 00:47:45,380
um

1050
00:47:45,560 --> 00:47:48,960
in this definition we can prove that if

1051
00:47:48,960 --> 00:47:51,240
you read M bits what m is close enough

1052
00:47:51,240 --> 00:47:53,520
to the size of the polynomial but not

1053
00:47:53,520 --> 00:47:55,980
exactly the same then your advantage is

1054
00:47:55,980 --> 00:47:58,140
going to be negligible even if you have

1055
00:47:58,140 --> 00:48:00,300
an exponential amount of tiles that you

1056
00:48:00,300 --> 00:48:02,760
can read you can choose from

1057
00:48:02,760 --> 00:48:04,800
now the problem with this definition is

1058
00:48:04,800 --> 00:48:06,960
the following now I'm talking about

1059
00:48:06,960 --> 00:48:08,700
tiles so information that you can read

1060
00:48:08,700 --> 00:48:10,859
from the memory but to use this

1061
00:48:10,859 --> 00:48:13,140
definition and practice we need to have

1062
00:48:13,140 --> 00:48:14,819
an estimation of the memory not the

1063
00:48:14,819 --> 00:48:16,079
number of information encoded on the

1064
00:48:16,079 --> 00:48:17,040
memory

1065
00:48:17,040 --> 00:48:18,839
so we would like to say like if your

1066
00:48:18,839 --> 00:48:20,640
machine has a one terabyte of storage

1067
00:48:20,640 --> 00:48:23,520
then there is no way to read

1068
00:48:23,520 --> 00:48:25,800
less than n Bits And correctly compute

1069
00:48:25,800 --> 00:48:26,819
the output

1070
00:48:26,819 --> 00:48:28,680
so we need to find a way to transform

1071
00:48:28,680 --> 00:48:32,000
this T into a memory size

1072
00:48:32,000 --> 00:48:35,400
and this turnouts to not be easy simply

1073
00:48:35,400 --> 00:48:37,859
because for example Tau 1 and Tau 2 may

1074
00:48:37,859 --> 00:48:40,680
have a common pattern inside and while

1075
00:48:40,680 --> 00:48:43,260
you could encode this information into

1076
00:48:43,260 --> 00:48:45,720
the main memory by not repeating the red

1077
00:48:45,720 --> 00:48:46,680
pattern

1078
00:48:46,680 --> 00:48:48,540
and then you leverage the random access

1079
00:48:48,540 --> 00:48:50,579
to the memory to reconstruct tau1 and

1080
00:48:50,579 --> 00:48:53,819
Tau 2 when according when you need it

1081
00:48:53,819 --> 00:48:56,040
so the question is I mean again what's

1082
00:48:56,040 --> 00:48:59,520
the relation between T and A Memory that

1083
00:48:59,520 --> 00:49:01,380
is of size n that it's going to encode

1084
00:49:01,380 --> 00:49:03,780
these informations

1085
00:49:03,780 --> 00:49:07,079
so uh what we show is that I mean what

1086
00:49:07,079 --> 00:49:10,200
we can show is is the following so we

1087
00:49:10,200 --> 00:49:12,660
use accounting argument and we count

1088
00:49:12,660 --> 00:49:14,280
according to the number of Random Access

1089
00:49:14,280 --> 00:49:15,900
you do to the memory

1090
00:49:15,900 --> 00:49:18,540
and we can achieve this definition that

1091
00:49:18,540 --> 00:49:20,160
is the final one the one that we would

1092
00:49:20,160 --> 00:49:21,839
like because we have a memory of size n

1093
00:49:21,839 --> 00:49:24,119
with the following parameter so we have

1094
00:49:24,119 --> 00:49:27,300
M and plus before Epsilon has before and

1095
00:49:27,300 --> 00:49:29,339
now this parameter hold if you have a

1096
00:49:29,339 --> 00:49:31,920
memory Access Financial site but under

1097
00:49:31,920 --> 00:49:34,020
the constraint that you do only cost a

1098
00:49:34,020 --> 00:49:35,819
number of random access to the memory so

1099
00:49:35,819 --> 00:49:38,040
you jump into the memory and you read

1100
00:49:38,040 --> 00:49:40,319
all your custom number of times

1101
00:49:40,319 --> 00:49:42,720
now if you do a non-constant number of

1102
00:49:42,720 --> 00:49:44,640
Random Access where non-truster means

1103
00:49:44,640 --> 00:49:46,980
that depends on them now we have a very

1104
00:49:46,980 --> 00:49:49,440
loose bound on n and technically we

1105
00:49:49,440 --> 00:49:51,420
don't have a clear estimation about this

1106
00:49:51,420 --> 00:49:52,920
unit of the function when you do this

1107
00:49:52,920 --> 00:49:55,020
kind of strategy

1108
00:49:55,020 --> 00:49:56,900
so uh

1109
00:49:56,900 --> 00:50:00,000
the question is if you can improve the

1110
00:50:00,000 --> 00:50:01,740
estimation of the memory bound when you

1111
00:50:01,740 --> 00:50:04,260
do non-constant random non-costal number

1112
00:50:04,260 --> 00:50:06,480
of random access to the memory while

1113
00:50:06,480 --> 00:50:08,400
keeping M close enough to the size of

1114
00:50:08,400 --> 00:50:10,020
the polynomial because we want to

1115
00:50:10,020 --> 00:50:11,579
maximize the number of bits we are going

1116
00:50:11,579 --> 00:50:13,440
to read

1117
00:50:13,440 --> 00:50:15,240
um there is a barrier and the bar is

1118
00:50:15,240 --> 00:50:17,339
this algorithm uh so there is this

1119
00:50:17,339 --> 00:50:20,040
algorithm that takes a polynomial and

1120
00:50:20,040 --> 00:50:22,140
pre-computes by building another

1121
00:50:22,140 --> 00:50:24,720
structure and the little structure is of

1122
00:50:24,720 --> 00:50:27,480
this side so n is going to be

1123
00:50:27,480 --> 00:50:31,079
D over 1 plus Delta or Delta is a cosine

1124
00:50:31,079 --> 00:50:33,420
times random more or less uh at least a

1125
00:50:33,420 --> 00:50:36,119
synthetically speaking and uh so it's

1126
00:50:36,119 --> 00:50:37,680
more than the size of the polynomial but

1127
00:50:37,680 --> 00:50:39,000
not too much

1128
00:50:39,000 --> 00:50:41,339
so it's polynomial essentially and then

1129
00:50:41,339 --> 00:50:44,280
on evaluation we can uh evaluate the

1130
00:50:44,280 --> 00:50:46,680
polynomial by using a non-constant

1131
00:50:46,680 --> 00:50:48,480
number of Random Access and reading this

1132
00:50:48,480 --> 00:50:50,760
amount of bits so polylog D times Lambda

1133
00:50:50,760 --> 00:50:52,619
that is way smaller than the size of the

1134
00:50:52,619 --> 00:50:54,540
polynomial because it's poly log in the

1135
00:50:54,540 --> 00:50:55,619
degree

1136
00:50:55,619 --> 00:50:57,720
So asymptotically speaking what I'm

1137
00:50:57,720 --> 00:50:59,400
saying is that we cannot go over these

1138
00:50:59,400 --> 00:51:01,559
parameters but maybe concretely but play

1139
00:51:01,559 --> 00:51:03,300
with the cost that we can get some kind

1140
00:51:03,300 --> 00:51:07,200
of concrete uh estimation

1141
00:51:07,200 --> 00:51:09,300
um very briefly regarding soundness so

1142
00:51:09,300 --> 00:51:11,339
what we show is that we can we have

1143
00:51:11,339 --> 00:51:12,599
soundness by using verifiable

1144
00:51:12,599 --> 00:51:13,740
computation

1145
00:51:13,740 --> 00:51:15,540
that is probably verifiable and public

1146
00:51:15,540 --> 00:51:17,640
deductible so on setup we also generate

1147
00:51:17,640 --> 00:51:20,040
some keys the key allows the evaluator

1148
00:51:20,040 --> 00:51:21,599
to produce the proof and the verifier

1149
00:51:21,599 --> 00:51:24,960
can use the same keys that are public to

1150
00:51:24,960 --> 00:51:27,900
verify the proof and regarding

1151
00:51:27,900 --> 00:51:30,780
efficiency what we show is the following

1152
00:51:30,780 --> 00:51:33,000
so we know that on evaluation we read

1153
00:51:33,000 --> 00:51:34,559
and beats close to the size of the

1154
00:51:34,559 --> 00:51:37,319
polynomial at least when we do cost and

1155
00:51:37,319 --> 00:51:39,000
number of Random Access

1156
00:51:39,000 --> 00:51:42,059
and on verification we can show the if

1157
00:51:42,059 --> 00:51:43,859
we use this verifiable computation here

1158
00:51:43,859 --> 00:51:47,339
from sfvcs to 2016.

1159
00:51:47,339 --> 00:51:48,720
what you're going to read from a memory

1160
00:51:48,720 --> 00:51:50,339
something that is proportional only to

1161
00:51:50,339 --> 00:51:51,960
the security parameter so independent

1162
00:51:51,960 --> 00:51:53,880
from the and that's why we get the

1163
00:51:53,880 --> 00:51:55,500
asymmetry

1164
00:51:55,500 --> 00:51:59,220
oh okay that's uh that's the end of my

1165
00:51:59,220 --> 00:52:02,480
talk thank you

1166
00:52:06,900 --> 00:52:09,619
questions

1167
00:52:13,920 --> 00:52:16,800
we have probably five minutes here so we

1168
00:52:16,800 --> 00:52:18,720
can if you don't have a question I'm

1169
00:52:18,720 --> 00:52:21,119
gonna ask a question it's maybe a little

1170
00:52:21,119 --> 00:52:23,880
more basic so I'm not so familiar with

1171
00:52:23,880 --> 00:52:25,260
this I was wondering if you could just

1172
00:52:25,260 --> 00:52:27,960
say again like uh what the different

1173
00:52:27,960 --> 00:52:29,940
parties do there's this Capital act that

1174
00:52:29,940 --> 00:52:31,640
you're working to make it hard to

1175
00:52:31,640 --> 00:52:35,700
evaluate right is that against the

1176
00:52:35,700 --> 00:52:38,099
so we want to build this function that

1177
00:52:38,099 --> 00:52:41,460
uh when you evaluate it we have a lower

1178
00:52:41,460 --> 00:52:43,200
bound on the number of energy

1179
00:52:43,200 --> 00:52:44,940
electricity you're gonna use do you have

1180
00:52:44,940 --> 00:52:47,460
a picture with the that describes the

1181
00:52:47,460 --> 00:52:49,200
general like just the basic setup with

1182
00:52:49,200 --> 00:52:52,879
capital F I think you had one

1183
00:52:56,520 --> 00:53:00,020
you mean this one

1184
00:53:01,380 --> 00:53:03,000
yeah

1185
00:53:03,000 --> 00:53:05,720
so like what's the difference between

1186
00:53:05,720 --> 00:53:08,280
the left bottom picture and the right

1187
00:53:08,280 --> 00:53:10,440
bottom picture like how can somebody do

1188
00:53:10,440 --> 00:53:13,559
verification versus that's a separate

1189
00:53:13,559 --> 00:53:15,660
protocol or how no it's the same product

1190
00:53:15,660 --> 00:53:17,339
so that when you evaluate the function

1191
00:53:17,339 --> 00:53:19,680
you you evaluate the function on X and

1192
00:53:19,680 --> 00:53:22,500
you produce y but together we why we all

1193
00:53:22,500 --> 00:53:24,599
you also produce a proof and the proof

1194
00:53:24,599 --> 00:53:26,880
is going to allow you on verification to

1195
00:53:26,880 --> 00:53:29,400
check if that is correct or not okay

1196
00:53:29,400 --> 00:53:32,160
it's similar to PDF the syntax so then

1197
00:53:32,160 --> 00:53:35,339
on the left this is on the left is the

1198
00:53:35,339 --> 00:53:37,079
defining a proof

1199
00:53:37,079 --> 00:53:39,900
like what's the what's the I still don't

1200
00:53:39,900 --> 00:53:42,540
quite figure one on the left yeah it's

1201
00:53:42,540 --> 00:53:44,460
minimum capacity there is the security

1202
00:53:44,460 --> 00:53:47,700
against uh an evaluator so here we're

1203
00:53:47,700 --> 00:53:49,859
gonna say that when you validate the

1204
00:53:49,859 --> 00:53:51,780
function if the output of the function

1205
00:53:51,780 --> 00:53:53,640
is correct then you're gonna read m

1206
00:53:53,640 --> 00:53:54,900
distingues

1207
00:53:54,900 --> 00:53:57,240
now the syntax of the function also

1208
00:53:57,240 --> 00:53:59,640
appends a proof and then the proof is

1209
00:53:59,640 --> 00:54:01,559
used on verification only so on the

1210
00:54:01,559 --> 00:54:02,940
right part now now we'll talk about the

1211
00:54:02,940 --> 00:54:05,160
verifier and we have sound rest and

1212
00:54:05,160 --> 00:54:07,020
efficiency so that part's easier so that

1213
00:54:07,020 --> 00:54:08,940
with the proof it's much easier than

1214
00:54:08,940 --> 00:54:11,700
yeah the problem is the minimum

1215
00:54:11,700 --> 00:54:13,140
capacitor and how do you estimate the

1216
00:54:13,140 --> 00:54:16,500
memory yeah yeah okay and then how does

1217
00:54:16,500 --> 00:54:19,740
someone use it initially if it's hard to

1218
00:54:19,740 --> 00:54:22,140
compute or I mean it's something that

1219
00:54:22,140 --> 00:54:24,300
you can compute yeah the problem is that

1220
00:54:24,300 --> 00:54:27,839
uh we yeah you're gonna use resources

1221
00:54:27,839 --> 00:54:29,640
that's that

1222
00:54:29,640 --> 00:54:32,040
and then what's code hard at this I saw

1223
00:54:32,040 --> 00:54:34,260
that as one of the uh Code art it's like

1224
00:54:34,260 --> 00:54:36,839
I think the clear example of code art

1225
00:54:36,839 --> 00:54:39,119
it's like a function which

1226
00:54:39,119 --> 00:54:41,520
on setup I mean I have an example so on

1227
00:54:41,520 --> 00:54:44,119
setup you

1228
00:54:44,119 --> 00:54:48,000
you you build like a random table

1229
00:54:48,000 --> 00:54:50,400
and I give you the random table and then

1230
00:54:50,400 --> 00:54:52,800
I'm gonna ask you give me this entry of

1231
00:54:52,800 --> 00:54:55,559
this table and since I'm gonna select

1232
00:54:55,559 --> 00:54:57,660
the entry of the table are random you

1233
00:54:57,660 --> 00:54:59,700
need to store let's say

1234
00:54:59,700 --> 00:55:02,579
the entire uh I mean the majority of the

1235
00:55:02,579 --> 00:55:04,079
database because otherwise I'm gonna hit

1236
00:55:04,079 --> 00:55:05,760
one that you don't know so that's called

1237
00:55:05,760 --> 00:55:08,099
that okay

1238
00:55:08,099 --> 00:55:10,140
thank you

1239
00:55:10,140 --> 00:55:13,160
any other questions

1240
00:55:15,720 --> 00:55:17,339
um so I think you you mentioned the

1241
00:55:17,339 --> 00:55:21,240
evaluation function is a polynomial and

1242
00:55:21,240 --> 00:55:24,420
uh that with high probability it is

1243
00:55:24,420 --> 00:55:27,000
actually energy demanding so is this a

1244
00:55:27,000 --> 00:55:29,280
random polynomial or is it just a random

1245
00:55:29,280 --> 00:55:31,380
number I mean it's a random polynomial

1246
00:55:31,380 --> 00:55:34,559
for Simplicity but technically if you

1247
00:55:34,559 --> 00:55:37,140
have a set of polynomials of where the

1248
00:55:37,140 --> 00:55:38,579
cardinality of this set is large enough

1249
00:55:38,579 --> 00:55:40,980
it's sufficient to sample from that cell

1250
00:55:40,980 --> 00:55:43,619
at least

1251
00:55:43,619 --> 00:55:46,140
and the the degree of the polynomial was

1252
00:55:46,140 --> 00:55:48,480
this D that was yeah it did fine so that

1253
00:55:48,480 --> 00:55:50,220
you need to set D according to how much

1254
00:55:50,220 --> 00:55:51,599
bits you want to read because that's the

1255
00:55:51,599 --> 00:55:53,760
only parameter we you for which you can

1256
00:55:53,760 --> 00:55:55,680
play with so the higher the more they

1257
00:55:55,680 --> 00:55:59,160
agree the higher the demon the mature

1258
00:55:59,160 --> 00:56:01,200
you have more coefficients and that's

1259
00:56:01,200 --> 00:56:02,880
they're gonna read more confused now

1260
00:56:02,880 --> 00:56:06,260
okay thank you

1261
00:56:06,359 --> 00:56:08,940
any other questions no thanks speaker

1262
00:56:08,940 --> 00:56:11,240
again

1263
00:56:37,800 --> 00:56:39,960
so in the last talking session is a

1264
00:56:39,960 --> 00:56:41,460
holistic approach towards side Channel

1265
00:56:41,460 --> 00:56:44,480
secure fixed wave polynomial sampling

1266
00:56:44,480 --> 00:56:50,480
and Marcus parks we didn't talk

1267
00:56:55,260 --> 00:56:56,760
okay

1268
00:56:56,760 --> 00:56:59,880
so hi and welcome to my talk about side

1269
00:56:59,880 --> 00:57:01,500
Channel secure fixed rate polynomial

1270
00:57:01,500 --> 00:57:02,760
sampling

1271
00:57:02,760 --> 00:57:04,559
so what is fixed rate polynomial

1272
00:57:04,559 --> 00:57:06,780
sampling it's quite a simple problem

1273
00:57:06,780 --> 00:57:08,880
actually we want to generate a random

1274
00:57:08,880 --> 00:57:11,640
bit string of length n and Hemingway's W

1275
00:57:11,640 --> 00:57:14,819
and for example with n equal to 10 and W

1276
00:57:14,819 --> 00:57:17,760
equal to 4 we have a bit string of links

1277
00:57:17,760 --> 00:57:21,900
10 where we have four ones and six zeros

1278
00:57:21,900 --> 00:57:24,420
and this bit string represents a bit

1279
00:57:24,420 --> 00:57:27,300
polynomial with 10 coefficients

1280
00:57:27,300 --> 00:57:30,359
and we call this representations a

1281
00:57:30,359 --> 00:57:32,280
coefficient representation but we could

1282
00:57:32,280 --> 00:57:34,440
also represent our bit polynomial in the

1283
00:57:34,440 --> 00:57:36,780
index representation where we simply

1284
00:57:36,780 --> 00:57:39,720
store the indices where

1285
00:57:39,720 --> 00:57:42,480
um the bit is one

1286
00:57:42,480 --> 00:57:44,700
and this is index representation we can

1287
00:57:44,700 --> 00:57:46,920
also rephrase our problem so what we

1288
00:57:46,920 --> 00:57:49,440
want is to draw W random elements from

1289
00:57:49,440 --> 00:57:51,960
the set 0 to n minus 1 without

1290
00:57:51,960 --> 00:57:55,740
replacement regardless of the order

1291
00:57:55,740 --> 00:57:58,559
so why do we need this actually we need

1292
00:57:58,559 --> 00:58:00,480
it quite a quite often and post Quantum

1293
00:58:00,480 --> 00:58:03,180
cryptography so there are some relevant

1294
00:58:03,180 --> 00:58:06,839
schemes that use this with some variety

1295
00:58:06,839 --> 00:58:09,059
and the most important parameters are of

1296
00:58:09,059 --> 00:58:11,760
course n and W and the resulting ratio

1297
00:58:11,760 --> 00:58:13,859
of w compared to n

1298
00:58:13,859 --> 00:58:16,200
so for bike and hqc for example we have

1299
00:58:16,200 --> 00:58:19,619
big n and small RW resulting in a very

1300
00:58:19,619 --> 00:58:22,339
small ratio

1301
00:58:22,400 --> 00:58:25,619
we have a medium sized n and for Andrew

1302
00:58:25,619 --> 00:58:28,859
and stream them into Prime then is small

1303
00:58:28,859 --> 00:58:31,619
and W is greater resulting in a ratio

1304
00:58:31,619 --> 00:58:33,900
that is close to 50 percent

1305
00:58:33,900 --> 00:58:36,000
so now you might be wondering why are we

1306
00:58:36,000 --> 00:58:38,040
talking about such a simple problem so

1307
00:58:38,040 --> 00:58:39,960
turns out if you want an efficient and

1308
00:58:39,960 --> 00:58:42,299
sidechain and secure implementation it's

1309
00:58:42,299 --> 00:58:44,640
not that easy yeah so side channel

1310
00:58:44,640 --> 00:58:46,140
security

1311
00:58:46,140 --> 00:58:48,059
when we when we talk about side channel

1312
00:58:48,059 --> 00:58:51,660
security we first have to evaluate uh

1313
00:58:51,660 --> 00:58:54,480
which values are secret and sensitive so

1314
00:58:54,480 --> 00:58:56,460
which values do we need to protect

1315
00:58:56,460 --> 00:58:58,740
against the side channels and for the

1316
00:58:58,740 --> 00:59:00,660
fixed rate polynomial sampling you we

1317
00:59:00,660 --> 00:59:02,819
have as inputs some Randomness and the

1318
00:59:02,819 --> 00:59:04,640
output is the polynomial

1319
00:59:04,640 --> 00:59:07,380
for other schemes

1320
00:59:07,380 --> 00:59:09,599
um this polynomial is a secret value so

1321
00:59:09,599 --> 00:59:12,599
our sampler must not leak any

1322
00:59:12,599 --> 00:59:14,760
information about the polynomial

1323
00:59:14,760 --> 00:59:16,680
but for some of the schemes we have an

1324
00:59:16,680 --> 00:59:19,260
additional requirement so the randomness

1325
00:59:19,260 --> 00:59:23,040
is generated by nprng and the seed the

1326
00:59:23,040 --> 00:59:25,680
input seat is a secret value therefore

1327
00:59:25,680 --> 00:59:27,780
the randomness is also secret dependent

1328
00:59:27,780 --> 00:59:29,760
and therefore our sampler must not

1329
00:59:29,760 --> 00:59:33,240
reveal anything about the randomness

1330
00:59:33,240 --> 00:59:34,619
foreign

1331
00:59:34,619 --> 00:59:36,480
so when I talk about side China security

1332
00:59:36,480 --> 00:59:39,480
talk about timing side channels and for

1333
00:59:39,480 --> 00:59:41,940
this um our common countermeasure is

1334
00:59:41,940 --> 00:59:43,920
constant time programming but in this

1335
00:59:43,920 --> 00:59:45,960
work we also focus on power side

1336
00:59:45,960 --> 00:59:48,059
channels and our content measure here is

1337
00:59:48,059 --> 00:59:48,960
masking

1338
00:59:48,960 --> 00:59:51,180
so a quick reminder about a constant

1339
00:59:51,180 --> 00:59:53,520
time program programming we basically

1340
00:59:53,520 --> 00:59:56,040
have three Simple Rules there

1341
00:59:56,040 --> 00:59:58,380
branches memory accesses and

1342
00:59:58,380 --> 01:00:00,240
instructions with Opera independent

1343
01:00:00,240 --> 01:00:02,220
runtime must not depend on any secret

1344
01:00:02,220 --> 01:00:03,299
values

1345
01:00:03,299 --> 01:00:05,160
and for the fixed by polynomial sampling

1346
01:00:05,160 --> 01:00:07,440
in memory accesses

1347
01:00:07,440 --> 01:00:10,319
um can be quite a problem

1348
01:00:10,319 --> 01:00:12,359
so for the power side channels as Chris

1349
01:00:12,359 --> 01:00:15,119
pikeout yesterday already introduced we

1350
01:00:15,119 --> 01:00:17,220
can use masking and the ideas here

1351
01:00:17,220 --> 01:00:19,500
secret values are split into random

1352
01:00:19,500 --> 01:00:22,020
shares and for first order Boolean

1353
01:00:22,020 --> 01:00:23,700
masking for example we would end up two

1354
01:00:23,700 --> 01:00:25,799
shares that we can combine with an XR

1355
01:00:25,799 --> 01:00:27,660
together original value

1356
01:00:27,660 --> 01:00:29,579
and as Chris explained the challenge

1357
01:00:29,579 --> 01:00:31,799
here is when we have non-linear

1358
01:00:31,799 --> 01:00:33,180
functions and they can be quite

1359
01:00:33,180 --> 01:00:34,980
expensive

1360
01:00:34,980 --> 01:00:36,900
so what are the methods that we can use

1361
01:00:36,900 --> 01:00:39,180
for fixed rate polynomial sampling so

1362
01:00:39,180 --> 01:00:41,280
they're basically six different methods

1363
01:00:41,280 --> 01:00:44,160
and we can put them into three distinct

1364
01:00:44,160 --> 01:00:45,480
categories

1365
01:00:45,480 --> 01:00:47,940
the first category is the rejection

1366
01:00:47,940 --> 01:00:51,599
sampling it outputs it polynomial in the

1367
01:00:51,599 --> 01:00:53,160
index representation

1368
01:00:53,160 --> 01:00:56,940
and then the next categories what I call

1369
01:00:56,940 --> 01:00:59,760
Setting bits randomly it works on the

1370
01:00:59,760 --> 01:01:02,339
coefficient representation and the last

1371
01:01:02,339 --> 01:01:05,040
category is shuffling it can either work

1372
01:01:05,040 --> 01:01:06,839
on index or on the coefficient

1373
01:01:06,839 --> 01:01:09,480
representation and they all also differ

1374
01:01:09,480 --> 01:01:11,819
by what I call this heat security so

1375
01:01:11,819 --> 01:01:13,619
what I mentioned whether it's possible

1376
01:01:13,619 --> 01:01:17,160
to implement them in a way that the seed

1377
01:01:17,160 --> 01:01:21,078
is not a lead virus High Channel

1378
01:01:21,180 --> 01:01:24,059
so let's jump into these categories so

1379
01:01:24,059 --> 01:01:26,099
rejection sampling is probably the most

1380
01:01:26,099 --> 01:01:27,599
straightforward solution for this

1381
01:01:27,599 --> 01:01:30,480
problem the idea here is that we sample

1382
01:01:30,480 --> 01:01:33,960
uniform random values from 0 to n and

1383
01:01:33,960 --> 01:01:36,000
reject a value if we have a collision so

1384
01:01:36,000 --> 01:01:38,040
if we already sampled the value before

1385
01:01:38,040 --> 01:01:41,160
and we just repeat this until we have W

1386
01:01:41,160 --> 01:01:43,020
distinct values

1387
01:01:43,020 --> 01:01:46,079
obviously this is not seat secure so

1388
01:01:46,079 --> 01:01:48,480
this would leak the seed or the random

1389
01:01:48,480 --> 01:01:49,680
method we are using because it

1390
01:01:49,680 --> 01:01:51,660
determines how many iterations we have

1391
01:01:51,660 --> 01:01:55,440
to do but we can transform this message

1392
01:01:55,440 --> 01:01:57,900
and to make it seed secure

1393
01:01:57,900 --> 01:02:01,140
and we call this a bounded method so

1394
01:02:01,140 --> 01:02:03,359
what we do here is we determine an upper

1395
01:02:03,359 --> 01:02:05,880
bound B of iterations in which this very

1396
01:02:05,880 --> 01:02:08,640
high probability enough distinct values

1397
01:02:08,640 --> 01:02:11,339
will be sampled and then we do exactly

1398
01:02:11,339 --> 01:02:14,339
always these B iterations and for each

1399
01:02:14,339 --> 01:02:17,579
value we always iterate our whole index

1400
01:02:17,579 --> 01:02:20,220
array to keep the current count Secret

1401
01:02:20,220 --> 01:02:22,380
and of course this adds some overhead so

1402
01:02:22,380 --> 01:02:24,119
this method only makes sense in a

1403
01:02:24,119 --> 01:02:26,400
scenario where we require this seat

1404
01:02:26,400 --> 01:02:28,559
security

1405
01:02:28,559 --> 01:02:30,839
so the next methods the setting random

1406
01:02:30,839 --> 01:02:33,240
bits there's this repeated ending

1407
01:02:33,240 --> 01:02:34,980
message the ideas here that we start

1408
01:02:34,980 --> 01:02:37,859
with a random polynomial of length n

1409
01:02:37,859 --> 01:02:40,319
and then we adapt The Weight by ending

1410
01:02:40,319 --> 01:02:43,380
or ordering random polynomials until our

1411
01:02:43,380 --> 01:02:46,619
desired weight w is reached so basically

1412
01:02:46,619 --> 01:02:48,359
we make use of the observation that we

1413
01:02:48,359 --> 01:02:50,700
when we and to

1414
01:02:50,700 --> 01:02:52,980
um random bit strings the way it can

1415
01:02:52,980 --> 01:02:55,799
only decrease not increase and if we are

1416
01:02:55,799 --> 01:02:58,140
to bit strings it can increase but not

1417
01:02:58,140 --> 01:03:01,200
decrease so when we make let's say a

1418
01:03:01,200 --> 01:03:02,760
clever combination of this ending and

1419
01:03:02,760 --> 01:03:05,700
ring to get to our desired weight

1420
01:03:05,700 --> 01:03:08,160
and an important observation is here

1421
01:03:08,160 --> 01:03:11,819
that the runtime is again

1422
01:03:11,819 --> 01:03:13,440
um depending on the randomness we get

1423
01:03:13,440 --> 01:03:15,000
and also

1424
01:03:15,000 --> 01:03:17,940
um if our ratio of w compared to n is

1425
01:03:17,940 --> 01:03:20,880
close to 50 this message can be fast

1426
01:03:20,880 --> 01:03:22,980
because this is like the expected rate

1427
01:03:22,980 --> 01:03:25,079
we get from a random bit string but if

1428
01:03:25,079 --> 01:03:28,380
our ratio is far away from the 50 and

1429
01:03:28,380 --> 01:03:31,859
then this method can be costly but we

1430
01:03:31,859 --> 01:03:34,500
have a solution for this yeah for

1431
01:03:34,500 --> 01:03:37,740
um for situations where where our ratio

1432
01:03:37,740 --> 01:03:39,440
is far away from the 50 percent we

1433
01:03:39,440 --> 01:03:42,299
basically you have a generalization of

1434
01:03:42,299 --> 01:03:44,819
this idea we call it a comparison method

1435
01:03:44,819 --> 01:03:47,339
therefore each coefficient we set a bit

1436
01:03:47,339 --> 01:03:49,920
with probability p

1437
01:03:49,920 --> 01:03:53,400
is include equal to W over n and then

1438
01:03:53,400 --> 01:03:55,319
basically resample the polynomial until

1439
01:03:55,319 --> 01:03:57,960
we get one with the desired weight

1440
01:03:57,960 --> 01:04:00,660
and we approximate P with a comparison

1441
01:04:00,660 --> 01:04:03,960
of a random L bit string

1442
01:04:03,960 --> 01:04:05,220
um

1443
01:04:05,220 --> 01:04:08,339
or basically our our p is in a range

1444
01:04:08,339 --> 01:04:12,059
from 0 to 1 and we scale it up with 2 to

1445
01:04:12,059 --> 01:04:14,940
the power of L and then if we take an L

1446
01:04:14,940 --> 01:04:16,740
bit string it will be in this range and

1447
01:04:16,740 --> 01:04:18,359
we compare it with a threshold and if

1448
01:04:18,359 --> 01:04:19,859
it's below the threshold we set the

1449
01:04:19,859 --> 01:04:22,140
coefficient to one if it's above we set

1450
01:04:22,140 --> 01:04:25,079
it to zero and in the Mast setting we

1451
01:04:25,079 --> 01:04:27,660
can do this bit slice so it's also

1452
01:04:27,660 --> 01:04:30,839
parallelizable so very comparable to the

1453
01:04:30,839 --> 01:04:33,420
ending method actually

1454
01:04:33,420 --> 01:04:35,760
last methods are the shuffling methods

1455
01:04:35,760 --> 01:04:38,339
the ideas here that we start with a

1456
01:04:38,339 --> 01:04:40,500
fixed polynomial of length n and the

1457
01:04:40,500 --> 01:04:43,079
correct way to W and then just apply a

1458
01:04:43,079 --> 01:04:44,940
random permutation yeah so for example

1459
01:04:44,940 --> 01:04:47,220
we set the first W

1460
01:04:47,220 --> 01:04:49,020
um coefficients to one and do a random

1461
01:04:49,020 --> 01:04:50,579
shuffling and then we end up with a

1462
01:04:50,579 --> 01:04:53,280
random polynomial question is now how do

1463
01:04:53,280 --> 01:04:54,660
we do the shuffling

1464
01:04:54,660 --> 01:04:56,640
and one solution is to do it with

1465
01:04:56,640 --> 01:05:00,000
sorting so when our method is to pair

1466
01:05:00,000 --> 01:05:02,339
each coefficient with a distinct random

1467
01:05:02,339 --> 01:05:04,680
number and then we sort the pairs

1468
01:05:04,680 --> 01:05:06,960
according to the random number and then

1469
01:05:06,960 --> 01:05:08,880
we get the random permutation of the

1470
01:05:08,880 --> 01:05:10,200
coefficients

1471
01:05:10,200 --> 01:05:13,200
and sorting can be somewhat efficiently

1472
01:05:13,200 --> 01:05:16,380
be done inside Channel secure

1473
01:05:16,380 --> 01:05:18,359
and now you might be wondering why don't

1474
01:05:18,359 --> 01:05:21,480
we use Fisheries shuffling well we can

1475
01:05:21,480 --> 01:05:24,059
use fisha Yates but it's usually not a

1476
01:05:24,059 --> 01:05:25,920
sidechain secure it's leaking the

1477
01:05:25,920 --> 01:05:29,460
permutation via the memory exercises but

1478
01:05:29,460 --> 01:05:31,619
we can transform it to make it scientist

1479
01:05:31,619 --> 01:05:35,160
secure but then it becomes quadratic but

1480
01:05:35,160 --> 01:05:37,200
there's still a use case for this the

1481
01:05:37,200 --> 01:05:39,119
idea is now that we start with an array

1482
01:05:39,119 --> 01:05:42,119
of the values from 0 to n minus 1 then

1483
01:05:42,119 --> 01:05:43,680
we apply a random permutation with

1484
01:05:43,680 --> 01:05:46,200
fisheries and then we take the first W

1485
01:05:46,200 --> 01:05:48,599
entries as a polynomial in the index

1486
01:05:48,599 --> 01:05:51,420
representation and Fisheries can be

1487
01:05:51,420 --> 01:05:54,059
stopped after the first W entries are

1488
01:05:54,059 --> 01:05:56,579
set so our runtime is predatric in W and

1489
01:05:56,579 --> 01:05:58,260
not n

1490
01:05:58,260 --> 01:06:00,540
yeah so these are all the methods that

1491
01:06:00,540 --> 01:06:03,299
at least we know and we implemented them

1492
01:06:03,299 --> 01:06:04,200
all

1493
01:06:04,200 --> 01:06:04,740
um

1494
01:06:04,740 --> 01:06:07,619
arbitrary order masked

1495
01:06:07,619 --> 01:06:08,400
um

1496
01:06:08,400 --> 01:06:12,960
and bit sliced in C and evaluated on a

1497
01:06:12,960 --> 01:06:14,940
cortic M4 microprocessor

1498
01:06:14,940 --> 01:06:16,740
so these are the results for the first

1499
01:06:16,740 --> 01:06:19,500
order I'm asking and let's look at the

1500
01:06:19,500 --> 01:06:21,540
Sorting approach in the middle

1501
01:06:21,540 --> 01:06:24,119
for bike in hqc we actually weren't able

1502
01:06:24,119 --> 01:06:25,740
to run it on the macro processor because

1503
01:06:25,740 --> 01:06:28,619
it requires too much Randomness and for

1504
01:06:28,619 --> 01:06:30,420
make a list for example it was a medium

1505
01:06:30,420 --> 01:06:32,280
sized end we can see it's not very

1506
01:06:32,280 --> 01:06:34,500
competitive approach yeah because it the

1507
01:06:34,500 --> 01:06:36,720
runtime really depends on n

1508
01:06:36,720 --> 01:06:39,599
and for Android and stream entry and

1509
01:06:39,599 --> 01:06:41,460
streamline Enterprise it's somewhat

1510
01:06:41,460 --> 01:06:43,140
acceptable

1511
01:06:43,140 --> 01:06:46,200
then for official Yates we can see for

1512
01:06:46,200 --> 01:06:48,740
example for HPC and make a lease

1513
01:06:48,740 --> 01:06:52,260
so runtime is very competitive because

1514
01:06:52,260 --> 01:06:55,859
it depends on W yeah

1515
01:06:55,859 --> 01:06:58,260
um and then the rejection method this is

1516
01:06:58,260 --> 01:07:00,359
not seat secure so we cannot use it for

1517
01:07:00,359 --> 01:07:03,359
bike and hqc but for the other cases

1518
01:07:03,359 --> 01:07:06,420
it's one of the fastest methods and for

1519
01:07:06,420 --> 01:07:08,640
a bike in hqc we can use the bounded

1520
01:07:08,640 --> 01:07:10,559
rejection methods

1521
01:07:10,559 --> 01:07:12,480
um and but this method doesn't make

1522
01:07:12,480 --> 01:07:14,520
sense for the other ones because it's

1523
01:07:14,520 --> 01:07:16,440
always lower than the rejection simple

1524
01:07:16,440 --> 01:07:18,839
rejection method but what we can also

1525
01:07:18,839 --> 01:07:20,760
see is that the bounded rejection method

1526
01:07:20,760 --> 01:07:23,039
is always lower than Fisheries so

1527
01:07:23,039 --> 01:07:24,660
actually there is no use case for the

1528
01:07:24,660 --> 01:07:26,400
bounded rejection message

1529
01:07:26,400 --> 01:07:28,140
and then we have the ending in

1530
01:07:28,140 --> 01:07:29,700
comparison methods they are also not

1531
01:07:29,700 --> 01:07:31,680
seen secure so not usable for bike in

1532
01:07:31,680 --> 01:07:33,359
hqc

1533
01:07:33,359 --> 01:07:35,760
um and they are also they can be the

1534
01:07:35,760 --> 01:07:37,859
fastest methods and what we can also see

1535
01:07:37,859 --> 01:07:39,900
is the comparison method is especially

1536
01:07:39,900 --> 01:07:42,960
faster in the case where we have a ratio

1537
01:07:42,960 --> 01:07:44,819
or make at least for example where the

1538
01:07:44,819 --> 01:07:46,619
ratio is two percent so very far away

1539
01:07:46,619 --> 01:07:48,539
from the 50 percent

1540
01:07:48,539 --> 01:07:51,119
so the outcome basically of our work is

1541
01:07:51,119 --> 01:07:53,280
yes we we can we have Solutions yes I

1542
01:07:53,280 --> 01:07:55,740
can secure solution for the use case but

1543
01:07:55,740 --> 01:07:58,020
actually they are all um very slow yeah

1544
01:07:58,020 --> 01:07:59,640
so these numbers that you see here they

1545
01:07:59,640 --> 01:08:01,619
are kilo Cycles so we're talking about

1546
01:08:01,619 --> 01:08:04,140
at least a million cycles for such a

1547
01:08:04,140 --> 01:08:05,640
simple operation

1548
01:08:05,640 --> 01:08:08,039
this is way more than we anticipated and

1549
01:08:08,039 --> 01:08:09,839
the way more that we would like to have

1550
01:08:09,839 --> 01:08:12,059
so we are actually actually still

1551
01:08:12,059 --> 01:08:14,760
looking for a viable solution and if you

1552
01:08:14,760 --> 01:08:17,698
have any ideas let me know

1553
01:08:17,698 --> 01:08:20,299
thank you

1554
01:08:25,738 --> 01:08:28,879
thank you questions

1555
01:08:37,679 --> 01:08:40,520
where I am

1556
01:08:42,660 --> 01:08:46,099
all right well it's thanks speak

1557
01:08:48,600 --> 01:08:51,199
foreign

1558
01:09:16,698 --> 01:09:21,238
ER buses 5 30 and 6 o'clock

1559
01:09:21,238 --> 01:09:24,719
hope to see you at the aquarium

1560
01:09:24,719 --> 01:09:27,319
yes

1561
01:09:28,439 --> 01:09:31,639
shuttles back

1562
01:09:32,219 --> 01:09:34,799
the second one back at 10.

1563
01:09:34,799 --> 01:09:37,020
I'm not sure what the first departure

1564
01:09:37,020 --> 01:09:40,279
time will be but

1565
01:09:41,279 --> 01:09:43,679
and we'll be meeting just the nice like

1566
01:09:43,679 --> 01:09:45,899
drop-off area right outside the hotel

1567
01:09:45,899 --> 01:09:48,379
lobby

