1
00:00:01,439 --> 00:00:03,600
uh so the first talk we have is the

2
00:00:03,600 --> 00:00:07,220
second of our best paper talks

3
00:00:09,120 --> 00:00:10,620
hello

4
00:00:10,620 --> 00:00:12,360
required

5
00:00:12,360 --> 00:00:14,580
hi are you able to hear me

6
00:00:14,580 --> 00:00:16,500
I'm just waiting for quiet on the room

7
00:00:16,500 --> 00:00:19,619
okay okay yeah so we have the second of

8
00:00:19,619 --> 00:00:22,140
our best paper talks now this is by uh

9
00:00:22,140 --> 00:00:24,539
Nadia Henninger and Keegan Ryan on the

10
00:00:24,539 --> 00:00:26,279
hidden number problem with small unknown

11
00:00:26,279 --> 00:00:29,099
multipliers Crypt analyzing Mega and six

12
00:00:29,099 --> 00:00:31,439
queries and other applications and

13
00:00:31,439 --> 00:00:34,320
Keegan will give the talk virtually

14
00:00:34,320 --> 00:00:35,880
great thank you for the introduction can

15
00:00:35,880 --> 00:00:37,200
I get confirmation that you can hear me

16
00:00:37,200 --> 00:00:39,500
all right

17
00:00:41,879 --> 00:00:44,520
all good and zoom

18
00:00:44,520 --> 00:00:46,500
all right perfect thank you

19
00:00:46,500 --> 00:00:48,539
all right so yes I'm Keegan Ryan and I'm

20
00:00:48,539 --> 00:00:49,739
presenting the hidden number problem

21
00:00:49,739 --> 00:00:51,420
with small unknown multipliers Crypt

22
00:00:51,420 --> 00:00:53,460
analyzing Mega in six queries and other

23
00:00:53,460 --> 00:00:55,020
applications

24
00:00:55,020 --> 00:00:57,360
so to begin this talk I'll mention a

25
00:00:57,360 --> 00:00:59,460
little bit about what Mega is

26
00:00:59,460 --> 00:01:02,160
so Vega is an encrypted cloud storage

27
00:01:02,160 --> 00:01:04,680
company so they're cloud storage so that

28
00:01:04,680 --> 00:01:06,720
means you can upload files to their

29
00:01:06,720 --> 00:01:09,360
service under your account uh but the

30
00:01:09,360 --> 00:01:11,159
fact that they're encrypted uh is

31
00:01:11,159 --> 00:01:12,840
because that they care about user

32
00:01:12,840 --> 00:01:16,020
privacy so even they themselves should

33
00:01:16,020 --> 00:01:17,700
not be able to see the plaintext of the

34
00:01:17,700 --> 00:01:19,740
files that you upload

35
00:01:19,740 --> 00:01:22,560
but these privacy guarantees were uh

36
00:01:22,560 --> 00:01:25,500
shown to be false in this paper from uh

37
00:01:25,500 --> 00:01:27,600
this year uh malleable encryption goes

38
00:01:27,600 --> 00:01:29,040
right from back in doll holler in

39
00:01:29,040 --> 00:01:31,200
Patterson where they showed that this

40
00:01:31,200 --> 00:01:32,820
assumption was false and it was possible

41
00:01:32,820 --> 00:01:35,759
to recover uh secret material from the

42
00:01:35,759 --> 00:01:37,140
surface

43
00:01:37,140 --> 00:01:39,659
Mega released the security update uh in

44
00:01:39,659 --> 00:01:42,540
a blog post discussing these attacks and

45
00:01:42,540 --> 00:01:45,360
in this blog post they uh noticed they

46
00:01:45,360 --> 00:01:47,880
noted that uh these vulnerabilities

47
00:01:47,880 --> 00:01:49,740
affected users who logged into their

48
00:01:49,740 --> 00:01:52,079
account at least 512 times

49
00:01:52,079 --> 00:01:54,240
so these vulnerabilities were not

50
00:01:54,240 --> 00:01:56,880
thought to affect people who only logged

51
00:01:56,880 --> 00:01:58,500
their account a few times which was the

52
00:01:58,500 --> 00:02:00,840
vast majority of users it only affected

53
00:02:00,840 --> 00:02:03,060
automated systems

54
00:02:03,060 --> 00:02:06,899
so uh our work was showing that these

55
00:02:06,899 --> 00:02:08,520
attacks were in fact possible with much

56
00:02:08,520 --> 00:02:10,919
fewer login attempts in fact only six

57
00:02:10,919 --> 00:02:14,459
login attempts and there's even uh newer

58
00:02:14,459 --> 00:02:15,780
work than that that shows it's possible

59
00:02:15,780 --> 00:02:17,760
to do it in two login attempts and I'll

60
00:02:17,760 --> 00:02:20,700
talk about that at the end

61
00:02:20,700 --> 00:02:24,420
so because all these attacks rely on a

62
00:02:24,420 --> 00:02:25,860
number of login attempts it helps to go

63
00:02:25,860 --> 00:02:27,959
through what the login process is for

64
00:02:27,959 --> 00:02:30,480
Mega and recall that because Mega is an

65
00:02:30,480 --> 00:02:33,900
encrypted system uh we need to make sure

66
00:02:33,900 --> 00:02:36,959
that the client has the encryption keys

67
00:02:36,959 --> 00:02:38,400
that they need and that the server

68
00:02:38,400 --> 00:02:40,980
cannot see the plaintext data

69
00:02:40,980 --> 00:02:43,019
and what are the problems with encrypted

70
00:02:43,019 --> 00:02:45,360
cloud storage systems is the problem of

71
00:02:45,360 --> 00:02:47,819
logging in on a new system where you

72
00:02:47,819 --> 00:02:49,680
don't have all the same key materials

73
00:02:49,680 --> 00:02:51,900
stored in fact the only secret material

74
00:02:51,900 --> 00:02:53,400
that the client has when logging in from

75
00:02:53,400 --> 00:02:55,980
a new system is their password or maybe

76
00:02:55,980 --> 00:02:58,260
an AES key derived from the password

77
00:02:58,260 --> 00:03:00,360
they have to somehow use this to

78
00:03:00,360 --> 00:03:01,920
bootstrap the remainder of the key

79
00:03:01,920 --> 00:03:04,019
material that they needed to decrypt

80
00:03:04,019 --> 00:03:05,700
their files

81
00:03:05,700 --> 00:03:07,319
so the server can't store the key

82
00:03:07,319 --> 00:03:09,540
material directly so instead the server

83
00:03:09,540 --> 00:03:12,000
stores an encrypted form of this key

84
00:03:12,000 --> 00:03:13,319
material

85
00:03:13,319 --> 00:03:15,120
during the login process the server

86
00:03:15,120 --> 00:03:17,220
sends the client the client's encrypted

87
00:03:17,220 --> 00:03:19,680
private key material and then the client

88
00:03:19,680 --> 00:03:21,840
can use their password derived key to

89
00:03:21,840 --> 00:03:23,700
decrypt it

90
00:03:23,700 --> 00:03:26,220
once the client decrypts it then the

91
00:03:26,220 --> 00:03:28,860
server and the client do this RSA type

92
00:03:28,860 --> 00:03:30,840
challenge to verify that the client

93
00:03:30,840 --> 00:03:33,720
successfully decrypted the challenge

94
00:03:33,720 --> 00:03:35,760
and decrypted the private key

95
00:03:35,760 --> 00:03:37,980
so the server creates a challenge plain

96
00:03:37,980 --> 00:03:41,159
text for RSA sends it to the client

97
00:03:41,159 --> 00:03:45,000
the ciphertext and then the client uses

98
00:03:45,000 --> 00:03:48,060
the decrypted private key to decrypt the

99
00:03:48,060 --> 00:03:51,120
RSA ciphertext take the plain text and

100
00:03:51,120 --> 00:03:53,220
then sends that back to the server as a

101
00:03:53,220 --> 00:03:55,200
way of confirming that the client was

102
00:03:55,200 --> 00:03:57,840
able to decrypt the challenge

103
00:03:57,840 --> 00:03:59,700
the server then authenticates the client

104
00:03:59,700 --> 00:04:01,739
if the challenge value matches what's

105
00:04:01,739 --> 00:04:02,879
expected

106
00:04:02,879 --> 00:04:06,599
and uh this then the server can go on to

107
00:04:06,599 --> 00:04:09,659
send client the encrypted files

108
00:04:09,659 --> 00:04:11,939
so in reality the client doesn't send

109
00:04:11,939 --> 00:04:14,099
the full plain text buffer the client

110
00:04:14,099 --> 00:04:16,320
only sends 43 bytes of the buffer for

111
00:04:16,320 --> 00:04:18,418
verification

112
00:04:18,418 --> 00:04:20,040
now this is how things are supposed to

113
00:04:20,040 --> 00:04:22,079
work normally but as part of the threat

114
00:04:22,079 --> 00:04:24,240
model we need to assume that the server

115
00:04:24,240 --> 00:04:26,580
could be acting maliciously in trying to

116
00:04:26,580 --> 00:04:29,280
recover the client's sensitive files

117
00:04:29,280 --> 00:04:31,199
so in this case we're considering an

118
00:04:31,199 --> 00:04:33,540
attacker uh who is impersonating the

119
00:04:33,540 --> 00:04:35,520
server and has access to everything on

120
00:04:35,520 --> 00:04:36,840
the server

121
00:04:36,840 --> 00:04:39,419
so you'll notice here that uh I've

122
00:04:39,419 --> 00:04:41,699
written that this is AES and ECB mode

123
00:04:41,699 --> 00:04:43,440
which is the first of two cryptographic

124
00:04:43,440 --> 00:04:46,919
weaknesses uh that we'll discuss in this

125
00:04:46,919 --> 00:04:48,120
system

126
00:04:48,120 --> 00:04:51,180
so this is weak because uh in as ECB

127
00:04:51,180 --> 00:04:52,680
mode it's possible for the attacker to

128
00:04:52,680 --> 00:04:54,419
modify different bits and different

129
00:04:54,419 --> 00:04:57,180
blocks of this encrypted private key and

130
00:04:57,180 --> 00:04:59,040
then those corresponding blocks will be

131
00:04:59,040 --> 00:05:02,759
modified in the corresponding blame text

132
00:05:02,759 --> 00:05:04,979
so the attack can modify different

133
00:05:04,979 --> 00:05:08,060
128-bit blocks in this encrypted form

134
00:05:08,060 --> 00:05:10,500
send it to the client and then when the

135
00:05:10,500 --> 00:05:11,520
client decrypts it with their

136
00:05:11,520 --> 00:05:13,620
password-based key then their

137
00:05:13,620 --> 00:05:15,560
corresponding private key will have

138
00:05:15,560 --> 00:05:18,840
128-bit blocks be modified so some of

139
00:05:18,840 --> 00:05:20,160
the private key values will be the same

140
00:05:20,160 --> 00:05:22,979
and some will be different

141
00:05:22,979 --> 00:05:26,759
then during this RSA challenge uh when

142
00:05:26,759 --> 00:05:28,380
the client tries to decrypt the

143
00:05:28,380 --> 00:05:30,479
challenge Cipher text it's going to try

144
00:05:30,479 --> 00:05:32,220
to decrypt it using some private key

145
00:05:32,220 --> 00:05:34,020
values that are correct and some private

146
00:05:34,020 --> 00:05:36,360
key values that are incorrect so this

147
00:05:36,360 --> 00:05:40,139
decrypted ciphertext now has a little

148
00:05:40,139 --> 00:05:42,000
bit of information about both the

149
00:05:42,000 --> 00:05:43,800
private key and the modification so the

150
00:05:43,800 --> 00:05:46,500
private key mixed into it

151
00:05:46,500 --> 00:05:50,400
when the client sends uh the resulting

152
00:05:50,400 --> 00:05:52,560
message to the attacker it does not

153
00:05:52,560 --> 00:05:56,400
check that the 43 bytes were properly

154
00:05:56,400 --> 00:05:58,380
padded with this weird custom padding

155
00:05:58,380 --> 00:06:01,320
scheme instead it just extracts 43 bytes

156
00:06:01,320 --> 00:06:03,300
from the most different bytes of that

157
00:06:03,300 --> 00:06:05,220
buffer and sends it directly to the

158
00:06:05,220 --> 00:06:07,020
attacker

159
00:06:07,020 --> 00:06:08,880
so then the goal for the attacker here

160
00:06:08,880 --> 00:06:11,100
is to use these 43 bytes to somehow

161
00:06:11,100 --> 00:06:14,460
infer information about what was on the

162
00:06:14,460 --> 00:06:16,500
client side the information about what

163
00:06:16,500 --> 00:06:18,780
were the unmodified values of the

164
00:06:18,780 --> 00:06:20,039
private key and what were the modified

165
00:06:20,039 --> 00:06:22,860
values of the private key

166
00:06:22,860 --> 00:06:24,300
so this brings us to the attack of

167
00:06:24,300 --> 00:06:26,580
backendoll holler and Patterson for

168
00:06:26,580 --> 00:06:28,319
their original attack in mega and this

169
00:06:28,319 --> 00:06:29,880
is just one of several attacks that they

170
00:06:29,880 --> 00:06:31,560
present in their paper

171
00:06:31,560 --> 00:06:34,319
so this is a key recovery attack and in

172
00:06:34,319 --> 00:06:36,539
this attack the private key is

173
00:06:36,539 --> 00:06:39,000
represented by four values q p d and U

174
00:06:39,000 --> 00:06:40,979
and then they use this ability to modify

175
00:06:40,979 --> 00:06:44,639
as ECB ciphertext to change the value of

176
00:06:44,639 --> 00:06:48,180
U which is the RSA CRT coefficient

177
00:06:48,180 --> 00:06:50,819
because of this uh the 43 bytes fall

178
00:06:50,819 --> 00:06:52,979
into one of two cases which allows them

179
00:06:52,979 --> 00:06:55,560
to do a binary search on the value of Q

180
00:06:55,560 --> 00:06:58,319
so every login attempt and every 43

181
00:06:58,319 --> 00:07:00,539
bytes from the client they narrow down

182
00:07:00,539 --> 00:07:03,000
the value of Q by one more bit

183
00:07:03,000 --> 00:07:05,759
this means that after 512 login attempts

184
00:07:05,759 --> 00:07:07,560
they have 512 bits of information about

185
00:07:07,560 --> 00:07:09,780
Q which means they can use copper

186
00:07:09,780 --> 00:07:11,699
Smith's method to efficiently Factor the

187
00:07:11,699 --> 00:07:15,840
rest of the modulus and recover the key

188
00:07:15,840 --> 00:07:19,740
but this seems uh a little excessive 512

189
00:07:19,740 --> 00:07:22,440
login attempts where each one has 43

190
00:07:22,440 --> 00:07:25,440
bytes of data in it but

191
00:07:25,440 --> 00:07:27,539
for every 43 bytes of data you only get

192
00:07:27,539 --> 00:07:29,099
one bit of information so it seems like

193
00:07:29,099 --> 00:07:30,960
we should be able to do a lot better and

194
00:07:30,960 --> 00:07:32,520
be a lot more efficient

195
00:07:32,520 --> 00:07:34,860
and to get the sufficiency we need to

196
00:07:34,860 --> 00:07:36,840
consider exactly where these 43 bytes

197
00:07:36,840 --> 00:07:38,699
come from

198
00:07:38,699 --> 00:07:41,340
so Mega clients use Garner's formula to

199
00:07:41,340 --> 00:07:43,380
compute the decryption and then it took

200
00:07:43,380 --> 00:07:46,259
the most significant bytes from this uh

201
00:07:46,259 --> 00:07:49,440
this value as the 43 bytes that it sent

202
00:07:49,440 --> 00:07:51,180
to the server

203
00:07:51,180 --> 00:07:53,699
now the gardens formula is complicated

204
00:07:53,699 --> 00:07:56,580
here so we can simplify it a bit there

205
00:07:56,580 --> 00:07:58,380
are several values that do not change so

206
00:07:58,380 --> 00:08:00,479
we'll just replace them with X there's

207
00:08:00,479 --> 00:08:02,280
this value M sub Q which because of

208
00:08:02,280 --> 00:08:04,740
Garner's formula is small and we can

209
00:08:04,740 --> 00:08:06,240
combine the uncertainty in the value of

210
00:08:06,240 --> 00:08:07,979
M sub Q with the uncertainty and the

211
00:08:07,979 --> 00:08:11,099
least bytes into a single value which we

212
00:08:11,099 --> 00:08:13,259
have as the error term e

213
00:08:13,259 --> 00:08:14,880
and then we'll also note that this

214
00:08:14,880 --> 00:08:18,259
multiplier U is based on those modified

215
00:08:18,259 --> 00:08:20,940
128-bit AES blocks and the modified

216
00:08:20,940 --> 00:08:25,620
value is only 128 bits so if we can

217
00:08:25,620 --> 00:08:29,000
learn what this unknown 128-bit value is

218
00:08:29,000 --> 00:08:33,360
then we can see what the result of an as

219
00:08:33,360 --> 00:08:36,240
decryption is we've created an as

220
00:08:36,240 --> 00:08:38,520
decryption Oracle and then this allows

221
00:08:38,520 --> 00:08:40,260
us to decrypt the rest of the key so our

222
00:08:40,260 --> 00:08:43,380
goal here is to recover this multiplier

223
00:08:43,380 --> 00:08:45,120
and we can say this a little bit more

224
00:08:45,120 --> 00:08:47,580
generally which we do here and this is

225
00:08:47,580 --> 00:08:49,620
actually the hidden number problem with

226
00:08:49,620 --> 00:08:51,959
small unknown multipliers

227
00:08:51,959 --> 00:08:55,140
so this is the main problem of our talk

228
00:08:55,140 --> 00:08:58,560
so focus on it just a little bit more

229
00:08:58,560 --> 00:09:00,180
we have this problem where we have a

230
00:09:00,180 --> 00:09:02,700
number of samples that are a product T

231
00:09:02,700 --> 00:09:06,120
times X Plus e and our goal is to

232
00:09:06,120 --> 00:09:09,060
recover the values of t

233
00:09:09,060 --> 00:09:10,860
one of the issues with solving this

234
00:09:10,860 --> 00:09:13,500
problem is that there are two unknowns

235
00:09:13,500 --> 00:09:16,140
for every new sample and three unknowns

236
00:09:16,140 --> 00:09:18,480
in that entire equation

237
00:09:18,480 --> 00:09:21,660
so the more samples that we have the

238
00:09:21,660 --> 00:09:25,040
more unknowns that we have to solve

239
00:09:25,040 --> 00:09:27,480
you may also notice that this Rose the

240
00:09:27,480 --> 00:09:29,519
hidden number problem from uh Bonet

241
00:09:29,519 --> 00:09:32,279
vikarasan in 1996 except in this case

242
00:09:32,279 --> 00:09:34,560
the multipliers are unknown so we can't

243
00:09:34,560 --> 00:09:36,300
use the multipliers to perform the same

244
00:09:36,300 --> 00:09:38,399
sort of lattice attack as was used for

245
00:09:38,399 --> 00:09:40,740
the hidden number problem

246
00:09:40,740 --> 00:09:44,519
another challenge in solving h p sum is

247
00:09:44,519 --> 00:09:46,860
we can't do linearization because this

248
00:09:46,860 --> 00:09:50,640
value of ti times X Mod n is not bounded

249
00:09:50,640 --> 00:09:53,760
mod n so we can't introduce a new

250
00:09:53,760 --> 00:09:55,980
variable here and use a Bound in that to

251
00:09:55,980 --> 00:09:57,600
solve for the value

252
00:09:57,600 --> 00:09:59,519
so there are many challenges to solving

253
00:09:59,519 --> 00:10:02,760
h p some but if we can solve them it'll

254
00:10:02,760 --> 00:10:04,800
allow us to cryptanalyze Mega with only

255
00:10:04,800 --> 00:10:07,440
six samples so it's uh

256
00:10:07,440 --> 00:10:09,839
it it would be good if we can overcome

257
00:10:09,839 --> 00:10:12,420
these challenges

258
00:10:12,420 --> 00:10:14,339
and in fact that's what we do in the

259
00:10:14,339 --> 00:10:16,440
paper we find a way to solve this

260
00:10:16,440 --> 00:10:19,260
problem and a way to see how to solve

261
00:10:19,260 --> 00:10:20,760
this problem is by starting with two

262
00:10:20,760 --> 00:10:23,640
samples if we start with two samples A1

263
00:10:23,640 --> 00:10:26,339
and A2 it's easy to see that a linear

264
00:10:26,339 --> 00:10:28,920
combination of these samples can be used

265
00:10:28,920 --> 00:10:31,440
to cancel out X and after we do this

266
00:10:31,440 --> 00:10:34,080
linear combination we see that the value

267
00:10:34,080 --> 00:10:36,360
of this linear combination is small the

268
00:10:36,360 --> 00:10:38,880
coefficients are small and this is a

269
00:10:38,880 --> 00:10:41,940
linear combination of known values so if

270
00:10:41,940 --> 00:10:43,560
we can recover the coefficients we've

271
00:10:43,560 --> 00:10:45,120
recovered the multipliers and we've

272
00:10:45,120 --> 00:10:46,820
solved the problem

273
00:10:46,820 --> 00:10:49,260
now you may see a small linear

274
00:10:49,260 --> 00:10:51,300
combination of known values with small

275
00:10:51,300 --> 00:10:52,620
coefficients and think this sounds like

276
00:10:52,620 --> 00:10:55,140
some sort of lattice problem and in fact

277
00:10:55,140 --> 00:10:58,380
it absolutely is we can set up this

278
00:10:58,380 --> 00:11:00,600
Dimension 3 lattice with these known

279
00:11:00,600 --> 00:11:03,420
values and because of the equation of

280
00:11:03,420 --> 00:11:04,980
the previous slide we know that this

281
00:11:04,980 --> 00:11:07,620
lattice contains the short Vector given

282
00:11:07,620 --> 00:11:08,880
here

283
00:11:08,880 --> 00:11:12,120
so if we use lattice reduction to reduce

284
00:11:12,120 --> 00:11:14,700
this lattice basis then it will find

285
00:11:14,700 --> 00:11:17,339
this short Target vector and we can come

286
00:11:17,339 --> 00:11:19,320
up with bounds that show exactly for

287
00:11:19,320 --> 00:11:21,240
what values we can find this short

288
00:11:21,240 --> 00:11:23,760
Target vector

289
00:11:23,760 --> 00:11:26,519
now this works for solving an H and P

290
00:11:26,519 --> 00:11:29,940
sum with two samples and we can ask how

291
00:11:29,940 --> 00:11:31,320
do we do it with three samples how do we

292
00:11:31,320 --> 00:11:33,720
do it with more samples than that and

293
00:11:33,720 --> 00:11:36,060
there's a very obvious way to generalize

294
00:11:36,060 --> 00:11:38,279
this lattice construction for three

295
00:11:38,279 --> 00:11:41,519
samples and we do so here so instead of

296
00:11:41,519 --> 00:11:42,959
a dimension three lattice we have a

297
00:11:42,959 --> 00:11:44,820
dimension for lattice and instead of

298
00:11:44,820 --> 00:11:47,120
having that one target Vector for that

299
00:11:47,120 --> 00:11:49,920
the two multipliers we have three

300
00:11:49,920 --> 00:11:52,079
different Target vectors for each of the

301
00:11:52,079 --> 00:11:54,800
three different pairs of values

302
00:11:54,800 --> 00:11:57,240
now for each of these Target vectors

303
00:11:57,240 --> 00:11:59,339
you'll notice that uh

304
00:11:59,339 --> 00:12:01,500
we only consider a pair of multipliers

305
00:12:01,500 --> 00:12:03,600
at a time and all the other values

306
00:12:03,600 --> 00:12:06,420
besides that are zero

307
00:12:06,420 --> 00:12:09,060
so if we can reduce this lattice to find

308
00:12:09,060 --> 00:12:11,820
any one of these short vectors then this

309
00:12:11,820 --> 00:12:13,260
will give us information about two of

310
00:12:13,260 --> 00:12:15,000
the multipliers and if we repeat that

311
00:12:15,000 --> 00:12:17,459
enough times we'll get information about

312
00:12:17,459 --> 00:12:20,040
all of the multipliers

313
00:12:20,040 --> 00:12:22,019
so we have this lattice construction

314
00:12:22,019 --> 00:12:24,420
let's try applying lattice reduction and

315
00:12:24,420 --> 00:12:26,279
unfortunately none of these Target

316
00:12:26,279 --> 00:12:28,740
vectors these short vectors in the

317
00:12:28,740 --> 00:12:31,560
lattice are found by lattice reduction

318
00:12:31,560 --> 00:12:34,620
so what exactly is going on well we have

319
00:12:34,620 --> 00:12:36,000
this example here where we have an

320
00:12:36,000 --> 00:12:37,980
instance of H and P sum with these three

321
00:12:37,980 --> 00:12:39,240
multipliers

322
00:12:39,240 --> 00:12:42,000
and after lattice reduction we see that

323
00:12:42,000 --> 00:12:43,740
lattice reduction does find short

324
00:12:43,740 --> 00:12:46,440
vectors but it doesn't find the short

325
00:12:46,440 --> 00:12:49,380
Target vectors that we're looking for

326
00:12:49,380 --> 00:12:52,139
hmp some this lattice reduction for h p

327
00:12:52,139 --> 00:12:55,320
sum finds a dense sub lattice spanned by

328
00:12:55,320 --> 00:12:58,459
these first two short vectors

329
00:12:58,459 --> 00:13:01,019
and although neither of these are the

330
00:13:01,019 --> 00:13:03,120
target Vector we can show that the

331
00:13:03,120 --> 00:13:05,760
target Vector is lie in this dense sub

332
00:13:05,760 --> 00:13:07,079
lattice

333
00:13:07,079 --> 00:13:09,240
so we want to find Target vectors that

334
00:13:09,240 --> 00:13:11,519
do have these zeros in the correct spots

335
00:13:11,519 --> 00:13:13,980
so one way of doing this is by taking

336
00:13:13,980 --> 00:13:16,620
the basis for this dense sub lattice and

337
00:13:16,620 --> 00:13:18,660
calculating the hermit normal form and

338
00:13:18,660 --> 00:13:20,779
after doing this the hermit normal form

339
00:13:20,779 --> 00:13:23,760
uh finds vectors with zeros in the

340
00:13:23,760 --> 00:13:26,100
correct places and this allows us to

341
00:13:26,100 --> 00:13:27,779
find the target vectors which allows us

342
00:13:27,779 --> 00:13:29,639
to recover the multipliers in this case

343
00:13:29,639 --> 00:13:33,600
turn 64 and 185 and even though this

344
00:13:33,600 --> 00:13:35,700
gives us just two of the multipliers we

345
00:13:35,700 --> 00:13:37,079
can always Shuffle around the samples

346
00:13:37,079 --> 00:13:39,779
and reorder them run this process again

347
00:13:39,779 --> 00:13:44,120
and get two other multipliers

348
00:13:44,279 --> 00:13:47,160
so we're able to solve the hidden number

349
00:13:47,160 --> 00:13:49,260
problem with small unknown multipliers

350
00:13:49,260 --> 00:13:51,300
by using this lattice construction and

351
00:13:51,300 --> 00:13:53,160
by doing a combination of lattice

352
00:13:53,160 --> 00:13:55,019
reduction and calculating the hermit

353
00:13:55,019 --> 00:13:56,399
normal form

354
00:13:56,399 --> 00:13:58,620
and fortunately this extends well and

355
00:13:58,620 --> 00:14:01,220
generalizes well for even more samples

356
00:14:01,220 --> 00:14:04,860
in higher dimension

357
00:14:04,860 --> 00:14:07,500
we make a couple observations for why

358
00:14:07,500 --> 00:14:09,240
this strategy works and one of the

359
00:14:09,240 --> 00:14:11,040
interesting things about this attack is

360
00:14:11,040 --> 00:14:12,660
that we're able to work around the

361
00:14:12,660 --> 00:14:15,240
challenges involving X by canceling it

362
00:14:15,240 --> 00:14:16,920
out and we don't cancel it out

363
00:14:16,920 --> 00:14:19,079
explicitly if we cancel out implicitly

364
00:14:19,079 --> 00:14:21,540
with the construction of our lattice so

365
00:14:21,540 --> 00:14:22,860
this allows us to work around the

366
00:14:22,860 --> 00:14:26,040
limitations for the linearization

367
00:14:26,040 --> 00:14:27,240
um problems that we're running into

368
00:14:27,240 --> 00:14:29,040
earlier

369
00:14:29,040 --> 00:14:31,200
another observation that we have here is

370
00:14:31,200 --> 00:14:32,880
that we're using lattice reduction not

371
00:14:32,880 --> 00:14:35,459
to find a short Vector but to find a

372
00:14:35,459 --> 00:14:37,980
dense sub lattice and although there are

373
00:14:37,980 --> 00:14:39,540
other examples in the literature of

374
00:14:39,540 --> 00:14:41,579
using lattice production in this way it

375
00:14:41,579 --> 00:14:43,740
definitely is a more unusual way of

376
00:14:43,740 --> 00:14:45,180
using lattice reduction to solve a

377
00:14:45,180 --> 00:14:47,359
problem

378
00:14:47,940 --> 00:14:50,459
so we have a way to solve the hidden

379
00:14:50,459 --> 00:14:51,540
number problem with small unknown

380
00:14:51,540 --> 00:14:53,399
multipliers

381
00:14:53,399 --> 00:14:55,440
um and we we're looking for ways to

382
00:14:55,440 --> 00:14:57,420
apply this problem in other situations

383
00:14:57,420 --> 00:14:59,519
in one such situation that came up was

384
00:14:59,519 --> 00:15:02,579
the RSA implicit factoring problem

385
00:15:02,579 --> 00:15:04,380
now the RSA implicit factoring problem

386
00:15:04,380 --> 00:15:06,480
has nothing to do with makeup but it

387
00:15:06,480 --> 00:15:09,420
does involve RSA moduli and it's

388
00:15:09,420 --> 00:15:11,639
particular RSA moduli with unbalanced

389
00:15:11,639 --> 00:15:14,699
factors and then the larger of the two

390
00:15:14,699 --> 00:15:17,519
prime factors shares bits with the

391
00:15:17,519 --> 00:15:20,160
factor from the other samples so the

392
00:15:20,160 --> 00:15:22,199
goal of this problem is given the moduli

393
00:15:22,199 --> 00:15:26,160
recover all the factorization

394
00:15:26,160 --> 00:15:28,380
now we can consider this with the most

395
00:15:28,380 --> 00:15:30,120
significant bits shared as is shown here

396
00:15:30,120 --> 00:15:32,399
but there's also a version of the plus a

397
00:15:32,399 --> 00:15:33,720
factory problem where the least glue

398
00:15:33,720 --> 00:15:36,120
bits are shared where a combination of

399
00:15:36,120 --> 00:15:37,680
the most and the leasing good bits are

400
00:15:37,680 --> 00:15:40,199
shared or where the middle bits are

401
00:15:40,199 --> 00:15:41,820
shared and we can consider all these

402
00:15:41,820 --> 00:15:43,740
cases

403
00:15:43,740 --> 00:15:46,920
and uh fortunately this does seem to

404
00:15:46,920 --> 00:15:48,420
resemble the hidden number problem with

405
00:15:48,420 --> 00:15:50,940
small unknown multipliers in particular

406
00:15:50,940 --> 00:15:54,000
we have a number of known samples uh

407
00:15:54,000 --> 00:15:57,360
given by the moduli the shared value X

408
00:15:57,360 --> 00:15:59,040
that's shared between all samples is

409
00:15:59,040 --> 00:16:01,680
just the shared most thin bits

410
00:16:01,680 --> 00:16:04,380
are small unknown multiplier is just

411
00:16:04,380 --> 00:16:06,720
this smaller of the two prime factors Q

412
00:16:06,720 --> 00:16:09,839
sub I and then the error term uh just

413
00:16:09,839 --> 00:16:11,820
comes from the fact that the RSA module

414
00:16:11,820 --> 00:16:14,040
I are unbalanced

415
00:16:14,040 --> 00:16:18,000
so this gives us the reduction for the

416
00:16:18,000 --> 00:16:20,220
uh case where the most commitments are

417
00:16:20,220 --> 00:16:21,660
shared but there are also reductions for

418
00:16:21,660 --> 00:16:24,120
the other cases that we

419
00:16:24,120 --> 00:16:25,680
oh

420
00:16:25,680 --> 00:16:28,500
now we can compare the performance of

421
00:16:28,500 --> 00:16:30,120
this reduction from the implicit

422
00:16:30,120 --> 00:16:32,699
factoring problem to hnp sum and we can

423
00:16:32,699 --> 00:16:35,699
compare how our lattice base approach

424
00:16:35,699 --> 00:16:38,820
for solving H and B sum uh performs when

425
00:16:38,820 --> 00:16:41,220
using it to solve the implicit factoring

426
00:16:41,220 --> 00:16:42,180
problem

427
00:16:42,180 --> 00:16:44,880
and uh we'll acknowledge that there are

428
00:16:44,880 --> 00:16:46,740
copper smith-based methods for solving

429
00:16:46,740 --> 00:16:48,120
the implicit factoring problem but those

430
00:16:48,120 --> 00:16:49,259
aren't the ones that we're comparing to

431
00:16:49,259 --> 00:16:50,820
here

432
00:16:50,820 --> 00:16:52,680
so in the case where the least good bits

433
00:16:52,680 --> 00:16:54,360
are shared we do improve upon the

434
00:16:54,360 --> 00:16:56,579
results of May and ritzenhofen uh from

435
00:16:56,579 --> 00:16:59,279
pkc 2009 that originally proposed this

436
00:16:59,279 --> 00:17:01,920
implicit factoring problem uh in the

437
00:17:01,920 --> 00:17:03,480
case where the most gambits are shared

438
00:17:03,480 --> 00:17:05,339
we are pretty close to the performance

439
00:17:05,339 --> 00:17:07,679
of the work of Jose Marnier and Renault

440
00:17:07,679 --> 00:17:11,040
from pksa 2010 although we are slightly

441
00:17:11,040 --> 00:17:13,380
worse in the case where the middle bits

442
00:17:13,380 --> 00:17:15,599
are shared our lattices are polynomials

443
00:17:15,599 --> 00:17:17,760
smaller than the lattices in that same

444
00:17:17,760 --> 00:17:20,699
work uh so if there are K samples then

445
00:17:20,699 --> 00:17:22,919
our lattice has Dimension o of K rather

446
00:17:22,919 --> 00:17:25,140
than o of K squared which is

447
00:17:25,140 --> 00:17:26,339
particularly important when you have

448
00:17:26,339 --> 00:17:28,679
more than just a few samples

449
00:17:28,679 --> 00:17:30,240
and finally in the case we're both

450
00:17:30,240 --> 00:17:32,160
leasing bit and most of the bits are

451
00:17:32,160 --> 00:17:34,080
shared uh there is no direct lattice

452
00:17:34,080 --> 00:17:35,700
Construction in the literature for us to

453
00:17:35,700 --> 00:17:37,740
compare to so our reduction is

454
00:17:37,740 --> 00:17:40,760
especially good there

455
00:17:41,100 --> 00:17:43,620
all right so we've gone through the

456
00:17:43,620 --> 00:17:45,360
design of Mega we've talked about how to

457
00:17:45,360 --> 00:17:47,039
solve the hidden number problem with

458
00:17:47,039 --> 00:17:49,020
small unknown multipliers and we've

459
00:17:49,020 --> 00:17:51,360
shown this reduction uh for the implicit

460
00:17:51,360 --> 00:17:54,000
Factory problem but why does all this

461
00:17:54,000 --> 00:17:55,620
matter

462
00:17:55,620 --> 00:17:58,260
so the original attack of vacandale

463
00:17:58,260 --> 00:18:00,360
holler in Patterson where they showed

464
00:18:00,360 --> 00:18:03,539
that 512 logins were enough to attack

465
00:18:03,539 --> 00:18:05,640
the security guarantees of Mega came out

466
00:18:05,640 --> 00:18:09,660
on June 21st 2022 and at that time Mega

467
00:18:09,660 --> 00:18:12,840
acknowledged the uh impact for users who

468
00:18:12,840 --> 00:18:15,480
had logged in more than this many times

469
00:18:15,480 --> 00:18:18,240
then in July of 2022 we disclosed the

470
00:18:18,240 --> 00:18:20,640
sixth login attack uh which caused Mega

471
00:18:20,640 --> 00:18:23,100
to update their blog post to say that

472
00:18:23,100 --> 00:18:24,840
this attack actually affected the vast

473
00:18:24,840 --> 00:18:26,760
majority of users

474
00:18:26,760 --> 00:18:28,799
and then it doesn't even stop there in

475
00:18:28,799 --> 00:18:30,900
September of 2022 albrecht's Tyler

476
00:18:30,900 --> 00:18:33,419
markova and Patterson showed that there

477
00:18:33,419 --> 00:18:36,299
is a two login on unpatched systems and

478
00:18:36,299 --> 00:18:37,320
they also showed that there were

479
00:18:37,320 --> 00:18:39,900
additional attacks on the patches that

480
00:18:39,900 --> 00:18:42,240
came out for the original set of attacks

481
00:18:42,240 --> 00:18:44,039
so the attacks are clearly getting

482
00:18:44,039 --> 00:18:47,760
better over time uh and we can wonder

483
00:18:47,760 --> 00:18:49,200
about how much better they will get

484
00:18:49,200 --> 00:18:50,640
Beyond there I don't think they'll get

485
00:18:50,640 --> 00:18:52,140
much better but feel free to talk to me

486
00:18:52,140 --> 00:18:54,780
later about that

487
00:18:54,780 --> 00:18:56,160
but none of this would be possible

488
00:18:56,160 --> 00:18:58,260
without the original work of backendoll

489
00:18:58,260 --> 00:19:00,900
holler and Patterson to analyze Mega

490
00:19:00,900 --> 00:19:04,200
and this worked to analyze Mega has led

491
00:19:04,200 --> 00:19:05,820
to quite a few interesting results it's

492
00:19:05,820 --> 00:19:07,500
led to three different papers and each

493
00:19:07,500 --> 00:19:09,120
of these papers have their own set of

494
00:19:09,120 --> 00:19:11,460
contributions but for this particular

495
00:19:11,460 --> 00:19:14,700
work uh it led us to defining the hnp

496
00:19:14,700 --> 00:19:17,760
sum problem and it allowed us to come up

497
00:19:17,760 --> 00:19:19,799
with a way to solve it that involves

498
00:19:19,799 --> 00:19:21,419
some unusual lattice techniques where

499
00:19:21,419 --> 00:19:23,760
we're looking for dense sublasses

500
00:19:23,760 --> 00:19:25,440
another interesting thing that came up

501
00:19:25,440 --> 00:19:28,200
with this problem is that we discovered

502
00:19:28,200 --> 00:19:29,760
there's this surprising application to

503
00:19:29,760 --> 00:19:31,679
the implicit factoring problem which has

504
00:19:31,679 --> 00:19:33,240
nothing to do with mega and we wouldn't

505
00:19:33,240 --> 00:19:35,520
have been looking at otherwise

506
00:19:35,520 --> 00:19:39,240
so the fact that uh Mega was

507
00:19:39,240 --> 00:19:40,740
cryptanalyzed in the first place allowed

508
00:19:40,740 --> 00:19:43,080
all of these developments to happen and

509
00:19:43,080 --> 00:19:46,020
even though uh we were surprised by the

510
00:19:46,020 --> 00:19:47,880
application to implicit factoring we're

511
00:19:47,880 --> 00:19:49,140
hopeful that there are many more

512
00:19:49,140 --> 00:19:51,660
applications for hnp some in the future

513
00:19:51,660 --> 00:19:53,460
and we look forward to seeing what they

514
00:19:53,460 --> 00:19:55,440
are so with that thank you for your

515
00:19:55,440 --> 00:19:57,799
attention

516
00:20:01,980 --> 00:20:04,559
okay thank you Keegan do we have one

517
00:20:04,559 --> 00:20:07,399
very quick question

518
00:20:09,120 --> 00:20:11,600
perfect

519
00:20:11,940 --> 00:20:14,400
so did Mega tell its customers that now

520
00:20:14,400 --> 00:20:17,280
the you know they they need logins of

521
00:20:17,280 --> 00:20:20,760
potentially fatal

522
00:20:20,760 --> 00:20:23,520
uh I'm not sure I think they did have a

523
00:20:23,520 --> 00:20:28,440
blog post with the two logins uh for uh

524
00:20:28,440 --> 00:20:30,600
R6 login they just update their blog

525
00:20:30,600 --> 00:20:32,039
post and one of the things about our

526
00:20:32,039 --> 00:20:35,580
blog post is our our attack is that our

527
00:20:35,580 --> 00:20:37,500
attack is defeated by the same patches

528
00:20:37,500 --> 00:20:39,960
that came out for the previous attacks

529
00:20:39,960 --> 00:20:42,179
so uh as long as you had passed for the

530
00:20:42,179 --> 00:20:43,559
previous attacks you're secure against

531
00:20:43,559 --> 00:20:45,600
our attacks

532
00:20:45,600 --> 00:20:47,400
um but that's not true for the new set

533
00:20:47,400 --> 00:20:50,419
of attacks that just came out

534
00:20:50,700 --> 00:20:52,919
okay thank you Keegan let's thank Keegan

535
00:20:52,919 --> 00:20:55,760
again thank you

536
00:20:57,900 --> 00:21:01,440
our next talk is by Leon and Shane

537
00:21:01,440 --> 00:21:03,840
Gibbons on Hull attacks on the lattice

538
00:21:03,840 --> 00:21:06,299
either ivomorphism problem

539
00:21:06,299 --> 00:21:10,160
and uh Shane will give the talk

540
00:21:51,600 --> 00:21:55,219
can you hear me okay yeah

541
00:21:57,000 --> 00:21:58,260
okay

542
00:21:58,260 --> 00:22:00,600
um yeah thank you for the introduction

543
00:22:00,600 --> 00:22:02,460
um and congrats again to the previous

544
00:22:02,460 --> 00:22:05,159
speaker for the best paper award

545
00:22:05,159 --> 00:22:08,520
um so I'm Shane I'll be uh presenting my

546
00:22:08,520 --> 00:22:10,500
joint work with Leo ducat on Hall

547
00:22:10,500 --> 00:22:12,539
attacks on the latter seismorphism

548
00:22:12,539 --> 00:22:15,600
problem so I'll actually present be

549
00:22:15,600 --> 00:22:18,539
presenting one Hull attack which is a

550
00:22:18,539 --> 00:22:20,039
geometric attack on the last

551
00:22:20,039 --> 00:22:22,559
seismorphism problem there's also a

552
00:22:22,559 --> 00:22:24,299
arithmetic attack that I won't present

553
00:22:24,299 --> 00:22:27,980
today but is available in the paper

554
00:22:28,500 --> 00:22:31,320
um so lattice isomorphism well

555
00:22:31,320 --> 00:22:34,200
intuitively you can think of it as a

556
00:22:34,200 --> 00:22:36,720
rotation of a lattice

557
00:22:36,720 --> 00:22:38,820
shown here for example

558
00:22:38,820 --> 00:22:41,240
um the lats on the left which in reality

559
00:22:41,240 --> 00:22:43,860
spreads out in infinitely in every

560
00:22:43,860 --> 00:22:47,039
direction and rotates and is isomorphic

561
00:22:47,039 --> 00:22:49,500
to the lapse on the right

562
00:22:49,500 --> 00:22:51,240
it's very obvious here in two Dimensions

563
00:22:51,240 --> 00:22:53,700
that they're isomorphic but in higher

564
00:22:53,700 --> 00:22:56,159
Dimensions this is non-trivial

565
00:22:56,159 --> 00:22:59,100
so this last isomorphism problem comes

566
00:22:59,100 --> 00:23:01,860
in different flavors the distinguishing

567
00:23:01,860 --> 00:23:05,700
variant of this problem called Delta lip

568
00:23:05,700 --> 00:23:10,260
is the challenge to decide which of two

569
00:23:10,260 --> 00:23:12,659
lactose isomorphism classes that are

570
00:23:12,659 --> 00:23:14,940
given lattice falls into

571
00:23:14,940 --> 00:23:17,039
the search variant of the last

572
00:23:17,039 --> 00:23:18,960
seismorphism problem is as you would

573
00:23:18,960 --> 00:23:21,240
expect finding the isomorphism if you

574
00:23:21,240 --> 00:23:23,760
know it if you know there is one

575
00:23:23,760 --> 00:23:26,640
and Delta lip has been proposed uh for

576
00:23:26,640 --> 00:23:28,919
using cryptography by Bennett at Al at

577
00:23:28,919 --> 00:23:31,799
your Crypt of this year and by dukav and

578
00:23:31,799 --> 00:23:35,159
Warden at your Crypt of last year and

579
00:23:35,159 --> 00:23:37,440
the signature scheme Hawk presented at

580
00:23:37,440 --> 00:23:39,720
Asia Crypt of

581
00:23:39,720 --> 00:23:45,059
um of last year by ducatal they use a

582
00:23:45,059 --> 00:23:47,580
search lab for their hardness assumption

583
00:23:47,580 --> 00:23:50,820
so formally two lattices L and L Prime

584
00:23:50,820 --> 00:23:53,100
they're said to be isomorphic if there

585
00:23:53,100 --> 00:23:55,679
exists some orthonormal transformation o

586
00:23:55,679 --> 00:23:57,900
sending one lattice to the other o times

587
00:23:57,900 --> 00:24:00,740
L is L Prime

588
00:24:00,740 --> 00:24:03,539
computationally of course we don't work

589
00:24:03,539 --> 00:24:05,220
in terms of lattices but instead in

590
00:24:05,220 --> 00:24:07,919
terms of bases so here

591
00:24:07,919 --> 00:24:11,000
your tasked not only with finding the

592
00:24:11,000 --> 00:24:14,520
isomorphism this Matrix o but also you

593
00:24:14,520 --> 00:24:16,020
have to deal with the fact that a

594
00:24:16,020 --> 00:24:18,480
lattice can have infinitely many bases

595
00:24:18,480 --> 00:24:20,400
and therefore you also need to find the

596
00:24:20,400 --> 00:24:23,640
change of basis U this invertible Matrix

597
00:24:23,640 --> 00:24:26,039
U

598
00:24:26,039 --> 00:24:27,120
um

599
00:24:27,120 --> 00:24:29,400
yeah and so if you want to use lattice

600
00:24:29,400 --> 00:24:32,100
isomorphism for cryptography then you of

601
00:24:32,100 --> 00:24:34,200
course need some idea of the hardness of

602
00:24:34,200 --> 00:24:36,780
these problems so all known attacks

603
00:24:36,780 --> 00:24:37,919
against lip

604
00:24:37,919 --> 00:24:38,640
um

605
00:24:38,640 --> 00:24:41,360
uh specifically Delta lip require

606
00:24:41,360 --> 00:24:43,620
solving shortest the shortest Vector

607
00:24:43,620 --> 00:24:45,120
problem SVP

608
00:24:45,120 --> 00:24:46,580
and the running time for this

609
00:24:46,580 --> 00:24:48,960
heuristically depends on the length of

610
00:24:48,960 --> 00:24:51,539
the shortest vector really the relative

611
00:24:51,539 --> 00:24:54,059
length of the shortest factor and so

612
00:24:54,059 --> 00:24:56,220
what this means is if you have an

613
00:24:56,220 --> 00:24:59,100
exceptionally short Vector in your

614
00:24:59,100 --> 00:25:02,039
lattice then you you expect it to be

615
00:25:02,039 --> 00:25:04,980
easier to find the short vector

616
00:25:04,980 --> 00:25:07,440
and well what does exceptionally short

617
00:25:07,440 --> 00:25:08,460
mean

618
00:25:08,460 --> 00:25:11,400
it's short relative to what you would

619
00:25:11,400 --> 00:25:13,260
expect the length of a short Vector to

620
00:25:13,260 --> 00:25:15,780
be in a lattice of a given Dimension and

621
00:25:15,780 --> 00:25:17,220
this value is known as the gaussian

622
00:25:17,220 --> 00:25:19,200
heuristic given there on the right or

623
00:25:19,200 --> 00:25:21,360
rather its approximation is given on the

624
00:25:21,360 --> 00:25:22,260
right

625
00:25:22,260 --> 00:25:24,720
and for a random lattice of Dimension n

626
00:25:24,720 --> 00:25:27,059
you would expect Lambda 1 which is

627
00:25:27,059 --> 00:25:29,100
length of the shortest Vector to be

628
00:25:29,100 --> 00:25:33,139
around this uh this length

629
00:25:33,360 --> 00:25:37,140
and to quantify the difference in the

630
00:25:37,140 --> 00:25:38,640
true shortest length and the expected

631
00:25:38,640 --> 00:25:41,580
shortest length we use this ratio called

632
00:25:41,580 --> 00:25:42,960
The Gap

633
00:25:42,960 --> 00:25:45,659
and the Gap is well exactly this it's

634
00:25:45,659 --> 00:25:47,100
the ratio of the gaussian heuristic with

635
00:25:47,100 --> 00:25:49,679
the length of the shortest vector

636
00:25:49,679 --> 00:25:53,460
since any uh lattice isomorphism style

637
00:25:53,460 --> 00:25:55,260
problem can be solved both in the Primal

638
00:25:55,260 --> 00:25:56,880
and the Dual you need to take into

639
00:25:56,880 --> 00:26:00,299
account both the gap of the Primal and

640
00:26:00,299 --> 00:26:02,940
the Dual lattices

641
00:26:02,940 --> 00:26:06,480
and well to make concrete what I said

642
00:26:06,480 --> 00:26:07,919
earlier

643
00:26:07,919 --> 00:26:10,919
um making having a lattice with an

644
00:26:10,919 --> 00:26:13,080
exceptionally short vector or a large

645
00:26:13,080 --> 00:26:14,039
gap

646
00:26:14,039 --> 00:26:16,980
means you can use bkz reduction which is

647
00:26:16,980 --> 00:26:20,279
used to solve SVP you can use a smaller

648
00:26:20,279 --> 00:26:22,919
block side so the smaller parameter beta

649
00:26:22,919 --> 00:26:24,620
and this would be the key parameter

650
00:26:24,620 --> 00:26:26,580
alter at the top

651
00:26:26,580 --> 00:26:28,679
that we're trying to minimize

652
00:26:28,679 --> 00:26:30,840
you can use a smaller parameter and

653
00:26:30,840 --> 00:26:33,120
therefore reduce the the running time

654
00:26:33,120 --> 00:26:36,720
which is 2 to the 0.292 beta plus a

655
00:26:36,720 --> 00:26:39,500
little lower beta

656
00:26:40,559 --> 00:26:43,020
and just some concrete examples so in a

657
00:26:43,020 --> 00:26:44,700
random lattice as before you would

658
00:26:44,700 --> 00:26:47,100
expect the Gap to be a big O of one

659
00:26:47,100 --> 00:26:49,679
because by definition you expect the

660
00:26:49,679 --> 00:26:51,480
length of the shortest Vector to be near

661
00:26:51,480 --> 00:26:54,000
to the gas generistic and with this you

662
00:26:54,000 --> 00:26:57,240
use bkz with parameter beta equal n so

663
00:26:57,240 --> 00:26:58,679
full block size

664
00:26:58,679 --> 00:27:01,919
whereas for a nicer lattice like the

665
00:27:01,919 --> 00:27:04,740
lattice of all integer vectors ZN the

666
00:27:04,740 --> 00:27:07,380
gap of this is actually square root of n

667
00:27:07,380 --> 00:27:10,380
and with this you can solve a

668
00:27:10,380 --> 00:27:13,020
you can solve SVP using the parameter

669
00:27:13,020 --> 00:27:15,720
beta is n over two

670
00:27:15,720 --> 00:27:17,279
and from the previous slide you know

671
00:27:17,279 --> 00:27:19,260
that's the quadratic speed up you're

672
00:27:19,260 --> 00:27:20,880
having the exponent

673
00:27:20,880 --> 00:27:23,880
and in general if you have a gap of size

674
00:27:23,880 --> 00:27:27,360
uh Big O N to the Delta then you expect

675
00:27:27,360 --> 00:27:30,419
to use this smaller block size here

676
00:27:30,419 --> 00:27:32,700
so in general the larger the Gap is the

677
00:27:32,700 --> 00:27:34,440
easier your instance

678
00:27:34,440 --> 00:27:36,539
at least heuristically

679
00:27:36,539 --> 00:27:39,299
and so do Calvin Warden give this

680
00:27:39,299 --> 00:27:41,760
conjecture to try and encapsulate all of

681
00:27:41,760 --> 00:27:44,159
this uh these heuristics into one

682
00:27:44,159 --> 00:27:46,799
statement and what they say is that the

683
00:27:46,799 --> 00:27:48,960
best attack against Delta lip which

684
00:27:48,960 --> 00:27:51,179
they're proposing uh for use in

685
00:27:51,179 --> 00:27:54,120
cryptography requires solving F

686
00:27:54,120 --> 00:27:57,299
approximate SVP in both lattices where f

687
00:27:57,299 --> 00:28:00,120
is the gap the gap of both lattices

688
00:28:00,120 --> 00:28:01,760
actually

689
00:28:01,760 --> 00:28:06,059
and so what this is saying is that to

690
00:28:06,059 --> 00:28:07,020
solve

691
00:28:07,020 --> 00:28:11,100
to solve SVP you would use bkz with a

692
00:28:11,100 --> 00:28:13,440
block size

693
00:28:13,440 --> 00:28:15,120
um with the block size that you would

694
00:28:15,120 --> 00:28:17,279
expect to have to use to solve F

695
00:28:17,279 --> 00:28:22,200
approximate SVP not regular s3p

696
00:28:22,200 --> 00:28:25,140
and so our attack is

697
00:28:25,140 --> 00:28:28,380
we extract subletters of the entire

698
00:28:28,380 --> 00:28:30,659
lattice which we know has a nicer Gap

699
00:28:30,659 --> 00:28:32,159
and therefore we can solve last

700
00:28:32,159 --> 00:28:34,080
isomorphism a bit easier

701
00:28:34,080 --> 00:28:36,120
and then we reconstruct the entire

702
00:28:36,120 --> 00:28:38,940
isomorphism from this isomorphism of the

703
00:28:38,940 --> 00:28:40,919
sub lattices

704
00:28:40,919 --> 00:28:43,679
So the plan of attack for today is I'll

705
00:28:43,679 --> 00:28:45,480
explain what the whole level at this is

706
00:28:45,480 --> 00:28:47,820
I'll explain what a construction a

707
00:28:47,820 --> 00:28:49,980
lattice is and this is the family of

708
00:28:49,980 --> 00:28:52,919
lattices on which this attack Works

709
00:28:52,919 --> 00:28:54,779
um or at least it's the one that we

710
00:28:54,779 --> 00:28:57,179
showed that it works on

711
00:28:57,179 --> 00:28:59,340
um and then finally I'll talk about how

712
00:28:59,340 --> 00:29:02,760
you can uh well use the whole to solve

713
00:29:02,760 --> 00:29:05,580
lip by an instance of zlip and the code

714
00:29:05,580 --> 00:29:08,299
equivalence problem

715
00:29:08,400 --> 00:29:10,620
so the whole of the lattice is defined

716
00:29:10,620 --> 00:29:13,919
uh is inspired by the idea of the whole

717
00:29:13,919 --> 00:29:16,380
of a code and if you're familiar with

718
00:29:16,380 --> 00:29:17,100
um

719
00:29:17,100 --> 00:29:19,260
coding Theory and the whole of a code

720
00:29:19,260 --> 00:29:22,500
you'll know that the uh the whole play

721
00:29:22,500 --> 00:29:24,299
is an important part in code equivalence

722
00:29:24,299 --> 00:29:26,460
problems and code equivalence can be

723
00:29:26,460 --> 00:29:28,559
seen as the code version of The Last

724
00:29:28,559 --> 00:29:30,600
isomorphism Problem

725
00:29:30,600 --> 00:29:34,620
so the whole of a code is uh given as

726
00:29:34,620 --> 00:29:36,539
the intersection of the code with its

727
00:29:36,539 --> 00:29:38,220
own dual

728
00:29:38,220 --> 00:29:39,600
and

729
00:29:39,600 --> 00:29:42,240
as an example in permutation code

730
00:29:42,240 --> 00:29:43,320
equivalence

731
00:29:43,320 --> 00:29:46,320
the hardness of this problem is

732
00:29:46,320 --> 00:29:48,539
exponential in the dimension of the hull

733
00:29:48,539 --> 00:29:50,640
so if you have a code with a trivial

734
00:29:50,640 --> 00:29:53,820
Hull then a permutation code equivalence

735
00:29:53,820 --> 00:29:56,460
can be solved efficiently

736
00:29:56,460 --> 00:29:59,100
so knowing this it's natural to want to

737
00:29:59,100 --> 00:30:01,620
define the idea of the hull of a lattice

738
00:30:01,620 --> 00:30:04,200
however if you have if you begin with an

739
00:30:04,200 --> 00:30:06,960
integer or integral lattice if you take

740
00:30:06,960 --> 00:30:09,240
its intersection with its own dual

741
00:30:09,240 --> 00:30:11,279
then you end up with the same lattice

742
00:30:11,279 --> 00:30:13,020
again so you don't learn anything by

743
00:30:13,020 --> 00:30:14,940
taking the hole and it's useless however

744
00:30:14,940 --> 00:30:17,940
what we can do is we

745
00:30:17,940 --> 00:30:21,840
Define the hole using a uh a scalar a

746
00:30:21,840 --> 00:30:25,020
non-zero scalar s and Define this whole

747
00:30:25,020 --> 00:30:26,940
to be the intersection of the lattice

748
00:30:26,940 --> 00:30:29,460
with this scaling of its duel

749
00:30:29,460 --> 00:30:31,080
and we're allowed to do this because

750
00:30:31,080 --> 00:30:33,360
this

751
00:30:33,360 --> 00:30:34,740
um this doesn't affect the property of

752
00:30:34,740 --> 00:30:38,520
the whole that these code equivalents

753
00:30:38,520 --> 00:30:39,179
um

754
00:30:39,179 --> 00:30:42,899
Notions use which is that the hull of

755
00:30:42,899 --> 00:30:43,760
some

756
00:30:43,760 --> 00:30:46,140
permutation of your code is the

757
00:30:46,140 --> 00:30:47,940
permutation of the whole of your code

758
00:30:47,940 --> 00:30:50,520
and the same in lattices the hull of a

759
00:30:50,520 --> 00:30:53,360
using this definition the hull of a

760
00:30:53,360 --> 00:30:55,980
rotation or isomorphism of your lattice

761
00:30:55,980 --> 00:30:58,620
is equal to the isomorphism of the whole

762
00:30:58,620 --> 00:31:01,520
of your lattice

763
00:31:01,679 --> 00:31:05,460
and so construction a lattices are the

764
00:31:05,460 --> 00:31:07,080
lashes where this is

765
00:31:07,080 --> 00:31:09,779
um most obviously useful and so these

766
00:31:09,779 --> 00:31:13,320
are lattices generated by codes

767
00:31:13,320 --> 00:31:16,799
and so uh your linear code over FP you

768
00:31:16,799 --> 00:31:18,059
can

769
00:31:18,059 --> 00:31:20,460
um kind of included into the integers

770
00:31:20,460 --> 00:31:23,700
using abusive notation here just write

771
00:31:23,700 --> 00:31:26,460
your code as a set of integers and you

772
00:31:26,460 --> 00:31:28,080
can imagine it as

773
00:31:28,080 --> 00:31:30,960
just uh in this example here the code is

774
00:31:30,960 --> 00:31:34,380
included in the box of uh of side length

775
00:31:34,380 --> 00:31:36,000
13 here

776
00:31:36,000 --> 00:31:39,059
with integer values and then the lattice

777
00:31:39,059 --> 00:31:42,179
generated by this is simply a matter of

778
00:31:42,179 --> 00:31:45,779
repeating this box in every direction

779
00:31:45,779 --> 00:31:47,880
um infinitely many times

780
00:31:47,880 --> 00:31:49,860
and this lattice

781
00:31:49,860 --> 00:31:52,020
um has a nice basis and everything that

782
00:31:52,020 --> 00:31:53,700
we can work with

783
00:31:53,700 --> 00:31:58,140
importantly the lattice hole of your

784
00:31:58,140 --> 00:32:00,899
construction a lattice coming from the

785
00:32:00,899 --> 00:32:03,840
code C is equal to the construction a

786
00:32:03,840 --> 00:32:06,120
lattice coming from the hull of your

787
00:32:06,120 --> 00:32:07,500
code

788
00:32:07,500 --> 00:32:09,840
and as before

789
00:32:09,840 --> 00:32:12,779
um codes with a trivial Hull are

790
00:32:12,779 --> 00:32:14,940
um easier to work with and it's the same

791
00:32:14,940 --> 00:32:17,279
here in construction a lattices so if

792
00:32:17,279 --> 00:32:20,220
your the code which generates your

793
00:32:20,220 --> 00:32:22,020
construction a lattice if this has a

794
00:32:22,020 --> 00:32:23,460
trivial Hull

795
00:32:23,460 --> 00:32:25,200
then

796
00:32:25,200 --> 00:32:27,059
as you can see from the right hand side

797
00:32:27,059 --> 00:32:28,140
here

798
00:32:28,140 --> 00:32:30,960
the whole of this lattice is going to be

799
00:32:30,960 --> 00:32:34,080
uh these red dots here essentially the

800
00:32:34,080 --> 00:32:35,640
corners of the box from the previous

801
00:32:35,640 --> 00:32:37,200
analogy

802
00:32:37,200 --> 00:32:39,899
and as you know from previous from a few

803
00:32:39,899 --> 00:32:43,860
slides previously solving SVP on

804
00:32:43,860 --> 00:32:46,200
um on a lattice that is a scaling of Z

805
00:32:46,200 --> 00:32:49,440
to the power n is much easier

806
00:32:49,440 --> 00:32:51,299
is much faster because you can use the

807
00:32:51,299 --> 00:32:54,000
parameter beta equals n over two and

808
00:32:54,000 --> 00:32:56,640
this is a quadratic speed up again

809
00:32:56,640 --> 00:33:01,140
so uh the instance of isomorphism that

810
00:33:01,140 --> 00:33:02,899
we'll solve is

811
00:33:02,899 --> 00:33:05,940
uh given a construction a lattice from a

812
00:33:05,940 --> 00:33:06,720
code

813
00:33:06,720 --> 00:33:09,720
and given two rotations of this o1 and

814
00:33:09,720 --> 00:33:12,419
O2 we have two different lattices L1 and

815
00:33:12,419 --> 00:33:14,460
L2 given here

816
00:33:14,460 --> 00:33:16,140
in the top left and top right and we

817
00:33:16,140 --> 00:33:18,659
know they are isomorphic to C plus P

818
00:33:18,659 --> 00:33:20,820
times Z to the N even though we don't

819
00:33:20,820 --> 00:33:23,820
need to know what c is here

820
00:33:23,820 --> 00:33:26,279
and what we do is we take the hull of

821
00:33:26,279 --> 00:33:29,220
each of the uh four parts of the diagram

822
00:33:29,220 --> 00:33:30,419
here

823
00:33:30,419 --> 00:33:33,779
and we know now that the whole of L1 is

824
00:33:33,779 --> 00:33:35,820
isomorphic to P times Z to the n and

825
00:33:35,820 --> 00:33:38,640
similarly for L2

826
00:33:38,640 --> 00:33:41,760
but if we now solve our instance of

827
00:33:41,760 --> 00:33:44,039
z-lib that's to say we solve the

828
00:33:44,039 --> 00:33:47,399
instance of lattice isomorphism

829
00:33:47,399 --> 00:33:49,799
um from the whole of L1 back to P times

830
00:33:49,799 --> 00:33:52,260
Z to the N we don't necessarily get the

831
00:33:52,260 --> 00:33:54,299
entire isomorphism because what we've

832
00:33:54,299 --> 00:33:56,399
done is we've found some isomorphism

833
00:33:56,399 --> 00:34:00,539
from L1 back to some other code C1 plus

834
00:34:00,539 --> 00:34:02,460
P times Z to the n

835
00:34:02,460 --> 00:34:05,220
and the same for L2 we found some

836
00:34:05,220 --> 00:34:08,699
isomorphism that cell that sends L2 back

837
00:34:08,699 --> 00:34:12,119
to C2 plus b times Z to the N for some

838
00:34:12,119 --> 00:34:14,040
code C1 and C2

839
00:34:14,040 --> 00:34:17,159
and so we need to find what element of

840
00:34:17,159 --> 00:34:19,379
the automorphism group of P times Z to

841
00:34:19,379 --> 00:34:21,060
the N applies here

842
00:34:21,060 --> 00:34:23,339
which would send C1 to C2

843
00:34:23,339 --> 00:34:24,719
and if you're familiar with code

844
00:34:24,719 --> 00:34:27,540
equivalence problems that's exactly uh

845
00:34:27,540 --> 00:34:29,940
what this is so after we apply the

846
00:34:29,940 --> 00:34:32,460
isomorphism that we have found

847
00:34:32,460 --> 00:34:35,399
to L1 and L2 and we reduce modulo P

848
00:34:35,399 --> 00:34:39,599
suddenly we have C1 and C2 are

849
00:34:39,599 --> 00:34:41,219
equivalent

850
00:34:41,219 --> 00:34:41,940
um

851
00:34:41,940 --> 00:34:44,520
via some element of the automorphism

852
00:34:44,520 --> 00:34:46,980
group of P times n to the n and such an

853
00:34:46,980 --> 00:34:49,619
element is always a signed permutation

854
00:34:49,619 --> 00:34:51,719
that's to say a permutation of the

855
00:34:51,719 --> 00:34:53,820
coordinates and a possible flipping of

856
00:34:53,820 --> 00:34:56,460
the sign of the coordinates in your code

857
00:34:56,460 --> 00:34:59,220
what we show in the paper and

858
00:34:59,220 --> 00:35:00,480
um

859
00:35:00,480 --> 00:35:02,460
uh yeah what we show in the paper is

860
00:35:02,460 --> 00:35:05,520
that this instance of signed permutation

861
00:35:05,520 --> 00:35:07,980
can be reduced to an easy instance of

862
00:35:07,980 --> 00:35:09,720
permutation equivalence

863
00:35:09,720 --> 00:35:11,880
and this differs to

864
00:35:11,880 --> 00:35:12,420
um

865
00:35:12,420 --> 00:35:15,060
so this is using a technique of Sandra a

866
00:35:15,060 --> 00:35:16,460
and CMOS

867
00:35:16,460 --> 00:35:21,300
in paper 2013 called the closure and

868
00:35:21,300 --> 00:35:22,500
um

869
00:35:22,500 --> 00:35:24,480
their instances reduced to hired

870
00:35:24,480 --> 00:35:26,400
instances of permutation equivalence

871
00:35:26,400 --> 00:35:28,740
whereas R1 we show reduces to an easier

872
00:35:28,740 --> 00:35:30,540
instance

873
00:35:30,540 --> 00:35:33,119
and so in summary how the attack works

874
00:35:33,119 --> 00:35:33,920
is

875
00:35:33,920 --> 00:35:37,260
given some linear code with a trivial

876
00:35:37,260 --> 00:35:38,520
Hull

877
00:35:38,520 --> 00:35:41,579
our instance of last isomorphism is two

878
00:35:41,579 --> 00:35:43,800
rotations of the construction a lattice

879
00:35:43,800 --> 00:35:46,020
coming from this code

880
00:35:46,020 --> 00:35:49,619
and we know that the whole of L1 and L2

881
00:35:49,619 --> 00:35:51,780
are both isomorphic to P times Z to the

882
00:35:51,780 --> 00:35:52,560
n

883
00:35:52,560 --> 00:35:57,300
so we solve the instance of isomorphism

884
00:35:57,300 --> 00:35:59,640
uh from these holes back to

885
00:35:59,640 --> 00:36:01,859
P times Z to the n and we've solved the

886
00:36:01,859 --> 00:36:04,380
entire isomorphism up to some element of

887
00:36:04,380 --> 00:36:07,380
the automorphism group of the whole

888
00:36:07,380 --> 00:36:09,660
this element of the automorphism group

889
00:36:09,660 --> 00:36:13,560
can be found uh by code equivalence by

890
00:36:13,560 --> 00:36:16,619
just reducing the rotation modulo P the

891
00:36:16,619 --> 00:36:18,599
two rotations modulo p and solving this

892
00:36:18,599 --> 00:36:21,119
easy instance of code equivalence

893
00:36:21,119 --> 00:36:25,040
and so finally the result is that

894
00:36:25,040 --> 00:36:27,660
we must update the conjecture given by

895
00:36:27,660 --> 00:36:30,420
decab and Warden uh essentially to take

896
00:36:30,420 --> 00:36:33,240
into account all of the possible hulls

897
00:36:33,240 --> 00:36:36,000
of the lattice and in fact we show that

898
00:36:36,000 --> 00:36:38,880
there are only you can see on the bottom

899
00:36:38,880 --> 00:36:41,700
um we Define the whole Gap to be the

900
00:36:41,700 --> 00:36:43,280
maximum overall

901
00:36:43,280 --> 00:36:46,680
integers s dividing the determinant of

902
00:36:46,680 --> 00:36:48,900
the transpose times B we show that there

903
00:36:48,900 --> 00:36:52,560
are uh essentially every possible hole

904
00:36:52,560 --> 00:36:54,119
where s is some

905
00:36:54,119 --> 00:36:57,599
non-zero real number and every possible

906
00:36:57,599 --> 00:37:01,380
Hull is simply a scaling of some

907
00:37:01,380 --> 00:37:02,640
whole

908
00:37:02,640 --> 00:37:04,980
uh for an s in a finite set and that

909
00:37:04,980 --> 00:37:06,900
finite set is the integers dividing this

910
00:37:06,900 --> 00:37:09,060
determinant

911
00:37:09,060 --> 00:37:10,980
and

912
00:37:10,980 --> 00:37:13,740
um so finally the recommendation uh

913
00:37:13,740 --> 00:37:15,599
resulting from this would be that if you

914
00:37:15,599 --> 00:37:17,579
have an instance of lattice isomorphism

915
00:37:17,579 --> 00:37:20,640
either search variant or Delta lip

916
00:37:20,640 --> 00:37:24,420
variant then the

917
00:37:24,420 --> 00:37:27,839
um when you really should instantiate

918
00:37:27,839 --> 00:37:31,500
this with lattices that for example have

919
00:37:31,500 --> 00:37:33,240
no non

920
00:37:33,240 --> 00:37:35,280
um have only

921
00:37:35,280 --> 00:37:38,180
excuse me unimodular lattices which have

922
00:37:38,180 --> 00:37:41,160
determinant of B transfers b equal to

923
00:37:41,160 --> 00:37:43,579
one and therefore the only possible hole

924
00:37:43,579 --> 00:37:47,520
that is of interest is the whole when

925
00:37:47,520 --> 00:37:49,859
the scaling at scalar s is equal to one

926
00:37:49,859 --> 00:37:54,000
and this is exactly uh well the one

927
00:37:54,000 --> 00:37:56,460
whole of any integer lattice is indeed

928
00:37:56,460 --> 00:37:58,980
the original lattice and therefore such

929
00:37:58,980 --> 00:38:02,520
a lattice is immune to the whole attack

930
00:38:02,520 --> 00:38:05,579
so yeah that's all I had to say for

931
00:38:05,579 --> 00:38:06,900
today

932
00:38:06,900 --> 00:38:08,460
um thank you and I'm happy to take any

933
00:38:08,460 --> 00:38:10,700
questions

934
00:38:13,680 --> 00:38:17,660
okay do we have any questions okay

935
00:38:26,700 --> 00:38:29,099
I wonder okay I'm wondering about the

936
00:38:29,099 --> 00:38:30,660
arithmetic attack

937
00:38:30,660 --> 00:38:32,160
um is it in somehow is it somehow like

938
00:38:32,160 --> 00:38:34,619
related or

939
00:38:34,619 --> 00:38:35,940
um formed by the same intuition as a

940
00:38:35,940 --> 00:38:38,599
geometric attack

941
00:38:38,700 --> 00:38:41,579
um uh thank you for asking so um it's

942
00:38:41,579 --> 00:38:44,460
really really quite different so

943
00:38:44,460 --> 00:38:47,280
um it's uh

944
00:38:47,280 --> 00:38:49,140
yeah it's quite perpendicular in the

945
00:38:49,140 --> 00:38:51,720
sense that it considers equivalence

946
00:38:51,720 --> 00:38:54,780
classes of uh quadratic forms rather

947
00:38:54,780 --> 00:38:58,980
than lattices so uh if you have a basis

948
00:38:58,980 --> 00:39:01,079
B of your lattice the relevant quadratic

949
00:39:01,079 --> 00:39:03,359
form that you're considering is uh B

950
00:39:03,359 --> 00:39:05,520
transpose B written there at the bottom

951
00:39:05,520 --> 00:39:09,420
and lattice isomorphism of

952
00:39:09,420 --> 00:39:12,359
um lattices with bases being B Prime

953
00:39:12,359 --> 00:39:15,180
this is equivalent to quadratic form

954
00:39:15,180 --> 00:39:18,900
equivalence for these two uh

955
00:39:18,900 --> 00:39:21,240
B transfers B and B Prime transverse B

956
00:39:21,240 --> 00:39:24,060
Prime and

957
00:39:24,060 --> 00:39:25,859
um yeah there's a lot of interesting

958
00:39:25,859 --> 00:39:27,960
number theoretic Machinery going on in

959
00:39:27,960 --> 00:39:29,820
quadratic form equivalence the problems

960
00:39:29,820 --> 00:39:31,740
are the same but

961
00:39:31,740 --> 00:39:33,060
um

962
00:39:33,060 --> 00:39:35,760
yeah there's uh it goes into periodic

963
00:39:35,760 --> 00:39:37,920
numbers and the genus and such things

964
00:39:37,920 --> 00:39:39,270
like this

965
00:39:39,270 --> 00:39:39,660
[Music]

966
00:39:39,660 --> 00:39:40,859
um

967
00:39:40,859 --> 00:39:42,300
yeah

968
00:39:42,300 --> 00:39:43,619
um

969
00:39:43,619 --> 00:39:46,079
so really quite different and in fact

970
00:39:46,079 --> 00:39:48,240
what we show is that

971
00:39:48,240 --> 00:39:50,280
um it still is related to the whole in

972
00:39:50,280 --> 00:39:52,260
the sense that taking the whole of a

973
00:39:52,260 --> 00:39:53,940
lattice and then trying to apply this

974
00:39:53,940 --> 00:39:55,800
Machinery won't won't help you anymore

975
00:39:55,800 --> 00:39:58,020
as well so it is in some sense a kind of

976
00:39:58,020 --> 00:39:59,520
failed attack but it is still relevant

977
00:39:59,520 --> 00:40:02,839
to know thank you

978
00:40:03,060 --> 00:40:06,619
okay thank you Shane

979
00:40:08,640 --> 00:40:10,740
okay the final Talk of the attack

980
00:40:10,740 --> 00:40:13,040
session is a key recovery attack against

981
00:40:13,040 --> 00:40:16,140
mitaka in the T probing model the papers

982
00:40:16,140 --> 00:40:19,020
by Tomar Prest and the paper will be

983
00:40:19,020 --> 00:40:23,599
presented on his behalf by Chris bykurtz

984
00:41:08,180 --> 00:41:10,320
apologies for interrupting we're not

985
00:41:10,320 --> 00:41:13,880
getting sound in Zoom

986
00:41:15,359 --> 00:41:18,060
how is it now much better that's good

987
00:41:18,060 --> 00:41:20,359
thanks

988
00:41:24,119 --> 00:41:26,400
so due to uh leakage in the signing

989
00:41:26,400 --> 00:41:28,859
procedure uh these early schemes were

990
00:41:28,859 --> 00:41:31,980
broken I'll say more about that uh then

991
00:41:31,980 --> 00:41:34,440
in 2008 there was a fixed at the design

992
00:41:34,440 --> 00:41:37,800
level uh allowing for uh an actual proof

993
00:41:37,800 --> 00:41:40,140
of security in the random Oracle model

994
00:41:40,140 --> 00:41:43,560
uh due to Gentry picarditonathan

995
00:41:43,560 --> 00:41:44,400
um

996
00:41:44,400 --> 00:41:46,619
if you then consider side Channel

997
00:41:46,619 --> 00:41:48,480
leakage so going Beyond the Black Box

998
00:41:48,480 --> 00:41:50,460
model and consider side channels during

999
00:41:50,460 --> 00:41:54,359
the uh the signing procedure uh these

1000
00:41:54,359 --> 00:41:56,520
schemes can again be attacked uh using

1001
00:41:56,520 --> 00:41:58,500
information gained from the side Channel

1002
00:41:58,500 --> 00:42:00,839
and then last year another design level

1003
00:42:00,839 --> 00:42:04,140
fix was proposed uh in this work mataka

1004
00:42:04,140 --> 00:42:09,000
from Euro Cup 22 and uh in this work uh

1005
00:42:09,000 --> 00:42:11,460
we show that the T probing leakage model

1006
00:42:11,460 --> 00:42:13,800
which was the one considered uh by the

1007
00:42:13,800 --> 00:42:16,740
Metallica work actually can be used to

1008
00:42:16,740 --> 00:42:21,300
attack and break this uh scheme due to a

1009
00:42:21,300 --> 00:42:24,240
flaw in in the proposed proof uh that

1010
00:42:24,240 --> 00:42:26,099
was given from a tuck right so that's

1011
00:42:26,099 --> 00:42:28,740
the roadmap for the talk uh so first let

1012
00:42:28,740 --> 00:42:31,200
me kind of set the stage with these hash

1013
00:42:31,200 --> 00:42:33,599
and sign signature schemes so these were

1014
00:42:33,599 --> 00:42:36,300
the initial attempts that uh lava space

1015
00:42:36,300 --> 00:42:38,339
signature schemes uh which looks

1016
00:42:38,339 --> 00:42:39,660
something like this so in the key

1017
00:42:39,660 --> 00:42:43,020
generation one generates a public Matrix

1018
00:42:43,020 --> 00:42:46,440
a that looks random that defines a

1019
00:42:46,440 --> 00:42:48,300
lattice and then B

1020
00:42:48,300 --> 00:42:50,339
which is a relatively short basis of

1021
00:42:50,339 --> 00:42:52,380
that lattice and that can be written by

1022
00:42:52,380 --> 00:42:54,480
a times b equals zero if you if these

1023
00:42:54,480 --> 00:42:56,940
representations are done correctly and B

1024
00:42:56,940 --> 00:42:58,980
is again has relatively small entries in

1025
00:42:58,980 --> 00:43:01,560
its small vectors so the public key is a

1026
00:43:01,560 --> 00:43:03,060
and the secret key is B

1027
00:43:03,060 --> 00:43:06,300
and then to sign a message uh one first

1028
00:43:06,300 --> 00:43:08,160
hashes the message and to some point in

1029
00:43:08,160 --> 00:43:11,640
space uh call it C here and then we can

1030
00:43:11,640 --> 00:43:13,800
I'm sorry don't call it C uh we'll

1031
00:43:13,800 --> 00:43:16,380
choose an arbitrary solution of a times

1032
00:43:16,380 --> 00:43:19,980
C equals the point in space and then C

1033
00:43:19,980 --> 00:43:21,420
though in general will be very large

1034
00:43:21,420 --> 00:43:24,000
will be a very long vector and so we

1035
00:43:24,000 --> 00:43:27,839
correct it by uh subtracting uh a

1036
00:43:27,839 --> 00:43:29,520
lattice Vector an appropriate lattice

1037
00:43:29,520 --> 00:43:31,980
vector v which has the Form B times some

1038
00:43:31,980 --> 00:43:35,220
integer uh integer coefficients which

1039
00:43:35,220 --> 00:43:38,040
are given by B inverse C and then the

1040
00:43:38,040 --> 00:43:40,800
difference between C and V is the actual

1041
00:43:40,800 --> 00:43:42,119
signature so it looks something like

1042
00:43:42,119 --> 00:43:45,300
this this C is an initial solution and

1043
00:43:45,300 --> 00:43:48,000
then uh V is a nearby lattice vector and

1044
00:43:48,000 --> 00:43:49,980
the difference Vector is the signature

1045
00:43:49,980 --> 00:43:52,680
right so to check uh the signature it's

1046
00:43:52,680 --> 00:43:55,079
easy to verify one just checks that s is

1047
00:43:55,079 --> 00:43:57,540
indeed short and that a times s equals

1048
00:43:57,540 --> 00:43:59,579
the hashed message and this holds

1049
00:43:59,579 --> 00:44:02,220
because a times V equals zero by

1050
00:44:02,220 --> 00:44:03,720
definition

1051
00:44:03,720 --> 00:44:05,819
okay so that was the original uh

1052
00:44:05,819 --> 00:44:07,800
proposal it's easy to see that this

1053
00:44:07,800 --> 00:44:09,900
would be correct uh and it seems like

1054
00:44:09,900 --> 00:44:13,380
finding a forgery would involve having

1055
00:44:13,380 --> 00:44:16,079
to find a short pre-image of uh this

1056
00:44:16,079 --> 00:44:18,900
randomly hashed message uh and in fact

1057
00:44:18,900 --> 00:44:21,300
that's true if you ignore the fact that

1058
00:44:21,300 --> 00:44:23,579
signatures are being uh given out so

1059
00:44:23,579 --> 00:44:25,440
it's hard to break if you don't give the

1060
00:44:25,440 --> 00:44:27,300
attacker any signatures but if you start

1061
00:44:27,300 --> 00:44:28,800
to give out signatures which is the

1062
00:44:28,800 --> 00:44:31,680
usual uh usage of signature schemes then

1063
00:44:31,680 --> 00:44:34,020
uh it's easy to break and so this was

1064
00:44:34,020 --> 00:44:35,760
shown uh in the so-called parallel of

1065
00:44:35,760 --> 00:44:39,359
hype attack by nuan and regev in 2006.

1066
00:44:39,359 --> 00:44:41,520
so uh the problem is that the

1067
00:44:41,520 --> 00:44:43,800
distribution of the signature is

1068
00:44:43,800 --> 00:44:46,140
coolestly correlated to the shape or the

1069
00:44:46,140 --> 00:44:49,079
geometry of the bases so the signature

1070
00:44:49,079 --> 00:44:51,780
remember looks like C minus uh some

1071
00:44:51,780 --> 00:44:54,300
multiple of B right B times this integer

1072
00:44:54,300 --> 00:44:58,200
vector and so uh it's always in this

1073
00:44:58,200 --> 00:45:01,020
parallel pipet of B times plus minus a

1074
00:45:01,020 --> 00:45:02,460
half to the N right so it's always

1075
00:45:02,460 --> 00:45:04,980
inside this parallel piped centered by

1076
00:45:04,980 --> 00:45:07,440
centered at C the nearby lattice Vector

1077
00:45:07,440 --> 00:45:09,240
is is the unique lattice Vector inside

1078
00:45:09,240 --> 00:45:12,540
this parallel weapon so the uh

1079
00:45:12,540 --> 00:45:14,700
signatures are actually distributed as

1080
00:45:14,700 --> 00:45:17,520
random points inside the parallel pipes

1081
00:45:17,520 --> 00:45:21,300
spanned by the secret basis and given uh

1082
00:45:21,300 --> 00:45:22,680
many signatures and not that many

1083
00:45:22,680 --> 00:45:25,619
actually but given enough signatures the

1084
00:45:25,619 --> 00:45:28,099
entire basis can be uh reconstructed

1085
00:45:28,099 --> 00:45:30,000
using what's called independent

1086
00:45:30,000 --> 00:45:32,160
component analysis right so it

1087
00:45:32,160 --> 00:45:34,079
completely uh recovers the secret key

1088
00:45:34,079 --> 00:45:36,480
from these early attempts

1089
00:45:36,480 --> 00:45:38,819
so the design level solution uh that

1090
00:45:38,819 --> 00:45:40,859
that followed a few years later from gpv

1091
00:45:40,859 --> 00:45:44,339
is to introduce some randomization into

1092
00:45:44,339 --> 00:45:46,500
the generation of the signature so

1093
00:45:46,500 --> 00:45:48,480
instead of just doing uh you know

1094
00:45:48,480 --> 00:45:51,540
rounding off B inverse times C rounding

1095
00:45:51,540 --> 00:45:53,760
it off to the nearest integers uh we

1096
00:45:53,760 --> 00:45:55,560
instead imagine rounding off to some

1097
00:45:55,560 --> 00:45:58,560
nearby uh integers chosen at random from

1098
00:45:58,560 --> 00:46:00,359
an appropriate distribution

1099
00:46:00,359 --> 00:46:04,740
so first attempt uh would be to use in

1100
00:46:04,740 --> 00:46:07,260
each coordinate we just round off uh

1101
00:46:07,260 --> 00:46:09,359
like using a gaussian we round off to a

1102
00:46:09,359 --> 00:46:12,180
nearby integer uh with some standard

1103
00:46:12,180 --> 00:46:13,800
deviation Sigma one

1104
00:46:13,800 --> 00:46:17,160
and so then uh the distribution of the

1105
00:46:17,160 --> 00:46:19,020
signature would look something like this

1106
00:46:19,020 --> 00:46:20,940
it would look like not a parallel piped

1107
00:46:20,940 --> 00:46:22,920
but it would be drawn from a gaussian

1108
00:46:22,920 --> 00:46:25,680
like an ellip elliptical gaussian that

1109
00:46:25,680 --> 00:46:27,780
has this kind of shape to it where this

1110
00:46:27,780 --> 00:46:29,880
shape is still basically the shape of

1111
00:46:29,880 --> 00:46:32,280
the basis so it's not a not a complete

1112
00:46:32,280 --> 00:46:34,740
solution that still reveals sort of the

1113
00:46:34,740 --> 00:46:37,440
geometry of the basis not not everything

1114
00:46:37,440 --> 00:46:39,780
about it but the the shape of it and

1115
00:46:39,780 --> 00:46:42,060
then there's one more uh trick which is

1116
00:46:42,060 --> 00:46:44,220
to say we can kind of

1117
00:46:44,220 --> 00:46:47,579
um accounts or or cancel out the the the

1118
00:46:47,579 --> 00:46:50,880
shape of this uh ellipse by uh

1119
00:46:50,880 --> 00:46:52,800
introducing some initial rounding

1120
00:46:52,800 --> 00:46:55,380
initial uh rounding of a corresponding

1121
00:46:55,380 --> 00:46:58,800
shape right and so by starting with uh

1122
00:46:58,800 --> 00:47:01,920
some so rounding off zero or choosing

1123
00:47:01,920 --> 00:47:04,800
some random short coefficient Vector

1124
00:47:04,800 --> 00:47:06,900
here a coordinate Vector here and

1125
00:47:06,900 --> 00:47:08,700
multiplying it by an appropriate Matrix

1126
00:47:08,700 --> 00:47:10,740
and then and then doing everything else

1127
00:47:10,740 --> 00:47:12,660
we end up with a final distribution

1128
00:47:12,660 --> 00:47:14,579
that's completely spherical and

1129
00:47:14,579 --> 00:47:17,160
isotropic so the signature in this case

1130
00:47:17,160 --> 00:47:20,940
uh would have no leakage or the shape of

1131
00:47:20,940 --> 00:47:23,280
the signature has no correlation to the

1132
00:47:23,280 --> 00:47:26,520
underlying basis all right so what you

1133
00:47:26,520 --> 00:47:28,500
can show formally is that if you choose

1134
00:47:28,500 --> 00:47:30,000
the parameters in just the right way so

1135
00:47:30,000 --> 00:47:30,960
that everything cancels out

1136
00:47:30,960 --> 00:47:33,540
appropriately uh this procedure that you

1137
00:47:33,540 --> 00:47:35,280
get on the right the distribution you

1138
00:47:35,280 --> 00:47:38,040
get is uh statistically close to a

1139
00:47:38,040 --> 00:47:41,520
perfect gaussian and this allows uh an

1140
00:47:41,520 --> 00:47:42,960
actual security proof to go through in

1141
00:47:42,960 --> 00:47:45,180
the random Oracle model where there's of

1142
00:47:45,180 --> 00:47:48,119
Two Worlds the real world is that we

1143
00:47:48,119 --> 00:47:50,760
hash and then we use B to sample the

1144
00:47:50,760 --> 00:47:53,280
short pre-image according to this but in

1145
00:47:53,280 --> 00:47:55,140
this ideal workflow we can actually

1146
00:47:55,140 --> 00:47:57,960
imagine choosing a short Vector s to

1147
00:47:57,960 --> 00:47:59,520
start with and then programming the

1148
00:47:59,520 --> 00:48:02,460
random Oracle for B A times s and so

1149
00:48:02,460 --> 00:48:04,200
this is what enables the proof to go

1150
00:48:04,200 --> 00:48:05,280
through

1151
00:48:05,280 --> 00:48:07,920
okay so there are now many uh different

1152
00:48:07,920 --> 00:48:10,859
concrete proposals uh in the in the gpp

1153
00:48:10,859 --> 00:48:13,079
family depending on uh what kind of

1154
00:48:13,079 --> 00:48:15,180
lattices you use how you generate the

1155
00:48:15,180 --> 00:48:17,520
short basis what kind of precise

1156
00:48:17,520 --> 00:48:19,980
sampling algorithm you use in signing

1157
00:48:19,980 --> 00:48:22,140
and so there's been several Works uh

1158
00:48:22,140 --> 00:48:23,940
Falcon for example which was selected by

1159
00:48:23,940 --> 00:48:26,280
nist is one mataka is a follow-up and

1160
00:48:26,280 --> 00:48:28,380
there have been many others there's a

1161
00:48:28,380 --> 00:48:30,240
different family of of trapdoors that

1162
00:48:30,240 --> 00:48:32,520
can be used that give different kinds of

1163
00:48:32,520 --> 00:48:33,839
properties

1164
00:48:33,839 --> 00:48:37,140
so um good so that's all in terms of the

1165
00:48:37,140 --> 00:48:40,140
the Black Box model where the leakage

1166
00:48:40,140 --> 00:48:42,000
that you get from the signer is just the

1167
00:48:42,000 --> 00:48:44,520
signatures that are that are produced uh

1168
00:48:44,520 --> 00:48:46,680
from this black box but now let's go

1169
00:48:46,680 --> 00:48:49,380
into uh side Channel attacks so side

1170
00:48:49,380 --> 00:48:53,040
Channel attacks say well in reality you

1171
00:48:53,040 --> 00:48:54,780
know signers aren't black boxes they're

1172
00:48:54,780 --> 00:48:56,880
doing computation and they may be

1173
00:48:56,880 --> 00:48:59,280
leaking uh information about their

1174
00:48:59,280 --> 00:49:01,260
secret operations we saw many examples

1175
00:49:01,260 --> 00:49:02,280
this morning

1176
00:49:02,280 --> 00:49:04,260
so examples would be like how much power

1177
00:49:04,260 --> 00:49:06,780
the signer uses what electromagnetic

1178
00:49:06,780 --> 00:49:09,839
conditions that it puts out timing that

1179
00:49:09,839 --> 00:49:12,420
uh the Furious operations take even

1180
00:49:12,420 --> 00:49:15,180
acoustic emanations from processors can

1181
00:49:15,180 --> 00:49:16,920
be used as side channels

1182
00:49:16,920 --> 00:49:19,140
and so when people have taken a look at

1183
00:49:19,140 --> 00:49:21,660
uh these these uh signing procedures

1184
00:49:21,660 --> 00:49:23,760
they've looked at okay well

1185
00:49:23,760 --> 00:49:25,619
is there side Channel information we can

1186
00:49:25,619 --> 00:49:28,740
use to then mount a parallel pipette

1187
00:49:28,740 --> 00:49:30,420
style attacks by getting partial

1188
00:49:30,420 --> 00:49:32,760
information uh during the signing

1189
00:49:32,760 --> 00:49:35,460
procedure right so in Falcon remember

1190
00:49:35,460 --> 00:49:38,339
that a signature looks like uh this

1191
00:49:38,339 --> 00:49:41,160
initial solution C minus this uh lattice

1192
00:49:41,160 --> 00:49:43,980
Vector that's near C all right and this

1193
00:49:43,980 --> 00:49:45,780
lattice Vector is some integer

1194
00:49:45,780 --> 00:49:48,060
combination of the secret basis

1195
00:49:48,060 --> 00:49:49,740
right and so if you monitor power

1196
00:49:49,740 --> 00:49:51,900
consumption or other side channels you

1197
00:49:51,900 --> 00:49:53,280
can get information about these

1198
00:49:53,280 --> 00:49:55,619
coefficients zi here

1199
00:49:55,619 --> 00:49:57,240
and so there have been a couple of side

1200
00:49:57,240 --> 00:49:59,640
Channel assisted uh parallel piped style

1201
00:49:59,640 --> 00:50:03,119
attacks from Teach as last year uh Power

1202
00:50:03,119 --> 00:50:07,740
analysis allowed you to uh detect when

1203
00:50:07,740 --> 00:50:10,200
for example the first coefficient zero

1204
00:50:10,200 --> 00:50:13,020
here is a zero or one and that allows

1205
00:50:13,020 --> 00:50:15,599
you to know that the signature lies in

1206
00:50:15,599 --> 00:50:17,339
some kind of band

1207
00:50:17,339 --> 00:50:19,500
um or that rather the the vector v lies

1208
00:50:19,500 --> 00:50:21,119
in some kind of band and that gives you

1209
00:50:21,119 --> 00:50:25,079
information about uh b0 and then a

1210
00:50:25,079 --> 00:50:28,500
second work uh uh eurocrypt a week or

1211
00:50:28,500 --> 00:50:31,859
two ago showed that you can even get

1212
00:50:31,859 --> 00:50:34,740
enough information if uh the Z zero so

1213
00:50:34,740 --> 00:50:36,119
one of these coefficients whether it's

1214
00:50:36,119 --> 00:50:37,740
positive or negative so it tells you

1215
00:50:37,740 --> 00:50:40,560
which side of this half space it lies on

1216
00:50:40,560 --> 00:50:42,420
and that's enough information to mount a

1217
00:50:42,420 --> 00:50:44,280
parallel pipette attack as well

1218
00:50:44,280 --> 00:50:46,020
so um

1219
00:50:46,020 --> 00:50:47,280
the most

1220
00:50:47,280 --> 00:50:49,079
robust countermeasure that we have

1221
00:50:49,079 --> 00:50:50,819
against side Channel attacks is masking

1222
00:50:50,819 --> 00:50:54,000
which is is widely used and the idea of

1223
00:50:54,000 --> 00:50:56,400
masking is to split each sensitive value

1224
00:50:56,400 --> 00:50:59,520
uh in the computation into a bunch of uh

1225
00:50:59,520 --> 00:51:02,280
shares basically secret share of them

1226
00:51:02,280 --> 00:51:03,960
um so that the real value is just the

1227
00:51:03,960 --> 00:51:05,819
sum of all these shares

1228
00:51:05,819 --> 00:51:09,240
and you can then analyze algorithms in

1229
00:51:09,240 --> 00:51:11,280
this so-called T probing model

1230
00:51:11,280 --> 00:51:14,579
where you allow the adversary to see up

1231
00:51:14,579 --> 00:51:17,220
to T sensitive values uh in the

1232
00:51:17,220 --> 00:51:21,000
computation but no more so this is some

1233
00:51:21,000 --> 00:51:23,940
kind of uh interesting model for uh side

1234
00:51:23,940 --> 00:51:26,040
Channel if x it's not the complete most

1235
00:51:26,040 --> 00:51:27,900
realistic model but it allows us to to

1236
00:51:27,900 --> 00:51:29,339
say something it's a good starting point

1237
00:51:29,339 --> 00:51:31,200
for understanding things

1238
00:51:31,200 --> 00:51:35,099
so if we split values into D shares so

1239
00:51:35,099 --> 00:51:37,079
that all the shares are random subject

1240
00:51:37,079 --> 00:51:39,300
to the constraint that they add up to

1241
00:51:39,300 --> 00:51:42,720
the actual secret value then you can get

1242
00:51:42,720 --> 00:51:46,260
a t probing security uh using MPC style

1243
00:51:46,260 --> 00:51:49,079
techniques and so if your operations are

1244
00:51:49,079 --> 00:51:52,680
linear uh then they they kind of

1245
00:51:52,680 --> 00:51:54,240
interact nicely with these linear

1246
00:51:54,240 --> 00:51:56,640
sharing and everything can be done quite

1247
00:51:56,640 --> 00:51:58,260
efficiently you just have linear

1248
00:51:58,260 --> 00:52:01,619
overhead in the number of shares uh if

1249
00:52:01,619 --> 00:52:03,359
your operations or multiplications then

1250
00:52:03,359 --> 00:52:05,160
you have to do some more interesting uh

1251
00:52:05,160 --> 00:52:07,380
NPC style multiplications and there's a

1252
00:52:07,380 --> 00:52:09,119
quadratic overhead which is hopefully

1253
00:52:09,119 --> 00:52:10,800
not not too bad and you can afford it

1254
00:52:10,800 --> 00:52:12,300
but if you're doing more complex

1255
00:52:12,300 --> 00:52:13,740
operations then there would be more than

1256
00:52:13,740 --> 00:52:16,140
quadratic over it

1257
00:52:16,140 --> 00:52:17,940
um good so in the T probing model

1258
00:52:17,940 --> 00:52:19,680
ideally you would you would have no

1259
00:52:19,680 --> 00:52:21,599
leakage whatsoever as long as the number

1260
00:52:21,599 --> 00:52:24,059
of shares exceeds the number of probed

1261
00:52:24,059 --> 00:52:25,980
values

1262
00:52:25,980 --> 00:52:28,260
okay so this brings us to mataka from

1263
00:52:28,260 --> 00:52:32,040
last uh from from last year uh so nataka

1264
00:52:32,040 --> 00:52:33,420
one of the features is many nice

1265
00:52:33,420 --> 00:52:36,839
features of mataka but one of the um key

1266
00:52:36,839 --> 00:52:39,059
features that the designers were aiming

1267
00:52:39,059 --> 00:52:42,180
for was easy mask ability so the

1268
00:52:42,180 --> 00:52:45,119
algorithms for mataka were designed to

1269
00:52:45,119 --> 00:52:46,800
be easily maskable

1270
00:52:46,800 --> 00:52:50,700
and they gave uh an outline of the proof

1271
00:52:50,700 --> 00:52:53,400
of a proof of this uh Security in the T

1272
00:52:53,400 --> 00:52:54,480
probing model

1273
00:52:54,480 --> 00:52:55,740
so

1274
00:52:55,740 --> 00:52:59,460
we won't give exactly the the algorithm

1275
00:52:59,460 --> 00:53:01,619
um signing procedure algorithm but what

1276
00:53:01,619 --> 00:53:03,599
I showed you before is roughly how it

1277
00:53:03,599 --> 00:53:07,319
works so again one uh sort of chooses a

1278
00:53:07,319 --> 00:53:10,319
random small Vector here multiplies it

1279
00:53:10,319 --> 00:53:12,319
by an appropriate linear transformation

1280
00:53:12,319 --> 00:53:16,020
and then adds a c applies B inverse and

1281
00:53:16,020 --> 00:53:18,119
then rounds this off here so let's look

1282
00:53:18,119 --> 00:53:19,859
at the different pieces of the signing

1283
00:53:19,859 --> 00:53:23,940
procedure in the masked setting so the

1284
00:53:23,940 --> 00:53:26,520
first point is uh nice this this initial

1285
00:53:26,520 --> 00:53:29,220
uh short random Vector can be done

1286
00:53:29,220 --> 00:53:31,140
offline so there's not really anything

1287
00:53:31,140 --> 00:53:33,300
you have to mask if you can do this

1288
00:53:33,300 --> 00:53:36,359
offline and store the result that's fine

1289
00:53:36,359 --> 00:53:39,119
these multiplications so m and b and b

1290
00:53:39,119 --> 00:53:42,359
inverse are secret uh secret elements or

1291
00:53:42,359 --> 00:53:44,400
secret matrices

1292
00:53:44,400 --> 00:53:46,200
um and so they have to be masked when

1293
00:53:46,200 --> 00:53:48,599
you multiply but these are relatively

1294
00:53:48,599 --> 00:53:51,200
easy to do because as I mentioned before

1295
00:53:51,200 --> 00:53:53,460
multiplications of two masked values

1296
00:53:53,460 --> 00:53:55,740
just involves uh you know quadratic

1297
00:53:55,740 --> 00:53:57,540
overhead just doing a simple NPC

1298
00:53:57,540 --> 00:53:58,500
technique

1299
00:53:58,500 --> 00:54:01,140
so these these aren't too bad to do but

1300
00:54:01,140 --> 00:54:03,300
the final step which is the final

1301
00:54:03,300 --> 00:54:06,119
rounding so we get this uh we get this

1302
00:54:06,119 --> 00:54:08,460
real valued coefficient vector and then

1303
00:54:08,460 --> 00:54:10,079
we need to do randomized rounding of

1304
00:54:10,079 --> 00:54:13,740
each entry uh and so how do we mask that

1305
00:54:13,740 --> 00:54:16,559
that was that's the sort of hard part uh

1306
00:54:16,559 --> 00:54:20,160
about masking this so in mataka they uh

1307
00:54:20,160 --> 00:54:21,960
proposed a masked gaussian sampling

1308
00:54:21,960 --> 00:54:25,680
procedure where you have this uh C which

1309
00:54:25,680 --> 00:54:26,760
is something that you'd like to do

1310
00:54:26,760 --> 00:54:29,280
randomized rounding on and C is just

1311
00:54:29,280 --> 00:54:31,500
shared so it's it's masked and shared

1312
00:54:31,500 --> 00:54:33,300
into D shares and then they want to

1313
00:54:33,300 --> 00:54:36,240
produce a sharing of the corresponding

1314
00:54:36,240 --> 00:54:38,579
uh randomized rounded output

1315
00:54:38,579 --> 00:54:41,760
okay so uh the basic idea is just to do

1316
00:54:41,760 --> 00:54:44,520
it entry share by share okay so you just

1317
00:54:44,520 --> 00:54:48,660
take uh Ci or CJ rather so the J share

1318
00:54:48,660 --> 00:54:51,059
of C you do some gaussian rounding on it

1319
00:54:51,059 --> 00:54:53,400
and that gives you a share of the

1320
00:54:53,400 --> 00:54:56,220
integer and then the point is that the

1321
00:54:56,220 --> 00:54:59,819
uh resulting zjs are a sharing of the

1322
00:54:59,819 --> 00:55:03,300
actual uh gaussian Z output right and

1323
00:55:03,300 --> 00:55:04,980
the reason this works is that the sum of

1324
00:55:04,980 --> 00:55:07,140
uh D gaussians is just the square root

1325
00:55:07,140 --> 00:55:09,359
times square root of D times wider than

1326
00:55:09,359 --> 00:55:12,059
uh the initial gaussian

1327
00:55:12,059 --> 00:55:15,119
so uh this seems really nice this is a

1328
00:55:15,119 --> 00:55:18,720
very clean uh way of doing it and um

1329
00:55:18,720 --> 00:55:21,059
unfortunately there is an attack against

1330
00:55:21,059 --> 00:55:23,339
this uh contrary to what was what was

1331
00:55:23,339 --> 00:55:25,920
believed so the there was a proof

1332
00:55:25,920 --> 00:55:27,839
outline given in Matata which says that

1333
00:55:27,839 --> 00:55:31,680
well you know if you look at the shares

1334
00:55:31,680 --> 00:55:35,339
of the uh of the C value the input to

1335
00:55:35,339 --> 00:55:37,680
the gaussian sampling procedure

1336
00:55:37,680 --> 00:55:41,099
uh you know any T any looking at any T

1337
00:55:41,099 --> 00:55:43,200
of these they all look uniform because

1338
00:55:43,200 --> 00:55:45,420
it's a random sharing of the actual

1339
00:55:45,420 --> 00:55:47,520
value and if you look at the output if

1340
00:55:47,520 --> 00:55:50,460
you any T of these looks random

1341
00:55:50,460 --> 00:55:51,960
um and so

1342
00:55:51,960 --> 00:55:53,940
we leak nothing right

1343
00:55:53,940 --> 00:55:55,980
but the nature of the attack is that

1344
00:55:55,980 --> 00:55:58,319
there's correlations between these CJs

1345
00:55:58,319 --> 00:55:59,700
and zjs

1346
00:55:59,700 --> 00:56:02,819
and so in particular by Design By

1347
00:56:02,819 --> 00:56:05,579
definition the difference between CJ and

1348
00:56:05,579 --> 00:56:09,240
CJ is itself a gaussian distributed and

1349
00:56:09,240 --> 00:56:11,700
so uh if you add up these differences

1350
00:56:11,700 --> 00:56:14,760
they're correlated uh to the overall

1351
00:56:14,760 --> 00:56:17,940
output of uh C minus C

1352
00:56:17,940 --> 00:56:21,180
okay so let's just kind of give a basic

1353
00:56:21,180 --> 00:56:23,040
idea of the attack

1354
00:56:23,040 --> 00:56:23,640
um

1355
00:56:23,640 --> 00:56:27,000
this is this V is sort of the the output

1356
00:56:27,000 --> 00:56:30,420
of uh or rather the secret offset of the

1357
00:56:30,420 --> 00:56:32,700
shrapdoor sampler and we're going to

1358
00:56:32,700 --> 00:56:36,540
probe T over 2 of these the C shares and

1359
00:56:36,540 --> 00:56:39,420
T over two of these Z shares we'll just

1360
00:56:39,420 --> 00:56:41,700
add up their differences right call that

1361
00:56:41,700 --> 00:56:42,599
w

1362
00:56:42,599 --> 00:56:46,260
and this W is one component it's not the

1363
00:56:46,260 --> 00:56:48,720
entire component but it's a small value

1364
00:56:48,720 --> 00:56:51,000
that's an additive component of the

1365
00:56:51,000 --> 00:56:52,800
actual signature

1366
00:56:52,800 --> 00:56:54,780
and so it tends to be positively

1367
00:56:54,780 --> 00:56:57,059
correlated with the signature right in

1368
00:56:57,059 --> 00:57:01,800
particular uh W Times b0 uh in an inner

1369
00:57:01,800 --> 00:57:03,599
product with the signature tends to be

1370
00:57:03,599 --> 00:57:04,680
positive

1371
00:57:04,680 --> 00:57:06,839
okay and so it's biased in the same

1372
00:57:06,839 --> 00:57:09,720
direction as uh the first lattice Vector

1373
00:57:09,720 --> 00:57:11,880
the first basis vector

1374
00:57:11,880 --> 00:57:14,099
so we have the I guess the return of the

1375
00:57:14,099 --> 00:57:16,020
return of the parallel pipette attack we

1376
00:57:16,020 --> 00:57:18,599
can get an estimator for b0 by just

1377
00:57:18,599 --> 00:57:22,500
taking a lot of traces or a lot of uh

1378
00:57:22,500 --> 00:57:25,800
yeah TT probing traces here and uh

1379
00:57:25,800 --> 00:57:26,940
what's interesting is this is an

1380
00:57:26,940 --> 00:57:30,480
unbiased estimator of b0 with some uh

1381
00:57:30,480 --> 00:57:32,940
noise in it but as you get more and more

1382
00:57:32,940 --> 00:57:35,700
traces the width of the noise decreases

1383
00:57:35,700 --> 00:57:37,079
as the square root of the number of

1384
00:57:37,079 --> 00:57:38,220
traces

1385
00:57:38,220 --> 00:57:40,800
and so uh the more traces you have the

1386
00:57:40,800 --> 00:57:42,480
easier it'd get the more precise

1387
00:57:42,480 --> 00:57:44,880
Precision you get for uh your estimate

1388
00:57:44,880 --> 00:57:46,980
of b0 so if you get about two million

1389
00:57:46,980 --> 00:57:49,500
traces you can recover b0 just by

1390
00:57:49,500 --> 00:57:51,900
rounding off and maybe simple guessing

1391
00:57:51,900 --> 00:57:54,480
if you have fewer than that you can use

1392
00:57:54,480 --> 00:57:59,099
lattice reduction to find still b0 and

1393
00:57:59,099 --> 00:58:01,079
even if you have a number of traces

1394
00:58:01,079 --> 00:58:04,140
which is a linear in the uh number of

1395
00:58:04,140 --> 00:58:07,200
shares you can still recover b0 even

1396
00:58:07,200 --> 00:58:09,540
with a constant number of probes right

1397
00:58:09,540 --> 00:58:11,940
so this is an asymptotic uh result that

1398
00:58:11,940 --> 00:58:14,579
happens to be true so here's a summary

1399
00:58:14,579 --> 00:58:18,540
uh the um specific values that one can

1400
00:58:18,540 --> 00:58:20,520
get

1401
00:58:20,520 --> 00:58:22,079
um number of as the number of traces

1402
00:58:22,079 --> 00:58:23,339
increases

1403
00:58:23,339 --> 00:58:27,300
okay and uh the ratio of how many Trace

1404
00:58:27,300 --> 00:58:29,040
I'm sorry how many probes you take

1405
00:58:29,040 --> 00:58:32,520
relative to the number of shares as uh

1406
00:58:32,520 --> 00:58:36,359
this ratio increases the work you have

1407
00:58:36,359 --> 00:58:39,359
to do uh decreases uh quite a bit and

1408
00:58:39,359 --> 00:58:40,859
this dotted line means that it's a

1409
00:58:40,859 --> 00:58:43,619
trivial uh recovery uh and these lines

1410
00:58:43,619 --> 00:58:46,020
above indicate how hard it is to use

1411
00:58:46,020 --> 00:58:48,480
lattice reduction to recover the basis

1412
00:58:48,480 --> 00:58:49,500
Factor

1413
00:58:49,500 --> 00:58:51,059
okay so

1414
00:58:51,059 --> 00:58:53,099
um that is the summary of everything and

1415
00:58:53,099 --> 00:58:55,079
uh here's a bibliography of of the works

1416
00:58:55,079 --> 00:58:58,520
and I'm happy to take your questions

1417
00:59:01,920 --> 00:59:03,599
well thank you Chris do we have any

1418
00:59:03,599 --> 00:59:05,839
questions

1419
00:59:08,339 --> 00:59:10,740
no thanks Chris for standing in on

1420
00:59:10,740 --> 00:59:12,420
behalf of Tomah and thanks to all the

1421
00:59:12,420 --> 00:59:15,440
speakers in the attack session

1422
00:59:17,099 --> 00:59:20,240
on my Passover

