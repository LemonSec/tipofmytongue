1
00:00:00,000 --> 00:00:01,500
you know we're not leaving we're

2
00:00:01,500 --> 00:00:03,899
continuing the to the next session

3
00:00:03,899 --> 00:00:07,319
without a break uh so Chris not only is

4
00:00:07,319 --> 00:00:09,420
uh standing in for the speaker in a

5
00:00:09,420 --> 00:00:12,660
previous session he's in by a speaker

6
00:00:12,660 --> 00:00:15,599
um he's a so I'm introducing him now

7
00:00:15,599 --> 00:00:17,220
Chris is a professor of computer science

8
00:00:17,220 --> 00:00:18,960
and engineering at the University of

9
00:00:18,960 --> 00:00:21,000
Michigan at Ann Arbor

10
00:00:21,000 --> 00:00:23,340
um he's well known for his work on on

11
00:00:23,340 --> 00:00:26,939
lantises which he uses to design secure

12
00:00:26,939 --> 00:00:28,560
efficient and Powerful cryptographic

13
00:00:28,560 --> 00:00:29,640
tools

14
00:00:29,640 --> 00:00:32,940
his research has been really visible and

15
00:00:32,940 --> 00:00:35,460
instrumental to ethereum practice of

16
00:00:35,460 --> 00:00:37,620
several post-quantum cryptography

17
00:00:37,620 --> 00:00:40,640
standards he's received a lot of

18
00:00:40,640 --> 00:00:43,680
different recognition uh he's a

19
00:00:43,680 --> 00:00:45,200
recipient of a Sloan Foundation

20
00:00:45,200 --> 00:00:49,680
Fellowship NSF career award and TCC TCC

21
00:00:49,680 --> 00:00:52,379
test of time award and multiple best pay

22
00:00:52,379 --> 00:00:55,620
for awards and now uh he's going to tell

23
00:00:55,620 --> 00:00:58,199
us about the unexpected applications of

24
00:00:58,199 --> 00:01:00,360
fully homophic encryption uh thanks

25
00:01:00,360 --> 00:01:02,579
Chris all right thank you Juan thank you

26
00:01:02,579 --> 00:01:05,000
for the introduction and the invitation

27
00:01:05,000 --> 00:01:07,860
it's uh great to be back in in Atlanta

28
00:01:07,860 --> 00:01:11,340
and at Georgia Tech and um happy to to

29
00:01:11,340 --> 00:01:14,400
talk to you all about some recent work

30
00:01:14,400 --> 00:01:18,299
which reveals a to me a large number of

31
00:01:18,299 --> 00:01:21,060
unexpected applications of fully

32
00:01:21,060 --> 00:01:22,799
homomorphic encryption

33
00:01:22,799 --> 00:01:25,740
so uh to sort of set the stage fully

34
00:01:25,740 --> 00:01:27,479
homomorphic encryption was this idea

35
00:01:27,479 --> 00:01:31,140
proposed by rivest Adelman and dutus uh

36
00:01:31,140 --> 00:01:33,420
now 35 years ago if I'm doing my math

37
00:01:33,420 --> 00:01:37,979
right and uh the idea is uh what if we

38
00:01:37,979 --> 00:01:42,240
could say take some data or message m

39
00:01:42,240 --> 00:01:44,280
and encrypt it under a key a public key

40
00:01:44,280 --> 00:01:47,159
secret key doesn't really matter and we

41
00:01:47,159 --> 00:01:48,600
can encrypt it and that sort of puts it

42
00:01:48,600 --> 00:01:50,820
in a box right so you can't look inside

43
00:01:50,820 --> 00:01:53,399
the Box there's just some opaque uh

44
00:01:53,399 --> 00:01:56,399
unreadable data inside this box but then

45
00:01:56,399 --> 00:01:59,159
what if we could evaluate arbitrary

46
00:01:59,159 --> 00:02:02,100
functions on that underlying data so you

47
00:02:02,100 --> 00:02:04,920
put this this ciphertext and a function

48
00:02:04,920 --> 00:02:07,500
f through this evaluation procedure and

49
00:02:07,500 --> 00:02:09,899
out comes now uh ciphertext that

50
00:02:09,899 --> 00:02:12,780
encrypts F of M instead

51
00:02:12,780 --> 00:02:15,720
and by encrypts F of M we mean well if

52
00:02:15,720 --> 00:02:17,879
you were to decrypt this ciphertext you

53
00:02:17,879 --> 00:02:21,599
would get out uh the value F of n

54
00:02:21,599 --> 00:02:24,300
and the important property which is

55
00:02:24,300 --> 00:02:26,819
sometimes implicit uh but is is really

56
00:02:26,819 --> 00:02:28,140
important for what we'll talk about

57
00:02:28,140 --> 00:02:29,940
today is that this should be compact

58
00:02:29,940 --> 00:02:34,379
right so the size of the ciphertext FFM

59
00:02:34,379 --> 00:02:37,140
should be much smaller than the function

60
00:02:37,140 --> 00:02:38,700
itself the representation of the

61
00:02:38,700 --> 00:02:40,620
function because one way you could

62
00:02:40,620 --> 00:02:43,500
trivially get a homomorphic encryption

63
00:02:43,500 --> 00:02:45,180
would be to just sort of take the

64
00:02:45,180 --> 00:02:47,099
ciphertext the encryption of M and just

65
00:02:47,099 --> 00:02:49,620
append F to it and then when you decrypt

66
00:02:49,620 --> 00:02:52,140
okay decrypt M and apply F to the result

67
00:02:52,140 --> 00:02:54,720
and that so that that's a trivial way to

68
00:02:54,720 --> 00:02:57,180
get fully homomorphic encryption but it

69
00:02:57,180 --> 00:02:59,160
would require attaching F to the

70
00:02:59,160 --> 00:03:01,140
ciphertext so what makes this

71
00:03:01,140 --> 00:03:03,780
non-trivial is this uh compactness

72
00:03:03,780 --> 00:03:05,580
property here

73
00:03:05,580 --> 00:03:08,160
okay so this is this is sort of the the

74
00:03:08,160 --> 00:03:09,780
canonical definition of fully

75
00:03:09,780 --> 00:03:12,060
homomorphic encryption and it was a long

76
00:03:12,060 --> 00:03:14,700
time uh it was sought after this was the

77
00:03:14,700 --> 00:03:17,400
Holy Grail of cryptography that was

78
00:03:17,400 --> 00:03:20,099
thought after for three decades uh with

79
00:03:20,099 --> 00:03:23,700
no really uh satisfactory Solutions uh

80
00:03:23,700 --> 00:03:26,580
until Gentry first gave the you know the

81
00:03:26,580 --> 00:03:29,700
first really credible uh proposal for a

82
00:03:29,700 --> 00:03:32,220
fully homomorphic encryption scheme and

83
00:03:32,220 --> 00:03:34,260
this spurred a ton of Interest it was a

84
00:03:34,260 --> 00:03:36,780
very exciting uh result with a lot of uh

85
00:03:36,780 --> 00:03:39,720
follow-up works in the the years uh

86
00:03:39,720 --> 00:03:42,540
following and lots of work improving the

87
00:03:42,540 --> 00:03:45,900
efficiency the theoretical uh security

88
00:03:45,900 --> 00:03:48,599
guarantees uh the Simplicity of these

89
00:03:48,599 --> 00:03:50,879
schemes and so forth and so on

90
00:03:50,879 --> 00:03:55,260
okay so the Holy Grail as I mentioned uh

91
00:03:55,260 --> 00:03:56,879
and you know people had in mind it's

92
00:03:56,879 --> 00:03:58,560
called a Holy Grail because it would

93
00:03:58,560 --> 00:04:00,239
have had so many applications right

94
00:04:00,239 --> 00:04:02,400
people said oh if we had fhe we could do

95
00:04:02,400 --> 00:04:03,659
this and that and the other thing right

96
00:04:03,659 --> 00:04:06,060
even before we had it so countless

97
00:04:06,060 --> 00:04:09,540
applications uh of this tool but uh I

98
00:04:09,540 --> 00:04:10,980
would like to argue that some of these

99
00:04:10,980 --> 00:04:13,439
applications are more uh more surprising

100
00:04:13,439 --> 00:04:15,180
uh than others at least they're

101
00:04:15,180 --> 00:04:17,399
surprised more surprising to me

102
00:04:17,399 --> 00:04:19,560
so let's talk about uh these

103
00:04:19,560 --> 00:04:20,760
applications

104
00:04:20,760 --> 00:04:22,440
um there are so many I won't be able to

105
00:04:22,440 --> 00:04:25,740
list even a small fraction of them uh

106
00:04:25,740 --> 00:04:28,020
but let me categorize them into let's

107
00:04:28,020 --> 00:04:30,600
say less surprising applications and

108
00:04:30,600 --> 00:04:33,240
then more uh surprising at least to me

109
00:04:33,240 --> 00:04:35,220
okay so what are some of the less

110
00:04:35,220 --> 00:04:36,840
surprising applications the things that

111
00:04:36,840 --> 00:04:39,300
people had in mind when fhe was first

112
00:04:39,300 --> 00:04:41,580
conceived of and or when people were

113
00:04:41,580 --> 00:04:43,259
saying oh if I had fhe I could do this

114
00:04:43,259 --> 00:04:45,120
that and the other thing

115
00:04:45,120 --> 00:04:47,639
um so the canonical story that we fell

116
00:04:47,639 --> 00:04:50,040
about fhe is private Cloud computation

117
00:04:50,040 --> 00:04:52,979
right I have my private data you know my

118
00:04:52,979 --> 00:04:55,500
private photos or emails or whatever I

119
00:04:55,500 --> 00:04:58,020
want to store them on the cloud I'd like

120
00:04:58,020 --> 00:05:00,419
to be able to search them in encrypted

121
00:05:00,419 --> 00:05:03,180
form or do processing on them encrypted

122
00:05:03,180 --> 00:05:05,160
form right so this is the the picture

123
00:05:05,160 --> 00:05:08,400
that you know every fhe talk uh gives

124
00:05:08,400 --> 00:05:09,960
right you have Google over here storing

125
00:05:09,960 --> 00:05:12,060
your encrypted FHA encrypted data and

126
00:05:12,060 --> 00:05:14,340
it's able to do searches and processing

127
00:05:14,340 --> 00:05:16,259
and so forth homomorphically and only

128
00:05:16,259 --> 00:05:17,940
you get to read the results because you

129
00:05:17,940 --> 00:05:19,800
have the secret key

130
00:05:19,800 --> 00:05:22,340
okay a second example would be

131
00:05:22,340 --> 00:05:24,419
multi-party computation with low

132
00:05:24,419 --> 00:05:27,960
communication so we have all our parties

133
00:05:27,960 --> 00:05:30,840
they encrypt their uh individual inputs

134
00:05:30,840 --> 00:05:34,620
under fhe then the uh everybody can

135
00:05:34,620 --> 00:05:37,380
locally compute well we send our

136
00:05:37,380 --> 00:05:39,120
encrypted inputs to each other and then

137
00:05:39,120 --> 00:05:40,919
we can all locally compute the results

138
00:05:40,919 --> 00:05:44,280
of the fhe and then we uh somehow

139
00:05:44,280 --> 00:05:46,440
jointly decrypt in the end okay so

140
00:05:46,440 --> 00:05:47,759
that's just very low communication

141
00:05:47,759 --> 00:05:49,560
because we're just sending our encrypted

142
00:05:49,560 --> 00:05:50,940
inputs to each other

143
00:05:50,940 --> 00:05:54,000
uh code obfuscation and is another well

144
00:05:54,000 --> 00:05:56,100
you want to encrypt code so let's use

145
00:05:56,100 --> 00:05:57,720
fhe to encrypt code and then

146
00:05:57,720 --> 00:05:59,780
homomorphically run the code

147
00:05:59,780 --> 00:06:03,120
Quantum fhe well fhe is in the name so

148
00:06:03,120 --> 00:06:04,919
obviously it's not very surprising that

149
00:06:04,919 --> 00:06:07,320
fhe would be useful to this right so

150
00:06:07,320 --> 00:06:09,539
lots and lots of of uh of great

151
00:06:09,539 --> 00:06:12,360
applications uh but they they don't

152
00:06:12,360 --> 00:06:14,400
surprise you that fhe comes into the

153
00:06:14,400 --> 00:06:15,300
picture

154
00:06:15,300 --> 00:06:18,180
uh by contrast uh to me at least maybe I

155
00:06:18,180 --> 00:06:21,000
just need a better imagination uh but I

156
00:06:21,000 --> 00:06:22,199
think there have been a lot of

157
00:06:22,199 --> 00:06:25,319
unexpected applications of fhe uh since

158
00:06:25,319 --> 00:06:27,539
it has emerged and I'm going to list

159
00:06:27,539 --> 00:06:29,819
these in uh reverse order reverse

160
00:06:29,819 --> 00:06:32,160
chronological order and I'll talk about

161
00:06:32,160 --> 00:06:33,840
them in Reverse chronological order in

162
00:06:33,840 --> 00:06:35,580
the talk as well

163
00:06:35,580 --> 00:06:37,919
um because somehow over the years we've

164
00:06:37,919 --> 00:06:39,720
gotten a better understanding have been

165
00:06:39,720 --> 00:06:41,220
able to sort of isolate the Key

166
00:06:41,220 --> 00:06:44,520
Properties be more modular about things

167
00:06:44,520 --> 00:06:47,460
um so the most recent unexpected

168
00:06:47,460 --> 00:06:50,639
application is uh functional commitments

169
00:06:50,639 --> 00:06:52,919
for all functions

170
00:06:52,919 --> 00:06:55,080
and this was a work uh where we had a

171
00:06:55,080 --> 00:06:57,720
starting point a couple of years ago and

172
00:06:57,720 --> 00:06:59,520
then in eurocrypt we kind of completely

173
00:06:59,520 --> 00:07:02,100
solved this problem uh eurocrypt this

174
00:07:02,100 --> 00:07:02,880
year

175
00:07:02,880 --> 00:07:05,940
another one was instantiating Fiat

176
00:07:05,940 --> 00:07:07,860
Shamir to get non-interactive zero

177
00:07:07,860 --> 00:07:09,960
knowledge uh proofs

178
00:07:09,960 --> 00:07:13,560
all right so that was a sub that was a

179
00:07:13,560 --> 00:07:16,759
culmination of several Works in 2019

180
00:07:16,759 --> 00:07:19,979
that finally resolved this uh question

181
00:07:19,979 --> 00:07:22,979
as well and then there have been a lot

182
00:07:22,979 --> 00:07:24,539
more I'll talk about at the end a lot

183
00:07:24,539 --> 00:07:26,340
more applications like attribute-based

184
00:07:26,340 --> 00:07:29,039
encryption and so forth uh which also

185
00:07:29,039 --> 00:07:31,080
seems somewhat unexpected

186
00:07:31,080 --> 00:07:34,080
so why we do why are these unexpected

187
00:07:34,080 --> 00:07:38,460
and uh you know the others are not well

188
00:07:38,460 --> 00:07:40,560
what I would say is that in these

189
00:07:40,560 --> 00:07:43,319
applications uh there's no hidden data

190
00:07:43,319 --> 00:07:45,840
there's no encrypted message

191
00:07:45,840 --> 00:07:47,460
right or if there is an encrypted

192
00:07:47,460 --> 00:07:49,440
message you're not actually Computing on

193
00:07:49,440 --> 00:07:51,539
it it's sort of off to the side you're

194
00:07:51,539 --> 00:07:53,759
not Computing on it uh the stuff you

195
00:07:53,759 --> 00:07:56,520
aren't Computing on is is public uh

196
00:07:56,520 --> 00:07:59,580
information right so in fhe right the

197
00:07:59,580 --> 00:08:01,020
picture is where you have some encrypted

198
00:08:01,020 --> 00:08:03,000
data and you compute on that encrypted

199
00:08:03,000 --> 00:08:06,419
data here in these applications the data

200
00:08:06,419 --> 00:08:09,240
isn't hidden uh we're homomorphically

201
00:08:09,240 --> 00:08:13,139
Computing on public data okay or uh if

202
00:08:13,139 --> 00:08:15,360
we are in one case we are doing some

203
00:08:15,360 --> 00:08:17,580
homomorphic computation on hidden data

204
00:08:17,580 --> 00:08:20,099
but we never actually decrypt it

205
00:08:20,099 --> 00:08:21,960
okay which is a bit weird right how can

206
00:08:21,960 --> 00:08:24,539
it be useful to homomorphically compute

207
00:08:24,539 --> 00:08:26,220
on data but then never actually recover

208
00:08:26,220 --> 00:08:28,620
the answer and yet it's it's very useful

209
00:08:28,620 --> 00:08:32,219
especially in the second example okay so

210
00:08:32,219 --> 00:08:33,659
that's why I feel that these

211
00:08:33,659 --> 00:08:37,219
applications uh are sort of surprising

212
00:08:37,219 --> 00:08:39,299
and uh

213
00:08:39,299 --> 00:08:41,880
you know we're not Computing on hidden

214
00:08:41,880 --> 00:08:44,039
data in these applications or at least

215
00:08:44,039 --> 00:08:46,260
not recovering it what we are doing is

216
00:08:46,260 --> 00:08:49,740
really exploiting the compactness of the

217
00:08:49,740 --> 00:08:52,200
homomorphic computation and some special

218
00:08:52,200 --> 00:08:54,720
structures of the fhe scheme itself

219
00:08:54,720 --> 00:08:56,940
these are really the essential uh

220
00:08:56,940 --> 00:08:59,700
ingredients of these applications

221
00:08:59,700 --> 00:09:03,300
okay so I hope uh as we go through a few

222
00:09:03,300 --> 00:09:04,680
of these applications

223
00:09:04,680 --> 00:09:06,779
and be able to highlight uh why this

224
00:09:06,779 --> 00:09:08,640
compactness and special structure arise

225
00:09:08,640 --> 00:09:12,240
and why Computing on hidden data is

226
00:09:12,240 --> 00:09:14,399
actually not uh needed in these

227
00:09:14,399 --> 00:09:16,200
applications

228
00:09:16,200 --> 00:09:19,980
okay so uh let's do some backgrounds and

229
00:09:19,980 --> 00:09:22,920
uh what I'll I'll try to well

230
00:09:22,920 --> 00:09:24,779
I thought I would minimize the number of

231
00:09:24,779 --> 00:09:27,420
equations but I failed uh horribly so

232
00:09:27,420 --> 00:09:28,860
there's a number of equations on here

233
00:09:28,860 --> 00:09:31,019
but if there's only one equation that

234
00:09:31,019 --> 00:09:32,220
you take away it should be what I'm

235
00:09:32,220 --> 00:09:33,600
going to call the central equation right

236
00:09:33,600 --> 00:09:34,920
you can ignore all the other equations

237
00:09:34,920 --> 00:09:38,040
if you wish but I do want you to try to

238
00:09:38,040 --> 00:09:39,779
remember the central equation

239
00:09:39,779 --> 00:09:42,240
okay so here's the background that will

240
00:09:42,240 --> 00:09:45,440
lead us to all these nice applications

241
00:09:45,440 --> 00:09:48,480
so it starts with the so-called third

242
00:09:48,480 --> 00:09:51,600
generation fhe scheme uh By Gentry

243
00:09:51,600 --> 00:09:54,660
sahyan Waters from 2013 and it's been

244
00:09:54,660 --> 00:09:56,760
used many many times uh different

245
00:09:56,760 --> 00:09:58,560
properties of it have been extracted out

246
00:09:58,560 --> 00:10:01,560
and variants have been produced and so

247
00:10:01,560 --> 00:10:03,060
what I'm going to show you on this slide

248
00:10:03,060 --> 00:10:06,120
is is not really probably what the

249
00:10:06,120 --> 00:10:08,580
original GSW paper uh would have

250
00:10:08,580 --> 00:10:10,260
highlighted or presented it in that way

251
00:10:10,260 --> 00:10:11,820
but everything I'm showing you is is

252
00:10:11,820 --> 00:10:14,839
implicit uh in some some form inside

253
00:10:14,839 --> 00:10:17,580
gsw13 but we're going to extract it out

254
00:10:17,580 --> 00:10:19,500
more explicitly

255
00:10:19,500 --> 00:10:23,940
so uh here's the main theorem uh for

256
00:10:23,940 --> 00:10:25,860
what I'll call a homomorphic computation

257
00:10:25,860 --> 00:10:27,779
scheme so I don't want to call it

258
00:10:27,779 --> 00:10:31,500
homomorphic encryption because as I say

259
00:10:31,500 --> 00:10:34,260
there does not have to be hidden data uh

260
00:10:34,260 --> 00:10:35,880
involved here right so let's call it

261
00:10:35,880 --> 00:10:38,220
homomorphic computation instead

262
00:10:38,220 --> 00:10:41,040
and here's basically what the theorem

263
00:10:41,040 --> 00:10:45,600
says if you take any Matrix a of a

264
00:10:45,600 --> 00:10:47,519
appropriate size

265
00:10:47,519 --> 00:10:50,220
okay and uh there'll be some color

266
00:10:50,220 --> 00:10:52,320
coding so blue here means that it's like

267
00:10:52,320 --> 00:10:54,360
an arbitrary Matrix think of it as maybe

268
00:10:54,360 --> 00:10:56,579
a random Matrix or a pseudorandom matrix

269
00:10:56,579 --> 00:10:58,680
but it really can be anything

270
00:10:58,680 --> 00:11:00,959
so for any Matrix a and a Boolean

271
00:11:00,959 --> 00:11:03,959
function f we can compute another Matrix

272
00:11:03,959 --> 00:11:05,519
called a sub f

273
00:11:05,519 --> 00:11:08,399
okay so we just uh and pictorially we

274
00:11:08,399 --> 00:11:10,380
have this Matrix a floating out here I

275
00:11:10,380 --> 00:11:12,180
can take F and put it through this

276
00:11:12,180 --> 00:11:15,180
evaluation procedure to get a sub f all

277
00:11:15,180 --> 00:11:16,980
right so you can think of this as sort

278
00:11:16,980 --> 00:11:18,720
of homo this is homomorphically

279
00:11:18,720 --> 00:11:22,500
Computing F uh in mixing together a in

280
00:11:22,500 --> 00:11:23,820
this fashion

281
00:11:23,820 --> 00:11:26,220
okay so after you've done that that's

282
00:11:26,220 --> 00:11:27,899
sort of phase one

283
00:11:27,899 --> 00:11:31,920
phase two is that now uh an input to the

284
00:11:31,920 --> 00:11:35,160
function comes okay so for any input X

285
00:11:35,160 --> 00:11:37,380
to this function f

286
00:11:37,380 --> 00:11:40,500
we can then compute a short Matrix so a

287
00:11:40,500 --> 00:11:43,380
Matrix S which has not uh not two large

288
00:11:43,380 --> 00:11:45,920
entries pretty small entries and could

289
00:11:45,920 --> 00:11:50,040
compute this Matrix S Sub F comma X

290
00:11:50,040 --> 00:11:52,560
right so pictorially we have this uh

291
00:11:52,560 --> 00:11:55,200
second phase I'll call it a Val Prime

292
00:11:55,200 --> 00:11:57,779
it takes in F and x and it's going to

293
00:11:57,779 --> 00:12:01,440
Output S Sub f of x and and also also it

294
00:12:01,440 --> 00:12:04,140
uses a so a can be used by everybody

295
00:12:04,140 --> 00:12:07,380
all right and what's the property so the

296
00:12:07,380 --> 00:12:08,640
property that we get of this short

297
00:12:08,640 --> 00:12:11,399
Matrix and everything in red means short

298
00:12:11,399 --> 00:12:15,060
today right so the property is that if

299
00:12:15,060 --> 00:12:18,720
you shift the original Matrix a by some

300
00:12:18,720 --> 00:12:21,180
robust encoding of X so some way of

301
00:12:21,180 --> 00:12:23,820
mapping X to a matrix of the same size

302
00:12:23,820 --> 00:12:27,480
as a so if you shift a by X and multiply

303
00:12:27,480 --> 00:12:30,360
by this short short Matrix you will get

304
00:12:30,360 --> 00:12:35,820
AF but shifted by the encoding of f x

305
00:12:35,820 --> 00:12:38,300
okay

306
00:12:39,720 --> 00:12:41,940
so we'll let sort of let that sink in

307
00:12:41,940 --> 00:12:43,260
what's going on here

308
00:12:43,260 --> 00:12:45,300
we've computed a single valid a single

309
00:12:45,300 --> 00:12:46,740
Matrix a sub f

310
00:12:46,740 --> 00:12:48,540
to start with

311
00:12:48,540 --> 00:12:51,480
but then I can apply any shift I like or

312
00:12:51,480 --> 00:12:54,060
any any appropriately encoded shift of

313
00:12:54,060 --> 00:12:57,720
to a multiply it by something short

314
00:12:57,720 --> 00:12:59,880
and I'll get the corresponding shift of

315
00:12:59,880 --> 00:13:01,139
AF

316
00:13:01,139 --> 00:13:03,200
here

317
00:13:03,200 --> 00:13:05,700
and by corresponding I mean it's it's

318
00:13:05,700 --> 00:13:08,760
now shifted by f of x so to be encoded

319
00:13:08,760 --> 00:13:11,399
okay this goes for any any X whatsoever

320
00:13:11,399 --> 00:13:14,760
the same a sub F will well the same a

321
00:13:14,760 --> 00:13:17,519
and a sub F will work

322
00:13:17,519 --> 00:13:19,620
so this is the central equation this is

323
00:13:19,620 --> 00:13:21,660
what I want you to remember it will keep

324
00:13:21,660 --> 00:13:24,839
appearing over and over again

325
00:13:24,839 --> 00:13:26,160
um

326
00:13:26,160 --> 00:13:30,060
let us see that uh this okay this uh

327
00:13:30,060 --> 00:13:32,579
Central equation is actually enough to

328
00:13:32,579 --> 00:13:35,880
imply all of the applications uh that

329
00:13:35,880 --> 00:13:37,740
we're going to see and really all the

330
00:13:37,740 --> 00:13:39,060
applications that have emerged since

331
00:13:39,060 --> 00:13:41,160
since GSW

332
00:13:41,160 --> 00:13:44,220
um for example we can actually get

333
00:13:44,220 --> 00:13:46,620
fully homomorphic encryption from this

334
00:13:46,620 --> 00:13:49,320
uh Central equation okay

335
00:13:49,320 --> 00:13:51,839
so here's how you can build fhe

336
00:13:51,839 --> 00:13:54,060
from this

337
00:13:54,060 --> 00:13:55,620
so I have to tell you how to encrypt

338
00:13:55,620 --> 00:13:57,300
right the way I'm going to encrypt a

339
00:13:57,300 --> 00:14:00,899
message is my message will be X and I'm

340
00:14:00,899 --> 00:14:03,000
going to encode it so I kind of put in

341
00:14:03,000 --> 00:14:05,639
this robust encoding and then my

342
00:14:05,639 --> 00:14:08,220
ciphertext will be just B plus encoding

343
00:14:08,220 --> 00:14:09,300
of x

344
00:14:09,300 --> 00:14:12,779
where B is an lwe Matrix but by this I

345
00:14:12,779 --> 00:14:15,060
mean that there's a secret Vector s

346
00:14:15,060 --> 00:14:17,040
where if you multiply it on the left

347
00:14:17,040 --> 00:14:18,660
you'll get something short you'll get

348
00:14:18,660 --> 00:14:20,700
something approximately zero

349
00:14:20,700 --> 00:14:22,139
okay so there's a there's sort of a

350
00:14:22,139 --> 00:14:24,600
hidden uh short Vector here where s

351
00:14:24,600 --> 00:14:27,620
times B is is a short vector

352
00:14:27,620 --> 00:14:32,339
but B looks is pseudorandom uh under the

353
00:14:32,339 --> 00:14:34,740
lwv assumption so this B looks like a

354
00:14:34,740 --> 00:14:37,320
random Matrix and so if I add the

355
00:14:37,320 --> 00:14:40,079
encoding of x to it this A will now just

356
00:14:40,079 --> 00:14:41,639
sort of look like a random Matrix this

357
00:14:41,639 --> 00:14:43,860
hides hides the value of x just by

358
00:14:43,860 --> 00:14:46,320
pseudo randomness

359
00:14:46,320 --> 00:14:49,380
okay so this is my encryption of x

360
00:14:49,380 --> 00:14:51,660
and now uh let's see how I

361
00:14:51,660 --> 00:14:54,959
homomorphically uh compute f

362
00:14:54,959 --> 00:14:57,240
right so what I'm going to do is to

363
00:14:57,240 --> 00:14:59,699
homomorphically compute F I will just do

364
00:14:59,699 --> 00:15:01,380
this evaluation procedure right I'll

365
00:15:01,380 --> 00:15:04,199
take take a and evaluate f on it to get

366
00:15:04,199 --> 00:15:05,639
a sub s

367
00:15:05,639 --> 00:15:08,459
so I've given the ciphertext a I can

368
00:15:08,459 --> 00:15:10,380
compute a sub f

369
00:15:10,380 --> 00:15:11,519
okay

370
00:15:11,519 --> 00:15:14,459
just by applying the eval procedure

371
00:15:14,459 --> 00:15:18,540
so let's look at what a sub F uh is how

372
00:15:18,540 --> 00:15:21,060
how its properties are so if you just

373
00:15:21,060 --> 00:15:22,680
look at this equation up here we notice

374
00:15:22,680 --> 00:15:25,500
that a minus and code X is B just move

375
00:15:25,500 --> 00:15:27,180
things around right so a minus and code

376
00:15:27,180 --> 00:15:31,019
X is B so we know that b times s equals

377
00:15:31,019 --> 00:15:34,380
AF minus encoding of f of x I can move

378
00:15:34,380 --> 00:15:37,079
the encode over to the other side so my

379
00:15:37,079 --> 00:15:38,459
homomorphic evaluation my

380
00:15:38,459 --> 00:15:40,620
homomorphically evaluated ciphertext AF

381
00:15:40,620 --> 00:15:43,860
it's just B times S Plus the encoding of

382
00:15:43,860 --> 00:15:45,240
f of x

383
00:15:45,240 --> 00:15:46,320
okay

384
00:15:46,320 --> 00:15:49,260
so how do I decrypt uh this Cipher text

385
00:15:49,260 --> 00:15:51,480
now so I'd like to be able to decrypt

386
00:15:51,480 --> 00:15:53,760
this and recover f of x

387
00:15:53,760 --> 00:15:56,399
okay well I'm going to use the fact that

388
00:15:56,399 --> 00:15:58,980
this B is a LW e Matrix so I can

389
00:15:58,980 --> 00:16:01,199
multiply on the left by the secret key

390
00:16:01,199 --> 00:16:04,620
and sort of effectively cancel out uh B

391
00:16:04,620 --> 00:16:07,440
I can annihilate B here get to dilate it

392
00:16:07,440 --> 00:16:09,060
perfectly but s times B is something

393
00:16:09,060 --> 00:16:10,079
small

394
00:16:10,079 --> 00:16:13,620
and so here I would have if I decrypt I

395
00:16:13,620 --> 00:16:16,620
just do s times AF that's s times B

396
00:16:16,620 --> 00:16:20,100
times the small Vector the short Matrix

397
00:16:20,100 --> 00:16:24,240
S and then plus s times encode here so s

398
00:16:24,240 --> 00:16:27,120
times B is small and S is small so all

399
00:16:27,120 --> 00:16:30,660
together uh this is smaller it'll it'll

400
00:16:30,660 --> 00:16:34,680
be relatively small and uh s times in

401
00:16:34,680 --> 00:16:37,079
code is such that it's easy to actually

402
00:16:37,079 --> 00:16:40,259
extract uh f of x from from this right

403
00:16:40,259 --> 00:16:43,380
so you can take a special column of this

404
00:16:43,380 --> 00:16:46,740
and actually learn what f of x is

405
00:16:46,740 --> 00:16:50,579
all right so just by uh doing this

406
00:16:50,579 --> 00:16:52,139
homomorphic evaluation and then hitting

407
00:16:52,139 --> 00:16:54,120
it on the left with the secret key I can

408
00:16:54,120 --> 00:16:56,519
annihilate this part and be left with

409
00:16:56,519 --> 00:16:59,040
just this part from which I can get f of

410
00:16:59,040 --> 00:17:00,360
x

411
00:17:00,360 --> 00:17:04,559
okay so this is how uh one gets fhe from

412
00:17:04,559 --> 00:17:07,079
the central equation

413
00:17:07,079 --> 00:17:08,819
um be a good time to take a question now

414
00:17:08,819 --> 00:17:11,459
if there are any uh any clarifications

415
00:17:11,459 --> 00:17:13,880
needed

416
00:17:15,419 --> 00:17:17,959
yes

417
00:17:18,599 --> 00:17:20,520
uh short Matrix just means it has like

418
00:17:20,520 --> 00:17:23,459
relatively small entries uh compared to

419
00:17:23,459 --> 00:17:27,119
like the entries of a so for those who

420
00:17:27,119 --> 00:17:30,120
know uh The Matrix a will be like random

421
00:17:30,120 --> 00:17:32,940
values mod q and Q will be you know

422
00:17:32,940 --> 00:17:35,220
moderately large and the entries of s

423
00:17:35,220 --> 00:17:37,740
will be much smaller than Q right so

424
00:17:37,740 --> 00:17:40,380
that if if you want more concreteness

425
00:17:40,380 --> 00:17:41,880
then you know this the things then that

426
00:17:41,880 --> 00:17:44,960
that should be in your mind

427
00:17:45,120 --> 00:17:48,979
all right uh good question yes any other

428
00:17:49,200 --> 00:17:51,419
yeah little s is the secret key of the

429
00:17:51,419 --> 00:17:53,280
of the uh which allows you to decrypt

430
00:17:53,280 --> 00:17:55,760
that's right

431
00:17:56,220 --> 00:17:59,700
yes good okay so this is how we can get

432
00:17:59,700 --> 00:18:03,720
uh the original GSW from the central

433
00:18:03,720 --> 00:18:07,380
equation just by setting up a properly

434
00:18:07,380 --> 00:18:11,340
and uh AF you know saying what AF is and

435
00:18:11,340 --> 00:18:13,980
then this shows us how to decrypt

436
00:18:13,980 --> 00:18:16,200
okay good so that's homomorphic

437
00:18:16,200 --> 00:18:17,220
computation

438
00:18:17,220 --> 00:18:20,400
uh and the central equation and let me

439
00:18:20,400 --> 00:18:21,960
just show you briefly if you're

440
00:18:21,960 --> 00:18:24,059
interested uh how this can actually be

441
00:18:24,059 --> 00:18:25,679
achieved so we can I can show you the

442
00:18:25,679 --> 00:18:28,320
internals how this is achieved uh it

443
00:18:28,320 --> 00:18:30,720
turns out not to be terribly complicated

444
00:18:30,720 --> 00:18:33,059
uh but it's very clever

445
00:18:33,059 --> 00:18:34,559
um and if you don't care you can kind of

446
00:18:34,559 --> 00:18:35,880
check out for a minute and I'll call you

447
00:18:35,880 --> 00:18:38,160
back uh when you're ready all right so

448
00:18:38,160 --> 00:18:40,440
how does this work internally the

449
00:18:40,440 --> 00:18:43,559
encoding uh operation is going to just

450
00:18:43,559 --> 00:18:47,100
take each bit of X and multiply it by a

451
00:18:47,100 --> 00:18:49,140
special Matrix g i call this the gadget

452
00:18:49,140 --> 00:18:52,559
Matrix G so we're just going to have uh

453
00:18:52,559 --> 00:18:55,320
you know X1 times G X2 times G X3 times

454
00:18:55,320 --> 00:18:58,320
G and so forth for each bit of x

455
00:18:58,320 --> 00:19:01,559
and the nice property of this G is that

456
00:19:01,559 --> 00:19:03,240
there's an operation called G inverse

457
00:19:03,240 --> 00:19:05,100
you can apply it to any Matrix you like

458
00:19:05,100 --> 00:19:07,679
and it will give you a short uh Matrix

459
00:19:07,679 --> 00:19:09,660
in a result

460
00:19:09,660 --> 00:19:12,240
and it's also G inverse is is well named

461
00:19:12,240 --> 00:19:14,340
if you multiply G times G inverse of Z

462
00:19:14,340 --> 00:19:17,160
you will get back the original Z

463
00:19:17,160 --> 00:19:19,919
okay so this holds for any Matrix Z

464
00:19:19,919 --> 00:19:22,440
and the color coding again G inverse

465
00:19:22,440 --> 00:19:25,740
represents that it's a short output

466
00:19:25,740 --> 00:19:28,020
Okay so

467
00:19:28,020 --> 00:19:30,960
we can use composition it's enough to

468
00:19:30,960 --> 00:19:33,120
just handle the basic uh addition and

469
00:19:33,120 --> 00:19:34,980
multiplication and negation operations

470
00:19:34,980 --> 00:19:36,780
and from that you can kind of build any

471
00:19:36,780 --> 00:19:39,240
circuit that you like so let's see how

472
00:19:39,240 --> 00:19:41,880
to handle negation negation is very easy

473
00:19:41,880 --> 00:19:43,799
so

474
00:19:43,799 --> 00:19:47,100
my function f is just negation that's

475
00:19:47,100 --> 00:19:49,740
what I want to show how to do right

476
00:19:49,740 --> 00:19:52,679
so this is easy I just Define my shorts

477
00:19:52,679 --> 00:19:55,440
uh s Matrix to be the negative identity

478
00:19:55,440 --> 00:20:00,419
Matrix and I'll Define a subneg right uh

479
00:20:00,419 --> 00:20:03,179
over here so f is the negation operation

480
00:20:03,179 --> 00:20:06,080
so a sub neg will just be negative a

481
00:20:06,080 --> 00:20:08,820
and it's very easy to verify that this

482
00:20:08,820 --> 00:20:12,539
equation holds uh just you know minus

483
00:20:12,539 --> 00:20:15,299
and code of f is the same as uh and code

484
00:20:15,299 --> 00:20:19,320
of negative f which is the identity

485
00:20:19,320 --> 00:20:20,760
function

486
00:20:20,760 --> 00:20:24,419
okay so easy to check that addition is

487
00:20:24,419 --> 00:20:27,900
almost as easy to uh to see so in this

488
00:20:27,900 --> 00:20:29,700
case we're going to have uh like two

489
00:20:29,700 --> 00:20:33,299
bits X1 and X2 and our Matrix a then has

490
00:20:33,299 --> 00:20:35,940
two blocks to it A1 and A2

491
00:20:35,940 --> 00:20:39,419
and I'm just going to define a plus so

492
00:20:39,419 --> 00:20:41,880
if I'm doing addition a sub f is a plus

493
00:20:41,880 --> 00:20:45,360
so a plus is just A1 Plus A2 it's the

494
00:20:45,360 --> 00:20:47,940
two halves added up together

495
00:20:47,940 --> 00:20:51,780
and so the S Plus is going to be two

496
00:20:51,780 --> 00:20:53,820
identity Matrix identity matrices

497
00:20:53,820 --> 00:20:56,220
stacked on top of each other

498
00:20:56,220 --> 00:20:57,780
so we can verify that this equation

499
00:20:57,780 --> 00:20:59,700
holds we just plug things in so this is

500
00:20:59,700 --> 00:21:04,039
a minus in code of X1 X2 times S Plus

501
00:21:04,039 --> 00:21:07,980
and well this times S Plus just adds up

502
00:21:07,980 --> 00:21:10,559
the two halves so you get A1 Plus A2

503
00:21:10,559 --> 00:21:12,900
that's a that's a plus and then this

504
00:21:12,900 --> 00:21:14,940
also adds adds up the two halves here so

505
00:21:14,940 --> 00:21:17,520
you get X1 plus X2 times G that's uh

506
00:21:17,520 --> 00:21:19,620
shifted it's the shift

507
00:21:19,620 --> 00:21:21,720
okay so again very easy to verify

508
00:21:21,720 --> 00:21:22,740
Edition

509
00:21:22,740 --> 00:21:26,940
uh multiplication is uh more clever it

510
00:21:26,940 --> 00:21:29,159
uh it works out again and we can show it

511
00:21:29,159 --> 00:21:31,440
in two lines uh but coming up with these

512
00:21:31,440 --> 00:21:33,419
two lines is very not obvious

513
00:21:33,419 --> 00:21:36,240
so the idea here is that uh we're going

514
00:21:36,240 --> 00:21:40,320
to define a times as the first half A1

515
00:21:40,320 --> 00:21:44,340
times G inverse of the second half A2

516
00:21:44,340 --> 00:21:45,720
and

517
00:21:45,720 --> 00:21:46,500
um

518
00:21:46,500 --> 00:21:49,559
so that's what appears here on the right

519
00:21:49,559 --> 00:21:51,960
and I just need to find an appropriate s

520
00:21:51,960 --> 00:21:55,200
Matrix that will make this equation hold

521
00:21:55,200 --> 00:21:57,539
and it turns out if you just take G

522
00:21:57,539 --> 00:22:00,659
inverse of A2 on top of X1 times

523
00:22:00,659 --> 00:22:05,480
identity this whole equation will hold

524
00:22:05,700 --> 00:22:07,260
um let me just give you some guidance on

525
00:22:07,260 --> 00:22:10,140
that so A1 times the top half here is

526
00:22:10,140 --> 00:22:13,320
just A1 G inverse A2 and that's exactly

527
00:22:13,320 --> 00:22:15,960
this part here so that's showing up as

528
00:22:15,960 --> 00:22:19,320
desired but then we also have a 2 times

529
00:22:19,320 --> 00:22:21,600
the bottom part so that's this

530
00:22:21,600 --> 00:22:24,240
multiplies out to X1 times A2

531
00:22:24,240 --> 00:22:27,419
right and the clever part is that X1 G

532
00:22:27,419 --> 00:22:31,320
times this up here cancels out exactly

533
00:22:31,320 --> 00:22:33,840
right so X1 times G times G inverse of

534
00:22:33,840 --> 00:22:36,840
A2 is just X1 times A2 and that's

535
00:22:36,840 --> 00:22:39,179
subtracted off so it cancels away and

536
00:22:39,179 --> 00:22:40,500
then we finally take this last part

537
00:22:40,500 --> 00:22:43,559
times the bottom and that's X to G times

538
00:22:43,559 --> 00:22:46,980
X1 identity that's X1 X2 G so that's

539
00:22:46,980 --> 00:22:49,320
what gets subtracted off so somehow

540
00:22:49,320 --> 00:22:51,539
these cross terms cancel out and you're

541
00:22:51,539 --> 00:22:54,059
left with exactly what you want on the

542
00:22:54,059 --> 00:22:55,280
right hand side

543
00:22:55,280 --> 00:23:00,179
so by uh setting up the uh the the short

544
00:23:00,179 --> 00:23:03,000
Matrix in this form uh you get the

545
00:23:03,000 --> 00:23:05,580
central equation to hold and now you can

546
00:23:05,580 --> 00:23:07,020
compose additions and multiplications

547
00:23:07,020 --> 00:23:09,299
and negations as much as you like

548
00:23:09,299 --> 00:23:10,260
okay

549
00:23:10,260 --> 00:23:12,900
great so all right if you didn't uh

550
00:23:12,900 --> 00:23:15,120
follow that that's fine but uh just

551
00:23:15,120 --> 00:23:17,039
remember the central equation

552
00:23:17,039 --> 00:23:19,559
and so now let's go and see our first uh

553
00:23:19,559 --> 00:23:22,260
and by first I mean last uh application

554
00:23:22,260 --> 00:23:24,539
or most recent application which are

555
00:23:24,539 --> 00:23:26,159
functional commitments

556
00:23:26,159 --> 00:23:28,200
so functional commitments were proposed

557
00:23:28,200 --> 00:23:32,700
by uh Liber and Jung in in 2016.

558
00:23:32,700 --> 00:23:36,059
and their idea was as follows we'd like

559
00:23:36,059 --> 00:23:39,000
to uh commit to a function so we'd like

560
00:23:39,000 --> 00:23:40,919
to be able to commit to a function maybe

561
00:23:40,919 --> 00:23:42,659
an arbitrary function or functions from

562
00:23:42,659 --> 00:23:44,700
some specific class

563
00:23:44,700 --> 00:23:46,380
and so it looked like this you know

564
00:23:46,380 --> 00:23:48,059
maybe there's some public parameter in

565
00:23:48,059 --> 00:23:50,280
the sky and you run a commit procedure

566
00:23:50,280 --> 00:23:54,059
on F and you get some commitment C sub f

567
00:23:54,059 --> 00:23:56,280
later on you'd like to open up that

568
00:23:56,280 --> 00:23:57,720
commitment but you don't want to open

569
00:23:57,720 --> 00:24:00,539
the entire function you just want to say

570
00:24:00,539 --> 00:24:03,240
the function I committed to at X

571
00:24:03,240 --> 00:24:05,820
evaluates to Y so you'd like to open up

572
00:24:05,820 --> 00:24:08,460
this function at specific inputs

573
00:24:08,460 --> 00:24:11,760
so later on some value you know X comes

574
00:24:11,760 --> 00:24:13,799
along and you'd like to open up your

575
00:24:13,799 --> 00:24:16,020
commitment and generate a proof that

576
00:24:16,020 --> 00:24:18,659
indeed uh the the function I committed

577
00:24:18,659 --> 00:24:21,360
to evaluates that X to some other value

578
00:24:21,360 --> 00:24:22,380
y

579
00:24:22,380 --> 00:24:23,280
okay

580
00:24:23,280 --> 00:24:26,159
and to make this non-trivial we would

581
00:24:26,159 --> 00:24:28,020
like both the commitment and the proofs

582
00:24:28,020 --> 00:24:30,360
to be much smaller than the size of the

583
00:24:30,360 --> 00:24:32,039
function itself because one way to

584
00:24:32,039 --> 00:24:33,659
commit to the function is just reveal

585
00:24:33,659 --> 00:24:35,840
the function and then the way to prove

586
00:24:35,840 --> 00:24:38,640
uh that the function evaluates you know

587
00:24:38,640 --> 00:24:41,220
to this at this x point is just say all

588
00:24:41,220 --> 00:24:43,500
right verifier do it yourself right

589
00:24:43,500 --> 00:24:45,480
so we'd like to we'd like both of these

590
00:24:45,480 --> 00:24:47,880
things to be much smaller than f

591
00:24:47,880 --> 00:24:49,740
um but still be convincing to a

592
00:24:49,740 --> 00:24:51,120
skeptical verifier

593
00:24:51,120 --> 00:24:54,000
okay so let's introduce the verifier

594
00:24:54,000 --> 00:24:56,159
right the verifier should be able to

595
00:24:56,159 --> 00:24:58,679
take in a previously given commitment

596
00:24:58,679 --> 00:25:02,220
and some proof or acclaimed proof that f

597
00:25:02,220 --> 00:25:05,520
x equals y and either accept it or

598
00:25:05,520 --> 00:25:07,500
reject it

599
00:25:07,500 --> 00:25:10,799
so I'd like to uh

600
00:25:10,799 --> 00:25:14,280
like to be convinced that this um

601
00:25:14,280 --> 00:25:16,080
that this commitment is being opened

602
00:25:16,080 --> 00:25:18,960
honestly or not

603
00:25:18,960 --> 00:25:21,720
okay so this is the the this kind of

604
00:25:21,720 --> 00:25:23,220
general definition of a functional

605
00:25:23,220 --> 00:25:25,740
commitment and it's got tons and tons of

606
00:25:25,740 --> 00:25:27,120
applications

607
00:25:27,120 --> 00:25:29,159
so first of all there are a lot of

608
00:25:29,159 --> 00:25:31,799
specializations that even precede this

609
00:25:31,799 --> 00:25:33,360
General notion of functional commitments

610
00:25:33,360 --> 00:25:35,580
uh things like vector commitments or

611
00:25:35,580 --> 00:25:37,020
polynomial commitments or linear

612
00:25:37,020 --> 00:25:40,320
commitments uh are all special cases of

613
00:25:40,320 --> 00:25:41,940
this

614
00:25:41,940 --> 00:25:44,520
um and you can use these ideas this this

615
00:25:44,520 --> 00:25:48,419
kind of uh structure to do all kinds of

616
00:25:48,419 --> 00:25:51,059
like verifiable outsourced data storage

617
00:25:51,059 --> 00:25:53,580
or Outsource databases or data

618
00:25:53,580 --> 00:25:55,740
structures you can do things like

619
00:25:55,740 --> 00:25:58,380
accumulators or updatable zero knowledge

620
00:25:58,380 --> 00:26:01,260
sets uh Outsource committed programs

621
00:26:01,260 --> 00:26:04,020
which is a paper appearing later in this

622
00:26:04,020 --> 00:26:06,600
program so you commit to a program and

623
00:26:06,600 --> 00:26:09,179
then later you can prove that you're you

624
00:26:09,179 --> 00:26:10,620
know you've applied you've evaluated

625
00:26:10,620 --> 00:26:12,299
this program correctly or even someone

626
00:26:12,299 --> 00:26:14,039
else can prove that they've evaluated

627
00:26:14,039 --> 00:26:15,539
the program correctly

628
00:26:15,539 --> 00:26:17,880
so there's lots and lots of applications

629
00:26:17,880 --> 00:26:19,740
of this all having to do with sort of

630
00:26:19,740 --> 00:26:22,940
authenticated computation

631
00:26:23,640 --> 00:26:25,200
um so let's talk about a couple of the

632
00:26:25,200 --> 00:26:27,000
most basic security properties there are

633
00:26:27,000 --> 00:26:28,080
a lot of different security properties

634
00:26:28,080 --> 00:26:30,779
that you might ask for for these these

635
00:26:30,779 --> 00:26:32,580
functional commitments uh we'll talk

636
00:26:32,580 --> 00:26:35,279
about just some of the most basic ones

637
00:26:35,279 --> 00:26:37,440
that you could ask

638
00:26:37,440 --> 00:26:39,840
so the first one is called evaluation

639
00:26:39,840 --> 00:26:40,980
binding

640
00:26:40,980 --> 00:26:43,020
and it says basically that it should be

641
00:26:43,020 --> 00:26:45,539
impossible to open a commitment in two

642
00:26:45,539 --> 00:26:47,760
different ways at the same input right

643
00:26:47,760 --> 00:26:49,440
so that it's really committing to a

644
00:26:49,440 --> 00:26:51,059
function and there's no way to

645
00:26:51,059 --> 00:26:54,059
equivocate uh the how the function

646
00:26:54,059 --> 00:26:57,059
evaluates at a certain uh input right so

647
00:26:57,059 --> 00:26:59,640
we say we allow the adversary to come up

648
00:26:59,640 --> 00:27:02,760
with a perhaps malicious commitment and

649
00:27:02,760 --> 00:27:05,700
a input value of its choice to different

650
00:27:05,700 --> 00:27:08,700
outputs it shouldn't be able to prove or

651
00:27:08,700 --> 00:27:09,960
shouldn't be able to convince the

652
00:27:09,960 --> 00:27:13,140
verifier that f of x equals y 0 but it

653
00:27:13,140 --> 00:27:15,720
also equals y1 right that would be a

654
00:27:15,720 --> 00:27:17,400
violation

655
00:27:17,400 --> 00:27:19,080
uh the thing I want to highlight here is

656
00:27:19,080 --> 00:27:20,880
that there's no hiding required in any

657
00:27:20,880 --> 00:27:23,760
of this so all this information is uh

658
00:27:23,760 --> 00:27:25,320
presumably public like the function

659
00:27:25,320 --> 00:27:27,480
itself could be public the values X and

660
00:27:27,480 --> 00:27:31,440
Y or public right what we are uh only

661
00:27:31,440 --> 00:27:34,320
asking for is that you can't convince

662
00:27:34,320 --> 00:27:36,299
the verifier that the function is this

663
00:27:36,299 --> 00:27:39,320
thing but also that thing

664
00:27:39,720 --> 00:27:41,340
um a more relaxed version would be

665
00:27:41,340 --> 00:27:43,740
Target binding where we ask for this

666
00:27:43,740 --> 00:27:45,240
property but only for an honestly

667
00:27:45,240 --> 00:27:47,520
generated uh commitment right so someone

668
00:27:47,520 --> 00:27:50,400
honestly commits to F but then someone

669
00:27:50,400 --> 00:27:52,260
else tries to open it in two different

670
00:27:52,260 --> 00:27:55,080
ways at uh some value X

671
00:27:55,080 --> 00:27:57,840
okay and then uh if you did want some

672
00:27:57,840 --> 00:28:00,120
kind of hiding you could ask for zero

673
00:28:00,120 --> 00:28:02,640
knowledge which would say that the

674
00:28:02,640 --> 00:28:04,980
commitment and the proofs don't reveal

675
00:28:04,980 --> 00:28:07,980
anything uh to the verifier except for

676
00:28:07,980 --> 00:28:10,200
the input output pairs that have been

677
00:28:10,200 --> 00:28:13,020
proven right so the function remains

678
00:28:13,020 --> 00:28:15,480
hidden except at the input outputs that

679
00:28:15,480 --> 00:28:17,700
are provided

680
00:28:17,700 --> 00:28:19,919
okay so these are some of the security

681
00:28:19,919 --> 00:28:21,840
proof properties that can be considered

682
00:28:21,840 --> 00:28:23,580
you can also think of much stronger ones

683
00:28:23,580 --> 00:28:25,980
uh I don't mention them because we don't

684
00:28:25,980 --> 00:28:28,320
get them at least not yet so that's an

685
00:28:28,320 --> 00:28:30,659
open problem

686
00:28:30,659 --> 00:28:34,320
okay so what could we do uh what could

687
00:28:34,320 --> 00:28:35,700
how could we construct these functional

688
00:28:35,700 --> 00:28:37,020
commitments

689
00:28:37,020 --> 00:28:38,820
um and so recently all the functional

690
00:28:38,820 --> 00:28:41,460
commitment constructions were limited to

691
00:28:41,460 --> 00:28:43,980
uh what we call linearizable functions

692
00:28:43,980 --> 00:28:45,480
so these functions are essentially

693
00:28:45,480 --> 00:28:48,900
linear uh in X or at least some

694
00:28:48,900 --> 00:28:50,760
pre-processed version of x

695
00:28:50,760 --> 00:28:52,919
okay so you could sort of pre-process X

696
00:28:52,919 --> 00:28:55,440
maybe expand it out uh do some

697
00:28:55,440 --> 00:28:57,059
pre-processing but then the function has

698
00:28:57,059 --> 00:28:58,919
to be linear in the pre-processed

699
00:28:58,919 --> 00:29:00,240
version of x

700
00:29:00,240 --> 00:29:02,940
alternatively if you rely on a strong

701
00:29:02,940 --> 00:29:05,279
non-falcifiable assumptions you can get

702
00:29:05,279 --> 00:29:07,440
functional commitments generically uh

703
00:29:07,440 --> 00:29:09,659
like if you have assumed snargs for NP

704
00:29:09,659 --> 00:29:12,059
then you can get functional commitments

705
00:29:12,059 --> 00:29:14,159
uh very easily but that's a very strong

706
00:29:14,159 --> 00:29:16,740
assumption

707
00:29:16,740 --> 00:29:21,059
so then recently we we uh with uh my two

708
00:29:21,059 --> 00:29:22,799
students showed that you can actually

709
00:29:22,799 --> 00:29:23,700
get

710
00:29:23,700 --> 00:29:25,640
functional commitments for all functions

711
00:29:25,640 --> 00:29:30,059
from the standard sis lattice assumption

712
00:29:30,059 --> 00:29:32,520
uh but there was one big caveat here

713
00:29:32,520 --> 00:29:33,840
which is that you need an online

714
00:29:33,840 --> 00:29:36,779
authority to help you generate these

715
00:29:36,779 --> 00:29:38,220
proofs here

716
00:29:38,220 --> 00:29:41,100
so you need somebody online who's

717
00:29:41,100 --> 00:29:42,960
available and say oh when I want to

718
00:29:42,960 --> 00:29:45,960
produce a proof for X I have to go to

719
00:29:45,960 --> 00:29:47,940
the authority and get some help to

720
00:29:47,940 --> 00:29:49,559
produce a proof for x

721
00:29:49,559 --> 00:29:52,080
uh and that Authority holds a trapdoor

722
00:29:52,080 --> 00:29:54,000
for the public parameters and the

723
00:29:54,000 --> 00:29:55,919
authority could can break binding and

724
00:29:55,919 --> 00:29:58,140
and break all the security of the scheme

725
00:29:58,140 --> 00:30:00,899
so it's a pretty strong model

726
00:30:00,899 --> 00:30:03,539
uh but then it worked with Leo de Castro

727
00:30:03,539 --> 00:30:05,940
this year we've we got rid of this

728
00:30:05,940 --> 00:30:08,039
Authority and we showed how to get

729
00:30:08,039 --> 00:30:09,899
functional commitments for all functions

730
00:30:09,899 --> 00:30:12,779
still from sis but with a transparent

731
00:30:12,779 --> 00:30:16,620
setup so the public parameters is just a

732
00:30:16,620 --> 00:30:19,860
uniformly random unstructured string it

733
00:30:19,860 --> 00:30:22,260
has no trapdoor in it nobody knows any

734
00:30:22,260 --> 00:30:24,360
you know Secrets related to the trapdoor

735
00:30:24,360 --> 00:30:26,700
so it's about the weakest setup you

736
00:30:26,700 --> 00:30:28,020
could hope for

737
00:30:28,020 --> 00:30:30,740
um and we can get

738
00:30:31,260 --> 00:30:32,899
they require

739
00:30:32,899 --> 00:30:36,539
criminal of that is further than the

740
00:30:36,539 --> 00:30:40,679
size of that yes so that means

741
00:30:40,679 --> 00:30:44,600
difference app and this is

742
00:30:44,600 --> 00:30:47,340
that's true yes so there could be in

743
00:30:47,340 --> 00:30:48,600
principle there could be two different

744
00:30:48,600 --> 00:30:51,480
F's that result in the same uh

745
00:30:51,480 --> 00:30:54,059
commitment here but it would be it's a

746
00:30:54,059 --> 00:30:56,039
consequence of the security properties

747
00:30:56,039 --> 00:30:58,740
is that it's infeasible to find any two

748
00:30:58,740 --> 00:31:00,679
different functions that Collide yeah

749
00:31:00,679 --> 00:31:04,940
yeah that's a good good observation

750
00:31:05,460 --> 00:31:09,360
great so uh what we'll show you here is

751
00:31:09,360 --> 00:31:12,240
how to get uh functional commitments

752
00:31:12,240 --> 00:31:14,700
using the background and the central

753
00:31:14,700 --> 00:31:15,960
equation

754
00:31:15,960 --> 00:31:18,659
that uh that I showed you before

755
00:31:18,659 --> 00:31:21,720
okay so again here is the sort of data

756
00:31:21,720 --> 00:31:22,919
flow of how we want functional

757
00:31:22,919 --> 00:31:24,419
commitments to work

758
00:31:24,419 --> 00:31:26,760
and uh if you were you're paying very

759
00:31:26,760 --> 00:31:28,620
close attention uh part of this picture

760
00:31:28,620 --> 00:31:31,799
should look pretty familiar uh any uh

761
00:31:31,799 --> 00:31:34,380
any observations which part of this

762
00:31:34,380 --> 00:31:37,760
picture looks looks familiar

763
00:31:38,659 --> 00:31:40,679
Sasha saw it

764
00:31:40,679 --> 00:31:42,299
all right

765
00:31:42,299 --> 00:31:44,940
so this left-hand side here

766
00:31:44,940 --> 00:31:47,760
should look familiar okay it's exactly

767
00:31:47,760 --> 00:31:49,919
uh what we showed before with the

768
00:31:49,919 --> 00:31:52,860
homomorphic uh computation scheme okay

769
00:31:52,860 --> 00:31:55,200
so before we said okay you've got a

770
00:31:55,200 --> 00:31:57,419
matrix a and you've got the Savannah

771
00:31:57,419 --> 00:32:00,000
procedure which takes F to a sub F and

772
00:32:00,000 --> 00:32:01,559
then you've got this opening or eval

773
00:32:01,559 --> 00:32:03,840
Prime procedure which takes both F and x

774
00:32:03,840 --> 00:32:06,779
and gives you this short Matrix S

775
00:32:06,779 --> 00:32:09,860
so in fact these two things are actually

776
00:32:09,860 --> 00:32:11,580
the same

777
00:32:11,580 --> 00:32:14,880
okay just up to naming variables

778
00:32:14,880 --> 00:32:17,640
so these two structures are the same and

779
00:32:17,640 --> 00:32:20,940
and we can take this and just use it as

780
00:32:20,940 --> 00:32:23,820
the left hand half of a functional

781
00:32:23,820 --> 00:32:26,220
commitment scheme and it will work it

782
00:32:26,220 --> 00:32:27,779
actually works

783
00:32:27,779 --> 00:32:30,360
so by work what do I mean well I have to

784
00:32:30,360 --> 00:32:33,000
tell you how the the verifier works

785
00:32:33,000 --> 00:32:35,340
right so uh any ideas how the

786
00:32:35,340 --> 00:32:37,620
verification might uh might work what

787
00:32:37,620 --> 00:32:39,120
should we be checking uh in the

788
00:32:39,120 --> 00:32:41,240
verification right

789
00:32:41,240 --> 00:32:43,440
go ahead

790
00:32:43,440 --> 00:32:45,600
let's use the central equation right so

791
00:32:45,600 --> 00:32:47,460
the verifier is just check the central

792
00:32:47,460 --> 00:32:51,059
equation okay so good when I want to

793
00:32:51,059 --> 00:32:54,179
commit I I my a is my public parameter I

794
00:32:54,179 --> 00:32:56,340
commit to F by running a vowel when I

795
00:32:56,340 --> 00:32:59,340
want to open F at a certain value X I

796
00:32:59,340 --> 00:33:02,340
run of L Prime and I get this S as my

797
00:33:02,340 --> 00:33:05,039
proof right and the verifier should be

798
00:33:05,039 --> 00:33:07,080
just checking the central equation so it

799
00:33:07,080 --> 00:33:08,220
should say oh

800
00:33:08,220 --> 00:33:11,880
you you claim that uh this commitment a

801
00:33:11,880 --> 00:33:12,840
star

802
00:33:12,840 --> 00:33:15,539
uh you know commits to a function where

803
00:33:15,539 --> 00:33:18,899
X star maps to Y star all right and

804
00:33:18,899 --> 00:33:20,640
here's your proof let's let's check that

805
00:33:20,640 --> 00:33:22,559
this holds

806
00:33:22,559 --> 00:33:24,600
so I'm gonna actually I should check two

807
00:33:24,600 --> 00:33:26,940
things I should check that s is uh

808
00:33:26,940 --> 00:33:29,100
sufficiently short and then I check that

809
00:33:29,100 --> 00:33:31,260
this linear equation holds okay

810
00:33:31,260 --> 00:33:33,140
so it's a simple linear equation check

811
00:33:33,140 --> 00:33:36,240
uh and also a norm check uh on how big

812
00:33:36,240 --> 00:33:38,460
how big s is

813
00:33:38,460 --> 00:33:41,460
and uh with this we can show that this

814
00:33:41,460 --> 00:33:43,980
actually is a binding uh commitment

815
00:33:43,980 --> 00:33:46,260
scheme okay so it's actually secure I

816
00:33:46,260 --> 00:33:48,419
mean it's complete obviously it's it's

817
00:33:48,419 --> 00:33:51,659
correct right this equation will hold uh

818
00:33:51,659 --> 00:33:55,019
more interestingly it's it's uh secure

819
00:33:55,019 --> 00:33:56,640
so we can show that this is evaluation

820
00:33:56,640 --> 00:34:00,179
binding uh under the sis assumption

821
00:34:00,179 --> 00:34:02,760
so let's suppose uh for contradiction

822
00:34:02,760 --> 00:34:05,340
that we had an attacker that was able to

823
00:34:05,340 --> 00:34:07,559
break evaluation binding right what does

824
00:34:07,559 --> 00:34:09,659
it mean it means the attacker comes up

825
00:34:09,659 --> 00:34:11,760
with some commitment a star

826
00:34:11,760 --> 00:34:14,580
and some value X star and two different

827
00:34:14,580 --> 00:34:16,859
outputs y Star right y zero star and Y

828
00:34:16,859 --> 00:34:18,000
one star

829
00:34:18,000 --> 00:34:21,418
where this equation holds for both uh

830
00:34:21,418 --> 00:34:24,060
with both y zero and Y one star in this

831
00:34:24,060 --> 00:34:26,879
position here so the equation both

832
00:34:26,879 --> 00:34:28,800
equations hold right just with y 0 and

833
00:34:28,800 --> 00:34:30,780
y1 here and we can just take their

834
00:34:30,780 --> 00:34:31,739
difference

835
00:34:31,739 --> 00:34:34,980
so if we take the difference then we

836
00:34:34,980 --> 00:34:36,239
notice that this

837
00:34:36,239 --> 00:34:39,000
here Remains the Same this is proof

838
00:34:39,000 --> 00:34:41,099
proof zero and proof one so we get the

839
00:34:41,099 --> 00:34:43,619
difference of s0 and S1 star

840
00:34:43,619 --> 00:34:46,159
and then uh by the linearity of encode

841
00:34:46,159 --> 00:34:49,080
uh kind of the difference between y 0

842
00:34:49,080 --> 00:34:53,280
and y1 goes inside uh the encode here

843
00:34:53,280 --> 00:34:55,139
so give them these two different valid

844
00:34:55,139 --> 00:34:57,359
proofs or acceptable proofs we take the

845
00:34:57,359 --> 00:34:58,980
difference of everything and we end up

846
00:34:58,980 --> 00:35:01,440
with this equation here

847
00:35:01,440 --> 00:35:04,740
and uh now we're kind of done

848
00:35:04,740 --> 00:35:08,220
what we've got now is that uh we've got

849
00:35:08,220 --> 00:35:11,099
like this Matrix here times something

850
00:35:11,099 --> 00:35:14,640
short uh equals encoding of a non-zero

851
00:35:14,640 --> 00:35:16,560
value right because y0 and y1 are

852
00:35:16,560 --> 00:35:17,280
different

853
00:35:17,280 --> 00:35:20,160
so in fact uh by the properties of this

854
00:35:20,160 --> 00:35:21,839
encoding there's a there's a short

855
00:35:21,839 --> 00:35:23,880
non-zero column over here this is a big

856
00:35:23,880 --> 00:35:25,859
Matrix we can just look at one of the

857
00:35:25,859 --> 00:35:29,579
columns and so basically we have uh like

858
00:35:29,579 --> 00:35:33,180
a random Matrix here times a short uh

859
00:35:33,180 --> 00:35:35,099
something short equals something short

860
00:35:35,099 --> 00:35:38,460
this is exactly solving the sis lattice

861
00:35:38,460 --> 00:35:39,180
problem

862
00:35:39,180 --> 00:35:42,359
okay all right uh and Anna goes I'm not

863
00:35:42,359 --> 00:35:44,940
sure because of this uh a minus and code

864
00:35:44,940 --> 00:35:47,280
X star here right exactly so what we

865
00:35:47,280 --> 00:35:50,040
need to do is we kind of Pop uh program

866
00:35:50,040 --> 00:35:53,040
the public parameters so that we can

867
00:35:53,040 --> 00:35:55,020
either guess x-star in the beginning or

868
00:35:55,020 --> 00:35:57,599
ask the adversary to give it to us and

869
00:35:57,599 --> 00:36:00,240
uh therefore this Matrix would be equal

870
00:36:00,240 --> 00:36:03,180
to our sis challenge Okay so we've

871
00:36:03,180 --> 00:36:05,700
basically said okay I can I have an

872
00:36:05,700 --> 00:36:07,800
equation sis challenge Times short

873
00:36:07,800 --> 00:36:11,160
equals short over here on the right

874
00:36:11,160 --> 00:36:13,859
so that's the the two or three line uh

875
00:36:13,859 --> 00:36:16,260
short version of the proof

876
00:36:16,260 --> 00:36:19,320
so this gives you evaluation binding uh

877
00:36:19,320 --> 00:36:20,940
just straight out from the central

878
00:36:20,940 --> 00:36:22,500
equation

879
00:36:22,500 --> 00:36:23,940
great

880
00:36:23,940 --> 00:36:25,619
um good time for a question if there is

881
00:36:25,619 --> 00:36:27,800
one

882
00:36:30,960 --> 00:36:33,619
oh yes

883
00:36:37,680 --> 00:36:39,599
yeah okay so the question is is there a

884
00:36:39,599 --> 00:36:41,400
black box to a black box way to

885
00:36:41,400 --> 00:36:42,900
construct functional commitments from

886
00:36:42,900 --> 00:36:46,260
fhe uh not that I'm aware of right so

887
00:36:46,260 --> 00:36:48,359
we're actually using something more

888
00:36:48,359 --> 00:36:51,300
about uh this particular fhe scheme and

889
00:36:51,300 --> 00:36:54,180
and in fact the homomorphic computation

890
00:36:54,180 --> 00:36:55,859
scheme right that could have extracting

891
00:36:55,859 --> 00:36:57,900
out some special properties of it uh

892
00:36:57,900 --> 00:37:00,780
yeah exactly so and that's a theme of

893
00:37:00,780 --> 00:37:02,940
all the applications that I'll mention

894
00:37:02,940 --> 00:37:05,220
today

895
00:37:05,220 --> 00:37:08,720
okay great yes

896
00:37:10,440 --> 00:37:11,760
yes

897
00:37:11,760 --> 00:37:13,200
yeah that's right so from the central

898
00:37:13,200 --> 00:37:15,420
equation everything's here is is Black

899
00:37:15,420 --> 00:37:17,640
Box ish right or you know you do a

900
00:37:17,640 --> 00:37:19,200
little bit of linear algebra and you

901
00:37:19,200 --> 00:37:21,780
you're done right so yes I think from

902
00:37:21,780 --> 00:37:24,000
the central equation you can recover I

903
00:37:24,000 --> 00:37:25,380
think all the applications that I'll

904
00:37:25,380 --> 00:37:27,960
mention by just setting up the matrices

905
00:37:27,960 --> 00:37:29,700
in the appropriate way yes

906
00:37:29,700 --> 00:37:33,180
yes uh a question there yes

907
00:37:33,180 --> 00:37:34,740
how large is

908
00:37:34,740 --> 00:37:38,280
how large is CF yeah right so if F let's

909
00:37:38,280 --> 00:37:41,160
say F outputs a single bit then a CF is

910
00:37:41,160 --> 00:37:43,140
just the Matrix that's the size of G so

911
00:37:43,140 --> 00:37:45,480
it's sort of a fixed size so it's um

912
00:37:45,480 --> 00:37:47,700
it's linear in the output uh length of f

913
00:37:47,700 --> 00:37:50,640
but not it does not depend really in any

914
00:37:50,640 --> 00:37:53,339
essential way on the size of f as a

915
00:37:53,339 --> 00:37:57,480
circuit yeah just the output length of f

916
00:37:57,480 --> 00:37:58,859
M great

917
00:37:58,859 --> 00:38:01,140
okay so let's go on

918
00:38:01,140 --> 00:38:03,119
um there's some nice bonus features of

919
00:38:03,119 --> 00:38:05,339
this which I'll just mention is that

920
00:38:05,339 --> 00:38:07,500
you know the specializations to Vector

921
00:38:07,500 --> 00:38:09,180
commitments and polynomial commitments

922
00:38:09,180 --> 00:38:10,619
and so forth

923
00:38:10,619 --> 00:38:11,640
um

924
00:38:11,640 --> 00:38:14,280
due to the form of these kinds of

925
00:38:14,280 --> 00:38:16,500
commitments you can do pre-computation

926
00:38:16,500 --> 00:38:19,260
and exploit linearity to get a much more

927
00:38:19,260 --> 00:38:21,540
efficient uh versions of this commitment

928
00:38:21,540 --> 00:38:22,859
scheme

929
00:38:22,859 --> 00:38:25,079
um so this just sort of says you can

930
00:38:25,079 --> 00:38:27,660
write the function f using its lookup

931
00:38:27,660 --> 00:38:31,700
table as a weighted sum of uh EQ

932
00:38:31,700 --> 00:38:34,560
equality tests and so by pre-computing

933
00:38:34,560 --> 00:38:36,540
all these equality tests you can sort of

934
00:38:36,540 --> 00:38:39,060
do that once and then commit to as many

935
00:38:39,060 --> 00:38:41,460
uh different you know lookup tables or

936
00:38:41,460 --> 00:38:43,260
polynomials as you like

937
00:38:43,260 --> 00:38:45,960
uh you can also do stateless updates an

938
00:38:45,960 --> 00:38:47,700
interest of time I won't say more about

939
00:38:47,700 --> 00:38:50,339
that you can also get zero knowledge if

940
00:38:50,339 --> 00:38:51,900
you relax The Binding property a little

941
00:38:51,900 --> 00:38:55,320
bit uh by using what's known as circuit

942
00:38:55,320 --> 00:38:58,380
privacy or eval evaluation privacy so

943
00:38:58,380 --> 00:39:00,960
this a sub F here can actually hide the

944
00:39:00,960 --> 00:39:03,119
function f right reveal nothing about

945
00:39:03,119 --> 00:39:05,400
the function f and then when you open

946
00:39:05,400 --> 00:39:07,619
you can also make it so this s here

947
00:39:07,619 --> 00:39:10,619
doesn't reveal anything apart from the

948
00:39:10,619 --> 00:39:13,980
input output XY relationship right so

949
00:39:13,980 --> 00:39:15,900
you can get a zero knowledge version of

950
00:39:15,900 --> 00:39:18,599
this which actually does hide F and and

951
00:39:18,599 --> 00:39:20,880
other information

952
00:39:20,880 --> 00:39:24,599
okay so that's uh final thoughts on

953
00:39:24,599 --> 00:39:26,160
functional commitments

954
00:39:26,160 --> 00:39:28,920
so unlike an fhe everything we've seen

955
00:39:28,920 --> 00:39:30,060
here

956
00:39:30,060 --> 00:39:32,579
there's no hiding needed and there's no

957
00:39:32,579 --> 00:39:34,079
structure to any of these matrices

958
00:39:34,079 --> 00:39:35,640
needed there's no need to have a secret

959
00:39:35,640 --> 00:39:37,700
key embedded in it or anything like that

960
00:39:37,700 --> 00:39:40,020
uh the public parameters is an

961
00:39:40,020 --> 00:39:42,540
unstructured random Matrix the function

962
00:39:42,540 --> 00:39:44,720
f and X are all public

963
00:39:44,720 --> 00:39:47,339
and so this doesn't look very much like

964
00:39:47,339 --> 00:39:50,400
fhe but it it is homomorphic computation

965
00:39:50,400 --> 00:39:54,300
and it has arisen from an fhe scheme as

966
00:39:54,300 --> 00:39:55,920
I've said before compactness is really

967
00:39:55,920 --> 00:39:58,500
the the critical feature right we get

968
00:39:58,500 --> 00:40:02,300
one small a sub F or C sub F if you like

969
00:40:02,300 --> 00:40:04,920
but it supports many different openings

970
00:40:04,920 --> 00:40:07,500
or many different solutions uh to this

971
00:40:07,500 --> 00:40:10,619
Central equation for all the x's in the

972
00:40:10,619 --> 00:40:12,720
domain of the function

973
00:40:12,720 --> 00:40:14,940
okay I should also mention there's a

974
00:40:14,940 --> 00:40:17,280
concurrent work by we and Wu which also

975
00:40:17,280 --> 00:40:18,780
gets functional commitments with the

976
00:40:18,780 --> 00:40:20,880
very different properties they have a

977
00:40:20,880 --> 00:40:23,280
structured uh random string so there's a

978
00:40:23,280 --> 00:40:26,339
private private key setup the burden of

979
00:40:26,339 --> 00:40:28,200
computation is swapped so the prover

980
00:40:28,200 --> 00:40:30,180
does little work but the verifier does a

981
00:40:30,180 --> 00:40:32,640
lot of work uh that has smaller proofs

982
00:40:32,640 --> 00:40:34,619
and it's based on a new ad hoc

983
00:40:34,619 --> 00:40:37,920
assumption that needs cryptanalysis

984
00:40:37,920 --> 00:40:40,200
uh but still still I think you can

985
00:40:40,200 --> 00:40:42,720
probably write down their scheme as a

986
00:40:42,720 --> 00:40:46,079
arising from the central equation

987
00:40:46,079 --> 00:40:48,960
okay so let's move on to uh a second

988
00:40:48,960 --> 00:40:50,579
surprising application which is

989
00:40:50,579 --> 00:40:52,800
instantiating Fiat Shamir

990
00:40:52,800 --> 00:40:55,800
to get non-interactive zero knowledge

991
00:40:55,800 --> 00:40:58,500
okay so uh is there a knowledge and and

992
00:40:58,500 --> 00:41:00,180
non-interactive zero knowledge so first

993
00:41:00,180 --> 00:41:02,220
of all zero knowledge is usually

994
00:41:02,220 --> 00:41:04,079
conceived of as an interactive protocol

995
00:41:04,079 --> 00:41:06,560
between prover and verifier

996
00:41:06,560 --> 00:41:10,140
and a central theorem or two theorems

997
00:41:10,140 --> 00:41:12,240
about this is if one-way functions exist

998
00:41:12,240 --> 00:41:16,680
then every NP language has a zero

999
00:41:16,680 --> 00:41:17,820
knowledge proof or a zero knowledge

1000
00:41:17,820 --> 00:41:19,079
argument

1001
00:41:19,079 --> 00:41:21,359
well both a proof and an argument uh

1002
00:41:21,359 --> 00:41:24,359
depending on what the protocol is

1003
00:41:24,359 --> 00:41:26,400
um so that's with you allow interaction

1004
00:41:26,400 --> 00:41:28,380
the the problem is essentially solved

1005
00:41:28,380 --> 00:41:30,900
the one-way functions are uh sufficient

1006
00:41:30,900 --> 00:41:33,960
and arguably necessary to get zero

1007
00:41:33,960 --> 00:41:36,000
knowledge for NP

1008
00:41:36,000 --> 00:41:38,700
but interaction is not desirable we

1009
00:41:38,700 --> 00:41:40,260
don't like a lot of back and forth right

1010
00:41:40,260 --> 00:41:42,780
so uh the question asked by blumen

1011
00:41:42,780 --> 00:41:45,720
DeSantis McAllen persiano in 88 was what

1012
00:41:45,720 --> 00:41:47,820
if the approver could just send a proof

1013
00:41:47,820 --> 00:41:49,500
over to the verifier and the verifier

1014
00:41:49,500 --> 00:41:51,780
would check it

1015
00:41:51,780 --> 00:41:53,940
okay is this possible can we get zero

1016
00:41:53,940 --> 00:41:57,000
knowledge uh for this well in the plane

1017
00:41:57,000 --> 00:41:58,920
model where it's really just the proof

1018
00:41:58,920 --> 00:42:02,060
going over uh you can't prove anything

1019
00:42:02,060 --> 00:42:04,920
uh non-interactively that you can't

1020
00:42:04,920 --> 00:42:07,920
prove the verifier can't do himself

1021
00:42:07,920 --> 00:42:10,980
so it's a trivial the languages that you

1022
00:42:10,980 --> 00:42:12,540
can prove in non-interactive zero

1023
00:42:12,540 --> 00:42:14,760
knowledge or just the trivial languages

1024
00:42:14,760 --> 00:42:17,820
but if you allow a random string or a

1025
00:42:17,820 --> 00:42:21,780
reference string to be chosen then uh

1026
00:42:21,780 --> 00:42:24,839
every NP language has a non-interactive

1027
00:42:24,839 --> 00:42:26,700
zero knowledge protocol

1028
00:42:26,700 --> 00:42:29,520
under various cryptographic assumptions

1029
00:42:29,520 --> 00:42:32,220
so these assumptions are like trapdoor

1030
00:42:32,220 --> 00:42:34,320
permutations or pairings or

1031
00:42:34,320 --> 00:42:37,320
indistinguishability obfuscation so

1032
00:42:37,320 --> 00:42:39,839
specific specific assumptions not like

1033
00:42:39,839 --> 00:42:41,460
General one-way functions that's still

1034
00:42:41,460 --> 00:42:43,260
not known

1035
00:42:43,260 --> 00:42:46,500
and a question uh that we were asking in

1036
00:42:46,500 --> 00:42:49,320
2008 uh when we were looking at a lot of

1037
00:42:49,320 --> 00:42:51,839
these applications are like can we get

1038
00:42:51,839 --> 00:42:55,740
nizzix for NP under lattice assumptions

1039
00:42:55,740 --> 00:42:58,680
and for a long time we couldn't do it we

1040
00:42:58,680 --> 00:43:00,720
tried a lot of different things and just

1041
00:43:00,720 --> 00:43:03,060
uh nothing was working

1042
00:43:03,060 --> 00:43:06,060
uh but then in 2019 uh building on this

1043
00:43:06,060 --> 00:43:08,280
these Works related to fiasmir uh

1044
00:43:08,280 --> 00:43:11,099
finally this was uh resolved so a major

1045
00:43:11,099 --> 00:43:13,920
step uh toward it by kinety at all and

1046
00:43:13,920 --> 00:43:16,920
then uh with my student Cena Sheehan we

1047
00:43:16,920 --> 00:43:19,020
finally got the last piece of the puzzle

1048
00:43:19,020 --> 00:43:23,400
to assume lwe uh nizics are possible for

1049
00:43:23,400 --> 00:43:25,440
all of NP

1050
00:43:25,440 --> 00:43:28,079
okay so I'd like to show you a flavor of

1051
00:43:28,079 --> 00:43:31,020
how uh this result works and why

1052
00:43:31,020 --> 00:43:34,200
homomorphic uh and computation is

1053
00:43:34,200 --> 00:43:36,060
Central to it

1054
00:43:36,060 --> 00:43:38,460
so the way this works is going is going

1055
00:43:38,460 --> 00:43:41,280
to be via Fiat Shamir Sophia is a

1056
00:43:41,280 --> 00:43:43,440
transform that allows you to remove

1057
00:43:43,440 --> 00:43:46,020
interaction from a public coin protocol

1058
00:43:46,020 --> 00:43:48,180
using a hash function

1059
00:43:48,180 --> 00:43:49,920
so suppose you have some protocol where

1060
00:43:49,920 --> 00:43:51,720
the prover sends a message the verifier

1061
00:43:51,720 --> 00:43:53,579
sends random bits the proofer sends

1062
00:43:53,579 --> 00:43:55,380
something verifier maybe sends more

1063
00:43:55,380 --> 00:43:57,599
random bits and eventually the verifier

1064
00:43:57,599 --> 00:43:59,760
accepts or rejects

1065
00:43:59,760 --> 00:44:02,880
you can make this non-interactive by uh

1066
00:44:02,880 --> 00:44:04,680
putting a hash function you know in the

1067
00:44:04,680 --> 00:44:08,819
sky right and uh saying instead of the

1068
00:44:08,819 --> 00:44:11,520
verifier choosing random bits we'll just

1069
00:44:11,520 --> 00:44:15,599
hash all the prior uh messages from the

1070
00:44:15,599 --> 00:44:17,940
prover and treat those as if they were

1071
00:44:17,940 --> 00:44:21,180
the random bits given by the verifier so

1072
00:44:21,180 --> 00:44:22,920
the prover can kind of act as the

1073
00:44:22,920 --> 00:44:24,839
verifier on its own locally and then

1074
00:44:24,839 --> 00:44:26,700
just send the whole proof over in one

1075
00:44:26,700 --> 00:44:29,359
one pass

1076
00:44:29,579 --> 00:44:32,520
so uh it's relatively easy to show that

1077
00:44:32,520 --> 00:44:35,160
if your original protocol is complete

1078
00:44:35,160 --> 00:44:37,800
and through a knowledge then this

1079
00:44:37,800 --> 00:44:40,200
version can also be complete and zero

1080
00:44:40,200 --> 00:44:42,660
knowledge uh it's not too hard to to

1081
00:44:42,660 --> 00:44:44,940
argue this but the hard part of a

1082
00:44:44,940 --> 00:44:48,119
fiashimir is soundness right so

1083
00:44:48,119 --> 00:44:50,579
soundness being

1084
00:44:50,579 --> 00:44:53,099
if the statement is false right if

1085
00:44:53,099 --> 00:44:54,300
you're trying to prove a false statement

1086
00:44:54,300 --> 00:44:56,160
the proverb will be caught with very

1087
00:44:56,160 --> 00:44:58,440
high probability over here

1088
00:44:58,440 --> 00:45:00,300
but if the proof is trying to prove a

1089
00:45:00,300 --> 00:45:02,520
false statement over here maybe can it

1090
00:45:02,520 --> 00:45:04,740
rig up you know some special message

1091
00:45:04,740 --> 00:45:07,140
Alpha that hashes just the right way so

1092
00:45:07,140 --> 00:45:08,760
that it can complete the full proof and

1093
00:45:08,760 --> 00:45:10,579
convince the verifier

1094
00:45:10,579 --> 00:45:14,099
so proving soundness is really the the

1095
00:45:14,099 --> 00:45:15,660
key difficulty

1096
00:45:15,660 --> 00:45:18,000
uh that is are there some you know

1097
00:45:18,000 --> 00:45:21,180
proverb messages Alpha and gamma

1098
00:45:21,180 --> 00:45:23,760
such that Alpha hashes to just the right

1099
00:45:23,760 --> 00:45:25,920
uh just the right value that lets the

1100
00:45:25,920 --> 00:45:28,140
approver complete the proof

1101
00:45:28,140 --> 00:45:29,940
okay

1102
00:45:29,940 --> 00:45:32,160
um and can a cheating prover actually

1103
00:45:32,160 --> 00:45:34,920
find such values right so this is the

1104
00:45:34,920 --> 00:45:36,480
question of is it a proof or is it an

1105
00:45:36,480 --> 00:45:37,740
argument does it sound against an

1106
00:45:37,740 --> 00:45:40,260
unbounded prover does it sound against a

1107
00:45:40,260 --> 00:45:42,660
computationally bounded proofer you can

1108
00:45:42,660 --> 00:45:45,599
ask both questions

1109
00:45:45,599 --> 00:45:48,180
okay so the hard part of Fiat Shamir is

1110
00:45:48,180 --> 00:45:52,880
soundness and uh starting with uh Kalia

1111
00:45:52,880 --> 00:45:56,520
bloom in uh 17 and and many subsequent

1112
00:45:56,520 --> 00:45:58,859
Works uh there was a lot of progress on

1113
00:45:58,859 --> 00:46:00,780
addressing this question

1114
00:46:00,780 --> 00:46:04,140
so uh what was uh observed is that

1115
00:46:04,140 --> 00:46:06,540
what's called a correlation intractable

1116
00:46:06,540 --> 00:46:09,720
hash function uh can often suffice to

1117
00:46:09,720 --> 00:46:11,640
make Fiat Shamir sound

1118
00:46:11,640 --> 00:46:13,560
so what is correlation intractable mean

1119
00:46:13,560 --> 00:46:16,079
it means that if you choose a hash

1120
00:46:16,079 --> 00:46:18,240
function at random from this special

1121
00:46:18,240 --> 00:46:19,380
family

1122
00:46:19,380 --> 00:46:22,680
then it's hard or maybe impossible to

1123
00:46:22,680 --> 00:46:24,420
find an input Alpha

1124
00:46:24,420 --> 00:46:27,420
so that a and the hash of alpha is in

1125
00:46:27,420 --> 00:46:29,700
some certain relation what is that

1126
00:46:29,700 --> 00:46:32,520
relation it's the relation of uh Alpha

1127
00:46:32,520 --> 00:46:35,460
Beta pairs that have a you know a way to

1128
00:46:35,460 --> 00:46:38,160
complete the proof to fool the verifier

1129
00:46:38,160 --> 00:46:40,160
okay so just

1130
00:46:40,160 --> 00:46:42,480
not really saying anything here just

1131
00:46:42,480 --> 00:46:44,880
syntactically this is just another way

1132
00:46:44,880 --> 00:46:47,099
of stating the soundness condition that

1133
00:46:47,099 --> 00:46:49,260
we want right we want it to be hard to

1134
00:46:49,260 --> 00:46:53,460
find an alpha whose hash beta allows the

1135
00:46:53,460 --> 00:46:56,480
proof to be completed

1136
00:46:56,520 --> 00:46:59,220
so a theorem that was shown more more

1137
00:46:59,220 --> 00:47:01,980
precisely actually more concretely uh by

1138
00:47:01,980 --> 00:47:04,500
homgun and Marty and then Kennedy at all

1139
00:47:04,500 --> 00:47:07,079
is that we can get uh music proofs for

1140
00:47:07,079 --> 00:47:09,900
any NP language if we have a correlation

1141
00:47:09,900 --> 00:47:12,540
intractable hash family for all bounded

1142
00:47:12,540 --> 00:47:13,619
circuits

1143
00:47:13,619 --> 00:47:15,540
okay so what does that mean

1144
00:47:15,540 --> 00:47:18,780
s that if you choose a hash function

1145
00:47:18,780 --> 00:47:21,060
from the family at random

1146
00:47:21,060 --> 00:47:24,000
then you can't find an alpha such that h

1147
00:47:24,000 --> 00:47:26,819
of alpha equals c of alpha where C is

1148
00:47:26,819 --> 00:47:30,859
any circuit up to a certain size

1149
00:47:31,680 --> 00:47:34,140
so importantly you have to fix the

1150
00:47:34,140 --> 00:47:35,040
family

1151
00:47:35,040 --> 00:47:37,740
first okay you fix the family script H

1152
00:47:37,740 --> 00:47:41,579
and then you say all right now I uh I

1153
00:47:41,579 --> 00:47:43,380
want this circuit C this particular

1154
00:47:43,380 --> 00:47:45,000
circuit c

1155
00:47:45,000 --> 00:47:46,980
um and if I choose a member from the

1156
00:47:46,980 --> 00:47:49,020
family from the hash family it should be

1157
00:47:49,020 --> 00:47:51,060
hard for me to make h of alpha equals c

1158
00:47:51,060 --> 00:47:52,380
of alpha

1159
00:47:52,380 --> 00:47:55,020
okay so this is the theorem that they

1160
00:47:55,020 --> 00:47:57,540
proved and the extent of proof idea the

1161
00:47:57,540 --> 00:48:01,140
idea key idea why this suffices is that

1162
00:48:01,140 --> 00:48:03,300
uh if you take for example the the

1163
00:48:03,300 --> 00:48:06,900
classic hamiltonian cycle uh protocol

1164
00:48:06,900 --> 00:48:08,940
every message that the prover sends

1165
00:48:08,940 --> 00:48:10,680
every Alpha that the prover might start

1166
00:48:10,680 --> 00:48:11,579
with

1167
00:48:11,579 --> 00:48:14,880
there's exactly one beta

1168
00:48:14,880 --> 00:48:17,099
that will let the prover complete the

1169
00:48:17,099 --> 00:48:18,119
proof

1170
00:48:18,119 --> 00:48:19,680
okay so we can call this the fooling

1171
00:48:19,680 --> 00:48:21,180
challenge or something that's the if

1172
00:48:21,180 --> 00:48:24,300
there's a single value beta that uh will

1173
00:48:24,300 --> 00:48:26,460
let the prover fool the verifier

1174
00:48:26,460 --> 00:48:28,020
okay

1175
00:48:28,020 --> 00:48:30,599
if chosen the approval will be caught a

1176
00:48:30,599 --> 00:48:32,880
lying on the verifier will reject right

1177
00:48:32,880 --> 00:48:34,859
so it's exactly one fooling challenge

1178
00:48:34,859 --> 00:48:38,040
beta and moreover this fooling challenge

1179
00:48:38,040 --> 00:48:41,480
actually can be computed from alpha

1180
00:48:41,480 --> 00:48:46,079
using a trapdoor for the um uh the

1181
00:48:46,079 --> 00:48:47,819
trapdoor that for a value that's up in

1182
00:48:47,819 --> 00:48:50,400
the common random string right so there

1183
00:48:50,400 --> 00:48:52,859
is a secret circuit that has a secret

1184
00:48:52,859 --> 00:48:55,500
key in it uh that will tell you what the

1185
00:48:55,500 --> 00:48:57,119
fooling challenge is so no matter what

1186
00:48:57,119 --> 00:48:59,339
uh what Alpha is sent there's a secret

1187
00:48:59,339 --> 00:49:01,200
circuit that will tell you what the

1188
00:49:01,200 --> 00:49:03,960
fooling challenge is all right and so if

1189
00:49:03,960 --> 00:49:06,000
your hash family is

1190
00:49:06,000 --> 00:49:08,839
Collision intractable for that circuit

1191
00:49:08,839 --> 00:49:11,520
well that means there's no way for you

1192
00:49:11,520 --> 00:49:13,920
to come up with an alpha that hashes to

1193
00:49:13,920 --> 00:49:15,660
the fooling challenge

1194
00:49:15,660 --> 00:49:18,180
okay so very lovely uh very lovely

1195
00:49:18,180 --> 00:49:21,000
argument here but the bottom line is we

1196
00:49:21,000 --> 00:49:23,460
just need a CI family for all bounded

1197
00:49:23,460 --> 00:49:24,599
circuits

1198
00:49:24,599 --> 00:49:26,520
and once we have that we can get nizzix

1199
00:49:26,520 --> 00:49:28,380
for NP

1200
00:49:28,380 --> 00:49:31,800
so uh that's what was obtained uh in a

1201
00:49:31,800 --> 00:49:33,540
long series of Works under various

1202
00:49:33,540 --> 00:49:37,680
assumptions ultimately sis or lwb

1203
00:49:37,680 --> 00:49:40,319
so we can get a coalition intractable

1204
00:49:40,319 --> 00:49:42,540
hash function for all bounded circuits

1205
00:49:42,540 --> 00:49:45,480
using this homomorphic computation under

1206
00:49:45,480 --> 00:49:47,520
SS and lwe

1207
00:49:47,520 --> 00:49:49,140
and there's kind of two different modes

1208
00:49:49,140 --> 00:49:52,260
one is uh based on sis

1209
00:49:52,260 --> 00:49:55,500
and it says that it's hard to find uh

1210
00:49:55,500 --> 00:49:58,440
you know a collision correlation it's

1211
00:49:58,440 --> 00:50:00,720
fine hard to find a correlation and so

1212
00:50:00,720 --> 00:50:03,359
this will give you a argument right

1213
00:50:03,359 --> 00:50:05,400
it'll be sound against the

1214
00:50:05,400 --> 00:50:07,980
computationally bounded prover and it'll

1215
00:50:07,980 --> 00:50:10,079
be statistically zero knowledge

1216
00:50:10,079 --> 00:50:12,660
uh under a random string

1217
00:50:12,660 --> 00:50:15,599
or you can flip it and get uh something

1218
00:50:15,599 --> 00:50:17,700
where even there does not exist in Alpha

1219
00:50:17,700 --> 00:50:20,400
that breaks this correlation interact

1220
00:50:20,400 --> 00:50:22,920
ability doesn't exist so even an

1221
00:50:22,920 --> 00:50:25,020
unbounded prover can't find it because

1222
00:50:25,020 --> 00:50:27,660
this Alpha doesn't exist

1223
00:50:27,660 --> 00:50:29,640
um so this gives you uh computationally

1224
00:50:29,640 --> 00:50:31,440
zero knowledge proof If you have a

1225
00:50:31,440 --> 00:50:33,960
structured random string that is an lwe

1226
00:50:33,960 --> 00:50:36,060
Matrix

1227
00:50:36,060 --> 00:50:39,960
okay so let me give you uh the sort of

1228
00:50:39,960 --> 00:50:42,540
one slide description of how this hash

1229
00:50:42,540 --> 00:50:44,460
function works

1230
00:50:44,460 --> 00:50:46,800
um it's it's quite simple once you once

1231
00:50:46,800 --> 00:50:48,059
you see it of course it wasn't simple

1232
00:50:48,059 --> 00:50:49,380
for a long time

1233
00:50:49,380 --> 00:50:50,640
so we want to have correlation

1234
00:50:50,640 --> 00:50:53,099
attractability for size s circuits let's

1235
00:50:53,099 --> 00:50:54,660
pretend that the circuit outputs a

1236
00:50:54,660 --> 00:50:58,440
vector okay a vector of values

1237
00:50:58,440 --> 00:51:00,960
my hash key is going to be just a

1238
00:51:00,960 --> 00:51:03,780
uniformly random Matrix a and this a

1239
00:51:03,780 --> 00:51:05,819
will be big enough that it can hide a

1240
00:51:05,819 --> 00:51:08,040
description of the circuit or an encoded

1241
00:51:08,040 --> 00:51:10,680
description of the circuit as we'll see

1242
00:51:10,680 --> 00:51:13,020
so think of this a as maybe having the

1243
00:51:13,020 --> 00:51:15,180
circuit hidden inside of it maybe maybe

1244
00:51:15,180 --> 00:51:17,339
not right but you don't know what if it

1245
00:51:17,339 --> 00:51:18,839
has a circuit in it or what circuit is

1246
00:51:18,839 --> 00:51:20,099
in there

1247
00:51:20,099 --> 00:51:21,960
right so how do we evaluate this hash

1248
00:51:21,960 --> 00:51:25,440
function I'm given some input Alpha

1249
00:51:25,440 --> 00:51:28,079
and I'm just going to evaluate I'm going

1250
00:51:28,079 --> 00:51:31,260
to do homomorphic evaluation on a

1251
00:51:31,260 --> 00:51:34,559
special function U sub Alpha this use of

1252
00:51:34,559 --> 00:51:37,140
alpha basically flips code and data so

1253
00:51:37,140 --> 00:51:39,780
it's a universal circuit

1254
00:51:39,780 --> 00:51:43,440
um if I call U sub Alpha on a circuit it

1255
00:51:43,440 --> 00:51:45,599
will output C of alpha

1256
00:51:45,599 --> 00:51:48,420
okay so the the clever idea here is to

1257
00:51:48,420 --> 00:51:51,500
swap code and data we're now evaluating

1258
00:51:51,500 --> 00:51:55,680
uh this universal circuit that has Alpha

1259
00:51:55,680 --> 00:51:57,780
hard coded into it

1260
00:51:57,780 --> 00:52:00,540
okay so we get this a sub Alpha out

1261
00:52:00,540 --> 00:52:01,859
and then the second thing we're going to

1262
00:52:01,859 --> 00:52:05,819
do is like flatten or inertify as what I

1263
00:52:05,819 --> 00:52:08,339
call it this Matrix a

1264
00:52:08,339 --> 00:52:10,380
um oops that should be a sub Alpha sorry

1265
00:52:10,380 --> 00:52:13,140
so we're basically going to take a sub

1266
00:52:13,140 --> 00:52:16,020
Alpha times a single short vector and so

1267
00:52:16,020 --> 00:52:18,660
we'll get a vector out as output

1268
00:52:18,660 --> 00:52:20,460
and this is a special Vector that has

1269
00:52:20,460 --> 00:52:21,960
the property that if you take an

1270
00:52:21,960 --> 00:52:24,839
encoding of any y times the short Vector

1271
00:52:24,839 --> 00:52:27,599
it will give you back the vector y

1272
00:52:27,599 --> 00:52:29,700
so this short Vector is easy to easy to

1273
00:52:29,700 --> 00:52:31,879
design

1274
00:52:31,920 --> 00:52:35,040
and our output is just this right so our

1275
00:52:35,040 --> 00:52:37,020
hash function just homomorphically

1276
00:52:37,020 --> 00:52:40,440
evaluates this uh universal circuit with

1277
00:52:40,440 --> 00:52:42,480
a hard coded into it and then kind of

1278
00:52:42,480 --> 00:52:45,960
basically picks out a one one random

1279
00:52:45,960 --> 00:52:48,000
column of the result another random

1280
00:52:48,000 --> 00:52:50,220
column I'm sorry a special column of the

1281
00:52:50,220 --> 00:52:52,399
result

1282
00:52:53,520 --> 00:52:58,680
okay so uh the key Point here is that

1283
00:52:58,680 --> 00:53:02,099
the output of our function is a vector

1284
00:53:02,099 --> 00:53:04,740
and it's a vector that has the same size

1285
00:53:04,740 --> 00:53:07,800
as the circuits that uh we want to be

1286
00:53:07,800 --> 00:53:09,540
intractable for

1287
00:53:09,540 --> 00:53:12,240
okay so this Ace of alpha can

1288
00:53:12,240 --> 00:53:15,599
effectively hide a circuit or circuit

1289
00:53:15,599 --> 00:53:18,300
output rather of the same size and this

1290
00:53:18,300 --> 00:53:20,160
allows us to actually mix together these

1291
00:53:20,160 --> 00:53:21,900
values or cancel them out so we're sort

1292
00:53:21,900 --> 00:53:26,700
of comparing the uh commitment and the

1293
00:53:26,700 --> 00:53:29,160
value that it commits to and treating

1294
00:53:29,160 --> 00:53:33,540
them as uh mixable okay so that probably

1295
00:53:33,540 --> 00:53:35,160
doesn't make a lot of sense but the next

1296
00:53:35,160 --> 00:53:38,598
slide will explain that yes

1297
00:53:39,660 --> 00:53:42,839
this is any uh this is any value y

1298
00:53:42,839 --> 00:53:45,180
so no matter what Y is

1299
00:53:45,180 --> 00:53:47,099
right so you can think of think of this

1300
00:53:47,099 --> 00:53:50,280
y as as representing C of alpha right in

1301
00:53:50,280 --> 00:53:52,140
the in the security proof

1302
00:53:52,140 --> 00:53:56,220
C Alpha will be hidden in here and uh

1303
00:53:56,220 --> 00:53:57,780
we're going to hit it with this short

1304
00:53:57,780 --> 00:54:00,240
vector and that will output

1305
00:54:00,240 --> 00:54:03,359
C Alpha as a vector itself

1306
00:54:03,359 --> 00:54:06,960
okay so just to uh

1307
00:54:06,960 --> 00:54:09,660
to give you an idea of the the proof

1308
00:54:09,660 --> 00:54:11,160
okay so why is this correlation

1309
00:54:11,160 --> 00:54:12,599
attractable

1310
00:54:12,599 --> 00:54:15,240
again our hash key is just a random

1311
00:54:15,240 --> 00:54:19,440
Matrix and evaluation looks like this so

1312
00:54:19,440 --> 00:54:22,559
we do eval to get a sub Alpha and then

1313
00:54:22,559 --> 00:54:25,079
we multiply by this one short vector

1314
00:54:25,079 --> 00:54:29,280
so suppose you have a circuit C and

1315
00:54:29,280 --> 00:54:30,900
suppose you have some adversary that

1316
00:54:30,900 --> 00:54:32,760
violates correlation attractability

1317
00:54:32,760 --> 00:54:34,980
right so what does it mean means that

1318
00:54:34,980 --> 00:54:37,200
the adversary was given this hash key

1319
00:54:37,200 --> 00:54:39,420
and was able to find an alpha such that

1320
00:54:39,420 --> 00:54:42,420
H Alpha equals c of alpha right that's

1321
00:54:42,420 --> 00:54:44,160
what it means to break correlation

1322
00:54:44,160 --> 00:54:45,660
attractability

1323
00:54:45,660 --> 00:54:47,220
what we'll show

1324
00:54:47,220 --> 00:54:51,000
is that uh we can use this Alpha

1325
00:54:51,000 --> 00:54:54,480
to solve sis

1326
00:54:54,480 --> 00:54:56,339
so we can use this adversary to solve

1327
00:54:56,339 --> 00:54:57,780
SAS

1328
00:54:57,780 --> 00:55:00,599
so the observation is that um

1329
00:55:00,599 --> 00:55:03,480
this adversary works you know given this

1330
00:55:03,480 --> 00:55:06,420
random hash key but we could have

1331
00:55:06,420 --> 00:55:09,420
hidden the circuit of interest in in

1332
00:55:09,420 --> 00:55:11,339
this hash key right instead of using a

1333
00:55:11,339 --> 00:55:14,520
we could have used a uniform B plus an

1334
00:55:14,520 --> 00:55:15,839
encoding of the circuit in question

1335
00:55:15,839 --> 00:55:18,420
right and this this B is uniform so

1336
00:55:18,420 --> 00:55:20,220
overall the distribution of a is still

1337
00:55:20,220 --> 00:55:22,559
appropriate it's still random uniformly

1338
00:55:22,559 --> 00:55:24,660
random as it should be

1339
00:55:24,660 --> 00:55:26,880
okay so imagine that this hash key

1340
00:55:26,880 --> 00:55:29,040
actually holds this encoding of of the

1341
00:55:29,040 --> 00:55:30,000
circuit

1342
00:55:30,000 --> 00:55:32,040
and now let's just use the central

1343
00:55:32,040 --> 00:55:36,119
equation okay so uh we're going to

1344
00:55:36,119 --> 00:55:39,180
derive our short Matrix you know using

1345
00:55:39,180 --> 00:55:41,460
eval Prime here so we have our function

1346
00:55:41,460 --> 00:55:44,160
we have our input we just derived this

1347
00:55:44,160 --> 00:55:46,339
so by the central equation we know that

1348
00:55:46,339 --> 00:55:49,920
a minus and code of C that's B

1349
00:55:49,920 --> 00:55:51,559
times s

1350
00:55:51,559 --> 00:55:55,079
equals a minus and code of c times s

1351
00:55:55,079 --> 00:55:58,260
okay so I just did a substitution here

1352
00:55:58,260 --> 00:56:00,599
so this is just substitution of what B

1353
00:56:00,599 --> 00:56:03,240
is B is a minus and code of C

1354
00:56:03,240 --> 00:56:05,700
but by the essential equation this term

1355
00:56:05,700 --> 00:56:08,099
here A minus and code of c times the

1356
00:56:08,099 --> 00:56:11,700
short Matrix equals a alpha minus encode

1357
00:56:11,700 --> 00:56:13,740
of C Alpha

1358
00:56:13,740 --> 00:56:16,559
okay so that's the central equation and

1359
00:56:16,559 --> 00:56:19,200
then we've also multiplied by this this

1360
00:56:19,200 --> 00:56:21,780
inerting or this flattening Matrix sorry

1361
00:56:21,780 --> 00:56:23,280
flattening vector

1362
00:56:23,280 --> 00:56:26,099
and by design a alpha times s star is

1363
00:56:26,099 --> 00:56:28,859
just little a alpha but also in code of

1364
00:56:28,859 --> 00:56:31,920
anything times s star is just uh the

1365
00:56:31,920 --> 00:56:34,559
encoded value

1366
00:56:34,559 --> 00:56:36,480
Now by assumption

1367
00:56:36,480 --> 00:56:38,640
the hash value the hash output which is

1368
00:56:38,640 --> 00:56:41,880
a alpha equals c Alpha so this is all

1369
00:56:41,880 --> 00:56:43,800
zero everything cancels out

1370
00:56:43,800 --> 00:56:46,460
the value uh the the the the

1371
00:56:46,460 --> 00:56:48,839
homomorphically encrypted value equals

1372
00:56:48,839 --> 00:56:51,059
the value that's inside of it and

1373
00:56:51,059 --> 00:56:52,980
somehow we've arranged for them to

1374
00:56:52,980 --> 00:56:55,020
cancel each other out and that gives us

1375
00:56:55,020 --> 00:56:56,640
zero

1376
00:56:56,640 --> 00:56:59,880
so this in fact solves sis uh on the

1377
00:56:59,880 --> 00:57:02,160
Matrix on the random Matrix B right so

1378
00:57:02,160 --> 00:57:04,440
if our or we can set things up so that

1379
00:57:04,440 --> 00:57:08,520
our B is our sis uh challenge we set up

1380
00:57:08,520 --> 00:57:10,740
our hash key to VB plus and code of c

1381
00:57:10,740 --> 00:57:14,400
and everything just falls out

1382
00:57:14,400 --> 00:57:16,920
okay so that's a lot uh too many

1383
00:57:16,920 --> 00:57:19,619
equations right but um hopefully that

1384
00:57:19,619 --> 00:57:21,300
gives you the flavor of what's going on

1385
00:57:21,300 --> 00:57:22,740
here

1386
00:57:22,740 --> 00:57:25,440
all right you can also tweak this so

1387
00:57:25,440 --> 00:57:28,200
that if you make B uh an lwe Matrix

1388
00:57:28,200 --> 00:57:30,660
instead of a uniformly random one you

1389
00:57:30,660 --> 00:57:33,420
can actually make this impossible so

1390
00:57:33,420 --> 00:57:35,520
there just does not exist in Alpha where

1391
00:57:35,520 --> 00:57:37,559
the hash of alpha equals c of alpha

1392
00:57:37,559 --> 00:57:39,000
right so there's a little tweak maybe

1393
00:57:39,000 --> 00:57:41,099
I'll leave that as an exercise to uh see

1394
00:57:41,099 --> 00:57:43,319
if you can work that out

1395
00:57:43,319 --> 00:57:48,119
okay great so uh or rather I can take a

1396
00:57:48,119 --> 00:57:50,520
question here uh or I can uh wrap up

1397
00:57:50,520 --> 00:57:51,839
well let me see if there's a question

1398
00:57:51,839 --> 00:57:54,380
first

1399
00:57:56,339 --> 00:57:58,020
yes

1400
00:57:58,020 --> 00:57:59,540
so

1401
00:57:59,540 --> 00:58:02,359
this correlations

1402
00:58:02,359 --> 00:58:05,460
how strong of an assumption is that on

1403
00:58:05,460 --> 00:58:06,380
uh

1404
00:58:06,380 --> 00:58:13,280
is that it would be meter than foreign

1405
00:58:16,520 --> 00:58:19,440
to Collision resistance

1406
00:58:19,440 --> 00:58:21,720
um you know in this case it's not that

1407
00:58:21,720 --> 00:58:23,339
strong because we can base it on sis

1408
00:58:23,339 --> 00:58:25,920
which is a pretty mild assumption

1409
00:58:25,920 --> 00:58:30,119
um but yeah in general I mean it seemed

1410
00:58:30,119 --> 00:58:31,680
three years ago that correlation

1411
00:58:31,680 --> 00:58:33,839
attractability was completely you know

1412
00:58:33,839 --> 00:58:37,200
very difficult to obtain but now now we

1413
00:58:37,200 --> 00:58:39,660
know that we can get it from pretty mild

1414
00:58:39,660 --> 00:58:42,200
assumptions

1415
00:58:47,960 --> 00:58:51,299
right so it's for it's for a class of

1416
00:58:51,299 --> 00:58:53,640
circuits uh in this case right so the

1417
00:58:53,640 --> 00:58:54,900
correlation and tractability is for

1418
00:58:54,900 --> 00:58:58,260
class of size s circuits and the way it

1419
00:58:58,260 --> 00:59:00,299
goes is the adversary picks a circuit

1420
00:59:00,299 --> 00:59:01,559
from that class

1421
00:59:01,559 --> 00:59:04,380
is given a random hash key and cannot

1422
00:59:04,380 --> 00:59:07,079
make h of alpha equals c of alpha

1423
00:59:07,079 --> 00:59:10,500
yeah yeah exactly if it's just for a

1424
00:59:10,500 --> 00:59:12,119
single circuit it's trivial to achieve

1425
00:59:12,119 --> 00:59:15,359
then it's not interesting yeah

1426
00:59:15,359 --> 00:59:19,200
so so final thoughts on uh CI hatching

1427
00:59:19,200 --> 00:59:21,359
um in the security proof that I outlined

1428
00:59:21,359 --> 00:59:24,420
the hash key is hiding uh a trap door

1429
00:59:24,420 --> 00:59:26,760
that's right it's holding a hiding a

1430
00:59:26,760 --> 00:59:29,460
secret key that homomorphically lets us

1431
00:59:29,460 --> 00:59:31,980
compute the fooling challenge of the

1432
00:59:31,980 --> 00:59:34,020
zero knowledge protocol

1433
00:59:34,020 --> 00:59:36,140
okay so it allows us to kind of

1434
00:59:36,140 --> 00:59:39,119
decrypt this Alpha and and compute the

1435
00:59:39,119 --> 00:59:41,339
fooling Challenge and uh what's

1436
00:59:41,339 --> 00:59:43,140
interesting is this is another example

1437
00:59:43,140 --> 00:59:46,380
of uh homomorphic computation of a

1438
00:59:46,380 --> 00:59:48,660
decryption function which was originally

1439
00:59:48,660 --> 00:59:50,400
showing up in the the classic

1440
00:59:50,400 --> 00:59:54,240
bootstrapping uh fhe technique so here's

1441
00:59:54,240 --> 00:59:57,299
another appearance of that kind of idea

1442
00:59:57,299 --> 00:59:59,460
uh the other thing in this construction

1443
00:59:59,460 --> 01:00:02,040
there is hidden data right the the

1444
01:00:02,040 --> 01:00:04,920
circuit is sort of hidden inside the

1445
01:00:04,920 --> 01:00:06,059
hash key

1446
01:00:06,059 --> 01:00:08,760
and we homomorphically compute that

1447
01:00:08,760 --> 01:00:11,099
circuit you know under the covers but

1448
01:00:11,099 --> 01:00:13,579
it's somehow never opened which is weird

1449
01:00:13,579 --> 01:00:16,140
but uh the correlation intractability

1450
01:00:16,140 --> 01:00:18,180
says that just breaking correlation

1451
01:00:18,180 --> 01:00:20,880
interactability makes the outer value

1452
01:00:20,880 --> 01:00:23,160
equal the inner value and this itself is

1453
01:00:23,160 --> 01:00:25,980
is infeasible to do so you never have to

1454
01:00:25,980 --> 01:00:27,599
actually decrypt anything in this

1455
01:00:27,599 --> 01:00:28,980
Construction

1456
01:00:28,980 --> 01:00:31,740
so that's the cancellation

1457
01:00:31,740 --> 01:00:33,540
um and then I'll wrap up with just a

1458
01:00:33,540 --> 01:00:35,400
couple more mentions of uh or maybe more

1459
01:00:35,400 --> 01:00:37,440
than a couple other applications of

1460
01:00:37,440 --> 01:00:39,599
these ideas that you can get by applying

1461
01:00:39,599 --> 01:00:41,819
the central equation uh in a different

1462
01:00:41,819 --> 01:00:44,819
ways so attribute based encryption uh

1463
01:00:44,819 --> 01:00:46,559
there's homomorphic computation here but

1464
01:00:46,559 --> 01:00:48,599
it's on public attributes and public

1465
01:00:48,599 --> 01:00:51,359
policies so there's nothing hidden going

1466
01:00:51,359 --> 01:00:54,480
on but whether you can decrypt or not is

1467
01:00:54,480 --> 01:00:57,240
related to the public evaluation of

1468
01:00:57,240 --> 01:00:59,160
these computations

1469
01:00:59,160 --> 01:01:01,740
uh predicate encryption actually does

1470
01:01:01,740 --> 01:01:04,859
find the attributes and there's two

1471
01:01:04,859 --> 01:01:06,900
layers so there's

1472
01:01:06,900 --> 01:01:08,819
encrypted attributes which are public

1473
01:01:08,819 --> 01:01:10,380
and those are computed on

1474
01:01:10,380 --> 01:01:12,720
homomorphically and then anyway it's

1475
01:01:12,720 --> 01:01:15,859
very very complicated and clever

1476
01:01:15,859 --> 01:01:18,540
but again homomorphic computation on

1477
01:01:18,540 --> 01:01:21,299
public attributes for the homomorphic

1478
01:01:21,299 --> 01:01:23,160
signatures again these are doing

1479
01:01:23,160 --> 01:01:24,839
homomorphic computation but again it's

1480
01:01:24,839 --> 01:01:26,819
on the public sign to data there's no

1481
01:01:26,819 --> 01:01:30,180
secret data that's uh being homologous

1482
01:01:30,180 --> 01:01:32,040
computed on

1483
01:01:32,040 --> 01:01:34,440
um and then there are prfs which are

1484
01:01:34,440 --> 01:01:36,240
privately constrained and again they're

1485
01:01:36,240 --> 01:01:37,740
someone worth a computation on the

1486
01:01:37,740 --> 01:01:40,680
public prf inputs according to a policy

1487
01:01:40,680 --> 01:01:42,000
of whether you should be able to

1488
01:01:42,000 --> 01:01:45,000
evaluate or not evaluate the prf at this

1489
01:01:45,000 --> 01:01:45,900
input

1490
01:01:45,900 --> 01:01:48,480
okay and then uh your next great idea

1491
01:01:48,480 --> 01:01:50,700
we'll also use this because now you know

1492
01:01:50,700 --> 01:01:52,859
how it's done okay so thank you for your

1493
01:01:52,859 --> 01:01:56,540
attention and uh let's have lunch

1494
01:02:02,099 --> 01:02:03,540
thank you Chris

1495
01:02:03,540 --> 01:02:06,059
um well Chris asked throughout the talk

1496
01:02:06,059 --> 01:02:08,099
either questions but let's see if there

1497
01:02:08,099 --> 01:02:10,880
is questions now

1498
01:02:14,579 --> 01:02:17,420
yes

1499
01:02:21,680 --> 01:02:24,559
applications

1500
01:02:24,559 --> 01:02:30,859
yes yeah so I'm uh Slide Away back here

1501
01:02:31,200 --> 01:02:32,940
um yeah we did it in about a quarter of

1502
01:02:32,940 --> 01:02:35,640
a slide right here right yeah so this

1503
01:02:35,640 --> 01:02:38,819
blue this blue tells you yeah so I think

1504
01:02:38,819 --> 01:02:40,740
this I think the central equation is

1505
01:02:40,740 --> 01:02:43,260
strong enough to uh give you all the

1506
01:02:43,260 --> 01:02:45,240
applications I mentioned if you just set

1507
01:02:45,240 --> 01:02:48,979
up the matrices correctly

1508
01:02:53,420 --> 01:02:56,040
in some in some sense I think so yeah

1509
01:02:56,040 --> 01:02:58,380
and again this is this has always been

1510
01:02:58,380 --> 01:03:00,059
going on in the internals of the GSW

1511
01:03:00,059 --> 01:03:03,599
scheme it just took some uh time to

1512
01:03:03,599 --> 01:03:05,240
abstract and

1513
01:03:05,240 --> 01:03:09,359
extract these properties out uh so that

1514
01:03:09,359 --> 01:03:12,619
they can be modular

1515
01:03:26,839 --> 01:03:29,400
I also don't know how to spell parallel

1516
01:03:29,400 --> 01:03:32,059
Piper uh

1517
01:03:32,059 --> 01:03:35,579
p-a-r-e-l-l-e okay so ding right I lost

1518
01:03:35,579 --> 01:03:37,740
the spelling bee uh yeah I think that

1519
01:03:37,740 --> 01:03:40,619
with this you probably could could start

1520
01:03:40,619 --> 01:03:42,000
doing you know

1521
01:03:42,000 --> 01:03:43,260
um maybe you can do Anonymous

1522
01:03:43,260 --> 01:03:46,200
credentials using using uh this kind of

1523
01:03:46,200 --> 01:03:50,118
abstraction I hope so let's see

1524
01:03:51,720 --> 01:03:54,140
oh

1525
01:03:54,299 --> 01:03:55,980
the

1526
01:03:55,980 --> 01:03:58,920
proof sizes for the so

1527
01:03:58,920 --> 01:04:01,079
yeah the functional commitments

1528
01:04:01,079 --> 01:04:01,799
um

1529
01:04:01,799 --> 01:04:05,119
so it's not a snark actually uh because

1530
01:04:05,119 --> 01:04:07,500
uh it doesn't have

1531
01:04:07,500 --> 01:04:10,079
um uh knowledge uh we don't have

1532
01:04:10,079 --> 01:04:12,660
knowledge properties from this uh but it

1533
01:04:12,660 --> 01:04:15,299
is it's very related sounding to snargs

1534
01:04:15,299 --> 01:04:16,140
right

1535
01:04:16,140 --> 01:04:19,020
um so the proof here is just this uh

1536
01:04:19,020 --> 01:04:20,460
Matrix S

1537
01:04:20,460 --> 01:04:23,420
and the dimensions of this s the height

1538
01:04:23,420 --> 01:04:27,960
is uh linear in the length of X or the

1539
01:04:27,960 --> 01:04:29,040
input X

1540
01:04:29,040 --> 01:04:32,940
and the width of s is uh linear in the

1541
01:04:32,940 --> 01:04:34,559
output length of Y

1542
01:04:34,559 --> 01:04:36,900
so basically it's it's length of x times

1543
01:04:36,900 --> 01:04:41,700
length of Y uh in size so fairly big but

1544
01:04:41,700 --> 01:04:44,040
uh in but but independent of the

1545
01:04:44,040 --> 01:04:47,760
function complexity uh and so it's

1546
01:04:47,760 --> 01:04:51,500
smaller than the function in that sense

1547
01:04:54,839 --> 01:04:56,700
yes

1548
01:04:56,700 --> 01:04:58,759
um

1549
01:05:03,140 --> 01:05:06,240
can you bypass bootstrapping in an fhe

1550
01:05:06,240 --> 01:05:08,220
uh do you mean or

1551
01:05:08,220 --> 01:05:09,299
uh

1552
01:05:09,299 --> 01:05:11,460
oh yes yeah

1553
01:05:11,460 --> 01:05:12,480
yes

1554
01:05:12,480 --> 01:05:14,579
um almost all these applications that I

1555
01:05:14,579 --> 01:05:17,640
mentioned uh the detail in detail and

1556
01:05:17,640 --> 01:05:20,640
also all of these uh almost all of them

1557
01:05:20,640 --> 01:05:22,619
do not use bootstrapping or at least do

1558
01:05:22,619 --> 01:05:24,180
not need to

1559
01:05:24,180 --> 01:05:25,740
um I think that predicate encryption

1560
01:05:25,740 --> 01:05:28,500
arguably does have a bootstrapping like

1561
01:05:28,500 --> 01:05:32,160
operations going on uh but um the rest

1562
01:05:32,160 --> 01:05:34,920
of these don't don't really need it they

1563
01:05:34,920 --> 01:05:36,980
may benefit from it as an optimization

1564
01:05:36,980 --> 01:05:39,480
uh but they don't need it

1565
01:05:39,480 --> 01:05:41,819
in fact uh what I should say is a big

1566
01:05:41,819 --> 01:05:44,220
open problem is to get a bootstrapable

1567
01:05:44,220 --> 01:05:46,319
version of the central equation

1568
01:05:46,319 --> 01:05:49,079
because in many cases they don't need

1569
01:05:49,079 --> 01:05:51,240
bootstrapping but they from it and I

1570
01:05:51,240 --> 01:05:52,559
don't know how to introduce

1571
01:05:52,559 --> 01:05:53,940
bootstrapping into a lot of these

1572
01:05:53,940 --> 01:05:57,000
applications so that would be terrific

1573
01:05:57,000 --> 01:06:00,799
uh it would be very beneficial

1574
01:06:03,000 --> 01:06:04,380
good question

1575
01:06:04,380 --> 01:06:06,839
okay so I think now we're uh we're done

1576
01:06:06,839 --> 01:06:10,859
thanks thanks again Chris thank you all

1577
01:06:10,859 --> 01:06:13,578
nope

