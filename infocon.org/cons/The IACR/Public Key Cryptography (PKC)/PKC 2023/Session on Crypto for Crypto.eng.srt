1
00:00:01,280 --> 00:00:05,700
welcome to the crypto for crypto session

2
00:00:05,700 --> 00:00:08,400
um our first talk is on the paper uh

3
00:00:08,400 --> 00:00:11,099
craft composable Randomness beacons and

4
00:00:11,099 --> 00:00:13,740
output independent abort MPC from Time

5
00:00:13,740 --> 00:00:17,039
by Karsten Baum Bernardo David Rafael

6
00:00:17,039 --> 00:00:19,619
dowsley Ravi Kishore yes prabhu's

7
00:00:19,619 --> 00:00:22,680
Nielsen and Sabine Ochsner and Ravi

8
00:00:22,680 --> 00:00:25,880
Kishore is giving the talk

9
00:00:27,619 --> 00:00:32,759
can you hear me yeah uh myself I'm going

10
00:00:32,759 --> 00:00:35,660
to talk about craft

11
00:00:35,760 --> 00:00:37,920
um composable Randomness beacons and

12
00:00:37,920 --> 00:00:39,899
output independent about MPC from time

13
00:00:39,899 --> 00:00:42,300
this is a joint work with my co-authors

14
00:00:42,300 --> 00:00:47,059
custom Bernardo Raphael esper and Sabine

15
00:00:47,059 --> 00:00:49,320
agenda is as follows

16
00:00:49,320 --> 00:00:51,180
I'll introduce you to the refillable

17
00:00:51,180 --> 00:00:53,219
delay functions and time log puzzles

18
00:00:53,219 --> 00:00:54,739
and

19
00:00:54,739 --> 00:00:57,239
I'll talk about artist model of abstract

20
00:00:57,239 --> 00:01:00,239
composable time on which uh we built

21
00:01:00,239 --> 00:01:02,600
this protocols and then I talked about

22
00:01:02,600 --> 00:01:05,880
probable sequential computations in UC

23
00:01:05,880 --> 00:01:08,460
setting based on this I'll show you a

24
00:01:08,460 --> 00:01:11,420
couple of constructions for ucvdfs and

25
00:01:11,420 --> 00:01:14,220
publicly verifiable time lock puzzles

26
00:01:14,220 --> 00:01:18,360
and uh building on this uh building on

27
00:01:18,360 --> 00:01:21,000
these constructions I'll show you a

28
00:01:21,000 --> 00:01:23,400
couple of applications one is uh MPC

29
00:01:23,400 --> 00:01:25,320
with output independent about

30
00:01:25,320 --> 00:01:28,340
and um efficient unbiasable Randomness

31
00:01:28,340 --> 00:01:32,520
Beacon and I conclude with uh feature

32
00:01:32,520 --> 00:01:34,080
works

33
00:01:34,080 --> 00:01:37,140
okay so what is a PDF uh PDF is a

34
00:01:37,140 --> 00:01:38,119
function

35
00:01:38,119 --> 00:01:40,799
and its output is generated only after

36
00:01:40,799 --> 00:01:42,540
performing a certain number of

37
00:01:42,540 --> 00:01:44,759
computational steps

38
00:01:44,759 --> 00:01:46,979
and that means there is a delay is

39
00:01:46,979 --> 00:01:50,340
involved and moreover uh this PDF along

40
00:01:50,340 --> 00:01:53,040
with the output it produces a proof and

41
00:01:53,040 --> 00:01:55,979
this proof can be to disprove guarantees

42
00:01:55,979 --> 00:01:58,200
that to get the output a certain number

43
00:01:58,200 --> 00:02:00,740
of competition ships have been performed

44
00:02:00,740 --> 00:02:05,520
and moreover with this proof we can

45
00:02:05,520 --> 00:02:08,780
essentially check whether this

46
00:02:08,780 --> 00:02:10,818
computation

47
00:02:10,818 --> 00:02:13,200
this output we got after performing

48
00:02:13,200 --> 00:02:15,900
these many competitions is independent

49
00:02:15,900 --> 00:02:19,160
of the number of steps

50
00:02:21,739 --> 00:02:24,780
primitive which allows uh encrypting a

51
00:02:24,780 --> 00:02:26,640
message to the Future

52
00:02:26,640 --> 00:02:30,300
so to construct these uh Primitives we

53
00:02:30,300 --> 00:02:32,340
need a computational task that must be

54
00:02:32,340 --> 00:02:35,280
executed in sequential steps taking at

55
00:02:35,280 --> 00:02:37,500
least some time

56
00:02:37,500 --> 00:02:40,560
so in RSW 96

57
00:02:40,560 --> 00:02:44,040
First Construction of TLP and which is

58
00:02:44,040 --> 00:02:46,680
uh based on iterated squaring

59
00:02:46,680 --> 00:02:49,019
uh your trading square is not elements

60
00:02:49,019 --> 00:02:51,120
from groups of unknown order

61
00:02:51,120 --> 00:02:54,120
let's see what it is exactly

62
00:02:54,120 --> 00:02:57,060
um let's say you start with n which is a

63
00:02:57,060 --> 00:02:59,459
product of two primes as in RSA key

64
00:02:59,459 --> 00:03:01,160
generation now you pick an element

65
00:03:01,160 --> 00:03:04,140
random element G from GN star

66
00:03:04,140 --> 00:03:06,120
if suppose if you want to compute the G

67
00:03:06,120 --> 00:03:07,920
to the power of 2 to the power of T then

68
00:03:07,920 --> 00:03:09,720
you need to perform T sequential

69
00:03:09,720 --> 00:03:12,360
computations uh starting from z z g

70
00:03:12,360 --> 00:03:14,700
Square g g to the power of 2 power 2 G

71
00:03:14,700 --> 00:03:16,980
to the power of 2 power 3 and so on G to

72
00:03:16,980 --> 00:03:19,440
the power of two power t

73
00:03:19,440 --> 00:03:20,040
um

74
00:03:20,040 --> 00:03:23,819
and uh so notice that suppose you know

75
00:03:23,819 --> 00:03:25,680
the order of the group which is pi of n

76
00:03:25,680 --> 00:03:29,220
then you can perform uh you can compute

77
00:03:29,220 --> 00:03:31,280
G to the power of two power T much

78
00:03:31,280 --> 00:03:33,720
faster than T sequential computations

79
00:03:33,720 --> 00:03:36,480
because uh G Port 2 power T is nothing

80
00:03:36,480 --> 00:03:38,819
but G to the power of 2 power T mod Pi

81
00:03:38,819 --> 00:03:40,260
of n

82
00:03:40,260 --> 00:03:43,560
okay so under this assumption uh what

83
00:03:43,560 --> 00:03:45,420
how how do you construct time log puzzle

84
00:03:45,420 --> 00:03:47,940
so time Block Puzzle is nothing but B

85
00:03:47,940 --> 00:03:49,739
and then M times G to the power of 2

86
00:03:49,739 --> 00:03:51,000
power t

87
00:03:51,000 --> 00:03:54,060
uh once uh once you compute G to the

88
00:03:54,060 --> 00:03:55,980
power of 2 power D then you can find the

89
00:03:55,980 --> 00:03:58,799
inverse uh and you multiply due to the

90
00:03:58,799 --> 00:04:00,360
power of 2 probability inverse with M

91
00:04:00,360 --> 00:04:01,920
times e to the power of 2 power T and

92
00:04:01,920 --> 00:04:05,119
then you get back the message m

93
00:04:06,120 --> 00:04:08,940
so that's the first construction uh what

94
00:04:08,940 --> 00:04:11,220
are our contributions uh

95
00:04:11,220 --> 00:04:12,439
um

96
00:04:12,439 --> 00:04:17,220
uh you see a treatment of verifiability

97
00:04:17,220 --> 00:04:18,478
of the functions we give the definition

98
00:04:18,478 --> 00:04:20,940
and then matching construction and same

99
00:04:20,940 --> 00:04:23,940
goes with uh pvtl publicly verifiable

100
00:04:23,940 --> 00:04:26,520
time lock puzzles as well and then a

101
00:04:26,520 --> 00:04:29,280
couple of uh a few of a few applications

102
00:04:29,280 --> 00:04:32,400
uh based on this Primitives that's uh

103
00:04:32,400 --> 00:04:35,400
one is UC MPC with output independent

104
00:04:35,400 --> 00:04:38,820
about and you see MPC with punishable

105
00:04:38,820 --> 00:04:41,220
output independent about

106
00:04:41,220 --> 00:04:44,460
and uh efficient Randomness Beacon

107
00:04:44,460 --> 00:04:46,259
protocol

108
00:04:46,259 --> 00:04:49,919
okay so related Works uh a few Works

109
00:04:49,919 --> 00:04:52,380
exist on uh modeling cloud

110
00:04:52,380 --> 00:04:54,840
functionalities in the first two Works

111
00:04:54,840 --> 00:04:57,840
uh model the wall clocks where

112
00:04:57,840 --> 00:04:59,220
functional where parties and

113
00:04:59,220 --> 00:05:00,600
functionalities can ask for the current

114
00:05:00,600 --> 00:05:03,000
current time so whereas in the last work

115
00:05:03,000 --> 00:05:06,780
uh which is uh we follow as well where

116
00:05:06,780 --> 00:05:09,300
functionalities can ask only if a Time

117
00:05:09,300 --> 00:05:12,000
unit has passed

118
00:05:12,000 --> 00:05:15,600
and moreover the Standalone time lock

119
00:05:15,600 --> 00:05:18,139
puzzles and vdfs have been constructed

120
00:05:18,139 --> 00:05:22,199
uh of course which are not uh UC

121
00:05:22,199 --> 00:05:23,460
composable

122
00:05:23,460 --> 00:05:28,199
and non-reliable time log puzzles too

123
00:05:28,199 --> 00:05:28,919
um

124
00:05:28,919 --> 00:05:33,320
building on this time lock puzzles

125
00:05:33,320 --> 00:05:35,940
protocols exist for partial fairness for

126
00:05:35,940 --> 00:05:37,740
2pc

127
00:05:37,740 --> 00:05:40,860
over like again no Comfort no composable

128
00:05:40,860 --> 00:05:43,020
guarantees for any of this except Tardis

129
00:05:43,020 --> 00:05:46,800
work Tardis first introduced uctlps and

130
00:05:46,800 --> 00:05:50,360
and presented an application to PC with

131
00:05:50,360 --> 00:05:52,500
application for two PC with output

132
00:05:52,500 --> 00:05:54,300
independent abort

133
00:05:54,300 --> 00:05:58,560
okay so uh what is start this model in

134
00:05:58,560 --> 00:06:00,660
the studies model there is no Global

135
00:06:00,660 --> 00:06:03,419
clock but in its in place of global

136
00:06:03,419 --> 00:06:05,780
clock we have a global ticker where

137
00:06:05,780 --> 00:06:08,699
functionalities can ask the a global

138
00:06:08,699 --> 00:06:10,440
ticker whether a new tick has happened

139
00:06:10,440 --> 00:06:12,539
since the elastic that means whether a

140
00:06:12,539 --> 00:06:14,699
Time unit has passed or not

141
00:06:14,699 --> 00:06:17,400
and then in response Global Response

142
00:06:17,400 --> 00:06:20,220
with yes and new tick has happened or no

143
00:06:20,220 --> 00:06:22,620
still in the same time unit

144
00:06:22,620 --> 00:06:26,160
and whereas the parties just observe the

145
00:06:26,160 --> 00:06:27,960
events from the functionalities

146
00:06:27,960 --> 00:06:30,360
uh if suppose they have to if suppose

147
00:06:30,360 --> 00:06:31,440
they are get activated by the

148
00:06:31,440 --> 00:06:33,720
functionality then before doing that you

149
00:06:33,720 --> 00:06:36,300
just acknowledges the global ticker that

150
00:06:36,300 --> 00:06:38,460
it got activated by the functionality

151
00:06:38,460 --> 00:06:42,720
but in response uh parties don't get any

152
00:06:42,720 --> 00:06:44,520
information about how many tics has

153
00:06:44,520 --> 00:06:47,759
passed whether that has passed or not

154
00:06:47,759 --> 00:06:49,759
that's the

155
00:06:49,759 --> 00:06:52,440
Tardis model for artist model of

156
00:06:52,440 --> 00:06:55,380
composable time

157
00:06:55,380 --> 00:06:58,199
um so now in this setting uh I'll show

158
00:06:58,199 --> 00:07:00,960
you how we model the probable sequential

159
00:07:00,960 --> 00:07:03,259
computations

160
00:07:03,259 --> 00:07:06,780
this functionality of PSE which is pse's

161
00:07:06,780 --> 00:07:08,580
probable sequential computations this

162
00:07:08,580 --> 00:07:10,620
captures the notion of generic

163
00:07:10,620 --> 00:07:15,840
Standalone trapdoor vdfs so FPC fpsc

164
00:07:15,840 --> 00:07:18,120
allows both comp Computing and verifying

165
00:07:18,120 --> 00:07:22,319
sequential proofs okay fpsc has

166
00:07:22,319 --> 00:07:24,319
four uh

167
00:07:24,319 --> 00:07:27,780
blobs at one state table salt solve and

168
00:07:27,780 --> 00:07:30,419
verify and then parties can ask so

169
00:07:30,419 --> 00:07:33,900
present the from initial State st0 and

170
00:07:33,900 --> 00:07:35,280
then solve it for take computational

171
00:07:35,280 --> 00:07:38,940
steps it can ask for uh solve and then

172
00:07:38,940 --> 00:07:41,099
when party or adversely asks for solved

173
00:07:41,099 --> 00:07:42,539
that will be added to the list of

174
00:07:42,539 --> 00:07:46,020
puzzles being solved and then in the say

175
00:07:46,020 --> 00:07:48,960
I minus one I minus one to take parties

176
00:07:48,960 --> 00:07:52,319
are parties are adversary asks for

177
00:07:52,319 --> 00:07:54,300
advanced take this it will be Advanced

178
00:07:54,300 --> 00:07:57,479
only in the next take

179
00:07:57,479 --> 00:07:59,880
um see there is an Epsilon parameter

180
00:07:59,880 --> 00:08:02,639
which which we allow for adversary to

181
00:08:02,639 --> 00:08:05,520
get this let's say yeah adversely may be

182
00:08:05,520 --> 00:08:08,699
a little powerful than the a honest part

183
00:08:08,699 --> 00:08:11,460
is so that is why if I is Epsilon time T

184
00:08:11,460 --> 00:08:13,979
that means uh by Epsilon times T

185
00:08:13,979 --> 00:08:16,259
adversity will get the yes after

186
00:08:16,259 --> 00:08:18,240
Computing these T mini steps what would

187
00:08:18,240 --> 00:08:20,039
be the final state that gets is that is

188
00:08:20,039 --> 00:08:23,819
stt and then get the proof whereas uh

189
00:08:23,819 --> 00:08:28,500
parties must wait until the uh tier the

190
00:08:28,500 --> 00:08:31,259
sequential step happens then only a

191
00:08:31,259 --> 00:08:34,380
party gets a final State STD and then

192
00:08:34,380 --> 00:08:35,940
proof pi

193
00:08:35,940 --> 00:08:38,399
uh however there is a Blog for the

194
00:08:38,399 --> 00:08:41,039
trapdosol suppose they are

195
00:08:41,039 --> 00:08:43,140
um somebody who's having trapped over

196
00:08:43,140 --> 00:08:44,880
from the

197
00:08:44,880 --> 00:08:45,660
um

198
00:08:45,660 --> 00:08:49,140
uh somebody who's having the trapdoor uh

199
00:08:49,140 --> 00:08:51,600
trap door from uh trapdoor can starting

200
00:08:51,600 --> 00:08:54,300
from the st0 in t steps directly gets

201
00:08:54,300 --> 00:08:57,120
the final State and then proof pi

202
00:08:57,120 --> 00:09:00,899
so also this uh there is a verify

203
00:09:00,899 --> 00:09:02,279
interface as well in the verify

204
00:09:02,279 --> 00:09:04,860
interface when party asks for verified

205
00:09:04,860 --> 00:09:07,140
gives the proof this is the initial

206
00:09:07,140 --> 00:09:09,480
state after T steps this is the state

207
00:09:09,480 --> 00:09:11,519
sdt and then this is the proof if you

208
00:09:11,519 --> 00:09:14,459
want to verify that then suppose it

209
00:09:14,459 --> 00:09:17,000
verification takes G of T time units

210
00:09:17,000 --> 00:09:19,940
then after G of T time units

211
00:09:19,940 --> 00:09:23,339
this functionality outputs a bit B where

212
00:09:23,339 --> 00:09:27,240
uh with ACS this is valid proof or if B

213
00:09:27,240 --> 00:09:29,399
is one yes this is valid proof otherwise

214
00:09:29,399 --> 00:09:33,240
no this is invalid okay let's see our

215
00:09:33,240 --> 00:09:36,540
vdf construction based on this

216
00:09:36,540 --> 00:09:39,540
um so now you start with a random state

217
00:09:39,540 --> 00:09:42,000
st0 from State space and then you set

218
00:09:42,000 --> 00:09:45,360
your input as st0 and then now you you

219
00:09:45,360 --> 00:09:48,060
query the fpsc to solve this from

220
00:09:48,060 --> 00:09:50,399
starting State SD naught then fpsc after

221
00:09:50,399 --> 00:09:54,360
T steps it outputs uh spp and then Pi

222
00:09:54,360 --> 00:09:57,000
okay so once this is ready you set your

223
00:09:57,000 --> 00:10:00,839
output as a hash of final State and then

224
00:10:00,839 --> 00:10:01,800
proof

225
00:10:01,800 --> 00:10:04,680
uh proof which you got from fpsc and

226
00:10:04,680 --> 00:10:08,040
then you set the proof of a vdf as uh S3

227
00:10:08,040 --> 00:10:10,560
Pi STP and then the original proof you

228
00:10:10,560 --> 00:10:12,480
got from

229
00:10:12,480 --> 00:10:14,760
um you know fpsc so how do you verify

230
00:10:14,760 --> 00:10:16,920
this now once we have the output and

231
00:10:16,920 --> 00:10:18,839
then proof you want to verify whether

232
00:10:18,839 --> 00:10:20,880
this is uh computed after certain number

233
00:10:20,880 --> 00:10:23,700
of steps then you pass your proof as St

234
00:10:23,700 --> 00:10:28,560
80 and then pi now compute uh a hash

235
00:10:28,560 --> 00:10:31,640
that is output Prime which is a hash of

236
00:10:31,640 --> 00:10:36,060
T HTT and Pi now you see you already

237
00:10:36,060 --> 00:10:37,620
have the original output and then check

238
00:10:37,620 --> 00:10:39,180
what would be the hash you got both are

239
00:10:39,180 --> 00:10:41,160
matching or not if matching then s

240
00:10:41,160 --> 00:10:43,260
that's the correct

241
00:10:43,260 --> 00:10:46,680
correct output otherwise if you say that

242
00:10:46,680 --> 00:10:49,200
okay so that's the video of construction

243
00:10:49,200 --> 00:10:53,040
and then now uh let's see how to

244
00:10:53,040 --> 00:10:56,579
construct pvtlp

245
00:10:58,320 --> 00:11:01,800
um here again some random state from

246
00:11:01,800 --> 00:11:04,700
State space now

247
00:11:04,700 --> 00:11:07,440
because it's the owner who is creating

248
00:11:07,440 --> 00:11:09,839
the time log puzzle you simply send tap

249
00:11:09,839 --> 00:11:12,420
those all St 0 to fpsc and then you

250
00:11:12,420 --> 00:11:14,160
immediately get the final State and then

251
00:11:14,160 --> 00:11:16,500
prove now you compute the hash of all

252
00:11:16,500 --> 00:11:17,279
this

253
00:11:17,279 --> 00:11:19,620
and then that is call it H1 and then you

254
00:11:19,620 --> 00:11:22,019
compute a tag which is uh xor of this

255
00:11:22,019 --> 00:11:25,140
previous hash and this message now hash

256
00:11:25,140 --> 00:11:28,860
everything you get the the let's say

257
00:11:28,860 --> 00:11:31,040
call it H2 which acts as a

258
00:11:31,040 --> 00:11:33,899
commitment for these values now you

259
00:11:33,899 --> 00:11:35,820
output your TLP as

260
00:11:35,820 --> 00:11:38,880
t 0 and tag one tag two

261
00:11:38,880 --> 00:11:40,860
so now suppose somebody wants to solve

262
00:11:40,860 --> 00:11:44,100
this time log puzzle so then like you

263
00:11:44,100 --> 00:11:46,079
have an outcome like puzzle St 0 to add

264
00:11:46,079 --> 00:11:47,459
one tag two now if you want to solve

265
00:11:47,459 --> 00:11:49,980
this what do you do you simply compute

266
00:11:49,980 --> 00:11:53,940
uh stt sequentially from st0 and then

267
00:11:53,940 --> 00:11:55,800
get the proof because your PSC outputs

268
00:11:55,800 --> 00:11:58,500
proof as well now and then you compute

269
00:11:58,500 --> 00:12:01,800
hash of as usual here you compute hash

270
00:12:01,800 --> 00:12:04,200
of all these values and then now extract

271
00:12:04,200 --> 00:12:07,920
the message M which is uh uh tag one xor

272
00:12:07,920 --> 00:12:10,380
with H1 now you compute H2 because you

273
00:12:10,380 --> 00:12:12,839
already have now proof and then tag one

274
00:12:12,839 --> 00:12:14,459
and then message as well

275
00:12:14,459 --> 00:12:16,440
and then see if it is matching with the

276
00:12:16,440 --> 00:12:19,019
tag two if it matches then output

277
00:12:19,019 --> 00:12:22,440
message otherwise it's an invalid time

278
00:12:22,440 --> 00:12:23,760
log puzzle

279
00:12:23,760 --> 00:12:27,140
so how do you verify suppose somebody's

280
00:12:27,140 --> 00:12:30,560
gives you the message and then proof

281
00:12:30,560 --> 00:12:33,540
contained in this message content in

282
00:12:33,540 --> 00:12:36,000
this PL TLP if you want to verify then

283
00:12:36,000 --> 00:12:40,200
how do you do that you pass your TLP st0

284
00:12:40,200 --> 00:12:42,779
tag one tag to do and then because now

285
00:12:42,779 --> 00:12:44,399
you know the final State and then prove

286
00:12:44,399 --> 00:12:47,700
you can directly get the

287
00:12:47,700 --> 00:12:49,800
um you can you can you can directly find

288
00:12:49,800 --> 00:12:50,959
out the

289
00:12:50,959 --> 00:12:55,260
final state sdt from proof pi and then

290
00:12:55,260 --> 00:12:58,980
you follow the steps from two to five of

291
00:12:58,980 --> 00:13:02,120
the solve procedure

292
00:13:02,339 --> 00:13:04,920
yeah so what are the applications now

293
00:13:04,920 --> 00:13:07,740
you you know you have uh you know how to

294
00:13:07,740 --> 00:13:10,620
construct uh pvt LPS

295
00:13:10,620 --> 00:13:13,139
so one application is output independent

296
00:13:13,139 --> 00:13:15,120
about MPC

297
00:13:15,120 --> 00:13:16,980
um what is output independent about MPC

298
00:13:16,980 --> 00:13:18,720
the adversary if adversary decide to

299
00:13:18,720 --> 00:13:22,139
abort it must decide before learning the

300
00:13:22,139 --> 00:13:24,600
output of the MPC protocol how do we do

301
00:13:24,600 --> 00:13:26,880
how do we do that

302
00:13:26,880 --> 00:13:30,060
um so you do MPC protocol as usual uh

303
00:13:30,060 --> 00:13:32,940
till the last round but before sending

304
00:13:32,940 --> 00:13:34,800
the last message what you do what you do

305
00:13:34,800 --> 00:13:37,440
is you put that message last message in

306
00:13:37,440 --> 00:13:41,100
the TLP now

307
00:13:41,839 --> 00:13:44,880
like every part in our sense these

308
00:13:44,880 --> 00:13:46,560
outputs to the other parties now you

309
00:13:46,560 --> 00:13:48,300
expect uh

310
00:13:48,300 --> 00:13:50,160
um uh you expect to this if you're a

311
00:13:50,160 --> 00:13:52,139
honest party you expect to receive uh

312
00:13:52,139 --> 00:13:55,440
the other part is TLP before uh your TLP

313
00:13:55,440 --> 00:13:57,360
is solved if you don't receive then you

314
00:13:57,360 --> 00:14:01,440
know that uh about is detected

315
00:14:01,440 --> 00:14:05,339
so that's the one application of uh

316
00:14:05,339 --> 00:14:08,760
uh TLP and um

317
00:14:08,760 --> 00:14:11,700
let's move on to uh efficient Randomness

318
00:14:11,700 --> 00:14:16,019
beacons uh here also uh

319
00:14:16,019 --> 00:14:19,019
um protocol works as follows

320
00:14:19,019 --> 00:14:22,680
um all parties starts with some random

321
00:14:22,680 --> 00:14:25,320
number which they put in a time lock

322
00:14:25,320 --> 00:14:30,000
puzzle and then broadcast it now uh say

323
00:14:30,000 --> 00:14:32,760
I part is Randomness is RI and then you

324
00:14:32,760 --> 00:14:35,160
broadcast it and after broadcast delay

325
00:14:35,160 --> 00:14:36,860
all the parties

326
00:14:36,860 --> 00:14:39,620
reveal their Randomness and then

327
00:14:39,620 --> 00:14:43,639
trapdoor if suppose

328
00:14:47,300 --> 00:14:50,339
what you can do is because the TLP you

329
00:14:50,339 --> 00:14:54,240
compute uh you'll be able to compute uh

330
00:14:54,240 --> 00:14:56,100
you will be able to solve the time lock

331
00:14:56,100 --> 00:14:57,360
puzzle

332
00:14:57,360 --> 00:15:01,019
so once you solve the time log puzzle so

333
00:15:01,019 --> 00:15:02,579
look at look for the valid ones and then

334
00:15:02,579 --> 00:15:06,019
now we exalt all the values that is uh

335
00:15:06,019 --> 00:15:10,800
that is the output so

336
00:15:10,800 --> 00:15:13,560
um so yeah I mean that's the main idea

337
00:15:13,560 --> 00:15:18,600
suppose some party fails to uh open the

338
00:15:18,600 --> 00:15:21,139
TLP but uh

339
00:15:21,139 --> 00:15:23,940
you know that TLP can be solved after

340
00:15:23,940 --> 00:15:26,519
certain time units you just simply solve

341
00:15:26,519 --> 00:15:29,399
and then now eggs are all the valid uh

342
00:15:29,399 --> 00:15:33,240
messages from the time log puzzles

343
00:15:33,240 --> 00:15:36,839
and then you Excel you get the you exert

344
00:15:36,839 --> 00:15:40,220
all of this and you take it as output

345
00:15:40,220 --> 00:15:44,940
suppose some parties won't comply in

346
00:15:44,940 --> 00:15:47,040
sending the in opening their time log

347
00:15:47,040 --> 00:15:49,500
puzzles then we can impose Financial

348
00:15:49,500 --> 00:15:52,079
penalties

349
00:15:52,079 --> 00:15:53,040
um

350
00:15:53,040 --> 00:15:55,760
yeah so open questions

351
00:15:55,760 --> 00:15:59,220
we can try for we can look for UC

352
00:15:59,220 --> 00:16:02,360
compilers for fairness and efficient

353
00:16:02,360 --> 00:16:04,920
output independent about for generic

354
00:16:04,920 --> 00:16:06,899
functionalities also we can try to

355
00:16:06,899 --> 00:16:07,940
construct

356
00:16:07,940 --> 00:16:13,079
a home office uctlps and PDFs

357
00:16:13,079 --> 00:16:16,440
also we can look for uh applications in

358
00:16:16,440 --> 00:16:18,120
crypto space

359
00:16:18,120 --> 00:16:21,079
yeah thank you

360
00:16:25,380 --> 00:16:28,519
we have time for questions

361
00:16:32,279 --> 00:16:34,019
I was wondering if you can comment a

362
00:16:34,019 --> 00:16:35,880
little bit more on the implications for

363
00:16:35,880 --> 00:16:39,839
rational MPC yeah so now

364
00:16:39,839 --> 00:16:41,699
um

365
00:16:41,699 --> 00:16:45,420
for example like look at this protocol

366
00:16:45,420 --> 00:16:46,279
um

367
00:16:46,279 --> 00:16:52,399
after uh sending the TLP you can expect

368
00:16:52,399 --> 00:16:55,440
immediately all the parties to open time

369
00:16:55,440 --> 00:16:57,120
lock puzzles like by providing the

370
00:16:57,120 --> 00:16:59,699
trapdoor you suppose some parties are

371
00:16:59,699 --> 00:17:01,759
not providing then you can impose uh

372
00:17:01,759 --> 00:17:05,099
Financial penalities so

373
00:17:05,099 --> 00:17:06,660
um

374
00:17:06,660 --> 00:17:08,640
um if computation is taking too much

375
00:17:08,640 --> 00:17:11,459
time then you can adjust parameters

376
00:17:11,459 --> 00:17:13,859
accordingly

377
00:17:13,859 --> 00:17:15,959
um so if it is a rational adversary then

378
00:17:15,959 --> 00:17:18,419
there is no incentive to cheat so

379
00:17:18,419 --> 00:17:21,780
adversary behaves as honestly and then

380
00:17:21,780 --> 00:17:24,900
immediately tries to open the uh time

381
00:17:24,900 --> 00:17:29,120
lock puzzle by providing the trapdoor

382
00:17:30,540 --> 00:17:34,140
thanks any other questions

383
00:17:34,140 --> 00:17:37,640
right well let's thank the speaker

384
00:17:41,340 --> 00:17:42,419
um

385
00:17:42,419 --> 00:17:46,700
so next up Daniel is paper 24.

386
00:18:05,400 --> 00:18:06,539
all right

387
00:18:06,539 --> 00:18:07,500
um

388
00:18:07,500 --> 00:18:09,600
so the next talk is on the paper

389
00:18:09,600 --> 00:18:11,340
efficient and universally composable

390
00:18:11,340 --> 00:18:13,559
single secret leader election from

391
00:18:13,559 --> 00:18:16,860
parents by Dario catalani catalana Daria

392
00:18:16,860 --> 00:18:19,740
Fiore and Emilia Emmanuel giunta and

393
00:18:19,740 --> 00:18:22,940
emmanuelli will give the talk

394
00:18:30,960 --> 00:18:33,380
thank you

395
00:18:37,860 --> 00:18:40,980
does it work yeah sounds better so

396
00:18:40,980 --> 00:18:43,380
welcome everyone I'm American and today

397
00:18:43,380 --> 00:18:45,539
I will present uh this paper is a joint

398
00:18:45,539 --> 00:18:47,360
work with Professor letter catarano and

399
00:18:47,360 --> 00:18:51,059
professori uh from Catania I'm India

400
00:18:51,059 --> 00:18:53,820
from Madrid so

401
00:18:53,820 --> 00:18:55,559
um today I will be talking about uh

402
00:18:55,559 --> 00:18:57,780
leader election protocols and to give

403
00:18:57,780 --> 00:19:00,059
some motivation uh the reason we studied

404
00:19:00,059 --> 00:19:01,799
interaction protocol is because they are

405
00:19:01,799 --> 00:19:03,720
a way to achieve consensus in blockchain

406
00:19:03,720 --> 00:19:06,179
so for instance uh when we elect a

407
00:19:06,179 --> 00:19:07,380
leader in blockchain in motion

408
00:19:07,380 --> 00:19:09,240
application the leader is the one who is

409
00:19:09,240 --> 00:19:11,460
supposed to post for instance Block in a

410
00:19:11,460 --> 00:19:14,340
chain and let everybody agree on the

411
00:19:14,340 --> 00:19:16,679
content of the chain at this moment

412
00:19:16,679 --> 00:19:18,780
now since the leader is a very important

413
00:19:18,780 --> 00:19:21,120
role in keeping the protocol alive it is

414
00:19:21,120 --> 00:19:23,520
important that when we elect a leader we

415
00:19:23,520 --> 00:19:26,460
keep it secret in such a way that it is

416
00:19:26,460 --> 00:19:28,380
impeasable for anniversary to maybe

417
00:19:28,380 --> 00:19:30,720
perform a DDOS attack on the leader and

418
00:19:30,720 --> 00:19:32,700
block the protocol execution

419
00:19:32,700 --> 00:19:34,860
so for this reason uh secretly Direction

420
00:19:34,860 --> 00:19:36,600
protocol actually deployed in practice

421
00:19:36,600 --> 00:19:39,480
but they have a drawback the fact that

422
00:19:39,480 --> 00:19:41,520
in many applications they are just

423
00:19:41,520 --> 00:19:43,500
probabilistic secret leader election

424
00:19:43,500 --> 00:19:45,000
protocols

425
00:19:45,000 --> 00:19:47,520
so this means that the protocol is

426
00:19:47,520 --> 00:19:49,980
divided in three phases at first there

427
00:19:49,980 --> 00:19:52,620
is a protocol to elect the leader uh in

428
00:19:52,620 --> 00:19:54,000
practice you can think of this as

429
00:19:54,000 --> 00:19:56,400
choosing around put a random inputs and

430
00:19:56,400 --> 00:19:58,559
then user basically evaluates a vrf on

431
00:19:58,559 --> 00:20:00,900
these random inputs then there is a

432
00:20:00,900 --> 00:20:02,760
potential a phase in which many

433
00:20:02,760 --> 00:20:04,679
potential leaders are elected for

434
00:20:04,679 --> 00:20:06,419
instance those who have evaluated the

435
00:20:06,419 --> 00:20:09,179
function their own vrf and got for

436
00:20:09,179 --> 00:20:12,000
instance a very low uh outputs but they

437
00:20:12,000 --> 00:20:13,980
don't know yet they are the leader and

438
00:20:13,980 --> 00:20:15,480
finally revealing their own secret

439
00:20:15,480 --> 00:20:17,940
information uh parties understand who is

440
00:20:17,940 --> 00:20:19,500
the leader for instance the one who got

441
00:20:19,500 --> 00:20:22,320
the lowest vrf value and they've also

442
00:20:22,320 --> 00:20:23,700
collected only one leader of course

443
00:20:23,700 --> 00:20:25,320
because they can only be at most one

444
00:20:25,320 --> 00:20:28,860
smallest value on expectation uh so this

445
00:20:28,860 --> 00:20:30,720
is nice and it's very efficient because

446
00:20:30,720 --> 00:20:33,179
it's not interactive but it creates some

447
00:20:33,179 --> 00:20:36,419
issues for instance statistical Imports

448
00:20:36,419 --> 00:20:38,160
because if somebody doesn't receive the

449
00:20:38,160 --> 00:20:39,900
output of some leader some potential

450
00:20:39,900 --> 00:20:41,700
leader maybe you can think the winner is

451
00:20:41,700 --> 00:20:44,039
someone else uh and also create wasted

452
00:20:44,039 --> 00:20:46,380
effort uh because if uh all those

453
00:20:46,380 --> 00:20:47,880
potential leaders have to create the

454
00:20:47,880 --> 00:20:49,620
next block maybe they need to lose some

455
00:20:49,620 --> 00:20:51,299
proof of work and they need to waste

456
00:20:51,299 --> 00:20:52,980
computation to do that

457
00:20:52,980 --> 00:20:57,260
so for this reason in 2020 uh

458
00:20:57,260 --> 00:21:00,179
proposed a new primitive called single

459
00:21:00,179 --> 00:21:02,400
secret leader election but there can

460
00:21:02,400 --> 00:21:04,980
only be at most one leader uh for each

461
00:21:04,980 --> 00:21:06,780
election indeed

462
00:21:06,780 --> 00:21:08,760
um so this was proven to be harder to

463
00:21:08,760 --> 00:21:12,960
attack uh by azulian capital in 2021 uh

464
00:21:12,960 --> 00:21:14,760
and the only disadvantage so far is that

465
00:21:14,760 --> 00:21:17,460
there is a inefficiency gap with the

466
00:21:17,460 --> 00:21:19,380
probabilistic redirection now in this

467
00:21:19,380 --> 00:21:21,120
case uh more interaction is usually

468
00:21:21,120 --> 00:21:23,340
required

469
00:21:23,340 --> 00:21:25,320
um so just to be more formal and precise

470
00:21:25,320 --> 00:21:27,419
uh so in the case of single secret

471
00:21:27,419 --> 00:21:29,340
leader election we tackle basically

472
00:21:29,340 --> 00:21:31,140
three properties and we're defined in

473
00:21:31,140 --> 00:21:33,860
the first paper

474
00:21:33,860 --> 00:21:36,059
and this property are essentially

475
00:21:36,059 --> 00:21:38,520
uniqueness uh saying that for each

476
00:21:38,520 --> 00:21:41,400
election there can be at most One winner

477
00:21:41,400 --> 00:21:43,500
and notice that we cannot have precisely

478
00:21:43,500 --> 00:21:45,720
One winner because adversary can win and

479
00:21:45,720 --> 00:21:48,179
say uh and decide not to claim victory

480
00:21:48,179 --> 00:21:50,220
so we can have at most one leader but

481
00:21:50,220 --> 00:21:53,039
maybe none for some elections uh we want

482
00:21:53,039 --> 00:21:55,320
to have fairness meaning that all users

483
00:21:55,320 --> 00:21:56,820
have the same probability of winning one

484
00:21:56,820 --> 00:21:57,900
election

485
00:21:57,900 --> 00:21:59,580
and finally we want to have

486
00:21:59,580 --> 00:22:02,700
unpredictability meaning that uh before

487
00:22:02,700 --> 00:22:04,799
the leader decide to reveal uh she won

488
00:22:04,799 --> 00:22:07,260
the election uh there should be no way

489
00:22:07,260 --> 00:22:09,600
to guess uh who the leader is better

490
00:22:09,600 --> 00:22:12,539
than guessing at random

491
00:22:12,539 --> 00:22:14,700
unfortunately uh the only issue with the

492
00:22:14,700 --> 00:22:18,260
definition proposed by bonuses

493
00:22:18,260 --> 00:22:21,059
security May Fail if we compose the

494
00:22:21,059 --> 00:22:23,159
protocol concurrently with itself and

495
00:22:23,159 --> 00:22:24,659
actually in the paper we provide some

496
00:22:24,659 --> 00:22:26,880
situation in which this does happen so

497
00:22:26,880 --> 00:22:29,039
this is a concrete threat and for this

498
00:22:29,039 --> 00:22:31,260
reason uh we propose a UC secure

499
00:22:31,260 --> 00:22:33,059
definition so for those who are not

500
00:22:33,059 --> 00:22:35,340
familiar with the UC model we

501
00:22:35,340 --> 00:22:36,539
essentially provide an ideal

502
00:22:36,539 --> 00:22:38,039
functionality which describes which

503
00:22:38,039 --> 00:22:40,080
specifies how elections should be

504
00:22:40,080 --> 00:22:42,240
carried out uh for instance handling

505
00:22:42,240 --> 00:22:44,700
registrations for election for instance

506
00:22:44,700 --> 00:22:46,919
party can access the functionality to do

507
00:22:46,919 --> 00:22:48,360
an election and the functionality can

508
00:22:48,360 --> 00:22:50,460
privately tell one of those users that

509
00:22:50,460 --> 00:22:52,440
he won the election and when this user

510
00:22:52,440 --> 00:22:54,480
wants to claim victory this can

511
00:22:54,480 --> 00:22:55,860
communicate with the functionality and

512
00:22:55,860 --> 00:22:57,600
say I want to claim victory and the

513
00:22:57,600 --> 00:22:59,159
functionality convince everyone that

514
00:22:59,159 --> 00:23:00,900
this is indeed the winner

515
00:23:00,900 --> 00:23:02,580
and what we have to do is simply show

516
00:23:02,580 --> 00:23:04,679
that real protocol behaves in

517
00:23:04,679 --> 00:23:06,659
distinguishably from the ideal protocol

518
00:23:06,659 --> 00:23:09,720
up to simulating missing messages

519
00:23:09,720 --> 00:23:12,960
uh so prior to this work and also after

520
00:23:12,960 --> 00:23:15,960
uh this work was published on ePrint uh

521
00:23:15,960 --> 00:23:18,059
essentially we had only the game based

522
00:23:18,059 --> 00:23:20,280
uh early game based uh secured

523
00:23:20,280 --> 00:23:21,960
Construction in the first paper and

524
00:23:21,960 --> 00:23:24,419
there were three of them uh one based on

525
00:23:24,419 --> 00:23:26,580
in East initially obfuscation another

526
00:23:26,580 --> 00:23:28,860
one on threshold photographic encryption

527
00:23:28,860 --> 00:23:31,159
which are mostly theoretical interest

528
00:23:31,159 --> 00:23:33,659
although they have some nice feature and

529
00:23:33,659 --> 00:23:36,000
the most practical one was the one was a

530
00:23:36,000 --> 00:23:38,419
shuffling based solution based on ddh

531
00:23:38,419 --> 00:23:41,159
which has as a main drawback the fact

532
00:23:41,159 --> 00:23:43,500
that uh essentially each user is

533
00:23:43,500 --> 00:23:45,179
associated with hypertext and we need to

534
00:23:45,179 --> 00:23:47,280
permute this list so we have we have a

535
00:23:47,280 --> 00:23:49,140
high on chain costs we need to keep this

536
00:23:49,140 --> 00:23:51,000
list on chain for each election

537
00:23:51,000 --> 00:23:53,940
uh next many other improvements there on

538
00:23:53,940 --> 00:23:56,000
chain to the shuffle based construction

539
00:23:56,000 --> 00:23:58,679
essentially were published uh with a

540
00:23:58,679 --> 00:24:00,840
paper last year in podzi which improves

541
00:24:00,840 --> 00:24:02,760
this achieving UC security and adaptive

542
00:24:02,760 --> 00:24:04,620
security uh and there are other

543
00:24:04,620 --> 00:24:06,240
construction which for instance uh

544
00:24:06,240 --> 00:24:08,400
improved on uh presence managed to

545
00:24:08,400 --> 00:24:12,720
distribute the shuffle uh and and

546
00:24:12,720 --> 00:24:13,679
finally there is another construction

547
00:24:13,679 --> 00:24:16,020
that is based I don't think it works

548
00:24:16,020 --> 00:24:18,179
okay I reconstruction that it's based on

549
00:24:18,179 --> 00:24:20,100
NPC which is another advantage of having

550
00:24:20,100 --> 00:24:22,080
like very small on chain uh complexity

551
00:24:22,080 --> 00:24:24,120
so for verification we don't need to put

552
00:24:24,120 --> 00:24:26,220
many things on chain but it's very high

553
00:24:26,220 --> 00:24:27,900
on communication uh on of chain

554
00:24:27,900 --> 00:24:30,360
communication so our construction so the

555
00:24:30,360 --> 00:24:31,799
the main feature that it achieves is

556
00:24:31,799 --> 00:24:34,500
that we use only uh well started and

557
00:24:34,500 --> 00:24:37,080
basic assumptions and we achieved nice

558
00:24:37,080 --> 00:24:39,360
uh poly logarithmic on chain efficiency

559
00:24:39,360 --> 00:24:41,640
so this will be the main contribution of

560
00:24:41,640 --> 00:24:43,080
our work

561
00:24:43,080 --> 00:24:45,120
so now I can just uh present a little

562
00:24:45,120 --> 00:24:47,460
like what are the technique we used

563
00:24:47,460 --> 00:24:49,679
uh so the main building block we used to

564
00:24:49,679 --> 00:24:52,860
provide our construction is a keyword

565
00:24:52,860 --> 00:24:55,320
search functional encryption uh and a

566
00:24:55,320 --> 00:24:57,659
slightly enhanced version of it so

567
00:24:57,659 --> 00:24:59,280
keyword search functional encliction

568
00:24:59,280 --> 00:25:01,380
essentially uh is an encryption scheme

569
00:25:01,380 --> 00:25:03,360
in which there are functional secret

570
00:25:03,360 --> 00:25:05,640
keys that are associated to messages in

571
00:25:05,640 --> 00:25:08,400
this case sky is labeled with message Y

572
00:25:08,400 --> 00:25:11,640
and when we decrypt with secret key we

573
00:25:11,640 --> 00:25:13,679
can learn if a cipher text is encrypting

574
00:25:13,679 --> 00:25:15,840
why or not and that's the only thing we

575
00:25:15,840 --> 00:25:17,820
learn we don't learn anything else about

576
00:25:17,820 --> 00:25:19,020
the message

577
00:25:19,020 --> 00:25:20,820
so in the paper actually we do need a

578
00:25:20,820 --> 00:25:22,740
slightly enhanced version of this uh

579
00:25:22,740 --> 00:25:24,539
which we call Modular keyword search

580
00:25:24,539 --> 00:25:27,120
functional encryption and instead of

581
00:25:27,120 --> 00:25:30,000
checking if x is equal to Y uh we can

582
00:25:30,000 --> 00:25:32,520
actually check if x is equal to Y module

583
00:25:32,520 --> 00:25:33,419
one

584
00:25:33,419 --> 00:25:35,820
so of course the message X and Y needs

585
00:25:35,820 --> 00:25:38,700
to lie in some uh given a set of

586
00:25:38,700 --> 00:25:42,299
integers like in a given range uh but

587
00:25:42,299 --> 00:25:43,980
that's a lot more technical details I

588
00:25:43,980 --> 00:25:45,299
won't go into

589
00:25:45,299 --> 00:25:47,700
so at the high level uh in order three

590
00:25:47,700 --> 00:25:49,200
percent thought protocol and I just need

591
00:25:49,200 --> 00:25:51,600
to specify two things I need to specify

592
00:25:51,600 --> 00:25:53,700
how a user can register into the system

593
00:25:53,700 --> 00:25:57,000
and our elections are carried out uh so

594
00:25:57,000 --> 00:25:58,500
at first I will just focus on election

595
00:25:58,500 --> 00:26:00,779
and then I will mention more like I will

596
00:26:00,779 --> 00:26:03,000
say more about registration but for now

597
00:26:03,000 --> 00:26:04,260
we just need to know that a registration

598
00:26:04,260 --> 00:26:06,480
we assume there is a subject subgroup of

599
00:26:06,480 --> 00:26:08,820
users who maybe have a secret sharing of

600
00:26:08,820 --> 00:26:10,740
the master secret key of the functional

601
00:26:10,740 --> 00:26:13,020
encryption scheme and a registration

602
00:26:13,020 --> 00:26:15,299
time gives new user a secret key labeled

603
00:26:15,299 --> 00:26:18,059
with the identity that they have uh so

604
00:26:18,059 --> 00:26:19,200
that's okay so they have a secret

605
00:26:19,200 --> 00:26:21,299
keyboard the modular keyword search

606
00:26:21,299 --> 00:26:23,880
functional encryption scheme uh and next

607
00:26:23,880 --> 00:26:25,380
every time you want to perform an

608
00:26:25,380 --> 00:26:28,559
election uh We Begin by We Begin by

609
00:26:28,559 --> 00:26:31,380
simply by publicly uh selecting a random

610
00:26:31,380 --> 00:26:33,779
committee or police mode and it's

611
00:26:33,779 --> 00:26:35,279
another committee as the duty of

612
00:26:35,279 --> 00:26:38,279
computing a commitment to a Cyber attack

613
00:26:38,279 --> 00:26:40,919
social and Cypher text uh so this

614
00:26:40,919 --> 00:26:42,299
challenge ciphertext will be the one

615
00:26:42,299 --> 00:26:43,679
deciding the winner

616
00:26:43,679 --> 00:26:46,020
so first this committee uh select this

617
00:26:46,020 --> 00:26:48,360
uh create this commitment to running a

618
00:26:48,360 --> 00:26:51,059
random challenge Cipher text then all

619
00:26:51,059 --> 00:26:52,740
the parties together threshold of and

620
00:26:52,740 --> 00:26:54,419
his commitments and get the challenge

621
00:26:54,419 --> 00:26:57,539
Cipher text and finally only the user

622
00:26:57,539 --> 00:26:59,820
who is able to decrypt this message here

623
00:26:59,820 --> 00:27:02,039
uh is the one who can who won the

624
00:27:02,039 --> 00:27:04,679
election and it proves it uh throughout

625
00:27:04,679 --> 00:27:06,419
the knowledge proof

626
00:27:06,419 --> 00:27:08,100
not this year that by the way the

627
00:27:08,100 --> 00:27:09,539
modular keyword search is important

628
00:27:09,539 --> 00:27:11,820
because uh this message here I'm

629
00:27:11,820 --> 00:27:14,400
identifying the winner uh is essentially

630
00:27:14,400 --> 00:27:17,279
taking us the sum of several uh M1 MK

631
00:27:17,279 --> 00:27:19,500
several shares all lying in this range

632
00:27:19,500 --> 00:27:21,779
So eventually this m will be lying

633
00:27:21,779 --> 00:27:24,299
between zero and if there are Kappa user

634
00:27:24,299 --> 00:27:27,240
Kappa times n uh so we need to do

635
00:27:27,240 --> 00:27:29,760
modular reduction here to check that the

636
00:27:29,760 --> 00:27:32,100
identity is equal to the message model

637
00:27:32,100 --> 00:27:33,059
one

638
00:27:33,059 --> 00:27:35,940
uh so just to give also a bit intuition

639
00:27:35,940 --> 00:27:38,640
like why this scheme is secure uh we

640
00:27:38,640 --> 00:27:40,200
immediately have the scheme satisfy

641
00:27:40,200 --> 00:27:42,299
uniqueness because for each M uh

642
00:27:42,299 --> 00:27:44,039
reducing it module and there if the

643
00:27:44,039 --> 00:27:46,559
entities are from 0 to n minus one that

644
00:27:46,559 --> 00:27:48,120
can only be one secret key that keeps

645
00:27:48,120 --> 00:27:51,720
this message uh it is uh Fair uh

646
00:27:51,720 --> 00:27:53,279
satisfies fairness because if there is

647
00:27:53,279 --> 00:27:54,900
at least one user honest user in this

648
00:27:54,900 --> 00:27:57,360
committee one of these Mi is uniformly

649
00:27:57,360 --> 00:28:00,059
random uh in zero and minus one and in

650
00:28:00,059 --> 00:28:02,039
particular this m is uniform module one

651
00:28:02,039 --> 00:28:05,520
and finally it is uh it is unpredictable

652
00:28:05,520 --> 00:28:09,480
because uh because um other parties only

653
00:28:09,480 --> 00:28:10,559
learned that they didn't want the

654
00:28:10,559 --> 00:28:12,419
election but again no information on who

655
00:28:12,419 --> 00:28:14,880
the winner really was

656
00:28:14,880 --> 00:28:17,039
okay so just a little bit more detail on

657
00:28:17,039 --> 00:28:19,740
this uh so again uh the election phase

658
00:28:19,740 --> 00:28:21,360
Begin by selecting a random committee

659
00:28:21,360 --> 00:28:23,100
and it is done through a random Beacon

660
00:28:23,100 --> 00:28:25,380
which essentially gives random values

661
00:28:25,380 --> 00:28:28,320
and identifies a small subset and the

662
00:28:28,320 --> 00:28:30,179
small subset against us to produce the

663
00:28:30,179 --> 00:28:32,640
commitment to Virtual and ciphertext and

664
00:28:32,640 --> 00:28:34,559
then encrypting like the sum of all this

665
00:28:34,559 --> 00:28:36,900
share that they're randomly sampling all

666
00:28:36,900 --> 00:28:39,179
of these like laying in the range from 0

667
00:28:39,179 --> 00:28:41,820
to a minus one

668
00:28:41,820 --> 00:28:45,360
um okay and so how do they do this I

669
00:28:45,360 --> 00:28:46,620
need to go a little bit more on the

670
00:28:46,620 --> 00:28:48,659
detail of how the encryption scheme

671
00:28:48,659 --> 00:28:50,279
works and this is by the way a modified

672
00:28:50,279 --> 00:28:53,640
version of uh uh encryption skin biotech

673
00:28:53,640 --> 00:28:55,860
query from 2018.

674
00:28:55,860 --> 00:28:57,480
um so we don't need to know much about

675
00:28:57,480 --> 00:28:59,340
the details but just that the encryption

676
00:28:59,340 --> 00:29:01,500
comes from this expression those are

677
00:29:01,500 --> 00:29:03,840
like public key elements and the issue

678
00:29:03,840 --> 00:29:06,059
is that uh the randomness used to

679
00:29:06,059 --> 00:29:08,100
encrypt uh so everything is linear in

680
00:29:08,100 --> 00:29:09,659
the randomness used to encrypt besides

681
00:29:09,659 --> 00:29:12,179
for this term uh so if everything were

682
00:29:12,179 --> 00:29:13,620
linear the nice thing is that we could

683
00:29:13,620 --> 00:29:15,600
have each user in the community selected

684
00:29:15,600 --> 00:29:17,460
on Randomness then we multiply things

685
00:29:17,460 --> 00:29:19,020
together and this would be a valid

686
00:29:19,020 --> 00:29:20,880
Cipher text but because of this

687
00:29:20,880 --> 00:29:22,440
quadratic term we cannot do this

688
00:29:22,440 --> 00:29:24,360
directly so we might need more rounds

689
00:29:24,360 --> 00:29:27,659
and this is problematic uh so the way we

690
00:29:27,659 --> 00:29:29,279
avoid using more rounds of communication

691
00:29:29,279 --> 00:29:31,679
is uh through random oracles

692
00:29:31,679 --> 00:29:34,080
so the idea is that uh we use the random

693
00:29:34,080 --> 00:29:36,000
Oracle to sample two uh uniform

694
00:29:36,000 --> 00:29:38,039
municipated group elements and we

695
00:29:38,039 --> 00:29:39,600
interpret those these two group elements

696
00:29:39,600 --> 00:29:41,940
as an encryption of a random message uh

697
00:29:41,940 --> 00:29:44,520
under algamal or whether like a random

698
00:29:44,520 --> 00:29:47,520
commitments commitments that is the

699
00:29:47,520 --> 00:29:50,220
orange element in here and then we use

700
00:29:50,220 --> 00:29:53,820
linearity of El Gamal uh to uh build the

701
00:29:53,820 --> 00:29:56,279
remaining parts of the cycle text which

702
00:29:56,279 --> 00:29:58,260
now only depends linearly on the secrets

703
00:29:58,260 --> 00:30:00,360
that is the message and the randomness

704
00:30:00,360 --> 00:30:02,520
as used for the encryption

705
00:30:02,520 --> 00:30:05,100
so now uh we just can compute everything

706
00:30:05,100 --> 00:30:07,140
in one rounds by having uh first

707
00:30:07,140 --> 00:30:09,419
teranomorical compute this part this

708
00:30:09,419 --> 00:30:11,520
orange part and then you said in the

709
00:30:11,520 --> 00:30:13,020
committee uh producing their own share

710
00:30:13,020 --> 00:30:15,779
and finally multiplying things together

711
00:30:15,779 --> 00:30:18,360
uh so to conclude the election uh we

712
00:30:18,360 --> 00:30:20,880
just need uh to essentiate a textual

713
00:30:20,880 --> 00:30:23,279
decryption I didn't mention maybe that's

714
00:30:23,279 --> 00:30:25,760
uh we assume that this is a random

715
00:30:25,760 --> 00:30:28,679
commitments under secret TZ so assume

716
00:30:28,679 --> 00:30:32,340
there is like uh G1 and zg1 uh publicly

717
00:30:32,340 --> 00:30:34,919
available to every user and also that

718
00:30:34,919 --> 00:30:37,740
they use it as a share of Z so user can

719
00:30:37,740 --> 00:30:39,779
can threshold The Click then this is

720
00:30:39,779 --> 00:30:41,760
just the standard Algoma threshold

721
00:30:41,760 --> 00:30:43,860
decryption there is nothing new and

722
00:30:43,860 --> 00:30:46,020
finally uh to clean Victory uh the

723
00:30:46,020 --> 00:30:48,240
winner simply provides the generalist

724
00:30:48,240 --> 00:30:49,559
proof that he knows a secret key

725
00:30:49,559 --> 00:30:52,320
decrypting the challenge Cipher text and

726
00:30:52,320 --> 00:30:54,120
this can be done easily with a sigma

727
00:30:54,120 --> 00:30:56,159
protocol like very efficiently Maxima

728
00:30:56,159 --> 00:30:58,380
protocol so finally I just need to

729
00:30:58,380 --> 00:31:01,500
explain how the registration Works uh an

730
00:31:01,500 --> 00:31:03,179
area is essentially the same so we

731
00:31:03,179 --> 00:31:05,640
assume that at setup time uh there is a

732
00:31:05,640 --> 00:31:07,620
committee design probably larger comedy

733
00:31:07,620 --> 00:31:10,740
of user who has a secret sharing of uh

734
00:31:10,740 --> 00:31:12,899
the master public key for the encryption

735
00:31:12,899 --> 00:31:16,799
scheme and uh for the secret Z that was

736
00:31:16,799 --> 00:31:18,600
the secret key for the Algoma commitment

737
00:31:18,600 --> 00:31:20,100
scheme

738
00:31:20,100 --> 00:31:22,500
um okay so this can be simply by having

739
00:31:22,500 --> 00:31:25,980
issues are sampling on the wi and zygi

740
00:31:25,980 --> 00:31:28,320
and then implicitly defining w and z as

741
00:31:28,320 --> 00:31:30,779
the sum of all these shares

742
00:31:30,779 --> 00:31:33,840
um so given this uh the the secret key

743
00:31:33,840 --> 00:31:35,820
in our scale must essentially this shape

744
00:31:35,820 --> 00:31:38,820
and we again have the same problem uh we

745
00:31:38,820 --> 00:31:41,640
have this random Sr that it's uh fresh

746
00:31:41,640 --> 00:31:43,980
for its secret key in this case okay we

747
00:31:43,980 --> 00:31:45,840
just have it but here we have a

748
00:31:45,840 --> 00:31:48,120
quadratic independency with the

749
00:31:48,120 --> 00:31:49,799
randomness and the master public and

750
00:31:49,799 --> 00:31:52,320
master secret key so in theory we would

751
00:31:52,320 --> 00:31:54,179
need more round of interaction to

752
00:31:54,179 --> 00:31:57,419
computer sharing of R times Tableau but

753
00:31:57,419 --> 00:31:58,740
again we can use the same trick of the

754
00:31:58,740 --> 00:32:01,320
random Oracle by sampling by generating

755
00:32:01,320 --> 00:32:04,559
these two uh these elements randomly for

756
00:32:04,559 --> 00:32:06,419
all the user in the committee and

757
00:32:06,419 --> 00:32:08,220
finally having each member of the

758
00:32:08,220 --> 00:32:10,679
committee uh return give to the user

759
00:32:10,679 --> 00:32:14,220
like wi times all these things uh and

760
00:32:14,220 --> 00:32:15,720
then multiply all this element together

761
00:32:15,720 --> 00:32:18,960
in order to get uh the correct secret

762
00:32:18,960 --> 00:32:21,140
key

763
00:32:21,140 --> 00:32:24,840
uh okay so to conclude

764
00:32:24,840 --> 00:32:28,740
um we have okay so we did uh compare our

765
00:32:28,740 --> 00:32:30,360
work essentially with the shuffle based

766
00:32:30,360 --> 00:32:33,140
Solution by uh bonus

767
00:32:33,140 --> 00:32:36,000
uh and in particular we observed that uh

768
00:32:36,000 --> 00:32:38,279
okay so for each of our uh Rich columns

769
00:32:38,279 --> 00:32:40,980
here uh we assume that we perform an

770
00:32:40,980 --> 00:32:43,020
election and between every two elections

771
00:32:43,020 --> 00:32:45,960
uh there are uh 10 20 and 50

772
00:32:45,960 --> 00:32:49,320
registrations just to provide uh I mean

773
00:32:49,320 --> 00:32:51,299
just have a way to compare both the

774
00:32:51,299 --> 00:32:52,500
restriction and elections at the same

775
00:32:52,500 --> 00:32:55,799
time and we observed that in our case uh

776
00:32:55,799 --> 00:32:57,960
the setup cost is a little bit is of

777
00:32:57,960 --> 00:32:59,220
course more than the shuffle-based

778
00:32:59,220 --> 00:33:00,720
solution uh because we need to

779
00:33:00,720 --> 00:33:01,919
instantiate the verifiable secret

780
00:33:01,919 --> 00:33:04,380
sharing at first which is with high in

781
00:33:04,380 --> 00:33:07,140
communication uh but then uh the fact

782
00:33:07,140 --> 00:33:08,700
that our registration is very efficient

783
00:33:08,700 --> 00:33:10,860
uh the committee simply need to send a

784
00:33:10,860 --> 00:33:12,419
constant number of group elements to the

785
00:33:12,419 --> 00:33:15,059
new user uh the cost of the scheme is

786
00:33:15,059 --> 00:33:17,159
eventually better than the shuffle based

787
00:33:17,159 --> 00:33:18,899
solution where you need to shuffle the

788
00:33:18,899 --> 00:33:20,940
whole list uh every time there is a new

789
00:33:20,940 --> 00:33:22,500
user

790
00:33:22,500 --> 00:33:23,880
um and this is a problem by the way that

791
00:33:23,880 --> 00:33:25,380
affects all the shuffle based

792
00:33:25,380 --> 00:33:27,840
construction that came afterwards so the

793
00:33:27,840 --> 00:33:29,399
efficiency in those cases are comparable

794
00:33:29,399 --> 00:33:31,100
with the first construction

795
00:33:31,100 --> 00:33:34,559
and even for on chain costs our scheme

796
00:33:34,559 --> 00:33:36,960
is even better than uh the square root

797
00:33:36,960 --> 00:33:38,340
of and Shuffle where your list Shuffle

798
00:33:38,340 --> 00:33:40,620
subset so yeah you have even less

799
00:33:40,620 --> 00:33:44,580
anonymity in that case uh but uh still

800
00:33:44,580 --> 00:33:46,919
like very high on chain complexity uh

801
00:33:46,919 --> 00:33:49,940
for the previous constructions

802
00:33:49,940 --> 00:33:52,799
what I present today is a practical and

803
00:33:52,799 --> 00:33:55,980
you see security scheme uh that achieve

804
00:33:55,980 --> 00:33:59,399
uh poly logarithmic uh on chain

805
00:33:59,399 --> 00:34:01,679
complexity and only relies on standard

806
00:34:01,679 --> 00:34:03,659
paying assumptions so there are still

807
00:34:03,659 --> 00:34:05,220
problems and ways to improve this

808
00:34:05,220 --> 00:34:06,840
protocol and for instance one of those

809
00:34:06,840 --> 00:34:09,000
questions is can we reduce the setup

810
00:34:09,000 --> 00:34:10,560
costs like do we need to use the

811
00:34:10,560 --> 00:34:13,379
verifiable signaturing or uh can we use

812
00:34:13,379 --> 00:34:15,839
different techniques uh and finally if

813
00:34:15,839 --> 00:34:17,219
it's possible to achieve adaptive

814
00:34:17,219 --> 00:34:19,800
Security in our setting uh for instance

815
00:34:19,800 --> 00:34:21,719
the reason why we don't achieve adaptive

816
00:34:21,719 --> 00:34:24,060
security is that we rely on committees

817
00:34:24,060 --> 00:34:27,060
and uh if

818
00:34:27,060 --> 00:34:29,460
and if those committees are fully

819
00:34:29,460 --> 00:34:31,320
corrupted actively then the adversary

820
00:34:31,320 --> 00:34:33,179
completely breaks the system so we can

821
00:34:33,179 --> 00:34:35,399
only uh prove security against study

822
00:34:35,399 --> 00:34:37,560
Corruptions so that's it thanks for your

823
00:34:37,560 --> 00:34:38,520
attention

824
00:34:38,520 --> 00:34:39,780
and

825
00:34:39,780 --> 00:34:42,679
related questions

826
00:34:45,599 --> 00:34:47,280
thank you for the talk we have uh we

827
00:34:47,280 --> 00:34:50,300
have a few minutes for questions

828
00:34:52,080 --> 00:34:54,119
so I didn't get how to make sure that

829
00:34:54,119 --> 00:34:56,159
the N is correct in the encrypted

830
00:34:56,159 --> 00:34:57,420
messages

831
00:34:57,420 --> 00:35:00,540
uh okay I I I missed I mean I didn't

832
00:35:00,540 --> 00:35:02,520
mention like how we ensure that all

833
00:35:02,520 --> 00:35:03,660
these cyber attacks are correctly

834
00:35:03,660 --> 00:35:06,900
generated uh but in fact the small n is

835
00:35:06,900 --> 00:35:08,400
the number of registered user at the

836
00:35:08,400 --> 00:35:10,280
moment and this is a public information

837
00:35:10,280 --> 00:35:15,180
and uh in fact uh all user or you say in

838
00:35:15,180 --> 00:35:17,160
the committee uh that produces these

839
00:35:17,160 --> 00:35:18,420
partial ciphertext that are later

840
00:35:18,420 --> 00:35:20,220
aggregated uh need to attach the

841
00:35:20,220 --> 00:35:23,400
knowledge proof of that and uh and it's

842
00:35:23,400 --> 00:35:25,140
part of these statements that the Cyber

843
00:35:25,140 --> 00:35:26,820
tests are correctly generated so it has

844
00:35:26,820 --> 00:35:28,619
to be the number of registered user at

845
00:35:28,619 --> 00:35:30,180
the moment

846
00:35:30,180 --> 00:35:33,259
uh thanks for the question

847
00:35:35,820 --> 00:35:39,200
I actually have a quick question

848
00:35:43,980 --> 00:35:46,440
for the zero knowledge proof uh do you

849
00:35:46,440 --> 00:35:48,599
use Sigma protocol or like customized

850
00:35:48,599 --> 00:35:51,900
protocol based on pairings okay uh so

851
00:35:51,900 --> 00:35:53,460
essentially use the fact you mean the

852
00:35:53,460 --> 00:35:55,380
general Edge proof for the uh for

853
00:35:55,380 --> 00:35:56,880
proving like that I can decrypt The

854
00:35:56,880 --> 00:35:58,920
Cypher the challenge Cipher text

855
00:35:58,920 --> 00:36:01,260
okay uh so we essentially use the fact

856
00:36:01,260 --> 00:36:03,000
that our encryption scheme and

857
00:36:03,000 --> 00:36:04,680
especially in the decryption procedure

858
00:36:04,680 --> 00:36:07,920
is essentially linear uh so we can we

859
00:36:07,920 --> 00:36:09,240
can essentially a lot of like known

860
00:36:09,240 --> 00:36:11,280
techniques like uh like this grammar

861
00:36:11,280 --> 00:36:14,040
version of Sigma protocol for uh linear

862
00:36:14,040 --> 00:36:16,560
statements uh so essentially it's not

863
00:36:16,560 --> 00:36:18,420
basically has no proof uh but for a

864
00:36:18,420 --> 00:36:21,839
slightly modified statement uh and also

865
00:36:21,839 --> 00:36:23,579
like uh since the Cyber text has only a

866
00:36:23,579 --> 00:36:25,020
constant amount of group elements that

867
00:36:25,020 --> 00:36:27,180
provides to us like five group elements

868
00:36:27,180 --> 00:36:29,880
in total if I'm not wrong thanks for the

869
00:36:29,880 --> 00:36:32,119
question

870
00:36:34,980 --> 00:36:38,220
I I'm gonna ask my question so so

871
00:36:38,220 --> 00:36:39,780
um so this is a beautiful construction

872
00:36:39,780 --> 00:36:42,119
and you really kind of looks like

873
00:36:42,119 --> 00:36:45,119
um s s x DH is doing a lot of heavy

874
00:36:45,119 --> 00:36:48,300
lifting there so I was wondering

875
00:36:48,300 --> 00:36:49,800
um what are your thoughts on achieving

876
00:36:49,800 --> 00:36:51,599
the same asymptotics but from other

877
00:36:51,599 --> 00:36:53,060
assumptions

878
00:36:53,060 --> 00:36:55,619
uh so I think that without pairing it's

879
00:36:55,619 --> 00:36:58,020
uh probably hard because uh I mean we

880
00:36:58,020 --> 00:36:59,220
need parents to have functional

881
00:36:59,220 --> 00:37:01,440
encryption there and without it I don't

882
00:37:01,440 --> 00:37:03,599
I'm not aware if there are like keyword

883
00:37:03,599 --> 00:37:05,160
search function encryption for weak

884
00:37:05,160 --> 00:37:07,740
assumptions I I believe it could be

885
00:37:07,740 --> 00:37:09,480
possible from lactices but I don't know

886
00:37:09,480 --> 00:37:11,220
if efficiency wise would be better or

887
00:37:11,220 --> 00:37:13,260
not but that's definitely an interesting

888
00:37:13,260 --> 00:37:15,900
question thanks thanks

889
00:37:15,900 --> 00:37:19,500
all right other questions right so let's

890
00:37:19,500 --> 00:37:22,579
uh thank the speaker

891
00:37:25,020 --> 00:37:26,640
so um

892
00:37:26,640 --> 00:37:27,900
So Daniel

893
00:37:27,900 --> 00:37:33,180
um the next paper is paper 37. yeah

894
00:37:42,000 --> 00:37:43,740
all right

895
00:37:43,740 --> 00:37:45,960
so

896
00:37:45,960 --> 00:37:48,140
um

897
00:37:56,040 --> 00:37:59,640
so our next paper is uh

898
00:37:59,640 --> 00:38:02,400
simple fast efficient and tightly secure

899
00:38:02,400 --> 00:38:04,619
non-maleable non-interactive timed

900
00:38:04,619 --> 00:38:07,560
commitments by Peter and Tibor Jagger

901
00:38:07,560 --> 00:38:09,960
and Peter will give the talk

902
00:38:09,960 --> 00:38:12,060
okay thank you for introduction can you

903
00:38:12,060 --> 00:38:16,140
hear me yes okay so hi everyone I'm

904
00:38:16,140 --> 00:38:18,480
Peter and I'm going to talk about simple

905
00:38:18,480 --> 00:38:20,220
past efficient and titles secure

906
00:38:20,220 --> 00:38:21,780
non-miable non-interactive time

907
00:38:21,780 --> 00:38:23,579
commitments which is growing work with

908
00:38:23,579 --> 00:38:26,160
Tibor Jager and let me start with

909
00:38:26,160 --> 00:38:29,339
motivation example uh imagine that you

910
00:38:29,339 --> 00:38:32,760
have uh set off and bidders who wants to

911
00:38:32,760 --> 00:38:34,800
participate in Seal bit auction

912
00:38:34,800 --> 00:38:37,140
and the first thing they do they commit

913
00:38:37,140 --> 00:38:39,000
with standard commitments came to their

914
00:38:39,000 --> 00:38:43,079
bids and they publicly made these

915
00:38:43,079 --> 00:38:46,440
commitments to available everyone and at

916
00:38:46,440 --> 00:38:47,820
some point of time they reveal their

917
00:38:47,820 --> 00:38:50,160
bits but now assume that one of the

918
00:38:50,160 --> 00:38:52,980
bidders claims or I lost my Randomness

919
00:38:52,980 --> 00:38:57,300
I'm not able to open the commitment and

920
00:38:57,300 --> 00:38:59,280
and he claims that his bid is the

921
00:38:59,280 --> 00:39:00,599
highest which is interesting for the

922
00:39:00,599 --> 00:39:03,000
seller because he wants to sell the item

923
00:39:03,000 --> 00:39:05,700
for the higher highest price and now the

924
00:39:05,700 --> 00:39:08,400
question is can we resolve this issue

925
00:39:08,400 --> 00:39:11,099
uh and one way how to resolve this is

926
00:39:11,099 --> 00:39:15,420
use so-called time commitment and time

927
00:39:15,420 --> 00:39:17,339
commitment has additional feature which

928
00:39:17,339 --> 00:39:19,800
we call Force the commitment and this

929
00:39:19,800 --> 00:39:22,980
feature allows to open the commitment at

930
00:39:22,980 --> 00:39:25,920
a specified point of time automatically

931
00:39:25,920 --> 00:39:27,839
without the intervention of another

932
00:39:27,839 --> 00:39:30,060
users

933
00:39:30,060 --> 00:39:32,640
um so what we require from such a times

934
00:39:32,640 --> 00:39:34,920
commitment are following properties uh

935
00:39:34,920 --> 00:39:36,119
the first one is called public

936
00:39:36,119 --> 00:39:38,640
verifiability of the commitments we want

937
00:39:38,640 --> 00:39:40,619
to be sure that the commitments are

938
00:39:40,619 --> 00:39:43,380
correctly generated and also we want to

939
00:39:43,380 --> 00:39:45,480
be especially sure that they can be

940
00:39:45,480 --> 00:39:47,220
really forced the committed

941
00:39:47,220 --> 00:39:49,680
uh then non-interactivity for practical

942
00:39:49,680 --> 00:39:52,740
reasons uh we want to be that they are

943
00:39:52,740 --> 00:39:55,380
non-mariable we don't want to allow uh

944
00:39:55,380 --> 00:39:57,480
users to create their commitments based

945
00:39:57,480 --> 00:40:00,480
on the time commitments of another users

946
00:40:00,480 --> 00:40:02,400
uh then some kind of homomorphic

947
00:40:02,400 --> 00:40:05,160
properties can be interesting because uh

948
00:40:05,160 --> 00:40:06,540
usually this Force the commitment

949
00:40:06,540 --> 00:40:08,820
requires to execute some sequential

950
00:40:08,820 --> 00:40:11,460
computation which can be expensive and

951
00:40:11,460 --> 00:40:14,280
now imagine that several users reject to

952
00:40:14,280 --> 00:40:16,160
open their commitments

953
00:40:16,160 --> 00:40:20,040
in the case that we are interested only

954
00:40:20,040 --> 00:40:22,260
on some evaluation on the messages which

955
00:40:22,260 --> 00:40:24,780
are hidden in these commitments we can

956
00:40:24,780 --> 00:40:26,400
homomorphically combine the time

957
00:40:26,400 --> 00:40:29,460
commitments and then Force the commit

958
00:40:29,460 --> 00:40:32,820
only resulting time commitment and then

959
00:40:32,820 --> 00:40:34,800
we also also introduce this new property

960
00:40:34,800 --> 00:40:36,420
which we call public verifiability of

961
00:40:36,420 --> 00:40:38,760
the first day commitment and this allows

962
00:40:38,760 --> 00:40:41,760
to Outsource the computation of the

963
00:40:41,760 --> 00:40:43,800
first day commitment to untrusted server

964
00:40:43,800 --> 00:40:46,619
and he can prove us that he execute the

965
00:40:46,619 --> 00:40:48,660
first equipment correctly

966
00:40:48,660 --> 00:40:50,579
okay this has found several interesting

967
00:40:50,579 --> 00:40:52,980
applications like achieving unbiased

968
00:40:52,980 --> 00:40:55,560
e-voting or fairness in multi-party

969
00:40:55,560 --> 00:40:57,420
computation protocols like Fair coin

970
00:40:57,420 --> 00:41:00,119
flipping and several others

971
00:41:00,119 --> 00:41:01,859
uh let's start to be a little bit more

972
00:41:01,859 --> 00:41:03,960
formal non-interactive time commitments

973
00:41:03,960 --> 00:41:07,320
were introduced by cuts at all and it is

974
00:41:07,320 --> 00:41:09,300
a couple of algorithms so we have a

975
00:41:09,300 --> 00:41:11,099
pigeon algorithm which they just input

976
00:41:11,099 --> 00:41:13,020
the security parameter and time

977
00:41:13,020 --> 00:41:15,420
parameter and output the CRS then we

978
00:41:15,420 --> 00:41:17,160
have committing algorithm which comments

979
00:41:17,160 --> 00:41:18,359
to the message and produce the

980
00:41:18,359 --> 00:41:20,940
commitments and also committing and the

981
00:41:20,940 --> 00:41:23,700
committing proof then come verify

982
00:41:23,700 --> 00:41:25,560
algorithm that checks that the

983
00:41:25,560 --> 00:41:29,160
commitment is correctly generated uh the

984
00:41:29,160 --> 00:41:31,500
commitment verify algorithm just think

985
00:41:31,500 --> 00:41:33,480
about it as a standard opening algorithm

986
00:41:33,480 --> 00:41:35,579
for the commitment and then we have this

987
00:41:35,579 --> 00:41:37,440
special force the commitment algorithm

988
00:41:37,440 --> 00:41:40,380
which allows to open the commitment

989
00:41:40,380 --> 00:41:43,859
without any secret information and the

990
00:41:43,859 --> 00:41:45,599
requirement is that the runtime of the

991
00:41:45,599 --> 00:41:48,720
algorithm is roughly thin as I mentioned

992
00:41:48,720 --> 00:41:50,640
we introduced this new property called

993
00:41:50,640 --> 00:41:52,619
public verifiability of course the

994
00:41:52,619 --> 00:41:53,579
commitment

995
00:41:53,579 --> 00:41:55,200
and in that case the first the

996
00:41:55,200 --> 00:41:58,680
commitment additionally outputs uh also

997
00:41:58,680 --> 00:42:00,599
additional algorithm first document to

998
00:42:00,599 --> 00:42:02,640
verify we check that the first day

999
00:42:02,640 --> 00:42:06,839
commitment was executed correctly uh and

1000
00:42:06,839 --> 00:42:08,880
then that again it I'll also introduce

1001
00:42:08,880 --> 00:42:11,339
this homomorphic properties uh where

1002
00:42:11,339 --> 00:42:12,960
there is a evaluation algorithm which

1003
00:42:12,960 --> 00:42:15,240
works in the following way it takes us

1004
00:42:15,240 --> 00:42:18,359
into the CRS circuit and set of time

1005
00:42:18,359 --> 00:42:20,700
commitments output and under time

1006
00:42:20,700 --> 00:42:22,920
commitment and then we can run for the

1007
00:42:22,920 --> 00:42:25,140
commitment algorithm and open evaluation

1008
00:42:25,140 --> 00:42:27,300
of the circuit on the messages which

1009
00:42:27,300 --> 00:42:30,359
were hidden in the time commitments

1010
00:42:30,359 --> 00:42:32,460
uh there are actually several security

1011
00:42:32,460 --> 00:42:34,920
property which are which are required

1012
00:42:34,920 --> 00:42:38,040
from uh such a time commitment but in

1013
00:42:38,040 --> 00:42:39,660
this talk we are going to focus only on

1014
00:42:39,660 --> 00:42:43,140
one which is called indcca security and

1015
00:42:43,140 --> 00:42:44,760
this property is actually very similar

1016
00:42:44,760 --> 00:42:46,859
to indcc security or public key

1017
00:42:46,859 --> 00:42:49,740
encryption uh and it works in the

1018
00:42:49,740 --> 00:42:51,839
following way adversary a consists of

1019
00:42:51,839 --> 00:42:55,320
two machines a0a1 and then the

1020
00:42:55,320 --> 00:42:57,359
Challenger run speed and algorithm to

1021
00:42:57,359 --> 00:43:02,280
obtain CRS it sends CRS to the a0 a0 can

1022
00:43:02,280 --> 00:43:05,220
ask the commitment queries but we are

1023
00:43:05,220 --> 00:43:06,720
going to answer the commitment queries

1024
00:43:06,720 --> 00:43:08,640
only for commitments which are correctly

1025
00:43:08,640 --> 00:43:11,520
generated and the requirement is that we

1026
00:43:11,520 --> 00:43:13,260
answer them using Force the commitment

1027
00:43:13,260 --> 00:43:15,240
algorithm

1028
00:43:15,240 --> 00:43:15,960
um

1029
00:43:15,960 --> 00:43:18,359
so at this point I want to mention that

1030
00:43:18,359 --> 00:43:19,859
if we want to achieve tight security

1031
00:43:19,859 --> 00:43:22,140
proof in the proof there must be another

1032
00:43:22,140 --> 00:43:24,000
way how to answer this the commitment

1033
00:43:24,000 --> 00:43:26,760
queries because the runtime of this

1034
00:43:26,760 --> 00:43:29,099
algorithm is rough City and it might be

1035
00:43:29,099 --> 00:43:32,940
expensive then a0 provides a challenge

1036
00:43:32,940 --> 00:43:33,859
messages

1037
00:43:33,859 --> 00:43:36,420
Challenger randomly sample a bit commit

1038
00:43:36,420 --> 00:43:38,640
to the message MB compute the commitment

1039
00:43:38,640 --> 00:43:40,500
provides a challenge commitment to the

1040
00:43:40,500 --> 00:43:41,940
adversary A1

1041
00:43:41,940 --> 00:43:45,119
uh A1 again can ask this the commitment

1042
00:43:45,119 --> 00:43:46,980
queries again we are going to answer

1043
00:43:46,980 --> 00:43:50,040
only correctly uh generated uh

1044
00:43:50,040 --> 00:43:52,200
commitments and it must be also

1045
00:43:52,200 --> 00:43:54,839
different from The Challenge commitment

1046
00:43:54,839 --> 00:43:58,380
uh and then adversary A1 output B Prime

1047
00:43:58,380 --> 00:44:00,660
and the requirement is that the runtime

1048
00:44:00,660 --> 00:44:03,839
of the adversary A1 is less than t uh

1049
00:44:03,839 --> 00:44:06,119
because otherwise A1 can run this Force

1050
00:44:06,119 --> 00:44:08,700
the commitment already and he would be

1051
00:44:08,700 --> 00:44:11,400
able to uh see what is in the inside of

1052
00:44:11,400 --> 00:44:12,599
the commitment

1053
00:44:12,599 --> 00:44:14,579
and then the output of the experiment is

1054
00:44:14,579 --> 00:44:16,980
defined as the true uh truth value of

1055
00:44:16,980 --> 00:44:19,680
the expression Biz equal B Prime and

1056
00:44:19,680 --> 00:44:21,180
Advantage is defined as a probability

1057
00:44:21,180 --> 00:44:24,180
that uh X Prime and outputs one minus

1058
00:44:24,180 --> 00:44:25,619
one half

1059
00:44:25,619 --> 00:44:29,579
okay so I told you uh that this security

1060
00:44:29,579 --> 00:44:32,040
notion is very similar to invcca

1061
00:44:32,040 --> 00:44:33,359
security notion of the public key

1062
00:44:33,359 --> 00:44:36,180
encryption and also we need this public

1063
00:44:36,180 --> 00:44:39,300
verifiability of the commitments uh so

1064
00:44:39,300 --> 00:44:42,060
therefore uh the idea is to start the

1065
00:44:42,060 --> 00:44:44,040
publicly verifiable public key

1066
00:44:44,040 --> 00:44:46,859
encryption scheme and the candidate of

1067
00:44:46,859 --> 00:44:49,020
course now yeah in Paradigm where you

1068
00:44:49,020 --> 00:44:51,000
can uh

1069
00:44:51,000 --> 00:44:53,160
encrypt the message twice using two

1070
00:44:53,160 --> 00:44:56,040
independent Keys using CPA Secure Public

1071
00:44:56,040 --> 00:44:58,859
encryption scheme and then prove using

1072
00:44:58,859 --> 00:45:01,319
one-time simulation some music that the

1073
00:45:01,319 --> 00:45:03,660
uh that both encryption contain the same

1074
00:45:03,660 --> 00:45:05,400
message okay

1075
00:45:05,400 --> 00:45:08,579
and uh we want to have however efficient

1076
00:45:08,579 --> 00:45:10,500
construction that is also efficient

1077
00:45:10,500 --> 00:45:12,839
music so the base would be some Sigma

1078
00:45:12,839 --> 00:45:14,339
protocol and we know that the sigma

1079
00:45:14,339 --> 00:45:17,280
protocol exists for algebraic languages

1080
00:45:17,280 --> 00:45:19,319
and therefore the challenge is to find

1081
00:45:19,319 --> 00:45:21,839
the replacement to substitute this

1082
00:45:21,839 --> 00:45:24,359
public encryption scheme

1083
00:45:24,359 --> 00:45:27,660
okay so the candidate for such a

1084
00:45:27,660 --> 00:45:31,319
substitution uh is actually homomorphic

1085
00:45:31,319 --> 00:45:34,260
time or puzzle of malabota at all which

1086
00:45:34,260 --> 00:45:36,720
consists of four algorithms setup genes

1087
00:45:36,720 --> 00:45:39,119
solve and evaluation algorithm and this

1088
00:45:39,119 --> 00:45:41,819
evaluation algorithm works as expected

1089
00:45:41,819 --> 00:45:44,220
and now notice if I just rename the

1090
00:45:44,220 --> 00:45:45,720
algorithms as speed didn't come and

1091
00:45:45,720 --> 00:45:47,940
force the commitment then I have a time

1092
00:45:47,940 --> 00:45:50,280
commitment but uh

1093
00:45:50,280 --> 00:45:53,339
this time commitment has very weak or

1094
00:45:53,339 --> 00:45:56,220
weaker Security in Ocean and it's very

1095
00:45:56,220 --> 00:45:58,319
similar to CPA security and option okay

1096
00:45:58,319 --> 00:46:00,420
so this is the candidate

1097
00:46:00,420 --> 00:46:03,240
and malabota at our show how to build

1098
00:46:03,240 --> 00:46:04,619
this primitive from the strong

1099
00:46:04,619 --> 00:46:07,980
sequential squaring assumption

1100
00:46:07,980 --> 00:46:09,480
um which is the following assumption

1101
00:46:09,480 --> 00:46:11,940
adversary again consists of the two

1102
00:46:11,940 --> 00:46:14,339
machines a0 A1

1103
00:46:14,339 --> 00:46:16,980
and uh Challenger runs then what

1104
00:46:16,980 --> 00:46:18,900
algorithm produced to large Price p and

1105
00:46:18,900 --> 00:46:20,579
Q and is the product of the primes and

1106
00:46:20,579 --> 00:46:23,819
GSM generator we provide ntng to the

1107
00:46:23,819 --> 00:46:25,319
adversary a0

1108
00:46:25,319 --> 00:46:27,660
and then Challenger randomly sample X

1109
00:46:27,660 --> 00:46:30,240
from the group of J of n which is the

1110
00:46:30,240 --> 00:46:32,400
subgroup of that star of elements which

1111
00:46:32,400 --> 00:46:35,940
Jacobi symbol one y zero is computed as

1112
00:46:35,940 --> 00:46:39,060
x to the two to the T mod N and y1 is

1113
00:46:39,060 --> 00:46:41,460
the element of J of N and I Define it as

1114
00:46:41,460 --> 00:46:43,680
two algorithm two experiments so in one

1115
00:46:43,680 --> 00:46:46,619
experiment we provide X and Y 0 a second

1116
00:46:46,619 --> 00:46:50,220
experiment X and Y one a one output B

1117
00:46:50,220 --> 00:46:53,520
bit B Prime and the runtime should be

1118
00:46:53,520 --> 00:46:56,640
less than P of the algorithm A1 and the

1119
00:46:56,640 --> 00:46:58,200
advantage is defined as a probability

1120
00:46:58,200 --> 00:47:00,660
that adversary a outputs 1 in experience

1121
00:47:00,660 --> 00:47:02,880
zero minus probability that adversary a

1122
00:47:02,880 --> 00:47:06,000
outputs one in experiment one

1123
00:47:06,000 --> 00:47:08,760
okay so in their paper actually they

1124
00:47:08,760 --> 00:47:10,140
show uh

1125
00:47:10,140 --> 00:47:11,940
linearly homomorphic and also

1126
00:47:11,940 --> 00:47:13,380
multiplicatively homework Construction

1127
00:47:13,380 --> 00:47:15,060
in this logo I'm going to talk about

1128
00:47:15,060 --> 00:47:16,980
only leader article morphe construction

1129
00:47:16,980 --> 00:47:19,260
of timeline puzzle

1130
00:47:19,260 --> 00:47:21,960
um so in Pigeon the Iran decision mod

1131
00:47:21,960 --> 00:47:26,460
algorithm then they uh they compute this

1132
00:47:26,460 --> 00:47:29,460
Euler functions by of the N which is T

1133
00:47:29,460 --> 00:47:31,619
minus one times Q minus one and then

1134
00:47:31,619 --> 00:47:34,079
they compute the Special Value t as a 2

1135
00:47:34,079 --> 00:47:36,540
to the T modify of ND divided by two and

1136
00:47:36,540 --> 00:47:39,359
this is the order of the group of J of N

1137
00:47:39,359 --> 00:47:42,420
and H as G to the T mod n and CRS is

1138
00:47:42,420 --> 00:47:44,880
then NP G and H

1139
00:47:44,880 --> 00:47:47,579
and now the commitment commitment is

1140
00:47:47,579 --> 00:47:49,980
something very similar to paella like

1141
00:47:49,980 --> 00:47:53,220
encryption where we randomly sample R

1142
00:47:53,220 --> 00:47:57,060
from some interval and compute c0 with G

1143
00:47:57,060 --> 00:48:00,359
to the r naught n and C1 is very similar

1144
00:48:00,359 --> 00:48:03,000
to Pi a h to the r times n times one

1145
00:48:03,000 --> 00:48:06,540
plus n to the power of M mod n Square

1146
00:48:06,540 --> 00:48:09,119
and now notice we can force the commit

1147
00:48:09,119 --> 00:48:11,940
it without any secret information we

1148
00:48:11,940 --> 00:48:14,520
compute the value y as c0 to the power

1149
00:48:14,520 --> 00:48:16,980
of 2 to the P naught n and this can be

1150
00:48:16,980 --> 00:48:18,900
computed by repeated squaring and it

1151
00:48:18,900 --> 00:48:20,339
takes three steps of the repeated

1152
00:48:20,339 --> 00:48:22,560
squaring therefore we say it has runtime

1153
00:48:22,560 --> 00:48:24,900
roughly D and the message can be

1154
00:48:24,900 --> 00:48:27,599
recomputed as C1 times inverse of Y to

1155
00:48:27,599 --> 00:48:29,640
the power of n mod N squared minus 1

1156
00:48:29,640 --> 00:48:31,140
divided by n

1157
00:48:31,140 --> 00:48:33,240
now notice we have also by like

1158
00:48:33,240 --> 00:48:35,640
homomorphism it is sufficient to

1159
00:48:35,640 --> 00:48:37,980
multiply separately c0 parts of the

1160
00:48:37,980 --> 00:48:39,780
commitment and C1 parts of the

1161
00:48:39,780 --> 00:48:42,599
commitments and additionally okay we can

1162
00:48:42,599 --> 00:48:44,700
also Define standard opening algorithm

1163
00:48:44,700 --> 00:48:47,099
uh if you give me message on Randomness

1164
00:48:47,099 --> 00:48:49,079
I reconcute the commitment from the

1165
00:48:49,079 --> 00:48:51,780
scratch and just check if it match the

1166
00:48:51,780 --> 00:48:53,220
client commitment

1167
00:48:53,220 --> 00:48:56,040
and this was shown to be kind of CPA

1168
00:48:56,040 --> 00:48:57,900
secure based on strong sequential

1169
00:48:57,900 --> 00:48:59,700
squaring decision of composite

1170
00:48:59,700 --> 00:49:01,740
residuality and decision of the film and

1171
00:49:01,740 --> 00:49:03,900
assumption

1172
00:49:03,900 --> 00:49:07,500
um so our first attempt how to obtain

1173
00:49:07,500 --> 00:49:11,280
this CCA security is just use the

1174
00:49:11,280 --> 00:49:13,440
combine two independent homomorphic time

1175
00:49:13,440 --> 00:49:15,780
of puzzles which were produced using two

1176
00:49:15,780 --> 00:49:17,960
independent Keys okay

1177
00:49:17,960 --> 00:49:20,400
and on this slide I also wrote two

1178
00:49:20,400 --> 00:49:22,980
independent modules and one and two but

1179
00:49:22,980 --> 00:49:25,560
in reality if we want to let's use

1180
00:49:25,560 --> 00:49:29,160
standard Sigma protocol then N1 is equal

1181
00:49:29,160 --> 00:49:32,400
to N2 and from now on I assume that this

1182
00:49:32,400 --> 00:49:34,800
holds okay and now look let's look what

1183
00:49:34,800 --> 00:49:37,440
will happen in the security proof so I

1184
00:49:37,440 --> 00:49:39,599
told you that in the experiment uh there

1185
00:49:39,599 --> 00:49:41,040
is this requirement we have to answer

1186
00:49:41,040 --> 00:49:43,079
this the commitment queries using for

1187
00:49:43,079 --> 00:49:45,599
the commitment algorithm and in order to

1188
00:49:45,599 --> 00:49:47,579
obtain time security prove there must be

1189
00:49:47,579 --> 00:49:50,460
another way so let's say we use kt1 and

1190
00:49:50,460 --> 00:49:52,140
this is indistinguishable based on the

1191
00:49:52,140 --> 00:49:54,900
soundness of the music uh then we can

1192
00:49:54,900 --> 00:49:57,060
start to simulate the proof okay here we

1193
00:49:57,060 --> 00:49:58,560
rely on the Zero knowledge property of

1194
00:49:58,560 --> 00:50:01,619
the music and now we can try to replace

1195
00:50:01,619 --> 00:50:03,780
the message in the second homomorphic

1196
00:50:03,780 --> 00:50:07,319
table also with the random message

1197
00:50:07,319 --> 00:50:10,380
but now what happens this kp1 has this

1198
00:50:10,380 --> 00:50:12,660
special form two to the team of order of

1199
00:50:12,660 --> 00:50:14,940
the group and in order to compute this

1200
00:50:14,940 --> 00:50:16,260
key we need to know the order of the

1201
00:50:16,260 --> 00:50:17,460
group and essentially we need to know

1202
00:50:17,460 --> 00:50:19,980
the factorization of 10 but at the same

1203
00:50:19,980 --> 00:50:22,200
time we need to reduce the security of

1204
00:50:22,200 --> 00:50:24,660
home morphic time on puzzle and

1205
00:50:24,660 --> 00:50:26,220
especially we need to reduce to the

1206
00:50:26,220 --> 00:50:27,900
strong sequential squaring assumption

1207
00:50:27,900 --> 00:50:30,300
and this assumption does not hold if we

1208
00:50:30,300 --> 00:50:32,160
know the factorization of n

1209
00:50:32,160 --> 00:50:35,040
so we are a little bit stuck with this

1210
00:50:35,040 --> 00:50:36,859
approach

1211
00:50:36,859 --> 00:50:39,960
and there is a simple observation that

1212
00:50:39,960 --> 00:50:42,000
from this homomorphic time of puzzle we

1213
00:50:42,000 --> 00:50:45,480
can just get simply homomorphic uh we

1214
00:50:45,480 --> 00:50:47,700
are homomorphic public encryption scheme

1215
00:50:47,700 --> 00:50:50,520
if we sample the Key T uniformly at

1216
00:50:50,520 --> 00:50:52,980
random from some interval and then I

1217
00:50:52,980 --> 00:50:54,839
just simply rename the algorithms and I

1218
00:50:54,839 --> 00:50:56,819
have standard public encryption scheme

1219
00:50:56,819 --> 00:50:59,940
very CPA secure based on decision or

1220
00:50:59,940 --> 00:51:01,440
composite residuality and decision

1221
00:51:01,440 --> 00:51:03,599
assumption

1222
00:51:03,599 --> 00:51:05,960
okay so what uh what is our second

1223
00:51:05,960 --> 00:51:08,400
attempt is to

1224
00:51:08,400 --> 00:51:11,940
combine homomorphic timelock puzzle uh

1225
00:51:11,940 --> 00:51:16,380
with uh with this encryption scheme

1226
00:51:16,380 --> 00:51:18,420
and they were produced using independent

1227
00:51:18,420 --> 00:51:21,420
Keys okay but now what happens in the

1228
00:51:21,420 --> 00:51:23,520
proof that at some point of the time I

1229
00:51:23,520 --> 00:51:25,440
again have to use this key T which is

1230
00:51:25,440 --> 00:51:27,000
this special form

1231
00:51:27,000 --> 00:51:28,500
and for which I need to know the

1232
00:51:28,500 --> 00:51:30,599
factorization of N and I will have to

1233
00:51:30,599 --> 00:51:32,819
reduce to the DCR assumption and now the

1234
00:51:32,819 --> 00:51:34,500
problem is that this air assumption does

1235
00:51:34,500 --> 00:51:37,680
not hold even on the factorization of n

1236
00:51:37,680 --> 00:51:41,160
so we can fix this issue simply by what

1237
00:51:41,160 --> 00:51:43,319
we call Triple night or young and triple

1238
00:51:43,319 --> 00:51:45,599
now or yank is you can encrypt the

1239
00:51:45,599 --> 00:51:48,119
message twice using two independent keys

1240
00:51:48,119 --> 00:51:50,640
and the third time you commit uh using

1241
00:51:50,640 --> 00:51:52,559
this homomorphic timeline puzzle because

1242
00:51:52,559 --> 00:51:54,900
you still want to have this feature of

1243
00:51:54,900 --> 00:51:56,640
force the commitment

1244
00:51:56,640 --> 00:51:58,980
and why this works

1245
00:51:58,980 --> 00:52:01,440
um so in the security proof you can

1246
00:52:01,440 --> 00:52:04,619
always uh answer the commitment queries

1247
00:52:04,619 --> 00:52:09,960
either using pk1 and change the message

1248
00:52:09,960 --> 00:52:12,000
sorry

1249
00:52:12,000 --> 00:52:15,240
change the message in the homework time

1250
00:52:15,240 --> 00:52:16,680
of person and second public key

1251
00:52:16,680 --> 00:52:18,359
encryption scheme will be the random

1252
00:52:18,359 --> 00:52:19,200
message

1253
00:52:19,200 --> 00:52:22,020
uh or you can answer them using key K2

1254
00:52:22,020 --> 00:52:24,839
and then change the message in first

1255
00:52:24,839 --> 00:52:26,520
public encryption scheme with a random

1256
00:52:26,520 --> 00:52:28,680
message and you never have to rely on

1257
00:52:28,680 --> 00:52:30,900
this special key which for which you

1258
00:52:30,900 --> 00:52:33,660
needed to know the factorization of and

1259
00:52:33,660 --> 00:52:36,839
yeah so the security proves simply works

1260
00:52:36,839 --> 00:52:39,000
and this is essentially our construction

1261
00:52:39,000 --> 00:52:42,540
that we can do little bit better uh we

1262
00:52:42,540 --> 00:52:44,700
can use the technique of the biagini at

1263
00:52:44,700 --> 00:52:46,680
all and instead of having three

1264
00:52:46,680 --> 00:52:48,900
independent keys and three independent

1265
00:52:48,900 --> 00:52:52,079
commitments we can generate just one

1266
00:52:52,079 --> 00:52:55,740
generator G and produce H1 H2 H3 with

1267
00:52:55,740 --> 00:52:58,200
respect to this generator G and then we

1268
00:52:58,200 --> 00:53:00,300
can comment with using shared Randomness

1269
00:53:00,300 --> 00:53:03,380
so we compute G to the r and then we

1270
00:53:03,380 --> 00:53:06,059
compute this three pile like commitments

1271
00:53:06,059 --> 00:53:09,839
using the same Randomness r okay so

1272
00:53:09,839 --> 00:53:12,240
instead of six elements we will have

1273
00:53:12,240 --> 00:53:15,059
four elements

1274
00:53:15,059 --> 00:53:15,900
um

1275
00:53:15,900 --> 00:53:17,400
and therefore we need one-time

1276
00:53:17,400 --> 00:53:19,140
simulation sound music for the language

1277
00:53:19,140 --> 00:53:24,660
which shows that c0c1 c2c3 is correctly

1278
00:53:24,660 --> 00:53:27,119
generated commitment and contains only

1279
00:53:27,119 --> 00:53:29,400
one message in a Randomness and in our

1280
00:53:29,400 --> 00:53:31,680
paper we show how to build a sigma

1281
00:53:31,680 --> 00:53:34,140
protocol for this music and we show how

1282
00:53:34,140 --> 00:53:38,339
to obtain uh either uh music in random

1283
00:53:38,339 --> 00:53:40,500
record model or in standard model using

1284
00:53:40,500 --> 00:53:43,260
this Collision intractable hash function

1285
00:53:43,260 --> 00:53:44,520
okay

1286
00:53:44,520 --> 00:53:48,599
so to just uh point out to the important

1287
00:53:48,599 --> 00:53:52,680
things uh okay in PGN we randomly

1288
00:53:52,680 --> 00:53:55,740
sampled these two keys K1 K2 from some

1289
00:53:55,740 --> 00:53:57,059
interval and then we have this special

1290
00:53:57,059 --> 00:53:59,819
keep uh which is completed as 2 to the T

1291
00:53:59,819 --> 00:54:02,400
mod order of the group and if we have an

1292
00:54:02,400 --> 00:54:04,260
easy in standard node model then we have

1293
00:54:04,260 --> 00:54:06,359
also the setup of the music

1294
00:54:06,359 --> 00:54:08,420
series of the music

1295
00:54:08,420 --> 00:54:11,700
and uh then we commit as was explained

1296
00:54:11,700 --> 00:54:13,200
on the previous slide with the shared

1297
00:54:13,200 --> 00:54:16,140
Randomness and we prove that the

1298
00:54:16,140 --> 00:54:20,160
commitment is correctly generated and

1299
00:54:20,160 --> 00:54:21,900
the randomness R is actually just

1300
00:54:21,900 --> 00:54:25,319
standard opening of the commitment okay

1301
00:54:25,319 --> 00:54:27,960
and in our paper we also show how to

1302
00:54:27,960 --> 00:54:30,359
implement all other algorithms uh

1303
00:54:30,359 --> 00:54:31,980
efficiently

1304
00:54:31,980 --> 00:54:34,740
so to conclude in our paper you will

1305
00:54:34,740 --> 00:54:36,119
find four constructions two

1306
00:54:36,119 --> 00:54:38,700
constructions are linearly homomorphic

1307
00:54:38,700 --> 00:54:40,380
two constructions are multiplicatively

1308
00:54:40,380 --> 00:54:41,520
homomorphic

1309
00:54:41,520 --> 00:54:44,400
and always one is in random Oracle model

1310
00:54:44,400 --> 00:54:46,980
and one is in standard model and

1311
00:54:46,980 --> 00:54:49,559
compared to the previous Works uh we

1312
00:54:49,559 --> 00:54:52,140
either actually uh efficient committing

1313
00:54:52,140 --> 00:54:55,140
time type security proof some novel

1314
00:54:55,140 --> 00:54:57,119
properties

1315
00:54:57,119 --> 00:55:00,720
um smaller size of the commitments uh or

1316
00:55:00,720 --> 00:55:02,220
that the constructions are standard

1317
00:55:02,220 --> 00:55:04,079
model because often they are in a random

1318
00:55:04,079 --> 00:55:06,119
Oracle model

1319
00:55:06,119 --> 00:55:07,619
um okay if you are interested in the

1320
00:55:07,619 --> 00:55:09,780
paper you can just find it on the ePrint

1321
00:55:09,780 --> 00:55:12,960
or you can contact me via my email uh

1322
00:55:12,960 --> 00:55:14,760
thank you for your attention if you have

1323
00:55:14,760 --> 00:55:18,500
any question you are welcome to ask

1324
00:55:22,740 --> 00:55:25,440
we have time for questions

1325
00:55:25,440 --> 00:55:27,980
questions

1326
00:55:32,760 --> 00:55:35,099
um so I have a question about the

1327
00:55:35,099 --> 00:55:39,119
applications of uh uh of this type of

1328
00:55:39,119 --> 00:55:42,300
commitments yes so uh as I told you like

1329
00:55:42,300 --> 00:55:44,280
very often you want to use it for

1330
00:55:44,280 --> 00:55:47,640
achieving this uh fairness uh in the

1331
00:55:47,640 --> 00:55:49,740
multi-party computation protocols like

1332
00:55:49,740 --> 00:55:53,220
Fair coin flipping so you uh

1333
00:55:53,220 --> 00:55:56,339
like for example in this uh coin

1334
00:55:56,339 --> 00:55:58,559
flipping protocol like it can happen

1335
00:55:58,559 --> 00:56:00,619
that at some point the

1336
00:56:00,619 --> 00:56:03,240
participants see their uh

1337
00:56:03,240 --> 00:56:05,160
messages which they are sending in the

1338
00:56:05,160 --> 00:56:07,680
protocol uh or when they are opening the

1339
00:56:07,680 --> 00:56:09,720
commitments and one would reject to open

1340
00:56:09,720 --> 00:56:12,960
then the protocol fails yes but because

1341
00:56:12,960 --> 00:56:14,700
they commit for example with this time

1342
00:56:14,700 --> 00:56:18,300
protocol uh they can still open also the

1343
00:56:18,300 --> 00:56:20,880
commitments of the other users and the

1344
00:56:20,880 --> 00:56:22,740
product already continue how is it

1345
00:56:22,740 --> 00:56:25,098
different from

1346
00:56:27,119 --> 00:56:30,380
I mean verifiable

1347
00:56:31,680 --> 00:56:33,720
I mean verify of the UI function you are

1348
00:56:33,720 --> 00:56:35,700
really not committing to the value yes

1349
00:56:35,700 --> 00:56:38,520
it's just the output of the I mean this

1350
00:56:38,520 --> 00:56:40,140
verified UI function is good for

1351
00:56:40,140 --> 00:56:43,140
achieving this unbi uh unbiased Beacon

1352
00:56:43,140 --> 00:56:46,380
yes but for example it wouldn't be good

1353
00:56:46,380 --> 00:56:50,760
for achieving uh unbiased evoking

1354
00:56:50,760 --> 00:56:54,480
right yes it will be done enough yeah I

1355
00:56:54,480 --> 00:56:56,220
guess my bigger question is the

1356
00:56:56,220 --> 00:56:58,319
relationship between between this result

1357
00:56:58,319 --> 00:57:00,720
and the one we just heard it in in our

1358
00:57:00,720 --> 00:57:04,640
you know the craft okay yeah

1359
00:57:04,640 --> 00:57:06,800
yeah so

1360
00:57:06,800 --> 00:57:10,140
yeah the construction is UC secure yes

1361
00:57:10,140 --> 00:57:13,079
also they have to also rely on the uh

1362
00:57:13,079 --> 00:57:16,859
a random Oracle model and I mean

1363
00:57:16,859 --> 00:57:19,440
if it is UC secure I think it means it's

1364
00:57:19,440 --> 00:57:21,240
automatically not malleable but they

1365
00:57:21,240 --> 00:57:22,740
don't have for example these homomorphic

1366
00:57:22,740 --> 00:57:23,880
properties

1367
00:57:23,880 --> 00:57:26,480
yes

1368
00:57:29,940 --> 00:57:31,920
okay uh thank you thank you for your

1369
00:57:31,920 --> 00:57:35,099
talk I want to ask uh what assumptions

1370
00:57:35,099 --> 00:57:39,800
uh do the first three Works rely on

1371
00:57:39,800 --> 00:57:44,220
uh okay cut uh

1372
00:57:44,220 --> 00:57:48,059
uh okay uh it's a sec this circulation

1373
00:57:48,059 --> 00:57:51,240
squaring assumption uh is in all of them

1374
00:57:51,240 --> 00:57:52,700
I think

1375
00:57:52,700 --> 00:57:55,859
and uh

1376
00:57:55,859 --> 00:58:00,359
the second one is real yeah is relying

1377
00:58:00,359 --> 00:58:03,839
on uh generic musics uh

1378
00:58:03,839 --> 00:58:06,599
so therefore like they are relying on

1379
00:58:06,599 --> 00:58:09,619
snacks actually snacks yes

1380
00:58:09,619 --> 00:58:13,440
uh and they are the first two are or all

1381
00:58:13,440 --> 00:58:14,819
of them are in the random Morocco model

1382
00:58:14,819 --> 00:58:15,780
I think

1383
00:58:15,780 --> 00:58:17,460
yes

1384
00:58:17,460 --> 00:58:20,099
so they are also revised

1385
00:58:20,099 --> 00:58:21,660
okay thanks

1386
00:58:21,660 --> 00:58:24,140
welcome

1387
00:58:29,040 --> 00:58:33,980
so the next paper is paper 83. your plan

1388
00:58:45,480 --> 00:58:46,680
all right

1389
00:58:46,680 --> 00:58:49,559
um so our next paper is a certifying

1390
00:58:49,559 --> 00:58:52,319
giant non-primes by Charlotte Hoffman

1391
00:58:52,319 --> 00:58:55,619
Bible hubachik Chetan Kamas and

1392
00:58:55,619 --> 00:58:58,200
Christopher and Charlotte will give the

1393
00:58:58,200 --> 00:58:59,760
talk

1394
00:58:59,760 --> 00:59:02,099
okay thanks for the introduction

1395
00:59:02,099 --> 00:59:03,720
so I hope you're not too disappointed

1396
00:59:03,720 --> 00:59:04,859
that this is not going to be a talk

1397
00:59:04,859 --> 00:59:07,020
about crypto for crypto but we're going

1398
00:59:07,020 --> 00:59:08,700
to see an application of crypto in

1399
00:59:08,700 --> 00:59:11,299
computational number Theory

1400
00:59:11,299 --> 00:59:13,319
namely we're going to look at prime

1401
00:59:13,319 --> 00:59:14,819
numbers

1402
00:59:14,819 --> 00:59:16,559
so prime numbers have always been of

1403
00:59:16,559 --> 00:59:18,720
Interest not only in number Theory but

1404
00:59:18,720 --> 00:59:21,480
also just in the General Public

1405
00:59:21,480 --> 00:59:23,160
so for example there are those

1406
00:59:23,160 --> 00:59:25,500
large-scale projects that are dedicated

1407
00:59:25,500 --> 00:59:27,599
to searching giant prime numbers

1408
00:59:27,599 --> 00:59:31,760
they are called gims and Prime grid

1409
00:59:32,160 --> 00:59:33,900
um and when I say giant I really mean

1410
00:59:33,900 --> 00:59:36,660
giant so the largest prime number that

1411
00:59:36,660 --> 00:59:39,599
has been found by Prime grid consists of

1412
00:59:39,599 --> 00:59:42,780
more than 9 million decimal digits

1413
00:59:42,780 --> 00:59:43,920
yeah

1414
00:59:43,920 --> 00:59:46,140
to find those numbers the projects

1415
00:59:46,140 --> 00:59:48,000
perform expensive primality tests for

1416
00:59:48,000 --> 00:59:49,920
numbers of special form for example

1417
00:59:49,920 --> 00:59:53,280
profit numbers or mercen numbers

1418
00:59:53,280 --> 00:59:55,200
and to prevent cheating and computation

1419
00:59:55,200 --> 00:59:57,599
errors until recently they have done

1420
00:59:57,599 --> 00:59:59,700
this via double checking so do two

1421
00:59:59,700 --> 01:00:01,140
different parties check the same number

1422
01:00:01,140 --> 01:00:04,020
no matter if the result was prime or not

1423
01:00:04,020 --> 01:00:05,579
Prime

1424
01:00:05,579 --> 01:00:07,619
but of course we as cryptographers we

1425
01:00:07,619 --> 01:00:09,960
can ask ourselves if we can replace this

1426
01:00:09,960 --> 01:00:11,400
expensive double checking with

1427
01:00:11,400 --> 01:00:14,540
cryptographic proofs

1428
01:00:14,940 --> 01:00:16,799
um and in our work we show that this is

1429
01:00:16,799 --> 01:00:20,780
possible for some specific cases

1430
01:00:21,780 --> 01:00:23,460
um namely we're going to look at Cross

1431
01:00:23,460 --> 01:00:24,420
numbers

1432
01:00:24,420 --> 01:00:26,880
so Prof numbers are numbers of this form

1433
01:00:26,880 --> 01:00:29,280
K times 2 to the N Plus 1.

1434
01:00:29,280 --> 01:00:31,980
where K is odd and it is strictly less

1435
01:00:31,980 --> 01:00:34,200
than 2 to the n

1436
01:00:34,200 --> 01:00:36,540
and for numbers of this form there

1437
01:00:36,540 --> 01:00:38,280
exists the where non-family test called

1438
01:00:38,280 --> 01:00:40,020
Prof steering

1439
01:00:40,020 --> 01:00:41,359
so

1440
01:00:41,359 --> 01:00:43,680
this says that for any X which is a

1441
01:00:43,680 --> 01:00:46,079
quadratic non-residue modulo n we have

1442
01:00:46,079 --> 01:00:48,420
the NS Prime if and only if the

1443
01:00:48,420 --> 01:00:49,680
following holds

1444
01:00:49,680 --> 01:00:51,780
we take X we raise it to the power of K

1445
01:00:51,780 --> 01:00:54,000
times 2 to the N minus 1 and then we

1446
01:00:54,000 --> 01:00:56,940
check if the result is -1 modular n if

1447
01:00:56,940 --> 01:00:58,500
the result of minus one we know that the

1448
01:00:58,500 --> 01:01:00,540
number is prime if the result is not

1449
01:01:00,540 --> 01:01:01,980
minus one we know that the number is

1450
01:01:01,980 --> 01:01:03,720
composite

1451
01:01:03,720 --> 01:01:06,180
but notice that even if we now know that

1452
01:01:06,180 --> 01:01:07,740
the number is composite we do not get a

1453
01:01:07,740 --> 01:01:10,440
divisor of the number so we don't have a

1454
01:01:10,440 --> 01:01:12,599
we don't have a proof that this was

1455
01:01:12,599 --> 01:01:15,359
actually the correct result

1456
01:01:15,359 --> 01:01:16,559
um but if we look at the permeability

1457
01:01:16,559 --> 01:01:19,260
test we see that this is this uh

1458
01:01:19,260 --> 01:01:22,980
big a big exponentiation so

1459
01:01:22,980 --> 01:01:23,700
um

1460
01:01:23,700 --> 01:01:26,460
and in cryptography we have a tour to

1461
01:01:26,460 --> 01:01:28,559
certify the result of some big

1462
01:01:28,559 --> 01:01:30,359
exponentiations

1463
01:01:30,359 --> 01:01:31,859
and those are called proofs of

1464
01:01:31,859 --> 01:01:33,299
exponentiation

1465
01:01:33,299 --> 01:01:35,339
so there we have approved render

1466
01:01:35,339 --> 01:01:36,420
verifier

1467
01:01:36,420 --> 01:01:38,220
and approver claims that the result of

1468
01:01:38,220 --> 01:01:40,680
some big exponentiation is equal to Y

1469
01:01:40,680 --> 01:01:42,780
and some group G

1470
01:01:42,780 --> 01:01:44,640
and to prove this the proofer can send

1471
01:01:44,640 --> 01:01:45,900
the Poe

1472
01:01:45,900 --> 01:01:49,020
so proof of exponentiation

1473
01:01:49,020 --> 01:01:51,359
those Poes are usually only interesting

1474
01:01:51,359 --> 01:01:53,520
in Hidden order groups

1475
01:01:53,520 --> 01:01:55,859
because if you know the group order

1476
01:01:55,859 --> 01:01:57,839
then the verifier does not need any help

1477
01:01:57,839 --> 01:01:59,640
from the proofer it can just reduce the

1478
01:01:59,640 --> 01:02:01,680
exponent module of the group order and

1479
01:02:01,680 --> 01:02:03,720
then raise X to that power and it's

1480
01:02:03,720 --> 01:02:05,160
usually efficient and it can just check

1481
01:02:05,160 --> 01:02:07,440
if the result is true or not

1482
01:02:07,440 --> 01:02:10,079
but if the group order is hidden then we

1483
01:02:10,079 --> 01:02:11,819
don't know of a significantly faster way

1484
01:02:11,819 --> 01:02:13,680
to compute the result than to perform T

1485
01:02:13,680 --> 01:02:15,900
sequential exponentiations so that's

1486
01:02:15,900 --> 01:02:18,839
what the proofer does but

1487
01:02:18,839 --> 01:02:21,480
then it sends a proof of exponentiation

1488
01:02:21,480 --> 01:02:23,520
for which the cost of computing and

1489
01:02:23,520 --> 01:02:25,559
verifying it is much less than T so the

1490
01:02:25,559 --> 01:02:29,400
verifier does not need to work as hard

1491
01:02:29,400 --> 01:02:32,520
okay so this looks promising now can we

1492
01:02:32,520 --> 01:02:34,260
use this for our primality test so can

1493
01:02:34,260 --> 01:02:36,299
we use Poes for primality certificates

1494
01:02:36,299 --> 01:02:39,660
or non-parently certificates

1495
01:02:39,660 --> 01:02:42,059
uh yeah again here you see the primality

1496
01:02:42,059 --> 01:02:44,760
test it's this big exponentiation

1497
01:02:44,760 --> 01:02:46,980
and in fact games and Prime grid have

1498
01:02:46,980 --> 01:02:48,540
already discovered this connection and

1499
01:02:48,540 --> 01:02:51,180
they have deployed PHX Poe to certify

1500
01:02:51,180 --> 01:02:53,640
primality tests

1501
01:02:53,640 --> 01:02:55,980
but there's a problem here so as I just

1502
01:02:55,980 --> 01:02:57,960
said future xpoe was constructed for

1503
01:02:57,960 --> 01:02:59,700
hidden order groups

1504
01:02:59,700 --> 01:03:01,319
and now we're working in the group z

1505
01:03:01,319 --> 01:03:02,940
modulo n

1506
01:03:02,940 --> 01:03:05,040
so if it's a prime number then we know

1507
01:03:05,040 --> 01:03:09,140
the group order it's just n minus 1.

1508
01:03:09,359 --> 01:03:11,339
um so notice that this does not speed up

1509
01:03:11,339 --> 01:03:13,440
this computation because

1510
01:03:13,440 --> 01:03:15,480
the group order is still larger than the

1511
01:03:15,480 --> 01:03:17,460
exponent so we cannot reduce the

1512
01:03:17,460 --> 01:03:20,400
exponent anymore however PHX protocol is

1513
01:03:20,400 --> 01:03:21,960
unfortunately enough sound in those

1514
01:03:21,960 --> 01:03:22,920
groups

1515
01:03:22,920 --> 01:03:25,140
and in fact there even isn't a tick so

1516
01:03:25,140 --> 01:03:28,319
for any Prof prime number

1517
01:03:28,319 --> 01:03:29,819
um the prover can come up with a fault

1518
01:03:29,819 --> 01:03:31,680
proof convincing the verifier that the

1519
01:03:31,680 --> 01:03:35,299
number is composite even though it's not

1520
01:03:35,819 --> 01:03:37,319
um notice that there are other Poes in

1521
01:03:37,319 --> 01:03:38,280
the literature there are also

1522
01:03:38,280 --> 01:03:40,380
statistically sound Poes that work in

1523
01:03:40,380 --> 01:03:41,819
any group

1524
01:03:41,819 --> 01:03:43,680
however they are more complex and

1525
01:03:43,680 --> 01:03:45,119
because we are working with such huge

1526
01:03:45,119 --> 01:03:46,799
prime numbers here we can really cannot

1527
01:03:46,799 --> 01:03:49,859
afford to use a Poe that's much more

1528
01:03:49,859 --> 01:03:53,579
complex than phxpoe

1529
01:03:53,579 --> 01:03:55,140
um right so in our world we take care of

1530
01:03:55,140 --> 01:03:57,599
this problem so our contribution is we

1531
01:03:57,599 --> 01:03:59,099
construct a statistically sound

1532
01:03:59,099 --> 01:04:01,260
certificate of non-premability for proof

1533
01:04:01,260 --> 01:04:02,579
numbers

1534
01:04:02,579 --> 01:04:04,440
that reduces the complexity of double

1535
01:04:04,440 --> 01:04:06,660
checking from n multiplications to all

1536
01:04:06,660 --> 01:04:08,880
of Lambda Times log n where Lambda is a

1537
01:04:08,880 --> 01:04:11,819
statistical security parameter

1538
01:04:11,819 --> 01:04:13,680
and it increases the complexity of the

1539
01:04:13,680 --> 01:04:15,720
currently deployed protocol which is not

1540
01:04:15,720 --> 01:04:18,480
the cryptographically sound only by a

1541
01:04:18,480 --> 01:04:21,599
multi-duplicative factor of two

1542
01:04:21,599 --> 01:04:24,059
okay again not so this is a certificate

1543
01:04:24,059 --> 01:04:27,000
of non-premality however in practice

1544
01:04:27,000 --> 01:04:29,280
more most of the numbers are not Prime

1545
01:04:29,280 --> 01:04:31,559
and so with this certificate

1546
01:04:31,559 --> 01:04:35,780
we cover almost all of the cases

1547
01:04:36,180 --> 01:04:38,460
um okay now how do we achieve that

1548
01:04:38,460 --> 01:04:40,559
uh the rest of the rest of the chart

1549
01:04:40,559 --> 01:04:43,200
we're first going to look at phxpe uh

1550
01:04:43,200 --> 01:04:44,339
then I will show you the attack and

1551
01:04:44,339 --> 01:04:46,319
cross number groups and then finally

1552
01:04:46,319 --> 01:04:48,920
we'll see our protocol

1553
01:04:48,920 --> 01:04:51,180
but first I want to remind you of the

1554
01:04:51,180 --> 01:04:53,460
definition of interactive protocols so

1555
01:04:53,460 --> 01:04:55,020
again we have approver and the verifier

1556
01:04:55,020 --> 01:04:56,940
and they both get us input some

1557
01:04:56,940 --> 01:04:59,280
statement X and then the approver also

1558
01:04:59,280 --> 01:05:01,680
gets a witness or just more computing

1559
01:05:01,680 --> 01:05:03,960
power than the verifier

1560
01:05:03,960 --> 01:05:05,700
then they send messages back and forth

1561
01:05:05,700 --> 01:05:07,799
until in the end the verify outputs

1562
01:05:07,799 --> 01:05:10,440
accept or reject

1563
01:05:10,440 --> 01:05:12,240
and we say that this protocol is sound

1564
01:05:12,240 --> 01:05:14,520
if whenever the statement is false then

1565
01:05:14,520 --> 01:05:15,839
the verifier rejects with higher

1566
01:05:15,839 --> 01:05:17,339
probability no matter what the malicious

1567
01:05:17,339 --> 01:05:18,720
proofer does

1568
01:05:18,720 --> 01:05:20,700
and we say that it's complete if

1569
01:05:20,700 --> 01:05:22,440
whenever the statement is correct and P

1570
01:05:22,440 --> 01:05:24,420
is honest then the verify accepts with

1571
01:05:24,420 --> 01:05:26,520
high probability

1572
01:05:26,520 --> 01:05:28,559
in this talk all of the protocols will

1573
01:05:28,559 --> 01:05:30,180
be trivially complete so we're just

1574
01:05:30,180 --> 01:05:33,259
going to discuss soundness

1575
01:05:33,359 --> 01:05:35,040
okay so let's take a look at pictures

1576
01:05:35,040 --> 01:05:36,480
Poe

1577
01:05:36,480 --> 01:05:38,760
here the statement to be proven is that

1578
01:05:38,760 --> 01:05:41,160
x to the 2 to the T equals y and some

1579
01:05:41,160 --> 01:05:42,299
group

1580
01:05:42,299 --> 01:05:44,400
to prove this the first message of the

1581
01:05:44,400 --> 01:05:46,680
proverb is this element G1 which we also

1582
01:05:46,680 --> 01:05:48,839
call midpoint because it's the result of

1583
01:05:48,839 --> 01:05:50,760
the exponentiation X to the 2 to the T

1584
01:05:50,760 --> 01:05:52,559
over 2.

1585
01:05:52,559 --> 01:05:54,480
notice that by sending this element that

1586
01:05:54,480 --> 01:05:57,000
implicitly splits up the first claim

1587
01:05:57,000 --> 01:05:59,280
into two smaller claims

1588
01:05:59,280 --> 01:06:01,319
so one of them is that this G1 is

1589
01:06:01,319 --> 01:06:02,700
actually the correct result of this

1590
01:06:02,700 --> 01:06:05,520
exponentiation with 2 to the T over 2.

1591
01:06:05,520 --> 01:06:07,440
and the other claim is that if you take

1592
01:06:07,440 --> 01:06:09,420
the midpoint and raise this one two two

1593
01:06:09,420 --> 01:06:11,520
to the T over two you should get back Y

1594
01:06:11,520 --> 01:06:15,240
which is the result of the initial chain

1595
01:06:15,240 --> 01:06:16,680
okay good so now we've made some

1596
01:06:16,680 --> 01:06:18,480
progress we've reduced the exponent from

1597
01:06:18,480 --> 01:06:21,180
2 to the T to 2 to the T over 2 but we

1598
01:06:21,180 --> 01:06:22,619
now have two statements instead of one

1599
01:06:22,619 --> 01:06:25,079
and so to take care of this the verifier

1600
01:06:25,079 --> 01:06:25,859
now

1601
01:06:25,859 --> 01:06:28,260
since a random coin R and The Proven

1602
01:06:28,260 --> 01:06:30,059
verifier for those two statements back

1603
01:06:30,059 --> 01:06:31,799
together into one

1604
01:06:31,799 --> 01:06:34,200
like this so we obtain this equation

1605
01:06:34,200 --> 01:06:36,180
down here by taking the first statement

1606
01:06:36,180 --> 01:06:38,819
raising it to the power R and then

1607
01:06:38,819 --> 01:06:40,020
multiplying this with the second

1608
01:06:40,020 --> 01:06:42,500
statement

1609
01:06:46,680 --> 01:06:49,020
okay and then now we feel the rate

1610
01:06:49,020 --> 01:06:50,579
progress so if we use the exponent from

1611
01:06:50,579 --> 01:06:53,099
2 to the T to 2 to the T over 2 and now

1612
01:06:53,099 --> 01:06:55,680
the proverb again just needs to prove

1613
01:06:55,680 --> 01:06:58,559
one statement so we can request

1614
01:06:58,559 --> 01:07:00,720
um the proverb again since the midpoint

1615
01:07:00,720 --> 01:07:02,760
and we do this for log T many rounds

1616
01:07:02,760 --> 01:07:04,980
until in the end the verifier just needs

1617
01:07:04,980 --> 01:07:07,380
to check the result of this one squaring

1618
01:07:07,380 --> 01:07:11,160
and then it can output accept or reject

1619
01:07:11,160 --> 01:07:13,559
notice that all the messages the

1620
01:07:13,559 --> 01:07:15,359
verifier sends are just public random

1621
01:07:15,359 --> 01:07:17,280
clients so this protocol can also be

1622
01:07:17,280 --> 01:07:20,460
made non-interactive using feature

1623
01:07:20,460 --> 01:07:22,859
now what you can see is that if you if

1624
01:07:22,859 --> 01:07:24,240
the approver here starts off with the

1625
01:07:24,240 --> 01:07:26,220
wrong statement in the beginning then no

1626
01:07:26,220 --> 01:07:27,359
matter what it sends in the first

1627
01:07:27,359 --> 01:07:28,920
message at least one of the new

1628
01:07:28,920 --> 01:07:31,140
statements will also be incorrect

1629
01:07:31,140 --> 01:07:33,180
however for soundness to hold we need

1630
01:07:33,180 --> 01:07:35,520
that also after the folding step

1631
01:07:35,520 --> 01:07:39,299
we still have a wrong statement here

1632
01:07:39,299 --> 01:07:41,819
um so that in the end the verify notices

1633
01:07:41,819 --> 01:07:44,819
that there's something fishy

1634
01:07:44,819 --> 01:07:46,680
um so pitchek proves that this holds in

1635
01:07:46,680 --> 01:07:49,079
certain groups but unfortunately it does

1636
01:07:49,079 --> 01:07:51,359
not hold in proof number groups

1637
01:07:51,359 --> 01:07:53,400
and now we're going to see the attack

1638
01:07:53,400 --> 01:07:55,020
so let's assume that we have a prime

1639
01:07:55,020 --> 01:07:57,599
number of prime n so the correct result

1640
01:07:57,599 --> 01:08:00,180
of the terminology test is minus one

1641
01:08:00,180 --> 01:08:02,160
however we have a malicious prover that

1642
01:08:02,160 --> 01:08:04,260
claims that the result is actually minus

1643
01:08:04,260 --> 01:08:07,200
Alpha for some other element Alpha

1644
01:08:07,200 --> 01:08:09,119
now there are different messages that

1645
01:08:09,119 --> 01:08:10,500
the prover can send in the first round

1646
01:08:10,500 --> 01:08:12,900
uh it's not really important to us how

1647
01:08:12,900 --> 01:08:15,780
it looks like but we as we just said

1648
01:08:15,780 --> 01:08:17,698
um we still have that one of the new

1649
01:08:17,698 --> 01:08:19,439
statements there's still incorrect and

1650
01:08:19,439 --> 01:08:21,719
this bad element Alpha is still in there

1651
01:08:21,719 --> 01:08:24,259
somehow

1652
01:08:24,299 --> 01:08:25,620
um then the verified sense of random

1653
01:08:25,620 --> 01:08:27,660
coin and then we fold the two statements

1654
01:08:27,660 --> 01:08:29,640
back together into one so we take them

1655
01:08:29,640 --> 01:08:31,738
we raise the first one to the power R

1656
01:08:31,738 --> 01:08:33,238
and then we multiply it with the second

1657
01:08:33,238 --> 01:08:34,859
statement

1658
01:08:34,859 --> 01:08:36,719
but this might be a problem right now we

1659
01:08:36,719 --> 01:08:38,160
have this bad element here and we raise

1660
01:08:38,160 --> 01:08:40,020
it to some random number

1661
01:08:40,020 --> 01:08:41,939
so we might actually be unlucky and have

1662
01:08:41,939 --> 01:08:43,799
that Alpha raised to that random to a

1663
01:08:43,799 --> 01:08:46,259
random number equals one modulo n

1664
01:08:46,259 --> 01:08:47,939
and then this means that the bed element

1665
01:08:47,939 --> 01:08:49,560
vanishes from the claim we have a

1666
01:08:49,560 --> 01:08:51,479
correct claim and the proofer can be

1667
01:08:51,479 --> 01:08:53,580
honest in the rest of the execution and

1668
01:08:53,580 --> 01:08:55,500
the verifier will never notice that

1669
01:08:55,500 --> 01:08:56,460
there was something wrong in the

1670
01:08:56,460 --> 01:08:58,580
beginning

1671
01:08:58,799 --> 01:09:00,060
um now what's the probability of this

1672
01:09:00,060 --> 01:09:01,620
event happening well that depends on the

1673
01:09:01,620 --> 01:09:04,738
order of alpha so if we say that Alpha

1674
01:09:04,738 --> 01:09:06,960
is an element of order D then the

1675
01:09:06,960 --> 01:09:08,399
probability that Alpha raised to a

1676
01:09:08,399 --> 01:09:10,620
random number equals one module n is

1677
01:09:10,620 --> 01:09:12,359
just one over d

1678
01:09:12,359 --> 01:09:14,160
and so we have the probability that

1679
01:09:14,160 --> 01:09:16,859
verify accepts that and is composite

1680
01:09:16,859 --> 01:09:19,439
even though it's Prime is at least one

1681
01:09:19,439 --> 01:09:21,299
over d

1682
01:09:21,299 --> 01:09:23,160
uh I forget to say that this attack was

1683
01:09:23,160 --> 01:09:25,799
first shown in the context of ddfs by

1684
01:09:25,799 --> 01:09:28,819
beneathans and fish

1685
01:09:29,339 --> 01:09:31,920
um okay good so this is a problem but in

1686
01:09:31,920 --> 01:09:34,319
our setting we can take care of it so

1687
01:09:34,319 --> 01:09:36,000
let's see for our work we first make

1688
01:09:36,000 --> 01:09:37,979
some observations so here I'm reminding

1689
01:09:37,979 --> 01:09:40,080
you again of pro steering and now we're

1690
01:09:40,080 --> 01:09:41,819
in the setting where we have approval

1691
01:09:41,819 --> 01:09:43,620
that claims the number is composite and

1692
01:09:43,620 --> 01:09:46,080
the result is minus Alpha

1693
01:09:46,080 --> 01:09:48,060
so the first observation we make is that

1694
01:09:48,060 --> 01:09:49,979
in this case the verifier only needs to

1695
01:09:49,979 --> 01:09:52,140
exclude that the correct result is minus

1696
01:09:52,140 --> 01:09:53,040
one

1697
01:09:53,040 --> 01:09:55,620
so we don't care if the proverb cheats a

1698
01:09:55,620 --> 01:09:57,060
little bit and claims that the result is

1699
01:09:57,060 --> 01:09:59,640
minus Alpha even though it's 7 or it's

1700
01:09:59,640 --> 01:10:01,739
13 or whatever because in all of those

1701
01:10:01,739 --> 01:10:03,540
cases we would have that the number is

1702
01:10:03,540 --> 01:10:05,040
composite and that's all the information

1703
01:10:05,040 --> 01:10:06,300
that we want

1704
01:10:06,300 --> 01:10:08,400
we just need to remember out that it is

1705
01:10:08,400 --> 01:10:10,140
actually Prime

1706
01:10:10,140 --> 01:10:11,400
then we have seen that the success

1707
01:10:11,400 --> 01:10:13,080
probability of the attack depends on the

1708
01:10:13,080 --> 01:10:14,580
order of IFR

1709
01:10:14,580 --> 01:10:16,500
but if we assume that we have a

1710
01:10:16,500 --> 01:10:19,260
malicious proverb then n is Prime and

1711
01:10:19,260 --> 01:10:21,540
then we know the group order it's just n

1712
01:10:21,540 --> 01:10:23,640
minus one and we know that the order of

1713
01:10:23,640 --> 01:10:25,199
alpha because it's an element of the

1714
01:10:25,199 --> 01:10:27,600
group divides Disorder so then we know

1715
01:10:27,600 --> 01:10:31,140
that Alpha divides K times 2 to the n

1716
01:10:31,140 --> 01:10:34,620
and we can use this information to check

1717
01:10:34,620 --> 01:10:37,140
if the order fiber is too small

1718
01:10:37,140 --> 01:10:40,140
okay so here we're in a lucky situation

1719
01:10:40,140 --> 01:10:41,640
which is very different from the usual

1720
01:10:41,640 --> 01:10:43,679
settings when you use vdf

1721
01:10:43,679 --> 01:10:45,600
um we're assuming that if we have images

1722
01:10:45,600 --> 01:10:47,940
proverb then we have a prime number and

1723
01:10:47,940 --> 01:10:49,739
so by assuming you have a prime number

1724
01:10:49,739 --> 01:10:51,540
this gives us much more structure that

1725
01:10:51,540 --> 01:10:53,520
we can use to construct the sound

1726
01:10:53,520 --> 01:10:55,440
protocol

1727
01:10:55,440 --> 01:10:57,600
and this is how the protocol looks like

1728
01:10:57,600 --> 01:10:59,580
so again this is a non-premulatory

1729
01:10:59,580 --> 01:11:01,199
certificate

1730
01:11:01,199 --> 01:11:04,140
uh this is posterior again

1731
01:11:04,140 --> 01:11:06,120
and now we have approved by their claims

1732
01:11:06,120 --> 01:11:09,900
uh it has a number that is composite so

1733
01:11:09,900 --> 01:11:12,000
the result of the primality test is

1734
01:11:12,000 --> 01:11:14,340
minus mu for some mu that is not equal

1735
01:11:14,340 --> 01:11:15,960
to one

1736
01:11:15,960 --> 01:11:18,060
and now what the verifier does is it

1737
01:11:18,060 --> 01:11:20,159
performs checks on the order of mu and

1738
01:11:20,159 --> 01:11:22,320
then depending on the outcome

1739
01:11:22,320 --> 01:11:25,020
um the protocol looks differently

1740
01:11:25,020 --> 01:11:27,300
so let's first assume that the verify

1741
01:11:27,300 --> 01:11:28,800
has raised this element here to the

1742
01:11:28,800 --> 01:11:31,380
power K and has already gotten one

1743
01:11:31,380 --> 01:11:33,300
so that means the order of new divides K

1744
01:11:33,300 --> 01:11:35,940
so it's odd and it is smaller

1745
01:11:35,940 --> 01:11:38,580
this isn't for the very very lucky case

1746
01:11:38,580 --> 01:11:40,679
because then again it doesn't doesn't

1747
01:11:40,679 --> 01:11:43,020
need any help from the prover to check

1748
01:11:43,020 --> 01:11:45,600
if the result is true so I don't want to

1749
01:11:45,600 --> 01:11:47,159
go into detail what the verifier does

1750
01:11:47,159 --> 01:11:49,020
but it performs some number of theoretic

1751
01:11:49,020 --> 01:11:50,640
tricks and then it can just output

1752
01:11:50,640 --> 01:11:52,679
except or result reject simply without

1753
01:11:52,679 --> 01:11:55,800
ever seeing a message from the approver

1754
01:11:55,800 --> 01:11:57,659
the second case is that the order is

1755
01:11:57,659 --> 01:11:59,699
large enough so the verifier has taken

1756
01:11:59,699 --> 01:12:01,739
the element mu raised it to the power K

1757
01:12:01,739 --> 01:12:04,440
and then 2 to the Lambda Times log n

1758
01:12:04,440 --> 01:12:06,300
where Lambda has some statistical

1759
01:12:06,300 --> 01:12:08,880
security parameter and the result is not

1760
01:12:08,880 --> 01:12:09,900
one

1761
01:12:09,900 --> 01:12:11,880
again recall that if we have a malicious

1762
01:12:11,880 --> 01:12:14,280
prover the order of mu divides K times 2

1763
01:12:14,280 --> 01:12:16,560
to the m and now we've raised it to K

1764
01:12:16,560 --> 01:12:18,540
times the sufficiently large power of

1765
01:12:18,540 --> 01:12:21,480
two we didn't get one and so this means

1766
01:12:21,480 --> 01:12:23,820
the order of mu is very very large so

1767
01:12:23,820 --> 01:12:25,380
the success probability of the attack

1768
01:12:25,380 --> 01:12:27,960
that we have seen is negligible and so

1769
01:12:27,960 --> 01:12:29,520
in this case the problem can just send

1770
01:12:29,520 --> 01:12:32,400
phxpv without anything else and then the

1771
01:12:32,400 --> 01:12:34,320
verify can sound the output except or

1772
01:12:34,320 --> 01:12:36,179
reject

1773
01:12:36,179 --> 01:12:38,520
and the last case is that the orders

1774
01:12:38,520 --> 01:12:41,340
even but it's not big enough so we're

1775
01:12:41,340 --> 01:12:44,040
performing this check raise mu to the

1776
01:12:44,040 --> 01:12:46,320
power K times 2 to the Lambda log n we

1777
01:12:46,320 --> 01:12:48,960
got the result one

1778
01:12:48,960 --> 01:12:51,179
so in this case we're going to use a

1779
01:12:51,179 --> 01:12:52,679
trick that's similar to the one we used

1780
01:12:52,679 --> 01:12:55,260
in a paper from last year at crypto

1781
01:12:55,260 --> 01:12:58,260
so we let the provery step a little bit

1782
01:12:58,260 --> 01:12:59,699
earlier the Hoover should not perform

1783
01:12:59,699 --> 01:13:02,280
the entire exponentiation but it should

1784
01:13:02,280 --> 01:13:04,800
stop at 2 to the N minus 1 minus Lambda

1785
01:13:04,800 --> 01:13:06,179
Times log n

1786
01:13:06,179 --> 01:13:09,000
and output the result way and also a

1787
01:13:09,000 --> 01:13:11,520
proof that Y is the correct thing and

1788
01:13:11,520 --> 01:13:13,080
then the verifier performs the final

1789
01:13:13,080 --> 01:13:15,179
exponentiation itself so it takes this

1790
01:13:15,179 --> 01:13:17,280
way raises it to the power two times

1791
01:13:17,280 --> 01:13:19,500
Lambda Times log n and then checks if

1792
01:13:19,500 --> 01:13:21,480
the result is really minus mu as the

1793
01:13:21,480 --> 01:13:23,219
prover Clint

1794
01:13:23,219 --> 01:13:25,020
again I don't want to go into detail of

1795
01:13:25,020 --> 01:13:26,699
why this is sound but the idea is that

1796
01:13:26,699 --> 01:13:28,860
by performing this final exponentiation

1797
01:13:28,860 --> 01:13:30,900
itself the verifier somehow weeds out

1798
01:13:30,900 --> 01:13:33,239
potentially bad elements that the prover

1799
01:13:33,239 --> 01:13:35,760
used to cheat with and so also this case

1800
01:13:35,760 --> 01:13:38,040
is statistically sound and with the

1801
01:13:38,040 --> 01:13:41,159
verify outputs except reject

1802
01:13:41,159 --> 01:13:42,719
and that's the protocol now we've

1803
01:13:42,719 --> 01:13:45,239
covered all of the cases

1804
01:13:45,239 --> 01:13:47,400
so to sum up we construct a

1805
01:13:47,400 --> 01:13:49,320
non-permanent certificate for profit

1806
01:13:49,320 --> 01:13:51,239
numbers with the following efficiency

1807
01:13:51,239 --> 01:13:54,300
properties so compared to PHX Poe in

1808
01:13:54,300 --> 01:13:56,520
person number groups it's only slightly

1809
01:13:56,520 --> 01:13:57,300
more

1810
01:13:57,300 --> 01:14:00,420
a complex but our protocol is

1811
01:14:00,420 --> 01:14:02,820
statistically sound and hxp we didn't

1812
01:14:02,820 --> 01:14:05,159
give us any cryptographic soundness

1813
01:14:05,159 --> 01:14:07,020
and compared to double checking we've

1814
01:14:07,020 --> 01:14:09,480
reduced the complexity of verifying from

1815
01:14:09,480 --> 01:14:11,520
n multiplications to all of them at

1816
01:14:11,520 --> 01:14:13,620
times login so in practice that means

1817
01:14:13,620 --> 01:14:16,080
we've reduced the work from weeks to

1818
01:14:16,080 --> 01:14:18,179
hours

1819
01:14:18,179 --> 01:14:20,640
one interesting open problem is to also

1820
01:14:20,640 --> 01:14:22,980
construct a cryptographically sounded

1821
01:14:22,980 --> 01:14:25,380
certificate of primality as I said

1822
01:14:25,380 --> 01:14:27,719
before most numbers are composite so our

1823
01:14:27,719 --> 01:14:29,880
certificate already covers a lot of the

1824
01:14:29,880 --> 01:14:31,679
cases but of course it would be nice to

1825
01:14:31,679 --> 01:14:33,780
cover all of them

1826
01:14:33,780 --> 01:14:36,239
and another open question is to

1827
01:14:36,239 --> 01:14:38,219
construct similar certificates of

1828
01:14:38,219 --> 01:14:40,440
non-permability for other types of whole

1829
01:14:40,440 --> 01:14:42,540
numbers such as mercen numbers which are

1830
01:14:42,540 --> 01:14:45,960
of the form 2 to the N minus 1.

1831
01:14:45,960 --> 01:14:47,580
and that's it now we're happy to take

1832
01:14:47,580 --> 01:14:49,820
questions

1833
01:14:54,840 --> 01:14:56,520
thanks we have plenty of time for

1834
01:14:56,520 --> 01:14:58,760
questions

1835
01:15:04,699 --> 01:15:08,100
so my question was why are Prof primes

1836
01:15:08,100 --> 01:15:10,199
interesting why is there you know what

1837
01:15:10,199 --> 01:15:12,480
why was there so much interest in this

1838
01:15:12,480 --> 01:15:15,300
uh and why is it interesting that

1839
01:15:15,300 --> 01:15:18,179
they're non-primes right so fraught

1840
01:15:18,179 --> 01:15:19,739
prims are interesting for the community

1841
01:15:19,739 --> 01:15:21,719
because we have such a nice primality

1842
01:15:21,719 --> 01:15:24,480
test which is deterministic right

1843
01:15:24,480 --> 01:15:26,880
um so yeah that's why

1844
01:15:26,880 --> 01:15:28,140
um they're testing a lot of protein

1845
01:15:28,140 --> 01:15:29,940
numbers and then

1846
01:15:29,940 --> 01:15:30,540
um

1847
01:15:30,540 --> 01:15:32,159
yeah of course you want to make sure

1848
01:15:32,159 --> 01:15:33,480
that you don't miss a prime number so

1849
01:15:33,480 --> 01:15:35,760
when you work with such giant numbers so

1850
01:15:35,760 --> 01:15:37,679
you want to approve for both cases you

1851
01:15:37,679 --> 01:15:38,940
want to be sure when you found

1852
01:15:38,940 --> 01:15:40,199
paranormal you want to be sure that it's

1853
01:15:40,199 --> 01:15:42,120
Prime but also when someone claims no no

1854
01:15:42,120 --> 01:15:44,280
this number is composite and then we

1855
01:15:44,280 --> 01:15:45,780
also want to be sure it's actually

1856
01:15:45,780 --> 01:15:48,000
confidence that and you have not missed

1857
01:15:48,000 --> 01:15:49,980
a big Prime member

1858
01:15:49,980 --> 01:15:52,459
um yeah

1859
01:16:02,219 --> 01:16:04,380
well let's let's thank Charlotte and uh

1860
01:16:04,380 --> 01:16:06,800
let's

1861
01:16:15,900 --> 01:16:17,900
see

1862
01:16:26,820 --> 01:16:29,159
look thank you

1863
01:16:29,159 --> 01:16:30,900
I'm going to introduce you

1864
01:16:30,900 --> 01:16:32,100
um

1865
01:16:32,100 --> 01:16:34,980
all right so uh the last paper in the

1866
01:16:34,980 --> 01:16:37,500
session is transparent batchable time

1867
01:16:37,500 --> 01:16:39,239
lock puzzles and applications to

1868
01:16:39,239 --> 01:16:41,040
Byzantine consensus

1869
01:16:41,040 --> 01:16:44,219
by shravan srinivasan Julian lost Julia

1870
01:16:44,219 --> 01:16:48,060
malavolta cardig Nayak Bob is papamantu

1871
01:16:48,060 --> 01:16:50,520
and Shri

1872
01:16:50,520 --> 01:16:53,520
um and

1873
01:16:54,239 --> 01:16:57,620
um shravan will give the talk uh hi uh

1874
01:16:57,620 --> 01:17:00,120
thank you for the introduction I'm going

1875
01:17:00,120 --> 01:17:02,159
to repeat it uh this is a giant work

1876
01:17:02,159 --> 01:17:05,599
with Julian lost Julia

1877
01:17:08,460 --> 01:17:10,739
so our work our work is on building

1878
01:17:10,739 --> 01:17:12,480
transparent batchable time lock puzzles

1879
01:17:12,480 --> 01:17:14,460
that has applications in our Byzantine

1880
01:17:14,460 --> 01:17:15,659
conferences

1881
01:17:15,659 --> 01:17:18,239
uh thanks to the speakers before me they

1882
01:17:18,239 --> 01:17:20,340
pretty much gave all the setup and

1883
01:17:20,340 --> 01:17:22,260
examples which I was I'm going to go

1884
01:17:22,260 --> 01:17:24,420
over in this talk but yeah here is it

1885
01:17:24,420 --> 01:17:26,760
one more time so um time block Was A

1886
01:17:26,760 --> 01:17:29,280
cryptographic Primitive that lets Alice

1887
01:17:29,280 --> 01:17:32,040
encrypt a message into the future say uh

1888
01:17:32,040 --> 01:17:34,219
Alice wants to send a message M to Bob

1889
01:17:34,219 --> 01:17:36,659
Alice puts this in a Time Block Puzzle

1890
01:17:36,659 --> 01:17:38,460
and gives it to Bob

1891
01:17:38,460 --> 01:17:40,800
Bob will be unable to open this time

1892
01:17:40,800 --> 01:17:45,060
lock puzzle Before Time t uh two Key

1893
01:17:45,060 --> 01:17:46,739
properties which we want from the time

1894
01:17:46,739 --> 01:17:49,380
log puzzles are first uh it should be

1895
01:17:49,380 --> 01:17:51,600
easy for Alice to generate a time lock

1896
01:17:51,600 --> 01:17:54,780
puzzle and um even if Bob implies

1897
01:17:54,780 --> 01:17:56,760
parallel strategies Bob should not be

1898
01:17:56,760 --> 01:17:58,980
able to open up open the time lock

1899
01:17:58,980 --> 01:18:01,620
puzzle anytime before d

1900
01:18:01,620 --> 01:18:03,060
um panel business have found

1901
01:18:03,060 --> 01:18:05,780
applications and uh timed commitments

1902
01:18:05,780 --> 01:18:08,520
auctions blockchains and many more

1903
01:18:08,520 --> 01:18:11,640
applications continue to emerge

1904
01:18:11,640 --> 01:18:13,739
um unfortunately uh existing time lock

1905
01:18:13,739 --> 01:18:17,699
puzzles have a key drawback first it

1906
01:18:17,699 --> 01:18:20,460
does not scale with multiple users say

1907
01:18:20,460 --> 01:18:22,560
uh in a setting like auction where you

1908
01:18:22,560 --> 01:18:24,120
have to open up multiple time lock

1909
01:18:24,120 --> 01:18:25,920
puzzles to figure out who the winner is

1910
01:18:25,920 --> 01:18:27,480
then

1911
01:18:27,480 --> 01:18:29,460
um with traditional time lock puzzles

1912
01:18:29,460 --> 01:18:31,380
you are stuck with opening one puzzle at

1913
01:18:31,380 --> 01:18:32,400
a time

1914
01:18:32,400 --> 01:18:34,980
um however uh matchable timeline puzzles

1915
01:18:34,980 --> 01:18:36,780
are just New Primitives introduced by

1916
01:18:36,780 --> 01:18:40,500
maloval.ly agarajan uh in in this uh in

1917
01:18:40,500 --> 01:18:42,600
this setting uh in in this in these

1918
01:18:42,600 --> 01:18:44,820
constructions uh you can combine many

1919
01:18:44,820 --> 01:18:46,500
individual time lock puzzles into a

1920
01:18:46,500 --> 01:18:48,719
single bashed puzzle and you can open up

1921
01:18:48,719 --> 01:18:50,640
the batch puzzle for the price of one

1922
01:18:50,640 --> 01:18:52,980
yeah um as mentioned by the other

1923
01:18:52,980 --> 01:18:55,320
speakers before um they also support a

1924
01:18:55,320 --> 01:18:58,080
homomorphic properties where you can in

1925
01:18:58,080 --> 01:19:00,659
fact perform computations inside uh the

1926
01:19:00,659 --> 01:19:04,980
bashed puzzle so um yeah the batch plan

1927
01:19:04,980 --> 01:19:08,880
block was the focus of this work uh and

1928
01:19:08,880 --> 01:19:12,300
there are two known um time lock puzzle

1929
01:19:12,300 --> 01:19:14,880
constructions one is based on the RSA

1930
01:19:14,880 --> 01:19:16,800
setting and the other one is based on

1931
01:19:16,800 --> 01:19:19,860
our class groups uh RSA based setting uh

1932
01:19:19,860 --> 01:19:21,900
RSA based construction does not does

1933
01:19:21,900 --> 01:19:23,940
require a trusted setup on the other

1934
01:19:23,940 --> 01:19:25,500
hand class groups based construction

1935
01:19:25,500 --> 01:19:29,159
does not required uh however uh both of

1936
01:19:29,159 --> 01:19:31,500
these constructions suffer are two

1937
01:19:31,500 --> 01:19:34,140
drawbacks first one is these

1938
01:19:34,140 --> 01:19:36,000
constructions required on a priority

1939
01:19:36,000 --> 01:19:39,179
Bond on the batch size meaning someone

1940
01:19:39,179 --> 01:19:41,219
even before they generate a puzzle they

1941
01:19:41,219 --> 01:19:43,500
should uh they should know the total

1942
01:19:43,500 --> 01:19:45,120
number of puzzles that could be bashed

1943
01:19:45,120 --> 01:19:47,640
in this setting and uh and which is a

1944
01:19:47,640 --> 01:19:49,560
which is a drawback because you can't do

1945
01:19:49,560 --> 01:19:53,159
unbounded batching another drawback is

1946
01:19:53,159 --> 01:19:53,940
um

1947
01:19:53,940 --> 01:19:56,219
the uh the puzzle slices in these

1948
01:19:56,219 --> 01:19:58,140
settings are

1949
01:19:58,140 --> 01:20:01,320
um are linear in the number of number of

1950
01:20:01,320 --> 01:20:04,080
uh uh people in the in the batch set in

1951
01:20:04,080 --> 01:20:06,900
the batch size so um you're stuck with

1952
01:20:06,900 --> 01:20:09,120
large puzzle sizes uh in these

1953
01:20:09,120 --> 01:20:11,940
constructions so um we ask in this book

1954
01:20:11,940 --> 01:20:15,060
can we build a batchable uh uh time lock

1955
01:20:15,060 --> 01:20:17,340
puzzle that has transparent setup can

1956
01:20:17,340 --> 01:20:20,280
support Unbound and batching and uh and

1957
01:20:20,280 --> 01:20:22,380
uh and has puzzle size independent asked

1958
01:20:22,380 --> 01:20:24,120
uh the batch size

1959
01:20:24,120 --> 01:20:26,940
yeah so why do we care about a time lock

1960
01:20:26,940 --> 01:20:29,159
puzzle with these properties so the

1961
01:20:29,159 --> 01:20:30,480
first crucial

1962
01:20:30,480 --> 01:20:31,020
um

1963
01:20:31,020 --> 01:20:33,960
uh and these app these time lockers have

1964
01:20:33,960 --> 01:20:35,400
applications in the context of

1965
01:20:35,400 --> 01:20:37,800
decentralized setting uh especially in

1966
01:20:37,800 --> 01:20:41,640
uh payment consensus and mme prevention

1967
01:20:41,640 --> 01:20:45,300
and so on so um yeah uh considered in a

1968
01:20:45,300 --> 01:20:47,520
permissionless setting um these

1969
01:20:47,520 --> 01:20:49,679
properties are off the bat useful so

1970
01:20:49,679 --> 01:20:52,020
first we don't know uh number of nodes

1971
01:20:52,020 --> 01:20:54,659
that are there in the system and uh and

1972
01:20:54,659 --> 01:20:56,280
it's also impractical to rely on a

1973
01:20:56,280 --> 01:20:58,860
trusted setup uh moreover you are stuck

1974
01:20:58,860 --> 01:21:00,540
with large puzzle sizes in the previous

1975
01:21:00,540 --> 01:21:03,179
constructions and that increases the

1976
01:21:03,179 --> 01:21:06,120
communication overhead as well so uh our

1977
01:21:06,120 --> 01:21:08,580
contributions are as follows so we

1978
01:21:08,580 --> 01:21:10,500
introduce a new time lock puzzle which

1979
01:21:10,500 --> 01:21:13,860
has which is matchable has transparent

1980
01:21:13,860 --> 01:21:16,199
setup and has uh can do unbounded

1981
01:21:16,199 --> 01:21:18,480
matching and has compact password size

1982
01:21:18,480 --> 01:21:20,820
however we use indistinguishability

1983
01:21:20,820 --> 01:21:23,520
obfuscation so uh this makes it a

1984
01:21:23,520 --> 01:21:25,560
feasibility result and we see that there

1985
01:21:25,560 --> 01:21:27,420
are no fundamental barriers in achieving

1986
01:21:27,420 --> 01:21:29,280
a construction like this and we leave

1987
01:21:29,280 --> 01:21:31,560
the task of coming up with a efficient

1988
01:21:31,560 --> 01:21:35,580
construction to future work so

1989
01:21:35,580 --> 01:21:38,340
these time lock puzzles are useful in

1990
01:21:38,340 --> 01:21:40,380
conferences and especially uh they solve

1991
01:21:40,380 --> 01:21:43,140
to long-standing open problems first one

1992
01:21:43,140 --> 01:21:44,760
is in the context of permissionless

1993
01:21:44,760 --> 01:21:48,540
setting so uh in this setting uh uh this

1994
01:21:48,540 --> 01:21:49,620
in the setting it's called as mobile

1995
01:21:49,620 --> 01:21:51,420
sluggish model where it's a weaker

1996
01:21:51,420 --> 01:21:53,880
notion of a synchrony where the messages

1997
01:21:53,880 --> 01:21:56,219
can get delayed uh uh and in this

1998
01:21:56,219 --> 01:21:58,260
setting we can we show that uh we can

1999
01:21:58,260 --> 01:21:59,340
achieve the first permissionless

2000
01:21:59,340 --> 01:22:02,580
protocol and we also uh build the first

2001
01:22:02,580 --> 01:22:06,020
round uh expected uh oauth one around

2002
01:22:06,020 --> 01:22:08,280
Byzantine broadcast under strongly

2003
01:22:08,280 --> 01:22:11,280
adaptive and uh current majority setting

2004
01:22:11,280 --> 01:22:14,760
so um this is going to be the outline

2005
01:22:14,760 --> 01:22:16,320
for the rest of my talk I'm going to

2006
01:22:16,320 --> 01:22:17,880
introduce the preliminaries that are

2007
01:22:17,880 --> 01:22:20,400
required to realize our construction I'm

2008
01:22:20,400 --> 01:22:22,380
going to tell you how we build our time

2009
01:22:22,380 --> 01:22:24,960
log puzzle and then I'm going to explain

2010
01:22:24,960 --> 01:22:27,659
how we can use uh this time lock puzzle

2011
01:22:27,659 --> 01:22:28,640
uh

2012
01:22:28,640 --> 01:22:32,280
and and permissionless setting so um

2013
01:22:32,280 --> 01:22:34,140
first jumping into the preliminaries

2014
01:22:34,140 --> 01:22:36,179
being the first building block which we

2015
01:22:36,179 --> 01:22:38,699
need is homomorphic time lock puzzles so

2016
01:22:38,699 --> 01:22:40,739
homomorphic time lock puzzles are these

2017
01:22:40,739 --> 01:22:43,440
mice Primitives say you have uh time

2018
01:22:43,440 --> 01:22:45,480
Mark poses for message M1 and you have a

2019
01:22:45,480 --> 01:22:48,360
time lock puzzle for message M2 these

2020
01:22:48,360 --> 01:22:50,640
puzzles let you come add these up

2021
01:22:50,640 --> 01:22:52,560
together and come up with a new time

2022
01:22:52,560 --> 01:22:54,600
lock puzzle which is for the message M1

2023
01:22:54,600 --> 01:22:57,719
plus M2 and some a solver has to spend

2024
01:22:57,719 --> 01:22:59,820
time only opening this bashed puzzle to

2025
01:22:59,820 --> 01:23:02,580
get the values uh um the summation of

2026
01:23:02,580 --> 01:23:04,380
these values out of it for the price of

2027
01:23:04,380 --> 01:23:06,659
one they don't have to open M1 and M2

2028
01:23:06,659 --> 01:23:08,219
separately

2029
01:23:08,219 --> 01:23:09,719
um the second key building block which

2030
01:23:09,719 --> 01:23:12,780
we want the uh we use is key homomorphic

2031
01:23:12,780 --> 01:23:15,960
to the random functions say a function f

2032
01:23:15,960 --> 01:23:19,260
is uh key homomorphic pseudo random then

2033
01:23:19,260 --> 01:23:22,679
this has this nice property with if you

2034
01:23:22,679 --> 01:23:25,620
take the prf of message M under key K1

2035
01:23:25,620 --> 01:23:27,900
and if you add it with the prf of

2036
01:23:27,900 --> 01:23:30,840
message M under key K2 this is same as

2037
01:23:30,840 --> 01:23:36,000
the prf of message M under K1 plus K2

2038
01:23:36,000 --> 01:23:38,460
yeah so uh jumping into how our

2039
01:23:38,460 --> 01:23:41,159
construction works so uh in a

2040
01:23:41,159 --> 01:23:42,900
traditional time log puzzle you'll be

2041
01:23:42,900 --> 01:23:45,120
sending around a group element as a time

2042
01:23:45,120 --> 01:23:47,699
lock puzzle but in our setting uh since

2043
01:23:47,699 --> 01:23:49,800
we use IO we send around obfuscated

2044
01:23:49,800 --> 01:23:52,500
programs so let's say in the setting

2045
01:23:52,500 --> 01:23:55,020
player I watched player player I sends

2046
01:23:55,020 --> 01:23:58,679
out an obfuscated program bi so um what

2047
01:23:58,679 --> 01:24:00,420
to tell you more about how this program

2048
01:24:00,420 --> 01:24:04,800
works first this program takes in uh and

2049
01:24:04,800 --> 01:24:07,980
the size of the batch as an input it has

2050
01:24:07,980 --> 01:24:11,280
two key elements inside the circuit so

2051
01:24:11,280 --> 01:24:13,920
first one is uh this is the message Mi

2052
01:24:13,920 --> 01:24:16,380
that the player I wants to put it in the

2053
01:24:16,380 --> 01:24:18,360
Pam lock puzzle that's that's hardwired

2054
01:24:18,360 --> 01:24:20,940
inside the circuit and also the uh the

2055
01:24:20,940 --> 01:24:23,400
prf key which which we use that's also

2056
01:24:23,400 --> 01:24:26,460
hardwired uh enter this circuit so um

2057
01:24:26,460 --> 01:24:28,800
when someone runs this program with bot

2058
01:24:28,800 --> 01:24:31,100
size n uh it spits out

2059
01:24:31,100 --> 01:24:34,199
uh important uh two outputs the first

2060
01:24:34,199 --> 01:24:36,239
one is it's going to spit out a time

2061
01:24:36,239 --> 01:24:40,080
lock puzzle off the key Ki and it's

2062
01:24:40,080 --> 01:24:43,080
going to give another uh Vector which is

2063
01:24:43,080 --> 01:24:45,540
a structured Vector of ciphertext so

2064
01:24:45,540 --> 01:24:47,159
what it's essentially going to do is

2065
01:24:47,159 --> 01:24:50,280
it's going to uh take the prf uh under

2066
01:24:50,280 --> 01:24:54,000
the key Ki for position one so we put

2067
01:24:54,000 --> 01:24:56,100
plugin value one and get the prf value

2068
01:24:56,100 --> 01:24:57,960
out of it and you we do this for all the

2069
01:24:57,960 --> 01:25:00,600
positions in the vector however at

2070
01:25:00,600 --> 01:25:03,600
position I uh we also mask it with the

2071
01:25:03,600 --> 01:25:05,340
value or the message that has to be

2072
01:25:05,340 --> 01:25:08,100
encoded here so that's going to be RMI

2073
01:25:08,100 --> 01:25:11,460
so uh with this uh this is how somebody

2074
01:25:11,460 --> 01:25:14,760
generates a puzzle in our setting so uh

2075
01:25:14,760 --> 01:25:16,620
once you have these puzzles so the

2076
01:25:16,620 --> 01:25:18,780
question comes about how do you do how

2077
01:25:18,780 --> 01:25:20,580
do you open up these puzzles in a

2078
01:25:20,580 --> 01:25:24,060
matched manner so um uh um uh so to do

2079
01:25:24,060 --> 01:25:27,179
back solving so first the solver gets

2080
01:25:27,179 --> 01:25:29,880
the program p12 in this example there

2081
01:25:29,880 --> 01:25:32,219
are three uh batch three batch sizes

2082
01:25:32,219 --> 01:25:34,739
three the the solver gets these programs

2083
01:25:34,739 --> 01:25:37,560
first the solver runs the program P1

2084
01:25:37,560 --> 01:25:40,679
gets the two values out of it uh K1 and

2085
01:25:40,679 --> 01:25:43,679
that's a TLP of the key K1 and the

2086
01:25:43,679 --> 01:25:45,960
master ciphertext Vector it does this

2087
01:25:45,960 --> 01:25:48,060
for the player number two Justice for

2088
01:25:48,060 --> 01:25:50,100
play number three and so on so you can

2089
01:25:50,100 --> 01:25:53,280
see that uh the M1 is appropriately set

2090
01:25:53,280 --> 01:25:55,800
in uh in position one M2 is in position

2091
01:25:55,800 --> 01:25:58,679
two M3 in position three and so on so

2092
01:25:58,679 --> 01:26:01,739
once uh the solder has computed these

2093
01:26:01,739 --> 01:26:04,500
values so using the homomorphic

2094
01:26:04,500 --> 01:26:06,540
properties of the time lock puzzle we

2095
01:26:06,540 --> 01:26:08,880
can just sum them up sum up dot or

2096
01:26:08,880 --> 01:26:11,219
timelock puzzles to get a new time log

2097
01:26:11,219 --> 01:26:13,260
puzzle which is summation of the keys

2098
01:26:13,260 --> 01:26:14,820
which that were used in the individual

2099
01:26:14,820 --> 01:26:17,699
time lock puzzles and uh we call this KK

2100
01:26:17,699 --> 01:26:21,000
start and the proof and the solar also

2101
01:26:21,000 --> 01:26:23,760
um sums up these uh individual vectors

2102
01:26:23,760 --> 01:26:26,940
that was generated uh position y element

2103
01:26:26,940 --> 01:26:29,460
wise so you end up with summation of

2104
01:26:29,460 --> 01:26:33,179
multiple prf values plus message M1 and

2105
01:26:33,179 --> 01:26:35,940
position one summation of prf values on

2106
01:26:35,940 --> 01:26:38,639
under position two with message M2 and

2107
01:26:38,639 --> 01:26:43,679
so on with SH M3 yeah I'll so from now

2108
01:26:43,679 --> 01:26:45,120
on I'm going to focus only on the stuff

2109
01:26:45,120 --> 01:26:47,460
which is on the rightmost corner so I'm

2110
01:26:47,460 --> 01:26:48,900
going to copy these values to the next

2111
01:26:48,900 --> 01:26:51,900
slide so in this slide so first we

2112
01:26:51,900 --> 01:26:54,659
exploit the homomorphic properties of

2113
01:26:54,659 --> 01:26:58,139
the prf so uh essentially uh when

2114
01:26:58,139 --> 01:27:00,420
earlier this was the summation of PR of

2115
01:27:00,420 --> 01:27:02,940
values but the the mice property about

2116
01:27:02,940 --> 01:27:05,040
homomorphism lets us take the summation

2117
01:27:05,040 --> 01:27:07,860
inside the prf so it's going to be a

2118
01:27:07,860 --> 01:27:09,960
summation of keys rather than summation

2119
01:27:09,960 --> 01:27:13,500
of prf values so uh we can do this for

2120
01:27:13,500 --> 01:27:15,900
um all the positions in the vector and

2121
01:27:15,900 --> 01:27:17,699
you Mr you end up with a vector that

2122
01:27:17,699 --> 01:27:20,940
looks something like uh this on left so

2123
01:27:20,940 --> 01:27:23,400
now we go about opening the time lock

2124
01:27:23,400 --> 01:27:26,280
puzzle by spending time T you open the

2125
01:27:26,280 --> 01:27:27,840
time Block Puzzle and you come up with

2126
01:27:27,840 --> 01:27:30,360
the key case start once you have this

2127
01:27:30,360 --> 01:27:32,400
key K star uh

2128
01:27:32,400 --> 01:27:34,739
once you have this key case start so the

2129
01:27:34,739 --> 01:27:38,460
solver runs the prf under PK start and

2130
01:27:38,460 --> 01:27:41,460
position I position two position one

2131
01:27:41,460 --> 01:27:43,560
position two and purchase position three

2132
01:27:43,560 --> 01:27:45,600
and so on and then can come up with

2133
01:27:45,600 --> 01:27:48,719
another Vector uh as I show uh and if I

2134
01:27:48,719 --> 01:27:52,620
show it here so once you compute this

2135
01:27:52,620 --> 01:27:54,719
this Vector we can simply subtract it

2136
01:27:54,719 --> 01:27:56,940
from the previous vector and get the

2137
01:27:56,940 --> 01:28:00,719
message M1 M2 and M3 so uh that's how

2138
01:28:00,719 --> 01:28:03,420
you recover the message uh messages from

2139
01:28:03,420 --> 01:28:07,080
the uh from the timeline puzzle so um

2140
01:28:07,080 --> 01:28:09,659
jumping into how we use our time lock

2141
01:28:09,659 --> 01:28:14,699
puzzles so um a brief uh context so in

2142
01:28:14,699 --> 01:28:16,440
the permissionless setting we do not

2143
01:28:16,440 --> 01:28:17,820
know the number of nodes that are there

2144
01:28:17,820 --> 01:28:20,040
in the system and we do there is no

2145
01:28:20,040 --> 01:28:22,199
authentication mechanism between nodes

2146
01:28:22,199 --> 01:28:24,239
and nodes have to communicate with each

2147
01:28:24,239 --> 01:28:26,820
other over uh unauthenticated channels

2148
01:28:26,820 --> 01:28:29,460
so um Nakamoto contents this was this

2149
01:28:29,460 --> 01:28:31,679
breakthrough result where you they

2150
01:28:31,679 --> 01:28:34,139
should shown that you could do this you

2151
01:28:34,139 --> 01:28:37,139
can achieve permissionless consensus and

2152
01:28:37,139 --> 01:28:39,179
they use

2153
01:28:39,179 --> 01:28:42,659
proof of work and the key idea here is

2154
01:28:42,659 --> 01:28:44,460
the longest chain always spins that's

2155
01:28:44,460 --> 01:28:46,980
the the governing principle behind how

2156
01:28:46,980 --> 01:28:49,320
Nakamoto consensus Works

2157
01:28:49,320 --> 01:28:51,900
um prior books have shown that Nakamoto

2158
01:28:51,900 --> 01:28:53,340
consensus is secure only in the

2159
01:28:53,340 --> 01:28:55,920
synchronous model of communication

2160
01:28:55,920 --> 01:28:58,800
um so uh just the overview of how it all

2161
01:28:58,800 --> 01:29:01,080
buys together so in the synchronous

2162
01:29:01,080 --> 01:29:03,480
model of communication uh you assume

2163
01:29:03,480 --> 01:29:05,580
that all honest messages have an upper

2164
01:29:05,580 --> 01:29:08,280
Bond Delta so this is the time it takes

2165
01:29:08,280 --> 01:29:09,960
for any honest message to get a

2166
01:29:09,960 --> 01:29:12,300
delivered to another honest person uh

2167
01:29:12,300 --> 01:29:15,239
and uh and and and and and synchronous

2168
01:29:15,239 --> 01:29:17,460
model you assume that every player knows

2169
01:29:17,460 --> 01:29:19,920
the Delta and even the protocol designer

2170
01:29:19,920 --> 01:29:21,540
knows the Delta

2171
01:29:21,540 --> 01:29:24,120
um but if you assumes if you make such

2172
01:29:24,120 --> 01:29:26,219
assumptions you know that you you know

2173
01:29:26,219 --> 01:29:27,360
that you can achieve permissionless

2174
01:29:27,360 --> 01:29:29,340
consensus which was considered to be a

2175
01:29:29,340 --> 01:29:32,639
difficult problem in the past

2176
01:29:32,639 --> 01:29:35,940
um however um the topic of synchronous

2177
01:29:35,940 --> 01:29:37,920
model is it's exceedingly optimistic so

2178
01:29:37,920 --> 01:29:40,199
we deployment to consensus on the

2179
01:29:40,199 --> 01:29:42,360
internet but expecting uh you have

2180
01:29:42,360 --> 01:29:43,800
synchronous communication is something

2181
01:29:43,800 --> 01:29:46,139
it's excitingly optimistic

2182
01:29:46,139 --> 01:29:46,920
um

2183
01:29:46,920 --> 01:29:49,320
other models of communication are

2184
01:29:49,320 --> 01:29:50,760
partially synchronous and asynchronous

2185
01:29:50,760 --> 01:29:53,400
model of communication so in this we

2186
01:29:53,400 --> 01:29:55,260
don't assume that there's an own Delta

2187
01:29:55,260 --> 01:29:58,320
uh for the honest messages and uh of

2188
01:29:58,320 --> 01:29:58,980
course

2189
01:29:58,980 --> 01:30:00,780
um when you make stuff when you assume

2190
01:30:00,780 --> 01:30:02,880
that you can't do that then uh there are

2191
01:30:02,880 --> 01:30:04,560
impossibility results to say that you

2192
01:30:04,560 --> 01:30:06,360
cannot achieve permissionless consensus

2193
01:30:06,360 --> 01:30:09,300
by Ellen true and Raphael pass uh but

2194
01:30:09,300 --> 01:30:10,560
partialist synchronous and uh

2195
01:30:10,560 --> 01:30:12,540
asynchronous model uh capture the

2196
01:30:12,540 --> 01:30:14,040
realities of the internet much closely

2197
01:30:14,040 --> 01:30:16,739
than the synchronous Network so can we

2198
01:30:16,739 --> 01:30:18,540
have the best of both worlds for the

2199
01:30:18,540 --> 01:30:22,679
long lingering question and uh um go at

2200
01:30:22,679 --> 01:30:24,239
all and later by Andrew ham and I'll

2201
01:30:24,239 --> 01:30:26,100
propose this new model called um a

2202
01:30:26,100 --> 01:30:28,620
sluggish model of communication where

2203
01:30:28,620 --> 01:30:30,900
the honest parties are of two kinds

2204
01:30:30,900 --> 01:30:34,620
first one is the prompt one those nodes

2205
01:30:34,620 --> 01:30:37,139
follow the protocol to the dot and also

2206
01:30:37,139 --> 01:30:39,420
have synchronous communication

2207
01:30:39,420 --> 01:30:41,340
you also have another kind of harness

2208
01:30:41,340 --> 01:30:43,620
node called sluggish node these sluggish

2209
01:30:43,620 --> 01:30:45,719
nodes follow the protocol but for

2210
01:30:45,719 --> 01:30:47,100
gardeners they are suffering Network

2211
01:30:47,100 --> 01:30:48,540
Jitters and bunch of other network

2212
01:30:48,540 --> 01:30:50,580
problems but they are unable to uh

2213
01:30:50,580 --> 01:30:53,340
satisfy synchrony so uh the question

2214
01:30:53,340 --> 01:30:55,679
which we ask in this work are can we

2215
01:30:55,679 --> 01:30:57,659
achieve permissionless consensus in the

2216
01:30:57,659 --> 01:31:00,120
presence of mobile sluggage faults so uh

2217
01:31:00,120 --> 01:31:01,860
one way to think about these models are

2218
01:31:01,860 --> 01:31:04,380
are uh through the uh through the power

2219
01:31:04,380 --> 01:31:06,120
of the adversary and the synchronous

2220
01:31:06,120 --> 01:31:07,980
model the adversary can read the

2221
01:31:07,980 --> 01:31:10,199
messages but cannot stop them but can at

2222
01:31:10,199 --> 01:31:12,120
most delay them by Delta and partially

2223
01:31:12,120 --> 01:31:14,520
synchronous or asynchrony uh the address

2224
01:31:14,520 --> 01:31:16,679
so you can read the messages can delay

2225
01:31:16,679 --> 01:31:18,840
them for a really really long time and

2226
01:31:18,840 --> 01:31:20,460
the model sluggage model you kind of

2227
01:31:20,460 --> 01:31:24,239
have a mix of these two things

2228
01:31:24,239 --> 01:31:26,639
um yeah uh to get to give an overview of

2229
01:31:26,639 --> 01:31:28,860
what we do in this book so uh we modify

2230
01:31:28,860 --> 01:31:32,040
Nakamoto consensus to achieve uh uh

2231
01:31:32,040 --> 01:31:34,080
using time lockers as we modify it to

2232
01:31:34,080 --> 01:31:36,060
achieve our consensus in the mobile

2233
01:31:36,060 --> 01:31:38,880
sluggish model so um the key idea here

2234
01:31:38,880 --> 01:31:40,679
is we timelock encrypt any message

2235
01:31:40,679 --> 01:31:43,260
someone sends in this network so since

2236
01:31:43,260 --> 01:31:44,100
the

2237
01:31:44,100 --> 01:31:46,679
um messages are time locked with uh the

2238
01:31:46,679 --> 01:31:49,080
duration to be uh the synchrony value

2239
01:31:49,080 --> 01:31:52,800
the Delta here so um the adversity is

2240
01:31:52,800 --> 01:31:54,960
now forced to open the time lock to see

2241
01:31:54,960 --> 01:31:57,060
what's inside the inside uh what's

2242
01:31:57,060 --> 01:32:00,800
inside the uh the message so um uh that

2243
01:32:00,800 --> 01:32:02,880
inherently forces the adversary either

2244
01:32:02,880 --> 01:32:05,100
to deliver the message or take time to

2245
01:32:05,100 --> 01:32:07,620
open it and see what's happening here

2246
01:32:07,620 --> 01:32:08,820
um however

2247
01:32:08,820 --> 01:32:10,560
um a key drawback in Nakamoto style

2248
01:32:10,560 --> 01:32:12,659
Protocols are there's only one person

2249
01:32:12,659 --> 01:32:14,580
who is transmitting a message at any

2250
01:32:14,580 --> 01:32:17,340
given time so you need to have some sort

2251
01:32:17,340 --> 01:32:19,380
of a decoy mechanism where even the

2252
01:32:19,380 --> 01:32:21,300
non-block vendors are creating enough

2253
01:32:21,300 --> 01:32:23,880
message cover for someone who is the

2254
01:32:23,880 --> 01:32:25,139
block winner so that the adversary

2255
01:32:25,139 --> 01:32:27,000
doesn't know who is sending the block or

2256
01:32:27,000 --> 01:32:29,159
who is sending ID card so in this case

2257
01:32:29,159 --> 01:32:31,260
the adversary is now first to randomly

2258
01:32:31,260 --> 01:32:34,199
pick its victims without knowing

2259
01:32:34,199 --> 01:32:35,820
um without knowing the contents long

2260
01:32:35,820 --> 01:32:37,500
story short we modify an automotive

2261
01:32:37,500 --> 01:32:38,940
conferences in such a way that the

2262
01:32:38,940 --> 01:32:41,100
adversary doesn't know what's inside a

2263
01:32:41,100 --> 01:32:42,960
message and it has to arbitrarily pick

2264
01:32:42,960 --> 01:32:46,679
some uh messages to stop and uh and we

2265
01:32:46,679 --> 01:32:49,020
use time lock puzzles that helps uh to

2266
01:32:49,020 --> 01:32:50,280
get around

2267
01:32:50,280 --> 01:32:53,880
um the challenges first by adversary so

2268
01:32:53,880 --> 01:32:55,620
um to tell you more about decoy so

2269
01:32:55,620 --> 01:32:57,600
decoys are essentially a dummy time lock

2270
01:32:57,600 --> 01:32:59,460
puzzle messages it's going to give tower

2271
01:32:59,460 --> 01:33:01,620
for the honest uh person who has just

2272
01:33:01,620 --> 01:33:04,679
mined a block uh however and as I said

2273
01:33:04,679 --> 01:33:06,179
in the permissionless setting we don't

2274
01:33:06,179 --> 01:33:08,280
know who is there in the system so this

2275
01:33:08,280 --> 01:33:11,100
is prone to civil attacks so uh we just

2276
01:33:11,100 --> 01:33:13,440
like Nakamoto contractors we use a proof

2277
01:33:13,440 --> 01:33:16,260
of work to get around this problem so um

2278
01:33:16,260 --> 01:33:18,060
so let's say that when you have a

2279
01:33:18,060 --> 01:33:20,400
payload in Nakamoto consensus you just

2280
01:33:20,400 --> 01:33:22,320
compute the hash of it and if it falls

2281
01:33:22,320 --> 01:33:25,139
in some windows 0 to D1 then you say

2282
01:33:25,139 --> 01:33:27,060
that you have mined a block that's how

2283
01:33:27,060 --> 01:33:29,820
it goes about so we just use the two for

2284
01:33:29,820 --> 01:33:31,980
one trick which uh was used in the past

2285
01:33:31,980 --> 01:33:34,080
in food chains career at all and so on

2286
01:33:34,080 --> 01:33:37,020
so what we do is if the hash faults in

2287
01:33:37,020 --> 01:33:39,719
another bucket D1 to D2 which is much

2288
01:33:39,719 --> 01:33:41,820
easier than mining a block but at the

2289
01:33:41,820 --> 01:33:43,800
same time it's not too easy enough for

2290
01:33:43,800 --> 01:33:46,199
the adversary can flood the network uh

2291
01:33:46,199 --> 01:33:48,239
we say that if someone Falls in this

2292
01:33:48,239 --> 01:33:49,800
bucket then it's going to they have

2293
01:33:49,800 --> 01:33:52,980
mined a decar in this uh exam so in this

2294
01:33:52,980 --> 01:33:55,980
in the setting so uh to give you a high

2295
01:33:55,980 --> 01:33:57,840
level overview of what uh and a

2296
01:33:57,840 --> 01:33:59,820
simplified version of our protocol uh

2297
01:33:59,820 --> 01:34:02,159
our protocol proceeds in two phases the

2298
01:34:02,159 --> 01:34:05,400
first phase is where you mine blocks or

2299
01:34:05,400 --> 01:34:07,920
a decoy if you're lucky you stumble upon

2300
01:34:07,920 --> 01:34:09,360
it and of course you first pick the

2301
01:34:09,360 --> 01:34:11,820
longest chain uh then your time lock and

2302
01:34:11,820 --> 01:34:14,699
trip whatever you find and you keep the

2303
01:34:14,699 --> 01:34:17,159
messages those messages with you uh

2304
01:34:17,159 --> 01:34:19,440
right now then when you enter the solve

2305
01:34:19,440 --> 01:34:21,780
phase you multicast the puzzles uh

2306
01:34:21,780 --> 01:34:24,000
multicast the puzzle you have it could

2307
01:34:24,000 --> 01:34:27,060
either be a decoy or a block or if if I

2308
01:34:27,060 --> 01:34:28,800
was unlucky I wouldn't have anything but

2309
01:34:28,800 --> 01:34:30,300
we said the parameters and such a way

2310
01:34:30,300 --> 01:34:32,400
that with good probability if you are

2311
01:34:32,400 --> 01:34:33,679
able to mine at least one of the other

2312
01:34:33,679 --> 01:34:36,420
uh then you multicast these uh these

2313
01:34:36,420 --> 01:34:38,340
time lock puzzles and um Everybody

2314
01:34:38,340 --> 01:34:40,739
relieves these puzzles they batch open

2315
01:34:40,739 --> 01:34:44,040
uh using our time log primitive which I

2316
01:34:44,040 --> 01:34:45,719
introduced uh in the previous section

2317
01:34:45,719 --> 01:34:47,880
and you extend the chain and you keep on

2318
01:34:47,880 --> 01:34:51,060
doing this so um here is an example a

2319
01:34:51,060 --> 01:34:53,820
contrived example of how this happens so

2320
01:34:53,820 --> 01:34:56,820
uh in this example um these four miners

2321
01:34:56,820 --> 01:34:59,639
are trying to add a third block to the

2322
01:34:59,639 --> 01:35:02,340
to the blockchain so what they do here

2323
01:35:02,340 --> 01:35:03,540
is um

2324
01:35:03,540 --> 01:35:05,820
first um they enter the Mind phase they

2325
01:35:05,820 --> 01:35:07,440
start a timer

2326
01:35:07,440 --> 01:35:10,860
um Everybody tries to mine a decoy or

2327
01:35:10,860 --> 01:35:13,080
block in this example uh except the

2328
01:35:13,080 --> 01:35:15,239
third Miner everyone else is in lock uh

2329
01:35:15,239 --> 01:35:17,580
mines are D Coin but the third minor

2330
01:35:17,580 --> 01:35:22,080
mines uh uh mines are a block so once

2331
01:35:22,080 --> 01:35:24,420
they have uh their respective messages

2332
01:35:24,420 --> 01:35:27,900
uh they go about time lock encrypting it

2333
01:35:27,900 --> 01:35:28,440
um

2334
01:35:28,440 --> 01:35:31,260
uh whatever they have and they wait for

2335
01:35:31,260 --> 01:35:33,900
the Mind phase to end so now they get

2336
01:35:33,900 --> 01:35:36,060
into the solve phase so at the at the

2337
01:35:36,060 --> 01:35:37,500
beginning of the solve phase first thing

2338
01:35:37,500 --> 01:35:38,820
you do is you send out all the messages

2339
01:35:38,820 --> 01:35:42,239
you are you have so uh in this case a is

2340
01:35:42,239 --> 01:35:44,400
sending its messages to everybody in

2341
01:35:44,400 --> 01:35:45,900
this in this thing minor number two is

2342
01:35:45,900 --> 01:35:47,760
sending it to others in this case minor

2343
01:35:47,760 --> 01:35:49,500
three is doing it and minor four is

2344
01:35:49,500 --> 01:35:51,540
doing it so uh at the end of the day

2345
01:35:51,540 --> 01:35:54,000
everybody should have had uh received

2346
01:35:54,000 --> 01:35:56,400
those messages and if the uh adversary

2347
01:35:56,400 --> 01:35:57,600
would have stopped some message you

2348
01:35:57,600 --> 01:35:58,800
wouldn't have received it but

2349
01:35:58,800 --> 01:36:00,840
unfortunately adversary cannot see what

2350
01:36:00,840 --> 01:36:04,380
is inside the uh inside these uh time

2351
01:36:04,380 --> 01:36:06,239
lock puzzles without spending time on it

2352
01:36:06,239 --> 01:36:08,040
so once you have these individual

2353
01:36:08,040 --> 01:36:10,440
puzzles you spend time

2354
01:36:10,440 --> 01:36:12,719
you uh you bash them using our matching

2355
01:36:12,719 --> 01:36:14,639
property so you can come up with a

2356
01:36:14,639 --> 01:36:18,719
single puzzle and you can uh and you can

2357
01:36:18,719 --> 01:36:20,940
uh spend time opening just the one

2358
01:36:20,940 --> 01:36:23,040
puzzle you have and figure out who the

2359
01:36:23,040 --> 01:36:25,920
winner of the puzzle is so with this you

2360
01:36:25,920 --> 01:36:27,540
can find out who the winner is and you

2361
01:36:27,540 --> 01:36:29,699
can keep on doing this for other blocks

2362
01:36:29,699 --> 01:36:31,800
in this uh for other blogs in this

2363
01:36:31,800 --> 01:36:34,620
manner so uh and and somebody we

2364
01:36:34,620 --> 01:36:36,300
presented a new time lock puzzle which

2365
01:36:36,300 --> 01:36:39,659
has cool properties then we developed

2366
01:36:39,659 --> 01:36:41,159
the first permission let's show or show

2367
01:36:41,159 --> 01:36:42,540
the first permissionless protocol on the

2368
01:36:42,540 --> 01:36:45,480
mobile sluggish model and uh in the

2369
01:36:45,480 --> 01:36:46,920
paper we also show an attack on

2370
01:36:46,920 --> 01:36:48,600
locomotor consensus in the mobile

2371
01:36:48,600 --> 01:36:51,840
sluggish model and uh another word which

2372
01:36:51,840 --> 01:36:53,880
I didn't get to talk about was we show

2373
01:36:53,880 --> 01:36:56,580
how to do uh we build a generic compiler

2374
01:36:56,580 --> 01:36:58,440
that can convert any weekly adaptive

2375
01:36:58,440 --> 01:37:00,120
broadcast protocol into a strongly

2376
01:37:00,120 --> 01:37:02,820
Adaptive One so here's strong says that

2377
01:37:02,820 --> 01:37:04,560
uh the adversary can look at the message

2378
01:37:04,560 --> 01:37:06,780
can delete any message from the network

2379
01:37:06,780 --> 01:37:09,360
even when it was sent by a node that was

2380
01:37:09,360 --> 01:37:12,139
harnessed so it's much higher culture

2381
01:37:12,139 --> 01:37:15,840
power of adversary we build a compiler

2382
01:37:15,840 --> 01:37:17,520
that can convert any weekly adaptive

2383
01:37:17,520 --> 01:37:19,679
protocol into strongly adapter one and

2384
01:37:19,679 --> 01:37:21,960
we should give the um the first expected

2385
01:37:21,960 --> 01:37:24,060
non-constant uh Byzantine broadcast on

2386
01:37:24,060 --> 01:37:25,620
the strongly adaptive and majority

2387
01:37:25,620 --> 01:37:27,840
Corruptions but the highlight of these

2388
01:37:27,840 --> 01:37:30,360
uh broadcast works are you don't even

2389
01:37:30,360 --> 01:37:32,520
have to use the TLP from our paper you

2390
01:37:32,520 --> 01:37:34,199
can use any batchable time lock puzzles

2391
01:37:34,199 --> 01:37:37,080
to uh to do it uh and so you can fun

2392
01:37:37,080 --> 01:37:39,360
fact realize it in practice uh yeah

2393
01:37:39,360 --> 01:37:41,040
that's it I'll stop and take questions

2394
01:37:41,040 --> 01:37:42,840
and I apologize for the animations I'm

2395
01:37:42,840 --> 01:37:44,820
not sure why it was just zooming out and

2396
01:37:44,820 --> 01:37:47,420
off yeah

2397
01:37:53,100 --> 01:37:55,800
thanks questions

2398
01:37:55,800 --> 01:37:58,800
foreign

2399
01:38:02,100 --> 01:38:04,320
so can you can you say a little bit more

2400
01:38:04,320 --> 01:38:07,739
about this generic compiler so um this

2401
01:38:07,739 --> 01:38:11,699
isn't and uh um uh um we use a random

2402
01:38:11,699 --> 01:38:13,860
Oracle model so essentially it takes any

2403
01:38:13,860 --> 01:38:17,100
message one sent in a weekly adapter one

2404
01:38:17,100 --> 01:38:20,040
we put it in a Time log and uh we send

2405
01:38:20,040 --> 01:38:21,960
it send them around the challenges and

2406
01:38:21,960 --> 01:38:23,520
when how do you prove that this is in

2407
01:38:23,520 --> 01:38:25,440
fact correct and uh we show in the paper

2408
01:38:25,440 --> 01:38:29,820
how to do it nicely uh uh yeah um this

2409
01:38:29,820 --> 01:38:31,560
is a long-standing open problem where

2410
01:38:31,560 --> 01:38:33,659
you want to figure out however a oau of

2411
01:38:33,659 --> 01:38:36,120
one or own complexity is that that's in

2412
01:38:36,120 --> 01:38:37,800
the sluggish model right no no that's

2413
01:38:37,800 --> 01:38:39,420
not an isolated model so there are two

2414
01:38:39,420 --> 01:38:42,920
independent results yeah okay yeah

2415
01:38:45,060 --> 01:38:48,320
other questions

2416
01:38:49,920 --> 01:38:52,139
all right I guess uh let's thank the

2417
01:38:52,139 --> 01:38:53,520
speaker and that's the end of the

2418
01:38:53,520 --> 01:38:54,840
session

2419
01:38:54,840 --> 01:38:57,500
thank you

