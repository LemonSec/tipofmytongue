1
00:00:00,840 --> 00:00:04,319
Welcome to our post lunch session

2
00:00:04,319 --> 00:00:07,740
on key exchange and messaging

3
00:00:07,740 --> 00:00:10,380
we'll be starting it out with Xiang Yu

4
00:00:10,380 --> 00:00:13,740
Liu telling us about eke meets tight

5
00:00:13,740 --> 00:00:16,500
security in the Universal universally

6
00:00:16,500 --> 00:00:18,840
composable framework

7
00:00:18,840 --> 00:00:21,900
take it away okay okay I hear me okay it

8
00:00:21,900 --> 00:00:24,119
works well thank you thank you for your

9
00:00:24,119 --> 00:00:26,400
introduction and I'm sure you do from

10
00:00:26,400 --> 00:00:29,880
Purdue University and the title is eke

11
00:00:29,880 --> 00:00:31,859
Miss Thai Security in the universally

12
00:00:31,859 --> 00:00:34,440
composable framework it's a joint work

13
00:00:34,440 --> 00:00:37,860
which university

14
00:00:42,559 --> 00:00:44,700
password-based authenticated key

15
00:00:44,700 --> 00:00:46,860
exchange protocol as shown in this

16
00:00:46,860 --> 00:00:50,039
figure that involved two parties really

17
00:00:50,039 --> 00:00:53,579
the clients and the server uh they

18
00:00:53,579 --> 00:00:57,300
appreciate a short password PW and after

19
00:00:57,300 --> 00:00:59,280
several rounds of interaction they

20
00:00:59,280 --> 00:01:01,739
finally outputs the same and the

21
00:01:01,739 --> 00:01:04,920
pseudo-random session kkc or KS you

22
00:01:04,920 --> 00:01:07,860
already this password is short and it's

23
00:01:07,860 --> 00:01:11,220
human remember and besides the entropy

24
00:01:11,220 --> 00:01:13,920
of the password is very limited uh

25
00:01:13,920 --> 00:01:17,600
different from AKA in Pak we do not need

26
00:01:17,600 --> 00:01:21,299
complicated cryptographic keys for in

27
00:01:21,299 --> 00:01:24,780
for signatures or for encryptions

28
00:01:24,780 --> 00:01:28,320
uh well Kik has an asthmatic variance

29
00:01:28,320 --> 00:01:32,159
which we call the ATK in atak here

30
00:01:32,159 --> 00:01:35,159
differently the server now it stores a

31
00:01:35,159 --> 00:01:38,100
password field uh your rather than the

32
00:01:38,100 --> 00:01:40,140
password in play usually the password

33
00:01:40,140 --> 00:01:43,759
field is a hash value of password and

34
00:01:43,759 --> 00:01:47,820
ATK is designed to prevent potential

35
00:01:47,820 --> 00:01:50,460
attacks for example the adversary may

36
00:01:50,460 --> 00:01:53,220
log in the server until the password

37
00:01:53,220 --> 00:01:58,020
field so uh APK we required even with

38
00:01:58,020 --> 00:02:00,740
the password field the adversary cannot

39
00:02:00,740 --> 00:02:03,600
impersonate a client to log into a

40
00:02:03,600 --> 00:02:05,399
server

41
00:02:05,399 --> 00:02:09,000
uh well we consider the UC framework UC

42
00:02:09,000 --> 00:02:11,459
Security in this work and we may tell

43
00:02:11,459 --> 00:02:12,900
something about YouTube framework

44
00:02:12,900 --> 00:02:15,540
universally composable framework and

45
00:02:15,540 --> 00:02:18,120
this the left figure shows the real

46
00:02:18,120 --> 00:02:21,780
world view and the right figures shows

47
00:02:21,780 --> 00:02:26,520
the ideal words view we see a protocol

48
00:02:26,520 --> 00:02:30,420
is uses curve if it emulates some ideal

49
00:02:30,420 --> 00:02:33,120
functionality F so that's the real world

50
00:02:33,120 --> 00:02:35,879
view is distinguishable from the ideal

51
00:02:35,879 --> 00:02:39,620
world view and compared to

52
00:02:39,620 --> 00:02:41,280
indistinguishable uh

53
00:02:41,280 --> 00:02:43,440
indistinguishability and debased

54
00:02:43,440 --> 00:02:45,720
security model UC security model has

55
00:02:45,720 --> 00:02:48,000
several advantages for example it Sports

56
00:02:48,000 --> 00:02:51,000
entry correlation and distribution for

57
00:02:51,000 --> 00:02:54,780
passwords and the universal compose the

58
00:02:54,780 --> 00:02:57,080
universal composition theory is applied

59
00:02:57,080 --> 00:03:00,120
that means the security of the protocol

60
00:03:00,120 --> 00:03:02,519
preserves even is running in actual

61
00:03:02,519 --> 00:03:05,400
networks where multiple uh protocol

62
00:03:05,400 --> 00:03:08,879
instance may run in parallel

63
00:03:08,879 --> 00:03:12,000
uh well in this world we also consider

64
00:03:12,000 --> 00:03:13,920
Thai security so we may tell something

65
00:03:13,920 --> 00:03:16,200
about reduction we know improved

66
00:03:16,200 --> 00:03:19,560
security we designed for or skiing as

67
00:03:19,560 --> 00:03:22,800
based on some problem p and we make a

68
00:03:22,800 --> 00:03:25,920
reduction to prove the security uh in

69
00:03:25,920 --> 00:03:28,140
the reduction we Define circular section

70
00:03:28,140 --> 00:03:32,220
as L over f l Epsilon over absolute

71
00:03:32,220 --> 00:03:35,519
prime whereas Epsilon is is the

72
00:03:35,519 --> 00:03:38,099
adventure of the adversary and Epsilon

73
00:03:38,099 --> 00:03:40,140
Prime is the advantage of the reduction

74
00:03:40,140 --> 00:03:42,599
algorithm B uh from the definition we

75
00:03:42,599 --> 00:03:45,360
can see obviously uh the smaller the

76
00:03:45,360 --> 00:03:48,720
current loss factor is the better and

77
00:03:48,720 --> 00:03:51,299
typically means L is a constant or there

78
00:03:51,299 --> 00:03:53,180
is a polynomial in Lambda the security

79
00:03:53,180 --> 00:03:55,980
parameter and in contrast the loose

80
00:03:55,980 --> 00:03:58,080
security means L depends on its

81
00:03:58,080 --> 00:04:01,440
behaviors for example depends on the

82
00:04:01,440 --> 00:04:04,379
number of users or stations involved by

83
00:04:04,379 --> 00:04:07,040
the adversary

84
00:04:07,459 --> 00:04:10,260
by standard hybrid arguments we know

85
00:04:10,260 --> 00:04:12,420
supporting the single users and single

86
00:04:12,420 --> 00:04:14,099
station settings like Security in the

87
00:04:14,099 --> 00:04:16,079
multi-user and multiplication setting

88
00:04:16,079 --> 00:04:18,540
but with a cost of huge circuit loss

89
00:04:18,540 --> 00:04:21,358
really this this cost can be as high as

90
00:04:21,358 --> 00:04:25,620
2 to 30 to 50. so uh that's why we

91
00:04:25,620 --> 00:04:28,320
achieve that's why I will try to design

92
00:04:28,320 --> 00:04:30,960
and Titleist curve uh

93
00:04:30,960 --> 00:04:34,139
uh cryptographic schemes uh since uh

94
00:04:34,139 --> 00:04:36,060
Thai security has many advantages for

95
00:04:36,060 --> 00:04:37,919
example Universal parameters and the

96
00:04:37,919 --> 00:04:39,960
smaller parameters under the same

97
00:04:39,960 --> 00:04:41,759
security level

98
00:04:41,759 --> 00:04:43,259
uh

99
00:04:43,259 --> 00:04:47,600
okay uh now uh in terms of high clinical

100
00:04:47,600 --> 00:04:50,820
tricky and APK schemes there are only

101
00:04:50,820 --> 00:04:53,520
two related words the first one bio plus

102
00:04:53,520 --> 00:04:58,620
17 is proposed uh PK protocol uh based

103
00:04:58,620 --> 00:05:01,259
based on Gap theater assumption in the

104
00:05:01,259 --> 00:05:04,199
ND model we already mentioned that the

105
00:05:04,199 --> 00:05:07,440
ID model is weaker than the UC model and

106
00:05:07,440 --> 00:05:11,699
the other work ABB past 20 is proposed a

107
00:05:11,699 --> 00:05:15,300
titleists per PK protocol also based on

108
00:05:15,300 --> 00:05:18,240
the gfdh Assumption in the relaxed UC

109
00:05:18,240 --> 00:05:20,840
model uh Here Again The Edge assumption

110
00:05:20,840 --> 00:05:26,460
states that given GE G2x g2y as well as

111
00:05:26,460 --> 00:05:29,280
the decision Oracle for ddh typos it's

112
00:05:29,280 --> 00:05:33,840
still hard to compute C to X Y since it

113
00:05:33,840 --> 00:05:36,900
involves a decision Oracle and is

114
00:05:36,900 --> 00:05:39,960
interactive so we may sometimes to some

115
00:05:39,960 --> 00:05:42,960
extent consider it as non-standard

116
00:05:42,960 --> 00:05:46,500
so in this work we aim to prove to

117
00:05:46,500 --> 00:05:50,699
design a plk protocol as well as an ATK

118
00:05:50,699 --> 00:05:52,620
protocol with type support in the

119
00:05:52,620 --> 00:05:55,139
standard UC framework probably from

120
00:05:55,139 --> 00:05:57,419
standard Harmony assumptions like the

121
00:05:57,419 --> 00:05:58,979
CDH consumption

122
00:05:58,979 --> 00:06:01,560
so that's our goal and we make the

123
00:06:01,560 --> 00:06:03,660
following contributions first we

124
00:06:03,660 --> 00:06:08,280
proposed a twin DH EKG it's a it's a PHP

125
00:06:08,280 --> 00:06:10,680
protocol and we prove its types uses

126
00:06:10,680 --> 00:06:13,979
Security based on the CDH assumption uh

127
00:06:13,979 --> 00:06:16,259
we also want to extend it to the

128
00:06:16,259 --> 00:06:20,100
asymmetric version but we found a

129
00:06:20,100 --> 00:06:24,720
negative result that is 88k protocols

130
00:06:24,720 --> 00:06:28,620
cannot achieve full tight security and

131
00:06:28,620 --> 00:06:31,319
the surgery loss factor is lower bounded

132
00:06:31,319 --> 00:06:33,660
by and the total number of client server

133
00:06:33,660 --> 00:06:37,039
pairs nevertheless we still propose the

134
00:06:37,039 --> 00:06:41,220
20-haek uh it's an APK protocol and we

135
00:06:41,220 --> 00:06:43,560
prove its UC Security based on the CDH

136
00:06:43,560 --> 00:06:46,560
assumption and the secure loss factor is

137
00:06:46,560 --> 00:06:49,680
an 11 means it means the optimal support

138
00:06:49,680 --> 00:06:50,699
loss

139
00:06:50,699 --> 00:06:54,600
so uh now we may tell some technical

140
00:06:54,600 --> 00:06:57,000
details and we may start from eke

141
00:06:57,000 --> 00:07:00,360
protocol encrypted key exchange protocol

142
00:07:00,360 --> 00:07:04,199
uh it's proposed by blabbing and metrics

143
00:07:04,199 --> 00:07:08,340
in uh in 1992 and I think it's the first

144
00:07:08,340 --> 00:07:12,780
also the most well-known KKK protocol

145
00:07:12,780 --> 00:07:15,240
over the world as shown is this this

146
00:07:15,240 --> 00:07:17,639
figure is rather simple uh a high level

147
00:07:17,639 --> 00:07:22,080
uh uh it just encrypts uh every

148
00:07:22,080 --> 00:07:25,020
transcript message for a review for a

149
00:07:25,020 --> 00:07:27,960
regular click exchange protocol uh now

150
00:07:27,960 --> 00:07:31,099
uh for example the clients examples uh

151
00:07:31,099 --> 00:07:36,660
GX and encrypt G2x using password as the

152
00:07:36,660 --> 00:07:39,180
symmetric key to obtain the U1 and send

153
00:07:39,180 --> 00:07:42,479
this out and the servers do similarly uh

154
00:07:42,479 --> 00:07:47,479
the finalization key is computed as H uh

155
00:07:47,479 --> 00:07:51,479
abstract V which is equal to G to x y

156
00:07:51,479 --> 00:07:54,060
and chance may uh include the

157
00:07:54,060 --> 00:07:56,280
transcription information as well as

158
00:07:56,280 --> 00:07:58,380
some public information like the

159
00:07:58,380 --> 00:08:01,740
identities of involved parties

160
00:08:01,740 --> 00:08:04,860
now we want to prove the Thai security

161
00:08:04,860 --> 00:08:08,520
of eke that is we want to make a

162
00:08:08,520 --> 00:08:11,639
reduction and the reduction of reduction

163
00:08:11,639 --> 00:08:15,180
every term B into theory is first we

164
00:08:15,180 --> 00:08:18,060
need to randomize the CDH or ddh

165
00:08:18,060 --> 00:08:21,000
challenge problem and invade them into

166
00:08:21,000 --> 00:08:24,060
multiple session instance and that's due

167
00:08:24,060 --> 00:08:25,979
to the random self-reducibility of the

168
00:08:25,979 --> 00:08:30,000
DH problem but we may face the two

169
00:08:30,000 --> 00:08:31,740
following obstacles

170
00:08:31,740 --> 00:08:36,000
first if uh now suppose the adversary a

171
00:08:36,000 --> 00:08:38,760
uh attacks successfully for example is

172
00:08:38,760 --> 00:08:43,320
all powerful and it can compute the CDH

173
00:08:43,320 --> 00:08:47,040
problem so that means it can compute the

174
00:08:47,040 --> 00:08:50,519
real session key but uh in this in this

175
00:08:50,519 --> 00:08:53,940
set in this case we have already invased

176
00:08:53,940 --> 00:08:56,399
the heart the challenge problem into

177
00:08:56,399 --> 00:09:00,480
these sessions that means we can not uh

178
00:09:00,480 --> 00:09:04,620
computes the session KSA but if a

179
00:09:04,620 --> 00:09:06,899
attacks successfully how can we extract

180
00:09:06,899 --> 00:09:09,360
the track CDH value from the hash list

181
00:09:09,360 --> 00:09:11,640
since there might be thousands

182
00:09:11,640 --> 00:09:15,120
candidates these in the hash list and B

183
00:09:15,120 --> 00:09:18,540
does not know which one is correct

184
00:09:18,540 --> 00:09:21,660
so that's the first obstacle and for the

185
00:09:21,660 --> 00:09:24,480
first for the second circle now if a

186
00:09:24,480 --> 00:09:27,120
correctly gets the password

187
00:09:27,120 --> 00:09:30,060
so how can we do since in this case we

188
00:09:30,060 --> 00:09:32,820
uh cannot compute

189
00:09:32,820 --> 00:09:35,459
the session KF before and we noticed

190
00:09:35,459 --> 00:09:38,459
that uh uh

191
00:09:38,459 --> 00:09:41,700
since the passwords uh entry is very

192
00:09:41,700 --> 00:09:43,980
limited that means it can guess it

193
00:09:43,980 --> 00:09:47,160
correctly with a non-negligible problem

194
00:09:47,160 --> 00:09:50,580
so in this case how can we do so

195
00:09:50,580 --> 00:09:54,480
um we need uh on the way towards tax

196
00:09:54,480 --> 00:09:56,220
credit we need to solve this to our

197
00:09:56,220 --> 00:09:59,700
circles and our idea is to resort to a

198
00:09:59,700 --> 00:10:03,420
decision Oracle we noticed that in 2008

199
00:10:03,420 --> 00:10:06,480
cash skills and shoes they propose the

200
00:10:06,480 --> 00:10:10,019
strong pdh assumption and shows uh

201
00:10:10,019 --> 00:10:12,120
proves its equivalent to the standard

202
00:10:12,120 --> 00:10:13,680
CDH assumption

203
00:10:13,680 --> 00:10:16,800
hair strong teenage assumptions is that

204
00:10:16,800 --> 00:10:21,540
given G to X1 G2 X2 and g2y as well as a

205
00:10:21,540 --> 00:10:24,060
decision or to tune DH it's still hard

206
00:10:24,060 --> 00:10:29,399
to compute G to x y y and G2 x21 here

207
00:10:29,399 --> 00:10:32,580
10th is a decision article that it

208
00:10:32,580 --> 00:10:36,779
improves gty Prime G to V1 and G2 D2 and

209
00:10:36,779 --> 00:10:40,200
it outputs whether xyy Prime is equal to

210
00:10:40,200 --> 00:10:45,860
D1 and XY Prime is equal to Z2

211
00:10:46,200 --> 00:10:50,519
so uh knowing the strong 108 assumption

212
00:10:50,519 --> 00:10:51,899
we now

213
00:10:51,899 --> 00:10:54,600
designed to engage eke protocol as well

214
00:10:54,600 --> 00:10:55,400
as

215
00:10:55,400 --> 00:10:57,899
[Applause]

216
00:10:57,899 --> 00:11:02,040
now the client is samples X1 and X2 and

217
00:11:02,040 --> 00:11:06,959
encrypt G to X1 as as well as G2 X2

218
00:11:06,959 --> 00:11:09,959
using password as a symmetric key and

219
00:11:09,959 --> 00:11:12,360
obtains you are Essence it out the

220
00:11:12,360 --> 00:11:15,540
server does similarly as samples Y and

221
00:11:15,540 --> 00:11:19,200
encrypted to Y to obtain E2 and now the

222
00:11:19,200 --> 00:11:21,959
session key is computed as harsh chess

223
00:11:21,959 --> 00:11:25,800
V1 and Z2 where V1 is equal to G to x1y

224
00:11:25,800 --> 00:11:31,200
and they they choose G to uh Z2 is equal

225
00:11:31,200 --> 00:11:35,880
to G to x21 and the security of twin DH

226
00:11:35,880 --> 00:11:38,040
EK is based on the strong 20 actual

227
00:11:38,040 --> 00:11:39,899
assumption which is equivalent to the

228
00:11:39,899 --> 00:11:42,779
standard CDH assumption now uh let's

229
00:11:42,779 --> 00:11:45,959
have a look why 20h eke can means Thai

230
00:11:45,959 --> 00:11:46,980
security

231
00:11:46,980 --> 00:11:48,959
that is we need to solve the two of

232
00:11:48,959 --> 00:11:51,720
circles we mentioned above and for the

233
00:11:51,720 --> 00:11:54,180
first of circle uh

234
00:11:54,180 --> 00:11:57,480
now since uh in the reduction the

235
00:11:57,480 --> 00:12:00,000
reduction algorithm B it can locate the

236
00:12:00,000 --> 00:12:03,899
correct C cracked CDH values Z1 and Z2 y

237
00:12:03,899 --> 00:12:07,860
check in Twin DH y D1 V2 is equal to one

238
00:12:07,860 --> 00:12:11,339
so it can locate the correct values and

239
00:12:11,339 --> 00:12:13,019
solve the

240
00:12:13,019 --> 00:12:16,800
solve the challenge problem exactly and

241
00:12:16,800 --> 00:12:20,519
for the setup Circle if a gets the

242
00:12:20,519 --> 00:12:23,160
password correctly now in the reduction

243
00:12:23,160 --> 00:12:26,700
we just samples a random okay and view

244
00:12:26,700 --> 00:12:29,279
it as the real session key and return it

245
00:12:29,279 --> 00:12:32,760
to the adversary a and if a later adds

246
00:12:32,760 --> 00:12:36,180
hash uh which which works as a land

247
00:12:36,180 --> 00:12:39,540
motor with the correct value then B can

248
00:12:39,540 --> 00:12:43,680
locate can notice it and it's just

249
00:12:43,680 --> 00:12:46,079
reprogrammed the random Oracle to make x

250
00:12:46,079 --> 00:12:49,260
view be consistent and this is this can

251
00:12:49,260 --> 00:12:50,820
be done due to the simulation of

252
00:12:50,820 --> 00:12:54,060
landmark as well as the twin Dash

253
00:12:54,060 --> 00:12:56,100
assumption as well as the twin DH

254
00:12:56,100 --> 00:12:59,160
decision Oracle so we solve the two of

255
00:12:59,160 --> 00:13:03,120
circle and that means 20h EK means tight

256
00:13:03,120 --> 00:13:04,620
security

257
00:13:04,620 --> 00:13:08,700
well we also consider UC Security in uh

258
00:13:08,700 --> 00:13:10,860
in our protocol and

259
00:13:10,860 --> 00:13:14,399
that's um by ideal cyphers yeah actually

260
00:13:14,399 --> 00:13:17,639
the infinity H eke we modeled uh the

261
00:13:17,639 --> 00:13:21,420
symmetric encryption schemes Z1 and EQ

262
00:13:21,420 --> 00:13:24,360
as ideal ciphers that means we can

263
00:13:24,360 --> 00:13:27,360
simulate transcripts UI and EQ without

264
00:13:27,360 --> 00:13:30,839
knowing passwords also we can deduce the

265
00:13:30,839 --> 00:13:34,019
password gaze PW Prime in the

266
00:13:34,019 --> 00:13:36,899
adversaries mind from the hash from the

267
00:13:36,899 --> 00:13:39,300
ideal fiber list and if the case is

268
00:13:39,300 --> 00:13:42,600
cracked we just execute the executive

269
00:13:42,600 --> 00:13:45,060
protocol honestly and return the real

270
00:13:45,060 --> 00:13:47,880
session key and if the case is raw we

271
00:13:47,880 --> 00:13:50,160
just return a random key and supported

272
00:13:50,160 --> 00:13:52,500
rely on strong twin DH assumption which

273
00:13:52,500 --> 00:13:54,240
is equivalent to the standard cth

274
00:13:54,240 --> 00:13:56,240
assumption

275
00:13:56,240 --> 00:14:00,540
uh now uh for the last date we extend it

276
00:14:00,540 --> 00:14:04,079
to the asymmetric values namely we

277
00:14:04,079 --> 00:14:07,620
designed 20 h a eke protocol and it has

278
00:14:07,620 --> 00:14:11,160
two main difference first we need first

279
00:14:11,160 --> 00:14:13,320
we need to add additional computation

280
00:14:13,320 --> 00:14:17,040
States uh which is highlights in blue

281
00:14:17,040 --> 00:14:20,639
now in the computation of session Keys

282
00:14:20,639 --> 00:14:23,459
we need to edit these three V4 in the

283
00:14:23,459 --> 00:14:26,760
hash input which where D3 is equal to g

284
00:14:26,760 --> 00:14:30,779
v one y and Z4 is equal to g v two y

285
00:14:30,779 --> 00:14:34,139
That's the first difference and for the

286
00:14:34,139 --> 00:14:37,019
second main difference we ate a Max

287
00:14:37,019 --> 00:14:40,260
Sigma from the client to the server to

288
00:14:40,260 --> 00:14:43,560
achieve perfect forward secures

289
00:14:43,560 --> 00:14:47,519
and we prove that we prove the uses

290
00:14:47,519 --> 00:14:50,279
security of 10 DH 80k based on the

291
00:14:50,279 --> 00:14:52,500
strong 20th assumption and the support

292
00:14:52,500 --> 00:14:55,800
loss is in this work we following prove

293
00:14:55,800 --> 00:15:00,180
that for uh APK simple reductions have

294
00:15:00,180 --> 00:15:03,120
optimal circuit loss and the total

295
00:15:03,120 --> 00:15:05,339
number of client server pairs here

296
00:15:05,339 --> 00:15:08,279
simple reduction means uh the in the

297
00:15:08,279 --> 00:15:10,320
reduction the reduction enzyme just

298
00:15:10,320 --> 00:15:12,720
involves the adversary a only once

299
00:15:12,720 --> 00:15:16,860
almost all known uh Pro techniques fall

300
00:15:16,860 --> 00:15:19,800
into this type of simple reduction that

301
00:15:19,800 --> 00:15:22,920
means between the H A EK means optimal

302
00:15:22,920 --> 00:15:24,360
secret loss

303
00:15:24,360 --> 00:15:27,000
okay to make a conclusion uh in this

304
00:15:27,000 --> 00:15:30,420
work we propose the 20h eke protocol and

305
00:15:30,420 --> 00:15:33,600
show yes types uses the quality based on

306
00:15:33,600 --> 00:15:36,360
the CDH assumption and we also give a

307
00:15:36,360 --> 00:15:38,399
negative result for the tax credit of

308
00:15:38,399 --> 00:15:42,839
AEK and design 20h APK shows its optimal

309
00:15:42,839 --> 00:15:45,959
secret loss and okay

310
00:15:45,959 --> 00:15:48,899
uh well that's the main idea of this

311
00:15:48,899 --> 00:15:50,639
work and thank you thank you for your

312
00:15:50,639 --> 00:15:52,880
attention

313
00:15:59,820 --> 00:16:01,920
we have time for questions if anyone has

314
00:16:01,920 --> 00:16:04,279
a question

315
00:16:09,660 --> 00:16:11,760
you have some like uh insight into like

316
00:16:11,760 --> 00:16:14,279
what aspect of apic as compared to pick

317
00:16:14,279 --> 00:16:16,800
makes it so that you can't achieve

318
00:16:16,800 --> 00:16:18,480
better than this factor and security

319
00:16:18,480 --> 00:16:20,699
loss you mean the difference between

320
00:16:20,699 --> 00:16:23,279
pack and APAC yeah what what about it

321
00:16:23,279 --> 00:16:25,560
she makes it uh harder to have a tight

322
00:16:25,560 --> 00:16:26,600
security

323
00:16:26,600 --> 00:16:32,040
uh okay uh we can show in this uh in

324
00:16:32,040 --> 00:16:34,500
this figure uh we we can see the

325
00:16:34,500 --> 00:16:37,079
Actually the password field it works as

326
00:16:37,079 --> 00:16:39,240
we can view it as a commitment from the

327
00:16:39,240 --> 00:16:41,579
client to the server and to achieve

328
00:16:41,579 --> 00:16:44,040
types of protein in the reduction we do

329
00:16:44,040 --> 00:16:46,560
not know whether the adversary can

330
00:16:46,560 --> 00:16:49,440
obtain the original password from the

331
00:16:49,440 --> 00:16:52,139
password field since it can it can guess

332
00:16:52,139 --> 00:16:54,839
and it can check whether the gas is

333
00:16:54,839 --> 00:16:56,820
cracked due to since it's not the

334
00:16:56,820 --> 00:16:59,579
password field so due to this reason we

335
00:16:59,579 --> 00:17:02,519
we do not know where where and when will

336
00:17:02,519 --> 00:17:05,459
Aid the adversaries successfully obtain

337
00:17:05,459 --> 00:17:07,799
the original password and if it does

338
00:17:07,799 --> 00:17:10,619
then the support is brave so due to this

339
00:17:10,619 --> 00:17:13,079
reason we have to choose one's

340
00:17:13,079 --> 00:17:16,740
particular session and it made as a hard

341
00:17:16,740 --> 00:17:19,740
problem into it that leads to the loose

342
00:17:19,740 --> 00:17:22,439
circuit loss factor and

343
00:17:22,439 --> 00:17:26,600
that makes sense thank you thank you

344
00:17:27,839 --> 00:17:31,320
and uh questions I have one um

345
00:17:31,320 --> 00:17:33,780
so part of your motivation for studying

346
00:17:33,780 --> 00:17:35,640
tightness was it's nice when you do a

347
00:17:35,640 --> 00:17:37,260
hybrid argument from a single user to

348
00:17:37,260 --> 00:17:38,880
multi-user

349
00:17:38,880 --> 00:17:41,700
um with this security loss of n were you

350
00:17:41,700 --> 00:17:44,039
able to do just a proof for a single

351
00:17:44,039 --> 00:17:46,440
pair and then do a hybrid or did your

352
00:17:46,440 --> 00:17:48,840
analysis fairly need to analyze all that

353
00:17:48,840 --> 00:17:52,559
uh well if we use hybrid arguments uh we

354
00:17:52,559 --> 00:17:55,679
we have not only the loss factor and but

355
00:17:55,679 --> 00:17:59,460
also uh maybe a q where Q depends on the

356
00:17:59,460 --> 00:18:03,679
session and total number of

357
00:18:03,980 --> 00:18:08,580
is involved by a but uh so you know n

358
00:18:08,580 --> 00:18:12,480
times Q is usually larger than us so

359
00:18:12,480 --> 00:18:18,020
then so the security loss makes sense

360
00:18:18,660 --> 00:18:22,700
let's thank our speaker again thank you

361
00:18:29,940 --> 00:18:34,440
next up we'll have paper 170.

362
00:18:36,780 --> 00:18:39,419
and while I'm talking to you all we have

363
00:18:39,419 --> 00:18:41,360
our aquarium visit today

364
00:18:41,360 --> 00:18:44,340
we're going to have two bus trips one at

365
00:18:44,340 --> 00:18:48,439
5 30 one at six o'clock

366
00:18:49,919 --> 00:18:51,299
okay

367
00:18:51,299 --> 00:18:54,419
and so this talk is going to be on a

368
00:18:54,419 --> 00:18:57,299
universally composable Peak with zero

369
00:18:57,299 --> 00:18:59,580
communication cost and why it shouldn't

370
00:18:59,580 --> 00:19:02,160
be considered UC secure and the talk

371
00:19:02,160 --> 00:19:04,559
will be given by Lawrence Roy take it

372
00:19:04,559 --> 00:19:06,678
away

373
00:19:21,419 --> 00:19:23,820
hear me yes okay

374
00:19:23,820 --> 00:19:26,580
uh hello everyone I'd like to present ju

375
00:19:26,580 --> 00:19:28,320
and my analysis of correctness and

376
00:19:28,320 --> 00:19:29,460
universally composable password

377
00:19:29,460 --> 00:19:32,640
authenticated key exchange

378
00:19:32,640 --> 00:19:34,919
so as usual Alice and Bob want to find a

379
00:19:34,919 --> 00:19:36,539
shared symmetric key that they can use

380
00:19:36,539 --> 00:19:39,120
to communicate

381
00:19:39,120 --> 00:19:43,020
so they use diffie-hillman key exchange

382
00:19:43,020 --> 00:19:44,700
over an authenticated Channel this works

383
00:19:44,700 --> 00:19:46,140
great the adversary is just an

384
00:19:46,140 --> 00:19:48,360
eavesdropper and cannot find the key

385
00:19:48,360 --> 00:19:50,280
without solving the diffie-hellman

386
00:19:50,280 --> 00:19:52,520
problem

387
00:19:52,679 --> 00:19:54,780
however it falls apart against a man in

388
00:19:54,780 --> 00:19:56,280
the middle adversary

389
00:19:56,280 --> 00:19:59,100
that is if the party's uh communicate

390
00:19:59,100 --> 00:20:01,140
over an unauthenticated Channel then the

391
00:20:01,140 --> 00:20:03,299
adversary can replace their messages

392
00:20:03,299 --> 00:20:05,940
with its own and completing a separate

393
00:20:05,940 --> 00:20:07,980
key exchange of each party

394
00:20:07,980 --> 00:20:09,900
so Alice and Bob now think they share us

395
00:20:09,900 --> 00:20:12,179
key when really each shows a key with

396
00:20:12,179 --> 00:20:14,340
the adversary

397
00:20:14,340 --> 00:20:16,260
so let's say the Allison Bob now share a

398
00:20:16,260 --> 00:20:18,059
secret password which might be of low

399
00:20:18,059 --> 00:20:19,980
entropy like many passwords are in

400
00:20:19,980 --> 00:20:21,660
practice

401
00:20:21,660 --> 00:20:23,340
um with a password authenticated key

402
00:20:23,340 --> 00:20:25,080
exchange or cake they can use this

403
00:20:25,080 --> 00:20:26,760
password to stop a man in the middle

404
00:20:26,760 --> 00:20:28,679
attack

405
00:20:28,679 --> 00:20:31,919
so uh Pake is Illustrated here

406
00:20:31,919 --> 00:20:34,020
um as the encrypted key exchange

407
00:20:34,020 --> 00:20:36,120
protocol that you just heard about

408
00:20:36,120 --> 00:20:37,919
um in the last talk

409
00:20:37,919 --> 00:20:40,140
which encrypts the Hellman key messages

410
00:20:40,140 --> 00:20:42,120
with an ideal Cipher using the password

411
00:20:42,120 --> 00:20:43,500
as a key

412
00:20:43,500 --> 00:20:46,020
uh when not under attack the parties can

413
00:20:46,020 --> 00:20:47,760
successfully decrypt each of those

414
00:20:47,760 --> 00:20:49,980
messages and then agree on a feed the

415
00:20:49,980 --> 00:20:51,900
same as diffie-hellman

416
00:20:51,900 --> 00:20:53,880
and now say there's a man in the middle

417
00:20:53,880 --> 00:20:55,620
adversary

418
00:20:55,620 --> 00:20:58,080
the adversary now has a choice it can

419
00:20:58,080 --> 00:21:00,299
either leave Alice's message any

420
00:21:00,299 --> 00:21:03,120
unchanged but then it won't learn uh

421
00:21:03,120 --> 00:21:06,179
Bob's key because effectively it becomes

422
00:21:06,179 --> 00:21:09,660
just a Divi Helman key exchange again

423
00:21:09,660 --> 00:21:11,760
alternatively you can modify Alice's

424
00:21:11,760 --> 00:21:13,980
message to get a prime but this requires

425
00:21:13,980 --> 00:21:16,200
guessing which password to encrypt under

426
00:21:16,200 --> 00:21:17,700
and then guess it's wrong the message

427
00:21:17,700 --> 00:21:19,740
will be decrypted to a random

428
00:21:19,740 --> 00:21:21,780
diffie-hellman group element and again

429
00:21:21,780 --> 00:21:23,700
it becomes a random key the adversary

430
00:21:23,700 --> 00:21:24,840
can't guess

431
00:21:24,840 --> 00:21:26,940
so this gives them an intuition as to

432
00:21:26,940 --> 00:21:27,840
like

433
00:21:27,840 --> 00:21:30,000
the sort of security properties that um

434
00:21:30,000 --> 00:21:32,100
take provides

435
00:21:32,100 --> 00:21:33,840
um the full security properties are

436
00:21:33,840 --> 00:21:36,960
defined uh have been defined in two ways

437
00:21:36,960 --> 00:21:38,460
um

438
00:21:38,460 --> 00:21:42,120
one um uh one is the game based model

439
00:21:42,120 --> 00:21:44,280
and the other is in the Universal

440
00:21:44,280 --> 00:21:45,960
composability framework

441
00:21:45,960 --> 00:21:50,039
and the UC definition has since become

442
00:21:50,039 --> 00:21:51,659
standard

443
00:21:51,659 --> 00:21:54,059
uh so my father most commonly used for a

444
00:21:54,059 --> 00:21:56,159
pig

445
00:21:56,159 --> 00:21:59,520
so now I'll present our trivial pick

446
00:21:59,520 --> 00:22:01,200
here Allison Bob send no messages

447
00:22:01,200 --> 00:22:03,539
instead just sample their own keys

448
00:22:03,539 --> 00:22:06,360
uniformly at random

449
00:22:06,360 --> 00:22:08,700
so the question is is this opaque

450
00:22:08,700 --> 00:22:10,740
like I mean obviously not as it's not

451
00:22:10,740 --> 00:22:14,039
correct right this is like uh this is uh

452
00:22:14,039 --> 00:22:15,539
in the so-called key exchange protocol

453
00:22:15,539 --> 00:22:16,980
the only way the two parties can agree

454
00:22:16,980 --> 00:22:18,600
on a keys by accident

455
00:22:18,600 --> 00:22:21,419
right actually it does satisfy the UC

456
00:22:21,419 --> 00:22:24,740
ideal functionality for a pick

457
00:22:24,840 --> 00:22:28,919
to see why we need to look at the um you

458
00:22:28,919 --> 00:22:33,000
see pink ideal functionality of uh nftfl

459
00:22:33,000 --> 00:22:34,860
so the key features of this ideal

460
00:22:34,860 --> 00:22:37,380
functionality are test password and new

461
00:22:37,380 --> 00:22:38,820
key

462
00:22:38,820 --> 00:22:41,820
so um the simulator can use test

463
00:22:41,820 --> 00:22:43,860
password to test a password guess

464
00:22:43,860 --> 00:22:45,840
against a fresh session

465
00:22:45,840 --> 00:22:47,100
um

466
00:22:47,100 --> 00:22:50,340
if the simulator guesses correctly then

467
00:22:50,340 --> 00:22:53,820
the session will become compromised

468
00:22:53,820 --> 00:22:56,039
and singular to be told that their guess

469
00:22:56,039 --> 00:22:57,600
is correct

470
00:22:57,600 --> 00:22:59,159
uh similarly if the guess is wrong

471
00:22:59,159 --> 00:23:00,720
they'll be told the wrong is their guess

472
00:23:00,720 --> 00:23:02,159
is wrong

473
00:23:02,159 --> 00:23:03,659
um at this time the the session will be

474
00:23:03,659 --> 00:23:05,940
interrupted

475
00:23:05,940 --> 00:23:08,039
later on when the simulator submits a

476
00:23:08,039 --> 00:23:10,080
new key query to tell the functionality

477
00:23:10,080 --> 00:23:12,120
to Output a key to a given party

478
00:23:12,120 --> 00:23:14,280
the what key is output depends on the

479
00:23:14,280 --> 00:23:15,600
state of the session

480
00:23:15,600 --> 00:23:17,880
so if it's compromised the simulator

481
00:23:17,880 --> 00:23:19,880
gets to choose

482
00:23:19,880 --> 00:23:22,559
which key to

483
00:23:22,559 --> 00:23:25,080
um output to that party

484
00:23:25,080 --> 00:23:27,000
if it's interrupted then it's just going

485
00:23:27,000 --> 00:23:28,980
to get a random key the Party's Just

486
00:23:28,980 --> 00:23:30,900
Gonna Get a random key

487
00:23:30,900 --> 00:23:34,080
and uh only when the session is fresh

488
00:23:34,080 --> 00:23:35,640
that is like a neither corrupted or

489
00:23:35,640 --> 00:23:37,919
interrupted will the functionality like

490
00:23:37,919 --> 00:23:41,340
do what you'd expect like what you'd

491
00:23:41,340 --> 00:23:43,020
expect the queue to take to do in like

492
00:23:43,020 --> 00:23:45,600
uh the honest case where

493
00:23:45,600 --> 00:23:47,280
it generates a random key and gives the

494
00:23:47,280 --> 00:23:50,418
key same key to both parties

495
00:23:51,240 --> 00:23:52,919
now to show that the trivial page

496
00:23:52,919 --> 00:23:54,840
implements the peak ideal functionality

497
00:23:54,840 --> 00:23:57,179
we need to show a simulator that makes

498
00:23:57,179 --> 00:23:59,700
the ideal World here match the real

499
00:23:59,700 --> 00:24:00,600
world

500
00:24:00,600 --> 00:24:02,100
in particular the simulator needs to

501
00:24:02,100 --> 00:24:05,820
make the uh ideal functionality also

502
00:24:05,820 --> 00:24:08,100
output independent uniformly random keys

503
00:24:08,100 --> 00:24:10,320
to the two parties

504
00:24:10,320 --> 00:24:12,240
so to do this let me just have the

505
00:24:12,240 --> 00:24:14,460
simulator interrupt both sessions

506
00:24:14,460 --> 00:24:16,620
that is the simulator will pick a fake

507
00:24:16,620 --> 00:24:19,760
password oops

508
00:24:19,919 --> 00:24:22,200
the simulator will pick a fake password

509
00:24:22,200 --> 00:24:24,900
if you're just written as a bot that um

510
00:24:24,900 --> 00:24:27,299
neither party will use

511
00:24:27,299 --> 00:24:29,340
um either like yeah randomly or is it

512
00:24:29,340 --> 00:24:31,500
some sentimental value I guess

513
00:24:31,500 --> 00:24:33,659
and then uh try guessing this password

514
00:24:33,659 --> 00:24:35,880
against both parties

515
00:24:35,880 --> 00:24:37,799
since the guess is always they're always

516
00:24:37,799 --> 00:24:39,960
going to guess wrong the both passwords

517
00:24:39,960 --> 00:24:42,419
both sessions get interrupted so then

518
00:24:42,419 --> 00:24:44,100
when you you can just provide any key

519
00:24:44,100 --> 00:24:45,720
you want to new key this key will get

520
00:24:45,720 --> 00:24:48,960
ignored and uh the new query will just

521
00:24:48,960 --> 00:24:51,120
send a new Fresh uniformly random key to

522
00:24:51,120 --> 00:24:54,139
both Alice and Bob here

523
00:24:55,559 --> 00:24:57,659
um but actually there's an even simpler

524
00:24:57,659 --> 00:24:59,760
example of a trio opaque

525
00:24:59,760 --> 00:25:01,919
and if you do nothing and never output a

526
00:25:01,919 --> 00:25:04,799
key so the protocol never completes

527
00:25:04,799 --> 00:25:07,320
so is this a pick now

528
00:25:07,320 --> 00:25:09,780
well uh it also satisfies the ideal

529
00:25:09,780 --> 00:25:11,520
functionality why

530
00:25:11,520 --> 00:25:13,860
well recall that the I the pick ideal

531
00:25:13,860 --> 00:25:16,860
functionality only uh outputs a key when

532
00:25:16,860 --> 00:25:19,380
the simulator sends the new key query

533
00:25:19,380 --> 00:25:21,059
the simulator can just decide to never

534
00:25:21,059 --> 00:25:23,220
send new key and then the simulation the

535
00:25:23,220 --> 00:25:24,480
simulation will be perfect because the

536
00:25:24,480 --> 00:25:25,559
ideal functionality is never going to

537
00:25:25,559 --> 00:25:28,080
send a queue

538
00:25:28,080 --> 00:25:30,659
um so I should note that this empty Peg

539
00:25:30,659 --> 00:25:32,400
was already pointed out by Canada and

540
00:25:32,400 --> 00:25:34,860
the original UC Pig paper one of the

541
00:25:34,860 --> 00:25:37,380
results is to is a proof that take is

542
00:25:37,380 --> 00:25:39,480
impossible in the plane model but the

543
00:25:39,480 --> 00:25:40,679
thing is this empty Pig works in the

544
00:25:40,679 --> 00:25:42,779
play model so to resolve this they need

545
00:25:42,779 --> 00:25:44,039
to have an additional condition on the

546
00:25:44,039 --> 00:25:45,120
proof which is that the pick is

547
00:25:45,120 --> 00:25:46,740
non-trivial

548
00:25:46,740 --> 00:25:48,539
so as you can see yeah they have a

549
00:25:48,539 --> 00:25:51,179
non-trivial requirement motivated by

550
00:25:51,179 --> 00:25:54,320
this empty Pig protocol

551
00:25:54,559 --> 00:25:57,120
however the existence of the empty Pig

552
00:25:57,120 --> 00:25:59,159
protocol is more of a general problem

553
00:25:59,159 --> 00:26:01,080
it's not really very specific to take at

554
00:26:01,080 --> 00:26:02,159
all

555
00:26:02,159 --> 00:26:03,900
um because it's also true of

556
00:26:03,900 --> 00:26:06,659
authenticated key exchange or two-party

557
00:26:06,659 --> 00:26:09,419
computation or other things as well that

558
00:26:09,419 --> 00:26:11,460
is it's just because you see it usually

559
00:26:11,460 --> 00:26:13,799
works in a like a asynchronous model

560
00:26:13,799 --> 00:26:15,539
letting the adversary delay protocol

561
00:26:15,539 --> 00:26:17,220
execution arbitrarily

562
00:26:17,220 --> 00:26:19,559
and if the adversary can decide to never

563
00:26:19,559 --> 00:26:21,600
deliver any messages at all then every

564
00:26:21,600 --> 00:26:24,179
protocol it kind of looks like this

565
00:26:24,179 --> 00:26:25,679
um so because there's a generic issue

566
00:26:25,679 --> 00:26:27,600
it's not as relevant to our focus on pay

567
00:26:27,600 --> 00:26:29,580
and so I'll mostly skip past this

568
00:26:29,580 --> 00:26:30,960
particular problem for the this

569
00:26:30,960 --> 00:26:33,360
presentation

570
00:26:33,360 --> 00:26:35,820
so we analyzed several ways of fixing

571
00:26:35,820 --> 00:26:37,380
the the take definition to include

572
00:26:37,380 --> 00:26:39,360
correctness

573
00:26:39,360 --> 00:26:40,620
so while we showed they're all

574
00:26:40,620 --> 00:26:42,000
equivalent that doesn't necessarily mean

575
00:26:42,000 --> 00:26:43,679
that they're all equally useful some

576
00:26:43,679 --> 00:26:45,539
might be more convenient to use for some

577
00:26:45,539 --> 00:26:46,740
purpose

578
00:26:46,740 --> 00:26:48,419
so the first approach is the simplest

579
00:26:48,419 --> 00:26:50,400
you can just explicitly require that the

580
00:26:50,400 --> 00:26:52,140
protocol is correct

581
00:26:52,140 --> 00:26:54,720
that's what the non-triviality condition

582
00:26:54,720 --> 00:26:57,120
of Canadia doll did

583
00:26:57,120 --> 00:26:58,140
um

584
00:26:58,140 --> 00:27:02,400
and uh for their impossibility proof I

585
00:27:02,400 --> 00:27:04,740
mean also it's it seems like a pretty

586
00:27:04,740 --> 00:27:05,940
reasonable thing to do like most

587
00:27:05,940 --> 00:27:07,679
game-based definitions will have a

588
00:27:07,679 --> 00:27:09,600
security property and a correctness

589
00:27:09,600 --> 00:27:12,059
property and the separate things but UC

590
00:27:12,059 --> 00:27:13,740
tends to work differently if you see

591
00:27:13,740 --> 00:27:16,440
usually the whole definition

592
00:27:16,440 --> 00:27:19,320
um is given by the ideal functionality

593
00:27:19,320 --> 00:27:20,580
and that's very important for

594
00:27:20,580 --> 00:27:23,960
composition because any protocol that's

595
00:27:23,960 --> 00:27:27,059
built using Pig will work in the it will

596
00:27:27,059 --> 00:27:28,740
be defined or analyzed in the pink

597
00:27:28,740 --> 00:27:30,480
hybrid model so you won't be analyzing

598
00:27:30,480 --> 00:27:32,100
it using some concrete pick you'll be

599
00:27:32,100 --> 00:27:33,900
analyzing it as using this cake ideal

600
00:27:33,900 --> 00:27:35,460
functionality and then use the

601
00:27:35,460 --> 00:27:36,960
composition theorem to show that it

602
00:27:36,960 --> 00:27:38,220
works when you instantiate if the

603
00:27:38,220 --> 00:27:40,500
concrete you take now if this pick ideal

604
00:27:40,500 --> 00:27:41,520
functionality doesn't guarantee

605
00:27:41,520 --> 00:27:43,020
correctness whatever protocol you're

606
00:27:43,020 --> 00:27:45,059
building on top is not going to be able

607
00:27:45,059 --> 00:27:46,500
to you're not going to be able to

608
00:27:46,500 --> 00:27:49,620
analyze it assuming correctness holds

609
00:27:49,620 --> 00:27:51,539
in the hybrid model because it doesn't

610
00:27:51,539 --> 00:27:54,320
hold in the hybrid model

611
00:27:54,419 --> 00:27:59,419
uh so next we tried to go uh

612
00:27:59,419 --> 00:28:01,740
look at more of the under underlying

613
00:28:01,740 --> 00:28:04,200
reason for this problem so

614
00:28:04,200 --> 00:28:05,520
it seems like the cake ideal

615
00:28:05,520 --> 00:28:07,020
functionality is giving the simulator

616
00:28:07,020 --> 00:28:08,760
too much power

617
00:28:08,760 --> 00:28:10,860
intuitively intuitively is the test

618
00:28:10,860 --> 00:28:13,740
password query corresponds to the

619
00:28:13,740 --> 00:28:16,559
adversary replacing an honest party's

620
00:28:16,559 --> 00:28:19,320
message with their own message if they

621
00:28:19,320 --> 00:28:20,760
replace a message then they can put

622
00:28:20,760 --> 00:28:22,140
their own password guess into this

623
00:28:22,140 --> 00:28:23,760
message

624
00:28:23,760 --> 00:28:25,740
so this is just another approach

625
00:28:25,740 --> 00:28:27,840
restricting to reasonable simulators

626
00:28:27,840 --> 00:28:31,440
meaning simulators that only use uh test

627
00:28:31,440 --> 00:28:34,620
password when the adversary decides to

628
00:28:34,620 --> 00:28:36,840
tamper with a message

629
00:28:36,840 --> 00:28:38,340
so there's a number of ways you could

630
00:28:38,340 --> 00:28:39,960
Define this

631
00:28:39,960 --> 00:28:41,880
um so for a reasonable one way is there

632
00:28:41,880 --> 00:28:43,380
a reasonable simulator

633
00:28:43,380 --> 00:28:45,419
so

634
00:28:45,419 --> 00:28:47,039
excuse me

635
00:28:47,039 --> 00:28:49,380
one way is a reasonable simulator so if

636
00:28:49,380 --> 00:28:50,779
the adversary

637
00:28:50,779 --> 00:28:53,340
is an eavesdropper meaning it doesn't

638
00:28:53,340 --> 00:28:56,220
modify any messages it just eavesdrops

639
00:28:56,220 --> 00:28:58,620
um then the simulator must not use test

640
00:28:58,620 --> 00:29:00,059
password except with negotiable

641
00:29:00,059 --> 00:29:01,440
probability

642
00:29:01,440 --> 00:29:04,620
uh next is a strong reasonable simulator

643
00:29:04,620 --> 00:29:07,559
which is a bit more a slightly stronger

644
00:29:07,559 --> 00:29:10,200
notion uh at least it looks like a

645
00:29:10,200 --> 00:29:12,480
stronger stronger initially

646
00:29:12,480 --> 00:29:14,640
um so it's additionally required to uh

647
00:29:14,640 --> 00:29:17,460
requires the simulator to not call

648
00:29:17,460 --> 00:29:19,500
um test password

649
00:29:19,500 --> 00:29:21,179
um the floor a modifies a message even

650
00:29:21,179 --> 00:29:22,919
if a is going to later modify a message

651
00:29:22,919 --> 00:29:25,440
so even if a is not a use dropper as

652
00:29:25,440 --> 00:29:27,480
long as a behaves like a eavesdropper

653
00:29:27,480 --> 00:29:29,820
then it will uh the simulator but still

654
00:29:29,820 --> 00:29:31,799
not call test password

655
00:29:31,799 --> 00:29:33,059
and then finally there's a couple other

656
00:29:33,059 --> 00:29:35,220
tweaks you can make like probability one

657
00:29:35,220 --> 00:29:37,080
instead of negotiable probability or

658
00:29:37,080 --> 00:29:39,539
maybe some interesting uh more

659
00:29:39,539 --> 00:29:41,640
interesting one is to require that all

660
00:29:41,640 --> 00:29:42,840
successful simulators meaning all

661
00:29:42,840 --> 00:29:44,340
simulators that

662
00:29:44,340 --> 00:29:46,380
can be used to prove

663
00:29:46,380 --> 00:29:48,899
um that the protocol instantiates it uh

664
00:29:48,899 --> 00:29:51,840
and Institute the ideal functionality uh

665
00:29:51,840 --> 00:29:52,980
satisfy one of the reasonability

666
00:29:52,980 --> 00:29:54,360
definitions

667
00:29:54,360 --> 00:29:56,640
so it turns out these last two things

668
00:29:56,640 --> 00:29:59,820
are incompatible

669
00:29:59,820 --> 00:30:00,419
um

670
00:30:00,419 --> 00:30:01,860
and so it's always possible to construct

671
00:30:01,860 --> 00:30:05,039
simulators that violate reasonable or uh

672
00:30:05,039 --> 00:30:08,039
strongly reasonable with non-zero but

673
00:30:08,039 --> 00:30:10,440
negligible probability so that means we

674
00:30:10,440 --> 00:30:12,899
can't we can't say that uh all

675
00:30:12,899 --> 00:30:14,880
successful simulators are perfectly

676
00:30:14,880 --> 00:30:17,100
reasonable for example but if we exclude

677
00:30:17,100 --> 00:30:19,320
this one compatibility it turns out all

678
00:30:19,320 --> 00:30:20,820
combinations of these like ways of

679
00:30:20,820 --> 00:30:24,299
defining anti-equivalent yeah that's uh

680
00:30:24,299 --> 00:30:27,539
yeah we proved this in our paper

681
00:30:27,539 --> 00:30:29,640
however ideally we would like to make it

682
00:30:29,640 --> 00:30:31,860
work with just the ideal functionality

683
00:30:31,860 --> 00:30:34,200
we'd like to fix the works of just UC

684
00:30:34,200 --> 00:30:35,640
with no outside requirements on the

685
00:30:35,640 --> 00:30:37,080
protocol or the simulator then

686
00:30:37,080 --> 00:30:38,220
everything would work nicely with the

687
00:30:38,220 --> 00:30:40,620
composition theorem

688
00:30:40,620 --> 00:30:42,000
unfortunately to prove this is

689
00:30:42,000 --> 00:30:43,919
impossible to fix just by changing the

690
00:30:43,919 --> 00:30:45,720
ideal functionality alone

691
00:30:45,720 --> 00:30:47,460
the idea of functionality has no way to

692
00:30:47,460 --> 00:30:49,260
tell whether the adversary is acting as

693
00:30:49,260 --> 00:30:51,480
an eavesdropper or a man in the middle

694
00:30:51,480 --> 00:30:53,640
in the latter case the adversary can

695
00:30:53,640 --> 00:30:55,380
corrupt the protocol messages so the

696
00:30:55,380 --> 00:30:57,720
simulator needs the power to make the

697
00:30:57,720 --> 00:31:01,380
cake output independently random keys

698
00:31:01,380 --> 00:31:03,299
so again it needs to be able to Output

699
00:31:03,299 --> 00:31:05,039
independently random keys if it's a man

700
00:31:05,039 --> 00:31:06,480
in the middle so it's the eavesdropper

701
00:31:06,480 --> 00:31:08,760
we need to not give the simulator this

702
00:31:08,760 --> 00:31:10,380
power because otherwise they could just

703
00:31:10,380 --> 00:31:12,899
the simulator can use that power to

704
00:31:12,899 --> 00:31:14,340
uh

705
00:31:14,340 --> 00:31:16,559
make the trivial pick

706
00:31:16,559 --> 00:31:18,679
um epic

707
00:31:18,679 --> 00:31:21,059
so the

708
00:31:21,059 --> 00:31:23,700
that we have this problem is like you uh

709
00:31:23,700 --> 00:31:25,740
the the the ideal functionality just

710
00:31:25,740 --> 00:31:28,380
doesn't have enough information to model

711
00:31:28,380 --> 00:31:30,299
it properly

712
00:31:30,299 --> 00:31:32,340
so this suggests that maybe we need to

713
00:31:32,340 --> 00:31:34,559
change things up a little bit we need to

714
00:31:34,559 --> 00:31:35,820
change something so that the ideal

715
00:31:35,820 --> 00:31:37,620
functionality can know whether the

716
00:31:37,620 --> 00:31:38,760
adversary is behaving as the

717
00:31:38,760 --> 00:31:41,700
eavesdropper or a man in the middle

718
00:31:41,700 --> 00:31:43,860
um so we Revisited the unauthenticated

719
00:31:43,860 --> 00:31:45,840
uh Channel

720
00:31:45,840 --> 00:31:48,480
um model that the takes are built in

721
00:31:48,480 --> 00:31:50,159
so when Alice and Bob are communicating

722
00:31:50,159 --> 00:31:52,260
over an unauthenticated Channel this

723
00:31:52,260 --> 00:31:53,460
really means that they're just talking

724
00:31:53,460 --> 00:31:56,399
directly to the adversary the the it

725
00:31:56,399 --> 00:31:57,899
only really functions as a Channel with

726
00:31:57,899 --> 00:32:00,000
the adversary decides to send the

727
00:32:00,000 --> 00:32:02,100
messages back and forth

728
00:32:02,100 --> 00:32:03,240
um so it's only at the will of the

729
00:32:03,240 --> 00:32:04,980
adversary that's the channel

730
00:32:04,980 --> 00:32:07,500
so maybe a slightly more realistic model

731
00:32:07,500 --> 00:32:09,840
is that Alice and Bob are talking to

732
00:32:09,840 --> 00:32:12,600
each other over some untrusted Network

733
00:32:12,600 --> 00:32:14,580
um Illustrated as a router here

734
00:32:14,580 --> 00:32:16,140
and when the router is working properly

735
00:32:16,140 --> 00:32:18,059
the adversary can only eavesdrop on the

736
00:32:18,059 --> 00:32:19,740
messages passing through it cannot

737
00:32:19,740 --> 00:32:22,980
actually uh change the messages

738
00:32:22,980 --> 00:32:24,960
but if the adversary preps the router

739
00:32:24,960 --> 00:32:26,760
then it can modify the messages

740
00:32:26,760 --> 00:32:28,919
arbitrarily as within authenticated

741
00:32:28,919 --> 00:32:30,059
Channel

742
00:32:30,059 --> 00:32:32,880
so model this we we treat the router as

743
00:32:32,880 --> 00:32:36,000
a third party in the protocol uh Pig

744
00:32:36,000 --> 00:32:38,460
protocol and give Alice and Bob

745
00:32:38,460 --> 00:32:40,620
unauthenticated sorry give the oil

746
00:32:40,620 --> 00:32:42,299
symbol authenticated channels to

747
00:32:42,299 --> 00:32:45,260
communicate with the router

748
00:32:45,980 --> 00:32:48,179
we also acquire that the uncorrupted

749
00:32:48,179 --> 00:32:49,080
router

750
00:32:49,080 --> 00:32:51,840
only just his job is only the past

751
00:32:51,840 --> 00:32:53,279
messages it can't do any like actual

752
00:32:53,279 --> 00:32:54,779
computation

753
00:32:54,779 --> 00:32:56,640
um so the protocol doesn't get to

754
00:32:56,640 --> 00:32:58,620
specify what the router does that's

755
00:32:58,620 --> 00:33:01,440
predefined

756
00:33:01,440 --> 00:33:03,480
um but if the uh

757
00:33:03,480 --> 00:33:05,340
router is corrupted then the adversary

758
00:33:05,340 --> 00:33:07,919
gets to tell the router to do whatever

759
00:33:07,919 --> 00:33:09,480
it wants and then it gets to modify the

760
00:33:09,480 --> 00:33:10,380
messages

761
00:33:10,380 --> 00:33:12,360
and just like if it corrupts any other

762
00:33:12,360 --> 00:33:14,399
party

763
00:33:14,399 --> 00:33:16,380
so with this model we only needed to

764
00:33:16,380 --> 00:33:19,799
slightly tweak the um take ideal

765
00:33:19,799 --> 00:33:23,159
functionality to include correctness

766
00:33:23,159 --> 00:33:24,899
pick where we just need to make test

767
00:33:24,899 --> 00:33:27,899
password uh queries come from a correct

768
00:33:27,899 --> 00:33:29,880
a corrupted party instead of from the

769
00:33:29,880 --> 00:33:31,679
simulator

770
00:33:31,679 --> 00:33:32,340
um

771
00:33:32,340 --> 00:33:34,080
and that way if nobody's corrected the

772
00:33:34,080 --> 00:33:36,140
simulator can't use test password to

773
00:33:36,140 --> 00:33:38,700
interrupt the session and so the trivial

774
00:33:38,700 --> 00:33:40,620
pick doesn't satisfy the definition

775
00:33:40,620 --> 00:33:43,320
in fact we uh we proved that any uh that

776
00:33:43,320 --> 00:33:45,840
satisfying this definition is equivalent

777
00:33:45,840 --> 00:33:47,340
to

778
00:33:47,340 --> 00:33:48,960
um satisfying the original UC pick

779
00:33:48,960 --> 00:33:50,519
definition and also satisfying

780
00:33:50,519 --> 00:33:52,820
correctness

781
00:33:53,820 --> 00:33:55,260
um

782
00:33:55,260 --> 00:33:57,179
and it also turns out that each of these

783
00:33:57,179 --> 00:33:58,980
approaches to requiring practice also

784
00:33:58,980 --> 00:34:00,779
has a natural corresponding approach to

785
00:34:00,779 --> 00:34:03,419
requiring the protocol to Output it a

786
00:34:03,419 --> 00:34:05,220
key to rule out the empty pick

787
00:34:05,220 --> 00:34:08,219
so if required as a separate property we

788
00:34:08,219 --> 00:34:10,739
might as well require the protocol

789
00:34:10,739 --> 00:34:13,980
um complete as a separate property

790
00:34:13,980 --> 00:34:16,199
um for reasonable simulators we could

791
00:34:16,199 --> 00:34:18,119
require uh we can require the simulator

792
00:34:18,119 --> 00:34:19,139
to

793
00:34:19,139 --> 00:34:22,980
uh set on to eventually send the new key

794
00:34:22,980 --> 00:34:25,500
messages if the adversary eventually

795
00:34:25,500 --> 00:34:28,080
delivers all of its messages

796
00:34:28,080 --> 00:34:29,639
all the messages in the real world

797
00:34:29,639 --> 00:34:32,879
episode eventually delivers messages

798
00:34:32,879 --> 00:34:35,580
and uh

799
00:34:35,580 --> 00:34:37,619
for the three party pick model it's a

800
00:34:37,619 --> 00:34:39,500
bit more uh

801
00:34:39,500 --> 00:34:42,418
complicated but it is possible to to fix

802
00:34:42,418 --> 00:34:43,679
it using

803
00:34:43,679 --> 00:34:45,899
um a technique from a paper by cattle

804
00:34:45,899 --> 00:34:48,659
that shows how to model synchronous

805
00:34:48,659 --> 00:34:51,919
computation in UC

806
00:34:52,739 --> 00:34:55,020
all right and in conclusion we presented

807
00:34:55,020 --> 00:34:57,300
a UC pick that does not satisfy

808
00:34:57,300 --> 00:34:59,520
correctness but we focused on fake

809
00:34:59,520 --> 00:35:01,500
similar issues can occur in other

810
00:35:01,500 --> 00:35:03,480
protocols that work over unauthenticated

811
00:35:03,480 --> 00:35:05,580
channels for example UC Notions of

812
00:35:05,580 --> 00:35:07,200
authenticated key exchange also failed

813
00:35:07,200 --> 00:35:10,380
to guarantee practice in this way

814
00:35:10,380 --> 00:35:12,300
um we analyzed several approaches to

815
00:35:12,300 --> 00:35:13,980
finding fixing the definition to include

816
00:35:13,980 --> 00:35:15,960
definition correctness which turned out

817
00:35:15,960 --> 00:35:17,700
to be equivalent

818
00:35:17,700 --> 00:35:19,800
uh first was to explicitly acquire the

819
00:35:19,800 --> 00:35:21,540
protocol to be correct

820
00:35:21,540 --> 00:35:24,000
uh second was to Nerf the simulator so

821
00:35:24,000 --> 00:35:25,500
it cannot use test password when the

822
00:35:25,500 --> 00:35:28,200
adversary is just an eavesdropper

823
00:35:28,200 --> 00:35:29,660
uh

824
00:35:29,660 --> 00:35:31,560
unfortunately showed that it cannot be

825
00:35:31,560 --> 00:35:33,000
fixed but just by changing the ideal

826
00:35:33,000 --> 00:35:34,140
functionality

827
00:35:34,140 --> 00:35:36,660
but we can fix it if we add the router

828
00:35:36,660 --> 00:35:39,180
as a third party

829
00:35:39,180 --> 00:35:40,980
uh they and tweak the ideal

830
00:35:40,980 --> 00:35:43,760
functionality slightly

831
00:35:43,880 --> 00:35:47,880
this gives a composable pick definition

832
00:35:47,880 --> 00:35:50,160
that includes correctness allowing

833
00:35:50,160 --> 00:35:52,079
higher level protocols to be built on

834
00:35:52,079 --> 00:35:55,320
top of this hybrid model well

835
00:35:55,320 --> 00:35:57,060
being able to assume correctness inside

836
00:35:57,060 --> 00:35:59,160
this protocols

837
00:35:59,160 --> 00:36:02,160
and similar approaches work to rule out

838
00:36:02,160 --> 00:36:05,660
the empty tank as well

839
00:36:06,119 --> 00:36:08,720
thank you

840
00:36:13,440 --> 00:36:16,700
we have time for questions

841
00:36:22,099 --> 00:36:26,060
uh that's the definition problem

842
00:36:26,060 --> 00:36:29,040
occurs in some other UC Frameworks for

843
00:36:29,040 --> 00:36:31,800
example for ake and some other protocols

844
00:36:31,800 --> 00:36:34,020
uh akaes

845
00:36:34,020 --> 00:36:37,200
um it has the same problem yes

846
00:36:37,200 --> 00:36:41,220
I I think it's probably uh generic to a

847
00:36:41,220 --> 00:36:42,320
lot of like

848
00:36:42,320 --> 00:36:44,579
unauthenticated key exchange uh sorry

849
00:36:44,579 --> 00:36:47,040
unauthenticated uh Channel

850
00:36:47,040 --> 00:36:49,680
um protocols but I authenticated key

851
00:36:49,680 --> 00:36:50,820
exchange is the only other one we've

852
00:36:50,820 --> 00:36:53,820
looked at okay due to they do not

853
00:36:53,820 --> 00:36:58,700
consider crackness uh okay thank you

854
00:37:01,859 --> 00:37:04,320
so you said you had a couple different

855
00:37:04,320 --> 00:37:06,420
ways of kind of fixing this you know

856
00:37:06,420 --> 00:37:08,280
maybe three or so

857
00:37:08,280 --> 00:37:10,320
do you have any recommendation for

858
00:37:10,320 --> 00:37:12,420
somebody writing a random paper which of

859
00:37:12,420 --> 00:37:15,119
the three formalisms they should use I

860
00:37:15,119 --> 00:37:16,920
mean what what answer is whatever makes

861
00:37:16,920 --> 00:37:18,599
your proof easiest since they're

862
00:37:18,599 --> 00:37:23,040
equivalent but um I I I I like the uh

863
00:37:23,040 --> 00:37:25,200
the the three-party pick version the

864
00:37:25,200 --> 00:37:27,180
best I I like how it fits with the

865
00:37:27,180 --> 00:37:29,040
composition model

866
00:37:29,040 --> 00:37:29,700
um

867
00:37:29,700 --> 00:37:31,680
I I think that's probably easiest if

868
00:37:31,680 --> 00:37:34,020
you're using a page if you're creating

869
00:37:34,020 --> 00:37:35,640
it if you're trying to prove something

870
00:37:35,640 --> 00:37:37,440
is a take

871
00:37:37,440 --> 00:37:39,359
um I think the reasonable simulators

872
00:37:39,359 --> 00:37:40,619
definition may actually be the most

873
00:37:40,619 --> 00:37:42,680
convenient

874
00:37:42,680 --> 00:37:44,940
thank you very much let's thank our

875
00:37:44,940 --> 00:37:47,480
speaker again

876
00:37:51,359 --> 00:37:56,420
next up will be paper number two

877
00:38:11,579 --> 00:38:14,099
but this paper will be moving away from

878
00:38:14,099 --> 00:38:16,260
pakes and talking about key

879
00:38:16,260 --> 00:38:18,599
encapsulation in particular Center

880
00:38:18,599 --> 00:38:21,599
binding key encapsulation our speaker

881
00:38:21,599 --> 00:38:23,460
will be

882
00:38:23,460 --> 00:38:26,460
vasilis

883
00:38:36,440 --> 00:38:40,800
yes so I'm going to cheat a little bit I

884
00:38:40,800 --> 00:38:42,960
hope that's okay

885
00:38:42,960 --> 00:38:45,740
um so my name is

886
00:38:45,740 --> 00:38:51,000
and I'm going to to present results from

887
00:38:51,000 --> 00:38:53,160
our John Burke

888
00:38:53,160 --> 00:38:54,020
um

889
00:38:54,020 --> 00:38:58,040
with loud intense versus

890
00:39:01,460 --> 00:39:04,920
While most of the co-authors are from

891
00:39:04,920 --> 00:39:09,420
the well-known University of Kit me and

892
00:39:09,420 --> 00:39:12,359
zarya lebrecht are from a small Research

893
00:39:12,359 --> 00:39:16,020
Institute fzi located also at in

894
00:39:16,020 --> 00:39:19,800
kaiserable first of all

895
00:39:19,800 --> 00:39:21,599
um I would like to motivate the concept

896
00:39:21,599 --> 00:39:23,160
of a secure Channel

897
00:39:23,160 --> 00:39:26,099
the basic intuition of such a strong

898
00:39:26,099 --> 00:39:29,520
channel is that an adversary is not

899
00:39:29,520 --> 00:39:32,880
allowed to learn anything except that

900
00:39:32,880 --> 00:39:35,960
there is communication taking place

901
00:39:35,960 --> 00:39:39,420
employing only CCE to secure encryption

902
00:39:39,420 --> 00:39:41,520
however is not enough

903
00:39:41,520 --> 00:39:43,980
the adversary May relay the honest

904
00:39:43,980 --> 00:39:46,260
ciphertext to another party in the name

905
00:39:46,260 --> 00:39:48,180
of a control party

906
00:39:48,180 --> 00:39:50,180
or a corrupted party

907
00:39:50,180 --> 00:39:52,800
which is going to look like an honest

908
00:39:52,800 --> 00:39:57,420
ciphertext from this corrupted party

909
00:39:57,420 --> 00:40:01,140
um this cc is to security alone this

910
00:40:01,140 --> 00:40:04,940
attack cannot be Earth countered however

911
00:40:04,940 --> 00:40:07,619
sending such encryptions over an

912
00:40:07,619 --> 00:40:09,900
authenticated Channel towards these

913
00:40:09,900 --> 00:40:12,900
kinds of attacks and may realize seq

914
00:40:12,900 --> 00:40:14,099
Channel

915
00:40:14,099 --> 00:40:15,619
please note

916
00:40:15,619 --> 00:40:18,720
that's already here it is required that

917
00:40:18,720 --> 00:40:21,839
the encrypted message the plain text is

918
00:40:21,839 --> 00:40:25,200
concatenated by some form of sender

919
00:40:25,200 --> 00:40:29,760
Identity or any other binding to the

920
00:40:29,760 --> 00:40:33,300
I'll dedicated Channel

921
00:40:33,300 --> 00:40:36,359
so how are authenticated chairs

922
00:40:36,359 --> 00:40:38,760
constructed um for this presentation

923
00:40:38,760 --> 00:40:41,720
it's also sufficient to know that an

924
00:40:41,720 --> 00:40:44,099
existential unfortable chosen message

925
00:40:44,099 --> 00:40:47,280
attack secure uh signature plus some

926
00:40:47,280 --> 00:40:50,339
secure certification Authority is enough

927
00:40:50,339 --> 00:40:53,760
just think about it as some form of uh

928
00:40:53,760 --> 00:40:55,460
sign friction

929
00:40:55,460 --> 00:41:00,079
constructed in form of encrypt and sign

930
00:41:00,839 --> 00:41:05,760
now CCA security is quite strong as

931
00:41:05,760 --> 00:41:08,339
flipping a single bit

932
00:41:08,339 --> 00:41:11,520
of the ciphertext will be detected and

933
00:41:11,520 --> 00:41:12,680
rejected

934
00:41:12,680 --> 00:41:15,960
thus cca2 security guarantees

935
00:41:15,960 --> 00:41:18,660
non-mallebility of the ciphertext

936
00:41:18,660 --> 00:41:22,260
adding euf CMA signatures however among

937
00:41:22,260 --> 00:41:23,280
other things

938
00:41:23,280 --> 00:41:25,680
guarantees also that manipulations of

939
00:41:25,680 --> 00:41:27,960
the ciphertext are going to be detected

940
00:41:27,960 --> 00:41:30,240
it's used therefore that the Integrity

941
00:41:30,240 --> 00:41:32,780
protection guarantees

942
00:41:32,780 --> 00:41:36,540
guarantees of cca2 security and the aof

943
00:41:36,540 --> 00:41:39,780
CMA security overlap the first such

944
00:41:39,780 --> 00:41:42,359
observation was done by kanetti Craft

945
00:41:42,359 --> 00:41:46,260
and Nielsen in the year 2003

946
00:41:46,260 --> 00:41:48,300
um I'll buy their main motivation was

947
00:41:48,300 --> 00:41:49,859
somewhat different

948
00:41:49,859 --> 00:41:52,020
um the authors proposed a relaxation of

949
00:41:52,020 --> 00:41:54,740
cca2 that allows a special form of

950
00:41:54,740 --> 00:41:57,900
benign malleability of the ciphertext

951
00:41:57,900 --> 00:42:00,540
basically the bit flipping example

952
00:42:00,540 --> 00:42:01,500
um

953
00:42:01,500 --> 00:42:03,900
and they introduced the replayable CCA

954
00:42:03,900 --> 00:42:06,240
security which they also showed to be

955
00:42:06,240 --> 00:42:09,119
sufficient to realize a secure Channel

956
00:42:09,119 --> 00:42:10,680
when combined with authenticated

957
00:42:10,680 --> 00:42:14,220
channels then McKinsey writer and young

958
00:42:14,220 --> 00:42:17,180
motivated by this exact observation

959
00:42:17,180 --> 00:42:20,640
introduce a special kind of pke namely

960
00:42:20,640 --> 00:42:22,680
the attack based pke

961
00:42:22,680 --> 00:42:25,020
together with the first relaxation of

962
00:42:25,020 --> 00:42:27,359
the non-mallability intuition and namely

963
00:42:27,359 --> 00:42:30,680
the weak normal ability

964
00:42:31,740 --> 00:42:33,540
which basically lets the adversary

965
00:42:33,540 --> 00:42:35,640
manipulate everything as long as the

966
00:42:35,640 --> 00:42:37,380
tech inside the server text is not

967
00:42:37,380 --> 00:42:38,700
concerned

968
00:42:38,700 --> 00:42:40,800
they showed this to be sufficient for a

969
00:42:40,800 --> 00:42:43,140
secure channel in conjunction with

970
00:42:43,140 --> 00:42:45,079
authenticated channels

971
00:42:45,079 --> 00:42:47,940
both security definitions are somewhat

972
00:42:47,940 --> 00:42:51,000
incomparable as rcca and Regional

973
00:42:51,000 --> 00:42:53,760
malleability concern different kind of

974
00:42:53,760 --> 00:42:56,820
pke Notions and this is going to be a

975
00:42:56,820 --> 00:42:59,460
similar problem with sender binding

976
00:42:59,460 --> 00:43:03,380
chems and general purpose camps

977
00:43:03,380 --> 00:43:07,200
recently we have introduced a more

978
00:43:07,200 --> 00:43:08,700
relaxed security definition than the

979
00:43:08,700 --> 00:43:10,319
previous tag-based big CCA security

980
00:43:10,319 --> 00:43:14,099
definitions namely send a binding CPA

981
00:43:14,099 --> 00:43:15,540
for

982
00:43:15,540 --> 00:43:18,060
um sender binding encryption

983
00:43:18,060 --> 00:43:20,280
and so that this relaxed definition is

984
00:43:20,280 --> 00:43:21,839
still sufficient and in fact weaker than

985
00:43:21,839 --> 00:43:24,500
previous Notions

986
00:43:24,900 --> 00:43:27,119
however in the reality no one is going

987
00:43:27,119 --> 00:43:29,359
to use a solely based pke

988
00:43:29,359 --> 00:43:31,800
based encryption because of the very

989
00:43:31,800 --> 00:43:34,260
elegant alternative by hybrid encryption

990
00:43:34,260 --> 00:43:36,599
therefore we have asked ourselves how

991
00:43:36,599 --> 00:43:38,640
are our relaxation of a special kind of

992
00:43:38,640 --> 00:43:40,579
pkea

993
00:43:40,579 --> 00:43:42,839
translates to the security requirements

994
00:43:42,839 --> 00:43:45,780
of the cam them compositions and we have

995
00:43:45,780 --> 00:43:49,140
found interesting insights

996
00:43:49,140 --> 00:43:52,319
their literature around hybrid

997
00:43:52,319 --> 00:43:54,060
encryption has produced quite a lot of

998
00:43:54,060 --> 00:43:55,920
Works regarding the relaxation of the

999
00:43:55,920 --> 00:43:58,020
security requirements of the dam or the

1000
00:43:58,020 --> 00:44:00,540
can relaxations of the dam included

1001
00:44:00,540 --> 00:44:02,720
slight relaxations like

1002
00:44:02,720 --> 00:44:06,060
indistinguishability one-time CCA or the

1003
00:44:06,060 --> 00:44:07,319
quite impressive results with the

1004
00:44:07,319 --> 00:44:09,560
extremely weak security requirements of

1005
00:44:09,560 --> 00:44:12,420
just the indistinguishability one-time

1006
00:44:12,420 --> 00:44:15,000
security over them red adversary does

1007
00:44:15,000 --> 00:44:17,700
not get any access to any records last

1008
00:44:17,700 --> 00:44:19,400
but at least these then relaxations

1009
00:44:19,400 --> 00:44:21,839
unsurprisingly require the camper to be

1010
00:44:21,839 --> 00:44:23,819
CCA too secure

1011
00:44:23,819 --> 00:44:26,400
for the sake of completeness it should

1012
00:44:26,400 --> 00:44:28,619
be mentioned that much work has been

1013
00:44:28,619 --> 00:44:30,599
done on relaxing the cam part

1014
00:44:30,599 --> 00:44:33,140
and hybrid construction

1015
00:44:33,140 --> 00:44:35,880
unfortunately these relaxations miss our

1016
00:44:35,880 --> 00:44:38,520
motivation due to the main goal of this

1017
00:44:38,520 --> 00:44:42,300
works being Acca to secure hybrid pke

1018
00:44:42,300 --> 00:44:44,400
in addition they consider only the

1019
00:44:44,400 --> 00:44:46,619
single message transfer scenario where

1020
00:44:46,619 --> 00:44:49,079
the symmetric key is used only once

1021
00:44:49,079 --> 00:44:51,480
which effectively excludes a wide range

1022
00:44:51,480 --> 00:44:54,060
of reward application as SSL ipsec and

1023
00:44:54,060 --> 00:44:55,020
SSH

1024
00:44:55,020 --> 00:44:59,000
there is however one word

1025
00:44:59,000 --> 00:45:01,920
that has extended the classic single

1026
00:45:01,920 --> 00:45:03,900
message scenario for hybrid encryption

1027
00:45:03,900 --> 00:45:05,520
towards the session communication

1028
00:45:05,520 --> 00:45:06,660
scenario

1029
00:45:06,660 --> 00:45:08,520
where the symmetric key is used multiple

1030
00:45:08,520 --> 00:45:11,280
times throughout one session such that

1031
00:45:11,280 --> 00:45:13,200
the game part serves

1032
00:45:13,200 --> 00:45:14,760
well essentially the key exchange

1033
00:45:14,760 --> 00:45:17,880
purpose the this result enabled the

1034
00:45:17,880 --> 00:45:22,280
usefulness of hybrid encryption in the

1035
00:45:22,280 --> 00:45:25,819
protocols of SSL ipsec and SSH

1036
00:45:25,819 --> 00:45:28,740
however one of their theorems is

1037
00:45:28,740 --> 00:45:31,500
surprisingly strong

1038
00:45:31,500 --> 00:45:34,380
um the authors use a cam functionality

1039
00:45:34,380 --> 00:45:36,980
that is equivalent to a cca2 secure can

1040
00:45:36,980 --> 00:45:40,020
thus we have also asked ourselves

1041
00:45:40,020 --> 00:45:43,140
whether dcca2 chem security is a

1042
00:45:43,140 --> 00:45:45,900
necessary condition for a secure Channel

1043
00:45:45,900 --> 00:45:48,660
um in a session communication scenario

1044
00:45:48,660 --> 00:45:52,619
which brings us to our contribution

1045
00:45:52,619 --> 00:45:55,500
first of all we introduce a yet another

1046
00:45:55,500 --> 00:45:58,140
reformulation of a can and namely a

1047
00:45:58,140 --> 00:46:00,599
sender binding cam in a similar fashion

1048
00:46:00,599 --> 00:46:03,359
we have reformulated a pke to a send a

1049
00:46:03,359 --> 00:46:05,400
binding encryption scheme also we

1050
00:46:05,400 --> 00:46:07,260
introduce an according security

1051
00:46:07,260 --> 00:46:12,240
definition of sbcpa for an sbcam these

1052
00:46:12,240 --> 00:46:13,680
definitions allow us to prove two

1053
00:46:13,680 --> 00:46:15,900
important theorems

1054
00:46:15,900 --> 00:46:18,300
we were able to show that the previous

1055
00:46:18,300 --> 00:46:22,319
results for SBA are also achievable by

1056
00:46:22,319 --> 00:46:25,319
hybrid encryption when and as bcpa

1057
00:46:25,319 --> 00:46:28,800
secure sbcam together with an in

1058
00:46:28,800 --> 00:46:31,079
OT Dem is used

1059
00:46:31,079 --> 00:46:34,020
which basically constructs an sbcpa

1060
00:46:34,020 --> 00:46:37,200
sender binding encryption the you see

1061
00:46:37,200 --> 00:46:40,440
realization of secure message transfer

1062
00:46:40,440 --> 00:46:43,460
then follows from the previous

1063
00:46:43,460 --> 00:46:47,460
sbcpa results

1064
00:46:47,700 --> 00:46:50,520
the scenario of session communication is

1065
00:46:50,520 --> 00:46:54,240
however somewhat more involved we showed

1066
00:46:54,240 --> 00:46:57,420
that the same also holds here with an

1067
00:46:57,420 --> 00:47:02,700
expected requirement that cca2 or rscca

1068
00:47:02,700 --> 00:47:05,099
symmetric encryption has to be used

1069
00:47:05,099 --> 00:47:07,980
because of the repeated use usage of the

1070
00:47:07,980 --> 00:47:11,160
exchange symmetric key in contrast in

1071
00:47:11,160 --> 00:47:13,200
contrast to the single-use Symmetry key

1072
00:47:13,200 --> 00:47:15,420
and

1073
00:47:15,420 --> 00:47:18,020
otdm Security in the single message

1074
00:47:18,020 --> 00:47:21,599
secure message transfer scenario

1075
00:47:21,599 --> 00:47:24,660
the interesting part here is that the

1076
00:47:24,660 --> 00:47:26,400
authenticator Channel

1077
00:47:26,400 --> 00:47:28,619
is only required during the initial

1078
00:47:28,619 --> 00:47:31,260
exchange of the symmetric key and not

1079
00:47:31,260 --> 00:47:33,720
when later on communicating over the

1080
00:47:33,720 --> 00:47:37,020
cca2 or rcca secure them

1081
00:47:37,020 --> 00:47:38,819
the reason is that the exchange

1082
00:47:38,819 --> 00:47:41,280
symmetric key is used to implicitly

1083
00:47:41,280 --> 00:47:43,740
authenticate both the sender and the

1084
00:47:43,740 --> 00:47:45,020
receiving party

1085
00:47:45,020 --> 00:47:47,640
our results can be seen as a

1086
00:47:47,640 --> 00:47:49,980
generalization of and relaxation of the

1087
00:47:49,980 --> 00:47:51,900
theorems or from nagao manabi and

1088
00:47:51,900 --> 00:47:53,640
okamoto

1089
00:47:53,640 --> 00:47:56,099
so what is the intuition behind intsb

1090
00:47:56,099 --> 00:47:59,280
CPA security for a cam

1091
00:47:59,280 --> 00:48:00,240
um

1092
00:48:00,240 --> 00:48:03,540
we don't care about any manipulations of

1093
00:48:03,540 --> 00:48:06,000
the ciphertext as long as they do not

1094
00:48:06,000 --> 00:48:09,480
concern as long as they do do concern

1095
00:48:09,480 --> 00:48:12,900
the um sender identity inside the

1096
00:48:12,900 --> 00:48:14,400
ciphertext

1097
00:48:14,400 --> 00:48:16,260
obviously

1098
00:48:16,260 --> 00:48:18,000
there is nothing that prevents the

1099
00:48:18,000 --> 00:48:20,520
adversary from honestly generating

1100
00:48:20,520 --> 00:48:24,119
um crypting

1101
00:48:24,300 --> 00:48:26,940
a ciphertext with any known standard

1102
00:48:26,940 --> 00:48:28,680
identity as they are just public

1103
00:48:28,680 --> 00:48:31,619
identities however keep in mind that

1104
00:48:31,619 --> 00:48:33,780
this security is meant to be used in

1105
00:48:33,780 --> 00:48:36,780
conjunctions without indicated channels

1106
00:48:36,780 --> 00:48:39,359
and the identities are required to be

1107
00:48:39,359 --> 00:48:42,240
bound to these channels such that and

1108
00:48:42,240 --> 00:48:44,880
honestly generated ciphertext is also

1109
00:48:44,880 --> 00:48:47,220
required to be sent over the according

1110
00:48:47,220 --> 00:48:49,079
authenticated Channel

1111
00:48:49,079 --> 00:48:51,000
which is only possible when the

1112
00:48:51,000 --> 00:48:53,099
respective center part party is

1113
00:48:53,099 --> 00:48:55,079
corrupted and thus is part of the

1114
00:48:55,079 --> 00:48:56,480
adversary

1115
00:48:56,480 --> 00:49:00,980
therefore we just reject the um such

1116
00:49:00,980 --> 00:49:06,619
honest encryptions inside the

1117
00:49:07,560 --> 00:49:09,960
um it's bcpa game

1118
00:49:09,960 --> 00:49:12,680
all right

1119
00:49:18,480 --> 00:49:21,119
now regarding the exact formulation of

1120
00:49:21,119 --> 00:49:23,119
the sbcpa security

1121
00:49:23,119 --> 00:49:25,440
the previous intuition can be found

1122
00:49:25,440 --> 00:49:27,240
inside the formulation of the decryption

1123
00:49:27,240 --> 00:49:30,660
Oracle another three important details

1124
00:49:30,660 --> 00:49:33,300
that may Stand Out are instead of

1125
00:49:33,300 --> 00:49:35,700
generating only one key pair

1126
00:49:35,700 --> 00:49:37,560
the Challenger generates two key pairs

1127
00:49:37,560 --> 00:49:39,720
for sender and receiver and the

1128
00:49:39,720 --> 00:49:41,400
adversary is handed over both public

1129
00:49:41,400 --> 00:49:43,920
keys with their respective identities

1130
00:49:43,920 --> 00:49:46,740
secondly we have only one Oracle phase

1131
00:49:46,740 --> 00:49:48,660
which stems from the simple fact that

1132
00:49:48,660 --> 00:49:50,940
technically the game can be written with

1133
00:49:50,940 --> 00:49:54,660
two oracles Oracle phases as usually is

1134
00:49:54,660 --> 00:49:57,839
the case but both phases are in contrast

1135
00:49:57,839 --> 00:50:01,920
to the cca2 game identically

1136
00:50:03,119 --> 00:50:06,599
um and we just skip the first phase

1137
00:50:06,599 --> 00:50:08,040
this is also the reason why the

1138
00:50:08,040 --> 00:50:09,119
adversaries handed a challenge

1139
00:50:09,119 --> 00:50:10,920
encapsulation together with the public

1140
00:50:10,920 --> 00:50:14,099
information in the beginning of the game

1141
00:50:14,099 --> 00:50:17,359
last but not least

1142
00:50:19,440 --> 00:50:22,160
last but not least

1143
00:50:22,160 --> 00:50:24,480
besides the results regarding the

1144
00:50:24,480 --> 00:50:26,240
realization

1145
00:50:26,240 --> 00:50:29,480
of the secure message transfer

1146
00:50:29,480 --> 00:50:33,300
of the secure Channel we also show

1147
00:50:33,300 --> 00:50:35,940
how sbcpa can be compared to currently

1148
00:50:35,940 --> 00:50:39,420
existing security Notions for camps

1149
00:50:39,420 --> 00:50:42,599
however due to different interface

1150
00:50:42,599 --> 00:50:43,740
formulation

1151
00:50:43,740 --> 00:50:47,480
of a general purpose Cam and an sbcam

1152
00:50:47,480 --> 00:50:49,859
according security Nationals Notions are

1153
00:50:49,859 --> 00:50:51,780
rather incomparable therefore we

1154
00:50:51,780 --> 00:50:53,880
restrict the comparison only to security

1155
00:50:53,880 --> 00:50:55,740
formulations of the more related

1156
00:50:55,740 --> 00:50:58,319
tech-based camps to this end we have

1157
00:50:58,319 --> 00:51:00,300
formulated the so far we can CCA notion

1158
00:51:00,300 --> 00:51:04,020
for tech-based camps namely int given

1159
00:51:04,020 --> 00:51:08,280
tag CCA security for Tech cams and that

1160
00:51:08,280 --> 00:51:10,859
is implied by all-known relaxations of

1161
00:51:10,859 --> 00:51:13,680
tech-based camps we show that this

1162
00:51:13,680 --> 00:51:16,020
security is not implied

1163
00:51:16,020 --> 00:51:18,780
by sbcba

1164
00:51:18,780 --> 00:51:21,079
sorry

1165
00:51:21,079 --> 00:51:24,059
whereas the other side

1166
00:51:24,059 --> 00:51:27,800
the on the other side the USB security

1167
00:51:27,800 --> 00:51:31,859
CPA is implied by and given tax CCA

1168
00:51:31,859 --> 00:51:35,520
security for techems

1169
00:51:35,520 --> 00:51:37,559
um in the end

1170
00:51:37,559 --> 00:51:39,780
I would like to clear out possible

1171
00:51:39,780 --> 00:51:41,900
misunderstanding that might occur

1172
00:51:41,900 --> 00:51:44,940
firstly the bcpa security is not a

1173
00:51:44,940 --> 00:51:47,460
general purpose replacement for cca2

1174
00:51:47,460 --> 00:51:48,480
security

1175
00:51:48,480 --> 00:51:51,240
SB security is meant to be used only

1176
00:51:51,240 --> 00:51:53,220
when the encryption is combined with

1177
00:51:53,220 --> 00:51:55,440
some form of Authentication

1178
00:51:55,440 --> 00:51:58,160
in such cases as arbit in the beginning

1179
00:51:58,160 --> 00:52:01,980
CCA security and all of non-relaxations

1180
00:52:01,980 --> 00:52:03,920
are

1181
00:52:03,920 --> 00:52:06,059
unnecessarily strong

1182
00:52:06,059 --> 00:52:10,260
secondly although in this work we give

1183
00:52:10,260 --> 00:52:12,720
only constructions of SB camps in the

1184
00:52:12,720 --> 00:52:15,540
standard model the sbcba ethereums are

1185
00:52:15,540 --> 00:52:17,220
not restricted to be used

1186
00:52:17,220 --> 00:52:20,460
in standard module settings only

1187
00:52:20,460 --> 00:52:24,359
the cams in the random Oracle model for

1188
00:52:24,359 --> 00:52:25,980
example the currently to be standardized

1189
00:52:25,980 --> 00:52:27,540
kyber

1190
00:52:27,540 --> 00:52:30,380
um are Fujisaki okamoto transformation

1191
00:52:30,380 --> 00:52:33,420
and as such are already almost as

1192
00:52:33,420 --> 00:52:35,339
efficient as they are underlying one-way

1193
00:52:35,339 --> 00:52:38,099
secure constructions

1194
00:52:38,099 --> 00:52:38,700
um

1195
00:52:38,700 --> 00:52:40,740
similar observation can be done also

1196
00:52:40,740 --> 00:52:42,920
with the react transformation

1197
00:52:42,920 --> 00:52:45,480
whereas in the standard model we were

1198
00:52:45,480 --> 00:52:47,099
able to prove a straightforward

1199
00:52:47,099 --> 00:52:48,780
simplification

1200
00:52:48,780 --> 00:52:53,520
um of an already quite practical

1201
00:52:53,520 --> 00:52:55,619
um although maybe not comparatively

1202
00:52:55,619 --> 00:52:57,960
efficient as in there in Oracle model

1203
00:52:57,960 --> 00:53:01,500
existing lattice based Construction

1204
00:53:01,500 --> 00:53:04,400
thank you very much

1205
00:53:09,839 --> 00:53:13,160
we have time for questions

1206
00:53:21,559 --> 00:53:25,859
this question so you kind of

1207
00:53:25,859 --> 00:53:27,720
showed that the various existing

1208
00:53:27,720 --> 00:53:30,599
definitions implied this one and that

1209
00:53:30,599 --> 00:53:33,200
this doesn't say in the other ones but

1210
00:53:33,200 --> 00:53:36,480
is there any notion in which you can say

1211
00:53:36,480 --> 00:53:39,540
this is really the like minimum that's

1212
00:53:39,540 --> 00:53:41,819
required for the application you use or

1213
00:53:41,819 --> 00:53:43,800
could one always

1214
00:53:43,800 --> 00:53:46,140
make it weaker I don't know

1215
00:53:46,140 --> 00:53:48,180
um yeah nice question

1216
00:53:48,180 --> 00:53:50,180
um

1217
00:53:50,180 --> 00:53:53,819
we have managed um or Rebecca schwerz

1218
00:53:53,819 --> 00:53:55,920
one of the co-authors have actually

1219
00:53:55,920 --> 00:53:59,660
managed to prove that as bcpa security

1220
00:53:59,660 --> 00:54:04,339
is in fact the minimal requirement and

1221
00:54:04,339 --> 00:54:07,920
there cannot be a minimal um uh weaker

1222
00:54:07,920 --> 00:54:11,160
security definition in order to you see

1223
00:54:11,160 --> 00:54:14,339
realize a secure channel in conjunction

1224
00:54:14,339 --> 00:54:16,800
with authenticated channels however this

1225
00:54:16,800 --> 00:54:19,260
results concerns

1226
00:54:19,260 --> 00:54:19,859
um

1227
00:54:19,859 --> 00:54:22,380
send a binding encryption which is again

1228
00:54:22,380 --> 00:54:24,359
a special form of public encryption

1229
00:54:24,359 --> 00:54:27,900
therefore it didn't fit in this work so

1230
00:54:27,900 --> 00:54:30,780
you may find it in her dissertation uh

1231
00:54:30,780 --> 00:54:34,220
of Rebecca flat yeah

1232
00:54:36,240 --> 00:54:38,819
thanks for the talk um so I was curious

1233
00:54:38,819 --> 00:54:40,920
how how does your formalization of

1234
00:54:40,920 --> 00:54:44,099
Central Banking encapsulation uh

1235
00:54:44,099 --> 00:54:45,900
Compares with another some other

1236
00:54:45,900 --> 00:54:47,819
formalizations of generalizations of

1237
00:54:47,819 --> 00:54:49,980
chem so for example there was something

1238
00:54:49,980 --> 00:54:52,980
known as a split chem where you again

1239
00:54:52,980 --> 00:54:54,780
have this

1240
00:54:54,780 --> 00:54:57,420
distinction of Ascender and a receiver

1241
00:54:57,420 --> 00:55:00,960
so there I believe uh in a split cam

1242
00:55:00,960 --> 00:55:03,599
when you do end cap then not only do you

1243
00:55:03,599 --> 00:55:05,099
use the receiver's public key but then

1244
00:55:05,099 --> 00:55:07,800
you also use the sender's secret key and

1245
00:55:07,800 --> 00:55:09,900
then to Decap you use the receiver

1246
00:55:09,900 --> 00:55:12,020
secret key and the sender's public key

1247
00:55:12,020 --> 00:55:14,460
uh but in your

1248
00:55:14,460 --> 00:55:15,119
um

1249
00:55:15,119 --> 00:55:19,380
sender binding chem I guess you are the

1250
00:55:19,380 --> 00:55:21,839
the sender only you only are you are

1251
00:55:21,839 --> 00:55:23,160
using ascenders

1252
00:55:23,160 --> 00:55:26,880
public key in some sense in some form um

1253
00:55:26,880 --> 00:55:29,040
it's easier to think about sender

1254
00:55:29,040 --> 00:55:31,380
binding cams as a special form of tag

1255
00:55:31,380 --> 00:55:33,480
based cams so basically a sender

1256
00:55:33,480 --> 00:55:36,180
identity can be seen as a very special

1257
00:55:36,180 --> 00:55:38,339
form of attack and tech-based encryption

1258
00:55:38,339 --> 00:55:42,780
requires to be secure for arbitrary

1259
00:55:42,780 --> 00:55:44,760
text

1260
00:55:44,760 --> 00:55:49,380
um and there is the send identities can

1261
00:55:49,380 --> 00:55:52,020
be of many different forms and it

1262
00:55:52,020 --> 00:55:54,540
depends on which constructions you are

1263
00:55:54,540 --> 00:55:58,200
used to prove them as bccpa secure

1264
00:55:58,200 --> 00:56:01,319
um you can do it directly which we

1265
00:56:01,319 --> 00:56:05,058
presented in our work in other

1266
00:56:05,359 --> 00:56:08,520
line of constructions would be

1267
00:56:08,520 --> 00:56:12,059
constructing over the Dual receiver

1268
00:56:12,059 --> 00:56:13,220
encryption

1269
00:56:13,220 --> 00:56:16,740
settings where you have actually a

1270
00:56:16,740 --> 00:56:17,960
xender

1271
00:56:17,960 --> 00:56:21,300
encrypts twice one with his own public

1272
00:56:21,300 --> 00:56:23,880
key and the second time with the

1273
00:56:23,880 --> 00:56:26,819
receiver's public key and there is

1274
00:56:26,819 --> 00:56:28,740
another property of soundness which

1275
00:56:28,740 --> 00:56:31,020
guarantees if the receiver is able to

1276
00:56:31,020 --> 00:56:34,440
decrypt the ciphertext then the sender

1277
00:56:34,440 --> 00:56:36,480
is able to decrypt this in the same way

1278
00:56:36,480 --> 00:56:38,420
which basically

1279
00:56:38,420 --> 00:56:40,559
provides them some form of plain text

1280
00:56:40,559 --> 00:56:43,680
awareness so there the public keys are

1281
00:56:43,680 --> 00:56:46,400
used as sender identities in fact

1282
00:56:46,400 --> 00:56:49,740
regarding your question with the split

1283
00:56:49,740 --> 00:56:52,079
camps and how they relate I have to

1284
00:56:52,079 --> 00:56:54,240
admit that I'm not aware of them I

1285
00:56:54,240 --> 00:56:56,579
didn't know about them but it might be

1286
00:56:56,579 --> 00:56:59,040
interesting to have a look inside thank

1287
00:56:59,040 --> 00:57:01,160
you

1288
00:57:03,960 --> 00:57:06,540
one more quick question so you said you

1289
00:57:06,540 --> 00:57:09,660
made construction from lwe and LPN I

1290
00:57:09,660 --> 00:57:12,480
believe did you look at any other

1291
00:57:12,480 --> 00:57:14,579
starting assumptions or just chose those

1292
00:57:14,579 --> 00:57:16,619
two

1293
00:57:16,619 --> 00:57:19,640
uh you mean the uh pre-quantum

1294
00:57:19,640 --> 00:57:22,260
factorization is on yeah something like

1295
00:57:22,260 --> 00:57:25,319
that um yeah not yet no but it's

1296
00:57:25,319 --> 00:57:28,980
obviously of uh

1297
00:57:28,980 --> 00:57:33,540
um open questions one can maybe achieve

1298
00:57:33,540 --> 00:57:36,780
uh uh much more efficient results with

1299
00:57:36,780 --> 00:57:40,800
uh one thing I have to say that is that

1300
00:57:40,800 --> 00:57:43,800
we constrained ourselves to the standard

1301
00:57:43,800 --> 00:57:45,500
model

1302
00:57:45,500 --> 00:57:51,000
and the constructions of lwe and LPN in

1303
00:57:51,000 --> 00:57:52,680
the standard model are quite inefficient

1304
00:57:52,680 --> 00:57:55,339
so it was quite

1305
00:57:55,339 --> 00:57:58,500
a good gain of efficiency when you're

1306
00:57:58,500 --> 00:58:01,260
able to construct uh based on the LPN

1307
00:58:01,260 --> 00:58:04,020
and lwe maybe it's even more inflation

1308
00:58:04,020 --> 00:58:06,119
with RSA

1309
00:58:06,119 --> 00:58:09,559
let's thank our speaker again

1310
00:58:15,119 --> 00:58:19,140
stump paper 55.

1311
00:58:31,619 --> 00:58:34,500
this paper will be pattern matching in

1312
00:58:34,500 --> 00:58:36,420
encrypted stream

1313
00:58:36,420 --> 00:58:39,000
from inner product encryption our

1314
00:58:39,000 --> 00:58:43,079
speaker will be Olivier Sanders

1315
00:58:43,079 --> 00:58:45,839
okay does it work yes

1316
00:58:45,839 --> 00:58:48,660
okay thank you for the introduction

1317
00:58:48,660 --> 00:58:51,420
so today uh end-to-end encryption has

1318
00:58:51,420 --> 00:58:53,880
become extremely common uh we indeed

1319
00:58:53,880 --> 00:58:55,920
estimate that about 90 percent of

1320
00:58:55,920 --> 00:58:58,380
internet traffic worldwide is encrypted

1321
00:58:58,380 --> 00:59:00,480
which is obviously a good point

1322
00:59:00,480 --> 00:59:02,760
regarding privacy but it also creates

1323
00:59:02,760 --> 00:59:05,520
some security issues because it prevents

1324
00:59:05,520 --> 00:59:07,859
any processing of this encrypted data

1325
00:59:07,859 --> 00:59:10,920
for example if we want to detect malware

1326
00:59:10,920 --> 00:59:13,920
using a tool such as North this is not

1327
00:59:13,920 --> 00:59:16,319
possible to do that directly on the

1328
00:59:16,319 --> 00:59:18,599
encrypted stream so it means that there

1329
00:59:18,599 --> 00:59:20,099
is some kind of competition between

1330
00:59:20,099 --> 00:59:22,079
privacy and functionality so we have to

1331
00:59:22,079 --> 00:59:24,480
choose between them and in practice

1332
00:59:24,480 --> 00:59:27,240
privacy does not win because in most

1333
00:59:27,240 --> 00:59:30,180
situation what we see is a proxy that we

1334
00:59:30,180 --> 00:59:32,220
liked as a man in the middle that will

1335
00:59:32,220 --> 00:59:34,380
decrypt the world stream and then

1336
00:59:34,380 --> 00:59:36,480
perform the processing directly on the

1337
00:59:36,480 --> 00:59:38,040
clear data

1338
00:59:38,040 --> 00:59:40,859
so these questions the very point of

1339
00:59:40,859 --> 00:59:42,839
end-to-end encryption and so the

1340
00:59:42,839 --> 00:59:46,020
question we want to solve is can we do

1341
00:59:46,020 --> 00:59:47,940
better than that and in particular in

1342
00:59:47,940 --> 00:59:49,920
our paper we focus specifically on the

1343
00:59:49,920 --> 00:59:51,780
case on the case of pattern matching

1344
00:59:51,780 --> 00:59:53,280
meaning that we want to search a

1345
00:59:53,280 --> 00:59:55,040
specific pattern within the stream

1346
00:59:55,040 --> 00:59:58,619
because it's a task that is that we find

1347
00:59:58,619 --> 01:00:00,540
in many services such as introduction

1348
01:00:00,540 --> 01:00:03,059
detection system or content filtering

1349
01:00:03,059 --> 01:00:04,980
here I would like to stress that the

1350
01:00:04,980 --> 01:00:07,079
problem on searching a pattern within a

1351
01:00:07,079 --> 01:00:10,200
stream is very different to the one of

1352
01:00:10,200 --> 01:00:12,000
searching a pattern within a database

1353
01:00:12,000 --> 01:00:13,380
because

1354
01:00:13,380 --> 01:00:15,359
um we have to with the stream we have to

1355
01:00:15,359 --> 01:00:18,180
to process the stream on the Fly we do

1356
01:00:18,180 --> 01:00:20,819
we we don't have the time to extract a

1357
01:00:20,819 --> 01:00:22,579
set of keywords that will be Associated

1358
01:00:22,579 --> 01:00:26,220
to the data so as to enable efficient

1359
01:00:26,220 --> 01:00:29,400
search moreover if we look at some

1360
01:00:29,400 --> 01:00:31,740
example for example of pattern that we

1361
01:00:31,740 --> 01:00:35,280
search we can see that they are they are

1362
01:00:35,280 --> 01:00:37,619
not natural keywords or natural patterns

1363
01:00:37,619 --> 01:00:40,020
we might want to search any arbitrary

1364
01:00:40,020 --> 01:00:43,020
patterns

1365
01:00:43,020 --> 01:00:45,960
so at first sight it looks exactly like

1366
01:00:45,960 --> 01:00:47,280
searchable encryption because

1367
01:00:47,280 --> 01:00:49,680
researchable encryption you can issue a

1368
01:00:49,680 --> 01:00:52,200
tractor specific to a pattern and then

1369
01:00:52,200 --> 01:00:55,500
use it to decide is if a site vertex is

1370
01:00:55,500 --> 01:00:58,920
indeed an encryption of this pattern but

1371
01:00:58,920 --> 01:01:01,140
this is not exactly what we want to do

1372
01:01:01,140 --> 01:01:04,380
because what we want to do is to decide

1373
01:01:04,380 --> 01:01:07,319
if the encrypted stream contain a

1374
01:01:07,319 --> 01:01:09,900
specific pattern as a substring so this

1375
01:01:09,900 --> 01:01:12,540
is not exactly the same problem and this

1376
01:01:12,540 --> 01:01:14,640
is why in practice solution based on

1377
01:01:14,640 --> 01:01:16,980
searchable encryption use a technique

1378
01:01:16,980 --> 01:01:19,440
that is called sliding window method

1379
01:01:19,440 --> 01:01:22,500
which consists in setting a window of

1380
01:01:22,500 --> 01:01:25,559
some fixed size and then encrypting the

1381
01:01:25,559 --> 01:01:28,500
streams by Shifting the window character

1382
01:01:28,500 --> 01:01:30,480
per character for example as Illustrated

1383
01:01:30,480 --> 01:01:34,859
on the on the slide so it works

1384
01:01:34,859 --> 01:01:38,220
but only for patterns that have exactly

1385
01:01:38,220 --> 01:01:41,520
the same size as the window typically if

1386
01:01:41,520 --> 01:01:43,200
we look at the last pattern it won't be

1387
01:01:43,200 --> 01:01:46,500
detected this way so we have essentially

1388
01:01:46,500 --> 01:01:49,500
two solution either we repeat the

1389
01:01:49,500 --> 01:01:51,599
process for each possible pattern size

1390
01:01:51,599 --> 01:01:55,980
but it's clearly unpractical or we

1391
01:01:55,980 --> 01:01:58,500
choose to split the patterns into

1392
01:01:58,500 --> 01:02:01,020
smaller ones typically we will choose

1393
01:02:01,020 --> 01:02:03,240
the size of the smallest pattern but

1394
01:02:03,240 --> 01:02:05,579
here we are arming privacy

1395
01:02:05,579 --> 01:02:09,420
so this is not the solution we want if

1396
01:02:09,420 --> 01:02:10,380
we look at a very different

1397
01:02:10,380 --> 01:02:12,660
cryptographic Primitives there is an

1398
01:02:12,660 --> 01:02:14,940
hidden Vector encryption which allows to

1399
01:02:14,940 --> 01:02:17,760
encrypt vectors and also to generate

1400
01:02:17,760 --> 01:02:19,980
secret Keys associated with the vector k

1401
01:02:19,980 --> 01:02:22,980
which can contain characters but also a

1402
01:02:22,980 --> 01:02:24,660
specific character which is called the

1403
01:02:24,660 --> 01:02:26,880
Wild Card which is a character that

1404
01:02:26,880 --> 01:02:30,059
matches every other character and thanks

1405
01:02:30,059 --> 01:02:33,540
to test algorithm we can decide if the

1406
01:02:33,540 --> 01:02:36,599
the vector k associated with a secret

1407
01:02:36,599 --> 01:02:40,500
key matches the encrypted Vector X and

1408
01:02:40,500 --> 01:02:42,780
the security property ensures that

1409
01:02:42,780 --> 01:02:46,020
nothing be Beyond this the output of

1410
01:02:46,020 --> 01:02:48,540
this function will leak so here again it

1411
01:02:48,540 --> 01:02:52,200
seems to be exactly what we want but the

1412
01:02:52,200 --> 01:02:53,700
problem is that

1413
01:02:53,700 --> 01:02:56,339
the pattern can be contained anywhere in

1414
01:02:56,339 --> 01:02:58,140
the Stream so it means that in practice

1415
01:02:58,140 --> 01:03:00,059
if you want to use hidden Vector

1416
01:03:00,059 --> 01:03:02,220
encryption you will have to provide a

1417
01:03:02,220 --> 01:03:05,339
secret key for each possible position so

1418
01:03:05,339 --> 01:03:07,140
for example if you want if you want to

1419
01:03:07,140 --> 01:03:09,119
encrypt end bytes you will have to

1420
01:03:09,119 --> 01:03:12,359
provide n keys for a single pattern

1421
01:03:12,359 --> 01:03:17,160
so this this has led to the design of a

1422
01:03:17,160 --> 01:03:19,319
new primitive which is called searchable

1423
01:03:19,319 --> 01:03:21,119
encryption supporting pattern matching

1424
01:03:21,119 --> 01:03:22,339
scpm

1425
01:03:22,339 --> 01:03:25,319
which can essentially be seen as an

1426
01:03:25,319 --> 01:03:28,200
Indian Vector encryption with key size

1427
01:03:28,200 --> 01:03:31,020
independence of N and there are only

1428
01:03:31,020 --> 01:03:32,819
very few constructions that has been

1429
01:03:32,819 --> 01:03:36,059
proposed and they are rather complex and

1430
01:03:36,059 --> 01:03:38,520
in particular they also do not achieve

1431
01:03:38,520 --> 01:03:40,260
some important security properties such

1432
01:03:40,260 --> 01:03:44,280
as adaptive security so in our paper

1433
01:03:44,280 --> 01:03:46,740
what we want to do is not to propose a

1434
01:03:46,740 --> 01:03:49,920
new construction of scpm rather to move

1435
01:03:49,920 --> 01:03:51,900
on to pre to highlight some relation

1436
01:03:51,900 --> 01:03:54,500
between scpm and more popular

1437
01:03:54,500 --> 01:03:56,780
cryptographic Primitives

1438
01:03:56,780 --> 01:03:59,940
more specifically what we will do in the

1439
01:03:59,940 --> 01:04:02,099
first step is to we will show a generic

1440
01:04:02,099 --> 01:04:04,380
transformation from any hidden Vector

1441
01:04:04,380 --> 01:04:07,980
encryption to a CPM and non-sexual

1442
01:04:07,980 --> 01:04:10,680
relation was known before our work

1443
01:04:10,680 --> 01:04:13,740
but as there are only few uh hidden

1444
01:04:13,740 --> 01:04:16,319
Vector encryption construction we also

1445
01:04:16,319 --> 01:04:19,020
want to relate to create a relation

1446
01:04:19,020 --> 01:04:21,240
between sapm and inner products

1447
01:04:21,240 --> 01:04:22,619
encryption for which the state of the

1448
01:04:22,619 --> 01:04:27,420
earth is is huge and in this case we

1449
01:04:27,420 --> 01:04:30,240
already have something because the cat's

1450
01:04:30,240 --> 01:04:32,180
eye and Waters proposed 10 years ago

1451
01:04:32,180 --> 01:04:34,559
generic transformation from inner

1452
01:04:34,559 --> 01:04:36,180
product encryption to Hidden Vector

1453
01:04:36,180 --> 01:04:37,940
encryption but this transformation

1454
01:04:37,940 --> 01:04:40,799
doubles the ciphert exercise so we want

1455
01:04:40,799 --> 01:04:43,020
to do better than that

1456
01:04:43,020 --> 01:04:45,839
so just another quick Overlook of the

1457
01:04:45,839 --> 01:04:47,339
first contribution I will spend more

1458
01:04:47,339 --> 01:04:48,900
time on the second one

1459
01:04:48,900 --> 01:04:52,200
um so the the idea we use is we notice

1460
01:04:52,200 --> 01:04:55,020
that uh Becca here Italian in a recent

1461
01:04:55,020 --> 01:04:56,940
paper introduced the fragmentation

1462
01:04:56,940 --> 01:05:00,299
approach which consists in splitting uh

1463
01:05:00,299 --> 01:05:03,000
the stream into several overlapping

1464
01:05:03,000 --> 01:05:06,299
fragments as Illustrated on the slide

1465
01:05:06,299 --> 01:05:09,780
and they use this tool for for the for

1466
01:05:09,780 --> 01:05:11,640
the construction but actually what we

1467
01:05:11,640 --> 01:05:13,740
notice is that this fragmentation is

1468
01:05:13,740 --> 01:05:16,400
much more powerful that initially so

1469
01:05:16,400 --> 01:05:20,520
because it guarantees actually that the

1470
01:05:20,520 --> 01:05:22,500
pattern you are going to search is

1471
01:05:22,500 --> 01:05:25,020
entirely contained in a single fragment

1472
01:05:25,020 --> 01:05:27,599
so it means that you can use a needle

1473
01:05:27,599 --> 01:05:29,579
Vector encryption with the same key for

1474
01:05:29,579 --> 01:05:31,680
encrypting each fragment

1475
01:05:31,680 --> 01:05:34,020
and then you only have to provide a set

1476
01:05:34,020 --> 01:05:37,319
of secret keys for a single fragment and

1477
01:05:37,319 --> 01:05:40,859
deal with the the white card to deal

1478
01:05:40,859 --> 01:05:43,559
with the offset within a single fragment

1479
01:05:43,559 --> 01:05:46,260
so concretely what it means is that you

1480
01:05:46,260 --> 01:05:49,079
have a pattern you have a system it's

1481
01:05:49,079 --> 01:05:51,420
not as a kind of hidden Vector

1482
01:05:51,420 --> 01:05:53,700
encryption with key size independent of

1483
01:05:53,700 --> 01:05:56,819
the of the size of the stream so it's

1484
01:05:56,819 --> 01:06:01,380
exactly uh scpm so the the thanks to the

1485
01:06:01,380 --> 01:06:03,420
fragmentation approach we actually have

1486
01:06:03,420 --> 01:06:06,000
a generic transformation from Eden

1487
01:06:06,000 --> 01:06:08,520
Vector encryption to scpm

1488
01:06:08,520 --> 01:06:11,220
now if we look at the transformation

1489
01:06:11,220 --> 01:06:13,859
from inner product encryption to Hidden

1490
01:06:13,859 --> 01:06:16,200
Vector encryption uh cat style Waters

1491
01:06:16,200 --> 01:06:18,180
propose this transformation which

1492
01:06:18,180 --> 01:06:20,280
consists in doubling the size of the

1493
01:06:20,280 --> 01:06:21,839
encrypted vector by adding some

1494
01:06:21,839 --> 01:06:23,400
Randomness r

1495
01:06:23,400 --> 01:06:26,280
and similarly the increase the size of

1496
01:06:26,280 --> 01:06:28,859
the the vector accessory to the secret

1497
01:06:28,859 --> 01:06:32,760
key by adding some one and as you can

1498
01:06:32,760 --> 01:06:36,599
see the scheme is correct because if if

1499
01:06:36,599 --> 01:06:40,500
x equal k then you will have a zero in

1500
01:06:40,500 --> 01:06:42,780
your product I have not described white

1501
01:06:42,780 --> 01:06:44,339
card in this case but the the

1502
01:06:44,339 --> 01:06:46,619
transformation really adapts to the to

1503
01:06:46,619 --> 01:06:50,640
the to White curves and the opposite

1504
01:06:50,640 --> 01:06:53,039
seems to be true if if we have a zero

1505
01:06:53,039 --> 01:06:55,200
node product the vector that should be

1506
01:06:55,200 --> 01:06:58,260
equal but actually this is only true for

1507
01:06:58,260 --> 01:07:00,480
honest key queries

1508
01:07:00,480 --> 01:07:03,780
and unfortunately the the original paper

1509
01:07:03,780 --> 01:07:05,339
does not contain the formal security

1510
01:07:05,339 --> 01:07:07,440
proof of this transformation to be fair

1511
01:07:07,440 --> 01:07:09,480
it was just an application of their work

1512
01:07:09,480 --> 01:07:12,680
it was not their uh that their core

1513
01:07:12,680 --> 01:07:16,079
contribution but the point we have is

1514
01:07:16,079 --> 01:07:18,480
that many shoes queries can create some

1515
01:07:18,480 --> 01:07:20,640
discrepancy between the inner product

1516
01:07:20,640 --> 01:07:23,539
encryption experiment and the hvl1

1517
01:07:23,539 --> 01:07:27,180
because uh that does I could use could

1518
01:07:27,180 --> 01:07:31,020
leverage the randomness added to select

1519
01:07:31,020 --> 01:07:35,640
some secret keys that that don't do not

1520
01:07:35,640 --> 01:07:38,400
match the challenge messages so it's a

1521
01:07:38,400 --> 01:07:41,700
valid query in the SV experiment but

1522
01:07:41,700 --> 01:07:44,700
that yet lead to zero in our products so

1523
01:07:44,700 --> 01:07:46,920
it would be an invariable query for the

1524
01:07:46,920 --> 01:07:48,440
inner product experiment

1525
01:07:48,440 --> 01:07:51,059
fortunately we show in our paper how we

1526
01:07:51,059 --> 01:07:53,520
can deal with this issue by adopting the

1527
01:07:53,520 --> 01:07:55,039
full strategy

1528
01:07:55,039 --> 01:07:57,720
so my point is was not to say that there

1529
01:07:57,720 --> 01:07:59,460
is a problem with this transformation

1530
01:07:59,460 --> 01:08:01,859
but simply through highlight the pro

1531
01:08:01,859 --> 01:08:03,720
this problem that will be much more

1532
01:08:03,720 --> 01:08:05,819
difficult to solve in our in our second

1533
01:08:05,819 --> 01:08:08,420
transformation

1534
01:08:08,460 --> 01:08:10,740
um so our conversion

1535
01:08:10,740 --> 01:08:13,980
um actually moves the randomness added

1536
01:08:13,980 --> 01:08:17,698
by capitals into the secret keys so it

1537
01:08:17,698 --> 01:08:19,859
allows to add only one component to the

1538
01:08:19,859 --> 01:08:23,339
initial Vector so it's it has the size

1539
01:08:23,339 --> 01:08:25,560
of the of the cipher text compared to

1540
01:08:25,560 --> 01:08:28,799
the category transformation and here

1541
01:08:28,799 --> 01:08:31,560
again we can easily check that if the

1542
01:08:31,560 --> 01:08:34,259
vector equals then we will have a zero

1543
01:08:34,259 --> 01:08:36,719
inner product and conversely we have

1544
01:08:36,719 --> 01:08:39,299
exactly the same situation if we the

1545
01:08:39,299 --> 01:08:42,479
inner product is zero we have equality

1546
01:08:42,479 --> 01:08:45,479
of the vectors but only for next creep

1547
01:08:45,479 --> 01:08:48,179
queries key queries so we have to deal

1548
01:08:48,179 --> 01:08:51,479
with malicious so in this case there we

1549
01:08:51,479 --> 01:08:53,160
will consider differently two two

1550
01:08:53,160 --> 01:08:55,738
situations for Selective security it's

1551
01:08:55,738 --> 01:08:58,140
rather easy to manage such kind of

1552
01:08:58,140 --> 01:09:00,779
queries so we can prove selective

1553
01:09:00,779 --> 01:09:04,460
security without any issue

1554
01:09:04,880 --> 01:09:07,560
is actually much more complex as I will

1555
01:09:07,560 --> 01:09:08,520
explain

1556
01:09:08,520 --> 01:09:10,140
because

1557
01:09:10,140 --> 01:09:13,560
if we look at this transformation what

1558
01:09:13,560 --> 01:09:14,939
we have is that at some point the other

1559
01:09:14,939 --> 01:09:17,520
side makes some queries in the hidden

1560
01:09:17,520 --> 01:09:20,160
Vector experiments and these queries are

1561
01:09:20,160 --> 01:09:22,259
transformed by your reduction which adds

1562
01:09:22,259 --> 01:09:23,460
some randomness

1563
01:09:23,460 --> 01:09:26,040
and then the address I received the

1564
01:09:26,040 --> 01:09:28,140
secret piece corresponding to cap Prime

1565
01:09:28,140 --> 01:09:30,359
and the problem is that each of these

1566
01:09:30,359 --> 01:09:32,279
secret key carry information about the

1567
01:09:32,279 --> 01:09:35,819
randomness so theoretically an adversary

1568
01:09:35,819 --> 01:09:38,640
could choose uh the challenge the the

1569
01:09:38,640 --> 01:09:42,319
two challenges in such a way that the

1570
01:09:42,319 --> 01:09:45,960
none of the security match match the

1571
01:09:45,960 --> 01:09:48,439
these challenges so it would be valid

1572
01:09:48,439 --> 01:09:51,479
queries in the hidden Vector experiments

1573
01:09:51,479 --> 01:09:54,900
but this that these challenges would

1574
01:09:54,900 --> 01:09:57,000
yield different in your product which

1575
01:09:57,000 --> 01:09:59,340
will be considered invalid in the inner

1576
01:09:59,340 --> 01:10:01,260
product experiments

1577
01:10:01,260 --> 01:10:05,699
so we have to rule out this situation to

1578
01:10:05,699 --> 01:10:07,140
to prove the security of our

1579
01:10:07,140 --> 01:10:09,900
transformation but just a few remarks

1580
01:10:09,900 --> 01:10:12,540
the first one is that if an adversary

1581
01:10:12,540 --> 01:10:15,900
has the ability to recover the value cat

1582
01:10:15,900 --> 01:10:18,360
Prime associated with the secret key

1583
01:10:18,360 --> 01:10:21,000
then it can trivially break the security

1584
01:10:21,000 --> 01:10:22,980
of our system so it means that the

1585
01:10:22,980 --> 01:10:26,520
secret key must hide the the vectors

1586
01:10:26,520 --> 01:10:28,800
that it is associated with

1587
01:10:28,800 --> 01:10:31,679
so it looks like the notion of of

1588
01:10:31,679 --> 01:10:34,800
function privacy but the problem that

1589
01:10:34,800 --> 01:10:36,840
with function privacy in a public key

1590
01:10:36,840 --> 01:10:39,179
setting is that an adversary can always

1591
01:10:39,179 --> 01:10:42,179
perform some executive Search to recover

1592
01:10:42,179 --> 01:10:45,179
the the value K Prime so it means that

1593
01:10:45,179 --> 01:10:48,060
we cannot at best rely on the mean

1594
01:10:48,060 --> 01:10:50,940
entropy of the pattern set and so this

1595
01:10:50,940 --> 01:10:53,400
means that this property depends on the

1596
01:10:53,400 --> 01:10:54,960
context and this is something we would

1597
01:10:54,960 --> 01:10:58,080
like to avoid moreover also to

1598
01:10:58,080 --> 01:11:00,780
understand you cannot know the value the

1599
01:11:00,780 --> 01:11:03,360
vector Capron it has some control over

1600
01:11:03,360 --> 01:11:06,659
it because it selects the initial Vector

1601
01:11:06,659 --> 01:11:10,380
CHI with which which is uh

1602
01:11:10,380 --> 01:11:12,360
which is defined here

1603
01:11:12,360 --> 01:11:14,040
so

1604
01:11:14,040 --> 01:11:17,699
the this so This conform has been

1605
01:11:17,699 --> 01:11:19,980
modeled by your new property

1606
01:11:19,980 --> 01:11:23,159
so this lead to a new security notion

1607
01:11:23,159 --> 01:11:25,260
for inner product encryption that we

1608
01:11:25,260 --> 01:11:28,140
call Key privacy which is a model as

1609
01:11:28,140 --> 01:11:30,120
follows them so another side we can make

1610
01:11:30,120 --> 01:11:33,060
some key queries as usual and at some

1611
01:11:33,060 --> 01:11:36,060
point it will select a challenge Vector

1612
01:11:36,060 --> 01:11:42,239
Y and receive a secret key uh SK U for a

1613
01:11:42,239 --> 01:11:45,480
vector U which is orthogonal to Y and

1614
01:11:45,480 --> 01:11:47,280
its goal

1615
01:11:47,280 --> 01:11:49,980
um will be to select a new Vector to

1616
01:11:49,980 --> 01:11:52,140
find a new Vector then which is

1617
01:11:52,140 --> 01:11:54,540
orthogonal to you and which is not

1618
01:11:54,540 --> 01:11:57,540
collinear to Y because otherwise it can

1619
01:11:57,540 --> 01:12:00,239
trivial wins so it's very simple

1620
01:12:00,239 --> 01:12:03,179
property which is easy to assess on a

1621
01:12:03,179 --> 01:12:04,920
for linear product encryption schemes

1622
01:12:04,920 --> 01:12:08,219
but it is actually sufficient to prove

1623
01:12:08,219 --> 01:12:10,320
adaptive security or conversion as we

1624
01:12:10,320 --> 01:12:12,659
prove in the in the paper

1625
01:12:12,659 --> 01:12:15,000
so an important property that as you're

1626
01:12:15,000 --> 01:12:17,100
not the reason there is a computational

1627
01:12:17,100 --> 01:12:20,520
goal uh it does not depend on the minion

1628
01:12:20,520 --> 01:12:23,880
for p of the of the pattern set and we

1629
01:12:23,880 --> 01:12:26,219
show in our paper that this property is

1630
01:12:26,219 --> 01:12:29,400
actually uh already achieved by many

1631
01:12:29,400 --> 01:12:31,500
um important construction of inner

1632
01:12:31,500 --> 01:12:33,080
product encryption for example the

1633
01:12:33,080 --> 01:12:35,940
construction Purpose By cation Waters or

1634
01:12:35,940 --> 01:12:37,280
the okay

1635
01:12:37,280 --> 01:12:39,719
which can which achieves this property

1636
01:12:39,719 --> 01:12:41,460
under the descript logarithm assumption

1637
01:12:41,460 --> 01:12:43,560
we also show that some inner product

1638
01:12:43,560 --> 01:12:45,780
encryption construction cannot achieve

1639
01:12:45,780 --> 01:12:49,800
it so for this stream we have to use the

1640
01:12:49,800 --> 01:12:51,600
category water transform Which is less

1641
01:12:51,600 --> 01:12:53,940
efficient so in other words what it

1642
01:12:53,940 --> 01:12:56,219
means is that there are some inner

1643
01:12:56,219 --> 01:12:58,440
products encryption schemes that that

1644
01:12:58,440 --> 01:13:00,659
are better suited to build hidden vector

1645
01:13:00,659 --> 01:13:04,099
encryptions and other ones

1646
01:13:04,560 --> 01:13:08,340
um so to conclude uh what we show in our

1647
01:13:08,340 --> 01:13:10,380
paper is that we first show that we can

1648
01:13:10,380 --> 01:13:13,199
generically build uh scpm construction

1649
01:13:13,199 --> 01:13:16,020
from any Vector hidden Vector encryption

1650
01:13:16,020 --> 01:13:17,580
we have a generic transform the concrete

1651
01:13:17,580 --> 01:13:20,100
transformation from hidden Vector

1652
01:13:20,100 --> 01:13:24,600
encryption to uh scpm

1653
01:13:25,199 --> 01:13:26,880
um we have also Revisited the relation

1654
01:13:26,880 --> 01:13:28,739
between hidden Vector encryption and

1655
01:13:28,739 --> 01:13:31,679
inner product encryption by introducing

1656
01:13:31,679 --> 01:13:33,780
a more efficient conversion than the one

1657
01:13:33,780 --> 01:13:37,080
proposed by cat science Watchers uh so

1658
01:13:37,080 --> 01:13:40,440
it as we explained this in this

1659
01:13:40,440 --> 01:13:43,260
conversion uh achieve always has achieve

1660
01:13:43,260 --> 01:13:45,000
that effective security without any

1661
01:13:45,000 --> 01:13:48,540
additional condition but require some

1662
01:13:48,540 --> 01:13:51,480
night conviction which we call a p

1663
01:13:51,480 --> 01:13:54,780
privacy to prove adaptive security

1664
01:13:54,780 --> 01:13:58,500
so it means that we can use actually any

1665
01:13:58,500 --> 01:14:01,560
inner product encryption uh with

1666
01:14:01,560 --> 01:14:04,260
satisfying this property to build a new

1667
01:14:04,260 --> 01:14:06,420
scpm construction so typically we will

1668
01:14:06,420 --> 01:14:08,219
thanks to that we will be able to have

1669
01:14:08,219 --> 01:14:11,340
adaptive adaptive list secure or scpm

1670
01:14:11,340 --> 01:14:13,380
scpm proven under standard assumption

1671
01:14:13,380 --> 01:14:15,179
and so on because the state of the art

1672
01:14:15,179 --> 01:14:19,199
of inner product encryption is a huge

1673
01:14:19,199 --> 01:14:22,339
okay thank you

1674
01:14:27,900 --> 01:14:31,159
we have time for questions

1675
01:14:31,560 --> 01:14:34,620
maybe I'll start us off on the editor

1676
01:14:34,620 --> 01:14:37,380
just the previous slide you mentioned

1677
01:14:37,380 --> 01:14:40,500
that uh you provide examples of schemes

1678
01:14:40,500 --> 01:14:42,060
that do not achieve it well these

1679
01:14:42,060 --> 01:14:44,520
examples kind of contrived examples just

1680
01:14:44,520 --> 01:14:48,380
so there's not required over these

1681
01:14:50,000 --> 01:14:51,960
construction that has already been

1682
01:14:51,960 --> 01:14:54,300
published actually is there construction

1683
01:14:54,300 --> 01:14:57,960
whereas the knowledge of the vectors

1684
01:14:57,960 --> 01:15:00,060
Associated to a secret key is necessary

1685
01:15:00,060 --> 01:15:02,340
to to perform the test operation before

1686
01:15:02,340 --> 01:15:05,280
is because in some situation

1687
01:15:05,280 --> 01:15:05,820
um

1688
01:15:05,820 --> 01:15:08,219
if I can say in some constrictions the

1689
01:15:08,219 --> 01:15:11,699
secret Keys uh uh consist of for example

1690
01:15:11,699 --> 01:15:15,120
elements of the group G2 in a pairing

1691
01:15:15,120 --> 01:15:18,960
setting and so they can they implicitly

1692
01:15:18,960 --> 01:15:20,520
hide the vector but in some other

1693
01:15:20,520 --> 01:15:23,280
situation for example constructions that

1694
01:15:23,280 --> 01:15:25,860
are that are not based on pairings and

1695
01:15:25,860 --> 01:15:28,920
the to perform the test operation you

1696
01:15:28,920 --> 01:15:32,280
need to know the the vectors because

1697
01:15:32,280 --> 01:15:34,500
there will be the components of this

1698
01:15:34,500 --> 01:15:37,199
Vector will be involved as exponent as

1699
01:15:37,199 --> 01:15:40,380
exponents in the computation so there is

1700
01:15:40,380 --> 01:15:43,199
such construction inherently rely on the

1701
01:15:43,199 --> 01:15:45,179
knowledge of the of the vector

1702
01:15:45,179 --> 01:15:47,580
Associated to the secret tree and as I

1703
01:15:47,580 --> 01:15:49,500
explained if you know this Vector you

1704
01:15:49,500 --> 01:15:51,420
can trivially break a key privacy

1705
01:15:51,420 --> 01:15:53,520
because you just have to choose the

1706
01:15:53,520 --> 01:15:58,219
vector orthogonal to public vectors

1707
01:15:58,280 --> 01:16:01,080
let's thank our speaker and all of the

1708
01:16:01,080 --> 01:16:03,920
speakers in this session

1709
01:16:06,300 --> 01:16:08,880
I believe we're on to our next break

1710
01:16:08,880 --> 01:16:11,840
enjoy a snack

