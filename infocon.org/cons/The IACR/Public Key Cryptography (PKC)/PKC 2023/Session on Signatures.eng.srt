1
00:00:01,140 --> 00:00:04,560
I guess the dessert is too nice

2
00:00:04,560 --> 00:00:07,919
all right let's get started uh

3
00:00:07,919 --> 00:00:10,679
we have pretty full schedule five talks

4
00:00:10,679 --> 00:00:11,700
in

5
00:00:11,700 --> 00:00:14,040
a little bit of an hour so 20 minutes

6
00:00:14,040 --> 00:00:17,400
each okay so my name is Dr unanzing I'm

7
00:00:17,400 --> 00:00:19,260
the assistant chair

8
00:00:19,260 --> 00:00:21,119
I'm from UAB

9
00:00:21,119 --> 00:00:23,939
the first talk about a hardening

10
00:00:23,939 --> 00:00:26,160
signature skin via drive and a deer

11
00:00:26,160 --> 00:00:29,760
randomize stronger security proof for

12
00:00:29,760 --> 00:00:35,600
uh Ed DSA by Michi Beller Hannah Davis

13
00:00:35,600 --> 00:00:39,920
and I guess speaker will be Hannah

14
00:00:44,660 --> 00:00:49,640
Davis I'm from UC San Diego

15
00:01:12,180 --> 00:01:15,240
yep okay

16
00:01:15,240 --> 00:01:17,100
well

17
00:01:17,100 --> 00:01:20,280
uh so I guess I'll start back with a

18
00:01:20,280 --> 00:01:23,040
digital signature has three algorithms

19
00:01:23,040 --> 00:01:25,560
and I have just messed this up more so I

20
00:01:25,560 --> 00:01:28,799
guess I'm gonna put that uh digital

21
00:01:28,799 --> 00:01:30,600
signature has three algorithms one two

22
00:01:30,600 --> 00:01:33,540
generate a public private key pair uh

23
00:01:33,540 --> 00:01:35,939
one to take a secret key and a message

24
00:01:35,939 --> 00:01:37,979
and generate a signature and one that

25
00:01:37,979 --> 00:01:39,659
takes that signature and a public key

26
00:01:39,659 --> 00:01:41,280
and verifies whether or not the

27
00:01:41,280 --> 00:01:44,520
signature is valid our security goal for

28
00:01:44,520 --> 00:01:46,020
a digital signature is going to be

29
00:01:46,020 --> 00:01:48,600
existential unforgeability which means

30
00:01:48,600 --> 00:01:51,540
essentially that an adversary given

31
00:01:51,540 --> 00:01:53,759
access to a signing Oracle should not be

32
00:01:53,759 --> 00:01:56,159
able to produce a valid signature on a

33
00:01:56,159 --> 00:01:58,740
message that it hasn't already gotten a

34
00:01:58,740 --> 00:02:02,280
signature on from that signing Oracle

35
00:02:02,280 --> 00:02:04,320
so the eventual goal of this talk is

36
00:02:04,320 --> 00:02:06,479
going to be to given security analysis

37
00:02:06,479 --> 00:02:08,940
of the eddsa signature scheme but first

38
00:02:08,940 --> 00:02:10,919
I want to talk about Schnur signatures

39
00:02:10,919 --> 00:02:15,060
which are built from a prime Order Group

40
00:02:15,060 --> 00:02:16,920
in which the discrete log problem

41
00:02:16,920 --> 00:02:20,040
problem is assumed to be hard and a hash

42
00:02:20,040 --> 00:02:23,780
function which we'll call H

43
00:02:24,500 --> 00:02:29,879
is essentially just a random element of

44
00:02:29,879 --> 00:02:31,739
um the integers modulo of the group

45
00:02:31,739 --> 00:02:34,620
order and its public key is the group

46
00:02:34,620 --> 00:02:36,720
element whose discrete log is the secret

47
00:02:36,720 --> 00:02:40,200
key to sign a message we pick a random

48
00:02:40,200 --> 00:02:42,840
group element hash it together with the

49
00:02:42,840 --> 00:02:44,580
public key and the message

50
00:02:44,580 --> 00:02:46,680
and then we use that

51
00:02:46,680 --> 00:02:48,480
um the discrete log of our random

52
00:02:48,480 --> 00:02:50,640
element to mask the product of the

53
00:02:50,640 --> 00:02:52,860
secret key in the hash to verify the

54
00:02:52,860 --> 00:02:56,040
scheme we then multiply the hash by the

55
00:02:56,040 --> 00:02:59,040
secret key and mask it with the random

56
00:02:59,040 --> 00:03:00,660
group element we compute that value two

57
00:03:00,660 --> 00:03:02,519
different ways from the signature and

58
00:03:02,519 --> 00:03:05,480
check that they both match

59
00:03:06,379 --> 00:03:08,580
signatures are have been pretty

60
00:03:08,580 --> 00:03:10,080
prominent in the literature because

61
00:03:10,080 --> 00:03:12,300
they're simple they're efficient

62
00:03:12,300 --> 00:03:15,360
um they're relatively straightforward

63
00:03:15,360 --> 00:03:18,780
for a discrete log based scheme

64
00:03:18,780 --> 00:03:21,599
um and they're reducible to the discrete

65
00:03:21,599 --> 00:03:23,879
logarithm problem as long as you're

66
00:03:23,879 --> 00:03:25,800
willing to assume that the hash function

67
00:03:25,800 --> 00:03:27,780
H can be modeled as a random Oracle

68
00:03:27,780 --> 00:03:31,340
basically a public random function

69
00:03:31,620 --> 00:03:34,500
in addition to the initial security

70
00:03:34,500 --> 00:03:37,879
proof there have been a number of

71
00:03:37,879 --> 00:03:42,000
more recent results that have improved

72
00:03:42,000 --> 00:03:44,220
to the bounds and basically validated

73
00:03:44,220 --> 00:03:47,340
Shannara for for shorter and shorter

74
00:03:47,340 --> 00:03:51,000
parameters uh

75
00:03:56,159 --> 00:03:59,159
yep uh the downside of Schnur is that

76
00:03:59,159 --> 00:04:01,080
it's susceptible to Randomness reuse

77
00:04:01,080 --> 00:04:03,000
attack so if you sign two different

78
00:04:03,000 --> 00:04:05,159
messages using the same random group

79
00:04:05,159 --> 00:04:08,099
element any attacker who gets a hold of

80
00:04:08,099 --> 00:04:09,480
those two signatures will be able to

81
00:04:09,480 --> 00:04:11,280
extract the secret key

82
00:04:11,280 --> 00:04:13,920
and that's where eddsa comes in

83
00:04:13,920 --> 00:04:17,220
EDSA was developed in 2015 essentially

84
00:04:17,220 --> 00:04:19,260
as a set of tweaks to the schnart

85
00:04:19,260 --> 00:04:21,238
signature scheme that make it more

86
00:04:21,238 --> 00:04:23,220
secure and more efficient at the same

87
00:04:23,220 --> 00:04:25,080
time and we're going to address these

88
00:04:25,080 --> 00:04:26,880
tweaks one by one

89
00:04:26,880 --> 00:04:31,199
so the first tweak is changing the group

90
00:04:31,199 --> 00:04:33,060
basically to one with a faster

91
00:04:33,060 --> 00:04:35,220
implementation called a twisted Edwards

92
00:04:35,220 --> 00:04:37,080
curve and the main change we need to

93
00:04:37,080 --> 00:04:39,840
worry about is that a twisted Edwards

94
00:04:39,840 --> 00:04:42,180
curve is not a prime Order Group instead

95
00:04:42,180 --> 00:04:44,880
its order is a prime multiplied by a

96
00:04:44,880 --> 00:04:48,120
small power of two called the cofactor

97
00:04:48,120 --> 00:04:50,400
and this changes our verification

98
00:04:50,400 --> 00:04:52,380
algorithm just a little bit because

99
00:04:52,380 --> 00:04:55,020
verification might now receive a

100
00:04:55,020 --> 00:04:58,080
signature where the group element isn't

101
00:04:58,080 --> 00:05:00,900
in the prime order subgroup it's in the

102
00:05:00,900 --> 00:05:02,699
group as a whole so this gives us two

103
00:05:02,699 --> 00:05:04,500
different variants of verification

104
00:05:04,500 --> 00:05:06,360
depending on how we want to handle that

105
00:05:06,360 --> 00:05:10,680
we can either check equality based only

106
00:05:10,680 --> 00:05:12,960
on the part of the group element in the

107
00:05:12,960 --> 00:05:14,940
prime order subgroup or we can check

108
00:05:14,940 --> 00:05:16,620
equality as the whole and we call these

109
00:05:16,620 --> 00:05:18,540
two variants permissive verification and

110
00:05:18,540 --> 00:05:21,300
strict verification our analysis works

111
00:05:21,300 --> 00:05:23,280
on both of them but we have to pick one

112
00:05:23,280 --> 00:05:24,840
so for the rest of this talk I'll be

113
00:05:24,840 --> 00:05:28,219
working with permissive verification

114
00:05:28,919 --> 00:05:33,360
the second tweak that Esa does is it it

115
00:05:33,360 --> 00:05:36,419
handles the possibility that the secret

116
00:05:36,419 --> 00:05:38,820
key is generated by a biased random

117
00:05:38,820 --> 00:05:42,060
number generator by expanding the secret

118
00:05:42,060 --> 00:05:45,240
key using the same hash function used in

119
00:05:45,240 --> 00:05:46,620
snore

120
00:05:46,620 --> 00:05:47,400
um

121
00:05:47,400 --> 00:05:50,400
and we also perform a little bit of

122
00:05:50,400 --> 00:05:52,020
formatting on that secret key called

123
00:05:52,020 --> 00:05:54,180
clamping in this case what we're doing

124
00:05:54,180 --> 00:05:55,919
is we're setting the high order bit of

125
00:05:55,919 --> 00:05:58,080
the secret key to one and the three low

126
00:05:58,080 --> 00:06:00,000
order bits to zero

127
00:06:00,000 --> 00:06:02,039
uh

128
00:06:02,039 --> 00:06:03,840
and the final thing the thing that

129
00:06:03,840 --> 00:06:06,419
actually fixes the randomness reuse

130
00:06:06,419 --> 00:06:08,940
attack is we de-randomize the signing

131
00:06:08,940 --> 00:06:11,160
algorithm and make a deterministic this

132
00:06:11,160 --> 00:06:13,440
is a standard technique effectively

133
00:06:13,440 --> 00:06:16,560
using a prf to derive pseudo-random

134
00:06:16,560 --> 00:06:19,919
coins from the message and an extra part

135
00:06:19,919 --> 00:06:23,419
of this expanded secret key

136
00:06:24,660 --> 00:06:26,280
since we're using the hash function

137
00:06:26,280 --> 00:06:29,039
everywhere I should mention that

138
00:06:29,039 --> 00:06:32,699
ah this hash function is given two

139
00:06:32,699 --> 00:06:34,020
specific options in different

140
00:06:34,020 --> 00:06:36,240
instantiations of the dvsa for the lower

141
00:06:36,240 --> 00:06:37,160
security

142
00:06:37,160 --> 00:06:39,840
ed19 the hash function we're looking at

143
00:06:39,840 --> 00:06:41,880
is shot 512 and for the higher security

144
00:06:41,880 --> 00:06:44,520
the hash function is shake and I've

145
00:06:44,520 --> 00:06:46,800
mentioned in all of the Schnur analyzes

146
00:06:46,800 --> 00:06:48,720
we assume that this hash function is a

147
00:06:48,720 --> 00:06:51,419
random Oracle and in the one proof of

148
00:06:51,419 --> 00:06:53,460
security for eddsa which we'll get to

149
00:06:53,460 --> 00:06:55,500
shortly uh

150
00:06:55,500 --> 00:06:58,139
this is also this assumption is the same

151
00:06:58,139 --> 00:06:59,940
it's assumed to be a random article so

152
00:06:59,940 --> 00:07:01,500
we want to make sure that that's a

153
00:07:01,500 --> 00:07:04,500
reasonable assumption to be using here

154
00:07:04,500 --> 00:07:06,360
so let's look a little bit more closely

155
00:07:06,360 --> 00:07:09,300
at shop 512 and Shake they're both built

156
00:07:09,300 --> 00:07:12,600
by iterating a smaller primitive

157
00:07:12,600 --> 00:07:14,460
um for Shopify 12 it's compression

158
00:07:14,460 --> 00:07:17,120
function for shake it's a permutation

159
00:07:17,120 --> 00:07:20,220
and obviously they don't look random

160
00:07:20,220 --> 00:07:22,080
they're fixed known functions we can

161
00:07:22,080 --> 00:07:24,539
compute their values they're not random

162
00:07:24,539 --> 00:07:26,460
in order to model them as a random

163
00:07:26,460 --> 00:07:29,099
Oracle what we want is we want for them

164
00:07:29,099 --> 00:07:31,500
to look like a random Oracle when their

165
00:07:31,500 --> 00:07:34,440
ideal Primitives are assumed when their

166
00:07:34,440 --> 00:07:36,240
underlying Primitives are assumed to be

167
00:07:36,240 --> 00:07:40,039
ideal or assumed to be random themselves

168
00:07:41,400 --> 00:07:43,620
uh

169
00:07:43,620 --> 00:07:45,539
and what this will give us is it will

170
00:07:45,539 --> 00:07:47,639
help us ensure that the structure of

171
00:07:47,639 --> 00:07:50,460
shop 512 this iterative structure isn't

172
00:07:50,460 --> 00:07:52,740
going to become a problem when we plug

173
00:07:52,740 --> 00:07:54,419
it into something that's assuming it's a

174
00:07:54,419 --> 00:07:55,979
random Oracle

175
00:07:55,979 --> 00:07:58,860
so we can evaluate the structure in the

176
00:07:58,860 --> 00:08:00,539
indifferentiability framework which was

177
00:08:00,539 --> 00:08:02,940
first designed for checking whether hash

178
00:08:02,940 --> 00:08:05,340
functions can be safely modeled as

179
00:08:05,340 --> 00:08:08,119
random oracles

180
00:08:08,580 --> 00:08:10,319
there are existing results for both of

181
00:08:10,319 --> 00:08:11,520
these functions and what they say

182
00:08:11,520 --> 00:08:13,560
essentially is Shake can be safely

183
00:08:13,560 --> 00:08:15,840
modeled as a random Oracle but shot 512

184
00:08:15,840 --> 00:08:17,940
can't and that's because of the length

185
00:08:17,940 --> 00:08:19,500
expansion attack which is pretty well

186
00:08:19,500 --> 00:08:21,840
known and applies to all Merkel

187
00:08:21,840 --> 00:08:25,020
Dawnguard hashes which Shopify 12 is one

188
00:08:25,020 --> 00:08:27,180
effectively weather length extension

189
00:08:27,180 --> 00:08:29,460
attack is is an attacker who has access

190
00:08:29,460 --> 00:08:31,919
to the compression function can predict

191
00:08:31,919 --> 00:08:34,080
certain outputs of sha-512 without

192
00:08:34,080 --> 00:08:35,820
having to compute the entire

193
00:08:35,820 --> 00:08:37,200
Construction

194
00:08:37,200 --> 00:08:41,219
ah this doesn't make eddsa insecure the

195
00:08:41,219 --> 00:08:43,200
designers of eddas I knew about the

196
00:08:43,200 --> 00:08:44,700
length extension attack they took it

197
00:08:44,700 --> 00:08:47,160
into account but it doesn't show up in

198
00:08:47,160 --> 00:08:49,500
any of the formal analysis and it does

199
00:08:49,500 --> 00:08:51,899
mean that we can't actually assume that

200
00:08:51,899 --> 00:08:54,480
shot 512 can be modeled as a random

201
00:08:54,480 --> 00:08:56,959
Oracle

202
00:08:58,200 --> 00:09:01,560
so coming back to eddsa there's one

203
00:09:01,560 --> 00:09:04,260
security proof for Esa by brendel at all

204
00:09:04,260 --> 00:09:06,120
ah

205
00:09:06,120 --> 00:09:08,519
and the security proof essentially

206
00:09:08,519 --> 00:09:11,160
models the original snar proofs where it

207
00:09:11,160 --> 00:09:13,920
breaks down the Fiat shimir structure of

208
00:09:13,920 --> 00:09:17,880
the Schnur signature scheme uh

209
00:09:17,880 --> 00:09:20,519
and like those original proofs it's not

210
00:09:20,519 --> 00:09:23,640
quite tight it has a quadratic loss that

211
00:09:23,640 --> 00:09:27,920
comes from the original of working love

212
00:09:29,040 --> 00:09:30,899
and it also is making the same

213
00:09:30,899 --> 00:09:33,240
assumption that the hash function

214
00:09:33,240 --> 00:09:35,580
whether it's shop 512 or Shake is going

215
00:09:35,580 --> 00:09:37,500
to be a random article

216
00:09:37,500 --> 00:09:40,500
so what we did what are

217
00:09:40,500 --> 00:09:42,360
um what our goal was was to give a new

218
00:09:42,360 --> 00:09:44,760
security proof of eddsa that doesn't go

219
00:09:44,760 --> 00:09:46,560
all the way back to the discrete law

220
00:09:46,560 --> 00:09:49,560
problem it just reduces directly to the

221
00:09:49,560 --> 00:09:51,240
security of the schnar signature scheme

222
00:09:51,240 --> 00:09:54,360
and what that gives us is we don't have

223
00:09:54,360 --> 00:09:56,760
it's first of all much a much simpler

224
00:09:56,760 --> 00:09:59,040
proof and second of all it means that we

225
00:09:59,040 --> 00:10:01,320
can rely on all these more recent proofs

226
00:10:01,320 --> 00:10:03,120
for Schnur that have tighter bounds that

227
00:10:03,120 --> 00:10:05,399
validate shorter parameters and we can

228
00:10:05,399 --> 00:10:07,200
just plug those into

229
00:10:07,200 --> 00:10:09,779
our approach in a modular way

230
00:10:09,779 --> 00:10:11,220
the other

231
00:10:11,220 --> 00:10:12,180
um

232
00:10:12,180 --> 00:10:14,640
so I will quickly point out it's an

233
00:10:14,640 --> 00:10:16,740
example what this gives us for concrete

234
00:10:16,740 --> 00:10:19,380
bounds if we have a sample attacker with

235
00:10:19,380 --> 00:10:21,779
a 2 to the 70 runtime bound and 260

236
00:10:21,779 --> 00:10:23,160
query bound

237
00:10:23,160 --> 00:10:24,360
then

238
00:10:24,360 --> 00:10:25,339
against

239
00:10:25,339 --> 00:10:29,220
ed25519 we can save 10 bits or so just

240
00:10:29,220 --> 00:10:32,580
by using tighter bounds for schnor and

241
00:10:32,580 --> 00:10:34,080
if we're willing to change assumptions

242
00:10:34,080 --> 00:10:35,899
like some of the much more recent

243
00:10:35,899 --> 00:10:38,519
analyzes of schnardo then we can save up

244
00:10:38,519 --> 00:10:41,339
to 100 bits of security so we're able to

245
00:10:41,339 --> 00:10:43,860
validate much much larger parameters and

246
00:10:43,860 --> 00:10:46,140
get much better guarantees for this uh

247
00:10:46,140 --> 00:10:47,880
for the parameters that are actually

248
00:10:47,880 --> 00:10:50,279
used in practice

249
00:10:50,279 --> 00:10:52,200
the other thing that a proof does is

250
00:10:52,200 --> 00:10:55,260
instead of assuming that shot 512 is a

251
00:10:55,260 --> 00:10:56,880
random Oracle we assume that it's

252
00:10:56,880 --> 00:10:59,100
compression function is a random Oracle

253
00:10:59,100 --> 00:11:00,839
which means that we can explicitly take

254
00:11:00,839 --> 00:11:02,279
into account things like length

255
00:11:02,279 --> 00:11:04,019
extension attacks we can explicitly

256
00:11:04,019 --> 00:11:07,980
validate that choice of hash function

257
00:11:07,980 --> 00:11:11,279
and we aren't making this we aren't we

258
00:11:11,279 --> 00:11:14,120
don't have this problem

259
00:11:16,320 --> 00:11:18,360
and in addition while we were doing this

260
00:11:18,360 --> 00:11:21,060
proof we also came up with some handy

261
00:11:21,060 --> 00:11:23,399
intermediate results that we think have

262
00:11:23,399 --> 00:11:25,500
a little bit of independent interest the

263
00:11:25,500 --> 00:11:27,360
first is derived Fender randomize which

264
00:11:27,360 --> 00:11:29,700
is a generic signature scheme that

265
00:11:29,700 --> 00:11:32,220
captures these tweaks that edds say is

266
00:11:32,220 --> 00:11:34,440
making the show to Schnur and makes them

267
00:11:34,440 --> 00:11:36,600
generic so that they can be applied to

268
00:11:36,600 --> 00:11:40,620
any scheme as a d randomization strategy

269
00:11:40,620 --> 00:11:42,240
um and the nice thing is that our

270
00:11:42,240 --> 00:11:43,860
validation of the derived and the

271
00:11:43,860 --> 00:11:46,019
randomized transform happens in the

272
00:11:46,019 --> 00:11:48,000
standard model so we don't need to make

273
00:11:48,000 --> 00:11:50,760
any random Oracle assumptions at all

274
00:11:50,760 --> 00:11:52,680
there and we can work in any model

275
00:11:52,680 --> 00:11:55,260
generically

276
00:11:55,260 --> 00:11:58,260
the second contribution we have here is

277
00:11:58,260 --> 00:12:02,640
a closer analysis of a class of md-based

278
00:12:02,640 --> 00:12:05,040
hash functions

279
00:12:05,040 --> 00:12:08,519
um that both captures the way that eddsa

280
00:12:08,519 --> 00:12:12,240
uses 512 and validates it but also

281
00:12:12,240 --> 00:12:15,540
improves on prior results for uh

282
00:12:15,540 --> 00:12:17,459
existing hash functions like chop MD

283
00:12:17,459 --> 00:12:20,700
which is used to build shot 384 and

284
00:12:20,700 --> 00:12:24,320
might be useful in other schemes as well

285
00:12:26,279 --> 00:12:28,440
so this is our transform derive then D

286
00:12:28,440 --> 00:12:30,300
randomized and what it does is it takes

287
00:12:30,300 --> 00:12:33,240
in a randomized digital signature scheme

288
00:12:33,240 --> 00:12:36,839
a prf a prg and a clamping function and

289
00:12:36,839 --> 00:12:38,880
it builds a deterministic signature

290
00:12:38,880 --> 00:12:41,300
scheme

291
00:12:43,079 --> 00:12:45,240
and one thing uh

292
00:12:45,240 --> 00:12:47,220
and I won't go into details on the

293
00:12:47,220 --> 00:12:48,779
construction but essentially it's doing

294
00:12:48,779 --> 00:12:51,060
the same thing that EDD essay does it's

295
00:12:51,060 --> 00:12:53,100
expanding the secret key it's clamping

296
00:12:53,100 --> 00:12:55,920
it's de-randomizing the only thing that

297
00:12:55,920 --> 00:12:57,480
it doesn't do is change the underlying

298
00:12:57,480 --> 00:12:59,660
group

299
00:12:59,820 --> 00:13:02,279
one interesting thing about the DTD

300
00:13:02,279 --> 00:13:04,260
transform is that first of all the

301
00:13:04,260 --> 00:13:06,360
reduction is completely tight we're only

302
00:13:06,360 --> 00:13:09,300
losing a constant Factor based on how

303
00:13:09,300 --> 00:13:11,040
much of the secret key we lose during

304
00:13:11,040 --> 00:13:13,260
the clamping process

305
00:13:13,260 --> 00:13:15,360
and the other interesting thing is we're

306
00:13:15,360 --> 00:13:17,519
not assuming Independence for any of the

307
00:13:17,519 --> 00:13:20,040
components so we do allow the digital

308
00:13:20,040 --> 00:13:22,800
signature scheme and the prf and the prg

309
00:13:22,800 --> 00:13:24,899
all to depend on the same underlying

310
00:13:24,899 --> 00:13:27,420
components which is important in for

311
00:13:27,420 --> 00:13:29,519
example eddsa when we're building them

312
00:13:29,519 --> 00:13:32,220
all from shop 512 and its underlying

313
00:13:32,220 --> 00:13:33,839
compression function which would be our

314
00:13:33,839 --> 00:13:36,620
random Oracle here

315
00:13:37,500 --> 00:13:40,139
so I'll move through this pretty quickly

316
00:13:40,139 --> 00:13:42,660
for time's sake but our trans are proof

317
00:13:42,660 --> 00:13:44,579
for the derived then do randomized

318
00:13:44,579 --> 00:13:47,820
transform is fairly straightforward we

319
00:13:47,820 --> 00:13:49,620
reverse the transform step by step

320
00:13:49,620 --> 00:13:52,019
relying on

321
00:13:52,019 --> 00:13:55,800
um first are prf or prg property to undo

322
00:13:55,800 --> 00:13:59,160
the key expansion then our peer then our

323
00:13:59,160 --> 00:14:00,600
prf property to undo the

324
00:14:00,600 --> 00:14:03,180
de-randomization and finally we stopped

325
00:14:03,180 --> 00:14:06,959
clamping and just lose a factor based on

326
00:14:06,959 --> 00:14:09,300
the probability that a random key will

327
00:14:09,300 --> 00:14:12,380
be clamped in the first place

328
00:14:14,339 --> 00:14:16,260
so the last thing I want to talk about

329
00:14:16,260 --> 00:14:18,899
is that in order to use this generic

330
00:14:18,899 --> 00:14:20,760
derive then dear randomized transform on

331
00:14:20,760 --> 00:14:22,920
EDSA we need to make the appropriate

332
00:14:22,920 --> 00:14:25,260
choices for each of the components so

333
00:14:25,260 --> 00:14:27,480
our digital signature scheme is going to

334
00:14:27,480 --> 00:14:29,700
be schnor our clamping function is this

335
00:14:29,700 --> 00:14:31,320
function I discussed before where we set

336
00:14:31,320 --> 00:14:33,240
the higher order bit and wipe the lower

337
00:14:33,240 --> 00:14:34,800
bits

338
00:14:34,800 --> 00:14:37,500
but our remaining components are a

339
00:14:37,500 --> 00:14:38,760
little bit more complicated because

340
00:14:38,760 --> 00:14:41,519
they're all based on a single hash

341
00:14:41,519 --> 00:14:43,800
function or random Oracle

342
00:14:43,800 --> 00:14:46,680
depending which model you're in so we

343
00:14:46,680 --> 00:14:48,240
have a pseudorandom function a

344
00:14:48,240 --> 00:14:50,459
pseudorandom generator and a random

345
00:14:50,459 --> 00:14:51,959
Oracle and we want to make sure that we

346
00:14:51,959 --> 00:14:54,660
can get all of these things even if our

347
00:14:54,660 --> 00:14:57,180
hash is an empty hash and has that

348
00:14:57,180 --> 00:14:59,279
underlying structure provided we can

349
00:14:59,279 --> 00:15:01,980
assume the compression function is ideal

350
00:15:01,980 --> 00:15:04,860
for the pseudorandom function this is

351
00:15:04,860 --> 00:15:06,959
pretty straightforward because eddsa is

352
00:15:06,959 --> 00:15:09,060
using the AMAC construction which has

353
00:15:09,060 --> 00:15:11,160
already been proved secure with an MD

354
00:15:11,160 --> 00:15:12,540
hash

355
00:15:12,540 --> 00:15:15,060
for the pseudonym generator we show this

356
00:15:15,060 --> 00:15:17,000
directly but it's pretty trivial because

357
00:15:17,000 --> 00:15:19,560
the generator is just calling the

358
00:15:19,560 --> 00:15:21,660
underlying compression function exactly

359
00:15:21,660 --> 00:15:24,839
once and returning its output directly

360
00:15:24,839 --> 00:15:27,839
the interesting point is showing that

361
00:15:27,839 --> 00:15:30,420
our hash function behaves as a random

362
00:15:30,420 --> 00:15:32,519
Oracle when we reduce its output modulo

363
00:15:32,519 --> 00:15:33,720
p

364
00:15:33,720 --> 00:15:35,579
and we proved this directly in the

365
00:15:35,579 --> 00:15:37,800
indifferentiability framework so very

366
00:15:37,800 --> 00:15:39,360
little time but if you're familiar with

367
00:15:39,360 --> 00:15:40,920
indifferentiability

368
00:15:40,920 --> 00:15:43,740
the way uh what we have is we have an

369
00:15:43,740 --> 00:15:46,620
idea a real world where there's our

370
00:15:46,620 --> 00:15:48,420
construction so in this case C would be

371
00:15:48,420 --> 00:15:51,720
shot 512 and our compression function

372
00:15:51,720 --> 00:15:53,699
um which is idealized as a random Oracle

373
00:15:53,699 --> 00:15:55,620
and in the ideal world we want to keep

374
00:15:55,620 --> 00:15:57,240
the same interface but we want to

375
00:15:57,240 --> 00:15:59,579
replace the hash function with a random

376
00:15:59,579 --> 00:16:01,620
Oracle and we need something to replace

377
00:16:01,620 --> 00:16:03,660
the compression function on the right

378
00:16:03,660 --> 00:16:07,399
and that's going to be a simulator

379
00:16:08,279 --> 00:16:11,040
so the simulator

380
00:16:11,040 --> 00:16:12,360
uh

381
00:16:12,360 --> 00:16:17,820
that we use takes uh I'm going to skip

382
00:16:17,820 --> 00:16:19,620
through this but basically say we're not

383
00:16:19,620 --> 00:16:22,500
just proving in differentiability for

384
00:16:22,500 --> 00:16:23,820
uh

385
00:16:23,820 --> 00:16:26,399
Merkel bomgaard reduced modulo Prime and

386
00:16:26,399 --> 00:16:29,220
we're also not just doing it for

387
00:16:29,220 --> 00:16:31,860
Merkel Dawnguard reduce modulo Prime and

388
00:16:31,860 --> 00:16:33,540
the chop MD construction which

389
00:16:33,540 --> 00:16:35,639
effectively reduces by a power of two

390
00:16:35,639 --> 00:16:39,180
we're doing it for any transform that

391
00:16:39,180 --> 00:16:41,639
truncates the um

392
00:16:41,639 --> 00:16:44,160
that truncates the output of a Merkel

393
00:16:44,160 --> 00:16:46,380
domguard hash in a way that can be

394
00:16:46,380 --> 00:16:48,720
sampled in reverse

395
00:16:48,720 --> 00:16:52,639
and the details on that are in the paper

396
00:16:52,740 --> 00:16:55,440
okay and with my last couple minutes I'm

397
00:16:55,440 --> 00:16:57,779
just going to say we think that our our

398
00:16:57,779 --> 00:16:59,880
proof has a little bit of independent

399
00:16:59,880 --> 00:17:01,259
interest because while we were looking

400
00:17:01,259 --> 00:17:04,079
at the chop MD proof we found a minor

401
00:17:04,079 --> 00:17:04,799
bug

402
00:17:04,799 --> 00:17:06,900
and the way that that works is there's a

403
00:17:06,900 --> 00:17:08,400
simulator

404
00:17:08,400 --> 00:17:10,199
um that is supposed to simulate a random

405
00:17:10,199 --> 00:17:12,839
compression function and that works by

406
00:17:12,839 --> 00:17:15,419
building a tree where each Edge in the

407
00:17:15,419 --> 00:17:16,799
tree

408
00:17:16,799 --> 00:17:19,439
um represents one compression function

409
00:17:19,439 --> 00:17:21,660
execution and a path through the tree

410
00:17:21,660 --> 00:17:24,240
represents one full evaluation of Merkel

411
00:17:24,240 --> 00:17:25,859
domgaard on a message

412
00:17:25,859 --> 00:17:28,740
and usually proofs add extra nodes to

413
00:17:28,740 --> 00:17:31,380
this tree over the course of the proof

414
00:17:31,380 --> 00:17:34,140
to represent full hash function queries

415
00:17:34,140 --> 00:17:36,480
that are made by the adversary but since

416
00:17:36,480 --> 00:17:38,520
these nodes change the simulator State

417
00:17:38,520 --> 00:17:42,059
they can change its responses slightly

418
00:17:42,059 --> 00:17:43,799
and that can be detectable in certain

419
00:17:43,799 --> 00:17:46,260
somewhat unlikely situations so our

420
00:17:46,260 --> 00:17:48,179
simulator avoids this by constructing

421
00:17:48,179 --> 00:17:51,240
two trees uh responding to adversarial

422
00:17:51,240 --> 00:17:53,520
queries with one and using the other

423
00:17:53,520 --> 00:17:55,320
internally and bounding the probability

424
00:17:55,320 --> 00:17:58,100
that they'd average

425
00:17:58,380 --> 00:18:00,720
um and that's what I've got thank you

426
00:18:00,720 --> 00:18:03,200
for your time

427
00:18:06,539 --> 00:18:08,760
yeah would you have pushing for a couple

428
00:18:08,760 --> 00:18:12,379
questions time for patients

429
00:18:13,440 --> 00:18:16,100
yes

430
00:18:19,200 --> 00:18:20,880
um sorry if I missed it but how do you

431
00:18:20,880 --> 00:18:23,760
actually Define a clamping function

432
00:18:23,760 --> 00:18:26,400
so a clamping function is just a

433
00:18:26,400 --> 00:18:29,640
function that Maps the set of all

434
00:18:29,640 --> 00:18:31,919
possible secret keys to a subset of

435
00:18:31,919 --> 00:18:33,299
itself

436
00:18:33,299 --> 00:18:37,080
um so we format the secret keys and

437
00:18:37,080 --> 00:18:40,620
project them into a smaller set and the

438
00:18:40,620 --> 00:18:42,419
only property that we require of this

439
00:18:42,419 --> 00:18:45,059
clamping function is that the subset of

440
00:18:45,059 --> 00:18:47,100
clamped Keys is at least a large

441
00:18:47,100 --> 00:18:49,559
fraction of the entire set so we're not

442
00:18:49,559 --> 00:18:51,299
losing too much entropy in the secret

443
00:18:51,299 --> 00:18:54,320
Keys when we clamp

444
00:18:55,980 --> 00:18:58,640
questions

445
00:19:00,500 --> 00:19:03,919
thank you very much

446
00:19:06,179 --> 00:19:10,740
the next talk by annalisker about a

447
00:19:10,740 --> 00:19:15,240
security analysis of LSA bssa

448
00:19:37,380 --> 00:19:40,380
okay

449
00:19:46,679 --> 00:19:48,740
um

450
00:19:55,380 --> 00:19:58,320
let's try this okay hi everyone my name

451
00:19:58,320 --> 00:19:59,520
is Anna sanska and I'm going to be

452
00:19:59,520 --> 00:20:01,440
talking about the security analysis of

453
00:20:01,440 --> 00:20:04,640
RSA bssa

454
00:20:09,419 --> 00:20:12,919
okay I'm just going to talk like this

455
00:20:13,140 --> 00:20:16,620
oh it wasn't me oh okay good

456
00:20:16,620 --> 00:20:17,820
okay

457
00:20:17,820 --> 00:20:19,140
so

458
00:20:19,140 --> 00:20:22,020
what's RSA bssa we'll get to that for

459
00:20:22,020 --> 00:20:23,760
now let's talk about blind signatures

460
00:20:23,760 --> 00:20:25,440
what are blind signatures this is what

461
00:20:25,440 --> 00:20:27,360
the stock is about

462
00:20:27,360 --> 00:20:30,299
um so thanks to the previous speaker we

463
00:20:30,299 --> 00:20:32,100
know exactly what a regular signature

464
00:20:32,100 --> 00:20:34,440
scheme is a blind signature is a

465
00:20:34,440 --> 00:20:35,820
signature scheme that has a key

466
00:20:35,820 --> 00:20:37,559
generation algorithm just like a regular

467
00:20:37,559 --> 00:20:39,780
signature scheme verification algorithm

468
00:20:39,780 --> 00:20:41,580
just like a regular signature scheme but

469
00:20:41,580 --> 00:20:43,860
signing is now a secure protocol between

470
00:20:43,860 --> 00:20:46,760
a signer and a signature recipient

471
00:20:46,760 --> 00:20:50,280
where the recipient just knows the

472
00:20:50,280 --> 00:20:52,080
public key and the message he won't sign

473
00:20:52,080 --> 00:20:55,260
the signer knows the secret key

474
00:20:55,260 --> 00:20:59,400
the wheels turn the user's output is the

475
00:20:59,400 --> 00:21:00,900
signature on the message and the signer

476
00:21:00,900 --> 00:21:02,640
learns nothing other than he just

477
00:21:02,640 --> 00:21:05,220
successfully ran a signing protocol

478
00:21:05,220 --> 00:21:07,980
and the blindness means that the sign

479
00:21:07,980 --> 00:21:09,480
alerts not

480
00:21:09,480 --> 00:21:12,539
so that's what blind signatures are

481
00:21:12,539 --> 00:21:15,120
um why is this A Primitive we've been

482
00:21:15,120 --> 00:21:17,400
studying for the last 40 years

483
00:21:17,400 --> 00:21:19,740
uh it was proposed by David Cham in

484
00:21:19,740 --> 00:21:22,020
order to digitally represent money in a

485
00:21:22,020 --> 00:21:24,240
way that's privacy preserving so that

486
00:21:24,240 --> 00:21:27,299
was 40 years ago so why now so blind

487
00:21:27,299 --> 00:21:29,700
signatures are suddenly important

488
00:21:29,700 --> 00:21:31,380
why are they suddenly important well

489
00:21:31,380 --> 00:21:33,419
let's say that you wanna

490
00:21:33,419 --> 00:21:35,039
prove that you're not a robot not a

491
00:21:35,039 --> 00:21:36,539
troll

492
00:21:36,539 --> 00:21:39,960
um not a bot and so you asked to solve

493
00:21:39,960 --> 00:21:42,480
the capture if you had to solve capture

494
00:21:42,480 --> 00:21:44,580
for every single site you visit that's

495
00:21:44,580 --> 00:21:46,740
extremely onerous so it would be nice if

496
00:21:46,740 --> 00:21:48,780
you could just solve a capture once get

497
00:21:48,780 --> 00:21:50,580
some kind of digital tokens that you can

498
00:21:50,580 --> 00:21:52,500
then go and spend in a way that's not

499
00:21:52,500 --> 00:21:54,299
even linkable to your captures or to

500
00:21:54,299 --> 00:21:57,480
each other so that's one current use of

501
00:21:57,480 --> 00:21:59,820
blind signatures

502
00:21:59,820 --> 00:22:02,100
um and that one um

503
00:22:02,100 --> 00:22:04,440
is maybe a little hypothetical but

504
00:22:04,440 --> 00:22:05,940
actually online advertising platforms

505
00:22:05,940 --> 00:22:09,360
want to use them for accounting purposes

506
00:22:09,360 --> 00:22:11,580
um and um this is kind of part of this

507
00:22:11,580 --> 00:22:13,200
big plan to phase out third-party

508
00:22:13,200 --> 00:22:14,100
cookies

509
00:22:14,100 --> 00:22:17,340
don't ask me about that too much

510
00:22:17,340 --> 00:22:19,679
um Google uses blind signatures as

511
00:22:19,679 --> 00:22:22,740
tokens in the in the VPN

512
00:22:22,740 --> 00:22:25,500
and um so this is when you know if

513
00:22:25,500 --> 00:22:28,260
you're using uh Google one VPN this is

514
00:22:28,260 --> 00:22:29,700
what's happening under the hood it's a

515
00:22:29,700 --> 00:22:31,440
blind signature

516
00:22:31,440 --> 00:22:33,059
um but so when you log into the VPN

517
00:22:33,059 --> 00:22:34,919
Google doesn't

518
00:22:34,919 --> 00:22:36,419
um the server doesn't know who you are

519
00:22:36,419 --> 00:22:38,760
but you use a blind signature as a token

520
00:22:38,760 --> 00:22:41,640
and Apple's using them to let you browse

521
00:22:41,640 --> 00:22:43,620
the web anonymously

522
00:22:43,620 --> 00:22:46,020
um using this iCloud private relay so

523
00:22:46,020 --> 00:22:49,020
suddenly line signatures are being used

524
00:22:49,020 --> 00:22:51,299
and our focus is a specific line

525
00:22:51,299 --> 00:22:54,320
signature scheme called RSA bssa

526
00:22:54,320 --> 00:22:56,820
bssa stands for blind signature scheme

527
00:22:56,820 --> 00:22:58,200
with appendix

528
00:22:58,200 --> 00:23:00,059
and it's an ietf at this point it's

529
00:23:00,059 --> 00:23:01,620
still a draft but it's about to be

530
00:23:01,620 --> 00:23:02,940
standardized

531
00:23:02,940 --> 00:23:05,820
um by Dennis Jakes Jacobson woods so

532
00:23:05,820 --> 00:23:08,820
this is the the Apple side of that um

533
00:23:08,820 --> 00:23:11,280
of that big picture that I just showed

534
00:23:11,280 --> 00:23:13,679
so this is the first proposal for a

535
00:23:13,679 --> 00:23:15,780
standardized blind signature scheme

536
00:23:15,780 --> 00:23:18,780
uh the reason that they went with the

537
00:23:18,780 --> 00:23:21,419
this uh this scheme and not some other

538
00:23:21,419 --> 00:23:23,880
scheme is because it's built it builds

539
00:23:23,880 --> 00:23:27,299
off of RSA PSS which is of course part

540
00:23:27,299 --> 00:23:29,340
of the pkc as number one standard so

541
00:23:29,340 --> 00:23:30,600
it's everywhere people already have

542
00:23:30,600 --> 00:23:33,059
libraries for at least the key

543
00:23:33,059 --> 00:23:35,520
generation and verification part so it's

544
00:23:35,520 --> 00:23:37,919
just a signing protocol that they had to

545
00:23:37,919 --> 00:23:39,000
um introduce

546
00:23:39,000 --> 00:23:41,880
and it's used in Apple's private reeling

547
00:23:41,880 --> 00:23:44,520
okay so that's our focus is this

548
00:23:44,520 --> 00:23:46,919
particular blind signature scheme so

549
00:23:46,919 --> 00:23:49,220
here's a summary of our results

550
00:23:49,220 --> 00:23:51,539
so first of all

551
00:23:51,539 --> 00:23:52,380
um

552
00:23:52,380 --> 00:23:54,780
the good news is that rsabssa is

553
00:23:54,780 --> 00:23:58,020
strongly one more enforceable and that's

554
00:23:58,020 --> 00:24:01,080
the the gold standard notion of security

555
00:24:01,080 --> 00:24:03,360
for unfortability for blind signatures

556
00:24:03,360 --> 00:24:06,360
and I'll get into it in a moment

557
00:24:06,360 --> 00:24:09,659
um and it's um it is unforceable under

558
00:24:09,659 --> 00:24:13,320
this one more say assumption that 20

559
00:24:13,320 --> 00:24:15,360
years ago like more than 20 years ago it

560
00:24:15,360 --> 00:24:17,280
was when it was introduced maybe you

561
00:24:17,280 --> 00:24:19,020
would have said one more I would say

562
00:24:19,020 --> 00:24:22,020
what's this but by now it is a

563
00:24:22,020 --> 00:24:24,299
relatively established assumption

564
00:24:24,299 --> 00:24:27,480
um in the random Oracle model and um of

565
00:24:27,480 --> 00:24:29,460
course right now one question is why why

566
00:24:29,460 --> 00:24:30,840
standardized something that's not

567
00:24:30,840 --> 00:24:33,120
Quantum resistant well the

568
00:24:33,120 --> 00:24:35,520
unfortunatability doesn't doesn't hold

569
00:24:35,520 --> 00:24:37,679
uh in the quantum world of course

570
00:24:37,679 --> 00:24:40,559
because it's a RSA is not secure with

571
00:24:40,559 --> 00:24:43,320
quantum computers but This only affects

572
00:24:43,320 --> 00:24:45,840
unproachability so you know at the time

573
00:24:45,840 --> 00:24:47,340
when you're using your tokens which is

574
00:24:47,340 --> 00:24:49,260
today they are unforgeable and we can go

575
00:24:49,260 --> 00:24:50,940
on using them but your privacy is

576
00:24:50,940 --> 00:24:53,100
Everlasting even if quantum computers

577
00:24:53,100 --> 00:24:56,820
show up okay so

578
00:24:56,820 --> 00:24:59,640
um that's unapproachability

579
00:24:59,640 --> 00:25:02,220
um but what about blindness so the first

580
00:25:02,220 --> 00:25:05,640
draft of this iitf standard actually I'm

581
00:25:05,640 --> 00:25:08,640
not I don't know that it isn't blind but

582
00:25:08,640 --> 00:25:10,679
the proof of security hit a snag and

583
00:25:10,679 --> 00:25:13,260
I'll tell you why

584
00:25:13,260 --> 00:25:15,299
um but you can fix it with minor

585
00:25:15,299 --> 00:25:17,760
modifications

586
00:25:17,760 --> 00:25:20,520
um and the interesting thing is that the

587
00:25:20,520 --> 00:25:22,140
you know the alternative the one that

588
00:25:22,140 --> 00:25:25,440
Google uses uh the blind version of RSA

589
00:25:25,440 --> 00:25:27,120
of DH

590
00:25:27,120 --> 00:25:29,700
um is actually doesn't satisfy the

591
00:25:29,700 --> 00:25:31,740
definition the modern definition of

592
00:25:31,740 --> 00:25:33,200
blindness either

593
00:25:33,200 --> 00:25:36,480
uh but they both satisfy a weaker notion

594
00:25:36,480 --> 00:25:39,000
of this blind token which we've defined

595
00:25:39,000 --> 00:25:42,240
and um and it turns out that it's good

596
00:25:42,240 --> 00:25:44,220
enough for the applications

597
00:25:44,220 --> 00:25:46,020
where they're used all right so that's a

598
00:25:46,020 --> 00:25:47,580
summary of the result now let's jump in

599
00:25:47,580 --> 00:25:51,139
into the details

600
00:25:51,179 --> 00:25:53,159
um

601
00:25:53,159 --> 00:25:55,140
okay so what's the definition of a blind

602
00:25:55,140 --> 00:25:56,820
signature so as I said you have a key

603
00:25:56,820 --> 00:25:59,580
generation uh assigning protocol and a

604
00:25:59,580 --> 00:26:01,440
verification algorithm Q generation

605
00:26:01,440 --> 00:26:03,000
verification same as in a regular

606
00:26:03,000 --> 00:26:04,740
signature

607
00:26:04,740 --> 00:26:07,740
um the signing protocol here we will

608
00:26:07,740 --> 00:26:09,659
focus on just a two round structure of

609
00:26:09,659 --> 00:26:11,820
the signing protocol and if this is if

610
00:26:11,820 --> 00:26:13,980
we're willing to just only consider two

611
00:26:13,980 --> 00:26:16,020
rounds then the definition looks like

612
00:26:16,020 --> 00:26:18,059
this it's a protocol that consists of

613
00:26:18,059 --> 00:26:21,240
three algorithms the blind algorithm

614
00:26:21,240 --> 00:26:23,940
where the user choose generates this

615
00:26:23,940 --> 00:26:26,700
message to the signer the block the BC

616
00:26:26,700 --> 00:26:27,900
algorithm where the sign actually

617
00:26:27,900 --> 00:26:30,360
produces kind of an initial something

618
00:26:30,360 --> 00:26:32,580
that looks like a signature and then the

619
00:26:32,580 --> 00:26:34,200
finalized algorithm where the user

620
00:26:34,200 --> 00:26:37,080
extracts the signature from the signers

621
00:26:37,080 --> 00:26:39,320
answer

622
00:26:39,500 --> 00:26:43,020
and we want this uh to satisfy

623
00:26:43,020 --> 00:26:44,159
correctness and portability and

624
00:26:44,159 --> 00:26:46,080
blindness correctness always the same

625
00:26:46,080 --> 00:26:47,460
you know if everybody follows the

626
00:26:47,460 --> 00:26:48,980
protocol everything works out

627
00:26:48,980 --> 00:26:51,360
unfortubility is one more

628
00:26:51,360 --> 00:26:53,700
unfortunatability what does that mean it

629
00:26:53,700 --> 00:26:55,559
means that if you have a malicious user

630
00:26:55,559 --> 00:26:58,440
who gets a public key of the signer and

631
00:26:58,440 --> 00:27:00,659
gets to interact with the signer ask him

632
00:27:00,659 --> 00:27:03,419
to issue blind signature so send him

633
00:27:03,419 --> 00:27:05,700
blinded messages and get a response send

634
00:27:05,700 --> 00:27:07,020
him another blind message and get a

635
00:27:07,020 --> 00:27:10,020
response and do it l times

636
00:27:10,020 --> 00:27:12,480
um and then if he outputs this then this

637
00:27:12,480 --> 00:27:14,220
malicious user outputs all the message

638
00:27:14,220 --> 00:27:16,620
signature pairs

639
00:27:16,620 --> 00:27:17,520
um

640
00:27:17,520 --> 00:27:19,860
this user wins the one more

641
00:27:19,860 --> 00:27:22,500
unfortunatability game if he manages to

642
00:27:22,500 --> 00:27:25,380
Output more message signature pairs then

643
00:27:25,380 --> 00:27:27,059
the queries he's made to the sign that

644
00:27:27,059 --> 00:27:29,340
he is allowed to

645
00:27:29,340 --> 00:27:30,840
so

646
00:27:30,840 --> 00:27:31,919
it's called strong and more

647
00:27:31,919 --> 00:27:33,539
approachability

648
00:27:33,539 --> 00:27:36,480
um if uh all of them all of the messages

649
00:27:36,480 --> 00:27:38,220
are distinct

650
00:27:38,220 --> 00:27:40,679
and what about many around protocols

651
00:27:40,679 --> 00:27:42,120
well then if you wanted to Define then

652
00:27:42,120 --> 00:27:43,860
the be like question of whether

653
00:27:43,860 --> 00:27:45,659
sequential security

654
00:27:45,659 --> 00:27:47,940
for these many round protocols or you

655
00:27:47,940 --> 00:27:50,400
can maybe want to care about concurrent

656
00:27:50,400 --> 00:27:52,080
strong more strong one more

657
00:27:52,080 --> 00:27:55,080
unfortubility and the nice thing about

658
00:27:55,080 --> 00:27:56,820
only caring about this two round

659
00:27:56,820 --> 00:27:58,799
structure is that in the two if your

660
00:27:58,799 --> 00:28:00,200
protocol has only two rounds

661
00:28:00,200 --> 00:28:02,279
consequential implies concurrent then

662
00:28:02,279 --> 00:28:03,600
you don't have to worry about these

663
00:28:03,600 --> 00:28:05,940
subtleties which is suddenly very

664
00:28:05,940 --> 00:28:08,340
important because two years ago there

665
00:28:08,340 --> 00:28:09,480
was an attack

666
00:28:09,480 --> 00:28:11,279
um they showed it turns out that it's

667
00:28:11,279 --> 00:28:14,820
very subtle so so uh better to just deal

668
00:28:14,820 --> 00:28:16,320
with the two round structure and not

669
00:28:16,320 --> 00:28:18,900
worry about it okay so that's

670
00:28:18,900 --> 00:28:21,720
unfortubility and blindness formally

671
00:28:21,720 --> 00:28:24,419
means that I'm gonna go super fast

672
00:28:24,419 --> 00:28:27,360
um is that if you have an honest user

673
00:28:27,360 --> 00:28:29,880
who once cares about his privacy doesn't

674
00:28:29,880 --> 00:28:31,740
want the malicious signer to know which

675
00:28:31,740 --> 00:28:34,080
message the user once signed

676
00:28:34,080 --> 00:28:36,659
even though the sinus says here's my

677
00:28:36,659 --> 00:28:38,220
public key and here are two messages

678
00:28:38,220 --> 00:28:41,120
that I want you to obtain signatures of

679
00:28:41,120 --> 00:28:44,520
when the user gets them signed in random

680
00:28:44,520 --> 00:28:47,580
order so he sends his blinded messages

681
00:28:47,580 --> 00:28:50,400
he gets back the blinded signatures then

682
00:28:50,400 --> 00:28:53,220
he unblinds them and sends them in the

683
00:28:53,220 --> 00:28:55,200
same order as the messages he received

684
00:28:55,200 --> 00:28:57,419
the malicious signer cannot figure out

685
00:28:57,419 --> 00:28:59,400
in what order

686
00:28:59,400 --> 00:29:01,380
um the signage has happened so that's

687
00:29:01,380 --> 00:29:03,059
blinds

688
00:29:03,059 --> 00:29:06,360
okay so and I just gave you these

689
00:29:06,360 --> 00:29:08,100
definitions

690
00:29:08,100 --> 00:29:10,500
um these definitions are actually

691
00:29:10,500 --> 00:29:11,880
standard

692
00:29:11,880 --> 00:29:15,600
and it took the community many years to

693
00:29:15,600 --> 00:29:17,340
settle on these definitions being

694
00:29:17,340 --> 00:29:18,480
correct

695
00:29:18,480 --> 00:29:20,820
and it is kind of important so the one

696
00:29:20,820 --> 00:29:22,860
more importability definition was the

697
00:29:22,860 --> 00:29:24,659
original version was given in 96 by

698
00:29:24,659 --> 00:29:28,340
employer Stern and then this strong

699
00:29:28,340 --> 00:29:30,539
untouchability and the reason it's

700
00:29:30,539 --> 00:29:34,860
preferable was not given until 2012

701
00:29:34,860 --> 00:29:37,799
and for blindness the first try was in

702
00:29:37,799 --> 00:29:41,700
97 by Jules nostrovsky and then and then

703
00:29:41,700 --> 00:29:44,580
the improved definition is to account

704
00:29:44,580 --> 00:29:46,980
for the fact that the public key might

705
00:29:46,980 --> 00:29:49,020
be chosen maliciously by the signer and

706
00:29:49,020 --> 00:29:52,679
you still want blindness to hold

707
00:29:52,679 --> 00:29:54,840
um so and in that intervening time

708
00:29:54,840 --> 00:29:58,500
between 97 and 06 is when the original

709
00:29:58,500 --> 00:30:02,340
blind fdh RSA was published so it had a

710
00:30:02,340 --> 00:30:04,200
proof of security proof of blindness

711
00:30:04,200 --> 00:30:06,059
under the original definition that

712
00:30:06,059 --> 00:30:07,380
didn't account for the adversarial

713
00:30:07,380 --> 00:30:10,799
signer which is why I said oh but it

714
00:30:10,799 --> 00:30:12,360
doesn't one of our results and this is

715
00:30:12,360 --> 00:30:14,700
all I'm going to say about it is that um

716
00:30:14,700 --> 00:30:18,480
if blind fdhrsa isn't blind under this

717
00:30:18,480 --> 00:30:20,159
more modern definition

718
00:30:20,159 --> 00:30:21,659
okay

719
00:30:21,659 --> 00:30:24,779
um so that's definitions now our results

720
00:30:24,779 --> 00:30:27,720
so as I said what does this result say

721
00:30:27,720 --> 00:30:30,840
about rsabssa so what does it look like

722
00:30:30,840 --> 00:30:33,480
so I would say bssa

723
00:30:33,480 --> 00:30:35,520
uh the key Generations just scenario say

724
00:30:35,520 --> 00:30:37,559
key pair and three hash functions which

725
00:30:37,559 --> 00:30:39,120
we're going to model as random Oracles

726
00:30:39,120 --> 00:30:41,100
in the analysis the signing protocol

727
00:30:41,100 --> 00:30:42,899
I'll show you in a moment the

728
00:30:42,899 --> 00:30:45,500
verification just

729
00:30:45,500 --> 00:30:49,380
you verify use the same way as RSA PSS

730
00:30:49,380 --> 00:30:50,640
which

731
00:30:50,640 --> 00:30:52,380
roughly means that you take the

732
00:30:52,380 --> 00:30:54,059
signature you raise it to your exponent

733
00:30:54,059 --> 00:30:57,120
e and then you do this PSS decoding so

734
00:30:57,120 --> 00:30:58,740
for now this looks like nonsense because

735
00:30:58,740 --> 00:31:00,539
nobody remembers BSS off the top of

736
00:31:00,539 --> 00:31:02,279
their head but I'll get to it okay so

737
00:31:02,279 --> 00:31:04,919
what does the signing protocol look like

738
00:31:04,919 --> 00:31:07,500
pretty much what you would expect yeah

739
00:31:07,500 --> 00:31:09,720
the first thing the user does is when he

740
00:31:09,720 --> 00:31:13,200
wants to Blind is he Inc he does he PF

741
00:31:13,200 --> 00:31:15,059
doesn't codes his message

742
00:31:15,059 --> 00:31:17,700
and then he gets this em uh which is

743
00:31:17,700 --> 00:31:20,159
called encoded message that's a PSS

744
00:31:20,159 --> 00:31:22,860
notation takes it take this encoded

745
00:31:22,860 --> 00:31:25,740
message blinded by multiplying it with a

746
00:31:25,740 --> 00:31:28,559
random R raised to the E so now it's a

747
00:31:28,559 --> 00:31:31,799
random element of the group z and star

748
00:31:31,799 --> 00:31:34,320
and send that to the signer

749
00:31:34,320 --> 00:31:37,080
and then the signer computes the eighth

750
00:31:37,080 --> 00:31:38,880
root of that so raising that to the D

751
00:31:38,880 --> 00:31:40,919
sends it back and then you compute the

752
00:31:40,919 --> 00:31:43,620
signature by unbinding so

753
00:31:43,620 --> 00:31:50,059
and so so the PSS encoding is is uh

754
00:31:50,460 --> 00:31:52,679
is the part that I haven't approached

755
00:31:52,679 --> 00:31:55,140
yet exactly how it works okay so that's

756
00:31:55,140 --> 00:31:56,640
a signing protocol

757
00:31:56,640 --> 00:31:58,919
so this is very reminiscent of the of

758
00:31:58,919 --> 00:32:00,960
charm's original blind signature scheme

759
00:32:00,960 --> 00:32:02,880
except it's p-assessment coding as

760
00:32:02,880 --> 00:32:04,260
opposed to any other encoding of the

761
00:32:04,260 --> 00:32:05,700
message

762
00:32:05,700 --> 00:32:08,100
okay so here's a theorem if the one more

763
00:32:08,100 --> 00:32:11,279
RSA assumption holds then RSA B SSA is

764
00:32:11,279 --> 00:32:12,600
strongly one more unforceable in the

765
00:32:12,600 --> 00:32:14,279
random moroccuma so this proposal

766
00:32:14,279 --> 00:32:16,500
societyf draft proposal

767
00:32:16,500 --> 00:32:18,600
um has the unportability properties that

768
00:32:18,600 --> 00:32:19,799
that you want

769
00:32:19,799 --> 00:32:22,200
okay and how do we prove this theorem

770
00:32:22,200 --> 00:32:24,779
this is going to be very quick proof by

771
00:32:24,779 --> 00:32:26,039
picture

772
00:32:26,039 --> 00:32:28,260
um so we want to construct a reduction

773
00:32:28,260 --> 00:32:30,720
that solves one more RSA so it has a one

774
00:32:30,720 --> 00:32:33,539
more RSA Challenger

775
00:32:33,539 --> 00:32:37,559
um it gets an RSA public key it fires up

776
00:32:37,559 --> 00:32:39,840
the adversary who's trying to break rsab

777
00:32:39,840 --> 00:32:42,960
SSA gives it the same public key now it

778
00:32:42,960 --> 00:32:46,140
needs to answer the address queries

779
00:32:46,140 --> 00:32:48,419
um when the adversary sends it a blinded

780
00:32:48,419 --> 00:32:52,320
message it just forwards it to the

781
00:32:52,320 --> 00:32:54,779
um one more research Challenger and gets

782
00:32:54,779 --> 00:32:56,539
the answer so that's those are the easy

783
00:32:56,539 --> 00:32:59,360
queries to answer

784
00:32:59,360 --> 00:33:01,679
and I also need to tell you how to

785
00:33:01,679 --> 00:33:03,299
answer the three types of random Oracle

786
00:33:03,299 --> 00:33:05,520
queries there's the one where you just

787
00:33:05,520 --> 00:33:07,200
hash you have a message which is like

788
00:33:07,200 --> 00:33:10,260
arbitrary length long text whatever you

789
00:33:10,260 --> 00:33:11,880
you want to Hash it down to a short

790
00:33:11,880 --> 00:33:15,360
string so you just do that random Oracle

791
00:33:15,360 --> 00:33:17,039
yourself just respond with a random

792
00:33:17,039 --> 00:33:18,659
value

793
00:33:18,659 --> 00:33:21,419
um when it comes to hashing so I'll show

794
00:33:21,419 --> 00:33:23,220
you how that works as part of this be

795
00:33:23,220 --> 00:33:25,740
assessment coding caching some specific

796
00:33:25,740 --> 00:33:27,539
things that are called Capital M's

797
00:33:27,539 --> 00:33:30,539
that's when you ask your um one more

798
00:33:30,539 --> 00:33:32,519
essay Challenger to give you a challenge

799
00:33:32,519 --> 00:33:36,120
and he produces a challenge and from

800
00:33:36,120 --> 00:33:37,500
that challenge you compute the answers

801
00:33:37,500 --> 00:33:39,539
to these types of random oracles

802
00:33:39,539 --> 00:33:41,519
and then in the end when you output

803
00:33:41,519 --> 00:33:43,919
signatures

804
00:33:43,919 --> 00:33:46,019
um we want to those signatures to

805
00:33:46,019 --> 00:33:48,200
somehow be solutions to these challenges

806
00:33:48,200 --> 00:33:50,640
so what does that mean it means that

807
00:33:50,640 --> 00:33:52,500
they are the East roots of the challenge

808
00:33:52,500 --> 00:33:54,419
values y x

809
00:33:54,419 --> 00:33:57,179
okay so that's what we want so we want a

810
00:33:57,179 --> 00:33:59,460
signature that the adversary produces at

811
00:33:59,460 --> 00:34:02,039
the end to be an eighth root of one of

812
00:34:02,039 --> 00:34:03,360
the challenges and we want him to

813
00:34:03,360 --> 00:34:05,159
produce L plus one

814
00:34:05,159 --> 00:34:07,799
where L is the number of the um

815
00:34:07,799 --> 00:34:10,619
questions that we asked one more RSA

816
00:34:10,619 --> 00:34:11,699
challenge

817
00:34:11,699 --> 00:34:14,879
and so what does that mean it means that

818
00:34:14,879 --> 00:34:15,899
the

819
00:34:15,899 --> 00:34:18,839
uh we want this if it's a valid

820
00:34:18,839 --> 00:34:22,020
signature we want the Yi to decode to

821
00:34:22,020 --> 00:34:24,839
the message message for I so that means

822
00:34:24,839 --> 00:34:26,399
we need to program the random Oracle for

823
00:34:26,399 --> 00:34:28,619
all of this to work out so how do we do

824
00:34:28,619 --> 00:34:30,179
that that's when we actually need to

825
00:34:30,179 --> 00:34:33,659
look at how this PSS encoding works

826
00:34:33,659 --> 00:34:35,639
um so the way the PSS and coding works

827
00:34:35,639 --> 00:34:38,460
is you take a message you hash it

828
00:34:38,460 --> 00:34:40,980
um using hash star

829
00:34:40,980 --> 00:34:43,739
uh you add some salt to it because PSS

830
00:34:43,739 --> 00:34:45,418
stands for probabilistic signatures give

831
00:34:45,418 --> 00:34:46,980
so that's where the probabilistic part

832
00:34:46,980 --> 00:34:48,960
comes in then you pad it with some

833
00:34:48,960 --> 00:34:51,119
deterministic padding package it

834
00:34:51,119 --> 00:34:53,040
together then you hash it together you

835
00:34:53,040 --> 00:34:55,520
get some value H then you take that H

836
00:34:55,520 --> 00:34:58,200
you run it through the math generating

837
00:34:58,200 --> 00:34:59,940
function that takes a little bit of

838
00:34:59,940 --> 00:35:01,920
Randomness which is H and expands it to

839
00:35:01,920 --> 00:35:05,880
some longitude random string you xor

840
00:35:05,880 --> 00:35:09,000
that with salt with some other padding

841
00:35:09,000 --> 00:35:12,960
and then that's your masked salt DB

842
00:35:12,960 --> 00:35:14,339
means data block but it's really the

843
00:35:14,339 --> 00:35:16,859
mask of your mask salt and then you

844
00:35:16,859 --> 00:35:19,260
stick that H in and then this is like

845
00:35:19,260 --> 00:35:20,700
some other uh

846
00:35:20,700 --> 00:35:23,820
a few bytes BC two bites and then that

847
00:35:23,820 --> 00:35:26,160
is your encoded message that's how PSS

848
00:35:26,160 --> 00:35:28,260
encoding works

849
00:35:28,260 --> 00:35:30,900
um and then the PSS decoding works in

850
00:35:30,900 --> 00:35:32,339
the opposite direction

851
00:35:32,339 --> 00:35:34,079
so you kind of go back

852
00:35:34,079 --> 00:35:36,359
and then you check that you that this m

853
00:35:36,359 --> 00:35:38,880
that you get hashes to the right h

854
00:35:38,880 --> 00:35:41,700
so in order to program this random

855
00:35:41,700 --> 00:35:42,839
Oracle

856
00:35:42,839 --> 00:35:45,240
uh what we need to do is we we need to

857
00:35:45,240 --> 00:35:47,099
make sure that this m this is the Mi

858
00:35:47,099 --> 00:35:49,040
that's being

859
00:35:49,040 --> 00:35:52,619
hashed there that it's of this form if

860
00:35:52,619 --> 00:35:54,300
it's of another form just respond

861
00:35:54,300 --> 00:35:56,460
randomly and then we want to make sure

862
00:35:56,460 --> 00:35:58,380
that it that the resulting encoding

863
00:35:58,380 --> 00:36:00,839
corresponds to this m and this is the

864
00:36:00,839 --> 00:36:02,460
resulting what the resulting in coding

865
00:36:02,460 --> 00:36:04,560
is going to look like this y I think of

866
00:36:04,560 --> 00:36:06,839
y i as the encoding

867
00:36:06,839 --> 00:36:08,940
so in order to make sure that we program

868
00:36:08,940 --> 00:36:12,660
it correctly we

869
00:36:12,660 --> 00:36:16,980
take this um this H from our from this

870
00:36:16,980 --> 00:36:18,900
challenge y i

871
00:36:18,900 --> 00:36:21,660
and make sure that the math generation

872
00:36:21,660 --> 00:36:23,880
generating function when you feed it the

873
00:36:23,880 --> 00:36:26,520
H produces the correct salt that came

874
00:36:26,520 --> 00:36:29,339
from that M so this is where the salt

875
00:36:29,339 --> 00:36:30,599
came from

876
00:36:30,599 --> 00:36:32,579
so your program that means that you need

877
00:36:32,579 --> 00:36:34,680
to program the mass generated generation

878
00:36:34,680 --> 00:36:37,079
function this way and then the next

879
00:36:37,079 --> 00:36:38,339
thing you need to program is you need to

880
00:36:38,339 --> 00:36:40,980
program the H so you need to make sure

881
00:36:40,980 --> 00:36:44,400
that H uh that this Mi actually hashes

882
00:36:44,400 --> 00:36:45,839
to the H that comes from your challenge

883
00:36:45,839 --> 00:36:48,540
why and after you've done that

884
00:36:48,540 --> 00:36:50,579
that's the you know

885
00:36:50,579 --> 00:36:53,280
five more pages of analysis gives you

886
00:36:53,280 --> 00:36:55,200
the theorem all right so that's the

887
00:36:55,200 --> 00:36:57,000
first theorem but blindness is a

888
00:36:57,000 --> 00:36:58,859
different story so blindness is where

889
00:36:58,859 --> 00:37:01,020
there's a surprise where actually I

890
00:37:01,020 --> 00:37:03,359
couldn't show up blindness

891
00:37:03,359 --> 00:37:05,640
um well first of all the easy part is

892
00:37:05,640 --> 00:37:07,920
that if e is relatively prime to Phi of

893
00:37:07,920 --> 00:37:10,680
n then blindness holds and that's

894
00:37:10,680 --> 00:37:12,780
because in that case this blinded

895
00:37:12,780 --> 00:37:15,359
message is just a random element of the

896
00:37:15,359 --> 00:37:16,320
n-star

897
00:37:16,320 --> 00:37:19,320
so that's easy to see why

898
00:37:19,320 --> 00:37:22,500
um but that's not good enough because

899
00:37:22,500 --> 00:37:24,839
maybe the adversary prepared the public

900
00:37:24,839 --> 00:37:27,180
key in such a way that e is not

901
00:37:27,180 --> 00:37:29,099
relatively fine to Phi of n

902
00:37:29,099 --> 00:37:31,500
so in that case the one thing that he

903
00:37:31,500 --> 00:37:33,180
could do is he could make n the product

904
00:37:33,180 --> 00:37:37,020
of c primes such that e divides each and

905
00:37:37,020 --> 00:37:41,400
every uh file API for each anyway you

906
00:37:41,400 --> 00:37:43,500
know what I mean so that e is a multiple

907
00:37:43,500 --> 00:37:45,839
of Pi minus one for each of them

908
00:37:45,839 --> 00:37:47,760
so in that case information

909
00:37:47,760 --> 00:37:49,619
theoretically this blinded message

910
00:37:49,619 --> 00:37:52,460
actually reveals a lot of information

911
00:37:52,460 --> 00:37:55,680
about the original DM so you blind this

912
00:37:55,680 --> 00:37:58,320
Em by multiplying it with R to the E for

913
00:37:58,320 --> 00:38:01,560
a random R but it's still

914
00:38:01,560 --> 00:38:02,579
um

915
00:38:02,579 --> 00:38:04,320
if you think of it as like equivalence

916
00:38:04,320 --> 00:38:06,540
classes it still uh lives in the same

917
00:38:06,540 --> 00:38:09,960
equivalence class modular HP as the

918
00:38:09,960 --> 00:38:12,119
original em

919
00:38:12,119 --> 00:38:15,119
so those bits I mean the leaked

920
00:38:15,119 --> 00:38:16,560
information theoretically

921
00:38:16,560 --> 00:38:18,839
we don't know there's any way for this

922
00:38:18,839 --> 00:38:20,640
adversary to actually recover them and

923
00:38:20,640 --> 00:38:23,640
be prepared end this way

924
00:38:23,640 --> 00:38:25,020
um I mean you know he can recover them

925
00:38:25,020 --> 00:38:27,599
sorry but if you if you can use them

926
00:38:27,599 --> 00:38:30,119
somehow but what's the worst case so the

927
00:38:30,119 --> 00:38:33,540
worst case is here is our em

928
00:38:33,540 --> 00:38:37,020
um it is of course blinded but it's

929
00:38:37,020 --> 00:38:39,359
leaking so it's leaking some bits the

930
00:38:39,359 --> 00:38:40,980
worst case is that these are the bits

931
00:38:40,980 --> 00:38:42,720
that are being leaked that live live

932
00:38:42,720 --> 00:38:44,940
somewhere here and if these are the bits

933
00:38:44,940 --> 00:38:47,579
that are being leaked

934
00:38:47,579 --> 00:38:50,220
um then we have the h

935
00:38:50,220 --> 00:38:51,599
we can feed it through the math

936
00:38:51,599 --> 00:38:53,640
generation function now now by we I mean

937
00:38:53,640 --> 00:38:55,380
the adversary can feed it through this

938
00:38:55,380 --> 00:38:56,540
MGs

939
00:38:56,540 --> 00:39:01,020
and recover the salt why because he has

940
00:39:01,020 --> 00:39:02,520
these bits these blood bits in the clear

941
00:39:02,520 --> 00:39:04,560
and then when he masks when he exhorts

942
00:39:04,560 --> 00:39:07,320
them with this MGF of H he gets the salt

943
00:39:07,320 --> 00:39:10,980
and if he has the salt uh then he can

944
00:39:10,980 --> 00:39:14,339
and he wants to yes is this is the

945
00:39:14,339 --> 00:39:16,740
message being signed message zero and he

946
00:39:16,740 --> 00:39:19,440
takes message zero hashes it to this m

947
00:39:19,440 --> 00:39:22,859
hash sticks the salts that gets M checks

948
00:39:22,859 --> 00:39:25,680
does this m hash to H and if it does

949
00:39:25,680 --> 00:39:26,760
then

950
00:39:26,760 --> 00:39:30,540
then uh it's not blind okay so therefore

951
00:39:30,540 --> 00:39:32,400
this version has no blindness and the

952
00:39:32,400 --> 00:39:34,980
one provable blindness so we can modify

953
00:39:34,980 --> 00:39:37,020
it the two ways of modifying it both

954
00:39:37,020 --> 00:39:39,000
very straightforward

955
00:39:39,000 --> 00:39:40,200
um

956
00:39:40,200 --> 00:39:44,160
either you just add some additional soul

957
00:39:44,160 --> 00:39:47,160
to the message and then the adversary

958
00:39:47,160 --> 00:39:48,720
cannot recover this because there's an

959
00:39:48,720 --> 00:39:50,460
additional Soul Club over there that he

960
00:39:50,460 --> 00:39:53,700
doesn't know or you just make sure that

961
00:39:53,700 --> 00:39:56,339
your public Keys have some proof that e

962
00:39:56,339 --> 00:39:59,220
is relatively prime to 5n and this is

963
00:39:59,220 --> 00:40:01,320
this can be done using known techniques

964
00:40:01,320 --> 00:40:03,180
and I'm going to skip this new notion of

965
00:40:03,180 --> 00:40:06,900
line token because I'm out of time

966
00:40:06,900 --> 00:40:08,579
um and this is just a summary of the

967
00:40:08,579 --> 00:40:12,000
results again is that um rsabssa is

968
00:40:12,000 --> 00:40:14,460
strongly one more importable

969
00:40:14,460 --> 00:40:18,060
um it doesn't it it's uh

970
00:40:18,060 --> 00:40:20,460
the new the new version satisfies

971
00:40:20,460 --> 00:40:23,280
blindness the original version satisfied

972
00:40:23,280 --> 00:40:25,200
the weaker notion that is good enough

973
00:40:25,200 --> 00:40:27,480
for the application

974
00:40:27,480 --> 00:40:29,460
um and um

975
00:40:29,460 --> 00:40:31,380
and there's an open problem that I guess

976
00:40:31,380 --> 00:40:32,460
I should have mentioned when I was

977
00:40:32,460 --> 00:40:34,440
presenting that whether this original

978
00:40:34,440 --> 00:40:35,940
version actually is blind is an

979
00:40:35,940 --> 00:40:38,180
interesting

980
00:40:42,359 --> 00:40:44,520
we've run out of time unfortunately for

981
00:40:44,520 --> 00:40:46,500
questions so I encourage you to uh sorry

982
00:40:46,500 --> 00:40:50,660
about later so what's the next talk

983
00:40:53,520 --> 00:40:55,260
sir by

984
00:40:55,260 --> 00:40:57,260
um

985
00:40:59,950 --> 00:41:02,000
[Music]

986
00:41:02,000 --> 00:41:04,520
and the title is about extendable

987
00:41:04,520 --> 00:41:09,240
threshold and signature he has anonymity

988
00:41:09,240 --> 00:41:11,660
speakers

989
00:41:18,960 --> 00:41:20,820
yes

990
00:41:20,820 --> 00:41:23,520
okay perfect

991
00:41:23,520 --> 00:41:26,579
okay so this is going to work with the

992
00:41:26,579 --> 00:41:28,020
Vincenzo button the referral and today

993
00:41:28,020 --> 00:41:29,339
I'll talk about extendable

994
00:41:29,339 --> 00:41:31,079
thresholdering signature with an asset

995
00:41:31,079 --> 00:41:32,099
anonymity

996
00:41:32,099 --> 00:41:34,079
so extendable threshold bearing

997
00:41:34,079 --> 00:41:35,700
signature were introduced at last year

998
00:41:35,700 --> 00:41:40,500
pkc uh by aranya Anderson and Jacob and

999
00:41:40,500 --> 00:41:42,420
I introduced this primitive without an

1000
00:41:42,420 --> 00:41:45,420
example so basically imagine that we

1001
00:41:45,420 --> 00:41:48,420
have a user a that wants to start a

1002
00:41:48,420 --> 00:41:50,520
public petition and he also knows the

1003
00:41:50,520 --> 00:41:53,640
public key of user B and user C user a

1004
00:41:53,640 --> 00:41:55,680
would encode the petition in this

1005
00:41:55,680 --> 00:41:58,500
message M and then it would run a sign

1006
00:41:58,500 --> 00:42:01,200
in algorithm on input the secret key the

1007
00:42:01,200 --> 00:42:02,880
message and all the public keys that he

1008
00:42:02,880 --> 00:42:05,400
knows and this will give us output one

1009
00:42:05,400 --> 00:42:07,619
out of three signature that basically

1010
00:42:07,619 --> 00:42:09,780
certifies that the message gem was

1011
00:42:09,780 --> 00:42:12,180
signed either by us array user b or user

1012
00:42:12,180 --> 00:42:14,400
C but without disclosing the concrete

1013
00:42:14,400 --> 00:42:17,579
identity of designer and then user a can

1014
00:42:17,579 --> 00:42:19,560
start the petition by posting the the

1015
00:42:19,560 --> 00:42:20,940
message and the signature on a public

1016
00:42:20,940 --> 00:42:23,400
bulletin board that everybody can see

1017
00:42:23,400 --> 00:42:25,980
and now imagine that for example a user

1018
00:42:25,980 --> 00:42:27,720
C also know the public key of another

1019
00:42:27,720 --> 00:42:30,780
user user D she can run an extend

1020
00:42:30,780 --> 00:42:32,940
algorithm that will take as input this

1021
00:42:32,940 --> 00:42:34,440
previous signature on the bulletin board

1022
00:42:34,440 --> 00:42:36,480
and this additional public key of user D

1023
00:42:36,480 --> 00:42:38,900
and this will produce a one out of four

1024
00:42:38,900 --> 00:42:42,660
signature that now hides the identity

1025
00:42:42,660 --> 00:42:45,599
between four signers and imagine that

1026
00:42:45,599 --> 00:42:48,420
user C wants to endorse The Proposal as

1027
00:42:48,420 --> 00:42:50,540
well

1028
00:42:50,900 --> 00:42:53,099
the previous signature and their secret

1029
00:42:53,099 --> 00:42:54,780
key and this will produce a two out of

1030
00:42:54,780 --> 00:42:56,579
four signature that now certifies that

1031
00:42:56,579 --> 00:42:59,040
the number of signaries two and then she

1032
00:42:59,040 --> 00:43:01,560
can publish this signature as well and

1033
00:43:01,560 --> 00:43:03,119
the petition can go on with people

1034
00:43:03,119 --> 00:43:05,640
joining with extension and join

1035
00:43:05,640 --> 00:43:07,619
procedure session before

1036
00:43:07,619 --> 00:43:10,859
so what was the anonymity notion that

1037
00:43:10,859 --> 00:43:12,780
was considered in the previous work so

1038
00:43:12,780 --> 00:43:15,300
we have an adversary and a challenger

1039
00:43:15,300 --> 00:43:17,579
and the adversary will correct the

1040
00:43:17,579 --> 00:43:19,980
Challenger with two sequences so let's

1041
00:43:19,980 --> 00:43:21,900
take a look at these two sequences

1042
00:43:21,900 --> 00:43:23,940
so basically

1043
00:43:23,940 --> 00:43:28,680
these two sequences are such that they

1044
00:43:28,680 --> 00:43:30,960
ask for an operation of the signature

1045
00:43:30,960 --> 00:43:32,819
schema teach step so for example

1046
00:43:32,819 --> 00:43:35,099
sequences zero first task for a

1047
00:43:35,099 --> 00:43:37,680
signature with message M on public Keys

1048
00:43:37,680 --> 00:43:41,160
PK and pkb and then to to it and

1049
00:43:41,160 --> 00:43:42,359
requires it to be done with the secret

1050
00:43:42,359 --> 00:43:44,579
key of A then the second step is an

1051
00:43:44,579 --> 00:43:47,460
extension query with the public UFC and

1052
00:43:47,460 --> 00:43:49,200
then a join query with the secret key of

1053
00:43:49,200 --> 00:43:52,380
B and on the other end in order for the

1054
00:43:52,380 --> 00:43:54,300
diversary to be admissible this

1055
00:43:54,300 --> 00:43:56,400
sequences one must be compatible with

1056
00:43:56,400 --> 00:43:59,280
the zero so by compatible I mean that at

1057
00:43:59,280 --> 00:44:01,260
each step of the sequence the kind of

1058
00:44:01,260 --> 00:44:03,000
queries are of the same type and the

1059
00:44:03,000 --> 00:44:04,619
public inputs are the same

1060
00:44:04,619 --> 00:44:07,380
and then uh the Challenger will pick a

1061
00:44:07,380 --> 00:44:09,540
random beat and then we'll compute a

1062
00:44:09,540 --> 00:44:11,640
signature according to the sequence SB

1063
00:44:11,640 --> 00:44:14,579
and then very crucially here what the

1064
00:44:14,579 --> 00:44:17,760
Challenger will send to the adversary is

1065
00:44:17,760 --> 00:44:20,400
uh the signature that results from the

1066
00:44:20,400 --> 00:44:23,700
last step so in this case it will be a

1067
00:44:23,700 --> 00:44:26,220
two out of three signature and then the

1068
00:44:26,220 --> 00:44:28,380
adversary will have to guess uh what was

1069
00:44:28,380 --> 00:44:30,720
the bit uh that the Challenger picked

1070
00:44:30,720 --> 00:44:32,220
and then we say that the scheme is

1071
00:44:32,220 --> 00:44:34,319
anonymous if the anniversary doesn't get

1072
00:44:34,319 --> 00:44:37,800
lacking a single more than guessing at

1073
00:44:37,800 --> 00:44:41,819
random and yeah so if you take a look at

1074
00:44:41,819 --> 00:44:43,500
the application scenario that I've shown

1075
00:44:43,500 --> 00:44:46,200
before uh this definition doesn't fit

1076
00:44:46,200 --> 00:44:48,560
with the application scenario because uh

1077
00:44:48,560 --> 00:44:51,180
as you may see uh the adversary and

1078
00:44:51,180 --> 00:44:52,740
everybody will see a sequence of

1079
00:44:52,740 --> 00:44:55,140
signature so actually that's the

1080
00:44:55,140 --> 00:44:56,579
modification that we make to the

1081
00:44:56,579 --> 00:44:58,980
definition we allow the adversary to see

1082
00:44:58,980 --> 00:45:01,560
more signature so all the signature that

1083
00:45:01,560 --> 00:45:04,500
result from each step of the sequence

1084
00:45:04,500 --> 00:45:07,200
and actually when you look at the

1085
00:45:07,200 --> 00:45:09,420
sensation of the previous year paper it

1086
00:45:09,420 --> 00:45:10,920
turns out that the most efficient

1087
00:45:10,920 --> 00:45:13,440
Sensation that there doesn't satisfy our

1088
00:45:13,440 --> 00:45:15,540
strong anonymity notion and indeed there

1089
00:45:15,540 --> 00:45:18,420
is a very easy attack to break it

1090
00:45:18,420 --> 00:45:21,180
according to our notion and there is

1091
00:45:21,180 --> 00:45:24,599
also another Sensation that uh it's way

1092
00:45:24,599 --> 00:45:26,940
less efficient but satisfies our strong

1093
00:45:26,940 --> 00:45:29,520
anonymity definition but nevertheless

1094
00:45:29,520 --> 00:45:33,420
our instantiation over performs the

1095
00:45:33,420 --> 00:45:35,460
previous work both in terms of signature

1096
00:45:35,460 --> 00:45:39,839
sites and uh time complexity of all the

1097
00:45:39,839 --> 00:45:41,040
operation that you can make in the

1098
00:45:41,040 --> 00:45:44,700
signature scheme so here little n is the

1099
00:45:44,700 --> 00:45:47,520
size of the the ring K is the current

1100
00:45:47,520 --> 00:45:49,740
threshold and capital N is an upper

1101
00:45:49,740 --> 00:45:52,680
bound on the size of the ring that has

1102
00:45:52,680 --> 00:45:54,780
to be fixed from the very beginning so

1103
00:45:54,780 --> 00:45:58,020
maybe much bigger than a little n

1104
00:45:58,020 --> 00:46:00,060
so now I want to show the techniques

1105
00:46:00,060 --> 00:46:02,640
that that we use so first I introduce k

1106
00:46:02,640 --> 00:46:04,740
out of a new is so non-interactive

1107
00:46:04,740 --> 00:46:07,140
witnessing distinguishable proofs where

1108
00:46:07,140 --> 00:46:09,000
you have a translated party at publishes

1109
00:46:09,000 --> 00:46:11,220
a common random string and then you have

1110
00:46:11,220 --> 00:46:13,079
approval and the verifier they both get

1111
00:46:13,079 --> 00:46:15,540
in input and instances which may or may

1112
00:46:15,540 --> 00:46:17,640
not be in an empty language and then the

1113
00:46:17,640 --> 00:46:20,540
proverb gets as additional input K

1114
00:46:20,540 --> 00:46:23,240
weaknesses that certifies that K

1115
00:46:23,240 --> 00:46:26,099
different instance and weakness pairs

1116
00:46:26,099 --> 00:46:29,400
are in under NP relation and then the

1117
00:46:29,400 --> 00:46:31,680
prover will just send one message to the

1118
00:46:31,680 --> 00:46:33,900
verifier that is approved and divide the

1119
00:46:33,900 --> 00:46:36,319
verifier will either accept or reject

1120
00:46:36,319 --> 00:46:39,420
aside from soundness guarantees that

1121
00:46:39,420 --> 00:46:41,880
this proof system has to satisfy here we

1122
00:46:41,880 --> 00:46:44,280
are more interested in uh witnessing

1123
00:46:44,280 --> 00:46:46,500
distinguishability meaning that even if

1124
00:46:46,500 --> 00:46:49,200
the verifier Peaks uh the weakness to be

1125
00:46:49,200 --> 00:46:52,140
to be used he actually can distinguish a

1126
00:46:52,140 --> 00:46:54,540
proof gun with uh witness a certain

1127
00:46:54,540 --> 00:46:56,099
weakness or a proof done with another

1128
00:46:56,099 --> 00:47:00,480
weakness and yeah so uh now

1129
00:47:00,480 --> 00:47:02,819
um I'll show that if you can

1130
00:47:02,819 --> 00:47:05,339
um sort of change the niwi to be

1131
00:47:05,339 --> 00:47:07,140
extendable in the same way of the

1132
00:47:07,140 --> 00:47:08,880
extendable thresholdering signature you

1133
00:47:08,880 --> 00:47:10,319
can get an extendable threshold during

1134
00:47:10,319 --> 00:47:13,079
signature schema very easily so what do

1135
00:47:13,079 --> 00:47:15,660
I mean by uh this simple notion of

1136
00:47:15,660 --> 00:47:18,420
extendably with this so for example a

1137
00:47:18,420 --> 00:47:20,640
first prover using one weakness will

1138
00:47:20,640 --> 00:47:23,040
produce a one out of N1 proof and then

1139
00:47:23,040 --> 00:47:26,220
this proof will need to be updatable by

1140
00:47:26,220 --> 00:47:28,560
many different Brewers using only one

1141
00:47:28,560 --> 00:47:32,400
weakness so for example approver P2 will

1142
00:47:32,400 --> 00:47:34,920
produce a two out of N1 plus N2 using

1143
00:47:34,920 --> 00:47:37,260
just one additional weakness and so on

1144
00:47:37,260 --> 00:47:40,500
and so forth up to prover k

1145
00:47:40,500 --> 00:47:43,740
um and if we have this we can get an

1146
00:47:43,740 --> 00:47:45,300
extendable threshold during signature

1147
00:47:45,300 --> 00:47:48,720
very easily so we set the public key uh

1148
00:47:48,720 --> 00:47:50,880
of the scheme to be an instance and the

1149
00:47:50,880 --> 00:47:53,579
secret key of the signature scheme to be

1150
00:47:53,579 --> 00:47:56,099
the witness for that instance and then

1151
00:47:56,099 --> 00:47:58,140
uh to get the CRS we actually the

1152
00:47:58,140 --> 00:48:00,480
message and if the CRS is uniformly

1153
00:48:00,480 --> 00:48:02,520
random and we're in the random Oracle

1154
00:48:02,520 --> 00:48:04,920
model this is fine and then basically we

1155
00:48:04,920 --> 00:48:07,440
can now map an algorithm of the

1156
00:48:07,440 --> 00:48:09,540
signature scheme to an algorithm of the

1157
00:48:09,540 --> 00:48:12,440
extendable nuiso to sign we run a proof

1158
00:48:12,440 --> 00:48:15,599
with the CRS derived from the message

1159
00:48:15,599 --> 00:48:18,480
for example and and so on but however

1160
00:48:18,480 --> 00:48:21,599
such a simple notion as I shown can't

1161
00:48:21,599 --> 00:48:24,960
exist it's very easy to see why if you

1162
00:48:24,960 --> 00:48:26,760
for example produce a one out of three

1163
00:48:26,760 --> 00:48:30,960
proof using the weakness for instance

1164
00:48:30,960 --> 00:48:33,000
Eastern swan

1165
00:48:33,000 --> 00:48:34,740
that's why I call already between red

1166
00:48:34,740 --> 00:48:37,079
here and then for example you run a

1167
00:48:37,079 --> 00:48:39,619
joint operation with a witness for

1168
00:48:39,619 --> 00:48:42,480
instance 2 you'll get uh two out of

1169
00:48:42,480 --> 00:48:45,359
three proof but what happens if you run

1170
00:48:45,359 --> 00:48:47,940
a joint operation on the first proof but

1171
00:48:47,940 --> 00:48:51,119
using again a weakness for X1 you would

1172
00:48:51,119 --> 00:48:53,400
get a one out of three proof again or

1173
00:48:53,400 --> 00:48:55,319
this should fail because otherwise you

1174
00:48:55,319 --> 00:48:56,700
don't have any soundness proof of

1175
00:48:56,700 --> 00:48:59,880
knowledge guarantee so basically what

1176
00:48:59,880 --> 00:49:01,740
I've shown is an algorithm to

1177
00:49:01,740 --> 00:49:03,660
distinguish what is and what was what

1178
00:49:03,660 --> 00:49:06,300
weakness was used in in the proofs so

1179
00:49:06,300 --> 00:49:07,319
this would not be witness

1180
00:49:07,319 --> 00:49:09,599
indistinguishable so we have to tweak

1181
00:49:09,599 --> 00:49:12,660
the definitions a little bit so

1182
00:49:12,660 --> 00:49:14,640
um we introduced the notion of auxiliary

1183
00:49:14,640 --> 00:49:17,460
values uh together with the proof so for

1184
00:49:17,460 --> 00:49:20,160
each instance uh the prover will produce

1185
00:49:20,160 --> 00:49:22,920
an auxiliary value and these auxiliary

1186
00:49:22,920 --> 00:49:25,319
values have a color so basically the red

1187
00:49:25,319 --> 00:49:29,339
uh whether the um if the a witness for

1188
00:49:29,339 --> 00:49:31,079
that instance was used to make the proof

1189
00:49:31,079 --> 00:49:34,200
or their green otherwise and now when

1190
00:49:34,200 --> 00:49:35,819
you run an extend procedure you will

1191
00:49:35,819 --> 00:49:37,500
produce an additional auxiliary value

1192
00:49:37,500 --> 00:49:39,660
for the the instance that you just added

1193
00:49:39,660 --> 00:49:41,880
to the proof and then when you run at

1194
00:49:41,880 --> 00:49:44,220
the join procedure you will consume one

1195
00:49:44,220 --> 00:49:45,960
green auxiliary value and you will use

1196
00:49:45,960 --> 00:49:47,640
the witness for the distance to produce

1197
00:49:47,640 --> 00:49:50,640
a two out of four proof in this case and

1198
00:49:50,640 --> 00:49:52,560
the witnessing distinguishability notion

1199
00:49:52,560 --> 00:49:55,800
is like this the the adversary sample

1200
00:49:55,800 --> 00:49:58,260
statement and two possible weakness and

1201
00:49:58,260 --> 00:49:59,819
then the Challenger basically we can

1202
00:49:59,819 --> 00:50:02,040
imagine that computes both proofs with

1203
00:50:02,040 --> 00:50:04,920
both weaknesses and then picks a random

1204
00:50:04,920 --> 00:50:06,960
bit to select which proof to send to the

1205
00:50:06,960 --> 00:50:08,220
adversary

1206
00:50:08,220 --> 00:50:11,280
and now together with the proof it will

1207
00:50:11,280 --> 00:50:13,619
send a subset of all the auxiliary value

1208
00:50:13,619 --> 00:50:15,180
and the auxiliary value that they're

1209
00:50:15,180 --> 00:50:16,619
being sent are not all the auxiliary

1210
00:50:16,619 --> 00:50:19,140
value but in this case uh the auxiliary

1211
00:50:19,140 --> 00:50:21,119
value number one and two that basically

1212
00:50:21,119 --> 00:50:22,740
are the auxiliary value with the same

1213
00:50:22,740 --> 00:50:25,079
color so intuitively this auxiliary

1214
00:50:25,079 --> 00:50:26,940
value just should tell if a witness was

1215
00:50:26,940 --> 00:50:29,160
used or not so they shouldn't tell

1216
00:50:29,160 --> 00:50:32,880
anymore so in this case uh this

1217
00:50:32,880 --> 00:50:36,180
shouldn't help the the adversary and now

1218
00:50:36,180 --> 00:50:37,619
of course the adversary has to Guess The

1219
00:50:37,619 --> 00:50:38,400
Beat

1220
00:50:38,400 --> 00:50:41,819
so now if we are the public encryption

1221
00:50:41,819 --> 00:50:44,160
it's very easy to get an extendable

1222
00:50:44,160 --> 00:50:45,900
thresholdering signature for this from

1223
00:50:45,900 --> 00:50:47,640
this extendable new way we just

1224
00:50:47,640 --> 00:50:50,099
incremented the public key with the a

1225
00:50:50,099 --> 00:50:53,220
public key of a public encryption scheme

1226
00:50:53,220 --> 00:50:55,380
and then as before first we asked the

1227
00:50:55,380 --> 00:50:57,599
message to get the CRS and then to to

1228
00:50:57,599 --> 00:51:01,740
sign we we make a proof and additionally

1229
00:51:01,740 --> 00:51:04,500
we encrypt each of this auxiliary value

1230
00:51:04,500 --> 00:51:08,220
with the public key related to to the

1231
00:51:08,220 --> 00:51:10,859
corresponding uh user into the

1232
00:51:10,859 --> 00:51:13,200
corresponding distance and then as

1233
00:51:13,200 --> 00:51:15,660
output we will give the proof and the

1234
00:51:15,660 --> 00:51:18,660
encrypted the auxiliary values and if we

1235
00:51:18,660 --> 00:51:21,119
want to run a join a procedure for

1236
00:51:21,119 --> 00:51:22,800
example with the secret key of user3

1237
00:51:22,800 --> 00:51:25,680
user 3 can using his own decryption key

1238
00:51:25,680 --> 00:51:29,760
take the auxiliary value and then as as

1239
00:51:29,760 --> 00:51:31,619
soon as he has this auxiliary value he

1240
00:51:31,619 --> 00:51:33,420
can run the join procedure with the

1241
00:51:33,420 --> 00:51:35,760
extendable Nui and this will give us

1242
00:51:35,760 --> 00:51:38,160
output out of three proof after we also

1243
00:51:38,160 --> 00:51:40,079
re-encrypt the auxiliary value and we

1244
00:51:40,079 --> 00:51:41,880
give them an output

1245
00:51:41,880 --> 00:51:45,180
so why this extendable thresholdering

1246
00:51:45,180 --> 00:51:47,880
signature is strongly Anonymous at a

1247
00:51:47,880 --> 00:51:50,160
very high level in the in the proof you

1248
00:51:50,160 --> 00:51:51,900
will have an hybrid in which you want to

1249
00:51:51,900 --> 00:51:54,599
move from one sequence to another and

1250
00:51:54,599 --> 00:51:56,400
basically you want to use witnessing

1251
00:51:56,400 --> 00:51:58,680
distinguishability in this hybrid so

1252
00:51:58,680 --> 00:52:01,079
here it seems fine it doesn't seem that

1253
00:52:01,079 --> 00:52:02,760
we need this extended the notion with

1254
00:52:02,760 --> 00:52:05,099
the auxiliary value but also the

1255
00:52:05,099 --> 00:52:07,740
definition of an anonymity for the

1256
00:52:07,740 --> 00:52:09,960
signature scheme as allows for some

1257
00:52:09,960 --> 00:52:11,940
corruption and the corruption that are

1258
00:52:11,940 --> 00:52:14,220
allowed are Corruptions of non-signing

1259
00:52:14,220 --> 00:52:17,700
user so in this case uh in both

1260
00:52:17,700 --> 00:52:19,740
sequences the non-signing user we have

1261
00:52:19,740 --> 00:52:22,140
an auxiliary value of the same color so

1262
00:52:22,140 --> 00:52:24,300
this would allow a teacher step of the

1263
00:52:24,300 --> 00:52:27,059
sequence to reduce to this uh extendable

1264
00:52:27,059 --> 00:52:28,160
uh

1265
00:52:28,160 --> 00:52:31,079
weakness and distribution ability

1266
00:52:31,079 --> 00:52:34,079
so now at the end of my talk I want to

1267
00:52:34,079 --> 00:52:35,819
show a little bit how do we get the

1268
00:52:35,819 --> 00:52:37,079
technique that we use to get the

1269
00:52:37,079 --> 00:52:39,720
extendable Nui we use growth side proofs

1270
00:52:39,720 --> 00:52:42,300
uh in groups I proof the statement is an

1271
00:52:42,300 --> 00:52:44,520
equation with several unknowns and a

1272
00:52:44,520 --> 00:52:46,740
weakness is a satisfying assignment for

1273
00:52:46,740 --> 00:52:49,500
that equation and the proof is made of

1274
00:52:49,500 --> 00:52:52,260
two parts first we have to commit uh to

1275
00:52:52,260 --> 00:52:54,359
all the assignment and then after the

1276
00:52:54,359 --> 00:52:56,520
prover has to has committed to all these

1277
00:52:56,520 --> 00:52:58,380
assignments if we run approval algorithm

1278
00:52:58,380 --> 00:53:00,240
that don't input the equation the

1279
00:53:00,240 --> 00:53:01,440
commitments and the commitment

1280
00:53:01,440 --> 00:53:03,540
randomnesses will output some proof

1281
00:53:03,540 --> 00:53:06,420
elements and the proof is made of the

1282
00:53:06,420 --> 00:53:09,839
proof elements pi and commitments so now

1283
00:53:09,839 --> 00:53:12,000
I first show to get k out of n growth

1284
00:53:12,000 --> 00:53:15,119
SCI proofs so let's start from this

1285
00:53:15,119 --> 00:53:16,500
example of um

1286
00:53:16,500 --> 00:53:18,660
a simple pairing product equation with

1287
00:53:18,660 --> 00:53:21,599
one one unknown X2 we can modify this

1288
00:53:21,599 --> 00:53:25,140
equation to have two new variables where

1289
00:53:25,140 --> 00:53:26,880
basically for each element of the group

1290
00:53:26,880 --> 00:53:30,119
two we uh we add the new variable y i

1291
00:53:30,119 --> 00:53:33,119
and then we can add other equations uh

1292
00:53:33,119 --> 00:53:35,460
of this type so in this case we

1293
00:53:35,460 --> 00:53:37,260
introduce a new variable M and we prove

1294
00:53:37,260 --> 00:53:40,140
that m is equal to G to the power of a

1295
00:53:40,140 --> 00:53:42,119
bit and then we'll also add this

1296
00:53:42,119 --> 00:53:45,079
equation so where that

1297
00:53:45,079 --> 00:53:48,599
correlate the M the y i and the x i and

1298
00:53:48,599 --> 00:53:51,720
then now uh this has given us some

1299
00:53:51,720 --> 00:53:54,359
degree of freedom because we can set the

1300
00:53:54,359 --> 00:53:56,940
bit B to Bill equal to zero if we set

1301
00:53:56,940 --> 00:53:59,880
the bit B2B level uh to zero this will

1302
00:53:59,880 --> 00:54:02,460
be G to the power of 0 if we plug G to

1303
00:54:02,460 --> 00:54:05,400
the power of 0 in here y i uh for the

1304
00:54:05,400 --> 00:54:07,559
properties of pairing we can set y i to

1305
00:54:07,559 --> 00:54:10,140
whatever we want so in particular we can

1306
00:54:10,140 --> 00:54:12,359
set y i to be equal to one so we are

1307
00:54:12,359 --> 00:54:13,980
able to satisfy the modify the question

1308
00:54:13,980 --> 00:54:16,500
with the trivial assignment but if you

1309
00:54:16,500 --> 00:54:19,980
set bit one where uh we are forced to

1310
00:54:19,980 --> 00:54:22,859
pick the y i equal to the x i and this

1311
00:54:22,859 --> 00:54:24,720
will give the the the the initial

1312
00:54:24,720 --> 00:54:28,079
equation basically so to get out of and

1313
00:54:28,079 --> 00:54:30,780
proof use this fact you start from many

1314
00:54:30,780 --> 00:54:34,559
instances you modify uh DN instances uh

1315
00:54:34,559 --> 00:54:37,140
as I've shown before and you add an

1316
00:54:37,140 --> 00:54:39,359
additional equation in which you prove

1317
00:54:39,359 --> 00:54:43,920
that uh all the fbis some 2K so this is

1318
00:54:43,920 --> 00:54:46,020
this uh in terms is displaying product

1319
00:54:46,020 --> 00:54:49,200
equation it's not really important and

1320
00:54:49,200 --> 00:54:50,880
now basically

1321
00:54:50,880 --> 00:54:54,119
uh uh the the value of the bi is

1322
00:54:54,119 --> 00:54:56,760
constrained so we can have at most kbis

1323
00:54:56,760 --> 00:54:59,640
that are equal to one and uh and we will

1324
00:54:59,640 --> 00:55:01,680
have n minus k b i is that are equal to

1325
00:55:01,680 --> 00:55:04,319
zero so for K times we will set to the

1326
00:55:04,319 --> 00:55:06,540
beta to b equal to one and we will use

1327
00:55:06,540 --> 00:55:09,300
the original assignment and for n minus

1328
00:55:09,300 --> 00:55:11,339
K times we will say to the beat to be

1329
00:55:11,339 --> 00:55:13,200
zero and we can use the trivial

1330
00:55:13,200 --> 00:55:14,640
assignment to satisfy the modified

1331
00:55:14,640 --> 00:55:17,280
equation and basically as a proof we

1332
00:55:17,280 --> 00:55:19,500
will have uh commitment and proof

1333
00:55:19,500 --> 00:55:21,359
elements for each individual modified

1334
00:55:21,359 --> 00:55:23,460
the question and the commitment and

1335
00:55:23,460 --> 00:55:25,200
proof elements for this additional

1336
00:55:25,200 --> 00:55:28,500
equation over here okay and now

1337
00:55:28,500 --> 00:55:29,700
basically

1338
00:55:29,700 --> 00:55:34,140
um if we want to have a

1339
00:55:34,140 --> 00:55:37,740
an extendability property over here we

1340
00:55:37,740 --> 00:55:40,500
just need to focus on this equation over

1341
00:55:40,500 --> 00:55:44,460
here uh so uh basically this is because

1342
00:55:44,460 --> 00:55:46,619
if you want if we want to run an

1343
00:55:46,619 --> 00:55:49,500
extended procedure this would imply that

1344
00:55:49,500 --> 00:55:51,359
we need to add another question and do

1345
00:55:51,359 --> 00:55:53,099
this modification and run the proof but

1346
00:55:53,099 --> 00:55:55,619
this is kind of independent from all the

1347
00:55:55,619 --> 00:55:58,559
other equations they're not correlated

1348
00:55:58,559 --> 00:56:01,559
together but the the only place where

1349
00:56:01,559 --> 00:56:03,240
this addition of a new equation over

1350
00:56:03,240 --> 00:56:05,520
here would have impact is in this sum

1351
00:56:05,520 --> 00:56:09,300
over here so here in particular we need

1352
00:56:09,300 --> 00:56:12,740
to add another variable b n plus one and

1353
00:56:12,740 --> 00:56:15,720
if we want to run a joint procedure it

1354
00:56:15,720 --> 00:56:17,640
means that we don't want to use a

1355
00:56:17,640 --> 00:56:20,040
trivial assignment for equation say for

1356
00:56:20,040 --> 00:56:22,500
example in equation one we now want to

1357
00:56:22,500 --> 00:56:26,160
use the the actual assignment we need to

1358
00:56:26,160 --> 00:56:28,260
modify this equation to be equal to K

1359
00:56:28,260 --> 00:56:30,960
plus 1 and we will replace basically

1360
00:56:30,960 --> 00:56:33,119
this proof with a new proof

1361
00:56:33,119 --> 00:56:37,740
so how do we do this basically I will be

1362
00:56:37,740 --> 00:56:40,440
a high level D here I won't go into the

1363
00:56:40,440 --> 00:56:42,780
detail of the broadside proofs but

1364
00:56:42,780 --> 00:56:45,599
basically internally when the roadside

1365
00:56:45,599 --> 00:56:47,880
prover makes a proof for this equation

1366
00:56:47,880 --> 00:56:50,520
what you will do for example imagine

1367
00:56:50,520 --> 00:56:54,800
that we start with the B2 equal to zero

1368
00:56:54,800 --> 00:56:58,319
uh he will do the following first he

1369
00:56:58,319 --> 00:57:01,079
will commit to all the values of the Mis

1370
00:57:01,079 --> 00:57:04,380
including the commitment to M2 that is

1371
00:57:04,380 --> 00:57:07,319
now G to the power of 0 that is one and

1372
00:57:07,319 --> 00:57:09,059
and they will have any sense all these

1373
00:57:09,059 --> 00:57:10,619
commitments and the commitment

1374
00:57:10,619 --> 00:57:13,559
randomnesses and when he basically has

1375
00:57:13,559 --> 00:57:16,140
to generate the proof elements you can

1376
00:57:16,140 --> 00:57:17,940
look at it as it's it's an addition of

1377
00:57:17,940 --> 00:57:20,220
all this stuff so this stuff is combined

1378
00:57:20,220 --> 00:57:23,520
uh to get these proof elements and now

1379
00:57:23,520 --> 00:57:27,000
imagine that you want to get uh an a

1380
00:57:27,000 --> 00:57:30,119
joint procedure so you want to make this

1381
00:57:30,119 --> 00:57:32,280
equation prove that this equation is

1382
00:57:32,280 --> 00:57:35,339
equal to K plus 1 and now and we change

1383
00:57:35,339 --> 00:57:38,160
the value of B2 to b equal 1 and

1384
00:57:38,160 --> 00:57:41,640
therefore M2 will be G so you will

1385
00:57:41,640 --> 00:57:44,760
commit to the variable M2 again creating

1386
00:57:44,760 --> 00:57:47,640
a new commitment cm2 Prime and with the

1387
00:57:47,640 --> 00:57:50,520
commitment Randomness rm2 Prime

1388
00:57:50,520 --> 00:57:53,400
and basically now what we would like to

1389
00:57:53,400 --> 00:57:55,440
do is to create new proof elements

1390
00:57:55,440 --> 00:57:57,780
modifying the old proof elements so

1391
00:57:57,780 --> 00:57:59,640
basically what do we need to do is to

1392
00:57:59,640 --> 00:58:01,260
erase some contribution of the old

1393
00:58:01,260 --> 00:58:02,400
commitment

1394
00:58:02,400 --> 00:58:04,500
and add the contribution of the new

1395
00:58:04,500 --> 00:58:06,119
commitment because everything else is

1396
00:58:06,119 --> 00:58:07,920
the same so we want just to change this

1397
00:58:07,920 --> 00:58:10,079
part and basically we will achieve this

1398
00:58:10,079 --> 00:58:12,540
by using as auxiliary value the

1399
00:58:12,540 --> 00:58:15,420
commitment Randomness related to the

1400
00:58:15,420 --> 00:58:18,119
variable M2 and once we have this we

1401
00:58:18,119 --> 00:58:19,559
have both of the commitment that is

1402
00:58:19,559 --> 00:58:21,900
public this commitment Randomness we can

1403
00:58:21,900 --> 00:58:24,000
remove it with the inverse of this

1404
00:58:24,000 --> 00:58:25,740
operation that I denoted with the plus

1405
00:58:25,740 --> 00:58:29,160
and then we can add the new uh

1406
00:58:29,160 --> 00:58:31,380
commitment and the new Randomness to get

1407
00:58:31,380 --> 00:58:35,099
an updated proof element Pi n Prime

1408
00:58:35,099 --> 00:58:36,780
so to conclude

1409
00:58:36,780 --> 00:58:38,700
in this work we have introduced a

1410
00:58:38,700 --> 00:58:41,880
stronger notion for extend of anonymity

1411
00:58:41,880 --> 00:58:43,680
for extendable thresholdering signature

1412
00:58:43,680 --> 00:58:47,460
we provide an efficient and strongly

1413
00:58:47,460 --> 00:58:48,960
Anonymous extendable threshold during

1414
00:58:48,960 --> 00:58:51,660
signature and also kind of interesting

1415
00:58:51,660 --> 00:58:53,280
we formalize this new notion of

1416
00:58:53,280 --> 00:58:54,780
extendable new which would be used

1417
00:58:54,780 --> 00:58:56,760
elsewhere maybe and we propose any

1418
00:58:56,760 --> 00:58:59,099
sensation for extendable news for

1419
00:58:59,099 --> 00:59:00,780
repairing product equations

1420
00:59:00,780 --> 00:59:04,339
thank you I'm open to questions

1421
00:59:05,940 --> 00:59:09,200
one question please

1422
00:59:12,839 --> 00:59:17,779
well thank you again thank you foreign

1423
00:59:18,760 --> 00:59:20,900
[Music]

1424
00:59:20,900 --> 00:59:24,359
tracing a linear space application to

1425
00:59:24,359 --> 00:59:27,599
linear homomorphic group signature by

1426
00:59:27,599 --> 00:59:31,020
Chloe hoband David Point Cheval

1427
00:59:31,020 --> 00:59:34,440
and challenge I believe Robert is a

1428
00:59:34,440 --> 00:59:37,339
speaker right yes

1429
00:59:54,119 --> 00:59:57,319
so can you hear me

1430
01:00:10,680 --> 01:00:13,020
all right so hello everyone my name is

1431
01:00:13,020 --> 01:00:15,059
Robert and I will be presenting a joint

1432
01:00:15,059 --> 01:00:17,940
work with Chloe bong and David Wong

1433
01:00:17,940 --> 01:00:22,319
Cheval and in our work we introduce a

1434
01:00:22,319 --> 01:00:24,180
new technique that we call tracing of a

1435
01:00:24,180 --> 01:00:26,339
linear Subspace and we demonstrate how

1436
01:00:26,339 --> 01:00:29,040
this technique can be used to build a

1437
01:00:29,040 --> 01:00:30,660
linearly homomorphic group signature

1438
01:00:30,660 --> 01:00:31,640
scheme

1439
01:00:31,640 --> 01:00:35,099
and I will start with a short definition

1440
01:00:35,099 --> 01:00:37,740
of our security model followed by a high

1441
01:00:37,740 --> 01:00:40,740
level overview of our construction and

1442
01:00:40,740 --> 01:00:42,780
at the end of this construction we will

1443
01:00:42,780 --> 01:00:45,540
identify like a key technical problem

1444
01:00:45,540 --> 01:00:48,420
that we need to solve and fortunately

1445
01:00:48,420 --> 01:00:50,400
there is a very simple solution that we

1446
01:00:50,400 --> 01:00:52,980
will discuss first and in the end of

1447
01:00:52,980 --> 01:00:55,380
time permits we also look at a more

1448
01:00:55,380 --> 01:00:58,020
Advanced Construction that leads to much

1449
01:00:58,020 --> 01:01:00,780
shorter signatures and so actually all

1450
01:01:00,780 --> 01:01:02,099
the technical stuff in the paper is

1451
01:01:02,099 --> 01:01:05,640
going on and the last bullet there but

1452
01:01:05,640 --> 01:01:06,540
um

1453
01:01:06,540 --> 01:01:08,579
yes so it is targeted in the signature

1454
01:01:08,579 --> 01:01:10,140
so we can just have a look at the

1455
01:01:10,140 --> 01:01:11,579
application

1456
01:01:11,579 --> 01:01:13,980
yeah so as the name indicates a linearly

1457
01:01:13,980 --> 01:01:16,740
homomorphic group signature consists of

1458
01:01:16,740 --> 01:01:19,020
or is a combination of two Primitives a

1459
01:01:19,020 --> 01:01:21,420
linearly homomorphic signature and a

1460
01:01:21,420 --> 01:01:24,180
group signature and so just as little

1461
01:01:24,180 --> 01:01:26,460
reminder a linearity homomorphic groups

1462
01:01:26,460 --> 01:01:28,680
linear homomorphic signature scheme

1463
01:01:28,680 --> 01:01:31,680
consists of four algorithms three of

1464
01:01:31,680 --> 01:01:33,059
them are standard a key generation

1465
01:01:33,059 --> 01:01:35,540
assigning and the verification algorithm

1466
01:01:35,540 --> 01:01:39,180
and the message space of such a

1467
01:01:39,180 --> 01:01:41,280
signature is always a vector space

1468
01:01:41,280 --> 01:01:43,559
meaning that the signing algorithm

1469
01:01:43,559 --> 01:01:45,200
science

1470
01:01:45,200 --> 01:01:47,819
science vectors in this case for example

1471
01:01:47,819 --> 01:01:50,280
vectors and one and two and then three

1472
01:01:50,280 --> 01:01:52,980
in the figure there and the reason why

1473
01:01:52,980 --> 01:01:54,240
this scheme is called linearly

1474
01:01:54,240 --> 01:01:56,960
homomorphic is that

1475
01:01:56,960 --> 01:02:01,140
given signatures for say M1 M2 and M3 we

1476
01:02:01,140 --> 01:02:04,200
can derive signatures for any message M

1477
01:02:04,200 --> 01:02:05,579
that can be written as a linear

1478
01:02:05,579 --> 01:02:09,359
combination over M1 and 2 and M3

1479
01:02:09,359 --> 01:02:12,119
and the important property here is that

1480
01:02:12,119 --> 01:02:14,579
this derivation needs only the public

1481
01:02:14,579 --> 01:02:16,319
key but no knowledge of the secret key

1482
01:02:16,319 --> 01:02:19,440
so essentially everyone can do it and

1483
01:02:19,440 --> 01:02:22,319
for this reason we need to adapt our

1484
01:02:22,319 --> 01:02:24,960
security notion a bit essentially what

1485
01:02:24,960 --> 01:02:26,700
we would like to have is existential

1486
01:02:26,700 --> 01:02:28,319
unforgeability against Joe's message

1487
01:02:28,319 --> 01:02:31,859
attacks however we need to exclude some

1488
01:02:31,859 --> 01:02:33,720
trivial attacks that are induced by this

1489
01:02:33,720 --> 01:02:36,780
derivation algorithm so comfortably if

1490
01:02:36,780 --> 01:02:38,520
an adversary wants to win the security

1491
01:02:38,520 --> 01:02:40,319
game then he needs to come up with his

1492
01:02:40,319 --> 01:02:42,660
signature for a message that does not

1493
01:02:42,660 --> 01:02:44,819
lie in space in the span of those

1494
01:02:44,819 --> 01:02:46,920
messages that were queried to the

1495
01:02:46,920 --> 01:02:48,420
signing Oracle

1496
01:02:48,420 --> 01:02:51,059
and the second primitive that we

1497
01:02:51,059 --> 01:02:52,859
consider is the group signature scheme

1498
01:02:52,859 --> 01:02:55,920
and in this case group does not refer to

1499
01:02:55,920 --> 01:02:59,400
an algebraic robot group of users uh

1500
01:02:59,400 --> 01:03:02,579
together with some trusted Authority

1501
01:03:02,579 --> 01:03:05,819
that is called the group manager and so

1502
01:03:05,819 --> 01:03:08,339
each party has their own secret key and

1503
01:03:08,339 --> 01:03:10,740
in addition there is one public key for

1504
01:03:10,740 --> 01:03:13,500
the entire group and so we consider

1505
01:03:13,500 --> 01:03:16,260
signature scheme so of course every user

1506
01:03:16,260 --> 01:03:18,960
can sign messages like this

1507
01:03:18,960 --> 01:03:22,619
and uh all these signatures are valid

1508
01:03:22,619 --> 01:03:24,660
with respect to the same unique public

1509
01:03:24,660 --> 01:03:27,720
key of the group meaning that or the

1510
01:03:27,720 --> 01:03:30,859
intuition behind that is that all the

1511
01:03:30,859 --> 01:03:34,020
users can sign on behalf of this group

1512
01:03:34,020 --> 01:03:36,000
and regarding security we have two

1513
01:03:36,000 --> 01:03:38,160
requirements the first one is called

1514
01:03:38,160 --> 01:03:40,260
anonymity and it essentially means that

1515
01:03:40,260 --> 01:03:43,980
all the signatures yeah look the same

1516
01:03:43,980 --> 01:03:46,980
and behave in the same way and so of

1517
01:03:46,980 --> 01:03:48,480
course anonymity is a very desirable

1518
01:03:48,480 --> 01:03:51,380
property but it's also

1519
01:03:51,380 --> 01:03:53,760
like the perfect environment for a

1520
01:03:53,760 --> 01:03:55,559
corruption or malicious behavior in

1521
01:03:55,559 --> 01:03:57,480
general and for this reason one

1522
01:03:57,480 --> 01:04:00,319
introduces a second security

1523
01:04:00,319 --> 01:04:02,780
requirement that is called traceability

1524
01:04:02,780 --> 01:04:05,040
and this is the point where the group

1525
01:04:05,040 --> 01:04:07,200
manager enters the stage because using

1526
01:04:07,200 --> 01:04:09,119
this special secret key of the group

1527
01:04:09,119 --> 01:04:11,460
manager it is possible to revoke

1528
01:04:11,460 --> 01:04:16,500
anonymity and to identify the creator of

1529
01:04:16,500 --> 01:04:20,819
a given signature and the letter uh

1530
01:04:20,819 --> 01:04:24,540
process is called opening of a signature

1531
01:04:24,540 --> 01:04:28,799
and now the question is well what makes

1532
01:04:28,799 --> 01:04:30,660
the combination of those two Primitives

1533
01:04:30,660 --> 01:04:33,780
actually non-trivial and my intuition on

1534
01:04:33,780 --> 01:04:36,420
that is that so on the one hand we have

1535
01:04:36,420 --> 01:04:39,140
this group signatures that gives us

1536
01:04:39,140 --> 01:04:42,059
several uses and all of these users

1537
01:04:42,059 --> 01:04:46,619
should be able to sign documents so we

1538
01:04:46,619 --> 01:04:49,140
have several signatures and on the other

1539
01:04:49,140 --> 01:04:52,079
hand we have this derivation algorithm

1540
01:04:52,079 --> 01:04:55,020
that should be able to take arbitrary

1541
01:04:55,020 --> 01:04:57,299
given signatures and to derive new

1542
01:04:57,299 --> 01:04:58,619
signages

1543
01:04:58,619 --> 01:05:01,980
and in particular in our setting this

1544
01:05:01,980 --> 01:05:06,000
means that the given signatures our

1545
01:05:06,000 --> 01:05:07,920
signature is produced by different users

1546
01:05:07,920 --> 01:05:11,220
so this derivation process can lead to

1547
01:05:11,220 --> 01:05:13,319
signatures that do not have only one

1548
01:05:13,319 --> 01:05:17,400
signer but like several contributors and

1549
01:05:17,400 --> 01:05:19,859
of course this is

1550
01:05:19,859 --> 01:05:23,040
important for correctness this

1551
01:05:23,040 --> 01:05:26,339
derivation with signatures by produced

1552
01:05:26,339 --> 01:05:27,960
by different users should again lead to

1553
01:05:27,960 --> 01:05:30,420
a valid signature but this is also

1554
01:05:30,420 --> 01:05:32,940
important for anonymity because the

1555
01:05:32,940 --> 01:05:35,520
given signatures could either be

1556
01:05:35,520 --> 01:05:37,319
produced by the same user or by the diff

1557
01:05:37,319 --> 01:05:38,940
by different users

1558
01:05:38,940 --> 01:05:43,200
maybe they are freshly generated or they

1559
01:05:43,200 --> 01:05:45,000
are the result of a previous derivation

1560
01:05:45,000 --> 01:05:48,480
process in any case the output signature

1561
01:05:48,480 --> 01:05:51,119
of the derivation should follow an

1562
01:05:51,119 --> 01:05:54,059
indistinguishable distribution

1563
01:05:54,059 --> 01:05:58,980
and this fact that signatures can have

1564
01:05:58,980 --> 01:06:00,839
several contributors is also a challenge

1565
01:06:00,839 --> 01:06:03,900
for traceability because it's no longer

1566
01:06:03,900 --> 01:06:06,839
sufficient to uh

1567
01:06:06,839 --> 01:06:09,660
it's no longer sufficient to find only

1568
01:06:09,660 --> 01:06:12,900
one signer of signature but what we need

1569
01:06:12,900 --> 01:06:18,000
instead is to identify a subset of users

1570
01:06:18,000 --> 01:06:20,099
that contains all the contributors to a

1571
01:06:20,099 --> 01:06:24,059
certain signature and at this point so

1572
01:06:24,059 --> 01:06:27,180
it's really important that the group

1573
01:06:27,180 --> 01:06:30,420
manager actually finds all of the

1574
01:06:30,420 --> 01:06:32,160
contributors to Signature because

1575
01:06:32,160 --> 01:06:34,980
otherwise an adversary simply could mix

1576
01:06:34,980 --> 01:06:38,520
its own malicious signature with many

1577
01:06:38,520 --> 01:06:40,980
signatures produced by Honest users and

1578
01:06:40,980 --> 01:06:43,160
in the end there would be

1579
01:06:43,160 --> 01:06:46,859
a good probability that the group

1580
01:06:46,859 --> 01:06:50,280
manager only finds honest users as a

1581
01:06:50,280 --> 01:06:52,440
contributor but not the real malicious

1582
01:06:52,440 --> 01:06:55,140
user or the adversary so for a

1583
01:06:55,140 --> 01:06:57,059
meaningful security notion it's

1584
01:06:57,059 --> 01:06:59,700
important that the group manager finds

1585
01:06:59,700 --> 01:07:03,119
all the contributors to a signature

1586
01:07:03,119 --> 01:07:05,819
and so before I will be presenting our

1587
01:07:05,819 --> 01:07:07,680
construction I would like to recall a

1588
01:07:07,680 --> 01:07:10,940
framework for group signatures by uh

1589
01:07:10,940 --> 01:07:14,400
mishanshu and varanchi I guess my

1590
01:07:14,400 --> 01:07:17,160
pronunciation was completely odd but uh

1591
01:07:17,160 --> 01:07:18,480
anyway

1592
01:07:18,480 --> 01:07:20,880
um so their scheme uses uh three

1593
01:07:20,880 --> 01:07:22,740
ingredients a traditional signature

1594
01:07:22,740 --> 01:07:24,900
scheme a public encryption scheme and

1595
01:07:24,900 --> 01:07:26,520
non-interactive gear knowledge proofs

1596
01:07:26,520 --> 01:07:27,900
for NP

1597
01:07:27,900 --> 01:07:30,720
and so as I just said the group consists

1598
01:07:30,720 --> 01:07:34,079
of a bunch of users and uh

1599
01:07:34,079 --> 01:07:37,260
Central Authority the group manager and

1600
01:07:37,260 --> 01:07:40,200
secret keys of the users consists of a

1601
01:07:40,200 --> 01:07:41,819
fresh key pair of the traditional

1602
01:07:41,819 --> 01:07:44,339
signature and a certificate of their

1603
01:07:44,339 --> 01:07:46,680
identity this is essentially their

1604
01:07:46,680 --> 01:07:50,220
identity signed by the key generator and

1605
01:07:50,220 --> 01:07:52,079
in addition we have

1606
01:07:52,079 --> 01:07:55,079
this secret here for the group manager

1607
01:07:55,079 --> 01:07:57,839
that is a secret key of the public key

1608
01:07:57,839 --> 01:08:00,599
encryption scheme and so now let's

1609
01:08:00,599 --> 01:08:03,480
assume that for example the green user

1610
01:08:03,480 --> 01:08:06,539
wants to sign a message for this she

1611
01:08:06,539 --> 01:08:09,180
takes her secret signing key and signs

1612
01:08:09,180 --> 01:08:11,400
this message and to make the signature

1613
01:08:11,400 --> 01:08:14,760
trace the ads the certificate of her

1614
01:08:14,760 --> 01:08:16,080
identity

1615
01:08:16,080 --> 01:08:18,660
uh subsequently to make the signature

1616
01:08:18,660 --> 01:08:22,500
try an anonymous she encrypts this Tuple

1617
01:08:22,500 --> 01:08:25,500
using the public key that corresponds to

1618
01:08:25,500 --> 01:08:28,080
the secret key of the group manager now

1619
01:08:28,080 --> 01:08:31,500
we have uh anonymity and traceability

1620
01:08:31,500 --> 01:08:35,460
what is missing is verifiability and for

1621
01:08:35,460 --> 01:08:37,080
this she adds a non-interactive

1622
01:08:37,080 --> 01:08:38,880
technology proof that this ciphertext

1623
01:08:38,880 --> 01:08:41,520
actually contains what it should

1624
01:08:41,520 --> 01:08:44,399
and the second aspect is how to do the

1625
01:08:44,399 --> 01:08:47,100
openings I guess it's already clear so

1626
01:08:47,100 --> 01:08:49,259
given such a signature the group manager

1627
01:08:49,259 --> 01:08:52,920
takes a decipher text and uses his

1628
01:08:52,920 --> 01:08:55,339
secret key to decrypt the cipher text

1629
01:08:55,339 --> 01:08:58,979
like this and so this is actually the

1630
01:08:58,979 --> 01:09:00,600
The crucial step because the group

1631
01:09:00,600 --> 01:09:03,420
manager is the only one who knows this

1632
01:09:03,420 --> 01:09:06,299
secret key so he is the only party that

1633
01:09:06,299 --> 01:09:08,960
actually can perform this decryption

1634
01:09:08,960 --> 01:09:13,259
process here and after the decryption

1635
01:09:13,259 --> 01:09:15,359
one simply extracts the identity of

1636
01:09:15,359 --> 01:09:17,640
designer

1637
01:09:17,640 --> 01:09:20,939
now the question is how can we make the

1638
01:09:20,939 --> 01:09:23,040
signature or this framework linearly

1639
01:09:23,040 --> 01:09:25,620
homomorphic and for the scope of this

1640
01:09:25,620 --> 01:09:27,839
talk we will only concentrate on this

1641
01:09:27,839 --> 01:09:30,660
gray area here and to make the whole

1642
01:09:30,660 --> 01:09:32,219
thing linearly homomorphic I guess it's

1643
01:09:32,219 --> 01:09:34,880
a good starting point to

1644
01:09:34,880 --> 01:09:37,439
analyze well what happens if you replace

1645
01:09:37,439 --> 01:09:39,120
all the ingredients by the ordinary

1646
01:09:39,120 --> 01:09:40,799
homographic counterpart

1647
01:09:40,799 --> 01:09:44,580
uh so at first we will use a homomorphic

1648
01:09:44,580 --> 01:09:45,839
encryption scheme for the public

1649
01:09:45,839 --> 01:09:49,020
encryption uh in our case we use algae

1650
01:09:49,020 --> 01:09:50,580
Mal but I guess other schemes would do

1651
01:09:50,580 --> 01:09:52,979
as well the important property that we

1652
01:09:52,979 --> 01:09:54,179
need is

1653
01:09:54,179 --> 01:09:56,699
given several Cipher texts and if we

1654
01:09:56,699 --> 01:09:58,860
want to compute a linear combination

1655
01:09:58,860 --> 01:10:00,960
over the cipher text then these linear

1656
01:10:00,960 --> 01:10:02,580
combinations should essentially be

1657
01:10:02,580 --> 01:10:06,239
shifted into onto the plain text level

1658
01:10:06,239 --> 01:10:09,660
meaning that given several Cipher

1659
01:10:09,660 --> 01:10:10,860
attacks and we compute a linear

1660
01:10:10,860 --> 01:10:14,060
combination then this should be equal to

1661
01:10:14,060 --> 01:10:16,800
one ciphertext that encrypts the linear

1662
01:10:16,800 --> 01:10:19,140
combinations of the plain text and in

1663
01:10:19,140 --> 01:10:20,820
our case these plain takes consist of

1664
01:10:20,820 --> 01:10:23,520
two components the first one is a

1665
01:10:23,520 --> 01:10:25,020
traditional signature scheme and of

1666
01:10:25,020 --> 01:10:26,340
course we will replace it with a

1667
01:10:26,340 --> 01:10:28,679
linearly homomorphic signature this

1668
01:10:28,679 --> 01:10:31,500
allows us to deal with those linear

1669
01:10:31,500 --> 01:10:34,040
combinations in a very natural way

1670
01:10:34,040 --> 01:10:37,679
uh but the question is how to deal with

1671
01:10:37,679 --> 01:10:41,580
this part here in the BMW framework this

1672
01:10:41,580 --> 01:10:45,540
is just any encoding of the identity and

1673
01:10:45,540 --> 01:10:48,179
so what does this mean in our context

1674
01:10:48,179 --> 01:10:50,699
um so we use Algoma encryption algemal

1675
01:10:50,699 --> 01:10:53,280
encrypts group elements at a very high

1676
01:10:53,280 --> 01:10:55,679
level we could say well these identities

1677
01:10:55,679 --> 01:10:57,659
of the users are just a sequence of

1678
01:10:57,659 --> 01:11:02,100
proof elements AKA a vector so

1679
01:11:02,100 --> 01:11:04,800
very hard on speaking on a very high

1680
01:11:04,800 --> 01:11:07,860
level what we have here is we have one

1681
01:11:07,860 --> 01:11:10,679
vector for each user and now what

1682
01:11:10,679 --> 01:11:12,780
happens if we uh

1683
01:11:12,780 --> 01:11:16,440
uh do a signature derivation for example

1684
01:11:16,440 --> 01:11:18,659
uh here let's assume that we have a

1685
01:11:18,659 --> 01:11:21,900
signature produced by user two and one

1686
01:11:21,900 --> 01:11:25,739
by user free and then this derived

1687
01:11:25,739 --> 01:11:27,659
signature does no longer have one of the

1688
01:11:27,659 --> 01:11:31,199
vectors V2 or V3 but it will have a new

1689
01:11:31,199 --> 01:11:33,120
Vector U that is a linear combination

1690
01:11:33,120 --> 01:11:37,380
over V2 and V3 meaning that Omega 1 is 0

1691
01:11:37,380 --> 01:11:39,840
in this case because there was no

1692
01:11:39,840 --> 01:11:42,540
signature of user 1 involved in this

1693
01:11:42,540 --> 01:11:45,000
derivation process

1694
01:11:45,000 --> 01:11:45,900
um

1695
01:11:45,900 --> 01:11:48,179
trace the other way around if we want to

1696
01:11:48,179 --> 01:11:49,920
open a signature then we need to take

1697
01:11:49,920 --> 01:11:53,400
this Vector U and we need to find those

1698
01:11:53,400 --> 01:11:55,860
indices I where the corresponding

1699
01:11:55,860 --> 01:11:58,320
coefficient Omega I is non-zero because

1700
01:11:58,320 --> 01:12:02,040
this means that the vector v I actually

1701
01:12:02,040 --> 01:12:04,980
contributed something to this Vector U

1702
01:12:04,980 --> 01:12:07,320
and in turn this corresponds to those

1703
01:12:07,320 --> 01:12:08,420
users

1704
01:12:08,420 --> 01:12:12,000
IE that contributed a signature to the

1705
01:12:12,000 --> 01:12:13,679
signature derivation

1706
01:12:13,679 --> 01:12:17,219
and a bit more formal we call this the

1707
01:12:17,219 --> 01:12:19,560
linear Subspace tracing problem

1708
01:12:19,560 --> 01:12:21,960
where we are given a basis B consisting

1709
01:12:21,960 --> 01:12:24,960
of vectors we want V2 until the end it

1710
01:12:24,960 --> 01:12:27,120
spends some Vector space and we are

1711
01:12:27,120 --> 01:12:30,480
given a vector uh that lies in this

1712
01:12:30,480 --> 01:12:33,900
Vector space and we would like to find

1713
01:12:33,900 --> 01:12:36,840
the set of indices I where the

1714
01:12:36,840 --> 01:12:38,640
corresponding coefficient Omega I is

1715
01:12:38,640 --> 01:12:41,760
non-zero and the intuition why we call

1716
01:12:41,760 --> 01:12:44,900
this a linear Subspace tracing is that

1717
01:12:44,900 --> 01:12:47,820
so essentially we would like to find the

1718
01:12:47,820 --> 01:12:50,880
smallest subset X of the bases such that

1719
01:12:50,880 --> 01:12:54,060
the vector U still lies in the span of

1720
01:12:54,060 --> 01:12:56,340
the subset so in some sense we would

1721
01:12:56,340 --> 01:12:59,880
like to find the smallest Subspace of

1722
01:12:59,880 --> 01:13:01,620
the full Vector space V that still

1723
01:13:01,620 --> 01:13:03,900
contains the vector U

1724
01:13:03,900 --> 01:13:07,800
and I guess a few of you you may Wonder

1725
01:13:07,800 --> 01:13:11,040
now well isn't it a trivial problem and

1726
01:13:11,040 --> 01:13:13,800
here yes it is for example we could

1727
01:13:13,800 --> 01:13:17,219
choose the vector space ACP to the N uh

1728
01:13:17,219 --> 01:13:19,620
together with the canonical basis and an

1729
01:13:19,620 --> 01:13:22,980
input Vector uh with coordinates You

1730
01:13:22,980 --> 01:13:25,679
Want U to u n we simply return those

1731
01:13:25,679 --> 01:13:30,179
indices I where UI is not not equal to

1732
01:13:30,179 --> 01:13:31,260
zero

1733
01:13:31,260 --> 01:13:34,080
and the good news here is that this

1734
01:13:34,080 --> 01:13:36,179
trivial solution when plugged into the

1735
01:13:36,179 --> 01:13:38,040
framework from the last slide will

1736
01:13:38,040 --> 01:13:39,960
indeed give us a linearly homomorphic

1737
01:13:39,960 --> 01:13:43,140
group signature and even better this

1738
01:13:43,140 --> 01:13:45,420
trivial solution is essentially optimal

1739
01:13:45,420 --> 01:13:48,420
and what I mean by that is

1740
01:13:48,420 --> 01:13:51,840
um so to have a unique tracing result we

1741
01:13:51,840 --> 01:13:54,960
essentially need that uh

1742
01:13:54,960 --> 01:13:58,320
for any Vector U the decomposition into

1743
01:13:58,320 --> 01:14:00,420
linear combination over the vectors V I

1744
01:14:00,420 --> 01:14:04,560
should be unique and uh

1745
01:14:04,560 --> 01:14:07,620
so essentially this requires that all

1746
01:14:07,620 --> 01:14:11,400
the vectors v i are linearly independent

1747
01:14:11,400 --> 01:14:13,860
and now if we want to have a scheme for

1748
01:14:13,860 --> 01:14:15,659
end users then we need n linearly

1749
01:14:15,659 --> 01:14:18,540
independent vectors so of course they

1750
01:14:18,540 --> 01:14:20,520
must have Dimension at least n and if we

1751
01:14:20,520 --> 01:14:22,020
have a look at our trivial solution and

1752
01:14:22,020 --> 01:14:24,120
this is exactly what we achieve we have

1753
01:14:24,120 --> 01:14:27,600
uh n linear the independent vectors of

1754
01:14:27,600 --> 01:14:30,179
Dimension n so in some sense we cannot

1755
01:14:30,179 --> 01:14:33,060
do better here however this solution is

1756
01:14:33,060 --> 01:14:34,739
also a bit inefficient because as I said

1757
01:14:34,739 --> 01:14:38,580
earlier these vectors V I must be

1758
01:14:38,580 --> 01:14:41,580
embedded into the signatures so at the

1759
01:14:41,580 --> 01:14:44,100
end of the day we have a signature that

1760
01:14:44,100 --> 01:14:46,020
grows linearly with the number of users

1761
01:14:46,020 --> 01:14:48,360
in our group which is probably not

1762
01:14:48,360 --> 01:14:49,860
really what we want

1763
01:14:49,860 --> 01:14:53,820
and uh for this reason we consider a

1764
01:14:53,820 --> 01:14:56,040
weaker notion of traceability where we

1765
01:14:56,040 --> 01:14:58,380
introduce an upper bound C on the

1766
01:14:58,380 --> 01:15:00,120
maximum size of collusions that we are

1767
01:15:00,120 --> 01:15:01,440
able to trace

1768
01:15:01,440 --> 01:15:02,880
and

1769
01:15:02,880 --> 01:15:03,840
um

1770
01:15:03,840 --> 01:15:05,640
so

1771
01:15:05,640 --> 01:15:07,980
specifically what we are able to

1772
01:15:07,980 --> 01:15:10,620
guarantee is that

1773
01:15:10,620 --> 01:15:12,179
um

1774
01:15:12,179 --> 01:15:15,780
we are we still never accuse an honest

1775
01:15:15,780 --> 01:15:20,159
user regardless of the size of

1776
01:15:20,159 --> 01:15:22,100
the collusion

1777
01:15:22,100 --> 01:15:25,860
however a correct opening in a sense of

1778
01:15:25,860 --> 01:15:27,780
a complete opening is only guaranteed

1779
01:15:27,780 --> 01:15:30,600
for collusions of size up to C if the

1780
01:15:30,600 --> 01:15:32,520
size of the collusion exceeds this bound

1781
01:15:32,520 --> 01:15:34,920
seed and it may happen that we do not

1782
01:15:34,920 --> 01:15:36,900
find all the Traders

1783
01:15:36,900 --> 01:15:39,600
and what does that mean for the Subspace

1784
01:15:39,600 --> 01:15:41,820
tracing problem

1785
01:15:41,820 --> 01:15:44,040
um I guess the main Insight here is that

1786
01:15:44,040 --> 01:15:46,860
this Vector U has a very specific form

1787
01:15:46,860 --> 01:15:48,540
now when writing it as a linear

1788
01:15:48,540 --> 01:15:51,179
combination over the vectors v i uh

1789
01:15:51,179 --> 01:15:52,199
because

1790
01:15:52,199 --> 01:15:54,540
now we know that

1791
01:15:54,540 --> 01:15:57,719
they're at most C non-zero coefficients

1792
01:15:57,719 --> 01:16:01,940
and correspondingly we can also relax

1793
01:16:01,940 --> 01:16:06,000
the condition on those vectors VI they

1794
01:16:06,000 --> 01:16:09,300
no longer need to be a basis meaning

1795
01:16:09,300 --> 01:16:11,400
they no longer need to be all linearly

1796
01:16:11,400 --> 01:16:14,159
independent but what we need is that

1797
01:16:14,159 --> 01:16:16,440
only linear combinations with up to C

1798
01:16:16,440 --> 01:16:19,320
non-zero coefficients should be unique

1799
01:16:19,320 --> 01:16:22,260
and this is what I mean by C linearly

1800
01:16:22,260 --> 01:16:25,860
Independence here and it turns out that

1801
01:16:25,860 --> 01:16:27,960
this is actually actually a strictly

1802
01:16:27,960 --> 01:16:31,140
weaker notion because it allows us to

1803
01:16:31,140 --> 01:16:34,140
obtain a more efficient scheme in the

1804
01:16:34,140 --> 01:16:36,420
end we are able to present a

1805
01:16:36,420 --> 01:16:38,820
construction where vectors have length C

1806
01:16:38,820 --> 01:16:41,159
Square Times log n over Epsilon where

1807
01:16:41,159 --> 01:16:43,260
Epsilon is the maximum probability that

1808
01:16:43,260 --> 01:16:47,159
the tracing will fail and for large

1809
01:16:47,159 --> 01:16:50,219
numbers and uh where n is the number of

1810
01:16:50,219 --> 01:16:52,140
users so for a large number of users

1811
01:16:52,140 --> 01:16:54,960
this is significantly better than o of n

1812
01:16:54,960 --> 01:16:57,960
what we had for the trivial solution

1813
01:16:57,960 --> 01:17:00,800
and

1814
01:17:00,840 --> 01:17:02,880
yeah so I guess my time is over so I

1815
01:17:02,880 --> 01:17:05,460
will skip the technical part here

1816
01:17:05,460 --> 01:17:09,540
and instead conclude so uh in our work

1817
01:17:09,540 --> 01:17:11,820
we Define linearly homomorphic group

1818
01:17:11,820 --> 01:17:14,580
signatures and

1819
01:17:14,580 --> 01:17:16,500
it turns out that the combination of

1820
01:17:16,500 --> 01:17:18,179
signatures created by different users

1821
01:17:18,179 --> 01:17:19,980
makes both the derivation and the

1822
01:17:19,980 --> 01:17:23,100
traceability non-trivial well it is also

1823
01:17:23,100 --> 01:17:25,380
a difficulty for anonymity but we can

1824
01:17:25,380 --> 01:17:28,020
solve this by using alcohol and by

1825
01:17:28,020 --> 01:17:31,140
adding uh encryptions of zero we can

1826
01:17:31,140 --> 01:17:33,900
re-randomize the whole thing so the real

1827
01:17:33,900 --> 01:17:36,120
challenges are derivation and

1828
01:17:36,120 --> 01:17:39,420
traceability and using our staff space

1829
01:17:39,420 --> 01:17:41,280
tracing technique

1830
01:17:41,280 --> 01:17:43,980
we are able to get somewhat short

1831
01:17:43,980 --> 01:17:45,480
signatures

1832
01:17:45,480 --> 01:17:46,980
thank you very much for your attention

1833
01:17:46,980 --> 01:17:50,580
and if you're interested this is the

1834
01:17:50,580 --> 01:17:54,440
link to our work on ePrint thank you

1835
01:17:56,460 --> 01:17:58,320
anyway do you have time for a couple of

1836
01:17:58,320 --> 01:17:59,520
questions

1837
01:17:59,520 --> 01:18:02,120
yes

1838
01:18:03,780 --> 01:18:07,739
if malicious group member wants to sign

1839
01:18:07,739 --> 01:18:12,000
a message without being traced then you

1840
01:18:12,000 --> 01:18:13,940
can collect

1841
01:18:13,940 --> 01:18:16,860
many existing signature do some random

1842
01:18:16,860 --> 01:18:18,860
linear combination sign the difference

1843
01:18:18,860 --> 01:18:22,199
and the trace the trace function will

1844
01:18:22,199 --> 01:18:24,719
output himself and all the previous

1845
01:18:24,719 --> 01:18:27,239
signers right yeah this is exactly the

1846
01:18:27,239 --> 01:18:29,400
aspect that we also discussed with the

1847
01:18:29,400 --> 01:18:32,100
reviewers and my intention on that is

1848
01:18:32,100 --> 01:18:34,260
that though I presented a simplified

1849
01:18:34,260 --> 01:18:36,480
solution or a simpler very end of

1850
01:18:36,480 --> 01:18:38,280
linearly homomorphic signatures here

1851
01:18:38,280 --> 01:18:42,540
what we have in the real world is that

1852
01:18:42,540 --> 01:18:46,199
we add text and signing uh

1853
01:18:46,199 --> 01:18:48,600
proceeds with respect to attack or a

1854
01:18:48,600 --> 01:18:50,640
label and we can only derive new

1855
01:18:50,640 --> 01:18:53,600
signatures if we have labels and

1856
01:18:53,600 --> 01:18:56,100
originally these labels were introduced

1857
01:18:56,100 --> 01:18:58,219
to

1858
01:18:58,219 --> 01:19:02,640
have more control over uh which

1859
01:19:02,640 --> 01:19:05,960
signatures can be derived so this voice

1860
01:19:05,960 --> 01:19:08,760
also in the plain linearly homomorphic

1861
01:19:08,760 --> 01:19:12,060
signature model we have these labels to

1862
01:19:12,060 --> 01:19:16,020
control what for which messages we are

1863
01:19:16,020 --> 01:19:19,199
able to derive signatures and in some

1864
01:19:19,199 --> 01:19:21,239
sense this is exactly the same problem

1865
01:19:21,239 --> 01:19:24,659
if we would not have labels there then

1866
01:19:24,659 --> 01:19:27,960
we could essentially sign every message

1867
01:19:27,960 --> 01:19:30,480
after seeing it after seeing a few

1868
01:19:30,480 --> 01:19:33,780
signatures and uh so

1869
01:19:33,780 --> 01:19:35,280
the corresponding needed we have the

1870
01:19:35,280 --> 01:19:37,080
same problem for the tracing so if we do

1871
01:19:37,080 --> 01:19:41,580
not have uh labels then after seeing a

1872
01:19:41,580 --> 01:19:45,179
view a few messages or a few signatures

1873
01:19:45,179 --> 01:19:47,100
we can essentially

1874
01:19:47,100 --> 01:19:52,140
uh yeah produce signatures with a high

1875
01:19:52,140 --> 01:19:53,760
probability of not being traced

1876
01:19:53,760 --> 01:19:56,580
therefore we add labels and these labels

1877
01:19:56,580 --> 01:19:59,699
give us some controls such that

1878
01:19:59,699 --> 01:20:01,140
um

1879
01:20:01,140 --> 01:20:04,260
then adversary hopefully will not have

1880
01:20:04,260 --> 01:20:06,600
too many signatures

1881
01:20:06,600 --> 01:20:09,960
to choose from such that exactly the

1882
01:20:09,960 --> 01:20:11,699
scenario that you described should not

1883
01:20:11,699 --> 01:20:14,178
be possible

1884
01:20:16,440 --> 01:20:19,699
okay one more questions

1885
01:20:20,400 --> 01:20:23,699
thank you very much

1886
01:20:23,699 --> 01:20:26,520
well this concludes the section this

1887
01:20:26,520 --> 01:20:31,040
session enjoy your coffee break

