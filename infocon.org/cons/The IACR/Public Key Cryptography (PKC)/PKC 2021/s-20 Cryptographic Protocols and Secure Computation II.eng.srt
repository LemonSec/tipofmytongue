1
00:00:00,799 --> 00:00:02,240
okay you're good to go have a good

2
00:00:02,240 --> 00:00:03,679
session

3
00:00:03,679 --> 00:00:06,160
uh okay thanks k and kevin uh hi

4
00:00:06,160 --> 00:00:07,680
everyone uh welcome to the

5
00:00:07,680 --> 00:00:12,000
pkc 2021 thursday session and um i'm

6
00:00:12,000 --> 00:00:13,840
going to co-chair in the session with

7
00:00:13,840 --> 00:00:15,280
akshay

8
00:00:15,280 --> 00:00:18,400
um this session is about the

9
00:00:18,400 --> 00:00:21,439
crypto crypto protocols and i

10
00:00:21,439 --> 00:00:24,240
probably as most of you know the each

11
00:00:24,240 --> 00:00:25,119
talk will have

12
00:00:25,119 --> 00:00:27,039
about 10 minutes if we have uh some

13
00:00:27,039 --> 00:00:29,599
short short time we have a short

14
00:00:29,599 --> 00:00:32,800
questions without further ado let's

15
00:00:32,800 --> 00:00:34,800
start the session the first talk is a

16
00:00:34,800 --> 00:00:36,480
flexible and efficient verifiable

17
00:00:36,480 --> 00:00:38,239
computational encrypted data

18
00:00:38,239 --> 00:00:41,040
those are alexandra ignacio dario and

19
00:00:41,040 --> 00:00:41,600
dongwoo

20
00:00:41,600 --> 00:00:45,840
i think dongwoo will be giving a talk

21
00:00:49,120 --> 00:00:51,360
so if you are around could you start

22
00:00:51,360 --> 00:00:59,840
sharing your slides

23
00:01:03,760 --> 00:01:08,320
and don't go i o around

24
00:01:08,960 --> 00:01:13,839
yes let me start okay okay

25
00:01:38,840 --> 00:01:41,840
okay

26
00:02:00,159 --> 00:02:03,840
can you see this

27
00:02:03,840 --> 00:02:06,880
uh yes yeah okay sorry for the

28
00:02:06,880 --> 00:02:10,318
slow okay hi everyone hi

29
00:02:10,318 --> 00:02:12,239
i'm donkey i will talk about flexible

30
00:02:12,239 --> 00:02:14,319
and fg verify computational encrypted

31
00:02:14,319 --> 00:02:14,959
data

32
00:02:14,959 --> 00:02:18,160
this is a joint work with alexander boyd

33
00:02:18,160 --> 00:02:22,879
ignacio cascado and dario fury

34
00:02:22,879 --> 00:02:25,360
okay let me start with the motivation of

35
00:02:25,360 --> 00:02:26,160
our work

36
00:02:26,160 --> 00:02:28,080
we will think about the outsourced

37
00:02:28,080 --> 00:02:30,560
computation where a client our sources

38
00:02:30,560 --> 00:02:32,400
data and computation to

39
00:02:32,400 --> 00:02:35,599
a possibly untrusted server in this case

40
00:02:35,599 --> 00:02:37,760
we can think of two security concerns of

41
00:02:37,760 --> 00:02:39,200
the client

42
00:02:39,200 --> 00:02:41,680
the first one is a data privacy that the

43
00:02:41,680 --> 00:02:44,800
client doesn't want to expose its data

44
00:02:44,800 --> 00:02:46,560
the second one is in computational

45
00:02:46,560 --> 00:02:48,720
integrity that the client wants to be

46
00:02:48,720 --> 00:02:50,879
guaranteed that the result given by the

47
00:02:50,879 --> 00:02:53,440
server is correct or not

48
00:02:53,440 --> 00:02:56,400
for the data privacy we can see that

49
00:02:56,400 --> 00:02:57,040
fully on

50
00:02:57,040 --> 00:02:59,280
encryption can be a solution since it

51
00:02:59,280 --> 00:03:01,120
enables the computation over

52
00:03:01,120 --> 00:03:04,400
the site text and the client can protect

53
00:03:04,400 --> 00:03:06,640
his data

54
00:03:06,640 --> 00:03:08,959
in case of computational integrity we

55
00:03:08,959 --> 00:03:10,159
can use

56
00:03:10,159 --> 00:03:12,879
verifiable computation where a server

57
00:03:12,879 --> 00:03:14,959
provides approval with

58
00:03:14,959 --> 00:03:17,440
its computation result to the client

59
00:03:17,440 --> 00:03:20,959
that the client can verify the result

60
00:03:20,959 --> 00:03:23,840
and here the natural question is if

61
00:03:23,840 --> 00:03:26,000
there is a solution for

62
00:03:26,000 --> 00:03:28,879
this both privacy and integrity which

63
00:03:28,879 --> 00:03:32,000
also provides an efficiency

64
00:03:32,000 --> 00:03:34,959
and in fact there are only a few work

65
00:03:34,959 --> 00:03:37,120
which provides the solution to this

66
00:03:37,120 --> 00:03:39,920
both privacy and integrity among them it

67
00:03:39,920 --> 00:03:41,920
will focus on the theory

68
00:03:41,920 --> 00:03:45,200
gentry and past pastors work which uses

69
00:03:45,200 --> 00:03:48,000
fully-owned encryptions to delegate

70
00:03:48,000 --> 00:03:48,799
computation

71
00:03:48,799 --> 00:03:52,239
then use verified computation on this

72
00:03:52,239 --> 00:03:54,640
site of text computation to guarantee

73
00:03:54,640 --> 00:03:56,640
the integrity

74
00:03:56,640 --> 00:03:58,879
this is quite a simple solution but the

75
00:03:58,879 --> 00:04:00,080
main question here

76
00:04:00,080 --> 00:04:02,640
is that we should design an efficient

77
00:04:02,640 --> 00:04:03,840
paper computation

78
00:04:03,840 --> 00:04:07,200
for this science text computation

79
00:04:07,200 --> 00:04:09,439
and there are a few work provide the

80
00:04:09,439 --> 00:04:10,720
solution to this

81
00:04:10,720 --> 00:04:12,959
problem and our work also provides a

82
00:04:12,959 --> 00:04:15,840
solution to this

83
00:04:15,840 --> 00:04:19,199
and you can summarize the result of our

84
00:04:19,199 --> 00:04:22,800
work as this at this slide and

85
00:04:22,800 --> 00:04:25,040
we can compare the result of ours with

86
00:04:25,040 --> 00:04:27,040
our other previous

87
00:04:27,040 --> 00:04:29,520
the main point is that we can work with

88
00:04:29,520 --> 00:04:30,479
any prime

89
00:04:30,479 --> 00:04:33,280
any fully on fingerprint modules with

90
00:04:33,280 --> 00:04:34,400
any module skew

91
00:04:34,400 --> 00:04:36,880
while the previous work can work only

92
00:04:36,880 --> 00:04:37,520
with

93
00:04:37,520 --> 00:04:41,240
the prime modulus which is about

94
00:04:41,240 --> 00:04:46,400
256 bits for 128 bit security

95
00:04:46,400 --> 00:04:48,800
for this our we introduced the new

96
00:04:48,800 --> 00:04:49,759
homework cache

97
00:04:49,759 --> 00:04:51,919
which is just a ring home vision from

98
00:04:51,919 --> 00:04:53,680
this two variate ring

99
00:04:53,680 --> 00:04:56,800
with questions from prime power modulus

100
00:04:56,800 --> 00:04:58,720
to the gallery ring

101
00:04:58,720 --> 00:05:02,880
then we apply this gkr particle over

102
00:05:02,880 --> 00:05:04,000
this string

103
00:05:04,000 --> 00:05:05,919
which can verify the computation over

104
00:05:05,919 --> 00:05:08,160
this string

105
00:05:08,160 --> 00:05:11,440
i can give the overview of our solution

106
00:05:11,440 --> 00:05:14,639
the verifier first our sources is data

107
00:05:14,639 --> 00:05:16,400
in encrypted form with some of

108
00:05:16,400 --> 00:05:18,080
encryption

109
00:05:18,080 --> 00:05:20,400
this life text can be seen as two

110
00:05:20,400 --> 00:05:22,800
variate polynomial with coefficient from

111
00:05:22,800 --> 00:05:23,280
this

112
00:05:23,280 --> 00:05:25,600
prime power module string then the

113
00:05:25,600 --> 00:05:27,919
prover gives back the result

114
00:05:27,919 --> 00:05:29,919
then instead of verifying this

115
00:05:29,919 --> 00:05:32,080
computation the verifier samples the

116
00:05:32,080 --> 00:05:34,080
whole cache which is just a ring more

117
00:05:34,080 --> 00:05:36,080
feasible from the side text space

118
00:05:36,080 --> 00:05:39,680
to the gallery then the proverb gives

119
00:05:39,680 --> 00:05:40,000
back

120
00:05:40,000 --> 00:05:43,680
the profound the skyrowing space

121
00:05:43,680 --> 00:05:45,759
then the verifier can verify this

122
00:05:45,759 --> 00:05:47,280
computation instead of

123
00:05:47,280 --> 00:05:50,080
the subtext competition here the point

124
00:05:50,080 --> 00:05:50,880
is that

125
00:05:50,880 --> 00:05:53,600
these verified computation on this ring

126
00:05:53,600 --> 00:05:54,960
is much smaller

127
00:05:54,960 --> 00:05:58,000
cost in than the computation

128
00:05:58,000 --> 00:06:01,840
or vapor computation on this large ring

129
00:06:01,840 --> 00:06:03,360
we can see the efficiency of our

130
00:06:03,360 --> 00:06:05,280
solution by seeing some example

131
00:06:05,280 --> 00:06:06,639
parameters

132
00:06:06,639 --> 00:06:09,680
here uh we can see that the cipher

133
00:06:09,680 --> 00:06:10,880
string

134
00:06:10,880 --> 00:06:14,880
has degree like this 2 to the 11 or even

135
00:06:14,880 --> 00:06:18,000
15 while the coloring which is the

136
00:06:18,000 --> 00:06:19,520
target of our verification

137
00:06:19,520 --> 00:06:21,680
is has degree much less than the

138
00:06:21,680 --> 00:06:22,960
ciphertext ring

139
00:06:22,960 --> 00:06:25,520
so we can also gain efficiency in this

140
00:06:25,520 --> 00:06:27,520
verified computation

141
00:06:27,520 --> 00:06:29,520
and we can also compare the previous

142
00:06:29,520 --> 00:06:30,560
work with ours

143
00:06:30,560 --> 00:06:33,600
in the previous work the bb scheme the

144
00:06:33,600 --> 00:06:35,039
whole encryption scheme

145
00:06:35,039 --> 00:06:38,000
should must also use the parameter with

146
00:06:38,000 --> 00:06:39,039
low cube

147
00:06:39,039 --> 00:06:42,319
bigger than 250 which also gives that

148
00:06:42,319 --> 00:06:44,400
the degree of cipher space should be

149
00:06:44,400 --> 00:06:45,520
bigger than 2

150
00:06:45,520 --> 00:06:48,720
to the 14 or more while we can use these

151
00:06:48,720 --> 00:06:50,160
small parameters

152
00:06:50,160 --> 00:06:53,199
in our scheme and yeah this

153
00:06:53,199 --> 00:06:55,919
is the end of our talk and thank you

154
00:06:55,919 --> 00:06:59,120
very much for your attention

155
00:06:59,120 --> 00:07:02,319
very nice talk thanks donal is that

156
00:07:02,319 --> 00:07:04,960
if you have any questions feel free to

157
00:07:04,960 --> 00:07:08,400
unmute yourself and ask here

158
00:07:13,680 --> 00:07:17,840
seems any question

159
00:07:17,840 --> 00:07:20,319
um since we have one one minute i have a

160
00:07:20,319 --> 00:07:21,440
very good question so

161
00:07:21,440 --> 00:07:23,919
it looks like the the nice technical

162
00:07:23,919 --> 00:07:24,880
tool of a new

163
00:07:24,880 --> 00:07:27,759
homomorphic hash right yeah do you find

164
00:07:27,759 --> 00:07:28,400
it like

165
00:07:28,400 --> 00:07:30,720
any other broader applications of this

166
00:07:30,720 --> 00:07:32,080
uh new primitive

167
00:07:32,080 --> 00:07:35,520
the primitive yeah yes

168
00:07:35,520 --> 00:07:39,039
maybe we can use this technique to

169
00:07:39,039 --> 00:07:42,560
verify some same operations

170
00:07:42,560 --> 00:07:45,199
so if we want to verify many other

171
00:07:45,199 --> 00:07:46,800
bigger polynomial

172
00:07:46,800 --> 00:07:49,199
operations on bigger polynomials then we

173
00:07:49,199 --> 00:07:51,680
can reduce this with our hash

174
00:07:51,680 --> 00:07:54,160
so we can verify that yeah i think we

175
00:07:54,160 --> 00:07:54,960
can

176
00:07:54,960 --> 00:07:58,400
use this technique in others verify

177
00:07:58,400 --> 00:07:59,520
computation over

178
00:07:59,520 --> 00:08:02,560
other things then this one

179
00:08:02,560 --> 00:08:06,400
inclusions okay okay great thanks

180
00:08:06,400 --> 00:08:10,799
uh if is there any other question

181
00:08:11,280 --> 00:08:13,360
if there's no more question let's move

182
00:08:13,360 --> 00:08:14,800
to the second

183
00:08:14,800 --> 00:08:17,360
talk our second talk will be

184
00:08:17,360 --> 00:08:18,800
transferable ecash

185
00:08:18,800 --> 00:08:20,960
a cleaner model and the first practical

186
00:08:20,960 --> 00:08:22,400
instantiation

187
00:08:22,400 --> 00:08:26,000
from bausa gurg and chen

188
00:08:26,000 --> 00:08:30,160
i think balzaza will be giving the talk

189
00:08:30,160 --> 00:08:34,640
yes i'm here do you hear me

190
00:08:34,640 --> 00:08:41,838
yeah yeah can you share your skirt yeah

191
00:08:44,880 --> 00:08:48,720
do you see is it enough good

192
00:08:48,720 --> 00:08:50,959
yes

193
00:08:51,920 --> 00:08:54,430
okay so

194
00:08:54,430 --> 00:08:55,920
[Music]

195
00:08:55,920 --> 00:08:57,760
hello everyone i'm balthazar boyer and

196
00:08:57,760 --> 00:08:59,600
i'm happy to present you a

197
00:08:59,600 --> 00:09:01,920
transferable ecash a cleaner model and

198
00:09:01,920 --> 00:09:03,760
the first practical instantiation a

199
00:09:03,760 --> 00:09:04,640
joint work with

200
00:09:04,640 --> 00:09:07,760
georg foxbower and chen can

201
00:09:07,760 --> 00:09:10,000
so first i would like to speak quickly

202
00:09:10,000 --> 00:09:12,000
about the history of ecash

203
00:09:12,000 --> 00:09:15,040
so ecash is a basic payment system with

204
00:09:15,040 --> 00:09:18,240
three types of entities a bank

205
00:09:18,240 --> 00:09:20,800
which is authorized to issue a coin to a

206
00:09:20,800 --> 00:09:21,519
user

207
00:09:21,519 --> 00:09:24,240
yeah alice who is allowed to spend this

208
00:09:24,240 --> 00:09:24,640
coin

209
00:09:24,640 --> 00:09:28,080
at the shop which can thus deposit this

210
00:09:28,080 --> 00:09:28,560
coin

211
00:09:28,560 --> 00:09:31,600
at the bank it is very easy

212
00:09:31,600 --> 00:09:33,519
to make such a system with basic

213
00:09:33,519 --> 00:09:35,360
cryptographic functionalities

214
00:09:35,360 --> 00:09:39,440
such as signatures but the goal here

215
00:09:39,440 --> 00:09:41,519
is also to protect the privacy of the

216
00:09:41,519 --> 00:09:43,200
users and

217
00:09:43,200 --> 00:09:47,360
the merchants against a curious bank

218
00:09:47,360 --> 00:09:49,519
and to be more precise about what does a

219
00:09:49,519 --> 00:09:51,680
transaction anonymity mean

220
00:09:51,680 --> 00:09:53,920
in the model of charm the inventor of

221
00:09:53,920 --> 00:09:55,200
the cash

222
00:09:55,200 --> 00:09:57,600
with his definitions we have the

223
00:09:57,600 --> 00:09:58,720
guarantee that

224
00:09:58,720 --> 00:10:02,240
the bank can't identify the kind issued

225
00:10:02,240 --> 00:10:05,680
as the kind received it means that the

226
00:10:05,680 --> 00:10:06,079
bank

227
00:10:06,079 --> 00:10:09,200
cannot link alice and the merchant

228
00:10:09,200 --> 00:10:11,279
as it is written here chum has not only

229
00:10:11,279 --> 00:10:13,279
defined the main oceans

230
00:10:13,279 --> 00:10:16,079
but has also built a first instantiation

231
00:10:16,079 --> 00:10:18,720
in the 80s

232
00:10:18,720 --> 00:10:22,480
the main drawback of

233
00:10:22,480 --> 00:10:25,440
such a system in the offline context is

234
00:10:25,440 --> 00:10:27,360
a non-transferability

235
00:10:27,360 --> 00:10:29,839
indeed the merchant cannot directly

236
00:10:29,839 --> 00:10:31,200
spend the coin received

237
00:10:31,200 --> 00:10:34,480
to another merchant

238
00:10:34,800 --> 00:10:37,040
that's why more recently researchers

239
00:10:37,040 --> 00:10:39,360
have developed more powerful schemes

240
00:10:39,360 --> 00:10:43,040
which merge the user merchant statuses

241
00:10:43,040 --> 00:10:45,200
by authorizing an arbitrary number of

242
00:10:45,200 --> 00:10:47,360
transfers without any communication with

243
00:10:47,360 --> 00:10:49,200
the bank

244
00:10:49,200 --> 00:10:51,040
and of course we would like to still

245
00:10:51,040 --> 00:10:53,680
have anonymity guarantees

246
00:10:53,680 --> 00:10:56,480
i will not details all the numerous

247
00:10:56,480 --> 00:10:57,519
publications

248
00:10:57,519 --> 00:10:59,519
about transferable cash but the

249
00:10:59,519 --> 00:11:01,880
important thing to know is that in

250
00:11:01,880 --> 00:11:05,920
2015 baldimet chs foxboro and coldweiss

251
00:11:05,920 --> 00:11:07,680
proposed the first polynomial time

252
00:11:07,680 --> 00:11:08,399
scheme

253
00:11:08,399 --> 00:11:10,800
which verifies satisfying anonymity

254
00:11:10,800 --> 00:11:13,359
properties

255
00:11:13,440 --> 00:11:15,279
now i would like to speak about our

256
00:11:15,279 --> 00:11:16,560
contributions

257
00:11:16,560 --> 00:11:20,320
by comparing it to the work of 2015.

258
00:11:20,320 --> 00:11:22,320
first we have rewritten the anonymity

259
00:11:22,320 --> 00:11:23,600
definitions

260
00:11:23,600 --> 00:11:25,760
then we have added missing economical

261
00:11:25,760 --> 00:11:26,959
properties

262
00:11:26,959 --> 00:11:28,959
and finally we have built a more

263
00:11:28,959 --> 00:11:32,160
efficient construction

264
00:11:32,160 --> 00:11:34,000
about the anonymity definition i would

265
00:11:34,000 --> 00:11:35,279
like to introduce

266
00:11:35,279 --> 00:11:36,880
a notion which is specific to

267
00:11:36,880 --> 00:11:38,959
transferable cache

268
00:11:38,959 --> 00:11:41,760
contrary to the standard model of cache

269
00:11:41,760 --> 00:11:42,160
in

270
00:11:42,160 --> 00:11:44,720
transferable cache a user can receive a

271
00:11:44,720 --> 00:11:47,360
coin he has previously owned

272
00:11:47,360 --> 00:11:50,480
then we have to define a feature which

273
00:11:50,480 --> 00:11:51,120
protects

274
00:11:51,120 --> 00:11:54,079
us against such a curious user for

275
00:11:54,079 --> 00:11:55,600
example here

276
00:11:55,600 --> 00:11:57,760
we do not want to authorize a list to

277
00:11:57,760 --> 00:11:58,800
link

278
00:11:58,800 --> 00:12:00,959
the current transfer to charlie and the

279
00:12:00,959 --> 00:12:01,920
coin received

280
00:12:01,920 --> 00:12:05,440
from the store we call this property

281
00:12:05,440 --> 00:12:08,480
coin transparency

282
00:12:08,480 --> 00:12:11,279
now let's explain briefly how our scheme

283
00:12:11,279 --> 00:12:12,320
work

284
00:12:12,320 --> 00:12:15,200
so suppose alice wants to withdraw coins

285
00:12:15,200 --> 00:12:16,160
and

286
00:12:16,160 --> 00:12:19,440
she would generate a serial number

287
00:12:19,440 --> 00:12:22,639
and ask the bank for a signature on it

288
00:12:22,639 --> 00:12:25,920
and if bob wants to receive

289
00:12:25,920 --> 00:12:29,360
this coin he should also generate

290
00:12:29,360 --> 00:12:32,959
a serial number sn1 which will become a

291
00:12:32,959 --> 00:12:34,399
part of the coin

292
00:12:34,399 --> 00:12:36,880
and a list to confirm the transfer will

293
00:12:36,880 --> 00:12:37,440
create

294
00:12:37,440 --> 00:12:40,959
a tag related to both serial numbers

295
00:12:40,959 --> 00:12:43,839
and which encodes identity and will be

296
00:12:43,839 --> 00:12:45,360
required

297
00:12:45,360 --> 00:12:49,440
to address so-called double spendings

298
00:12:49,440 --> 00:12:51,519
and bob will do the same with charlie

299
00:12:51,519 --> 00:12:54,880
for the next transaction

300
00:12:55,040 --> 00:12:57,839
now let's consider alice once double

301
00:12:57,839 --> 00:12:58,959
span her coin

302
00:12:58,959 --> 00:13:02,639
to bobet then bobet will generate a new

303
00:13:02,639 --> 00:13:03,600
serial number

304
00:13:03,600 --> 00:13:07,040
sn1prime and alice has to create

305
00:13:07,040 --> 00:13:10,240
another tag t1 prime that links

306
00:13:10,240 --> 00:13:12,880
her already used serial number sn4 with

307
00:13:12,880 --> 00:13:13,519
a new

308
00:13:13,519 --> 00:13:17,600
one of bobet sn1 prime

309
00:13:18,800 --> 00:13:21,920
and if we consider that both coins

310
00:13:21,920 --> 00:13:24,959
are deposited at the bank

311
00:13:24,959 --> 00:13:28,320
then by noticing twice the same initial

312
00:13:28,320 --> 00:13:29,120
three and

313
00:13:29,120 --> 00:13:32,160
serial number the bank will detect the

314
00:13:32,160 --> 00:13:33,760
fraud

315
00:13:33,760 --> 00:13:37,680
and by the property of the tags

316
00:13:37,680 --> 00:13:39,920
two tags for the same initial serial

317
00:13:39,920 --> 00:13:41,760
number

318
00:13:41,760 --> 00:13:46,560
leak the identity of the double standard

319
00:13:47,760 --> 00:13:51,360
here alice so now a good question is

320
00:13:51,360 --> 00:13:55,120
how to make such a system anonymous

321
00:13:55,120 --> 00:13:58,160
first by using a blind signature

322
00:13:58,160 --> 00:13:59,920
we guarantee that the bank can't

323
00:13:59,920 --> 00:14:02,959
organize an issued kind

324
00:14:02,959 --> 00:14:07,359
then we have to modify the scheme

325
00:14:07,519 --> 00:14:09,680
to achieve the previously defined coin

326
00:14:09,680 --> 00:14:10,959
transparency nation

327
00:14:10,959 --> 00:14:13,760
indeed since the coin contains the

328
00:14:13,760 --> 00:14:14,720
serial numbers

329
00:14:14,720 --> 00:14:16,720
alice could easily recognize account

330
00:14:16,720 --> 00:14:18,399
when she received

331
00:14:18,399 --> 00:14:21,040
it again so we will hide the serial

332
00:14:21,040 --> 00:14:22,000
number by using

333
00:14:22,000 --> 00:14:25,680
commitments to do it and give zero

334
00:14:25,680 --> 00:14:27,360
knowledge proofs

335
00:14:27,360 --> 00:14:31,839
that the committed values are correct

336
00:14:33,040 --> 00:14:35,760
for alice not to be able to recognize

337
00:14:35,760 --> 00:14:37,600
the commitments we will randomize the

338
00:14:37,600 --> 00:14:39,360
commitments and proofs

339
00:14:39,360 --> 00:14:42,959
which can be done for grocery proofs

340
00:14:42,959 --> 00:14:45,279
however now the bank cannot check for

341
00:14:45,279 --> 00:14:46,800
double spendings

342
00:14:46,800 --> 00:14:49,920
we will therefore include encryptions

343
00:14:49,920 --> 00:14:53,680
of serial numbers and tags

344
00:14:53,680 --> 00:14:57,360
which the bank can decrypt

345
00:14:57,360 --> 00:15:00,480
uh of course this cypher text

346
00:15:00,480 --> 00:15:03,760
must also be randomizable so we will

347
00:15:03,760 --> 00:15:07,680
reconstruct a new complexity

348
00:15:08,380 --> 00:15:09,760
[Music]

349
00:15:09,760 --> 00:15:13,680
cca encryption scheme

350
00:15:13,680 --> 00:15:16,720
and yeah and and

351
00:15:16,720 --> 00:15:18,800
yeah and now i would like to thank you

352
00:15:18,800 --> 00:15:20,320
for your attention

353
00:15:20,320 --> 00:15:22,880
and if you have questions i would be

354
00:15:22,880 --> 00:15:23,760
happy

355
00:15:23,760 --> 00:15:27,600
to answer them thanks for the nice talk

356
00:15:27,600 --> 00:15:31,600
uh any questions from an audience

357
00:15:32,000 --> 00:15:35,759
just feel free to unmute yourself

358
00:15:37,440 --> 00:15:39,759
yeah so you mentioned that you model

359
00:15:39,759 --> 00:15:41,680
some economic considerations so

360
00:15:41,680 --> 00:15:45,199
what what what are those

361
00:15:46,560 --> 00:15:50,160
okay so

362
00:15:50,160 --> 00:15:53,360
the in previous model

363
00:15:53,360 --> 00:15:58,639
if someone spend a coin

364
00:15:58,639 --> 00:16:02,959
honestly received we

365
00:16:02,959 --> 00:16:07,279
we can imagine he can break the coin

366
00:16:07,279 --> 00:16:10,880
then he didn't

367
00:16:10,880 --> 00:16:12,959
create new money but he breaks the coin

368
00:16:12,959 --> 00:16:15,199
and he transfer it to someone

369
00:16:15,199 --> 00:16:19,360
and the receiver

370
00:16:19,360 --> 00:16:22,720
has no guarantee he can detect the fact

371
00:16:22,720 --> 00:16:26,000
the coin is broken

372
00:16:26,800 --> 00:16:31,839
so this we it's this type of attack

373
00:16:31,839 --> 00:16:34,839
was not considered in the previous

374
00:16:34,839 --> 00:16:36,480
scheme

375
00:16:36,480 --> 00:16:39,680
so but it's an important

376
00:16:39,680 --> 00:16:42,639
property because it guarantees to a

377
00:16:42,639 --> 00:16:45,600
receiver that a

378
00:16:45,839 --> 00:16:48,160
transferred coin can be transferred to

379
00:16:48,160 --> 00:16:50,480
another honest user

380
00:16:50,480 --> 00:16:54,079
and has not been broken

381
00:16:56,160 --> 00:17:00,160
i don't know if it answers to me

382
00:17:00,160 --> 00:17:02,320
what is what does it mean to be broken

383
00:17:02,320 --> 00:17:03,199
exactly

384
00:17:03,199 --> 00:17:06,400
uh no there is no double spending

385
00:17:06,400 --> 00:17:09,839
because in this case the

386
00:17:09,839 --> 00:17:12,959
the the adversary

387
00:17:12,959 --> 00:17:15,679
does not create money it just break

388
00:17:15,679 --> 00:17:17,599
money

389
00:17:17,599 --> 00:17:20,640
but it's

390
00:17:20,640 --> 00:17:22,559
theoretically it's theoretically

391
00:17:22,559 --> 00:17:23,839
possible

392
00:17:23,839 --> 00:17:27,520
that he that he

393
00:17:27,520 --> 00:17:30,799
convinced you to

394
00:17:30,799 --> 00:17:34,080
the coin is valid but after you accept

395
00:17:34,080 --> 00:17:35,840
you have accepted the coin

396
00:17:35,840 --> 00:17:39,600
you cannot transfer it again

397
00:17:39,600 --> 00:17:43,280
but it may be as yeah it could seem

398
00:17:43,280 --> 00:17:45,039
very weird because he has not created

399
00:17:45,039 --> 00:17:46,720
money but if

400
00:17:46,720 --> 00:17:49,520
he's heavily he can just wants to

401
00:17:49,520 --> 00:17:51,360
destroy

402
00:17:51,360 --> 00:17:54,640
your money you have accepted

403
00:17:54,640 --> 00:17:59,360
and yeah thank

404
00:17:59,520 --> 00:18:01,840
uh you also one quick one question in

405
00:18:01,840 --> 00:18:02,559
zulip

406
00:18:02,559 --> 00:18:07,360
uh where do the serial numbers come from

407
00:18:08,320 --> 00:18:11,440
uh you mean as a primitive

408
00:18:11,440 --> 00:18:14,880
you mean the history of

409
00:18:15,039 --> 00:18:17,840
the syrian yeah that's just a very

410
00:18:17,840 --> 00:18:19,039
simple question

411
00:18:19,039 --> 00:18:21,600
in the zulu or maybe if the answer is

412
00:18:21,600 --> 00:18:23,760
pretty longer than you you may

413
00:18:23,760 --> 00:18:26,799
answer directly at zulip but guarantees

414
00:18:26,799 --> 00:18:29,840
their uniqueness

415
00:18:30,400 --> 00:18:33,280
so so the serial numbers are created

416
00:18:33,280 --> 00:18:33,840
with a

417
00:18:33,840 --> 00:18:37,679
secret key of owner of users

418
00:18:37,679 --> 00:18:43,840
and yeah he

419
00:18:51,760 --> 00:18:54,559
two different users can't have the same

420
00:18:54,559 --> 00:18:57,840
serial numbers

421
00:18:58,320 --> 00:19:00,080
that's a very good answer but maybe you

422
00:19:00,080 --> 00:19:03,600
can chat more in the loop

423
00:19:03,840 --> 00:19:07,039
okay i i will check

424
00:19:07,039 --> 00:19:10,000
thanks again and let's move to the next

425
00:19:10,000 --> 00:19:10,960
talk

426
00:19:10,960 --> 00:19:13,760
next one is a beta biometric enabled

427
00:19:13,760 --> 00:19:15,360
threshold authentication

428
00:19:15,360 --> 00:19:18,400
from zhonjang uh say christina

429
00:19:18,400 --> 00:19:21,600
payman and uh

430
00:19:21,600 --> 00:19:25,039
zika i think sakura sheena will be given

431
00:19:25,039 --> 00:19:27,360
the talk

432
00:19:31,760 --> 00:19:36,480
about maybe you should stop sharing your

433
00:19:36,840 --> 00:19:39,840
screen

434
00:19:42,240 --> 00:19:45,919
uh i'm just trying to share my screen

435
00:19:50,840 --> 00:19:53,840
sure

436
00:20:10,720 --> 00:20:13,919
uh do you see my screen uh yes can i do

437
00:20:13,919 --> 00:20:15,679
the presentation mode

438
00:20:15,679 --> 00:20:19,520
yeah yeah good enough

439
00:20:19,520 --> 00:20:24,320
um so thanks for the introduction and uh

440
00:20:26,480 --> 00:20:28,080
yeah uh my name is sai krishna i'm going

441
00:20:28,080 --> 00:20:29,919
to be talking about a paper

442
00:20:29,919 --> 00:20:32,320
titled beta which is an acronym for

443
00:20:32,320 --> 00:20:33,679
biometric enabled threshold

444
00:20:33,679 --> 00:20:34,799
authentication

445
00:20:34,799 --> 00:20:36,480
um this is a joint work with shashank

446
00:20:36,480 --> 00:20:39,840
payment pratiyan sugar

447
00:20:40,320 --> 00:20:43,200
so first let's

448
00:20:43,840 --> 00:20:45,280
let's look at how traditionally

449
00:20:45,280 --> 00:20:47,360
biometric authentication

450
00:20:47,360 --> 00:20:51,120
works you have an enrollment phase

451
00:20:51,120 --> 00:20:53,679
where the user stores and draws their

452
00:20:53,679 --> 00:20:55,360
biometric template and stores it on a

453
00:20:55,360 --> 00:20:56,320
server

454
00:20:56,320 --> 00:20:58,480
and then in an online phase when the

455
00:20:58,480 --> 00:21:00,320
user wants to authenticate themselves

456
00:21:00,320 --> 00:21:02,240
they enter the new biometric measurement

457
00:21:02,240 --> 00:21:04,000
onto their mobile phone

458
00:21:04,000 --> 00:21:05,679
um for example and then the phone

459
00:21:05,679 --> 00:21:07,360
transfers this measurement over to the

460
00:21:07,360 --> 00:21:08,559
server that stores

461
00:21:08,559 --> 00:21:11,520
all the um biometric templates in the

462
00:21:11,520 --> 00:21:12,559
enrollment phase

463
00:21:12,559 --> 00:21:15,360
the server privately checks whether the

464
00:21:15,360 --> 00:21:16,799
entered biometric measurement

465
00:21:16,799 --> 00:21:19,039
matches the user's original template or

466
00:21:19,039 --> 00:21:23,360
not and if so it authenticates the user

467
00:21:24,240 --> 00:21:26,240
as as we all know biometrics provide

468
00:21:26,240 --> 00:21:28,000
better usability than passwords

469
00:21:28,000 --> 00:21:30,640
but unfortunately a server-side breach

470
00:21:30,640 --> 00:21:32,640
of biometrics is much more damaging

471
00:21:32,640 --> 00:21:34,720
than in the case of passwords because

472
00:21:34,720 --> 00:21:36,000
you cannot really change them that

473
00:21:36,000 --> 00:21:38,400
easily

474
00:21:38,720 --> 00:21:41,120
the fido alliance is a recently uh

475
00:21:41,120 --> 00:21:43,039
popular industry-wide standard

476
00:21:43,039 --> 00:21:45,360
for replacing this traditional solution

477
00:21:45,360 --> 00:21:47,039
to biometric authentication

478
00:21:47,039 --> 00:21:49,360
and the way it works is as follows now

479
00:21:49,360 --> 00:21:50,799
in the enrollment phase

480
00:21:50,799 --> 00:21:52,240
when the user enters the biometric

481
00:21:52,240 --> 00:21:54,240
template it's no longer sent over to a

482
00:21:54,240 --> 00:21:54,960
server

483
00:21:54,960 --> 00:21:56,640
but instead the biometric template is

484
00:21:56,640 --> 00:22:00,240
stored locally on the user's device

485
00:22:00,240 --> 00:22:02,720
the device then generates a secret a

486
00:22:02,720 --> 00:22:04,559
signing key and a verification key

487
00:22:04,559 --> 00:22:06,240
and only sends over this verification

488
00:22:06,240 --> 00:22:07,919
key to the server

489
00:22:07,919 --> 00:22:10,720
storing the secret key locally and then

490
00:22:10,720 --> 00:22:13,039
in an online phase

491
00:22:13,039 --> 00:22:14,400
when the user wants to authenticate

492
00:22:14,400 --> 00:22:16,640
themselves they enter the biometric

493
00:22:16,640 --> 00:22:17,440
measurement

494
00:22:17,440 --> 00:22:19,919
the phone locally checks whether the

495
00:22:19,919 --> 00:22:21,440
entered measurement matches the template

496
00:22:21,440 --> 00:22:22,400
or not

497
00:22:22,400 --> 00:22:24,880
and if the match is successful the phone

498
00:22:24,880 --> 00:22:26,960
is able to unlock the signing key

499
00:22:26,960 --> 00:22:29,039
and generates a signature on a

500
00:22:29,039 --> 00:22:31,200
server-generated challenge

501
00:22:31,200 --> 00:22:34,240
to prove to the server that the user was

502
00:22:34,240 --> 00:22:35,440
able to correctly authenticate

503
00:22:35,440 --> 00:22:37,120
themselves

504
00:22:37,120 --> 00:22:40,400
okay while this solves the problem that

505
00:22:40,400 --> 00:22:42,240
uh the server doesn't need to store

506
00:22:42,240 --> 00:22:43,919
every user's biometric template

507
00:22:43,919 --> 00:22:45,280
there are still a couple of concerns

508
00:22:45,280 --> 00:22:47,440
here the first is that now naturally

509
00:22:47,440 --> 00:22:49,120
once again the phone is a single point

510
00:22:49,120 --> 00:22:50,240
of failure

511
00:22:50,240 --> 00:22:51,760
and anybody who's able to break into the

512
00:22:51,760 --> 00:22:56,320
phone can steal the users by metric

513
00:22:56,320 --> 00:22:57,840
and then in order for the user to

514
00:22:57,840 --> 00:22:59,120
authenticate themselves they need to

515
00:22:59,120 --> 00:22:59,440
take

516
00:22:59,440 --> 00:23:02,400
care on the same device every time along

517
00:23:02,400 --> 00:23:05,039
with themselves

518
00:23:05,520 --> 00:23:07,440
in this work our idea is to propose a

519
00:23:07,440 --> 00:23:08,799
new notion to

520
00:23:08,799 --> 00:23:12,080
distribute fido and we introduce a new

521
00:23:12,080 --> 00:23:14,159
primitive called a fuzzy threshold

522
00:23:14,159 --> 00:23:16,799
tokenizer which works as follows in the

523
00:23:16,799 --> 00:23:18,320
enrollment phase when the user enters

524
00:23:18,320 --> 00:23:19,760
their biometric template

525
00:23:19,760 --> 00:23:22,480
instead of storing it entirely on this

526
00:23:22,480 --> 00:23:23,679
single device

527
00:23:23,679 --> 00:23:25,440
the idea is we want to secret share this

528
00:23:25,440 --> 00:23:27,600
biometric template and also the signing

529
00:23:27,600 --> 00:23:28,000
key

530
00:23:28,000 --> 00:23:30,240
amongst a set of devices that the user

531
00:23:30,240 --> 00:23:31,200
owns

532
00:23:31,200 --> 00:23:33,600
so the phone now generates different

533
00:23:33,600 --> 00:23:35,840
shares and sends across each share to

534
00:23:35,840 --> 00:23:39,200
one device that the user owns

535
00:23:39,200 --> 00:23:40,799
and then of course sends the public the

536
00:23:40,799 --> 00:23:44,158
verification key to the server

537
00:23:44,320 --> 00:23:45,760
you could also imagine a setting where

538
00:23:45,760 --> 00:23:47,679
each of these different devices

539
00:23:47,679 --> 00:23:49,279
are not necessarily the user owned

540
00:23:49,279 --> 00:23:51,039
devices but it could also be some

541
00:23:51,039 --> 00:23:52,880
multiple servers that are not controlled

542
00:23:52,880 --> 00:23:54,480
by the user

543
00:23:54,480 --> 00:23:57,039
depending on the application scenario

544
00:23:57,039 --> 00:23:58,320
and then what happens in the online

545
00:23:58,320 --> 00:23:59,919
phase is that now when the user enters

546
00:23:59,919 --> 00:24:01,360
the biometric measurement

547
00:24:01,360 --> 00:24:03,760
instead of the phone locally checking

548
00:24:03,760 --> 00:24:05,600
the measurement

549
00:24:05,600 --> 00:24:08,640
with the template the phone now runs an

550
00:24:08,640 --> 00:24:09,919
mpc protocol

551
00:24:09,919 --> 00:24:12,960
interacting with various different other

552
00:24:12,960 --> 00:24:13,840
devices that

553
00:24:13,840 --> 00:24:16,159
that whole secret shares and this

554
00:24:16,159 --> 00:24:17,760
protocol checks whether the entered

555
00:24:17,760 --> 00:24:18,480
measurement

556
00:24:18,480 --> 00:24:21,120
matches the original template or not and

557
00:24:21,120 --> 00:24:22,480
if indeed there was a match

558
00:24:22,480 --> 00:24:24,559
the protocol also generates a signature

559
00:24:24,559 --> 00:24:26,799
on the server generated challenge

560
00:24:26,799 --> 00:24:30,320
before sending it along to the server

561
00:24:31,279 --> 00:24:33,919
and um

562
00:24:34,640 --> 00:24:37,440
and how do we leverage the threshold

563
00:24:37,440 --> 00:24:38,159
structure

564
00:24:38,159 --> 00:24:40,400
and what is the communication pattern in

565
00:24:40,400 --> 00:24:42,559
such a primitive

566
00:24:42,559 --> 00:24:46,080
the idea is that now in any

567
00:24:46,080 --> 00:24:47,679
authentication session in the online

568
00:24:47,679 --> 00:24:49,919
phase we want the user to be able to

569
00:24:49,919 --> 00:24:51,840
involve only some threshold number of

570
00:24:51,840 --> 00:24:53,520
devices and not necessarily all the

571
00:24:53,520 --> 00:24:55,120
devices that store

572
00:24:55,120 --> 00:24:57,679
that hold one share of the key and the

573
00:24:57,679 --> 00:24:59,840
template

574
00:24:59,840 --> 00:25:02,080
we don't want we don't want to require

575
00:25:02,080 --> 00:25:03,520
all these devices to

576
00:25:03,520 --> 00:25:05,120
be able to talk to each other in

577
00:25:05,120 --> 00:25:06,960
particular we want

578
00:25:06,960 --> 00:25:09,120
we want a communication pattern where

579
00:25:09,120 --> 00:25:10,880
all the communication is routed only

580
00:25:10,880 --> 00:25:12,640
through the initiating device

581
00:25:12,640 --> 00:25:14,400
in this case in this diagram the phone

582
00:25:14,400 --> 00:25:16,799
out here

583
00:25:17,200 --> 00:25:19,039
and finally we don't want the user to be

584
00:25:19,039 --> 00:25:20,240
required

585
00:25:20,240 --> 00:25:23,039
to every time login or authenticate

586
00:25:23,039 --> 00:25:24,880
themselves only using the same device in

587
00:25:24,880 --> 00:25:25,520
particular

588
00:25:25,520 --> 00:25:27,840
any of these devices that hold one share

589
00:25:27,840 --> 00:25:29,600
of the template and the signing key

590
00:25:29,600 --> 00:25:31,840
could be treated as the initiator onto

591
00:25:31,840 --> 00:25:34,159
which the new measurement is in

592
00:25:34,159 --> 00:25:37,520
is and turn into this way

593
00:25:37,520 --> 00:25:40,240
we saw one concern that we had earlier

594
00:25:40,240 --> 00:25:41,679
where the same device needs to be used

595
00:25:41,679 --> 00:25:42,320
every time

596
00:25:42,320 --> 00:25:45,440
in the authentication phase

597
00:25:45,440 --> 00:25:48,720
so this is briefly the description of

598
00:25:48,720 --> 00:25:49,679
the perimeter

599
00:25:49,679 --> 00:25:52,080
and let's look at what are the goals or

600
00:25:52,080 --> 00:25:53,679
the security goals we would want out of

601
00:25:53,679 --> 00:25:55,440
such a primitive

602
00:25:55,440 --> 00:25:56,799
suppose we consider the malicious

603
00:25:56,799 --> 00:25:58,720
adversary that corrupts a set of devices

604
00:25:58,720 --> 00:26:01,520
maybe less than t

605
00:26:01,679 --> 00:26:03,200
the first requirement is that we want

606
00:26:03,200 --> 00:26:05,520
privacy of the biometric template

607
00:26:05,520 --> 00:26:08,159
that was entered in the enrollment phase

608
00:26:08,159 --> 00:26:09,840
and then naturally we also want privacy

609
00:26:09,840 --> 00:26:11,360
of the biometric measurement that was

610
00:26:11,360 --> 00:26:13,279
entered in the authentication phase

611
00:26:13,279 --> 00:26:15,120
so no single device should be able to

612
00:26:15,120 --> 00:26:17,039
learn any information about

613
00:26:17,039 --> 00:26:20,080
either of these values and then we want

614
00:26:20,080 --> 00:26:21,120
unforgivability

615
00:26:21,120 --> 00:26:22,960
in this context that means that an

616
00:26:22,960 --> 00:26:24,640
adversity should not be able to generate

617
00:26:24,640 --> 00:26:25,840
a valid signature

618
00:26:25,840 --> 00:26:28,240
without actually running the protocol on

619
00:26:28,240 --> 00:26:29,840
a valid measurement

620
00:26:29,840 --> 00:26:31,520
what do i mean by a valid measurement it

621
00:26:31,520 --> 00:26:32,960
means that the measurement

622
00:26:32,960 --> 00:26:35,200
that that is used in the online phase

623
00:26:35,200 --> 00:26:36,640
should match the template that was

624
00:26:36,640 --> 00:26:39,600
stored in the enrollment phase

625
00:26:39,600 --> 00:26:42,080
moreover we also require that in any run

626
00:26:42,080 --> 00:26:43,200
of the session

627
00:26:43,200 --> 00:26:44,880
no more than a single signature should

628
00:26:44,880 --> 00:26:46,720
be generated by the adversary

629
00:26:46,720 --> 00:26:48,000
so if you want to generate two

630
00:26:48,000 --> 00:26:50,320
signatures you should necessarily run

631
00:26:50,320 --> 00:26:52,080
two sessions using two valid

632
00:26:52,080 --> 00:26:56,080
measurements maybe the same one also

633
00:26:57,440 --> 00:26:59,120
and briefly the results we obtain is

634
00:26:59,120 --> 00:27:01,279
that we we have a new primitive

635
00:27:01,279 --> 00:27:03,360
for threshold biometric authentication

636
00:27:03,360 --> 00:27:05,200
we provide a formal security model with

637
00:27:05,200 --> 00:27:06,559
uc security

638
00:27:06,559 --> 00:27:09,200
and we give three protocols with various

639
00:27:09,200 --> 00:27:10,720
trade-offs

640
00:27:10,720 --> 00:27:12,559
the first protocol works for any number

641
00:27:12,559 --> 00:27:14,080
of parties with any

642
00:27:14,080 --> 00:27:16,480
corruption threshold it's a feasibility

643
00:27:16,480 --> 00:27:18,480
result based on tour on npc

644
00:27:18,480 --> 00:27:19,760
the second protocol is also a

645
00:27:19,760 --> 00:27:21,440
feasibility result and this one is based

646
00:27:21,440 --> 00:27:23,200
on threshold fxe

647
00:27:23,200 --> 00:27:24,640
both of these protocols work for any

648
00:27:24,640 --> 00:27:27,120
distance metric uh by distance metric i

649
00:27:27,120 --> 00:27:28,960
mean that the biometric matching

650
00:27:28,960 --> 00:27:33,039
mechanism is not tied to any single uh

651
00:27:33,039 --> 00:27:36,159
way of matching to biometrics the third

652
00:27:36,159 --> 00:27:38,080
protocol works for the notions

653
00:27:38,080 --> 00:27:39,919
called cosine similarity or euclidean

654
00:27:39,919 --> 00:27:41,600
distance both of which are popular

655
00:27:41,600 --> 00:27:43,279
metrics for fingerprint and face shield

656
00:27:43,279 --> 00:27:44,640
recognition

657
00:27:44,640 --> 00:27:47,200
uh this protocol is uh is a concretely

658
00:27:47,200 --> 00:27:48,159
efficient one

659
00:27:48,159 --> 00:27:50,399
it's based on prior encryption uh but

660
00:27:50,399 --> 00:27:51,760
unlike the first two protocols this

661
00:27:51,760 --> 00:27:53,360
works for the most specific setting

662
00:27:53,360 --> 00:27:53,919
where

663
00:27:53,919 --> 00:27:55,679
the number of the threshold is only

664
00:27:55,679 --> 00:27:57,840
three and the adversary can corrupt at

665
00:27:57,840 --> 00:28:00,480
most one of the three devices

666
00:28:00,480 --> 00:28:02,799
um and i'd like to end here thank you

667
00:28:02,799 --> 00:28:04,799
for listening

668
00:28:04,799 --> 00:28:07,440
thanks for the presentation uh do you

669
00:28:07,440 --> 00:28:08,480
have any

670
00:28:08,480 --> 00:28:10,960
quick question we have like one minute i

671
00:28:10,960 --> 00:28:12,720
have one quick question

672
00:28:12,720 --> 00:28:16,000
sure if i have as i do three devices

673
00:28:16,000 --> 00:28:19,279
and two of them are turned off so that

674
00:28:19,279 --> 00:28:22,080
there's only one party involved does it

675
00:28:22,080 --> 00:28:25,520
reduce to the original problem

676
00:28:25,520 --> 00:28:29,200
um if you have only one device in uh

677
00:28:29,200 --> 00:28:30,480
involved in our solution

678
00:28:30,480 --> 00:28:31,919
unfortunately you wouldn't be able to

679
00:28:31,919 --> 00:28:34,799
authenticate yourselves um

680
00:28:34,799 --> 00:28:37,039
the reason being that we don't want any

681
00:28:37,039 --> 00:28:38,240
single device to be

682
00:28:38,240 --> 00:28:41,679
able to hold the entire

683
00:28:41,679 --> 00:28:45,200
signing key or the biometric template

684
00:28:45,200 --> 00:28:46,880
but if you wanted such a feature to be

685
00:28:46,880 --> 00:28:48,240
enabled then you're right that

686
00:28:48,240 --> 00:28:50,159
it would just reduce to the original

687
00:28:50,159 --> 00:28:51,840
setting because each device should now

688
00:28:51,840 --> 00:28:53,679
be locally able to

689
00:28:53,679 --> 00:28:56,080
do the matching and and the second thing

690
00:28:56,080 --> 00:28:56,799
is

691
00:28:56,799 --> 00:28:59,120
if all three devices are capable of

692
00:28:59,120 --> 00:28:59,919
biometric

693
00:28:59,919 --> 00:29:02,480
verification do i have to enroll all

694
00:29:02,480 --> 00:29:04,000
three of the devices

695
00:29:04,000 --> 00:29:06,000
so that they're they're sharing shares

696
00:29:06,000 --> 00:29:07,440
with each other

697
00:29:07,440 --> 00:29:09,840
uh any one device can be the one running

698
00:29:09,840 --> 00:29:11,039
the enrollment phase and

699
00:29:11,039 --> 00:29:13,200
that device could then generate the

700
00:29:13,200 --> 00:29:14,880
shares and send it across to the

701
00:29:14,880 --> 00:29:17,039
other devices with the way we modulate

702
00:29:17,039 --> 00:29:19,120
is by assuming that there is a

703
00:29:19,120 --> 00:29:21,440
trusted phase a trusted setup phase that

704
00:29:21,440 --> 00:29:23,279
happens at that point so that no single

705
00:29:23,279 --> 00:29:24,640
device

706
00:29:24,640 --> 00:29:27,039
stores the shares um locally even after

707
00:29:27,039 --> 00:29:29,919
the enrollment phase

708
00:29:30,000 --> 00:29:31,679
that's very interesting so that if i

709
00:29:31,679 --> 00:29:33,600
enroll on one device i'm basically

710
00:29:33,600 --> 00:29:34,240
enrolling

711
00:29:34,240 --> 00:29:38,840
all on all 10 devices yeah that's

712
00:29:38,840 --> 00:29:40,159
connect

713
00:29:40,159 --> 00:29:42,640
okay thanks for the question and thanks

714
00:29:42,640 --> 00:29:43,840
for the talk again

715
00:29:43,840 --> 00:29:47,360
uh our next talk will be

716
00:29:47,360 --> 00:29:49,520
private set operations from oblivious

717
00:29:49,520 --> 00:29:50,480
switching

718
00:29:50,480 --> 00:29:54,399
it's from uh gaia three ir3 payment mike

719
00:29:54,399 --> 00:29:58,240
saeed and jasper thank you so much for

720
00:29:58,240 --> 00:29:59,600
the introduction

721
00:29:59,600 --> 00:30:01,360
i'm gayathri and i'll be presenting

722
00:30:01,360 --> 00:30:03,279
private set operations from oblivious

723
00:30:03,279 --> 00:30:04,320
switching

724
00:30:04,320 --> 00:30:06,480
this is joint work with payment mohassel

725
00:30:06,480 --> 00:30:08,880
mike rosilick says

726
00:30:08,880 --> 00:30:12,559
jaspal singh so let's get started

727
00:30:12,559 --> 00:30:16,720
in psi alice has a set x bob has a set y

728
00:30:16,720 --> 00:30:18,240
and we want alice to learn the

729
00:30:18,240 --> 00:30:20,240
intersection

730
00:30:20,240 --> 00:30:22,159
in recent years there has been much work

731
00:30:22,159 --> 00:30:24,720
to make psi practically very efficient

732
00:30:24,720 --> 00:30:26,559
both in the semi honest and malicious

733
00:30:26,559 --> 00:30:27,840
setting

734
00:30:27,840 --> 00:30:30,159
but many real world applications lead us

735
00:30:30,159 --> 00:30:31,760
to ask the question

736
00:30:31,760 --> 00:30:34,000
what if alice only wants to learn some

737
00:30:34,000 --> 00:30:34,799
partial or

738
00:30:34,799 --> 00:30:36,320
aggregate information about the

739
00:30:36,320 --> 00:30:38,640
intersection for instance just the

740
00:30:38,640 --> 00:30:41,039
cardinality

741
00:30:41,039 --> 00:30:43,120
consider this example proposed in this

742
00:30:43,120 --> 00:30:44,640
paper by authors from google and

743
00:30:44,640 --> 00:30:46,559
columbia university

744
00:30:46,559 --> 00:30:47,840
their goal was to measure the

745
00:30:47,840 --> 00:30:49,279
effectiveness of their online

746
00:30:49,279 --> 00:30:50,399
advertising

747
00:30:50,399 --> 00:30:52,000
so they wanted to know the number of

748
00:30:52,000 --> 00:30:53,760
people who both viewed an

749
00:30:53,760 --> 00:30:56,240
ad online on their platform and then

750
00:30:56,240 --> 00:30:59,039
went on to buy a related item offline

751
00:30:59,039 --> 00:31:00,799
and they also wanted to know the total

752
00:31:00,799 --> 00:31:02,960
transaction amount generated by such

753
00:31:02,960 --> 00:31:04,159
people

754
00:31:04,159 --> 00:31:06,080
in the most general terms what we're

755
00:31:06,080 --> 00:31:07,519
looking for

756
00:31:07,519 --> 00:31:09,840
is that alice and bob are able to learn

757
00:31:09,840 --> 00:31:10,799
some function

758
00:31:10,799 --> 00:31:13,679
f over the intersection for any function

759
00:31:13,679 --> 00:31:15,039
of their choice

760
00:31:15,039 --> 00:31:17,360
so we call this private computation on

761
00:31:17,360 --> 00:31:19,120
set intersection

762
00:31:19,120 --> 00:31:21,120
there have been some works that have uh

763
00:31:21,120 --> 00:31:22,640
in this direction

764
00:31:22,640 --> 00:31:24,399
and the state-of-the-art protocol was

765
00:31:24,399 --> 00:31:26,799
given by pinkish schneider kachenko and

766
00:31:26,799 --> 00:31:28,640
yani in 2019

767
00:31:28,640 --> 00:31:32,480
and i'll call this the psty protocol

768
00:31:32,480 --> 00:31:34,159
so let's start by identifying a

769
00:31:34,159 --> 00:31:37,600
performance gap between psi and pcsi

770
00:31:37,600 --> 00:31:39,519
for a million items in the semi-honest

771
00:31:39,519 --> 00:31:41,919
setting computing the intersection takes

772
00:31:41,919 --> 00:31:43,600
well under a minute

773
00:31:43,600 --> 00:31:46,880
but for the fastest pcsi protocol even

774
00:31:46,880 --> 00:31:48,799
computing something like the cardinality

775
00:31:48,799 --> 00:31:50,720
takes around 9 minutes

776
00:31:50,720 --> 00:31:53,279
so concretely this is 20 times slower

777
00:31:53,279 --> 00:31:56,000
and needs 30 times more communication

778
00:31:56,000 --> 00:31:58,159
so let's see why this is and how we can

779
00:31:58,159 --> 00:32:00,480
bridge this gap

780
00:32:00,480 --> 00:32:03,120
so the psty protocol starts with a

781
00:32:03,120 --> 00:32:05,120
pre-processing phase

782
00:32:05,120 --> 00:32:07,440
at the end of this step we are in we end

783
00:32:07,440 --> 00:32:09,840
up with the following situation

784
00:32:09,840 --> 00:32:12,960
alice has a fixed ordering of her items

785
00:32:12,960 --> 00:32:16,320
and alice and bob learn vectors s and t

786
00:32:16,320 --> 00:32:18,880
such that s i and t i are an additive

787
00:32:18,880 --> 00:32:19,840
sharing of 0

788
00:32:19,840 --> 00:32:22,720
if x is in the intersection otherwise s

789
00:32:22,720 --> 00:32:24,640
i and t i are a narrative sharing of a

790
00:32:24,640 --> 00:32:26,480
pseudo-random value

791
00:32:26,480 --> 00:32:28,720
so if alice learns that s1 is equal to

792
00:32:28,720 --> 00:32:30,720
t1 then she can conclude that x1 is in

793
00:32:30,720 --> 00:32:32,880
the intersection

794
00:32:32,880 --> 00:32:35,679
so clearly it's not safe for alice or

795
00:32:35,679 --> 00:32:37,440
bob to learn the outcome of

796
00:32:37,440 --> 00:32:40,000
any individual comparison because that

797
00:32:40,000 --> 00:32:41,519
would leak something about the contents

798
00:32:41,519 --> 00:32:42,480
of the intersection

799
00:32:42,480 --> 00:32:45,279
and that's not allowed in pcsl so what's

800
00:32:45,279 --> 00:32:45,600
done

801
00:32:45,600 --> 00:32:48,080
is the comparisons are made inside some

802
00:32:48,080 --> 00:32:50,399
general purpose mpc protocol

803
00:32:50,399 --> 00:32:52,320
and the results are fed into another

804
00:32:52,320 --> 00:32:54,240
circuit into a circuit f

805
00:32:54,240 --> 00:32:58,799
which will compute f on the intersection

806
00:32:59,360 --> 00:33:02,640
so comparing two l-bit strings in a

807
00:33:02,640 --> 00:33:03,440
general purpose

808
00:33:03,440 --> 00:33:05,760
mpc requires order l times kappa

809
00:33:05,760 --> 00:33:07,519
communication

810
00:33:07,519 --> 00:33:09,919
in the psty protocol the comparison

811
00:33:09,919 --> 00:33:12,320
circuit accounts for 96 percent of the

812
00:33:12,320 --> 00:33:14,320
communication cost

813
00:33:14,320 --> 00:33:17,360
in concrete terms in contrast if you

814
00:33:17,360 --> 00:33:18,640
look at psi

815
00:33:18,640 --> 00:33:20,960
comparing two l bit strings just takes

816
00:33:20,960 --> 00:33:22,840
four point five times kabab it's a

817
00:33:22,840 --> 00:33:24,080
communication

818
00:33:24,080 --> 00:33:25,600
notice that it's independent of the

819
00:33:25,600 --> 00:33:27,360
length of the strings

820
00:33:27,360 --> 00:33:29,519
but the caveat still remains that alice

821
00:33:29,519 --> 00:33:31,279
or bob learn the outcome of each

822
00:33:31,279 --> 00:33:33,679
individual comparison

823
00:33:33,679 --> 00:33:35,360
so our goal is that we have these

824
00:33:35,360 --> 00:33:37,200
special purpose equality tests which are

825
00:33:37,200 --> 00:33:38,399
really efficient

826
00:33:38,399 --> 00:33:39,919
and we want to somehow make them

827
00:33:39,919 --> 00:33:42,640
compatible with this pre-processing step

828
00:33:42,640 --> 00:33:45,039
so our main idea is that we shuffle the

829
00:33:45,039 --> 00:33:46,720
equality tests

830
00:33:46,720 --> 00:33:48,240
according to some permutation that's

831
00:33:48,240 --> 00:33:50,000
known to alice

832
00:33:50,000 --> 00:33:52,399
then it becomes safe for bob to learn

833
00:33:52,399 --> 00:33:54,720
the output of the equality tests

834
00:33:54,720 --> 00:33:56,640
so basically he only ends up learning

835
00:33:56,640 --> 00:33:58,880
the number of strings that match

836
00:33:58,880 --> 00:34:00,799
but the oblivious shuffling network

837
00:34:00,799 --> 00:34:02,559
breaks the correlation between the

838
00:34:02,559 --> 00:34:04,240
strings that match and the items that

839
00:34:04,240 --> 00:34:06,000
they correspond to

840
00:34:06,000 --> 00:34:07,600
so we call these three steps our

841
00:34:07,600 --> 00:34:09,280
protocol core

842
00:34:09,280 --> 00:34:12,000
and asymptotically we go from order nl

843
00:34:12,000 --> 00:34:13,280
times kappa

844
00:34:13,280 --> 00:34:15,520
down to order n log n times kappa for

845
00:34:15,520 --> 00:34:17,599
the shuffling cost followed by order n

846
00:34:17,599 --> 00:34:20,079
times kappa for the equality tests

847
00:34:20,079 --> 00:34:22,800
in almost all cases log n is much much

848
00:34:22,800 --> 00:34:24,879
smaller than the length of strings

849
00:34:24,879 --> 00:34:26,560
so we give both an asymptotic and

850
00:34:26,560 --> 00:34:29,440
concrete improvement

851
00:34:29,440 --> 00:34:31,839
so we can summarize our contributions as

852
00:34:31,839 --> 00:34:32,960
follows

853
00:34:32,960 --> 00:34:36,159
we give a new protocol for pcsi provided

854
00:34:36,159 --> 00:34:38,159
it's always safe to leak the cardinality

855
00:34:38,159 --> 00:34:39,679
of the intersection

856
00:34:39,679 --> 00:34:42,079
this gives us 2.5 to 3 times lower

857
00:34:42,079 --> 00:34:43,359
communication

858
00:34:43,359 --> 00:34:44,879
as a result of which we have faster

859
00:34:44,879 --> 00:34:47,440
running time on slower networks

860
00:34:47,440 --> 00:34:49,280
our main construction is what we call

861
00:34:49,280 --> 00:34:50,800
our protocol core

862
00:34:50,800 --> 00:34:52,879
and once we have this we're able to get

863
00:34:52,879 --> 00:34:54,879
secret shares of the intersection

864
00:34:54,879 --> 00:34:56,960
which can then be fed which can then be

865
00:34:56,960 --> 00:34:58,800
fed into any circuit which will compute

866
00:34:58,800 --> 00:35:00,800
f over the intersection

867
00:35:00,800 --> 00:35:03,359
we also show that protocol core can be

868
00:35:03,359 --> 00:35:04,720
used directly

869
00:35:04,720 --> 00:35:06,000
to realize some interesting

870
00:35:06,000 --> 00:35:08,320
functionalities like

871
00:35:08,320 --> 00:35:11,200
cardinality we also get a protocol for

872
00:35:11,200 --> 00:35:12,640
cardinality sum

873
00:35:12,640 --> 00:35:14,160
without having to compute the secret

874
00:35:14,160 --> 00:35:16,000
shares of the intersection

875
00:35:16,000 --> 00:35:18,720
we also get a faster protocol to compute

876
00:35:18,720 --> 00:35:19,520
the union's

877
00:35:19,520 --> 00:35:21,599
union of the sets although it doesn't

878
00:35:21,599 --> 00:35:24,720
strictly fit into the pcsi framework

879
00:35:24,720 --> 00:35:27,280
and this union protocol can be used to

880
00:35:27,280 --> 00:35:29,359
realize a functionality called private

881
00:35:29,359 --> 00:35:30,160
id

882
00:35:30,160 --> 00:35:32,000
which was proposed in this paper and

883
00:35:32,000 --> 00:35:34,160
ours is the first ot extension based

884
00:35:34,160 --> 00:35:35,599
construction for

885
00:35:35,599 --> 00:35:38,800
realizing this functionality

886
00:35:38,800 --> 00:35:40,560
finally i'll leave you with some

887
00:35:40,560 --> 00:35:43,599
takeaways from our performance numbers

888
00:35:43,599 --> 00:35:46,880
and these are the links to our code and

889
00:35:46,880 --> 00:35:48,079
our paper thank you so much for

890
00:35:48,079 --> 00:35:50,240
listening

891
00:35:50,240 --> 00:35:52,240
thanks a lot for the presentation a very

892
00:35:52,240 --> 00:35:54,000
nice talk

893
00:35:54,000 --> 00:35:56,000
any question from the audience we'll

894
00:35:56,000 --> 00:35:59,839
have about 30 minutes

895
00:36:02,000 --> 00:36:03,920
where is the core functionality

896
00:36:03,920 --> 00:36:06,640
instantiated who is doing the

897
00:36:06,640 --> 00:36:10,320
computations so this is a two-party

898
00:36:10,320 --> 00:36:12,560
protocol so it it will be instantiated

899
00:36:12,560 --> 00:36:14,480
by alice and bob together

900
00:36:14,480 --> 00:36:16,400
the first step of the core will be the

901
00:36:16,400 --> 00:36:19,520
psty pre-processing

902
00:36:19,520 --> 00:36:23,040
then alice and bob will do the oblivious

903
00:36:23,040 --> 00:36:24,560
switching which is another two-party

904
00:36:24,560 --> 00:36:25,599
protocol and then

905
00:36:25,599 --> 00:36:27,520
alice and bob will do equality testing

906
00:36:27,520 --> 00:36:31,119
which is another two-party protocol

907
00:36:33,040 --> 00:36:36,240
and where does the shuffling take place

908
00:36:36,240 --> 00:36:39,200
uh so yeah so it's an interactive

909
00:36:39,200 --> 00:36:41,040
interactive protocol between alice and

910
00:36:41,040 --> 00:36:43,040
bob so alice has the power to choose the

911
00:36:43,040 --> 00:36:44,400
permutation

912
00:36:44,400 --> 00:36:47,200
and bob will have like and both of them

913
00:36:47,200 --> 00:36:49,040
can feed an additive shares of some

914
00:36:49,040 --> 00:36:49,599
vector

915
00:36:49,599 --> 00:36:51,200
and then they'll get a re-randomized

916
00:36:51,200 --> 00:36:55,839
additive sharing of the permuted vector

917
00:36:58,560 --> 00:37:00,720
uh is that clear or should i try to

918
00:37:00,720 --> 00:37:02,320
explain it in a different way

919
00:37:02,320 --> 00:37:06,000
uh no but i'm i'm just thinking that

920
00:37:06,000 --> 00:37:08,560
somewhere along the way the lists have

921
00:37:08,560 --> 00:37:10,480
to be sorted in order to perform the

922
00:37:10,480 --> 00:37:11,680
comparison

923
00:37:11,680 --> 00:37:14,720
is that correct uh so we're not doing a

924
00:37:14,720 --> 00:37:16,720
comparison based switching so

925
00:37:16,720 --> 00:37:18,800
we will have like a switching network a

926
00:37:18,800 --> 00:37:20,160
universal switching network like a

927
00:37:20,160 --> 00:37:21,680
banished network or a

928
00:37:21,680 --> 00:37:23,920
walksman network and the guarantee of

929
00:37:23,920 --> 00:37:24,800
that like

930
00:37:24,800 --> 00:37:26,880
such a network would be that like if you

931
00:37:26,880 --> 00:37:28,079
feed in

932
00:37:28,079 --> 00:37:30,480
a vector x then you can realize any

933
00:37:30,480 --> 00:37:32,000
permutation of your choice by

934
00:37:32,000 --> 00:37:33,359
programming it so you have like

935
00:37:33,359 --> 00:37:34,800
programming bits

936
00:37:34,800 --> 00:37:36,800
so you'll have order n log n switches

937
00:37:36,800 --> 00:37:38,960
and if you can program those switches

938
00:37:38,960 --> 00:37:40,800
then you can realize any permutation of

939
00:37:40,800 --> 00:37:42,400
your choice

940
00:37:42,400 --> 00:37:45,440
thank you yeah

941
00:37:45,440 --> 00:37:48,560
okay uh thanks thanks again for the nice

942
00:37:48,560 --> 00:37:50,720
talk thank you i will hand the session

943
00:37:50,720 --> 00:37:52,640
to akshay

944
00:37:52,640 --> 00:37:56,320
uh thanks so the next talk is titled

945
00:37:56,320 --> 00:37:56,720
mass

946
00:37:56,720 --> 00:37:58,720
triples amortizing multiplication

947
00:37:58,720 --> 00:38:00,720
triples across conditionals

948
00:38:00,720 --> 00:38:03,680
uh it's by david vladimir and stennis

949
00:38:03,680 --> 00:38:05,040
law and sten's law will

950
00:38:05,040 --> 00:38:07,599
give the talk

951
00:38:11,119 --> 00:38:14,000
thank you for the introduction let me

952
00:38:14,000 --> 00:38:19,839
share my screen

953
00:38:28,079 --> 00:38:31,040
can you see my screen

954
00:38:31,119 --> 00:38:35,440
yeah uh okay so my name is tim passeni

955
00:38:35,440 --> 00:38:37,200
and this is a joint work with david

956
00:38:37,200 --> 00:38:37,599
heath

957
00:38:37,599 --> 00:38:40,079
and vlad kolesnikov and i will be

958
00:38:40,079 --> 00:38:40,960
presenting

959
00:38:40,960 --> 00:38:43,839
mass triples amortizing multiplication

960
00:38:43,839 --> 00:38:44,640
triples

961
00:38:44,640 --> 00:38:47,920
across conditionals

962
00:38:47,920 --> 00:38:50,720
so in this work i'll be discussing a

963
00:38:50,720 --> 00:38:51,680
classic

964
00:38:51,680 --> 00:38:55,200
npc protocol and this protocol uses

965
00:38:55,200 --> 00:38:58,240
pre-processed multiplication triples to

966
00:38:58,240 --> 00:39:01,839
evaluate arbitrary functions represented

967
00:39:01,839 --> 00:39:03,920
as boolean circuit

968
00:39:03,920 --> 00:39:07,119
and a boolean circuit consists of and

969
00:39:07,119 --> 00:39:10,400
and xor gates and

970
00:39:10,400 --> 00:39:14,320
while evaluating the linear xor gate is

971
00:39:14,320 --> 00:39:15,119
essentially

972
00:39:15,119 --> 00:39:18,320
free the non-linear and gates are

973
00:39:18,320 --> 00:39:19,599
evaluated with

974
00:39:19,599 --> 00:39:22,480
beaver multiplication triples and those

975
00:39:22,480 --> 00:39:22,880
are

976
00:39:22,880 --> 00:39:26,079
expensive to generate

977
00:39:26,079 --> 00:39:28,720
in our work we reduce the cost

978
00:39:28,720 --> 00:39:30,720
associated with generating

979
00:39:30,720 --> 00:39:33,760
these multiplication triples our

980
00:39:33,760 --> 00:39:34,480
improvement

981
00:39:34,480 --> 00:39:38,240
results in significant reduction to both

982
00:39:38,240 --> 00:39:41,280
communication and runtime of this

983
00:39:41,280 --> 00:39:44,800
triple bass protocol

984
00:39:45,359 --> 00:39:47,839
we improved the protocol by carefully

985
00:39:47,839 --> 00:39:50,160
reusing the multiplication triples

986
00:39:50,160 --> 00:39:52,880
in conditional statements of the source

987
00:39:52,880 --> 00:39:54,800
program

988
00:39:54,800 --> 00:39:57,520
traditionally it has been assumed that

989
00:39:57,520 --> 00:39:59,440
we need multiplication triples for all

990
00:39:59,440 --> 00:40:01,200
branches in a conditional

991
00:40:01,200 --> 00:40:04,880
and this is because for security

992
00:40:04,880 --> 00:40:08,640
each multiplication triple can mask

993
00:40:08,640 --> 00:40:11,680
at most one and gate

994
00:40:11,680 --> 00:40:14,000
in this work we show that this is not

995
00:40:14,000 --> 00:40:16,240
necessary and the number of triples we

996
00:40:16,240 --> 00:40:17,119
need

997
00:40:17,119 --> 00:40:20,560
is proportional only to the size

998
00:40:20,560 --> 00:40:25,119
of the single longest branch

999
00:40:25,119 --> 00:40:26,640
prior work looked into conditional

1000
00:40:26,640 --> 00:40:28,560
branching improvements under other

1001
00:40:28,560 --> 00:40:29,839
protocols

1002
00:40:29,839 --> 00:40:32,079
star garbling looked into the problem in

1003
00:40:32,079 --> 00:40:34,960
yao scarborough circuit so into bc

1004
00:40:34,960 --> 00:40:37,839
and motif which was presented at asia

1005
00:40:37,839 --> 00:40:39,280
creek 2020

1006
00:40:39,280 --> 00:40:41,119
was the first work that achieved

1007
00:40:41,119 --> 00:40:42,960
significant conditional branching

1008
00:40:42,960 --> 00:40:46,079
improvement in the multi-party setting

1009
00:40:46,079 --> 00:40:49,280
motif worked with the gmw protocol which

1010
00:40:49,280 --> 00:40:49,920
is

1011
00:40:49,920 --> 00:40:52,800
also related to the triple bass protocol

1012
00:40:52,800 --> 00:40:53,359
so

1013
00:40:53,359 --> 00:40:55,839
our approach works in a similar setting

1014
00:40:55,839 --> 00:40:58,400
to multi but our solution is distinct

1015
00:40:58,400 --> 00:41:01,520
and yields a significant concrete

1016
00:41:01,520 --> 00:41:03,680
improvement over motif

1017
00:41:03,680 --> 00:41:06,000
so i want to very briefly show motifs

1018
00:41:06,000 --> 00:41:08,160
limitations

1019
00:41:08,160 --> 00:41:10,960
so the key cost in the gmw protocol is

1020
00:41:10,960 --> 00:41:13,839
pre-computing random oblivious transfers

1021
00:41:13,839 --> 00:41:16,480
which are used to evaluate the and gates

1022
00:41:16,480 --> 00:41:17,760
of the circuit

1023
00:41:17,760 --> 00:41:21,040
and oblivious transfers or shortly ots

1024
00:41:21,040 --> 00:41:22,480
are expensive

1025
00:41:22,480 --> 00:41:25,280
public key primitives and motives

1026
00:41:25,280 --> 00:41:27,520
improvement stems from amortizing

1027
00:41:27,520 --> 00:41:32,240
these ots across conditional branches

1028
00:41:32,400 --> 00:41:36,079
motives limitation is

1029
00:41:36,160 --> 00:41:38,960
that the improvement is dependent on the

1030
00:41:38,960 --> 00:41:40,720
alignment of the and gates

1031
00:41:40,720 --> 00:41:43,200
across branches meaning the branches

1032
00:41:43,200 --> 00:41:45,680
need to have a similar number of n-gage

1033
00:41:45,680 --> 00:41:47,440
and gates in each circuit layer for

1034
00:41:47,440 --> 00:41:49,680
optimal performance

1035
00:41:49,680 --> 00:41:53,200
in the sample conditional i show

1036
00:41:53,200 --> 00:41:55,680
there are two unaligned branches and in

1037
00:41:55,680 --> 00:41:56,560
this case

1038
00:41:56,560 --> 00:41:58,960
motif would pay for four n gates but the

1039
00:41:58,960 --> 00:42:02,960
longest branch has only three n gates

1040
00:42:02,960 --> 00:42:05,520
our new work is mass triples and

1041
00:42:05,520 --> 00:42:07,200
similarly to motif we

1042
00:42:07,200 --> 00:42:08,960
reduce the number of these expensive

1043
00:42:08,960 --> 00:42:10,640
random ots

1044
00:42:10,640 --> 00:42:12,880
in the triple base protocol random ots

1045
00:42:12,880 --> 00:42:14,880
are one way to generate multiplication

1046
00:42:14,880 --> 00:42:15,680
triples

1047
00:42:15,680 --> 00:42:18,480
and unlike in motif the number of random

1048
00:42:18,480 --> 00:42:20,400
ot's we need to generate

1049
00:42:20,400 --> 00:42:22,240
is proportional to the size of the

1050
00:42:22,240 --> 00:42:24,720
longest conditional branch

1051
00:42:24,720 --> 00:42:27,040
so i have introduced the key idea for

1052
00:42:27,040 --> 00:42:27,920
improvement

1053
00:42:27,920 --> 00:42:29,920
i will now get into more technical

1054
00:42:29,920 --> 00:42:33,040
aspects of our improvement

1055
00:42:33,040 --> 00:42:34,880
so recall that the xor gates are

1056
00:42:34,880 --> 00:42:36,400
virtually free

1057
00:42:36,400 --> 00:42:38,720
the triple base protocol cost really

1058
00:42:38,720 --> 00:42:40,880
comes from generating triples for the

1059
00:42:40,880 --> 00:42:42,400
end gates

1060
00:42:42,400 --> 00:42:44,640
hence we would like to reuse a single

1061
00:42:44,640 --> 00:42:45,760
triple across

1062
00:42:45,760 --> 00:42:48,400
all conditional branches if we are able

1063
00:42:48,400 --> 00:42:49,280
to do that

1064
00:42:49,280 --> 00:42:51,760
and securely then we have effectively

1065
00:42:51,760 --> 00:42:54,560
made all untaken branches free

1066
00:42:54,560 --> 00:42:56,880
i will now show how to do that and for

1067
00:42:56,880 --> 00:42:58,480
simplicity let's just consider two

1068
00:42:58,480 --> 00:43:00,240
branches where the top branches the

1069
00:43:00,240 --> 00:43:02,480
taken branch

1070
00:43:02,480 --> 00:43:04,160
we would like to use the same triple on

1071
00:43:04,160 --> 00:43:08,240
both end gates and the two branches

1072
00:43:08,319 --> 00:43:10,640
the key idea behind reusing triple

1073
00:43:10,640 --> 00:43:12,720
securely is that we can carefully

1074
00:43:12,720 --> 00:43:17,119
apply secret shared masks to the triples

1075
00:43:17,119 --> 00:43:19,839
for the inactive branch the priority

1076
00:43:19,839 --> 00:43:22,400
sponsor triples with uniform xo shares

1077
00:43:22,400 --> 00:43:23,040
of

1078
00:43:23,040 --> 00:43:26,640
uniform masks rns thus randomizing the

1079
00:43:26,640 --> 00:43:27,520
triples and

1080
00:43:27,520 --> 00:43:30,400
preventing us from breaking the security

1081
00:43:30,400 --> 00:43:30,800
of

1082
00:43:30,800 --> 00:43:33,760
one time pad and by randomizing the

1083
00:43:33,760 --> 00:43:34,720
triples we

1084
00:43:34,720 --> 00:43:37,359
violate the correctness of the and gate

1085
00:43:37,359 --> 00:43:38,880
on the inactive branch but

1086
00:43:38,880 --> 00:43:41,280
this is of no concern because the output

1087
00:43:41,280 --> 00:43:43,440
of these inactive end gates

1088
00:43:43,440 --> 00:43:47,040
are ultimately discarded

1089
00:43:47,040 --> 00:43:49,760
for the active branch that is the taken

1090
00:43:49,760 --> 00:43:51,680
branch the parties use the triples

1091
00:43:51,680 --> 00:43:54,720
as is meaning the active branch is

1092
00:43:54,720 --> 00:43:57,040
evaluated normally

1093
00:43:57,040 --> 00:43:58,640
of course the party should not know

1094
00:43:58,640 --> 00:44:00,800
which branch is inactive so

1095
00:44:00,800 --> 00:44:02,640
from the perspective of the parties it

1096
00:44:02,640 --> 00:44:04,800
should appear plausible that either

1097
00:44:04,800 --> 00:44:06,240
branch could have used randomized

1098
00:44:06,240 --> 00:44:07,040
triples

1099
00:44:07,040 --> 00:44:08,880
and to achieve this for the active

1100
00:44:08,880 --> 00:44:11,200
branch the parties also exhaust masks

1101
00:44:11,200 --> 00:44:12,720
onto the triples

1102
00:44:12,720 --> 00:44:15,119
but in this case each mask is a uniform

1103
00:44:15,119 --> 00:44:16,560
sharing of zero

1104
00:44:16,560 --> 00:44:19,920
hence the exuring is a no up

1105
00:44:19,920 --> 00:44:22,400
i stress that masking only the a and b

1106
00:44:22,400 --> 00:44:24,079
bits of the triple is

1107
00:44:24,079 --> 00:44:27,280
necessary and sufficient and uh

1108
00:44:27,280 --> 00:44:29,839
to see why please see the full

1109
00:44:29,839 --> 00:44:30,960
presentation

1110
00:44:30,960 --> 00:44:34,079
or our paper

1111
00:44:34,319 --> 00:44:36,400
importantly our approach of significant

1112
00:44:36,400 --> 00:44:38,000
concrete improvement because

1113
00:44:38,000 --> 00:44:40,800
generating these masks is much cheaper

1114
00:44:40,800 --> 00:44:41,200
than

1115
00:44:41,200 --> 00:44:44,160
generating additional triples and

1116
00:44:44,160 --> 00:44:45,599
unfortunately due to the time

1117
00:44:45,599 --> 00:44:47,440
constraints i cannot go into

1118
00:44:47,440 --> 00:44:49,839
how the masks are generated but the

1119
00:44:49,839 --> 00:44:51,920
details are in the full presentation as

1120
00:44:51,920 --> 00:44:52,480
well as

1121
00:44:52,480 --> 00:44:56,720
in our paper so i have introduced the

1122
00:44:56,720 --> 00:44:58,079
mass triplets protocol

1123
00:44:58,079 --> 00:45:00,079
again the key contribution of mass

1124
00:45:00,079 --> 00:45:02,800
triples is that we introduce a protocol

1125
00:45:02,800 --> 00:45:05,359
that has communication proportional to a

1126
00:45:05,359 --> 00:45:06,160
program's

1127
00:45:06,160 --> 00:45:08,319
longest execution path in the

1128
00:45:08,319 --> 00:45:10,000
multi-party setting

1129
00:45:10,000 --> 00:45:12,800
and unlike state-of-the-art motif our

1130
00:45:12,800 --> 00:45:13,920
improvement is

1131
00:45:13,920 --> 00:45:17,119
independent of the circuit topology so

1132
00:45:17,119 --> 00:45:18,160
thanks for listening

1133
00:45:18,160 --> 00:45:24,000
and i'm happy to take any questions

1134
00:45:24,240 --> 00:45:27,520
so thanks spencer for this nice talk so

1135
00:45:27,520 --> 00:45:33,839
any questions to the speaker

1136
00:45:37,680 --> 00:45:40,079
that i have no questions uh i have a

1137
00:45:40,079 --> 00:45:41,119
quick question so

1138
00:45:41,119 --> 00:45:44,880
how do you hide which branch is active

1139
00:45:44,880 --> 00:45:48,160
and which is the invalid function

1140
00:45:48,160 --> 00:45:51,280
so basically when you're evaluating

1141
00:45:51,280 --> 00:45:52,400
conditionals

1142
00:45:52,400 --> 00:45:56,000
in in this triple-based protocol you're

1143
00:45:56,000 --> 00:45:58,960
evaluating some circuit and then at some

1144
00:45:58,960 --> 00:46:00,640
point uh

1145
00:46:00,640 --> 00:46:03,359
you branch into one or another branch

1146
00:46:03,359 --> 00:46:03,680
and

1147
00:46:03,680 --> 00:46:06,480
you have you you have this branch

1148
00:46:06,480 --> 00:46:07,520
condition

1149
00:46:07,520 --> 00:46:10,160
bit you hold the share of this bit

1150
00:46:10,160 --> 00:46:11,520
determines

1151
00:46:11,520 --> 00:46:14,720
which branch is actually taken

1152
00:46:14,720 --> 00:46:17,920
and since this condition bit

1153
00:46:17,920 --> 00:46:21,760
is secret shared you do not know which

1154
00:46:21,760 --> 00:46:29,760
which branch will actually be taken

1155
00:46:29,760 --> 00:46:33,119
uh any other questions

1156
00:46:36,400 --> 00:46:40,800
so let's uh thank uh stanislav again

1157
00:46:40,800 --> 00:46:44,240
thank you uh so the next talk is

1158
00:46:44,240 --> 00:46:47,040
uh titled two server distributed oram

1159
00:46:47,040 --> 00:46:48,079
with sublinear

1160
00:46:48,079 --> 00:46:51,280
computation and constant rounds by ariel

1161
00:46:51,280 --> 00:46:53,359
uh and mayank and ariel will be giving

1162
00:46:53,359 --> 00:46:55,280
the problem

1163
00:46:55,280 --> 00:46:58,720
all right um thank you let me just share

1164
00:46:58,720 --> 00:47:01,279
my screen

1165
00:47:04,079 --> 00:47:06,560
all right um thank you for the

1166
00:47:06,560 --> 00:47:07,359
introduction

1167
00:47:07,359 --> 00:47:09,760
uh first off i want to apologize if

1168
00:47:09,760 --> 00:47:11,280
there are any background noises

1169
00:47:11,280 --> 00:47:12,800
there's construction happening in the

1170
00:47:12,800 --> 00:47:14,880
apartment below me so

1171
00:47:14,880 --> 00:47:18,240
bear with me in this regard

1172
00:47:18,240 --> 00:47:20,880
today i will be talking about two server

1173
00:47:20,880 --> 00:47:22,640
distributed oram with sublinear

1174
00:47:22,640 --> 00:47:23,599
computation and

1175
00:47:23,599 --> 00:47:26,000
constant rounds this is a joint work

1176
00:47:26,000 --> 00:47:26,960
with mayank

1177
00:47:26,960 --> 00:47:30,480
uh varia from boston university

1178
00:47:30,480 --> 00:47:33,040
to first describe distributed oram it

1179
00:47:33,040 --> 00:47:36,000
was introduced by ostrovsky and shupe

1180
00:47:36,000 --> 00:47:39,200
in 1997 and formally defined by lew

1181
00:47:39,200 --> 00:47:42,319
nostrovsky in 2013.

1182
00:47:42,319 --> 00:47:46,640
it exists apart from the original

1183
00:47:46,640 --> 00:47:50,640
oram setting in that it

1184
00:47:50,640 --> 00:47:52,400
basically allows for multiple

1185
00:47:52,400 --> 00:47:54,079
non-including servers

1186
00:47:54,079 --> 00:47:56,960
um to interact with the client and this

1187
00:47:56,960 --> 00:47:59,280
distributed nature was first

1188
00:47:59,280 --> 00:48:00,960
employed as a way to get around the

1189
00:48:00,960 --> 00:48:04,319
lower bounds within oram

1190
00:48:04,319 --> 00:48:06,480
particularly today i will be talking

1191
00:48:06,480 --> 00:48:07,520
about

1192
00:48:07,520 --> 00:48:09,680
the distributed oram in the secure

1193
00:48:09,680 --> 00:48:10,960
computation variant

1194
00:48:10,960 --> 00:48:14,400
meaning things like mpc for ram

1195
00:48:14,400 --> 00:48:17,119
um often we'll use this where the two

1196
00:48:17,119 --> 00:48:18,240
servers

1197
00:48:18,240 --> 00:48:21,520
not only act as the oram

1198
00:48:21,520 --> 00:48:24,880
servers but also uh emulate the

1199
00:48:24,880 --> 00:48:29,200
oram client in a distributed way

1200
00:48:30,319 --> 00:48:33,359
so there are quite a few works in

1201
00:48:33,359 --> 00:48:35,760
this model i've highlighted two of the

1202
00:48:35,760 --> 00:48:37,680
more recent ones

1203
00:48:37,680 --> 00:48:40,160
that sort of perform the best gordon

1204
00:48:40,160 --> 00:48:41,520
cats and wang

1205
00:48:41,520 --> 00:48:44,800
are able to get polylog bandwidth

1206
00:48:44,800 --> 00:48:48,000
and constant rounds but

1207
00:48:48,000 --> 00:48:51,599
they do require local server computation

1208
00:48:51,599 --> 00:48:53,760
on each server in order to answer a

1209
00:48:53,760 --> 00:48:55,520
particular query

1210
00:48:55,520 --> 00:48:58,880
uh directy and wei in 2018 have sort of

1211
00:48:58,880 --> 00:49:01,359
the best asymptotics across the board

1212
00:49:01,359 --> 00:49:04,400
but they require non-constant rounds in

1213
00:49:04,400 --> 00:49:05,440
cases where

1214
00:49:05,440 --> 00:49:08,559
bandwidth is

1215
00:49:08,800 --> 00:49:11,040
not so much an issue but latency between

1216
00:49:11,040 --> 00:49:12,960
rounds are

1217
00:49:12,960 --> 00:49:15,040
a non-constant number of rounds is

1218
00:49:15,040 --> 00:49:16,800
really not ideal

1219
00:49:16,800 --> 00:49:19,440
so in this talk i introduce the first

1220
00:49:19,440 --> 00:49:20,559
two constructions

1221
00:49:20,559 --> 00:49:23,520
in the secure computation for do-ram

1222
00:49:23,520 --> 00:49:24,319
model

1223
00:49:24,319 --> 00:49:26,720
that achieve a sub-linear local

1224
00:49:26,720 --> 00:49:27,599
computation

1225
00:49:27,599 --> 00:49:30,559
and constant rounds the first of which

1226
00:49:30,559 --> 00:49:33,119
is a sublinear doram that obtains

1227
00:49:33,119 --> 00:49:35,760
square root log n where n is database

1228
00:49:35,760 --> 00:49:36,240
size

1229
00:49:36,240 --> 00:49:38,800
local computation and bandwidth and

1230
00:49:38,800 --> 00:49:40,319
constant rounds

1231
00:49:40,319 --> 00:49:43,119
this is based on an adaptation of square

1232
00:49:43,119 --> 00:49:44,400
root oram

1233
00:49:44,400 --> 00:49:47,359
and second we'll briefly go over the

1234
00:49:47,359 --> 00:49:48,240
construction

1235
00:49:48,240 --> 00:49:51,920
for our unlimited reads doram

1236
00:49:51,920 --> 00:49:54,559
where we leak the difference between

1237
00:49:54,559 --> 00:49:56,000
reads and writes

1238
00:49:56,000 --> 00:49:58,240
and assume that reeds are much more

1239
00:49:58,240 --> 00:50:00,160
common than writes

1240
00:50:00,160 --> 00:50:01,839
and this allows us to get better

1241
00:50:01,839 --> 00:50:04,480
asthmatic performance

1242
00:50:04,480 --> 00:50:06,640
so for the rest of the talk i briefly

1243
00:50:06,640 --> 00:50:08,559
want to go over our sublinear doram

1244
00:50:08,559 --> 00:50:10,240
construction

1245
00:50:10,240 --> 00:50:12,000
and how we managed to do that in

1246
00:50:12,000 --> 00:50:14,000
constant rounds

1247
00:50:14,000 --> 00:50:16,160
as i said before it is based on square

1248
00:50:16,160 --> 00:50:18,079
root o ram and there are two main

1249
00:50:18,079 --> 00:50:19,280
problems

1250
00:50:19,280 --> 00:50:21,200
in adapting this to the secure

1251
00:50:21,200 --> 00:50:22,559
computation setting

1252
00:50:22,559 --> 00:50:24,480
rather than just sort of applying a

1253
00:50:24,480 --> 00:50:26,079
generic mpc

1254
00:50:26,079 --> 00:50:29,680
compiler to a square root orm client

1255
00:50:29,680 --> 00:50:33,040
which would result not necessarily in

1256
00:50:33,040 --> 00:50:35,920
sub-linear local computation our two

1257
00:50:35,920 --> 00:50:36,880
main problems

1258
00:50:36,880 --> 00:50:40,559
are reshuffling the um

1259
00:50:40,559 --> 00:50:42,960
stash back into the store in constant

1260
00:50:42,960 --> 00:50:44,960
rounds at the end of an epoch

1261
00:50:44,960 --> 00:50:48,160
and the second is representing the

1262
00:50:48,160 --> 00:50:49,119
permutation

1263
00:50:49,119 --> 00:50:52,400
over the data in the store in a way that

1264
00:50:52,400 --> 00:50:53,839
is

1265
00:50:53,839 --> 00:50:57,520
conducive to the secure computation uh

1266
00:50:57,520 --> 00:51:00,000
sort of environment so i'm gonna go over

1267
00:51:00,000 --> 00:51:02,480
how we solve those two problems

1268
00:51:02,480 --> 00:51:06,160
um at a high level our two servers

1269
00:51:06,160 --> 00:51:09,440
store um as their store

1270
00:51:09,440 --> 00:51:12,000
a permuted additively secret shared

1271
00:51:12,000 --> 00:51:13,119
database

1272
00:51:13,119 --> 00:51:16,160
so both servers have the same

1273
00:51:16,160 --> 00:51:19,359
permutation um and uh

1274
00:51:19,359 --> 00:51:23,119
sort of also store um the permeated

1275
00:51:23,119 --> 00:51:25,280
secret shared database is a read-only

1276
00:51:25,280 --> 00:51:26,480
data structure

1277
00:51:26,480 --> 00:51:28,960
in addition to that they also store a

1278
00:51:28,960 --> 00:51:30,000
stash

1279
00:51:30,000 --> 00:51:33,040
which is going to be a read and write

1280
00:51:33,040 --> 00:51:35,680
um where updates can be sort of

1281
00:51:35,680 --> 00:51:36,640
cataloged

1282
00:51:36,640 --> 00:51:39,200
until the end of an epoch where they're

1283
00:51:39,200 --> 00:51:41,520
shuffled back into this permuted secret

1284
00:51:41,520 --> 00:51:43,520
shared database

1285
00:51:43,520 --> 00:51:46,720
so when an operation is submitted

1286
00:51:46,720 --> 00:51:48,880
to a doram in the secure computation

1287
00:51:48,880 --> 00:51:50,000
model the operation

1288
00:51:50,000 --> 00:51:52,960
itself and the index to be read are also

1289
00:51:52,960 --> 00:51:54,720
additively secret shared

1290
00:51:54,720 --> 00:51:56,240
so the server does not know what

1291
00:51:56,240 --> 00:51:57,760
operation or which index

1292
00:51:57,760 --> 00:52:01,760
it is sort of emulating the client on

1293
00:52:01,760 --> 00:52:05,280
a read operation basically takes three

1294
00:52:05,280 --> 00:52:05,920
steps

1295
00:52:05,920 --> 00:52:08,480
um as very much like square root o ram

1296
00:52:08,480 --> 00:52:10,720
we simply scan the stash

1297
00:52:10,720 --> 00:52:12,720
um to see if the record is already there

1298
00:52:12,720 --> 00:52:15,440
depending on that outcome we either read

1299
00:52:15,440 --> 00:52:18,880
a dummy or the actual index

1300
00:52:18,880 --> 00:52:22,400
from our store and this is where

1301
00:52:22,400 --> 00:52:25,040
we first come across how do we represent

1302
00:52:25,040 --> 00:52:27,200
this permutation over our secret shared

1303
00:52:27,200 --> 00:52:28,240
database

1304
00:52:28,240 --> 00:52:30,240
the way we do this is to leverage

1305
00:52:30,240 --> 00:52:32,240
oblivious pseudorandom functions or

1306
00:52:32,240 --> 00:52:33,680
oprfs

1307
00:52:33,680 --> 00:52:37,040
at a high level oprfs allow you to have

1308
00:52:37,040 --> 00:52:40,079
the key and the point to be evaluated

1309
00:52:40,079 --> 00:52:41,119
for the prf

1310
00:52:41,119 --> 00:52:44,160
secret shared amongst two parties and

1311
00:52:44,160 --> 00:52:45,280
during the evaluation

1312
00:52:45,280 --> 00:52:46,800
they didn't learn anything about the

1313
00:52:46,800 --> 00:52:48,960
other person's input but they both

1314
00:52:48,960 --> 00:52:51,520
do in fact learn the output so that is

1315
00:52:51,520 --> 00:52:53,040
exactly what we do

1316
00:52:53,040 --> 00:52:56,160
each server has their own prf key um

1317
00:52:56,160 --> 00:52:59,040
the read index is uh secret shared

1318
00:52:59,040 --> 00:53:00,319
amongst the two

1319
00:53:00,319 --> 00:53:03,280
um and we output and get essentially the

1320
00:53:03,280 --> 00:53:04,240
prf

1321
00:53:04,240 --> 00:53:07,599
evaluation on this point um we then

1322
00:53:07,599 --> 00:53:09,680
are able to look up in the permuted

1323
00:53:09,680 --> 00:53:11,040
secret shared database

1324
00:53:11,040 --> 00:53:13,280
that is sort of sorted according to

1325
00:53:13,280 --> 00:53:14,880
these tax

1326
00:53:14,880 --> 00:53:17,440
recover the shares of that as part of

1327
00:53:17,440 --> 00:53:19,119
this step

1328
00:53:19,119 --> 00:53:22,160
then finally we write this back to the

1329
00:53:22,160 --> 00:53:24,559
stash at the current index and increment

1330
00:53:24,559 --> 00:53:27,359
that index

1331
00:53:27,520 --> 00:53:30,720
so rights are fairly similar um

1332
00:53:30,720 --> 00:53:34,000
they only differ in one regard which is

1333
00:53:34,000 --> 00:53:35,440
in this third step

1334
00:53:35,440 --> 00:53:37,200
where we go to write something back to

1335
00:53:37,200 --> 00:53:38,480
the stash

1336
00:53:38,480 --> 00:53:41,920
um and in this instead of writing at the

1337
00:53:41,920 --> 00:53:43,200
current index

1338
00:53:43,200 --> 00:53:46,240
um we are if we sort of

1339
00:53:46,240 --> 00:53:48,800
during the initial scan find the place

1340
00:53:48,800 --> 00:53:50,480
where that element is stored

1341
00:53:50,480 --> 00:53:52,640
when we write back to the stash we write

1342
00:53:52,640 --> 00:53:54,640
it back to that specific location if

1343
00:53:54,640 --> 00:53:56,319
it's already there

1344
00:53:56,319 --> 00:53:58,800
and this is important to maintain sort

1345
00:53:58,800 --> 00:54:01,440
of our constant round shuffling

1346
00:54:01,440 --> 00:54:04,079
so in particular the invariant that if

1347
00:54:04,079 --> 00:54:06,240
an element has been read or written to

1348
00:54:06,240 --> 00:54:07,119
already

1349
00:54:07,119 --> 00:54:09,920
it is in the stash and each element only

1350
00:54:09,920 --> 00:54:11,200
occurs in the stash

1351
00:54:11,200 --> 00:54:14,319
once this allows us to essentially

1352
00:54:14,319 --> 00:54:17,119
reshuffle in constant rounds in a fairly

1353
00:54:17,119 --> 00:54:19,200
straightforward way

1354
00:54:19,200 --> 00:54:21,119
essentially what we do is we note that

1355
00:54:21,119 --> 00:54:22,559
the unread elements

1356
00:54:22,559 --> 00:54:25,200
are public information essentially to

1357
00:54:25,200 --> 00:54:26,240
each server

1358
00:54:26,240 --> 00:54:28,800
so since we're only reading each element

1359
00:54:28,800 --> 00:54:29,520
in the stash

1360
00:54:29,520 --> 00:54:31,920
once we simply take those unread

1361
00:54:31,920 --> 00:54:34,480
elements at the end of an epoch

1362
00:54:34,480 --> 00:54:36,559
and know that the rest of them are going

1363
00:54:36,559 --> 00:54:38,160
to be in the stash

1364
00:54:38,160 --> 00:54:40,720
and so all we have to do is concatenate

1365
00:54:40,720 --> 00:54:42,000
the two of them together

1366
00:54:42,000 --> 00:54:44,400
uh permute them obliviously between the

1367
00:54:44,400 --> 00:54:45,520
two servers

1368
00:54:45,520 --> 00:54:48,319
and then apply a new prf key for a new

1369
00:54:48,319 --> 00:54:49,440
permutation

1370
00:54:49,440 --> 00:54:51,839
so shuffling becomes constant rounds and

1371
00:54:51,839 --> 00:54:54,240
fairly straightforward

1372
00:54:54,240 --> 00:54:57,280
um so yay new prf key

1373
00:54:57,280 --> 00:55:00,480
um we also provide a doram with

1374
00:55:00,480 --> 00:55:03,839
unlimited reads namely we leak the

1375
00:55:03,839 --> 00:55:05,359
difference between reads and writes and

1376
00:55:05,359 --> 00:55:08,079
assume reads are much more common

1377
00:55:08,079 --> 00:55:11,280
we assume we essentially add a second

1378
00:55:11,280 --> 00:55:14,319
store to each database using a

1379
00:55:14,319 --> 00:55:17,280
appear that has sub-linear server

1380
00:55:17,280 --> 00:55:19,599
computation so a secret key deep here by

1381
00:55:19,599 --> 00:55:21,920
canadian all and boyle at all

1382
00:55:21,920 --> 00:55:24,079
that has an encoding of the database

1383
00:55:24,079 --> 00:55:26,319
shares reads happen only from this

1384
00:55:26,319 --> 00:55:29,839
database and rights will happen as usual

1385
00:55:29,839 --> 00:55:33,119
secret key deep here is

1386
00:55:33,119 --> 00:55:35,680
kind of highly amenable to this and

1387
00:55:35,680 --> 00:55:37,599
provides a modular extension for pretty

1388
00:55:37,599 --> 00:55:38,079
much

1389
00:55:38,079 --> 00:55:40,319
any dorm in the setting in order to

1390
00:55:40,319 --> 00:55:42,720
approve improve asthmatics

1391
00:55:42,720 --> 00:55:43,920
when we assume sort of this

1392
00:55:43,920 --> 00:55:46,720
differentiation between reads and writes

1393
00:55:46,720 --> 00:55:49,440
as i just said secret kdpir is mostly

1394
00:55:49,440 --> 00:55:51,599
local linear ultra computations

1395
00:55:51,599 --> 00:55:53,839
so this easily allows us to perform

1396
00:55:53,839 --> 00:55:55,440
constant rounds

1397
00:55:55,440 --> 00:55:58,079
um and of independent interest we do

1398
00:55:58,079 --> 00:55:59,119
provide

1399
00:55:59,119 --> 00:56:01,920
a fast fourier transform a secure

1400
00:56:01,920 --> 00:56:03,280
computation protocol

1401
00:56:03,280 --> 00:56:05,760
that is able to sort of run in

1402
00:56:05,760 --> 00:56:07,200
quasi-linear time

1403
00:56:07,200 --> 00:56:10,079
with only local computations and we use

1404
00:56:10,079 --> 00:56:10,559
this

1405
00:56:10,559 --> 00:56:12,960
in our secret pdp here for polynomial

1406
00:56:12,960 --> 00:56:15,599
interpolation and evaluations

1407
00:56:15,599 --> 00:56:19,440
so in summary we're able to get two

1408
00:56:19,440 --> 00:56:21,440
protocols the first of which that have

1409
00:56:21,440 --> 00:56:23,680
sublinear local computation and constant

1410
00:56:23,680 --> 00:56:25,839
rounds in the secure computation

1411
00:56:25,839 --> 00:56:28,319
uh do-ram setting and we're able to get

1412
00:56:28,319 --> 00:56:29,520
better performances

1413
00:56:29,520 --> 00:56:31,119
when we sort of leak the difference

1414
00:56:31,119 --> 00:56:32,720
between reads and rights

1415
00:56:32,720 --> 00:56:35,440
um thank you for listening to my talk

1416
00:56:35,440 --> 00:56:37,119
please feel free to reach out to me if

1417
00:56:37,119 --> 00:56:38,960
you have any questions i will note i

1418
00:56:38,960 --> 00:56:40,880
have not been able to get on the zulu

1419
00:56:40,880 --> 00:56:42,640
chat so please feel free to reach out to

1420
00:56:42,640 --> 00:56:45,599
me via email

1421
00:56:45,599 --> 00:56:48,720
they both should be on the eprint

1422
00:56:48,720 --> 00:56:52,559
so thank you yeah thanks ariel for the

1423
00:56:52,559 --> 00:56:53,599
interesting talk

1424
00:56:53,599 --> 00:56:59,839
we have time for a quick question

1425
00:57:03,440 --> 00:57:06,079
ah so i have a question so how does this

1426
00:57:06,079 --> 00:57:06,960
oprf

1427
00:57:06,960 --> 00:57:09,040
assumption compare with the prior

1428
00:57:09,040 --> 00:57:10,839
non-constant on

1429
00:57:10,839 --> 00:57:13,599
protocol uh so do they also need

1430
00:57:13,599 --> 00:57:15,680
oprf or can they do it from better

1431
00:57:15,680 --> 00:57:17,040
essentials

1432
00:57:17,040 --> 00:57:20,799
so um our opr can the particular

1433
00:57:20,799 --> 00:57:23,040
instantiation is based on elgamal

1434
00:57:23,040 --> 00:57:26,640
encryption um the strongest assumption

1435
00:57:26,640 --> 00:57:28,400
is actually hiding in our

1436
00:57:28,400 --> 00:57:31,760
unlimited reads doe ram um which is

1437
00:57:31,760 --> 00:57:35,119
a new coding assumption based on noisy

1438
00:57:35,119 --> 00:57:38,319
uh permuted read muller coats but in our

1439
00:57:38,319 --> 00:57:40,079
sublinear doram

1440
00:57:40,079 --> 00:57:42,960
um our our assumptions are are

1441
00:57:42,960 --> 00:57:44,319
relatively minimal

1442
00:57:44,319 --> 00:57:47,920
based on um sort of the underlying

1443
00:57:47,920 --> 00:57:48,640
assumptions

1444
00:57:48,640 --> 00:57:50,799
of the dorm that we use for our to

1445
00:57:50,799 --> 00:57:52,880
implement our stash

1446
00:57:52,880 --> 00:57:55,599
which relies on functional secret

1447
00:57:55,599 --> 00:57:56,400
sharing

1448
00:57:56,400 --> 00:57:58,160
and then our own construction really

1449
00:57:58,160 --> 00:57:59,440
only relies on

1450
00:57:59,440 --> 00:58:03,680
um uh additively homomorphic encryption

1451
00:58:03,680 --> 00:58:04,799
and algomal for

1452
00:58:04,799 --> 00:58:09,839
our opr

1453
00:58:10,240 --> 00:58:13,439
or any other questions

1454
00:58:15,440 --> 00:58:18,480
so let's thank ariel again

1455
00:58:18,480 --> 00:58:22,240
uh so so the next uh is a

1456
00:58:22,240 --> 00:58:25,839
joint talk of two papers

1457
00:58:25,839 --> 00:58:28,480
so the first is multi-party cardinality

1458
00:58:28,480 --> 00:58:29,280
testing for

1459
00:58:29,280 --> 00:58:31,280
threshold private set intersection by

1460
00:58:31,280 --> 00:58:33,920
petro branco nico dotling and srihanku

1461
00:58:33,920 --> 00:58:34,960
and the

1462
00:58:34,960 --> 00:58:37,760
next is multi-party threshold private

1463
00:58:37,760 --> 00:58:39,280
sector intersection with sublinear

1464
00:58:39,280 --> 00:58:41,280
communication by say krishna payhan

1465
00:58:41,280 --> 00:58:42,240
srinivasan

1466
00:58:42,240 --> 00:58:44,959
and peter

1467
00:58:45,359 --> 00:58:51,280
so yeah payhan will be

1468
00:58:51,280 --> 00:58:53,760
uh thanks actually for the introduction

1469
00:58:53,760 --> 00:58:55,920
this is a soft merge of two papers

1470
00:58:55,920 --> 00:58:57,760
and i will go first and sahan will

1471
00:58:57,760 --> 00:58:59,040
present the other one

1472
00:58:59,040 --> 00:59:01,119
uh so our work is multi-party threshold

1473
00:59:01,119 --> 00:59:03,040
private set intersection with sub linear

1474
00:59:03,040 --> 00:59:04,160
communication

1475
00:59:04,160 --> 00:59:05,680
it's joined to work with sai krishna

1476
00:59:05,680 --> 00:59:09,040
srinivasan and peter from visa research

1477
00:59:09,040 --> 00:59:12,079
um we start with the problem of private

1478
00:59:12,079 --> 00:59:14,079
sector intersection or psi

1479
00:59:14,079 --> 00:59:16,799
for short or there are two parties alice

1480
00:59:16,799 --> 00:59:17,440
and bob

1481
00:59:17,440 --> 00:59:20,160
each of them has a private set x and y

1482
00:59:20,160 --> 00:59:21,680
and i want to jointly compute the

1483
00:59:21,680 --> 00:59:23,200
intersection of the two sets

1484
00:59:23,200 --> 00:59:25,520
but nothing more and more generally we

1485
00:59:25,520 --> 00:59:27,599
can consider multi-party psi

1486
00:59:27,599 --> 00:59:29,520
where there are multiple parties each

1487
00:59:29,520 --> 00:59:30,960
having a private set

1488
00:59:30,960 --> 00:59:32,559
and they want to jointly compute the

1489
00:59:32,559 --> 00:59:34,640
introduction of all the sets but nothing

1490
00:59:34,640 --> 00:59:35,839
more

1491
00:59:35,839 --> 00:59:38,160
but in certain scenarios psi as a

1492
00:59:38,160 --> 00:59:39,440
functionality is not

1493
00:59:39,440 --> 00:59:41,920
enough we need something stronger for

1494
00:59:41,920 --> 00:59:43,839
example threshold psi

1495
00:59:43,839 --> 00:59:45,680
where the parties are only supposed to

1496
00:59:45,680 --> 00:59:46,880
learn the introduction

1497
00:59:46,880 --> 00:59:48,880
if the intersection is sufficiently

1498
00:59:48,880 --> 00:59:50,319
large

1499
00:59:50,319 --> 00:59:52,000
more generally in the multi-party

1500
00:59:52,000 --> 00:59:53,920
scenario they're only supposed to learn

1501
00:59:53,920 --> 00:59:55,680
the intersection if the intersection of

1502
00:59:55,680 --> 00:59:56,720
all the sets

1503
00:59:56,720 --> 00:59:59,760
is sufficiently large for example in

1504
00:59:59,760 --> 01:00:01,760
privacy preserving right sharing

1505
01:00:01,760 --> 01:00:03,680
the parties might only want to share

1506
01:00:03,680 --> 01:00:05,760
right if their common trajectory is

1507
01:00:05,760 --> 01:00:07,520
sufficiently long

1508
01:00:07,520 --> 01:00:09,359
the next question is how to achieve

1509
01:00:09,359 --> 01:00:10,960
threshold psi

1510
01:00:10,960 --> 01:00:13,119
a natural approach is to first compute

1511
01:00:13,119 --> 01:00:14,799
the psi cardinality

1512
01:00:14,799 --> 01:00:16,799
which is the size of the intersection

1513
01:00:16,799 --> 01:00:18,559
and then check if it is sufficiently

1514
01:00:18,559 --> 01:00:19,359
large

1515
01:00:19,359 --> 01:00:21,119
following that approach the best

1516
01:00:21,119 --> 01:00:22,880
communication complexity

1517
01:00:22,880 --> 01:00:25,280
is of order m where m is the size of the

1518
01:00:25,280 --> 01:00:25,920
smallest

1519
01:00:25,920 --> 01:00:29,040
set and this is tight so

1520
01:00:29,040 --> 01:00:30,799
does that mean this is the best

1521
01:00:30,799 --> 01:00:33,040
communication complexity we can hope for

1522
01:00:33,040 --> 01:00:35,760
for threshold psi surprisingly the

1523
01:00:35,760 --> 01:00:37,280
answer is no

1524
01:00:37,280 --> 01:00:39,599
in a recent work by gauss and simkin in

1525
01:00:39,599 --> 01:00:40,640
2019

1526
01:00:40,640 --> 01:00:42,319
they developed a new approach for

1527
01:00:42,319 --> 01:00:44,079
two-party threshold psi

1528
01:00:44,079 --> 01:00:46,880
to get a round of this communication

1529
01:00:46,880 --> 01:00:47,920
lower bound

1530
01:00:47,920 --> 01:00:51,119
by doing cardinality testing so they can

1531
01:00:51,119 --> 01:00:53,280
reduce the communication complexity

1532
01:00:53,280 --> 01:00:55,599
to only grow with the size of the set

1533
01:00:55,599 --> 01:00:56,880
difference

1534
01:00:56,880 --> 01:00:59,920
in particular the two parties can only

1535
01:00:59,920 --> 01:01:01,200
learn the intersection

1536
01:01:01,200 --> 01:01:04,400
if the total size of the set difference

1537
01:01:04,400 --> 01:01:06,640
is less than or equal to t or t the

1538
01:01:06,640 --> 01:01:08,960
threshold

1539
01:01:08,960 --> 01:01:11,920
in particular they construct two

1540
01:01:11,920 --> 01:01:12,720
protocols

1541
01:01:12,720 --> 01:01:14,160
one based on fully homomorphic

1542
01:01:14,160 --> 01:01:16,559
encryption with communication complexity

1543
01:01:16,559 --> 01:01:17,680
of order t

1544
01:01:17,680 --> 01:01:19,200
and another based on additively

1545
01:01:19,200 --> 01:01:20,720
homomorphic encryption with

1546
01:01:20,720 --> 01:01:22,839
communication complexity roughly t

1547
01:01:22,839 --> 01:01:25,359
squared further they show a

1548
01:01:25,359 --> 01:01:26,880
communication lower bound

1549
01:01:26,880 --> 01:01:29,280
for such kind of cardinality testing

1550
01:01:29,280 --> 01:01:30,960
let's order t

1551
01:01:30,960 --> 01:01:32,960
and in this work we ask the following

1552
01:01:32,960 --> 01:01:34,319
two questions

1553
01:01:34,319 --> 01:01:36,240
first can we extend the two-party

1554
01:01:36,240 --> 01:01:38,640
threshold psi to the multi-party case

1555
01:01:38,640 --> 01:01:41,040
and second can we bridge the gap between

1556
01:01:41,040 --> 01:01:42,480
upper bound and lower bound

1557
01:01:42,480 --> 01:01:45,280
from assumptions weaker than fhe and

1558
01:01:45,280 --> 01:01:47,200
before we talk about our results

1559
01:01:47,200 --> 01:01:49,040
i want to take a step back and think

1560
01:01:49,040 --> 01:01:50,799
about the formal definition for

1561
01:01:50,799 --> 01:01:53,760
multiparty threshold psi in particular

1562
01:01:53,760 --> 01:01:55,039
what does

1563
01:01:55,039 --> 01:01:57,440
what does sufficiently large mean how to

1564
01:01:57,440 --> 01:01:59,119
define it

1565
01:01:59,119 --> 01:02:00,799
and actually there are different ways to

1566
01:02:00,799 --> 01:02:03,680
define it at a very high level

1567
01:02:03,680 --> 01:02:06,559
the first option considers more on

1568
01:02:06,559 --> 01:02:08,240
whether the setting transaction is

1569
01:02:08,240 --> 01:02:09,440
sufficiently large

1570
01:02:09,440 --> 01:02:11,599
and the second option considers if the

1571
01:02:11,599 --> 01:02:13,280
entire set difference

1572
01:02:13,280 --> 01:02:15,839
is sufficiently small they seem to be

1573
01:02:15,839 --> 01:02:17,520
defining the same thing from two

1574
01:02:17,520 --> 01:02:19,119
different perspectives

1575
01:02:19,119 --> 01:02:21,039
and in fact they are equivalent in the

1576
01:02:21,039 --> 01:02:22,240
two-party scenario

1577
01:02:22,240 --> 01:02:24,799
but they're not in a multi-party case

1578
01:02:24,799 --> 01:02:26,720
and for that reason we consider both

1579
01:02:26,720 --> 01:02:28,319
functionalities

1580
01:02:28,319 --> 01:02:30,480
and we study both the communication

1581
01:02:30,480 --> 01:02:32,960
lower bond and communication upper bound

1582
01:02:32,960 --> 01:02:35,520
for both functionalities with the

1583
01:02:35,520 --> 01:02:36,480
complexities

1584
01:02:36,480 --> 01:02:38,640
showing the table where n is the number

1585
01:02:38,640 --> 01:02:39,520
of parties

1586
01:02:39,520 --> 01:02:42,319
and t is the threshold for upper bound

1587
01:02:42,319 --> 01:02:44,880
we construct three different protocols

1588
01:02:44,880 --> 01:02:46,640
from an outer band threshold for the

1589
01:02:46,640 --> 01:02:48,000
homomorphic encryption

1590
01:02:48,000 --> 01:02:50,000
or threshold actively homomorphic

1591
01:02:50,000 --> 01:02:52,000
encryption and all the protocols are

1592
01:02:52,000 --> 01:02:52,799
secure against

1593
01:02:52,799 --> 01:02:55,280
semi-honest adversaries corrupting them

1594
01:02:55,280 --> 01:02:57,280
up to n minus one parties

1595
01:02:57,280 --> 01:03:00,480
i want to point out here when n equals

1596
01:03:00,480 --> 01:03:00,960
two

1597
01:03:00,960 --> 01:03:04,319
then this protocol gives a new two-party

1598
01:03:04,319 --> 01:03:05,680
threshold psi

1599
01:03:05,680 --> 01:03:07,599
from additively homomorphic encryption

1600
01:03:07,599 --> 01:03:09,920
with communication complexity

1601
01:03:09,920 --> 01:03:12,319
better than the prior work as i

1602
01:03:12,319 --> 01:03:13,680
mentioned earlier

1603
01:03:13,680 --> 01:03:15,920
and the very very high level idea is

1604
01:03:15,920 --> 01:03:18,079
that the prior work gs19

1605
01:03:18,079 --> 01:03:20,160
reduces the problem of cardinality

1606
01:03:20,160 --> 01:03:22,480
testing to the problem of testing

1607
01:03:22,480 --> 01:03:23,520
singularity

1608
01:03:23,520 --> 01:03:26,400
of a handhold matrix and then they stop

1609
01:03:26,400 --> 01:03:26,880
there

1610
01:03:26,880 --> 01:03:30,079
to do a two pc for this task but we

1611
01:03:30,079 --> 01:03:32,559
take a further step to reduce this

1612
01:03:32,559 --> 01:03:34,160
problem to another problem

1613
01:03:34,160 --> 01:03:36,880
called half gcd which can be solved in

1614
01:03:36,880 --> 01:03:37,440
time

1615
01:03:37,440 --> 01:03:40,480
t log square t so we can reduce both the

1616
01:03:40,480 --> 01:03:41,839
communication complexity and

1617
01:03:41,839 --> 01:03:44,480
computational complexity

1618
01:03:44,480 --> 01:03:46,160
to summarize we study both

1619
01:03:46,160 --> 01:03:48,240
functionalities for multiparty threshold

1620
01:03:48,240 --> 01:03:49,039
psi

1621
01:03:49,039 --> 01:03:51,119
and we show various lower bound and

1622
01:03:51,119 --> 01:03:52,240
upper bound

1623
01:03:52,240 --> 01:03:54,799
in a concurrent work bronco dotary and

1624
01:03:54,799 --> 01:03:56,160
pool

1625
01:03:56,160 --> 01:03:58,319
complement our work by showing a

1626
01:03:58,319 --> 01:03:59,359
protocol for

1627
01:03:59,359 --> 01:04:01,599
the first functionality from threshold

1628
01:04:01,599 --> 01:04:03,359
activity homophilic encryption

1629
01:04:03,359 --> 01:04:06,400
with this much communication complexity

1630
01:04:06,400 --> 01:04:10,240
and so how is going to present their

1631
01:04:10,839 --> 01:04:13,839
work

1632
01:04:24,839 --> 01:04:27,839
uh

1633
01:04:29,599 --> 01:04:32,079
so since for introduction uh can you see

1634
01:04:32,079 --> 01:04:34,640
my screen

1635
01:04:42,480 --> 01:04:45,119
okay um okay uh thanks for the

1636
01:04:45,119 --> 01:04:46,799
introduction uh ms hung

1637
01:04:46,799 --> 01:04:49,520
uh i represent our work about uh my

1638
01:04:49,520 --> 01:04:51,520
particular multitasking for

1639
01:04:51,520 --> 01:04:54,000
structural psi uh which is joining work

1640
01:04:54,000 --> 01:05:09,839
with a pedophile

1641
01:05:13,359 --> 01:05:16,720
so we mainly focus on the functionality

1642
01:05:16,720 --> 01:05:20,240
uh as uh mentioned we only focus on the

1643
01:05:20,240 --> 01:05:24,160
function the fc test means uh

1644
01:05:24,160 --> 01:05:26,880
they only check their criminality if the

1645
01:05:26,880 --> 01:05:29,680
intersection is large enough

1646
01:05:29,680 --> 01:05:31,920
let's first see what happens uh when we

1647
01:05:31,920 --> 01:05:34,160
directly extend just 19 approach to

1648
01:05:34,160 --> 01:05:37,359
multi-party setting so um

1649
01:05:37,359 --> 01:05:40,720
for each m stat set uh encoded as a

1650
01:05:40,720 --> 01:05:43,280
n term polynomial then we can show the

1651
01:05:43,280 --> 01:05:44,079
difference

1652
01:05:44,079 --> 01:05:47,599
among n parts polynomials

1653
01:05:47,599 --> 01:05:50,079
assuming the intersection cardinality is

1654
01:05:50,079 --> 01:05:51,359
m minus t

1655
01:05:51,359 --> 01:05:55,119
m is a each step size so this is a

1656
01:05:55,119 --> 01:05:58,000
binomial the regarding polynomial with

1657
01:05:58,000 --> 01:05:59,680
degree n times t

1658
01:05:59,680 --> 01:06:02,240
so um the problem is uh if we want to

1659
01:06:02,240 --> 01:06:02,720
check

1660
01:06:02,720 --> 01:06:04,640
if this is a sparse polynomial but

1661
01:06:04,640 --> 01:06:06,480
location codes for each party will

1662
01:06:06,480 --> 01:06:06,960
depend

1663
01:06:06,960 --> 01:06:09,920
on the number of parties n which is a

1664
01:06:09,920 --> 01:06:10,880
highly desired

1665
01:06:10,880 --> 01:06:14,319
in our case our approach avoids this

1666
01:06:14,319 --> 01:06:15,200
blow up for

1667
01:06:15,200 --> 01:06:17,440
for each party let's first consider the

1668
01:06:17,440 --> 01:06:21,280
insecure way to do a cardinality test

1669
01:06:21,280 --> 01:06:24,400
so for uh each for each encoding we use

1670
01:06:24,400 --> 01:06:24,640
a

1671
01:06:24,640 --> 01:06:27,599
catalytic characteristic polynomial

1672
01:06:27,599 --> 01:06:29,200
being called each set

1673
01:06:29,200 --> 01:06:33,200
before uh um m such set we encoded as a

1674
01:06:33,200 --> 01:06:35,920
m degree polynomial and for all of

1675
01:06:35,920 --> 01:06:37,200
encoded polynomials

1676
01:06:37,200 --> 01:06:39,760
we can choose a rational function as

1677
01:06:39,760 --> 01:06:40,559
follows

1678
01:06:40,559 --> 01:06:43,039
so after cancelling all the common

1679
01:06:43,039 --> 01:06:44,480
factors

1680
01:06:44,480 --> 01:06:46,720
the resulting rational function i have

1681
01:06:46,720 --> 01:06:48,000
degree p

1682
01:06:48,000 --> 01:06:50,240
at most is uh intersection size is

1683
01:06:50,240 --> 01:06:51,440
larger than m

1684
01:06:51,440 --> 01:06:55,520
minus t m is a set size as i

1685
01:06:55,520 --> 01:06:59,359
mentioned before so uh

1686
01:06:59,359 --> 01:07:02,319
uh so other clinic tests can boils down

1687
01:07:02,319 --> 01:07:02,640
to

1688
01:07:02,640 --> 01:07:05,119
the foreign degree class problem so

1689
01:07:05,119 --> 01:07:05,760
given a

1690
01:07:05,760 --> 01:07:08,960
rational function f of x can we decide

1691
01:07:08,960 --> 01:07:09,760
if the degree

1692
01:07:09,760 --> 01:07:14,000
of this um both polynomials um

1693
01:07:14,000 --> 01:07:16,559
it's smaller than t with only all of the

1694
01:07:16,559 --> 01:07:17,760
evaluation points

1695
01:07:17,760 --> 01:07:21,440
of this uh rational function f of x

1696
01:07:21,440 --> 01:07:25,280
our answer is uh our main observation is

1697
01:07:25,280 --> 01:07:28,640
it will interpolate this ratio function

1698
01:07:28,640 --> 01:07:31,839
on two different support sets v and w to

1699
01:07:31,839 --> 01:07:32,640
get f v

1700
01:07:32,640 --> 01:07:36,000
and f w respectively where f of x

1701
01:07:36,000 --> 01:07:38,079
is some unknown reduced rational

1702
01:07:38,079 --> 01:07:39,280
function

1703
01:07:39,280 --> 01:07:42,000
which means p1 and p2 are grouped one

1704
01:07:42,000 --> 01:07:44,400
polynomials

1705
01:07:44,400 --> 01:07:47,440
then we have fv equals to w if the

1706
01:07:47,440 --> 01:07:49,200
degree is smaller than t

1707
01:07:49,200 --> 01:07:52,400
otherwise they are not equal except with

1708
01:07:52,400 --> 01:07:52,640
a

1709
01:07:52,640 --> 01:07:55,680
negligible probability

1710
01:07:55,680 --> 01:07:58,480
so also note that interpolating a

1711
01:07:58,480 --> 01:07:59,520
rational function

1712
01:07:59,520 --> 01:08:01,680
can be reduced to solving linear system

1713
01:08:01,680 --> 01:08:02,799
equations

1714
01:08:02,799 --> 01:08:05,359
by extending secure linear algebra tools

1715
01:08:05,359 --> 01:08:06,720
to multiply the case

1716
01:08:06,720 --> 01:08:11,039
we can securely perform the test above

1717
01:08:11,039 --> 01:08:13,680
and we prove our security in

1718
01:08:13,680 --> 01:08:16,560
externalized uc framework

1719
01:08:16,560 --> 01:08:18,238
we conclude we present a multi-party

1720
01:08:18,238 --> 01:08:21,040
called analytic test for structural psi

1721
01:08:21,040 --> 01:08:23,040
whose communication capacity only

1722
01:08:23,040 --> 01:08:27,439
depends on the strategy for each party

1723
01:08:27,520 --> 01:08:30,880
that's all that's for our internship

1724
01:08:33,120 --> 01:08:36,719
thanks uh for the interesting talk so

1725
01:08:36,719 --> 01:08:40,399
we have time for one quick question to

1726
01:08:40,399 --> 01:08:43,278
either one of them

1727
01:08:51,040 --> 01:08:54,238
so uh if there are no further questions

1728
01:08:54,238 --> 01:08:55,040
uh

1729
01:08:55,040 --> 01:08:58,799
so let's thank the speakers

1730
01:08:58,799 --> 01:09:00,880
again and uh let's thank all the

1731
01:09:00,880 --> 01:09:03,120
speakers for this session

1732
01:09:03,120 --> 01:09:06,319
uh so yeah so this brings

1733
01:09:06,319 --> 01:09:08,560
close to the session on cryptographic

1734
01:09:08,560 --> 01:09:10,560
protocols and secure computation part

1735
01:09:10,560 --> 01:09:11,198
two

1736
01:09:11,198 --> 01:09:15,759
so we'll convene once again in

