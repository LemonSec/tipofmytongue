1
00:00:01,120 --> 00:00:03,360
hi my name is valerio and i will be

2
00:00:03,360 --> 00:00:04,480
talking together with

3
00:00:04,480 --> 00:00:07,680
erican hi america about updatable

4
00:00:07,680 --> 00:00:08,400
signatures

5
00:00:08,400 --> 00:00:11,120
and message authentication codes this is

6
00:00:11,120 --> 00:00:13,280
a joint work with sebastien ramaker

7
00:00:13,280 --> 00:00:16,720
dennis lamoning and christoph strix

8
00:00:16,720 --> 00:00:18,880
in this work we introduce a definitional

9
00:00:18,880 --> 00:00:21,279
framework for updatable signatures

10
00:00:21,279 --> 00:00:24,480
us and updatable message authentication

11
00:00:24,480 --> 00:00:26,160
codes umac

12
00:00:26,160 --> 00:00:28,320
the form of the updatability we are

13
00:00:28,320 --> 00:00:29,679
interested in

14
00:00:29,679 --> 00:00:32,320
is that primitives are key updatable and

15
00:00:32,320 --> 00:00:33,600
allow to update

16
00:00:33,600 --> 00:00:36,399
all cryptographic objects so in our case

17
00:00:36,399 --> 00:00:37,200
signatures

18
00:00:37,200 --> 00:00:39,600
or message authentication codes from the

19
00:00:39,600 --> 00:00:41,600
old key to the updated key

20
00:00:41,600 --> 00:00:44,079
without requiring full access to the new

21
00:00:44,079 --> 00:00:44,879
key

22
00:00:44,879 --> 00:00:48,879
but only via a so-called update token

23
00:00:48,879 --> 00:00:50,559
similarly to concrete practical

24
00:00:50,559 --> 00:00:52,320
motivations that led

25
00:00:52,320 --> 00:00:54,960
to recent works and updatable encryption

26
00:00:54,960 --> 00:00:56,840
so for example lemanital from

27
00:00:56,840 --> 00:00:58,559
eurocrypt18

28
00:00:58,559 --> 00:01:00,719
we observed that also in the context of

29
00:01:00,719 --> 00:01:02,399
signatures and macs

30
00:01:02,399 --> 00:01:04,080
it's important to follow good key

31
00:01:04,080 --> 00:01:06,320
management practices and to periodically

32
00:01:06,320 --> 00:01:08,159
switch keys

33
00:01:08,159 --> 00:01:10,479
two possible examples of that are

34
00:01:10,479 --> 00:01:12,320
software distribution channels

35
00:01:12,320 --> 00:01:14,479
when one relies on signatures to ensure

36
00:01:14,479 --> 00:01:16,000
the authenticity of the software

37
00:01:16,000 --> 00:01:17,680
distributed

38
00:01:17,680 --> 00:01:20,479
or outsourced databases which usually

39
00:01:20,479 --> 00:01:22,159
require signatures or macs

40
00:01:22,159 --> 00:01:24,640
to ensure integrity of the stored data

41
00:01:24,640 --> 00:01:26,560
in both cases if the orders of the

42
00:01:26,560 --> 00:01:28,560
secret key could compute a token

43
00:01:28,560 --> 00:01:30,720
that allows some third party to update

44
00:01:30,720 --> 00:01:31,920
existing signatures

45
00:01:31,920 --> 00:01:36,079
or max to once valid under the new key

46
00:01:36,079 --> 00:01:38,079
then these holders wouldn't have to

47
00:01:38,079 --> 00:01:40,320
generate fresh signatures and max

48
00:01:40,320 --> 00:01:42,399
for the old data again whenever they

49
00:01:42,399 --> 00:01:45,119
switch keys

50
00:01:46,159 --> 00:01:48,720
in the context of signatures we can

51
00:01:48,720 --> 00:01:50,399
describe the functionality

52
00:01:50,399 --> 00:01:53,600
of updatability as follows

53
00:01:53,600 --> 00:01:55,759
as done in the context of updatable

54
00:01:55,759 --> 00:01:56,799
encryption

55
00:01:56,799 --> 00:01:59,600
we use the concept of epochs where each

56
00:01:59,600 --> 00:02:00,240
epoch

57
00:02:00,240 --> 00:02:03,840
has an associated key pair pke ske

58
00:02:03,840 --> 00:02:08,080
for apple key in any given epoch the

59
00:02:08,080 --> 00:02:09,840
order of the secret key

60
00:02:09,840 --> 00:02:12,959
can sign arbitrary messages to obtain

61
00:02:12,959 --> 00:02:15,760
the corresponding signatures

62
00:02:15,760 --> 00:02:18,400
it can then send them to some third

63
00:02:18,400 --> 00:02:22,160
party for example a server or a database

64
00:02:22,160 --> 00:02:25,120
at any time the user can run an

65
00:02:25,120 --> 00:02:25,840
algorithm

66
00:02:25,840 --> 00:02:28,800
called next which on input the key pair

67
00:02:28,800 --> 00:02:29,599
of the current

68
00:02:29,599 --> 00:02:32,000
epoch generates a keeper for the

69
00:02:32,000 --> 00:02:33,519
following epoch

70
00:02:33,519 --> 00:02:36,319
together with a so-called update token

71
00:02:36,319 --> 00:02:38,000
delta

72
00:02:38,000 --> 00:02:40,720
the user can then send such token to the

73
00:02:40,720 --> 00:02:42,800
third party that was storing the old

74
00:02:42,800 --> 00:02:44,080
signatures

75
00:02:44,080 --> 00:02:47,760
so that this third party using such

76
00:02:47,760 --> 00:02:50,000
update token it can run an update

77
00:02:50,000 --> 00:02:51,040
algorithm

78
00:02:51,040 --> 00:02:53,519
that converts signatures produced in the

79
00:02:53,519 --> 00:02:54,560
old epoch

80
00:02:54,560 --> 00:02:57,360
to new ones that verify for the same

81
00:02:57,360 --> 00:02:58,080
message

82
00:02:58,080 --> 00:03:01,440
under the new public key

83
00:03:01,599 --> 00:03:03,680
regarding security we start to achieve

84
00:03:03,680 --> 00:03:05,599
two different security notions on

85
00:03:05,599 --> 00:03:06,560
forgeability

86
00:03:06,560 --> 00:03:09,440
and unlikability as far as the first

87
00:03:09,440 --> 00:03:11,120
notion is concerned

88
00:03:11,120 --> 00:03:13,599
we want to guarantee signatures and max

89
00:03:13,599 --> 00:03:14,800
affordability

90
00:03:14,800 --> 00:03:16,560
even against an adversary that can

91
00:03:16,560 --> 00:03:18,879
trigger yet the articles it has

92
00:03:18,879 --> 00:03:21,200
access to arbitrary signature

93
00:03:21,200 --> 00:03:22,400
computations

94
00:03:22,400 --> 00:03:24,879
adaptive computation of next keys and

95
00:03:24,879 --> 00:03:26,480
updates of signatures

96
00:03:26,480 --> 00:03:28,319
and also that can adaptively corrupt

97
00:03:28,319 --> 00:03:30,400
tokens and signing keys

98
00:03:30,400 --> 00:03:32,080
of course with the restriction that we

99
00:03:32,080 --> 00:03:34,720
exclude trivial forgeries

100
00:03:34,720 --> 00:03:38,000
the second security notion unlinkability

101
00:03:38,000 --> 00:03:40,560
essentially says that updated signatures

102
00:03:40,560 --> 00:03:43,519
cannot be distinguished from fresh ones

103
00:03:43,519 --> 00:03:45,440
this again should hold against an

104
00:03:45,440 --> 00:03:46,640
adversary that can

105
00:03:46,640 --> 00:03:48,959
adaptively query signing keys update

106
00:03:48,959 --> 00:03:52,239
tokens and signatures

107
00:03:53,360 --> 00:03:55,280
as in recent work and updatable

108
00:03:55,280 --> 00:03:57,680
encryption we use the concept of leakage

109
00:03:57,680 --> 00:03:58,480
profile

110
00:03:58,480 --> 00:04:01,040
to capture key token and signature

111
00:04:01,040 --> 00:04:01,840
leakage

112
00:04:01,840 --> 00:04:05,040
that cannot be captured directly via the

113
00:04:05,040 --> 00:04:08,080
articles in the security experiment

114
00:04:08,080 --> 00:04:10,640
indeed due to the updatability

115
00:04:10,640 --> 00:04:12,640
functionality provided

116
00:04:12,640 --> 00:04:15,360
updatable signature schemes inherently

117
00:04:15,360 --> 00:04:17,120
allow for information leakage

118
00:04:17,120 --> 00:04:20,478
of updated message signature pairs

119
00:04:20,478 --> 00:04:23,040
keys and tokens besides what is

120
00:04:23,040 --> 00:04:25,440
modelling the security experiment

121
00:04:25,440 --> 00:04:28,479
for example one single update token can

122
00:04:28,479 --> 00:04:29,440
be

123
00:04:29,440 --> 00:04:32,160
used to update polynomially many message

124
00:04:32,160 --> 00:04:33,600
signature pairs

125
00:04:33,600 --> 00:04:35,680
and therefore we cannot capture which

126
00:04:35,680 --> 00:04:37,120
particular signature

127
00:04:37,120 --> 00:04:40,000
the adversary will potentially update

128
00:04:40,000 --> 00:04:41,280
moreover

129
00:04:41,280 --> 00:04:42,960
tokens could potentially enable the

130
00:04:42,960 --> 00:04:45,120
adversary not only to upgrade

131
00:04:45,120 --> 00:04:47,840
but also to downgrade signatures and or

132
00:04:47,840 --> 00:04:49,680
keys

133
00:04:49,680 --> 00:04:51,759
having upgrades only would lead to

134
00:04:51,759 --> 00:04:52,800
stronger schemes

135
00:04:52,800 --> 00:04:55,440
which however seem of limited interest

136
00:04:55,440 --> 00:04:56,479
in authentication

137
00:04:56,479 --> 00:04:58,960
scenarios where all keys are typically

138
00:04:58,960 --> 00:05:02,160
assumed to be invalidated anyway

139
00:05:02,160 --> 00:05:04,720
we therefore opted for the simpler and

140
00:05:04,720 --> 00:05:07,600
cleaner bidirectional setting

141
00:05:07,600 --> 00:05:09,120
we consider the following leakage

142
00:05:09,120 --> 00:05:10,880
profile

143
00:05:10,880 --> 00:05:14,320
tokens allow to both update keys

144
00:05:14,320 --> 00:05:17,520
and to downgrade them pairs of

145
00:05:17,520 --> 00:05:19,440
consecutive secret keys

146
00:05:19,440 --> 00:05:21,840
leak the intermediate tokens between

147
00:05:21,840 --> 00:05:22,960
them

148
00:05:22,960 --> 00:05:26,000
and update tokens allow also to update

149
00:05:26,000 --> 00:05:26,800
signatures

150
00:05:26,800 --> 00:05:30,240
from old app to new one and

151
00:05:30,240 --> 00:05:33,600
from new epoch to old ones

152
00:05:33,600 --> 00:05:35,680
graphically which is probably easier to

153
00:05:35,680 --> 00:05:36,880
understand

154
00:05:36,880 --> 00:05:39,120
suppose that an adversary has queried

155
00:05:39,120 --> 00:05:40,000
its key

156
00:05:40,000 --> 00:05:42,240
update and signing articles to obtain

157
00:05:42,240 --> 00:05:43,120
the data

158
00:05:43,120 --> 00:05:46,800
colored in green in our leakage profile

159
00:05:46,800 --> 00:05:48,800
we deduce that the adversary has access

160
00:05:48,800 --> 00:05:50,800
not only to this information

161
00:05:50,800 --> 00:05:53,520
but also to the data that can be derived

162
00:05:53,520 --> 00:05:54,560
from it

163
00:05:54,560 --> 00:05:57,840
for example using the update token

164
00:05:57,840 --> 00:06:00,960
for epoch e minus 2 the adversary can

165
00:06:00,960 --> 00:06:03,120
downgrade the secret key of apoc e minus

166
00:06:03,120 --> 00:06:03,919
2

167
00:06:03,919 --> 00:06:05,919
to obtain the secret key of the previous

168
00:06:05,919 --> 00:06:08,080
epoch

169
00:06:08,080 --> 00:06:10,240
now with this new information the

170
00:06:10,240 --> 00:06:12,319
adversary has access to both secret key

171
00:06:12,319 --> 00:06:15,360
of epoch e minus 4 and apoc e minus 3

172
00:06:15,360 --> 00:06:18,080
from which it can derive the in between

173
00:06:18,080 --> 00:06:21,840
update token delta e -3

174
00:06:21,840 --> 00:06:25,039
once it has access to such token

175
00:06:25,039 --> 00:06:27,360
the adversary can then update signature

176
00:06:27,360 --> 00:06:29,280
from epoch e minus 4

177
00:06:29,280 --> 00:06:33,600
to signatures valid in epoch a minus 3.

178
00:06:33,600 --> 00:06:35,759
similarly other informations can be

179
00:06:35,759 --> 00:06:37,919
derived via these leakages

180
00:06:37,919 --> 00:06:39,360
and eventually all the information

181
00:06:39,360 --> 00:06:41,600
colored in blue can be obtained

182
00:06:41,600 --> 00:06:44,560
by the adversary

183
00:06:45,199 --> 00:06:47,360
after defining this new primitive and

184
00:06:47,360 --> 00:06:49,680
modeling the security requirements

185
00:06:49,680 --> 00:06:51,840
we provide a different sensations based

186
00:06:51,840 --> 00:06:54,400
on various type of assumptions

187
00:06:54,400 --> 00:06:57,120
we will describe here only some of them

188
00:06:57,120 --> 00:06:57,840
and aircon

189
00:06:57,840 --> 00:06:59,919
will give you an overview of all of them

190
00:06:59,919 --> 00:07:02,639
in the last part of the presentation

191
00:07:02,639 --> 00:07:04,479
here we will focus on how to construct

192
00:07:04,479 --> 00:07:05,840
updatable signatures

193
00:07:05,840 --> 00:07:08,560
from chemomorphic signatures a primitive

194
00:07:08,560 --> 00:07:11,919
integer introduced by darlene slamanig

195
00:07:11,919 --> 00:07:14,080
i will then discuss a lattice-based

196
00:07:14,080 --> 00:07:16,479
candidate us construction which follows

197
00:07:16,479 --> 00:07:18,800
the gpb template

198
00:07:18,800 --> 00:07:20,800
aircon we then present how to construct

199
00:07:20,800 --> 00:07:24,319
umax from almost geomorphic prf

200
00:07:24,319 --> 00:07:26,560
and will give you an overview of the

201
00:07:26,560 --> 00:07:31,680
security proof ideas we used in our work

202
00:07:31,680 --> 00:07:34,080
before introducing ketomorphic

203
00:07:34,080 --> 00:07:36,080
signatures we need to first define what

204
00:07:36,080 --> 00:07:37,759
a secret key to public key

205
00:07:37,759 --> 00:07:40,720
homomorphism is consider a signature

206
00:07:40,720 --> 00:07:41,360
scheme

207
00:07:41,360 --> 00:07:43,919
sigma where both secret keys and public

208
00:07:43,919 --> 00:07:45,680
keys are elements of two different

209
00:07:45,680 --> 00:07:46,800
groups

210
00:07:46,800 --> 00:07:49,520
if this is the case then a secret key to

211
00:07:49,520 --> 00:07:50,240
public key

212
00:07:50,240 --> 00:07:52,960
homomorphism is a map between the secret

213
00:07:52,960 --> 00:07:55,120
key group and the public key one

214
00:07:55,120 --> 00:07:58,319
that satisfies two different properties

215
00:07:58,319 --> 00:08:01,280
first of all it is a group homomorphism

216
00:08:01,280 --> 00:08:03,039
so it is a map that is compatible with

217
00:08:03,039 --> 00:08:05,520
the group structure of both groups

218
00:08:05,520 --> 00:08:07,680
second such map should also be

219
00:08:07,680 --> 00:08:09,280
compatible with the key generation

220
00:08:09,280 --> 00:08:11,520
algorithm of the signature scheme

221
00:08:11,520 --> 00:08:13,759
that is it should send secret keys to

222
00:08:13,759 --> 00:08:15,759
the corresponding public keys

223
00:08:15,759 --> 00:08:18,560
for example in the d-log setting one

224
00:08:18,560 --> 00:08:20,080
usually has that the secret key is a

225
00:08:20,080 --> 00:08:22,080
random element in set b

226
00:08:22,080 --> 00:08:23,840
where p is the cardinality of the group

227
00:08:23,840 --> 00:08:26,160
g and the corresponding public key

228
00:08:26,160 --> 00:08:28,720
is the given generator of the group g

229
00:08:28,720 --> 00:08:30,879
raised to the secret key

230
00:08:30,879 --> 00:08:33,519
in this case the map that exactly sends

231
00:08:33,519 --> 00:08:34,559
k zp

232
00:08:34,559 --> 00:08:37,440
to g to the k in g is a secret key to

233
00:08:37,440 --> 00:08:38,159
public key

234
00:08:38,159 --> 00:08:42,320
or morphism a signature scheme

235
00:08:42,320 --> 00:08:44,959
is then called homomorphic if it

236
00:08:44,959 --> 00:08:46,640
provides a secret key to public key

237
00:08:46,640 --> 00:08:48,000
homomorphism

238
00:08:48,000 --> 00:08:50,480
and an additional ppt algorithm called

239
00:08:50,480 --> 00:08:51,120
adapt

240
00:08:51,120 --> 00:08:52,800
that is compatible with the secret key

241
00:08:52,800 --> 00:08:54,800
to public key map

242
00:08:54,800 --> 00:08:57,920
such algorithm an input a public key

243
00:08:57,920 --> 00:09:00,320
a message its corresponding signature

244
00:09:00,320 --> 00:09:01,200
and a token

245
00:09:01,200 --> 00:09:02,800
which is an element of the security

246
00:09:02,800 --> 00:09:04,720
group outputs

247
00:09:04,720 --> 00:09:07,680
a new public key and a new signature the

248
00:09:07,680 --> 00:09:08,800
new signature

249
00:09:08,800 --> 00:09:10,640
should be a valid signature for the

250
00:09:10,640 --> 00:09:12,640
input message under the new

251
00:09:12,640 --> 00:09:14,800
public key and the new public key should

252
00:09:14,800 --> 00:09:16,640
be derived via the secret key to public

253
00:09:16,640 --> 00:09:18,000
key or monomorphism

254
00:09:18,000 --> 00:09:21,360
the input token and your public key

255
00:09:21,360 --> 00:09:24,240
for example in the bls signature scheme

256
00:09:24,240 --> 00:09:25,680
the signature of a message

257
00:09:25,680 --> 00:09:29,360
m under secret key sk is the edge of the

258
00:09:29,360 --> 00:09:30,080
message m

259
00:09:30,080 --> 00:09:33,360
raised to the sk in this case the adapt

260
00:09:33,360 --> 00:09:34,160
algorithm

261
00:09:34,160 --> 00:09:37,120
will output p k times g to the delta as

262
00:09:37,120 --> 00:09:38,959
the newly obtained public key

263
00:09:38,959 --> 00:09:41,519
and sigma times the h of the message m

264
00:09:41,519 --> 00:09:43,120
raised to the delta

265
00:09:43,120 --> 00:09:46,160
as the new signature

266
00:09:46,880 --> 00:09:49,680
given a chemomorphic signature scheme it

267
00:09:49,680 --> 00:09:51,839
is possible to generically construct an

268
00:09:51,839 --> 00:09:53,600
updatable signature

269
00:09:53,600 --> 00:09:55,200
as long as the starting primitive

270
00:09:55,200 --> 00:09:57,760
satisfies an additional requirement

271
00:09:57,760 --> 00:10:00,560
that there learns laminig named perfect

272
00:10:00,560 --> 00:10:01,920
adaption

273
00:10:01,920 --> 00:10:03,839
which however all natural scheme seems

274
00:10:03,839 --> 00:10:05,600
to provide

275
00:10:05,600 --> 00:10:07,440
such generic transformation works as

276
00:10:07,440 --> 00:10:09,120
follows in each

277
00:10:09,120 --> 00:10:12,240
epoch signature and verification work as

278
00:10:12,240 --> 00:10:15,360
for the underlying theomorphic signature

279
00:10:15,360 --> 00:10:18,079
whenever the next algorithm is run it

280
00:10:18,079 --> 00:10:20,000
samples the update token as a fresh

281
00:10:20,000 --> 00:10:22,160
uniform element from the secret key

282
00:10:22,160 --> 00:10:23,040
group

283
00:10:23,040 --> 00:10:25,279
and sets the new secret key as the sum

284
00:10:25,279 --> 00:10:26,800
of the o key

285
00:10:26,800 --> 00:10:29,200
plus this update token and the new

286
00:10:29,200 --> 00:10:30,079
public key

287
00:10:30,079 --> 00:10:31,839
via the secret key to public key

288
00:10:31,839 --> 00:10:33,200
homomorphism

289
00:10:33,200 --> 00:10:35,600
in this way both new secret key and new

290
00:10:35,600 --> 00:10:37,120
public key are uniform

291
00:10:37,120 --> 00:10:39,920
elements in their respective groups to

292
00:10:39,920 --> 00:10:40,800
update

293
00:10:40,800 --> 00:10:43,760
all signatures one runs the adapt

294
00:10:43,760 --> 00:10:44,800
algorithm

295
00:10:44,800 --> 00:10:47,680
of the kiam marty scheme which is

296
00:10:47,680 --> 00:10:50,160
guaranteed to produce a valley signature

297
00:10:50,160 --> 00:10:53,519
for the new public key which moreover

298
00:10:53,519 --> 00:10:55,120
looks as a fresh one

299
00:10:55,120 --> 00:10:57,360
under this additional requirement of

300
00:10:57,360 --> 00:10:59,040
perfect adoption that we mentioned

301
00:10:59,040 --> 00:11:01,040
before

302
00:11:01,040 --> 00:11:03,360
this last requirement is not only

303
00:11:03,360 --> 00:11:04,240
necessary

304
00:11:04,240 --> 00:11:07,440
to prove the unlinkability of the

305
00:11:07,440 --> 00:11:10,880
so obtain updatable signature but it's

306
00:11:10,880 --> 00:11:12,480
also required in

307
00:11:12,480 --> 00:11:15,360
our proof of affordability as erican

308
00:11:15,360 --> 00:11:18,240
will later tell you

309
00:11:18,640 --> 00:11:20,800
a second construction that we provided

310
00:11:20,800 --> 00:11:22,720
is based on the lattice-based

311
00:11:22,720 --> 00:11:26,079
gpv signature scheme to briefly recall

312
00:11:26,079 --> 00:11:26,959
it

313
00:11:26,959 --> 00:11:29,040
in such scheme the public key is a

314
00:11:29,040 --> 00:11:30,800
uniformly random matrix

315
00:11:30,800 --> 00:11:32,640
of appropriate dimensions over their

316
00:11:32,640 --> 00:11:35,360
queue and the associated secret key

317
00:11:35,360 --> 00:11:37,920
is a sufficiently short basis of the

318
00:11:37,920 --> 00:11:41,600
kernel lattice defined by the public key

319
00:11:41,600 --> 00:11:44,240
using the full domain hash paradigm to

320
00:11:44,240 --> 00:11:45,200
sign a message

321
00:11:45,200 --> 00:11:48,079
m one first applies the hash function to

322
00:11:48,079 --> 00:11:48,959
the message

323
00:11:48,959 --> 00:11:52,160
to obtain a random vector h of m

324
00:11:52,160 --> 00:11:55,040
a valid signature corresponds then to a

325
00:11:55,040 --> 00:11:56,000
short pre-image of

326
00:11:56,000 --> 00:11:58,880
h of m in the illustration yellow

327
00:11:58,880 --> 00:12:01,519
represents uniformly random matrices

328
00:12:01,519 --> 00:12:05,200
or vectors and green short ones

329
00:12:05,200 --> 00:12:08,399
to prove the security of the scheme one

330
00:12:08,399 --> 00:12:10,399
then leverages on the programmability of

331
00:12:10,399 --> 00:12:12,399
the random article

332
00:12:12,399 --> 00:12:14,480
the reduction first samples the short

333
00:12:14,480 --> 00:12:15,519
vector

334
00:12:15,519 --> 00:12:17,839
and then sets the oracle value on the

335
00:12:17,839 --> 00:12:18,639
message

336
00:12:18,639 --> 00:12:23,440
m to be the subtheme value h of m

337
00:12:23,440 --> 00:12:25,120
using techniques from the proxy

338
00:12:25,120 --> 00:12:27,600
resignation approach of fan and u

339
00:12:27,600 --> 00:12:30,720
we can construct a us scheme as follows

340
00:12:30,720 --> 00:12:32,959
in each epoch design and verification

341
00:12:32,959 --> 00:12:33,760
algorithms

342
00:12:33,760 --> 00:12:36,959
are the ones from the gpv scheme

343
00:12:36,959 --> 00:12:39,440
the next algorithm runs the key

344
00:12:39,440 --> 00:12:42,560
generation algorithm of the gpv scheme

345
00:12:42,560 --> 00:12:45,040
to obtain a uniformly random matrix

346
00:12:45,040 --> 00:12:46,720
together with a corresponding short

347
00:12:46,720 --> 00:12:47,839
basis

348
00:12:47,839 --> 00:12:50,160
which will be the public key and secret

349
00:12:50,160 --> 00:12:52,320
key of the new epoch

350
00:12:52,320 --> 00:12:54,560
to produce the update token the

351
00:12:54,560 --> 00:12:56,959
algorithm basically uses the secret key

352
00:12:56,959 --> 00:12:57,519
of the new

353
00:12:57,519 --> 00:13:00,880
epoch to sign the old public key

354
00:13:00,880 --> 00:13:02,880
we then get that the update token is a

355
00:13:02,880 --> 00:13:04,160
short matrix

356
00:13:04,160 --> 00:13:06,560
that maps the new public key to the old

357
00:13:06,560 --> 00:13:08,480
one

358
00:13:08,480 --> 00:13:10,720
such update token can then be used to

359
00:13:10,720 --> 00:13:11,600
update

360
00:13:11,600 --> 00:13:14,639
by multiplication old signatures to the

361
00:13:14,639 --> 00:13:16,399
new epoch

362
00:13:16,399 --> 00:13:19,120
we can see already that updated

363
00:13:19,120 --> 00:13:20,000
signatures

364
00:13:20,000 --> 00:13:23,040
do not look as fresh ones even if

365
00:13:23,040 --> 00:13:25,200
both matrices involved in the update

366
00:13:25,200 --> 00:13:26,240
process

367
00:13:26,240 --> 00:13:28,959
are short and so the resulting signature

368
00:13:28,959 --> 00:13:30,959
is also somewhat short

369
00:13:30,959 --> 00:13:33,440
the norm of signatures increases with

370
00:13:33,440 --> 00:13:34,800
each update

371
00:13:34,800 --> 00:13:37,120
enhance can be used to distinguish fresh

372
00:13:37,120 --> 00:13:40,639
signatures from updated ones

373
00:13:41,360 --> 00:13:43,440
one can then check that the superdue

374
00:13:43,440 --> 00:13:45,680
signature verifies under the new public

375
00:13:45,680 --> 00:13:46,639
key

376
00:13:46,639 --> 00:13:49,120
by simply writing down the verification

377
00:13:49,120 --> 00:13:50,480
equation

378
00:13:50,480 --> 00:13:52,800
and using the way the update token was

379
00:13:52,800 --> 00:13:54,240
produced

380
00:13:54,240 --> 00:13:58,240
to verify the above quality

381
00:13:59,199 --> 00:14:01,279
i will now hand it over to aircon for

382
00:14:01,279 --> 00:14:04,079
the next part of the

383
00:14:04,880 --> 00:14:07,279
before presenting our update above mac

384
00:14:07,279 --> 00:14:08,320
construction

385
00:14:08,320 --> 00:14:10,240
let's first remember the canonical mac

386
00:14:10,240 --> 00:14:12,320
construction from a prf

387
00:14:12,320 --> 00:14:15,279
let f be a secure prf then we can

388
00:14:15,279 --> 00:14:17,600
construct a mac as follows

389
00:14:17,600 --> 00:14:19,600
the signing operation involves just

390
00:14:19,600 --> 00:14:21,040
evaluating the prf

391
00:14:21,040 --> 00:14:23,199
on the message to obtain the tag which

392
00:14:23,199 --> 00:14:25,360
is denoted here with sigma

393
00:14:25,360 --> 00:14:27,360
the verification involves just

394
00:14:27,360 --> 00:14:30,079
re-evaluating the prf on the message

395
00:14:30,079 --> 00:14:32,160
and then comparing the result with the

396
00:14:32,160 --> 00:14:34,720
tag obtained from the signing procedure

397
00:14:34,720 --> 00:14:36,480
now in order to introduce updating

398
00:14:36,480 --> 00:14:38,320
capabilities to such a meg

399
00:14:38,320 --> 00:14:40,480
we need to replace the prf with the key

400
00:14:40,480 --> 00:14:43,040
homomorphic variant

401
00:14:43,040 --> 00:14:46,320
we say that a prf is key homomorphic if

402
00:14:46,320 --> 00:14:49,519
if it is a secure prf and in addition

403
00:14:49,519 --> 00:14:52,240
its input and output spaces are groups

404
00:14:52,240 --> 00:14:54,079
and for every input x

405
00:14:54,079 --> 00:14:56,639
we have that adding two prf evaluations

406
00:14:56,639 --> 00:14:57,600
at x

407
00:14:57,600 --> 00:15:00,480
but under two different keys yields a

408
00:15:00,480 --> 00:15:01,839
prf evaluation at

409
00:15:01,839 --> 00:15:04,720
x under the combined key using such a

410
00:15:04,720 --> 00:15:06,240
key homomorphic prf

411
00:15:06,240 --> 00:15:08,399
we can construct an updatable mac as

412
00:15:08,399 --> 00:15:09,440
follows

413
00:15:09,440 --> 00:15:11,519
the signing operation remains the same

414
00:15:11,519 --> 00:15:13,600
as in the canonical mac

415
00:15:13,600 --> 00:15:15,680
where we just evaluate the prf on the

416
00:15:15,680 --> 00:15:16,880
message m

417
00:15:16,880 --> 00:15:20,399
under the key k1 in this case to update

418
00:15:20,399 --> 00:15:21,040
the tag

419
00:15:21,040 --> 00:15:23,279
sigma 1 we evaluate the prf on the

420
00:15:23,279 --> 00:15:24,240
message

421
00:15:24,240 --> 00:15:26,320
but this time under the update token

422
00:15:26,320 --> 00:15:28,320
delta 2 which is defined as

423
00:15:28,320 --> 00:15:32,000
k2 minus k1 so if we add the output of

424
00:15:32,000 --> 00:15:34,240
this prf evaluation to the previously

425
00:15:34,240 --> 00:15:35,839
computed sigma 1

426
00:15:35,839 --> 00:15:38,800
what we end up with is sigma 2 which is

427
00:15:38,800 --> 00:15:40,480
just prf evaluation

428
00:15:40,480 --> 00:15:43,759
on the message m under the key k2

429
00:15:43,759 --> 00:15:46,399
so essentially k1 cancels out due to the

430
00:15:46,399 --> 00:15:48,079
key homomorphic properties of the

431
00:15:48,079 --> 00:15:49,759
underlying prf

432
00:15:49,759 --> 00:15:52,399
lastly to verify the mac we proceed as

433
00:15:52,399 --> 00:15:54,560
in the canonical mac construction

434
00:15:54,560 --> 00:15:56,639
and just re-evaluate the prf on the

435
00:15:56,639 --> 00:15:58,959
message m under the key k2

436
00:15:58,959 --> 00:16:00,800
and compare it with the previously

437
00:16:00,800 --> 00:16:02,880
obtained text sigma

438
00:16:02,880 --> 00:16:05,040
so far we only considered perfectly

439
00:16:05,040 --> 00:16:07,120
correct homomorphic prfs

440
00:16:07,120 --> 00:16:10,160
however bonaire tau showed that one can

441
00:16:10,160 --> 00:16:12,240
also obtain lattice-based q homomorphic

442
00:16:12,240 --> 00:16:13,120
prfs

443
00:16:13,120 --> 00:16:16,160
if the definition is relaxed a bit more

444
00:16:16,160 --> 00:16:17,440
precisely

445
00:16:17,440 --> 00:16:19,519
we can consider almost q homomorphic

446
00:16:19,519 --> 00:16:22,000
prfs where the homomorphism in the key

447
00:16:22,000 --> 00:16:25,279
space is noisy so essentially we have

448
00:16:25,279 --> 00:16:26,160
equality

449
00:16:26,160 --> 00:16:29,040
up to an added noise term however this

450
00:16:29,040 --> 00:16:31,120
breaks correctness

451
00:16:31,120 --> 00:16:33,440
because now after the update operation

452
00:16:33,440 --> 00:16:35,759
we end up with a prf evaluation with an

453
00:16:35,759 --> 00:16:37,440
additional noise term

454
00:16:37,440 --> 00:16:39,680
and if we were to naively compare that

455
00:16:39,680 --> 00:16:42,000
with a fresh evaluation of the prf from

456
00:16:42,000 --> 00:16:43,759
the verification procedure

457
00:16:43,759 --> 00:16:46,480
then the two tags won't be equal the

458
00:16:46,480 --> 00:16:47,680
workaround to this

459
00:16:47,680 --> 00:16:49,759
is to consider approximate canonical

460
00:16:49,759 --> 00:16:50,800
verification

461
00:16:50,800 --> 00:16:53,279
or more precisely noisy quality check

462
00:16:53,279 --> 00:16:55,120
where the verification operation

463
00:16:55,120 --> 00:16:57,199
computes the distance between the two

464
00:16:57,199 --> 00:16:57,839
tags

465
00:16:57,839 --> 00:16:59,759
and only succeeds if the distance

466
00:16:59,759 --> 00:17:01,519
between the two is smaller than some

467
00:17:01,519 --> 00:17:05,039
bound delta

468
00:17:05,039 --> 00:17:06,959
next i will talk about the high level

469
00:17:06,959 --> 00:17:09,199
idea of our proof technique

470
00:17:09,199 --> 00:17:11,280
essentially we reduce the updatable

471
00:17:11,280 --> 00:17:13,599
unforgeability of other constructions

472
00:17:13,599 --> 00:17:15,599
to the unforgeability of the underlying

473
00:17:15,599 --> 00:17:18,720
mac or signature scheme in order to

474
00:17:18,720 --> 00:17:20,720
prove that we use the key insulation

475
00:17:20,720 --> 00:17:22,559
technique of quasar tau

476
00:17:22,559 --> 00:17:24,799
where we define an insulated region of

477
00:17:24,799 --> 00:17:26,319
epox which avoids

478
00:17:26,319 --> 00:17:28,559
trivial winds by the adversary more

479
00:17:28,559 --> 00:17:30,559
precisely we consider an insulated

480
00:17:30,559 --> 00:17:32,799
region where no key inside the region is

481
00:17:32,799 --> 00:17:33,760
corrupted

482
00:17:33,760 --> 00:17:35,760
the tokens on the borders of the region

483
00:17:35,760 --> 00:17:36,960
are not corrupted

484
00:17:36,960 --> 00:17:39,120
and lastly all tokens inside the region

485
00:17:39,120 --> 00:17:40,559
are corrupted

486
00:17:40,559 --> 00:17:42,480
to demonstrate this pictorially let's

487
00:17:42,480 --> 00:17:44,559
consider the following eight epochs and

488
00:17:44,559 --> 00:17:46,000
the keys tokens and

489
00:17:46,000 --> 00:17:48,640
signatures associated to them here we

490
00:17:48,640 --> 00:17:50,559
assume that the objects marked with red

491
00:17:50,559 --> 00:17:53,440
are already corrupted by the adversary

492
00:17:53,440 --> 00:17:56,640
then we can set our insulated region

493
00:17:56,640 --> 00:17:58,720
to be the region between the epochs 3

494
00:17:58,720 --> 00:18:00,960
and 7 because it satisfies all the

495
00:18:00,960 --> 00:18:02,640
properties of insulated region

496
00:18:02,640 --> 00:18:04,240
previously described

497
00:18:04,240 --> 00:18:06,400
more precisely no key inside the region

498
00:18:06,400 --> 00:18:07,360
is corrupted

499
00:18:07,360 --> 00:18:09,440
but all the tokens are corrupted and

500
00:18:09,440 --> 00:18:10,400
furthermore

501
00:18:10,400 --> 00:18:12,320
no token on the borders of the region

502
00:18:12,320 --> 00:18:13,440
are corrupted

503
00:18:13,440 --> 00:18:15,760
this kind of insulated region rules out

504
00:18:15,760 --> 00:18:19,840
a trivial forgery by the adversary

505
00:18:20,240 --> 00:18:22,400
once we have defined such an insulated

506
00:18:22,400 --> 00:18:25,600
region our proof proceeds as follows

507
00:18:25,600 --> 00:18:28,400
first we associate the euf cma

508
00:18:28,400 --> 00:18:30,400
challenger of the underlying signature

509
00:18:30,400 --> 00:18:30,799
scheme

510
00:18:30,799 --> 00:18:33,440
sigma to an apple within the region for

511
00:18:33,440 --> 00:18:35,840
example to epoche minus here

512
00:18:35,840 --> 00:18:38,880
which is on the left border next since

513
00:18:38,880 --> 00:18:40,880
we do not know the secret keys within

514
00:18:40,880 --> 00:18:41,600
the region

515
00:18:41,600 --> 00:18:43,760
we implicitly set them by sampling a

516
00:18:43,760 --> 00:18:45,840
random update token delta

517
00:18:45,840 --> 00:18:48,320
for each epoch and use the secret key to

518
00:18:48,320 --> 00:18:50,480
publicly homomorphism of sigma

519
00:18:50,480 --> 00:18:52,640
to set the public keys recursively as

520
00:18:52,640 --> 00:18:54,240
shown here

521
00:18:54,240 --> 00:18:57,360
lastly we use the challenger of sigma

522
00:18:57,360 --> 00:18:59,600
and the adapt algorithm to answer the

523
00:18:59,600 --> 00:19:02,160
queries and adapt the forgery

524
00:19:02,160 --> 00:19:04,480
for example if we get query for the

525
00:19:04,480 --> 00:19:05,520
fifth apple

526
00:19:05,520 --> 00:19:07,520
we query the message to the challenger

527
00:19:07,520 --> 00:19:10,400
of sigma to obtain the signature then we

528
00:19:10,400 --> 00:19:12,080
use the obtained signature within the

529
00:19:12,080 --> 00:19:13,919
adapt algorithm of sigma

530
00:19:13,919 --> 00:19:16,480
to move it in the forward direction and

531
00:19:16,480 --> 00:19:18,480
we continue to do this until we reach

532
00:19:18,480 --> 00:19:19,600
the target apple

533
00:19:19,600 --> 00:19:21,919
in this case epoc5 and due to the

534
00:19:21,919 --> 00:19:23,760
adoption property of sigma

535
00:19:23,760 --> 00:19:26,160
we have that the adapted signature and

536
00:19:26,160 --> 00:19:27,600
freshly computed one

537
00:19:27,600 --> 00:19:30,240
are identically distributed and has

538
00:19:30,240 --> 00:19:33,280
indistinguishable for the adversary

539
00:19:33,280 --> 00:19:35,039
we follow a similar approach for

540
00:19:35,039 --> 00:19:36,559
outputting the forgery

541
00:19:36,559 --> 00:19:39,039
for example if our adversary outputs of

542
00:19:39,039 --> 00:19:41,039
forgery for epoch 6

543
00:19:41,039 --> 00:19:43,120
then we can use the adopt algorithm to

544
00:19:43,120 --> 00:19:45,120
adapt the form of jerry backwards

545
00:19:45,120 --> 00:19:47,600
until we reach the epoch e minus where

546
00:19:47,600 --> 00:19:50,400
the challenger of sigma is associated

547
00:19:50,400 --> 00:19:52,640
this establishes on a high level how our

548
00:19:52,640 --> 00:19:54,240
security proof works

549
00:19:54,240 --> 00:19:56,240
and i refer you to our paper for the

550
00:19:56,240 --> 00:19:59,200
full details of the proof

551
00:19:59,200 --> 00:20:02,000
next we provide an overview and describe

552
00:20:02,000 --> 00:20:04,559
our instantiations

553
00:20:04,559 --> 00:20:06,480
the overview here the updatable

554
00:20:06,480 --> 00:20:08,720
signature schemes that we obtain

555
00:20:08,720 --> 00:20:11,760
the uu cmi column specifies whether the

556
00:20:11,760 --> 00:20:13,760
schema achieves unlinkability

557
00:20:13,760 --> 00:20:15,679
the ub column specifies whether it

558
00:20:15,679 --> 00:20:18,159
supports an unbounded number of epochs

559
00:20:18,159 --> 00:20:21,440
and mdmi stand for message dependent and

560
00:20:21,440 --> 00:20:22,640
message independent

561
00:20:22,640 --> 00:20:24,640
where message independent schemes do not

562
00:20:24,640 --> 00:20:26,559
require the message during the update

563
00:20:26,559 --> 00:20:27,520
procedure

564
00:20:27,520 --> 00:20:28,880
which in turn can improve the

565
00:20:28,880 --> 00:20:30,799
performance of the scheme

566
00:20:30,799 --> 00:20:32,400
since we can generically obtain

567
00:20:32,400 --> 00:20:34,080
updatable signatures from key home

568
00:20:34,080 --> 00:20:35,440
morphic signatures

569
00:20:35,440 --> 00:20:37,200
it follows that we can instantiate

570
00:20:37,200 --> 00:20:39,200
updatable signatures from many different

571
00:20:39,200 --> 00:20:40,159
schemes

572
00:20:40,159 --> 00:20:42,080
for example we obtain updatable

573
00:20:42,080 --> 00:20:43,520
signature from bls

574
00:20:43,520 --> 00:20:45,440
which is unlinkable and supports

575
00:20:45,440 --> 00:20:47,520
unbounded number of epochs

576
00:20:47,520 --> 00:20:49,679
furthermore it can be instantiated as

577
00:20:49,679 --> 00:20:51,520
either message dependent or message

578
00:20:51,520 --> 00:20:52,880
independent

579
00:20:52,880 --> 00:20:55,200
we obtain identical features also using

580
00:20:55,200 --> 00:20:57,919
the poinchable sanders signature scheme

581
00:20:57,919 --> 00:20:59,919
we obtain similar features also for

582
00:20:59,919 --> 00:21:01,280
voter signature

583
00:21:01,280 --> 00:21:03,600
however we only obtain message dependent

584
00:21:03,600 --> 00:21:05,520
construction from it

585
00:21:05,520 --> 00:21:08,159
lastly using the gpv signature we can

586
00:21:08,159 --> 00:21:09,760
obtain lattice-based scheme

587
00:21:09,760 --> 00:21:12,159
that is message independent and provides

588
00:21:12,159 --> 00:21:14,320
only bounded number of updates

589
00:21:14,320 --> 00:21:16,720
where the bound t is poly logarithmic

590
00:21:16,720 --> 00:21:17,840
for this scheme

591
00:21:17,840 --> 00:21:20,080
however we note that this construction

592
00:21:20,080 --> 00:21:22,080
does not achieve unlinkability

593
00:21:22,080 --> 00:21:24,320
and it only achieves unforgeability in a

594
00:21:24,320 --> 00:21:25,600
weakened model

595
00:21:25,600 --> 00:21:27,440
i refer you to our paper for the

596
00:21:27,440 --> 00:21:30,480
concrete details

597
00:21:30,480 --> 00:21:32,880
analogously we can instantiate umac

598
00:21:32,880 --> 00:21:35,440
using various keyhole morphic prs

599
00:21:35,440 --> 00:21:37,919
for example using now pinkas rhinegold

600
00:21:37,919 --> 00:21:38,559
prf

601
00:21:38,559 --> 00:21:40,159
we obtain a scheme that achieves

602
00:21:40,159 --> 00:21:42,400
unlinkability and supports unbounded

603
00:21:42,400 --> 00:21:45,200
number of apples furthermore it can also

604
00:21:45,200 --> 00:21:47,200
be turned into a message independent

605
00:21:47,200 --> 00:21:48,400
scheme

606
00:21:48,400 --> 00:21:50,000
additionally using the recent

607
00:21:50,000 --> 00:21:51,760
lattice-based almost queue homomorphic

608
00:21:51,760 --> 00:21:52,720
prfs

609
00:21:52,720 --> 00:21:54,799
we obtain a scheme that is message

610
00:21:54,799 --> 00:21:56,240
dependent and supports

611
00:21:56,240 --> 00:21:58,720
only constant number of epochs and even

612
00:21:58,720 --> 00:22:00,159
though these schemes are almost key

613
00:22:00,159 --> 00:22:01,280
homomorphic

614
00:22:01,280 --> 00:22:03,280
and there is an error term involved we

615
00:22:03,280 --> 00:22:05,440
can still achieve unlinkability using

616
00:22:05,440 --> 00:22:06,799
our epoch-dependent

617
00:22:06,799 --> 00:22:09,280
error trick for which i refer you to our

618
00:22:09,280 --> 00:22:11,600
paper

619
00:22:11,600 --> 00:22:13,679
next we conclude and list some open

620
00:22:13,679 --> 00:22:16,080
questions

621
00:22:16,080 --> 00:22:17,919
in conclusion we introduced new

622
00:22:17,919 --> 00:22:19,360
cryptographic primitives

623
00:22:19,360 --> 00:22:21,600
namely updatable mac and updatable

624
00:22:21,600 --> 00:22:22,799
signature

625
00:22:22,799 --> 00:22:25,200
we provided generic constructions from

626
00:22:25,200 --> 00:22:28,640
morphic prf and q homomorphic signature

627
00:22:28,640 --> 00:22:30,960
in our paper we also describe how to do

628
00:22:30,960 --> 00:22:33,280
message independent updates in order to

629
00:22:33,280 --> 00:22:35,760
improve the performance of the schemes

630
00:22:35,760 --> 00:22:37,679
and additionally we provided post

631
00:22:37,679 --> 00:22:39,200
quantum instantiations

632
00:22:39,200 --> 00:22:41,360
using lattice-based signature and almost

633
00:22:41,360 --> 00:22:44,640
keyhole morphic prf

634
00:22:44,640 --> 00:22:47,360
finally we leave two open questions

635
00:22:47,360 --> 00:22:47,919
first

636
00:22:47,919 --> 00:22:49,440
as we already mentioned our

637
00:22:49,440 --> 00:22:51,919
lattice-based updatable signature scheme

638
00:22:51,919 --> 00:22:54,000
provides security only in the beacon

639
00:22:54,000 --> 00:22:56,480
model this naturally brings us to the

640
00:22:56,480 --> 00:22:57,760
following question

641
00:22:57,760 --> 00:23:00,000
can we construct lattice-based updatable

642
00:23:00,000 --> 00:23:02,720
signature that achieves full security

643
00:23:02,720 --> 00:23:05,200
second our construction of umac for our

644
00:23:05,200 --> 00:23:07,360
mosquito homomorphic prfs

645
00:23:07,360 --> 00:23:09,520
involve a noise term which grows with

646
00:23:09,520 --> 00:23:10,720
every update

647
00:23:10,720 --> 00:23:12,400
in our constructions we took the

648
00:23:12,400 --> 00:23:14,559
conservative approach and only assumed

649
00:23:14,559 --> 00:23:16,480
the constant number of updates

650
00:23:16,480 --> 00:23:18,080
and this brings us to the following

651
00:23:18,080 --> 00:23:20,400
question can we provide concrete bounds

652
00:23:20,400 --> 00:23:22,559
for the number of supported epochs

653
00:23:22,559 --> 00:23:24,799
for you mac from almost q homomorphic

654
00:23:24,799 --> 00:23:26,880
prf

655
00:23:26,880 --> 00:23:29,200
with that i want to conclude thank you

656
00:23:29,200 --> 00:23:37,840
for your attention

657
00:23:40,640 --> 00:23:42,720
you

