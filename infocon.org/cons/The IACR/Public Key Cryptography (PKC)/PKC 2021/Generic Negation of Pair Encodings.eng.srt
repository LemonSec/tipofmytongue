1
00:00:00,160 --> 00:00:03,199
hello i'm miguel ambrona from entity

2
00:00:03,199 --> 00:00:04,799
laboratories i'm a positive student

3
00:00:04,799 --> 00:00:05,759
there

4
00:00:05,759 --> 00:00:08,240
under the supervision of massive ave and

5
00:00:08,240 --> 00:00:10,320
today i'm going to talk about my work

6
00:00:10,320 --> 00:00:11,920
on generic and negation of pairing

7
00:00:11,920 --> 00:00:13,599
coding schemes

8
00:00:13,599 --> 00:00:15,280
parent codings are primitive that is

9
00:00:15,280 --> 00:00:16,960
used to build attribute-based encryption

10
00:00:16,960 --> 00:00:18,640
so i'm going to first

11
00:00:18,640 --> 00:00:20,400
start by defining what attribute-based

12
00:00:20,400 --> 00:00:22,240
encryption is in attribute-based

13
00:00:22,240 --> 00:00:23,039
encryption

14
00:00:23,039 --> 00:00:25,519
there is a master authority for an

15
00:00:25,519 --> 00:00:27,199
example think of a university where

16
00:00:27,199 --> 00:00:28,480
there are students

17
00:00:28,480 --> 00:00:31,199
there are professors and many users and

18
00:00:31,199 --> 00:00:32,320
this authority

19
00:00:32,320 --> 00:00:34,640
can provide with secret keys to to the

20
00:00:34,640 --> 00:00:36,320
different parties so for example in this

21
00:00:36,320 --> 00:00:37,040
case

22
00:00:37,040 --> 00:00:39,760
the university will give a secret key to

23
00:00:39,760 --> 00:00:41,600
the student who is a phd student in

24
00:00:41,600 --> 00:00:42,640
mathematics

25
00:00:42,640 --> 00:00:44,559
so the key will will be associated to

26
00:00:44,559 --> 00:00:46,079
those values

27
00:00:46,079 --> 00:00:48,879
which are called attributes and the

28
00:00:48,879 --> 00:00:49,920
second student

29
00:00:49,920 --> 00:00:52,320
in this case let's let's say it's she's

30
00:00:52,320 --> 00:00:55,600
a master student in mathematics

31
00:00:55,600 --> 00:00:58,640
now consider a party who has a file some

32
00:00:58,640 --> 00:00:59,280
document

33
00:00:59,280 --> 00:01:02,000
and that wants to be she wants to share

34
00:01:02,000 --> 00:01:04,640
this document with

35
00:01:04,640 --> 00:01:07,040
some parties but not with everybody so

36
00:01:07,040 --> 00:01:08,799
she is in fact the again of a policy

37
00:01:08,799 --> 00:01:10,240
she wants to share this document with

38
00:01:10,240 --> 00:01:12,320
professors or phd students in

39
00:01:12,320 --> 00:01:13,439
mathematics

40
00:01:13,439 --> 00:01:15,600
so she can leverage this attribute based

41
00:01:15,600 --> 00:01:16,960
encryption system

42
00:01:16,960 --> 00:01:18,960
to produce a cipher text out of this

43
00:01:18,960 --> 00:01:20,080
file

44
00:01:20,080 --> 00:01:21,759
and decipher this cannot be published

45
00:01:21,759 --> 00:01:24,560
for example in the university server

46
00:01:24,560 --> 00:01:26,799
everybody can see it but only those who

47
00:01:26,799 --> 00:01:28,400
have a secret key

48
00:01:28,400 --> 00:01:30,159
which satisfies the policy will be able

49
00:01:30,159 --> 00:01:31,840
to decrypt in this case

50
00:01:31,840 --> 00:01:33,040
the first student will be able to

51
00:01:33,040 --> 00:01:37,439
decrypt but the second student cannot

52
00:01:37,439 --> 00:01:39,520
and in attribute-based encryption we

53
00:01:39,520 --> 00:01:40,479
also want to forbid

54
00:01:40,479 --> 00:01:44,320
collusion so for example let's say that

55
00:01:44,320 --> 00:01:46,479
the second student she has a friend who

56
00:01:46,479 --> 00:01:48,960
is a phd student in chemistry

57
00:01:48,960 --> 00:01:50,560
even though these two kids individually

58
00:01:50,560 --> 00:01:52,560
have attributes which

59
00:01:52,560 --> 00:01:54,880
potentially could satisfy this policy it

60
00:01:54,880 --> 00:01:56,560
should be impossible to combine both

61
00:01:56,560 --> 00:01:58,079
keys

62
00:01:58,079 --> 00:02:01,119
and decrypt so more

63
00:02:01,119 --> 00:02:03,840
more formally an attribute-based

64
00:02:03,840 --> 00:02:04,880
encryption for operatic

65
00:02:04,880 --> 00:02:08,000
p consists of four algorithm the setup

66
00:02:08,000 --> 00:02:10,878
algorithm that produces a pair of keys

67
00:02:10,878 --> 00:02:12,720
this algorithm is supposed to be run by

68
00:02:12,720 --> 00:02:15,520
the university in our previous example

69
00:02:15,520 --> 00:02:18,480
and the key generation algorithm which

70
00:02:18,480 --> 00:02:20,400
requires the master secret key this is

71
00:02:20,400 --> 00:02:21,360
only known

72
00:02:21,360 --> 00:02:24,560
by the university and on input an

73
00:02:24,560 --> 00:02:27,760
attribute y produces a secret key for y

74
00:02:27,760 --> 00:02:29,599
encryption which can be run by everybody

75
00:02:29,599 --> 00:02:31,519
who knows the master public key

76
00:02:31,519 --> 00:02:33,519
when input and attribute x produces

77
00:02:33,519 --> 00:02:35,599
circuit text for x

78
00:02:35,599 --> 00:02:38,640
and a key symmetric key which can be

79
00:02:38,640 --> 00:02:40,160
used as a key encapsulation

80
00:02:40,160 --> 00:02:43,280
mechanism and then there is the

81
00:02:43,280 --> 00:02:44,959
decryption algorithm which should input

82
00:02:44,959 --> 00:02:45,599
a key

83
00:02:45,599 --> 00:02:47,760
and a ciphertext will produce the

84
00:02:47,760 --> 00:02:48,640
symmetric key

85
00:02:48,640 --> 00:02:51,200
which is supposed to be the same one

86
00:02:51,200 --> 00:02:52,400
produced during encryption

87
00:02:52,400 --> 00:02:56,160
if the predicate between x and y holds

88
00:02:56,160 --> 00:02:59,040
or bought otherwise attribute-based

89
00:02:59,040 --> 00:02:59,760
encryption

90
00:02:59,760 --> 00:03:02,840
was first conceived by saharan waters in

91
00:03:02,840 --> 00:03:04,319
2005

92
00:03:04,319 --> 00:03:06,560
and it was later actually introduced by

93
00:03:06,560 --> 00:03:08,400
goyal and others

94
00:03:08,400 --> 00:03:10,400
originally it was designed in the flavor

95
00:03:10,400 --> 00:03:12,480
of key policy as we base encryption

96
00:03:12,480 --> 00:03:14,720
but there are other other versions of it

97
00:03:14,720 --> 00:03:17,040
for example cipheretics policy

98
00:03:17,040 --> 00:03:19,920
where um policies are in the ciphertext

99
00:03:19,920 --> 00:03:21,120
and the keys are associated to

100
00:03:21,120 --> 00:03:21,760
attributes

101
00:03:21,760 --> 00:03:24,080
that that's the example that we saw with

102
00:03:24,080 --> 00:03:25,519
the university

103
00:03:25,519 --> 00:03:27,280
but nowadays the notion of attribute

104
00:03:27,280 --> 00:03:28,640
based encryption has been

105
00:03:28,640 --> 00:03:32,319
generalized and thanks to big effort by

106
00:03:32,319 --> 00:03:33,680
the community

107
00:03:33,680 --> 00:03:36,000
there exists efficient skins for a rich

108
00:03:36,000 --> 00:03:38,959
variety of predicates so for example

109
00:03:38,959 --> 00:03:42,319
we have a zero inner product encryption

110
00:03:42,319 --> 00:03:45,519
where x and y are both vectors

111
00:03:45,519 --> 00:03:48,239
and decryption will hold if the inner

112
00:03:48,239 --> 00:03:51,120
product of between these vectors is zero

113
00:03:51,120 --> 00:03:54,080
but other examples are for example

114
00:03:54,080 --> 00:03:56,239
monotonic access structures

115
00:03:56,239 --> 00:03:58,239
or hierarchical identity based

116
00:03:58,239 --> 00:03:59,519
encryption

117
00:03:59,519 --> 00:04:01,280
large universe attribute-based

118
00:04:01,280 --> 00:04:02,480
encryption where the number of

119
00:04:02,480 --> 00:04:04,400
attributes is

120
00:04:04,400 --> 00:04:07,760
exponential maybe exponential number of

121
00:04:07,760 --> 00:04:10,720
existing attributes

122
00:04:10,799 --> 00:04:12,879
polynomial size circuits regular

123
00:04:12,879 --> 00:04:15,439
languages and there are many others

124
00:04:15,439 --> 00:04:18,880
but however despite this great progress

125
00:04:18,880 --> 00:04:20,720
in the field designing better schemes in

126
00:04:20,720 --> 00:04:22,639
terms of size

127
00:04:22,639 --> 00:04:24,400
performance security and expressivity

128
00:04:24,400 --> 00:04:26,479
became really hard

129
00:04:26,479 --> 00:04:28,000
until two breakthrough through

130
00:04:28,000 --> 00:04:30,560
constructions appeared in 2014 so these

131
00:04:30,560 --> 00:04:32,080
are the works by

132
00:04:32,080 --> 00:04:33,840
we and atrapatun which are two

133
00:04:33,840 --> 00:04:35,280
independent works

134
00:04:35,280 --> 00:04:38,560
that propose uh generic and unifying

135
00:04:38,560 --> 00:04:40,320
frameworks for designing attribute-based

136
00:04:40,320 --> 00:04:41,360
encryption schemes

137
00:04:41,360 --> 00:04:44,080
four different predicates both works

138
00:04:44,080 --> 00:04:45,919
define

139
00:04:45,919 --> 00:04:48,720
what is called an encoding and then

140
00:04:48,720 --> 00:04:50,639
follow the dual system methodology

141
00:04:50,639 --> 00:04:52,880
to construct to construct a compiler

142
00:04:52,880 --> 00:04:54,639
that on input the encoding for certain

143
00:04:54,639 --> 00:04:57,120
predicate p produces a fully secure

144
00:04:57,120 --> 00:04:58,720
attribute-based encryption for it for

145
00:04:58,720 --> 00:05:00,479
that predicate

146
00:05:00,479 --> 00:05:02,479
these frameworks remarkably simplify the

147
00:05:02,479 --> 00:05:04,080
design and study of attribute-based

148
00:05:04,080 --> 00:05:05,759
encryption schemes because the designer

149
00:05:05,759 --> 00:05:07,039
can focus

150
00:05:07,039 --> 00:05:08,840
on the construction of the simpler

151
00:05:08,840 --> 00:05:12,080
encoding for the desired predicate

152
00:05:12,080 --> 00:05:14,240
and then uh you can just use the

153
00:05:14,240 --> 00:05:15,759
compiler to get the attribute-based

154
00:05:15,759 --> 00:05:17,120
encryption scheme and analyzing the

155
00:05:17,120 --> 00:05:18,400
security of

156
00:05:18,400 --> 00:05:21,840
these encodings is much simpler so in

157
00:05:21,840 --> 00:05:24,400
the framework of we they define what's

158
00:05:24,400 --> 00:05:25,199
called

159
00:05:25,199 --> 00:05:27,919
predicate encodings and it's the

160
00:05:27,919 --> 00:05:29,840
framework of a trapadon

161
00:05:29,840 --> 00:05:32,160
where they define pairing callings and

162
00:05:32,160 --> 00:05:33,759
this is the primitive that we study in

163
00:05:33,759 --> 00:05:36,240
this work

164
00:05:36,560 --> 00:05:38,479
both works were generalized to the prime

165
00:05:38,479 --> 00:05:39,919
order setting

166
00:05:39,919 --> 00:05:43,039
and there are other subsequent works

167
00:05:43,039 --> 00:05:43,520
about

168
00:05:43,520 --> 00:05:45,759
parent coding some predicate encodings

169
00:05:45,759 --> 00:05:49,120
that refine these notions

170
00:05:49,120 --> 00:05:50,800
so we are going to focus on on the

171
00:05:50,800 --> 00:05:52,560
framework by a trapezoid started by a

172
00:05:52,560 --> 00:05:53,520
tripod about

173
00:05:53,520 --> 00:05:56,400
pair encodings and this is supposed to

174
00:05:56,400 --> 00:05:57,520
be

175
00:05:57,520 --> 00:06:00,160
the most expressive one now let me

176
00:06:00,160 --> 00:06:01,919
define what a

177
00:06:01,919 --> 00:06:03,840
parent calling actually is so a pure

178
00:06:03,840 --> 00:06:05,039
encoding

179
00:06:05,039 --> 00:06:08,479
with respect to certain predicate

180
00:06:08,479 --> 00:06:11,039
consists of four algorithms the first

181
00:06:11,039 --> 00:06:12,319
algorithm just takes

182
00:06:12,319 --> 00:06:14,720
certain parameters defined by the

183
00:06:14,720 --> 00:06:16,880
predicate and produces an integer

184
00:06:16,880 --> 00:06:18,560
this integer corresponds to the number

185
00:06:18,560 --> 00:06:20,960
of common variables

186
00:06:20,960 --> 00:06:22,880
we'll see which would these are in a

187
00:06:22,880 --> 00:06:24,160
second and

188
00:06:24,160 --> 00:06:26,240
the other two encodings the key encoding

189
00:06:26,240 --> 00:06:27,680
and the ciphertex encoding

190
00:06:27,680 --> 00:06:30,800
they just produce polynomials

191
00:06:30,800 --> 00:06:32,319
this k represents a vector of

192
00:06:32,319 --> 00:06:35,680
polynomials on several variables

193
00:06:35,680 --> 00:06:39,360
and what i want to point out

194
00:06:39,360 --> 00:06:42,720
is that in this set of variables

195
00:06:42,720 --> 00:06:44,560
r hat there is this distinguished

196
00:06:44,560 --> 00:06:48,400
variable called alpha

197
00:06:48,400 --> 00:06:51,680
separators in coding also outputs

198
00:06:51,680 --> 00:06:53,599
a set of polynomials a list of

199
00:06:53,599 --> 00:06:55,039
polynomials

200
00:06:55,039 --> 00:06:56,960
on different variables but as you can

201
00:06:56,960 --> 00:06:59,280
see this b

202
00:06:59,280 --> 00:07:00,880
appears in both that's why they are

203
00:07:00,880 --> 00:07:03,440
called the common variables

204
00:07:03,440 --> 00:07:06,000
and here there is a distinguished

205
00:07:06,000 --> 00:07:06,560
variable

206
00:07:06,560 --> 00:07:11,039
s0 finally there is a fourth algorithm

207
00:07:11,039 --> 00:07:15,280
that outputs two matrices and

208
00:07:15,280 --> 00:07:16,960
there are several conditions on the

209
00:07:16,960 --> 00:07:19,039
parent coding scheme so one of them is

210
00:07:19,039 --> 00:07:21,680
structural constraints which basically

211
00:07:21,680 --> 00:07:22,560
says that

212
00:07:22,560 --> 00:07:25,680
this list of polynomials k produced

213
00:07:25,680 --> 00:07:28,400
by the the king coding they can only

214
00:07:28,400 --> 00:07:28,960
contain

215
00:07:28,960 --> 00:07:31,520
this this type of monomials these types

216
00:07:31,520 --> 00:07:34,240
of monomials

217
00:07:34,720 --> 00:07:37,039
either a common variable multiplied by

218
00:07:37,039 --> 00:07:37,919
one of these

219
00:07:37,919 --> 00:07:40,800
r variables called the non-lone

220
00:07:40,800 --> 00:07:42,840
variables

221
00:07:42,840 --> 00:07:46,479
or uh so-called loan variables

222
00:07:46,479 --> 00:07:50,800
alone and similarly

223
00:07:50,800 --> 00:07:53,599
ciphertext encodings can only be formed

224
00:07:53,599 --> 00:07:54,080
off

225
00:07:54,080 --> 00:07:57,440
of this this type of parameters

226
00:07:57,440 --> 00:08:00,400
okay that said there is an extra

227
00:08:00,400 --> 00:08:02,879
condition which is that

228
00:08:02,879 --> 00:08:06,319
if the predicate between x and y holds

229
00:08:06,319 --> 00:08:09,039
then these matrices satisfy the

230
00:08:09,039 --> 00:08:11,599
following equality

231
00:08:11,599 --> 00:08:14,960
symbolically so as polynomials

232
00:08:14,960 --> 00:08:17,440
finally there is an an extra condition

233
00:08:17,440 --> 00:08:19,280
called a non-reconstructability

234
00:08:19,280 --> 00:08:21,520
or which is the one that provides

235
00:08:21,520 --> 00:08:23,280
security which says that

236
00:08:23,280 --> 00:08:25,440
when the predicate does not hold between

237
00:08:25,440 --> 00:08:26,639
x and y

238
00:08:26,639 --> 00:08:29,599
then this equality should not hold for

239
00:08:29,599 --> 00:08:30,160
any

240
00:08:30,160 --> 00:08:32,320
possible value of the matrices e and e

241
00:08:32,320 --> 00:08:33,919
prime

242
00:08:33,919 --> 00:08:37,200
now let me briefly explain you how

243
00:08:37,200 --> 00:08:39,279
how this encoding is then used to build

244
00:08:39,279 --> 00:08:40,799
attribute-based encryption scheme so

245
00:08:40,799 --> 00:08:43,039
this is a simplification

246
00:08:43,039 --> 00:08:45,360
of the actual compiler but i think it

247
00:08:45,360 --> 00:08:48,480
gives a good intuition how it works

248
00:08:48,480 --> 00:08:51,680
so we are all over a bi-linear

249
00:08:51,680 --> 00:08:54,720
bi-linear group

250
00:08:54,720 --> 00:08:58,640
and the master public key will be just

251
00:08:58,640 --> 00:09:00,720
the generator of the target group to the

252
00:09:00,720 --> 00:09:03,839
the power of the secret element alpha

253
00:09:03,839 --> 00:09:06,880
and the generator of the first group

254
00:09:06,880 --> 00:09:09,440
to the power of the common variables all

255
00:09:09,440 --> 00:09:11,040
right alpha and the common variables are

256
00:09:11,040 --> 00:09:12,560
the master security

257
00:09:12,560 --> 00:09:15,680
then keys secret keys have this form so

258
00:09:15,680 --> 00:09:17,120
polynomials k

259
00:09:17,120 --> 00:09:21,440
are used in the exponent of g2

260
00:09:21,440 --> 00:09:24,480
and ciphertexts have this form

261
00:09:24,480 --> 00:09:26,880
very similar and notice that the kink

262
00:09:26,880 --> 00:09:28,560
absolution mechanism

263
00:09:28,560 --> 00:09:32,160
is just gt to the power of this

264
00:09:32,160 --> 00:09:33,920
interesting polynomial between the two

265
00:09:33,920 --> 00:09:36,720
distinguished variables

266
00:09:36,720 --> 00:09:38,920
so now this property over here

267
00:09:38,920 --> 00:09:40,480
reconstructability

268
00:09:40,480 --> 00:09:43,440
guarantees that um if you if your x and

269
00:09:43,440 --> 00:09:45,440
y satisfy the predicate

270
00:09:45,440 --> 00:09:47,680
then you will be able to combine these

271
00:09:47,680 --> 00:09:52,399
these terms over here in order to get

272
00:09:52,399 --> 00:09:54,959
the key encapsulation in the target

273
00:09:54,959 --> 00:09:55,760
group

274
00:09:55,760 --> 00:09:58,160
so the way you do it you will pair this

275
00:09:58,160 --> 00:09:59,360
element

276
00:09:59,360 --> 00:10:02,480
with these elements here

277
00:10:02,480 --> 00:10:05,680
and vice versa here and then apply uh

278
00:10:05,680 --> 00:10:06,959
make linear algebra

279
00:10:06,959 --> 00:10:10,399
in the exponent let's see an example

280
00:10:10,399 --> 00:10:13,120
this is probably the simplest parenchym

281
00:10:13,120 --> 00:10:14,320
scheme

282
00:10:14,320 --> 00:10:16,399
for the predicate and the identity based

283
00:10:16,399 --> 00:10:18,160
encryption predicate where

284
00:10:18,160 --> 00:10:21,360
the predicate between x and y holds if x

285
00:10:21,360 --> 00:10:25,279
equals y in this case

286
00:10:25,279 --> 00:10:26,959
n equals three so we can say the first

287
00:10:26,959 --> 00:10:30,399
algorithm outputs three

288
00:10:30,480 --> 00:10:32,640
these are the the key encoding and

289
00:10:32,640 --> 00:10:34,320
ciphertext encoding kink only has two

290
00:10:34,320 --> 00:10:35,279
polynomials

291
00:10:35,279 --> 00:10:38,399
separate encoding has only one on these

292
00:10:38,399 --> 00:10:41,680
variables and in this case and those

293
00:10:41,680 --> 00:10:43,760
matrices allow reconstructability to see

294
00:10:43,760 --> 00:10:44,079
why

295
00:10:44,079 --> 00:10:47,680
you can simply check that

296
00:10:47,680 --> 00:10:50,720
if you multiply s0 by this polynomial

297
00:10:50,720 --> 00:10:55,040
and s1 by this polynomial and subtract

298
00:10:55,040 --> 00:10:56,640
this other polynomial what you get is

299
00:10:56,640 --> 00:10:58,800
this and notice that

300
00:10:58,800 --> 00:11:02,240
when x equals y these two terms will

301
00:11:02,240 --> 00:11:03,680
cancel out

302
00:11:03,680 --> 00:11:06,720
and you will end up with s0 times

303
00:11:06,720 --> 00:11:11,120
alpha argon non-reconstructability is

304
00:11:11,120 --> 00:11:14,240
more involved but there is a very nice

305
00:11:14,240 --> 00:11:14,800
way of

306
00:11:14,800 --> 00:11:18,640
doing it for this example which is uh

307
00:11:18,640 --> 00:11:22,160
finding an assignment of the variables

308
00:11:22,160 --> 00:11:25,200
that vanishes all the polynomials

309
00:11:25,200 --> 00:11:27,279
so you can check you can actually check

310
00:11:27,279 --> 00:11:28,320
that this assignment

311
00:11:28,320 --> 00:11:31,120
vanishes all polynomials but it does not

312
00:11:31,120 --> 00:11:32,480
vanish polynomial

313
00:11:32,480 --> 00:11:34,880
s 0 times alpha because actually both s

314
00:11:34,880 --> 00:11:36,000
0 and alpha

315
00:11:36,000 --> 00:11:39,920
are equal 1. so if this happens

316
00:11:39,920 --> 00:11:44,320
then it's uh it's clear that

317
00:11:44,320 --> 00:11:45,760
you cannot have your constructability

318
00:11:45,760 --> 00:11:48,000
otherwise you will have a contradiction

319
00:11:48,000 --> 00:11:51,600
the following you can you can reason

320
00:11:51,600 --> 00:11:53,519
in the following way and you derive that

321
00:11:53,519 --> 00:11:55,680
zero must be equal to one which is

322
00:11:55,680 --> 00:11:57,040
obviously a contradiction

323
00:11:57,040 --> 00:12:01,040
and notice that um this assignment

324
00:12:01,040 --> 00:12:03,440
is using the inverse of x minus y so

325
00:12:03,440 --> 00:12:04,959
actually this assignment is only well

326
00:12:04,959 --> 00:12:05,920
defined

327
00:12:05,920 --> 00:12:08,880
if the predicate is false but that's

328
00:12:08,880 --> 00:12:12,160
fine because that's all we want

329
00:12:12,160 --> 00:12:13,760
this is just an example where there

330
00:12:13,760 --> 00:12:15,839
exists pairing codings for a rich

331
00:12:15,839 --> 00:12:17,600
variety of predicates

332
00:12:17,600 --> 00:12:20,959
however and it's natural to ask the

333
00:12:20,959 --> 00:12:22,480
question of whether we can transform or

334
00:12:22,480 --> 00:12:24,079
combine bearing codings

335
00:12:24,079 --> 00:12:27,440
and in fact this has been done so

336
00:12:27,440 --> 00:12:29,920
starting from a predicate sorry from a

337
00:12:29,920 --> 00:12:31,680
parent coding

338
00:12:31,680 --> 00:12:34,240
scheme for threat and predicate p one

339
00:12:34,240 --> 00:12:35,040
may want to

340
00:12:35,040 --> 00:12:38,160
to transform this into

341
00:12:38,160 --> 00:12:39,920
upper encoding scheme for the dual

342
00:12:39,920 --> 00:12:41,519
predicate which is

343
00:12:41,519 --> 00:12:43,600
defined as follows basically just swap

344
00:12:43,600 --> 00:12:46,880
the roles of x and y

345
00:12:47,360 --> 00:12:50,800
and this has been done by trapadong and

346
00:12:50,800 --> 00:12:52,959
yamada in 2015

347
00:12:52,959 --> 00:12:55,839
and they also did the conjunction so

348
00:12:55,839 --> 00:12:57,680
starting from two different

349
00:12:57,680 --> 00:12:59,200
uh pairing coding schemes for two

350
00:12:59,200 --> 00:13:01,440
different predicates just build one

351
00:13:01,440 --> 00:13:04,320
pass for the the conjunction of these

352
00:13:04,320 --> 00:13:07,200
two predicates

353
00:13:07,200 --> 00:13:08,480
you can also do this junction this

354
00:13:08,480 --> 00:13:11,279
junction is very easy you can just run

355
00:13:11,279 --> 00:13:15,519
both both schemes in parallel

356
00:13:15,519 --> 00:13:18,000
however how about the negation negation

357
00:13:18,000 --> 00:13:19,680
is harder

358
00:13:19,680 --> 00:13:21,920
and it was not done before it has been

359
00:13:21,920 --> 00:13:25,440
done in a limited framework of

360
00:13:25,440 --> 00:13:28,639
predicating codings by myself and

361
00:13:28,639 --> 00:13:32,240
this was under my phd and this

362
00:13:32,240 --> 00:13:34,959
predicate encoding setting as i said is

363
00:13:34,959 --> 00:13:37,360
less expressive than parent cuttings

364
00:13:37,360 --> 00:13:39,440
and this open this problem was open for

365
00:13:39,440 --> 00:13:41,040
the case of pairing coatings general

366
00:13:41,040 --> 00:13:42,320
pairing cuttings

367
00:13:42,320 --> 00:13:44,000
and it's what we try to solve in this

368
00:13:44,000 --> 00:13:45,360
work

369
00:13:45,360 --> 00:13:47,440
so in this work we propose a generic

370
00:13:47,440 --> 00:13:49,279
transformation that takes any parench

371
00:13:49,279 --> 00:13:50,320
and scheme

372
00:13:50,320 --> 00:13:53,920
and produces a new parenchyma scheme for

373
00:13:53,920 --> 00:13:55,920
the negated predicate so as i said we

374
00:13:55,920 --> 00:13:58,560
solve this problem that was open

375
00:13:58,560 --> 00:14:01,760
for the case of general generic negation

376
00:14:01,760 --> 00:14:03,120
of brain coatings

377
00:14:03,120 --> 00:14:05,040
so along the way we provide an algebraic

378
00:14:05,040 --> 00:14:06,720
characterization of prime coatings that

379
00:14:06,720 --> 00:14:08,000
can be of independent

380
00:14:08,000 --> 00:14:09,199
interest and we're going to talk a

381
00:14:09,199 --> 00:14:11,279
little bit about this later

382
00:14:11,279 --> 00:14:13,519
and our transformation leads to new new

383
00:14:13,519 --> 00:14:15,279
encodings for example we propose the

384
00:14:15,279 --> 00:14:16,800
first brain coding for

385
00:14:16,800 --> 00:14:20,240
negated doubly spatial encryption

386
00:14:20,240 --> 00:14:21,839
which i'm going to explain what it is

387
00:14:21,839 --> 00:14:23,920
later

388
00:14:23,920 --> 00:14:26,639
and finally we we're going to discuss

389
00:14:26,639 --> 00:14:28,079
other implications

390
00:14:28,079 --> 00:14:31,279
of our results and

391
00:14:31,279 --> 00:14:33,600
why i think this transformation is

392
00:14:33,600 --> 00:14:35,440
important

393
00:14:35,440 --> 00:14:37,360
in order to define our generic negation

394
00:14:37,360 --> 00:14:38,800
transformation

395
00:14:38,800 --> 00:14:41,279
we're gonna modify the way we look at

396
00:14:41,279 --> 00:14:42,880
parent coding schemes

397
00:14:42,880 --> 00:14:45,680
so i'm gonna define a new way a new

398
00:14:45,680 --> 00:14:48,320
definition of encoding

399
00:14:48,320 --> 00:14:49,839
which i like to think about it as

400
00:14:49,839 --> 00:14:52,320
splitting and encoding into layers

401
00:14:52,320 --> 00:14:55,360
so there'll be as many layers as there

402
00:14:55,360 --> 00:14:57,199
are common

403
00:14:57,199 --> 00:15:00,240
variables plus one

404
00:15:00,240 --> 00:15:03,360
so instead of producing polynomials

405
00:15:03,360 --> 00:15:05,600
the way i see the encoding this is what

406
00:15:05,600 --> 00:15:07,199
i call the algebraic encoding

407
00:15:07,199 --> 00:15:10,800
is two algorithms that produce matrices

408
00:15:10,800 --> 00:15:12,240
and there is a correspondence between

409
00:15:12,240 --> 00:15:14,880
these matrices and previous polynomials

410
00:15:14,880 --> 00:15:18,160
which is follows by the way

411
00:15:18,160 --> 00:15:21,199
i am assuming that the key encoding is

412
00:15:21,199 --> 00:15:22,880
of a certain specific form

413
00:15:22,880 --> 00:15:25,279
namely alpha only appears in one of the

414
00:15:25,279 --> 00:15:27,040
polynomials

415
00:15:27,040 --> 00:15:29,759
and that polynomial is of this form so

416
00:15:29,759 --> 00:15:30,240
this

417
00:15:30,240 --> 00:15:33,199
this assumption can eyes without loss of

418
00:15:33,199 --> 00:15:35,040
generality that has been used many times

419
00:15:35,040 --> 00:15:36,959
in the literature

420
00:15:36,959 --> 00:15:40,480
for example by a trapadon and one way of

421
00:15:40,480 --> 00:15:42,079
saying why it's without loss of

422
00:15:42,079 --> 00:15:44,160
generality is applying the

423
00:15:44,160 --> 00:15:46,800
dual transformation twice if you apply a

424
00:15:46,800 --> 00:15:48,639
troponins to a transformation

425
00:15:48,639 --> 00:15:51,440
which is an involution you will get an

426
00:15:51,440 --> 00:15:53,519
encoding that is of this form

427
00:15:53,519 --> 00:15:56,560
our polynomials can be seen

428
00:15:56,560 --> 00:15:59,600
as the multiplication of these matrices

429
00:15:59,600 --> 00:16:02,720
by the corresponding common variable

430
00:16:02,720 --> 00:16:05,759
and then all multiplied by the

431
00:16:05,759 --> 00:16:08,240
null lone variables and we add c times

432
00:16:08,240 --> 00:16:09,839
the lone variables the same structure

433
00:16:09,839 --> 00:16:10,880
goes here

434
00:16:10,880 --> 00:16:12,720
and this structure is possible thanks to

435
00:16:12,720 --> 00:16:14,399
the structural constraints on the

436
00:16:14,399 --> 00:16:16,959
polynomials that they only contain

437
00:16:16,959 --> 00:16:20,560
these kind of monomials respectively

438
00:16:20,560 --> 00:16:23,759
and it's very useful to look at

439
00:16:23,759 --> 00:16:26,720
these at parent codings as matrices

440
00:16:26,720 --> 00:16:28,399
instead of polynomials

441
00:16:28,399 --> 00:16:32,240
and to look at the reconstructability

442
00:16:32,240 --> 00:16:34,480
property in terms of matrices namely in

443
00:16:34,480 --> 00:16:36,000
this case

444
00:16:36,000 --> 00:16:39,360
we say an algebraic encoding

445
00:16:39,360 --> 00:16:43,040
is reconstructable if for every x and y

446
00:16:43,040 --> 00:16:44,880
to satisfy the predicate there exists

447
00:16:44,880 --> 00:16:45,519
matrices

448
00:16:45,519 --> 00:16:48,240
e and e prime such that all these

449
00:16:48,240 --> 00:16:50,160
equations hold

450
00:16:50,160 --> 00:16:51,920
so here i'm being very explicit with the

451
00:16:51,920 --> 00:16:53,360
dimensions but

452
00:16:53,360 --> 00:16:55,600
it's not very important now so this

453
00:16:55,600 --> 00:16:57,920
means the zero matrix

454
00:16:57,920 --> 00:17:01,440
and this is just a zero matrix

455
00:17:01,440 --> 00:17:05,599
whose first element is a one so

456
00:17:05,599 --> 00:17:08,400
the the element on the first column and

457
00:17:08,400 --> 00:17:09,280
the first

458
00:17:09,280 --> 00:17:12,160
row is one everything else is zero and

459
00:17:12,160 --> 00:17:13,760
it can be shown that

460
00:17:13,760 --> 00:17:17,039
this this set of equations here is

461
00:17:17,039 --> 00:17:18,439
equivalent to the previous

462
00:17:18,439 --> 00:17:21,520
reconstructability so why is this useful

463
00:17:21,520 --> 00:17:23,359
well this is useful because we can now

464
00:17:23,359 --> 00:17:25,439
leverage a very powerful result from the

465
00:17:25,439 --> 00:17:27,919
linear algorithm that has been widely

466
00:17:27,919 --> 00:17:28,720
used in

467
00:17:28,720 --> 00:17:31,440
in the literature which says that a

468
00:17:31,440 --> 00:17:32,559
certain system

469
00:17:32,559 --> 00:17:36,320
is unsatisfiable so there is

470
00:17:36,320 --> 00:17:39,039
there is no v such that a times v equals

471
00:17:39,039 --> 00:17:39,600
said

472
00:17:39,600 --> 00:17:43,600
if and only if there exists a w

473
00:17:43,600 --> 00:17:46,720
that vanishes a without vanishing set

474
00:17:46,720 --> 00:17:49,840
roughly and this is so powerful

475
00:17:49,840 --> 00:17:51,120
and it's what we are going to use in

476
00:17:51,120 --> 00:17:53,200
order to build our negated encoding

477
00:17:53,200 --> 00:17:56,400
so you can think of this property

478
00:17:56,400 --> 00:18:00,080
as non-reconstructability so for

479
00:18:00,080 --> 00:18:03,440
all solutions a certain

480
00:18:03,440 --> 00:18:05,600
system is not satisfiable this is what

481
00:18:05,600 --> 00:18:07,360
you have when

482
00:18:07,360 --> 00:18:08,760
when the predicate is false you have

483
00:18:08,760 --> 00:18:11,039
non-reconstructability then there is a

484
00:18:11,039 --> 00:18:12,320
dual world

485
00:18:12,320 --> 00:18:13,520
where things are actually

486
00:18:13,520 --> 00:18:16,799
reconstructable so the intuition is that

487
00:18:16,799 --> 00:18:19,760
if we can somehow transpose all the

488
00:18:19,760 --> 00:18:20,960
matrices involved

489
00:18:20,960 --> 00:18:24,559
in in our encoding we can create

490
00:18:24,559 --> 00:18:27,200
an encoding for the negated predicate in

491
00:18:27,200 --> 00:18:29,039
this work we use a modified

492
00:18:29,039 --> 00:18:32,240
version of the previous lemma that is

493
00:18:32,240 --> 00:18:34,160
closer to what we need which is as

494
00:18:34,160 --> 00:18:35,840
follows and then

495
00:18:35,840 --> 00:18:37,520
very explicit with the dimensions of the

496
00:18:37,520 --> 00:18:39,200
matrices but just ignore this

497
00:18:39,200 --> 00:18:41,440
what this lemma says is that if you have

498
00:18:41,440 --> 00:18:42,480
matrices

499
00:18:42,480 --> 00:18:45,520
a i b i c i and a hat we had

500
00:18:45,520 --> 00:18:47,600
then these two conditions are equivalent

501
00:18:47,600 --> 00:18:49,520
so there does not exist

502
00:18:49,520 --> 00:18:52,640
a solution x y to this system of

503
00:18:52,640 --> 00:18:53,760
equations

504
00:18:53,760 --> 00:18:57,360
if and only if there exists a solution

505
00:18:57,360 --> 00:18:59,360
to this other system notice that the

506
00:18:59,360 --> 00:19:01,120
first the first statement here is very

507
00:19:01,120 --> 00:19:01,760
close

508
00:19:01,760 --> 00:19:04,640
to our reconstructability condition here

509
00:19:04,640 --> 00:19:04,960
so

510
00:19:04,960 --> 00:19:06,400
there is a correspondence between the

511
00:19:06,400 --> 00:19:09,600
solution x and matrix e

512
00:19:09,600 --> 00:19:12,720
solution y and matrix e prime and you

513
00:19:12,720 --> 00:19:13,280
can check

514
00:19:13,280 --> 00:19:14,799
that there is actually correspondence

515
00:19:14,799 --> 00:19:16,640
between everything i mean this this

516
00:19:16,640 --> 00:19:19,120
this limit has not been designed by

517
00:19:19,120 --> 00:19:19,679
chance

518
00:19:19,679 --> 00:19:22,799
it's just exactly what we need another

519
00:19:22,799 --> 00:19:24,320
question is whether we can

520
00:19:24,320 --> 00:19:26,880
use these matrices that define our

521
00:19:26,880 --> 00:19:27,919
encoding

522
00:19:27,919 --> 00:19:30,320
in transposed manner so that we can

523
00:19:30,320 --> 00:19:32,640
leverage the second statement

524
00:19:32,640 --> 00:19:35,600
when the predicate is false which will

525
00:19:35,600 --> 00:19:37,360
give us reconstructability

526
00:19:37,360 --> 00:19:40,160
of the negated encoding so here is my

527
00:19:40,160 --> 00:19:41,039
negation

528
00:19:41,039 --> 00:19:43,520
transformation the matrices

529
00:19:43,520 --> 00:19:45,520
corresponding to common variables both

530
00:19:45,520 --> 00:19:46,960
here and here

531
00:19:46,960 --> 00:19:49,520
are very sparse almost all the entries

532
00:19:49,520 --> 00:19:50,480
are 0x

533
00:19:50,480 --> 00:19:52,960
except for a few ones so now that we

534
00:19:52,960 --> 00:19:53,600
have a

535
00:19:53,600 --> 00:19:56,799
generic transformation that negates any

536
00:19:56,799 --> 00:19:57,919
pair encoding scheme

537
00:19:57,919 --> 00:19:59,280
let me talk a little bit about the

538
00:19:59,280 --> 00:20:01,039
consequences of this so first of all we

539
00:20:01,039 --> 00:20:02,640
can negate an encoding

540
00:20:02,640 --> 00:20:05,919
so people were designing both the normal

541
00:20:05,919 --> 00:20:07,840
version of hana coding and

542
00:20:07,840 --> 00:20:10,880
their negated one by hand but now we can

543
00:20:10,880 --> 00:20:13,039
we can get the negated version for free

544
00:20:13,039 --> 00:20:14,480
and maybe there is some encoding for

545
00:20:14,480 --> 00:20:15,440
which no negate

546
00:20:15,440 --> 00:20:17,360
negated version was known and this is

547
00:20:17,360 --> 00:20:19,039
actually the case of doubly spatial

548
00:20:19,039 --> 00:20:20,000
encryption

549
00:20:20,000 --> 00:20:22,559
and i'm very grateful to atrapatung

550
00:20:22,559 --> 00:20:24,480
because he pointed this out

551
00:20:24,480 --> 00:20:26,480
giving a vector and matrix another

552
00:20:26,480 --> 00:20:28,320
vector another matrix

553
00:20:28,320 --> 00:20:30,240
the break gate is one if and only if

554
00:20:30,240 --> 00:20:32,080
these two

555
00:20:32,080 --> 00:20:34,159
spaces intersect and there was a

556
00:20:34,159 --> 00:20:35,360
predicate for

557
00:20:35,360 --> 00:20:37,440
us repairing coding for this predicate

558
00:20:37,440 --> 00:20:38,559
by a trapezone

559
00:20:38,559 --> 00:20:41,760
and it has this form but there was uh

560
00:20:41,760 --> 00:20:44,880
we didn't know how to build this uh the

561
00:20:44,880 --> 00:20:46,880
negated version of this predicate

562
00:20:46,880 --> 00:20:49,200
and our negative transformation gives us

563
00:20:49,200 --> 00:20:50,559
the best of

564
00:20:50,559 --> 00:20:53,360
my knowledge the first pairing coding

565
00:20:53,360 --> 00:20:54,240
for

566
00:20:54,240 --> 00:20:57,120
negated the application encryption and

567
00:20:57,120 --> 00:20:57,919
it looks

568
00:20:57,919 --> 00:21:01,679
as follows you can pause the video and

569
00:21:01,679 --> 00:21:04,080
analyze it slowly but i just want to

570
00:21:04,080 --> 00:21:05,360
point out that this is a

571
00:21:05,360 --> 00:21:07,919
pairing coding scheme for this predicate

572
00:21:07,919 --> 00:21:08,559
so

573
00:21:08,559 --> 00:21:11,840
predicted this one if only if these two

574
00:21:11,840 --> 00:21:15,520
spaces do not intersect our results

575
00:21:15,520 --> 00:21:18,640
tell us uh new information about

576
00:21:18,640 --> 00:21:21,200
the expressivity of pairing codings so

577
00:21:21,200 --> 00:21:22,960
for example now we know that

578
00:21:22,960 --> 00:21:24,720
the set of predicates that can be

579
00:21:24,720 --> 00:21:26,240
expressed with

580
00:21:26,240 --> 00:21:28,240
parent codings is closed under negation

581
00:21:28,240 --> 00:21:30,400
we don't know this before why is this

582
00:21:30,400 --> 00:21:32,400
useful well this suggests that maybe

583
00:21:32,400 --> 00:21:33,200
building

584
00:21:33,200 --> 00:21:34,880
pairing codings for context-free

585
00:21:34,880 --> 00:21:37,440
languages is harder than we think

586
00:21:37,440 --> 00:21:39,840
or it's maybe impossible we can capture

587
00:21:39,840 --> 00:21:41,200
regular languages but

588
00:21:41,200 --> 00:21:42,720
it was it wasn't known whether

589
00:21:42,720 --> 00:21:44,400
context-free languages could be captured

590
00:21:44,400 --> 00:21:45,280
or not

591
00:21:45,280 --> 00:21:47,120
but notice that context-free languages

592
00:21:47,120 --> 00:21:49,760
are not closed under complementation

593
00:21:49,760 --> 00:21:52,640
and therefore if we can build parenchyme

594
00:21:52,640 --> 00:21:54,640
schemes for context-free languages

595
00:21:54,640 --> 00:21:56,559
we could also build parenchyman schemes

596
00:21:56,559 --> 00:21:58,320
for a predicate class that is strictly

597
00:21:58,320 --> 00:21:59,679
more powerful than counterfeit

598
00:21:59,679 --> 00:22:02,559
three languages maybe achieving context

599
00:22:02,559 --> 00:22:04,000
free languages is

600
00:22:04,000 --> 00:22:07,120
is not possible other consequences are

601
00:22:07,120 --> 00:22:09,760
potential performance improvements

602
00:22:09,760 --> 00:22:10,960
notice that

603
00:22:10,960 --> 00:22:13,440
our results tell us that every pair

604
00:22:13,440 --> 00:22:14,880
encoding

605
00:22:14,880 --> 00:22:18,480
can be expressed in this manner where

606
00:22:18,480 --> 00:22:20,880
the common variable matrices are of this

607
00:22:20,880 --> 00:22:21,919
form

608
00:22:21,919 --> 00:22:24,400
like they do not depend on the predicate

609
00:22:24,400 --> 00:22:25,600
all the part that depends on the

610
00:22:25,600 --> 00:22:26,240
predicate

611
00:22:26,240 --> 00:22:29,600
is in this lone variables matrix

612
00:22:29,600 --> 00:22:32,960
so why is this useful well this can lead

613
00:22:32,960 --> 00:22:33,600
to

614
00:22:33,600 --> 00:22:36,080
two efficiency improvements first of all

615
00:22:36,080 --> 00:22:38,000
you can pre-compute this part which is

616
00:22:38,000 --> 00:22:39,679
common for every predicate

617
00:22:39,679 --> 00:22:42,000
and second second of all the part that

618
00:22:42,000 --> 00:22:43,520
depends on the predicate

619
00:22:43,520 --> 00:22:46,559
is here and the part on

620
00:22:46,559 --> 00:22:48,880
loan variables can be batched very

621
00:22:48,880 --> 00:22:49,679
efficiently

622
00:22:49,679 --> 00:22:51,679
whereas this other part cannot be batch

623
00:22:51,679 --> 00:22:53,280
sufficiently i give more details in the

624
00:22:53,280 --> 00:22:54,640
paper about this

625
00:22:54,640 --> 00:22:56,320
so in general our new generic

626
00:22:56,320 --> 00:22:58,000
transformation tells us

627
00:22:58,000 --> 00:22:59,679
that every parent coding can be

628
00:22:59,679 --> 00:23:01,840
expressed of this on this form

629
00:23:01,840 --> 00:23:04,159
so if you don't see why well you can

630
00:23:04,159 --> 00:23:05,760
just negate it twice

631
00:23:05,760 --> 00:23:07,600
and you'll get it of this format in

632
00:23:07,600 --> 00:23:09,280
general maybe there is

633
00:23:09,280 --> 00:23:12,080
an easier way of doing it and having it

634
00:23:12,080 --> 00:23:13,919
in this form it's very useful because

635
00:23:13,919 --> 00:23:16,559
it can lead to efficiency improvements

636
00:23:16,559 --> 00:23:18,320
so i have presented my work on

637
00:23:18,320 --> 00:23:20,840
generic negation of parent coding

638
00:23:20,840 --> 00:23:24,400
schemes i hope this

639
00:23:24,400 --> 00:23:27,520
this gives us a better understanding of

640
00:23:27,520 --> 00:23:30,480
of this primitive and also i mean it led

641
00:23:30,480 --> 00:23:32,640
to new encodings

642
00:23:32,640 --> 00:23:35,120
and can potentially lead to performance

643
00:23:35,120 --> 00:23:36,559
improvements so it will be useful to

644
00:23:36,559 --> 00:23:37,120
know

645
00:23:37,120 --> 00:23:39,679
to really implement these ideas and and

646
00:23:39,679 --> 00:23:41,360
see

647
00:23:41,360 --> 00:23:44,880
um what they can lead to and also as

648
00:23:44,880 --> 00:23:45,919
future work

649
00:23:45,919 --> 00:23:47,679
it will be good to extend our techniques

650
00:23:47,679 --> 00:23:49,440
to this new framework by trapezoidal

651
00:23:49,440 --> 00:23:50,480
gantomida

652
00:23:50,480 --> 00:23:53,760
where they perform dynamic composition

653
00:23:53,760 --> 00:23:56,240
in a standard model of attribute-based

654
00:23:56,240 --> 00:23:57,039
encryption

655
00:23:57,039 --> 00:24:00,080
and notice that our our techniques

656
00:24:00,080 --> 00:24:04,480
are applied to a scenario where

657
00:24:04,480 --> 00:24:06,640
there is a queue type assumption it's

658
00:24:06,640 --> 00:24:08,559
not a completely standard model

659
00:24:08,559 --> 00:24:10,320
it'll be good to know whether our

660
00:24:10,320 --> 00:24:12,320
techniques apply to this other framework

661
00:24:12,320 --> 00:24:15,279
very recent work by a tripod and domina

662
00:24:15,279 --> 00:24:15,679
so

663
00:24:15,679 --> 00:24:17,760
yeah thank you very much for listening

664
00:24:17,760 --> 00:24:20,559
that was it

