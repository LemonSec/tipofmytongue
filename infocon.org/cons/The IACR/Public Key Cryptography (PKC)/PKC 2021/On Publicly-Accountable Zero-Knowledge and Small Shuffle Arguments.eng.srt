1
00:00:01,120 --> 00:00:03,360
this talk is on publicly countable zero

2
00:00:03,360 --> 00:00:05,200
knowledge and small shuffle arguments

3
00:00:05,200 --> 00:00:07,200
my name is niels flashaka and this is

4
00:00:07,200 --> 00:00:10,639
joint work with mark zimkin

5
00:00:11,120 --> 00:00:13,599
in this talk i will be talking about

6
00:00:13,599 --> 00:00:15,759
shuffling re-randomizable commitments

7
00:00:15,759 --> 00:00:17,359
what do i mean by re-randomizable

8
00:00:17,359 --> 00:00:18,960
commitments normally when you think of

9
00:00:18,960 --> 00:00:19,680
rebound

10
00:00:19,680 --> 00:00:21,760
of commitments you will think of binding

11
00:00:21,760 --> 00:00:22,800
and hiding

12
00:00:22,800 --> 00:00:24,640
those properties are not important for

13
00:00:24,640 --> 00:00:27,119
our definitions or our construction

14
00:00:27,119 --> 00:00:28,640
and we need two properties of the

15
00:00:28,640 --> 00:00:30,160
commitment scheme

16
00:00:30,160 --> 00:00:32,159
we need that if we we need perfect

17
00:00:32,159 --> 00:00:33,680
re-randomizability which

18
00:00:33,680 --> 00:00:35,360
means that if we have a message and we

19
00:00:35,360 --> 00:00:36,719
commit to it

20
00:00:36,719 --> 00:00:38,960
resulting in commitment c and we

21
00:00:38,960 --> 00:00:42,000
re-randomize this commitment c

22
00:00:42,000 --> 00:00:45,440
to c prime the distribution

23
00:00:45,440 --> 00:00:47,520
of this is identical to just

24
00:00:47,520 --> 00:00:49,039
recommitting

25
00:00:49,039 --> 00:00:50,960
with fresh randomness to the same

26
00:00:50,960 --> 00:00:53,199
message

27
00:00:53,199 --> 00:00:56,480
the second property we need is

28
00:00:56,480 --> 00:00:58,960
inversely randomizability which means

29
00:00:58,960 --> 00:01:00,160
that if we have a commitment

30
00:01:00,160 --> 00:01:03,120
we re-randomize it using randomness r

31
00:01:03,120 --> 00:01:05,280
then there is a procedure to undo this

32
00:01:05,280 --> 00:01:06,159
basically

33
00:01:06,159 --> 00:01:08,000
the inverse re-randomization if we use

34
00:01:08,000 --> 00:01:09,760
the same randomness to inversely

35
00:01:09,760 --> 00:01:10,960
re-randomize

36
00:01:10,960 --> 00:01:12,880
then you get back to the original

37
00:01:12,880 --> 00:01:15,360
commitment

38
00:01:15,600 --> 00:01:18,880
now for shuffling arguments to be useful

39
00:01:18,880 --> 00:01:21,119
you would still probably need some kind

40
00:01:21,119 --> 00:01:23,439
of hiding property because otherwise

41
00:01:23,439 --> 00:01:27,520
well things become trivial however

42
00:01:27,520 --> 00:01:29,840
for our definitions and for our

43
00:01:29,840 --> 00:01:31,200
construction

44
00:01:31,200 --> 00:01:33,280
this is not relevant only these two

45
00:01:33,280 --> 00:01:36,560
properties are necessary

46
00:01:36,880 --> 00:01:39,200
so let's talk about what does it mean to

47
00:01:39,200 --> 00:01:41,040
shuffle commitments

48
00:01:41,040 --> 00:01:43,439
it means we have a list or a vector of

49
00:01:43,439 --> 00:01:45,360
commitments v here

50
00:01:45,360 --> 00:01:48,000
with commitments c1 through c4 in this

51
00:01:48,000 --> 00:01:49,200
example

52
00:01:49,200 --> 00:01:52,880
and to shuffle means we re-randomize

53
00:01:52,880 --> 00:01:54,399
each one of those commitments

54
00:01:54,399 --> 00:01:57,600
and then we permute them at random

55
00:01:57,600 --> 00:02:02,159
and v1 v prime is a shuffle of v

56
00:02:02,159 --> 00:02:04,479
if and only if there exists randomnesses

57
00:02:04,479 --> 00:02:05,920
r1 through r4

58
00:02:05,920 --> 00:02:09,119
in this case and the permutation p such

59
00:02:09,119 --> 00:02:10,959
that

60
00:02:10,959 --> 00:02:13,920
c prime p i is in fact the

61
00:02:13,920 --> 00:02:14,959
re-randomization

62
00:02:14,959 --> 00:02:18,959
of c i with ri

63
00:02:19,520 --> 00:02:22,400
and for short we just write this as v

64
00:02:22,400 --> 00:02:22,879
prime

65
00:02:22,879 --> 00:02:26,080
is pi of v

66
00:02:26,080 --> 00:02:30,319
with randomness r and permutation p

67
00:02:30,800 --> 00:02:35,040
okay and a shuffle argument now

68
00:02:35,040 --> 00:02:38,319
is an argument that we can use to

69
00:02:38,319 --> 00:02:39,760
or a zero knowledge argument in

70
00:02:39,760 --> 00:02:42,480
particular that we can use to prove

71
00:02:42,480 --> 00:02:47,359
that v prime is in fact a shuffle of v

72
00:02:47,840 --> 00:02:50,319
now how would we do this so this is the

73
00:02:50,319 --> 00:02:52,319
situation we start with we have v

74
00:02:52,319 --> 00:02:56,160
and v prime and we know that there

75
00:02:56,160 --> 00:02:57,920
exists the shuffle and we also know what

76
00:02:57,920 --> 00:02:59,200
this shuffle is

77
00:02:59,200 --> 00:03:02,640
r and p and we want to prove that this r

78
00:03:02,640 --> 00:03:03,040
and p

79
00:03:03,040 --> 00:03:05,840
exists essentially

80
00:03:07,040 --> 00:03:10,480
so how do we do this the idea is well

81
00:03:10,480 --> 00:03:13,519
split this rnp into two separate

82
00:03:13,519 --> 00:03:14,400
shuffles

83
00:03:14,400 --> 00:03:18,000
r1 p1 r2 p2 such that if you

84
00:03:18,000 --> 00:03:19,760
apply those two shuffles one after

85
00:03:19,760 --> 00:03:21,760
another what you get

86
00:03:21,760 --> 00:03:26,798
is in fact the original shuffle rp

87
00:03:27,360 --> 00:03:31,440
now in general it is not

88
00:03:31,440 --> 00:03:33,360
possible to do this for all commitments

89
00:03:33,360 --> 00:03:34,720
but for most commitments

90
00:03:34,720 --> 00:03:37,120
um you can in fact find these things

91
00:03:37,120 --> 00:03:39,760
efficiently

92
00:03:39,760 --> 00:03:43,440
now um at the end with what we're doing

93
00:03:43,440 --> 00:03:45,920
you don't actually need to do this but

94
00:03:45,920 --> 00:03:47,440
it is in fact possible with most

95
00:03:47,440 --> 00:03:48,480
commitments to

96
00:03:48,480 --> 00:03:51,680
find this kind of split efficiently

97
00:03:51,680 --> 00:03:54,080
now once you split the shuffle like this

98
00:03:54,080 --> 00:03:55,760
you can do a very simple

99
00:03:55,760 --> 00:03:59,280
sigma protocol where the prover

100
00:03:59,280 --> 00:04:02,799
in the first round sends v1 the verifier

101
00:04:02,799 --> 00:04:03,439
then says

102
00:04:03,439 --> 00:04:06,799
hey open the first shuffle or hey

103
00:04:06,799 --> 00:04:10,159
open the second shuffle and the prover

104
00:04:10,159 --> 00:04:11,200
then replies

105
00:04:11,200 --> 00:04:15,519
by sending the corresponding shuffle

106
00:04:15,519 --> 00:04:18,478
now say the verifier said to open the

107
00:04:18,478 --> 00:04:19,519
first shuffle

108
00:04:19,519 --> 00:04:21,839
well then they can recompute the shuffle

109
00:04:21,839 --> 00:04:22,880
get a vector of

110
00:04:22,880 --> 00:04:26,400
commitments and compare this with v1

111
00:04:26,400 --> 00:04:29,120
if it is the same they accept the same

112
00:04:29,120 --> 00:04:29,919
thing can be done

113
00:04:29,919 --> 00:04:32,880
in reverse um for the second shuffle we

114
00:04:32,880 --> 00:04:33,680
start from

115
00:04:33,680 --> 00:04:37,360
v prime and we inversely re-randomize

116
00:04:37,360 --> 00:04:39,520
those commitments and permute them

117
00:04:39,520 --> 00:04:41,360
according to

118
00:04:41,360 --> 00:04:44,880
the r2 p2 and we can check is this the

119
00:04:44,880 --> 00:04:45,919
same as v1

120
00:04:45,919 --> 00:04:49,120
or not and

121
00:04:49,120 --> 00:04:52,479
if it is the verify accepts now this is

122
00:04:52,479 --> 00:04:54,880
a sigma protocol it's honest verify zero

123
00:04:54,880 --> 00:04:55,600
knowledge

124
00:04:55,600 --> 00:04:57,680
the simulator is very simple you just

125
00:04:57,680 --> 00:04:59,440
randomly choose d

126
00:04:59,440 --> 00:05:02,880
you randomly choose a shuffle rdpd

127
00:05:02,880 --> 00:05:07,199
and then you can just compute v v one

128
00:05:07,199 --> 00:05:08,560
so this is honest verifies your

129
00:05:08,560 --> 00:05:10,240
knowledge it's also sound

130
00:05:10,240 --> 00:05:12,880
because imagine you have v and v prime

131
00:05:12,880 --> 00:05:16,960
such that v prime is not a shuffle of v

132
00:05:17,360 --> 00:05:20,720
if the prover was able to

133
00:05:20,720 --> 00:05:23,280
prove that it is a shuffle to the

134
00:05:23,280 --> 00:05:24,000
verifier

135
00:05:24,000 --> 00:05:27,039
with probability greater than one-half

136
00:05:27,039 --> 00:05:30,400
that would mean that in some cases the

137
00:05:30,400 --> 00:05:33,120
prover is able to answer both of those

138
00:05:33,120 --> 00:05:33,840
challenges

139
00:05:33,840 --> 00:05:36,080
one and two but that would mean that

140
00:05:36,080 --> 00:05:37,360
there exists

141
00:05:37,360 --> 00:05:41,039
a shuffle from v to v1 and from v1 to v

142
00:05:41,039 --> 00:05:42,240
prime

143
00:05:42,240 --> 00:05:43,560
and because of the perfect

144
00:05:43,560 --> 00:05:45,360
re-randomizability of the commitment

145
00:05:45,360 --> 00:05:46,479
scheme

146
00:05:46,479 --> 00:05:48,320
we have that this would imply that there

147
00:05:48,320 --> 00:05:50,240
exists in fact a shuffle from b

148
00:05:50,240 --> 00:05:53,840
to v prime

149
00:05:54,639 --> 00:05:56,960
and that would contradict of course the

150
00:05:56,960 --> 00:05:57,680
fact that v

151
00:05:57,680 --> 00:06:01,600
and v prime are not in the language

152
00:06:02,080 --> 00:06:06,160
now why do we not just use the shuffle

153
00:06:06,160 --> 00:06:08,160
argument this seems nice it's a sql

154
00:06:08,160 --> 00:06:10,160
protocol we can actually get the sounds

155
00:06:10,160 --> 00:06:10,960
error down

156
00:06:10,960 --> 00:06:13,919
through sequential repetition and um we

157
00:06:13,919 --> 00:06:14,319
can

158
00:06:14,319 --> 00:06:16,080
apply future mu to that to get make it

159
00:06:16,080 --> 00:06:17,440
non-interactive

160
00:06:17,440 --> 00:06:20,880
however this argument is actually huge

161
00:06:20,880 --> 00:06:22,960
because you can imagine that both prover

162
00:06:22,960 --> 00:06:24,160
messages v1

163
00:06:24,160 --> 00:06:27,120
and of course these randomness values

164
00:06:27,120 --> 00:06:28,400
that we need to send in the third

165
00:06:28,400 --> 00:06:29,520
message

166
00:06:29,520 --> 00:06:31,919
they scale linearly with the length of

167
00:06:31,919 --> 00:06:34,000
the vector v

168
00:06:34,000 --> 00:06:35,919
and this means we can only prove

169
00:06:35,919 --> 00:06:38,240
relatively short

170
00:06:38,240 --> 00:06:39,759
shuffles with this in an efficient

171
00:06:39,759 --> 00:06:42,160
manner what we would want is that it

172
00:06:42,160 --> 00:06:44,000
scales

173
00:06:44,000 --> 00:06:47,280
ideally independently of the

174
00:06:47,280 --> 00:06:50,880
length of those permuted vectors

175
00:06:50,880 --> 00:06:53,840
now the first message is easily fixed

176
00:06:53,840 --> 00:06:55,440
instead of sending v1

177
00:06:55,440 --> 00:06:58,479
we can just send a hash of v1 now the

178
00:06:58,479 --> 00:07:00,479
verifier can still check this

179
00:07:00,479 --> 00:07:03,680
we can recompute the vector

180
00:07:03,680 --> 00:07:05,520
and then hash them and compare the

181
00:07:05,520 --> 00:07:07,680
hashes of course it's now

182
00:07:07,680 --> 00:07:09,599
no longer a proof it's now only an

183
00:07:09,599 --> 00:07:11,759
argument but we're perfectly fine with

184
00:07:11,759 --> 00:07:13,599
that

185
00:07:13,599 --> 00:07:15,759
the bigger problem is the third message

186
00:07:15,759 --> 00:07:17,680
the second prover message

187
00:07:17,680 --> 00:07:20,160
where we need to send these random

188
00:07:20,160 --> 00:07:22,639
shuffles

189
00:07:26,960 --> 00:07:30,240
and to minimize

190
00:07:30,240 --> 00:07:33,599
the communication cost here we would

191
00:07:33,599 --> 00:07:37,280
need to somehow compress those

192
00:07:38,240 --> 00:07:41,599
and um well those are basically

193
00:07:41,599 --> 00:07:44,720
random values so you could imagine

194
00:07:44,720 --> 00:07:46,879
saying okay if these are random values

195
00:07:46,879 --> 00:07:48,479
maybe we can replace them with something

196
00:07:48,479 --> 00:07:49,759
that is not random but

197
00:07:49,759 --> 00:07:53,280
pseudo-random and well

198
00:07:53,280 --> 00:07:56,240
that basically means hey replace them

199
00:07:56,240 --> 00:07:58,080
with the output of a pseudo-random

200
00:07:58,080 --> 00:07:59,199
generator

201
00:07:59,199 --> 00:08:01,599
and then we only need to send the seeds

202
00:08:01,599 --> 00:08:03,360
in the last round

203
00:08:03,360 --> 00:08:05,599
now this looks good because the seed is

204
00:08:05,599 --> 00:08:07,520
actually independent of the

205
00:08:07,520 --> 00:08:09,360
the length of the seed is independent of

206
00:08:09,360 --> 00:08:12,080
the length of the permuted vectors so

207
00:08:12,080 --> 00:08:13,680
that's good

208
00:08:13,680 --> 00:08:15,680
but the problem is this doesn't quite

209
00:08:15,680 --> 00:08:18,000
work because if we have an arbitrary

210
00:08:18,000 --> 00:08:19,120
shuffle from v

211
00:08:19,120 --> 00:08:23,039
to v prime and we choose for example the

212
00:08:23,039 --> 00:08:24,639
seat s1

213
00:08:24,639 --> 00:08:27,199
then with overwhelming probability there

214
00:08:27,199 --> 00:08:28,960
does not actually exist

215
00:08:28,960 --> 00:08:34,320
a seed s2 that completes the shuffle

216
00:08:34,320 --> 00:08:37,919
so this is annoying however at this

217
00:08:37,919 --> 00:08:39,679
point we can observe

218
00:08:39,679 --> 00:08:41,919
something about the applications of

219
00:08:41,919 --> 00:08:43,679
shuffle arguments

220
00:08:43,679 --> 00:08:46,720
you very rarely need to prove

221
00:08:46,720 --> 00:08:49,839
that something arbitrary some arbitrary

222
00:08:49,839 --> 00:08:50,480
shuffle

223
00:08:50,480 --> 00:08:54,399
is correct in most applications of

224
00:08:54,399 --> 00:08:56,399
shuffle arguments what you actually want

225
00:08:56,399 --> 00:08:58,399
is that you shuffle something

226
00:08:58,399 --> 00:09:01,120
at random and then you prove that this

227
00:09:01,120 --> 00:09:02,720
random shuffle

228
00:09:02,720 --> 00:09:06,480
is still a list of the same things

229
00:09:06,720 --> 00:09:09,760
and while we can replace those random

230
00:09:09,760 --> 00:09:12,480
shuffles with pseudo-random shuffles

231
00:09:12,480 --> 00:09:15,040
and then if we allow the prover to

232
00:09:15,040 --> 00:09:15,519
actually

233
00:09:15,519 --> 00:09:19,120
choose the shuffle then we can get

234
00:09:19,120 --> 00:09:21,440
somewhere

235
00:09:21,440 --> 00:09:23,279
so basically we would allow the prover

236
00:09:23,279 --> 00:09:25,440
to choose v prime

237
00:09:25,440 --> 00:09:27,680
the issue is that in the normal

238
00:09:27,680 --> 00:09:30,080
framework of zero knowledge arguments

239
00:09:30,080 --> 00:09:32,320
this is not possible because well there

240
00:09:32,320 --> 00:09:34,720
we do not allow the prover to prove

241
00:09:34,720 --> 00:09:38,880
uh to choose part of the statement

242
00:09:39,440 --> 00:09:42,800
however we can actually define something

243
00:09:42,800 --> 00:09:43,519
like this

244
00:09:43,519 --> 00:09:46,560
and this is exactly what we do we define

245
00:09:46,560 --> 00:09:48,480
a new kind of language which we call

246
00:09:48,480 --> 00:09:51,839
partially fixable language

247
00:09:52,000 --> 00:09:56,560
where the partially fixable language

248
00:09:56,800 --> 00:10:00,800
is a subset of the cartesian product of

249
00:10:00,800 --> 00:10:05,279
two sets x and y and

250
00:10:05,279 --> 00:10:09,200
for any x in the set x

251
00:10:09,200 --> 00:10:13,040
we define some sub language lx

252
00:10:13,040 --> 00:10:16,959
that is actually all of the pairs in l

253
00:10:16,959 --> 00:10:19,519
such that x is the first component of

254
00:10:19,519 --> 00:10:21,440
that

255
00:10:21,440 --> 00:10:23,760
and now we call a language l that has

256
00:10:23,760 --> 00:10:25,440
this structure

257
00:10:25,440 --> 00:10:28,240
partially fixable if we can sample

258
00:10:28,240 --> 00:10:29,600
efficiently

259
00:10:29,600 --> 00:10:33,200
uniformly from every one of those

260
00:10:33,200 --> 00:10:36,320
non-empty lxs why do we call this

261
00:10:36,320 --> 00:10:37,920
partially fixable because this means

262
00:10:37,920 --> 00:10:39,279
that we can basically choose

263
00:10:39,279 --> 00:10:43,040
x and then later

264
00:10:43,040 --> 00:10:47,920
let the prover choose the why

265
00:10:49,920 --> 00:10:53,120
now how do we define

266
00:10:53,120 --> 00:10:55,440
arguments for this kind of language this

267
00:10:55,440 --> 00:10:56,880
is what we call an argument for a

268
00:10:56,880 --> 00:10:59,519
partially fixed statement

269
00:10:59,519 --> 00:11:01,680
and what we do is basically split the

270
00:11:01,680 --> 00:11:02,880
prover in two

271
00:11:02,880 --> 00:11:06,959
in the first stage the prover p0

272
00:11:06,959 --> 00:11:09,200
is only given the first part of the

273
00:11:09,200 --> 00:11:10,320
statement x

274
00:11:10,320 --> 00:11:12,000
which in our case would be the original

275
00:11:12,000 --> 00:11:17,120
vector v and it then chooses

276
00:11:17,200 --> 00:11:18,720
the second part of the statement which

277
00:11:18,720 --> 00:11:21,519
in our case would be v prime

278
00:11:21,519 --> 00:11:24,640
and some auxiliary information you can

279
00:11:24,640 --> 00:11:26,320
think of this auxiliary information as

280
00:11:26,320 --> 00:11:28,160
essentially the witness of the statement

281
00:11:28,160 --> 00:11:28,959
it's just that

282
00:11:28,959 --> 00:11:30,720
it doesn't have to be a generic witness

283
00:11:30,720 --> 00:11:32,480
it can be a very special kind of

284
00:11:32,480 --> 00:11:34,320
weakness

285
00:11:34,320 --> 00:11:36,560
in our case this would basically be the

286
00:11:36,560 --> 00:11:39,359
prg seats

287
00:11:39,519 --> 00:11:42,560
now once that is done we can run a

288
00:11:42,560 --> 00:11:46,399
very normal protocol between approver p1

289
00:11:46,399 --> 00:11:49,120
that gets as input the statement xy and

290
00:11:49,120 --> 00:11:51,040
the absolute information which as i said

291
00:11:51,040 --> 00:11:52,320
you can basically think of as

292
00:11:52,320 --> 00:11:56,639
a witness and the verifier gets as input

293
00:11:56,639 --> 00:11:58,399
only the statement x y

294
00:11:58,399 --> 00:12:01,760
and then outputs 0 1 for accept or

295
00:12:01,760 --> 00:12:04,160
reject

296
00:12:05,360 --> 00:12:06,959
okay for this kind of argument we need

297
00:12:06,959 --> 00:12:10,399
to define completeness and soundness

298
00:12:10,399 --> 00:12:12,639
completeness differs a bit from normal

299
00:12:12,639 --> 00:12:13,600
arguments

300
00:12:13,600 --> 00:12:16,880
we say that for any x such that

301
00:12:16,880 --> 00:12:20,079
lx is non-empty so there exists

302
00:12:20,079 --> 00:12:24,160
pairs with x as the first component it

303
00:12:24,160 --> 00:12:25,279
holds that

304
00:12:25,279 --> 00:12:29,839
if you run the protocol both stages

305
00:12:29,839 --> 00:12:32,320
x y will actually be in the language so

306
00:12:32,320 --> 00:12:34,639
we're saying that

307
00:12:34,639 --> 00:12:36,880
this prover will actually choose correct

308
00:12:36,880 --> 00:12:39,519
statements and the verifier will accept

309
00:12:39,519 --> 00:12:42,000
with probability 1. the difference to a

310
00:12:42,000 --> 00:12:42,800
normal

311
00:12:42,800 --> 00:12:45,440
completeness definition is that we here

312
00:12:45,440 --> 00:12:47,440
now need to require that the statement

313
00:12:47,440 --> 00:12:48,320
that approver

314
00:12:48,320 --> 00:12:50,839
actually produces will actually be

315
00:12:50,839 --> 00:12:53,600
correct

316
00:12:53,600 --> 00:12:56,480
soundness is just well normal soundness

317
00:12:56,480 --> 00:12:57,920
where we say that for any

318
00:12:57,920 --> 00:13:00,480
ppt prover and any statement that is not

319
00:13:00,480 --> 00:13:02,320
in the language

320
00:13:02,320 --> 00:13:04,880
it holds that the probability that the

321
00:13:04,880 --> 00:13:07,360
verifier will accept

322
00:13:07,360 --> 00:13:09,519
is at most negligibly larger than

323
00:13:09,519 --> 00:13:11,360
epsilon where epsilon is

324
00:13:11,360 --> 00:13:14,480
the soundness error which for our

325
00:13:14,480 --> 00:13:18,320
protocol for example was one half

326
00:13:18,560 --> 00:13:22,240
okay um what remains to be defined

327
00:13:22,240 --> 00:13:25,040
is zero knowledge and here again we

328
00:13:25,040 --> 00:13:26,639
diverge a bit from

329
00:13:26,639 --> 00:13:29,600
normal definition of um zero knowledge

330
00:13:29,600 --> 00:13:31,360
because

331
00:13:31,360 --> 00:13:34,399
we have this first stage right where the

332
00:13:34,399 --> 00:13:38,480
prover needs to choose why

333
00:13:38,560 --> 00:13:42,000
so we have the normal definition of we

334
00:13:42,000 --> 00:13:43,760
have two worlds we have the real world

335
00:13:43,760 --> 00:13:44,480
where the

336
00:13:44,480 --> 00:13:47,760
prover on the left hand side

337
00:13:47,760 --> 00:13:50,320
we'll choose y and the auxiliary

338
00:13:50,320 --> 00:13:51,839
information

339
00:13:51,839 --> 00:13:53,680
and then we have an execution between

340
00:13:53,680 --> 00:13:55,440
the honest prover and a malicious

341
00:13:55,440 --> 00:13:57,199
verifier

342
00:13:57,199 --> 00:13:59,199
and at the end of this execution the

343
00:13:59,199 --> 00:14:00,880
malicious verifier will output

344
00:14:00,880 --> 00:14:03,839
some information s on the right hand

345
00:14:03,839 --> 00:14:06,240
side we have the simulated world

346
00:14:06,240 --> 00:14:09,680
here the second part of the statement y

347
00:14:09,680 --> 00:14:10,160
prime

348
00:14:10,160 --> 00:14:12,639
is actually chosen uniformly at random

349
00:14:12,639 --> 00:14:17,600
from lx

350
00:14:17,600 --> 00:14:20,880
and this y prime or

351
00:14:20,880 --> 00:14:23,519
the combination of x and y prime is

352
00:14:23,519 --> 00:14:24,160
given

353
00:14:24,160 --> 00:14:26,959
to the simulator and the simulator now

354
00:14:26,959 --> 00:14:28,880
can interact with the malicious verifier

355
00:14:28,880 --> 00:14:31,839
can also rewind the malicious verifier

356
00:14:31,839 --> 00:14:34,399
and then we'll output some information

357
00:14:34,399 --> 00:14:35,600
as prime

358
00:14:35,600 --> 00:14:37,440
and we say this protocol is zero

359
00:14:37,440 --> 00:14:40,240
knowledge if the two tuples

360
00:14:40,240 --> 00:14:43,760
x y s and x y prime s prime

361
00:14:43,760 --> 00:14:46,160
are computationally indistinguishable

362
00:14:46,160 --> 00:14:47,600
now this differs from normal zero

363
00:14:47,600 --> 00:14:49,440
knowledge in that we also require that

364
00:14:49,440 --> 00:14:50,399
the

365
00:14:50,399 --> 00:14:52,000
statements are computationally

366
00:14:52,000 --> 00:14:53,920
indistinguishable

367
00:14:53,920 --> 00:14:56,320
this is necessary because we need to

368
00:14:56,320 --> 00:14:58,079
here require that what the

369
00:14:58,079 --> 00:15:00,959
prover actually outputs is

370
00:15:00,959 --> 00:15:02,079
indistinguishable

371
00:15:02,079 --> 00:15:05,600
from a uniformly chosen by prime

372
00:15:05,600 --> 00:15:07,440
otherwise it could cause a weird

373
00:15:07,440 --> 00:15:08,720
distribution here

374
00:15:08,720 --> 00:15:11,680
and we don't want that so this means

375
00:15:11,680 --> 00:15:12,000
that

376
00:15:12,000 --> 00:15:15,360
in our case the uniformly random thing

377
00:15:15,360 --> 00:15:17,440
here is a uniformly random shuffle of

378
00:15:17,440 --> 00:15:18,240
our

379
00:15:18,240 --> 00:15:21,279
input vector and this means that the

380
00:15:21,279 --> 00:15:22,800
prover will need to output something

381
00:15:22,800 --> 00:15:24,320
that is indistinguishable

382
00:15:24,320 --> 00:15:28,320
from a uniformly random shuffle

383
00:15:28,480 --> 00:15:32,720
okay so

384
00:15:32,720 --> 00:15:34,240
what does that mean for our protocol

385
00:15:34,240 --> 00:15:36,160
well it just means that basically this

386
00:15:36,160 --> 00:15:38,800
now just works you can think of this

387
00:15:38,800 --> 00:15:40,880
part on top here as the first part of

388
00:15:40,880 --> 00:15:42,320
the prover

389
00:15:42,320 --> 00:15:44,959
where given v which is the x in the

390
00:15:44,959 --> 00:15:46,880
definition

391
00:15:46,880 --> 00:15:50,320
the prover just chooses s1 s2

392
00:15:50,320 --> 00:15:53,120
then can compute v prime which will be

393
00:15:53,120 --> 00:15:54,399
the

394
00:15:54,399 --> 00:15:56,240
v prime which will be the y in the

395
00:15:56,240 --> 00:15:57,519
definition

396
00:15:57,519 --> 00:15:59,680
and s1 and s2 are just the auxiliary

397
00:15:59,680 --> 00:16:02,320
information we output

398
00:16:02,320 --> 00:16:04,639
and now the prover can actually do this

399
00:16:04,639 --> 00:16:06,320
proof because

400
00:16:06,320 --> 00:16:08,240
now there's no problem anymore that we

401
00:16:08,240 --> 00:16:09,680
need to somehow

402
00:16:09,680 --> 00:16:12,800
prove an arbitrary shuffle we can now

403
00:16:12,800 --> 00:16:16,240
choose which shuffle to prove and

404
00:16:16,240 --> 00:16:18,720
well this now works we can only have to

405
00:16:18,720 --> 00:16:19,519
send

406
00:16:19,519 --> 00:16:23,680
this seed sd and this is independent of

407
00:16:23,680 --> 00:16:25,519
the length of the vector so this

408
00:16:25,519 --> 00:16:28,320
whole transcript is independent of the

409
00:16:28,320 --> 00:16:30,560
length of the vector

410
00:16:30,560 --> 00:16:33,279
now it still only has a soundness

411
00:16:33,279 --> 00:16:34,720
one-half

412
00:16:34,720 --> 00:16:37,199
and the problem is we can no longer do

413
00:16:37,199 --> 00:16:39,360
sequential repetition

414
00:16:39,360 --> 00:16:41,279
because if you sequentially repeat this

415
00:16:41,279 --> 00:16:42,399
protocol

416
00:16:42,399 --> 00:16:45,120
what you will end up with is different v

417
00:16:45,120 --> 00:16:46,320
primes

418
00:16:46,320 --> 00:16:48,079
every time you repeat it you get a

419
00:16:48,079 --> 00:16:49,600
different v prime

420
00:16:49,600 --> 00:16:51,519
so you're not re-proving the same

421
00:16:51,519 --> 00:16:53,120
statement over and over again but you're

422
00:16:53,120 --> 00:16:53,600
proving

423
00:16:53,600 --> 00:16:55,839
fresh statements each time which means

424
00:16:55,839 --> 00:16:57,360
the soundness error doesn't actually go

425
00:16:57,360 --> 00:16:59,600
down

426
00:16:59,600 --> 00:17:02,839
we can get a slightly better soundless

427
00:17:02,839 --> 00:17:04,000
arrow

428
00:17:04,000 --> 00:17:07,039
by splitting the shuffle

429
00:17:07,039 --> 00:17:09,760
in more ways basically instead of

430
00:17:09,760 --> 00:17:11,119
splitting it in two

431
00:17:11,119 --> 00:17:14,958
we can split it into t shuffles

432
00:17:15,359 --> 00:17:20,079
and then have the verifier tell us

433
00:17:20,079 --> 00:17:22,559
one of those shuffles and we will give

434
00:17:22,559 --> 00:17:23,359
him all

435
00:17:23,359 --> 00:17:27,359
except for this one now this still works

436
00:17:27,359 --> 00:17:32,080
the um verify can still verify this by

437
00:17:32,080 --> 00:17:34,160
computing forward up to the gap and

438
00:17:34,160 --> 00:17:35,679
backwards up to the gap

439
00:17:35,679 --> 00:17:38,559
and verify that all of those

440
00:17:38,559 --> 00:17:41,360
intermediate vectors are correct

441
00:17:41,360 --> 00:17:44,320
and this now gives us a soundness error

442
00:17:44,320 --> 00:17:48,320
of 1 over t instead of one half

443
00:17:48,320 --> 00:17:51,919
um which is better though well

444
00:17:51,919 --> 00:17:54,880
still not great

445
00:17:55,440 --> 00:17:58,960
now one thing um we can now see here is

446
00:17:58,960 --> 00:18:01,440
that this

447
00:18:01,440 --> 00:18:03,679
transcript is actually now the length of

448
00:18:03,679 --> 00:18:05,360
it is independent still

449
00:18:05,360 --> 00:18:07,679
of the length of the vector however it

450
00:18:07,679 --> 00:18:09,600
depends linearly

451
00:18:09,600 --> 00:18:13,440
on the number of shuffles t here

452
00:18:13,440 --> 00:18:16,559
and we can do a bit better than that

453
00:18:16,559 --> 00:18:20,080
by replacing the prg seats here

454
00:18:20,080 --> 00:18:23,760
with the output of a punctual pref

455
00:18:23,760 --> 00:18:26,799
so a punctual pseudorandom function

456
00:18:26,799 --> 00:18:29,679
allows us to instead of sending a whole

457
00:18:29,679 --> 00:18:32,480
bunch of seeds in this last round

458
00:18:32,480 --> 00:18:35,600
actually just sending a punctured key

459
00:18:35,600 --> 00:18:38,080
punctured at the position that the

460
00:18:38,080 --> 00:18:39,600
verifier chose

461
00:18:39,600 --> 00:18:41,679
which means the verifier will be able to

462
00:18:41,679 --> 00:18:43,280
recompute all of the seeds

463
00:18:43,280 --> 00:18:47,360
except for the one at position d

464
00:18:47,760 --> 00:18:50,080
and this means that now this transcript

465
00:18:50,080 --> 00:18:51,120
only depends

466
00:18:51,120 --> 00:18:54,640
logarithmically on the

467
00:18:54,640 --> 00:18:57,520
number of shuffles t if we for example

468
00:18:57,520 --> 00:18:58,000
intro

469
00:18:58,000 --> 00:19:01,120
um instantiate this prf

470
00:19:01,120 --> 00:19:04,239
with ggm

471
00:19:05,679 --> 00:19:07,679
okay this is actually a pretty nice

472
00:19:07,679 --> 00:19:09,200
protocol it of course

473
00:19:09,200 --> 00:19:12,320
has issues um first of all we've only

474
00:19:12,320 --> 00:19:14,000
proven that this is honest verify zero

475
00:19:14,000 --> 00:19:15,200
knowledge

476
00:19:15,200 --> 00:19:17,120
second it still has a constant sound as

477
00:19:17,120 --> 00:19:18,640
error it's one over t

478
00:19:18,640 --> 00:19:20,240
not one half but it's still a constant

479
00:19:20,240 --> 00:19:21,679
sound of zero

480
00:19:21,679 --> 00:19:25,840
and it is an interactive protocol

481
00:19:26,480 --> 00:19:29,120
we will see that these problems are all

482
00:19:29,120 --> 00:19:31,760
related

483
00:19:32,720 --> 00:19:35,520
but we can solve some of them and

484
00:19:35,520 --> 00:19:36,559
mitigate others

485
00:19:36,559 --> 00:19:39,220
and so not solve some of them

486
00:19:39,220 --> 00:19:40,320
[Music]

487
00:19:40,320 --> 00:19:42,160
mainly we can show that the honest

488
00:19:42,160 --> 00:19:43,520
verifier zero node thing is not a

489
00:19:43,520 --> 00:19:44,000
problem

490
00:19:44,000 --> 00:19:47,039
because our protocol

491
00:19:47,039 --> 00:19:49,919
and many protocols like it are actually

492
00:19:49,919 --> 00:19:52,559
full zero knowledge and we can prove

493
00:19:52,559 --> 00:19:55,600
this in a generic way

494
00:19:55,600 --> 00:19:57,360
the constant soundness error we can

495
00:19:57,360 --> 00:19:59,280
sadly not get rid of

496
00:19:59,280 --> 00:20:01,039
which also means that we cannot make

497
00:20:01,039 --> 00:20:03,679
this thing interactive in any way that

498
00:20:03,679 --> 00:20:06,480
we are aware of because if you would for

499
00:20:06,480 --> 00:20:08,880
example apply fiat shamir

500
00:20:08,880 --> 00:20:11,840
well then you get something that is

501
00:20:11,840 --> 00:20:13,280
non-interactive but because of the

502
00:20:13,280 --> 00:20:14,559
constant soundness error

503
00:20:14,559 --> 00:20:17,679
the prover can basically try and retry

504
00:20:17,679 --> 00:20:21,039
until they get a

505
00:20:21,039 --> 00:20:23,440
an argument that is accepted even for

506
00:20:23,440 --> 00:20:24,880
false statements

507
00:20:24,880 --> 00:20:27,440
so the interactive thing we cannot get

508
00:20:27,440 --> 00:20:28,559
get rid of that

509
00:20:28,559 --> 00:20:30,000
the constant sound is error we also

510
00:20:30,000 --> 00:20:32,320
can't get rid of that but we can

511
00:20:32,320 --> 00:20:36,639
mitigate the problems of it somewhat

512
00:20:37,840 --> 00:20:40,000
but first the honest verifies your null

513
00:20:40,000 --> 00:20:41,919
thing

514
00:20:41,919 --> 00:20:45,280
what um why is this not a problem well

515
00:20:45,280 --> 00:20:46,559
we can prove a

516
00:20:46,559 --> 00:20:50,159
general ethereum that if you have

517
00:20:50,159 --> 00:20:52,000
any three move public coin honest

518
00:20:52,000 --> 00:20:54,320
verified zero knowledge argument

519
00:20:54,320 --> 00:20:56,320
that has a polynomial size challenged

520
00:20:56,320 --> 00:20:57,600
space

521
00:20:57,600 --> 00:21:00,080
then this thing is also zero knowledge

522
00:21:00,080 --> 00:21:03,840
against malicious verifiers

523
00:21:04,480 --> 00:21:07,679
why is that the case well

524
00:21:07,679 --> 00:21:09,600
if it's honest verify zone that means we

525
00:21:09,600 --> 00:21:11,360
have a honest verify

526
00:21:11,360 --> 00:21:15,039
simulator which means this is an

527
00:21:15,039 --> 00:21:17,039
algorithm that given a statement x

528
00:21:17,039 --> 00:21:20,320
y will output transcript

529
00:21:20,320 --> 00:21:22,159
alpha beta gamma that is

530
00:21:22,159 --> 00:21:23,600
indistinguishable

531
00:21:23,600 --> 00:21:25,760
from an honest transcript of an honest

532
00:21:25,760 --> 00:21:27,360
execution between the proven the

533
00:21:27,360 --> 00:21:28,960
verifier

534
00:21:28,960 --> 00:21:31,440
now how do we use this to construct a

535
00:21:31,440 --> 00:21:33,600
simulator against malicious verifiers

536
00:21:33,600 --> 00:21:34,880
well

537
00:21:34,880 --> 00:21:36,960
first of all just send alpha to the

538
00:21:36,960 --> 00:21:38,080
verifier

539
00:21:38,080 --> 00:21:40,880
the verifier will now reply with some

540
00:21:40,880 --> 00:21:44,559
challenge beta this

541
00:21:44,559 --> 00:21:46,880
challenge beta or this challenge beta

542
00:21:46,880 --> 00:21:47,760
prime

543
00:21:47,760 --> 00:21:51,039
may in fact be just the beta from our

544
00:21:51,039 --> 00:21:53,280
um transcript that we have there in fact

545
00:21:53,280 --> 00:21:54,080
because the

546
00:21:54,080 --> 00:21:56,400
channel space is only polynomially large

547
00:21:56,400 --> 00:21:57,840
there is a noticeable probability that

548
00:21:57,840 --> 00:22:00,480
this will happen

549
00:22:03,280 --> 00:22:05,919
now if this happens we can just reply

550
00:22:05,919 --> 00:22:06,559
with gamma

551
00:22:06,559 --> 00:22:10,000
and we are done this simulation works

552
00:22:10,000 --> 00:22:11,840
great

553
00:22:11,840 --> 00:22:14,240
course there is a significant

554
00:22:14,240 --> 00:22:15,200
probability

555
00:22:15,200 --> 00:22:16,880
that beta prime will in fact not be

556
00:22:16,880 --> 00:22:18,400
bitter

557
00:22:18,400 --> 00:22:20,400
and that's this case we cannot actually

558
00:22:20,400 --> 00:22:22,080
answer this challenge

559
00:22:22,080 --> 00:22:24,799
but what we can do is we can rewind and

560
00:22:24,799 --> 00:22:26,320
try again

561
00:22:26,320 --> 00:22:30,480
get a new transcript try again

562
00:22:30,480 --> 00:22:33,679
um doing this naively would cause

563
00:22:33,679 --> 00:22:36,080
all kinds of issues because we might run

564
00:22:36,080 --> 00:22:36,720
into

565
00:22:36,720 --> 00:22:40,240
well infinite loops and basically our

566
00:22:40,240 --> 00:22:42,240
run time might be exceeded if we try

567
00:22:42,240 --> 00:22:43,520
this

568
00:22:43,520 --> 00:22:45,919
so we need a clever uh rewinding

569
00:22:45,919 --> 00:22:47,200
strategy

570
00:22:47,200 --> 00:22:49,440
and a rewinding strategy very similar to

571
00:22:49,440 --> 00:22:50,640
the one of uh gold

572
00:22:50,640 --> 00:22:53,440
and kahan in fact works here we

573
00:22:53,440 --> 00:22:54,080
basically

574
00:22:54,080 --> 00:22:56,720
need to estimate the failure probability

575
00:22:56,720 --> 00:22:58,240
of the

576
00:22:58,240 --> 00:23:01,280
verifier and then we know how often we

577
00:23:01,280 --> 00:23:03,039
can rewind

578
00:23:03,039 --> 00:23:07,039
or we often we need to rewind and

579
00:23:07,039 --> 00:23:09,760
well basically this works we just need

580
00:23:09,760 --> 00:23:12,159
to be clever about the rewinding

581
00:23:12,159 --> 00:23:14,960
and this means that any such protocol in

582
00:23:14,960 --> 00:23:16,480
particular our protocol

583
00:23:16,480 --> 00:23:18,000
that we've proven honest verifies your

584
00:23:18,000 --> 00:23:19,760
knowledge is in fact also

585
00:23:19,760 --> 00:23:23,600
fully zero knowledge okay

586
00:23:23,600 --> 00:23:25,679
the second issue the constant sound is

587
00:23:25,679 --> 00:23:26,720
error

588
00:23:26,720 --> 00:23:29,120
we cannot get rid of the constant sounds

589
00:23:29,120 --> 00:23:31,840
as much as we want to

590
00:23:31,840 --> 00:23:33,840
but we can mitigate the problem that it

591
00:23:33,840 --> 00:23:36,320
causes somewhat

592
00:23:36,320 --> 00:23:39,600
imagine that we have some

593
00:23:39,600 --> 00:23:42,080
execution between a malicious approver

594
00:23:42,080 --> 00:23:43,840
and the verifier

595
00:23:43,840 --> 00:23:47,919
now if the malicious approver cheats

596
00:23:47,919 --> 00:23:51,120
the verifier may notice that

597
00:23:51,120 --> 00:23:53,200
and what we want is that the malicious

598
00:23:53,200 --> 00:23:55,279
uh that the honest verifier

599
00:23:55,279 --> 00:23:57,760
can then produce a certificate and give

600
00:23:57,760 --> 00:23:59,679
this to a judge

601
00:23:59,679 --> 00:24:02,880
who will rule and say yep indeed

602
00:24:02,880 --> 00:24:06,720
the prover cheated they're guilty

603
00:24:07,200 --> 00:24:09,360
and you can use that to then basically

604
00:24:09,360 --> 00:24:10,880
enforce some kind of financial

605
00:24:10,880 --> 00:24:11,600
punishment

606
00:24:11,600 --> 00:24:15,360
against the prover now of course you

607
00:24:15,360 --> 00:24:17,279
also don't want the verifier to be able

608
00:24:17,279 --> 00:24:18,080
to

609
00:24:18,080 --> 00:24:20,880
do this against honest brewers so

610
00:24:20,880 --> 00:24:21,279
there's

611
00:24:21,279 --> 00:24:23,820
something called deformation freeness

612
00:24:23,820 --> 00:24:25,600
[Music]

613
00:24:25,600 --> 00:24:28,159
where we say that if the prover is in

614
00:24:28,159 --> 00:24:29,120
fact honest

615
00:24:29,120 --> 00:24:30,960
even a malicious verifier should not be

616
00:24:30,960 --> 00:24:33,120
able to produce a certificate

617
00:24:33,120 --> 00:24:35,039
such that the judge would rule against

618
00:24:35,039 --> 00:24:36,640
the prover instead they would rule

619
00:24:36,640 --> 00:24:39,919
against the verifier in this case

620
00:24:39,919 --> 00:24:42,480
so formally we define this as publicly

621
00:24:42,480 --> 00:24:43,919
accountable zero-knowledge arguments

622
00:24:43,919 --> 00:24:45,360
which have two properties they are

623
00:24:45,360 --> 00:24:46,159
accountable

624
00:24:46,159 --> 00:24:48,320
and they are deformation free

625
00:24:48,320 --> 00:24:50,240
accountability means that if you have a

626
00:24:50,240 --> 00:24:52,080
malicious prover

627
00:24:52,080 --> 00:24:54,320
that convinces a verifier of a false

628
00:24:54,320 --> 00:24:56,960
statement with probability delta epsilon

629
00:24:56,960 --> 00:25:00,240
where epsilon is the sum of zero

630
00:25:00,240 --> 00:25:03,200
then the verifier will be able to

631
00:25:03,200 --> 00:25:04,320
convince the judge

632
00:25:04,320 --> 00:25:06,880
that the verifier that the prover

633
00:25:06,880 --> 00:25:08,640
cheated

634
00:25:08,640 --> 00:25:11,440
with probability delta times one minus

635
00:25:11,440 --> 00:25:13,760
epsilon

636
00:25:13,760 --> 00:25:15,840
and it's defamation free in the sense

637
00:25:15,840 --> 00:25:18,240
that if you have an honest prover even a

638
00:25:18,240 --> 00:25:19,919
malicious verifier

639
00:25:19,919 --> 00:25:21,440
should only be able to convince the

640
00:25:21,440 --> 00:25:23,039
judge that the prover cheated

641
00:25:23,039 --> 00:25:26,720
with negligible probability now

642
00:25:26,720 --> 00:25:30,000
how can we change our protocol

643
00:25:30,000 --> 00:25:33,760
to be publicly accountable

644
00:25:34,720 --> 00:25:37,840
well the first thing is that the with

645
00:25:37,840 --> 00:25:38,720
probability

646
00:25:38,720 --> 00:25:42,000
t minus one over t the very shot will

647
00:25:42,000 --> 00:25:46,080
actually notice that the prover cheated

648
00:25:46,080 --> 00:25:48,240
because well they can see that the

649
00:25:48,240 --> 00:25:49,279
shuffles don't

650
00:25:49,279 --> 00:25:51,520
match

651
00:25:52,960 --> 00:25:54,799
however they can't do anything with that

652
00:25:54,799 --> 00:25:56,320
information because

653
00:25:56,320 --> 00:25:58,320
well they could have the judge could say

654
00:25:58,320 --> 00:26:00,159
okay but you could have produced this

655
00:26:00,159 --> 00:26:03,360
transcript yourself right so what we

656
00:26:03,360 --> 00:26:04,000
introduce

657
00:26:04,000 --> 00:26:07,200
is that the prover

658
00:26:07,200 --> 00:26:10,320
will sign the transcript they now have a

659
00:26:10,320 --> 00:26:12,559
public key associated with themselves

660
00:26:12,559 --> 00:26:14,720
and they at the end of the protocol they

661
00:26:14,720 --> 00:26:16,240
sign the whole transcript and the

662
00:26:16,240 --> 00:26:18,240
verifier also verifies their signature

663
00:26:18,240 --> 00:26:19,919
and only accepts if the signature is

664
00:26:19,919 --> 00:26:21,760
valid

665
00:26:21,760 --> 00:26:24,480
so if the prover now goes through until

666
00:26:24,480 --> 00:26:25,120
the end

667
00:26:25,120 --> 00:26:27,600
and cheated then well the verifier can

668
00:26:27,600 --> 00:26:28,960
go to the judge and show

669
00:26:28,960 --> 00:26:30,640
hey here's a cheating transcript the

670
00:26:30,640 --> 00:26:32,880
prover signed it

671
00:26:32,880 --> 00:26:36,080
so he's guilty however

672
00:26:36,080 --> 00:26:38,080
the prover of course knows whether the

673
00:26:38,080 --> 00:26:39,279
verifier will accept

674
00:26:39,279 --> 00:26:43,279
once they see the challenge d

675
00:26:43,360 --> 00:26:46,960
so this doesn't quite work yet

676
00:26:46,960 --> 00:26:50,400
we need a way to hide the challenge d

677
00:26:50,400 --> 00:26:53,840
from the proverb and we can do this

678
00:26:53,840 --> 00:26:55,279
using something that we call an

679
00:26:55,279 --> 00:26:57,520
oblivious puncturing protocol

680
00:26:57,520 --> 00:26:59,520
an oblivious puncturing protocol is a

681
00:26:59,520 --> 00:27:01,760
protocol between a sender and a receiver

682
00:27:01,760 --> 00:27:04,640
where the sender has a punctual prf key

683
00:27:04,640 --> 00:27:07,679
the receiver has an index d

684
00:27:07,679 --> 00:27:10,240
and the receiver will at the end receive

685
00:27:10,240 --> 00:27:12,159
the punctured key

686
00:27:12,159 --> 00:27:16,320
the key punctured at position d

687
00:27:16,480 --> 00:27:20,080
now you need some security properties

688
00:27:20,080 --> 00:27:20,880
here

689
00:27:20,880 --> 00:27:23,919
you need that the sender

690
00:27:23,919 --> 00:27:26,320
does not learn anything about the index

691
00:27:26,320 --> 00:27:27,200
d

692
00:27:27,200 --> 00:27:29,679
and you need that the interaction with

693
00:27:29,679 --> 00:27:30,880
the sender

694
00:27:30,880 --> 00:27:34,000
from the point of view of the receiver

695
00:27:34,000 --> 00:27:37,760
is simulatable in some sense

696
00:27:37,760 --> 00:27:42,080
this protocol is basically very similar

697
00:27:42,080 --> 00:27:45,279
to a symmetrically secure

698
00:27:45,279 --> 00:27:49,840
private information retrieval protocol

699
00:27:49,840 --> 00:27:53,200
where the database of the peer would

700
00:27:53,200 --> 00:27:54,720
basically be all of the possible

701
00:27:54,720 --> 00:27:56,640
punctured keys

702
00:27:56,640 --> 00:28:00,000
and if you have such a protocol which is

703
00:28:00,000 --> 00:28:02,320
very efficiently instantiable using just

704
00:28:02,320 --> 00:28:03,120
uh

705
00:28:03,120 --> 00:28:06,240
lock t oblivious transfers for for

706
00:28:06,240 --> 00:28:07,440
example the ggm

707
00:28:07,440 --> 00:28:12,240
punctual prf then you can

708
00:28:12,240 --> 00:28:16,159
run the protocol like this the um first

709
00:28:16,159 --> 00:28:17,200
round is the same

710
00:28:17,200 --> 00:28:19,360
then you run the oblivious puncturing

711
00:28:19,360 --> 00:28:20,960
protocol

712
00:28:20,960 --> 00:28:22,320
and at the end of the oblivious

713
00:28:22,320 --> 00:28:24,559
puncturing protocol the verifier has

714
00:28:24,559 --> 00:28:26,080
received the punctured key

715
00:28:26,080 --> 00:28:27,600
whereas the approver does not know

716
00:28:27,600 --> 00:28:29,360
anything about which punctured key they

717
00:28:29,360 --> 00:28:30,720
received so

718
00:28:30,720 --> 00:28:32,240
they don't know if the verifier will

719
00:28:32,240 --> 00:28:33,919
accept or reject but

720
00:28:33,919 --> 00:28:37,039
for them to accept at all they basically

721
00:28:37,039 --> 00:28:39,520
need to sign the whole transcript

722
00:28:39,520 --> 00:28:42,399
so they do that but now if they cheat it

723
00:28:42,399 --> 00:28:43,679
and the verifier

724
00:28:43,679 --> 00:28:46,399
catches them with probability t minus

725
00:28:46,399 --> 00:28:48,640
one over t

726
00:28:48,640 --> 00:28:50,480
the verifier can go to the judge show

727
00:28:50,480 --> 00:28:51,760
the cheating transcript

728
00:28:51,760 --> 00:28:53,840
and the signature on it and the judge

729
00:28:53,840 --> 00:28:55,760
can say yes indeed this is a cheating

730
00:28:55,760 --> 00:28:57,679
transcript and it's signed by the prover

731
00:28:57,679 --> 00:29:00,559
so the prover is guilty

732
00:29:00,559 --> 00:29:02,290
and this now means that um

733
00:29:02,290 --> 00:29:03,679
[Music]

734
00:29:03,679 --> 00:29:05,760
while we still have a constant soundness

735
00:29:05,760 --> 00:29:07,440
error we also have

736
00:29:07,440 --> 00:29:10,480
a way of punishing cheating provers with

737
00:29:10,480 --> 00:29:13,840
high probability

738
00:29:14,480 --> 00:29:16,799
so to conclude i want to compare our

739
00:29:16,799 --> 00:29:18,480
work with

740
00:29:18,480 --> 00:29:22,960
several related work from the literature

741
00:29:22,960 --> 00:29:24,080
basically different

742
00:29:24,080 --> 00:29:26,720
shuffle arguments and we compare with

743
00:29:26,720 --> 00:29:28,240
three shuffle arguments

744
00:29:28,240 --> 00:29:31,600
the work of bayer gold from 2012

745
00:29:31,600 --> 00:29:36,000
bulletproofs from 2018 and the growth 16

746
00:29:36,000 --> 00:29:38,240
snark

747
00:29:38,240 --> 00:29:41,840
and well we can see that our

748
00:29:41,840 --> 00:29:43,600
arguments if we do not need

749
00:29:43,600 --> 00:29:45,760
accountability

750
00:29:45,760 --> 00:29:48,640
and are fine with relatively large uh

751
00:29:48,640 --> 00:29:50,480
constant soundness errors

752
00:29:50,480 --> 00:29:51,919
you can get something that has

753
00:29:51,919 --> 00:29:53,760
communication cost very similar

754
00:29:53,760 --> 00:29:56,000
to snarks or even lower than snarks

755
00:29:56,000 --> 00:29:56,799
depending on

756
00:29:56,799 --> 00:29:58,480
how large you choose your sounder's

757
00:29:58,480 --> 00:30:00,720
error

758
00:30:03,200 --> 00:30:06,399
it's still interactive

759
00:30:06,399 --> 00:30:09,120
so it's in that case sense worse than

760
00:30:09,120 --> 00:30:11,200
snarks however we do not need a trusted

761
00:30:11,200 --> 00:30:13,039
setup compared to snarks

762
00:30:13,039 --> 00:30:15,039
and our assumptions are much weaker we

763
00:30:15,039 --> 00:30:16,480
only need a collision resistant hash

764
00:30:16,480 --> 00:30:17,200
function

765
00:30:17,200 --> 00:30:20,640
and a pseudo-random generator

766
00:30:21,760 --> 00:30:24,480
if we need accountability then well we

767
00:30:24,480 --> 00:30:27,200
need a crs but not a structured crs

768
00:30:27,200 --> 00:30:29,039
and we additionally need something to

769
00:30:29,039 --> 00:30:31,039
build an oblivious transfer from

770
00:30:31,039 --> 00:30:34,240
which is in this case for example

771
00:30:34,240 --> 00:30:36,640
a decisional diffie-hellman which allows

772
00:30:36,640 --> 00:30:39,039
us to efficiently instantiate this

773
00:30:39,039 --> 00:30:42,399
and there we get something which is now

774
00:30:42,399 --> 00:30:44,399
larger than a snark

775
00:30:44,399 --> 00:30:46,399
but still significantly smaller than

776
00:30:46,399 --> 00:30:47,600
bulletproofs

777
00:30:47,600 --> 00:30:50,559
which if we are shuffling a hundred

778
00:30:50,559 --> 00:30:52,559
thousand commitments basically

779
00:30:52,559 --> 00:30:56,000
is about twice as large

780
00:30:57,679 --> 00:31:00,399
um well it should be noted that out both

781
00:31:00,399 --> 00:31:01,440
our work and the

782
00:31:01,440 --> 00:31:04,320
um and the snarks they do not depend on

783
00:31:04,320 --> 00:31:05,679
the length of the

784
00:31:05,679 --> 00:31:07,120
on the number of commitments whereas

785
00:31:07,120 --> 00:31:08,960
bulletproofs and by a grower do

786
00:31:08,960 --> 00:31:11,519
bulletproofs logarithmically by a growth

787
00:31:11,519 --> 00:31:14,399
with a square root

788
00:31:14,399 --> 00:31:16,159
so this means that our work is

789
00:31:16,159 --> 00:31:18,159
significantly smaller than both biogoat

790
00:31:18,159 --> 00:31:20,159
and bulletproofs it is

791
00:31:20,159 --> 00:31:22,880
in some settings comparable to snarks

792
00:31:22,880 --> 00:31:23,760
and

793
00:31:23,760 --> 00:31:27,200
which means that at the cost of

794
00:31:27,200 --> 00:31:29,360
interaction and a constant soundness

795
00:31:29,360 --> 00:31:30,320
error

796
00:31:30,320 --> 00:31:32,320
we can get very small communication

797
00:31:32,320 --> 00:31:34,640
costs for shuffle arguments

798
00:31:34,640 --> 00:31:38,240
from very simple assumptions

799
00:31:38,240 --> 00:31:41,679
thank you

