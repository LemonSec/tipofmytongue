1
00:00:00,080 --> 00:00:01,839
my name is alex davidson and i'm going

2
00:00:01,839 --> 00:00:03,360
to be talking about post-quantum

3
00:00:03,360 --> 00:00:05,200
constructions of verifiable oblivious

4
00:00:05,200 --> 00:00:06,640
pseudorandom functions

5
00:00:06,640 --> 00:00:08,480
this is joint work with martin albrecht

6
00:00:08,480 --> 00:00:10,400
amid dio and nigel smart

7
00:00:10,400 --> 00:00:13,120
firstly our protocol is the first to be

8
00:00:13,120 --> 00:00:14,960
constructed from lattice-based hardness

9
00:00:14,960 --> 00:00:16,640
assumptions specifically the ring

10
00:00:16,640 --> 00:00:18,560
learning with errors and short intuitive

11
00:00:18,560 --> 00:00:20,000
solution

12
00:00:20,000 --> 00:00:23,039
problems um our construction holds in

13
00:00:23,039 --> 00:00:24,640
the quantum random oracle model

14
00:00:24,640 --> 00:00:26,720
but what i should say as a disclaimer

15
00:00:26,720 --> 00:00:28,320
and a caveat before i progress any

16
00:00:28,320 --> 00:00:30,000
further is that this result is purely

17
00:00:30,000 --> 00:00:32,719
a feasibility result for now we'll see

18
00:00:32,719 --> 00:00:33,840
later that there are many

19
00:00:33,840 --> 00:00:36,399
um applications of verifiable oblivious

20
00:00:36,399 --> 00:00:38,960
pseudo-random functions or vo prfs

21
00:00:38,960 --> 00:00:40,160
that require very efficient

22
00:00:40,160 --> 00:00:42,480
constructions and more work is needed in

23
00:00:42,480 --> 00:00:44,399
order to realize a construction of that

24
00:00:44,399 --> 00:00:45,360
nature

25
00:00:45,360 --> 00:00:47,280
so firstly i'm just going to introduce

26
00:00:47,280 --> 00:00:49,280
um how the aprs are constructives and

27
00:00:49,280 --> 00:00:50,640
some of the applications

28
00:00:50,640 --> 00:00:52,079
that we have in the real world for these

29
00:00:52,079 --> 00:00:53,840
protocols so

30
00:00:53,840 --> 00:00:55,440
a very prf can be thought of as a

31
00:00:55,440 --> 00:00:57,199
two-party protocol between a client and

32
00:00:57,199 --> 00:00:59,199
a server where a client holds

33
00:00:59,199 --> 00:01:01,199
an input x for a pseudo-random function

34
00:01:01,199 --> 00:01:02,239
and the server holds a

35
00:01:02,239 --> 00:01:05,040
input key k for that function and what

36
00:01:05,040 --> 00:01:06,799
the client wants to do is to communicate

37
00:01:06,799 --> 00:01:08,400
with the server in some way and then

38
00:01:08,400 --> 00:01:08,880
learn

39
00:01:08,880 --> 00:01:11,360
an output of this universal function on

40
00:01:11,360 --> 00:01:12,080
its input

41
00:01:12,080 --> 00:01:14,320
and the service key the security

42
00:01:14,320 --> 00:01:15,840
properties of the protocol state that

43
00:01:15,840 --> 00:01:17,280
the server should learn nothing about

44
00:01:17,280 --> 00:01:18,560
the client's input x

45
00:01:18,560 --> 00:01:20,080
and that the client should learn nothing

46
00:01:20,080 --> 00:01:22,159
about the server's input key k

47
00:01:22,159 --> 00:01:24,000
in order to realize verifiability the

48
00:01:24,000 --> 00:01:25,439
server must also prove

49
00:01:25,439 --> 00:01:27,680
that the output was evaluated using its

50
00:01:27,680 --> 00:01:29,040
key k

51
00:01:29,040 --> 00:01:31,280
so how do these things work generically

52
00:01:31,280 --> 00:01:33,040
so in order to

53
00:01:33,040 --> 00:01:35,119
get started the server first sends in an

54
00:01:35,119 --> 00:01:36,960
offline phase a commitment c

55
00:01:36,960 --> 00:01:39,439
to its key k which the client then

56
00:01:39,439 --> 00:01:40,799
registers

57
00:01:40,799 --> 00:01:42,720
so in the online phase when the client

58
00:01:42,720 --> 00:01:44,799
then has the commitment c which the

59
00:01:44,799 --> 00:01:46,479
server has sent and its own input x

60
00:01:46,479 --> 00:01:47,680
which it wants to query

61
00:01:47,680 --> 00:01:50,320
it first encodes its input x to some vo

62
00:01:50,320 --> 00:01:52,560
pof friendly input distribution so this

63
00:01:52,560 --> 00:01:53,759
gives this big x

64
00:01:53,759 --> 00:01:55,600
and then runs this generic blinding

65
00:01:55,600 --> 00:01:57,680
algorithm to receive y and this what

66
00:01:57,680 --> 00:01:58,640
this does is it

67
00:01:58,640 --> 00:02:01,680
hides x and then using this y the client

68
00:02:01,680 --> 00:02:04,719
sends this in a message to the server

69
00:02:04,719 --> 00:02:07,759
the server evaluates whatever it needs

70
00:02:07,759 --> 00:02:09,919
to do in order to evaluate the voprf on

71
00:02:09,919 --> 00:02:11,280
this blinded input y

72
00:02:11,280 --> 00:02:14,319
and then it produces this output z and

73
00:02:14,319 --> 00:02:16,000
in order to realize verifiability it

74
00:02:16,000 --> 00:02:17,680
also produces this proof pi

75
00:02:17,680 --> 00:02:20,720
which essentially shows that zed and

76
00:02:20,720 --> 00:02:24,080
the commitment c share um a common key

77
00:02:24,080 --> 00:02:26,640
k which is the server input when the

78
00:02:26,640 --> 00:02:28,239
client receives this message back from

79
00:02:28,239 --> 00:02:30,480
the server it first verifies the proof

80
00:02:30,480 --> 00:02:32,640
and then unblinds z by running this

81
00:02:32,640 --> 00:02:34,560
generic uh blinding algorithm and just

82
00:02:34,560 --> 00:02:36,319
simply outputs whatever that algorithm

83
00:02:36,319 --> 00:02:37,280
outputs

84
00:02:37,280 --> 00:02:40,000
so generically speaking we have two um

85
00:02:40,000 --> 00:02:42,000
guarantees that we require the voprf to

86
00:02:42,000 --> 00:02:42,400
hold

87
00:02:42,400 --> 00:02:44,720
so firstly the unblind operation on this

88
00:02:44,720 --> 00:02:45,440
z

89
00:02:45,440 --> 00:02:47,440
should give an output which is equal to

90
00:02:47,440 --> 00:02:50,000
the prf evaluation on the server's key

91
00:02:50,000 --> 00:02:52,160
k and the encoded x which the client

92
00:02:52,160 --> 00:02:53,440
provides

93
00:02:53,440 --> 00:02:55,040
and then we also obviously require a

94
00:02:55,040 --> 00:02:56,480
security guarantee

95
00:02:56,480 --> 00:02:58,080
which is that for any malicious client

96
00:02:58,080 --> 00:02:59,920
or server there's a polynomial time

97
00:02:59,920 --> 00:03:02,000
simulator that can simulate the real

98
00:03:02,000 --> 00:03:04,560
world to these adversaries just given

99
00:03:04,560 --> 00:03:07,680
access to an ideal vo pof functionality

100
00:03:07,680 --> 00:03:09,200
so what applications do we actually have

101
00:03:09,200 --> 00:03:12,000
for vopfs in the real world so

102
00:03:12,000 --> 00:03:13,599
the internet engineering task force is

103
00:03:13,599 --> 00:03:14,560
currently in the process of

104
00:03:14,560 --> 00:03:16,480
standardizing a number of different

105
00:03:16,480 --> 00:03:18,400
functionalities in the internet setting

106
00:03:18,400 --> 00:03:19,519
that use these

107
00:03:19,519 --> 00:03:21,440
protocols as building blocks so the

108
00:03:21,440 --> 00:03:22,720
first of these applications is the

109
00:03:22,720 --> 00:03:24,080
privacy class protocol which is a

110
00:03:24,080 --> 00:03:25,920
private authorization protocol

111
00:03:25,920 --> 00:03:27,280
in which the client receives

112
00:03:27,280 --> 00:03:28,799
authorization from the server for some

113
00:03:28,799 --> 00:03:29,440
event

114
00:03:29,440 --> 00:03:31,360
in order to do so it first sends some

115
00:03:31,360 --> 00:03:33,040
blinded token to the server

116
00:03:33,040 --> 00:03:35,040
and when the server wants to authorize

117
00:03:35,040 --> 00:03:37,200
the client it signs that token

118
00:03:37,200 --> 00:03:39,280
and returns it to the client what the

119
00:03:39,280 --> 00:03:41,519
client then does is output an unblinded

120
00:03:41,519 --> 00:03:42,799
version of this token

121
00:03:42,799 --> 00:03:44,879
that this exchange is actually a vo pof

122
00:03:44,879 --> 00:03:46,640
exchange so they climb the server

123
00:03:46,640 --> 00:03:48,799
and compute this vopof protocol and the

124
00:03:48,799 --> 00:03:51,920
client outputs the output of the vap rf

125
00:03:51,920 --> 00:03:53,200
and then in the future when the client

126
00:03:53,200 --> 00:03:55,040
wants to be authorized it sends this

127
00:03:55,040 --> 00:03:56,239
unblinded token

128
00:03:56,239 --> 00:03:58,000
and the server because it has never

129
00:03:58,000 --> 00:03:59,680
witnessed this unblinded token cannot

130
00:03:59,680 --> 00:04:00,000
link

131
00:04:00,000 --> 00:04:01,760
it back to a previous authorization

132
00:04:01,760 --> 00:04:04,000
event and it can but it can still verify

133
00:04:04,000 --> 00:04:05,760
that the client is authorized

134
00:04:05,760 --> 00:04:07,280
so the privacy plus protocol is used

135
00:04:07,280 --> 00:04:08,720
widely across the internet by many

136
00:04:08,720 --> 00:04:10,959
different companies and organizations

137
00:04:10,959 --> 00:04:12,799
secondly another application which is

138
00:04:12,799 --> 00:04:14,480
also undergoing standardization is the

139
00:04:14,480 --> 00:04:16,079
opaque passable authenticated key

140
00:04:16,079 --> 00:04:17,600
exchange protocol which essentially

141
00:04:17,600 --> 00:04:18,720
combines

142
00:04:18,720 --> 00:04:20,798
um an oblivious pseudorandom function

143
00:04:20,798 --> 00:04:22,400
protocol with an authenticated key

144
00:04:22,400 --> 00:04:24,960
exchange to build a secure pake

145
00:04:24,960 --> 00:04:28,080
and these pakes are seeing widespread

146
00:04:28,080 --> 00:04:30,240
adoption in the internet setting for

147
00:04:30,240 --> 00:04:31,600
allowing mutual client server

148
00:04:31,600 --> 00:04:33,199
authentication using usernames and

149
00:04:33,199 --> 00:04:33,919
passwords

150
00:04:33,919 --> 00:04:35,440
that are secure against standard

151
00:04:35,440 --> 00:04:37,120
precomputation attacks

152
00:04:37,120 --> 00:04:39,199
so before we get into our construction

153
00:04:39,199 --> 00:04:40,160
i'd just like to highlight

154
00:04:40,160 --> 00:04:41,680
exactly how we build these things in the

155
00:04:41,680 --> 00:04:42,960
classical setting because that's how

156
00:04:42,960 --> 00:04:43,840
they are used

157
00:04:43,840 --> 00:04:46,080
uh currently so both private space and

158
00:04:46,080 --> 00:04:47,040
opaque use this

159
00:04:47,040 --> 00:04:49,840
um verifiable oblivious pseudorandom

160
00:04:49,840 --> 00:04:50,639
function of

161
00:04:50,639 --> 00:04:54,080
yaraki kiyas and krafchik and

162
00:04:54,080 --> 00:04:56,639
so the first phase of this viopof sees

163
00:04:56,639 --> 00:04:58,160
the server commit to its

164
00:04:58,160 --> 00:05:00,320
uh key k by raising some common group

165
00:05:00,320 --> 00:05:02,000
element uh that's agreed by the client

166
00:05:02,000 --> 00:05:03,600
server to its key k

167
00:05:03,600 --> 00:05:06,720
and sending uh this value c uh

168
00:05:06,720 --> 00:05:09,120
to the client so once the client has the

169
00:05:09,120 --> 00:05:10,080
service commitment c

170
00:05:10,080 --> 00:05:12,400
and its own input x it first hashes its

171
00:05:12,400 --> 00:05:14,080
x to the group

172
00:05:14,080 --> 00:05:16,560
using this random deterministic mapping

173
00:05:16,560 --> 00:05:17,840
um

174
00:05:17,840 --> 00:05:20,400
this mapping outputs a group element x

175
00:05:20,400 --> 00:05:21,520
which the

176
00:05:21,520 --> 00:05:23,919
client can then multiply with this

177
00:05:23,919 --> 00:05:25,520
blinding factor and this blinding factor

178
00:05:25,520 --> 00:05:26,880
is constructed using the original

179
00:05:26,880 --> 00:05:27,919
generator g

180
00:05:27,919 --> 00:05:31,280
and this randomly sampled r to create y

181
00:05:31,280 --> 00:05:33,120
it then sends y to the server as in the

182
00:05:33,120 --> 00:05:34,320
generic case

183
00:05:34,320 --> 00:05:36,160
and the server in order to compute the

184
00:05:36,160 --> 00:05:38,639
prf simply raises this y to the power of

185
00:05:38,639 --> 00:05:39,120
its key

186
00:05:39,120 --> 00:05:42,400
k and then proves in zero knowledge uh

187
00:05:42,400 --> 00:05:44,720
that zed the output shares the same

188
00:05:44,720 --> 00:05:46,800
discrete log as the original commitment

189
00:05:46,800 --> 00:05:48,160
from the offline phase

190
00:05:48,160 --> 00:05:49,759
and there are proofs for doing this in

191
00:05:49,759 --> 00:05:51,840
the schnoor setting once the server

192
00:05:51,840 --> 00:05:52,639
constructs those

193
00:05:52,639 --> 00:05:54,240
uh two elements it sends them back to

194
00:05:54,240 --> 00:05:56,160
the client and the client can verify the

195
00:05:56,160 --> 00:05:56,960
proof

196
00:05:56,960 --> 00:05:59,520
and then unblinds the output by simply

197
00:05:59,520 --> 00:06:00,880
multiplying zed

198
00:06:00,880 --> 00:06:03,280
by the commitment c that the server sent

199
00:06:03,280 --> 00:06:04,960
raised to the power of the inverted r

200
00:06:04,960 --> 00:06:06,479
that is sampled in the previous

201
00:06:06,479 --> 00:06:09,360
phase and this output as shown in the

202
00:06:09,360 --> 00:06:10,560
argument there

203
00:06:10,560 --> 00:06:12,800
gives a correct pseudo-random function

204
00:06:12,800 --> 00:06:14,400
output where the pseudo-random function

205
00:06:14,400 --> 00:06:15,600
is simply x

206
00:06:15,600 --> 00:06:16,960
raised to the power of the server's key

207
00:06:16,960 --> 00:06:19,360
k so the security of the protocol rests

208
00:06:19,360 --> 00:06:20,080
upon the fact

209
00:06:20,080 --> 00:06:21,840
that the server's key k is in the

210
00:06:21,840 --> 00:06:23,360
discrete log

211
00:06:23,360 --> 00:06:25,280
of this client chosen value and

212
00:06:25,280 --> 00:06:26,560
therefore the client can't learn what

213
00:06:26,560 --> 00:06:27,840
that value is by the hardness of

214
00:06:27,840 --> 00:06:28,720
discrete log

215
00:06:28,720 --> 00:06:31,120
or discrete log type assumptions but

216
00:06:31,120 --> 00:06:32,400
clearly

217
00:06:32,400 --> 00:06:34,319
this protocol is not secure against post

218
00:06:34,319 --> 00:06:35,759
quantum adversaries given the fact that

219
00:06:35,759 --> 00:06:38,240
we use these classical based assumptions

220
00:06:38,240 --> 00:06:40,319
and so in now in this work i'm going to

221
00:06:40,319 --> 00:06:41,600
highlight some of the problem

222
00:06:41,600 --> 00:06:43,759
exact problems in these protocols and

223
00:06:43,759 --> 00:06:45,520
how we might then go about solving them

224
00:06:45,520 --> 00:06:47,199
in the post-quantum setting

225
00:06:47,199 --> 00:06:48,800
so firstly i should just note that no

226
00:06:48,800 --> 00:06:50,720
previous construction has been based on

227
00:06:50,720 --> 00:06:52,720
lattice-based primitives for realizing a

228
00:06:52,720 --> 00:06:55,120
secure vo pof protocol

229
00:06:55,120 --> 00:06:58,240
however um concurrently bernair tell

230
00:06:58,240 --> 00:07:01,039
asia crypt 2020 presented a post-quantum

231
00:07:01,039 --> 00:07:02,000
perf using

232
00:07:02,000 --> 00:07:04,560
uh isogenes over super singular elliptic

233
00:07:04,560 --> 00:07:05,120
curves

234
00:07:05,120 --> 00:07:06,720
constructed using hardness problems

235
00:07:06,720 --> 00:07:08,880
which are thought to be hard in the post

236
00:07:08,880 --> 00:07:10,000
quantum setting

237
00:07:10,000 --> 00:07:11,039
but in this work we're going to be

238
00:07:11,039 --> 00:07:13,120
focusing on the lattice based

239
00:07:13,120 --> 00:07:15,759
foundations for this protocol and first

240
00:07:15,759 --> 00:07:17,280
i'd just like to note the similarities

241
00:07:17,280 --> 00:07:18,080
between

242
00:07:18,080 --> 00:07:20,080
sort of discrete log type assumptions

243
00:07:20,080 --> 00:07:21,919
and those in the learning with errors

244
00:07:21,919 --> 00:07:25,520
um sphere of foundational assumptions

245
00:07:25,520 --> 00:07:27,440
specific specifically in the ring

246
00:07:27,440 --> 00:07:28,880
settings so firstly

247
00:07:28,880 --> 00:07:31,759
for the discrete log hardness problem we

248
00:07:31,759 --> 00:07:33,759
have this common generator g and then

249
00:07:33,759 --> 00:07:36,479
race raised to the power k um it's hard

250
00:07:36,479 --> 00:07:38,720
for the adversary to learn k

251
00:07:38,720 --> 00:07:41,599
likewise in the ring lwe setting we have

252
00:07:41,599 --> 00:07:42,800
this secret

253
00:07:42,800 --> 00:07:45,039
element s sample from the ring and we

254
00:07:45,039 --> 00:07:45,919
also have this

255
00:07:45,919 --> 00:07:47,199
error term which is sampled from a

256
00:07:47,199 --> 00:07:49,840
shorter distribution in that ring

257
00:07:49,840 --> 00:07:53,280
and then given some public ring value

258
00:07:53,280 --> 00:07:56,960
a computing a s plus e

259
00:07:56,960 --> 00:08:00,000
gives um a randomly distributed element

260
00:08:00,000 --> 00:08:01,199
in that ring

261
00:08:01,199 --> 00:08:03,440
even for an adversary that knows a so

262
00:08:03,440 --> 00:08:05,360
using this similar type assumption

263
00:08:05,360 --> 00:08:07,840
starting point for our work was uh

264
00:08:07,840 --> 00:08:08,479
actually

265
00:08:08,479 --> 00:08:10,400
can we create a natural post quantum

266
00:08:10,400 --> 00:08:11,520
video appear if analog

267
00:08:11,520 --> 00:08:14,400
using uh these foundations so what would

268
00:08:14,400 --> 00:08:14,800
like

269
00:08:14,800 --> 00:08:16,319
this look like so firstly i'm going to

270
00:08:16,319 --> 00:08:17,919
walk through this abstract attempt to

271
00:08:17,919 --> 00:08:18,960
construct

272
00:08:18,960 --> 00:08:20,319
a protocol which has some issues and

273
00:08:20,319 --> 00:08:22,160
then i'm going to highlight uh

274
00:08:22,160 --> 00:08:23,840
how we then solve these issues in order

275
00:08:23,840 --> 00:08:25,680
to get to our final construction

276
00:08:25,680 --> 00:08:28,560
so in the commitment phase we can

277
00:08:28,560 --> 00:08:30,240
replace the discrete log

278
00:08:30,240 --> 00:08:31,520
commitment which we had in the previous

279
00:08:31,520 --> 00:08:33,919
protocol with just the natural ring lwe

280
00:08:33,919 --> 00:08:35,679
analog so we have this ring element a

281
00:08:35,679 --> 00:08:37,360
and then we construct c

282
00:08:37,360 --> 00:08:40,240
as a k plus e and the client can't learn

283
00:08:40,240 --> 00:08:41,519
anything about the service key

284
00:08:41,519 --> 00:08:44,880
k based on the hardness of rwe i should

285
00:08:44,880 --> 00:08:46,640
note here that um the different colors

286
00:08:46,640 --> 00:08:48,080
in this diagram correspond to the

287
00:08:48,080 --> 00:08:48,720
different

288
00:08:48,720 --> 00:08:51,200
distributions which are highlighted in

289
00:08:51,200 --> 00:08:52,399
the top right

290
00:08:52,399 --> 00:08:54,959
so then in the client's first message in

291
00:08:54,959 --> 00:08:56,720
the online phase once it has the service

292
00:08:56,720 --> 00:08:57,680
commitment c

293
00:08:57,680 --> 00:09:00,240
and also its own input x it first has to

294
00:09:00,240 --> 00:09:02,080
do this encoding mechanism to change

295
00:09:02,080 --> 00:09:03,279
this bit string x

296
00:09:03,279 --> 00:09:05,839
into some ring value ax firstly assuming

297
00:09:05,839 --> 00:09:07,360
that this is possible this the client

298
00:09:07,360 --> 00:09:09,279
then constructs its message cx to the

299
00:09:09,279 --> 00:09:11,120
server in the following way so

300
00:09:11,120 --> 00:09:14,000
it adds ax to um essentially a newly

301
00:09:14,000 --> 00:09:14,640
sampled

302
00:09:14,640 --> 00:09:18,560
element and in doing so then cx is then

303
00:09:18,560 --> 00:09:20,080
randomly distributed in the ring and the

304
00:09:20,080 --> 00:09:21,839
server can't learn anything about this

305
00:09:21,839 --> 00:09:22,720
ax that

306
00:09:22,720 --> 00:09:25,279
is essentially the um message that the

307
00:09:25,279 --> 00:09:27,040
client is trying to blind in this

308
00:09:27,040 --> 00:09:30,080
um in this setting so once the server

309
00:09:30,080 --> 00:09:30,959
has cx

310
00:09:30,959 --> 00:09:33,279
it then has to compute dx and it does so

311
00:09:33,279 --> 00:09:34,240
again uh

312
00:09:34,240 --> 00:09:36,320
with the very natural uh ringo dw

313
00:09:36,320 --> 00:09:38,480
replacement so it simply multiplies cx

314
00:09:38,480 --> 00:09:40,399
by the key k and samples a new error

315
00:09:40,399 --> 00:09:41,680
term e2

316
00:09:41,680 --> 00:09:44,720
and uh then proves in zero knowledge

317
00:09:44,720 --> 00:09:47,360
uh that dx and the original commitment c

318
00:09:47,360 --> 00:09:49,519
share this same ring lwe

319
00:09:49,519 --> 00:09:51,839
secret k which is the service key

320
00:09:51,839 --> 00:09:53,120
finally um

321
00:09:53,120 --> 00:09:55,200
i'm ignoring now the verification steps

322
00:09:55,200 --> 00:09:57,200
because the client must also always do

323
00:09:57,200 --> 00:09:58,880
this but essentially the client verifies

324
00:09:58,880 --> 00:09:59,200
the

325
00:09:59,200 --> 00:10:01,600
proof and then computes the output of

326
00:10:01,600 --> 00:10:03,360
the pseudonym function the following way

327
00:10:03,360 --> 00:10:04,000
so it

328
00:10:04,000 --> 00:10:06,959
outputs this yx which is equal to the

329
00:10:06,959 --> 00:10:07,760
rounded

330
00:10:07,760 --> 00:10:11,440
um the rounded ring element um

331
00:10:11,440 --> 00:10:14,480
that results from uh rounding dx

332
00:10:14,480 --> 00:10:17,600
minus cs so we can think of this as like

333
00:10:17,600 --> 00:10:18,160
the

334
00:10:18,160 --> 00:10:19,839
the same way as the unblinding stuff in

335
00:10:19,839 --> 00:10:21,519
the classical construction

336
00:10:21,519 --> 00:10:24,000
therefore correctness holds when k and s

337
00:10:24,000 --> 00:10:25,519
are sampled as short elements in the

338
00:10:25,519 --> 00:10:28,560
ring just like the error terms e1 and e2

339
00:10:28,560 --> 00:10:30,880
and um what i should note here is that

340
00:10:30,880 --> 00:10:32,320
this p that's highlighted in the

341
00:10:32,320 --> 00:10:34,000
rounding step is chosen sufficiently

342
00:10:34,000 --> 00:10:34,880
small

343
00:10:34,880 --> 00:10:36,959
um corresponding to the original ring

344
00:10:36,959 --> 00:10:38,399
lwe modulus q

345
00:10:38,399 --> 00:10:40,560
such that this rounding um occurs

346
00:10:40,560 --> 00:10:42,480
correctly with high probability and i'll

347
00:10:42,480 --> 00:10:43,200
talk through

348
00:10:43,200 --> 00:10:45,839
how we mitigate for those um low

349
00:10:45,839 --> 00:10:47,600
probability events in the

350
00:10:47,600 --> 00:10:49,920
next few slides so the exact problems

351
00:10:49,920 --> 00:10:51,279
with this construction are the following

352
00:10:51,279 --> 00:10:53,040
so in the first in the commitment phase

353
00:10:53,040 --> 00:10:54,800
how does the client actually verify that

354
00:10:54,800 --> 00:10:56,640
the service commitment is constructed

355
00:10:56,640 --> 00:10:58,959
um in a proper way so in the way that

356
00:10:58,959 --> 00:11:00,800
this protocol describes

357
00:11:00,800 --> 00:11:02,160
the problem being that the service

358
00:11:02,160 --> 00:11:04,160
commitment c is actually just a random

359
00:11:04,160 --> 00:11:05,920
ring element and the server could just

360
00:11:05,920 --> 00:11:08,320
send um some maliciously constructed

361
00:11:08,320 --> 00:11:10,000
ring element in this point

362
00:11:10,000 --> 00:11:11,680
for example like a trapped ordering

363
00:11:11,680 --> 00:11:13,279
element or some ring element that's not

364
00:11:13,279 --> 00:11:14,800
actually sampled randomly and the client

365
00:11:14,800 --> 00:11:16,800
wouldn't be able to easily tell

366
00:11:16,800 --> 00:11:19,360
secondly in the online phase i left the

367
00:11:19,360 --> 00:11:20,720
description of this encode

368
00:11:20,720 --> 00:11:23,120
um mechanism generically but we are

369
00:11:23,120 --> 00:11:24,640
actually going to now have to define how

370
00:11:24,640 --> 00:11:25,360
we do this

371
00:11:25,360 --> 00:11:27,519
in such a way that the client's input is

372
00:11:27,519 --> 00:11:28,959
actually

373
00:11:28,959 --> 00:11:31,680
sampled as a random ring element given

374
00:11:31,680 --> 00:11:32,000
this

375
00:11:32,000 --> 00:11:35,040
x in a deterministic manner um another

376
00:11:35,040 --> 00:11:36,079
problem is that

377
00:11:36,079 --> 00:11:37,519
again the server can't verify the

378
00:11:37,519 --> 00:11:40,959
client's message in this phase so

379
00:11:40,959 --> 00:11:43,200
the client also can could submit a

380
00:11:43,200 --> 00:11:44,880
maliciously constructed ring element

381
00:11:44,880 --> 00:11:46,880
that has trap doors involved or is not

382
00:11:46,880 --> 00:11:48,720
actually randomly distributed which may

383
00:11:48,720 --> 00:11:50,000
allow the client to learn

384
00:11:50,000 --> 00:11:52,079
um aspects of the service key case we

385
00:11:52,079 --> 00:11:54,560
have to prevent against that

386
00:11:54,560 --> 00:11:57,200
in the service response um note as well

387
00:11:57,200 --> 00:11:58,000
that the key

388
00:11:58,000 --> 00:12:00,560
k is kind of encoded into the error term

389
00:12:00,560 --> 00:12:01,279
um

390
00:12:01,279 --> 00:12:04,480
of cx and what this may allow is for the

391
00:12:04,480 --> 00:12:06,320
client to learn things about the service

392
00:12:06,320 --> 00:12:08,399
key by analyzing the sort of errors that

393
00:12:08,399 --> 00:12:10,000
are involved here because this is no

394
00:12:10,000 --> 00:12:12,240
longer like a gaussian distributed or a

395
00:12:12,240 --> 00:12:13,920
typically distributed error

396
00:12:13,920 --> 00:12:15,519
uh distribution anymore so we have we

397
00:12:15,519 --> 00:12:17,920
have to protect against that as well

398
00:12:17,920 --> 00:12:19,600
and finally i left the zero knowledge

399
00:12:19,600 --> 00:12:22,000
proof as uh as a generic description but

400
00:12:22,000 --> 00:12:23,440
we're going to have to instantiate the

401
00:12:23,440 --> 00:12:25,040
required proof system for doing this

402
00:12:25,040 --> 00:12:26,560
in a way that preserves post-quantum

403
00:12:26,560 --> 00:12:28,240
security as well

404
00:12:28,240 --> 00:12:29,839
so with these problems in mind i'll now

405
00:12:29,839 --> 00:12:31,920
talk through um exactly how we

406
00:12:31,920 --> 00:12:34,720
uh finish up on our vop rf construction

407
00:12:34,720 --> 00:12:35,040
so

408
00:12:35,040 --> 00:12:38,000
firstly um i i've had to expand now some

409
00:12:38,000 --> 00:12:39,920
of the uh distributions and some of the

410
00:12:39,920 --> 00:12:41,360
zooming knowledge proofs that we use

411
00:12:41,360 --> 00:12:42,880
because we're going to have to use much

412
00:12:42,880 --> 00:12:43,360
more

413
00:12:43,360 --> 00:12:45,920
um functionality here um in order to

414
00:12:45,920 --> 00:12:48,079
realize a secure version of this vo pof

415
00:12:48,079 --> 00:12:49,120
protocol

416
00:12:49,120 --> 00:12:50,720
uh what i should know actually though is

417
00:12:50,720 --> 00:12:52,399
the eventual messages are going to stay

418
00:12:52,399 --> 00:12:55,040
very similar um and it's purely how we

419
00:12:55,040 --> 00:12:57,519
sample things that it's going to change

420
00:12:57,519 --> 00:12:58,880
what you should also note is that in the

421
00:12:58,880 --> 00:13:00,720
commitment phase we no longer

422
00:13:00,720 --> 00:13:03,440
um agree on an a uh based on what the

423
00:13:03,440 --> 00:13:05,040
server sensor client the client server

424
00:13:05,040 --> 00:13:06,079
must agree on

425
00:13:06,079 --> 00:13:08,160
the ring element a a priori to the

426
00:13:08,160 --> 00:13:09,360
entire protocol

427
00:13:09,360 --> 00:13:12,320
moreover we've had to um introduce some

428
00:13:12,320 --> 00:13:14,880
new error distributions specifically

429
00:13:14,880 --> 00:13:15,760
we're going to have this error

430
00:13:15,760 --> 00:13:18,160
distribution in green and this average

431
00:13:18,160 --> 00:13:19,519
distribution in violet so the error

432
00:13:19,519 --> 00:13:20,079
distribution

433
00:13:20,079 --> 00:13:22,480
violet is going to be the same as the

434
00:13:22,480 --> 00:13:24,480
distribution that we sample keys from

435
00:13:24,480 --> 00:13:26,160
and this is a gaussian distribution with

436
00:13:26,160 --> 00:13:27,920
standard deviation parameter sigma

437
00:13:27,920 --> 00:13:29,200
and then we have this green error

438
00:13:29,200 --> 00:13:30,480
distribution which has a standard

439
00:13:30,480 --> 00:13:32,399
deviation parameter of sigma prime

440
00:13:32,399 --> 00:13:34,800
where sigma prime is chosen large enough

441
00:13:34,800 --> 00:13:36,560
that any sample from the green error

442
00:13:36,560 --> 00:13:37,519
distribution

443
00:13:37,519 --> 00:13:40,160
drowned samples from the violet error

444
00:13:40,160 --> 00:13:42,560
distribution and the key distribution

445
00:13:42,560 --> 00:13:45,440
and finally the encode function which i

446
00:13:45,440 --> 00:13:46,320
mentioned before is going to be

447
00:13:46,320 --> 00:13:47,120
instantiated

448
00:13:47,120 --> 00:13:49,600
using the banerjee pika ring lwe based

449
00:13:49,600 --> 00:13:52,240
student function from crypto 2014

450
00:13:52,240 --> 00:13:54,480
and i'll note here that um the output of

451
00:13:54,480 --> 00:13:55,680
that universal function is going to be

452
00:13:55,680 --> 00:13:57,279
truncated in the sense that it's going

453
00:13:57,279 --> 00:13:58,160
to be

454
00:13:58,160 --> 00:14:01,040
a single ring element secondly the zero

455
00:14:01,040 --> 00:14:03,040
knowledge proves um

456
00:14:03,040 --> 00:14:04,639
now that we introduced there's going to

457
00:14:04,639 --> 00:14:06,079
be three different zero knowledge proofs

458
00:14:06,079 --> 00:14:07,279
and there's going to be one for the

459
00:14:07,279 --> 00:14:08,959
server setup message in the commitment

460
00:14:08,959 --> 00:14:09,360
phase

461
00:14:09,360 --> 00:14:10,639
there's going to be one for the client's

462
00:14:10,639 --> 00:14:11,760
message and there's going to be another

463
00:14:11,760 --> 00:14:13,040
for the servers message

464
00:14:13,040 --> 00:14:14,959
essentially we need to do uh use these

465
00:14:14,959 --> 00:14:16,560
image proofs in order to ensure that the

466
00:14:16,560 --> 00:14:18,000
client and server messages throughout

467
00:14:18,000 --> 00:14:18,720
the protocol

468
00:14:18,720 --> 00:14:22,160
are well um constructed um and so that

469
00:14:22,160 --> 00:14:23,519
in the final security proof the

470
00:14:23,519 --> 00:14:25,600
simulator that we use can extract

471
00:14:25,600 --> 00:14:27,120
uh the secret inputs that both the

472
00:14:27,120 --> 00:14:30,399
malicious clients and servers use

473
00:14:30,399 --> 00:14:32,399
and what i should note though is that

474
00:14:32,399 --> 00:14:33,760
these zero knowledge proofs can be

475
00:14:33,760 --> 00:14:35,120
instantiated using

476
00:14:35,120 --> 00:14:37,920
um newly discovered methods by yang itau

477
00:14:37,920 --> 00:14:39,920
and bewlins from crypto 2019 and

478
00:14:39,920 --> 00:14:42,880
eurocrypt 2020 respectively

479
00:14:42,880 --> 00:14:45,519
and that the ward bewlins methods um

480
00:14:45,519 --> 00:14:46,240
specifically

481
00:14:46,240 --> 00:14:47,839
are quantum random oracle model

482
00:14:47,839 --> 00:14:49,680
compatible which enables us to situate

483
00:14:49,680 --> 00:14:51,360
our security proof in the quantum london

484
00:14:51,360 --> 00:14:52,639
oracle model as well

485
00:14:52,639 --> 00:14:54,399
i'm not going to talk about exactly how

486
00:14:54,399 --> 00:14:55,680
these zone knowledge proofs are

487
00:14:55,680 --> 00:14:57,120
constructed as their constructions are

488
00:14:57,120 --> 00:14:58,560
very heavily involved but i would

489
00:14:58,560 --> 00:15:00,000
encourage you to see the paper

490
00:15:00,000 --> 00:15:01,680
specifically section 4 if you'd like to

491
00:15:01,680 --> 00:15:03,760
learn more details

492
00:15:03,760 --> 00:15:06,480
so firstly going back to the original

493
00:15:06,480 --> 00:15:07,760
construction

494
00:15:07,760 --> 00:15:09,360
in the offline phase now the server

495
00:15:09,360 --> 00:15:10,800
constructs this message in exactly the

496
00:15:10,800 --> 00:15:12,320
same way but also appends this to a

497
00:15:12,320 --> 00:15:14,079
knowledge proof pi zero

498
00:15:14,079 --> 00:15:17,120
which attests to the um the construction

499
00:15:17,120 --> 00:15:18,639
of the message that the server gives

500
00:15:18,639 --> 00:15:21,760
that the client can then verify in the

501
00:15:21,760 --> 00:15:22,560
online phase

502
00:15:22,560 --> 00:15:24,000
again the client constructs this message

503
00:15:24,000 --> 00:15:26,000
in the same way except now the client

504
00:15:26,000 --> 00:15:28,240
samples errors from this violet error

505
00:15:28,240 --> 00:15:29,680
distribution which is the smaller

506
00:15:29,680 --> 00:15:30,399
distribution

507
00:15:30,399 --> 00:15:32,560
and also sends this pi 1 which attests

508
00:15:32,560 --> 00:15:34,079
to the construction of the message

509
00:15:34,079 --> 00:15:36,240
and the server then can verify it and

510
00:15:36,240 --> 00:15:38,320
finally the server sends again

511
00:15:38,320 --> 00:15:41,440
the same message and this pi 2 um proves

512
00:15:41,440 --> 00:15:42,000
that the

513
00:15:42,000 --> 00:15:43,600
in zero knowledge that the server has

514
00:15:43,600 --> 00:15:45,600
used the same key k in this message

515
00:15:45,600 --> 00:15:47,519
and in the original commitment see

516
00:15:47,519 --> 00:15:48,959
correctness holds due to exactly the

517
00:15:48,959 --> 00:15:50,720
same argument because the actual format

518
00:15:50,720 --> 00:15:52,000
of the messages

519
00:15:52,000 --> 00:15:54,880
has not changed beyond um using these

520
00:15:54,880 --> 00:15:56,320
different error distributions and i'm

521
00:15:56,320 --> 00:15:58,160
going to talk now why these uh using

522
00:15:58,160 --> 00:15:59,519
these different error distributions is

523
00:15:59,519 --> 00:15:59,920
fine

524
00:15:59,920 --> 00:16:01,440
even in the correctness argument so

525
00:16:01,440 --> 00:16:03,279
recall that the client's protocol output

526
00:16:03,279 --> 00:16:04,079
is this

527
00:16:04,079 --> 00:16:07,120
rounded ring element y x which is

528
00:16:07,120 --> 00:16:10,399
equal to ax multiplied by k plus this

529
00:16:10,399 --> 00:16:12,160
error term all rounded with respect to

530
00:16:12,160 --> 00:16:13,759
this modulus p

531
00:16:13,759 --> 00:16:15,680
which is chosen much smaller than the

532
00:16:15,680 --> 00:16:17,279
ring lwe modulus q

533
00:16:17,279 --> 00:16:18,800
so the veracity of our correctness

534
00:16:18,800 --> 00:16:20,240
argument is actually based on the

535
00:16:20,240 --> 00:16:21,519
computational hardness of the

536
00:16:21,519 --> 00:16:23,519
one-dimensional short integer solution

537
00:16:23,519 --> 00:16:24,959
problem

538
00:16:24,959 --> 00:16:26,800
how this works broadly is that we can

539
00:16:26,800 --> 00:16:28,320
show um

540
00:16:28,320 --> 00:16:30,480
quite easily that due to sampling all of

541
00:16:30,480 --> 00:16:32,720
these error terms and keys and

542
00:16:32,720 --> 00:16:34,800
secrets from short distributions we can

543
00:16:34,800 --> 00:16:36,560
bound the size of this error term with

544
00:16:36,560 --> 00:16:37,680
high probability

545
00:16:37,680 --> 00:16:40,079
within this boundary within these

546
00:16:40,079 --> 00:16:41,920
boundaries of minus t and t

547
00:16:41,920 --> 00:16:43,759
and then note that uh for for

548
00:16:43,759 --> 00:16:45,199
correctness not to hold

549
00:16:45,199 --> 00:16:47,519
we'd need a coefficient of a x k to be

550
00:16:47,519 --> 00:16:48,399
within

551
00:16:48,399 --> 00:16:51,759
minus t and t of a rounding boundary

552
00:16:51,759 --> 00:16:54,560
because in doing so um if axk was close

553
00:16:54,560 --> 00:16:56,079
to this rounding boundary then adding on

554
00:16:56,079 --> 00:16:57,519
this everton would push it over a

555
00:16:57,519 --> 00:16:58,320
rounding edge

556
00:16:58,320 --> 00:17:00,480
and would lead to a correctness error in

557
00:17:00,480 --> 00:17:02,800
order to use the hardness of one dsis

558
00:17:02,800 --> 00:17:04,400
in our correctness argument we

559
00:17:04,400 --> 00:17:06,000
essentially show that if any coefficient

560
00:17:06,000 --> 00:17:08,079
of ask was in this set so it was within

561
00:17:08,079 --> 00:17:09,119
minus t

562
00:17:09,119 --> 00:17:11,439
to t of a rounding boundary then an

563
00:17:11,439 --> 00:17:14,400
adversary could solve the 1dsis problem

564
00:17:14,400 --> 00:17:16,319
secondly so once correctness is argued

565
00:17:16,319 --> 00:17:17,520
we then need to

566
00:17:17,520 --> 00:17:19,520
focus on malicious security so we need

567
00:17:19,520 --> 00:17:21,119
to show that there's a simulator that

568
00:17:21,119 --> 00:17:21,599
can

569
00:17:21,599 --> 00:17:23,439
interact with the ideal vo prf

570
00:17:23,439 --> 00:17:25,359
functionality and simulate the real

571
00:17:25,359 --> 00:17:27,119
protocol to any malicious server or

572
00:17:27,119 --> 00:17:28,079
client

573
00:17:28,079 --> 00:17:29,840
so essentially how our security proof

574
00:17:29,840 --> 00:17:31,120
works is that the client

575
00:17:31,120 --> 00:17:33,360
um or the server in a malicious sense

576
00:17:33,360 --> 00:17:35,120
sends uh the message

577
00:17:35,120 --> 00:17:36,480
and providing that the zero knowledge

578
00:17:36,480 --> 00:17:38,960
proof that the adversary constructs does

579
00:17:38,960 --> 00:17:42,160
uh verify the the simulator can extract

580
00:17:42,160 --> 00:17:43,919
the secret inputs from those knowledge

581
00:17:43,919 --> 00:17:45,440
proofs using the

582
00:17:45,440 --> 00:17:48,400
knowledge extraction property of those

583
00:17:48,400 --> 00:17:50,000
of those proof objects

584
00:17:50,000 --> 00:17:51,840
and once it extracts those inputs it can

585
00:17:51,840 --> 00:17:53,440
simply forward them on to the ideal

586
00:17:53,440 --> 00:17:55,440
functionality and learn

587
00:17:55,440 --> 00:17:57,840
an output from that functionality and

588
00:17:57,840 --> 00:17:59,440
then it just has to uh

589
00:17:59,440 --> 00:18:02,000
create the remaining messages so firstly

590
00:18:02,000 --> 00:18:03,120
the messages

591
00:18:03,120 --> 00:18:04,720
that the simulator creates are can be

592
00:18:04,720 --> 00:18:06,240
made indistinguishable

593
00:18:06,240 --> 00:18:08,080
based on the hardness of the ring lwe

594
00:18:08,080 --> 00:18:09,760
problem in the sense that

595
00:18:09,760 --> 00:18:11,679
uh the messages in the protocol should

596
00:18:11,679 --> 00:18:13,200
all be randomly distributed ring

597
00:18:13,200 --> 00:18:14,720
elements

598
00:18:14,720 --> 00:18:16,640
secondly in order to finish off the

599
00:18:16,640 --> 00:18:18,320
security proofs we need to prove that

600
00:18:18,320 --> 00:18:19,760
the correct outputs

601
00:18:19,760 --> 00:18:21,679
are learned both in the client and in

602
00:18:21,679 --> 00:18:22,880
the server case

603
00:18:22,880 --> 00:18:25,120
and again we lean on the hardness of the

604
00:18:25,120 --> 00:18:26,720
1dsis problem

605
00:18:26,720 --> 00:18:28,320
and note that if any zero knowledge

606
00:18:28,320 --> 00:18:30,160
proofs fails at any time then the

607
00:18:30,160 --> 00:18:31,760
simulator simply aborts and that would

608
00:18:31,760 --> 00:18:33,280
be exactly the same as in the real

609
00:18:33,280 --> 00:18:35,360
protocol as well so this simulator

610
00:18:35,360 --> 00:18:37,600
um for both malicious clients and

611
00:18:37,600 --> 00:18:38,640
servers simulates

612
00:18:38,640 --> 00:18:41,760
uh the real world exactly based on the

613
00:18:41,760 --> 00:18:44,000
computational hardness of these

614
00:18:44,000 --> 00:18:46,160
problems finally i should know that the

615
00:18:46,160 --> 00:18:47,520
malicious client proof actually only

616
00:18:47,520 --> 00:18:49,440
holds in the average case in the sense

617
00:18:49,440 --> 00:18:50,799
that it only holds when the server

618
00:18:50,799 --> 00:18:53,200
samples its key from a ring lwe hard

619
00:18:53,200 --> 00:18:54,320
distribution

620
00:18:54,320 --> 00:18:56,640
so with now our construction uh given

621
00:18:56,640 --> 00:18:58,640
we'd like to talk through the efficiency

622
00:18:58,640 --> 00:19:00,160
um of our protocol and some of the

623
00:19:00,160 --> 00:19:01,600
parameter settings we have to make in

624
00:19:01,600 --> 00:19:02,240
order to

625
00:19:02,240 --> 00:19:04,160
inform how close we are to being able to

626
00:19:04,160 --> 00:19:06,320
realize and post quantum video prf

627
00:19:06,320 --> 00:19:07,679
for some of the applications that i

628
00:19:07,679 --> 00:19:09,360
highlighted previously

629
00:19:09,360 --> 00:19:12,880
so firstly um drawing attention now to

630
00:19:12,880 --> 00:19:13,440
some of the

631
00:19:13,440 --> 00:19:15,200
exact uh parameter settings that we make

632
00:19:15,200 --> 00:19:17,520
for our lattice based foundations

633
00:19:17,520 --> 00:19:19,200
the things i'd like to draw attention to

634
00:19:19,200 --> 00:19:21,039
are the um

635
00:19:21,039 --> 00:19:24,080
super polynomial um q

636
00:19:24,080 --> 00:19:26,640
and sigma prime that we have to use in

637
00:19:26,640 --> 00:19:28,480
order to realize our construction

638
00:19:28,480 --> 00:19:30,240
so this is a barrier uh quite a

639
00:19:30,240 --> 00:19:31,840
significant barrier to realizing the

640
00:19:31,840 --> 00:19:32,960
fission construction

641
00:19:32,960 --> 00:19:35,120
and we require doing this in order to

642
00:19:35,120 --> 00:19:38,160
meet two guarantees so the first is that

643
00:19:38,160 --> 00:19:39,840
the pseudo-random function that we use

644
00:19:39,840 --> 00:19:41,520
underlying our protocol so the banerjee

645
00:19:41,520 --> 00:19:43,039
pike at pseudo-random function

646
00:19:43,039 --> 00:19:45,360
requires a super polynomial size modulus

647
00:19:45,360 --> 00:19:47,039
queue in order to um

648
00:19:47,039 --> 00:19:49,919
achieve security in the for the ring lwe

649
00:19:49,919 --> 00:19:50,400
problem

650
00:19:50,400 --> 00:19:53,760
so that's one invariant and the second

651
00:19:53,760 --> 00:19:56,320
is that in order to realize this um

652
00:19:56,320 --> 00:19:58,880
noise drowning approach in order for the

653
00:19:58,880 --> 00:19:59,919
server to hide

654
00:19:59,919 --> 00:20:02,960
its um secret key k and the response to

655
00:20:02,960 --> 00:20:03,600
the client

656
00:20:03,600 --> 00:20:06,080
we must also use a very wide error

657
00:20:06,080 --> 00:20:07,440
distribution

658
00:20:07,440 --> 00:20:10,000
which again then forces our eventual

659
00:20:10,000 --> 00:20:10,960
modulus q to be

660
00:20:10,960 --> 00:20:13,679
a super polynomial in size so in terms

661
00:20:13,679 --> 00:20:14,960
of concrete sizes

662
00:20:14,960 --> 00:20:17,840
based on those asymptotic settings if we

663
00:20:17,840 --> 00:20:20,400
want to realize 128 128-bit security

664
00:20:20,400 --> 00:20:22,240
then roughly speaking we'll need a queue

665
00:20:22,240 --> 00:20:24,320
that's 256 bits long

666
00:20:24,320 --> 00:20:27,440
and we'll need um quite a large uh

667
00:20:27,440 --> 00:20:29,679
dimension uh parameter n in order to

668
00:20:29,679 --> 00:20:30,960
realize that and that

669
00:20:30,960 --> 00:20:32,320
essentially results in ring elements

670
00:20:32,320 --> 00:20:34,480
that are 0.5 megabytes in size

671
00:20:34,480 --> 00:20:36,000
and given that the client server both

672
00:20:36,000 --> 00:20:38,960
exchange um a ring element um

673
00:20:38,960 --> 00:20:40,480
then this will lead to at least one

674
00:20:40,480 --> 00:20:42,559
megabyte of communication

675
00:20:42,559 --> 00:20:44,799
however that's ignoring the zero

676
00:20:44,799 --> 00:20:45,760
knowledge proofs

677
00:20:45,760 --> 00:20:47,200
and instantiating the zero knowledge

678
00:20:47,200 --> 00:20:49,200
proofs using for example the

679
00:20:49,200 --> 00:20:51,120
proof system of yangotel we would

680
00:20:51,120 --> 00:20:53,120
require essentially two to the 40 bits

681
00:20:53,120 --> 00:20:53,520
of

682
00:20:53,520 --> 00:20:55,919
communication per repetition and while

683
00:20:55,919 --> 00:20:57,600
with our parameter sizes we can reduce

684
00:20:57,600 --> 00:20:58,480
the repetitions

685
00:20:58,480 --> 00:21:00,159
quite substantially to around two in

686
00:21:00,159 --> 00:21:02,000
order to achieve a secure

687
00:21:02,000 --> 00:21:05,039
protocol 2 to 40 bits of communication

688
00:21:05,039 --> 00:21:06,320
is going to be in the order of hundreds

689
00:21:06,320 --> 00:21:07,280
of gigabytes

690
00:21:07,280 --> 00:21:09,840
and so our protocol is very clearly not

691
00:21:09,840 --> 00:21:10,960
going to be

692
00:21:10,960 --> 00:21:12,720
anywhere near efficient enough to run

693
00:21:12,720 --> 00:21:15,280
for the applications i highlighted

694
00:21:15,280 --> 00:21:17,120
note however that in a practical setting

695
00:21:17,120 --> 00:21:18,640
you would probably try and instantiate

696
00:21:18,640 --> 00:21:20,880
these proofs using snarks or starks

697
00:21:20,880 --> 00:21:22,640
um although we haven't done the research

698
00:21:22,640 --> 00:21:23,919
into how exactly that would

699
00:21:23,919 --> 00:21:27,120
um how that would work and again

700
00:21:27,120 --> 00:21:28,559
for our parameter settings we highlight

701
00:21:28,559 --> 00:21:30,000
some more of these details in section

702
00:21:30,000 --> 00:21:31,039
5.3

703
00:21:31,039 --> 00:21:32,799
so clearly our protocol is not going to

704
00:21:32,799 --> 00:21:34,720
be practical enough and one of the major

705
00:21:34,720 --> 00:21:36,080
reasons for that is the zone knowledge

706
00:21:36,080 --> 00:21:37,039
proofs so

707
00:21:37,039 --> 00:21:39,360
in the paper um we highlight some

708
00:21:39,360 --> 00:21:41,200
possible ways of optimizing our protocol

709
00:21:41,200 --> 00:21:42,880
in order to reduce or remove some of

710
00:21:42,880 --> 00:21:44,960
those knowledge proofs that we use

711
00:21:44,960 --> 00:21:47,280
so firstly um we should note that in the

712
00:21:47,280 --> 00:21:49,039
commitment phase it may be possible to

713
00:21:49,039 --> 00:21:50,960
use a trapdoor ring element a

714
00:21:50,960 --> 00:21:52,880
instead of a zero knowledge proof

715
00:21:52,880 --> 00:21:54,080
because essentially we use this

716
00:21:54,080 --> 00:21:54,720
commitment

717
00:21:54,720 --> 00:21:58,080
in order to extract the server's input

718
00:21:58,080 --> 00:22:00,480
key k and using a trap.ring element

719
00:22:00,480 --> 00:22:02,000
would allow that

720
00:22:02,000 --> 00:22:03,679
secondly we may be able to remove

721
00:22:03,679 --> 00:22:05,360
completely the server's zero knowledge

722
00:22:05,360 --> 00:22:07,200
proof zkp2 in its

723
00:22:07,200 --> 00:22:09,280
response message to the client using a

724
00:22:09,280 --> 00:22:10,799
cut and choose based approach

725
00:22:10,799 --> 00:22:13,120
where the client would send multiple um

726
00:22:13,120 --> 00:22:13,840
queries

727
00:22:13,840 --> 00:22:15,600
and the server would evaluate the same

728
00:22:15,600 --> 00:22:17,120
vocab on each of those queries and the

729
00:22:17,120 --> 00:22:18,720
client would then choose a subset of the

730
00:22:18,720 --> 00:22:19,679
responses and check

731
00:22:19,679 --> 00:22:22,559
that they are well-formed so obviously

732
00:22:22,559 --> 00:22:23,840
this comes at the expense of sending

733
00:22:23,840 --> 00:22:26,080
larger client queries which may um

734
00:22:26,080 --> 00:22:28,159
or may not work and depending on the

735
00:22:28,159 --> 00:22:29,120
application

736
00:22:29,120 --> 00:22:31,840
and finally while we only presented a

737
00:22:31,840 --> 00:22:33,520
protocol for a single query

738
00:22:33,520 --> 00:22:35,760
we should note that um actually a server

739
00:22:35,760 --> 00:22:37,280
can generate a single

740
00:22:37,280 --> 00:22:38,640
zero knowledge proof instance for

741
00:22:38,640 --> 00:22:40,640
multiple client queries and so the

742
00:22:40,640 --> 00:22:41,760
client could send n

743
00:22:41,760 --> 00:22:43,600
uh vopf queries and the server could

744
00:22:43,600 --> 00:22:46,159
send n responses with only a single zone

745
00:22:46,159 --> 00:22:47,600
launch proof of test into the fact that

746
00:22:47,600 --> 00:22:48,960
they all contain

747
00:22:48,960 --> 00:22:50,960
an evaluation using the same secret key

748
00:22:50,960 --> 00:22:52,960
k as it's committed to in the commitment

749
00:22:52,960 --> 00:22:53,440
phase

750
00:22:53,440 --> 00:22:55,440
so with those optimizations in mind we

751
00:22:55,440 --> 00:22:56,880
can then compare our protocol with the

752
00:22:56,880 --> 00:22:59,120
previous designs so firstly the

753
00:22:59,120 --> 00:23:01,520
the uh yarrow kia tower construction in

754
00:23:01,520 --> 00:23:03,440
the classical setting is very small in

755
00:23:03,440 --> 00:23:04,240
the sense that

756
00:23:04,240 --> 00:23:05,600
the concrete communication cost is

757
00:23:05,600 --> 00:23:08,000
around 128 bytes it comes with the

758
00:23:08,000 --> 00:23:09,600
caveat that it's only secure in the

759
00:23:09,600 --> 00:23:11,760
random oracle model

760
00:23:11,760 --> 00:23:12,799
moving on to the post quantum

761
00:23:12,799 --> 00:23:14,799
construction so the one of bone a towel

762
00:23:14,799 --> 00:23:16,159
from asia crypt 2020

763
00:23:16,159 --> 00:23:18,080
has a concrete cost of around to two

764
00:23:18,080 --> 00:23:19,679
megabytes which is obviously much much

765
00:23:19,679 --> 00:23:20,159
bigger

766
00:23:20,159 --> 00:23:21,919
than the classical setting but is still

767
00:23:21,919 --> 00:23:22,960
possibly within the realms of

768
00:23:22,960 --> 00:23:24,159
practicality

769
00:23:24,159 --> 00:23:27,120
and this uh construction is is post

770
00:23:27,120 --> 00:23:29,200
quantum secure based on the hardness of

771
00:23:29,200 --> 00:23:32,240
um problems in the isogeny based setting

772
00:23:32,240 --> 00:23:34,640
then our construction in the ring lwe

773
00:23:34,640 --> 00:23:35,440
setting uh

774
00:23:35,440 --> 00:23:37,200
our concrete costs are kind of like one

775
00:23:37,200 --> 00:23:39,520
megabyte so one ring element between

776
00:23:39,520 --> 00:23:40,880
the client server and then one ring

777
00:23:40,880 --> 00:23:43,440
element back but we should highlight

778
00:23:43,440 --> 00:23:43,760
that

779
00:23:43,760 --> 00:23:45,279
all of these costs come with the caveat

780
00:23:45,279 --> 00:23:46,799
that we must include zero large proofs

781
00:23:46,799 --> 00:23:47,760
to ensure

782
00:23:47,760 --> 00:23:49,200
that both the client and server acting

783
00:23:49,200 --> 00:23:50,960
honestly and these zero launch proofs

784
00:23:50,960 --> 00:23:52,080
cause

785
00:23:52,080 --> 00:23:54,640
much much bigger communication costs

786
00:23:54,640 --> 00:23:55,200
with those

787
00:23:55,200 --> 00:23:56,559
uh comparisons of mine i'd just like to

788
00:23:56,559 --> 00:23:57,840
highlight some of the conclusions of the

789
00:23:57,840 --> 00:23:58,320
work

790
00:23:58,320 --> 00:23:59,679
and then some of the open problems which

791
00:23:59,679 --> 00:24:01,600
we think are required solving

792
00:24:01,600 --> 00:24:03,919
we can now build post quantum via pos

793
00:24:03,919 --> 00:24:04,640
using

794
00:24:04,640 --> 00:24:06,720
uh or assuming the hardness of

795
00:24:06,720 --> 00:24:08,320
well-known lattice-based problems so

796
00:24:08,320 --> 00:24:10,080
this complements the results of bonaire

797
00:24:10,080 --> 00:24:10,640
tell

798
00:24:10,640 --> 00:24:13,039
however all all post-quantum proposals

799
00:24:13,039 --> 00:24:14,720
currently including ours suffer from

800
00:24:14,720 --> 00:24:16,320
very expensive costs due to the

801
00:24:16,320 --> 00:24:17,279
zero-knowledge proofs proofs they're

802
00:24:17,279 --> 00:24:19,039
required and also the large parameter

803
00:24:19,039 --> 00:24:19,919
settings which

804
00:24:19,919 --> 00:24:22,080
are required to ensure security so in

805
00:24:22,080 --> 00:24:23,520
terms of future work we think it'd be

806
00:24:23,520 --> 00:24:24,799
really valuable to realize

807
00:24:24,799 --> 00:24:27,279
a more efficient post quantum via pof um

808
00:24:27,279 --> 00:24:28,159
in order to

809
00:24:28,159 --> 00:24:30,080
potentially realize um some of the

810
00:24:30,080 --> 00:24:31,360
applications that are highlighted in the

811
00:24:31,360 --> 00:24:32,880
internet setting

812
00:24:32,880 --> 00:24:34,720
so the first uh thing that we think

813
00:24:34,720 --> 00:24:36,080
would be really valuable would be to

814
00:24:36,080 --> 00:24:37,360
reduce or remove

815
00:24:37,360 --> 00:24:38,640
all the zero knowledge proofs while

816
00:24:38,640 --> 00:24:41,200
trying to still ensure verifiability

817
00:24:41,200 --> 00:24:42,799
in order to reduce some of the parameter

818
00:24:42,799 --> 00:24:45,200
settings um

819
00:24:45,200 --> 00:24:46,640
removing the noise drowning approach

820
00:24:46,640 --> 00:24:48,799
which we use to highlight how

821
00:24:48,799 --> 00:24:51,039
the server needs to protect its key in

822
00:24:51,039 --> 00:24:52,159
the response to the client

823
00:24:52,159 --> 00:24:54,320
and also using potentially a more

824
00:24:54,320 --> 00:24:55,679
efficient pseudo-random function

825
00:24:55,679 --> 00:24:57,600
alternative to the banerjee pika

826
00:24:57,600 --> 00:24:59,919
construction from 2014 may allow us to

827
00:24:59,919 --> 00:25:01,840
use a polynomial size modulus q which

828
00:25:01,840 --> 00:25:02,400
would

829
00:25:02,400 --> 00:25:04,799
then would um significantly reduce the

830
00:25:04,799 --> 00:25:06,000
size of the ring elements that the

831
00:25:06,000 --> 00:25:07,840
client server sent between each other

832
00:25:07,840 --> 00:25:09,600
so one thing i haven't highlighted is

833
00:25:09,600 --> 00:25:11,679
the potential for using generic methods

834
00:25:11,679 --> 00:25:13,919
and such as a garbage circuit based

835
00:25:13,919 --> 00:25:15,200
approaches or

836
00:25:15,200 --> 00:25:17,039
other secure computation mechanisms for

837
00:25:17,039 --> 00:25:19,600
constructing vo pofs between two parties

838
00:25:19,600 --> 00:25:21,600
to do a detailed comparison between

839
00:25:21,600 --> 00:25:23,120
these custom-based approaches on

840
00:25:23,120 --> 00:25:25,600
based around isogenys and ring lwe or

841
00:25:25,600 --> 00:25:26,799
other lattice-based

842
00:25:26,799 --> 00:25:28,720
foundations with these generic methods

843
00:25:28,720 --> 00:25:30,720
to see in the long term which is going

844
00:25:30,720 --> 00:25:32,000
to be the most efficient way of

845
00:25:32,000 --> 00:25:33,520
constructing these protocols

846
00:25:33,520 --> 00:25:35,840
with post-quantum security so just to

847
00:25:35,840 --> 00:25:37,120
finish i'd like to thank you for

848
00:25:37,120 --> 00:25:38,720
listening to our talk please do get in

849
00:25:38,720 --> 00:25:39,919
touch with any of the authors if you

850
00:25:39,919 --> 00:25:41,600
have any questions

851
00:25:41,600 --> 00:25:43,600
and i'd like to thank the organizers of

852
00:25:43,600 --> 00:25:45,679
pkc for allowing us to speak

853
00:25:45,679 --> 00:25:48,320
thank you

