1
00:00:02,159 --> 00:00:04,400
i welcome everyone to this presentation

2
00:00:04,400 --> 00:00:05,359
of the paper

3
00:00:05,359 --> 00:00:08,400
beyond security and efficiency on-demand

4
00:00:08,400 --> 00:00:11,200
ratcheting with security awareness

5
00:00:11,200 --> 00:00:13,599
my name is andrea cofforio and this is a

6
00:00:13,599 --> 00:00:14,559
joint work with

7
00:00:14,559 --> 00:00:17,039
bettie durock from boss research and

8
00:00:17,039 --> 00:00:18,000
search wooden

9
00:00:18,000 --> 00:00:22,320
from the lasik laboratory at epfl

10
00:00:23,439 --> 00:00:26,000
although messaging applications permeate

11
00:00:26,000 --> 00:00:27,199
our everyday life

12
00:00:27,199 --> 00:00:29,519
basically everywhere around the globe

13
00:00:29,519 --> 00:00:31,519
the cryptographic sub-discipline of

14
00:00:31,519 --> 00:00:32,800
secure messaging

15
00:00:32,800 --> 00:00:34,800
has only been gaining traction over the

16
00:00:34,800 --> 00:00:36,320
past few years

17
00:00:36,320 --> 00:00:38,480
with the emergence of several ratcheting

18
00:00:38,480 --> 00:00:40,640
protocols with varying security

19
00:00:40,640 --> 00:00:43,200
properties

20
00:00:43,200 --> 00:00:45,520
the overall goal however for all of

21
00:00:45,520 --> 00:00:47,200
these constructions remains

22
00:00:47,200 --> 00:00:50,320
identical how to secure an asynchronous

23
00:00:50,320 --> 00:00:52,239
channel between two participants

24
00:00:52,239 --> 00:00:54,239
that arbitrarily switch their rules in

25
00:00:54,239 --> 00:00:57,520
the presence of state exposures

26
00:00:57,520 --> 00:01:00,160
in this context asynchronous means that

27
00:01:00,160 --> 00:01:02,399
both users do not need to be online

28
00:01:02,399 --> 00:01:04,640
in order to communicate hence the

29
00:01:04,640 --> 00:01:07,520
sending and reception of messages may be

30
00:01:07,520 --> 00:01:10,320
randomly interleaved nevertheless this

31
00:01:10,320 --> 00:01:12,320
does not mean that the order of messages

32
00:01:12,320 --> 00:01:13,360
from a user

33
00:01:13,360 --> 00:01:15,680
can be mixed or that messages can be

34
00:01:15,680 --> 00:01:18,000
dropped

35
00:01:19,040 --> 00:01:20,960
we capture the security of a messaging

36
00:01:20,960 --> 00:01:22,960
protocol through two notions

37
00:01:22,960 --> 00:01:25,520
the first one is forward security we

38
00:01:25,520 --> 00:01:26,479
want to prevent

39
00:01:26,479 --> 00:01:28,799
the decryption of past messages by

40
00:01:28,799 --> 00:01:30,960
deleting all states through one-way

41
00:01:30,960 --> 00:01:32,560
functions

42
00:01:32,560 --> 00:01:35,280
and secondly post-compromised security

43
00:01:35,280 --> 00:01:37,119
we want to prevent the decryption of

44
00:01:37,119 --> 00:01:38,640
future communication

45
00:01:38,640 --> 00:01:41,040
by introducing some form of randomness

46
00:01:41,040 --> 00:01:42,640
into the user states

47
00:01:42,640 --> 00:01:46,479
this is commonly called ratcheting

48
00:01:47,280 --> 00:01:50,079
otr short for of the record was the

49
00:01:50,079 --> 00:01:52,399
earliest ratcheting protocol that found

50
00:01:52,399 --> 00:01:54,320
real world application

51
00:01:54,320 --> 00:01:56,799
it is now superseded by the omnipresent

52
00:01:56,799 --> 00:01:59,840
signal construction released in 2013

53
00:01:59,840 --> 00:02:02,880
and among others found in whatsapp the

54
00:02:02,880 --> 00:02:05,119
security of signal was only formally

55
00:02:05,119 --> 00:02:08,160
analyzed in 2017

56
00:02:08,160 --> 00:02:10,560
the first ratcheting protocol that found

57
00:02:10,560 --> 00:02:13,040
its way on the academic stage

58
00:02:13,040 --> 00:02:15,440
was a construction by cole gordon at all

59
00:02:15,440 --> 00:02:16,879
that however required

60
00:02:16,879 --> 00:02:20,000
synchronized rules a year later belaria

61
00:02:20,000 --> 00:02:21,920
at all proposed a unidirectional

62
00:02:21,920 --> 00:02:26,079
protocol with no forward security

63
00:02:26,480 --> 00:02:29,520
at crypto 2018 pattern and russell

64
00:02:29,520 --> 00:02:31,519
came forward with a protocol with

65
00:02:31,519 --> 00:02:32,800
optimal security

66
00:02:32,800 --> 00:02:34,879
in the sense that no better model is

67
00:02:34,879 --> 00:02:37,760
known it is proven in the random oracle

68
00:02:37,760 --> 00:02:39,920
model but does not consider leakage of

69
00:02:39,920 --> 00:02:42,720
random coins

70
00:02:43,120 --> 00:02:45,280
the construction is instantiated with a

71
00:02:45,280 --> 00:02:46,160
hierarchical

72
00:02:46,160 --> 00:02:48,160
identity based encryption scheme that

73
00:02:48,160 --> 00:02:50,239
requires bilinear pairings

74
00:02:50,239 --> 00:02:53,360
and is thus very inefficient at the same

75
00:02:53,360 --> 00:02:55,680
conference jager and stephanov proposed

76
00:02:55,680 --> 00:02:56,319
a similar

77
00:02:56,319 --> 00:02:58,400
optimal protocol in the random oracle

78
00:02:58,400 --> 00:03:01,440
model also relying on hiv es

79
00:03:01,440 --> 00:03:05,760
with random coin leakage before usage

80
00:03:05,760 --> 00:03:08,879
in 2019 durak and vodone put forward a

81
00:03:08,879 --> 00:03:10,879
highly efficient ratcheting protocol

82
00:03:10,879 --> 00:03:12,879
with slightly lower security in the

83
00:03:12,879 --> 00:03:13,840
standard model

84
00:03:13,840 --> 00:03:15,680
that only requires ordinary

85
00:03:15,680 --> 00:03:17,120
cryptosystems

86
00:03:17,120 --> 00:03:19,440
it is based on a publicly crypto system

87
00:03:19,440 --> 00:03:21,040
a symmetric key system

88
00:03:21,040 --> 00:03:23,280
a digital signature scheme and a hash

89
00:03:23,280 --> 00:03:24,959
function

90
00:03:24,959 --> 00:03:26,959
they further introduced the notion of

91
00:03:26,959 --> 00:03:28,480
recovery security

92
00:03:28,480 --> 00:03:30,400
meaning that a participant should not be

93
00:03:30,400 --> 00:03:31,680
able anymore to receive

94
00:03:31,680 --> 00:03:34,080
genuine messages after having received

95
00:03:34,080 --> 00:03:34,879
the forgery

96
00:03:34,879 --> 00:03:38,000
hence detecting the intrusion

97
00:03:38,000 --> 00:03:40,159
additionally the offers proved that

98
00:03:40,159 --> 00:03:42,239
post-compromise security implies

99
00:03:42,239 --> 00:03:43,920
publicly cryptography

100
00:03:43,920 --> 00:03:45,840
hence this security level cannot be

101
00:03:45,840 --> 00:03:49,920
achieved by symmetric primitives only

102
00:03:51,760 --> 00:03:54,159
in the same year yoast maurer and

103
00:03:54,159 --> 00:03:55,040
malarchik

104
00:03:55,040 --> 00:03:56,879
proposed another protocol in the random

105
00:03:56,879 --> 00:03:58,879
oracle model with a security level

106
00:03:58,879 --> 00:04:02,080
somewhere between dv and pr with coin

107
00:04:02,080 --> 00:04:03,200
leakage resilience

108
00:04:03,200 --> 00:04:06,720
after the usage as tv it is only based

109
00:04:06,720 --> 00:04:08,480
on ordinary primitives

110
00:04:08,480 --> 00:04:10,959
button but not as efficient as we will

111
00:04:10,959 --> 00:04:14,000
see later

112
00:04:14,000 --> 00:04:16,279
alvin karate and dodis introduced a

113
00:04:16,279 --> 00:04:18,560
reinterpretation of the single protocol

114
00:04:18,560 --> 00:04:20,399
and the standard model featuring

115
00:04:20,399 --> 00:04:21,680
immediate decryption

116
00:04:21,680 --> 00:04:23,840
the ability to decrypt out-of-order

117
00:04:23,840 --> 00:04:25,040
messages

118
00:04:25,040 --> 00:04:27,280
however their construction only relies

119
00:04:27,280 --> 00:04:29,600
on symmetric crypto during periods

120
00:04:29,600 --> 00:04:31,280
when the direction of the communication

121
00:04:31,280 --> 00:04:33,520
does not change hence there is no post

122
00:04:33,520 --> 00:04:36,560
compromise security for those messages

123
00:04:36,560 --> 00:04:39,680
acd pk is a tweak that incorporates

124
00:04:39,680 --> 00:04:41,520
public key cryptography into those

125
00:04:41,520 --> 00:04:43,360
unidirectional periods

126
00:04:43,360 --> 00:04:47,120
making it post-compromise secure

127
00:04:47,120 --> 00:04:50,080
and finally in 2020 jan and vodaney

128
00:04:50,080 --> 00:04:51,919
designed the so far most efficient

129
00:04:51,919 --> 00:04:52,800
protocol

130
00:04:52,800 --> 00:04:55,199
called encrypted and hash that only

131
00:04:55,199 --> 00:04:56,160
relies on

132
00:04:56,160 --> 00:04:58,880
symmetric primitives and thus offers no

133
00:04:58,880 --> 00:05:02,240
post-compromised security

134
00:05:03,440 --> 00:05:05,280
having reviewed state-of-the-art of

135
00:05:05,280 --> 00:05:07,520
secure messaging protocols

136
00:05:07,520 --> 00:05:10,560
what is the crux so in all proposed

137
00:05:10,560 --> 00:05:11,600
constructions

138
00:05:11,600 --> 00:05:14,000
the users are oblivious to the actual

139
00:05:14,000 --> 00:05:15,120
protocols

140
00:05:15,120 --> 00:05:17,919
active attacks may occur undetected as

141
00:05:17,919 --> 00:05:20,240
communication progresses

142
00:05:20,240 --> 00:05:22,560
additionally there is no way to modulate

143
00:05:22,560 --> 00:05:24,000
the security level

144
00:05:24,000 --> 00:05:26,639
in some scenarios and applications

145
00:05:26,639 --> 00:05:28,720
better performance is warranted at the

146
00:05:28,720 --> 00:05:31,440
cost of reduced security guarantees

147
00:05:31,440 --> 00:05:33,440
the known protocols are either strongly

148
00:05:33,440 --> 00:05:35,120
secure but impractical

149
00:05:35,120 --> 00:05:39,840
or or the other way around

150
00:05:39,919 --> 00:05:42,160
in this paper we propose the following

151
00:05:42,160 --> 00:05:43,680
contributions

152
00:05:43,680 --> 00:05:45,840
first a formal definition of the

153
00:05:45,840 --> 00:05:47,520
security awareness notion

154
00:05:47,520 --> 00:05:50,080
in which users are able to detect active

155
00:05:50,080 --> 00:05:50,960
attacks

156
00:05:50,960 --> 00:05:53,919
by noticing a communication breakdown

157
00:05:53,919 --> 00:05:54,560
meaning

158
00:05:54,560 --> 00:05:56,639
the inability to further send and

159
00:05:56,639 --> 00:05:58,560
receive messages

160
00:05:58,560 --> 00:06:01,120
consequently every acknowledged message

161
00:06:01,120 --> 00:06:03,120
is deemed secure

162
00:06:03,120 --> 00:06:05,520
secondly users can deduce from incoming

163
00:06:05,520 --> 00:06:06,160
messages

164
00:06:06,160 --> 00:06:08,160
which of the outgoing ones were actually

165
00:06:08,160 --> 00:06:09,280
delivered

166
00:06:09,280 --> 00:06:11,360
we call this concept an acknowledgement

167
00:06:11,360 --> 00:06:13,600
extractor

168
00:06:13,600 --> 00:06:16,080
additionally given a transcript of sent

169
00:06:16,080 --> 00:06:17,520
and received messages

170
00:06:17,520 --> 00:06:20,080
alongside potential state exposures we

171
00:06:20,080 --> 00:06:21,360
want to pinpoint

172
00:06:21,360 --> 00:06:23,840
which messages remain private we call

173
00:06:23,840 --> 00:06:27,440
this a cleanness extractor

174
00:06:27,440 --> 00:06:30,240
in practical terms we give a generic

175
00:06:30,240 --> 00:06:32,400
toolbox that allows the composition of

176
00:06:32,400 --> 00:06:34,240
any two protocols with different

177
00:06:34,240 --> 00:06:35,840
security levels

178
00:06:35,840 --> 00:06:37,919
when a strongly secured protocol is

179
00:06:37,919 --> 00:06:39,440
combined with a weaker

180
00:06:39,440 --> 00:06:41,759
but more efficient protocol we obtain

181
00:06:41,759 --> 00:06:45,039
the notion of ratchet on demand

182
00:06:45,039 --> 00:06:47,759
on a similar node a hybrid system of two

183
00:06:47,759 --> 00:06:49,599
identical protocols allows to

184
00:06:49,599 --> 00:06:53,440
re-instantiate broken communication

185
00:06:53,440 --> 00:06:55,360
finally we give a comprehensive

186
00:06:55,360 --> 00:06:57,039
implementation benchmark of

187
00:06:57,039 --> 00:07:00,000
all discussed scenes this includes the

188
00:07:00,000 --> 00:07:01,199
pretering universal

189
00:07:01,199 --> 00:07:03,360
jager and stephanos protocol the

190
00:07:03,360 --> 00:07:06,240
construction by durag and vodney

191
00:07:06,240 --> 00:07:07,840
the protocol by yoast maurer and

192
00:07:07,840 --> 00:07:10,479
malarchik both alban currently and dodis

193
00:07:10,479 --> 00:07:11,520
constructions

194
00:07:11,520 --> 00:07:13,759
and the recent encrypt and hash protocol

195
00:07:13,759 --> 00:07:16,080
bayan and voting

196
00:07:16,080 --> 00:07:17,599
note that some of those constructions

197
00:07:17,599 --> 00:07:19,759
are technically key agreement protocols

198
00:07:19,759 --> 00:07:21,680
however from a security standpoint we

199
00:07:21,680 --> 00:07:25,039
consider them equivalent

200
00:07:27,120 --> 00:07:28,880
before jumping into the meat of the

201
00:07:28,880 --> 00:07:30,560
paper we need to revisit

202
00:07:30,560 --> 00:07:33,680
some general concepts an asynchronous

203
00:07:33,680 --> 00:07:35,680
ratcheted communication protocol with

204
00:07:35,680 --> 00:07:38,240
associated data is a five tuple of

205
00:07:38,240 --> 00:07:41,599
ppt algorithms a setup algorithm that

206
00:07:41,599 --> 00:07:43,199
creates the public parameters

207
00:07:43,199 --> 00:07:46,800
according to some security parameter

208
00:07:46,800 --> 00:07:48,960
a key generation algorithm that creates

209
00:07:48,960 --> 00:07:51,520
a public secret key pair

210
00:07:51,520 --> 00:07:53,759
an initialization algorithm that creates

211
00:07:53,759 --> 00:07:57,120
the initial state of a user

212
00:07:57,120 --> 00:07:58,879
a send routine that produces a

213
00:07:58,879 --> 00:08:02,960
ciphertext and an updated state

214
00:08:02,960 --> 00:08:04,960
and a reception procedure that given a

215
00:08:04,960 --> 00:08:07,280
ciphertext produces the plain text

216
00:08:07,280 --> 00:08:09,919
an updated state and a flag indicating

217
00:08:09,919 --> 00:08:13,199
whether the decryption succeeded

218
00:08:13,199 --> 00:08:15,759
in terms of correctness we demand that

219
00:08:15,759 --> 00:08:18,080
any untempered sequence of wretched sent

220
00:08:18,080 --> 00:08:20,319
and wretched receive calls be permitted

221
00:08:20,319 --> 00:08:22,720
as long as no messages are dropped or a

222
00:08:22,720 --> 00:08:24,560
sequence of messages from a user are

223
00:08:24,560 --> 00:08:26,479
received in a different order

224
00:08:26,479 --> 00:08:28,720
in the form of a correctness game this

225
00:08:28,720 --> 00:08:30,560
means that we have two oracles

226
00:08:30,560 --> 00:08:33,360
a sent and received one that populate a

227
00:08:33,360 --> 00:08:36,320
send and received list for each user

228
00:08:36,320 --> 00:08:38,640
then for any schedule of send and

229
00:08:38,640 --> 00:08:40,640
receive calls we demand

230
00:08:40,640 --> 00:08:43,120
that the received list of each user is

231
00:08:43,120 --> 00:08:44,720
prefixed of the sent list

232
00:08:44,720 --> 00:08:48,000
of its counterpart more formally

233
00:08:48,000 --> 00:08:50,240
we say that a user p is in a matching

234
00:08:50,240 --> 00:08:52,160
status at time t

235
00:08:52,160 --> 00:08:54,560
if at any moment of the game before time

236
00:08:54,560 --> 00:08:56,880
t the received list of the user p

237
00:08:56,880 --> 00:08:59,200
is a prefix of the sent list of the user

238
00:08:59,200 --> 00:09:00,240
p bar

239
00:09:00,240 --> 00:09:02,480
and at any moment of the game before the

240
00:09:02,480 --> 00:09:03,839
time t bar

241
00:09:03,839 --> 00:09:06,080
for the user p bar we demand that his

242
00:09:06,080 --> 00:09:08,080
received list is a prefix

243
00:09:08,080 --> 00:09:11,760
of the cent list of the user p

244
00:09:12,080 --> 00:09:14,080
in order to simplify the analysis of

245
00:09:14,080 --> 00:09:15,680
various security properties we would

246
00:09:15,680 --> 00:09:17,600
like to talk away trivial attacks

247
00:09:17,600 --> 00:09:19,519
for example trivial forgeries after a

248
00:09:19,519 --> 00:09:20,720
state exposure

249
00:09:20,720 --> 00:09:23,279
behind the cleanest predicate see clean

250
00:09:23,279 --> 00:09:24,720
such that the games for the other

251
00:09:24,720 --> 00:09:27,440
security notions become easier to parse

252
00:09:27,440 --> 00:09:29,839
specifically we are interested in forge

253
00:09:29,839 --> 00:09:30,959
security

254
00:09:30,959 --> 00:09:33,920
resistance against forgeries recover

255
00:09:33,920 --> 00:09:34,720
security

256
00:09:34,720 --> 00:09:36,240
detecting a forgery through the

257
00:09:36,240 --> 00:09:38,160
inability to receive further genuine

258
00:09:38,160 --> 00:09:39,680
messages

259
00:09:39,680 --> 00:09:41,760
predict security the inability for an

260
00:09:41,760 --> 00:09:44,000
adversary to guest decipher text

261
00:09:44,000 --> 00:09:46,360
and most importantly in cta security for

262
00:09:46,360 --> 00:09:48,160
confidentiality

263
00:09:48,160 --> 00:09:50,320
having such a predicate simplifies our

264
00:09:50,320 --> 00:09:52,080
games significantly

265
00:09:52,080 --> 00:09:54,480
for example in the forge game diversity

266
00:09:54,480 --> 00:09:56,560
has access to a sentence receive oracle

267
00:09:56,560 --> 00:09:59,040
a state exposure oracle and a plaintext

268
00:09:59,040 --> 00:10:00,480
exposure oracle

269
00:10:00,480 --> 00:10:03,120
and his goal is to make a message accept

270
00:10:03,120 --> 00:10:03,519
by

271
00:10:03,519 --> 00:10:06,240
some user according to some cleanest

272
00:10:06,240 --> 00:10:07,200
predicate

273
00:10:07,200 --> 00:10:09,680
in the r recover game the goal of the

274
00:10:09,680 --> 00:10:12,000
adversary is to create divergence

275
00:10:12,000 --> 00:10:13,680
in the send and receive list of the

276
00:10:13,680 --> 00:10:16,800
users that goes unnoticed

277
00:10:16,800 --> 00:10:19,200
in this ncca game there is an additional

278
00:10:19,200 --> 00:10:20,079
oracle

279
00:10:20,079 --> 00:10:23,120
called challenge where and

280
00:10:23,120 --> 00:10:25,279
where either a random plaintext is

281
00:10:25,279 --> 00:10:26,480
encrypted

282
00:10:26,480 --> 00:10:29,760
or the given one

283
00:10:30,640 --> 00:10:33,440
as already indicated recover security

284
00:10:33,440 --> 00:10:35,040
averts that a user p

285
00:10:35,040 --> 00:10:37,519
continues to accept genuine ciphertext

286
00:10:37,519 --> 00:10:38,959
from its counterpart

287
00:10:38,959 --> 00:10:41,279
after having received the forgery

288
00:10:41,279 --> 00:10:42,000
however

289
00:10:42,000 --> 00:10:44,320
in this scenario the user p bar is still

290
00:10:44,320 --> 00:10:46,000
able to receive messages from

291
00:10:46,000 --> 00:10:50,079
p however we demand a complete breakdown

292
00:10:50,079 --> 00:10:51,200
of communication

293
00:10:51,200 --> 00:10:53,040
communication breakdown should reveal

294
00:10:53,040 --> 00:10:54,640
any forgery and receiving

295
00:10:54,640 --> 00:10:57,120
genuine messages should indicate that no

296
00:10:57,120 --> 00:10:59,760
fortress took place

297
00:10:59,760 --> 00:11:02,560
we capture this with the s recover

298
00:11:02,560 --> 00:11:03,760
security notion

299
00:11:03,760 --> 00:11:05,920
whose game or in whose game the

300
00:11:05,920 --> 00:11:08,640
adversary attempts to make a user accept

301
00:11:08,640 --> 00:11:10,640
a message from another user that has

302
00:11:10,640 --> 00:11:14,320
received a fortune

303
00:11:14,320 --> 00:11:16,880
the combination of recover as recover

304
00:11:16,880 --> 00:11:17,920
and predict

305
00:11:17,920 --> 00:11:19,760
security yields the following very

306
00:11:19,760 --> 00:11:21,360
useful result

307
00:11:21,360 --> 00:11:24,560
if an rcad is or recover as recover and

308
00:11:24,560 --> 00:11:25,920
predicts a cure

309
00:11:25,920 --> 00:11:28,560
whenever p receives a genuine message

310
00:11:28,560 --> 00:11:29,040
from

311
00:11:29,040 --> 00:11:32,480
p bar p is in a matching status except

312
00:11:32,480 --> 00:11:36,079
with negligible probability

313
00:11:36,640 --> 00:11:38,880
in addition to recover security we want

314
00:11:38,880 --> 00:11:40,800
to give a user the power to verify

315
00:11:40,800 --> 00:11:42,000
whether a message has been

316
00:11:42,000 --> 00:11:44,240
accepted by his counterpart and check

317
00:11:44,240 --> 00:11:46,240
whether some cleanest predicate has been

318
00:11:46,240 --> 00:11:48,000
violated

319
00:11:48,000 --> 00:11:51,360
for this let t of p be the chronological

320
00:11:51,360 --> 00:11:54,079
partial transcript of the

321
00:11:54,079 --> 00:11:57,279
up to time t of send receive exposure

322
00:11:57,279 --> 00:11:58,399
and challenge calls

323
00:11:58,399 --> 00:12:00,560
involving the user p alongside the

324
00:12:00,560 --> 00:12:02,240
ciphertext pairs

325
00:12:02,240 --> 00:12:04,880
corresponding to each send and receive

326
00:12:04,880 --> 00:12:06,399
invocation

327
00:12:06,399 --> 00:12:08,639
furthermore let t reg of p be the

328
00:12:08,639 --> 00:12:10,959
transcript that only contains the send

329
00:12:10,959 --> 00:12:14,319
receive and challenge call

330
00:12:14,480 --> 00:12:16,959
in addition to recover security we want

331
00:12:16,959 --> 00:12:19,040
to give a user the power to verify

332
00:12:19,040 --> 00:12:21,040
whether a message has been accepted by

333
00:12:21,040 --> 00:12:22,320
his counterpart

334
00:12:22,320 --> 00:12:23,839
and check whether some cleanest

335
00:12:23,839 --> 00:12:26,079
predicate has been violated

336
00:12:26,079 --> 00:12:29,200
for this let tfp be the chronological

337
00:12:29,200 --> 00:12:32,320
partial transcript up to time t of send

338
00:12:32,320 --> 00:12:33,120
receive

339
00:12:33,120 --> 00:12:36,399
exposure and challenge calls involving p

340
00:12:36,399 --> 00:12:38,720
alongside message pairs corresponding to

341
00:12:38,720 --> 00:12:40,000
each sender and receive

342
00:12:40,000 --> 00:12:43,279
invocation let t reg of p be the

343
00:12:43,279 --> 00:12:45,279
transcript that only contains send

344
00:12:45,279 --> 00:12:48,320
receive and challenge calls

345
00:12:48,320 --> 00:12:50,240
given such a transcript it is rather

346
00:12:50,240 --> 00:12:52,000
simple to define

347
00:12:52,000 --> 00:12:55,360
an acknowledgement extractor so given a

348
00:12:55,360 --> 00:12:56,560
transcript t of p

349
00:12:56,560 --> 00:12:59,040
and the message adct successfully

350
00:12:59,040 --> 00:13:00,000
received by p

351
00:13:00,000 --> 00:13:02,800
at time t that was sent by p bar at the

352
00:13:02,800 --> 00:13:03,360
time t

353
00:13:03,360 --> 00:13:06,320
bar let a d prime and cd prime be the

354
00:13:06,320 --> 00:13:07,839
last message we see for p

355
00:13:07,839 --> 00:13:11,040
bar before time t bar an acknowledgement

356
00:13:11,040 --> 00:13:12,800
extractor is an efficient function

357
00:13:12,800 --> 00:13:16,240
f such that f of t reg of p returns

358
00:13:16,240 --> 00:13:19,360
a d prime and c d prime for any time t

359
00:13:19,360 --> 00:13:23,120
and p is in a matching status

360
00:13:23,120 --> 00:13:24,480
furthermore we can also define a

361
00:13:24,480 --> 00:13:26,959
cleanest extractor so let t

362
00:13:26,959 --> 00:13:31,040
p and t p bar be two partial transcripts

363
00:13:31,040 --> 00:13:33,040
there is a cleanest extractor for c

364
00:13:33,040 --> 00:13:35,279
clean if there is an efficient function

365
00:13:35,279 --> 00:13:36,480
g such that

366
00:13:36,480 --> 00:13:39,600
g given given those two

367
00:13:39,600 --> 00:13:42,240
transcripts has the following properties

368
00:13:42,240 --> 00:13:44,160
there is one challenge in tp

369
00:13:44,160 --> 00:13:46,639
and either p received 80 test and cd

370
00:13:46,639 --> 00:13:47,360
test

371
00:13:47,360 --> 00:13:50,160
or there is a round trip p to p bar to p

372
00:13:50,160 --> 00:13:51,120
starting with p

373
00:13:51,120 --> 00:13:54,959
sending ad test and ct test then g given

374
00:13:54,959 --> 00:13:56,480
those two transcripts

375
00:13:56,480 --> 00:13:59,920
tells us whether the cleanest predicate

376
00:13:59,920 --> 00:14:01,760
has been violated

377
00:14:01,760 --> 00:14:03,440
the reason that we need such a round

378
00:14:03,440 --> 00:14:05,040
trip for an outgoing challenge

379
00:14:05,040 --> 00:14:07,199
message is that it's there is no way to

380
00:14:07,199 --> 00:14:08,720
know whether the challenge message has

381
00:14:08,720 --> 00:14:10,720
actually been correctly received by

382
00:14:10,720 --> 00:14:13,279
pmore

383
00:14:14,000 --> 00:14:15,600
in the following we give a generic

384
00:14:15,600 --> 00:14:17,120
construction that elevates

385
00:14:17,120 --> 00:14:20,320
any secure r card zero into a security

386
00:14:20,320 --> 00:14:20,800
word

387
00:14:20,800 --> 00:14:24,000
aware or card one denoted by

388
00:14:24,000 --> 00:14:27,360
chain of r card zero

389
00:14:28,240 --> 00:14:30,240
intuitively a blockchain-like structure

390
00:14:30,240 --> 00:14:32,160
that contains a hash chain of sent

391
00:14:32,160 --> 00:14:34,160
ciphertexts that is sent alongside

392
00:14:34,160 --> 00:14:36,800
each message suffices to associate each

393
00:14:36,800 --> 00:14:39,839
message to the digest of the chain

394
00:14:39,839 --> 00:14:42,560
for this we define some auxiliary

395
00:14:42,560 --> 00:14:43,760
variables

396
00:14:43,760 --> 00:14:46,639
h-sent is the hash of all sent

397
00:14:46,639 --> 00:14:49,120
ciphertexts computed by the sender and

398
00:14:49,120 --> 00:14:50,800
sent along each message and

399
00:14:50,800 --> 00:14:54,079
updated with a hashing key hk

400
00:14:54,079 --> 00:14:56,320
h received is the hash of all received

401
00:14:56,320 --> 00:14:57,760
cipher texts

402
00:14:57,760 --> 00:15:00,000
also updated of the hashing key upon

403
00:15:00,000 --> 00:15:02,160
every reception

404
00:15:02,160 --> 00:15:04,399
it should be easy to see that h sent and

405
00:15:04,399 --> 00:15:05,279
h received

406
00:15:05,279 --> 00:15:07,680
are enough to ensure or req or recover

407
00:15:07,680 --> 00:15:09,839
security since those two variables

408
00:15:09,839 --> 00:15:11,839
only need to be compared upon every

409
00:15:11,839 --> 00:15:14,079
message reception

410
00:15:14,079 --> 00:15:16,240
however more work is required for

411
00:15:16,240 --> 00:15:17,920
s-recovery security

412
00:15:17,920 --> 00:15:21,120
we define more auxiliary variables

413
00:15:21,120 --> 00:15:23,519
age received is a counter of received

414
00:15:23,519 --> 00:15:25,680
messages that need to be reported in the

415
00:15:25,680 --> 00:15:26,160
next

416
00:15:26,160 --> 00:15:29,040
step call the latest h received is

417
00:15:29,040 --> 00:15:30,959
attached to the message

418
00:15:30,959 --> 00:15:32,800
to acknowledge received messages and

419
00:15:32,800 --> 00:15:35,360
then resets to zero

420
00:15:35,360 --> 00:15:38,240
and then a ascent is a list of hashes of

421
00:15:38,240 --> 00:15:39,600
sent ciphertexts

422
00:15:39,600 --> 00:15:42,399
that are waiting for an acknowledgement

423
00:15:42,399 --> 00:15:44,399
with those two variables

424
00:15:44,399 --> 00:15:46,240
any important impersonation of a

425
00:15:46,240 --> 00:15:48,639
participant leads to an immediate cut in

426
00:15:48,639 --> 00:15:50,480
communication as the intrusion is

427
00:15:50,480 --> 00:15:51,839
detected

428
00:15:51,839 --> 00:15:53,759
so how does such a protocol actually

429
00:15:53,759 --> 00:15:56,240
look like in practice

430
00:15:56,240 --> 00:15:58,639
so we have a setup routine that

431
00:15:58,639 --> 00:16:00,639
generates the public parameters and the

432
00:16:00,639 --> 00:16:01,600
hashing key

433
00:16:01,600 --> 00:16:04,079
and the initialization routine that

434
00:16:04,079 --> 00:16:06,079
initializations the states of the two

435
00:16:06,079 --> 00:16:06,639
users

436
00:16:06,639 --> 00:16:10,720
alongside the auxiliary variables

437
00:16:10,720 --> 00:16:13,199
and then in the send function we attach

438
00:16:13,199 --> 00:16:13,759
the h

439
00:16:13,759 --> 00:16:16,240
send to each message as well as the h

440
00:16:16,240 --> 00:16:18,160
received and update the hsn

441
00:16:18,160 --> 00:16:20,720
variable with with the hash function

442
00:16:20,720 --> 00:16:22,160
then in the receive call

443
00:16:22,160 --> 00:16:24,560
we compare the eight the received h sent

444
00:16:24,560 --> 00:16:26,720
to the age received

445
00:16:26,720 --> 00:16:28,560
and decrypt the message and if it

446
00:16:28,560 --> 00:16:30,800
succeeds we update our h received

447
00:16:30,800 --> 00:16:31,519
variable

448
00:16:31,519 --> 00:16:33,680
with the hashing function and increment

449
00:16:33,680 --> 00:16:37,279
the h received counter

450
00:16:37,279 --> 00:16:39,920
we can now show that if h is a collision

451
00:16:39,920 --> 00:16:41,519
resistant hash function

452
00:16:41,519 --> 00:16:44,000
our chain archives construction is

453
00:16:44,000 --> 00:16:45,120
recover secure

454
00:16:45,120 --> 00:16:49,360
for both recover and s recover security

455
00:16:49,360 --> 00:16:51,199
it's also easy to see that our

456
00:16:51,199 --> 00:16:52,959
construction has an acknowledgement

457
00:16:52,959 --> 00:16:55,120
extractor

458
00:16:55,120 --> 00:16:57,600
furthermore we can also show that our

459
00:16:57,600 --> 00:16:58,480
chain archive

460
00:16:58,480 --> 00:17:01,120
scheme has a kleenex extractor for a

461
00:17:01,120 --> 00:17:02,880
group of cleanest predicates

462
00:17:02,880 --> 00:17:04,400
for the full definition of those

463
00:17:04,400 --> 00:17:06,720
predicates i refer the listener

464
00:17:06,720 --> 00:17:10,000
to the full paper and finally we can

465
00:17:10,000 --> 00:17:11,599
show that if arccat zero

466
00:17:11,599 --> 00:17:14,079
is predict secure then our chain archive

467
00:17:14,079 --> 00:17:14,880
construction

468
00:17:14,880 --> 00:17:19,359
is also predict secure

469
00:17:19,359 --> 00:17:21,439
we move on to the notion of on-demand

470
00:17:21,439 --> 00:17:23,439
ratcheting where we combine a strongly

471
00:17:23,439 --> 00:17:24,559
secured protocol

472
00:17:24,559 --> 00:17:26,640
using public key cryptography with a

473
00:17:26,640 --> 00:17:28,720
weaker protocol that is only based on

474
00:17:28,720 --> 00:17:30,080
symmetric primitives

475
00:17:30,080 --> 00:17:32,559
that is more efficient the weaker

476
00:17:32,559 --> 00:17:33,200
protocol

477
00:17:33,200 --> 00:17:35,840
is used for frequent exchanges where no

478
00:17:35,840 --> 00:17:38,080
post-compromise security is guaranteed

479
00:17:38,080 --> 00:17:40,160
and the strong protocol is engaged

480
00:17:40,160 --> 00:17:41,840
periodically

481
00:17:41,840 --> 00:17:43,520
for example ratcheting could be

482
00:17:43,520 --> 00:17:45,760
administered at the application level or

483
00:17:45,760 --> 00:17:48,480
even by the users themselves

484
00:17:48,480 --> 00:17:51,440
for this we denote by archived main the

485
00:17:51,440 --> 00:17:52,480
strong protocol

486
00:17:52,480 --> 00:17:56,720
and by archives of the weak protocol

487
00:17:56,720 --> 00:17:58,640
the composition of arcade main and

488
00:17:58,640 --> 00:18:01,200
orchid soft we call a hybrid

489
00:18:01,200 --> 00:18:03,919
and we instigate a ratcheting execution

490
00:18:03,919 --> 00:18:05,440
with a flag that is sent

491
00:18:05,440 --> 00:18:09,679
alongside the associated data

492
00:18:10,320 --> 00:18:12,320
our protocol proceeds in so-called

493
00:18:12,320 --> 00:18:14,000
epochs a concept that first

494
00:18:14,000 --> 00:18:15,600
appeared in the puttering adversary

495
00:18:15,600 --> 00:18:17,600
protocol intuitively

496
00:18:17,600 --> 00:18:20,000
an epoch designates a batch of sent and

497
00:18:20,000 --> 00:18:21,440
received messages

498
00:18:21,440 --> 00:18:23,280
until the direction of communication

499
00:18:23,280 --> 00:18:25,120
changes

500
00:18:25,120 --> 00:18:28,160
for this each user stores two counters

501
00:18:28,160 --> 00:18:31,200
e-sent and e-receive indicating the

502
00:18:31,200 --> 00:18:32,720
epack of the last sent

503
00:18:32,720 --> 00:18:35,760
and received message an epic counter is

504
00:18:35,760 --> 00:18:38,320
also sent alongside each message

505
00:18:38,320 --> 00:18:41,200
so here an apple counter e of m is equal

506
00:18:41,200 --> 00:18:42,240
to e send

507
00:18:42,240 --> 00:18:45,360
if e received is smaller than e sent

508
00:18:45,360 --> 00:18:50,080
or equal to e received plus 1 otherwise

509
00:18:50,400 --> 00:18:52,400
how does this look like in an example so

510
00:18:52,400 --> 00:18:54,160
here in this example

511
00:18:54,160 --> 00:18:56,320
user a starts off with a batch of

512
00:18:56,320 --> 00:18:58,240
messages that are sent to b

513
00:18:58,240 --> 00:19:00,320
and b responds with an incremented

514
00:19:00,320 --> 00:19:01,840
message epoch

515
00:19:01,840 --> 00:19:05,760
a response again but this time

516
00:19:05,760 --> 00:19:08,080
the message of a crosses an earlier

517
00:19:08,080 --> 00:19:09,200
message of e

518
00:19:09,200 --> 00:19:11,760
so in the following response to this

519
00:19:11,760 --> 00:19:12,720
message by a

520
00:19:12,720 --> 00:19:16,720
the apoc counter is not incremented

521
00:19:18,640 --> 00:19:20,640
in addition to the epoch counters each

522
00:19:20,640 --> 00:19:22,559
user keeps count of the number of

523
00:19:22,559 --> 00:19:25,039
messages within one epic

524
00:19:25,039 --> 00:19:28,000
so from a high level perspective each

525
00:19:28,000 --> 00:19:29,360
orcad main call

526
00:19:29,360 --> 00:19:32,320
creates a new arcade sub send and

527
00:19:32,320 --> 00:19:33,520
receive state

528
00:19:33,520 --> 00:19:35,679
the sender stores the send state in an

529
00:19:35,679 --> 00:19:38,000
array and transmits the receive state in

530
00:19:38,000 --> 00:19:40,799
the cipher text

531
00:19:40,799 --> 00:19:42,960
so how does our protocol actually look

532
00:19:42,960 --> 00:19:44,160
like the setup

533
00:19:44,160 --> 00:19:46,160
and initialization routines are very

534
00:19:46,160 --> 00:19:48,720
similar to the security or constructor

535
00:19:48,720 --> 00:19:49,200
for

536
00:19:49,200 --> 00:19:51,600
construction from before in the

537
00:19:51,600 --> 00:19:53,840
initialization function we create arcade

538
00:19:53,840 --> 00:19:55,360
main state for each user

539
00:19:55,360 --> 00:19:58,240
and initialize their epoch counters and

540
00:19:58,240 --> 00:19:59,840
arrays

541
00:19:59,840 --> 00:20:02,320
in the send routine we first check if

542
00:20:02,320 --> 00:20:04,480
you want to actually instigate a

543
00:20:04,480 --> 00:20:07,679
ratcheting call if so we first create a

544
00:20:07,679 --> 00:20:08,880
new architect sub

545
00:20:08,880 --> 00:20:12,000
uh send and receive state we keep the

546
00:20:12,000 --> 00:20:12,799
send state

547
00:20:12,799 --> 00:20:14,720
but pack the receive state into the

548
00:20:14,720 --> 00:20:16,799
ciphertext and encrypt it with the arc

549
00:20:16,799 --> 00:20:18,559
with arcade main

550
00:20:18,559 --> 00:20:20,320
otherwise if we don't want to ratchet we

551
00:20:20,320 --> 00:20:22,640
simply use our catsup for the ciphertext

552
00:20:22,640 --> 00:20:23,840
creation

553
00:20:23,840 --> 00:20:26,159
note that the very first message of a

554
00:20:26,159 --> 00:20:27,039
communication

555
00:20:27,039 --> 00:20:30,000
is necessarily a ratcheting call since

556
00:20:30,000 --> 00:20:32,240
no orcad stop states are created in the

557
00:20:32,240 --> 00:20:35,600
initialization function

558
00:20:35,600 --> 00:20:38,480
then the corresponding receive function

559
00:20:38,480 --> 00:20:39,120
we first

560
00:20:39,120 --> 00:20:42,080
check if a registering call has been

561
00:20:42,080 --> 00:20:44,480
demanded if so we use arcade main for

562
00:20:44,480 --> 00:20:45,440
the decryption

563
00:20:45,440 --> 00:20:49,840
otherwise we simply use architect

564
00:20:51,840 --> 00:20:54,320
we can show that we can derive the

565
00:20:54,320 --> 00:20:56,480
security of our hybrid construction

566
00:20:56,480 --> 00:20:58,559
directly from the security properties of

567
00:20:58,559 --> 00:21:00,880
the sub-protocols mainly arcade main

568
00:21:00,880 --> 00:21:04,000
and arcade sub furthermore

569
00:21:04,000 --> 00:21:06,000
if the two protocols are actually

570
00:21:06,000 --> 00:21:08,240
identical so if parker domain is equal

571
00:21:08,240 --> 00:21:09,600
to orca sub

572
00:21:09,600 --> 00:21:12,080
then we can use arcade main to generate

573
00:21:12,080 --> 00:21:14,480
a new archived subsession

574
00:21:14,480 --> 00:21:16,400
whenever we want so making it possible

575
00:21:16,400 --> 00:21:18,960
to restore a broken communication

576
00:21:18,960 --> 00:21:21,919
in our catsup

577
00:21:22,720 --> 00:21:24,559
for the last part of this presentation

578
00:21:24,559 --> 00:21:26,640
we move on to the benchmarks

579
00:21:26,640 --> 00:21:28,840
so we implemented the discussed

580
00:21:28,840 --> 00:21:30,559
protocols

581
00:21:30,559 --> 00:21:34,080
on a comparable on a machine comparable

582
00:21:34,080 --> 00:21:35,679
to a high-end smartphone

583
00:21:35,679 --> 00:21:38,400
in three different scenarios first we

584
00:21:38,400 --> 00:21:41,919
looked at alternating traffic so

585
00:21:41,919 --> 00:21:44,720
a and the users a and b take alternating

586
00:21:44,720 --> 00:21:45,440
terms and

587
00:21:45,440 --> 00:21:48,559
sending and receiving messages

588
00:21:48,559 --> 00:21:50,880
then we looked at unidirectional traffic

589
00:21:50,880 --> 00:21:52,320
so first

590
00:21:52,320 --> 00:21:54,640
user a sends n messages that are

591
00:21:54,640 --> 00:21:56,080
received by user b

592
00:21:56,080 --> 00:21:59,039
and then user b proceeds to send his

593
00:21:59,039 --> 00:22:00,640
share of n messages

594
00:22:00,640 --> 00:22:02,799
and finally we looked at something

595
00:22:02,799 --> 00:22:04,720
similar called a deferred and

596
00:22:04,720 --> 00:22:06,240
unidirectional traffic

597
00:22:06,240 --> 00:22:09,440
which starts off by a sending

598
00:22:09,440 --> 00:22:12,480
n messages but before p receives those

599
00:22:12,480 --> 00:22:13,120
messages

600
00:22:13,120 --> 00:22:16,720
he sends his share of messages

601
00:22:16,720 --> 00:22:19,360
what can we conclude from those free

602
00:22:19,360 --> 00:22:19,919
message

603
00:22:19,919 --> 00:22:22,559
or traffic scenarios first we look at

604
00:22:22,559 --> 00:22:24,320
alternating traffic

605
00:22:24,320 --> 00:22:27,360
so it is dominated of course by the eth

606
00:22:27,360 --> 00:22:29,200
construction by yarn and vodaner which

607
00:22:29,200 --> 00:22:31,520
doesn't use any public key cryptography

608
00:22:31,520 --> 00:22:33,760
we also see that the two schemes which

609
00:22:33,760 --> 00:22:36,000
are relying on hides

610
00:22:36,000 --> 00:22:38,240
are significantly less efficient than

611
00:22:38,240 --> 00:22:40,559
the other schemes relying on

612
00:22:40,559 --> 00:22:44,080
symmetric and public key cryptography

613
00:22:44,080 --> 00:22:45,919
a similar thing is true for

614
00:22:45,919 --> 00:22:48,480
unidirectional traffic

615
00:22:48,480 --> 00:22:50,400
however if you look at deferred unit

616
00:22:50,400 --> 00:22:52,799
actual traffic we see that the jmm

617
00:22:52,799 --> 00:22:55,520
protocol so the protocol by used mounted

618
00:22:55,520 --> 00:22:57,440
on mularchik actually has a hidden

619
00:22:57,440 --> 00:22:59,600
complexity when it comes to this

620
00:22:59,600 --> 00:23:04,399
type of traffic

621
00:23:05,679 --> 00:23:07,440
and with this slide i conclude my

622
00:23:07,440 --> 00:23:09,840
presentation

