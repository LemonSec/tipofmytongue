1
00:00:00,799 --> 00:00:03,199
hi my name is thank you seni

2
00:00:03,199 --> 00:00:05,839
in this talk i will present our paper

3
00:00:05,839 --> 00:00:07,040
mass triplets

4
00:00:07,040 --> 00:00:10,080
amortizing multiplication triples across

5
00:00:10,080 --> 00:00:12,880
conditionals this work was done by

6
00:00:12,880 --> 00:00:14,080
myself

7
00:00:14,080 --> 00:00:16,640
david heath and vodko lesnikov and we

8
00:00:16,640 --> 00:00:17,279
work at

9
00:00:17,279 --> 00:00:21,680
georgia tech in atlanta georgia

10
00:00:21,680 --> 00:00:24,000
in this work i will be discussing a

11
00:00:24,000 --> 00:00:26,560
classic secure multi-party computation

12
00:00:26,560 --> 00:00:27,599
protocol

13
00:00:27,599 --> 00:00:30,080
which uses pre-processed multiplication

14
00:00:30,080 --> 00:00:30,880
triples

15
00:00:30,880 --> 00:00:33,280
to evaluate arbitrary functions

16
00:00:33,280 --> 00:00:36,000
represented as boolean circuits

17
00:00:36,000 --> 00:00:38,399
a boolean circuit consists of non-linear

18
00:00:38,399 --> 00:00:39,440
and gates

19
00:00:39,440 --> 00:00:42,000
and linear xor gates the circuit is

20
00:00:42,000 --> 00:00:45,360
evaluated gateway gate under encryption

21
00:00:45,360 --> 00:00:47,840
while evaluating the linear exergates is

22
00:00:47,840 --> 00:00:49,520
essentially free

23
00:00:49,520 --> 00:00:51,920
the non-linear and gates require the use

24
00:00:51,920 --> 00:00:52,879
of costly

25
00:00:52,879 --> 00:00:56,480
interactive primitives more specifically

26
00:00:56,480 --> 00:00:58,559
and gates are evaluated with beaver

27
00:00:58,559 --> 00:01:02,239
triples which are expensive to generate

28
00:01:02,239 --> 00:01:04,640
in our work we reduce the cost

29
00:01:04,640 --> 00:01:06,159
associated with generating

30
00:01:06,159 --> 00:01:08,320
multiplication triples

31
00:01:08,320 --> 00:01:10,880
our improvement results in significant

32
00:01:10,880 --> 00:01:11,760
improvement

33
00:01:11,760 --> 00:01:14,479
to both communication and run time of

34
00:01:14,479 --> 00:01:17,920
the triple based protocol

35
00:01:18,000 --> 00:01:20,240
we improved the protocol by carefully

36
00:01:20,240 --> 00:01:22,320
reusing multiplication triples in

37
00:01:22,320 --> 00:01:23,920
conditional statements

38
00:01:23,920 --> 00:01:27,040
of the source program hence if a program

39
00:01:27,040 --> 00:01:29,600
has an if or a switch statement

40
00:01:29,600 --> 00:01:31,920
we can take advantage of the fact that

41
00:01:31,920 --> 00:01:33,759
only one of the branches is

42
00:01:33,759 --> 00:01:37,040
actually evaluated traditionally

43
00:01:37,040 --> 00:01:38,880
it has been assumed that we need

44
00:01:38,880 --> 00:01:40,560
multiplication triples

45
00:01:40,560 --> 00:01:43,200
for all branches in a conditional this

46
00:01:43,200 --> 00:01:44,799
was because we need to ensure

47
00:01:44,799 --> 00:01:47,680
security and each multiplication triple

48
00:01:47,680 --> 00:01:49,280
can be used to evaluate

49
00:01:49,280 --> 00:01:52,880
at most one hand gate in this work

50
00:01:52,880 --> 00:01:55,439
we showed that this is unnecessary and

51
00:01:55,439 --> 00:01:56,799
the number of triples

52
00:01:56,799 --> 00:02:00,240
we need is proportional only to the size

53
00:02:00,240 --> 00:02:01,280
of the single

54
00:02:01,280 --> 00:02:05,200
longest branch prior work

55
00:02:05,200 --> 00:02:07,439
has looked into conditional branching

56
00:02:07,439 --> 00:02:08,399
improvements

57
00:02:08,399 --> 00:02:12,080
under other protocols stock garbling

58
00:02:12,080 --> 00:02:14,800
is a line of research that has looked

59
00:02:14,800 --> 00:02:17,280
into the conditional branching problem

60
00:02:17,280 --> 00:02:19,920
in the yao scarborough circuit so in the

61
00:02:19,920 --> 00:02:23,040
two-party setting the first work

62
00:02:23,040 --> 00:02:25,040
to achieve significant conditional

63
00:02:25,040 --> 00:02:26,640
branching improvements

64
00:02:26,640 --> 00:02:29,920
in the multi-party setting was motif

65
00:02:29,920 --> 00:02:32,959
a work done by myself david heath and

66
00:02:32,959 --> 00:02:34,480
vlad kolesnikov

67
00:02:34,480 --> 00:02:38,480
and was presented at asia crypt 2020

68
00:02:38,480 --> 00:02:41,599
motif worked with the gmw protocol

69
00:02:41,599 --> 00:02:44,480
a protocol closely related to the triple

70
00:02:44,480 --> 00:02:45,760
based protocol

71
00:02:45,760 --> 00:02:48,800
in that both protocols evaluate boolean

72
00:02:48,800 --> 00:02:49,760
circuits

73
00:02:49,760 --> 00:02:52,560
work for any number of parties and are

74
00:02:52,560 --> 00:02:56,080
secure against this honest maturity

75
00:02:56,080 --> 00:02:58,720
our approach thus works in a similar

76
00:02:58,720 --> 00:03:00,640
setting to motif

77
00:03:00,640 --> 00:03:03,920
however our solution is distinct and

78
00:03:03,920 --> 00:03:05,920
yields a significant conditional

79
00:03:05,920 --> 00:03:06,879
improvement

80
00:03:06,879 --> 00:03:10,000
over motif i will now elaborate

81
00:03:10,000 --> 00:03:13,920
on motifs limitations

82
00:03:13,920 --> 00:03:16,959
the key cost in the gmw protocol

83
00:03:16,959 --> 00:03:19,280
is pre-computing random oblivious

84
00:03:19,280 --> 00:03:20,239
transfers

85
00:03:20,239 --> 00:03:22,400
which are then used to evaluate the

86
00:03:22,400 --> 00:03:24,640
circuits and gates

87
00:03:24,640 --> 00:03:28,400
oblivious transfers or shortly ots

88
00:03:28,400 --> 00:03:31,360
are expensive public key primitives and

89
00:03:31,360 --> 00:03:32,000
motifs

90
00:03:32,000 --> 00:03:35,760
improvement stems from amortizing ots

91
00:03:35,760 --> 00:03:40,319
across conditional branches in gmw

92
00:03:40,319 --> 00:03:43,000
all available and gates are computed

93
00:03:43,000 --> 00:03:45,440
simultaneously in layers

94
00:03:45,440 --> 00:03:48,879
at any time only the and gates whose

95
00:03:48,879 --> 00:03:51,599
input shares have already been computed

96
00:03:51,599 --> 00:03:53,439
are evaluated

97
00:03:53,439 --> 00:03:56,480
motives limitation is that it cannot

98
00:03:56,480 --> 00:04:00,239
amortize ots in future layer and gates

99
00:04:00,239 --> 00:04:03,280
in each layer of gmw computation

100
00:04:03,280 --> 00:04:06,879
one can amortize ots only over the ready

101
00:04:06,879 --> 00:04:08,159
gates

102
00:04:08,159 --> 00:04:11,360
thus motives improvement is dependent on

103
00:04:11,360 --> 00:04:14,000
the conditionals branch alignment

104
00:04:14,000 --> 00:04:16,160
meaning the branches need to have a

105
00:04:16,160 --> 00:04:18,320
similar number of and gates in each

106
00:04:18,320 --> 00:04:19,519
circuit layer

107
00:04:19,519 --> 00:04:22,880
for optimal performance in the sample

108
00:04:22,880 --> 00:04:24,000
conditional

109
00:04:24,000 --> 00:04:26,840
i show two layers both of which are

110
00:04:26,840 --> 00:04:28,479
unaligned

111
00:04:28,479 --> 00:04:31,280
in this conditional motif would pay the

112
00:04:31,280 --> 00:04:33,280
cost of four and gates

113
00:04:33,280 --> 00:04:36,240
while the longest branch has only three

114
00:04:36,240 --> 00:04:37,520
and gates

115
00:04:37,520 --> 00:04:40,639
thus the example conditional is not

116
00:04:40,639 --> 00:04:44,240
an ideal fit for motifs protocol

117
00:04:44,240 --> 00:04:47,280
our work shows this limitation of motif

118
00:04:47,280 --> 00:04:50,960
can be quite significant

119
00:04:51,440 --> 00:04:54,560
our new work is called mask triples and

120
00:04:54,560 --> 00:04:55,759
the benefit is

121
00:04:55,759 --> 00:04:59,199
that our improved protocol truly pays

122
00:04:59,199 --> 00:05:02,000
only for the longest conditional branch

123
00:05:02,000 --> 00:05:05,280
independently of the branch alignment

124
00:05:05,280 --> 00:05:08,400
recall that masked triples improves the

125
00:05:08,400 --> 00:05:10,080
triple base protocol

126
00:05:10,080 --> 00:05:12,800
which is closely related to the gmw

127
00:05:12,800 --> 00:05:14,479
protocol

128
00:05:14,479 --> 00:05:17,600
similarly to motif we reduce the number

129
00:05:17,600 --> 00:05:17,840
of

130
00:05:17,840 --> 00:05:21,440
expensive random ots in the triple bass

131
00:05:21,440 --> 00:05:22,560
protocol

132
00:05:22,560 --> 00:05:24,960
random ots are one way to generate

133
00:05:24,960 --> 00:05:26,880
multiplication triples

134
00:05:26,880 --> 00:05:29,360
which we amortize across conditional

135
00:05:29,360 --> 00:05:30,720
branches

136
00:05:30,720 --> 00:05:33,680
unlike in motif the number of ots we

137
00:05:33,680 --> 00:05:34,960
need to generate

138
00:05:34,960 --> 00:05:37,120
is proportional to the size of the

139
00:05:37,120 --> 00:05:39,919
longest conditional branch

140
00:05:39,919 --> 00:05:42,639
so i have introduced the key idea of our

141
00:05:42,639 --> 00:05:44,080
improvement

142
00:05:44,080 --> 00:05:46,479
now in order to get into the technical

143
00:05:46,479 --> 00:05:48,479
aspects of our improvement

144
00:05:48,479 --> 00:05:51,280
i briefly review how triple bass

145
00:05:51,280 --> 00:05:54,000
protocol works

146
00:05:54,000 --> 00:05:56,479
the triple bass protocol evaluates an

147
00:05:56,479 --> 00:05:59,600
arbitrary boolean function in four steps

148
00:05:59,600 --> 00:06:01,680
first the function is represented as a

149
00:06:01,680 --> 00:06:03,280
boolean circuit

150
00:06:03,280 --> 00:06:05,600
next the party secret share their input

151
00:06:05,600 --> 00:06:08,240
bits and send the appropriate shares to

152
00:06:08,240 --> 00:06:09,600
other parties

153
00:06:09,600 --> 00:06:11,520
then all parties step through the

154
00:06:11,520 --> 00:06:13,039
circuit gate by gate

155
00:06:13,039 --> 00:06:15,840
and ensure they hold a valid xor secret

156
00:06:15,840 --> 00:06:17,280
share of the true bit

157
00:06:17,280 --> 00:06:20,880
on each wire after evaluating all gates

158
00:06:20,880 --> 00:06:23,840
the parties reconstruct the output let's

159
00:06:23,840 --> 00:06:25,520
start with a simple circuit

160
00:06:25,520 --> 00:06:27,840
for simplicity we consider only two

161
00:06:27,840 --> 00:06:29,680
parties alice and bob

162
00:06:29,680 --> 00:06:31,520
but the extension to any number of

163
00:06:31,520 --> 00:06:33,440
parties is straightforward

164
00:06:33,440 --> 00:06:35,680
the circuit on this slide consists of a

165
00:06:35,680 --> 00:06:38,240
single and gate and a single xor gate

166
00:06:38,240 --> 00:06:42,479
alice holds input x and bubbles input y

167
00:06:42,479 --> 00:06:46,319
alice secretary input x into x1 and x2

168
00:06:46,319 --> 00:06:48,560
symmetrically bob secret shares his

169
00:06:48,560 --> 00:06:50,000
input y

170
00:06:50,000 --> 00:06:52,880
then alice sends x2 to bob and bob sends

171
00:06:52,880 --> 00:06:55,520
y1 to alice

172
00:06:55,520 --> 00:06:57,599
alice and bob know each hold one extra

173
00:06:57,599 --> 00:07:00,479
share of x and one extra share of y

174
00:07:00,479 --> 00:07:03,039
note that the y with input 1 can be

175
00:07:03,039 --> 00:07:05,280
trivially secret shared by alice setting

176
00:07:05,280 --> 00:07:06,479
her share to 1

177
00:07:06,479 --> 00:07:10,160
and bob setting his share to zero

178
00:07:10,160 --> 00:07:12,400
alice and bob next evaluate the circuit

179
00:07:12,400 --> 00:07:13,360
gate by gate

180
00:07:13,360 --> 00:07:15,440
and complete valid exercise on the

181
00:07:15,440 --> 00:07:18,880
output wires of all gates

182
00:07:18,880 --> 00:07:20,880
the last step is to reconstruct the

183
00:07:20,880 --> 00:07:23,599
output alice and bob send to one another

184
00:07:23,599 --> 00:07:25,199
their share of the output

185
00:07:25,199 --> 00:07:28,720
and compute x y xor 1. so i have

186
00:07:28,720 --> 00:07:30,720
explained how a boolean circuit is

187
00:07:30,720 --> 00:07:33,360
evaluated in the triple base protocol

188
00:07:33,360 --> 00:07:35,759
and now i will demonstrate how each gate

189
00:07:35,759 --> 00:07:37,680
is evaluated

190
00:07:37,680 --> 00:07:40,560
exor gates are virtually free and are

191
00:07:40,560 --> 00:07:44,000
evaluated locally without interaction

192
00:07:44,000 --> 00:07:47,919
alice and bob simply add their shares

193
00:07:47,919 --> 00:07:51,440
unlike xor gates n gates are expensive

194
00:07:51,440 --> 00:07:54,160
since they require the use of expensive

195
00:07:54,160 --> 00:07:56,879
and interactive primitives

196
00:07:56,879 --> 00:07:59,520
the key idea due to beaver is that if

197
00:07:59,520 --> 00:08:02,080
you have a way to compute a random and

198
00:08:02,080 --> 00:08:02,720
gate

199
00:08:02,720 --> 00:08:04,879
you can then perform cheap linear

200
00:08:04,879 --> 00:08:05,840
arithmetic

201
00:08:05,840 --> 00:08:08,960
and some cheap broadcasts to compute any

202
00:08:08,960 --> 00:08:10,319
and gate

203
00:08:10,319 --> 00:08:12,000
these random and gates are the

204
00:08:12,000 --> 00:08:13,840
multiplication triples

205
00:08:13,840 --> 00:08:17,120
and are expensive we thus

206
00:08:17,120 --> 00:08:20,000
separate and gate evaluation into two

207
00:08:20,000 --> 00:08:21,039
steps

208
00:08:21,039 --> 00:08:24,080
a pre-processing step where a triple is

209
00:08:24,080 --> 00:08:25,280
generated

210
00:08:25,280 --> 00:08:28,160
and an evaluation step where the triple

211
00:08:28,160 --> 00:08:28,960
is used

212
00:08:28,960 --> 00:08:31,599
alongside linear arithmetic and bit

213
00:08:31,599 --> 00:08:32,719
broadcasts

214
00:08:32,719 --> 00:08:36,080
to compute the and gate

215
00:08:36,080 --> 00:08:38,880
first let's look at the first step that

216
00:08:38,880 --> 00:08:39,440
is

217
00:08:39,440 --> 00:08:42,080
pre-processing a triple which means

218
00:08:42,080 --> 00:08:44,720
computing a random and gate

219
00:08:44,720 --> 00:08:48,000
in this step the parties throw two bits

220
00:08:48,000 --> 00:08:51,200
a and b uniformly and compute their

221
00:08:51,200 --> 00:08:52,320
product

222
00:08:52,320 --> 00:08:54,959
the output is a uniform sharing of the

223
00:08:54,959 --> 00:08:56,959
product

224
00:08:56,959 --> 00:08:59,600
this is achieved by each party uniformly

225
00:08:59,600 --> 00:09:00,160
drawing

226
00:09:00,160 --> 00:09:03,920
a bid for their share of a and b

227
00:09:03,920 --> 00:09:06,720
these shares are then input to an mpc

228
00:09:06,720 --> 00:09:07,600
protocol

229
00:09:07,600 --> 00:09:10,399
which outputs the share of the product a

230
00:09:10,399 --> 00:09:10,959
b

231
00:09:10,959 --> 00:09:14,160
to each party the npc protocol

232
00:09:14,160 --> 00:09:19,200
can be for example a single gmw nk

233
00:09:19,200 --> 00:09:22,080
the point is that the mpc protocol

234
00:09:22,080 --> 00:09:24,080
requires communication

235
00:09:24,080 --> 00:09:27,360
and is expensive

236
00:09:27,440 --> 00:09:29,920
now that we have pre-processed a triple

237
00:09:29,920 --> 00:09:32,640
we are ready to evaluate the and gate

238
00:09:32,640 --> 00:09:35,600
we input the pre-process triple that is

239
00:09:35,600 --> 00:09:36,480
the bits

240
00:09:36,480 --> 00:09:39,680
a and b and their product a b

241
00:09:39,680 --> 00:09:43,040
as well as the actual and gate inputs x

242
00:09:43,040 --> 00:09:46,240
and y we then use cheap linear

243
00:09:46,240 --> 00:09:47,360
arithmetic

244
00:09:47,360 --> 00:09:50,240
and broadcast two bits to get a sharing

245
00:09:50,240 --> 00:09:51,600
of the output

246
00:09:51,600 --> 00:09:55,040
z this is a well-known protocol

247
00:09:55,040 --> 00:09:58,240
to see the algebraic details please see

248
00:09:58,240 --> 00:10:00,720
our paper

249
00:10:00,720 --> 00:10:03,440
we have shown how to evaluate an n gate

250
00:10:03,440 --> 00:10:04,000
let's now

251
00:10:04,000 --> 00:10:06,480
analyze the cost of an and gate the

252
00:10:06,480 --> 00:10:08,320
evaluation phase is cheap

253
00:10:08,320 --> 00:10:12,720
and requires broadcasting only two bits

254
00:10:12,720 --> 00:10:14,959
the pre-processing phase is much more

255
00:10:14,959 --> 00:10:17,120
involved if we generate triples with a

256
00:10:17,120 --> 00:10:18,720
gmw and gate

257
00:10:18,720 --> 00:10:20,959
we will need to compute two ots in the

258
00:10:20,959 --> 00:10:22,560
two-party setting

259
00:10:22,560 --> 00:10:24,480
recall that ots are asymmetric

260
00:10:24,480 --> 00:10:25,839
primitives and thus

261
00:10:25,839 --> 00:10:28,640
are expensive if we generate otis with

262
00:10:28,640 --> 00:10:30,000
the ot extension of

263
00:10:30,000 --> 00:10:32,360
ishikali and the and petrang from

264
00:10:32,360 --> 00:10:34,000
crypto003

265
00:10:34,000 --> 00:10:35,920
each one bit multiplication costs

266
00:10:35,920 --> 00:10:37,760
communication on the order of the

267
00:10:37,760 --> 00:10:40,160
computational security parameter

268
00:10:40,160 --> 00:10:44,320
kappa which is usually 128 bits

269
00:10:44,320 --> 00:10:46,480
we add that recent advancements have

270
00:10:46,480 --> 00:10:48,880
shown that oblivious transfers can be

271
00:10:48,880 --> 00:10:50,959
extended without the expensive vigor of

272
00:10:50,959 --> 00:10:52,240
kappa communication

273
00:10:52,240 --> 00:10:55,200
overhead however these work still

274
00:10:55,200 --> 00:10:56,800
require the parties to perform

275
00:10:56,800 --> 00:10:58,640
significant computation

276
00:10:58,640 --> 00:11:00,720
to generate the correlated randomness

277
00:11:00,720 --> 00:11:02,720
associated with ots

278
00:11:02,720 --> 00:11:05,440
while we stress communication reduction

279
00:11:05,440 --> 00:11:06,480
more generally

280
00:11:06,480 --> 00:11:08,560
we simply reduce the number of needed

281
00:11:08,560 --> 00:11:09,680
ots

282
00:11:09,680 --> 00:11:11,760
thus even when using these new and

283
00:11:11,760 --> 00:11:13,200
powerful primitives

284
00:11:13,200 --> 00:11:15,600
it is worthwhile to use our approach in

285
00:11:15,600 --> 00:11:17,519
order to decrease computation

286
00:11:17,519 --> 00:11:19,600
consumption

287
00:11:19,600 --> 00:11:21,680
i have demonstrated that generating

288
00:11:21,680 --> 00:11:23,040
triples for and gate

289
00:11:23,040 --> 00:11:26,160
evaluation is expensive hence we would

290
00:11:26,160 --> 00:11:28,320
like to reduce the number of triples

291
00:11:28,320 --> 00:11:31,360
needed in the protocol let's consider a

292
00:11:31,360 --> 00:11:32,640
conditional with n

293
00:11:32,640 --> 00:11:35,680
branches and n and gates across all

294
00:11:35,680 --> 00:11:36,959
branches

295
00:11:36,959 --> 00:11:39,120
normally we would need to generate n

296
00:11:39,120 --> 00:11:40,320
distinct triples

297
00:11:40,320 --> 00:11:43,120
that is one triple per and gate this is

298
00:11:43,120 --> 00:11:44,720
because the triple values

299
00:11:44,720 --> 00:11:47,519
a and b are essentially one time paths

300
00:11:47,519 --> 00:11:50,480
on clear text values in the circuit

301
00:11:50,480 --> 00:11:52,560
thus if we use a triple for two

302
00:11:52,560 --> 00:11:53,760
different m gates

303
00:11:53,760 --> 00:11:57,120
we violate security we would like to be

304
00:11:57,120 --> 00:11:59,600
able to generate a single triple for all

305
00:11:59,600 --> 00:12:00,399
these and

306
00:12:00,399 --> 00:12:02,880
hand gates but we need to take care to

307
00:12:02,880 --> 00:12:03,440
do it

308
00:12:03,440 --> 00:12:07,760
securely so if we are able to securely

309
00:12:07,760 --> 00:12:10,480
reuse a triple on and gates across

310
00:12:10,480 --> 00:12:13,519
all branches we have effectively made

311
00:12:13,519 --> 00:12:16,880
all untaken branches free i will now

312
00:12:16,880 --> 00:12:17,920
demonstrate

313
00:12:17,920 --> 00:12:21,680
how we can reuse the triples securely

314
00:12:21,680 --> 00:12:24,560
we work for any number of branches but

315
00:12:24,560 --> 00:12:25,920
for simplicity

316
00:12:25,920 --> 00:12:28,800
let's consider just two branches where

317
00:12:28,800 --> 00:12:29,440
the top

318
00:12:29,440 --> 00:12:32,079
branch is the active that is the taken

319
00:12:32,079 --> 00:12:33,279
branch

320
00:12:33,279 --> 00:12:36,160
i emphasize that neither player knows

321
00:12:36,160 --> 00:12:37,200
which branch is

322
00:12:37,200 --> 00:12:40,959
active we would like to use the same

323
00:12:40,959 --> 00:12:42,240
triple on both

324
00:12:42,240 --> 00:12:46,240
end gates in the two branches

325
00:12:46,320 --> 00:12:49,440
this idea of reusing the same expensive

326
00:12:49,440 --> 00:12:50,399
resource

327
00:12:50,399 --> 00:12:54,000
is that of material reuse and stems from

328
00:12:54,000 --> 00:12:54,720
the stock

329
00:12:54,720 --> 00:12:57,600
garbling line of research discussed

330
00:12:57,600 --> 00:13:01,360
earlier in the presentation

331
00:13:01,360 --> 00:13:04,320
the key idea behind reusing triple

332
00:13:04,320 --> 00:13:05,360
securely

333
00:13:05,360 --> 00:13:08,240
is that we can carefully apply secret

334
00:13:08,240 --> 00:13:12,000
shared masks to the triples

335
00:13:12,000 --> 00:13:14,880
for the inactive branch the parties mask

336
00:13:14,880 --> 00:13:15,600
the shares

337
00:13:15,600 --> 00:13:18,480
with uniform eggs or shares of uniform

338
00:13:18,480 --> 00:13:19,519
masks

339
00:13:19,519 --> 00:13:22,880
r and s randomizing the triples

340
00:13:22,880 --> 00:13:25,120
and preventing us from breaking the

341
00:13:25,120 --> 00:13:26,240
security of

342
00:13:26,240 --> 00:13:30,639
one time pad by randomizing the triples

343
00:13:30,639 --> 00:13:33,440
we violate the correctness of and gates

344
00:13:33,440 --> 00:13:35,600
on the inactive branch

345
00:13:35,600 --> 00:13:38,720
but this is of no concern the output of

346
00:13:38,720 --> 00:13:39,120
each

347
00:13:39,120 --> 00:13:41,519
inactive and gate is ultimately

348
00:13:41,519 --> 00:13:44,000
discarded

349
00:13:44,000 --> 00:13:46,639
for the active branch the parties use

350
00:13:46,639 --> 00:13:47,600
the triples

351
00:13:47,600 --> 00:13:50,639
as is meaning the active branch is

352
00:13:50,639 --> 00:13:53,040
evaluated normally

353
00:13:53,040 --> 00:13:55,519
of course the parties should not know

354
00:13:55,519 --> 00:13:56,480
which branch is

355
00:13:56,480 --> 00:13:59,600
inactive so from the perspective of the

356
00:13:59,600 --> 00:14:00,480
parties

357
00:14:00,480 --> 00:14:02,800
it should appear plausible that either

358
00:14:02,800 --> 00:14:04,959
branch could have used randomized

359
00:14:04,959 --> 00:14:06,240
triples

360
00:14:06,240 --> 00:14:08,880
to achieve this for the active branch

361
00:14:08,880 --> 00:14:10,639
the parties also xor

362
00:14:10,639 --> 00:14:14,399
masks onto the triples but in this case

363
00:14:14,399 --> 00:14:17,920
each mask is a uniform sharing of zero

364
00:14:17,920 --> 00:14:21,120
hence the xoring is a no op

365
00:14:21,120 --> 00:14:24,320
we stress that masking only the a and b

366
00:14:24,320 --> 00:14:26,880
bits of the triple is necessary and

367
00:14:26,880 --> 00:14:28,320
sufficient

368
00:14:28,320 --> 00:14:30,560
this is because these two bits are used

369
00:14:30,560 --> 00:14:32,880
to mask broadcast during the and gate

370
00:14:32,880 --> 00:14:33,920
evaluation

371
00:14:33,920 --> 00:14:37,120
phase the third value in the triple

372
00:14:37,120 --> 00:14:40,079
does not need to be masked each party

373
00:14:40,079 --> 00:14:42,560
holds a share of this triple value

374
00:14:42,560 --> 00:14:45,519
but uses it only locally with garbage

375
00:14:45,519 --> 00:14:46,560
values

376
00:14:46,560 --> 00:14:48,639
whatever you learn from these local

377
00:14:48,639 --> 00:14:49,920
operations

378
00:14:49,920 --> 00:14:54,560
will not give you any useful information

379
00:14:54,560 --> 00:14:56,720
importantly our approach your

380
00:14:56,720 --> 00:14:58,160
significant concrete

381
00:14:58,160 --> 00:15:01,199
improvement because generating masks is

382
00:15:01,199 --> 00:15:01,600
much

383
00:15:01,600 --> 00:15:04,079
cheaper than generating additional

384
00:15:04,079 --> 00:15:05,740
triples

385
00:15:05,740 --> 00:15:06,959
[Music]

386
00:15:06,959 --> 00:15:09,680
i have shown that if we are able to

387
00:15:09,680 --> 00:15:10,880
cheaply generate

388
00:15:10,880 --> 00:15:13,440
triple masks as described on the

389
00:15:13,440 --> 00:15:15,120
previous slides

390
00:15:15,120 --> 00:15:18,320
we can reuse triples across conditional

391
00:15:18,320 --> 00:15:19,600
branches

392
00:15:19,600 --> 00:15:22,000
thereby driving down the cost of

393
00:15:22,000 --> 00:15:22,880
conditional

394
00:15:22,880 --> 00:15:26,399
evaluation i will now give a concrete

395
00:15:26,399 --> 00:15:27,279
example of

396
00:15:27,279 --> 00:15:30,880
our approach suppose our conditional

397
00:15:30,880 --> 00:15:31,839
consists of

398
00:15:31,839 --> 00:15:34,880
two branches

399
00:15:35,120 --> 00:15:37,199
and the first branch is the active

400
00:15:37,199 --> 00:15:38,800
branch recall

401
00:15:38,800 --> 00:15:41,680
that neither party knows which branch is

402
00:15:41,680 --> 00:15:43,920
active

403
00:15:43,920 --> 00:15:46,959
in a standard triple base protocol we

404
00:15:46,959 --> 00:15:49,199
would need to generate one triple per

405
00:15:49,199 --> 00:15:51,600
and gate in all branches

406
00:15:51,600 --> 00:15:56,240
and hence a total of five triples

407
00:15:56,399 --> 00:15:59,199
in our approach we need to generate

408
00:15:59,199 --> 00:16:00,000
triples

409
00:16:00,000 --> 00:16:03,360
only for the longest conditional branch

410
00:16:03,360 --> 00:16:06,000
as the upper branch is the longer branch

411
00:16:06,000 --> 00:16:06,480
in our

412
00:16:06,480 --> 00:16:09,759
example we need to pre-process only

413
00:16:09,759 --> 00:16:11,360
three triples

414
00:16:11,360 --> 00:16:14,880
one for each and gate in this branch

415
00:16:14,880 --> 00:16:18,079
so we have pre-processed our triples

416
00:16:18,079 --> 00:16:20,560
and now we generate a sufficient number

417
00:16:20,560 --> 00:16:22,000
of masks

418
00:16:22,000 --> 00:16:25,040
in our example we need six pairs of

419
00:16:25,040 --> 00:16:26,160
masks

420
00:16:26,160 --> 00:16:29,839
two pairs for each triple as we are

421
00:16:29,839 --> 00:16:33,120
masking two bits in each triple

422
00:16:33,120 --> 00:16:36,560
each pair consists of a mask for the

423
00:16:36,560 --> 00:16:37,759
active branch

424
00:16:37,759 --> 00:16:40,959
and a mask for the inactive branch

425
00:16:40,959 --> 00:16:44,079
once the masks are ready we proceed with

426
00:16:44,079 --> 00:16:48,160
the conditional evaluation

427
00:16:48,240 --> 00:16:50,800
as the upper branch is active the

428
00:16:50,800 --> 00:16:52,480
triples are masked with

429
00:16:52,480 --> 00:16:55,839
all zero masks hence the triple's

430
00:16:55,839 --> 00:16:58,959
semantic values are unchanged and the

431
00:16:58,959 --> 00:17:00,240
parties use them

432
00:17:00,240 --> 00:17:03,759
as is on the active branch note

433
00:17:03,759 --> 00:17:06,559
that the parties are not aware that the

434
00:17:06,559 --> 00:17:08,959
masks are shares of zeros

435
00:17:08,959 --> 00:17:12,640
as the shares are uniform in our masked

436
00:17:12,640 --> 00:17:14,319
triples protocol

437
00:17:14,319 --> 00:17:17,599
we take care that the all zero masks

438
00:17:17,599 --> 00:17:21,918
are aligned with the active branch

439
00:17:22,000 --> 00:17:25,199
on the inactive branch we randomize the

440
00:17:25,199 --> 00:17:27,599
triples by applying unit 4

441
00:17:27,599 --> 00:17:31,280
masks in this case we change the triple

442
00:17:31,280 --> 00:17:32,000
semantic

443
00:17:32,000 --> 00:17:35,200
values and invalidate the correctness of

444
00:17:35,200 --> 00:17:38,799
and gates on this branch as we discard

445
00:17:38,799 --> 00:17:41,919
the outputs of the inactive branch this

446
00:17:41,919 --> 00:17:45,039
is of no concern

447
00:17:45,039 --> 00:17:47,760
so now we hold the outputs of both

448
00:17:47,760 --> 00:17:48,799
branches

449
00:17:48,799 --> 00:17:51,679
but we need to propagate only the value

450
00:17:51,679 --> 00:17:53,760
on the active branch

451
00:17:53,760 --> 00:17:56,080
this can be achieved with ordinary

452
00:17:56,080 --> 00:17:57,760
boolean logic

453
00:17:57,760 --> 00:18:01,280
specifically we use a multiplexer

454
00:18:01,280 --> 00:18:04,640
which takes as input a branch condition

455
00:18:04,640 --> 00:18:07,440
a secret shared bit that determines

456
00:18:07,440 --> 00:18:08,480
which branch is

457
00:18:08,480 --> 00:18:12,840
active alongside the outputs of both

458
00:18:12,840 --> 00:18:15,679
branches the multiplexer

459
00:18:15,679 --> 00:18:18,559
consequently propagates the output value

460
00:18:18,559 --> 00:18:20,240
on the active branch

461
00:18:20,240 --> 00:18:23,039
and discards the invalid output on the

462
00:18:23,039 --> 00:18:24,720
inactive branch

463
00:18:24,720 --> 00:18:27,679
multiplexer costs one and gate per

464
00:18:27,679 --> 00:18:28,880
conditional

465
00:18:28,880 --> 00:18:33,120
output i have demonstrated

466
00:18:33,120 --> 00:18:36,160
that our protocol works assuming triple

467
00:18:36,160 --> 00:18:38,320
masks can be generated much

468
00:18:38,320 --> 00:18:41,679
more cheaply than additional triples

469
00:18:41,679 --> 00:18:44,880
what remains is to show how we generate

470
00:18:44,880 --> 00:18:48,240
these masks recall that we have to

471
00:18:48,240 --> 00:18:48,960
generate

472
00:18:48,960 --> 00:18:52,160
a large number of these masks i will

473
00:18:52,160 --> 00:18:53,760
refer to this number

474
00:18:53,760 --> 00:18:57,600
by n we need one triple for each and

475
00:18:57,600 --> 00:19:00,720
gate on the longest conditional branch

476
00:19:00,720 --> 00:19:04,640
and we need twice as many masks

477
00:19:04,640 --> 00:19:06,799
in order for us to evaluate a

478
00:19:06,799 --> 00:19:08,480
conditional statement

479
00:19:08,480 --> 00:19:11,600
for the cost of a single longest branch

480
00:19:11,600 --> 00:19:14,080
we must ensure that the cost of

481
00:19:14,080 --> 00:19:15,840
generating masks is

482
00:19:15,840 --> 00:19:19,360
independent of n the number of masks

483
00:19:19,360 --> 00:19:23,280
we need in fact we just need a small

484
00:19:23,280 --> 00:19:26,799
constant number of ots of long strings

485
00:19:26,799 --> 00:19:31,039
to generate any number of masks

486
00:19:31,039 --> 00:19:34,160
for simplicity i demonstrate our mask

487
00:19:34,160 --> 00:19:36,000
generation protocol

488
00:19:36,000 --> 00:19:38,799
in the context of two parties and two

489
00:19:38,799 --> 00:19:40,240
branches

490
00:19:40,240 --> 00:19:43,200
alice and bob first sample a uniform bit

491
00:19:43,200 --> 00:19:43,840
s

492
00:19:43,840 --> 00:19:48,320
and a uniform and bit string are

493
00:19:48,320 --> 00:19:50,720
alice and bob then compute a vector

494
00:19:50,720 --> 00:19:52,080
scalar product

495
00:19:52,080 --> 00:19:55,360
s times r and receive a sharing of this

496
00:19:55,360 --> 00:20:00,000
product this product can be computed

497
00:20:00,000 --> 00:20:03,120
cheaply with only two ot's on

498
00:20:03,120 --> 00:20:06,080
n-bit strings i will not discuss the

499
00:20:06,080 --> 00:20:07,280
details here

500
00:20:07,280 --> 00:20:11,440
but you can find them in our paper

501
00:20:11,760 --> 00:20:14,320
alice and bob then output their shares

502
00:20:14,320 --> 00:20:15,679
of the masks

503
00:20:15,679 --> 00:20:18,720
s times r and s times r

504
00:20:18,720 --> 00:20:21,840
plus r

505
00:20:21,840 --> 00:20:25,120
depending on the value of the bit s

506
00:20:25,120 --> 00:20:28,240
one mask is a share of zeros while the

507
00:20:28,240 --> 00:20:30,480
other is a share of the random bit

508
00:20:30,480 --> 00:20:32,840
string

509
00:20:32,840 --> 00:20:34,480
r

510
00:20:34,480 --> 00:20:37,280
now i have successfully generated all

511
00:20:37,280 --> 00:20:37,840
zero

512
00:20:37,840 --> 00:20:41,039
and uniform masks these masks

513
00:20:41,039 --> 00:20:43,679
are currently ordered according to the

514
00:20:43,679 --> 00:20:44,799
uniform bit

515
00:20:44,799 --> 00:20:48,559
s if we go back to our example with two

516
00:20:48,559 --> 00:20:49,760
branches

517
00:20:49,760 --> 00:20:52,559
we need to associate the all zero mask

518
00:20:52,559 --> 00:20:54,720
with the active branch

519
00:20:54,720 --> 00:20:57,840
however the parties do not know which

520
00:20:57,840 --> 00:20:58,240
mask

521
00:20:58,240 --> 00:21:02,080
is all zeros nor which branch is active

522
00:21:02,080 --> 00:21:04,720
this is easy and cheap to arrange given

523
00:21:04,720 --> 00:21:06,480
the branch condition bit

524
00:21:06,480 --> 00:21:09,360
and the bit s with a single bit

525
00:21:09,360 --> 00:21:10,400
broadcast

526
00:21:10,400 --> 00:21:14,000
and a simple local permutation

527
00:21:14,000 --> 00:21:16,720
so i have introduced the complete mass

528
00:21:16,720 --> 00:21:18,480
triples protocol

529
00:21:18,480 --> 00:21:21,200
we have implemented our approach and now

530
00:21:21,200 --> 00:21:21,760
i show

531
00:21:21,760 --> 00:21:24,480
some of our results we ran our

532
00:21:24,480 --> 00:21:26,480
experiments on circuits with

533
00:21:26,480 --> 00:21:29,520
randomly generated alignments across

534
00:21:29,520 --> 00:21:32,799
100 fronts please see our paper

535
00:21:32,799 --> 00:21:36,159
for details of the circuits we used

536
00:21:36,159 --> 00:21:39,520
this first plot is in the 2pc setting

537
00:21:39,520 --> 00:21:41,840
and demonstrates how we reduce the

538
00:21:41,840 --> 00:21:43,120
number of ots

539
00:21:43,120 --> 00:21:45,600
as a function of the branching factor

540
00:21:45,600 --> 00:21:46,320
that is

541
00:21:46,320 --> 00:21:49,120
the number of conditional branches in

542
00:21:49,120 --> 00:21:50,400
our solution

543
00:21:50,400 --> 00:21:53,520
the number of ots is virtually constant

544
00:21:53,520 --> 00:21:56,320
whereas the number of ots grows linearly

545
00:21:56,320 --> 00:21:58,240
in the standard triple based

546
00:21:58,240 --> 00:22:01,919
protocol recall at the beginning of the

547
00:22:01,919 --> 00:22:02,480
talk

548
00:22:02,480 --> 00:22:05,200
i said motif was limited by the branch

549
00:22:05,200 --> 00:22:07,360
alignment in the conditional

550
00:22:07,360 --> 00:22:10,400
and that our work improves on this

551
00:22:10,400 --> 00:22:13,520
this box plot shows motifs dependence on

552
00:22:13,520 --> 00:22:14,880
branch alignment

553
00:22:14,880 --> 00:22:18,000
in the case of two branches we plot the

554
00:22:18,000 --> 00:22:19,679
distribution of the number of

555
00:22:19,679 --> 00:22:22,640
random ots needed for two parties to

556
00:22:22,640 --> 00:22:24,799
evaluate each protocol

557
00:22:24,799 --> 00:22:28,159
across all 100 runs mass triples and the

558
00:22:28,159 --> 00:22:30,159
standard triple based protocol

559
00:22:30,159 --> 00:22:33,200
always need the same number of ots

560
00:22:33,200 --> 00:22:36,000
on the other hand motifs performance

561
00:22:36,000 --> 00:22:36,799
differs

562
00:22:36,799 --> 00:22:39,840
depending on branch alignment because we

563
00:22:39,840 --> 00:22:42,000
sample alignments uniformly

564
00:22:42,000 --> 00:22:44,240
this results in an increased number of

565
00:22:44,240 --> 00:22:46,000
consumed ots

566
00:22:46,000 --> 00:22:48,640
for two branches and on average our

567
00:22:48,640 --> 00:22:49,200
approach

568
00:22:49,200 --> 00:22:53,600
required 1.5 times fewer ots than motif

569
00:22:53,600 --> 00:22:56,400
and consistently required two times

570
00:22:56,400 --> 00:22:57,600
fewer ots

571
00:22:57,600 --> 00:23:01,039
than the standard triple based protocol

572
00:23:01,039 --> 00:23:04,240
our next plot shows the total per party

573
00:23:04,240 --> 00:23:05,600
communication

574
00:23:05,600 --> 00:23:08,080
as a function of the branching factor in

575
00:23:08,080 --> 00:23:08,799
motif

576
00:23:08,799 --> 00:23:11,919
and our work on 16 branches

577
00:23:11,919 --> 00:23:13,679
our approach improves total

578
00:23:13,679 --> 00:23:15,760
communication on average by

579
00:23:15,760 --> 00:23:18,880
factor 2.6 over motif our

580
00:23:18,880 --> 00:23:20,960
improvement over the standard protocol

581
00:23:20,960 --> 00:23:22,000
was by factor

582
00:23:22,000 --> 00:23:25,360
12 in the same setting

583
00:23:25,360 --> 00:23:28,000
our last experiment emphasizes our

584
00:23:28,000 --> 00:23:30,400
approaches scaling to the multi-party

585
00:23:30,400 --> 00:23:31,200
setting

586
00:23:31,200 --> 00:23:33,840
in this experiment we fix the number of

587
00:23:33,840 --> 00:23:35,280
branches to 16

588
00:23:35,280 --> 00:23:37,760
and plot per party communication as a

589
00:23:37,760 --> 00:23:39,120
function of the number of

590
00:23:39,120 --> 00:23:42,799
parties our optimization does not add

591
00:23:42,799 --> 00:23:45,520
additional costs as compared to motif

592
00:23:45,520 --> 00:23:48,240
and standard triple based protocol

593
00:23:48,240 --> 00:23:50,880
each technique consumes communication

594
00:23:50,880 --> 00:23:53,840
quadratic and the number of parties

595
00:23:53,840 --> 00:23:56,159
while our approach skills efficiently to

596
00:23:56,159 --> 00:23:57,919
the multi-party setting

597
00:23:57,919 --> 00:24:00,320
we also introduce more efficient mass

598
00:24:00,320 --> 00:24:02,400
generation protocols in the two and

599
00:24:02,400 --> 00:24:04,080
three-party setting

600
00:24:04,080 --> 00:24:05,840
you can find details about these

601
00:24:05,840 --> 00:24:08,960
protocols in our paper

602
00:24:08,960 --> 00:24:11,600
so this was mass triples the key

603
00:24:11,600 --> 00:24:12,640
contribution

604
00:24:12,640 --> 00:24:15,039
is that we introduce a protocol with

605
00:24:15,039 --> 00:24:16,880
communication proportional to a

606
00:24:16,880 --> 00:24:18,000
program's longest

607
00:24:18,000 --> 00:24:20,480
execution path in the multi-party

608
00:24:20,480 --> 00:24:21,760
setting

609
00:24:21,760 --> 00:24:24,480
unlike state-of-the-art motif our

610
00:24:24,480 --> 00:24:26,559
improvement is independent of the

611
00:24:26,559 --> 00:24:28,320
circuit topology

612
00:24:28,320 --> 00:24:30,720
we implemented our approach and obtained

613
00:24:30,720 --> 00:24:32,080
significant concrete

614
00:24:32,080 --> 00:24:35,200
improvements over motif in all tested

615
00:24:35,200 --> 00:24:36,240
settings

616
00:24:36,240 --> 00:24:40,960
so thank you for listening

