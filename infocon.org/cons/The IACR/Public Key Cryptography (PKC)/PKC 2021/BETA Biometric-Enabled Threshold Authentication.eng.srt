1
00:00:01,439 --> 00:00:03,280
welcome to my talk my name is say

2
00:00:03,280 --> 00:00:03,919
krishna

3
00:00:03,919 --> 00:00:05,200
and i'm going to be talking about our

4
00:00:05,200 --> 00:00:06,960
paper titled beta

5
00:00:06,960 --> 00:00:08,559
biometric enabled threshold

6
00:00:08,559 --> 00:00:11,200
authentication this is joint work with

7
00:00:11,200 --> 00:00:16,480
shashank payment practice and sugar

8
00:00:16,480 --> 00:00:18,400
first let's look at uh how

9
00:00:18,400 --> 00:00:20,080
password-based authentication works

10
00:00:20,080 --> 00:00:21,199
today

11
00:00:21,199 --> 00:00:23,119
so there is first an enrollment phase

12
00:00:23,119 --> 00:00:24,720
during which

13
00:00:24,720 --> 00:00:26,720
the user enrolls their password onto a

14
00:00:26,720 --> 00:00:28,880
server typically this is

15
00:00:28,880 --> 00:00:30,400
done in the form of storing a sorted

16
00:00:30,400 --> 00:00:32,800
hash of the password

17
00:00:32,800 --> 00:00:35,920
and then in an online phase

18
00:00:35,920 --> 00:00:37,600
the user enters their password onto

19
00:00:37,600 --> 00:00:39,920
their device say a mobile phone

20
00:00:39,920 --> 00:00:42,480
the phone passes along this password or

21
00:00:42,480 --> 00:00:43,200
assaulted

22
00:00:43,200 --> 00:00:46,079
hash version of it to the server the

23
00:00:46,079 --> 00:00:48,079
server then checks whether the password

24
00:00:48,079 --> 00:00:50,719
matches with the one it had on its end

25
00:00:50,719 --> 00:00:51,520
and then

26
00:00:51,520 --> 00:00:54,480
authenticates the form

27
00:00:54,640 --> 00:00:56,079
while password-based authentication is

28
00:00:56,079 --> 00:00:57,680
great there are multiple issues that we

29
00:00:57,680 --> 00:00:59,120
have identified

30
00:00:59,120 --> 00:01:02,640
over the years um

31
00:01:02,640 --> 00:01:05,519
as as everybody is aware the biggest

32
00:01:05,519 --> 00:01:06,240
concern is

33
00:01:06,240 --> 00:01:08,720
the of the problem of offline dictionary

34
00:01:08,720 --> 00:01:09,360
attacks

35
00:01:09,360 --> 00:01:10,799
there have been several large-scale

36
00:01:10,799 --> 00:01:12,799
real-world breaches where servers

37
00:01:12,799 --> 00:01:13,520
storing

38
00:01:13,520 --> 00:01:15,119
millions of passwords have been reached

39
00:01:15,119 --> 00:01:17,520
and compromised users

40
00:01:17,520 --> 00:01:20,880
privacy and then also there is a

41
00:01:20,880 --> 00:01:23,280
lot of usability concerns with using

42
00:01:23,280 --> 00:01:25,200
passwords because it

43
00:01:25,200 --> 00:01:28,320
inherently requires a high entropy and

44
00:01:28,320 --> 00:01:32,399
that is not easy to remember for users

45
00:01:33,040 --> 00:01:35,680
moving along to biometric authentication

46
00:01:35,680 --> 00:01:36,640
the flows are

47
00:01:36,640 --> 00:01:39,360
similar you have an enrollment phase

48
00:01:39,360 --> 00:01:40,479
where the user

49
00:01:40,479 --> 00:01:42,240
enrolls the biometric template which is

50
00:01:42,240 --> 00:01:44,240
stored on a server

51
00:01:44,240 --> 00:01:47,040
and then in an online phase the user

52
00:01:47,040 --> 00:01:48,640
enters the biometric

53
00:01:48,640 --> 00:01:50,880
measurement onto mobile phone or their

54
00:01:50,880 --> 00:01:51,920
device

55
00:01:51,920 --> 00:01:53,759
the phone passes it along to the server

56
00:01:53,759 --> 00:01:55,280
the server checks if it was a match or

57
00:01:55,280 --> 00:01:57,600
not to authenticate the user

58
00:01:57,600 --> 00:01:58,719
on the one hand there is better

59
00:01:58,719 --> 00:02:00,640
usability than passwords because users

60
00:02:00,640 --> 00:02:02,479
don't need to remember any data

61
00:02:02,479 --> 00:02:05,360
and no high entropic requirement is

62
00:02:05,360 --> 00:02:06,719
posed here

63
00:02:06,719 --> 00:02:09,840
while on the other hand

64
00:02:11,120 --> 00:02:12,879
a server-side breach is much more

65
00:02:12,879 --> 00:02:14,800
damaging in the case of biometrics than

66
00:02:14,800 --> 00:02:15,840
passwords because

67
00:02:15,840 --> 00:02:17,040
unlike passwords you cannot really

68
00:02:17,040 --> 00:02:20,319
change the biometric easily

69
00:02:21,760 --> 00:02:23,440
one of the popular industry wide

70
00:02:23,440 --> 00:02:24,879
standards for using biometric

71
00:02:24,879 --> 00:02:25,599
authentication

72
00:02:25,599 --> 00:02:28,160
is the fido alliance and let me briefly

73
00:02:28,160 --> 00:02:30,160
recall how that works

74
00:02:30,160 --> 00:02:32,400
first as as we mentioned before in the

75
00:02:32,400 --> 00:02:33,840
enrollment phase the user enters the

76
00:02:33,840 --> 00:02:35,760
biometric template onto their phone

77
00:02:35,760 --> 00:02:37,920
but then instead of sending across this

78
00:02:37,920 --> 00:02:39,760
phone the biometric template onto the

79
00:02:39,760 --> 00:02:40,480
server

80
00:02:40,480 --> 00:02:42,319
the phone locally stores the diameter

81
00:02:42,319 --> 00:02:43,519
template

82
00:02:43,519 --> 00:02:45,360
it then generates a public key and a

83
00:02:45,360 --> 00:02:46,800
signing key

84
00:02:46,800 --> 00:02:48,560
sends along the public key to the server

85
00:02:48,560 --> 00:02:51,120
and keeps the signing key with itself

86
00:02:51,120 --> 00:02:54,720
now in the online phase when a user

87
00:02:54,720 --> 00:02:56,800
wants to and to authenticate themselves

88
00:02:56,800 --> 00:02:58,319
they once again enter the biometric

89
00:02:58,319 --> 00:02:59,920
measurement onto the phone

90
00:02:59,920 --> 00:03:02,000
the phone locally performs the biometric

91
00:03:02,000 --> 00:03:03,040
comparison

92
00:03:03,040 --> 00:03:04,400
with the template that was stored

93
00:03:04,400 --> 00:03:06,239
earlier to check whether the new

94
00:03:06,239 --> 00:03:07,680
measurement matched or not

95
00:03:07,680 --> 00:03:09,920
and if it was a match the secret key or

96
00:03:09,920 --> 00:03:12,640
the signing key is unlocked

97
00:03:12,640 --> 00:03:14,080
and then the server sends along the

98
00:03:14,080 --> 00:03:15,840
challenge and the phone signs this

99
00:03:15,840 --> 00:03:18,480
challenge to indicate to the server that

100
00:03:18,480 --> 00:03:20,319
the user indeed produced a measurement

101
00:03:20,319 --> 00:03:21,920
that much

102
00:03:21,920 --> 00:03:22,959
and this is how the user is

103
00:03:22,959 --> 00:03:25,599
authenticated

104
00:03:25,840 --> 00:03:29,200
while this this is a popular standard

105
00:03:29,200 --> 00:03:29,599
and

106
00:03:29,599 --> 00:03:33,519
is very effective in several aspects

107
00:03:33,519 --> 00:03:35,360
there are once again some concerns with

108
00:03:35,360 --> 00:03:37,200
this as well the first is that as before

109
00:03:37,200 --> 00:03:39,200
there is again a single point of failure

110
00:03:39,200 --> 00:03:40,560
with the phone storing the user's

111
00:03:40,560 --> 00:03:43,440
biometric and then another usability

112
00:03:43,440 --> 00:03:44,000
concern

113
00:03:44,000 --> 00:03:46,159
is that every time the user wishes to

114
00:03:46,159 --> 00:03:47,760
authenticate themselves they now need to

115
00:03:47,760 --> 00:03:49,360
carry along the same device

116
00:03:49,360 --> 00:03:51,040
that originally held the biometric

117
00:03:51,040 --> 00:03:53,440
template

118
00:03:54,400 --> 00:03:56,720
now if you think about how the user can

119
00:03:56,720 --> 00:03:58,720
store the biometric data on the phone

120
00:03:58,720 --> 00:04:00,480
there are a few options here one is

121
00:04:00,480 --> 00:04:02,159
maybe there's a secure hardware

122
00:04:02,159 --> 00:04:04,319
but this is costly in or not easily

123
00:04:04,319 --> 00:04:06,239
available and so on

124
00:04:06,239 --> 00:04:08,000
another option is similar to the case of

125
00:04:08,000 --> 00:04:09,760
password could be to store a solid hash

126
00:04:09,760 --> 00:04:11,120
of the biometric

127
00:04:11,120 --> 00:04:14,239
and one concern here is that the

128
00:04:14,239 --> 00:04:16,238
biometric matching process unlike

129
00:04:16,238 --> 00:04:18,720
passwords is fuzzy whereas in the case

130
00:04:18,720 --> 00:04:20,320
of passwords it's an exactly quality

131
00:04:20,320 --> 00:04:21,199
test

132
00:04:21,199 --> 00:04:23,840
so solid hash might not be uh quite

133
00:04:23,840 --> 00:04:25,440
compatible with biometric matching and

134
00:04:25,440 --> 00:04:26,639
then of course there is also the issue

135
00:04:26,639 --> 00:04:28,960
of an offline attack

136
00:04:28,960 --> 00:04:32,080
that an adversary who manages to capture

137
00:04:32,080 --> 00:04:34,400
the phone can launch

138
00:04:34,400 --> 00:04:36,720
another option a popular option is you

139
00:04:36,720 --> 00:04:37,759
use

140
00:04:37,759 --> 00:04:40,080
using the notion of fuzzy extractors but

141
00:04:40,080 --> 00:04:41,199
then this requires

142
00:04:41,199 --> 00:04:42,880
a high entropy from the underlying

143
00:04:42,880 --> 00:04:44,320
biometric data

144
00:04:44,320 --> 00:04:46,160
uh fuzzy extractors also result in a

145
00:04:46,160 --> 00:04:47,600
loss in accuracy

146
00:04:47,600 --> 00:04:50,800
and of biometric matching

147
00:04:50,800 --> 00:04:52,800
and once again the offline dictionary

148
00:04:52,800 --> 00:04:56,639
attacks are still possible

149
00:04:56,639 --> 00:04:59,840
our solution to address this problem is

150
00:04:59,840 --> 00:05:02,880
uh to propose the notion of you can

151
00:05:02,880 --> 00:05:05,440
think of it as distributed fido

152
00:05:05,440 --> 00:05:07,199
so we propose this new primitive called

153
00:05:07,199 --> 00:05:09,520
a fuzzy threshold tokenizer

154
00:05:09,520 --> 00:05:12,880
which works as follows we have an

155
00:05:12,880 --> 00:05:15,360
enrollment phase as before

156
00:05:15,360 --> 00:05:16,880
but now in the enrollment phase when the

157
00:05:16,880 --> 00:05:18,639
user enters their biometric template

158
00:05:18,639 --> 00:05:20,160
into the phone

159
00:05:20,160 --> 00:05:21,840
the phone no longer stores the biometric

160
00:05:21,840 --> 00:05:23,680
template entirely in the clear

161
00:05:23,680 --> 00:05:27,360
in itself instead we think of several

162
00:05:27,360 --> 00:05:29,759
of more devices that the user owns and

163
00:05:29,759 --> 00:05:32,160
the phone secret shares its template

164
00:05:32,160 --> 00:05:35,440
on with all these devices

165
00:05:35,440 --> 00:05:37,199
similarly the signing key is also not

166
00:05:37,199 --> 00:05:38,479
stored only on the phone

167
00:05:38,479 --> 00:05:40,000
the signing key is also secret share

168
00:05:40,000 --> 00:05:42,080
between all these devices so think of a

169
00:05:42,080 --> 00:05:44,240
user who has a phone

170
00:05:44,240 --> 00:05:47,919
an ipad a watch a smart watch and let's

171
00:05:47,919 --> 00:05:48,960
say a laptop

172
00:05:48,960 --> 00:05:52,479
for example and then the public key

173
00:05:52,479 --> 00:05:54,639
central outreach server as before

174
00:05:54,639 --> 00:05:55,919
you can also think of a setting where

175
00:05:55,919 --> 00:05:57,440
the user only has one device but now

176
00:05:57,440 --> 00:05:58,080
instead of

177
00:05:58,080 --> 00:05:59,440
a single server there are multiple

178
00:05:59,440 --> 00:06:02,400
servers each of whom holds one sharing

179
00:06:02,400 --> 00:06:04,800
of the key but for the purpose of this

180
00:06:04,800 --> 00:06:06,000
talk let's just stick to the user

181
00:06:06,000 --> 00:06:08,800
having multiple devices and now what

182
00:06:08,800 --> 00:06:10,560
happens in the online phase the user can

183
00:06:10,560 --> 00:06:12,720
enter their biometric measurement

184
00:06:12,720 --> 00:06:15,280
uh the phone now instead of performing

185
00:06:15,280 --> 00:06:16,960
the biometric matching locally on its

186
00:06:16,960 --> 00:06:17,919
end

187
00:06:17,919 --> 00:06:19,840
talks to all these different other

188
00:06:19,840 --> 00:06:23,679
devices that the user owns

189
00:06:23,759 --> 00:06:24,960
to check whether the biometric

190
00:06:24,960 --> 00:06:26,560
measurement matched with the template

191
00:06:26,560 --> 00:06:27,039
that

192
00:06:27,039 --> 00:06:28,319
was secret shared amongst all these

193
00:06:28,319 --> 00:06:30,800
devices if the mac succeeded

194
00:06:30,800 --> 00:06:33,680
then the phone tries to generate a

195
00:06:33,680 --> 00:06:35,199
signature once again by talking to all

196
00:06:35,199 --> 00:06:36,720
these devices

197
00:06:36,720 --> 00:06:38,960
and produces specular server to

198
00:06:38,960 --> 00:06:41,520
authenticate

199
00:06:42,720 --> 00:06:45,919
um so this prevents the single point of

200
00:06:45,919 --> 00:06:47,360
failure attack that we were concerned

201
00:06:47,360 --> 00:06:48,560
about

202
00:06:48,560 --> 00:06:52,160
and what would be the advantage of this

203
00:06:52,160 --> 00:06:52,800
primitive

204
00:06:52,800 --> 00:06:54,960
or in particular how would the phone

205
00:06:54,960 --> 00:06:56,960
communicate with all these other devices

206
00:06:56,960 --> 00:06:58,319
what are the requirements that we post

207
00:06:58,319 --> 00:07:00,560
here in our perimeter

208
00:07:00,560 --> 00:07:03,680
the first is that we

209
00:07:03,680 --> 00:07:06,160
do not want the user to carry along all

210
00:07:06,160 --> 00:07:07,199
their devices

211
00:07:07,199 --> 00:07:10,479
all the time in particular the primitive

212
00:07:10,479 --> 00:07:11,360
requires

213
00:07:11,360 --> 00:07:14,880
or the primitive states that it's enough

214
00:07:14,880 --> 00:07:17,199
and sufficiently necessary for the user

215
00:07:17,199 --> 00:07:19,120
to only interact with some threshold d

216
00:07:19,120 --> 00:07:20,479
number of devices

217
00:07:20,479 --> 00:07:22,719
okay

218
00:07:23,599 --> 00:07:26,319
and secondly we want to enforce that the

219
00:07:26,319 --> 00:07:26,880
all the t

220
00:07:26,880 --> 00:07:28,800
devices do not need to interact amongst

221
00:07:28,800 --> 00:07:30,240
each other

222
00:07:30,240 --> 00:07:32,960
it's enough if they interact only with

223
00:07:32,960 --> 00:07:34,639
the device that is initiating this

224
00:07:34,639 --> 00:07:36,000
authentication session

225
00:07:36,000 --> 00:07:37,440
in particular this is like a star

226
00:07:37,440 --> 00:07:39,840
network where the one who's initiating

227
00:07:39,840 --> 00:07:40,800
the session

228
00:07:40,800 --> 00:07:43,680
is the star and of the star mode and

229
00:07:43,680 --> 00:07:44,800
sitting in the center

230
00:07:44,800 --> 00:07:47,120
and all communication only happens via

231
00:07:47,120 --> 00:07:49,759
this device

232
00:07:49,759 --> 00:07:53,199
and finally um the third requirement we

233
00:07:53,199 --> 00:07:54,160
pose is that

234
00:07:54,160 --> 00:07:57,599
the initiator need not be the phone that

235
00:07:57,599 --> 00:08:01,120
originally took us input the user's

236
00:08:01,120 --> 00:08:02,319
biometric measurement

237
00:08:02,319 --> 00:08:04,000
or in fact it did not even be the same

238
00:08:04,000 --> 00:08:06,000
device every time recall that one of our

239
00:08:06,000 --> 00:08:08,240
concerns with the filo standard was that

240
00:08:08,240 --> 00:08:10,160
we did not want the same device to be

241
00:08:10,160 --> 00:08:12,560
required to be used at data

242
00:08:12,560 --> 00:08:15,120
right so any of these devices could

243
00:08:15,120 --> 00:08:16,639
serve as the initiator in any of the

244
00:08:16,639 --> 00:08:19,680
authentication sessions

245
00:08:19,840 --> 00:08:21,680
but the only requirement that they then

246
00:08:21,680 --> 00:08:23,199
talk to a threshold number of other

247
00:08:23,199 --> 00:08:25,520
devices

248
00:08:25,520 --> 00:08:29,280
using a star network communication model

249
00:08:29,280 --> 00:08:33,039
okay so with this primitive in mind what

250
00:08:33,039 --> 00:08:34,559
are the security goals that we would

251
00:08:34,559 --> 00:08:37,919
want to achieve from such a parameter

252
00:08:37,919 --> 00:08:39,519
let's consider a malicious adversary

253
00:08:39,519 --> 00:08:40,958
that can corrupt a set of

254
00:08:40,958 --> 00:08:43,200
devices and the number of devices it

255
00:08:43,200 --> 00:08:46,560
corrupts can only be less than d

256
00:08:46,720 --> 00:08:49,760
the first requirement is privacy of the

257
00:08:49,760 --> 00:08:50,959
biometric template

258
00:08:50,959 --> 00:08:53,360
the template that is generated that is

259
00:08:53,360 --> 00:08:54,880
registered in the enrollment phase and

260
00:08:54,880 --> 00:08:56,560
secret share amongst the users

261
00:08:56,560 --> 00:08:58,560
amongst the devices should always remain

262
00:08:58,560 --> 00:09:00,720
private so in any authentication session

263
00:09:00,720 --> 00:09:02,000
the adversary should not be able to

264
00:09:02,000 --> 00:09:03,760
learn anything about

265
00:09:03,760 --> 00:09:06,399
the template similarly we also want

266
00:09:06,399 --> 00:09:07,839
privacy of the measurement so the

267
00:09:07,839 --> 00:09:09,279
adversary should not be able to learn

268
00:09:09,279 --> 00:09:10,640
anything about the measurement

269
00:09:10,640 --> 00:09:12,399
no matter whether match was successful

270
00:09:12,399 --> 00:09:14,080
or not and both of these requirements

271
00:09:14,080 --> 00:09:15,110
can be formalized

272
00:09:15,110 --> 00:09:17,040
[Music]

273
00:09:17,040 --> 00:09:19,279
using indistinguishability or simulation

274
00:09:19,279 --> 00:09:21,120
based definitions

275
00:09:21,120 --> 00:09:22,720
and finally we want the notion of

276
00:09:22,720 --> 00:09:24,720
unforgivability which states that the

277
00:09:24,720 --> 00:09:26,480
adversary should not be able to generate

278
00:09:26,480 --> 00:09:28,080
a valid signature

279
00:09:28,080 --> 00:09:30,560
on any challenge without actually

280
00:09:30,560 --> 00:09:32,320
running the protocol on a valid

281
00:09:32,320 --> 00:09:33,120
measurement

282
00:09:33,120 --> 00:09:34,720
by valid here i mean that the

283
00:09:34,720 --> 00:09:37,440
measurement that the protocol is run

284
00:09:37,440 --> 00:09:39,920
with should indeed produce a match with

285
00:09:39,920 --> 00:09:43,040
the template that was stored

286
00:09:43,440 --> 00:09:45,200
moreover another requirement we have is

287
00:09:45,200 --> 00:09:46,480
that even from

288
00:09:46,480 --> 00:09:49,600
even by using a valid measurement and

289
00:09:49,600 --> 00:09:52,160
running an honest session the adversary

290
00:09:52,160 --> 00:09:53,680
should not be able to generate more than

291
00:09:53,680 --> 00:09:55,279
one signature

292
00:09:55,279 --> 00:09:57,519
in particular in order to generate any

293
00:09:57,519 --> 00:09:58,640
fresh signature

294
00:09:58,640 --> 00:10:01,040
you need to run a fresh session using a

295
00:10:01,040 --> 00:10:04,880
valid measurement

296
00:10:04,880 --> 00:10:07,279
we formalize all these three security

297
00:10:07,279 --> 00:10:09,200
requirements by using a simulation based

298
00:10:09,200 --> 00:10:09,920
definition

299
00:10:09,920 --> 00:10:13,839
in the universal composibility framework

300
00:10:14,640 --> 00:10:16,399
before i move on to the results that we

301
00:10:16,399 --> 00:10:17,760
obtain in this paper

302
00:10:17,760 --> 00:10:19,600
let me briefly touch upon how the

303
00:10:19,600 --> 00:10:21,920
process of biometric matching works

304
00:10:21,920 --> 00:10:23,680
so how do we compare two measurement to

305
00:10:23,680 --> 00:10:24,959
biometric uh

306
00:10:24,959 --> 00:10:27,839
measurements so the first step is that

307
00:10:27,839 --> 00:10:28,240
we

308
00:10:28,240 --> 00:10:30,720
the biometric matching in the biometric

309
00:10:30,720 --> 00:10:32,320
matching process is to convert each of

310
00:10:32,320 --> 00:10:34,079
these measurements into vectors so let

311
00:10:34,079 --> 00:10:35,360
us say one of them is converted to a

312
00:10:35,360 --> 00:10:37,279
vector x and the other two vector y

313
00:10:37,279 --> 00:10:38,959
and then we say that the two vectors the

314
00:10:38,959 --> 00:10:40,880
two measurements match

315
00:10:40,880 --> 00:10:42,800
if the distance between these two

316
00:10:42,800 --> 00:10:44,000
vectors is small

317
00:10:44,000 --> 00:10:45,680
and this distance can be various

318
00:10:45,680 --> 00:10:47,440
distance functions depending on which

319
00:10:47,440 --> 00:10:49,920
biometric

320
00:10:49,920 --> 00:10:51,440
matching process we use or which

321
00:10:51,440 --> 00:10:54,160
biometric

322
00:10:54,399 --> 00:10:57,200
quantity we assume for example it could

323
00:10:57,200 --> 00:10:58,800
be a differentiation metric for

324
00:10:58,800 --> 00:11:00,560
your either scan a different one for

325
00:11:00,560 --> 00:11:03,440
fingerprints and so on

326
00:11:03,440 --> 00:11:05,519
okay so what are the results we obtain

327
00:11:05,519 --> 00:11:07,120
in this work as i mentioned before

328
00:11:07,120 --> 00:11:08,880
we define a new primitive for threshold

329
00:11:08,880 --> 00:11:10,399
biometric authentication

330
00:11:10,399 --> 00:11:12,079
and we formalize security of this

331
00:11:12,079 --> 00:11:14,079
primitive

332
00:11:14,079 --> 00:11:15,680
in using a standard simulation based

333
00:11:15,680 --> 00:11:17,839
definition with universal composable

334
00:11:17,839 --> 00:11:20,399
security

335
00:11:20,800 --> 00:11:23,760
we then design three protocols that are

336
00:11:23,760 --> 00:11:24,560
secure

337
00:11:24,560 --> 00:11:27,680
against malicious adversaries in with

338
00:11:27,680 --> 00:11:28,399
this

339
00:11:28,399 --> 00:11:31,120
uc secure definition and these three

340
00:11:31,120 --> 00:11:32,959
protocol servers various tradeoffs

341
00:11:32,959 --> 00:11:35,760
amongst each other

342
00:11:35,760 --> 00:11:37,200
the first protocol works for any

343
00:11:37,200 --> 00:11:39,519
distance metric

344
00:11:39,519 --> 00:11:40,959
in all three protocols there is no bound

345
00:11:40,959 --> 00:11:42,880
in the number of parties in the system

346
00:11:42,880 --> 00:11:45,200
in the first protocol the number of the

347
00:11:45,200 --> 00:11:46,880
threshold t can be anything

348
00:11:46,880 --> 00:11:48,720
anything less than n the number of

349
00:11:48,720 --> 00:11:50,160
corrupt parties can be anything less

350
00:11:50,160 --> 00:11:51,360
than t

351
00:11:51,360 --> 00:11:53,200
the protocol is based on any two round

352
00:11:53,200 --> 00:11:55,120
mpc protocol and it's

353
00:11:55,120 --> 00:11:56,560
it's not completely efficient it's a

354
00:11:56,560 --> 00:11:58,880
feasibility without the second protocol

355
00:11:58,880 --> 00:12:00,720
is also a feasibility result that works

356
00:12:00,720 --> 00:12:02,240
for any distance metric

357
00:12:02,240 --> 00:12:04,240
any number of corrupt parties any

358
00:12:04,240 --> 00:12:06,560
threshold t and this one is based on

359
00:12:06,560 --> 00:12:10,560
the primitive called threshold fetching

360
00:12:10,560 --> 00:12:12,160
the third protocol is an efficient is a

361
00:12:12,160 --> 00:12:14,079
completely efficient protocol

362
00:12:14,079 --> 00:12:16,720
this is tailor-made to cosign similarity

363
00:12:16,720 --> 00:12:18,160
and euclidean distance

364
00:12:18,160 --> 00:12:20,480
matrix both of which are popular for

365
00:12:20,480 --> 00:12:22,880
fingerprint and facial recognition

366
00:12:22,880 --> 00:12:25,279
this protocol is based on only prior

367
00:12:25,279 --> 00:12:27,440
encryption

368
00:12:27,440 --> 00:12:28,639
it works in the setting where the

369
00:12:28,639 --> 00:12:30,959
adversary can corrupt at most one party

370
00:12:30,959 --> 00:12:32,959
and the threshold number of parties

371
00:12:32,959 --> 00:12:34,079
required for any

372
00:12:34,079 --> 00:12:38,160
authentication session is only three

373
00:12:38,160 --> 00:12:40,000
uh in this work i'll focus briefly on

374
00:12:40,000 --> 00:12:41,440
the techniques uh

375
00:12:41,440 --> 00:12:43,440
underlying our first feasibility result

376
00:12:43,440 --> 00:12:45,519
and the efficient

377
00:12:45,519 --> 00:12:48,880
protocol for cosine simulator

378
00:12:51,120 --> 00:12:52,240
so what are the techniques in our

379
00:12:52,240 --> 00:12:53,760
protocol so first let's see the two

380
00:12:53,760 --> 00:12:55,440
round npc based one

381
00:12:55,440 --> 00:12:56,880
so suppose there was no constraint on

382
00:12:56,880 --> 00:12:58,480
the communication pattern at all

383
00:12:58,480 --> 00:13:00,480
right so now we have an authentication

384
00:13:00,480 --> 00:13:02,480
uh session in the online phase

385
00:13:02,480 --> 00:13:03,920
where each of these devices have their

386
00:13:03,920 --> 00:13:05,680
own shares of the template and the 690

387
00:13:05,680 --> 00:13:06,480
key

388
00:13:06,480 --> 00:13:08,320
and the device that initiating the

389
00:13:08,320 --> 00:13:11,279
protocol has a new measurement view

390
00:13:11,279 --> 00:13:13,760
and a challenge uh value that is sent

391
00:13:13,760 --> 00:13:15,279
from the server

392
00:13:15,279 --> 00:13:16,480
so if there was no constraint with the

393
00:13:16,480 --> 00:13:18,000
communication pattern we could just run

394
00:13:18,000 --> 00:13:19,200
an npc

395
00:13:19,200 --> 00:13:21,519
amongst all these are t plus one or

396
00:13:21,519 --> 00:13:22,800
these t parties

397
00:13:22,800 --> 00:13:25,680
for the following function the npc for

398
00:13:25,680 --> 00:13:26,399
each party

399
00:13:26,399 --> 00:13:29,760
each of these devices send use as input

400
00:13:29,760 --> 00:13:31,600
their share of the signing key and the

401
00:13:31,600 --> 00:13:32,320
temp

402
00:13:32,320 --> 00:13:34,480
template the initiator additionally also

403
00:13:34,480 --> 00:13:36,240
uses the challenge and the measurement

404
00:13:36,240 --> 00:13:37,440
as input

405
00:13:37,440 --> 00:13:40,160
the npc just simply reconstructs the

406
00:13:40,160 --> 00:13:41,040
template w

407
00:13:41,040 --> 00:13:43,360
and the signing key sk if the

408
00:13:43,360 --> 00:13:44,320
measurement and w

409
00:13:44,320 --> 00:13:46,160
are close according to the underlying

410
00:13:46,160 --> 00:13:47,519
distance metric then it generates the

411
00:13:47,519 --> 00:13:49,199
threshold signature

412
00:13:49,199 --> 00:13:51,199
right so this would be simple but the

413
00:13:51,199 --> 00:13:53,040
real challenge here is we want to

414
00:13:53,040 --> 00:13:57,040
be able to do all of this only using

415
00:13:57,040 --> 00:13:59,600
only using the star network

416
00:13:59,600 --> 00:14:00,880
communication model

417
00:14:00,880 --> 00:14:04,399
right and also we we would like to

418
00:14:04,399 --> 00:14:06,000
ensure that only one signature is

419
00:14:06,000 --> 00:14:08,880
generated each time and so on

420
00:14:08,880 --> 00:14:11,199
so how do we emulate a two-round npc

421
00:14:11,199 --> 00:14:12,240
protocol

422
00:14:12,240 --> 00:14:14,800
let's call the protocol span for

423
00:14:14,800 --> 00:14:15,760
simplicity

424
00:14:15,760 --> 00:14:17,440
for the stock let's say n and t are both

425
00:14:17,440 --> 00:14:19,279
three so the initiator is sitting in the

426
00:14:19,279 --> 00:14:20,800
middle the first party

427
00:14:20,800 --> 00:14:23,199
p2 is sitting on the left and p3 on the

428
00:14:23,199 --> 00:14:24,320
right

429
00:14:24,320 --> 00:14:26,560
so let's say p1 just sends out one

430
00:14:26,560 --> 00:14:27,440
message saying

431
00:14:27,440 --> 00:14:30,480
begin to uh let them know that

432
00:14:30,480 --> 00:14:32,959
they can now start running the protocol

433
00:14:32,959 --> 00:14:34,480
and both of them send the first round of

434
00:14:34,480 --> 00:14:36,639
the two running mpc message

435
00:14:36,639 --> 00:14:38,399
as you would imagine p1 can just forward

436
00:14:38,399 --> 00:14:39,680
this to the other party just

437
00:14:39,680 --> 00:14:41,360
act as a messenger in between forwarding

438
00:14:41,360 --> 00:14:43,920
the messages but of course

439
00:14:43,920 --> 00:14:46,480
this naively would not work because p1

440
00:14:46,480 --> 00:14:48,000
could send inconsistent or different

441
00:14:48,000 --> 00:14:49,680
messages

442
00:14:49,680 --> 00:14:51,760
p1 could send to p3 something that it

443
00:14:51,760 --> 00:14:54,240
did not actually receive from p2

444
00:14:54,240 --> 00:14:56,720
as you might guess this can be easily

445
00:14:56,720 --> 00:14:58,480
solved by just adding a signature

446
00:14:58,480 --> 00:15:00,079
let's say in the setup the enrollment

447
00:15:00,079 --> 00:15:02,480
phase p2's

448
00:15:02,480 --> 00:15:04,880
verification key is known to p3 and so

449
00:15:04,880 --> 00:15:06,800
on right so you can add a signature that

450
00:15:06,800 --> 00:15:09,120
would prevent p1 from

451
00:15:09,120 --> 00:15:12,160
sending different messages that it did

452
00:15:12,160 --> 00:15:13,040
not receive from

453
00:15:13,040 --> 00:15:16,399
one party to the other so the parties

454
00:15:16,399 --> 00:15:17,600
check the signature

455
00:15:17,600 --> 00:15:20,160
additionally p1 sends the first round of

456
00:15:20,160 --> 00:15:20,720
it's

457
00:15:20,720 --> 00:15:22,079
its own first round of the underlying

458
00:15:22,079 --> 00:15:24,720
npc protocol to both parties

459
00:15:24,720 --> 00:15:26,959
they respond back with their respective

460
00:15:26,959 --> 00:15:28,560
second round messages

461
00:15:28,560 --> 00:15:30,959
now notice that since we want only p1 to

462
00:15:30,959 --> 00:15:32,079
get the output

463
00:15:32,079 --> 00:15:34,079
uh it need not actually even generate

464
00:15:34,079 --> 00:15:35,920
its own second round message

465
00:15:35,920 --> 00:15:37,360
it can just use the transcript of the

466
00:15:37,360 --> 00:15:39,360
protocol so far to compute the output of

467
00:15:39,360 --> 00:15:40,320
the mpc

468
00:15:40,320 --> 00:15:43,519
and we would be done right

469
00:15:43,839 --> 00:15:46,399
unfortunately that is not the case as

470
00:15:46,399 --> 00:15:48,079
you might have noticed

471
00:15:48,079 --> 00:15:50,800
we also need to ensure that p1 does not

472
00:15:50,800 --> 00:15:51,759
send

473
00:15:51,759 --> 00:15:53,600
inconsistent first round messages to

474
00:15:53,600 --> 00:15:55,680
both the parties

475
00:15:55,680 --> 00:15:58,480
notice that this underlying tour on mpc

476
00:15:58,480 --> 00:16:00,160
protocol if it's

477
00:16:00,160 --> 00:16:03,839
based in the broadcast channel setting

478
00:16:03,839 --> 00:16:05,759
requires that the first round message

479
00:16:05,759 --> 00:16:07,519
sent by p1 to all the parties are the

480
00:16:07,519 --> 00:16:09,360
same

481
00:16:09,360 --> 00:16:11,120
right so now we need a mechanism to

482
00:16:11,120 --> 00:16:12,639
ensure that

483
00:16:12,639 --> 00:16:14,399
p1 indeed sends the same first round

484
00:16:14,399 --> 00:16:15,920
message to both parties

485
00:16:15,920 --> 00:16:19,440
or otherwise that this is detected

486
00:16:19,440 --> 00:16:22,720
our idea is that we do not require p2

487
00:16:22,720 --> 00:16:24,160
and p3 to detect that they got

488
00:16:24,160 --> 00:16:25,440
inconsistent messages

489
00:16:25,440 --> 00:16:27,199
but instead we want to design a

490
00:16:27,199 --> 00:16:29,279
mechanism that allows p1

491
00:16:29,279 --> 00:16:33,199
to recover p2 p2 second round message

492
00:16:33,199 --> 00:16:36,320
of the mpc protocol if and only if it

493
00:16:36,320 --> 00:16:37,199
indeed send

494
00:16:37,199 --> 00:16:38,800
the same first round message to both

495
00:16:38,800 --> 00:16:40,560
parties that is

496
00:16:40,560 --> 00:16:42,880
we want to say that only if message 2 is

497
00:16:42,880 --> 00:16:44,720
equal to message 3

498
00:16:44,720 --> 00:16:47,600
then p2's second round message of

499
00:16:47,600 --> 00:16:48,240
protocol

500
00:16:48,240 --> 00:16:51,680
pi is learned by p1

501
00:16:51,680 --> 00:16:53,680
and how do we do this this can be

502
00:16:53,680 --> 00:16:56,079
achieved by a very simple trick

503
00:16:56,079 --> 00:16:59,199
we let p2 and p3 share a couple of prf

504
00:16:59,199 --> 00:16:59,680
keys

505
00:16:59,680 --> 00:17:02,560
say k2 and k3 now instead of sending its

506
00:17:02,560 --> 00:17:04,799
own message in the clear p2 encrypts its

507
00:17:04,799 --> 00:17:07,199
second round message of pi

508
00:17:07,199 --> 00:17:10,160
using a key generated think of it like a

509
00:17:10,160 --> 00:17:11,039
one-time pad

510
00:17:11,039 --> 00:17:13,520
generated using the prf k2 on the

511
00:17:13,520 --> 00:17:15,439
message it received

512
00:17:15,439 --> 00:17:17,839
and now we can allow p3 to send across

513
00:17:17,839 --> 00:17:18,880
this one time pad

514
00:17:18,880 --> 00:17:22,079
to b1 so p3 would send brf of k2

515
00:17:22,079 --> 00:17:23,919
on the message 3 that it received now

516
00:17:23,919 --> 00:17:26,079
only if message 2 is equal to message 3

517
00:17:26,079 --> 00:17:28,079
p1 would be able to decrypt and learn

518
00:17:28,079 --> 00:17:30,320
the second round message of b2

519
00:17:30,320 --> 00:17:32,160
the same thing can be done in reverse to

520
00:17:32,160 --> 00:17:35,039
allow uh p3s for second-round message to

521
00:17:35,039 --> 00:17:37,520
also be learned

522
00:17:37,520 --> 00:17:39,440
and this approach naturally generalizes

523
00:17:39,440 --> 00:17:40,799
for arbitrary nd

524
00:17:40,799 --> 00:17:44,320
by using either pairs of prf keys or a

525
00:17:44,320 --> 00:17:46,160
distributed prf

526
00:17:46,160 --> 00:17:47,679
and i will not get into the details of

527
00:17:47,679 --> 00:17:49,840
that

528
00:17:50,480 --> 00:17:52,320
and now let me get in details of the

529
00:17:52,320 --> 00:17:53,520
techniques behind our three party

530
00:17:53,520 --> 00:17:55,039
protocol

531
00:17:55,039 --> 00:17:56,880
so how does the biometric matching work

532
00:17:56,880 --> 00:17:59,200
in the case of cosine similarity

533
00:17:59,200 --> 00:18:00,960
the distance function here is that the

534
00:18:00,960 --> 00:18:02,640
inner product between both these vectors

535
00:18:02,640 --> 00:18:04,480
should be greater than some threshold t

536
00:18:04,480 --> 00:18:06,160
i'm simplifying a little bit when i say

537
00:18:06,160 --> 00:18:07,280
it's the inner product but for the

538
00:18:07,280 --> 00:18:08,559
purpose of this talk let's just think

539
00:18:08,559 --> 00:18:11,039
about the inner product okay

540
00:18:11,039 --> 00:18:12,480
and the number of elements that you want

541
00:18:12,480 --> 00:18:14,480
to match is typically in the order of

542
00:18:14,480 --> 00:18:18,000
256 or 512.

543
00:18:18,000 --> 00:18:19,760
so how how does our protocol do this

544
00:18:19,760 --> 00:18:21,039
work in

545
00:18:21,039 --> 00:18:22,799
let's since we have just three parties

546
00:18:22,799 --> 00:18:24,160
let's say even n is three

547
00:18:24,160 --> 00:18:27,679
for simplicity in the enrollment phase

548
00:18:27,679 --> 00:18:29,440
as before we just secret share

549
00:18:29,440 --> 00:18:31,200
the template and the signing key

550
00:18:31,200 --> 00:18:33,039
additionally um

551
00:18:33,039 --> 00:18:35,600
suppose we have only consider the case

552
00:18:35,600 --> 00:18:37,120
where this phone at the center is

553
00:18:37,120 --> 00:18:39,120
going to be the initiator always then we

554
00:18:39,120 --> 00:18:40,559
share some randomness between the other

555
00:18:40,559 --> 00:18:42,880
two parties p2 and p3

556
00:18:42,880 --> 00:18:44,960
okay now in the online phase as before

557
00:18:44,960 --> 00:18:48,320
the initiator sits in the middle

558
00:18:48,640 --> 00:18:50,880
the initiator just runs a two-party

559
00:18:50,880 --> 00:18:52,080
protocol

560
00:18:52,080 --> 00:18:54,080
with one with p2 on the left and one

561
00:18:54,080 --> 00:18:56,080
with p3 on the right this is inspired by

562
00:18:56,080 --> 00:18:56,880
the work

563
00:18:56,880 --> 00:19:00,960
of mrz mohasel selec

564
00:19:00,960 --> 00:19:04,559
and zhang from 2015 ccs where

565
00:19:04,559 --> 00:19:06,960
they they consider the setting where you

566
00:19:06,960 --> 00:19:08,720
could run two parallel executions of the

567
00:19:08,720 --> 00:19:10,960
yards protocol and check whether one of

568
00:19:10,960 --> 00:19:12,400
them is lying or not

569
00:19:12,400 --> 00:19:14,000
since we have only one party that cannot

570
00:19:14,000 --> 00:19:16,160
be corrupt so

571
00:19:16,160 --> 00:19:18,640
both p2 and p3 generate a double circuit

572
00:19:18,640 --> 00:19:20,000
for the following circuit

573
00:19:20,000 --> 00:19:22,799
they just reconstruct w the template

574
00:19:22,799 --> 00:19:23,360
using

575
00:19:23,360 --> 00:19:26,880
um using the shares w1 and w2

576
00:19:26,880 --> 00:19:29,280
w2 is local to themselves and w1 is

577
00:19:29,280 --> 00:19:30,799
received

578
00:19:30,799 --> 00:19:32,799
and then if the inner product between u

579
00:19:32,799 --> 00:19:34,400
and w is greater than t

580
00:19:34,400 --> 00:19:38,799
it outputs some simple encryption key

581
00:19:39,360 --> 00:19:42,400
where the with uh where the

582
00:19:42,400 --> 00:19:43,919
partial signature of the thresholds

583
00:19:43,919 --> 00:19:45,520
landing scheme

584
00:19:45,520 --> 00:19:47,600
is generated and encrypted using this

585
00:19:47,600 --> 00:19:49,039
encryption key

586
00:19:49,039 --> 00:19:52,640
okay and now p3 just can send a hash of

587
00:19:52,640 --> 00:19:53,760
this message

588
00:19:53,760 --> 00:19:56,080
p1 checks the hash whether they're equal

589
00:19:56,080 --> 00:19:58,000
if so it recovers the labels of the ot

590
00:19:58,000 --> 00:19:58,880
protocol

591
00:19:58,880 --> 00:20:01,039
evaluates the global circuit and

592
00:20:01,039 --> 00:20:02,320
generates the encryption key and

593
00:20:02,320 --> 00:20:03,039
decrypts

594
00:20:03,039 --> 00:20:05,760
the ciphertext to recover this signature

595
00:20:05,760 --> 00:20:07,919
so this is pretty straightforward

596
00:20:07,919 --> 00:20:09,840
but there are multiple issues here the

597
00:20:09,840 --> 00:20:11,360
first is the computation inside the

598
00:20:11,360 --> 00:20:13,280
double circuit is very expensive

599
00:20:13,280 --> 00:20:16,480
because computing the reconstructing w

600
00:20:16,480 --> 00:20:18,559
computing the inner product term by term

601
00:20:18,559 --> 00:20:20,080
each of these is expense is very

602
00:20:20,080 --> 00:20:22,080
expensive as you saw the number of

603
00:20:22,080 --> 00:20:23,679
elements in each vector is

604
00:20:23,679 --> 00:20:27,039
in the order of 200 or 256 or 512.

605
00:20:27,039 --> 00:20:28,480
right so can we do backup can we can

606
00:20:28,480 --> 00:20:30,400
data much simpler carbon circuit

607
00:20:30,400 --> 00:20:32,159
uh in particular can we offload the

608
00:20:32,159 --> 00:20:33,760
computation of the inner product

609
00:20:33,760 --> 00:20:35,919
somewhere outside the carbon circuit and

610
00:20:35,919 --> 00:20:37,760
re use the carbon circuit only to do the

611
00:20:37,760 --> 00:20:39,520
comparison

612
00:20:39,520 --> 00:20:41,200
and secondly from a security point of

613
00:20:41,200 --> 00:20:43,440
view

614
00:20:43,600 --> 00:20:45,520
we'd also need to ensure that the input

615
00:20:45,520 --> 00:20:48,159
w1 that p1 uses in the ot

616
00:20:48,159 --> 00:20:50,400
receiver message is consistent with the

617
00:20:50,400 --> 00:20:52,240
w1 that it received at the end of the

618
00:20:52,240 --> 00:20:53,520
enrollment phase

619
00:20:53,520 --> 00:20:55,440
right we need there's no guarantee that

620
00:20:55,440 --> 00:20:57,039
it's using the actual template share

621
00:20:57,039 --> 00:20:58,480
that it stored at the end of the

622
00:20:58,480 --> 00:21:00,640
enrollment phase

623
00:21:00,640 --> 00:21:03,039
to tackle the first problem uh we resort

624
00:21:03,039 --> 00:21:04,880
to using pierre encryption which is an

625
00:21:04,880 --> 00:21:07,280
additively homologous encryption scheme

626
00:21:07,280 --> 00:21:10,400
um to compute the inner product outside

627
00:21:10,400 --> 00:21:11,600
the cable circuit

628
00:21:11,600 --> 00:21:14,880
initially in more detail p1 first

629
00:21:14,880 --> 00:21:17,039
generates an encryption of its temp of

630
00:21:17,039 --> 00:21:19,120
its measurement q

631
00:21:19,120 --> 00:21:21,600
p two using uh the additively

632
00:21:21,600 --> 00:21:23,200
homomorphic encryption scheme computes

633
00:21:23,200 --> 00:21:24,400
an inner product

634
00:21:24,400 --> 00:21:25,840
encryption of the inner product between

635
00:21:25,840 --> 00:21:27,600
u and w two

636
00:21:27,600 --> 00:21:29,679
p one can after checking the hash

637
00:21:29,679 --> 00:21:31,200
decrypt this to learn

638
00:21:31,200 --> 00:21:33,120
you inner product between u and w two in

639
00:21:33,120 --> 00:21:35,280
the clear adds it to the inner product

640
00:21:35,280 --> 00:21:36,640
between u and w one which

641
00:21:36,640 --> 00:21:38,640
can compute locally to compute the

642
00:21:38,640 --> 00:21:39,919
actual inner product

643
00:21:39,919 --> 00:21:41,679
right and then they can run this

644
00:21:41,679 --> 00:21:43,120
protocol as before

645
00:21:43,120 --> 00:21:44,799
now notice that the garble circuit does

646
00:21:44,799 --> 00:21:46,799
not need to compute the inner product

647
00:21:46,799 --> 00:21:48,480
it can just directly check if this is

648
00:21:48,480 --> 00:21:50,240
greater than the threshold

649
00:21:50,240 --> 00:21:54,559
which makes it much more efficient right

650
00:21:55,120 --> 00:21:57,200
how do we solve the input consistency

651
00:21:57,200 --> 00:21:58,159
issue

652
00:21:58,159 --> 00:22:01,520
the idea is that um in addition to

653
00:22:01,520 --> 00:22:03,120
sending an encryption

654
00:22:03,120 --> 00:22:05,840
of its measurement we require p one to

655
00:22:05,840 --> 00:22:07,520
also send an encryption

656
00:22:07,520 --> 00:22:09,120
of the inner product between the

657
00:22:09,120 --> 00:22:10,880
measurement and the temperature that it

658
00:22:10,880 --> 00:22:11,360
owned

659
00:22:11,360 --> 00:22:13,360
that is an encryption of inner product

660
00:22:13,360 --> 00:22:14,480
between u and w

661
00:22:14,480 --> 00:22:17,200
one and additionally we require p one to

662
00:22:17,200 --> 00:22:18,080
add

663
00:22:18,080 --> 00:22:19,760
uh zero knowledge proofs that this

664
00:22:19,760 --> 00:22:22,000
encryption u was correctly generated

665
00:22:22,000 --> 00:22:23,360
and that this inner product is

666
00:22:23,360 --> 00:22:26,000
consistent with the w w1 it had

667
00:22:26,000 --> 00:22:28,240
at the end of the enrollment phase so i

668
00:22:28,240 --> 00:22:29,760
not get into the details of how we

669
00:22:29,760 --> 00:22:30,960
generate this music

670
00:22:30,960 --> 00:22:32,480
but for the purpose of this talk just

671
00:22:32,480 --> 00:22:34,320
believe me that it's this can be done

672
00:22:34,320 --> 00:22:35,760
efficiently using

673
00:22:35,760 --> 00:22:38,799
existing schemes and literature

674
00:22:38,799 --> 00:22:40,640
and now what does p2 do instead of just

675
00:22:40,640 --> 00:22:42,640
computing the inner product u between u

676
00:22:42,640 --> 00:22:43,679
and w 2

677
00:22:43,679 --> 00:22:45,520
it adds it also to the inner product it

678
00:22:45,520 --> 00:22:47,840
received here to actually send in

679
00:22:47,840 --> 00:22:50,000
an inner product of the you know an

680
00:22:50,000 --> 00:22:52,840
encryption of the inner product itself

681
00:22:52,840 --> 00:22:55,280
okay

682
00:22:55,280 --> 00:22:57,919
um now p1 can just decrypt this and

683
00:22:57,919 --> 00:22:59,200
directly receive the

684
00:22:59,200 --> 00:23:00,799
inner product and proceed with the rest

685
00:23:00,799 --> 00:23:03,440
of the protocol

686
00:23:05,600 --> 00:23:07,919
i skipped over some issues some

687
00:23:07,919 --> 00:23:09,679
challenges here but those are mainly in

688
00:23:09,679 --> 00:23:11,280
terms of generating business it kind of

689
00:23:11,280 --> 00:23:11,919
let you

690
00:23:11,919 --> 00:23:14,480
look at the paper to understand

691
00:23:14,480 --> 00:23:16,480
materials here

692
00:23:16,480 --> 00:23:18,080
but now let me move on to some other

693
00:23:18,080 --> 00:23:20,960
issues with this protocol structure

694
00:23:20,960 --> 00:23:24,320
now notice that in by running this step

695
00:23:24,320 --> 00:23:24,799
here

696
00:23:24,799 --> 00:23:26,720
what happens is that p1 now learns the

697
00:23:26,720 --> 00:23:28,080
decryption

698
00:23:28,080 --> 00:23:29,520
of being the inner product directly in

699
00:23:29,520 --> 00:23:31,200
the clear right and this is too much

700
00:23:31,200 --> 00:23:32,960
leakage because we do not want p1 to

701
00:23:32,960 --> 00:23:34,720
learn any information whatsoever

702
00:23:34,720 --> 00:23:36,720
about either the template or the

703
00:23:36,720 --> 00:23:40,159
measurement that was generated

704
00:23:40,880 --> 00:23:42,799
while p1 knows the measurement since it

705
00:23:42,799 --> 00:23:44,559
uses it shouldn't learn the template so

706
00:23:44,559 --> 00:23:45,840
the inner product leaks information

707
00:23:45,840 --> 00:23:50,159
about the template

708
00:23:50,159 --> 00:23:52,000
how do we prevent that this can just be

709
00:23:52,000 --> 00:23:53,440
done by a simple one-time

710
00:23:53,440 --> 00:23:56,559
uh pad that p2 can add so p2 adds some

711
00:23:56,559 --> 00:23:57,840
randomness r

712
00:23:57,840 --> 00:24:00,400
to the inner product and this heights

713
00:24:00,400 --> 00:24:01,279
are

714
00:24:01,279 --> 00:24:03,520
this hides the anything about w entirely

715
00:24:03,520 --> 00:24:04,320
from p1

716
00:24:04,320 --> 00:24:06,720
point of view and the rest of the

717
00:24:06,720 --> 00:24:09,600
protocol can proceed

718
00:24:09,600 --> 00:24:11,520
the next challenge is how do we ensure

719
00:24:11,520 --> 00:24:13,440
that p1 indeed uses this

720
00:24:13,440 --> 00:24:16,559
value ip that it decrypts in the ot

721
00:24:16,559 --> 00:24:17,600
query

722
00:24:17,600 --> 00:24:20,000
in particular p1 could now just send ot1

723
00:24:20,000 --> 00:24:21,840
for any value that it wants on its own

724
00:24:21,840 --> 00:24:23,679
choice right

725
00:24:23,679 --> 00:24:25,360
and the idea to prevent that is we add

726
00:24:25,360 --> 00:24:27,279
additional one time max so along with

727
00:24:27,279 --> 00:24:27,600
this

728
00:24:27,600 --> 00:24:29,520
encryption of the inner product plus

729
00:24:29,520 --> 00:24:31,120
randomness p2 also

730
00:24:31,120 --> 00:24:34,960
sends a mac on the inner product

731
00:24:34,960 --> 00:24:37,360
the mark on this value and so the cable

732
00:24:37,360 --> 00:24:39,120
circuit will check this mac before it

733
00:24:39,120 --> 00:24:40,559
outputs

734
00:24:40,559 --> 00:24:44,080
the encryption key

735
00:24:45,039 --> 00:24:46,400
i don't have time to get into the

736
00:24:46,400 --> 00:24:48,080
details but i hope you got the gist of

737
00:24:48,080 --> 00:24:49,039
the idea

738
00:24:49,039 --> 00:24:51,360
and the final thing is we also need

739
00:24:51,360 --> 00:24:54,080
additional checks to make sure that

740
00:24:54,080 --> 00:24:58,000
p1 is using the right modulus for u and

741
00:24:58,000 --> 00:24:58,640
w1

742
00:24:58,640 --> 00:25:00,400
since there is no checks whatsoever

743
00:25:00,400 --> 00:25:02,799
especially node checks whatsoever being

744
00:25:02,799 --> 00:25:04,799
placed on the measurement queue

745
00:25:04,799 --> 00:25:06,240
for the sake of the biometric matching

746
00:25:06,240 --> 00:25:07,679
protocol we need to make sure that the

747
00:25:07,679 --> 00:25:09,039
vector view that is picked

748
00:25:09,039 --> 00:25:10,960
is indeed small and satisfies some

749
00:25:10,960 --> 00:25:13,600
modulus checks

750
00:25:13,600 --> 00:25:15,760
but i'll defer that to the paper for

751
00:25:15,760 --> 00:25:18,400
more details

752
00:25:19,279 --> 00:25:20,720
finally to conclude we have we have a

753
00:25:20,720 --> 00:25:22,640
new formal model for

754
00:25:22,640 --> 00:25:24,480
biometric uh threshold biometric

755
00:25:24,480 --> 00:25:25,679
authentication

756
00:25:25,679 --> 00:25:28,559
with the uc secure definition we have

757
00:25:28,559 --> 00:25:30,400
multiple protocols two feasibility

758
00:25:30,400 --> 00:25:31,200
results and one

759
00:25:31,200 --> 00:25:34,640
efficient protocol focus and similarity

760
00:25:34,640 --> 00:25:37,200
and now some open problems can we define

761
00:25:37,200 --> 00:25:40,080
a weaker gain based definition

762
00:25:40,080 --> 00:25:41,760
than the simulation based one that we

763
00:25:41,760 --> 00:25:43,279
have here and perhaps more efficient

764
00:25:43,279 --> 00:25:45,039
protocols with respect to this

765
00:25:45,039 --> 00:25:47,840
weaker definition uh how about

766
00:25:47,840 --> 00:25:49,360
considering other distance functions

767
00:25:49,360 --> 00:25:50,960
like harming distance which is popularly

768
00:25:50,960 --> 00:25:53,440
used for either scans

769
00:25:53,440 --> 00:25:55,679
can we consider a dynamic system where

770
00:25:55,679 --> 00:25:57,279
devices can be added

771
00:25:57,279 --> 00:26:00,960
and removed dynamically

772
00:26:00,960 --> 00:26:02,880
and finally can we consider the case of

773
00:26:02,880 --> 00:26:04,320
adaptive corruption

774
00:26:04,320 --> 00:26:06,240
our protocols and security proofs all

775
00:26:06,240 --> 00:26:09,520
considerably static corruption

776
00:26:09,520 --> 00:26:11,120
thank you and that's the end of my talk

777
00:26:11,120 --> 00:26:25,120
thank you for listening

