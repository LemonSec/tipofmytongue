1
00:00:02,159 --> 00:00:03,679
okay you're ready to go have a good

2
00:00:03,679 --> 00:00:06,080
session

3
00:00:07,600 --> 00:00:09,919
great

4
00:00:15,280 --> 00:00:19,119
okay um well welcome everyone

5
00:00:19,119 --> 00:00:22,320
uh i'm julio and today i'm going to uh

6
00:00:22,320 --> 00:00:26,160
share this fantastic session with payhan

7
00:00:26,160 --> 00:00:28,160
and as we briefly discussed before i'm

8
00:00:28,160 --> 00:00:29,599
going to introduce speakers

9
00:00:29,599 --> 00:00:32,000
and make sure that you go don't go over

10
00:00:32,000 --> 00:00:32,880
time and

11
00:00:32,880 --> 00:00:35,680
bahan will handle questions and monitor

12
00:00:35,680 --> 00:00:37,680
the chat

13
00:00:37,680 --> 00:00:40,960
um so i suggest that we are going to do

14
00:00:40,960 --> 00:00:43,840
a five minutes talk for each fresh paper

15
00:00:43,840 --> 00:00:44,320
and

16
00:00:44,320 --> 00:00:48,079
take the questions right afterwards

17
00:00:48,480 --> 00:00:51,680
so without further ado

18
00:00:51,680 --> 00:00:54,320
the first talk of today is on universal

19
00:00:54,320 --> 00:00:55,600
proxy encryption

20
00:00:55,600 --> 00:01:00,559
and rio is going to give the talk uh rio

21
00:01:01,280 --> 00:01:03,840
yeah okay thank you thank you for the

22
00:01:03,840 --> 00:01:04,720
introduction

23
00:01:04,720 --> 00:01:07,119
and coming to my talk i'm going to talk

24
00:01:07,119 --> 00:01:09,600
about the universal proxy encryption

25
00:01:09,600 --> 00:01:13,280
this is a joint work with nico doctoring

26
00:01:13,280 --> 00:01:16,000
okay in this work we put towards the

27
00:01:16,000 --> 00:01:16,640
notion of

28
00:01:16,640 --> 00:01:18,960
universal functional encryption which is

29
00:01:18,960 --> 00:01:20,960
the generalization of a proxy

30
00:01:20,960 --> 00:01:24,080
encryption we present two main

31
00:01:24,080 --> 00:01:25,040
constructions

32
00:01:25,040 --> 00:01:27,680
one is a universal proxy encryption

33
00:01:27,680 --> 00:01:30,000
scheme based on obvious station

34
00:01:30,000 --> 00:01:32,560
the other one is a relaxed version of

35
00:01:32,560 --> 00:01:34,880
universal proxy encryption based on

36
00:01:34,880 --> 00:01:38,799
garbage circuit okay let's start with

37
00:01:38,799 --> 00:01:39,119
what

38
00:01:39,119 --> 00:01:41,600
is the standard proxy encryption let's

39
00:01:41,600 --> 00:01:43,680
consider the following scenario

40
00:01:43,680 --> 00:01:47,040
alice sends an encrypted email to bob

41
00:01:47,040 --> 00:01:50,000
bob is on vacation so he wants to

42
00:01:50,000 --> 00:01:51,040
forward emails

43
00:01:51,040 --> 00:01:54,640
to chris during his vacation however

44
00:01:54,640 --> 00:01:57,200
chris cannot decrypt the the encrypted

45
00:01:57,200 --> 00:01:59,200
email since chris does not have bob's

46
00:01:59,200 --> 00:02:01,280
decryption key and bob does not

47
00:02:01,280 --> 00:02:03,840
want to reveal his decryption key to

48
00:02:03,840 --> 00:02:06,240
quiz

49
00:02:06,320 --> 00:02:09,360
so here's uh proxy information comes in

50
00:02:09,360 --> 00:02:12,480
uh in proxy reincursion uh

51
00:02:12,480 --> 00:02:15,520
we have uh the uh

52
00:02:15,520 --> 00:02:18,239
reincarnation keys initial algorithm uh

53
00:02:18,239 --> 00:02:19,280
which takes

54
00:02:19,280 --> 00:02:22,560
two uh different uh keys and the

55
00:02:22,560 --> 00:02:24,239
generator

56
00:02:24,239 --> 00:02:28,160
called token or re encryption key

57
00:02:28,160 --> 00:02:30,959
and we also have a re-encryption

58
00:02:30,959 --> 00:02:32,000
algorithm

59
00:02:32,000 --> 00:02:36,400
and this is given to a proxy and

60
00:02:36,400 --> 00:02:39,040
this reenglish algorithm takes our

61
00:02:39,040 --> 00:02:39,840
ciphertext

62
00:02:39,840 --> 00:02:42,959
of ice

63
00:02:42,959 --> 00:02:46,000
a ciphertext to both

64
00:02:46,000 --> 00:02:50,000
and also takes re-encryption key

65
00:02:50,000 --> 00:02:54,080
and generate re-encrypted ciphertext

66
00:02:54,080 --> 00:02:58,159
this can be degraded by chris

67
00:02:58,159 --> 00:03:02,159
so if this proxy

68
00:03:02,159 --> 00:03:05,599
lands re-encryption algorithm then and

69
00:03:05,599 --> 00:03:08,959
powered the included email to chris then

70
00:03:08,959 --> 00:03:09,840
chris

71
00:03:09,840 --> 00:03:13,040
can decrypt the ciphertext

72
00:03:13,040 --> 00:03:16,400
okay however all existing

73
00:03:16,400 --> 00:03:19,120
pre schemes are constructed from scratch

74
00:03:19,120 --> 00:03:20,319
we cannot use

75
00:03:20,319 --> 00:03:22,959
existing pk scheme such as the elgamal

76
00:03:22,959 --> 00:03:24,159
english and layer

77
00:03:24,159 --> 00:03:27,680
encryption and we can convert ciphertext

78
00:03:27,680 --> 00:03:30,720
between the same scheme

79
00:03:30,720 --> 00:03:33,840
so our question is uh can we convert the

80
00:03:33,840 --> 00:03:35,040
ciphertext of

81
00:03:35,040 --> 00:03:37,599
some schemax into a ciphertext of scheme

82
00:03:37,599 --> 00:03:38,319
y

83
00:03:38,319 --> 00:03:40,560
for example can we convert the

84
00:03:40,560 --> 00:03:42,480
ciphertext over algomary encryption

85
00:03:42,480 --> 00:03:45,599
into a cybertext of regular encryption

86
00:03:45,599 --> 00:03:49,680
so this is our main question

87
00:03:49,680 --> 00:03:53,120
so uh proxy universal proxy language

88
00:03:53,120 --> 00:03:56,400
solves this problem uh there are two

89
00:03:56,400 --> 00:03:58,560
different public key encryption schemes

90
00:03:58,560 --> 00:03:59,519
one is

91
00:03:59,519 --> 00:04:03,120
of one way is by derivatives uh scheme

92
00:04:03,120 --> 00:04:05,760
the other one is delegate stream uh for

93
00:04:05,760 --> 00:04:06,799
example we

94
00:04:06,799 --> 00:04:10,400
we can use the algorithm and the level

95
00:04:10,400 --> 00:04:11,360
encryption

96
00:04:11,360 --> 00:04:14,480
so these uh encryption schemes each a

97
00:04:14,480 --> 00:04:16,079
key generation algorithm output

98
00:04:16,079 --> 00:04:19,358
the key pair and each

99
00:04:19,358 --> 00:04:21,680
cyber english algorithm output the

100
00:04:21,680 --> 00:04:23,199
ciphertext

101
00:04:23,199 --> 00:04:25,759
and the universal proxy reaction

102
00:04:25,759 --> 00:04:26,880
consists of

103
00:04:26,880 --> 00:04:29,919
two algorithms one is a re

104
00:04:29,919 --> 00:04:32,720
encryption key generation algorithm this

105
00:04:32,720 --> 00:04:33,680
takes

106
00:04:33,680 --> 00:04:38,000
uh two keys of delegator and derivative

107
00:04:38,000 --> 00:04:38,800
and other

108
00:04:38,800 --> 00:04:42,479
re-encryption key and the other

109
00:04:42,479 --> 00:04:44,639
algorithm is the encryption algorithm

110
00:04:44,639 --> 00:04:45,759
that takes uh

111
00:04:45,759 --> 00:04:48,639
derivatives ciphertext and re-encryption

112
00:04:48,639 --> 00:04:49,280
key

113
00:04:49,280 --> 00:04:52,000
then output a ciphertext of delegates

114
00:04:52,000 --> 00:04:52,960
scheme

115
00:04:52,960 --> 00:04:56,000
so this ciphertext is uh

116
00:04:56,000 --> 00:04:58,960
in the ciphertext of the legislation

117
00:04:58,960 --> 00:04:59,520
scheme

118
00:04:59,520 --> 00:05:02,160
so we can decrypt this the encrypted

119
00:05:02,160 --> 00:05:02,960
ciphertext

120
00:05:02,960 --> 00:05:06,160
by using the decryption algorithm of the

121
00:05:06,160 --> 00:05:09,199
delegated scheme this is a universal

122
00:05:09,199 --> 00:05:12,000
proxy encryption

123
00:05:12,000 --> 00:05:14,800
we can consider a relaxed version of

124
00:05:14,800 --> 00:05:16,560
universal proxy encryption

125
00:05:16,560 --> 00:05:18,960
uh the english on key generation

126
00:05:18,960 --> 00:05:19,840
algorithm is

127
00:05:19,840 --> 00:05:23,919
the same as upre however re-english on

128
00:05:23,919 --> 00:05:25,680
algorithm is a bit different

129
00:05:25,680 --> 00:05:28,800
this algorithm output or ciphertext

130
00:05:28,800 --> 00:05:31,600
but the included ciphertext but this

131
00:05:31,600 --> 00:05:34,240
might not be in the ciphertext of

132
00:05:34,240 --> 00:05:37,840
delegates so we need to

133
00:05:37,840 --> 00:05:40,160
modify the directional algorithm uh in

134
00:05:40,160 --> 00:05:41,600
relaxed upr scheme

135
00:05:41,600 --> 00:05:44,000
but we can use the original uh

136
00:05:44,000 --> 00:05:44,960
decryption key

137
00:05:44,960 --> 00:05:48,080
of the deleted scheme so we do not

138
00:05:48,080 --> 00:05:51,440
need to change the decryption key uh

139
00:05:51,440 --> 00:05:54,560
of the the the original dedication key

140
00:05:54,560 --> 00:05:56,639
but we need a slightly modified

141
00:05:56,639 --> 00:05:57,759
degradation algorithm

142
00:05:57,759 --> 00:06:02,240
to decrypt early included ciphertext

143
00:06:02,960 --> 00:06:06,240
so the this universal approach reaction

144
00:06:06,240 --> 00:06:07,039
has a new

145
00:06:07,039 --> 00:06:09,759
application of proxy encryption we can

146
00:06:09,759 --> 00:06:10,639
use this

147
00:06:10,639 --> 00:06:13,280
uh for for migration of the encryption

148
00:06:13,280 --> 00:06:14,319
system

149
00:06:14,319 --> 00:06:17,600
uh if uh quantum computers are available

150
00:06:17,600 --> 00:06:19,840
rsa or the discrete or the best

151
00:06:19,840 --> 00:06:20,800
encryption with the

152
00:06:20,800 --> 00:06:23,919
broker so we want to migrate from

153
00:06:23,919 --> 00:06:26,560
obsolete or variable encryption to new

154
00:06:26,560 --> 00:06:27,280
one

155
00:06:27,280 --> 00:06:30,800
we can delegate this re-encryption uh

156
00:06:30,800 --> 00:06:34,080
the encryption to some cloud

157
00:06:34,080 --> 00:06:37,360
this crowd uh saves the tremendous

158
00:06:37,360 --> 00:06:37,919
amount of

159
00:06:37,919 --> 00:06:41,680
aggregated data uh if our user wants to

160
00:06:41,680 --> 00:06:45,120
uh migrate from uh such as

161
00:06:45,120 --> 00:06:46,800
rsa encryption system to regular

162
00:06:46,800 --> 00:06:48,560
encryption system then we can

163
00:06:48,560 --> 00:06:51,599
use uh universal proxy encryption and

164
00:06:51,599 --> 00:06:56,720
the user just re-encryption

165
00:06:56,720 --> 00:06:58,880
the encryption key to the cloud then the

166
00:06:58,880 --> 00:07:00,000
cloud

167
00:07:00,000 --> 00:07:03,520
can re-encrypt the ciphertext instead of

168
00:07:03,520 --> 00:07:06,000
the user

169
00:07:06,880 --> 00:07:10,160
okay uh so i'm running

170
00:07:10,160 --> 00:07:14,400
time so i skip the construction overview

171
00:07:14,400 --> 00:07:17,360
so our result is uh as uh summer this is

172
00:07:17,360 --> 00:07:18,639
summary of our result

173
00:07:18,639 --> 00:07:21,599
we define uh the notion of universal

174
00:07:21,599 --> 00:07:22,960
proxy encryption

175
00:07:22,960 --> 00:07:26,080
and we propose two construction one is

176
00:07:26,080 --> 00:07:26,479
uh

177
00:07:26,479 --> 00:07:29,440
based on uh overstation the other one is

178
00:07:29,440 --> 00:07:30,880
the relaxed version of

179
00:07:30,880 --> 00:07:33,520
universal proxy encryption but it is

180
00:07:33,520 --> 00:07:34,319
based on

181
00:07:34,319 --> 00:07:37,280
just the standard uh assumption uh

182
00:07:37,280 --> 00:07:38,800
double search

183
00:07:38,800 --> 00:07:43,120
we only assumed uh one-way function

184
00:07:43,120 --> 00:07:45,840
thank you

185
00:07:46,479 --> 00:07:50,318
uh any questions from the audience

186
00:07:52,319 --> 00:07:55,599
um i have a quick question so um

187
00:07:55,599 --> 00:07:57,840
in terms of definition did you only

188
00:07:57,840 --> 00:08:00,479
define it in a unidirectional

189
00:08:00,479 --> 00:08:03,599
uh scenario or you also have a

190
00:08:03,599 --> 00:08:06,240
definition for y direction or upre

191
00:08:06,240 --> 00:08:09,120
yeah in our paper we only define the

192
00:08:09,120 --> 00:08:10,560
unidirectional

193
00:08:10,560 --> 00:08:13,599
one but we can define bi-directional one

194
00:08:13,599 --> 00:08:16,720
and uh we we achieve the unidirectional

195
00:08:16,720 --> 00:08:18,560
schemes

196
00:08:18,560 --> 00:08:20,879
do you think bi-directional might be uh

197
00:08:20,879 --> 00:08:22,240
easier to construct

198
00:08:22,240 --> 00:08:25,039
or there's a specific reason that should

199
00:08:25,039 --> 00:08:26,160
only defines for

200
00:08:26,160 --> 00:08:29,599
uni-directional i'm not sure about the

201
00:08:29,599 --> 00:08:31,759
universal proxy encryption case uh

202
00:08:31,759 --> 00:08:35,440
in general standard proxy encryption it

203
00:08:35,440 --> 00:08:36,479
is easier to

204
00:08:36,479 --> 00:08:38,479
actually provide that bi-directional

205
00:08:38,479 --> 00:08:40,000
scheme but i'm not

206
00:08:40,000 --> 00:08:43,760
sure it is easier to

207
00:08:43,760 --> 00:08:47,040
achieve in upro case

208
00:08:47,040 --> 00:08:49,920
yeah okay

209
00:08:50,800 --> 00:08:55,839
thank the speaker again thank you

210
00:09:03,440 --> 00:09:07,680
okay um we have a few more minutes

211
00:09:07,680 --> 00:09:09,440
i think one more minute for question but

212
00:09:09,440 --> 00:09:11,440
if they're none maybe the next speaker

213
00:09:11,440 --> 00:09:23,839
can start sharing the screen

214
00:09:24,560 --> 00:09:28,560
good okay so our next sorry sorry yeah

215
00:09:28,560 --> 00:09:31,760
phone okay um

216
00:09:31,760 --> 00:09:33,680
sorry you're just about to ask if you

217
00:09:33,680 --> 00:09:35,120
can see the slides but

218
00:09:35,120 --> 00:09:38,880
yes it looks good and

219
00:09:38,880 --> 00:09:42,480
i think i can hear you well as well and

220
00:09:42,480 --> 00:09:45,760
yeah so let's uh let's get right into it

221
00:09:45,760 --> 00:09:47,920
uh our next talk is going to be

222
00:09:47,920 --> 00:09:49,839
efficient adaptively secure

223
00:09:49,839 --> 00:09:52,480
ibm cams and vrfs by a near collision

224
00:09:52,480 --> 00:09:53,839
resistance

225
00:09:53,839 --> 00:09:56,480
and david is going to give the talk

226
00:09:56,480 --> 00:09:56,880
please

227
00:09:56,880 --> 00:09:59,680
yeah hello everyone and welcome and

228
00:09:59,680 --> 00:10:01,680
thank you for the kite attraction julio

229
00:10:01,680 --> 00:10:03,519
i will be presenting joint work with

230
00:10:03,519 --> 00:10:05,440
tebow yaga and rafa akurik about

231
00:10:05,440 --> 00:10:07,279
constructing efficient adaptively secure

232
00:10:07,279 --> 00:10:09,040
ibes and vr apps from near collision

233
00:10:09,040 --> 00:10:11,120
resistant hash functions

234
00:10:11,120 --> 00:10:12,959
in terms of contributions we introduce

235
00:10:12,959 --> 00:10:14,640
new collision resistance as a natural

236
00:10:14,640 --> 00:10:16,720
assumption for hash functions

237
00:10:16,720 --> 00:10:18,240
that allow us to efficiently achieve

238
00:10:18,240 --> 00:10:20,000
adaptive security while avoiding the

239
00:10:20,000 --> 00:10:22,160
random outcome methodology

240
00:10:22,160 --> 00:10:23,680
furthermore we present four efficient

241
00:10:23,680 --> 00:10:25,519
constructions that use the technique

242
00:10:25,519 --> 00:10:27,279
first the variant of water's ibe with

243
00:10:27,279 --> 00:10:28,959
only logarithmically many group elements

244
00:10:28,959 --> 00:10:30,000
in the public key

245
00:10:30,000 --> 00:10:31,839
and then we also show how the technique

246
00:10:31,839 --> 00:10:33,600
can be applied in the lattice context by

247
00:10:33,600 --> 00:10:36,000
presenting an ibe secure under lwe with

248
00:10:36,000 --> 00:10:37,680
only logarithmically many matrices in

249
00:10:37,680 --> 00:10:39,680
the public key

250
00:10:39,680 --> 00:10:42,000
um furthermore we also show that the ib

251
00:10:42,000 --> 00:10:44,000
cam by my two co-authors from asiacrypt

252
00:10:44,000 --> 00:10:45,279
2018

253
00:10:45,279 --> 00:10:46,959
is also secure with a quadratically

254
00:10:46,959 --> 00:10:48,399
better loss

255
00:10:48,399 --> 00:10:50,079
finally we also present a verified

256
00:10:50,079 --> 00:10:52,320
random function with only a logarithmic

257
00:10:52,320 --> 00:10:53,200
number of

258
00:10:53,200 --> 00:10:54,399
group elements in the public

259
00:10:54,399 --> 00:10:57,120
verification key and in the

260
00:10:57,120 --> 00:11:00,000
proofs of correctness as a bonus when i

261
00:11:00,000 --> 00:11:01,760
said logarithmic before

262
00:11:01,760 --> 00:11:03,279
these numbers were only not

263
00:11:03,279 --> 00:11:05,839
asymptotically small but also concretely

264
00:11:05,839 --> 00:11:08,800
that is for a security parameter of 128

265
00:11:08,800 --> 00:11:09,839
these numbers

266
00:11:09,839 --> 00:11:11,760
as this number is only eight group

267
00:11:11,760 --> 00:11:13,519
elements or matrices depending on the

268
00:11:13,519 --> 00:11:14,399
construction

269
00:11:14,399 --> 00:11:16,000
and of course plus a small constant

270
00:11:16,000 --> 00:11:17,680
number of group elements or matrices for

271
00:11:17,680 --> 00:11:19,920
the specific construction

272
00:11:19,920 --> 00:11:21,680
first i'd like to informally introduce

273
00:11:21,680 --> 00:11:23,120
new collision resistance as an

274
00:11:23,120 --> 00:11:24,240
assumption

275
00:11:24,240 --> 00:11:25,839
that is when we assume that the family

276
00:11:25,839 --> 00:11:27,440
of hash functions is near collision

277
00:11:27,440 --> 00:11:28,320
resistant

278
00:11:28,320 --> 00:11:29,760
that means that we assume that the

279
00:11:29,760 --> 00:11:31,360
birthday attack is the most efficient

280
00:11:31,360 --> 00:11:33,040
attack and finding collision

281
00:11:33,040 --> 00:11:35,360
also on subset of the outer bits and not

282
00:11:35,360 --> 00:11:36,800
only on the complete output of the

283
00:11:36,800 --> 00:11:38,480
standard of the hash function

284
00:11:38,480 --> 00:11:40,720
as for standard collision resistance

285
00:11:40,720 --> 00:11:42,560
that is for a hash function with 16

286
00:11:42,560 --> 00:11:44,640
output bits as depicted here

287
00:11:44,640 --> 00:11:47,279
we assume that every algorithm that runs

288
00:11:47,279 --> 00:11:49,200
in time t has at most a chance

289
00:11:49,200 --> 00:11:51,519
of t squared over two to the sixth in

290
00:11:51,519 --> 00:11:52,959
finding collision on the first

291
00:11:52,959 --> 00:11:55,279
six output bits however for near

292
00:11:55,279 --> 00:11:56,000
collision resistance

293
00:11:56,000 --> 00:11:58,000
we also assume this for arbitrary subset

294
00:11:58,000 --> 00:11:59,120
of the output bits

295
00:11:59,120 --> 00:12:02,160
and not only for prefixes now let's look

296
00:12:02,160 --> 00:12:04,160
into how we can leverage this assumption

297
00:12:04,160 --> 00:12:07,120
to efficiently achieve adaptive security

298
00:12:07,120 --> 00:12:08,800
for the idea assume that we are in the

299
00:12:08,800 --> 00:12:10,240
reduction from some complexity

300
00:12:10,240 --> 00:12:12,079
assumption to the adept security of an

301
00:12:12,079 --> 00:12:12,800
ibe

302
00:12:12,800 --> 00:12:14,160
and we know sufficiently good

303
00:12:14,160 --> 00:12:15,760
approximations of the adversary's

304
00:12:15,760 --> 00:12:18,560
runtime t and its advantage epsilon

305
00:12:18,560 --> 00:12:20,079
we then leverage this knowledge to

306
00:12:20,079 --> 00:12:22,079
achieve to choose a subset i of output

307
00:12:22,079 --> 00:12:22,720
bits

308
00:12:22,720 --> 00:12:24,639
of the hash function such that first

309
00:12:24,639 --> 00:12:26,880
adversary we cannot find a collision

310
00:12:26,880 --> 00:12:28,560
with probability better than epsilon

311
00:12:28,560 --> 00:12:30,320
over 2 in its runtime

312
00:12:30,320 --> 00:12:31,519
and second that the number of

313
00:12:31,519 --> 00:12:33,600
possibilities on these output bits is

314
00:12:33,600 --> 00:12:34,880
polynomial

315
00:12:34,880 --> 00:12:37,440
the idea is then in the reduction to

316
00:12:37,440 --> 00:12:39,200
guess the hash of the challenge identity

317
00:12:39,200 --> 00:12:41,120
and the subset of algebra's i

318
00:12:41,120 --> 00:12:42,720
since there are only polynomially many

319
00:12:42,720 --> 00:12:44,399
possibilities our guess will be correct

320
00:12:44,399 --> 00:12:46,000
with the probability of at least

321
00:12:46,000 --> 00:12:48,320
one over some polynomial furthermore

322
00:12:48,320 --> 00:12:49,839
since adversary can only find a

323
00:12:49,839 --> 00:12:51,680
collision with probability of at most

324
00:12:51,680 --> 00:12:53,920
epsilon over two on the subset it is

325
00:12:53,920 --> 00:12:55,600
also sufficiently unlikely

326
00:12:55,600 --> 00:12:57,839
to make a user secret key query that

327
00:12:57,839 --> 00:12:59,760
matches our guess

328
00:12:59,760 --> 00:13:02,240
as you might have noticed our goals for

329
00:13:02,240 --> 00:13:04,160
choosing the size of this set i

330
00:13:04,160 --> 00:13:05,680
are conflicting meaning we want to

331
00:13:05,680 --> 00:13:07,839
choose i as small as possible to make

332
00:13:07,839 --> 00:13:09,519
the probability of guessing correctly as

333
00:13:09,519 --> 00:13:10,720
large as possible

334
00:13:10,720 --> 00:13:12,160
but at the same time keeping the

335
00:13:12,160 --> 00:13:14,240
collision probability on the chosen

336
00:13:14,240 --> 00:13:16,880
position sufficient sufficiently small

337
00:13:16,880 --> 00:13:18,959
trading of these two goals thus leads to

338
00:13:18,959 --> 00:13:20,160
ideal choice

339
00:13:20,160 --> 00:13:23,200
for the size of this index at i previous

340
00:13:23,200 --> 00:13:25,680
constructions however choose a set

341
00:13:25,680 --> 00:13:28,399
um and its size sub optimally more

342
00:13:28,399 --> 00:13:29,920
specifically they choose i

343
00:13:29,920 --> 00:13:32,160
as a prefix of length the smallest power

344
00:13:32,160 --> 00:13:34,480
of 2 larger than the ideal size

345
00:13:34,480 --> 00:13:37,040
by that choosing i almost twice the size

346
00:13:37,040 --> 00:13:39,680
of an ideal choice in the worst case

347
00:13:39,680 --> 00:13:42,560
for example if 5 was an ideal choice

348
00:13:42,560 --> 00:13:44,079
previous construction would choose a

349
00:13:44,079 --> 00:13:45,839
prefix of length 8.

350
00:13:45,839 --> 00:13:47,760
our approach maintains the small key

351
00:13:47,760 --> 00:13:49,920
sizes while at the same time improving

352
00:13:49,920 --> 00:13:52,079
the tightness loss quadratically

353
00:13:52,079 --> 00:13:53,760
that is we cut the output of the hash

354
00:13:53,760 --> 00:13:55,680
function in block

355
00:13:55,680 --> 00:13:57,120
and blocks of exponentially growing

356
00:13:57,120 --> 00:13:59,680
lengths meaning a first block h0 of one

357
00:13:59,680 --> 00:14:01,680
bit then the second block h1 consisting

358
00:14:01,680 --> 00:14:02,320
of two bits

359
00:14:02,320 --> 00:14:04,880
and so on and so forth resent represents

360
00:14:04,880 --> 00:14:06,320
a deal size of i

361
00:14:06,320 --> 00:14:08,720
as a sum of powers of two and choose i

362
00:14:08,720 --> 00:14:10,240
as a set of output bits in their

363
00:14:10,240 --> 00:14:11,519
respective blocks

364
00:14:11,519 --> 00:14:14,000
meaning if 5 is the ideal choice then we

365
00:14:14,000 --> 00:14:16,240
would choose the blocks h0 and h2

366
00:14:16,240 --> 00:14:19,120
since together they make up five bits

367
00:14:19,120 --> 00:14:20,800
due to the time limitations we won't be

368
00:14:20,800 --> 00:14:21,680
able to cover

369
00:14:21,680 --> 00:14:23,199
how exactly this is embedded in a

370
00:14:23,199 --> 00:14:24,959
construction and how it maintains the

371
00:14:24,959 --> 00:14:26,720
small key sizes and we have to refer to

372
00:14:26,720 --> 00:14:27,760
the paper for more

373
00:14:27,760 --> 00:14:31,040
explanation summing up we introduced

374
00:14:31,040 --> 00:14:32,959
near collision resistance as a mild hash

375
00:14:32,959 --> 00:14:34,480
function assumption that allows to

376
00:14:34,480 --> 00:14:35,440
efficiently

377
00:14:35,440 --> 00:14:37,360
replace the random overkill model for

378
00:14:37,360 --> 00:14:39,040
achieving adaptive security

379
00:14:39,040 --> 00:14:40,800
furthermore we show how it can be used

380
00:14:40,800 --> 00:14:42,399
to construct ibes from pairings and

381
00:14:42,399 --> 00:14:43,839
lattices and how it can be used to

382
00:14:43,839 --> 00:14:45,760
construct a vrf from pairings

383
00:14:45,760 --> 00:14:48,399
and all of these very efficiently last

384
00:14:48,399 --> 00:14:49,199
but not least

385
00:14:49,199 --> 00:14:50,639
thank you very much for your attention

386
00:14:50,639 --> 00:14:52,160
and if you have any questions feel free

387
00:14:52,160 --> 00:14:53,360
to look it up into

388
00:14:53,360 --> 00:14:56,079
our in our paper or write us an email or

389
00:14:56,079 --> 00:14:56,639
of course

390
00:14:56,639 --> 00:14:58,959
us right now i'll also be available on

391
00:14:58,959 --> 00:15:00,639
zulub throughout the conference so

392
00:15:00,639 --> 00:15:03,360
if questions come up later on feel free

393
00:15:03,360 --> 00:15:04,720
to write me a message or also my

394
00:15:04,720 --> 00:15:05,680
co-authors

395
00:15:05,680 --> 00:15:08,399
thank you very much

396
00:15:11,279 --> 00:15:15,120
any questions from the audience

397
00:15:17,120 --> 00:15:19,600
feel free to type your questions on the

398
00:15:19,600 --> 00:15:20,720
chat or just

399
00:15:20,720 --> 00:15:26,240
speak up

400
00:15:26,240 --> 00:15:28,720
i have one quick question so the notion

401
00:15:28,720 --> 00:15:30,880
of mere collision resistance

402
00:15:30,880 --> 00:15:34,480
is it a new proposed in this paper

403
00:15:34,480 --> 00:15:37,600
or it was in the literature

404
00:15:37,600 --> 00:15:40,000
yes and no so some of it is in the

405
00:15:40,000 --> 00:15:41,920
literature for example if you look

406
00:15:41,920 --> 00:15:45,759
into the book um on applied cryptography

407
00:15:45,759 --> 00:15:47,600
from minetsys

408
00:15:47,600 --> 00:15:49,440
so we don't have a second author's name

409
00:15:49,440 --> 00:15:51,759
um they already mentioned it

410
00:15:51,759 --> 00:15:55,680
also some in the context of

411
00:15:55,680 --> 00:15:57,920
security of hash functions it also comes

412
00:15:57,920 --> 00:15:59,759
up sometimes

413
00:15:59,759 --> 00:16:02,720
for attacking hash functions but in the

414
00:16:02,720 --> 00:16:04,880
specific notation that we use

415
00:16:04,880 --> 00:16:07,279
it is new it is an adaptation or more

416
00:16:07,279 --> 00:16:08,639
general

417
00:16:08,639 --> 00:16:10,639
formulation of truncation collision

418
00:16:10,639 --> 00:16:12,560
resistance that matuko also

419
00:16:12,560 --> 00:16:16,880
introduced in the asia crypt 2018 paper

420
00:16:16,880 --> 00:16:20,000
so is the new flavor coming from the

421
00:16:20,000 --> 00:16:22,880
adaptive security part

422
00:16:22,880 --> 00:16:26,800
um no it's more about the tightness so

423
00:16:26,800 --> 00:16:29,839
what i presented with um guessing the

424
00:16:29,839 --> 00:16:31,440
prefix

425
00:16:31,440 --> 00:16:33,360
that originally goes back to the

426
00:16:33,360 --> 00:16:34,839
confined guessing techniques or

427
00:16:34,839 --> 00:16:36,639
signatures and

428
00:16:36,639 --> 00:16:39,360
in the age of 2018 paper it was then

429
00:16:39,360 --> 00:16:41,440
used in the context of ibes and for hash

430
00:16:41,440 --> 00:16:42,000
functions

431
00:16:42,000 --> 00:16:43,600
where they considered specifically

432
00:16:43,600 --> 00:16:46,079
prefixes of the hash function

433
00:16:46,079 --> 00:16:49,120
and now choosing arbitrary subsets

434
00:16:49,120 --> 00:16:52,240
of the output bits allows us to do

435
00:16:52,240 --> 00:16:55,040
allows us to achieve a better tightness

436
00:16:55,040 --> 00:16:56,320
that's the rough

437
00:16:56,320 --> 00:16:58,959
history of that definition and its

438
00:16:58,959 --> 00:17:00,959
changes

439
00:17:00,959 --> 00:17:04,240
i see thanks

440
00:17:04,240 --> 00:17:07,359
any other questions

441
00:17:10,079 --> 00:17:13,599
so i i have a quick question um

442
00:17:13,599 --> 00:17:17,520
in terms of um actual instantiation of

443
00:17:17,520 --> 00:17:18,799
this hash function

444
00:17:18,799 --> 00:17:21,199
do you need something with structure

445
00:17:21,199 --> 00:17:22,160
like uh

446
00:17:22,160 --> 00:17:24,559
group base or any any hash function like

447
00:17:24,559 --> 00:17:28,480
shot 256 would work for you

448
00:17:28,799 --> 00:17:30,720
so for instantiation we would most

449
00:17:30,720 --> 00:17:32,640
likely assume that modern hash functions

450
00:17:32,640 --> 00:17:35,120
have this property since for example sha

451
00:17:35,120 --> 00:17:35,760
3 or

452
00:17:35,760 --> 00:17:37,640
keshack are proven to be

453
00:17:37,640 --> 00:17:40,799
indifferentiability from a random oracle

454
00:17:40,799 --> 00:17:43,360
however in a slightly idealized model

455
00:17:43,360 --> 00:17:44,000
and

456
00:17:44,000 --> 00:17:48,080
also in the literature

457
00:17:48,080 --> 00:17:50,640
near collision resistance is mentioned

458
00:17:50,640 --> 00:17:51,280
as a design

459
00:17:51,280 --> 00:17:54,559
goal for hash functions

460
00:17:54,559 --> 00:17:57,679
however if we look at

461
00:17:57,679 --> 00:17:59,679
complexity assumptions like discrete

462
00:17:59,679 --> 00:18:01,600
logarithm or

463
00:18:01,600 --> 00:18:03,520
similar assumptions also from the

464
00:18:03,520 --> 00:18:04,799
lattice context

465
00:18:04,799 --> 00:18:08,240
um at least we are not aware of any

466
00:18:08,240 --> 00:18:09,919
probably secure constructions that

467
00:18:09,919 --> 00:18:12,160
achieve this notion nonetheless we

468
00:18:12,160 --> 00:18:16,559
deem it to be a plausible and to be

469
00:18:16,559 --> 00:18:18,240
a mild alternative compared to the

470
00:18:18,240 --> 00:18:21,280
random outcome orders

471
00:18:23,280 --> 00:18:26,480
thanks welcome

472
00:18:26,480 --> 00:18:29,840
any other questions

473
00:18:30,160 --> 00:18:31,760
maybe i can ask you a clarifying

474
00:18:31,760 --> 00:18:34,080
question so so what makes it

475
00:18:34,080 --> 00:18:35,919
kind of a good alternative to the random

476
00:18:35,919 --> 00:18:37,760
workflow model um

477
00:18:37,760 --> 00:18:39,600
the program security because what if you

478
00:18:39,600 --> 00:18:41,280
just use a collision resistant hash

479
00:18:41,280 --> 00:18:42,000
function is that

480
00:18:42,000 --> 00:18:46,400
not enough i think or is that too much

481
00:18:47,039 --> 00:18:49,919
if you use a complete collision

482
00:18:49,919 --> 00:18:51,039
resistant hash function

483
00:18:51,039 --> 00:18:55,679
like shar 3 with 256 output bits

484
00:18:55,679 --> 00:18:57,760
then you would have to guess the

485
00:18:57,760 --> 00:18:59,280
complete hash function output and you

486
00:18:59,280 --> 00:19:00,240
would probably be

487
00:19:00,240 --> 00:19:01,919
wrong with your guess in the reduction

488
00:19:01,919 --> 00:19:03,919
with a very high probability

489
00:19:03,919 --> 00:19:06,640
uh what we also thought about was for

490
00:19:06,640 --> 00:19:07,919
example

491
00:19:07,919 --> 00:19:11,120
um sha-3 also has

492
00:19:11,120 --> 00:19:13,600
extendable output function modes where

493
00:19:13,600 --> 00:19:15,200
you can also

494
00:19:15,200 --> 00:19:17,440
just use a prefix of the hash function

495
00:19:17,440 --> 00:19:19,840
or smaller versions of it

496
00:19:19,840 --> 00:19:22,640
and we thought about concatenating

497
00:19:22,640 --> 00:19:23,280
different

498
00:19:23,280 --> 00:19:25,280
lengths hash functions together and then

499
00:19:25,280 --> 00:19:26,400
using those

500
00:19:26,400 --> 00:19:30,240
however those do not seem to work due to

501
00:19:30,240 --> 00:19:31,919
the multi-collision attacks by

502
00:19:31,919 --> 00:19:35,440
june from 2004 so because then

503
00:19:35,440 --> 00:19:38,559
you can more easily find collisions

504
00:19:38,559 --> 00:19:41,280
on the concatenation of hash functions

505
00:19:41,280 --> 00:19:42,640
than you would

506
00:19:42,640 --> 00:19:45,520
on single ones

507
00:19:45,919 --> 00:19:47,360
so that was the closest that we could

508
00:19:47,360 --> 00:19:49,679
get to actually

509
00:19:49,679 --> 00:19:52,160
instead instantiating it from complete

510
00:19:52,160 --> 00:19:54,559
from standard collision resistance

511
00:19:54,559 --> 00:19:57,918
does that answer the question

512
00:20:02,080 --> 00:20:07,280
thank you speaker again

513
00:20:07,280 --> 00:20:11,039
um okay we are right on time so if the

514
00:20:11,039 --> 00:20:15,520
speaker for the next paper can share a

515
00:20:18,840 --> 00:20:20,799
screen

516
00:20:20,799 --> 00:20:24,480
perfect um so

517
00:20:24,480 --> 00:20:26,000
so the next talk is going to be about

518
00:20:26,000 --> 00:20:27,440
subversion resilient public key

519
00:20:27,440 --> 00:20:30,080
encryption with practical watchdogs

520
00:20:30,080 --> 00:20:32,960
and pascal is giving the talk thank you

521
00:20:32,960 --> 00:20:34,080
very much

522
00:20:34,080 --> 00:20:35,760
so hello and welcome to my talk on

523
00:20:35,760 --> 00:20:36,960
subversion business public key

524
00:20:36,960 --> 00:20:38,799
encryption with practical watchdogs my

525
00:20:38,799 --> 00:20:40,400
name is tasker berman and this is joint

526
00:20:40,400 --> 00:20:41,840
work together with fong mao chen and

527
00:20:41,840 --> 00:20:44,480
tiba yaga

528
00:20:45,679 --> 00:20:48,000
all right so back in 2013 the snowden

529
00:20:48,000 --> 00:20:49,440
revelations showed that

530
00:20:49,440 --> 00:20:51,039
state-level adversaries were able to

531
00:20:51,039 --> 00:20:52,960
influence and manipulate the

532
00:20:52,960 --> 00:20:54,240
implementation of widely used

533
00:20:54,240 --> 00:20:56,240
cryptographic schemes which led to a

534
00:20:56,240 --> 00:20:58,080
whole series of scientific works showing

535
00:20:58,080 --> 00:20:58,799
how to

536
00:20:58,799 --> 00:21:00,240
model these kind of attacks and also

537
00:21:00,240 --> 00:21:02,640
coming up with possible counter measures

538
00:21:02,640 --> 00:21:05,200
one of these condom measures are the

539
00:21:05,200 --> 00:21:06,320
so-called watchdogs

540
00:21:06,320 --> 00:21:07,840
which are trusted parties that test

541
00:21:07,840 --> 00:21:09,440
subverted implementation

542
00:21:09,440 --> 00:21:10,480
while there are different classes of

543
00:21:10,480 --> 00:21:12,480
watchdogs in this work we will focus on

544
00:21:12,480 --> 00:21:14,000
offline watchdogs which i will explain

545
00:21:14,000 --> 00:21:15,200
now

546
00:21:15,200 --> 00:21:17,120
so there are two phases in the first

547
00:21:17,120 --> 00:21:19,280
phase the watchdog is aware of an on

548
00:21:19,280 --> 00:21:20,640
specification of the

549
00:21:20,640 --> 00:21:22,640
cryptographic scheme and it knows the

550
00:21:22,640 --> 00:21:24,960
input and output behavior

551
00:21:24,960 --> 00:21:27,440
then the adversary provides an

552
00:21:27,440 --> 00:21:28,960
implementation of the specification

553
00:21:28,960 --> 00:21:31,440
which may deviate in any possible way

554
00:21:31,440 --> 00:21:33,600
and the task of the watchdog is to

555
00:21:33,600 --> 00:21:35,039
compare the inlet outputs of the

556
00:21:35,039 --> 00:21:36,960
specification and implementation to

557
00:21:36,960 --> 00:21:40,240
see if they match if they match the

558
00:21:40,240 --> 00:21:43,520
watchdog accepts the implementation and

559
00:21:43,520 --> 00:21:44,480
otherwise

560
00:21:44,480 --> 00:21:46,640
the signals there's some backdoor

561
00:21:46,640 --> 00:21:48,400
possibly embedded

562
00:21:48,400 --> 00:21:50,080
after the second phase your usual

563
00:21:50,080 --> 00:21:51,919
security experiment in our case

564
00:21:51,919 --> 00:21:54,080
the cpa security game is executed

565
00:21:54,080 --> 00:21:55,919
however the twist is here that instead

566
00:21:55,919 --> 00:21:56,720
of your

567
00:21:56,720 --> 00:22:00,000
usual algorithms you execute the

568
00:22:00,000 --> 00:22:01,120
security experiment

569
00:22:01,120 --> 00:22:02,720
with implementation provided by the

570
00:22:02,720 --> 00:22:05,120
adversary

571
00:22:05,120 --> 00:22:06,799
so what does then security mean in this

572
00:22:06,799 --> 00:22:08,799
model in previous works you have

573
00:22:08,799 --> 00:22:10,320
asymptotic definitions where you use

574
00:22:10,320 --> 00:22:12,080
some polynomial time watchdog

575
00:22:12,080 --> 00:22:13,679
and you have it either this polynomial

576
00:22:13,679 --> 00:22:15,200
time watchdog has some non-negligible

577
00:22:15,200 --> 00:22:17,520
detection advantage or you have your

578
00:22:17,520 --> 00:22:20,400
security guarantee like cpa security we

579
00:22:20,400 --> 00:22:21,760
identified some potential problems with

580
00:22:21,760 --> 00:22:23,120
this kind of definition

581
00:22:23,120 --> 00:22:25,360
for one you don't have a specific run

582
00:22:25,360 --> 00:22:27,120
time for the watchdogs so if you for

583
00:22:27,120 --> 00:22:28,960
instance employ some practice

584
00:22:28,960 --> 00:22:30,720
um then you wouldn't know for how

585
00:22:30,720 --> 00:22:32,240
exactly long you would need to run your

586
00:22:32,240 --> 00:22:33,679
watchdog

587
00:22:33,679 --> 00:22:35,600
further a non-negligible detection

588
00:22:35,600 --> 00:22:37,200
advantage might just not be enough for

589
00:22:37,200 --> 00:22:38,320
some use cases

590
00:22:38,320 --> 00:22:40,320
for example consider an investigative

591
00:22:40,320 --> 00:22:41,440
journalist

592
00:22:41,440 --> 00:22:43,120
who has to fear that his identity or

593
00:22:43,120 --> 00:22:44,880
sources might get leaked um is if he

594
00:22:44,880 --> 00:22:45,520
uses a

595
00:22:45,520 --> 00:22:48,640
subverted means of communication

596
00:22:48,640 --> 00:22:50,000
while you could argue that you can use

597
00:22:50,000 --> 00:22:51,520
existing schemes and boost your

598
00:22:51,520 --> 00:22:52,799
detection advantage by simply

599
00:22:52,799 --> 00:22:54,320
re-executing a watchdog

600
00:22:54,320 --> 00:22:56,720
and this could induce a potentially huge

601
00:22:56,720 --> 00:22:58,240
testing overhead especially if testing

602
00:22:58,240 --> 00:22:59,919
is done regularly for instance each and

603
00:22:59,919 --> 00:23:01,200
every time before you use your

604
00:23:01,200 --> 00:23:04,799
mobile phone this is why

605
00:23:04,799 --> 00:23:06,799
in our work we brought a model which is

606
00:23:06,799 --> 00:23:08,559
a refinement of the workshop model

607
00:23:08,559 --> 00:23:11,520
by reflecting where we have a concrete

608
00:23:11,520 --> 00:23:13,200
bounce virtual run time and also use

609
00:23:13,200 --> 00:23:15,760
concrete security definitions secured in

610
00:23:15,760 --> 00:23:17,360
our model basically means that either we

611
00:23:17,360 --> 00:23:18,720
take subversion with overwhelming of

612
00:23:18,720 --> 00:23:20,880
probability or we have also

613
00:23:20,880 --> 00:23:23,840
wanted security guarantee

614
00:23:24,320 --> 00:23:26,880
within this model we then show different

615
00:23:26,880 --> 00:23:27,679
constructions

616
00:23:27,679 --> 00:23:29,919
um as a important building block we show

617
00:23:29,919 --> 00:23:31,600
how to build randomness generators based

618
00:23:31,600 --> 00:23:33,039
on the phenomenal extractor

619
00:23:33,039 --> 00:23:34,720
which is in an extremely simple

620
00:23:34,720 --> 00:23:36,159
construction and can be tested in

621
00:23:36,159 --> 00:23:38,480
constant time

622
00:23:38,480 --> 00:23:41,200
this gives raise to uniform random coins

623
00:23:41,200 --> 00:23:42,080
and

624
00:23:42,080 --> 00:23:43,919
with that we turn attention to a

625
00:23:43,919 --> 00:23:45,120
building subversion within key

626
00:23:45,120 --> 00:23:46,799
encapsulation mechanism

627
00:23:46,799 --> 00:23:50,480
and there we show that you can build

628
00:23:50,480 --> 00:23:52,000
several reason camps based on chem

629
00:23:52,000 --> 00:23:53,760
combiners with the base

630
00:23:53,760 --> 00:23:55,520
of the work of patterning at i which is

631
00:23:55,520 --> 00:23:57,279
basically a trusted exo function

632
00:23:57,279 --> 00:23:58,880
and the idea here is that we execute

633
00:23:58,880 --> 00:24:00,400
many camps in parallel

634
00:24:00,400 --> 00:24:02,720
and we can gain security if at least one

635
00:24:02,720 --> 00:24:04,000
execution was honest

636
00:24:04,000 --> 00:24:06,000
and the testing of the watchdog and

637
00:24:06,000 --> 00:24:07,440
ensures that this is happens with high

638
00:24:07,440 --> 00:24:08,880
probability

639
00:24:08,880 --> 00:24:10,799
from this it's not a large step to again

640
00:24:10,799 --> 00:24:12,320
efficiently testable cpa subversion

641
00:24:12,320 --> 00:24:14,080
within public key encryption

642
00:24:14,080 --> 00:24:15,600
and where we can use the trusted xo

643
00:24:15,600 --> 00:24:17,919
function however there are some

644
00:24:17,919 --> 00:24:19,200
drawbacks and restrictions to our

645
00:24:19,200 --> 00:24:20,159
approach

646
00:24:20,159 --> 00:24:21,840
first we have bigger public keys and

647
00:24:21,840 --> 00:24:23,200
ciphertexts and

648
00:24:23,200 --> 00:24:24,559
depending on your parameters this could

649
00:24:24,559 --> 00:24:26,159
for instance mean that the the the

650
00:24:26,159 --> 00:24:26,640
number of

651
00:24:26,640 --> 00:24:28,559
public keys and ciphertext may be equal

652
00:24:28,559 --> 00:24:31,039
to the security parameter

653
00:24:31,039 --> 00:24:32,640
in addition we cannot handle stateful

654
00:24:32,640 --> 00:24:34,159
subversion which means that

655
00:24:34,159 --> 00:24:36,320
subverted algorithms are not allowed to

656
00:24:36,320 --> 00:24:38,080
hold any state between executions

657
00:24:38,080 --> 00:24:39,840
if you if this is something that borrows

658
00:24:39,840 --> 00:24:41,440
you potentially

659
00:24:41,440 --> 00:24:42,720
reverse firewalls might be a more

660
00:24:42,720 --> 00:24:43,919
fitting approach for that depending on

661
00:24:43,919 --> 00:24:46,159
the application

662
00:24:46,159 --> 00:24:47,840
so what are the key tech hormones how

663
00:24:47,840 --> 00:24:49,440
much home messages from the stock

664
00:24:49,440 --> 00:24:50,720
um we brought us a new model with

665
00:24:50,720 --> 00:24:52,080
compute security based off the back of

666
00:24:52,080 --> 00:24:52,960
russell said i

667
00:24:52,960 --> 00:24:54,320
for the first time be focused on

668
00:24:54,320 --> 00:24:56,480
minimizing the watchdog runtime

669
00:24:56,480 --> 00:24:58,240
and within this model we showed that the

670
00:24:58,240 --> 00:24:59,679
fundamental extractor can be checked in

671
00:24:59,679 --> 00:25:01,600
question time and gives us uniform

672
00:25:01,600 --> 00:25:04,159
randomness securecamps can be built by

673
00:25:04,159 --> 00:25:05,440
chem combiners based

674
00:25:05,440 --> 00:25:07,679
on the work of a filtering header and

675
00:25:07,679 --> 00:25:09,200
last but not least subversion resilient

676
00:25:09,200 --> 00:25:10,559
public key encryption which can be

677
00:25:10,559 --> 00:25:11,679
tested efficiently

678
00:25:11,679 --> 00:25:14,240
is possible and achievable that's it for

679
00:25:14,240 --> 00:25:15,760
my side if you have any questions

680
00:25:15,760 --> 00:25:17,520
but feel free to visit our paper email

681
00:25:17,520 --> 00:25:21,360
me or of course ask questions now

682
00:25:24,080 --> 00:25:29,840
any questions from the audience

683
00:25:33,679 --> 00:25:36,240
um i have one question so for the secure

684
00:25:36,240 --> 00:25:37,440
camps about

685
00:25:37,440 --> 00:25:39,600
chem combiners is it a generic

686
00:25:39,600 --> 00:25:41,440
construction

687
00:25:41,440 --> 00:25:44,400
um yes so we don't it works with with

688
00:25:44,400 --> 00:25:45,520
any cam

689
00:25:45,520 --> 00:25:47,679
um and basically the only thing we need

690
00:25:47,679 --> 00:25:49,200
is a trusted exo function

691
00:25:49,200 --> 00:25:51,520
so it does it doesn't matter which cam

692
00:25:51,520 --> 00:25:54,000
you put in

693
00:25:54,159 --> 00:25:56,799
and is it also generic for the uh

694
00:25:56,799 --> 00:25:58,240
subversion releasing

695
00:25:58,240 --> 00:26:01,600
resilient uh pke

696
00:26:01,600 --> 00:26:04,240
um yeah this is again if we use our

697
00:26:04,240 --> 00:26:05,760
basically also version resilient chem as

698
00:26:05,760 --> 00:26:07,600
a building block again you know apke

699
00:26:07,600 --> 00:26:09,279
construction so it's basically it does

700
00:26:09,279 --> 00:26:11,679
it doesn't matter which which game you

701
00:26:11,679 --> 00:26:13,679
put in there that so it's generic in

702
00:26:13,679 --> 00:26:14,880
that regard

703
00:26:14,880 --> 00:26:17,039
okay

704
00:26:18,720 --> 00:26:21,679
any other questions

705
00:26:21,760 --> 00:26:24,559
can i ask so

706
00:26:25,600 --> 00:26:27,919
i was wondering what the goal of the

707
00:26:27,919 --> 00:26:29,919
public key is in this uh algorithm is it

708
00:26:29,919 --> 00:26:30,240
just

709
00:26:30,240 --> 00:26:33,520
part of the adversary's algorithm

710
00:26:33,520 --> 00:26:37,440
is sorry is there a public key for

711
00:26:37,440 --> 00:26:38,000
anchor

712
00:26:38,000 --> 00:26:40,559
for encrypting or like what where does

713
00:26:40,559 --> 00:26:42,559
the public key appear in your definition

714
00:26:42,559 --> 00:26:45,360
i'm just curious about i mean basically

715
00:26:45,360 --> 00:26:46,000
so the

716
00:26:46,000 --> 00:26:48,159
the adversary is uh provides

717
00:26:48,159 --> 00:26:49,520
implementations of the keychain

718
00:26:49,520 --> 00:26:50,240
algorithm

719
00:26:50,240 --> 00:26:52,720
and the encrypted algorithm and

720
00:26:52,720 --> 00:26:54,400
basically all the workshop does it

721
00:26:54,400 --> 00:26:57,360
chooses random values see the outputs if

722
00:26:57,360 --> 00:26:57,760
these are

723
00:26:57,760 --> 00:27:01,200
generated honestly um and after that

724
00:27:01,200 --> 00:27:03,200
this is the securities experiment is

725
00:27:03,200 --> 00:27:04,640
then executed and you get to get your

726
00:27:04,640 --> 00:27:05,679
public key

727
00:27:05,679 --> 00:27:07,760
so but basically we have and our

728
00:27:07,760 --> 00:27:09,120
approach is we take our

729
00:27:09,120 --> 00:27:10,320
our security definition and build

730
00:27:10,320 --> 00:27:12,559
subversion part around it

731
00:27:12,559 --> 00:27:16,639
basic that's basically the main idea

732
00:27:19,039 --> 00:27:21,840
any other questions

733
00:27:25,120 --> 00:27:35,840
okay let's thank the speaker again

734
00:27:36,880 --> 00:27:40,960
all right um so if the next speaker oh

735
00:27:40,960 --> 00:27:43,440
fantastic

736
00:27:45,360 --> 00:27:48,799
hi can you can you hear me yeah

737
00:27:48,799 --> 00:27:51,039
i can hear you and i can also see the

738
00:27:51,039 --> 00:27:53,440
slides

739
00:27:53,440 --> 00:27:55,840
all right so our next talk is going to

740
00:27:55,840 --> 00:27:58,080
be about non-interactive cca2 secure

741
00:27:58,080 --> 00:27:59,760
threshold crypto systems

742
00:27:59,760 --> 00:28:01,039
achieving adaptive security in the

743
00:28:01,039 --> 00:28:03,120
standard model without pairings and

744
00:28:03,120 --> 00:28:05,760
julian is giving the talk thank you

745
00:28:05,760 --> 00:28:06,559
thank you

746
00:28:06,559 --> 00:28:09,840
thank you for the introduction so let me

747
00:28:09,840 --> 00:28:13,039
first explain what was our goal when

748
00:28:13,039 --> 00:28:14,960
writing this paper we wanted to build

749
00:28:14,960 --> 00:28:16,799
non-interactive threshold public key

750
00:28:16,799 --> 00:28:18,000
encryption

751
00:28:18,000 --> 00:28:21,279
the idea is the following instead of

752
00:28:21,279 --> 00:28:23,919
sampling one secret key you share it

753
00:28:23,919 --> 00:28:24,640
into

754
00:28:24,640 --> 00:28:27,279
l key shares which are then distributed

755
00:28:27,279 --> 00:28:28,960
to servers

756
00:28:28,960 --> 00:28:31,600
and when you receive a ciphertext as in

757
00:28:31,600 --> 00:28:33,279
a standard pke

758
00:28:33,279 --> 00:28:36,240
you you instead forward the ciphertext

759
00:28:36,240 --> 00:28:37,279
to the servers

760
00:28:37,279 --> 00:28:40,080
which will then all compute some partial

761
00:28:40,080 --> 00:28:41,440
decryption

762
00:28:41,440 --> 00:28:44,799
of the ciphertext and

763
00:28:44,799 --> 00:28:46,159
when you receive these partial

764
00:28:46,159 --> 00:28:48,159
decryptions of course you want to check

765
00:28:48,159 --> 00:28:50,320
whether these decryptions are truthful

766
00:28:50,320 --> 00:28:50,880
or not

767
00:28:50,880 --> 00:28:52,480
this is the partial verification

768
00:28:52,480 --> 00:28:54,480
algorithm

769
00:28:54,480 --> 00:28:58,240
and when you have at least t out of l

770
00:28:58,240 --> 00:29:01,120
partial decryptions that are valid that

771
00:29:01,120 --> 00:29:02,080
you can

772
00:29:02,080 --> 00:29:04,480
trust then the combined algorithm lets

773
00:29:04,480 --> 00:29:06,320
you recover the message

774
00:29:06,320 --> 00:29:09,840
m we want to achieve

775
00:29:09,840 --> 00:29:12,399
for this cryptosystem the best possible

776
00:29:12,399 --> 00:29:13,520
security which

777
00:29:13,520 --> 00:29:16,320
is the cca2 security under adaptive

778
00:29:16,320 --> 00:29:17,840
corruptions

779
00:29:17,840 --> 00:29:20,799
setting so the idea is that you take the

780
00:29:20,799 --> 00:29:21,679
standard

781
00:29:21,679 --> 00:29:24,480
in cca2 security game but you have

782
00:29:24,480 --> 00:29:26,000
instead an oracle for

783
00:29:26,000 --> 00:29:28,960
partial decryptions for any side for any

784
00:29:28,960 --> 00:29:29,840
server

785
00:29:29,840 --> 00:29:32,320
we also ask the adversary for which

786
00:29:32,320 --> 00:29:33,840
threshold it wants to

787
00:29:33,840 --> 00:29:36,480
set at the beginning of the game and you

788
00:29:36,480 --> 00:29:38,480
also allow the adversary to do the

789
00:29:38,480 --> 00:29:41,279
following two kinds of queries

790
00:29:41,279 --> 00:29:43,760
so first you have the corruption query

791
00:29:43,760 --> 00:29:45,520
where the adversary recover

792
00:29:45,520 --> 00:29:48,799
any key share at any time and also you

793
00:29:48,799 --> 00:29:50,399
allow it necessary to make partial

794
00:29:50,399 --> 00:29:52,799
decryption queries for the challenge

795
00:29:52,799 --> 00:29:55,200
of course if it makes too many of these

796
00:29:55,200 --> 00:29:57,039
of these queries it could trivially win

797
00:29:57,039 --> 00:30:00,320
and we exclude this case and

798
00:30:00,320 --> 00:30:03,039
our result is that under the dcr

799
00:30:03,039 --> 00:30:03,760
assumption

800
00:30:03,760 --> 00:30:05,279
and under the learning with errors

801
00:30:05,279 --> 00:30:07,600
assumption it's possible to build such

802
00:30:07,600 --> 00:30:11,279
tpk whereas from previous works

803
00:30:11,279 --> 00:30:15,840
it was only achieved using pairings

804
00:30:15,840 --> 00:30:19,360
moreover we can see that our first

805
00:30:19,360 --> 00:30:20,240
construction

806
00:30:20,240 --> 00:30:22,240
is pretty efficient because in terms of

807
00:30:22,240 --> 00:30:23,840
safer text size

808
00:30:23,840 --> 00:30:26,159
we only have about three times the size

809
00:30:26,159 --> 00:30:27,600
of

810
00:30:27,600 --> 00:30:29,840
the non-standard the non-threshold

811
00:30:29,840 --> 00:30:31,679
version of the scheme

812
00:30:31,679 --> 00:30:34,159
but the second construction is not that

813
00:30:34,159 --> 00:30:35,039
much efficient

814
00:30:35,039 --> 00:30:37,840
because we have super polynomial modulus

815
00:30:37,840 --> 00:30:40,159
this is a flow that is common to a lot

816
00:30:40,159 --> 00:30:41,200
of tpk

817
00:30:41,200 --> 00:30:44,640
using the learning with eras

818
00:30:44,640 --> 00:30:47,840
assumption our main building block which

819
00:30:47,840 --> 00:30:49,440
is common to both

820
00:30:49,440 --> 00:30:51,600
schemes that we build is the linear

821
00:30:51,600 --> 00:30:53,360
secret scheme

822
00:30:53,360 --> 00:30:56,559
the idea is to share a secret s among

823
00:30:56,559 --> 00:30:59,679
n persons and when k of them

824
00:30:59,679 --> 00:31:01,679
are working together they can compute

825
00:31:01,679 --> 00:31:04,000
some linear combination of their secret

826
00:31:04,000 --> 00:31:06,799
key shares to recover the secret s this

827
00:31:06,799 --> 00:31:08,640
will be a way to share

828
00:31:08,640 --> 00:31:12,640
the secret key so

829
00:31:12,640 --> 00:31:14,720
i briefly recall the hardness

830
00:31:14,720 --> 00:31:16,880
assumptions that we use the first scheme

831
00:31:16,880 --> 00:31:18,000
uses the dcr

832
00:31:18,000 --> 00:31:20,240
assumption the second scheme using the

833
00:31:20,240 --> 00:31:21,120
lwe

834
00:31:21,120 --> 00:31:24,880
or assumption and now

835
00:31:24,880 --> 00:31:27,360
to give you a brief intuition on how we

836
00:31:27,360 --> 00:31:29,200
do it the first construction can

837
00:31:29,200 --> 00:31:30,960
either be seen as bearing free

838
00:31:30,960 --> 00:31:32,240
adaptation of

839
00:31:32,240 --> 00:31:35,679
a previous tpke or as

840
00:31:35,679 --> 00:31:38,320
some thresholdized version of a

841
00:31:38,320 --> 00:31:39,440
chemistry

842
00:31:39,440 --> 00:31:42,399
encryption schemes the idea is to have

843
00:31:42,399 --> 00:31:43,600
ciphertexts

844
00:31:43,600 --> 00:31:47,039
of this form where h is j0

845
00:31:47,039 --> 00:31:50,000
to the security key which is then shared

846
00:31:50,000 --> 00:31:51,440
using a list

847
00:31:51,440 --> 00:31:53,440
and we need to add a simulation sound

848
00:31:53,440 --> 00:31:55,200
proof that the first part of the cipher

849
00:31:55,200 --> 00:31:55,600
text

850
00:31:55,600 --> 00:31:59,600
is indeed an f residue mod n square

851
00:31:59,600 --> 00:32:03,279
to get the cca2 security to do so we use

852
00:32:03,279 --> 00:32:05,679
a music that we instantiate using

853
00:32:05,679 --> 00:32:08,240
correlation interactable hash functions

854
00:32:08,240 --> 00:32:09,440
hence the

855
00:32:09,440 --> 00:32:11,440
need for the learning with variables

856
00:32:11,440 --> 00:32:13,760
assumption

857
00:32:13,760 --> 00:32:17,360
and this we built from scratch uh

858
00:32:17,360 --> 00:32:19,519
in the end we get that the scheme is

859
00:32:19,519 --> 00:32:21,039
indeed cca2 secure

860
00:32:21,039 --> 00:32:24,080
under the assumption that dcr indeed

861
00:32:24,080 --> 00:32:25,760
holds and there is

862
00:32:25,760 --> 00:32:27,760
the and the music we use is one time

863
00:32:27,760 --> 00:32:29,919
simulation sound

864
00:32:29,919 --> 00:32:31,600
one time simulation sound meaning that

865
00:32:31,600 --> 00:32:34,799
if you see one simulated proof

866
00:32:34,799 --> 00:32:37,519
then you still are unable to forge

867
00:32:37,519 --> 00:32:40,240
proofs for false statements

868
00:32:40,240 --> 00:32:41,600
but this is a property which is

869
00:32:41,600 --> 00:32:43,760
satisfied by our new construction

870
00:32:43,760 --> 00:32:46,720
so that's all right finally to give you

871
00:32:46,720 --> 00:32:47,840
a quick insight

872
00:32:47,840 --> 00:32:50,240
on the second construction it can be

873
00:32:50,240 --> 00:32:52,640
seen as a thresholdized version of dual

874
00:32:52,640 --> 00:32:53,919
rgf

875
00:32:53,919 --> 00:32:57,120
where we shared the secret key are using

876
00:32:57,120 --> 00:32:58,080
the list

877
00:32:58,080 --> 00:33:00,880
which are each coefficient of it and

878
00:33:00,880 --> 00:33:02,399
everything then

879
00:33:02,399 --> 00:33:04,640
comes naturally until the parts with

880
00:33:04,640 --> 00:33:06,080
decryption

881
00:33:06,080 --> 00:33:08,320
with decryption where we need to add

882
00:33:08,320 --> 00:33:10,559
some noise in order not to reveal

883
00:33:10,559 --> 00:33:14,000
the key shares and this is where the

884
00:33:14,000 --> 00:33:14,399
super

885
00:33:14,399 --> 00:33:17,120
polynomial modulus comes from and to get

886
00:33:17,120 --> 00:33:19,600
the cca2 security we also need a proof

887
00:33:19,600 --> 00:33:23,120
that ciphertexts are well formed

888
00:33:23,120 --> 00:33:26,240
and to conclude uh the

889
00:33:26,240 --> 00:33:29,039
most the open problem that we still have

890
00:33:29,039 --> 00:33:30,320
is that

891
00:33:30,320 --> 00:33:33,440
uh how is it possible actually to build

892
00:33:33,440 --> 00:33:34,159
a cpk

893
00:33:34,159 --> 00:33:36,880
using only a polynomial modulus while

894
00:33:36,880 --> 00:33:39,039
still getting reasonable ciphertext

895
00:33:39,039 --> 00:33:42,240
ciphertext size so thank you for your

896
00:33:42,240 --> 00:33:42,960
attention

897
00:33:42,960 --> 00:33:44,399
and if you have any question i'll be

898
00:33:44,399 --> 00:33:47,439
happy to answer them

899
00:33:49,200 --> 00:33:53,840
any questions from the audience

900
00:33:55,840 --> 00:33:57,279
i have a question regarding the

901
00:33:57,279 --> 00:33:59,360
definition for the

902
00:33:59,360 --> 00:34:02,240
threshold decryption where you have a

903
00:34:02,240 --> 00:34:03,840
verified algorithm

904
00:34:03,840 --> 00:34:06,640
part parts to verify algorithm yes i was

905
00:34:06,640 --> 00:34:07,519
wondering

906
00:34:07,519 --> 00:34:10,719
if um that's necessary in the definition

907
00:34:10,719 --> 00:34:12,639
or it has something to do with the cca

908
00:34:12,639 --> 00:34:14,239
security

909
00:34:14,239 --> 00:34:17,440
so actually it's it's independent from

910
00:34:17,440 --> 00:34:20,079
the cca security it's not used in the

911
00:34:20,079 --> 00:34:23,280
cca security there are over security

912
00:34:23,280 --> 00:34:24,320
definitions

913
00:34:24,320 --> 00:34:27,440
uh notably a notion of robustness

914
00:34:27,440 --> 00:34:30,239
that are that are used but i do not have

915
00:34:30,239 --> 00:34:30,879
time to

916
00:34:30,879 --> 00:34:33,440
treat it and this is something that can

917
00:34:33,440 --> 00:34:34,239
be uh

918
00:34:34,239 --> 00:34:37,359
treated a bit apart because

919
00:34:37,359 --> 00:34:40,079
what you can do is most of the time

920
00:34:40,079 --> 00:34:41,520
adding a proof

921
00:34:41,520 --> 00:34:43,679
uh that your partial decryptions is

922
00:34:43,679 --> 00:34:44,960
indeed trustful

923
00:34:44,960 --> 00:34:49,199
uh is enough to get the robustness

924
00:34:49,199 --> 00:34:51,918
right so if you don't have this

925
00:34:51,918 --> 00:34:53,599
algorithm or you don't need this

926
00:34:53,599 --> 00:34:54,639
robustness

927
00:34:54,639 --> 00:34:56,639
guarantee can you achieve a more

928
00:34:56,639 --> 00:34:57,760
efficient

929
00:34:57,760 --> 00:35:00,480
or this is quite generic and it doesn't

930
00:35:00,480 --> 00:35:00,960
add

931
00:35:00,960 --> 00:35:04,400
a lot of cost on top so what uh what we

932
00:35:04,400 --> 00:35:06,800
actually do in the paper is we actually

933
00:35:06,800 --> 00:35:07,760
build

934
00:35:07,760 --> 00:35:09,680
uh the kitchen the encryption the

935
00:35:09,680 --> 00:35:11,119
partial decryption and combined

936
00:35:11,119 --> 00:35:11,920
algorithm

937
00:35:11,920 --> 00:35:15,599
first and then we see that to get the

938
00:35:15,599 --> 00:35:16,000
partial

939
00:35:16,000 --> 00:35:18,640
verification to work we need to add

940
00:35:18,640 --> 00:35:19,839
something

941
00:35:19,839 --> 00:35:21,920
to the key generation and to the partial

942
00:35:21,920 --> 00:35:23,520
decryption

943
00:35:23,520 --> 00:35:26,079
so if you want to remove this

944
00:35:26,079 --> 00:35:27,359
verification

945
00:35:27,359 --> 00:35:30,560
thing you can get slightly better

946
00:35:30,560 --> 00:35:35,759
things i see thanks

947
00:35:36,400 --> 00:35:39,680
any other questions can you show us how

948
00:35:39,680 --> 00:35:42,839
sharing the secret key again in the lwe

949
00:35:42,839 --> 00:35:44,320
scheme

950
00:35:44,320 --> 00:35:47,839
sorry i didn't hear you sir can you show

951
00:35:47,839 --> 00:35:49,280
us how you're sharing the secret key

952
00:35:49,280 --> 00:35:52,079
again in the lw ebay scheme

953
00:35:52,079 --> 00:35:54,960
all right so we have this uh building

954
00:35:54,960 --> 00:35:55,359
block

955
00:35:55,359 --> 00:35:57,200
we have this linear integer secret

956
00:35:57,200 --> 00:35:59,760
sharing this is something which

957
00:35:59,760 --> 00:36:02,560
does not come from us which lets us

958
00:36:02,560 --> 00:36:02,960
share

959
00:36:02,960 --> 00:36:06,880
an integer into t shares

960
00:36:06,880 --> 00:36:09,920
and in the case of lwe

961
00:36:09,920 --> 00:36:12,480
you so your secret key will be some

962
00:36:12,480 --> 00:36:13,680
matrix

963
00:36:13,680 --> 00:36:15,280
and you can actually share each

964
00:36:15,280 --> 00:36:16,960
coefficient of the matrix

965
00:36:16,960 --> 00:36:20,640
using this list

966
00:36:20,880 --> 00:36:26,240
i see thank you

967
00:36:26,240 --> 00:36:29,200
any other questions

968
00:36:32,160 --> 00:36:40,079
okay let's thank the speaker again

969
00:36:40,079 --> 00:36:44,480
great um so we are perfectly on time

970
00:36:44,480 --> 00:36:47,680
and uh if the next speaker wants to

971
00:36:47,680 --> 00:36:48,000
share

972
00:36:48,000 --> 00:36:51,200
screen we can proceed yeah hold on let

973
00:36:51,200 --> 00:36:52,400
me see if

974
00:36:52,400 --> 00:36:56,560
what's going on here oh here we go

975
00:37:00,240 --> 00:37:04,000
um sorry you look very young

976
00:37:04,000 --> 00:37:07,040
um yeah

977
00:37:07,040 --> 00:37:12,160
it's uh just last year

978
00:37:12,240 --> 00:37:16,000
uh okay everyone can see my screen

979
00:37:18,880 --> 00:37:22,079
yes that looks good that looks good okay

980
00:37:22,079 --> 00:37:25,200
so uh so thanks uh

981
00:37:25,200 --> 00:37:28,000
for coming uh this talk is about uh

982
00:37:28,000 --> 00:37:30,400
selective opening security for

983
00:37:30,400 --> 00:37:32,960
deterministic primitives so if you've

984
00:37:32,960 --> 00:37:34,800
studied or heard of

985
00:37:34,800 --> 00:37:37,839
selective opening security um

986
00:37:37,839 --> 00:37:39,680
uh deterministic primitives kind of give

987
00:37:39,680 --> 00:37:41,440
an interesting twist to this

988
00:37:41,440 --> 00:37:44,160
to this problem

989
00:37:46,880 --> 00:37:49,359
so uh i'll start with the background and

990
00:37:49,359 --> 00:37:50,000
motivation

991
00:37:50,000 --> 00:37:53,280
i'll move to define uh selective opening

992
00:37:53,280 --> 00:37:55,040
secure hash functions

993
00:37:55,040 --> 00:37:56,640
and then selected the opening secure

994
00:37:56,640 --> 00:37:58,480
deterministic encryption and then

995
00:37:58,480 --> 00:38:01,760
uh conclude so

996
00:38:01,760 --> 00:38:04,400
uh some motivation uh just generally

997
00:38:04,400 --> 00:38:05,920
speaking is

998
00:38:05,920 --> 00:38:08,960
um as we uh

999
00:38:08,960 --> 00:38:12,000
advance in encryption schemes so do uh

1000
00:38:12,000 --> 00:38:15,280
new types of attacks and uh one type of

1001
00:38:15,280 --> 00:38:16,960
attack that people have looked at

1002
00:38:16,960 --> 00:38:20,079
um for a while now is uh break-ins so

1003
00:38:20,079 --> 00:38:22,320
like adaptive corruption to

1004
00:38:22,320 --> 00:38:25,680
uh parties in a protocol or um breaking

1005
00:38:25,680 --> 00:38:27,359
into a sender's machine and getting

1006
00:38:27,359 --> 00:38:29,839
messages and maybe the random coins that

1007
00:38:29,839 --> 00:38:31,280
they use to encrypt the message things

1008
00:38:31,280 --> 00:38:32,320
like this

1009
00:38:32,320 --> 00:38:34,880
so this isn't captured by standard uh

1010
00:38:34,880 --> 00:38:35,839
ind cpa

1011
00:38:35,839 --> 00:38:39,280
security um and we need

1012
00:38:39,280 --> 00:38:43,040
new models that capture such attacks

1013
00:38:43,040 --> 00:38:46,640
and uh some things one may consider

1014
00:38:46,640 --> 00:38:50,480
is like uh the adversary may break into

1015
00:38:50,480 --> 00:38:51,680
standards so here

1016
00:38:51,680 --> 00:38:53,040
we're talking specifically about

1017
00:38:53,040 --> 00:38:55,680
encryption schemes for example right

1018
00:38:55,680 --> 00:38:58,079
and public encryption schemes and sender

1019
00:38:58,079 --> 00:39:00,000
break into senders machines

1020
00:39:00,000 --> 00:39:01,359
so they may get the messages and

1021
00:39:01,359 --> 00:39:03,839
randomness that the center used to

1022
00:39:03,839 --> 00:39:06,960
uh encrypt uh

1023
00:39:06,960 --> 00:39:10,079
and uh the question is how can we

1024
00:39:10,079 --> 00:39:10,960
protect

1025
00:39:10,960 --> 00:39:14,320
uh the other messages so can we give

1026
00:39:14,320 --> 00:39:16,640
uh proof that like the messages of the

1027
00:39:16,640 --> 00:39:18,240
other centers that weren't

1028
00:39:18,240 --> 00:39:21,839
weren't corrupted are secure

1029
00:39:21,839 --> 00:39:24,960
and um theoretically uh i mean

1030
00:39:24,960 --> 00:39:27,520
a theoretical result is that um there

1031
00:39:27,520 --> 00:39:28,000
exists

1032
00:39:28,000 --> 00:39:31,040
a pke that is ind cpa but vulnerable to

1033
00:39:31,040 --> 00:39:32,480
these types of attacks which are called

1034
00:39:32,480 --> 00:39:34,720
selective opening attacks so it actually

1035
00:39:34,720 --> 00:39:35,920
is a

1036
00:39:35,920 --> 00:39:39,200
genuine concern for um for

1037
00:39:39,200 --> 00:39:42,480
uh you know encryption schemes

1038
00:39:42,480 --> 00:39:44,160
okay so how how do we go about

1039
00:39:44,160 --> 00:39:46,000
protecting against this

1040
00:39:46,000 --> 00:39:50,800
uh so uh what we do is we use um

1041
00:39:50,800 --> 00:39:53,920
a selective opening secure uh pke

1042
00:39:53,920 --> 00:39:57,280
to protect against uh the after effects

1043
00:39:57,280 --> 00:39:59,359
of the break-in so again like i think an

1044
00:39:59,359 --> 00:40:00,000
important

1045
00:40:00,000 --> 00:40:01,920
point is that we're not protecting

1046
00:40:01,920 --> 00:40:03,280
against the break-in itself we're

1047
00:40:03,280 --> 00:40:04,480
protecting against

1048
00:40:04,480 --> 00:40:07,200
what what what security can be possible

1049
00:40:07,200 --> 00:40:08,640
after the break-in

1050
00:40:08,640 --> 00:40:11,119
right um to a center's machine and in

1051
00:40:11,119 --> 00:40:12,640
this work we want to construct

1052
00:40:12,640 --> 00:40:16,480
uh soa secure deterministic primitives

1053
00:40:16,480 --> 00:40:17,359
so

1054
00:40:17,359 --> 00:40:19,119
deterministic primitives are like that

1055
00:40:19,119 --> 00:40:21,119
we consider our hash functions

1056
00:40:21,119 --> 00:40:24,079
and deterministic encryption schemes um

1057
00:40:24,079 --> 00:40:24,720
i think

1058
00:40:24,720 --> 00:40:26,640
uh there's a couple of motivations for

1059
00:40:26,640 --> 00:40:28,800
this one is that uh

1060
00:40:28,800 --> 00:40:30,720
for deterministic encryption schemes

1061
00:40:30,720 --> 00:40:32,079
they're also useful for

1062
00:40:32,079 --> 00:40:35,839
um like

1063
00:40:35,839 --> 00:40:37,680
protecting against bad randomness

1064
00:40:37,680 --> 00:40:39,040
meaning that uh

1065
00:40:39,040 --> 00:40:40,720
deterministic encryption scheme if the

1066
00:40:40,720 --> 00:40:42,240
random coins have

1067
00:40:42,240 --> 00:40:44,079
if you use a deterministic encryption

1068
00:40:44,079 --> 00:40:45,920
scheme to encrypt like message

1069
00:40:45,920 --> 00:40:47,359
concatenated with coins

1070
00:40:47,359 --> 00:40:50,400
and your coins have not full entropy

1071
00:40:50,400 --> 00:40:53,599
the scheme is still secure whereas uh

1072
00:40:53,599 --> 00:40:56,079
a standard idc encryption scheme does

1073
00:40:56,079 --> 00:40:58,000
not guarantee security if the

1074
00:40:58,000 --> 00:41:00,079
scheme if the randomness only has high

1075
00:41:00,079 --> 00:41:02,000
entropy for example

1076
00:41:02,000 --> 00:41:03,680
so that's why we want to look at

1077
00:41:03,680 --> 00:41:05,119
deterministic encryption and

1078
00:41:05,119 --> 00:41:07,839
for hash functions uh i think a nice

1079
00:41:07,839 --> 00:41:10,480
application is like password hashing so

1080
00:41:10,480 --> 00:41:13,280
imagine there's a password file of uh

1081
00:41:13,280 --> 00:41:13,839
hash

1082
00:41:13,839 --> 00:41:15,599
hashes of passwords and some of the

1083
00:41:15,599 --> 00:41:17,680
passwords gets corrupted

1084
00:41:17,680 --> 00:41:20,800
right so you you you figure out uh okay

1085
00:41:20,800 --> 00:41:21,119
this

1086
00:41:21,119 --> 00:41:23,280
guy's password is this so i know that

1087
00:41:23,280 --> 00:41:24,480
this hashes to this

1088
00:41:24,480 --> 00:41:26,480
what can you say about the security of

1089
00:41:26,480 --> 00:41:27,760
the other the other

1090
00:41:27,760 --> 00:41:30,319
passwords

1091
00:41:32,319 --> 00:41:35,359
okay so um

1092
00:41:35,359 --> 00:41:38,880
what's uh been done in prior work is uh

1093
00:41:38,880 --> 00:41:41,920
bularia uh at all uh uh

1094
00:41:41,920 --> 00:41:44,960
and a paper by hawfites uh

1095
00:41:44,960 --> 00:41:47,520
which should be referenced here um show

1096
00:41:47,520 --> 00:41:49,200
uh i any uh

1097
00:41:49,200 --> 00:41:52,640
ind and sim security notions for

1098
00:41:52,640 --> 00:41:55,040
so stands for selected opening uh for

1099
00:41:55,040 --> 00:41:56,640
randomized pke

1100
00:41:56,640 --> 00:42:00,319
and uh a paper by blarid all in 2015

1101
00:42:00,319 --> 00:42:01,440
show that there's

1102
00:42:01,440 --> 00:42:03,920
no deterministic pk scheme meeting soa

1103
00:42:03,920 --> 00:42:05,040
secure

1104
00:42:05,040 --> 00:42:08,720
uh soa security under a simulation based

1105
00:42:08,720 --> 00:42:09,680
notion

1106
00:42:09,680 --> 00:42:11,839
so a simulation based notion for

1107
00:42:11,839 --> 00:42:13,200
deterministic encryption and hash

1108
00:42:13,200 --> 00:42:14,560
functions is ruled out

1109
00:42:14,560 --> 00:42:17,440
like deterministic primitives can't

1110
00:42:17,440 --> 00:42:19,200
achieve a simulation based

1111
00:42:19,200 --> 00:42:22,800
soa notion so uh we use a formulation

1112
00:42:22,800 --> 00:42:26,560
of hong it all um from a few years ago

1113
00:42:26,560 --> 00:42:27,520
for

1114
00:42:27,520 --> 00:42:30,960
uh soa for dp dpke

1115
00:42:30,960 --> 00:42:34,079
and they leave constructions

1116
00:42:34,079 --> 00:42:36,640
in the standard model open so that's

1117
00:42:36,640 --> 00:42:37,200
where

1118
00:42:37,200 --> 00:42:40,960
our work basically started and we give

1119
00:42:40,960 --> 00:42:43,440
constructions not just for deterministic

1120
00:42:43,440 --> 00:42:44,400
encryption in the center

1121
00:42:44,400 --> 00:42:48,000
but the simpler case of hash functions

1122
00:42:48,000 --> 00:42:53,280
okay uh how how am i doing on time

1123
00:42:54,160 --> 00:42:56,079
well we have banked a few minutes from

1124
00:42:56,079 --> 00:42:57,520
before so

1125
00:42:57,520 --> 00:42:59,680
okay so i'll keep going okay good so

1126
00:42:59,680 --> 00:43:01,680
just let me know if i'm like right

1127
00:43:01,680 --> 00:43:05,440
um so uh

1128
00:43:05,440 --> 00:43:07,839
how do we how do we define so i said

1129
00:43:07,839 --> 00:43:09,359
that a simulation based notion of

1130
00:43:09,359 --> 00:43:10,880
security is inachievable

1131
00:43:10,880 --> 00:43:14,240
so it's actually very so they left uh uh

1132
00:43:14,240 --> 00:43:16,480
the paper of bolari it all left an open

1133
00:43:16,480 --> 00:43:17,520
problem of constru

1134
00:43:17,520 --> 00:43:20,480
of giving a different definition and

1135
00:43:20,480 --> 00:43:22,000
it's instructive to see what that

1136
00:43:22,000 --> 00:43:23,920
definition turns out to be

1137
00:43:23,920 --> 00:43:27,200
so uh let m uh

1138
00:43:27,200 --> 00:43:32,000
sample uh vectors of messages okay

1139
00:43:34,240 --> 00:43:36,640
and uh we're gonna consider what's

1140
00:43:36,640 --> 00:43:37,359
called mu

1141
00:43:37,359 --> 00:43:40,960
d uh entropic message samplers which

1142
00:43:40,960 --> 00:43:41,760
means that

1143
00:43:41,760 --> 00:43:44,800
uh any message has uh

1144
00:43:44,800 --> 00:43:46,960
miniature p at least mu conditioned on

1145
00:43:46,960 --> 00:43:50,319
any d other messages

1146
00:43:50,480 --> 00:43:52,079
and we're going to use the notion of

1147
00:43:52,079 --> 00:43:54,160
conditionally resample meaning that

1148
00:43:54,160 --> 00:43:56,640
if you condition so when you condition

1149
00:43:56,640 --> 00:43:57,200
on those d

1150
00:43:57,200 --> 00:43:58,960
messages you can also resample the

1151
00:43:58,960 --> 00:44:03,119
message condition on those d messages

1152
00:44:03,119 --> 00:44:04,800
right so if you condition on some

1153
00:44:04,800 --> 00:44:06,839
messages you can resample the others

1154
00:44:06,839 --> 00:44:08,800
basically

1155
00:44:08,800 --> 00:44:13,040
uh so so here's the security

1156
00:44:13,040 --> 00:44:16,560
notion so um basically the challenger

1157
00:44:16,560 --> 00:44:18,800
generates a pk and sk

1158
00:44:18,800 --> 00:44:21,520
and uh a bunch of messages according to

1159
00:44:21,520 --> 00:44:22,480
m

1160
00:44:22,480 --> 00:44:25,839
and uh encrypts the messages sends them

1161
00:44:25,839 --> 00:44:29,440
uh ciphertext to the pk to the adversary

1162
00:44:29,440 --> 00:44:33,280
the adversary specifies a subset

1163
00:44:33,280 --> 00:44:36,400
and the uh the

1164
00:44:36,400 --> 00:44:38,079
challenger replies with that subset of

1165
00:44:38,079 --> 00:44:41,599
messages now the adversary i'll put some

1166
00:44:41,599 --> 00:44:45,599
like guess g and uh here's like uh

1167
00:44:45,599 --> 00:44:50,880
the technical thing so um

1168
00:44:50,880 --> 00:44:54,079
okay uh d

1169
00:44:54,079 --> 00:44:57,760
d e is uh s o a cpa secure if

1170
00:44:57,760 --> 00:45:01,280
g is equal to f of the messages with

1171
00:45:01,280 --> 00:45:03,599
about the same probability as the

1172
00:45:03,599 --> 00:45:05,599
message is resampled conditioned on the

1173
00:45:05,599 --> 00:45:07,760
open messages

1174
00:45:07,760 --> 00:45:10,800
so that's kind of the magic of

1175
00:45:10,800 --> 00:45:13,280
this definition is it is it considers

1176
00:45:13,280 --> 00:45:16,400
this resamplability

1177
00:45:17,119 --> 00:45:19,520
okay and this is as i said how long it

1178
00:45:19,520 --> 00:45:20,800
all showed that this notion is

1179
00:45:20,800 --> 00:45:22,319
achievable in the non-programmable

1180
00:45:22,319 --> 00:45:23,440
random oracle

1181
00:45:23,440 --> 00:45:25,359
model uh and we'll show it's achievable

1182
00:45:25,359 --> 00:45:28,160
in the standard model

1183
00:45:29,119 --> 00:45:31,920
so anyway the main results are for the

1184
00:45:31,920 --> 00:45:33,040
simpler case so

1185
00:45:33,040 --> 00:45:34,640
the hash functions are like

1186
00:45:34,640 --> 00:45:36,240
deterministic encryption with no

1187
00:45:36,240 --> 00:45:38,240
decryption right so it's kind of simpler

1188
00:45:38,240 --> 00:45:41,520
so in the simpler case we get uh uh

1189
00:45:41,520 --> 00:45:43,920
this result two t ys independent hash

1190
00:45:43,920 --> 00:45:44,800
functions

1191
00:45:44,800 --> 00:45:47,680
our so are soa secure for an unbounded

1192
00:45:47,680 --> 00:45:48,319
number of t

1193
00:45:48,319 --> 00:45:50,880
correlated messages meaning any group of

1194
00:45:50,880 --> 00:45:51,359
up to t

1195
00:45:51,359 --> 00:45:54,000
messages can be arbitrary arbitrarily

1196
00:45:54,000 --> 00:45:56,560
correlated

1197
00:45:58,880 --> 00:46:02,800
okay um

1198
00:46:04,160 --> 00:46:06,480
an analogous result we get for

1199
00:46:06,480 --> 00:46:08,319
deterministic encryption

1200
00:46:08,319 --> 00:46:10,560
and then one thing i won't maybe talk

1201
00:46:10,560 --> 00:46:12,160
about in the talk but i think is

1202
00:46:12,160 --> 00:46:13,520
actually pretty interesting

1203
00:46:13,520 --> 00:46:15,440
is that we look at selective opening

1204
00:46:15,440 --> 00:46:17,680
secure of just plain rsa

1205
00:46:17,680 --> 00:46:20,400
and show that it holds under phi hiding

1206
00:46:20,400 --> 00:46:22,240
and this gives a proof of the one more

1207
00:46:22,240 --> 00:46:24,560
rsa assumption under phi hiding and the

1208
00:46:24,560 --> 00:46:26,240
one more rsa assumption is used for

1209
00:46:26,240 --> 00:46:27,119
example

1210
00:46:27,119 --> 00:46:30,000
in charms blind signature scheme uh just

1211
00:46:30,000 --> 00:46:31,839
our result just requires large e so

1212
00:46:31,839 --> 00:46:32,240
that's

1213
00:46:32,240 --> 00:46:35,599
kind of the caveat um okay

1214
00:46:35,599 --> 00:46:38,560
so uh

1215
00:46:38,960 --> 00:46:40,960
so lossy trapped our function so i'll go

1216
00:46:40,960 --> 00:46:42,960
through just briefly very briefly

1217
00:46:42,960 --> 00:46:45,200
the constructions and then conclude adam

1218
00:46:45,200 --> 00:46:46,960
just to get just to give you a check on

1219
00:46:46,960 --> 00:46:48,960
times maybe like one two minutes we

1220
00:46:48,960 --> 00:46:49,599
should conclude

1221
00:46:49,599 --> 00:46:52,800
okay so uh let's see so maybe i

1222
00:46:52,800 --> 00:46:55,599
we have uh the main construction of

1223
00:46:55,599 --> 00:46:57,520
deterministic encryption uh meeting our

1224
00:46:57,520 --> 00:47:00,000
notion is from lossy chapter functions

1225
00:47:00,000 --> 00:47:04,319
and uh the construction uh

1226
00:47:04,319 --> 00:47:07,520
it kind of does uh kind of it

1227
00:47:07,520 --> 00:47:10,640
uses a pairwise independent hash

1228
00:47:10,640 --> 00:47:12,880
and i don't know probably you can't see

1229
00:47:12,880 --> 00:47:14,480
it here but you can talk to me

1230
00:47:14,480 --> 00:47:16,079
after the talk if you want the details

1231
00:47:16,079 --> 00:47:17,839
but it uses a pairwise independent hash

1232
00:47:17,839 --> 00:47:18,640
and kind of

1233
00:47:18,640 --> 00:47:20,720
folds things inside a lossy chapter

1234
00:47:20,720 --> 00:47:21,839
function

1235
00:47:21,839 --> 00:47:24,160
um the lossiness really helps for

1236
00:47:24,160 --> 00:47:25,760
selective opening security that's how we

1237
00:47:25,760 --> 00:47:28,079
get lost in savarasa as i said

1238
00:47:28,079 --> 00:47:31,280
um and so i'll skip the proof and

1239
00:47:31,280 --> 00:47:34,160
thanks for your attention

1240
00:47:35,839 --> 00:47:39,839
um any questions from the audience

1241
00:47:44,000 --> 00:47:45,520
so i i didn't realize that i had a

1242
00:47:45,520 --> 00:47:48,480
little more time i could have gone over

1243
00:47:48,480 --> 00:47:50,160
maybe some of the results so if you want

1244
00:47:50,160 --> 00:47:54,240
me to go over anything just let me know

1245
00:47:54,240 --> 00:47:56,319
yeah sure uh can you go over the high

1246
00:47:56,319 --> 00:47:58,960
level ideas for the construction maybe

1247
00:47:58,960 --> 00:48:02,160
yeah yeah so um

1248
00:48:02,160 --> 00:48:03,680
so the main construction is this

1249
00:48:03,680 --> 00:48:05,760
deterministic encryption construction

1250
00:48:05,760 --> 00:48:07,680
and so let's go through it so the key

1251
00:48:07,680 --> 00:48:09,280
gen generates

1252
00:48:09,280 --> 00:48:10,880
a key pair for the lossy chapter

1253
00:48:10,880 --> 00:48:13,200
function and encryption

1254
00:48:13,200 --> 00:48:16,240
hashes the message uh it

1255
00:48:16,240 --> 00:48:18,960
uh kind of uh you can think of think of

1256
00:48:18,960 --> 00:48:21,040
h and g as random oracles

1257
00:48:21,040 --> 00:48:23,200
at first but then we can show that like

1258
00:48:23,200 --> 00:48:24,640
pairwise independence

1259
00:48:24,640 --> 00:48:27,839
pairwise independence suffices so g of r

1260
00:48:27,839 --> 00:48:31,440
uh r is r is kind of the simulated coins

1261
00:48:31,440 --> 00:48:34,160
it's the hash of the message and g of r

1262
00:48:34,160 --> 00:48:36,480
xors with the message to kind of blind

1263
00:48:36,480 --> 00:48:37,520
the message

1264
00:48:37,520 --> 00:48:41,280
and then you fold uh y and r

1265
00:48:41,280 --> 00:48:44,720
inside the lossy chapter function

1266
00:48:44,720 --> 00:48:48,000
so it's kind of um it's kind of

1267
00:48:48,000 --> 00:48:51,440
a uh some type of

1268
00:48:51,440 --> 00:48:54,559
random oracle based

1269
00:48:54,559 --> 00:48:56,240
encryption scheme adapted to lossy

1270
00:48:56,240 --> 00:48:58,400
chapter functions where things are

1271
00:48:58,400 --> 00:48:59,839
as i said you could think of it first

1272
00:48:59,839 --> 00:49:01,520
cut you can think of h and g as random

1273
00:49:01,520 --> 00:49:02,559
oracles

1274
00:49:02,559 --> 00:49:04,480
uh but it turns out that it suffices

1275
00:49:04,480 --> 00:49:08,079
that for them to be pairwise independent

1276
00:49:10,240 --> 00:49:13,359
so here you did two hashes

1277
00:49:13,359 --> 00:49:16,160
first hash um and then use that to

1278
00:49:16,160 --> 00:49:17,040
somehow mask

1279
00:49:17,040 --> 00:49:19,440
the message yeah there's a specific

1280
00:49:19,440 --> 00:49:20,960
reason for that

1281
00:49:20,960 --> 00:49:24,000
um it's kind of like we took a we took a

1282
00:49:24,000 --> 00:49:25,520
specific randomized scheme and

1283
00:49:25,520 --> 00:49:27,359
de-randomized it by

1284
00:49:27,359 --> 00:49:30,160
hashing the message to get the coins so

1285
00:49:30,160 --> 00:49:31,839
that's where the first hash comes from

1286
00:49:31,839 --> 00:49:33,839
but then the actual scheme itself uses a

1287
00:49:33,839 --> 00:49:35,839
hash so do you get a second hash from

1288
00:49:35,839 --> 00:49:36,640
that

1289
00:49:36,640 --> 00:49:39,040
i see

1290
00:49:41,280 --> 00:49:46,319
yeah um and then the proof intuition is

1291
00:49:46,319 --> 00:49:50,880
uh uh basically when you switch to the

1292
00:49:50,880 --> 00:49:52,319
lossy mode

1293
00:49:52,319 --> 00:49:56,839
um the whole uh lossy mode is pairwise

1294
00:49:56,839 --> 00:49:58,800
independent and then you can use the

1295
00:49:58,800 --> 00:50:00,640
results saying that

1296
00:50:00,640 --> 00:50:03,520
basically i mean this this is basically

1297
00:50:03,520 --> 00:50:05,520
our hash results saying that now

1298
00:50:05,520 --> 00:50:08,800
a pairwise independent hash is soa right

1299
00:50:08,800 --> 00:50:10,079
once you switch the velocity mode you

1300
00:50:10,079 --> 00:50:11,920
gotta effectively get a pairwise

1301
00:50:11,920 --> 00:50:12,800
independent hash

1302
00:50:12,800 --> 00:50:15,839
and you apply that other result so

1303
00:50:15,839 --> 00:50:19,520
okay can i ask a question

1304
00:50:21,119 --> 00:50:23,920
any other question yeah so your

1305
00:50:23,920 --> 00:50:24,720
construction

1306
00:50:24,720 --> 00:50:26,400
it looks i mean it's not the same but it

1307
00:50:26,400 --> 00:50:28,720
looks a little bit like oap

1308
00:50:28,720 --> 00:50:31,920
this is usually yeah so could you get

1309
00:50:31,920 --> 00:50:33,359
like both properties like

1310
00:50:33,359 --> 00:50:35,920
depending on whether you want the

1311
00:50:35,920 --> 00:50:37,359
there's a

1312
00:50:37,359 --> 00:50:39,520
the selective opening security or the

1313
00:50:39,520 --> 00:50:41,440
cca2 security could you have a

1314
00:50:41,440 --> 00:50:42,240
construction

1315
00:50:42,240 --> 00:50:46,160
expose or is that even a variant of sra

1316
00:50:46,160 --> 00:50:48,160
that's a great that's a great question

1317
00:50:48,160 --> 00:50:49,280
um

1318
00:50:49,280 --> 00:50:51,040
we didn't think about this kind of like

1319
00:50:51,040 --> 00:50:52,880
hedge type of thing where

1320
00:50:52,880 --> 00:50:55,200
or whatever you call it where you get to

1321
00:50:55,200 --> 00:50:56,480
like it's kind of interesting to have

1322
00:50:56,480 --> 00:50:58,480
two notions of security depending on

1323
00:50:58,480 --> 00:51:00,079
whether you're assuming random oracle or

1324
00:51:00,079 --> 00:51:02,559
not i guess or maybe if you assume i

1325
00:51:02,559 --> 00:51:04,880
guess if you assume random oracle here

1326
00:51:04,880 --> 00:51:07,440
of course you get the soa security

1327
00:51:07,440 --> 00:51:08,800
because the random oracle is paralyzed

1328
00:51:08,800 --> 00:51:10,000
independent

1329
00:51:10,000 --> 00:51:13,119
but uh if you just want to assume

1330
00:51:13,119 --> 00:51:15,040
pairwise independence for soa and then

1331
00:51:15,040 --> 00:51:16,240
maybe get

1332
00:51:16,240 --> 00:51:20,480
uh cca from random oracle

1333
00:51:20,480 --> 00:51:22,079
yeah i mean that that seems maybe

1334
00:51:22,079 --> 00:51:23,280
plausible we didn't prove that but

1335
00:51:23,280 --> 00:51:25,119
that's interesting

1336
00:51:25,119 --> 00:51:28,559
thanks for the comment

1337
00:51:30,559 --> 00:51:37,839
sent the speaker again

1338
00:51:43,440 --> 00:51:45,920
okay so as for our last speaker of today

1339
00:51:45,920 --> 00:51:48,880
i think it's again david

1340
00:51:48,880 --> 00:51:52,240
yes can you hear me yeah yeah can hear

1341
00:51:52,240 --> 00:51:53,680
yeah i guess you

1342
00:51:53,680 --> 00:51:56,720
can see your slide perfect thank you

1343
00:51:56,720 --> 00:51:58,079
yeah thank you again for your kind

1344
00:51:58,079 --> 00:52:00,240
introduction julio and in this talk i

1345
00:52:00,240 --> 00:52:02,160
will speak about the types of verified

1346
00:52:02,160 --> 00:52:04,800
random functions or short vrfs

1347
00:52:04,800 --> 00:52:07,119
intuitively we can think of a vrf as a

1348
00:52:07,119 --> 00:52:08,880
combination of pseudo-random functions

1349
00:52:08,880 --> 00:52:10,800
and digital signatures

1350
00:52:10,800 --> 00:52:12,960
syntactically the vrf consists of three

1351
00:52:12,960 --> 00:52:15,040
algorithms first a generation algorithm

1352
00:52:15,040 --> 00:52:16,640
that produces a pair of secret key and

1353
00:52:16,640 --> 00:52:18,400
public verification key it's an

1354
00:52:18,400 --> 00:52:20,640
evaluation algorithm that produces a vrf

1355
00:52:20,640 --> 00:52:21,440
output y

1356
00:52:21,440 --> 00:52:24,319
for input x and just like prf the

1357
00:52:24,319 --> 00:52:26,079
algorithm requires a secret key and the

1358
00:52:26,079 --> 00:52:28,319
output is supposed to be pseudo-random

1359
00:52:28,319 --> 00:52:30,400
however the evaluation algorithm also

1360
00:52:30,400 --> 00:52:32,000
produces the non-interactive proof of

1361
00:52:32,000 --> 00:52:33,280
greatness pi

1362
00:52:33,280 --> 00:52:35,280
this proof can then be used to verify

1363
00:52:35,280 --> 00:52:37,520
the correctness of y with respect to the

1364
00:52:37,520 --> 00:52:38,400
input x

1365
00:52:38,400 --> 00:52:40,960
and the public verification key due to

1366
00:52:40,960 --> 00:52:42,559
the short time the roundtab won't be

1367
00:52:42,559 --> 00:52:44,480
able to discuss the security experiment

1368
00:52:44,480 --> 00:52:45,440
for vrfs

1369
00:52:45,440 --> 00:52:47,280
but for intuition you can mostly think

1370
00:52:47,280 --> 00:52:48,720
of this think of it

1371
00:52:48,720 --> 00:52:51,440
as a security experiment for eof cma

1372
00:52:51,440 --> 00:52:54,240
security of unique signatures

1373
00:52:54,240 --> 00:52:56,079
in terms of contributions this paper

1374
00:52:56,079 --> 00:52:57,839
revisits the lower bounds on the loss of

1375
00:52:57,839 --> 00:52:59,200
security proofs for public key

1376
00:52:59,200 --> 00:53:01,599
cryptography from eurocrypt 2016 by bada

1377
00:53:01,599 --> 00:53:02,319
at i

1378
00:53:02,319 --> 00:53:05,200
and extends them to vrfs furthermore we

1379
00:53:05,200 --> 00:53:06,960
present the first construction of a vr

1380
00:53:06,960 --> 00:53:08,559
apps that can be proven secure with this

1381
00:53:08,559 --> 00:53:10,079
optimal security loss

1382
00:53:10,079 --> 00:53:11,760
this construction is based on one of the

1383
00:53:11,760 --> 00:53:13,440
vr apps from the full version of the

1384
00:53:13,440 --> 00:53:16,480
crypto 2017 paper by shota yamada

1385
00:53:16,480 --> 00:53:18,160
let us first look at the lower bounds

1386
00:53:18,160 --> 00:53:19,520
for the tightness loss

1387
00:53:19,520 --> 00:53:22,160
of security proofs of vrfs intuitively

1388
00:53:22,160 --> 00:53:24,000
vrs are very similar to unique

1389
00:53:24,000 --> 00:53:25,280
signatures but with

1390
00:53:25,280 --> 00:53:27,359
partially pseudo-random signatures and

1391
00:53:27,359 --> 00:53:29,119
we would just expect that the security

1392
00:53:29,119 --> 00:53:30,559
reduction for vrfs

1393
00:53:30,559 --> 00:53:32,800
have a similar lab similar or larger

1394
00:53:32,800 --> 00:53:34,640
reduction loss

1395
00:53:34,640 --> 00:53:36,240
indeed what we find is slightly

1396
00:53:36,240 --> 00:53:38,160
surprising namely that the current

1397
00:53:38,160 --> 00:53:39,839
bounds only applied to your apps that

1398
00:53:39,839 --> 00:53:41,359
have a re-randomizable

1399
00:53:41,359 --> 00:53:44,240
proof of correctness however we are able

1400
00:53:44,240 --> 00:53:45,680
to address this in the proof of the

1401
00:53:45,680 --> 00:53:47,520
lower bound of bada at all

1402
00:53:47,520 --> 00:53:50,000
and thus adapted to vrfs we thus show

1403
00:53:50,000 --> 00:53:51,280
that every reduction from a

1404
00:53:51,280 --> 00:53:53,119
non-interactive complexity assumption to

1405
00:53:53,119 --> 00:53:54,800
the security of the vrf

1406
00:53:54,800 --> 00:53:57,119
loses at least a factor of q where q is

1407
00:53:57,119 --> 00:53:58,000
the number

1408
00:53:58,000 --> 00:54:00,559
of queries by the adversary we won't be

1409
00:54:00,559 --> 00:54:02,160
able to go into the details of the proof

1410
00:54:02,160 --> 00:54:03,920
however for those of you who know the

1411
00:54:03,920 --> 00:54:05,119
techniques

1412
00:54:05,119 --> 00:54:07,480
the lower bound proof uses the

1413
00:54:07,480 --> 00:54:09,200
re-randomizability only for the

1414
00:54:09,200 --> 00:54:10,000
challenge

1415
00:54:10,000 --> 00:54:11,599
however the challenge in the vrf

1416
00:54:11,599 --> 00:54:13,440
security experiment does not include the

1417
00:54:13,440 --> 00:54:14,559
proof of correctness pi

1418
00:54:14,559 --> 00:54:16,319
and thus the lower bound holds

1419
00:54:16,319 --> 00:54:18,240
regardless of the re-randomizability of

1420
00:54:18,240 --> 00:54:19,599
time

1421
00:54:19,599 --> 00:54:21,119
unfortunately the loss of previous

1422
00:54:21,119 --> 00:54:22,800
constructions in the standard model is

1423
00:54:22,800 --> 00:54:24,559
significantly worse when

1424
00:54:24,559 --> 00:54:26,960
than what is indicated by our bound

1425
00:54:26,960 --> 00:54:28,720
however with a little bit of trying we

1426
00:54:28,720 --> 00:54:30,079
can construct a brf

1427
00:54:30,079 --> 00:54:31,839
with a security proof with this

1428
00:54:31,839 --> 00:54:33,680
tightness loss

1429
00:54:33,680 --> 00:54:35,359
for the intuition behind our technique

1430
00:54:35,359 --> 00:54:37,599
let us slightly move the gold posts

1431
00:54:37,599 --> 00:54:40,240
and assumes a very nice adversary that

1432
00:54:40,240 --> 00:54:42,079
chooses all its queries and a challenge

1433
00:54:42,079 --> 00:54:43,760
uniformly at random from the domain of

1434
00:54:43,760 --> 00:54:45,040
the brf

1435
00:54:45,040 --> 00:54:46,720
if this were the case the reduction

1436
00:54:46,720 --> 00:54:48,720
could just guess the first block q plus

1437
00:54:48,720 --> 00:54:50,640
1 bits of the challenge input

1438
00:54:50,640 --> 00:54:52,079
and the reduction would be able to

1439
00:54:52,079 --> 00:54:53,599
extract the solution to the underlying

1440
00:54:53,599 --> 00:54:55,200
hardness assumption with the first block

1441
00:54:55,200 --> 00:54:56,480
q plus one bits

1442
00:54:56,480 --> 00:54:58,799
of the children do match the gas and it

1443
00:54:58,799 --> 00:55:00,720
and it can simulate an evaluation of the

1444
00:55:00,720 --> 00:55:01,440
vrf

1445
00:55:01,440 --> 00:55:03,520
if the first log q plus one bits of an

1446
00:55:03,520 --> 00:55:06,400
evaluation query differ from the gas

1447
00:55:06,400 --> 00:55:08,240
then proving that this strategy yields a

1448
00:55:08,240 --> 00:55:09,920
loss of only eight q is rather

1449
00:55:09,920 --> 00:55:12,079
straightforward and refers to the paper

1450
00:55:12,079 --> 00:55:13,839
for the forward proof

1451
00:55:13,839 --> 00:55:16,240
however of course it only holds for this

1452
00:55:16,240 --> 00:55:17,920
very nice adversary and

1453
00:55:17,920 --> 00:55:19,839
let's be honest most adversaries won't

1454
00:55:19,839 --> 00:55:21,440
be that nice

1455
00:55:21,440 --> 00:55:23,920
but we can make it work by passing all

1456
00:55:23,920 --> 00:55:26,240
inputs through prf first

1457
00:55:26,240 --> 00:55:28,079
before comparing them to the guest

1458
00:55:28,079 --> 00:55:29,520
prefix then

1459
00:55:29,520 --> 00:55:31,280
even if they are adversely chosen they

1460
00:55:31,280 --> 00:55:33,040
will be distributed computationally

1461
00:55:33,040 --> 00:55:34,720
indistinguishable from independent

1462
00:55:34,720 --> 00:55:36,720
uniformly random values

1463
00:55:36,720 --> 00:55:39,040
however the evaluation has to happen

1464
00:55:39,040 --> 00:55:40,880
outside of the view of the adversary

1465
00:55:40,880 --> 00:55:42,319
and at the same time has to be

1466
00:55:42,319 --> 00:55:43,599
incorporated into the proof of

1467
00:55:43,599 --> 00:55:45,119
correctness

1468
00:55:45,119 --> 00:55:47,359
fortunately however one of the shorter

1469
00:55:47,359 --> 00:55:50,160
yamada's reacts from crypto 2017

1470
00:55:50,160 --> 00:55:52,799
allows us to do exactly that more

1471
00:55:52,799 --> 00:55:54,559
specifically it allows us to embed an

1472
00:55:54,559 --> 00:55:55,520
arbitrary nun

1473
00:55:55,520 --> 00:55:57,440
circuit of polynomial size and

1474
00:55:57,440 --> 00:55:58,799
logarithmic depth

1475
00:55:58,799 --> 00:56:01,200
into the vrf so that the reduction can

1476
00:56:01,200 --> 00:56:03,440
simulate an evaluation of the vrf

1477
00:56:03,440 --> 00:56:05,440
if and only if the circuit evaluates to

1478
00:56:05,440 --> 00:56:08,000
zero that it can extract the solution to

1479
00:56:08,000 --> 00:56:09,920
the underlying hardness assumption

1480
00:56:09,920 --> 00:56:12,319
if and only if the circuit evaluates to

1481
00:56:12,319 --> 00:56:13,040
one

1482
00:56:13,040 --> 00:56:15,839
on the challenge input this embedding

1483
00:56:15,839 --> 00:56:16,319
hides

1484
00:56:16,319 --> 00:56:19,040
some chosen input bits and also all

1485
00:56:19,040 --> 00:56:20,720
internal states and the output of the

1486
00:56:20,720 --> 00:56:22,640
circuit from the adversary

1487
00:56:22,640 --> 00:56:24,480
thus we can embed the evaluation of the

1488
00:56:24,480 --> 00:56:27,359
prf and the comparison to the to our

1489
00:56:27,359 --> 00:56:27,920
guess

1490
00:56:27,920 --> 00:56:29,920
by setting the prf key and the guests as

1491
00:56:29,920 --> 00:56:31,359
secret input bits

1492
00:56:31,359 --> 00:56:33,200
then the proof strategy we discussed

1493
00:56:33,200 --> 00:56:36,160
before works without any flaws

1494
00:56:36,160 --> 00:56:38,079
in conclusion we first showed that the

1495
00:56:38,079 --> 00:56:39,680
lower bound on the loss of many public

1496
00:56:39,680 --> 00:56:41,839
key privileges by vardarta from crypto

1497
00:56:41,839 --> 00:56:44,880
europe 2016 also applies to vrfs in the

1498
00:56:44,880 --> 00:56:45,839
standard model

1499
00:56:45,839 --> 00:56:47,760
and we then show that this bound is tied

1500
00:56:47,760 --> 00:56:49,599
by presenting vrf with an accompanying

1501
00:56:49,599 --> 00:56:50,319
proof of

1502
00:56:50,319 --> 00:56:53,200
security that achieves this optimal loss

1503
00:56:53,200 --> 00:56:53,520
with

1504
00:56:53,520 --> 00:56:56,160
up to a small constant factor finally

1505
00:56:56,160 --> 00:56:57,680
again thank you all for your attention

1506
00:56:57,680 --> 00:56:58,480
if you have any

1507
00:56:58,480 --> 00:57:01,040
any questions feel free to write an

1508
00:57:01,040 --> 00:57:01,839
email

1509
00:57:01,839 --> 00:57:03,520
take a look at the paper or of course

1510
00:57:03,520 --> 00:57:05,200
ask just right now or

1511
00:57:05,200 --> 00:57:09,759
via zulip later on yeah thank you

1512
00:57:11,599 --> 00:57:14,960
thank the speaker for the talk um

1513
00:57:14,960 --> 00:57:26,559
any questions from the audience

1514
00:57:26,559 --> 00:57:28,319
so you said the lower bound and upper

1515
00:57:28,319 --> 00:57:30,160
bound is only constant factors

1516
00:57:30,160 --> 00:57:31,839
difference

1517
00:57:31,839 --> 00:57:35,359
yes so we can prove uh the lower bound

1518
00:57:35,359 --> 00:57:36,480
that with a loss of

1519
00:57:36,480 --> 00:57:39,359
q where q is the number of evaluation

1520
00:57:39,359 --> 00:57:40,799
queries

1521
00:57:40,799 --> 00:57:43,760
and we can show that we can show that in

1522
00:57:43,760 --> 00:57:45,680
the reduction that we lose only a factor

1523
00:57:45,680 --> 00:57:46,400
of 8q

1524
00:57:46,400 --> 00:57:49,680
where the 8 is due to some um

1525
00:57:49,680 --> 00:57:52,240
get some upper upper and lower bounding

1526
00:57:52,240 --> 00:57:53,200
of some equations

1527
00:57:53,200 --> 00:57:55,200
so if you look at it very very very

1528
00:57:55,200 --> 00:57:56,400
precisely

1529
00:57:56,400 --> 00:57:59,040
you might even get closer but for the

1530
00:57:59,040 --> 00:58:01,440
purpose of the paper

1531
00:58:01,440 --> 00:58:04,480
we deemed it plausible or enough to show

1532
00:58:04,480 --> 00:58:05,040
this

1533
00:58:05,040 --> 00:58:08,319
constant factor difference

1534
00:58:08,319 --> 00:58:12,880
asymptotically it is tight yes

1535
00:58:16,000 --> 00:58:22,160
any other questions

1536
00:58:22,160 --> 00:58:24,559
okay let's thank the speaker again and

1537
00:58:24,559 --> 00:58:28,319
thank all the speakers for the session

1538
00:58:29,599 --> 00:58:33,119
yeah thanks everyone for attending

1539
00:58:33,920 --> 00:58:38,319
so we will be back in 15

