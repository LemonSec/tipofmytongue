1
00:00:00,880 --> 00:00:02,639
and you're welcome to get started we're

2
00:00:02,639 --> 00:00:05,120
on youtube now

3
00:00:05,120 --> 00:00:08,639
okay um all right welcome everyone to

4
00:00:08,639 --> 00:00:10,559
the session on functional encryption and

5
00:00:10,559 --> 00:00:12,240
attribute-based encryption

6
00:00:12,240 --> 00:00:14,480
our first speaker is miguel ambrona

7
00:00:14,480 --> 00:00:16,400
who's telling us about generic negation

8
00:00:16,400 --> 00:00:17,279
of pain

9
00:00:17,279 --> 00:00:20,880
encodings yeah thank you

10
00:00:20,880 --> 00:00:24,160
for the introduction

11
00:00:24,800 --> 00:00:28,160
it's been seen properly yeah so

12
00:00:28,160 --> 00:00:30,080
in this work we we propose a generic

13
00:00:30,080 --> 00:00:31,679
negation of pairing codings

14
00:00:31,679 --> 00:00:33,840
and variance codings are a primitive

15
00:00:33,840 --> 00:00:35,440
that is used to build attribute-based

16
00:00:35,440 --> 00:00:36,399
encryption so you know in

17
00:00:36,399 --> 00:00:38,000
attribute-based encryption

18
00:00:38,000 --> 00:00:41,200
everybody can encrypt and when they

19
00:00:41,200 --> 00:00:43,840
when they produce a cipher text out of

20
00:00:43,840 --> 00:00:45,360
their message they are thinking of

21
00:00:45,360 --> 00:00:47,600
certain policy

22
00:00:47,600 --> 00:00:50,399
and the system is such that only those

23
00:00:50,399 --> 00:00:52,879
users who own a secret key

24
00:00:52,879 --> 00:00:55,920
with attributes satisfying the policy

25
00:00:55,920 --> 00:00:58,239
will be able to decrypt the ciphertext

26
00:00:58,239 --> 00:01:00,960
and this secret key has uh been

27
00:01:00,960 --> 00:01:02,480
requested

28
00:01:02,480 --> 00:01:04,799
and has been pro has been provided has

29
00:01:04,799 --> 00:01:08,400
been produced by a master authority

30
00:01:08,400 --> 00:01:10,799
so okay more generally when you encrypt

31
00:01:10,799 --> 00:01:12,320
when you produce a ciphertext

32
00:01:12,320 --> 00:01:13,840
you associate the value x to the

33
00:01:13,840 --> 00:01:16,799
ciphertext every secret key has a

34
00:01:16,799 --> 00:01:19,840
value of y associated and decryption

35
00:01:19,840 --> 00:01:23,200
works only if a predicate between x and

36
00:01:23,200 --> 00:01:23,600
y

37
00:01:23,600 --> 00:01:26,159
holds and there are many techniques

38
00:01:26,159 --> 00:01:27,280
there are many works

39
00:01:27,280 --> 00:01:29,200
for building a full security base

40
00:01:29,200 --> 00:01:31,119
encryption systems

41
00:01:31,119 --> 00:01:33,360
and the the one i'm interested in is

42
00:01:33,360 --> 00:01:35,920
this technique called parent codings

43
00:01:35,920 --> 00:01:38,840
which was introduced by a trapdoor in

44
00:01:38,840 --> 00:01:41,119
2014 and it's a very nice

45
00:01:41,119 --> 00:01:44,479
very nice idea you can focus on building

46
00:01:44,479 --> 00:01:46,159
a pre-encoding

47
00:01:46,159 --> 00:01:49,680
for certain predicate and then

48
00:01:49,680 --> 00:01:51,600
there is a a compiler that gives you a

49
00:01:51,600 --> 00:01:54,399
full security-based encryption

50
00:01:54,399 --> 00:01:56,640
system out of that encoding and this is

51
00:01:56,640 --> 00:01:58,479
very nice because analyzing the encoding

52
00:01:58,479 --> 00:02:00,000
is much simpler than analyzing the

53
00:02:00,000 --> 00:02:01,759
attribute-based encryption

54
00:02:01,759 --> 00:02:04,640
scheme in this talk we focus on very

55
00:02:04,640 --> 00:02:05,920
encoding schemes

56
00:02:05,920 --> 00:02:07,600
and a very natural question is whether

57
00:02:07,600 --> 00:02:09,440
you can transform or combine parent

58
00:02:09,440 --> 00:02:10,479
codings

59
00:02:10,479 --> 00:02:12,239
these are for example some combinations

60
00:02:12,239 --> 00:02:13,760
that that have been considered in the

61
00:02:13,760 --> 00:02:14,640
past

62
00:02:14,640 --> 00:02:16,800
so given a pairing coding scheme for a

63
00:02:16,800 --> 00:02:19,440
predicate p

64
00:02:19,520 --> 00:02:21,760
you can build a paren coding scheme for

65
00:02:21,760 --> 00:02:22,959
its dual predicate

66
00:02:22,959 --> 00:02:24,800
the dual predicate just swaps the rows

67
00:02:24,800 --> 00:02:26,319
of x and y

68
00:02:26,319 --> 00:02:28,000
or if you have two predicating two

69
00:02:28,000 --> 00:02:29,680
pairing codings for two different

70
00:02:29,680 --> 00:02:31,280
predicates you can make one for the

71
00:02:31,280 --> 00:02:32,480
conjunction

72
00:02:32,480 --> 00:02:34,800
this was done by a trapezoid and yamaha

73
00:02:34,800 --> 00:02:37,440
five or six years ago

74
00:02:37,440 --> 00:02:39,200
and you can also do this junction this

75
00:02:39,200 --> 00:02:41,200
junction is very easy but how about

76
00:02:41,200 --> 00:02:44,959
negation so negation seems uh

77
00:02:44,959 --> 00:02:46,560
a lot harder and this was not done

78
00:02:46,560 --> 00:02:48,720
before i have to say that this was done

79
00:02:48,720 --> 00:02:49,280
in a

80
00:02:49,280 --> 00:02:51,120
in a different framework very nice also

81
00:02:51,120 --> 00:02:53,840
introduced by hotec by the way

82
00:02:53,840 --> 00:02:56,720
uh predicate encodings so in this

83
00:02:56,720 --> 00:02:58,640
framework we knew how to generally

84
00:02:58,640 --> 00:02:59,120
negate

85
00:02:59,120 --> 00:03:01,120
a predicate and calling but in the

86
00:03:01,120 --> 00:03:03,200
framework of parent codings which are

87
00:03:03,200 --> 00:03:04,720
believed to be well they actually are

88
00:03:04,720 --> 00:03:06,080
more general

89
00:03:06,080 --> 00:03:08,159
we didn't know how to how to generically

90
00:03:08,159 --> 00:03:09,920
negate them so this is what we do in

91
00:03:09,920 --> 00:03:10,640
this work

92
00:03:10,640 --> 00:03:12,560
so our main contribution is a generic

93
00:03:12,560 --> 00:03:14,080
transformation that takes any parent

94
00:03:14,080 --> 00:03:16,159
coding scheme for predicate p

95
00:03:16,159 --> 00:03:18,959
and produces a new print print coding

96
00:03:18,959 --> 00:03:22,159
for the negated predicate

97
00:03:22,159 --> 00:03:24,239
so along the way we propose an algebraic

98
00:03:24,239 --> 00:03:25,920
characterization of pairing codings that

99
00:03:25,920 --> 00:03:26,720
i believe

100
00:03:26,720 --> 00:03:29,120
can be of independent interest and we

101
00:03:29,120 --> 00:03:29,920
also explore

102
00:03:29,920 --> 00:03:32,480
other other consequences of these

103
00:03:32,480 --> 00:03:34,400
results and this is what i want to

104
00:03:34,400 --> 00:03:36,400
talk a little bit about in the rest of

105
00:03:36,400 --> 00:03:38,319
this presentation

106
00:03:38,319 --> 00:03:41,440
so first of all we found new encoding so

107
00:03:41,440 --> 00:03:44,000
there was this parenchyma scheme by a

108
00:03:44,000 --> 00:03:45,040
trapadon

109
00:03:45,040 --> 00:03:47,519
for the w special encryption predicate

110
00:03:47,519 --> 00:03:48,959
which is this one

111
00:03:48,959 --> 00:03:52,560
and it was unknown how to build

112
00:03:52,560 --> 00:03:54,400
a parenchy scheme for the negated

113
00:03:54,400 --> 00:03:56,879
predicate so negated doubly spatial

114
00:03:56,879 --> 00:03:58,640
encryption

115
00:03:58,640 --> 00:04:00,720
and we can use our transformation we

116
00:04:00,720 --> 00:04:02,319
have it for free

117
00:04:02,319 --> 00:04:04,000
and in fact we can have it for we can

118
00:04:04,000 --> 00:04:05,439
have a dedication of a

119
00:04:05,439 --> 00:04:08,159
any uh parenchy scheme without having to

120
00:04:08,159 --> 00:04:09,599
design it

121
00:04:09,599 --> 00:04:11,200
so i want to say that i'm very grateful

122
00:04:11,200 --> 00:04:13,120
to atrap adam because he's the one who

123
00:04:13,120 --> 00:04:14,319
pointed out that this

124
00:04:14,319 --> 00:04:17,199
this problem was open and it made my

125
00:04:17,199 --> 00:04:17,680
paper

126
00:04:17,680 --> 00:04:19,759
uh much stronger so thank you thank you

127
00:04:19,759 --> 00:04:22,079
so much for that

128
00:04:22,079 --> 00:04:25,440
okay other things i want to mention um

129
00:04:25,440 --> 00:04:28,000
the expressivity of parent codings i

130
00:04:28,000 --> 00:04:29,840
think our new result brings

131
00:04:29,840 --> 00:04:31,680
new non-trivial information about the

132
00:04:31,680 --> 00:04:33,040
expressivity

133
00:04:33,040 --> 00:04:34,720
that can be achieved with parent coding

134
00:04:34,720 --> 00:04:37,840
schemes so for example what i mean

135
00:04:37,840 --> 00:04:40,320
is that the the set of predicates that

136
00:04:40,320 --> 00:04:41,680
we can handle

137
00:04:41,680 --> 00:04:45,120
is closed under negation so one of the

138
00:04:45,120 --> 00:04:46,400
consequences of this

139
00:04:46,400 --> 00:04:48,720
of this observation is that maybe

140
00:04:48,720 --> 00:04:50,400
building a

141
00:04:50,400 --> 00:04:52,479
encoding scheme for context free

142
00:04:52,479 --> 00:04:55,040
languages is harder than we think

143
00:04:55,040 --> 00:04:56,960
because you know context-free languages

144
00:04:56,960 --> 00:04:59,199
are not closed under complementation

145
00:04:59,199 --> 00:05:00,800
so if we could build a brain content

146
00:05:00,800 --> 00:05:02,720
scheme for a context-free language

147
00:05:02,720 --> 00:05:05,199
we would have also apparently scheme for

148
00:05:05,199 --> 00:05:06,400
some for some

149
00:05:06,400 --> 00:05:08,320
class that is strictly more powerful

150
00:05:08,320 --> 00:05:11,280
than context three languages

151
00:05:11,280 --> 00:05:13,759
so this suggests that maybe it's already

152
00:05:13,759 --> 00:05:14,479
hard to achieve

153
00:05:14,479 --> 00:05:17,120
against languages or maybe it's

154
00:05:17,120 --> 00:05:18,400
impossible or with

155
00:05:18,400 --> 00:05:21,520
parent codings given this observation

156
00:05:21,520 --> 00:05:24,720
and other other consequences that we

157
00:05:24,720 --> 00:05:27,280
explore in the paper are potential

158
00:05:27,280 --> 00:05:29,520
performance improvements so

159
00:05:29,520 --> 00:05:31,520
our transformation i didn't i didn't

160
00:05:31,520 --> 00:05:33,600
show how the transformation looks like

161
00:05:33,600 --> 00:05:37,759
but it gives a very specific structure

162
00:05:37,759 --> 00:05:40,639
on the produced encoding and it actually

163
00:05:40,639 --> 00:05:42,800
shows that any encoding can be expressed

164
00:05:42,800 --> 00:05:44,160
in this form

165
00:05:44,160 --> 00:05:47,120
and we explore several ideas that

166
00:05:47,120 --> 00:05:47,840
exploit this

167
00:05:47,840 --> 00:05:51,280
structure to produce a faster

168
00:05:51,280 --> 00:05:54,080
implementation so for example you can

169
00:05:54,080 --> 00:05:54,880
pre-compute

170
00:05:54,880 --> 00:05:56,240
some part that does not depend on the

171
00:05:56,240 --> 00:05:58,160
predicate and and only

172
00:05:58,160 --> 00:06:00,400
perform an unlike online computation on

173
00:06:00,400 --> 00:06:02,240
the part that uh

174
00:06:02,240 --> 00:06:03,840
actually depends on the predicate so it

175
00:06:03,840 --> 00:06:05,759
will be a very interesting direction for

176
00:06:05,759 --> 00:06:07,680
future future work to

177
00:06:07,680 --> 00:06:10,319
to implement and really test whether

178
00:06:10,319 --> 00:06:10,880
these

179
00:06:10,880 --> 00:06:14,080
ideas lead to something so yeah that's

180
00:06:14,080 --> 00:06:17,440
everything i wanted to say thank you so

181
00:06:18,840 --> 00:06:20,560
much

182
00:06:20,560 --> 00:06:22,639
thanks a lot miguel uh we have time for

183
00:06:22,639 --> 00:06:25,759
like a quick question maybe

184
00:06:28,479 --> 00:06:32,840
okay uh so we have a question

185
00:06:32,840 --> 00:06:36,319
from on the chat it looks a bit long but

186
00:06:36,319 --> 00:06:37,280
maybe we can

187
00:06:37,280 --> 00:06:40,720
put it to the end of the session uh

188
00:06:40,720 --> 00:06:44,800
or maybe i can try to read so

189
00:06:45,039 --> 00:06:47,680
right so if you apply your generic

190
00:06:47,680 --> 00:06:49,680
negation transformation to the

191
00:06:49,680 --> 00:06:52,639
uh say the unbounded kp abe formula

192
00:06:52,639 --> 00:06:53,840
constant programs

193
00:06:53,840 --> 00:06:57,280
for uh in the ultra paddle shield 2019

194
00:06:57,280 --> 00:06:58,319
paper

195
00:06:58,319 --> 00:07:00,080
do you get the same scheme as the one

196
00:07:00,080 --> 00:07:01,440
for non-monotone

197
00:07:01,440 --> 00:07:05,280
or is your generic negation different

198
00:07:06,560 --> 00:07:10,240
i guess it's probably different

199
00:07:10,479 --> 00:07:13,840
but i'm not sure

200
00:07:13,840 --> 00:07:16,880
i'm not very familiar with the

201
00:07:16,880 --> 00:07:21,360
framework of dynamic composition

202
00:07:21,360 --> 00:07:24,960
but my guess is it's

203
00:07:24,960 --> 00:07:27,919
very different

204
00:07:28,160 --> 00:07:29,919
okay maybe we can kind of take this to

205
00:07:29,919 --> 00:07:31,440
the left no idea

206
00:07:31,440 --> 00:07:33,440
that's all right i can look at that and

207
00:07:33,440 --> 00:07:35,199
and

208
00:07:35,199 --> 00:07:38,400
and give an answer in a few days to go

209
00:07:38,400 --> 00:07:40,638
over

210
00:07:40,880 --> 00:07:44,639
okay all right uh let's thank miguel and

211
00:07:44,639 --> 00:07:47,840
uh let's proceed to the next talk

212
00:07:47,840 --> 00:07:53,758
uh do we have uh shinran phong around

213
00:07:54,479 --> 00:07:58,319
yeah okay great uh so our next uh

214
00:07:58,319 --> 00:08:02,319
talk is uh master key kdm secure abe via

215
00:08:02,319 --> 00:08:02,720
private

216
00:08:02,720 --> 00:08:05,840
encoding by shinran from and

217
00:08:05,840 --> 00:08:09,599
uh and shinri will give the talk

218
00:08:09,599 --> 00:08:15,360
okay thank you oh let me show my screen

219
00:08:16,560 --> 00:08:21,199
okay so thank you hello everyone

220
00:08:21,199 --> 00:08:25,039
uh i would like to share our work about

221
00:08:25,039 --> 00:08:27,199
the framework of attributes based

222
00:08:27,199 --> 00:08:28,639
encryption with

223
00:08:28,639 --> 00:08:31,360
master key kdm security it's a joint

224
00:08:31,360 --> 00:08:34,000
work with xinjingong and json

225
00:08:34,000 --> 00:08:36,880
and in this work we study the master key

226
00:08:36,880 --> 00:08:39,120
dependent message security for the

227
00:08:39,120 --> 00:08:42,240
find function that is the the encrypted

228
00:08:42,240 --> 00:08:43,039
message

229
00:08:43,039 --> 00:08:46,240
is a file function of a master key and

230
00:08:46,240 --> 00:08:46,560
the

231
00:08:46,560 --> 00:08:49,279
adversary cannot distinguish the key

232
00:08:49,279 --> 00:08:50,560
dependent message

233
00:08:50,560 --> 00:08:52,800
and run the message even obtaining

234
00:08:52,800 --> 00:08:54,399
multiple mismatched

235
00:08:54,399 --> 00:08:57,680
civil texts and secret keys and we use

236
00:08:57,680 --> 00:08:58,640
the notion

237
00:08:58,640 --> 00:09:02,480
of predicating coding which provides a

238
00:09:02,480 --> 00:09:05,200
similar description of the underlying

239
00:09:05,200 --> 00:09:07,040
predicate p

240
00:09:07,040 --> 00:09:10,720
like ib hib abp for

241
00:09:10,720 --> 00:09:13,760
ap for abp so

242
00:09:13,760 --> 00:09:16,959
by concrete encodings we propose the

243
00:09:16,959 --> 00:09:20,320
first m ktm secure hiv schema

244
00:09:20,320 --> 00:09:23,839
and the first mkdm secure abe

245
00:09:23,839 --> 00:09:26,399
schema for abp under standard pairing

246
00:09:26,399 --> 00:09:28,160
based assumption

247
00:09:28,160 --> 00:09:31,040
thanks to the expressiveness we combine

248
00:09:31,040 --> 00:09:31,360
the

249
00:09:31,360 --> 00:09:35,040
classical chk cpa to cca transformation

250
00:09:35,040 --> 00:09:38,399
and obtain cca security

251
00:09:38,399 --> 00:09:42,240
and in the context of ibe

252
00:09:42,240 --> 00:09:45,360
we can also derive an ib schema from our

253
00:09:45,360 --> 00:09:46,560
framework

254
00:09:46,560 --> 00:09:49,839
it enjoys constant size master public

255
00:09:49,839 --> 00:09:50,160
key

256
00:09:50,160 --> 00:09:53,920
and achieve mkdmcca security

257
00:09:53,920 --> 00:09:56,720
um as a start point we first revisit

258
00:09:56,720 --> 00:10:00,080
ggh20 schema and next i will show the

259
00:10:00,080 --> 00:10:03,279
main idea behind our proof

260
00:10:03,279 --> 00:10:06,640
so uh both our schema and ggs schema use

261
00:10:06,640 --> 00:10:09,279
three basis simulating three subgroups

262
00:10:09,279 --> 00:10:10,800
in the composite order

263
00:10:10,800 --> 00:10:15,200
groups and here is the gh20 schema

264
00:10:15,200 --> 00:10:18,320
they showed a clever combination of ktm

265
00:10:18,320 --> 00:10:19,200
secure

266
00:10:19,200 --> 00:10:23,920
pke and tight secure ibe

267
00:10:23,920 --> 00:10:27,519
by the type reduction of ibe lets a

268
00:10:27,519 --> 00:10:29,920
variant of geosystem technical

269
00:10:29,920 --> 00:10:32,720
they can extract the entropy by this

270
00:10:32,720 --> 00:10:33,600
entropy

271
00:10:33,600 --> 00:10:36,399
they can carry out the ktm argument as

272
00:10:36,399 --> 00:10:38,959
in bbh08

273
00:10:38,959 --> 00:10:41,920
but however their proof relies on the

274
00:10:41,920 --> 00:10:42,959
structures of

275
00:10:42,959 --> 00:10:46,079
secret key and cyber text so it's not

276
00:10:46,079 --> 00:10:49,760
general for our schema

277
00:10:49,839 --> 00:10:53,760
in this work we employ another variant

278
00:10:53,760 --> 00:10:56,000
the system technical is slightly

279
00:10:56,000 --> 00:10:58,240
different to the standard using

280
00:10:58,240 --> 00:10:59,120
technical

281
00:10:59,120 --> 00:11:01,920
we first change secret keys and then

282
00:11:01,920 --> 00:11:04,240
change the server text one by one

283
00:11:04,240 --> 00:11:07,440
with another list argument and in final

284
00:11:07,440 --> 00:11:10,800
we change all cyber tags and secret keys

285
00:11:10,800 --> 00:11:13,360
at this point one can control the

286
00:11:13,360 --> 00:11:14,320
leakage of

287
00:11:14,320 --> 00:11:16,959
master secret key and england message

288
00:11:16,959 --> 00:11:17,519
using

289
00:11:17,519 --> 00:11:20,959
the entropy and then carry out the kdm

290
00:11:20,959 --> 00:11:21,519
argument

291
00:11:21,519 --> 00:11:29,839
for pke okay let's all thank you

292
00:11:31,279 --> 00:11:34,320
thank you very much that was a quick

293
00:11:34,320 --> 00:11:38,000
do we have any questions for the speaker

294
00:11:41,120 --> 00:11:44,240
uh let me just quickly check tune it

295
00:11:44,240 --> 00:11:46,640
um maybe i can ask a quick question so

296
00:11:46,640 --> 00:11:48,160
are there specific applications where

297
00:11:48,160 --> 00:11:50,399
you need kdm security

298
00:11:50,399 --> 00:11:54,399
of those schemes oh sorry

299
00:11:54,399 --> 00:11:56,000
my network has some problem can you

300
00:11:56,000 --> 00:11:58,000
repeat your question so do you know

301
00:11:58,000 --> 00:11:59,920
any specific applications where this

302
00:11:59,920 --> 00:12:01,120
property is needed

303
00:12:01,120 --> 00:12:04,959
to gain poor web security

304
00:12:05,040 --> 00:12:08,880
oh i'm not sure about this

305
00:12:08,880 --> 00:12:11,440
sorry anyways yeah i mean it's good to

306
00:12:11,440 --> 00:12:13,200
have but i was wondering whether

307
00:12:13,200 --> 00:12:15,120
it really kind of arises out of specific

308
00:12:15,120 --> 00:12:17,680
applications

309
00:12:21,440 --> 00:12:25,519
the other questions

310
00:12:25,519 --> 00:12:27,279
um okay then maybe we thank thank for

311
00:12:27,279 --> 00:12:29,279
the questions at the end of the session

312
00:12:29,279 --> 00:12:30,800
so i'm going to hand off to my fellow

313
00:12:30,800 --> 00:12:32,240
session chair to introduce the next

314
00:12:32,240 --> 00:12:33,279
speaker

315
00:12:33,279 --> 00:12:36,639
thank you okay so

316
00:12:36,639 --> 00:12:40,240
um hello everyone so the

317
00:12:40,240 --> 00:12:42,480
third talk of this session will be in a

318
00:12:42,480 --> 00:12:44,320
client functional encryption

319
00:12:44,320 --> 00:12:47,040
for separable functions and there are

320
00:12:47,040 --> 00:12:48,959
three authors to that paper

321
00:12:48,959 --> 00:12:51,839
ikelicampi with a siniskal iskalki and

322
00:12:51,839 --> 00:12:53,120
henry corner

323
00:12:53,120 --> 00:12:55,920
and the talk will be given by enrique so

324
00:12:55,920 --> 00:12:56,800
andrix of the

325
00:12:56,800 --> 00:12:59,360
the screen crs thanks for the

326
00:12:59,360 --> 00:13:00,160
introduction

327
00:13:00,160 --> 00:13:02,240
so yeah this talks about multi-client

328
00:13:02,240 --> 00:13:04,079
function encryption for separable

329
00:13:04,079 --> 00:13:05,600
functions

330
00:13:05,600 --> 00:13:07,680
joined with michaela chumpy and lisa

331
00:13:07,680 --> 00:13:09,120
siniskalchi

332
00:13:09,120 --> 00:13:11,440
and in this work we consider the setting

333
00:13:11,440 --> 00:13:13,279
where we have different parties that

334
00:13:13,279 --> 00:13:15,680
provide encrypted documents so we have

335
00:13:15,680 --> 00:13:17,279
alice and bob and both of them provide

336
00:13:17,279 --> 00:13:19,120
some some encrypted documents

337
00:13:19,120 --> 00:13:20,720
and now we want to allow dave and aaron

338
00:13:20,720 --> 00:13:22,240
to do some analysis over these

339
00:13:22,240 --> 00:13:23,760
these documents so in this setting we

340
00:13:23,760 --> 00:13:25,839
want dave dave wants to learn how many

341
00:13:25,839 --> 00:13:27,839
times the word pkc occurs in both of

342
00:13:27,839 --> 00:13:29,360
these documents

343
00:13:29,360 --> 00:13:31,200
and aaron wants to learn how many times

344
00:13:31,200 --> 00:13:32,959
the word crypto appears

345
00:13:32,959 --> 00:13:35,120
in both of these documents and while

346
00:13:35,120 --> 00:13:36,639
allowing for their evaluation we still

347
00:13:36,639 --> 00:13:37,200
want to

348
00:13:37,200 --> 00:13:38,880
preserve the privacy of the encryption

349
00:13:38,880 --> 00:13:40,720
so they should really only learn

350
00:13:40,720 --> 00:13:42,880
their desired word count and nothing

351
00:13:42,880 --> 00:13:45,040
beyond that

352
00:13:45,040 --> 00:13:46,959
and the cryptographic primitives that we

353
00:13:46,959 --> 00:13:48,160
can use to achieve this

354
00:13:48,160 --> 00:13:50,480
is multi-client function encryption for

355
00:13:50,480 --> 00:13:52,160
separable functions

356
00:13:52,160 --> 00:13:54,480
so as a parable function is an n input

357
00:13:54,480 --> 00:13:55,440
function

358
00:13:55,440 --> 00:13:58,079
that can also be evaluated if you

359
00:13:58,079 --> 00:13:58,959
evaluate

360
00:13:58,959 --> 00:14:01,519
n single input functions and applied on

361
00:14:01,519 --> 00:14:03,440
the different inputs and sum up the the

362
00:14:03,440 --> 00:14:05,519
results

363
00:14:05,519 --> 00:14:07,920
and in a multi-client scheme we have a

364
00:14:07,920 --> 00:14:09,440
setup algorithm that outputs

365
00:14:09,440 --> 00:14:11,040
several encryption keys and the master

366
00:14:11,040 --> 00:14:13,440
secret key the encryption keys can then

367
00:14:13,440 --> 00:14:15,279
be used by the by the different clients

368
00:14:15,279 --> 00:14:16,079
to encrypt

369
00:14:16,079 --> 00:14:17,600
their messages together with an

370
00:14:17,600 --> 00:14:19,680
encryption label

371
00:14:19,680 --> 00:14:21,440
and the master secret key is used in a

372
00:14:21,440 --> 00:14:23,360
key generation procedure to generate a

373
00:14:23,360 --> 00:14:24,959
functional keys

374
00:14:24,959 --> 00:14:26,800
and if bob is in possession of such a

375
00:14:26,800 --> 00:14:28,399
functional key

376
00:14:28,399 --> 00:14:30,720
he can compute the function evaluation

377
00:14:30,720 --> 00:14:32,480
of his key applied on the

378
00:14:32,480 --> 00:14:34,720
the plain text encrypted by alice and

379
00:14:34,720 --> 00:14:35,680
carol

380
00:14:35,680 --> 00:14:38,639
and this de decryption only succeeds if

381
00:14:38,639 --> 00:14:39,040
the

382
00:14:39,040 --> 00:14:41,440
the cipher text he uses are generated

383
00:14:41,440 --> 00:14:42,800
with respect to the to the same

384
00:14:42,800 --> 00:14:45,040
encryption label

385
00:14:45,040 --> 00:14:47,120
here in this in this work we show how to

386
00:14:47,120 --> 00:14:48,800
realize multi-client function encryption

387
00:14:48,800 --> 00:14:50,880
for separable function from secret key

388
00:14:50,880 --> 00:14:52,240
single input schemes

389
00:14:52,240 --> 00:14:54,079
and this is basically a similar setting

390
00:14:54,079 --> 00:14:56,399
where the setup algorithm only outputs a

391
00:14:56,399 --> 00:14:58,000
single key that is then used for

392
00:14:58,000 --> 00:15:02,399
the key generation and the encryption

393
00:15:02,399 --> 00:15:04,560
yeah there also exists a decentralized

394
00:15:04,560 --> 00:15:06,399
version of this notion where the

395
00:15:06,399 --> 00:15:07,680
where there's basically no setup

396
00:15:07,680 --> 00:15:09,440
algorithm that is executed by a single

397
00:15:09,440 --> 00:15:10,240
party but

398
00:15:10,240 --> 00:15:11,760
alice and carol do this together

399
00:15:11,760 --> 00:15:13,279
interactively

400
00:15:13,279 --> 00:15:14,720
and then for the generation of

401
00:15:14,720 --> 00:15:16,959
functional keys they can both both

402
00:15:16,959 --> 00:15:18,800
generate different functional key shares

403
00:15:18,800 --> 00:15:20,480
which can then be combined to obtain the

404
00:15:20,480 --> 00:15:21,120
full

405
00:15:21,120 --> 00:15:24,320
functional key yeah in terms of

406
00:15:24,320 --> 00:15:25,440
transformation from

407
00:15:25,440 --> 00:15:27,040
single input function encryption to

408
00:15:27,040 --> 00:15:28,639
multi-client functional encryption there

409
00:15:28,639 --> 00:15:29,040
have

410
00:15:29,040 --> 00:15:31,519
already been some work the first work is

411
00:15:31,519 --> 00:15:33,680
by broadcast get all where they show how

412
00:15:33,680 --> 00:15:35,680
to turn a secret key single input scheme

413
00:15:35,680 --> 00:15:37,759
into a multi-input scheme

414
00:15:37,759 --> 00:15:39,759
the notion of a multi-input is very

415
00:15:39,759 --> 00:15:41,440
similar to the multi-client notion they

416
00:15:41,440 --> 00:15:43,680
have a different security definition

417
00:15:43,680 --> 00:15:45,440
and they don't incorporate encryption

418
00:15:45,440 --> 00:15:46,800
labels

419
00:15:46,800 --> 00:15:48,480
and they do this for a general class of

420
00:15:48,480 --> 00:15:49,839
functions

421
00:15:49,839 --> 00:15:51,680
then there's some some other works on a

422
00:15:51,680 --> 00:15:53,680
more specific function class the inner

423
00:15:53,680 --> 00:15:54,959
products

424
00:15:54,959 --> 00:15:57,040
and there's been a work by abdullah al

425
00:15:57,040 --> 00:15:58,800
where they show how to lift the secret

426
00:15:58,800 --> 00:16:00,240
key single input scheme into

427
00:16:00,240 --> 00:16:02,639
the multi-client setting without labels

428
00:16:02,639 --> 00:16:04,160
and in another follow-up work it has

429
00:16:04,160 --> 00:16:05,360
also been shown how this

430
00:16:05,360 --> 00:16:08,560
scheme can be decentralized

431
00:16:08,560 --> 00:16:10,320
then in another follow-up work the the

432
00:16:10,320 --> 00:16:12,079
previous construction has been extended

433
00:16:12,079 --> 00:16:12,399
to

434
00:16:12,399 --> 00:16:14,240
two labels so it also incorporates

435
00:16:14,240 --> 00:16:16,480
labels and they have to switch from a

436
00:16:16,480 --> 00:16:18,399
secret key single input scheme to a

437
00:16:18,399 --> 00:16:20,639
public key scheme

438
00:16:20,639 --> 00:16:22,399
and yes already mentioned we focus on

439
00:16:22,399 --> 00:16:24,079
the transformation from secret key

440
00:16:24,079 --> 00:16:25,519
single input to

441
00:16:25,519 --> 00:16:28,399
multi-client for separable functions and

442
00:16:28,399 --> 00:16:30,160
we additionally also introduce a new

443
00:16:30,160 --> 00:16:32,000
notion that allows for distributed

444
00:16:32,000 --> 00:16:34,560
execution of the decryption procedure

445
00:16:34,560 --> 00:16:35,360
which we will

446
00:16:35,360 --> 00:16:37,920
see later so yeah how does our

447
00:16:37,920 --> 00:16:39,120
construction

448
00:16:39,120 --> 00:16:42,399
work our construction basically runs in

449
00:16:42,399 --> 00:16:43,839
different instances of a single input

450
00:16:43,839 --> 00:16:45,839
function encryption scheme and when a

451
00:16:45,839 --> 00:16:47,759
functional key for a separable function

452
00:16:47,759 --> 00:16:48,880
is requested

453
00:16:48,880 --> 00:16:50,560
functional keys for all the individual

454
00:16:50,560 --> 00:16:52,639
functions are generated

455
00:16:52,639 --> 00:16:54,320
and these functions then output the

456
00:16:54,320 --> 00:16:55,680
evaluation

457
00:16:55,680 --> 00:16:57,680
together with them with a secret share

458
00:16:57,680 --> 00:16:59,920
of zero so this secret share is used to

459
00:16:59,920 --> 00:17:01,279
to hide the individual function

460
00:17:01,279 --> 00:17:02,480
evaluation

461
00:17:02,480 --> 00:17:04,400
and to prevent the combination from

462
00:17:04,400 --> 00:17:06,480
individual keys with other individual

463
00:17:06,480 --> 00:17:07,520
keys from a different

464
00:17:07,520 --> 00:17:11,359
separable function and we need a similar

465
00:17:11,359 --> 00:17:12,079
property

466
00:17:12,079 --> 00:17:13,599
for incorporating labels in the

467
00:17:13,599 --> 00:17:15,679
ciphertext such that we cannot combine

468
00:17:15,679 --> 00:17:16,640
ciphertext

469
00:17:16,640 --> 00:17:19,520
encrypted under different labels and

470
00:17:19,520 --> 00:17:20,720
here the issue is that this

471
00:17:20,720 --> 00:17:22,799
secret shares cannot be generated by a

472
00:17:22,799 --> 00:17:24,720
single party but the clients have to do

473
00:17:24,720 --> 00:17:26,720
this non-interactively on the fly

474
00:17:26,720 --> 00:17:28,720
and we can accomplish this using a

475
00:17:28,720 --> 00:17:31,440
specific prf technique

476
00:17:31,440 --> 00:17:33,200
so then in the end the individual

477
00:17:33,200 --> 00:17:34,640
functional keys will output the

478
00:17:34,640 --> 00:17:36,559
individual function evaluation

479
00:17:36,559 --> 00:17:38,799
plus the encoded share inside the key

480
00:17:38,799 --> 00:17:39,600
plus the

481
00:17:39,600 --> 00:17:42,240
the share incorporated in the ciphertext

482
00:17:42,240 --> 00:17:43,760
and if all these values are summed up

483
00:17:43,760 --> 00:17:45,840
together the final output can can be

484
00:17:45,840 --> 00:17:48,320
obtained

485
00:17:48,320 --> 00:17:49,760
yeah this this scheme is not yet

486
00:17:49,760 --> 00:17:51,520
decentralized since we we say we

487
00:17:51,520 --> 00:17:53,520
generate these r values

488
00:17:53,520 --> 00:17:55,360
by a single party a single party does

489
00:17:55,360 --> 00:17:57,679
this but we can simply use again this

490
00:17:57,679 --> 00:17:59,039
prf technique to

491
00:17:59,039 --> 00:18:03,360
to also do this in a distributed way

492
00:18:04,000 --> 00:18:06,559
so yeah let me say something about the

493
00:18:06,559 --> 00:18:08,240
notion of outsource ability

494
00:18:08,240 --> 00:18:10,000
so an outsourceable multi-client

495
00:18:10,000 --> 00:18:11,679
function encryption scheme is similar to

496
00:18:11,679 --> 00:18:13,200
a multi-client scheme

497
00:18:13,200 --> 00:18:14,559
with the difference that the key

498
00:18:14,559 --> 00:18:16,480
generation procedure outputs different

499
00:18:16,480 --> 00:18:18,000
functional key shares

500
00:18:18,000 --> 00:18:19,760
which can then be used in a partial

501
00:18:19,760 --> 00:18:21,360
decryption procedure

502
00:18:21,360 --> 00:18:23,760
to generate decryption shares which can

503
00:18:23,760 --> 00:18:25,520
then be combined to obtain

504
00:18:25,520 --> 00:18:28,320
the final output and security here

505
00:18:28,320 --> 00:18:29,520
ensures that these

506
00:18:29,520 --> 00:18:31,440
seek these shares these decryption

507
00:18:31,440 --> 00:18:33,919
shares do not leak anything about

508
00:18:33,919 --> 00:18:36,720
the final function output and this

509
00:18:36,720 --> 00:18:38,559
notion is particularly useful if this

510
00:18:38,559 --> 00:18:40,400
partial decryption procedure is quite

511
00:18:40,400 --> 00:18:41,760
quite heavy such that it can be

512
00:18:41,760 --> 00:18:42,960
outsourced to

513
00:18:42,960 --> 00:18:45,760
someone with more computational power

514
00:18:45,760 --> 00:18:46,720
and our scheme

515
00:18:46,720 --> 00:18:48,400
directly realizes this notion by

516
00:18:48,400 --> 00:18:50,000
justifying the partial decryption

517
00:18:50,000 --> 00:18:50,799
procedure as

518
00:18:50,799 --> 00:18:52,559
the decryption procedure of all the

519
00:18:52,559 --> 00:18:54,559
single input schemes

520
00:18:54,559 --> 00:18:56,160
and then the combination is simply the

521
00:18:56,160 --> 00:18:59,280
sum of all these values

522
00:18:59,280 --> 00:19:02,160
thank you for listening

523
00:19:04,720 --> 00:19:07,600
okay so thank you andrey so um i had a

524
00:19:07,600 --> 00:19:11,440
question for the speaker

525
00:19:11,440 --> 00:19:12,880
um maybe a quick question can you go

526
00:19:12,880 --> 00:19:14,960
back one slide for the where you do the

527
00:19:14,960 --> 00:19:18,720
with the partial decryption so

528
00:19:18,720 --> 00:19:20,960
so i think there's a there's a separate

529
00:19:20,960 --> 00:19:22,840
partial encryption for every

530
00:19:22,840 --> 00:19:26,320
encrypter um i'm curious

531
00:19:26,320 --> 00:19:29,440
what happens if you kind of apply the

532
00:19:29,440 --> 00:19:30,880
decryption immediately

533
00:19:30,880 --> 00:19:32,880
after the encryption but this gives

534
00:19:32,880 --> 00:19:34,320
rises to some

535
00:19:34,320 --> 00:19:36,720
some encryption scheme that that already

536
00:19:36,720 --> 00:19:38,400
exists like that that allows you to

537
00:19:38,400 --> 00:19:40,880
instance to aggregate the results but um

538
00:19:40,880 --> 00:19:42,080
so i wonder whether there's some

539
00:19:42,080 --> 00:19:44,559
relation to existing schemes when you

540
00:19:44,559 --> 00:19:46,799
just combine your encryption decryption

541
00:19:46,799 --> 00:19:48,400
for these individual parties

542
00:19:48,400 --> 00:19:50,240
have you thought about that does it not

543
00:19:50,240 --> 00:19:52,400
makes any sense at all well the the

544
00:19:52,400 --> 00:19:53,919
thing is that then you're already like

545
00:19:53,919 --> 00:19:54,480
kind of

546
00:19:54,480 --> 00:19:56,160
committed to the function right i mean

547
00:19:56,160 --> 00:19:57,760
the advantage here is that you can

548
00:19:57,760 --> 00:20:00,559
uh yes i see that but i suspect that

549
00:20:00,559 --> 00:20:02,080
there are some constructions in the

550
00:20:02,080 --> 00:20:03,039
literature that

551
00:20:03,039 --> 00:20:04,240
that kind of commit to the assumption

552
00:20:04,240 --> 00:20:05,840
for instance are computing just the sum

553
00:20:05,840 --> 00:20:06,960
of the inputs

554
00:20:06,960 --> 00:20:08,799
and that that so that you are a special

555
00:20:08,799 --> 00:20:11,440
case of those constructions

556
00:20:11,440 --> 00:20:13,600
um and i was wondering whether for

557
00:20:13,600 --> 00:20:15,120
instance there are some kind of

558
00:20:15,120 --> 00:20:17,280
aggregation scheme private aggregation

559
00:20:17,280 --> 00:20:18,320
schemes where

560
00:20:18,320 --> 00:20:20,080
which which you would now be a special

561
00:20:20,080 --> 00:20:21,520
case of

562
00:20:21,520 --> 00:20:23,200
yeah probably i mean if you know the the

563
00:20:23,200 --> 00:20:25,200
function previously i don't think why

564
00:20:25,200 --> 00:20:26,320
this should not

565
00:20:26,320 --> 00:20:28,960
should not work

566
00:20:32,000 --> 00:20:35,840
okay any more questions

567
00:20:37,039 --> 00:20:41,520
oh okay so thank you enrique

568
00:20:41,520 --> 00:20:44,000
so let's move to the to the last talk of

569
00:20:44,000 --> 00:20:46,400
this session already

570
00:20:46,400 --> 00:20:49,120
um so the title of the paper is still

571
00:20:49,120 --> 00:20:49,840
composing

572
00:20:49,840 --> 00:20:51,679
computable story hardware based state

573
00:20:51,679 --> 00:20:54,240
full and randomized function encryption

574
00:20:54,240 --> 00:20:57,039
um there are four others so promote

575
00:20:57,039 --> 00:20:58,159
pathothea

576
00:20:58,159 --> 00:21:00,720
archival ways lorenzo martinico and

577
00:21:00,720 --> 00:21:02,080
janice siliconis

578
00:21:02,080 --> 00:21:03,919
so i'm sorry if i did not pronounce your

579
00:21:03,919 --> 00:21:05,200
names correctly

580
00:21:05,200 --> 00:21:07,919
and the tool could be given by lorenzo

581
00:21:07,919 --> 00:21:08,400
all right

582
00:21:08,400 --> 00:21:10,880
thanks mark so let me start with a

583
00:21:10,880 --> 00:21:12,080
motivating example

584
00:21:12,080 --> 00:21:14,320
let's take the problem of classifying

585
00:21:14,320 --> 00:21:16,960
encrypted messages as fake news

586
00:21:16,960 --> 00:21:18,880
of course we could try to download a

587
00:21:18,880 --> 00:21:21,440
heavy data set of fitness articles to

588
00:21:21,440 --> 00:21:23,919
mobile client but that's untenable so

589
00:21:23,919 --> 00:21:25,679
the best approach seems to

590
00:21:25,679 --> 00:21:27,919
send the message unencrypted to the

591
00:21:27,919 --> 00:21:29,520
cloud let the cloud run its

592
00:21:29,520 --> 00:21:30,880
classification algorithm

593
00:21:30,880 --> 00:21:33,600
update the data set with the new message

594
00:21:33,600 --> 00:21:34,640
and then return

595
00:21:34,640 --> 00:21:36,799
the classification to the client of

596
00:21:36,799 --> 00:21:38,559
course the disadvantage of this is that

597
00:21:38,559 --> 00:21:41,120
we reveal the client's correspondence

598
00:21:41,120 --> 00:21:43,360
so what we can do is run a function

599
00:21:43,360 --> 00:21:44,320
encryption scheme

600
00:21:44,320 --> 00:21:46,000
such that we can run this analysis

601
00:21:46,000 --> 00:21:48,000
function on the encrypted ciphertext and

602
00:21:48,000 --> 00:21:49,039
still return

603
00:21:49,039 --> 00:21:52,559
a classification our work expands the

604
00:21:52,559 --> 00:21:53,360
class of

605
00:21:53,360 --> 00:21:54,960
functional encryption functions that we

606
00:21:54,960 --> 00:21:56,559
can compute to include

607
00:21:56,559 --> 00:21:59,039
stateful and randomized functionalities

608
00:21:59,039 --> 00:22:01,440
and we instantiate a protocol

609
00:22:01,440 --> 00:22:03,760
that can implement them securely proven

610
00:22:03,760 --> 00:22:05,440
under the uc model using

611
00:22:05,440 --> 00:22:08,320
a trusted execution environment in

612
00:22:08,320 --> 00:22:10,840
pasadena's

613
00:22:10,840 --> 00:22:13,280
formalization and then finally we relax

614
00:22:13,280 --> 00:22:16,000
the model from basterdal pst to capture

615
00:22:16,000 --> 00:22:17,440
additional adversaries

616
00:22:17,440 --> 00:22:19,840
so our protocol is called steel and like

617
00:22:19,840 --> 00:22:20,720
the title says

618
00:22:20,720 --> 00:22:23,600
is composable hardware based and

619
00:22:23,600 --> 00:22:25,120
implements stateful and randomized

620
00:22:25,120 --> 00:22:27,200
function encryption

621
00:22:27,200 --> 00:22:29,440
so when we talk about randomized

622
00:22:29,440 --> 00:22:30,320
functionalities

623
00:22:30,320 --> 00:22:33,360
we mean that any attempts at decrypting

624
00:22:33,360 --> 00:22:36,000
can use a fresh random string this is

625
00:22:36,000 --> 00:22:37,280
different from previous notions of

626
00:22:37,280 --> 00:22:39,039
randomness in functional encryption

627
00:22:39,039 --> 00:22:41,280
where we'd have randomness come from a

628
00:22:41,280 --> 00:22:43,600
new functional key

629
00:22:43,600 --> 00:22:45,360
and then when we say stateful we mean

630
00:22:45,360 --> 00:22:47,360
that each of our decryptors

631
00:22:47,360 --> 00:22:49,520
can hold some kind of state for each of

632
00:22:49,520 --> 00:22:51,039
the functions they want to compute

633
00:22:51,039 --> 00:22:53,679
such that any decryption can update this

634
00:22:53,679 --> 00:22:55,200
private state

635
00:22:55,200 --> 00:22:58,400
in practice the f the class of functions

636
00:22:58,400 --> 00:22:59,360
that we can

637
00:22:59,360 --> 00:23:00,799
implement that we can compute in a

638
00:23:00,799 --> 00:23:02,480
function encryption scheme

639
00:23:02,480 --> 00:23:04,080
takes in as additional input a state

640
00:23:04,080 --> 00:23:05,760
string and a random string

641
00:23:05,760 --> 00:23:09,840
and return an additional state string

642
00:23:09,919 --> 00:23:11,840
our steel protocol as i mentioned is

643
00:23:11,840 --> 00:23:14,480
based on trusted execution environments

644
00:23:14,480 --> 00:23:17,200
which are extensions on cpu

645
00:23:17,200 --> 00:23:19,120
architectures to guarantee

646
00:23:19,120 --> 00:23:20,559
additional properties like

647
00:23:20,559 --> 00:23:23,600
confidentiality and integrity

648
00:23:23,600 --> 00:23:26,720
in particular our work is based off iron

649
00:23:26,720 --> 00:23:27,760
by faciadal

650
00:23:27,760 --> 00:23:30,000
which already implements public key

651
00:23:30,000 --> 00:23:31,039
functional encryption

652
00:23:31,039 --> 00:23:34,559
using intel sgx within our protocol

653
00:23:34,559 --> 00:23:36,480
we have the detractor and the key

654
00:23:36,480 --> 00:23:37,840
management authority

655
00:23:37,840 --> 00:23:41,279
as sgx secret machines the encryption

656
00:23:41,279 --> 00:23:41,760
phase

657
00:23:41,760 --> 00:23:44,960
is simply a plain public key encryption

658
00:23:44,960 --> 00:23:46,320
you can join with a plain text proof of

659
00:23:46,320 --> 00:23:48,559
knowledge and the key material for

660
00:23:48,559 --> 00:23:51,760
public key encryption is kept within

661
00:23:51,760 --> 00:23:53,840
the two enclaves confidentially and it's

662
00:23:53,840 --> 00:23:55,760
only a change if the two enclaves can

663
00:23:55,760 --> 00:23:56,799
convince each other

664
00:23:56,799 --> 00:23:58,240
that you're running the genuine steel

665
00:23:58,240 --> 00:24:00,880
code the functional keys

666
00:24:00,880 --> 00:24:02,799
are simply signatures over our

667
00:24:02,799 --> 00:24:04,480
presentation of the function

668
00:24:04,480 --> 00:24:06,640
which the decryption enclave will verify

669
00:24:06,640 --> 00:24:08,320
to be authentic before

670
00:24:08,320 --> 00:24:11,440
authorizing decryption

671
00:24:11,440 --> 00:24:13,760
our proof is in the uc with global

672
00:24:13,760 --> 00:24:15,279
subroutine setting

673
00:24:15,279 --> 00:24:18,000
where we are where we can add a global

674
00:24:18,000 --> 00:24:18,960
functionality to

675
00:24:18,960 --> 00:24:23,840
any uc protocol oops sorry

676
00:24:23,840 --> 00:24:27,039
and in particular we formalize

677
00:24:27,039 --> 00:24:28,640
in particular we use the global

678
00:24:28,640 --> 00:24:31,760
attestation functionality from passethel

679
00:24:31,760 --> 00:24:35,039
to uh to other um

680
00:24:35,039 --> 00:24:38,240
hardware based functionality um some

681
00:24:38,240 --> 00:24:39,679
data from the proof one particular

682
00:24:39,679 --> 00:24:41,440
challenge that we have is that we need

683
00:24:41,440 --> 00:24:42,640
to synchronize

684
00:24:42,640 --> 00:24:45,919
the state of the a real functionality

685
00:24:45,919 --> 00:24:47,679
without a simulator

686
00:24:47,679 --> 00:24:50,960
uh so as we mentioned whenever we run a

687
00:24:50,960 --> 00:24:51,919
decryption

688
00:24:51,919 --> 00:24:53,679
the state the inner state to the

689
00:24:53,679 --> 00:24:56,240
decryptor gets updated

690
00:24:56,240 --> 00:24:59,840
uh so so whenever the environment picks

691
00:24:59,840 --> 00:25:02,240
a challenge ciphertext

692
00:25:02,240 --> 00:25:03,919
because it encrypts it using the public

693
00:25:03,919 --> 00:25:06,240
key encryption the dr functionality has

694
00:25:06,240 --> 00:25:06,960
no notion

695
00:25:06,960 --> 00:25:09,440
of this encryption phase so we need to

696
00:25:09,440 --> 00:25:10,720
extract somehow

697
00:25:10,720 --> 00:25:12,640
the message and this is why we add a

698
00:25:12,640 --> 00:25:14,240
plaintext proof of knowledge which the

699
00:25:14,240 --> 00:25:16,480
simulator can use instructor to

700
00:25:16,480 --> 00:25:18,720
obtain back the original message x and

701
00:25:18,720 --> 00:25:20,559
pass it on to the deal functionality

702
00:25:20,559 --> 00:25:22,320
just like it would have happened in the

703
00:25:22,320 --> 00:25:24,559
real world where the enclave

704
00:25:24,559 --> 00:25:27,440
would decrypt the ciphertext using its

705
00:25:27,440 --> 00:25:29,039
key

706
00:25:29,039 --> 00:25:30,720
finally we model an additional

707
00:25:30,720 --> 00:25:33,279
relaxation over the psd functionality

708
00:25:33,279 --> 00:25:35,679
to allow two different kinds of attacks

709
00:25:35,679 --> 00:25:36,799
so in the normal

710
00:25:36,799 --> 00:25:39,919
in the honest setting uh any update to

711
00:25:39,919 --> 00:25:41,279
the state would proceed

712
00:25:41,279 --> 00:25:42,720
in such a linear fashion like in the

713
00:25:42,720 --> 00:25:45,440
figure however we model an additional

714
00:25:45,440 --> 00:25:47,120
battery that can conduct a rollback

715
00:25:47,120 --> 00:25:48,640
attack where after some

716
00:25:48,640 --> 00:25:50,640
states it can rewind it to a previous

717
00:25:50,640 --> 00:25:51,760
state

718
00:25:51,760 --> 00:25:53,679
as well as an adversary we can conduct a

719
00:25:53,679 --> 00:25:54,799
forking attack

720
00:25:54,799 --> 00:25:56,799
where you can hold different branches of

721
00:25:56,799 --> 00:25:59,440
the enclave at the same time

722
00:25:59,440 --> 00:26:01,600
we show that steel is vulnerable to both

723
00:26:01,600 --> 00:26:03,039
this kind of attacks

724
00:26:03,039 --> 00:26:04,880
and discuss some potential mitigations

725
00:26:04,880 --> 00:26:07,360
from the literature

726
00:26:07,360 --> 00:26:10,320
thank you these are the main takeaways

727
00:26:10,320 --> 00:26:11,279
over picker

728
00:26:11,279 --> 00:26:14,320
and i'll take questions then

729
00:26:14,480 --> 00:26:19,520
thank you lorenzo so i had a question or

730
00:26:22,840 --> 00:26:24,400
comments

731
00:26:24,400 --> 00:26:26,720
maybe a quick one then on my side so uh

732
00:26:26,720 --> 00:26:28,559
if you find a new extension so you may

733
00:26:28,559 --> 00:26:29,039
call it

734
00:26:29,039 --> 00:26:30,880
silver or gold so depending on the

735
00:26:30,880 --> 00:26:32,159
result

736
00:26:32,159 --> 00:26:35,440
yes that's the next paper

737
00:26:37,120 --> 00:26:40,159
no no questions

738
00:26:40,159 --> 00:26:42,240
um so maybe then we can recap for all

739
00:26:42,240 --> 00:26:44,080
the the talks and so if you have any

740
00:26:44,080 --> 00:26:45,679
questions for any of the the previous

741
00:26:45,679 --> 00:26:46,080
tools

742
00:26:46,080 --> 00:26:49,279
feel free to to ask

743
00:26:49,600 --> 00:26:51,520
you can also check on zoodeep so i don't

744
00:26:51,520 --> 00:26:54,639
read our question there

745
00:26:57,520 --> 00:26:59,679
yeah miguel maybe a question for you

746
00:26:59,679 --> 00:27:00,880
regarding the

747
00:27:00,880 --> 00:27:02,880
generic negation sort of follow up to

748
00:27:02,880 --> 00:27:05,200
the previous questions

749
00:27:05,200 --> 00:27:08,320
for most of the predicates the uh

750
00:27:08,320 --> 00:27:10,080
the uh encoding that you get from

751
00:27:10,080 --> 00:27:13,520
generic negation do they match the uh

752
00:27:13,520 --> 00:27:16,030
previous encoding for the negated uh

753
00:27:16,030 --> 00:27:18,840
[Music]

754
00:27:18,840 --> 00:27:21,440
predicate

755
00:27:21,440 --> 00:27:23,360
all right sorry i missed the first half

756
00:27:23,360 --> 00:27:25,120
of the question because i was

757
00:27:25,120 --> 00:27:27,440
refreshing my browser oh actually no

758
00:27:27,440 --> 00:27:28,480
that's fine um

759
00:27:28,480 --> 00:27:31,200
sort of like uh you know is it the case

760
00:27:31,200 --> 00:27:32,720
that for most predicates

761
00:27:32,720 --> 00:27:35,919
if i take the uh if i take the

762
00:27:35,919 --> 00:27:39,679
uh if i apply a generic negation um

763
00:27:39,679 --> 00:27:42,320
the encoding i get is the same as the

764
00:27:42,320 --> 00:27:44,480
existing encoding for the negation of

765
00:27:44,480 --> 00:27:45,760
the predicate

766
00:27:45,760 --> 00:27:49,360
ah okay so um i don't think so

767
00:27:49,360 --> 00:27:51,520
but maybe after simplification it is the

768
00:27:51,520 --> 00:27:54,080
same so i remember that

769
00:27:54,080 --> 00:27:56,880
for the the predicate encoding negation

770
00:27:56,880 --> 00:27:58,240
that i also developed

771
00:27:58,240 --> 00:28:00,320
four years ago that was actually the

772
00:28:00,320 --> 00:28:02,640
case for many encodings so if you first

773
00:28:02,640 --> 00:28:03,760
negate

774
00:28:03,760 --> 00:28:07,360
and then simplify you were getting the

775
00:28:07,360 --> 00:28:10,080
the actually negated encoding that some

776
00:28:10,080 --> 00:28:12,720
human had developed independently

777
00:28:12,720 --> 00:28:16,559
i see and it was by human some human i

778
00:28:16,559 --> 00:28:17,120
mean you

779
00:28:17,120 --> 00:28:18,799
basically because you you develop most

780
00:28:18,799 --> 00:28:20,720
of uh pretty the predicate and

781
00:28:20,720 --> 00:28:21,919
colleagues

782
00:28:21,919 --> 00:28:26,480
um but uh

783
00:28:26,480 --> 00:28:28,080
yeah so something interesting that i

784
00:28:28,080 --> 00:28:30,320
want to point out is that sometimes this

785
00:28:30,320 --> 00:28:32,320
after negating you are getting something

786
00:28:32,320 --> 00:28:34,320
even simpler

787
00:28:34,320 --> 00:28:35,840
so for example that was the case of

788
00:28:35,840 --> 00:28:37,679
monotone spam programs

789
00:28:37,679 --> 00:28:40,080
so you were getting something that was

790
00:28:40,080 --> 00:28:42,640
even smaller than the original encoding

791
00:28:42,640 --> 00:28:45,039
but you have to simplify negation is

792
00:28:45,039 --> 00:28:45,760
generically

793
00:28:45,760 --> 00:28:48,000
bigger it will be it'll be it'll grow

794
00:28:48,000 --> 00:28:50,159
but maybe you can simplify you can

795
00:28:50,159 --> 00:28:51,760
you know find some linear combinations

796
00:28:51,760 --> 00:28:53,840
that simplify and you get something

797
00:28:53,840 --> 00:28:56,399
smaller than the original and i have not

798
00:28:56,399 --> 00:28:57,360
observed this

799
00:28:57,360 --> 00:29:00,480
phenomenon in the new one but in

800
00:29:00,480 --> 00:29:01,840
parenthesis but maybe

801
00:29:01,840 --> 00:29:03,919
it happens that's an interesting

802
00:29:03,919 --> 00:29:05,919
question whether it will happen or not

803
00:29:05,919 --> 00:29:07,320
i see but can you apply the

804
00:29:07,320 --> 00:29:09,760
simplifications even before

805
00:29:09,760 --> 00:29:11,840
applying the negation or the

806
00:29:11,840 --> 00:29:13,360
simplifications uh

807
00:29:13,360 --> 00:29:15,120
the simplification technology is

808
00:29:15,120 --> 00:29:16,720
inherent to

809
00:29:16,720 --> 00:29:18,640
having applied the negation

810
00:29:18,640 --> 00:29:19,919
transformation

811
00:29:19,919 --> 00:29:23,039
right so um so first of all

812
00:29:23,039 --> 00:29:24,080
i don't really know how to

813
00:29:24,080 --> 00:29:26,399
systematically simplify brain coding

814
00:29:26,399 --> 00:29:27,919
so there was there were some ideas in

815
00:29:27,919 --> 00:29:29,840
the in the predicate encoding framework

816
00:29:29,840 --> 00:29:30,880
in brain coding i have

817
00:29:30,880 --> 00:29:34,159
no not really a good idea how to do it

818
00:29:34,159 --> 00:29:38,240
but um i don't think

819
00:29:38,240 --> 00:29:39,679
those simplifications were not working

820
00:29:39,679 --> 00:29:41,679
on the on the original encoding

821
00:29:41,679 --> 00:29:45,200
i see so it's when you introduce the

822
00:29:45,200 --> 00:29:47,919
redundancy after negating it turns out

823
00:29:47,919 --> 00:29:49,600
that

824
00:29:49,600 --> 00:29:52,799
you can simplify even farther but

825
00:29:52,799 --> 00:29:54,399
those simplifications were not giving

826
00:29:54,399 --> 00:29:56,320
you anything on the original

827
00:29:56,320 --> 00:29:58,159
and this is some weird phenomenon that i

828
00:29:58,159 --> 00:30:00,320
couldn't find explanation for even

829
00:30:00,320 --> 00:30:03,360
even after a few years maybe someone can

830
00:30:03,360 --> 00:30:04,159
can

831
00:30:04,159 --> 00:30:06,880
give a new

832
00:30:07,679 --> 00:30:09,200
so size sounds like a great open

833
00:30:09,200 --> 00:30:11,200
question um yeah

834
00:30:11,200 --> 00:30:13,200
yeah do you have any questions for maybe

835
00:30:13,200 --> 00:30:15,919
for either mcgill or the other speakers

836
00:30:15,919 --> 00:30:19,360
um maybe one of the shouldn't you any of

837
00:30:19,360 --> 00:30:21,120
your co-authors can try to answer my

838
00:30:21,120 --> 00:30:22,559
course question from earlier

839
00:30:22,559 --> 00:30:26,399
about motivations for kdm

840
00:30:29,919 --> 00:30:32,720
uh you're calling me uh yeah maybe can

841
00:30:32,720 --> 00:30:34,000
you answer

842
00:30:34,000 --> 00:30:36,559
my course question earlier about uh

843
00:30:36,559 --> 00:30:38,480
multiplication

844
00:30:38,480 --> 00:30:41,520
yeah yeah so so so for the for the ktm

845
00:30:41,520 --> 00:30:42,000
so

846
00:30:42,000 --> 00:30:45,360
uh the the main difference or what they

847
00:30:45,360 --> 00:30:47,360
enhance the security is that you can

848
00:30:47,360 --> 00:30:49,679
encrypt something related to key

849
00:30:49,679 --> 00:30:52,320
so so the triple k said that uh you can

850
00:30:52,320 --> 00:30:52,960
encrypt

851
00:30:52,960 --> 00:30:55,600
a key so for the for the standard cpa or

852
00:30:55,600 --> 00:30:58,000
cca you cannot do this

853
00:30:58,000 --> 00:31:00,640
so so so for this point uh we we can

854
00:31:00,640 --> 00:31:01,120
have

855
00:31:01,120 --> 00:31:03,679
several applications or some scenarios

856
00:31:03,679 --> 00:31:04,480
we need it

857
00:31:04,480 --> 00:31:07,840
from a theoretic part or maybe real

858
00:31:07,840 --> 00:31:09,440
world application

859
00:31:09,440 --> 00:31:12,399
so for the for the theoretical part so

860
00:31:12,399 --> 00:31:14,320
so maybe you all know that for the

861
00:31:14,320 --> 00:31:16,559
for the uh for the homomorphic

862
00:31:16,559 --> 00:31:18,000
encryption we need for striping

863
00:31:18,000 --> 00:31:21,120
you need to encrypt some key

864
00:31:21,120 --> 00:31:24,240
uh for the for the next round

865
00:31:24,240 --> 00:31:27,440
uh for the application when we saw uh we

866
00:31:27,440 --> 00:31:29,519
saw a scenario that described in

867
00:31:29,519 --> 00:31:32,320
uh previous papers that's you know if

868
00:31:32,320 --> 00:31:33,840
you have an ib system

869
00:31:33,840 --> 00:31:35,840
some something like this so you want to

870
00:31:35,840 --> 00:31:37,760
uh do some revocation

871
00:31:37,760 --> 00:31:40,960
you have some time period then you can

872
00:31:40,960 --> 00:31:41,679
encrypt

873
00:31:41,679 --> 00:31:44,720
the secret key for the next round

874
00:31:44,720 --> 00:31:47,840
for the next time slot using the

875
00:31:47,840 --> 00:31:49,760
the encryption system for the current

876
00:31:49,760 --> 00:31:52,240
time slot so so in this case you need to

877
00:31:52,240 --> 00:31:52,720
encrypt

878
00:31:52,720 --> 00:31:56,960
key using the same encryption system so

879
00:31:56,960 --> 00:32:00,000
uh this is what we know for this uh for

880
00:32:00,000 --> 00:32:01,600
the applications

881
00:32:01,600 --> 00:32:03,919
uh for our work actually we follow the

882
00:32:03,919 --> 00:32:04,640
line that

883
00:32:04,640 --> 00:32:07,440
extend the expressiveness from pke to

884
00:32:07,440 --> 00:32:10,240
ibe to av that is somewhat uh

885
00:32:10,240 --> 00:32:13,600
somewhat unnatural uh a natural

886
00:32:13,600 --> 00:32:16,720
desirable things we want to have

887
00:32:16,720 --> 00:32:19,039
uh but for this we also give an

888
00:32:19,039 --> 00:32:20,000
application so

889
00:32:20,000 --> 00:32:22,559
for the for the extension from pke to

890
00:32:22,559 --> 00:32:25,519
ibe we can do something like uh

891
00:32:25,519 --> 00:32:28,080
pke with cca security and also kdm

892
00:32:28,080 --> 00:32:30,799
security because we need ibu to do this

893
00:32:30,799 --> 00:32:34,399
i mean we need a kdm secure ibe

894
00:32:34,399 --> 00:32:37,440
to to work with the transformation so

895
00:32:37,440 --> 00:32:38,880
the classical one

896
00:32:38,880 --> 00:32:42,080
so for our work we uh we use the

897
00:32:42,080 --> 00:32:46,240
same paradigm to to show that

898
00:32:46,240 --> 00:32:49,679
an ab scheme with kdm is also useful

899
00:32:49,679 --> 00:32:52,320
because we can get

900
00:32:52,320 --> 00:32:56,640
cc secure and kdm for ib scheme

901
00:32:56,640 --> 00:32:58,240
so that's what we all know for the for

902
00:32:58,240 --> 00:33:00,000
the application and also it's it's

903
00:33:00,000 --> 00:33:00,799
really a

904
00:33:00,799 --> 00:33:04,080
interesting uh question to find more

905
00:33:04,080 --> 00:33:07,600
application i mean uh in the theory

906
00:33:07,600 --> 00:33:10,720
part i mean how to use uh a b with

907
00:33:10,720 --> 00:33:12,960
such kind of expressiveness because we

908
00:33:12,960 --> 00:33:14,159
can do uh

909
00:33:14,159 --> 00:33:17,760
uh kdmav for uh from the pretty encoding

910
00:33:17,760 --> 00:33:19,760
that means we can do uh

911
00:33:19,760 --> 00:33:23,440
um very expressive abe so

912
00:33:23,440 --> 00:33:26,480
yeah it i think it's an interesting uh

913
00:33:26,480 --> 00:33:29,519
direction to find more application

914
00:33:29,519 --> 00:33:32,240
yeah i i hope this answer the questions

915
00:33:32,240 --> 00:33:34,240
yeah no very very detailed answer thanks

916
00:33:34,240 --> 00:33:35,120
a lot

917
00:33:35,120 --> 00:33:36,320
i have another question maybe an

918
00:33:36,320 --> 00:33:38,080
application so i was wondering whether

919
00:33:38,080 --> 00:33:38,480
the

920
00:33:38,480 --> 00:33:40,559
functional encryption community sees

921
00:33:40,559 --> 00:33:41,600
value in

922
00:33:41,600 --> 00:33:43,519
and for instance using hardware to

923
00:33:43,519 --> 00:33:45,600
implement things that at the moment are

924
00:33:45,600 --> 00:33:47,919
too too inefficient but that can later

925
00:33:47,919 --> 00:33:50,000
on could be used with

926
00:33:50,000 --> 00:33:51,679
cryptographic solutions for general

927
00:33:51,679 --> 00:33:53,760
functions so kind of better this is a

928
00:33:53,760 --> 00:33:55,600
way of exploring kind of the

929
00:33:55,600 --> 00:33:57,440
potential of using functional encryption

930
00:33:57,440 --> 00:33:59,279
in applications

931
00:33:59,279 --> 00:34:01,039
you know but maybe maybe henrik wants to

932
00:34:01,039 --> 00:34:02,960
say something on that i don't know

933
00:34:02,960 --> 00:34:05,039
but i don't want to pick anyone now but

934
00:34:05,039 --> 00:34:07,440
just curious but for the other speakers

935
00:34:07,440 --> 00:34:10,480
of the talk so about that

936
00:34:16,560 --> 00:34:18,960
for me i don't know so so much about the

937
00:34:18,960 --> 00:34:21,199
the hot heart way of implementation but

938
00:34:21,199 --> 00:34:21,520
i

939
00:34:21,520 --> 00:34:24,639
i think some wonderful sgx

940
00:34:24,639 --> 00:34:26,159
or something like this but i didn't

941
00:34:26,159 --> 00:34:28,480
check the paper i guess

942
00:34:28,480 --> 00:34:31,440
so so if anybody know the no more i

943
00:34:31,440 --> 00:34:32,800
would like to hear about it

944
00:34:32,800 --> 00:34:35,599
yes it's uh it is true that for this

945
00:34:35,599 --> 00:34:38,240
it's a good point

946
00:34:39,599 --> 00:34:41,918
yeah so so so yeah the the same for ib

947
00:34:41,918 --> 00:34:44,000
so the very first implementation of ib

948
00:34:44,000 --> 00:34:46,800
basically was using a smart so that was

949
00:34:46,800 --> 00:34:48,719
a long time ago by the smeting kiscarter

950
00:34:48,719 --> 00:34:50,079
so

951
00:34:50,079 --> 00:34:51,839
i don't remember when but uh and then

952
00:34:51,839 --> 00:34:54,320
came those pairings and then

953
00:34:54,320 --> 00:34:56,560
just a few you know i mean that's

954
00:34:56,560 --> 00:34:58,320
natural to look at the solution i mean

955
00:34:58,320 --> 00:34:59,040
there is

956
00:34:59,040 --> 00:35:02,480
nothing else available

957
00:35:02,480 --> 00:35:03,920
do you know who did this smart card

958
00:35:03,920 --> 00:35:05,680
implementation of function encryption

959
00:35:05,680 --> 00:35:08,800
yes it was this method scatter i forgot

960
00:35:08,800 --> 00:35:11,520
the year so i i i wanted to say

961
00:35:11,520 --> 00:35:13,040
something wrong but uh yeah

962
00:35:13,040 --> 00:35:14,880
it's good that it's good that even this

963
00:35:14,880 --> 00:35:16,560
map is not here he would have shouted at

964
00:35:16,560 --> 00:35:17,280
us

965
00:35:17,280 --> 00:35:21,280
yes okay that's very good

966
00:35:21,280 --> 00:35:22,790
yeah you're missing that too

967
00:35:22,790 --> 00:35:26,800
[Laughter]

968
00:35:26,800 --> 00:35:31,440
okay very good late 80s

969
00:35:31,440 --> 00:35:34,960
late 80s thank you mati

970
00:35:36,640 --> 00:35:38,240
yeah but there's also been recent work

971
00:35:38,240 --> 00:35:39,680
looking into research

972
00:35:39,680 --> 00:35:42,720
looking into using hardware

973
00:35:42,720 --> 00:35:44,640
secure hardware to accelerate fully

974
00:35:44,640 --> 00:35:46,960
homomorphic encryption

975
00:35:46,960 --> 00:35:49,119
so i think it's a matter of time that we

976
00:35:49,119 --> 00:35:50,240
will also start

977
00:35:50,240 --> 00:35:52,400
looking into using hardware to

978
00:35:52,400 --> 00:35:55,599
accelerate our functional encryption

979
00:35:55,599 --> 00:35:57,280
yeah but there's a difference between

980
00:35:57,280 --> 00:35:59,839
using hardware and tamper-proof hardware

981
00:35:59,839 --> 00:36:01,200
which the user itself

982
00:36:01,200 --> 00:36:04,720
doesn't see the inner working

983
00:36:04,720 --> 00:36:06,400
like the public key that has actually

984
00:36:06,400 --> 00:36:08,000
based on a secret key there

985
00:36:08,000 --> 00:36:11,359
that does symmetric encryption and claim

986
00:36:11,359 --> 00:36:12,240
to be

987
00:36:12,240 --> 00:36:14,560
publicly it was done by uh this medkit

988
00:36:14,560 --> 00:36:16,079
scatter it was part of

989
00:36:16,079 --> 00:36:20,320
an ibm old architecture in the 80s too

990
00:36:20,320 --> 00:36:23,119
it's all tricks they always come back in

991
00:36:23,119 --> 00:36:25,200
a new format

992
00:36:25,200 --> 00:36:28,640
when there are more new primitives

993
00:36:33,280 --> 00:36:35,440
yeah i think this works on using minimal

994
00:36:35,440 --> 00:36:37,040
hardware tokens to implement

995
00:36:37,040 --> 00:36:39,200
function encryption so there's also more

996
00:36:39,200 --> 00:36:42,560
theoretical work in that direction

997
00:36:43,520 --> 00:36:46,960
yeah yeah all we say is that there are

998
00:36:46,960 --> 00:36:50,240
now new new dimensions to the old work

999
00:36:50,240 --> 00:36:52,839
it's not exactly the old one new

1000
00:36:52,839 --> 00:36:55,839
primitives

1001
00:36:56,640 --> 00:36:58,800
so actually building on that uh coming

1002
00:36:58,800 --> 00:37:00,880
back to lorenzo and the last work

1003
00:37:00,880 --> 00:37:03,760
um you know when you use your hardware

1004
00:37:03,760 --> 00:37:05,520
and your enclaves you stay a sense of

1005
00:37:05,520 --> 00:37:06,800
this

1006
00:37:06,800 --> 00:37:09,359
you know how simple can you make the uh

1007
00:37:09,359 --> 00:37:10,320
functionality

1008
00:37:10,320 --> 00:37:12,240
you require from the trusted hardware

1009
00:37:12,240 --> 00:37:14,799
components

1010
00:37:15,280 --> 00:37:18,320
um so sorry can you say it again uh by

1011
00:37:18,320 --> 00:37:21,040
by simple do you mean like

1012
00:37:21,040 --> 00:37:23,440
uh so you require some trusted hardware

1013
00:37:23,440 --> 00:37:24,240
right

1014
00:37:24,240 --> 00:37:27,200
uh yes and then you need to trust that

1015
00:37:27,200 --> 00:37:29,280
where to do some computation for you

1016
00:37:29,280 --> 00:37:33,280
um how simple can we can this uh

1017
00:37:33,280 --> 00:37:36,560
computation be

1018
00:37:36,560 --> 00:37:38,480
uh i think that's a great question i

1019
00:37:38,480 --> 00:37:40,560
think uh it's somewhat a trade-off

1020
00:37:40,560 --> 00:37:41,359
between

1021
00:37:41,359 --> 00:37:44,560
efficiency and uh you know security

1022
00:37:44,560 --> 00:37:45,920
because obviously we know trusted

1023
00:37:45,920 --> 00:37:47,280
hardware has some problems

1024
00:37:47,280 --> 00:37:50,480
like side channel attacks uh so right

1025
00:37:50,480 --> 00:37:52,320
now in our construction we

1026
00:37:52,320 --> 00:37:54,320
basically rely exclusively on the

1027
00:37:54,320 --> 00:37:55,440
trusted order to

1028
00:37:55,440 --> 00:37:59,599
to do the entire competition uh which

1029
00:37:59,599 --> 00:38:01,760
us and trade-offs but uh so we've been

1030
00:38:01,760 --> 00:38:03,119
thinking about trying to add

1031
00:38:03,119 --> 00:38:06,480
in more more crypto outside of the

1032
00:38:06,480 --> 00:38:07,680
anklet itself

1033
00:38:07,680 --> 00:38:10,800
to to to to to strengthen it uh but

1034
00:38:10,800 --> 00:38:12,240
obviously that would mean a decrease

1035
00:38:12,240 --> 00:38:13,280
because

1036
00:38:13,280 --> 00:38:15,520
just running the code in the enclave has

1037
00:38:15,520 --> 00:38:16,640
basically no

1038
00:38:16,640 --> 00:38:19,359
performance impact but any further

1039
00:38:19,359 --> 00:38:20,480
crypto we have to do

1040
00:38:20,480 --> 00:38:23,680
would affect that yeah i hope they

1041
00:38:23,680 --> 00:38:24,880
answered the questions

1042
00:38:24,880 --> 00:38:28,640
yeah um so we have the test of times

1043
00:38:28,640 --> 00:38:30,480
or what ceremony coming up so we should

1044
00:38:30,480 --> 00:38:31,680
try to end on time

1045
00:38:31,680 --> 00:38:33,520
well one more minute any other final

1046
00:38:33,520 --> 00:38:35,440
comments or remarks or questions for the

1047
00:38:35,440 --> 00:38:37,920
speakers

1048
00:38:39,520 --> 00:38:40,960
if not maybe we can take further

1049
00:38:40,960 --> 00:38:42,720
questions to tulip and

1050
00:38:42,720 --> 00:38:44,480
let's thank all the speakers again for

1051
00:38:44,480 --> 00:38:47,839
the session

1052
00:38:48,640 --> 00:38:51,200
all right thank you oh wait we still

1053
00:38:51,200 --> 00:38:53,359
have one minute so

1054
00:38:53,359 --> 00:39:01,839
questions after the applause

1055
00:39:03,119 --> 00:39:06,000
uh maybe we can finish a little bit

1056
00:39:06,000 --> 00:39:06,880
early

1057
00:39:06,880 --> 00:39:11,040
thank you everyone

