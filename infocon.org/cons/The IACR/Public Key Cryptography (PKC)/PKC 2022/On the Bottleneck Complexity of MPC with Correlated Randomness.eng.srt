1
00:00:00,880 --> 00:00:03,040
hello everyone this talk is on the

2
00:00:03,040 --> 00:00:05,200
bottom leg complexity of mpc with

3
00:00:05,200 --> 00:00:07,839
correlated randomness i'm divya and this

4
00:00:07,839 --> 00:00:09,760
is based on a joint work with claudio

5
00:00:09,760 --> 00:00:12,559
orlandi and peter scholl

6
00:00:12,559 --> 00:00:13,840
let me begin with what secure

7
00:00:13,840 --> 00:00:16,239
multi-party computation or mpc means

8
00:00:16,239 --> 00:00:17,920
suppose you have n mutually distrusting

9
00:00:17,920 --> 00:00:20,080
parties out of which t are corrupt and

10
00:00:20,080 --> 00:00:21,680
the goal is that these parties want to

11
00:00:21,680 --> 00:00:23,680
compute some combined function on their

12
00:00:23,680 --> 00:00:24,960
private inputs

13
00:00:24,960 --> 00:00:27,039
mpc gives them a way to do so while

14
00:00:27,039 --> 00:00:29,439
ensuring two main properties the first

15
00:00:29,439 --> 00:00:31,279
is correctness that is at the end of the

16
00:00:31,279 --> 00:00:32,880
protocol everyone gets the correct

17
00:00:32,880 --> 00:00:35,360
function output and the next is privacy

18
00:00:35,360 --> 00:00:36,880
meaning that nothing beyond the function

19
00:00:36,880 --> 00:00:39,600
output will be revealed so in a nutshell

20
00:00:39,600 --> 00:00:42,000
you can think of mpc as a protocol that

21
00:00:42,000 --> 00:00:43,760
emulates the effect of having a trusted

22
00:00:43,760 --> 00:00:45,840
third party to whom all these parties

23
00:00:45,840 --> 00:00:47,920
simply submit their inputs and get the

24
00:00:47,920 --> 00:00:50,320
output in return

25
00:00:50,320 --> 00:00:52,800
the efficiency of an mpc protocol can be

26
00:00:52,800 --> 00:00:54,160
measured with respect to different

27
00:00:54,160 --> 00:00:56,719
parameters one such popular measure is

28
00:00:56,719 --> 00:00:58,480
communication complexity

29
00:00:58,480 --> 00:01:00,320
which measures the total number of bits

30
00:01:00,320 --> 00:01:02,399
that are sent or received by honest

31
00:01:02,399 --> 00:01:05,119
parties during the protocol execution

32
00:01:05,119 --> 00:01:07,200
bottleneck complexity is a special

33
00:01:07,200 --> 00:01:10,240
flavor of communication complexity so to

34
00:01:10,240 --> 00:01:12,000
understand this let's look at this

35
00:01:12,000 --> 00:01:14,560
protocol a where every party sends a

36
00:01:14,560 --> 00:01:17,040
single bid to a central party

37
00:01:17,040 --> 00:01:19,439
next let's look at this protocol b where

38
00:01:19,439 --> 00:01:21,200
again every party is sending a single

39
00:01:21,200 --> 00:01:22,880
bid but this time the bits are

40
00:01:22,880 --> 00:01:26,400
communicated in a chain like fashion

41
00:01:26,400 --> 00:01:28,159
now you can see that in both these

42
00:01:28,159 --> 00:01:30,240
protocols the total number of bits that

43
00:01:30,240 --> 00:01:32,400
are being sent is the same which is n

44
00:01:32,400 --> 00:01:34,400
minus 1 bits so their communication

45
00:01:34,400 --> 00:01:37,520
complexity is the same however protocol

46
00:01:37,520 --> 00:01:40,000
b seems much better in the way that the

47
00:01:40,000 --> 00:01:41,920
communication has been distributed

48
00:01:41,920 --> 00:01:43,680
because it's more balanced among the

49
00:01:43,680 --> 00:01:44,720
parties

50
00:01:44,720 --> 00:01:47,520
so to capture this boyle and others they

51
00:01:47,520 --> 00:01:49,040
introduce this notion of bottleneck

52
00:01:49,040 --> 00:01:50,560
complexity

53
00:01:50,560 --> 00:01:52,240
which is defined as the maximum

54
00:01:52,240 --> 00:01:54,640
communication complexity of any party

55
00:01:54,640 --> 00:01:56,240
within the protocol

56
00:01:56,240 --> 00:01:58,399
so if you consider protocol a its

57
00:01:58,399 --> 00:02:00,320
bottleneck complexity will be at least

58
00:02:00,320 --> 00:02:02,399
of order n because the central party

59
00:02:02,399 --> 00:02:05,759
there is receiving n minus 1 bits

60
00:02:05,759 --> 00:02:08,160
however for protocol b the bottleneck

61
00:02:08,160 --> 00:02:11,038
complexity is a constant because every

62
00:02:11,038 --> 00:02:13,440
party is actually receiving or sending

63
00:02:13,440 --> 00:02:15,840
at most one bit and that's why this

64
00:02:15,840 --> 00:02:17,920
bottleneck complexity is independent of

65
00:02:17,920 --> 00:02:20,080
the number of parties

66
00:02:20,080 --> 00:02:22,720
so now if you have a situation where the

67
00:02:22,720 --> 00:02:25,200
bandwidth of this central party is

68
00:02:25,200 --> 00:02:27,440
creating a bottleneck then definitely

69
00:02:27,440 --> 00:02:29,280
protocol b with lower bottleneck

70
00:02:29,280 --> 00:02:31,200
complexity would be the one that is

71
00:02:31,200 --> 00:02:34,399
preferred in practice

72
00:02:34,640 --> 00:02:36,080
now if we think about settings where the

73
00:02:36,080 --> 00:02:38,319
number of parties is very large there

74
00:02:38,319 --> 00:02:40,319
the goal would be to design

75
00:02:40,319 --> 00:02:42,080
uh protocols having bottleneck

76
00:02:42,080 --> 00:02:44,160
complexity independent of the number of

77
00:02:44,160 --> 00:02:46,560
parties and we refer to such protocols

78
00:02:46,560 --> 00:02:49,040
as being bc efficient

79
00:02:49,040 --> 00:02:51,280
bc efficient protocols were studied by

80
00:02:51,280 --> 00:02:53,680
the work of boyle and others and on the

81
00:02:53,680 --> 00:02:55,280
negative side they showed that it's

82
00:02:55,280 --> 00:02:57,040
impossible to design bc efficient

83
00:02:57,040 --> 00:02:59,760
protocols for general functions

84
00:02:59,760 --> 00:03:01,680
more specifically they showed that even

85
00:03:01,680 --> 00:03:03,920
if you don't care about security still

86
00:03:03,920 --> 00:03:06,480
it's impossible to design protocols

87
00:03:06,480 --> 00:03:08,879
having bottleneck complexity sub linear

88
00:03:08,879 --> 00:03:10,720
in the number of parties for general

89
00:03:10,720 --> 00:03:12,480
functions

90
00:03:12,480 --> 00:03:14,400
however on the positive side they

91
00:03:14,400 --> 00:03:16,800
presented a bottleneck complexity

92
00:03:16,800 --> 00:03:19,360
preserving compiler that transforms any

93
00:03:19,360 --> 00:03:21,840
insecure protocol to a secure one and

94
00:03:21,840 --> 00:03:25,840
this compiler was relying on fhe

95
00:03:25,840 --> 00:03:28,720
since fhe is relatively inefficient a

96
00:03:28,720 --> 00:03:30,959
natural question to ask would be that if

97
00:03:30,959 --> 00:03:32,959
we restrict ourselves to just specific

98
00:03:32,959 --> 00:03:35,519
functions then can we design

99
00:03:35,519 --> 00:03:38,000
protocols with low bottleneck complexity

100
00:03:38,000 --> 00:03:40,400
without relying on effigy

101
00:03:40,400 --> 00:03:42,080
so this is the question that we

102
00:03:42,080 --> 00:03:45,440
addressed partially in this work

103
00:03:45,440 --> 00:03:47,680
so we considered this setting of semi

104
00:03:47,680 --> 00:03:50,560
honest adversary where the kara parties

105
00:03:50,560 --> 00:03:52,159
they follow the protocol steps but the

106
00:03:52,159 --> 00:03:54,640
adversary can learn their internal state

107
00:03:54,640 --> 00:03:56,720
and we allow the adversary to perform up

108
00:03:56,720 --> 00:03:59,519
to n minus 1 corruptions and we also

109
00:03:59,519 --> 00:04:01,680
assume that the parties have access to a

110
00:04:01,680 --> 00:04:03,760
correlated randomness setup

111
00:04:03,760 --> 00:04:06,159
so in this setting we designed pc

112
00:04:06,159 --> 00:04:08,480
efficient protocols for two function

113
00:04:08,480 --> 00:04:09,439
classes

114
00:04:09,439 --> 00:04:11,200
the first function class is abelian

115
00:04:11,200 --> 00:04:13,439
programs where an appealing program can

116
00:04:13,439 --> 00:04:16,320
be expressed as a function on the sum of

117
00:04:16,320 --> 00:04:19,199
parties inputs over an abelian group

118
00:04:19,199 --> 00:04:21,199
this is actually a very expressive class

119
00:04:21,199 --> 00:04:23,199
of functions which covers important

120
00:04:23,199 --> 00:04:25,840
applications like voting and classifiers

121
00:04:25,840 --> 00:04:27,280
and so on

122
00:04:27,280 --> 00:04:28,960
the next class is that of selection

123
00:04:28,960 --> 00:04:30,960
functions where the input of the first

124
00:04:30,960 --> 00:04:33,120
party is the selection index that can

125
00:04:33,120 --> 00:04:35,759
vary from 2 to n and the output is

126
00:04:35,759 --> 00:04:37,759
nothing but the input that the first

127
00:04:37,759 --> 00:04:40,960
party has selected to learn

128
00:04:40,960 --> 00:04:42,880
so for these two classes of functions we

129
00:04:42,880 --> 00:04:45,440
designed bc efficient protocols and we

130
00:04:45,440 --> 00:04:47,520
use the tool of gabel circuits which can

131
00:04:47,520 --> 00:04:49,280
be built from one way functions to

132
00:04:49,280 --> 00:04:50,720
construct them

133
00:04:50,720 --> 00:04:53,199
and additionally the

134
00:04:53,199 --> 00:04:54,800
construction corresponding to selection

135
00:04:54,800 --> 00:04:56,720
functions also uses additively

136
00:04:56,720 --> 00:04:58,960
homomorphic encryption which can be

137
00:04:58,960 --> 00:05:00,639
instantiated from standard number

138
00:05:00,639 --> 00:05:03,440
theoretic assumptions

139
00:05:03,440 --> 00:05:05,120
so now in the rest of the talk i will

140
00:05:05,120 --> 00:05:07,280
present some warm-up examples and give

141
00:05:07,280 --> 00:05:11,280
an idea about these two constructions

142
00:05:11,280 --> 00:05:13,199
so before going into the construction

143
00:05:13,199 --> 00:05:15,680
let's think about how any

144
00:05:15,680 --> 00:05:17,600
protocol design will look like such that

145
00:05:17,600 --> 00:05:19,120
it's independent of the number of

146
00:05:19,120 --> 00:05:21,280
parties so one of the designs that we

147
00:05:21,280 --> 00:05:24,400
saw earlier was a chain like interaction

148
00:05:24,400 --> 00:05:26,320
and this was quite promising because

149
00:05:26,320 --> 00:05:28,639
every party was talking only to its

150
00:05:28,639 --> 00:05:30,880
neighbors which were constant so this

151
00:05:30,880 --> 00:05:33,199
helped us design the protocol having

152
00:05:33,199 --> 00:05:35,520
bottleneck complexity independent of the

153
00:05:35,520 --> 00:05:37,199
number of parties

154
00:05:37,199 --> 00:05:38,639
but it's not just enough to design

155
00:05:38,639 --> 00:05:40,800
protocols over the chain because we also

156
00:05:40,800 --> 00:05:42,800
have to make sure that the number of

157
00:05:42,800 --> 00:05:44,400
traversals that we are making over the

158
00:05:44,400 --> 00:05:46,320
chain even that should be independent of

159
00:05:46,320 --> 00:05:47,039
n

160
00:05:47,039 --> 00:05:48,720
and the size of the messages that we're

161
00:05:48,720 --> 00:05:50,400
sending over the chain even that should

162
00:05:50,400 --> 00:05:53,039
be independent of n

163
00:05:53,039 --> 00:05:53,840
so

164
00:05:53,840 --> 00:05:56,000
what kind of functions can be computed

165
00:05:56,000 --> 00:05:58,160
incrementally over the chain in a way

166
00:05:58,160 --> 00:06:00,080
that the size of the messages don't blow

167
00:06:00,080 --> 00:06:00,800
up

168
00:06:00,800 --> 00:06:02,960
a natural example that comes to mind is

169
00:06:02,960 --> 00:06:06,160
that of the addition function

170
00:06:06,160 --> 00:06:09,199
so let's consider the xor example where

171
00:06:09,199 --> 00:06:11,280
every party has a single bit as input

172
00:06:11,280 --> 00:06:13,199
and the output is nothing but the xor of

173
00:06:13,199 --> 00:06:14,800
these n bits

174
00:06:14,800 --> 00:06:16,800
to begin with if we did not care about

175
00:06:16,800 --> 00:06:18,880
privacy then what the first party could

176
00:06:18,880 --> 00:06:20,880
do is she could simply send her input to

177
00:06:20,880 --> 00:06:23,440
the second party who could locally exalt

178
00:06:23,440 --> 00:06:26,080
his input with hers and forward it ahead

179
00:06:26,080 --> 00:06:28,560
on the chain and so on until the last

180
00:06:28,560 --> 00:06:31,199
party on the chain gets the output

181
00:06:31,199 --> 00:06:33,120
so note that this is a bc efficient

182
00:06:33,120 --> 00:06:35,039
protocol because here the bottleneck

183
00:06:35,039 --> 00:06:37,199
complexity is independent of the number

184
00:06:37,199 --> 00:06:39,039
of parties

185
00:06:39,039 --> 00:06:40,800
what if we now want this protocol to

186
00:06:40,800 --> 00:06:42,560
satisfy privacy

187
00:06:42,560 --> 00:06:44,720
so assume that you had access to a

188
00:06:44,720 --> 00:06:47,199
correlated randomness setup where every

189
00:06:47,199 --> 00:06:50,400
party is given its own masking bit such

190
00:06:50,400 --> 00:06:52,800
that the xor of these masking bits is

191
00:06:52,800 --> 00:06:54,000
zero

192
00:06:54,000 --> 00:06:55,840
then what each party could do is she

193
00:06:55,840 --> 00:06:58,800
could locally exor her input with her

194
00:06:58,800 --> 00:07:01,919
masking bit to compute the masked input

195
00:07:01,919 --> 00:07:05,039
and then the parties could compute the

196
00:07:05,039 --> 00:07:06,880
exhaust of these masked inputs over the

197
00:07:06,880 --> 00:07:08,400
chain

198
00:07:08,400 --> 00:07:10,319
it's easy to see that the xor of these

199
00:07:10,319 --> 00:07:12,560
mast inputs would be the same as the xor

200
00:07:12,560 --> 00:07:14,479
of the actual inputs and therefore the

201
00:07:14,479 --> 00:07:16,720
protocol would be computing the function

202
00:07:16,720 --> 00:07:18,240
correctly

203
00:07:18,240 --> 00:07:20,800
so this is an example of a bc efficient

204
00:07:20,800 --> 00:07:25,440
protocol that computes xor securely

205
00:07:26,319 --> 00:07:28,639
next let's look at a bc efficient

206
00:07:28,639 --> 00:07:31,199
protocol for and function where every

207
00:07:31,199 --> 00:07:33,680
party again has a single bit as input

208
00:07:33,680 --> 00:07:37,039
and the output now is the logical and of

209
00:07:37,039 --> 00:07:39,440
these input bits

210
00:07:39,440 --> 00:07:41,280
in this protocol as a part of the

211
00:07:41,280 --> 00:07:43,919
correlated randomness setup we give each

212
00:07:43,919 --> 00:07:46,479
party two elements one for each

213
00:07:46,479 --> 00:07:48,080
potential input

214
00:07:48,080 --> 00:07:50,800
so a party will use the

215
00:07:50,800 --> 00:07:53,680
element z if her input is zero otherwise

216
00:07:53,680 --> 00:07:56,879
she will use her element r

217
00:07:56,879 --> 00:07:58,720
so the basic idea is that if you

218
00:07:58,720 --> 00:08:01,919
visualize the and function as this tree

219
00:08:01,919 --> 00:08:04,879
then what we want is that at the end of

220
00:08:04,879 --> 00:08:07,039
their chain of inputs we want the

221
00:08:07,039 --> 00:08:09,440
parties to identify whether they have

222
00:08:09,440 --> 00:08:13,120
arrived at a green node or a gray node

223
00:08:13,120 --> 00:08:14,479
because that would correspond to the

224
00:08:14,479 --> 00:08:17,520
output being 1 or 0.

225
00:08:17,520 --> 00:08:19,919
since there is just one green node

226
00:08:19,919 --> 00:08:22,080
it's enough if we just give the parties

227
00:08:22,080 --> 00:08:24,560
some information to identify if they

228
00:08:24,560 --> 00:08:26,720
have arrived at this special green node

229
00:08:26,720 --> 00:08:28,080
or not

230
00:08:28,080 --> 00:08:29,759
so this information that we give to the

231
00:08:29,759 --> 00:08:32,240
parties that can simply be

232
00:08:32,240 --> 00:08:34,320
a sum of these r's that were given to

233
00:08:34,320 --> 00:08:35,200
them

234
00:08:35,200 --> 00:08:37,679
so that's what we do let capital r be

235
00:08:37,679 --> 00:08:39,599
the sum of the individual hours given to

236
00:08:39,599 --> 00:08:41,919
these parties and the parties are given

237
00:08:41,919 --> 00:08:44,159
this as a part of the quoted randomness

238
00:08:44,159 --> 00:08:45,600
setup

239
00:08:45,600 --> 00:08:47,760
now what the parties do is that in a

240
00:08:47,760 --> 00:08:50,080
forward chain they compute the sum of

241
00:08:50,080 --> 00:08:51,920
their y's

242
00:08:51,920 --> 00:08:54,160
now note that if each of their inputs

243
00:08:54,160 --> 00:08:56,399
was 1 the sum of these y's would be

244
00:08:56,399 --> 00:08:58,959
nothing but the same as capital r so the

245
00:08:58,959 --> 00:09:01,279
party at the end of the chain can simply

246
00:09:01,279 --> 00:09:03,360
check if this is the case if the sum is

247
00:09:03,360 --> 00:09:06,160
equal to capital r or not if so she

248
00:09:06,160 --> 00:09:09,760
outputs 1 otherwise she outputs 0.

249
00:09:09,760 --> 00:09:12,399
so this protocol seems to work correctly

250
00:09:12,399 --> 00:09:15,600
but let's analyze its security

251
00:09:15,600 --> 00:09:17,519
suppose an adversary is corrupting the

252
00:09:17,519 --> 00:09:19,519
first and the third party

253
00:09:19,519 --> 00:09:21,680
where the input of the first party x1 is

254
00:09:21,680 --> 00:09:24,160
1 and x3 is 0.

255
00:09:24,160 --> 00:09:27,360
so the correct output in this case is 0.

256
00:09:27,360 --> 00:09:29,680
now from the adversary's perspective

257
00:09:29,680 --> 00:09:31,760
among all the possible parts during the

258
00:09:31,760 --> 00:09:34,320
protocol execution based on the inputs

259
00:09:34,320 --> 00:09:36,560
of the corrupt party he already knows

260
00:09:36,560 --> 00:09:37,360
that

261
00:09:37,360 --> 00:09:38,160
the

262
00:09:38,160 --> 00:09:40,080
actual part during the execution should

263
00:09:40,080 --> 00:09:43,519
be one among these two parts

264
00:09:43,519 --> 00:09:47,279
so as per the security of the protocol

265
00:09:47,279 --> 00:09:49,920
he must not be able to identify which of

266
00:09:49,920 --> 00:09:52,560
these two parts has been active during

267
00:09:52,560 --> 00:09:54,720
the execution

268
00:09:54,720 --> 00:09:56,959
however now what he can do is that in

269
00:09:56,959 --> 00:09:59,760
his head he can imagine what the sum

270
00:09:59,760 --> 00:10:03,120
would have been had he added r3 instead

271
00:10:03,120 --> 00:10:06,640
of z3 on behalf of p3

272
00:10:06,640 --> 00:10:09,200
so he computes this sum y dash based on

273
00:10:09,200 --> 00:10:11,839
that and checks in his head if y dash is

274
00:10:11,839 --> 00:10:14,480
equal to capital r or not

275
00:10:14,480 --> 00:10:16,399
if it is indeed the case that y dash is

276
00:10:16,399 --> 00:10:18,480
equal to r then he will be able to

277
00:10:18,480 --> 00:10:21,680
identify that the path taken during the

278
00:10:21,680 --> 00:10:24,560
protocol execution should be the one

279
00:10:24,560 --> 00:10:26,480
passing through the orange node because

280
00:10:26,480 --> 00:10:30,079
this is the one that if p3 had added r3

281
00:10:30,079 --> 00:10:31,519
instead of z3 then she would have

282
00:10:31,519 --> 00:10:34,320
arrived at the green node

283
00:10:34,320 --> 00:10:36,160
so this contradicts the security of the

284
00:10:36,160 --> 00:10:38,640
protocol because now the adversary has

285
00:10:38,640 --> 00:10:40,959
learned which was the correct path taken

286
00:10:40,959 --> 00:10:43,200
during the execution and this will allow

287
00:10:43,200 --> 00:10:46,000
him to learn x2 which is the input of an

288
00:10:46,000 --> 00:10:48,480
honest p2

289
00:10:48,480 --> 00:10:51,279
so to fix this we do not give the

290
00:10:51,279 --> 00:10:53,600
parties the capital r as a part of the

291
00:10:53,600 --> 00:10:56,720
setup instead we give each of them a prf

292
00:10:56,720 --> 00:10:58,880
key

293
00:10:58,880 --> 00:11:01,519
now what the parties do is that

294
00:11:01,519 --> 00:11:03,279
at the end of the forward chain once

295
00:11:03,279 --> 00:11:05,839
they have uh obtained the sum now the

296
00:11:05,839 --> 00:11:09,040
last party she will be computing the prf

297
00:11:09,040 --> 00:11:12,880
on this sum using her secret prf key

298
00:11:12,880 --> 00:11:15,040
and forward it to the next party the

299
00:11:15,040 --> 00:11:17,839
next party does the same he applies the

300
00:11:17,839 --> 00:11:20,560
prf using his key on this and then

301
00:11:20,560 --> 00:11:23,040
forwards it to the next party and so on

302
00:11:23,040 --> 00:11:25,279
so there is a backward chain where there

303
00:11:25,279 --> 00:11:27,839
are n applications of the prf on this

304
00:11:27,839 --> 00:11:30,079
sum

305
00:11:30,320 --> 00:11:32,320
now as a part of the setup instead of

306
00:11:32,320 --> 00:11:34,240
giving them capital r

307
00:11:34,240 --> 00:11:37,440
we will be giving them z which is the

308
00:11:37,440 --> 00:11:40,959
um output of the applications of

309
00:11:40,959 --> 00:11:43,760
prfs using the n different keys on

310
00:11:43,760 --> 00:11:45,600
capital r

311
00:11:45,600 --> 00:11:47,519
now what the first party at the end of

312
00:11:47,519 --> 00:11:49,680
the backward chain does is that she

313
00:11:49,680 --> 00:11:52,399
checks if the z dash is equal to z or

314
00:11:52,399 --> 00:11:53,279
not

315
00:11:53,279 --> 00:11:55,600
and if it is the case then she outputs 1

316
00:11:55,600 --> 00:11:57,920
otherwise she outputs 0.

317
00:11:57,920 --> 00:11:59,600
so it's easy to see that the correctness

318
00:11:59,600 --> 00:12:01,920
still holds because when

319
00:12:01,920 --> 00:12:04,320
the sum y is same as r these two will

320
00:12:04,320 --> 00:12:05,680
match

321
00:12:05,680 --> 00:12:07,839
and now we have avoided the attack that

322
00:12:07,839 --> 00:12:09,519
we saw previously

323
00:12:09,519 --> 00:12:11,920
intuitively that's because as soon as

324
00:12:11,920 --> 00:12:14,880
this honest party applies the prf using

325
00:12:14,880 --> 00:12:17,120
his secret key k2

326
00:12:17,120 --> 00:12:21,200
now this in some sense fixes the sum y

327
00:12:21,200 --> 00:12:23,200
so now the adversary can no longer

328
00:12:23,200 --> 00:12:26,160
imagine what the output would be had the

329
00:12:26,160 --> 00:12:29,760
sum being y dash instead of phi

330
00:12:29,760 --> 00:12:32,240
so this is an example of a bc efficient

331
00:12:32,240 --> 00:12:35,920
protocol for and that is

332
00:12:36,839 --> 00:12:39,600
secure now the two warm-up examples that

333
00:12:39,600 --> 00:12:42,800
we saw for xor and and they are actually

334
00:12:42,800 --> 00:12:44,959
special cases of a function class called

335
00:12:44,959 --> 00:12:46,560
abelian programs

336
00:12:46,560 --> 00:12:48,399
where an abelian program can be

337
00:12:48,399 --> 00:12:50,880
expressed as a function on the sum of

338
00:12:50,880 --> 00:12:54,639
inputs of parties over an abelian group

339
00:12:54,639 --> 00:12:56,880
so we generalize some of the ideas there

340
00:12:56,880 --> 00:12:59,120
in this construction

341
00:12:59,120 --> 00:13:00,880
now what we already know is we know how

342
00:13:00,880 --> 00:13:03,279
to compute the sum of inputs securely

343
00:13:03,279 --> 00:13:05,360
so if you had as a part of the setup

344
00:13:05,360 --> 00:13:08,000
some coded sharing of 0 then the parties

345
00:13:08,000 --> 00:13:10,160
could simply compute the sum of the must

346
00:13:10,160 --> 00:13:12,240
inputs which would give them the sum of

347
00:13:12,240 --> 00:13:14,240
their actual inputs

348
00:13:14,240 --> 00:13:17,040
however note that the output of edge may

349
00:13:17,040 --> 00:13:19,279
not necessarily reveal the sum of inputs

350
00:13:19,279 --> 00:13:23,440
it just reveals f on the sum of inputs

351
00:13:23,440 --> 00:13:25,120
so we want to avoid

352
00:13:25,120 --> 00:13:27,519
parties from learning this sum so what

353
00:13:27,519 --> 00:13:29,440
we do instead is instead of having a

354
00:13:29,440 --> 00:13:31,680
quoted sharing of 0 we have a quoted

355
00:13:31,680 --> 00:13:34,079
sharing of a secret random element r

356
00:13:34,079 --> 00:13:36,320
instead so that at the end of the first

357
00:13:36,320 --> 00:13:38,560
forward chain the parties compute the

358
00:13:38,560 --> 00:13:43,120
mass sum x plus r which we refer to as y

359
00:13:43,120 --> 00:13:45,440
so now to compute h what we need to do

360
00:13:45,440 --> 00:13:49,360
is we need to compute f of y minus r

361
00:13:49,360 --> 00:13:51,519
but we should do this in a secure manner

362
00:13:51,519 --> 00:13:54,000
to be sure that this capital r

363
00:13:54,000 --> 00:13:56,959
remains hidden from the parties

364
00:13:56,959 --> 00:13:59,199
so for this we use the tool of kabul

365
00:13:59,199 --> 00:14:02,399
circuits for the secure evaluation

366
00:14:02,399 --> 00:14:04,480
so let me take a detour and let's look

367
00:14:04,480 --> 00:14:06,720
at what garble circuits

368
00:14:06,720 --> 00:14:08,560
does

369
00:14:08,560 --> 00:14:09,680
this is the circuit that we are

370
00:14:09,680 --> 00:14:12,880
interested in where an input r is hard

371
00:14:12,880 --> 00:14:16,079
coded it takes as input y and it outputs

372
00:14:16,079 --> 00:14:17,839
f of y minus r

373
00:14:17,839 --> 00:14:19,839
so to evaluate this securely we

374
00:14:19,839 --> 00:14:22,800
transform this into a double circuit

375
00:14:22,800 --> 00:14:25,920
which you can imagine as a magic box

376
00:14:25,920 --> 00:14:28,800
which has slots for each input bit

377
00:14:28,800 --> 00:14:31,199
so imagine that this y can be expressed

378
00:14:31,199 --> 00:14:34,079
as a string of five bits

379
00:14:34,079 --> 00:14:36,079
now this has a slot for each input bit

380
00:14:36,079 --> 00:14:38,160
and each of these slots can take two

381
00:14:38,160 --> 00:14:40,959
types of token one is the token for zero

382
00:14:40,959 --> 00:14:43,680
corresponding to that bit of y being 0

383
00:14:43,680 --> 00:14:46,639
and the other is the token for 1.

384
00:14:46,639 --> 00:14:48,720
the property of garble circuits is that

385
00:14:48,720 --> 00:14:51,360
if you feed this box the tokens

386
00:14:51,360 --> 00:14:53,440
corresponding to an input

387
00:14:53,440 --> 00:14:56,880
then this box will output f of y minus r

388
00:14:56,880 --> 00:15:00,240
and nothing else beyond that

389
00:15:01,360 --> 00:15:03,920
however this box can be evaluated only

390
00:15:03,920 --> 00:15:05,440
if you have

391
00:15:05,440 --> 00:15:07,360
these tokens available

392
00:15:07,360 --> 00:15:09,760
and also the security of this gobbled

393
00:15:09,760 --> 00:15:12,560
circuit holds only if

394
00:15:12,560 --> 00:15:16,880
one token per input slot is available

395
00:15:19,839 --> 00:15:21,920
now coming back to the protocol recall

396
00:15:21,920 --> 00:15:24,160
that we were trying to compute f of y

397
00:15:24,160 --> 00:15:27,680
minus r securely using double circuits

398
00:15:27,680 --> 00:15:29,279
so now as a part of the setup each of

399
00:15:29,279 --> 00:15:31,680
these parties is given this magic box or

400
00:15:31,680 --> 00:15:33,279
the cable circuit

401
00:15:33,279 --> 00:15:35,440
now we also need to give them some

402
00:15:35,440 --> 00:15:37,839
information related to the input tokens

403
00:15:37,839 --> 00:15:39,360
so that they can evaluate the kabul

404
00:15:39,360 --> 00:15:41,040
circuit

405
00:15:41,040 --> 00:15:43,120
now recall that the input tokens would

406
00:15:43,120 --> 00:15:46,000
be corresponding to y but the value of y

407
00:15:46,000 --> 00:15:47,600
is something that is determined only

408
00:15:47,600 --> 00:15:50,320
during the protocol and we do not know

409
00:15:50,320 --> 00:15:52,480
it during the time of setup

410
00:15:52,480 --> 00:15:54,880
so that's why the setup must give these

411
00:15:54,880 --> 00:15:57,759
parties information related to all

412
00:15:57,759 --> 00:16:00,079
possible values of y related to the bits

413
00:16:00,079 --> 00:16:03,600
of y turning out to be 0 as well as 1.

414
00:16:03,600 --> 00:16:05,759
so let's just consider a single

415
00:16:05,759 --> 00:16:09,440
bit of y for simplicity so there are two

416
00:16:09,440 --> 00:16:11,040
possible tokens corresponding to the

417
00:16:11,040 --> 00:16:14,160
single bit of y so what we do is that we

418
00:16:14,160 --> 00:16:16,959
additively share each of these tokens

419
00:16:16,959 --> 00:16:19,040
where additive sharing means that only

420
00:16:19,040 --> 00:16:21,279
if all the shares are available then

421
00:16:21,279 --> 00:16:23,519
this token can be reconstructed

422
00:16:23,519 --> 00:16:25,199
otherwise the parties learn no

423
00:16:25,199 --> 00:16:27,360
information about the token if even a

424
00:16:27,360 --> 00:16:29,839
single share is missing

425
00:16:29,839 --> 00:16:31,360
so we do an additive sharing of the

426
00:16:31,360 --> 00:16:33,360
token corresponding to zero as well as

427
00:16:33,360 --> 00:16:35,680
one and give the parties their

428
00:16:35,680 --> 00:16:37,759
respective shares

429
00:16:37,759 --> 00:16:39,360
these are going to be useful in the

430
00:16:39,360 --> 00:16:42,160
evaluation as we will now see

431
00:16:42,160 --> 00:16:44,079
now in the protocol as we saw from

432
00:16:44,079 --> 00:16:46,639
before the parties compute the mask sum

433
00:16:46,639 --> 00:16:49,120
in the forward chain

434
00:16:49,120 --> 00:16:51,519
now what the party at the end of the

435
00:16:51,519 --> 00:16:53,680
chain does is that once she knows the

436
00:16:53,680 --> 00:16:56,160
value of this mass sum y which is the

437
00:16:56,160 --> 00:16:57,920
input to the garble circuit she

438
00:16:57,920 --> 00:17:00,959
identifies her appropriate share of y

439
00:17:00,959 --> 00:17:02,880
based on whether y turned out to be 0 or

440
00:17:02,880 --> 00:17:05,439
1 and then she forwards her share and y

441
00:17:05,439 --> 00:17:06,959
to the next party

442
00:17:06,959 --> 00:17:08,959
what the next party does is that he also

443
00:17:08,959 --> 00:17:12,160
identifies his appropriate share of y

444
00:17:12,160 --> 00:17:14,720
and he adds it up to her share and then

445
00:17:14,720 --> 00:17:16,720
he sends this forward along with y to

446
00:17:16,720 --> 00:17:19,679
the other next party and so on

447
00:17:19,679 --> 00:17:22,240
so now at the end of the backward chain

448
00:17:22,240 --> 00:17:24,559
the first party would be getting the sum

449
00:17:24,559 --> 00:17:27,520
of all these additive shares of y so she

450
00:17:27,520 --> 00:17:29,440
will be able to reconstruct the token

451
00:17:29,440 --> 00:17:32,960
for y and use it to evaluate this magic

452
00:17:32,960 --> 00:17:36,160
box and get the output f of y minus r

453
00:17:36,160 --> 00:17:38,240
which is nothing but the correct output

454
00:17:38,240 --> 00:17:40,799
of h

455
00:17:40,960 --> 00:17:43,360
note that here the input of the global

456
00:17:43,360 --> 00:17:45,840
circuit which is y is actually public

457
00:17:45,840 --> 00:17:48,799
because all the parties know it however

458
00:17:48,799 --> 00:17:50,960
gable circuit still helped us in order

459
00:17:50,960 --> 00:17:54,400
to ensure that this hard coded input r

460
00:17:54,400 --> 00:17:57,840
still remains hidden from the parties

461
00:17:57,840 --> 00:18:00,960
and also note that if for example two

462
00:18:00,960 --> 00:18:03,520
out of these three parties were corrupt

463
00:18:03,520 --> 00:18:05,919
still that adversary cannot obtain

464
00:18:05,919 --> 00:18:07,840
multiple evaluations of the function and

465
00:18:07,840 --> 00:18:10,320
he cannot carry out residual attack

466
00:18:10,320 --> 00:18:12,240
that's because he gets exactly one of

467
00:18:12,240 --> 00:18:14,480
the tokens so due to this additive

468
00:18:14,480 --> 00:18:16,240
sharing we know that he will just get

469
00:18:16,240 --> 00:18:18,480
the token corresponding to y

470
00:18:18,480 --> 00:18:20,960
and for the other uh bit which is not

471
00:18:20,960 --> 00:18:23,360
equal to buy which is not equal to y he

472
00:18:23,360 --> 00:18:24,960
will be missing the share of the honest

473
00:18:24,960 --> 00:18:27,440
party so that's why the security of the

474
00:18:27,440 --> 00:18:29,200
government circuit holds since he gets

475
00:18:29,200 --> 00:18:33,440
just one token per inspect input slot

476
00:18:33,440 --> 00:18:35,760
so this completes uh the description for

477
00:18:35,760 --> 00:18:36,960
the protocol

478
00:18:36,960 --> 00:18:38,880
uh for a billion programs and for

479
00:18:38,880 --> 00:18:40,480
simplicity i explained it for three

480
00:18:40,480 --> 00:18:43,039
parties but it can be extended up to n

481
00:18:43,039 --> 00:18:45,760
parties and it maintains the property

482
00:18:45,760 --> 00:18:47,679
that the bottom leg complexity is

483
00:18:47,679 --> 00:18:50,799
independent of n

484
00:18:50,880 --> 00:18:52,640
lastly let's look at the construction

485
00:18:52,640 --> 00:18:54,400
for selection functions

486
00:18:54,400 --> 00:18:57,679
recall that uh selection function has uh

487
00:18:57,679 --> 00:19:00,000
the input from party p1 as the selection

488
00:19:00,000 --> 00:19:02,640
index which can vary from 2 to n and the

489
00:19:02,640 --> 00:19:05,200
output is nothing but the input that p1

490
00:19:05,200 --> 00:19:07,679
chose to learn

491
00:19:07,679 --> 00:19:09,919
a useful way to look at the output of

492
00:19:09,919 --> 00:19:11,919
selection functions is to express it as

493
00:19:11,919 --> 00:19:15,440
a summation of bi into x i where bi is

494
00:19:15,440 --> 00:19:18,000
an indicator bit which is 1 if i is

495
00:19:18,000 --> 00:19:20,240
equal to the selection index c

496
00:19:20,240 --> 00:19:22,480
otherwise it's 0.

497
00:19:22,480 --> 00:19:24,559
now this way of looking at it is useful

498
00:19:24,559 --> 00:19:27,280
because if we could make a part p p i

499
00:19:27,280 --> 00:19:30,320
compute this b i x i then the values of

500
00:19:30,320 --> 00:19:32,480
these v i x i's can be aggregated over

501
00:19:32,480 --> 00:19:36,799
the chain in a bc efficient manner

502
00:19:37,360 --> 00:19:38,799
but the problem with this direct

503
00:19:38,799 --> 00:19:40,799
approach of making each party compute

504
00:19:40,799 --> 00:19:44,880
bixi would need the party to know bi but

505
00:19:44,880 --> 00:19:46,640
that is something that is not leaked by

506
00:19:46,640 --> 00:19:48,080
the output of h

507
00:19:48,080 --> 00:19:50,960
so to do this without allowing the party

508
00:19:50,960 --> 00:19:52,400
to know bi

509
00:19:52,400 --> 00:19:54,160
we do it under the hood of additive

510
00:19:54,160 --> 00:19:56,960
homomorphic encryption

511
00:19:56,960 --> 00:19:59,520
what i mean by this is that suppose

512
00:19:59,520 --> 00:20:02,559
somehow these parties p2p 3 and p4 they

513
00:20:02,559 --> 00:20:04,400
got access to

514
00:20:04,400 --> 00:20:07,520
encryptions of b2 b3 and b4 respectively

515
00:20:07,520 --> 00:20:09,120
then what they could do is they can

516
00:20:09,120 --> 00:20:11,200
locally compute the encryption

517
00:20:11,200 --> 00:20:12,799
corresponding to

518
00:20:12,799 --> 00:20:16,000
bixi without knowing bi and these

519
00:20:16,000 --> 00:20:18,159
encryptions can be added up over the

520
00:20:18,159 --> 00:20:20,320
chain to obtain the encryption of the

521
00:20:20,320 --> 00:20:22,639
output

522
00:20:23,039 --> 00:20:25,600
but now we need a way to give them these

523
00:20:25,600 --> 00:20:27,520
encryptions of bi but that is something

524
00:20:27,520 --> 00:20:29,440
that we cannot directly give as a part

525
00:20:29,440 --> 00:20:31,840
of the setup because the value of bi

526
00:20:31,840 --> 00:20:34,720
depends on the input of party p1 which

527
00:20:34,720 --> 00:20:36,240
is something that is determined only

528
00:20:36,240 --> 00:20:38,480
during the protocol

529
00:20:38,480 --> 00:20:40,240
so that's why the setup must somehow

530
00:20:40,240 --> 00:20:42,799
account for all possible

531
00:20:42,799 --> 00:20:45,039
inputs of party p1

532
00:20:45,039 --> 00:20:46,720
so instead of giving them a single

533
00:20:46,720 --> 00:20:49,360
encryption each what we give them is a

534
00:20:49,360 --> 00:20:51,520
lookup table

535
00:20:51,520 --> 00:20:53,600
this is how the lookup tables

536
00:20:53,600 --> 00:20:56,000
would be having the structure so each of

537
00:20:56,000 --> 00:20:59,039
these lookup tables have exactly one row

538
00:20:59,039 --> 00:21:02,080
which has the encryption of one and that

539
00:21:02,080 --> 00:21:04,159
is corresponding to the case when the

540
00:21:04,159 --> 00:21:06,480
selection index turns out to be the same

541
00:21:06,480 --> 00:21:08,400
as the parties index

542
00:21:08,400 --> 00:21:09,840
and all the other rows have an

543
00:21:09,840 --> 00:21:12,240
encryption of 0.

544
00:21:12,240 --> 00:21:14,480
the idea is that

545
00:21:14,480 --> 00:21:17,520
during the protocol what p1 can do is

546
00:21:17,520 --> 00:21:19,919
that based on his selection index he can

547
00:21:19,919 --> 00:21:22,559
point these parties to the correct row

548
00:21:22,559 --> 00:21:24,640
based on whatever his indexes for

549
00:21:24,640 --> 00:21:27,120
example if he points if his selection

550
00:21:27,120 --> 00:21:29,520
index is 3 then he can point all of them

551
00:21:29,520 --> 00:21:31,840
to the second row so that they use these

552
00:21:31,840 --> 00:21:33,760
appropriate encryptions and they are

553
00:21:33,760 --> 00:21:35,280
able to get the encryptions of the

554
00:21:35,280 --> 00:21:37,520
output

555
00:21:37,520 --> 00:21:39,679
however if you order the ciphertext in

556
00:21:39,679 --> 00:21:41,840
this way then the pointer is

557
00:21:41,840 --> 00:21:45,120
automatically revealing what the

558
00:21:45,120 --> 00:21:47,360
selection index is and that is something

559
00:21:47,360 --> 00:21:49,200
which we want to avoid because we do not

560
00:21:49,200 --> 00:21:50,960
want these parties to learn the

561
00:21:50,960 --> 00:21:53,280
selection index

562
00:21:53,280 --> 00:21:56,000
so what we do instead is that we apply a

563
00:21:56,000 --> 00:21:58,880
random cyclic shift on these rows of the

564
00:21:58,880 --> 00:22:01,520
lookup table so now they are not in this

565
00:22:01,520 --> 00:22:04,240
lexicographic order they will be shifted

566
00:22:04,240 --> 00:22:05,679
sequence of rows

567
00:22:05,679 --> 00:22:07,600
with an offset r which is picked during

568
00:22:07,600 --> 00:22:08,880
the setup

569
00:22:08,880 --> 00:22:10,960
and this offset is also given as a part

570
00:22:10,960 --> 00:22:13,760
of the setup to party p1

571
00:22:13,760 --> 00:22:15,440
the reason for giving him the offset is

572
00:22:15,440 --> 00:22:17,919
so that he can calculate the appropriate

573
00:22:17,919 --> 00:22:20,240
pointer based on this offset and his

574
00:22:20,240 --> 00:22:22,400
selection index and he can give it to

575
00:22:22,400 --> 00:22:24,080
the parties

576
00:22:24,080 --> 00:22:26,640
so now what each party does is that she

577
00:22:26,640 --> 00:22:29,440
just looks at this pointer c dash the

578
00:22:29,440 --> 00:22:31,600
row corresponding to that in her lookup

579
00:22:31,600 --> 00:22:33,280
table and then she computes these

580
00:22:33,280 --> 00:22:35,679
ciphertexts and now c dash doesn't

581
00:22:35,679 --> 00:22:37,840
reveal anything about the selection

582
00:22:37,840 --> 00:22:41,840
index so the protocol maintains security

583
00:22:42,080 --> 00:22:44,400
so this is the main idea of the protocol

584
00:22:44,400 --> 00:22:45,919
but there are still a couple more things

585
00:22:45,919 --> 00:22:49,120
to take care of like first thing is that

586
00:22:49,120 --> 00:22:51,120
here we just got an encryption of the

587
00:22:51,120 --> 00:22:54,159
output but we also need to decrypt it in

588
00:22:54,159 --> 00:22:56,480
a bc efficient manner

589
00:22:56,480 --> 00:22:59,120
and secondly if you generalize this and

590
00:22:59,120 --> 00:23:01,120
extend it to n parties then we are

591
00:23:01,120 --> 00:23:03,200
actually giving each party a lookup

592
00:23:03,200 --> 00:23:06,159
table of n minus one ciphertext and this

593
00:23:06,159 --> 00:23:08,559
is a huge storage overhead in the cases

594
00:23:08,559 --> 00:23:10,080
when n is large

595
00:23:10,080 --> 00:23:12,400
so we also have a mechanism to compress

596
00:23:12,400 --> 00:23:14,400
the size of these lookup tables and make

597
00:23:14,400 --> 00:23:16,880
it independent of n

598
00:23:16,880 --> 00:23:18,960
interestingly both the techniques for

599
00:23:18,960 --> 00:23:21,360
these two features they actually rely on

600
00:23:21,360 --> 00:23:23,280
garbled circuits and i refer to the

601
00:23:23,280 --> 00:23:26,000
paper for further details

602
00:23:26,000 --> 00:23:27,919
so

603
00:23:27,919 --> 00:23:30,480
to summarize the notion of bottleneck

604
00:23:30,480 --> 00:23:32,480
complexity captures how balanced the

605
00:23:32,480 --> 00:23:34,880
communication of a protocol is and in

606
00:23:34,880 --> 00:23:37,120
our work we design bc efficient

607
00:23:37,120 --> 00:23:39,440
protocols for a billion programs and

608
00:23:39,440 --> 00:23:41,360
selection functions

609
00:23:41,360 --> 00:23:43,840
some interesting open questions are to

610
00:23:43,840 --> 00:23:45,600
more thoroughly characterize which

611
00:23:45,600 --> 00:23:48,799
functions allow for bc efficiency

612
00:23:48,799 --> 00:23:51,120
and it would also be nice to get get a

613
00:23:51,120 --> 00:23:53,360
general bottleneck complexity preserving

614
00:23:53,360 --> 00:23:56,960
compiler that does not rely on fhe

615
00:23:56,960 --> 00:23:59,279
with this i conclude my talk thank you

616
00:23:59,279 --> 00:24:02,440
for listening

