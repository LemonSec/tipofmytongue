1
00:00:00,480 --> 00:00:02,800
hello everyone my name is rebecca

2
00:00:02,800 --> 00:00:04,560
schwert and together with my colleague

3
00:00:04,560 --> 00:00:06,480
roland kohl i will give you some

4
00:00:06,480 --> 00:00:08,720
insights into our paper a new security

5
00:00:08,720 --> 00:00:11,040
notion for pkc in the standard model

6
00:00:11,040 --> 00:00:13,120
weaker simpler and still realizing

7
00:00:13,120 --> 00:00:14,960
secure channels

8
00:00:14,960 --> 00:00:17,039
the paper is joint work with vasily

9
00:00:17,039 --> 00:00:19,760
bascarovanov jeon malaccuade and astrid

10
00:00:19,760 --> 00:00:21,920
ottenhoos

11
00:00:21,920 --> 00:00:23,920
firstly i will try to give you an idea

12
00:00:23,920 --> 00:00:26,320
of our topic by explaining the choice of

13
00:00:26,320 --> 00:00:28,880
our title

14
00:00:28,880 --> 00:00:31,279
an important goal of cryptographic tools

15
00:00:31,279 --> 00:00:33,360
is to facilitate secure channels between

16
00:00:33,360 --> 00:00:35,520
communicating parties

17
00:00:35,520 --> 00:00:37,520
in our particular setting we want to

18
00:00:37,520 --> 00:00:39,360
build them from authenticated channels

19
00:00:39,360 --> 00:00:42,000
and some form of encryption

20
00:00:42,000 --> 00:00:43,920
this was previously achieved in

21
00:00:43,920 --> 00:00:46,480
different works by use of classic public

22
00:00:46,480 --> 00:00:49,360
key or tech-based encryption

23
00:00:49,360 --> 00:00:51,280
all the security notions employed for

24
00:00:51,280 --> 00:00:53,039
this however are known to be

25
00:00:53,039 --> 00:00:55,120
unnecessarily strong for the specific

26
00:00:55,120 --> 00:00:57,280
purpose

27
00:00:57,280 --> 00:00:59,520
in this work we develop a new game-based

28
00:00:59,520 --> 00:01:01,920
security notion which is weaker than the

29
00:01:01,920 --> 00:01:03,680
previous ones and makes for simpler

30
00:01:03,680 --> 00:01:05,119
constructions

31
00:01:05,119 --> 00:01:07,200
but at the same time is still strong

32
00:01:07,200 --> 00:01:08,960
enough to realize secured channels from

33
00:01:08,960 --> 00:01:12,159
authenticated channels

34
00:01:12,159 --> 00:01:14,000
to show that this is not merely a

35
00:01:14,000 --> 00:01:16,400
theoretic interest we provide a concrete

36
00:01:16,400 --> 00:01:18,320
construction which we prove in the

37
00:01:18,320 --> 00:01:20,000
standard model to fulfill our new

38
00:01:20,000 --> 00:01:21,759
security notion

39
00:01:21,759 --> 00:01:23,840
this construction is more efficient than

40
00:01:23,840 --> 00:01:25,759
previous ones which had to fulfill

41
00:01:25,759 --> 00:01:27,759
stronger security notions to realize

42
00:01:27,759 --> 00:01:30,560
secure channels

43
00:01:31,200 --> 00:01:32,960
i will now give you an overview of what

44
00:01:32,960 --> 00:01:36,720
to expect in this talk before diving in

45
00:01:36,720 --> 00:01:38,560
we firstly develop a new type of

46
00:01:38,560 --> 00:01:40,320
encryption scheme sender binding

47
00:01:40,320 --> 00:01:42,399
encryption which unifies prior

48
00:01:42,399 --> 00:01:44,320
approaches to construct secure message

49
00:01:44,320 --> 00:01:46,960
transfer from authenticated channels

50
00:01:46,960 --> 00:01:49,200
for this type of encryption we develop

51
00:01:49,200 --> 00:01:51,040
the corresponding game-based security

52
00:01:51,040 --> 00:01:52,840
notion of int

53
00:01:52,840 --> 00:01:54,399
sbcpa

54
00:01:54,399 --> 00:01:57,040
we proceed to show how spcpa secure

55
00:01:57,040 --> 00:01:58,960
sender binding encryption can be

56
00:01:58,960 --> 00:02:00,799
generically obtained by various

57
00:02:00,799 --> 00:02:02,560
transformations from other types of

58
00:02:02,560 --> 00:02:05,119
encryption scheme

59
00:02:05,119 --> 00:02:06,880
for the transformation from dual

60
00:02:06,880 --> 00:02:09,199
receiver encryption we give concrete

61
00:02:09,199 --> 00:02:11,120
constructions which are more efficient

62
00:02:11,120 --> 00:02:14,480
than previously known ones

63
00:02:14,560 --> 00:02:17,120
we then go on to prove that sp cpa

64
00:02:17,120 --> 00:02:19,520
security can be used to use serialized

65
00:02:19,520 --> 00:02:20,959
secure message transfer from

66
00:02:20,959 --> 00:02:24,160
authenticated channels

67
00:02:24,319 --> 00:02:26,560
in the last part we look at how the new

68
00:02:26,560 --> 00:02:29,360
svcpa security notion fits into the

69
00:02:29,360 --> 00:02:31,280
current landscape of other game-based

70
00:02:31,280 --> 00:02:33,760
notions

71
00:02:34,879 --> 00:02:38,799
let's get started with the first part

72
00:02:39,040 --> 00:02:41,519
as we all know a classic pke scheme

73
00:02:41,519 --> 00:02:43,840
consists of three algorithms key

74
00:02:43,840 --> 00:02:46,319
generation encryption and decryption

75
00:02:46,319 --> 00:02:48,400
which we require a correctness property

76
00:02:48,400 --> 00:02:50,879
from namely that by decrypting an

77
00:02:50,879 --> 00:02:52,959
encrypted message we get the same

78
00:02:52,959 --> 00:02:55,120
message back

79
00:02:55,120 --> 00:02:57,120
a tech based encryption scheme works

80
00:02:57,120 --> 00:02:58,720
almost the same

81
00:02:58,720 --> 00:03:00,879
just that encryption and decryption

82
00:03:00,879 --> 00:03:03,120
additionally take attack t

83
00:03:03,120 --> 00:03:04,959
the correctness property requires the

84
00:03:04,959 --> 00:03:06,879
text to be the same for encryption and

85
00:03:06,879 --> 00:03:09,518
decryption

86
00:03:09,760 --> 00:03:12,080
from tech-based encryption it is not far

87
00:03:12,080 --> 00:03:14,000
to what a new notion of sender binding

88
00:03:14,000 --> 00:03:15,760
encryption entails

89
00:03:15,760 --> 00:03:18,879
the texts are party ids now this is a

90
00:03:18,879 --> 00:03:21,360
notational difference only so far but

91
00:03:21,360 --> 00:03:23,200
means there are no correspondences

92
00:03:23,200 --> 00:03:25,599
between keys and ids

93
00:03:25,599 --> 00:03:27,599
these ids are thought of as some

94
00:03:27,599 --> 00:03:30,159
uniquely identifying information used

95
00:03:30,159 --> 00:03:32,640
within the specific system like names

96
00:03:32,640 --> 00:03:34,799
emails etc

97
00:03:34,799 --> 00:03:37,040
sender binding encryption is meant to be

98
00:03:37,040 --> 00:03:38,879
used with the id of the sending or

99
00:03:38,879 --> 00:03:40,959
encrypting party

100
00:03:40,959 --> 00:03:43,519
this definition alone does not yield any

101
00:03:43,519 --> 00:03:46,319
obvious benefits so far as ids are seen

102
00:03:46,319 --> 00:03:48,879
as public knowledge so malicious parties

103
00:03:48,879 --> 00:03:51,599
can insert any id they want

104
00:03:51,599 --> 00:03:53,680
but the benefits unfold in conjunction

105
00:03:53,680 --> 00:03:55,840
with authenticated channels

106
00:03:55,840 --> 00:03:57,439
checking the authenticated channel

107
00:03:57,439 --> 00:03:59,519
sender against the sender indicated in

108
00:03:59,519 --> 00:04:02,000
the ciphertext gives protection against

109
00:04:02,000 --> 00:04:04,239
replay attacks

110
00:04:04,239 --> 00:04:06,560
to make sure neither message content nor

111
00:04:06,560 --> 00:04:08,560
sender id of a ciphertext can be

112
00:04:08,560 --> 00:04:10,640
maliciously modified we need a

113
00:04:10,640 --> 00:04:12,640
meaningful security notion for sender

114
00:04:12,640 --> 00:04:15,200
binding encryption

115
00:04:15,200 --> 00:04:17,358
we call this notion in sender binding

116
00:04:17,358 --> 00:04:20,320
cpa it has the same setup as common

117
00:04:20,320 --> 00:04:23,360
game-based encryption security notions

118
00:04:23,360 --> 00:04:25,360
firstly the challenger determines

119
00:04:25,360 --> 00:04:27,440
information about the party or parties

120
00:04:27,440 --> 00:04:28,479
in question

121
00:04:28,479 --> 00:04:29,919
and hence the public part to the

122
00:04:29,919 --> 00:04:31,280
adversary

123
00:04:31,280 --> 00:04:33,680
for our setup this entails the keys and

124
00:04:33,680 --> 00:04:36,080
identities of a sending and a receiving

125
00:04:36,080 --> 00:04:37,680
party

126
00:04:37,680 --> 00:04:40,240
after a first oracle phase the adversary

127
00:04:40,240 --> 00:04:42,400
picks two messages and hands them to the

128
00:04:42,400 --> 00:04:44,000
challenger

129
00:04:44,000 --> 00:04:45,600
the challenger draws one of them

130
00:04:45,600 --> 00:04:48,080
uniformly at random and encrypts it as

131
00:04:48,080 --> 00:04:50,320
the challenge ciphertext

132
00:04:50,320 --> 00:04:52,880
lastly after the second oracle phase the

133
00:04:52,880 --> 00:04:54,560
adversary tries to determine the

134
00:04:54,560 --> 00:04:57,759
challenge bit and wins if it is correct

135
00:04:57,759 --> 00:04:59,440
now the interesting part about the

136
00:04:59,440 --> 00:05:02,000
security definition is what exactly the

137
00:05:02,000 --> 00:05:05,120
two oracle phases look like

138
00:05:05,120 --> 00:05:08,000
both oracle phases are identical

139
00:05:08,000 --> 00:05:10,160
as always the adversary asks for some

140
00:05:10,160 --> 00:05:12,880
ciphertext c to be decrypted

141
00:05:12,880 --> 00:05:15,199
in our case not only this receiver's

142
00:05:15,199 --> 00:05:17,759
public key but also the sender id are

143
00:05:17,759 --> 00:05:20,800
specified together with the ciphertext

144
00:05:20,800 --> 00:05:22,880
the oracle either decrypts to the true

145
00:05:22,880 --> 00:05:25,039
message or hence back bottom if

146
00:05:25,039 --> 00:05:28,320
decryption is not allowed

147
00:05:28,800 --> 00:05:30,720
what we want is for the adversary to

148
00:05:30,720 --> 00:05:32,720
have no access to any communication

149
00:05:32,720 --> 00:05:34,320
between snr

150
00:05:34,320 --> 00:05:36,320
but any other communication should be

151
00:05:36,320 --> 00:05:38,960
accessible as would be the case if every

152
00:05:38,960 --> 00:05:42,160
other party was corrupted

153
00:05:42,160 --> 00:05:44,479
the adversary already has three access

154
00:05:44,479 --> 00:05:47,440
to communication sent from s or r to any

155
00:05:47,440 --> 00:05:49,919
other party as the adversary can just

156
00:05:49,919 --> 00:05:52,080
choose the other party's keys himself

157
00:05:52,080 --> 00:05:54,560
and only needs public information from s

158
00:05:54,560 --> 00:05:58,160
or r to encrypt messages

159
00:05:58,160 --> 00:06:00,080
hence the oracle only needs to give

160
00:06:00,080 --> 00:06:02,720
access to messages from another party to

161
00:06:02,720 --> 00:06:04,720
srr

162
00:06:04,720 --> 00:06:06,880
this means for the decryption request

163
00:06:06,880 --> 00:06:10,000
that the receiver needs to be s or r

164
00:06:10,000 --> 00:06:11,759
while the sender needs to be someone

165
00:06:11,759 --> 00:06:12,960
else

166
00:06:12,960 --> 00:06:14,880
only in these cases does the oracle

167
00:06:14,880 --> 00:06:16,880
decrypt correctly

168
00:06:16,880 --> 00:06:19,440
with these oracle phases our indsp cpa

169
00:06:19,440 --> 00:06:23,280
security notion is fully specified

170
00:06:23,280 --> 00:06:25,440
there are several ways to generically

171
00:06:25,440 --> 00:06:27,520
transform other forms of encryption into

172
00:06:27,520 --> 00:06:30,319
secure sender binding encryption

173
00:06:30,319 --> 00:06:32,240
let us briefly look at the construction

174
00:06:32,240 --> 00:06:34,400
from classic public key encryption and

175
00:06:34,400 --> 00:06:36,080
then consider the transformation from

176
00:06:36,080 --> 00:06:37,759
dual receiver encryption in some more

177
00:06:37,759 --> 00:06:39,199
detail

178
00:06:39,199 --> 00:06:40,960
for the transformation from identity

179
00:06:40,960 --> 00:06:42,960
paste encryption please have a look at

180
00:06:42,960 --> 00:06:45,520
our paper

181
00:06:45,840 --> 00:06:47,840
to construct sender binding encryption

182
00:06:47,840 --> 00:06:49,919
from a classic public key scheme we

183
00:06:49,919 --> 00:06:52,000
simply concatenate the sender id to the

184
00:06:52,000 --> 00:06:54,160
message

185
00:06:54,160 --> 00:06:56,560
this gives an indspcp a secure sender

186
00:06:56,560 --> 00:06:58,880
binding encryption scheme as long as the

187
00:06:58,880 --> 00:07:02,880
underlying pke is in rcca secure

188
00:07:02,880 --> 00:07:04,560
for those of you who are not familiar

189
00:07:04,560 --> 00:07:05,919
with this notion

190
00:07:05,919 --> 00:07:08,960
rcca security lies strictly between cca1

191
00:07:08,960 --> 00:07:10,960
and cca2 security

192
00:07:10,960 --> 00:07:12,960
so we get a complete decryption oracle

193
00:07:12,960 --> 00:07:15,440
in the first oracle phase and a partial

194
00:07:15,440 --> 00:07:18,880
oracle in the second oracle phase

195
00:07:18,880 --> 00:07:20,560
the second oracle phase allows

196
00:07:20,560 --> 00:07:23,120
decryptions for all ciphertexts which do

197
00:07:23,120 --> 00:07:24,560
not contain one of the challenge

198
00:07:24,560 --> 00:07:28,240
messages m0 and m1

199
00:07:28,319 --> 00:07:30,400
for this sbe transformation where the

200
00:07:30,400 --> 00:07:33,120
sender id is concatenated to the message

201
00:07:33,120 --> 00:07:35,520
this means in particular that the oracle

202
00:07:35,520 --> 00:07:37,919
decrypts anything which has a sender id

203
00:07:37,919 --> 00:07:39,360
different from s

204
00:07:39,360 --> 00:07:41,680
even if the message before the sender id

205
00:07:41,680 --> 00:07:44,879
might be one of the challenge messages

206
00:07:44,879 --> 00:07:47,360
the construction is not very novel but

207
00:07:47,360 --> 00:07:50,080
was previously used by kaneti at alie to

208
00:07:50,080 --> 00:07:52,160
use serialized secure message transfer

209
00:07:52,160 --> 00:07:54,160
from authenticated channels and classic

210
00:07:54,160 --> 00:07:56,319
public key encryption

211
00:07:56,319 --> 00:07:58,560
together with its relation to tech-based

212
00:07:58,560 --> 00:08:01,280
encryption this shows that our notion of

213
00:08:01,280 --> 00:08:03,199
indspc pa secure sender binding

214
00:08:03,199 --> 00:08:05,360
encryption is well tailored to our

215
00:08:05,360 --> 00:08:08,000
research question and unifies all prior

216
00:08:08,000 --> 00:08:10,000
approaches to gain a secure message

217
00:08:10,000 --> 00:08:13,840
transfer via authenticated channels

218
00:08:14,639 --> 00:08:16,160
for the transformation from dual

219
00:08:16,160 --> 00:08:18,720
receiver encryption let us briefly recap

220
00:08:18,720 --> 00:08:21,280
how dre works and what dre soundness

221
00:08:21,280 --> 00:08:22,720
entails

222
00:08:22,720 --> 00:08:24,879
the intuition is that ciphertext should

223
00:08:24,879 --> 00:08:27,360
be decryptable by exactly two specified

224
00:08:27,360 --> 00:08:30,639
parties instead of just one

225
00:08:30,639 --> 00:08:32,719
so dre consists of the same three

226
00:08:32,719 --> 00:08:35,039
algorithms as most encryption schemes

227
00:08:35,039 --> 00:08:38,159
key generation encryption and decryption

228
00:08:38,159 --> 00:08:40,479
the interfaces are slightly different

229
00:08:40,479 --> 00:08:42,399
as both encryption and decryption get

230
00:08:42,399 --> 00:08:45,600
two public keys as input

231
00:08:45,600 --> 00:08:47,279
in addition to the common correctness

232
00:08:47,279 --> 00:08:50,000
property we require a die scheme to be

233
00:08:50,000 --> 00:08:51,200
sound

234
00:08:51,200 --> 00:08:53,360
this means an adversary cannot create a

235
00:08:53,360 --> 00:08:55,360
ciphertext which decrypts to two

236
00:08:55,360 --> 00:08:58,240
different messages for the two receivers

237
00:08:58,240 --> 00:09:00,160
not even if the adversary gets both

238
00:09:00,160 --> 00:09:02,160
public and secret keys of the parties

239
00:09:02,160 --> 00:09:04,640
involved

240
00:09:05,040 --> 00:09:07,680
for our sde construction we additionally

241
00:09:07,680 --> 00:09:09,920
require the die scheme to permit a

242
00:09:09,920 --> 00:09:12,080
boolean key checking function which

243
00:09:12,080 --> 00:09:14,080
indicates whether a secret and public

244
00:09:14,080 --> 00:09:16,399
key belong together or not

245
00:09:16,399 --> 00:09:18,240
think for instance about checking for an

246
00:09:18,240 --> 00:09:20,640
elgamal key pair whether the public key

247
00:09:20,640 --> 00:09:22,800
is the group generator exponentiated

248
00:09:22,800 --> 00:09:25,680
with the secret key

249
00:09:25,920 --> 00:09:27,440
now let's get to the actual

250
00:09:27,440 --> 00:09:29,120
transformation

251
00:09:29,120 --> 00:09:31,600
taking a dae scheme we require both the

252
00:09:31,600 --> 00:09:33,440
receiving and the sending parties to

253
00:09:33,440 --> 00:09:35,600
have keys

254
00:09:35,600 --> 00:09:37,360
instead of encrypting the message for

255
00:09:37,360 --> 00:09:39,600
two different receivers the sender

256
00:09:39,600 --> 00:09:43,040
encrypts for the receiver and themselves

257
00:09:43,040 --> 00:09:45,279
hence the construction sketch looks like

258
00:09:45,279 --> 00:09:47,360
this

259
00:09:47,360 --> 00:09:49,279
encrypting for the sending party might

260
00:09:49,279 --> 00:09:51,760
seem weird at first but actually acts as

261
00:09:51,760 --> 00:09:54,160
a plain text awareness property

262
00:09:54,160 --> 00:09:56,399
this means parties cannot send messages

263
00:09:56,399 --> 00:09:58,000
without knowing the content of the

264
00:09:58,000 --> 00:10:01,360
message which prevents replay attacks

265
00:10:01,360 --> 00:10:03,680
to get this property however we need to

266
00:10:03,680 --> 00:10:05,360
make sure parties actually know the

267
00:10:05,360 --> 00:10:07,200
secret key corresponding to the public

268
00:10:07,200 --> 00:10:09,279
credentials

269
00:10:09,279 --> 00:10:11,040
we ensure this by using a key

270
00:10:11,040 --> 00:10:12,320
registration with knowledge

271
00:10:12,320 --> 00:10:15,600
functionality fkrk

272
00:10:15,600 --> 00:10:18,000
a party registers their key by simply

273
00:10:18,000 --> 00:10:19,839
sending their public and secret key to

274
00:10:19,839 --> 00:10:22,480
the ideal functionality

275
00:10:22,480 --> 00:10:24,640
the functionality checks if the keypair

276
00:10:24,640 --> 00:10:26,560
is well-formed by the checking function

277
00:10:26,560 --> 00:10:28,560
fid

278
00:10:28,560 --> 00:10:31,040
now any party can query the registered

279
00:10:31,040 --> 00:10:33,120
public key

280
00:10:33,120 --> 00:10:35,120
hence we extend our construction by

281
00:10:35,120 --> 00:10:37,920
interactions with fkrk

282
00:10:37,920 --> 00:10:39,760
after the key generation keys are

283
00:10:39,760 --> 00:10:41,920
registered and for encryption and

284
00:10:41,920 --> 00:10:44,240
decryption the necessary public keys are

285
00:10:44,240 --> 00:10:47,040
queried from fk rk

286
00:10:47,040 --> 00:10:50,000
using fkrk and this transformation we

287
00:10:50,000 --> 00:10:52,399
can turn an ncpa secure and sound double

288
00:10:52,399 --> 00:10:55,040
receiver scheme into an sbcba secure

289
00:10:55,040 --> 00:10:57,839
sender binding encryption

290
00:10:57,839 --> 00:10:59,760
we'll have a quick look at how the proof

291
00:10:59,760 --> 00:11:01,519
of this works

292
00:11:01,519 --> 00:11:03,519
let's assume we have a successful

293
00:11:03,519 --> 00:11:05,519
adversary breaking the security of the

294
00:11:05,519 --> 00:11:07,200
sbe scheme

295
00:11:07,200 --> 00:11:09,440
we will use this con to construct an

296
00:11:09,440 --> 00:11:11,519
adversary against the underlying dre

297
00:11:11,519 --> 00:11:13,440
scheme

298
00:11:13,440 --> 00:11:16,160
firstly the dre challenger hands over to

299
00:11:16,160 --> 00:11:18,399
public keys

300
00:11:18,399 --> 00:11:20,800
the doe adversary denotes them as the

301
00:11:20,800 --> 00:11:23,519
public keys of two parties snr and

302
00:11:23,519 --> 00:11:27,360
inserts the keys into fkrk

303
00:11:27,360 --> 00:11:30,079
note that the dre adversary simulates fk

304
00:11:30,079 --> 00:11:32,480
or k for the sbe adversary

305
00:11:32,480 --> 00:11:34,640
so it can just insert those keys without

306
00:11:34,640 --> 00:11:37,839
providing corresponding secret keys

307
00:11:37,839 --> 00:11:39,920
apart from this insertion the do

308
00:11:39,920 --> 00:11:42,399
adversary honestly simulates fkok

309
00:11:42,399 --> 00:11:43,920
throughout this proof

310
00:11:43,920 --> 00:11:46,480
so the sbe adversary can register and

311
00:11:46,480 --> 00:11:49,440
request keys at any point

312
00:11:49,440 --> 00:11:51,680
don't be irritated by the dre adversary

313
00:11:51,680 --> 00:11:53,600
handing over the party ids instead of

314
00:11:53,600 --> 00:11:54,880
public keys

315
00:11:54,880 --> 00:11:56,800
we formally use those as the party's

316
00:11:56,800 --> 00:11:59,200
public keys for the sbe scheme but it is

317
00:11:59,200 --> 00:12:02,399
just a technicality

318
00:12:02,800 --> 00:12:04,720
now the rest of the game is just handing

319
00:12:04,720 --> 00:12:06,320
through everything that the sbe

320
00:12:06,320 --> 00:12:08,880
adversary and the dre challenger send

321
00:12:08,880 --> 00:12:12,480
apart from the oracle phases

322
00:12:12,560 --> 00:12:14,399
this is where the actual magic happens

323
00:12:14,399 --> 00:12:17,040
so we'll look at it in some detail

324
00:12:17,040 --> 00:12:18,880
the first and second oracle phase are

325
00:12:18,880 --> 00:12:21,200
exactly the same

326
00:12:21,200 --> 00:12:23,360
when the sb adversary asks for

327
00:12:23,360 --> 00:12:25,519
decryption of some ciphertext c sent

328
00:12:25,519 --> 00:12:28,160
from s prime to r prime the dle

329
00:12:28,160 --> 00:12:30,560
adversary firstly checks if the sbe

330
00:12:30,560 --> 00:12:32,639
oracle would decrypt this

331
00:12:32,639 --> 00:12:34,560
otherwise they hand back bottom straight

332
00:12:34,560 --> 00:12:36,320
away

333
00:12:36,320 --> 00:12:39,120
if the sbe oracle would decrypt then the

334
00:12:39,120 --> 00:12:41,120
receiver r prime must be one of our

335
00:12:41,120 --> 00:12:44,160
known parties snr and the sender s prime

336
00:12:44,160 --> 00:12:47,760
is not allowed to be one of those

337
00:12:48,000 --> 00:12:50,079
but this means the decryption only needs

338
00:12:50,079 --> 00:12:52,720
to succeed if the sbe adversary

339
00:12:52,720 --> 00:12:55,360
registered keys for s prime with fkrk at

340
00:12:55,360 --> 00:12:56,480
some point

341
00:12:56,480 --> 00:12:58,720
and in particular handed a valid secret

342
00:12:58,720 --> 00:13:02,800
key of s prime to the dle adversary

343
00:13:02,800 --> 00:13:05,360
the doe adversary uses this secret key

344
00:13:05,360 --> 00:13:07,519
and the public key of r prime to decrypt

345
00:13:07,519 --> 00:13:10,399
the oracle query

346
00:13:10,399 --> 00:13:12,720
the soundness property of the dre scheme

347
00:13:12,720 --> 00:13:14,639
guarantees that this decryption yields

348
00:13:14,639 --> 00:13:16,880
the same output as decryption with our

349
00:13:16,880 --> 00:13:20,000
prime secret keyword

350
00:13:20,000 --> 00:13:22,160
apart from a negligible difference the

351
00:13:22,160 --> 00:13:24,480
dle adversary now has the same success

352
00:13:24,480 --> 00:13:27,519
probability as the assumed sbe adversary

353
00:13:27,519 --> 00:13:30,560
has which concludes our proof

354
00:13:30,560 --> 00:13:32,320
i will now hand over to my colleague

355
00:13:32,320 --> 00:13:34,240
colin kroel to explain our efficient

356
00:13:34,240 --> 00:13:38,079
construction of ndi scheme

357
00:13:38,959 --> 00:13:40,560
thank you rebecca

358
00:13:40,560 --> 00:13:42,639
hello everyone i am roland grill and i

359
00:13:42,639 --> 00:13:43,839
want to show you an efficient

360
00:13:43,839 --> 00:13:46,160
construction of an ncpa secure dual

361
00:13:46,160 --> 00:13:48,720
receiver encryption scheme

362
00:13:48,720 --> 00:13:51,120
we built our scheme on three assumptions

363
00:13:51,120 --> 00:13:53,839
the first assumption is that random

364
00:13:53,839 --> 00:13:55,839
irreducible binary gopa codes are

365
00:13:55,839 --> 00:13:57,839
indistinguishable from random linear

366
00:13:57,839 --> 00:13:58,959
codes

367
00:13:58,959 --> 00:14:00,800
the second assumption is that random

368
00:14:00,800 --> 00:14:03,199
linear codes are hard to decode

369
00:14:03,199 --> 00:14:04,959
these assumptions are the basis for the

370
00:14:04,959 --> 00:14:07,839
mcles cryptosystem and are also known as

371
00:14:07,839 --> 00:14:09,839
maker lease assumptions

372
00:14:09,839 --> 00:14:11,519
the third assumption is that the

373
00:14:11,519 --> 00:14:12,839
learning parity with noise

374
00:14:12,839 --> 00:14:17,800
distinguishability problem is hard

375
00:14:19,680 --> 00:14:21,680
the main idea of our construction is to

376
00:14:21,680 --> 00:14:23,360
encode the message using a publicly

377
00:14:23,360 --> 00:14:25,680
known gopher code and then mask it using

378
00:14:25,680 --> 00:14:27,680
randomness that is encrypted for both

379
00:14:27,680 --> 00:14:30,560
the sender and the receiver

380
00:14:30,560 --> 00:14:32,399
this construction can be seen as an

381
00:14:32,399 --> 00:14:34,079
augmentation of a construction by

382
00:14:34,079 --> 00:14:35,440
kilzetal

383
00:14:35,440 --> 00:14:37,360
which they published in the work simple

384
00:14:37,360 --> 00:14:39,680
chosen ciphertext security from low

385
00:14:39,680 --> 00:14:41,600
noise lpn

386
00:14:41,600 --> 00:14:44,160
we augment this construction to the dual

387
00:14:44,160 --> 00:14:45,920
receiver setting

388
00:14:45,920 --> 00:14:46,720
by

389
00:14:46,720 --> 00:14:49,040
encrypting the randomness for both

390
00:14:49,040 --> 00:14:50,639
sender and receiver

391
00:14:50,639 --> 00:14:52,800
because copper codes and the mglease

392
00:14:52,800 --> 00:14:54,399
encryption scheme is an important

393
00:14:54,399 --> 00:14:56,480
building block of our construction i

394
00:14:56,480 --> 00:14:58,320
want to start with an overview about

395
00:14:58,320 --> 00:15:02,480
linear codes copper codes and megalis

396
00:15:05,279 --> 00:15:07,760
a linear code can be seen as a matrix

397
00:15:07,760 --> 00:15:09,760
that is multiplicated onto a message

398
00:15:09,760 --> 00:15:13,839
vector to compute a code vector

399
00:15:17,120 --> 00:15:19,279
while linear codes are hard to decode in

400
00:15:19,279 --> 00:15:21,279
general there are classes of linear

401
00:15:21,279 --> 00:15:23,199
codes that yield an efficient decoding

402
00:15:23,199 --> 00:15:24,720
algorithm

403
00:15:24,720 --> 00:15:27,199
one of these classes are irreducible

404
00:15:27,199 --> 00:15:28,959
binary gopa codes

405
00:15:28,959 --> 00:15:31,519
if you know the generating polynom or

406
00:15:31,519 --> 00:15:34,160
know a generator in a specific form the

407
00:15:34,160 --> 00:15:36,240
systematic form there is an efficient

408
00:15:36,240 --> 00:15:38,720
decoding algorithm it is a bit more

409
00:15:38,720 --> 00:15:40,720
complicated than that but for the sake

410
00:15:40,720 --> 00:15:43,279
of priority i won't get into more detail

411
00:15:43,279 --> 00:15:46,399
about decoding copper codes

412
00:15:46,399 --> 00:15:48,240
but despite there being an efficient

413
00:15:48,240 --> 00:15:50,240
decoding algorithm

414
00:15:50,240 --> 00:15:52,399
and this is an important assumption for

415
00:15:52,399 --> 00:15:55,040
the mcalees scripture system a random

416
00:15:55,040 --> 00:15:57,440
copper code is hard to distinguish from

417
00:15:57,440 --> 00:15:59,920
a random linear code if the attacker

418
00:15:59,920 --> 00:16:03,440
does not know the systematic generator

419
00:16:03,440 --> 00:16:05,519
on a high level mac at least works by

420
00:16:05,519 --> 00:16:07,519
using a systematic generator is the

421
00:16:07,519 --> 00:16:08,720
private key

422
00:16:08,720 --> 00:16:09,759
and

423
00:16:09,759 --> 00:16:11,920
scrambling this generator to get a

424
00:16:11,920 --> 00:16:14,320
random generator which does not yield an

425
00:16:14,320 --> 00:16:18,360
efficient decoding algorithm

426
00:16:22,399 --> 00:16:24,240
here we see the public and private keys

427
00:16:24,240 --> 00:16:26,480
of the mcaleese cryptosystem

428
00:16:26,480 --> 00:16:28,800
the matrix g prime is a generator for a

429
00:16:28,800 --> 00:16:30,639
gapper code yielding an efficient

430
00:16:30,639 --> 00:16:33,120
decoding algorithm and the non-singular

431
00:16:33,120 --> 00:16:36,000
matrix s and the permutation matrix p

432
00:16:36,000 --> 00:16:38,320
are used to scramble the generator so

433
00:16:38,320 --> 00:16:41,440
that a generator g can be computed that

434
00:16:41,440 --> 00:16:44,320
can be used to encode messages but not

435
00:16:44,320 --> 00:16:49,800
to efficiently decode code words

436
00:16:53,199 --> 00:16:55,120
to encrypt the message we sample a

437
00:16:55,120 --> 00:16:57,920
random error vector e such that the code

438
00:16:57,920 --> 00:17:00,720
word c can still be decoded

439
00:17:00,720 --> 00:17:02,880
so the error vector e

440
00:17:02,880 --> 00:17:07,280
can't introduce too many errors

441
00:17:08,400 --> 00:17:10,720
to decrypt the ciphertex c we first

442
00:17:10,720 --> 00:17:12,400
multiply it by the inverse of the

443
00:17:12,400 --> 00:17:15,039
permutation matrix p

444
00:17:15,039 --> 00:17:17,280
because the permutation does not change

445
00:17:17,280 --> 00:17:19,520
the hemming weight of a vector the error

446
00:17:19,520 --> 00:17:21,520
vector e times p inverse still

447
00:17:21,520 --> 00:17:23,919
introduces the same amount of errors as

448
00:17:23,919 --> 00:17:26,720
the original error vector e

449
00:17:26,720 --> 00:17:29,200
so we can still decode this code word to

450
00:17:29,200 --> 00:17:30,840
get m times

451
00:17:30,840 --> 00:17:34,559
s now we can multiply multiply the

452
00:17:34,559 --> 00:17:37,120
inverse of the non-singular matrix s to

453
00:17:37,120 --> 00:17:39,600
get the plain text

454
00:17:39,600 --> 00:17:41,840
now that we have seen how megalis works

455
00:17:41,840 --> 00:17:43,760
i can show you how our construction

456
00:17:43,760 --> 00:17:46,760
works

457
00:17:50,400 --> 00:17:52,160
first the preliminaries that are needed

458
00:17:52,160 --> 00:17:54,480
for our construction we need a family of

459
00:17:54,480 --> 00:17:56,880
irreducible binary gopher codes that can

460
00:17:56,880 --> 00:17:59,360
correct up to t errors we then need a

461
00:17:59,360 --> 00:18:01,280
bernoulli distribution to sample error

462
00:18:01,280 --> 00:18:03,600
vectors that introduce up to t errors to

463
00:18:03,600 --> 00:18:04,880
our codewords

464
00:18:04,880 --> 00:18:06,960
finally we need a public copper code

465
00:18:06,960 --> 00:18:09,360
with a public error correcting decoding

466
00:18:09,360 --> 00:18:11,918
algorithm

467
00:18:12,240 --> 00:18:14,320
to generate a key pair we generate a

468
00:18:14,320 --> 00:18:16,960
magnesi key pair and additional random

469
00:18:16,960 --> 00:18:18,400
matrix c

470
00:18:18,400 --> 00:18:20,160
this is later used together with an

471
00:18:20,160 --> 00:18:22,960
error vector to get the masking vector

472
00:18:22,960 --> 00:18:27,640
for the ciphertext code words

473
00:18:29,679 --> 00:18:32,160
to encrypt the message we generate

474
00:18:32,160 --> 00:18:34,559
randomness and encrypt it using the

475
00:18:34,559 --> 00:18:36,400
mclease keys for both sender and

476
00:18:36,400 --> 00:18:37,520
receiver

477
00:18:37,520 --> 00:18:39,520
we then encode the message using the

478
00:18:39,520 --> 00:18:41,760
public copper code and add an error

479
00:18:41,760 --> 00:18:44,320
vector to it and then mask this using

480
00:18:44,320 --> 00:18:46,480
the randomness and the matrix c of the

481
00:18:46,480 --> 00:18:49,120
public key

482
00:18:53,679 --> 00:18:55,679
now for the decryption

483
00:18:55,679 --> 00:18:57,520
we use make a lease decryption to get

484
00:18:57,520 --> 00:18:59,200
the shared randomness s

485
00:18:59,200 --> 00:19:01,440
we verify the consistency by encoding

486
00:19:01,440 --> 00:19:03,679
the decrypted s using the public

487
00:19:03,679 --> 00:19:07,039
michaelis matrix gs of the sender

488
00:19:07,039 --> 00:19:09,280
this should have difference es and the

489
00:19:09,280 --> 00:19:11,440
such have a hamming distance

490
00:19:11,440 --> 00:19:14,559
less than t to cs

491
00:19:14,559 --> 00:19:17,200
if this verification step succeeds we

492
00:19:17,200 --> 00:19:19,200
can use the shared randomness s to

493
00:19:19,200 --> 00:19:22,240
unmask the s time c part of the cipher

494
00:19:22,240 --> 00:19:24,240
text and use the public decoding

495
00:19:24,240 --> 00:19:28,160
algorithm to get the plain text

496
00:19:30,960 --> 00:19:32,640
now we get to the comparisons with

497
00:19:32,640 --> 00:19:34,160
similar schemes

498
00:19:34,160 --> 00:19:36,080
in this table we see the public key and

499
00:19:36,080 --> 00:19:38,720
ciphertext sizes of our construction in

500
00:19:38,720 --> 00:19:41,120
comparison with similar construction by

501
00:19:41,120 --> 00:19:43,840
kills at al and uh i

502
00:19:43,840 --> 00:19:46,080
because these sizes do not mean that

503
00:19:46,080 --> 00:19:49,120
much without inserting realistic numbers

504
00:19:49,120 --> 00:19:50,840
we research common

505
00:19:50,840 --> 00:19:53,440
recommendations for parameters for the

506
00:19:53,440 --> 00:19:57,200
underlying hardness assumptions

507
00:19:59,840 --> 00:20:03,280
here we see realistic public key sizes

508
00:20:03,280 --> 00:20:04,559
for the

509
00:20:04,559 --> 00:20:07,200
three different construction that were

510
00:20:07,200 --> 00:20:09,600
mentioned before

511
00:20:09,600 --> 00:20:11,520
for kill set up we have a public key

512
00:20:11,520 --> 00:20:14,000
size of 77 megabyte

513
00:20:14,000 --> 00:20:16,640
and this estimation is based on the

514
00:20:16,640 --> 00:20:19,840
paper is publicly encrypted based on lpn

515
00:20:19,840 --> 00:20:21,520
practical

516
00:20:21,520 --> 00:20:24,960
for us we have a public key size of 2.5

517
00:20:24,960 --> 00:20:26,640
megabyte

518
00:20:26,640 --> 00:20:29,440
which is based on the estimation from on

519
00:20:29,440 --> 00:20:34,400
solving lpn using bkw and variants

520
00:20:34,400 --> 00:20:36,720
for our work we have a

521
00:20:36,720 --> 00:20:39,280
estimated public key size of 505

522
00:20:39,280 --> 00:20:41,200
kilobyte

523
00:20:41,200 --> 00:20:42,400
and

524
00:20:42,400 --> 00:20:45,200
we use the estimations of the paper in

525
00:20:45,200 --> 00:20:47,440
tacking and defending the megaliths

526
00:20:47,440 --> 00:20:51,520
crypto system by bernstein

527
00:20:53,840 --> 00:20:56,240
now we get to the ncpa security of our

528
00:20:56,240 --> 00:20:58,559
construction these are the assumptions

529
00:20:58,559 --> 00:21:00,080
we need for the security of our

530
00:21:00,080 --> 00:21:02,720
construction as mentioned earlier we use

531
00:21:02,720 --> 00:21:04,720
the assumption that random irreducible

532
00:21:04,720 --> 00:21:07,440
binary gopa codes are indistinguishable

533
00:21:07,440 --> 00:21:09,760
from random linear codes and that random

534
00:21:09,760 --> 00:21:12,400
linear codes are hard to decode

535
00:21:12,400 --> 00:21:15,039
furthermore we rely on the assumption

536
00:21:15,039 --> 00:21:17,440
that learning parity with noise pairs

537
00:21:17,440 --> 00:21:20,559
are hard to distinguish from a uniformly

538
00:21:20,559 --> 00:21:23,840
random distribution

539
00:21:26,640 --> 00:21:28,640
now for overview of our game hopping

540
00:21:28,640 --> 00:21:31,120
proof for the in-cpa security of our

541
00:21:31,120 --> 00:21:32,720
construction

542
00:21:32,720 --> 00:21:35,600
for game one we examine the ncpa game

543
00:21:35,600 --> 00:21:37,120
the ciphertext is the challenge

544
00:21:37,120 --> 00:21:40,000
ciphertext from the ncpa experiment

545
00:21:40,000 --> 00:21:42,000
the indistinguishability assumption for

546
00:21:42,000 --> 00:21:44,400
gopher codes allows us to exchange the

547
00:21:44,400 --> 00:21:47,440
matrices gs and gr with uniform random

548
00:21:47,440 --> 00:21:50,720
matrices us and ur without an attacker

549
00:21:50,720 --> 00:21:52,640
being able to distinguish between these

550
00:21:52,640 --> 00:21:53,679
cases

551
00:21:53,679 --> 00:21:56,000
so game 2 and game 3 are

552
00:21:56,000 --> 00:21:57,520
indistinguishable

553
00:21:57,520 --> 00:22:00,400
from game one

554
00:22:02,799 --> 00:22:06,159
because s times u plus e is an instance

555
00:22:06,159 --> 00:22:07,679
of the learning parity with noise

556
00:22:07,679 --> 00:22:10,640
distinguishing problem we can exchange s

557
00:22:10,640 --> 00:22:13,360
times u plus e with a uniform random

558
00:22:13,360 --> 00:22:17,760
vector u to get game 4.

559
00:22:22,640 --> 00:22:24,880
now we have a code word of the message

560
00:22:24,880 --> 00:22:28,000
xod to a uniformly random vector

561
00:22:28,000 --> 00:22:30,480
this acts as a one-time pad and so our

562
00:22:30,480 --> 00:22:35,320
construction is into cpa secure

563
00:22:40,080 --> 00:22:42,400
to show die soundness we assume that the

564
00:22:42,400 --> 00:22:45,200
verification step fails for one party

565
00:22:45,200 --> 00:22:47,679
but succeeds for the other party

566
00:22:47,679 --> 00:22:49,679
the case where both verification steps

567
00:22:49,679 --> 00:22:52,240
succeed but the decryption results in

568
00:22:52,240 --> 00:22:54,240
different plain text messages is

569
00:22:54,240 --> 00:22:56,480
analogous

570
00:22:56,480 --> 00:22:58,799
the cipher text consists of the three

571
00:22:58,799 --> 00:23:01,679
parts cr cs and c prime

572
00:23:01,679 --> 00:23:03,360
the public keys for both sender and

573
00:23:03,360 --> 00:23:06,720
receiver consist of the public mecalis

574
00:23:06,720 --> 00:23:08,480
matrix

575
00:23:08,480 --> 00:23:12,640
gr respectively gs and the

576
00:23:12,640 --> 00:23:16,880
matrices cr and cs

577
00:23:17,360 --> 00:23:18,880
these are the cipher text of the

578
00:23:18,880 --> 00:23:21,200
supposedly shared randomness s and s

579
00:23:21,200 --> 00:23:23,840
prime

580
00:23:24,080 --> 00:23:26,159
the nonvalid decryption for the receiver

581
00:23:26,159 --> 00:23:28,720
means that the verification step has

582
00:23:28,720 --> 00:23:30,640
failed

583
00:23:30,640 --> 00:23:32,880
this means that the hamming distance

584
00:23:32,880 --> 00:23:34,080
between

585
00:23:34,080 --> 00:23:37,600
s prime gs and cs has to be greater than

586
00:23:37,600 --> 00:23:40,399
or equal to t

587
00:23:42,320 --> 00:23:45,039
because cs is equal to

588
00:23:45,039 --> 00:23:47,279
sgs x or es

589
00:23:47,279 --> 00:23:49,679
we get that the hemming weight of

590
00:23:49,679 --> 00:23:51,279
s prime gs

591
00:23:51,279 --> 00:23:55,279
x or sgs xor es has to be greater than

592
00:23:55,279 --> 00:23:58,080
or equal to t

593
00:23:59,840 --> 00:24:02,480
now because es has a hamming weight

594
00:24:02,480 --> 00:24:04,400
which is less than t

595
00:24:04,400 --> 00:24:07,760
it follows that um

596
00:24:08,159 --> 00:24:10,400
sgs and

597
00:24:10,400 --> 00:24:12,000
s prime gs

598
00:24:12,000 --> 00:24:15,200
have a non-zero hamming distance and so

599
00:24:15,200 --> 00:24:17,360
s and s prime

600
00:24:17,360 --> 00:24:18,640
have to be

601
00:24:18,640 --> 00:24:21,360
non-equal

602
00:24:25,760 --> 00:24:28,640
however because the decryption for the

603
00:24:28,640 --> 00:24:30,640
receiver does not fail we see that the

604
00:24:30,640 --> 00:24:35,039
hemming weight for sgr x or s prime gr x

605
00:24:35,039 --> 00:24:38,640
or er has to be less than t

606
00:24:39,039 --> 00:24:42,320
because s and s prime are not equal

607
00:24:42,320 --> 00:24:46,080
sgr and s prime gr are code words for

608
00:24:46,080 --> 00:24:47,919
different plain text and as such have a

609
00:24:47,919 --> 00:24:53,200
hamming distance greater than 2t plus 1.

610
00:24:55,039 --> 00:24:58,159
but because er is a mecalis error vector

611
00:24:58,159 --> 00:25:00,720
it has a hemming weight less than t

612
00:25:00,720 --> 00:25:03,360
so this contradicts with the inequality

613
00:25:03,360 --> 00:25:06,240
that the hemming weight of sgr x or s

614
00:25:06,240 --> 00:25:11,200
prime gr x or er is less than t

615
00:25:11,200 --> 00:25:13,200
similar considerations will yield that

616
00:25:13,200 --> 00:25:15,039
the case when both the decryption for

617
00:25:15,039 --> 00:25:17,520
the sender and the receiver succeed but

618
00:25:17,520 --> 00:25:20,320
compute different plain text messages is

619
00:25:20,320 --> 00:25:22,159
impossible

620
00:25:22,159 --> 00:25:24,320
now my colleague rebecca schwartz will

621
00:25:24,320 --> 00:25:27,960
continue the talk

622
00:25:28,240 --> 00:25:29,840
thank you roland

623
00:25:29,840 --> 00:25:31,279
time to look at the next part of our

624
00:25:31,279 --> 00:25:32,720
contribution

625
00:25:32,720 --> 00:25:34,400
how can we actually use serialized

626
00:25:34,400 --> 00:25:36,799
secure message transfer from intsbcpa

627
00:25:36,799 --> 00:25:39,200
security

628
00:25:39,200 --> 00:25:40,880
we'll first clarify the involved

629
00:25:40,880 --> 00:25:43,039
functionalities for everyone who is not

630
00:25:43,039 --> 00:25:46,080
intimately familiar with them

631
00:25:46,080 --> 00:25:49,120
both foath and fmsnt are concerned with

632
00:25:49,120 --> 00:25:51,520
authenticated message transmission

633
00:25:51,520 --> 00:25:53,840
i.e a sender hands the functionality a

634
00:25:53,840 --> 00:25:57,120
message m and an intended receiver r

635
00:25:57,120 --> 00:25:59,120
and the functionality hence the message

636
00:25:59,120 --> 00:26:00,640
and the id of the sender to the

637
00:26:00,640 --> 00:26:03,360
receiving party

638
00:26:03,360 --> 00:26:05,840
with f auth both the identities of the

639
00:26:05,840 --> 00:26:07,600
sender and receiver as well as the

640
00:26:07,600 --> 00:26:09,360
message content is handed to the

641
00:26:09,360 --> 00:26:10,480
adversary

642
00:26:10,480 --> 00:26:12,640
the adversary can block messages by not

643
00:26:12,640 --> 00:26:15,120
giving their ok for transmission but

644
00:26:15,120 --> 00:26:17,279
cannot change its content or the parties

645
00:26:17,279 --> 00:26:19,360
involved

646
00:26:19,360 --> 00:26:22,320
in contrast fmsmt does not leak the

647
00:26:22,320 --> 00:26:25,039
message content hence it is very natural

648
00:26:25,039 --> 00:26:27,279
to think of secure message transfer as

649
00:26:27,279 --> 00:26:28,960
adding encryption to authenticated

650
00:26:28,960 --> 00:26:31,120
channels

651
00:26:31,120 --> 00:26:33,279
a further difference for our paper is

652
00:26:33,279 --> 00:26:35,679
that we use a one-time functionality for

653
00:26:35,679 --> 00:26:38,799
f off but a multi-receiver multi-message

654
00:26:38,799 --> 00:26:42,159
multi-sender version of fsmt

655
00:26:42,159 --> 00:26:44,320
note that single message secure message

656
00:26:44,320 --> 00:26:47,120
transfer is easily realized via ncpa

657
00:26:47,120 --> 00:26:50,080
secure encryption but not very practical

658
00:26:50,080 --> 00:26:52,240
as it requires a new setup for every

659
00:26:52,240 --> 00:26:54,640
message

660
00:26:55,760 --> 00:26:57,679
let's see what the protocol looks like

661
00:26:57,679 --> 00:26:59,679
that we use to realize secure message

662
00:26:59,679 --> 00:27:01,600
transfer from authenticated channels and

663
00:27:01,600 --> 00:27:04,559
sender binding encryption

664
00:27:04,559 --> 00:27:06,400
when some party s wants to send a

665
00:27:06,400 --> 00:27:09,279
message m to another party r

666
00:27:09,279 --> 00:27:10,960
they essentially just encrypt this

667
00:27:10,960 --> 00:27:13,600
message by the int sbcpa secure sender

668
00:27:13,600 --> 00:27:15,360
binding encryption scheme

669
00:27:15,360 --> 00:27:17,600
and send the resulting ciphertext over

670
00:27:17,600 --> 00:27:20,240
the authenticated channel

671
00:27:20,240 --> 00:27:22,399
the receiver decrypts the ciphertext and

672
00:27:22,399 --> 00:27:24,080
learns the message

673
00:27:24,080 --> 00:27:26,399
really nothing surprising here

674
00:27:26,399 --> 00:27:28,080
of course there are some details we need

675
00:27:28,080 --> 00:27:30,080
to take care of like key generation and

676
00:27:30,080 --> 00:27:31,840
distribution

677
00:27:31,840 --> 00:27:33,919
we handle this on demand i.e when a

678
00:27:33,919 --> 00:27:35,840
receiver's key is needed but not known

679
00:27:35,840 --> 00:27:38,399
yet the sending party asks them over f

680
00:27:38,399 --> 00:27:40,240
oath to initiate

681
00:27:40,240 --> 00:27:42,320
the receiver generates a new key pair if

682
00:27:42,320 --> 00:27:44,640
they do not have one already

683
00:27:44,640 --> 00:27:46,799
and broadcasts the public key to all

684
00:27:46,799 --> 00:27:51,240
other parties again via authentication

685
00:27:51,440 --> 00:27:53,520
to show that this protocol realizes

686
00:27:53,520 --> 00:27:55,440
secure message transfer we need to

687
00:27:55,440 --> 00:27:58,000
define a simulator s which makes the

688
00:27:58,000 --> 00:28:00,240
ideal world indistinguishable from the

689
00:28:00,240 --> 00:28:03,919
protocol for an environment that

690
00:28:03,919 --> 00:28:06,480
our simulator the grey box basically

691
00:28:06,480 --> 00:28:08,559
simulates the whole protocol as honestly

692
00:28:08,559 --> 00:28:09,919
as possible

693
00:28:09,919 --> 00:28:11,919
so for each honest party in the ideal

694
00:28:11,919 --> 00:28:13,600
world there is an in the head party

695
00:28:13,600 --> 00:28:16,000
which conducts the protocol while in the

696
00:28:16,000 --> 00:28:18,000
head corrupted parties directly hand

697
00:28:18,000 --> 00:28:19,919
through what the environment asks them

698
00:28:19,919 --> 00:28:22,159
to do in the protocol

699
00:28:22,159 --> 00:28:24,799
f auth is played in the head as well

700
00:28:24,799 --> 00:28:27,520
the extra part denoted by behavior

701
00:28:27,520 --> 00:28:29,600
defines how the simulator translates

702
00:28:29,600 --> 00:28:31,760
between in the head honest parties and

703
00:28:31,760 --> 00:28:33,919
corrupted parties interacting with the

704
00:28:33,919 --> 00:28:35,840
functionality

705
00:28:35,840 --> 00:28:40,000
let us clarify this with an example

706
00:28:40,240 --> 00:28:42,640
assume a corrupted party s sends a

707
00:28:42,640 --> 00:28:45,360
message to an honest party r

708
00:28:45,360 --> 00:28:47,679
in this case the environment asks s to

709
00:28:47,679 --> 00:28:50,159
send ici for text c to r

710
00:28:50,159 --> 00:28:52,480
this request is handed through to f auth

711
00:28:52,480 --> 00:28:55,279
which asks that for permission

712
00:28:55,279 --> 00:28:57,440
if permission is granted the ciphertext

713
00:28:57,440 --> 00:28:59,679
is handed to the indie head copy of r

714
00:28:59,679 --> 00:29:01,760
which owns all's keys

715
00:29:01,760 --> 00:29:03,760
remember there are no keys in the ideal

716
00:29:03,760 --> 00:29:05,679
world

717
00:29:05,679 --> 00:29:07,840
in the head r decrypts the ciphertext

718
00:29:07,840 --> 00:29:10,080
according to the protocol and outputs

719
00:29:10,080 --> 00:29:14,399
that is for send message m from party s

720
00:29:14,399 --> 00:29:16,399
with this information the simulator can

721
00:29:16,399 --> 00:29:19,840
now feed fmsmt asking via s to send m to

722
00:29:19,840 --> 00:29:21,520
r

723
00:29:21,520 --> 00:29:23,360
the simulator instantly grants the

724
00:29:23,360 --> 00:29:25,039
request for transmission as the

725
00:29:25,039 --> 00:29:26,960
environment did so as well and the

726
00:29:26,960 --> 00:29:30,399
message is delivered to party r

727
00:29:30,399 --> 00:29:32,799
now assume as a second example that an

728
00:29:32,799 --> 00:29:34,720
honest party s sends a message to

729
00:29:34,720 --> 00:29:37,440
another honest party r

730
00:29:37,440 --> 00:29:39,520
in this case the environment gives s the

731
00:29:39,520 --> 00:29:41,440
message and receiver id

732
00:29:41,440 --> 00:29:43,279
who hands it to the ideal functionality

733
00:29:43,279 --> 00:29:44,720
in turn

734
00:29:44,720 --> 00:29:46,640
the ideal functionality now asks the

735
00:29:46,640 --> 00:29:48,880
simulator for permission to transmit a

736
00:29:48,880 --> 00:29:51,360
message from s to r

737
00:29:51,360 --> 00:29:53,120
to learn whether or not the environment

738
00:29:53,120 --> 00:29:54,799
grants permission for transmission of

739
00:29:54,799 --> 00:29:55,919
the message

740
00:29:55,919 --> 00:29:57,840
the simulator needs to generate the

741
00:29:57,840 --> 00:30:00,159
corresponding request from f auth to the

742
00:30:00,159 --> 00:30:01,760
environment

743
00:30:01,760 --> 00:30:03,679
but in this case it has no way of

744
00:30:03,679 --> 00:30:06,960
learning the content of the message

745
00:30:06,960 --> 00:30:09,360
hence it instead asks in the head party

746
00:30:09,360 --> 00:30:13,520
s to send an all zero message to r

747
00:30:13,520 --> 00:30:16,000
in the head s encrypts the zero message

748
00:30:16,000 --> 00:30:18,720
and asks f off to deliver to r which in

749
00:30:18,720 --> 00:30:20,799
turn prompts the request from f off to

750
00:30:20,799 --> 00:30:22,960
the environment

751
00:30:22,960 --> 00:30:25,440
if permission is granted and in the head

752
00:30:25,440 --> 00:30:27,600
r receives the message the simulator

753
00:30:27,600 --> 00:30:30,000
allows fmsmt to transmit the real

754
00:30:30,000 --> 00:30:31,760
message

755
00:30:31,760 --> 00:30:34,000
note that this case messages between

756
00:30:34,000 --> 00:30:36,399
honest parties is the only case where

757
00:30:36,399 --> 00:30:39,360
the simulator cannot simulate perfectly

758
00:30:39,360 --> 00:30:41,520
and the only difference in this case is

759
00:30:41,520 --> 00:30:43,279
showing the environment and encryption

760
00:30:43,279 --> 00:30:45,440
of zeros rather than an encryption of

761
00:30:45,440 --> 00:30:47,600
the real message

762
00:30:47,600 --> 00:30:49,520
in essence the indistinguishability

763
00:30:49,520 --> 00:30:51,760
between those two cipher texts is what

764
00:30:51,760 --> 00:30:53,520
the employed encryption scheme needs to

765
00:30:53,520 --> 00:30:55,918
provide

766
00:30:56,240 --> 00:30:58,080
i now want to try and give you a rough

767
00:30:58,080 --> 00:31:00,080
idea of the proof

768
00:31:00,080 --> 00:31:02,720
what was it we wanted to prove again

769
00:31:02,720 --> 00:31:05,440
that if we use an in-sp cpi secure spe

770
00:31:05,440 --> 00:31:07,760
scheme as the encryption within protocol

771
00:31:07,760 --> 00:31:08,480
pi

772
00:31:08,480 --> 00:31:10,559
this protocol realizes secure message

773
00:31:10,559 --> 00:31:12,880
transfer which in turn means showing

774
00:31:12,880 --> 00:31:15,440
that the simulator we just had a look at

775
00:31:15,440 --> 00:31:17,519
indeed makes the protocol and ideal

776
00:31:17,519 --> 00:31:19,600
functionality indistinguishable for the

777
00:31:19,600 --> 00:31:22,159
environment set

778
00:31:22,159 --> 00:31:24,480
we now conduct our proof by assuming we

779
00:31:24,480 --> 00:31:26,080
have an environment which does

780
00:31:26,080 --> 00:31:28,240
distinguish between the two and use it

781
00:31:28,240 --> 00:31:30,159
to construct an effective adversary

782
00:31:30,159 --> 00:31:33,840
against the underlying spe scheme

783
00:31:34,320 --> 00:31:36,640
as mentioned before the simulator s

784
00:31:36,640 --> 00:31:39,039
simulates everything perfectly apart

785
00:31:39,039 --> 00:31:41,760
from messages between honest parties

786
00:31:41,760 --> 00:31:43,840
for this case the only difference is

787
00:31:43,840 --> 00:31:45,679
that the environment sees encrypted

788
00:31:45,679 --> 00:31:47,679
zeros instead of an encryption of the

789
00:31:47,679 --> 00:31:50,559
actual messages

790
00:31:50,559 --> 00:31:52,720
we now define a chain of hybrids between

791
00:31:52,720 --> 00:31:54,320
those worlds

792
00:31:54,320 --> 00:31:56,799
in hybrid hk for the first k messages

793
00:31:56,799 --> 00:31:58,799
between honest parties the environment

794
00:31:58,799 --> 00:32:00,799
sees encryptions of zero

795
00:32:00,799 --> 00:32:02,799
for all later messages the encryptions

796
00:32:02,799 --> 00:32:05,200
of the real messages

797
00:32:05,200 --> 00:32:07,120
if there is an environment set which

798
00:32:07,120 --> 00:32:09,600
distinguishes the real and ideal world

799
00:32:09,600 --> 00:32:12,159
there has to exist at least one k such

800
00:32:12,159 --> 00:32:14,240
there is an environment zk which

801
00:32:14,240 --> 00:32:16,080
distinguishes the two consecutive

802
00:32:16,080 --> 00:32:20,000
hybrids h k and h k minus 1.

803
00:32:20,000 --> 00:32:22,000
for this environment only the encryption

804
00:32:22,000 --> 00:32:25,440
of the case message differs

805
00:32:25,440 --> 00:32:28,480
this difference the message mk and 0

806
00:32:28,480 --> 00:32:30,559
is used as the two challenge messages

807
00:32:30,559 --> 00:32:33,919
for the sbe adversary we construct

808
00:32:33,919 --> 00:32:35,840
the resulting challenge ciphertext is

809
00:32:35,840 --> 00:32:37,760
shown to zk

810
00:32:37,760 --> 00:32:40,320
if zk now determines it is in the real

811
00:32:40,320 --> 00:32:42,960
world the sbe adversary answers that the

812
00:32:42,960 --> 00:32:46,000
challenge ciphertext encrypts mk

813
00:32:46,000 --> 00:32:48,559
conversely if zk answers with ideal

814
00:32:48,559 --> 00:32:52,399
world the sbe adversary hands back zero

815
00:32:52,399 --> 00:32:54,799
this way we get an sbe adversary with

816
00:32:54,799 --> 00:32:57,360
non-negligible success probability which

817
00:32:57,360 --> 00:33:00,080
concludes our proof

818
00:33:00,080 --> 00:33:02,559
as the last part of our contribution we

819
00:33:02,559 --> 00:33:04,799
want to talk about how our new security

820
00:33:04,799 --> 00:33:06,880
notion fits into the landscape of prior

821
00:33:06,880 --> 00:33:09,440
game-based security notions

822
00:33:09,440 --> 00:33:11,919
we compared ourselves to classic pke as

823
00:33:11,919 --> 00:33:14,480
well as tb inertions

824
00:33:14,480 --> 00:33:16,640
note that in both cases there's some

825
00:33:16,640 --> 00:33:18,720
slight interpretation necessary to make

826
00:33:18,720 --> 00:33:21,039
the settings comparable

827
00:33:21,039 --> 00:33:23,440
subject to the we think very intuitive

828
00:33:23,440 --> 00:33:25,600
interpretation we chose the only

829
00:33:25,600 --> 00:33:28,480
relationship to pke notions is that

830
00:33:28,480 --> 00:33:31,440
spcpa security implies classic cpa

831
00:33:31,440 --> 00:33:32,559
security

832
00:33:32,559 --> 00:33:36,000
while there are no other implications

833
00:33:36,000 --> 00:33:38,080
the connection to dbe notions is a bit

834
00:33:38,080 --> 00:33:40,720
stronger as the only assumption there is

835
00:33:40,720 --> 00:33:42,880
that the respective text base is at

836
00:33:42,880 --> 00:33:47,360
least as large as the number of parties

837
00:33:47,519 --> 00:33:50,480
the weakest prior tbe notions were atec

838
00:33:50,480 --> 00:33:53,039
and stack weak cca

839
00:33:53,039 --> 00:33:55,279
in our paper we weakened those notions

840
00:33:55,279 --> 00:33:58,240
further to arrive at g-techweak cca

841
00:33:58,240 --> 00:34:01,039
which we then derived as bcpa from

842
00:34:01,039 --> 00:34:03,120
i will briefly explain the differences

843
00:34:03,120 --> 00:34:06,799
between the three tbe notions

844
00:34:06,799 --> 00:34:09,280
each of them has the usual setup

845
00:34:09,280 --> 00:34:11,520
the challenger generates a key pair

846
00:34:11,520 --> 00:34:13,760
hence the public key to the adversary

847
00:34:13,760 --> 00:34:16,320
their oracle faces the adversary chooses

848
00:34:16,320 --> 00:34:19,359
the challenge messages and so on

849
00:34:19,359 --> 00:34:21,520
the differences now lie in when and by

850
00:34:21,520 --> 00:34:23,520
whom the challenge tag is chosen and

851
00:34:23,520 --> 00:34:26,719
what the oracle provides

852
00:34:26,719 --> 00:34:29,599
for adaptive tech week cca the tag is

853
00:34:29,599 --> 00:34:31,119
chosen together with the challenge

854
00:34:31,119 --> 00:34:33,199
messages by the adversary

855
00:34:33,199 --> 00:34:35,199
the second oracle phase does not provide

856
00:34:35,199 --> 00:34:38,719
any decryptions for the challenge tag

857
00:34:38,719 --> 00:34:41,199
for selective tech week cca the attack

858
00:34:41,199 --> 00:34:43,520
is chosen by the adversary as well but

859
00:34:43,520 --> 00:34:45,599
at the start of the protocol before they

860
00:34:45,599 --> 00:34:47,440
learn the public key

861
00:34:47,440 --> 00:34:49,599
now both oracle phases exclude the

862
00:34:49,599 --> 00:34:52,159
challenge tag

863
00:34:52,159 --> 00:34:54,560
for given tech week cca the tech is

864
00:34:54,560 --> 00:34:56,639
randomly chosen by the challenger and

865
00:34:56,639 --> 00:34:58,320
handed to the adversary together with

866
00:34:58,320 --> 00:35:00,160
the public key

867
00:35:00,160 --> 00:35:02,320
both oracles again exclude the challenge

868
00:35:02,320 --> 00:35:04,079
tag

869
00:35:04,079 --> 00:35:06,000
from this it should be easy to see the

870
00:35:06,000 --> 00:35:07,839
implications between the three tbe

871
00:35:07,839 --> 00:35:10,160
notions as the adversary gets less power

872
00:35:10,160 --> 00:35:14,240
moving up and less oracle access

873
00:35:14,320 --> 00:35:16,240
identifying the text base with sender

874
00:35:16,240 --> 00:35:19,520
ids sp cpa is very similar to gtech weak

875
00:35:19,520 --> 00:35:20,880
cca

876
00:35:20,880 --> 00:35:23,280
there is a second key pair i.e the keys

877
00:35:23,280 --> 00:35:25,760
of the challenge tag id and a second tag

878
00:35:25,760 --> 00:35:28,880
ie the receiver id drawn at the start

879
00:35:28,880 --> 00:35:30,880
and the oracles are further restricted

880
00:35:30,880 --> 00:35:32,560
in that they now do not allow

881
00:35:32,560 --> 00:35:36,000
description for either of the known tags

882
00:35:36,000 --> 00:35:38,079
now although these implications all seem

883
00:35:38,079 --> 00:35:40,560
straightforward and a bit boring there

884
00:35:40,560 --> 00:35:42,800
is an actual benefit here

885
00:35:42,800 --> 00:35:45,280
atec weak cca was already previously

886
00:35:45,280 --> 00:35:47,760
used to construct smt via authenticated

887
00:35:47,760 --> 00:35:49,200
channels

888
00:35:49,200 --> 00:35:52,320
aztec weak cca was as well but only with

889
00:35:52,320 --> 00:35:55,760
a detour via cca2 security

890
00:35:55,760 --> 00:35:58,160
with our work it is now obvious that

891
00:35:58,160 --> 00:36:00,800
aztec weak cca itself is already enough

892
00:36:00,800 --> 00:36:02,800
to get smt without the need for further

893
00:36:02,800 --> 00:36:05,680
encryption constructions

894
00:36:05,680 --> 00:36:07,520
to conclude let's recap what we have

895
00:36:07,520 --> 00:36:09,359
seen in this talk

896
00:36:09,359 --> 00:36:10,800
finding an encryption scheme to

897
00:36:10,800 --> 00:36:12,720
construct secure message transfer from

898
00:36:12,720 --> 00:36:14,800
authenticated channels is a common

899
00:36:14,800 --> 00:36:16,160
problem

900
00:36:16,160 --> 00:36:18,560
it was previously solved by taking an

901
00:36:18,560 --> 00:36:21,760
rcc a secure pke or a weak cca secure

902
00:36:21,760 --> 00:36:23,280
tbe scheme

903
00:36:23,280 --> 00:36:25,040
but both of these notions are

904
00:36:25,040 --> 00:36:27,839
unnecessarily strong

905
00:36:27,839 --> 00:36:29,680
we developed a new type of encryption

906
00:36:29,680 --> 00:36:32,079
scheme which unifies prior approaches

907
00:36:32,079 --> 00:36:34,000
and a corresponding security notion

908
00:36:34,000 --> 00:36:36,240
which is weaker than prior notions in an

909
00:36:36,240 --> 00:36:38,560
intuitive sense

910
00:36:38,560 --> 00:36:40,640
this notion can be generically obtained

911
00:36:40,640 --> 00:36:43,040
by various transformations

912
00:36:43,040 --> 00:36:45,680
together with our new doe construction

913
00:36:45,680 --> 00:36:48,160
this generic transformations yield more

914
00:36:48,160 --> 00:36:51,599
efficiency than prior smt solutions

915
00:36:51,599 --> 00:36:53,760
we then proceeded to prove spcpa

916
00:36:53,760 --> 00:36:55,599
security to be strong enough to

917
00:36:55,599 --> 00:36:57,680
serialize smt from authenticated

918
00:36:57,680 --> 00:36:58,640
channels

919
00:36:58,640 --> 00:37:01,280
and provided a classification of sbcpa

920
00:37:01,280 --> 00:37:03,680
security within the current landscape of

921
00:37:03,680 --> 00:37:05,920
other game-based notions

922
00:37:05,920 --> 00:37:08,079
thank you for listening to our talk and

923
00:37:08,079 --> 00:37:12,359
i hope you have fun with our paper

