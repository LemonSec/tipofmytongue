1
00:00:02,399 --> 00:00:05,120
hello and thank you for showing interest

2
00:00:05,120 --> 00:00:08,000
in our research my name is dylan martz

3
00:00:08,000 --> 00:00:10,480
and i'll be presenting common work with

4
00:00:10,480 --> 00:00:13,599
my colleagues jose maria bermudo

5
00:00:13,599 --> 00:00:16,000
and schumann karma car and assam

6
00:00:16,000 --> 00:00:18,160
soleimanian on

7
00:00:18,160 --> 00:00:20,800
efficient lattice-based inner product

8
00:00:20,800 --> 00:00:23,840
functional encryption

9
00:00:24,640 --> 00:00:27,199
let's start with some basics

10
00:00:27,199 --> 00:00:29,840
function encryption introduced by

11
00:00:29,840 --> 00:00:32,960
sahayan waters in 2005

12
00:00:32,960 --> 00:00:35,600
can be seen as a generalization of

13
00:00:35,600 --> 00:00:37,760
public key encryption

14
00:00:37,760 --> 00:00:39,360
where we have a

15
00:00:39,360 --> 00:00:42,239
say trusted third party being able to

16
00:00:42,239 --> 00:00:44,879
produce public keys

17
00:00:44,879 --> 00:00:48,559
that enable an encrypter say alice in

18
00:00:48,559 --> 00:00:50,320
our case

19
00:00:50,320 --> 00:00:53,920
to encrypt message x using the public

20
00:00:53,920 --> 00:00:55,440
key

21
00:00:55,440 --> 00:00:59,359
and independent of that the trusted

22
00:00:59,359 --> 00:01:02,320
third party is able to produce

23
00:01:02,320 --> 00:01:05,280
functional keys depending on a function

24
00:01:05,280 --> 00:01:06,479
f

25
00:01:06,479 --> 00:01:08,720
that can be distributed to a decrypter

26
00:01:08,720 --> 00:01:10,320
say say bob

27
00:01:10,320 --> 00:01:13,680
who can with the functional key

28
00:01:13,680 --> 00:01:17,360
decrypt from the encryption of message x

29
00:01:17,360 --> 00:01:20,159
a function f of x

30
00:01:20,159 --> 00:01:23,280
so in some sense the decrypter is able

31
00:01:23,280 --> 00:01:27,520
to do computation on encrypted message

32
00:01:27,520 --> 00:01:31,439
and decrypt only the result of this

33
00:01:31,439 --> 00:01:34,240
of this function

34
00:01:34,240 --> 00:01:37,040
notice the similarity with homomorphic

35
00:01:37,040 --> 00:01:38,720
encryption

36
00:01:38,720 --> 00:01:41,840
which also enables computing on

37
00:01:41,840 --> 00:01:43,680
encrypted data

38
00:01:43,680 --> 00:01:46,880
but usually there the result is returned

39
00:01:46,880 --> 00:01:48,720
back to encrypter

40
00:01:48,720 --> 00:01:50,560
in this case in the case of function

41
00:01:50,560 --> 00:01:51,759
encryption

42
00:01:51,759 --> 00:01:54,799
the decrypter should be able to decrypt

43
00:01:54,799 --> 00:01:57,759
only the result

44
00:01:58,479 --> 00:02:00,240
let's try to understand what it means

45
00:02:00,240 --> 00:02:02,320
for a function encryption scheme to be

46
00:02:02,320 --> 00:02:04,159
secure

47
00:02:04,159 --> 00:02:07,040
the security notion is usually modeled

48
00:02:07,040 --> 00:02:10,000
as a in distinguishability game

49
00:02:10,000 --> 00:02:13,280
where adversary submits to messages say

50
00:02:13,280 --> 00:02:15,200
x0 and x1

51
00:02:15,200 --> 00:02:18,239
and the challenger encrypts one of them

52
00:02:18,239 --> 00:02:21,040
the adversary shouldn't be able to

53
00:02:21,040 --> 00:02:25,040
tell which message was encrypted

54
00:02:25,040 --> 00:02:27,120
but the challenge here is in in

55
00:02:27,120 --> 00:02:29,360
functional encryption

56
00:02:29,360 --> 00:02:31,360
that the challenge that the adversary

57
00:02:31,360 --> 00:02:33,440
shouldn't be able to distinguish the

58
00:02:33,440 --> 00:02:34,720
message

59
00:02:34,720 --> 00:02:36,480
even if he or she

60
00:02:36,480 --> 00:02:39,920
has access to functional encryption keys

61
00:02:39,920 --> 00:02:42,480
with this limitation that that he or she

62
00:02:42,480 --> 00:02:44,400
can ask only for function encryption

63
00:02:44,400 --> 00:02:46,640
keys for functions that do not

64
00:02:46,640 --> 00:02:49,840
distinguish messages itself so only for

65
00:02:49,840 --> 00:02:52,879
functions f such that f of x0 is equal

66
00:02:52,879 --> 00:02:55,760
to f of x1

67
00:02:55,760 --> 00:02:57,440
there is a slight difference between

68
00:02:57,440 --> 00:02:59,519
selective and adaptive security where

69
00:02:59,519 --> 00:03:03,120
the adaptive security is a bit stricter

70
00:03:03,120 --> 00:03:06,879
demanding that the adversary cannot

71
00:03:06,879 --> 00:03:08,560
submit

72
00:03:08,560 --> 00:03:12,640
messages x0x1 even after

73
00:03:12,640 --> 00:03:14,319
he or she observed

74
00:03:14,319 --> 00:03:19,319
the public parameters and public keys

75
00:03:20,319 --> 00:03:22,400
there has been quite a lot of research

76
00:03:22,400 --> 00:03:24,400
done already in the field of functional

77
00:03:24,400 --> 00:03:26,080
encryption and there are many

78
00:03:26,080 --> 00:03:29,680
interesting results and constructions

79
00:03:29,680 --> 00:03:32,239
there are designs for functional

80
00:03:32,239 --> 00:03:34,319
encryption schemes for arbitrary

81
00:03:34,319 --> 00:03:35,680
functions

82
00:03:35,680 --> 00:03:38,799
but unfortunately as it was shown

83
00:03:38,799 --> 00:03:42,239
constructing such such such schemes is

84
00:03:42,239 --> 00:03:44,360
equivalent to

85
00:03:44,360 --> 00:03:46,959
indistinguishability for obfuscation

86
00:03:46,959 --> 00:03:49,920
constructing which is known to be quite

87
00:03:49,920 --> 00:03:52,159
hard and even though there were quite

88
00:03:52,159 --> 00:03:54,640
major breakthroughs recently

89
00:03:54,640 --> 00:03:57,200
uh they still remain

90
00:03:57,200 --> 00:03:58,840
a bit

91
00:03:58,840 --> 00:04:02,080
impractical for this reason a subfield

92
00:04:02,080 --> 00:04:04,400
emerged starting with

93
00:04:04,400 --> 00:04:07,280
abdallah at all in 2015

94
00:04:07,280 --> 00:04:09,200
focusing on

95
00:04:09,200 --> 00:04:11,599
providing functional encryption schemes

96
00:04:11,599 --> 00:04:14,640
that have some limited functionality

97
00:04:14,640 --> 00:04:15,519
but

98
00:04:15,519 --> 00:04:18,798
designing these schemes had efficiency

99
00:04:18,798 --> 00:04:21,440
in mind so they tried to provide schemes

100
00:04:21,440 --> 00:04:23,840
that they could that could be practical

101
00:04:23,840 --> 00:04:26,880
and implemented

102
00:04:26,880 --> 00:04:29,759
in particular uh schemes for inner

103
00:04:29,759 --> 00:04:32,479
product so linear functions were were

104
00:04:32,479 --> 00:04:35,759
designed and also quadratic functions

105
00:04:35,759 --> 00:04:37,040
uh based on

106
00:04:37,040 --> 00:04:39,919
well-established assumptions such as ddh

107
00:04:39,919 --> 00:04:43,040
dcr and lwe

108
00:04:43,040 --> 00:04:45,199
furthermore they were extended to

109
00:04:45,199 --> 00:04:48,320
multi-client setting in decentralized or

110
00:04:48,320 --> 00:04:50,240
centralized way

111
00:04:50,240 --> 00:04:52,720
meaning that multiple increa encryptors

112
00:04:52,720 --> 00:04:54,639
can provide

113
00:04:54,639 --> 00:04:58,080
cipher text and also with a function

114
00:04:58,080 --> 00:05:01,120
function hiding property

115
00:05:01,120 --> 00:05:04,320
so in this context our work

116
00:05:04,320 --> 00:05:05,600
improves

117
00:05:05,600 --> 00:05:08,320
this line of line of work where we want

118
00:05:08,320 --> 00:05:10,960
to wanted to provide efficient and

119
00:05:10,960 --> 00:05:14,479
practical rink lwe based

120
00:05:14,479 --> 00:05:16,000
so quantumly secure functional

121
00:05:16,000 --> 00:05:18,880
encryption scheme for in a inner product

122
00:05:18,880 --> 00:05:21,680
and we do so with selective and also

123
00:05:21,680 --> 00:05:24,080
adaptive security

124
00:05:24,080 --> 00:05:26,639
so in particular we improve

125
00:05:26,639 --> 00:05:28,800
results on

126
00:05:28,800 --> 00:05:31,199
inner product function encryption

127
00:05:31,199 --> 00:05:34,080
schemes based on lwe

128
00:05:34,080 --> 00:05:37,680
and we do this transition to ring lwe

129
00:05:37,680 --> 00:05:40,880
setting because we really wanted to

130
00:05:40,880 --> 00:05:43,280
provide schemes that can be considered

131
00:05:43,280 --> 00:05:44,720
practical

132
00:05:44,720 --> 00:05:46,160
since uh

133
00:05:46,160 --> 00:05:49,840
the practicality of existing lwe schemes

134
00:05:49,840 --> 00:05:52,960
as i will try to argue later are still

135
00:05:52,960 --> 00:05:55,520
quite quite limited

136
00:05:55,520 --> 00:05:58,400
to provide these results we need to

137
00:05:58,400 --> 00:06:01,039
prove some new results on lattices as i

138
00:06:01,039 --> 00:06:03,039
will tell you later

139
00:06:03,039 --> 00:06:06,240
and additionally to to make the schemes

140
00:06:06,240 --> 00:06:08,479
even more practical we provide also

141
00:06:08,479 --> 00:06:11,360
compiler to decentralized identity based

142
00:06:11,360 --> 00:06:13,280
multi-client inner product functional

143
00:06:13,280 --> 00:06:14,800
encryption

144
00:06:14,800 --> 00:06:17,639
and an quite highly optimized

145
00:06:17,639 --> 00:06:20,400
implementation uh

146
00:06:20,400 --> 00:06:21,759
showing

147
00:06:21,759 --> 00:06:26,160
our claims on on efficiency

148
00:06:26,319 --> 00:06:28,080
an inner product functional encryption

149
00:06:28,080 --> 00:06:31,039
scheme should support encrypting vectors

150
00:06:31,039 --> 00:06:33,039
say x in our case

151
00:06:33,039 --> 00:06:36,000
and deriving function encryption keys

152
00:06:36,000 --> 00:06:39,360
based on some other vectors say y

153
00:06:39,360 --> 00:06:42,560
that enable you to decrypt an inner

154
00:06:42,560 --> 00:06:44,240
product of

155
00:06:44,240 --> 00:06:46,240
x and y

156
00:06:46,240 --> 00:06:48,080
of course having such a function

157
00:06:48,080 --> 00:06:49,919
encryption key

158
00:06:49,919 --> 00:06:52,960
the idea how ringglwe based in a

159
00:06:52,960 --> 00:06:54,160
functional encryption scheme is

160
00:06:54,160 --> 00:06:57,599
constructed is similar to other existing

161
00:06:57,599 --> 00:06:59,360
inner product functional encryption

162
00:06:59,360 --> 00:07:00,400
schemes

163
00:07:00,400 --> 00:07:02,240
and also can be seen as a natural

164
00:07:02,240 --> 00:07:04,000
generalization of

165
00:07:04,000 --> 00:07:07,039
of a wrinkle we based public key

166
00:07:07,039 --> 00:07:08,880
encryption

167
00:07:08,880 --> 00:07:11,599
the main idea is to produce

168
00:07:11,599 --> 00:07:14,400
public keys that can be seen as

169
00:07:14,400 --> 00:07:17,599
ring lwe samples

170
00:07:17,599 --> 00:07:18,960
recall that

171
00:07:18,960 --> 00:07:22,240
we obtain such samples by sampling

172
00:07:22,240 --> 00:07:25,120
some values say a uniformity at random

173
00:07:25,120 --> 00:07:26,880
from some ring usually ring of

174
00:07:26,880 --> 00:07:28,880
polynomial which is the case in our

175
00:07:28,880 --> 00:07:31,440
scheme as well and some

176
00:07:31,440 --> 00:07:34,319
secret and noise values

177
00:07:34,319 --> 00:07:36,240
usually sampled from some small

178
00:07:36,240 --> 00:07:38,479
distribution such as gaussian

179
00:07:38,479 --> 00:07:41,120
distribution

180
00:07:41,120 --> 00:07:43,840
to encrypt in our function function

181
00:07:43,840 --> 00:07:46,800
encryption scheme uh one does

182
00:07:46,800 --> 00:07:48,800
the same as

183
00:07:48,800 --> 00:07:50,319
uh it's done in

184
00:07:50,319 --> 00:07:53,840
ring lwe based public key encryption

185
00:07:53,840 --> 00:07:58,800
um but just uh we said we encrypt

186
00:07:58,800 --> 00:08:01,039
coordinates of the vector that we want

187
00:08:01,039 --> 00:08:03,840
so values x i

188
00:08:03,840 --> 00:08:05,039
uh

189
00:08:05,039 --> 00:08:07,759
each one with a separate public key that

190
00:08:07,759 --> 00:08:10,160
we produced um

191
00:08:10,160 --> 00:08:12,400
above

192
00:08:12,400 --> 00:08:15,199
the point is here also that a shared

193
00:08:15,199 --> 00:08:18,080
randomness needs needs to be used

194
00:08:18,080 --> 00:08:19,440
uh

195
00:08:19,440 --> 00:08:22,319
so the values that the random values

196
00:08:22,319 --> 00:08:24,479
that are used across

197
00:08:24,479 --> 00:08:25,840
all these

198
00:08:25,840 --> 00:08:27,520
ciphertext values

199
00:08:27,520 --> 00:08:29,919
are are shared

200
00:08:29,919 --> 00:08:33,039
to generate a functional encryption key

201
00:08:33,039 --> 00:08:35,679
one uses the fact that

202
00:08:35,679 --> 00:08:38,640
wrinkle wv public key encryption scheme

203
00:08:38,640 --> 00:08:41,039
is key homomorphic

204
00:08:41,039 --> 00:08:44,159
so a functional key is produced as a

205
00:08:44,159 --> 00:08:47,040
linear combination of

206
00:08:47,040 --> 00:08:49,519
secret keys with respect to

207
00:08:49,519 --> 00:08:50,560
two

208
00:08:50,560 --> 00:08:52,160
coefficients

209
00:08:52,160 --> 00:08:53,120
of

210
00:08:53,120 --> 00:08:55,120
of vector y

211
00:08:55,120 --> 00:08:57,200
finally to decrypt

212
00:08:57,200 --> 00:09:00,800
an inner product one uses the ciphertext

213
00:09:00,800 --> 00:09:04,800
homomorphic property of wrinkle we

214
00:09:04,800 --> 00:09:07,040
and evaluates

215
00:09:07,040 --> 00:09:08,640
uh

216
00:09:08,640 --> 00:09:11,600
as it was in a standard way which

217
00:09:11,600 --> 00:09:15,040
results in in some value

218
00:09:15,040 --> 00:09:16,959
plus some noise

219
00:09:16,959 --> 00:09:19,519
and because we obtained this noise as it

220
00:09:19,519 --> 00:09:22,080
is standard that the values that were

221
00:09:22,080 --> 00:09:25,839
encrypted were also a bit scaled so this

222
00:09:25,839 --> 00:09:27,440
scaling

223
00:09:27,440 --> 00:09:29,680
of then the result

224
00:09:29,680 --> 00:09:35,000
helps us to to eliminate the noise

225
00:09:36,399 --> 00:09:38,160
let's see what are the main challenges

226
00:09:38,160 --> 00:09:41,680
improving security of such schemes

227
00:09:41,680 --> 00:09:43,519
as previously mentioned the main

228
00:09:43,519 --> 00:09:44,800
challenge in

229
00:09:44,800 --> 00:09:47,360
function encryption schemes is to prove

230
00:09:47,360 --> 00:09:49,640
that encryption is still

231
00:09:49,640 --> 00:09:51,760
indistinguishable even knowing

232
00:09:51,760 --> 00:09:54,000
functional keys

233
00:09:54,000 --> 00:09:56,480
and as it turns out in in our case

234
00:09:56,480 --> 00:09:58,480
functional keys reveal a bit more

235
00:09:58,480 --> 00:10:01,839
information about the underlying ring lw

236
00:10:01,839 --> 00:10:02,959
problems

237
00:10:02,959 --> 00:10:05,680
than than desired

238
00:10:05,680 --> 00:10:09,680
maybe going directly to to our scheme

239
00:10:09,680 --> 00:10:11,120
let's first

240
00:10:11,120 --> 00:10:13,519
just assume that that

241
00:10:13,519 --> 00:10:16,000
diversity had no access to functional

242
00:10:16,000 --> 00:10:17,600
keys

243
00:10:17,600 --> 00:10:20,880
then one could simply argue that values

244
00:10:20,880 --> 00:10:22,880
in in public keys

245
00:10:22,880 --> 00:10:24,480
sampled in this way

246
00:10:24,480 --> 00:10:25,680
could be

247
00:10:25,680 --> 00:10:29,120
seen as ring lwe samples and one could

248
00:10:29,120 --> 00:10:31,600
then argue that they can be replaced by

249
00:10:31,600 --> 00:10:33,440
the hardness of

250
00:10:33,440 --> 00:10:36,240
wrinkle we problem with the uniform

251
00:10:36,240 --> 00:10:38,399
random ones since the adversary could

252
00:10:38,399 --> 00:10:41,920
not distinguish this this change

253
00:10:41,920 --> 00:10:43,920
and then in the next step also these

254
00:10:43,920 --> 00:10:46,000
values here

255
00:10:46,000 --> 00:10:48,160
could also be replaced by uniformly

256
00:10:48,160 --> 00:10:50,160
random sampled ones

257
00:10:50,160 --> 00:10:53,120
uh and having

258
00:10:53,120 --> 00:10:55,760
such values then they

259
00:10:55,760 --> 00:10:59,920
they they hide statistically height the

260
00:10:59,920 --> 00:11:01,839
the message

261
00:11:01,839 --> 00:11:03,839
but since the adversary has some

262
00:11:03,839 --> 00:11:05,760
information about

263
00:11:05,760 --> 00:11:08,000
secret secret values

264
00:11:08,000 --> 00:11:09,120
uh

265
00:11:09,120 --> 00:11:10,959
some known directly through it through

266
00:11:10,959 --> 00:11:11,680
the

267
00:11:11,680 --> 00:11:12,560
uh

268
00:11:12,560 --> 00:11:14,079
through the secret to through the

269
00:11:14,079 --> 00:11:18,000
functional keys but some also

270
00:11:18,000 --> 00:11:19,279
uh uh

271
00:11:19,279 --> 00:11:21,600
are leaked through through the noise in

272
00:11:21,600 --> 00:11:24,399
the the decryption one cannot simply

273
00:11:24,399 --> 00:11:25,519
replace

274
00:11:25,519 --> 00:11:27,600
this and these values

275
00:11:27,600 --> 00:11:30,560
with uniformly random ones

276
00:11:30,560 --> 00:11:32,959
but nevertheless a similar strategy can

277
00:11:32,959 --> 00:11:34,640
be employed

278
00:11:34,640 --> 00:11:37,920
and with a bit of resampling and also a

279
00:11:37,920 --> 00:11:39,920
bit of rewriting the

280
00:11:39,920 --> 00:11:43,360
the cipher text one can still

281
00:11:43,360 --> 00:11:45,760
replace

282
00:11:45,760 --> 00:11:47,279
these values and actually also these

283
00:11:47,279 --> 00:11:48,480
values

284
00:11:48,480 --> 00:11:50,480
with some other values that

285
00:11:50,480 --> 00:11:53,600
statistically hide all the information

286
00:11:53,600 --> 00:11:56,000
that could be used for distinguishing

287
00:11:56,000 --> 00:11:58,480
which message was encrypted

288
00:11:58,480 --> 00:12:00,160
but to do so

289
00:12:00,160 --> 00:12:03,360
one arrives to the following problem

290
00:12:03,360 --> 00:12:06,320
that we call multi-hint extended ring

291
00:12:06,320 --> 00:12:09,279
lwe problem

292
00:12:09,279 --> 00:12:12,480
recall that uh a standard ring lwe

293
00:12:12,480 --> 00:12:14,639
problem asks to

294
00:12:14,639 --> 00:12:16,160
distinguish for

295
00:12:16,160 --> 00:12:19,519
say a and u uniformly sampled values

296
00:12:19,519 --> 00:12:22,399
from from some ring of polynomials uh

297
00:12:22,399 --> 00:12:27,040
and some s and e uh uh also sampled uh

298
00:12:27,040 --> 00:12:29,200
from from ring polynomials but from some

299
00:12:29,200 --> 00:12:30,880
small distribution usually gaussian

300
00:12:30,880 --> 00:12:32,639
distribution

301
00:12:32,639 --> 00:12:35,839
uh so the the wrinkle w problem asks to

302
00:12:35,839 --> 00:12:39,120
distinguish uh this pair from from from

303
00:12:39,120 --> 00:12:41,440
uniformly some uniformly at random

304
00:12:41,440 --> 00:12:42,720
sampled

305
00:12:42,720 --> 00:12:43,920
pair

306
00:12:43,920 --> 00:12:46,800
in the multi-hint extended ring lwe

307
00:12:46,800 --> 00:12:49,279
problem we have a similar situation we

308
00:12:49,279 --> 00:12:51,839
want to distinguish

309
00:12:51,839 --> 00:12:54,160
values from these values but

310
00:12:54,160 --> 00:12:57,200
additionally we are given some some

311
00:12:57,200 --> 00:12:58,480
some hints

312
00:12:58,480 --> 00:13:00,800
that reveal some information about the

313
00:13:00,800 --> 00:13:04,480
secret and and the noise term in the

314
00:13:04,480 --> 00:13:07,600
in the ring lwe sample

315
00:13:07,600 --> 00:13:09,760
and what we were able to do we were able

316
00:13:09,760 --> 00:13:12,079
to prove that if one

317
00:13:12,079 --> 00:13:14,000
increases uh

318
00:13:14,000 --> 00:13:16,639
the the starting distribution

319
00:13:16,639 --> 00:13:21,240
of the noise and and secret

320
00:13:21,600 --> 00:13:24,079
one can still argue that uh with this a

321
00:13:24,079 --> 00:13:25,839
bit increased

322
00:13:25,839 --> 00:13:30,160
distribution uh that these hints

323
00:13:30,160 --> 00:13:32,800
do not reveal

324
00:13:32,800 --> 00:13:35,839
enough information uh to to to

325
00:13:35,839 --> 00:13:38,240
distinguish uh the values in particular

326
00:13:38,240 --> 00:13:41,199
one can can uh um

327
00:13:41,199 --> 00:13:44,399
one can uh transfer the hardness of

328
00:13:44,399 --> 00:13:47,600
uh um this problem to to the to the

329
00:13:47,600 --> 00:13:49,839
hardness of the original

330
00:13:49,839 --> 00:13:53,760
uh ring lwe problem

331
00:13:53,760 --> 00:13:57,680
and this allows us to to uh

332
00:13:57,680 --> 00:14:01,440
to rewrite uh so to to change

333
00:14:01,440 --> 00:14:03,839
um

334
00:14:04,160 --> 00:14:07,680
to change the ciphertext um

335
00:14:07,680 --> 00:14:10,000
sampling by the challenger in in an

336
00:14:10,000 --> 00:14:12,880
indistinguishable way for the adversary

337
00:14:12,880 --> 00:14:15,519
uh actually we can use this this trick

338
00:14:15,519 --> 00:14:18,560
twice in in our proof which uh

339
00:14:18,560 --> 00:14:20,399
simplifies and gives a bit better

340
00:14:20,399 --> 00:14:24,560
parameters in comparison to the

341
00:14:24,720 --> 00:14:27,040
to the lwe

342
00:14:27,040 --> 00:14:28,720
proof which also

343
00:14:28,720 --> 00:14:32,399
used a multi-hint well extended lwe

344
00:14:32,399 --> 00:14:35,279
problem in in their case but in their

345
00:14:35,279 --> 00:14:37,279
case this is not enough and and

346
00:14:37,279 --> 00:14:40,639
additional tricks need to be uh employed

347
00:14:40,639 --> 00:14:42,800
uh so our proof

348
00:14:42,800 --> 00:14:46,639
is a bit a bit simpler

349
00:14:47,040 --> 00:14:49,600
nevertheless using only hardness of

350
00:14:49,600 --> 00:14:52,560
multi-hint extended ring lwe problem we

351
00:14:52,560 --> 00:14:55,519
were not able to prove adaptive security

352
00:14:55,519 --> 00:14:57,199
of our scheme

353
00:14:57,199 --> 00:15:00,000
so what we needed to do is modify

354
00:15:00,000 --> 00:15:01,920
the scheme slightly

355
00:15:01,920 --> 00:15:04,560
particularly sampling public keys since

356
00:15:04,560 --> 00:15:07,519
th these are the ones that adversary can

357
00:15:07,519 --> 00:15:09,920
observe before

358
00:15:09,920 --> 00:15:12,320
submitting messages in the adaptive

359
00:15:12,320 --> 00:15:14,800
security game

360
00:15:14,800 --> 00:15:17,680
and we modified them in with a trick

361
00:15:17,680 --> 00:15:20,959
that was also used in lwe

362
00:15:20,959 --> 00:15:24,160
based function encryption schemes

363
00:15:24,160 --> 00:15:25,760
in particular

364
00:15:25,760 --> 00:15:28,959
replace it with values sampled like this

365
00:15:28,959 --> 00:15:30,800
uh where we sample

366
00:15:30,800 --> 00:15:32,800
values aj

367
00:15:32,800 --> 00:15:34,480
shared across

368
00:15:34,480 --> 00:15:37,279
across public keys uniformly at random

369
00:15:37,279 --> 00:15:41,040
and secret values s i j

370
00:15:41,040 --> 00:15:45,040
from some small gaussian distribution

371
00:15:45,040 --> 00:15:48,000
what one can argue is that

372
00:15:48,000 --> 00:15:50,000
value samples like this

373
00:15:50,000 --> 00:15:53,440
are indistinguishable from random

374
00:15:53,440 --> 00:15:55,839
by a statistical argument

375
00:15:55,839 --> 00:15:58,560
so not depending on the hardness of

376
00:15:58,560 --> 00:16:01,040
underlying ring lw problem or something

377
00:16:01,040 --> 00:16:03,439
like that

378
00:16:03,680 --> 00:16:05,440
these arguments are usually known as

379
00:16:05,440 --> 00:16:08,160
leftover hash lemma and our reasonably

380
00:16:08,160 --> 00:16:09,680
standard

381
00:16:09,680 --> 00:16:12,320
thing in lwe setting

382
00:16:12,320 --> 00:16:15,040
in ring lwe settings there are also

383
00:16:15,040 --> 00:16:16,880
results

384
00:16:16,880 --> 00:16:21,360
showing that this kind of values are are

385
00:16:21,360 --> 00:16:23,839
in indistinguishable from random

386
00:16:23,839 --> 00:16:26,399
uh some quite general results some also

387
00:16:26,399 --> 00:16:28,880
a bit more specific what we did is we

388
00:16:28,880 --> 00:16:30,880
took these results and a bit polished

389
00:16:30,880 --> 00:16:33,440
them to fit our purpose

390
00:16:33,440 --> 00:16:36,000
uh to to have as

391
00:16:36,000 --> 00:16:38,959
efficient scheme as possible so to to

392
00:16:38,959 --> 00:16:41,279
get a bit better parameters

393
00:16:41,279 --> 00:16:44,560
then they are suggested in say the most

394
00:16:44,560 --> 00:16:46,079
general

395
00:16:46,079 --> 00:16:48,480
general results

396
00:16:48,480 --> 00:16:50,480
uh what is also interesting in the ring

397
00:16:50,480 --> 00:16:53,600
setting is that

398
00:16:53,600 --> 00:16:56,000
uh this m value here

399
00:16:56,000 --> 00:16:57,839
uh that

400
00:16:57,839 --> 00:17:00,560
also tells us how big the

401
00:17:00,560 --> 00:17:03,120
the public keys public parameters will

402
00:17:03,120 --> 00:17:04,720
be

403
00:17:04,720 --> 00:17:07,119
does not need to be

404
00:17:07,119 --> 00:17:10,640
too big in the lwe setting

405
00:17:10,640 --> 00:17:13,760
so the matrix setting

406
00:17:13,760 --> 00:17:15,839
it must be quite big

407
00:17:15,839 --> 00:17:16,880
but

408
00:17:16,880 --> 00:17:20,400
here it can be see constant for a bit

409
00:17:20,400 --> 00:17:21,439
depends but

410
00:17:21,439 --> 00:17:23,760
how you want to choose parameters but it

411
00:17:23,760 --> 00:17:26,559
does not grow

412
00:17:27,039 --> 00:17:28,960
let's say linearly with n or something

413
00:17:28,960 --> 00:17:30,880
like that

414
00:17:30,880 --> 00:17:33,120
and having public keys uh uh

415
00:17:33,120 --> 00:17:34,720
statistically indistinguishable from

416
00:17:34,720 --> 00:17:35,919
random

417
00:17:35,919 --> 00:17:37,679
uh one can then use

418
00:17:37,679 --> 00:17:39,919
some standard arguments uh with

419
00:17:39,919 --> 00:17:41,760
complexity leveraging

420
00:17:41,760 --> 00:17:43,840
to to argue

421
00:17:43,840 --> 00:17:47,360
that a similar proof as it was in

422
00:17:47,360 --> 00:17:50,480
a selective case so also using a

423
00:17:50,480 --> 00:17:53,840
multi-hint extended ring lwe problem but

424
00:17:53,840 --> 00:17:57,280
a bit in a slightly different way

425
00:17:57,280 --> 00:17:59,520
one can lift a proof

426
00:17:59,520 --> 00:18:00,640
uh

427
00:18:00,640 --> 00:18:03,440
this proof to to adaptive security

428
00:18:03,440 --> 00:18:05,440
without losing

429
00:18:05,440 --> 00:18:07,360
much on on

430
00:18:07,360 --> 00:18:10,479
security assumptions

431
00:18:11,840 --> 00:18:15,120
so what are the benefits of ring lwe

432
00:18:15,120 --> 00:18:16,720
setting

433
00:18:16,720 --> 00:18:18,240
well um

434
00:18:18,240 --> 00:18:22,559
rink lwe allows us as said to simplify

435
00:18:22,559 --> 00:18:24,960
the proofs arriving to a bit better

436
00:18:24,960 --> 00:18:27,679
parameters in the end and we did really

437
00:18:27,679 --> 00:18:29,840
carefully craft these parameters to not

438
00:18:29,840 --> 00:18:30,799
lose

439
00:18:30,799 --> 00:18:35,120
efficiency uh for for too much

440
00:18:35,120 --> 00:18:37,200
on the other hand uh

441
00:18:37,200 --> 00:18:39,360
ring settings allows some faster

442
00:18:39,360 --> 00:18:41,039
operations

443
00:18:41,039 --> 00:18:42,960
due to the fact that multiplying

444
00:18:42,960 --> 00:18:45,440
polynomials is is a bit faster than

445
00:18:45,440 --> 00:18:47,600
multiplying well it can be a bit faster

446
00:18:47,600 --> 00:18:51,280
than multiplying matrices with vectors

447
00:18:51,280 --> 00:18:54,000
uh and this is uh for example reflected

448
00:18:54,000 --> 00:18:56,799
in this table where we compare with two

449
00:18:56,799 --> 00:19:00,559
known lwe based

450
00:19:01,200 --> 00:19:03,520
the lwe based inner product functional

451
00:19:03,520 --> 00:19:06,000
schemes where

452
00:19:06,000 --> 00:19:09,120
procedures like setup and

453
00:19:09,120 --> 00:19:10,480
an encryption

454
00:19:10,480 --> 00:19:13,919
has this factor of n times log n which

455
00:19:13,919 --> 00:19:16,559
is um asymptotically

456
00:19:16,559 --> 00:19:17,360
what

457
00:19:17,360 --> 00:19:20,080
what's the cost of multiplying uh two

458
00:19:20,080 --> 00:19:23,760
polynomials while for multiplying matrix

459
00:19:23,760 --> 00:19:26,000
with uh with a vector we have

460
00:19:26,000 --> 00:19:27,520
terms uh

461
00:19:27,520 --> 00:19:28,720
n square

462
00:19:28,720 --> 00:19:29,600
uh

463
00:19:29,600 --> 00:19:32,960
in setup and encryption as well uh so

464
00:19:32,960 --> 00:19:35,679
there is an improvement here

465
00:19:35,679 --> 00:19:38,400
uh but also uh

466
00:19:38,400 --> 00:19:40,640
in the ring setting we we do have

467
00:19:40,640 --> 00:19:42,160
smaller keys

468
00:19:42,160 --> 00:19:47,360
since uh in in lwe settings we we

469
00:19:47,360 --> 00:19:49,440
need to have quite big

470
00:19:49,440 --> 00:19:52,960
matrices to to ensure security

471
00:19:52,960 --> 00:19:55,600
in particular uh for example for public

472
00:19:55,600 --> 00:19:56,640
key

473
00:19:56,640 --> 00:20:00,320
we have this uh factors of n square log

474
00:20:00,320 --> 00:20:02,480
q square

475
00:20:02,480 --> 00:20:04,799
in both

476
00:20:04,799 --> 00:20:07,520
in both lwe uh schemes

477
00:20:07,520 --> 00:20:10,480
while in wrinkle double e we have only n

478
00:20:10,480 --> 00:20:15,120
times log q uh factor so uh a huge

479
00:20:15,120 --> 00:20:17,520
improvement well which might not seem on

480
00:20:17,520 --> 00:20:20,799
on paper as much but it turns out that

481
00:20:20,799 --> 00:20:21,760
if

482
00:20:21,760 --> 00:20:24,400
uh one implements uh

483
00:20:24,400 --> 00:20:26,799
such a scheme uh for

484
00:20:26,799 --> 00:20:28,960
say vectors of uh

485
00:20:28,960 --> 00:20:31,200
reasonably big uh

486
00:20:31,200 --> 00:20:33,440
length it turns out that then the public

487
00:20:33,440 --> 00:20:36,320
keys in the case of uh

488
00:20:36,320 --> 00:20:39,440
lwe can be even measured in gigabytes

489
00:20:39,440 --> 00:20:42,320
while in ring lwe they are only

490
00:20:42,320 --> 00:20:44,000
megabytes uh

491
00:20:44,000 --> 00:20:46,960
of size so a drastic

492
00:20:46,960 --> 00:20:49,360
improvement

493
00:20:49,360 --> 00:20:51,039
there is another

494
00:20:51,039 --> 00:20:54,480
advantage which could be important for

495
00:20:54,480 --> 00:20:57,120
many applications

496
00:20:57,120 --> 00:21:00,480
and that is that ring setting allows to

497
00:21:00,480 --> 00:21:03,039
encrypt values

498
00:21:03,039 --> 00:21:06,720
in one cipher text in in parallel

499
00:21:06,720 --> 00:21:09,039
this is a well-known phenomenon that is

500
00:21:09,039 --> 00:21:10,640
also used in

501
00:21:10,640 --> 00:21:13,280
homophilic encryption

502
00:21:13,280 --> 00:21:14,240
so in

503
00:21:14,240 --> 00:21:16,640
in our case it means that we are able to

504
00:21:16,640 --> 00:21:19,600
encrypt not just one vector but uh

505
00:21:19,600 --> 00:21:21,760
maybe thousands of vectors

506
00:21:21,760 --> 00:21:24,880
uh in one cipher text without

507
00:21:24,880 --> 00:21:28,480
losing uh much in the performance

508
00:21:28,480 --> 00:21:30,400
actually uh um

509
00:21:30,400 --> 00:21:33,200
a really really small addition here

510
00:21:33,200 --> 00:21:35,120
um

511
00:21:35,120 --> 00:21:38,000
and and this way uh then on decrypting

512
00:21:38,000 --> 00:21:40,960
uh not decrypting just just one value

513
00:21:40,960 --> 00:21:45,360
but uh doing a kind of uh simd type of

514
00:21:45,360 --> 00:21:48,799
calculation so in parallel decrypting uh

515
00:21:48,799 --> 00:21:51,440
thousands of

516
00:21:51,440 --> 00:21:54,880
values of evaluation of some function

517
00:21:54,880 --> 00:21:58,919
in our case inner product

518
00:21:59,520 --> 00:22:02,960
as pointed out we provided an efficient

519
00:22:02,960 --> 00:22:06,000
implementation of our scheme

520
00:22:06,000 --> 00:22:08,960
and i will let my colleague schumann

521
00:22:08,960 --> 00:22:11,440
explain to you what were the problems

522
00:22:11,440 --> 00:22:16,799
and solutions in implementing our scheme

523
00:22:16,880 --> 00:22:18,720
we need to perform very large polynomial

524
00:22:18,720 --> 00:22:21,120
multiplications for our scheme we choose

525
00:22:21,120 --> 00:22:23,039
our primes such that they support

526
00:22:23,039 --> 00:22:24,720
efficient polynomial multiplication

527
00:22:24,720 --> 00:22:26,720
using number theoretic transform and

528
00:22:26,720 --> 00:22:28,480
fast modular reduction

529
00:22:28,480 --> 00:22:30,159
we also need large fields for

530
00:22:30,159 --> 00:22:32,000
correctness of our scheme

531
00:22:32,000 --> 00:22:34,240
we split our large primes using chinese

532
00:22:34,240 --> 00:22:36,480
remainder theorem into smaller primes

533
00:22:36,480 --> 00:22:38,480
and perform individual multiplication

534
00:22:38,480 --> 00:22:41,039
using smaller primes we provide a full

535
00:22:41,039 --> 00:22:42,320
residual number system based

536
00:22:42,320 --> 00:22:45,039
implementation using crt

537
00:22:45,039 --> 00:22:47,200
finally as the length of our polynomials

538
00:22:47,200 --> 00:22:49,280
can be very large the rearrangement

539
00:22:49,280 --> 00:22:51,840
steps after entity or inverse entity can

540
00:22:51,840 --> 00:22:54,720
be very costly to avoid this we combine

541
00:22:54,720 --> 00:22:57,200
quickly entity and gentleman sunday

542
00:22:57,200 --> 00:22:58,799
inverse entity

543
00:22:58,799 --> 00:23:01,120
for security we also need samples from

544
00:23:01,120 --> 00:23:03,280
very large gaussian distributions

545
00:23:03,280 --> 00:23:06,159
we achieve this using two steps first we

546
00:23:06,159 --> 00:23:08,559
generate samples from a gaussian

547
00:23:08,559 --> 00:23:10,640
distribution with small and fixed

548
00:23:10,640 --> 00:23:13,120
standard deviation second we combine the

549
00:23:13,120 --> 00:23:15,360
samples from the small distribution to

550
00:23:15,360 --> 00:23:17,520
generate samples from arbitrarily large

551
00:23:17,520 --> 00:23:19,280
gaussian distribution

552
00:23:19,280 --> 00:23:21,039
we perform both of these steps in

553
00:23:21,039 --> 00:23:23,120
constant time to remove any adverse

554
00:23:23,120 --> 00:23:27,280
effect of any timing attacks

555
00:23:28,480 --> 00:23:30,480
here are our parameters for our

556
00:23:30,480 --> 00:23:32,960
implementations we provide parameters

557
00:23:32,960 --> 00:23:34,480
for three different levels of post

558
00:23:34,480 --> 00:23:37,039
quantum security we also provide the set

559
00:23:37,039 --> 00:23:39,919
of crt primes for each level of security

560
00:23:39,919 --> 00:23:41,679
the implementation is available at the

561
00:23:41,679 --> 00:23:45,360
above mentioned github repository

562
00:23:47,840 --> 00:23:49,840
thank you

563
00:23:49,840 --> 00:23:51,840
to better understand what these

564
00:23:51,840 --> 00:23:54,240
performance numbers mean we also

565
00:23:54,240 --> 00:23:57,039
implemented some simple use case to

566
00:23:57,039 --> 00:23:59,360
demonstrate how our

567
00:23:59,360 --> 00:24:01,360
scheme can be used

568
00:24:01,360 --> 00:24:02,480
we

569
00:24:02,480 --> 00:24:04,880
showed how to use some simple machine

570
00:24:04,880 --> 00:24:08,240
learning on encrypted data in particular

571
00:24:08,240 --> 00:24:09,679
we wanted to

572
00:24:09,679 --> 00:24:12,480
do simple machine learning on encrypted

573
00:24:12,480 --> 00:24:14,320
images

574
00:24:14,320 --> 00:24:16,400
images can be seen as

575
00:24:16,400 --> 00:24:18,080
simply a

576
00:24:18,080 --> 00:24:20,480
vector of pixels

577
00:24:20,480 --> 00:24:23,760
so for each pixel you get one value

578
00:24:23,760 --> 00:24:24,720
and

579
00:24:24,720 --> 00:24:27,600
using our scheme then you can of course

580
00:24:27,600 --> 00:24:28,480
inc

581
00:24:28,480 --> 00:24:29,520
encrypt

582
00:24:29,520 --> 00:24:31,600
encrypt these vectors

583
00:24:31,600 --> 00:24:34,240
what we worked with what is a quite

584
00:24:34,240 --> 00:24:37,200
standard data set in machine learning

585
00:24:37,200 --> 00:24:39,919
known as mnist data set

586
00:24:39,919 --> 00:24:43,440
of handwritten digits so each image

587
00:24:43,440 --> 00:24:44,720
consists of

588
00:24:44,720 --> 00:24:48,720
one digit that has been hand written

589
00:24:48,720 --> 00:24:52,080
the task is to to classify or predict

590
00:24:52,080 --> 00:24:54,720
which which image which digit is in the

591
00:24:54,720 --> 00:24:56,000
image

592
00:24:56,000 --> 00:24:59,200
so using our scheme one can encrypt

593
00:24:59,200 --> 00:25:00,159
these

594
00:25:00,159 --> 00:25:02,360
images this can be seen as

595
00:25:02,360 --> 00:25:06,000
785 dimensional vectors

596
00:25:06,000 --> 00:25:08,880
uh and evaluate a simple machine

597
00:25:08,880 --> 00:25:10,480
learning model

598
00:25:10,480 --> 00:25:13,919
we used logistic regression because uh

599
00:25:13,919 --> 00:25:16,320
it only needs to evaluate linear

600
00:25:16,320 --> 00:25:18,640
functions and we are bound in our skin

601
00:25:18,640 --> 00:25:21,120
to two linear functions

602
00:25:21,120 --> 00:25:23,440
completely one needs to evaluate ten

603
00:25:23,440 --> 00:25:25,679
inner product functions to get ten

604
00:25:25,679 --> 00:25:28,480
predictions for each digit

605
00:25:28,480 --> 00:25:30,720
and

606
00:25:30,960 --> 00:25:33,200
what we observe is that

607
00:25:33,200 --> 00:25:34,919
it takes roughly

608
00:25:34,919 --> 00:25:37,360
381 milliseconds

609
00:25:37,360 --> 00:25:40,159
to to encrypt such an image

610
00:25:40,159 --> 00:25:42,400
and then to to evaluate the machine

611
00:25:42,400 --> 00:25:44,320
learning model that was

612
00:25:44,320 --> 00:25:45,760
learned before

613
00:25:45,760 --> 00:25:47,919
um

614
00:25:47,919 --> 00:25:52,080
it takes only 170 milliseconds so to to

615
00:25:52,080 --> 00:25:54,840
evaluate 10 inner product

616
00:25:54,840 --> 00:25:58,240
functions but notice also that one can

617
00:25:58,240 --> 00:26:00,559
encrypt multiple uh

618
00:26:00,559 --> 00:26:03,279
multiple images in in one cipher text

619
00:26:03,279 --> 00:26:05,200
without increasing the size of the

620
00:26:05,200 --> 00:26:06,559
ciphertext

621
00:26:06,559 --> 00:26:07,679
and

622
00:26:07,679 --> 00:26:09,440
worsening

623
00:26:09,440 --> 00:26:11,760
the the time complexity of it

624
00:26:11,760 --> 00:26:12,640
so

625
00:26:12,640 --> 00:26:14,960
in fact you can encrypt uh

626
00:26:14,960 --> 00:26:17,039
up to 4092

627
00:26:17,039 --> 00:26:19,679
images in parallel in one ciphertext and

628
00:26:19,679 --> 00:26:20,960
then

629
00:26:20,960 --> 00:26:23,919
evaluate the model on all the images

630
00:26:23,919 --> 00:26:25,360
encrypted

631
00:26:25,360 --> 00:26:26,960
simultaneously

632
00:26:26,960 --> 00:26:28,240
without

633
00:26:28,240 --> 00:26:30,559
without worsening this performance

634
00:26:30,559 --> 00:26:32,960
numbers

635
00:26:33,760 --> 00:26:36,640
as a bonus and to make our scheme even

636
00:26:36,640 --> 00:26:40,000
more practical we explain how the scheme

637
00:26:40,000 --> 00:26:41,679
can be

638
00:26:41,679 --> 00:26:43,279
compiled to

639
00:26:43,279 --> 00:26:45,120
multi-client setting

640
00:26:45,120 --> 00:26:47,679
so a setting where we have not just one

641
00:26:47,679 --> 00:26:49,360
encryptor but

642
00:26:49,360 --> 00:26:50,720
many of them

643
00:26:50,720 --> 00:26:54,080
each encrypting their own secret values

644
00:26:54,080 --> 00:26:56,240
secret message

645
00:26:56,240 --> 00:26:59,679
so there are known compilers how to do

646
00:26:59,679 --> 00:27:00,559
that

647
00:27:00,559 --> 00:27:03,520
for example abdallah at all explained it

648
00:27:03,520 --> 00:27:06,000
in 2019

649
00:27:06,000 --> 00:27:09,440
uh what we do here is we argue that our

650
00:27:09,440 --> 00:27:12,159
skin can be used in such compilers and

651
00:27:12,159 --> 00:27:16,000
we even additionally um extend this or

652
00:27:16,000 --> 00:27:18,240
we generalize it to identity based

653
00:27:18,240 --> 00:27:20,399
decentralized setting

654
00:27:20,399 --> 00:27:21,840
so

655
00:27:21,840 --> 00:27:26,399
we uh end up with the scheme where

656
00:27:26,399 --> 00:27:28,399
the the encryptors can in truly

657
00:27:28,399 --> 00:27:31,279
decentralized way without some trusted

658
00:27:31,279 --> 00:27:32,840
setup

659
00:27:32,840 --> 00:27:35,679
um encrypt their values

660
00:27:35,679 --> 00:27:37,840
with some labels

661
00:27:37,840 --> 00:27:40,559
uh and the decrypter that is then able

662
00:27:40,559 --> 00:27:42,880
to decrypt inner product of of these

663
00:27:42,880 --> 00:27:43,919
values

664
00:27:43,919 --> 00:27:47,520
and is not able to to join ciphertext

665
00:27:47,520 --> 00:27:50,159
that were not meant to be joined only

666
00:27:50,159 --> 00:27:53,360
those which correspond to to the same

667
00:27:53,360 --> 00:27:55,360
label

668
00:27:55,360 --> 00:27:58,000
for the conclusion let's recap the

669
00:27:58,000 --> 00:28:01,200
results we presented in this talk

670
00:28:01,200 --> 00:28:04,399
we provided an efficient rink lwe based

671
00:28:04,399 --> 00:28:06,159
inner product functional encryption

672
00:28:06,159 --> 00:28:08,159
schemes with

673
00:28:08,159 --> 00:28:12,080
selective and also adaptive security

674
00:28:12,080 --> 00:28:13,679
we

675
00:28:13,679 --> 00:28:15,120
provide

676
00:28:15,120 --> 00:28:18,080
some new results on lattices needed to

677
00:28:18,080 --> 00:28:21,440
prove security of the mentioned schemes

678
00:28:21,440 --> 00:28:23,919
most importantly multi-hint extended

679
00:28:23,919 --> 00:28:27,039
ring lw problem or the reduction of the

680
00:28:27,039 --> 00:28:29,279
difficulty of this problem to

681
00:28:29,279 --> 00:28:32,480
a standard ring lwe problem

682
00:28:32,480 --> 00:28:34,080
and also a

683
00:28:34,080 --> 00:28:34,880
a

684
00:28:34,880 --> 00:28:37,360
version of leftover hash lemma for rings

685
00:28:37,360 --> 00:28:40,080
that we needed

686
00:28:40,080 --> 00:28:41,600
to make our scheme

687
00:28:41,600 --> 00:28:44,159
more practical we explained how to

688
00:28:44,159 --> 00:28:46,399
compile it to identity based

689
00:28:46,399 --> 00:28:50,159
decentralized multi-client scheme

690
00:28:50,159 --> 00:28:53,360
and provide an implementation quite

691
00:28:53,360 --> 00:28:55,440
optimized implementation

692
00:28:55,440 --> 00:28:58,640
of our scheme with multiple parameters

693
00:28:58,640 --> 00:29:01,200
and security settings

694
00:29:01,200 --> 00:29:04,320
and a simple showcase of how our scheme

695
00:29:04,320 --> 00:29:06,080
can be used

696
00:29:06,080 --> 00:29:08,799
of course all further details can be can

697
00:29:08,799 --> 00:29:10,640
be found in

698
00:29:10,640 --> 00:29:14,320
the paper thank you for your attention

699
00:29:14,320 --> 00:29:15,840
and

700
00:29:15,840 --> 00:29:19,000
see you

