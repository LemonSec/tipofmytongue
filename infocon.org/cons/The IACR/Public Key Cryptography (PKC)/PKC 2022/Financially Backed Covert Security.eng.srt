1
00:00:02,320 --> 00:00:04,319
hello i'm benjamin schlosser and i'm

2
00:00:04,319 --> 00:00:06,240
going to present you the paper financial

3
00:00:06,240 --> 00:00:08,480
backed covert security which is a joint

4
00:00:08,480 --> 00:00:10,960
work sebastian faus kamita zai and david

5
00:00:10,960 --> 00:00:12,240
kressler

6
00:00:12,240 --> 00:00:13,920
this work belongs to the area of

7
00:00:13,920 --> 00:00:16,720
multi-party computation short mpc

8
00:00:16,720 --> 00:00:19,600
mpc in general deals with protocols that

9
00:00:19,600 --> 00:00:22,080
allow distrusting parties to compute

10
00:00:22,080 --> 00:00:24,640
some function on private inputs

11
00:00:24,640 --> 00:00:27,359
and typically we require security

12
00:00:27,359 --> 00:00:29,439
guarantees correctness and privacy to

13
00:00:29,439 --> 00:00:31,599
hold for these protocols

14
00:00:31,599 --> 00:00:33,760
when analyzing the security of protocol

15
00:00:33,760 --> 00:00:35,440
we need to specify

16
00:00:35,440 --> 00:00:37,520
an adversary model there are different

17
00:00:37,520 --> 00:00:40,000
classes of adversaries on the one side

18
00:00:40,000 --> 00:00:42,160
there are semi honest adversaries

19
00:00:42,160 --> 00:00:45,680
these adversaries follows

20
00:00:45,680 --> 00:00:47,680
the protocol description as it is

21
00:00:47,680 --> 00:00:49,600
described

22
00:00:49,600 --> 00:00:51,440
they try to learn additional information

23
00:00:51,440 --> 00:00:53,920
from the interaction with other parties

24
00:00:53,920 --> 00:00:55,520
on the other side there are malicious

25
00:00:55,520 --> 00:00:57,920
adversaries these adversaries may behave

26
00:00:57,920 --> 00:00:59,760
arbitrarily in particular they may

27
00:00:59,760 --> 00:01:02,160
deviate from the protocol description

28
00:01:02,160 --> 00:01:03,840
while security against malicious

29
00:01:03,840 --> 00:01:06,240
adversaries provide a much higher level

30
00:01:06,240 --> 00:01:09,039
of security

31
00:01:09,119 --> 00:01:11,600
semi honestly secure protocols are still

32
00:01:11,600 --> 00:01:13,119
way more efficient

33
00:01:13,119 --> 00:01:14,479
as a middle ground flip between

34
00:01:14,479 --> 00:01:16,799
efficiency and security auman and

35
00:01:16,799 --> 00:01:18,880
lindell proposed security and against

36
00:01:18,880 --> 00:01:20,720
covert adversary

37
00:01:20,720 --> 00:01:23,680
these type of advisory may deviate

38
00:01:23,680 --> 00:01:25,119
arbitrarily from the protocol

39
00:01:25,119 --> 00:01:27,680
description but it is only willing to

40
00:01:27,680 --> 00:01:30,240
cheat if it's not getting caught

41
00:01:30,240 --> 00:01:31,759
let's take a closer look at covert

42
00:01:31,759 --> 00:01:34,400
security a covertly secure protocol

43
00:01:34,400 --> 00:01:36,720
needs to guarantee that if there is some

44
00:01:36,720 --> 00:01:38,479
malicious party that cheats in the

45
00:01:38,479 --> 00:01:41,040
protocol execution then with a fixed

46
00:01:41,040 --> 00:01:43,520
probability called the deterrence factor

47
00:01:43,520 --> 00:01:47,280
epsilon this cheating will be detected

48
00:01:47,280 --> 00:01:50,320
in on the contrary with probability 1

49
00:01:50,320 --> 00:01:52,840
minus epsilon cheating will be

50
00:01:52,840 --> 00:01:55,920
undetected the notion was extended by

51
00:01:55,920 --> 00:01:58,399
asha of andorlandi

52
00:01:58,399 --> 00:02:00,479
with the notion of publicly verifiable

53
00:02:00,479 --> 00:02:03,280
covert security short pvc

54
00:02:03,280 --> 00:02:04,640
here code

55
00:02:04,640 --> 00:02:06,880
the covertly sql protocol is extended by

56
00:02:06,880 --> 00:02:09,679
two algorithm the blame algorithm takes

57
00:02:09,679 --> 00:02:12,160
the view of an honest party as input

58
00:02:12,160 --> 00:02:15,280
after cheating is detected and generates

59
00:02:15,280 --> 00:02:18,080
a certificate this certificate is then

60
00:02:18,080 --> 00:02:21,440
or can then be passed to any third party

61
00:02:21,440 --> 00:02:23,760
which utilizes the judge to verify the

62
00:02:23,760 --> 00:02:26,319
validity of the certificate if it's a

63
00:02:26,319 --> 00:02:28,720
valid certificate then the third party

64
00:02:28,720 --> 00:02:29,680
will be

65
00:02:29,680 --> 00:02:31,760
convinced about misbehavior of the

66
00:02:31,760 --> 00:02:34,160
corrupted party

67
00:02:34,160 --> 00:02:37,760
the definition of pvc um defines this

68
00:02:37,760 --> 00:02:40,160
judge algorithm as non-interactive this

69
00:02:40,160 --> 00:02:42,000
has the advantage that

70
00:02:42,000 --> 00:02:44,400
the certificate can be sent to any third

71
00:02:44,400 --> 00:02:45,519
party

72
00:02:45,519 --> 00:02:47,200
later on even if the party does not

73
00:02:47,200 --> 00:02:49,519
contribute to the protocol execution at

74
00:02:49,519 --> 00:02:51,280
the beginning

75
00:02:51,280 --> 00:02:54,000
while the intuition of pvc is that due

76
00:02:54,000 --> 00:02:56,800
to the publicly verifiability the

77
00:02:56,800 --> 00:03:00,000
deterrent effect is should be increased

78
00:03:00,000 --> 00:03:01,360
however

79
00:03:01,360 --> 00:03:03,200
we observe that there is a problem in

80
00:03:03,200 --> 00:03:05,360
settings like the internet where party

81
00:03:05,360 --> 00:03:08,239
can hide behind digital identities and

82
00:03:08,239 --> 00:03:11,680
these identities can easily be changed

83
00:03:11,680 --> 00:03:15,680
therefore our goal is to connect

84
00:03:15,680 --> 00:03:17,920
detected cheating directly with

85
00:03:17,920 --> 00:03:20,879
financial punishment

86
00:03:20,879 --> 00:03:23,519
our contribution is threefold first we

87
00:03:23,519 --> 00:03:25,200
present the definition

88
00:03:25,200 --> 00:03:27,120
of our new notion called financial

89
00:03:27,120 --> 00:03:30,720
backed covert security short fbc

90
00:03:30,720 --> 00:03:32,799
then we present construction of fpc

91
00:03:32,799 --> 00:03:34,000
protocols

92
00:03:34,000 --> 00:03:36,319
in total we present

93
00:03:36,319 --> 00:03:38,400
three different or constructions for

94
00:03:38,400 --> 00:03:40,799
three different classes of protocols all

95
00:03:40,799 --> 00:03:42,640
our constructions benefit from very

96
00:03:42,640 --> 00:03:45,680
efficient verification of misbehavior

97
00:03:45,680 --> 00:03:48,400
and as a third aspect we evaluate our

98
00:03:48,400 --> 00:03:50,239
construction and provide benchmark

99
00:03:50,239 --> 00:03:52,080
results

100
00:03:52,080 --> 00:03:54,239
let's start with our notion of financial

101
00:03:54,239 --> 00:03:56,239
background security

102
00:03:56,239 --> 00:03:58,640
here we extend the model that besides

103
00:03:58,640 --> 00:04:00,560
the parties that want to execute some

104
00:04:00,560 --> 00:04:03,519
protocol we have a so-called judge party

105
00:04:03,519 --> 00:04:06,000
let me emphasize that this is different

106
00:04:06,000 --> 00:04:08,640
to the judge algorithm of a pvc protocol

107
00:04:08,640 --> 00:04:11,360
here we have a party that may interact

108
00:04:11,360 --> 00:04:12,560
with other

109
00:04:12,560 --> 00:04:14,959
parties at the beginning

110
00:04:14,959 --> 00:04:17,680
all parties send some coins to this

111
00:04:17,680 --> 00:04:19,918
judge party which

112
00:04:19,918 --> 00:04:23,199
um which are kind of security deposits

113
00:04:23,199 --> 00:04:26,000
then the parties execute come covertly

114
00:04:26,000 --> 00:04:28,720
secure protocol here the judge does not

115
00:04:28,720 --> 00:04:30,479
need to contribute

116
00:04:30,479 --> 00:04:32,400
afterwards

117
00:04:32,400 --> 00:04:34,160
the algorithm can use the blame

118
00:04:34,160 --> 00:04:35,440
algorithm

119
00:04:35,440 --> 00:04:38,320
so each party can each honors party can

120
00:04:38,320 --> 00:04:41,680
execute a claim algorithm for himself

121
00:04:41,680 --> 00:04:44,160
as using his view as an input to check

122
00:04:44,160 --> 00:04:46,400
if the other party was maliciously

123
00:04:46,400 --> 00:04:48,240
during the execution

124
00:04:48,240 --> 00:04:50,320
in case there is no no malicious

125
00:04:50,320 --> 00:04:52,240
behavior detected

126
00:04:52,240 --> 00:04:54,840
the parties execute the so-called punish

127
00:04:54,840 --> 00:04:56,880
protocol which

128
00:04:56,880 --> 00:05:00,000
due to no cheating happened just sends

129
00:05:00,000 --> 00:05:02,560
back the security deposits to the other

130
00:05:02,560 --> 00:05:04,479
parties

131
00:05:04,479 --> 00:05:07,199
to the to the honest parties

132
00:05:07,199 --> 00:05:10,240
so in case there is a malicious party

133
00:05:10,240 --> 00:05:11,120
then

134
00:05:11,120 --> 00:05:13,840
due to covertly secure protocol

135
00:05:13,840 --> 00:05:16,080
the blame algorithm will detect cheating

136
00:05:16,080 --> 00:05:18,160
with a fixed probability in this case

137
00:05:18,160 --> 00:05:20,880
the output of the blame algorithm

138
00:05:20,880 --> 00:05:23,520
will be some certificate that is used as

139
00:05:23,520 --> 00:05:25,919
input to the punishable goal

140
00:05:25,919 --> 00:05:28,479
at the end of the punish protocol

141
00:05:28,479 --> 00:05:29,360
which

142
00:05:29,360 --> 00:05:31,039
might require interaction between the

143
00:05:31,039 --> 00:05:32,800
parties

144
00:05:32,800 --> 00:05:34,160
the

145
00:05:34,160 --> 00:05:36,160
security deposits are only sent back to

146
00:05:36,160 --> 00:05:38,160
the honest parties

147
00:05:38,160 --> 00:05:40,320
the security deposits of the malicious

148
00:05:40,320 --> 00:05:43,039
party will be burnt

149
00:05:43,039 --> 00:05:45,840
we require two security properties

150
00:05:45,840 --> 00:05:48,400
of fpc protocols first one is called

151
00:05:48,400 --> 00:05:51,280
financial accountability it states that

152
00:05:51,280 --> 00:05:54,000
if an honest party detects cheating then

153
00:05:54,000 --> 00:05:56,319
there exists also a corrupted party that

154
00:05:56,319 --> 00:05:58,800
loses its deposit

155
00:05:58,800 --> 00:06:01,199
another the second property is called

156
00:06:01,199 --> 00:06:03,280
financial defamation freeze and state

157
00:06:03,280 --> 00:06:05,840
that the adversary cannot force an

158
00:06:05,840 --> 00:06:09,280
honest party to lose its deposits

159
00:06:09,280 --> 00:06:10,400
for

160
00:06:10,400 --> 00:06:12,000
while these um

161
00:06:12,000 --> 00:06:14,240
security properties are analog to pvc

162
00:06:14,240 --> 00:06:15,680
protocols

163
00:06:15,680 --> 00:06:17,280
we are the first to present format

164
00:06:17,280 --> 00:06:21,840
security games for both properties

165
00:06:22,080 --> 00:06:24,639
we now turn to the question how to

166
00:06:24,639 --> 00:06:26,880
instantiate a judge party

167
00:06:26,880 --> 00:06:29,039
while the definition in general allows

168
00:06:29,039 --> 00:06:31,280
that just a single party act assists

169
00:06:31,280 --> 00:06:32,400
judge

170
00:06:32,400 --> 00:06:34,400
our construction utilize blockchain

171
00:06:34,400 --> 00:06:36,240
technologies

172
00:06:36,240 --> 00:06:38,319
this way instead of putting trust into a

173
00:06:38,319 --> 00:06:39,680
single party

174
00:06:39,680 --> 00:06:41,039
we can

175
00:06:41,039 --> 00:06:43,039
we need to trust the correctness of the

176
00:06:43,039 --> 00:06:45,120
system which is based on its majority

177
00:06:45,120 --> 00:06:46,800
assumption

178
00:06:46,800 --> 00:06:49,199
in addition blockchain technologies have

179
00:06:49,199 --> 00:06:51,360
several advantages

180
00:06:51,360 --> 00:06:52,160
um

181
00:06:52,160 --> 00:06:54,479
several advantages properties

182
00:06:54,479 --> 00:06:56,160
first one is that

183
00:06:56,160 --> 00:06:58,319
most of the blockchain technologies

184
00:06:58,319 --> 00:06:59,759
for most of the blockchain technologies

185
00:06:59,759 --> 00:07:02,560
an integral part is to

186
00:07:02,560 --> 00:07:04,960
to maintain

187
00:07:04,960 --> 00:07:08,000
a ledger where parties possess some

188
00:07:08,000 --> 00:07:10,000
coins and can transfer

189
00:07:10,000 --> 00:07:12,319
these points between them

190
00:07:12,319 --> 00:07:14,800
the second aspect is that many smart

191
00:07:14,800 --> 00:07:16,800
many blockchain technologies allow the

192
00:07:16,800 --> 00:07:19,360
execution of so-called smart contracts

193
00:07:19,360 --> 00:07:22,319
these are small programs which enable

194
00:07:22,319 --> 00:07:26,080
money transfer based on predefined rules

195
00:07:26,080 --> 00:07:27,759
therefore our construction and high

196
00:07:27,759 --> 00:07:30,400
level work that at the at the beginning

197
00:07:30,400 --> 00:07:32,639
the party sent a security deposit to a

198
00:07:32,639 --> 00:07:34,240
smart contract

199
00:07:34,240 --> 00:07:36,160
then the parties execute the quality

200
00:07:36,160 --> 00:07:37,759
secure protocol

201
00:07:37,759 --> 00:07:39,599
next in case there is some cheating

202
00:07:39,599 --> 00:07:42,240
detected

203
00:07:42,240 --> 00:07:43,840
the parties engage in a punished

204
00:07:43,840 --> 00:07:46,160
protocol where alice can use the

205
00:07:46,160 --> 00:07:48,720
certificate as input and if there is

206
00:07:48,720 --> 00:07:49,599
some

207
00:07:49,599 --> 00:07:52,400
was some cheating then only the honest

208
00:07:52,400 --> 00:07:55,280
party gets his money back

209
00:07:55,280 --> 00:07:57,759
here we need to take special care of the

210
00:07:57,759 --> 00:08:01,120
complexity of the punished protocol of

211
00:08:01,120 --> 00:08:03,199
the to be precise of the judge party in

212
00:08:03,199 --> 00:08:07,520
the punished protocol because for every

213
00:08:07,520 --> 00:08:08,560
for every

214
00:08:08,560 --> 00:08:10,080
information that needs to be stored on

215
00:08:10,080 --> 00:08:12,080
the smart contract and every operation

216
00:08:12,080 --> 00:08:13,919
that needs to be executed on the smart

217
00:08:13,919 --> 00:08:16,479
contract we need to pay fees for example

218
00:08:16,479 --> 00:08:20,960
for ethereum we need to pay in gas

219
00:08:21,680 --> 00:08:24,160
before heading to over construction let

220
00:08:24,160 --> 00:08:25,599
me first introduce

221
00:08:25,599 --> 00:08:28,240
or mention an important building block

222
00:08:28,240 --> 00:08:30,400
we use throughout

223
00:08:30,400 --> 00:08:32,799
our construction and this is a merkle

224
00:08:32,799 --> 00:08:33,760
tree

225
00:08:33,760 --> 00:08:37,039
mercury allows to commit to a set of

226
00:08:37,039 --> 00:08:39,360
data chunks here x1

227
00:08:39,360 --> 00:08:41,519
to x8

228
00:08:41,519 --> 00:08:44,640
and the merkle tree root constitutes a

229
00:08:44,640 --> 00:08:47,360
commitment on all of these values

230
00:08:47,360 --> 00:08:48,560
in addition

231
00:08:48,560 --> 00:08:51,760
it's easy or it's efficiently very

232
00:08:51,760 --> 00:08:54,880
sufficiently possible to prove that a

233
00:08:54,880 --> 00:08:57,279
specific data chunk is indeed part of

234
00:08:57,279 --> 00:08:59,920
the mercury to this we create a

235
00:08:59,920 --> 00:09:02,320
so-called merkle proof which consists of

236
00:09:02,320 --> 00:09:04,880
all these hash values there are siblings

237
00:09:04,880 --> 00:09:07,440
of these values that sit on the path

238
00:09:07,440 --> 00:09:09,120
from the data chunk

239
00:09:09,120 --> 00:09:11,440
until the to the

240
00:09:11,440 --> 00:09:13,600
mercury root

241
00:09:13,600 --> 00:09:15,440
so this allows

242
00:09:15,440 --> 00:09:17,040
to create a mercury proof with only

243
00:09:17,040 --> 00:09:19,680
logarithmic many values and where n is

244
00:09:19,680 --> 00:09:22,560
the number of data chunks

245
00:09:22,560 --> 00:09:24,800
so now our first construction yield an

246
00:09:24,800 --> 00:09:27,120
input independent protocol such a

247
00:09:27,120 --> 00:09:28,959
protocol can be used for the offline

248
00:09:28,959 --> 00:09:31,120
phase or the pre-computation phase of

249
00:09:31,120 --> 00:09:33,600
so-called offline online protocols for

250
00:09:33,600 --> 00:09:37,040
example speeds and authenticated goblin

251
00:09:37,040 --> 00:09:37,920
these

252
00:09:37,920 --> 00:09:39,839
offline online protocol works on a high

253
00:09:39,839 --> 00:09:41,440
level that they

254
00:09:41,440 --> 00:09:43,760
use an offline protocol where the

255
00:09:43,760 --> 00:09:45,920
parties only use some random values as

256
00:09:45,920 --> 00:09:47,839
input to set up some correlated

257
00:09:47,839 --> 00:09:49,120
randomness

258
00:09:49,120 --> 00:09:51,360
then this correlated randomness can be

259
00:09:51,360 --> 00:09:53,600
used to speed up the online phase where

260
00:09:53,600 --> 00:09:56,240
the party actually use their inputs to

261
00:09:56,240 --> 00:09:57,839
get the output of the function

262
00:09:57,839 --> 00:10:00,480
evaluation

263
00:10:01,040 --> 00:10:04,320
here the first part is

264
00:10:04,320 --> 00:10:06,640
totally independent of the secret inputs

265
00:10:06,640 --> 00:10:09,519
of the parties we now take a look how

266
00:10:09,519 --> 00:10:12,560
can we construct such an if

267
00:10:12,560 --> 00:10:14,800
we can reconstruct an fvc protocol for

268
00:10:14,800 --> 00:10:17,519
such an input independent protocol

269
00:10:17,519 --> 00:10:20,399
as a starting point we start with a with

270
00:10:20,399 --> 00:10:22,320
a semi honest

271
00:10:22,320 --> 00:10:24,959
version of this online protocol

272
00:10:24,959 --> 00:10:26,880
and then we use the current choose and

273
00:10:26,880 --> 00:10:29,360
barge which means we not execute not

274
00:10:29,360 --> 00:10:30,800
just once the

275
00:10:30,800 --> 00:10:33,040
semi semi-honest offline version offline

276
00:10:33,040 --> 00:10:35,760
protocol we executed several times where

277
00:10:35,760 --> 00:10:38,240
the party uses different

278
00:10:38,240 --> 00:10:40,880
run values as input

279
00:10:40,880 --> 00:10:41,839
then

280
00:10:41,839 --> 00:10:44,320
at the end of the cut and choose in the

281
00:10:44,320 --> 00:10:45,600
opening

282
00:10:45,600 --> 00:10:48,560
phase of cut and choose we open all but

283
00:10:48,560 --> 00:10:50,720
one of these instances

284
00:10:50,720 --> 00:10:53,360
for all the open instances we reveal the

285
00:10:53,360 --> 00:10:55,440
inputs that are used so that we can

286
00:10:55,440 --> 00:10:58,720
verify if the parties

287
00:10:58,880 --> 00:11:01,360
behave correctly in this execution since

288
00:11:01,360 --> 00:11:03,680
we leaked in from the inputs in these

289
00:11:03,680 --> 00:11:05,600
phases we have to throw them away

290
00:11:05,600 --> 00:11:07,600
however there is still one instance left

291
00:11:07,600 --> 00:11:09,519
which can be used for the online

292
00:11:09,519 --> 00:11:11,600
execution

293
00:11:11,600 --> 00:11:14,079
as a next key feature we require that

294
00:11:14,079 --> 00:11:14,800
the

295
00:11:14,800 --> 00:11:17,760
behavior of the partic parties

296
00:11:17,760 --> 00:11:19,760
throughout the protocol execution are

297
00:11:19,760 --> 00:11:22,720
deterministic based on the random values

298
00:11:22,720 --> 00:11:25,680
used as inputs this can easily be

299
00:11:25,680 --> 00:11:28,560
achieved by deriving all random choices

300
00:11:28,560 --> 00:11:31,279
from these random inputs

301
00:11:31,279 --> 00:11:33,839
as a next key feature we require that

302
00:11:33,839 --> 00:11:36,640
the parties sign a public transcript

303
00:11:36,640 --> 00:11:39,519
after the protocol execution but before

304
00:11:39,519 --> 00:11:41,200
the opening phase of the cut and choose

305
00:11:41,200 --> 00:11:43,040
protocol

306
00:11:43,040 --> 00:11:45,839
and as a fourth feature we require that

307
00:11:45,839 --> 00:11:48,880
for all the opening opened instances the

308
00:11:48,880 --> 00:11:50,240
parties

309
00:11:50,240 --> 00:11:53,120
obtain a publicly verifiable initial

310
00:11:53,120 --> 00:11:54,320
state

311
00:11:54,320 --> 00:11:57,440
or publicly verifiable

312
00:11:57,440 --> 00:12:00,160
inputs this can easily be achieved by

313
00:12:00,160 --> 00:12:02,160
first sending signed commitment at the

314
00:12:02,160 --> 00:12:04,720
beginning and then in the opening phase

315
00:12:04,720 --> 00:12:06,720
of the cut and choose the parties

316
00:12:06,720 --> 00:12:09,680
sketched no decommitment values

317
00:12:09,680 --> 00:12:12,079
for the other party's

318
00:12:12,079 --> 00:12:14,000
inputs

319
00:12:14,000 --> 00:12:15,920
all of these key features are already

320
00:12:15,920 --> 00:12:17,360
provided by

321
00:12:17,360 --> 00:12:20,880
known input independent pvc protocols

322
00:12:20,880 --> 00:12:23,120
in particular there exists generic

323
00:12:23,120 --> 00:12:26,079
compilers from simi on security to pvc

324
00:12:26,079 --> 00:12:27,760
security

325
00:12:27,760 --> 00:12:30,240
which also provide these

326
00:12:30,240 --> 00:12:33,519
features so we can directly use such a

327
00:12:33,519 --> 00:12:36,240
pvc protocol and transform it into an

328
00:12:36,240 --> 00:12:39,839
fpc protocol our natural question is is

329
00:12:39,839 --> 00:12:42,160
it just possible to

330
00:12:42,160 --> 00:12:44,480
take the judge algorithm of a pvc

331
00:12:44,480 --> 00:12:48,240
protocol and let it run by the judge

332
00:12:48,240 --> 00:12:52,079
judge party of the fpc protocol to see

333
00:12:52,079 --> 00:12:54,560
the problem with this approach let's

334
00:12:54,560 --> 00:12:56,399
have a closer look at the verification

335
00:12:56,399 --> 00:12:59,920
of just a single instance

336
00:13:00,000 --> 00:13:01,839
so to verify

337
00:13:01,839 --> 00:13:04,160
we start each party starts the protocol

338
00:13:04,160 --> 00:13:06,880
execution within some initial state for

339
00:13:06,880 --> 00:13:08,800
input independent protocols this initial

340
00:13:08,800 --> 00:13:12,720
state just constitutes or exists of the

341
00:13:12,720 --> 00:13:15,200
random value you set input

342
00:13:15,200 --> 00:13:17,040
next all

343
00:13:17,040 --> 00:13:20,160
next behavior in each round can be

344
00:13:20,160 --> 00:13:22,240
computed using some compute round

345
00:13:22,240 --> 00:13:23,360
function

346
00:13:23,360 --> 00:13:25,440
this function takes as input a state of

347
00:13:25,440 --> 00:13:27,600
the previous round together with the set

348
00:13:27,600 --> 00:13:29,440
of messages that were received in the

349
00:13:29,440 --> 00:13:30,720
previous round

350
00:13:30,720 --> 00:13:32,800
since there are no message received

351
00:13:32,800 --> 00:13:35,120
before round one we start with an empty

352
00:13:35,120 --> 00:13:36,079
set

353
00:13:36,079 --> 00:13:38,560
the function computes an updated state

354
00:13:38,560 --> 00:13:40,959
together with a set of messages in this

355
00:13:40,959 --> 00:13:43,440
case only one message that is that are

356
00:13:43,440 --> 00:13:45,839
sent to the other parties

357
00:13:45,839 --> 00:13:48,959
so next they exchange messages and they

358
00:13:48,959 --> 00:13:50,880
actually they perform the same step

359
00:13:50,880 --> 00:13:52,639
again

360
00:13:52,639 --> 00:13:55,279
all random choices that need to be done

361
00:13:55,279 --> 00:13:56,959
in this compute round function can be

362
00:13:56,959 --> 00:13:58,880
derived from the state

363
00:13:58,880 --> 00:14:01,279
so this means that the compute round

364
00:14:01,279 --> 00:14:04,240
function is totally deterministic this

365
00:14:04,240 --> 00:14:07,279
is necessary to

366
00:14:07,279 --> 00:14:10,079
to allow for verification data on

367
00:14:10,079 --> 00:14:12,399
now verification works that given the

368
00:14:12,399 --> 00:14:15,360
stage and all messages that were

369
00:14:15,360 --> 00:14:17,120
received by some party

370
00:14:17,120 --> 00:14:19,519
we can recompute to compute round

371
00:14:19,519 --> 00:14:22,639
function for each round of this party

372
00:14:22,639 --> 00:14:24,720
and then we can compare the message that

373
00:14:24,720 --> 00:14:26,880
were sent during the real protocol

374
00:14:26,880 --> 00:14:29,040
execution with the mesh such as that

375
00:14:29,040 --> 00:14:31,199
should be have been sent

376
00:14:31,199 --> 00:14:34,480
and most of the known pvc protocol in

377
00:14:34,480 --> 00:14:36,800
particular these ones that can be

378
00:14:36,800 --> 00:14:39,440
obtained using the generic compilers

379
00:14:39,440 --> 00:14:40,959
require that the

380
00:14:40,959 --> 00:14:42,720
third party

381
00:14:42,720 --> 00:14:45,839
recomputes the whole protocol execution

382
00:14:45,839 --> 00:14:48,959
um to detect cheating and this is not

383
00:14:48,959 --> 00:14:50,959
plausible for smart contracts because

384
00:14:50,959 --> 00:14:53,279
protocol execution might require too

385
00:14:53,279 --> 00:14:54,160
much

386
00:14:54,160 --> 00:14:57,360
computational effort

387
00:14:57,519 --> 00:14:59,120
so in

388
00:14:59,120 --> 00:15:00,480
instead

389
00:15:00,480 --> 00:15:03,600
we extend we use the same formalization

390
00:15:03,600 --> 00:15:06,880
so we use the compute round function

391
00:15:06,880 --> 00:15:08,800
which on input state and the set of

392
00:15:08,800 --> 00:15:12,000
message compute and updated state and

393
00:15:12,000 --> 00:15:14,880
set of messages and now when alice wants

394
00:15:14,880 --> 00:15:17,199
to send a message to bob

395
00:15:17,199 --> 00:15:19,839
in the first round it sends the message

396
00:15:19,839 --> 00:15:20,880
that is

397
00:15:20,880 --> 00:15:23,600
that is intended to bob together with a

398
00:15:23,600 --> 00:15:25,040
set of hashes

399
00:15:25,040 --> 00:15:27,519
where each message that should

400
00:15:27,519 --> 00:15:29,839
that are sent to some other party is

401
00:15:29,839 --> 00:15:32,240
hashed and then the set of hashes is

402
00:15:32,240 --> 00:15:35,680
given to um to bob this is an explicit

403
00:15:35,680 --> 00:15:38,160
way how to formalize the public

404
00:15:38,160 --> 00:15:41,920
transcript property and finally we add a

405
00:15:41,920 --> 00:15:44,800
commitment on the intermediate states

406
00:15:44,800 --> 00:15:48,079
in the form of a hash of this state

407
00:15:48,079 --> 00:15:50,399
the same is done by bob

408
00:15:50,399 --> 00:15:53,120
and after the last round all the message

409
00:15:53,120 --> 00:15:56,320
hashes are used to compute a merkle tree

410
00:15:56,320 --> 00:15:58,320
as we as we have seen before

411
00:15:58,320 --> 00:16:01,040
and then the parties exchange

412
00:16:01,040 --> 00:16:03,120
um signatures on the roots of these

413
00:16:03,120 --> 00:16:05,519
hashes this is done for the message

414
00:16:05,519 --> 00:16:09,120
hashes as well as for the states

415
00:16:09,120 --> 00:16:11,360
we can order the message and the states

416
00:16:11,360 --> 00:16:14,000
in such a way that um

417
00:16:14,000 --> 00:16:15,040
that the

418
00:16:15,040 --> 00:16:17,680
ordering is unique and all the mess all

419
00:16:17,680 --> 00:16:20,480
the parties sign the same

420
00:16:20,480 --> 00:16:21,440
roots

421
00:16:21,440 --> 00:16:23,600
rules

422
00:16:23,600 --> 00:16:25,519
now what does it help to have these

423
00:16:25,519 --> 00:16:27,120
intermediate

424
00:16:27,120 --> 00:16:30,160
commitments on the intermediate states

425
00:16:30,160 --> 00:16:32,240
so we will now

426
00:16:32,240 --> 00:16:33,680
take a look at

427
00:16:33,680 --> 00:16:36,079
how can bob check if alice behaves

428
00:16:36,079 --> 00:16:38,639
correctly or behaved correctly so bob

429
00:16:38,639 --> 00:16:42,160
knows for all rounds the messages that

430
00:16:42,160 --> 00:16:44,240
were sent by alice to bob together with

431
00:16:44,240 --> 00:16:45,440
the hashes

432
00:16:45,440 --> 00:16:46,560
that was

433
00:16:46,560 --> 00:16:48,079
of the messages that were sent from

434
00:16:48,079 --> 00:16:49,600
alice to some other parties and

435
00:16:49,600 --> 00:16:52,160
intermediate state commitments

436
00:16:52,160 --> 00:16:55,600
in addition it knows signatures on the

437
00:16:55,600 --> 00:16:58,000
roots of the merkle trees over the

438
00:16:58,000 --> 00:17:01,360
hashes the message hashes and the states

439
00:17:01,360 --> 00:17:02,160
and

440
00:17:02,160 --> 00:17:03,600
due to the

441
00:17:03,600 --> 00:17:05,599
publicly verifiable initial state

442
00:17:05,599 --> 00:17:07,199
property we also

443
00:17:07,199 --> 00:17:09,679
have the state the initial state of some

444
00:17:09,679 --> 00:17:12,160
party of all parties

445
00:17:12,160 --> 00:17:15,039
and then bob can recompute all messages

446
00:17:15,039 --> 00:17:16,880
that should have been sent by alice

447
00:17:16,880 --> 00:17:19,359
together with the intermediate states

448
00:17:19,359 --> 00:17:20,959
now let's assume

449
00:17:20,959 --> 00:17:23,119
bob detects a malicious behavior for

450
00:17:23,119 --> 00:17:26,079
example bob detects that alice sent to

451
00:17:26,079 --> 00:17:28,880
some party m in around k an incorrect

452
00:17:28,880 --> 00:17:29,919
message

453
00:17:29,919 --> 00:17:33,840
this means that all messages

454
00:17:33,840 --> 00:17:35,760
before

455
00:17:35,760 --> 00:17:39,760
this this message are correct but then

456
00:17:39,760 --> 00:17:41,679
this is the first message that is

457
00:17:41,679 --> 00:17:44,559
incorrect and this message is also part

458
00:17:44,559 --> 00:17:46,400
of the public transcript

459
00:17:46,400 --> 00:17:48,480
which was

460
00:17:48,480 --> 00:17:51,760
which was signed or which

461
00:17:51,760 --> 00:17:53,760
whether the merkle tree route was signed

462
00:17:53,760 --> 00:17:55,679
by others

463
00:17:55,679 --> 00:17:58,320
now in the punishment protocol bob can

464
00:17:58,320 --> 00:18:00,080
create a certificate and send this one

465
00:18:00,080 --> 00:18:03,440
to the judge where the certificate

466
00:18:03,440 --> 00:18:05,840
contains the signatures

467
00:18:05,840 --> 00:18:08,240
on the commitments on the market on the

468
00:18:08,240 --> 00:18:11,679
message hashes together with the states

469
00:18:11,679 --> 00:18:13,440
so the signature on the

470
00:18:13,440 --> 00:18:16,000
mercury root for the states

471
00:18:16,000 --> 00:18:18,480
the state of the previous round of alice

472
00:18:18,480 --> 00:18:21,360
so of around k minus 1 together with all

473
00:18:21,360 --> 00:18:24,160
messages that were received in round k

474
00:18:24,160 --> 00:18:26,480
minus 1 by alice and the incorrect

475
00:18:26,480 --> 00:18:27,520
message

476
00:18:27,520 --> 00:18:29,679
now the last three

477
00:18:29,679 --> 00:18:32,240
components are all sent together with

478
00:18:32,240 --> 00:18:35,280
merkle proofs these microproofs

479
00:18:35,280 --> 00:18:37,280
show that

480
00:18:37,280 --> 00:18:39,520
the messages and the state are indeed

481
00:18:39,520 --> 00:18:42,400
part of the mercuries that were assigned

482
00:18:42,400 --> 00:18:43,840
by alice

483
00:18:43,840 --> 00:18:45,039
and now

484
00:18:45,039 --> 00:18:46,960
after checking that the signatures and

485
00:18:46,960 --> 00:18:49,679
the mercury merkle proofs are correct

486
00:18:49,679 --> 00:18:52,559
the charge can execute this compute

487
00:18:52,559 --> 00:18:54,840
round function based on the previous

488
00:18:54,840 --> 00:18:57,919
stage so state the state after after

489
00:18:57,919 --> 00:19:00,480
around k minus 1 and the messages that

490
00:19:00,480 --> 00:19:02,880
were received to obtain the messages

491
00:19:02,880 --> 00:19:05,039
that should have been sent by alice in

492
00:19:05,039 --> 00:19:06,160
round k

493
00:19:06,160 --> 00:19:07,919
and finally

494
00:19:07,919 --> 00:19:10,320
the judge can make the make the judge

495
00:19:10,320 --> 00:19:13,200
the the check whether this message is

496
00:19:13,200 --> 00:19:15,440
correct or not so whether whether the

497
00:19:15,440 --> 00:19:19,760
um send message was the right one or not

498
00:19:19,760 --> 00:19:22,720
so let me emphasize that here although

499
00:19:22,720 --> 00:19:24,640
our punishment protocol in general

500
00:19:24,640 --> 00:19:25,600
allows

501
00:19:25,600 --> 00:19:27,760
to be interactive here we have

502
00:19:27,760 --> 00:19:29,679
we can non-interactively send the

503
00:19:29,679 --> 00:19:31,440
certificate

504
00:19:31,440 --> 00:19:32,720
in addition

505
00:19:32,720 --> 00:19:35,120
we just require the judge to compute a

506
00:19:35,120 --> 00:19:38,160
single step of the protocol execution so

507
00:19:38,160 --> 00:19:39,280
this is

508
00:19:39,280 --> 00:19:41,679
way more efficient than most of the

509
00:19:41,679 --> 00:19:42,799
known

510
00:19:42,799 --> 00:19:46,080
pvc protocols

511
00:19:46,240 --> 00:19:48,400
we then have a second construction in

512
00:19:48,400 --> 00:19:51,679
which yields input dependent protocols

513
00:19:51,679 --> 00:19:55,280
and here the parties directly use the

514
00:19:55,280 --> 00:19:57,280
the secret inputs

515
00:19:57,280 --> 00:19:59,520
for the computation so we need to take

516
00:19:59,520 --> 00:20:01,440
special care that the privacy of these

517
00:20:01,440 --> 00:20:03,280
secret inputs

518
00:20:03,280 --> 00:20:05,520
is still guaranteed

519
00:20:05,520 --> 00:20:06,960
for details

520
00:20:06,960 --> 00:20:10,640
i'd like to refer to our paper

521
00:20:10,640 --> 00:20:14,159
so next we had the question so that on

522
00:20:14,159 --> 00:20:16,799
all pvc all known pvc protocol as well

523
00:20:16,799 --> 00:20:19,440
as the construction one and two require

524
00:20:19,440 --> 00:20:22,400
that after the execution

525
00:20:22,400 --> 00:20:25,440
of the cme honest protocols the parties

526
00:20:25,440 --> 00:20:28,159
need to agree on a protocol transcript

527
00:20:28,159 --> 00:20:30,400
so we had to question can we relax on

528
00:20:30,400 --> 00:20:31,840
this requirement

529
00:20:31,840 --> 00:20:34,480
that is can we construct fpc protocols

530
00:20:34,480 --> 00:20:37,360
without any form of public transcript

531
00:20:37,360 --> 00:20:39,520
this would reduce the communication cost

532
00:20:39,520 --> 00:20:41,520
for the honest execution

533
00:20:41,520 --> 00:20:43,760
we answer this question with yes for the

534
00:20:43,760 --> 00:20:45,520
input independent

535
00:20:45,520 --> 00:20:46,480
case

536
00:20:46,480 --> 00:20:50,080
and here we exploit the interactivity of

537
00:20:50,080 --> 00:20:53,360
the punishment protocol

538
00:20:53,360 --> 00:20:55,520
so let me show up this picture again we

539
00:20:55,520 --> 00:20:57,440
had before for the input independent

540
00:20:57,440 --> 00:20:58,400
case

541
00:20:58,400 --> 00:20:59,840
and now

542
00:20:59,840 --> 00:21:01,760
we just removed the public transcript

543
00:21:01,760 --> 00:21:03,760
property

544
00:21:03,760 --> 00:21:05,280
and

545
00:21:05,280 --> 00:21:08,240
yeah we can obtain such a protocol from

546
00:21:08,240 --> 00:21:10,480
taking a pvc protocol with public

547
00:21:10,480 --> 00:21:12,400
transcript and just removing the public

548
00:21:12,400 --> 00:21:14,559
transcript property

549
00:21:14,559 --> 00:21:17,919
now in case we only have two parties um

550
00:21:17,919 --> 00:21:20,480
we always have a common transcript

551
00:21:20,480 --> 00:21:22,480
because messages are either sent or

552
00:21:22,480 --> 00:21:25,039
received so we need to take a look at

553
00:21:25,039 --> 00:21:26,640
more than two parties to see what are

554
00:21:26,640 --> 00:21:28,320
the challenges

555
00:21:28,320 --> 00:21:31,679
so um let me give you this scenario here

556
00:21:31,679 --> 00:21:33,840
here we have an honest execution between

557
00:21:33,840 --> 00:21:36,640
three parties in round k

558
00:21:36,640 --> 00:21:40,320
um alice sends a moth message to bob and

559
00:21:40,320 --> 00:21:42,559
about this message bob learns no

560
00:21:42,559 --> 00:21:44,960
information so no information is given

561
00:21:44,960 --> 00:21:46,880
to charlie about this even not the hash

562
00:21:46,880 --> 00:21:47,840
of it

563
00:21:47,840 --> 00:21:49,840
then in the next round in the round k

564
00:21:49,840 --> 00:21:52,880
plus one bob sends a message to

565
00:21:52,880 --> 00:21:55,120
to charlie

566
00:21:55,120 --> 00:21:57,360
and this message now depends on all

567
00:21:57,360 --> 00:21:59,679
previously received message so also on

568
00:21:59,679 --> 00:22:01,120
the message

569
00:22:01,120 --> 00:22:04,080
sent from alice to bob in round k

570
00:22:04,080 --> 00:22:07,280
now let's assume that alice is malicious

571
00:22:07,280 --> 00:22:10,159
then he might send an incorrect message

572
00:22:10,159 --> 00:22:11,520
in round k

573
00:22:11,520 --> 00:22:14,159
and although

574
00:22:14,159 --> 00:22:16,480
although bob beheads correctly the

575
00:22:16,480 --> 00:22:20,400
message m prime now looks incorrectly

576
00:22:20,400 --> 00:22:22,880
from the point of view of charlie

577
00:22:22,880 --> 00:22:26,159
so how can we prevent that um the

578
00:22:26,159 --> 00:22:28,799
charlie now accuses bob of being

579
00:22:28,799 --> 00:22:31,440
malicious to this

580
00:22:31,440 --> 00:22:33,840
to this end we introduce a two-phase

581
00:22:33,840 --> 00:22:37,200
punish protocol where all parties first

582
00:22:37,200 --> 00:22:38,799
submit

583
00:22:38,799 --> 00:22:40,720
accusations and then only the first

584
00:22:40,720 --> 00:22:42,159
accusation so

585
00:22:42,159 --> 00:22:44,799
um the one that

586
00:22:44,799 --> 00:22:47,360
claims the the earliest message that is

587
00:22:47,360 --> 00:22:48,740
incorrect it will be

588
00:22:48,740 --> 00:22:49,919
[Music]

589
00:22:49,919 --> 00:22:53,120
um will be verified later on so this way

590
00:22:53,120 --> 00:22:54,640
we identify

591
00:22:54,640 --> 00:22:55,440
one

592
00:22:55,440 --> 00:22:57,919
accuser and one blame party

593
00:22:57,919 --> 00:23:00,640
and then the second question is

594
00:23:00,640 --> 00:23:02,720
since we have no publicly signed

595
00:23:02,720 --> 00:23:04,799
transcript how can we provide

596
00:23:04,799 --> 00:23:07,679
information about the messages to to the

597
00:23:07,679 --> 00:23:10,240
judge party and for this

598
00:23:10,240 --> 00:23:12,559
one of the parties first suggests a

599
00:23:12,559 --> 00:23:16,240
message history in case they agree then

600
00:23:16,240 --> 00:23:18,240
we the judge can use this message

601
00:23:18,240 --> 00:23:21,200
history in case they do not agree we use

602
00:23:21,200 --> 00:23:23,760
the so called bisection protocol this

603
00:23:23,760 --> 00:23:26,240
bisection protocol

604
00:23:26,240 --> 00:23:27,919
is an interactive protocol between these

605
00:23:27,919 --> 00:23:29,919
two parties and allow them to narrow

606
00:23:29,919 --> 00:23:32,480
down the disagreement to just a single

607
00:23:32,480 --> 00:23:35,520
message or the first message on which

608
00:23:35,520 --> 00:23:38,799
they disagree in the message history

609
00:23:38,799 --> 00:23:41,760
and then the judge can again recompute

610
00:23:41,760 --> 00:23:44,720
only a single round to identify

611
00:23:44,720 --> 00:23:47,200
which of these parties

612
00:23:47,200 --> 00:23:50,240
were maliciously

613
00:23:50,240 --> 00:23:52,480
so what's more for all of our three

614
00:23:52,480 --> 00:23:54,799
construction we provide formal security

615
00:23:54,799 --> 00:23:55,760
proofs

616
00:23:55,760 --> 00:23:57,520
moreover even

617
00:23:57,520 --> 00:24:00,720
um we require just we require that the

618
00:24:00,720 --> 00:24:03,360
judge just to perform a single round we

619
00:24:03,360 --> 00:24:07,520
could even improve more that is we can

620
00:24:07,520 --> 00:24:09,919
lower the requirements on the judge such

621
00:24:09,919 --> 00:24:11,840
that it only needs to recompute a single

622
00:24:11,840 --> 00:24:14,720
gate of an arithmetic circuit here we

623
00:24:14,720 --> 00:24:15,919
need inter

624
00:24:15,919 --> 00:24:17,600
interaction between the parties so we

625
00:24:17,600 --> 00:24:20,080
can apply this extension to all our

626
00:24:20,080 --> 00:24:22,640
construction however in if we blow it

627
00:24:22,640 --> 00:24:24,799
for if we apply it for the first and the

628
00:24:24,799 --> 00:24:26,720
second construction then and this

629
00:24:26,720 --> 00:24:28,640
construction will also require an

630
00:24:28,640 --> 00:24:32,080
interactive punish protocol

631
00:24:32,080 --> 00:24:34,159
as a third aspect

632
00:24:34,159 --> 00:24:35,360
we

633
00:24:35,360 --> 00:24:37,679
implemented a smart contract in solidity

634
00:24:37,679 --> 00:24:40,159
and we measured the gas cost to make an

635
00:24:40,159 --> 00:24:42,799
efficiency evaluation and providing

636
00:24:42,799 --> 00:24:44,840
benchmark

637
00:24:44,840 --> 00:24:47,279
results so

638
00:24:47,279 --> 00:24:49,840
as a conclusion

639
00:24:49,840 --> 00:24:51,679
we we consider

640
00:24:51,679 --> 00:24:54,559
our fpc construction and notion

641
00:24:54,559 --> 00:24:58,000
to have several advantages over pvc

642
00:24:58,000 --> 00:24:58,840
in

643
00:24:58,840 --> 00:25:00,559
particular we think that the

644
00:25:00,559 --> 00:25:03,360
effectiveness of the deterrence is

645
00:25:03,360 --> 00:25:05,600
increased because now we directly link

646
00:25:05,600 --> 00:25:07,679
detected cheating with financial

647
00:25:07,679 --> 00:25:08,799
punishment

648
00:25:08,799 --> 00:25:10,880
then we improve on the computation costs

649
00:25:10,880 --> 00:25:12,080
of the judge

650
00:25:12,080 --> 00:25:13,279
by

651
00:25:13,279 --> 00:25:15,840
requiring only to re-execute a single

652
00:25:15,840 --> 00:25:18,640
step or even a single gateway gauge of

653
00:25:18,640 --> 00:25:21,600
the whole protocol and finally we lower

654
00:25:21,600 --> 00:25:23,440
the communication cost in the honest

655
00:25:23,440 --> 00:25:26,320
execution by relaxing on the requirement

656
00:25:26,320 --> 00:25:29,039
of the public transcript

657
00:25:29,039 --> 00:25:30,799
thank you very much for attention if you

658
00:25:30,799 --> 00:25:32,720
have any question feel free to get in

659
00:25:32,720 --> 00:25:36,240
contact with my colleague david or or

660
00:25:36,240 --> 00:25:37,440
myself

661
00:25:37,440 --> 00:25:40,559
thank you

