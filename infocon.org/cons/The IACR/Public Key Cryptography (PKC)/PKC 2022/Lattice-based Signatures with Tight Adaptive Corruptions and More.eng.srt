1
00:00:01,439 --> 00:00:03,840
hello welcome to this talk about the

2
00:00:03,840 --> 00:00:06,000
paper letter space signatures with tight

3
00:00:06,000 --> 00:00:08,559
adaptive corruptions and more this is a

4
00:00:08,559 --> 00:00:12,080
joint work with jason paan from ntnu

5
00:00:12,080 --> 00:00:14,000
as the title of this work already

6
00:00:14,000 --> 00:00:16,480
suggests this talk will be about digital

7
00:00:16,480 --> 00:00:19,840
signatures in the lattice setting

8
00:00:19,840 --> 00:00:22,160
so i want to start it with

9
00:00:22,160 --> 00:00:24,000
recalling what a digital signature

10
00:00:24,000 --> 00:00:25,680
scheme is

11
00:00:25,680 --> 00:00:28,000
which you all should be very familiar

12
00:00:28,000 --> 00:00:32,000
with that is as it is one of the most um

13
00:00:32,000 --> 00:00:33,920
fundamental cryptographic building

14
00:00:33,920 --> 00:00:35,280
blocks

15
00:00:35,280 --> 00:00:37,840
so in a digital signature scheme

16
00:00:37,840 --> 00:00:40,239
we have a user alice that sends a

17
00:00:40,239 --> 00:00:42,879
message m to user bob

18
00:00:42,879 --> 00:00:46,160
and the user bob knows the public key of

19
00:00:46,160 --> 00:00:48,000
user alice

20
00:00:48,000 --> 00:00:51,039
so she can append a digital signature

21
00:00:51,039 --> 00:00:52,800
sigma to that message

22
00:00:52,800 --> 00:00:55,520
that bob can verify using the public key

23
00:00:55,520 --> 00:00:57,920
and this will ensure authenticity and

24
00:00:57,920 --> 00:01:00,559
integrity of this message

25
00:01:00,559 --> 00:01:01,440
so

26
00:01:01,440 --> 00:01:03,440
typically we think of a scenario where

27
00:01:03,440 --> 00:01:05,119
we have an adversary

28
00:01:05,119 --> 00:01:08,159
that also knows the public key of alice

29
00:01:08,159 --> 00:01:10,479
and can interact with alice so he can

30
00:01:10,479 --> 00:01:13,119
learn some signatures from alice and he

31
00:01:13,119 --> 00:01:16,159
can then try to forge signatures

32
00:01:16,159 --> 00:01:19,520
on arbitrary messages for bob

33
00:01:19,520 --> 00:01:22,400
and we model this using a cryptographic

34
00:01:22,400 --> 00:01:25,040
security game of unforgeability under

35
00:01:25,040 --> 00:01:27,520
chosen message attacks

36
00:01:27,520 --> 00:01:29,759
here the adversary first gets a public

37
00:01:29,759 --> 00:01:31,600
key pk

38
00:01:31,600 --> 00:01:33,920
and then the adversary can ask for

39
00:01:33,920 --> 00:01:36,159
signatures for arbitrary messages of its

40
00:01:36,159 --> 00:01:37,600
choice

41
00:01:37,600 --> 00:01:39,040
and in the end

42
00:01:39,040 --> 00:01:42,399
the adversary outputs a message

43
00:01:42,399 --> 00:01:45,360
signature pair m star sigma star

44
00:01:45,360 --> 00:01:47,520
and he wins this game if this is a valid

45
00:01:47,520 --> 00:01:49,600
message signature pair

46
00:01:49,600 --> 00:01:50,640
and

47
00:01:50,640 --> 00:01:52,720
the message is fresh so he never learned

48
00:01:52,720 --> 00:01:56,240
a signature for that message

49
00:01:56,240 --> 00:01:58,000
okay

50
00:01:58,000 --> 00:02:00,000
so if we look at this and this is the

51
00:02:00,000 --> 00:02:02,159
standard notion

52
00:02:02,159 --> 00:02:03,840
we see that this is not quite what's

53
00:02:03,840 --> 00:02:05,040
happening in

54
00:02:05,040 --> 00:02:06,719
the real world

55
00:02:06,719 --> 00:02:08,560
because in the real world we don't have

56
00:02:08,560 --> 00:02:11,520
two users we have many users and many

57
00:02:11,520 --> 00:02:13,360
systems that all have their own key

58
00:02:13,360 --> 00:02:14,319
pairs

59
00:02:14,319 --> 00:02:16,400
and can communicate with each other and

60
00:02:16,400 --> 00:02:19,599
make use of the same system parameters

61
00:02:19,599 --> 00:02:20,560
and

62
00:02:20,560 --> 00:02:22,720
we can have an outside adversary that

63
00:02:22,720 --> 00:02:25,680
just observes this situation

64
00:02:25,680 --> 00:02:28,720
as before but we can also have insider

65
00:02:28,720 --> 00:02:31,680
adversaries that can corrupt

66
00:02:31,680 --> 00:02:33,280
users and learn their secret key

67
00:02:33,280 --> 00:02:34,560
material

68
00:02:34,560 --> 00:02:36,640
so we should also model this in our

69
00:02:36,640 --> 00:02:38,560
security game

70
00:02:38,560 --> 00:02:40,560
and this leads to the notion of

71
00:02:40,560 --> 00:02:43,040
multi-user security under chosen message

72
00:02:43,040 --> 00:02:45,760
attacks with adaptive corruptions

73
00:02:45,760 --> 00:02:47,519
in the following i will just call this

74
00:02:47,519 --> 00:02:50,640
multi-user security

75
00:02:50,640 --> 00:02:53,680
okay so in this game the adversary first

76
00:02:53,680 --> 00:02:56,480
gets public keys

77
00:02:56,480 --> 00:02:58,480
for n users

78
00:02:58,480 --> 00:03:00,959
then he can again ask for signatures for

79
00:03:00,959 --> 00:03:02,800
messages of its choice

80
00:03:02,800 --> 00:03:04,959
but now the adversary can also specify

81
00:03:04,959 --> 00:03:09,120
which user should sign these messages

82
00:03:09,360 --> 00:03:10,640
and then

83
00:03:10,640 --> 00:03:12,959
the adversary can in addition to asking

84
00:03:12,959 --> 00:03:14,640
for signatures he can also ask for

85
00:03:14,640 --> 00:03:18,640
secret keys so he can corrupt users

86
00:03:18,640 --> 00:03:20,319
and in the end he outputs a message

87
00:03:20,319 --> 00:03:23,200
signature pair for some target user i

88
00:03:23,200 --> 00:03:24,480
star

89
00:03:24,480 --> 00:03:26,319
and he wins this game

90
00:03:26,319 --> 00:03:28,319
if this is a valid message signature

91
00:03:28,319 --> 00:03:30,000
pair now for this

92
00:03:30,000 --> 00:03:33,440
particular public key and this user is

93
00:03:33,440 --> 00:03:35,440
not corrupted so he didn't learn the

94
00:03:35,440 --> 00:03:36,720
secret key

95
00:03:36,720 --> 00:03:39,040
and he didn't learn a message a

96
00:03:39,040 --> 00:03:41,440
signature for that message m star for

97
00:03:41,440 --> 00:03:43,360
that user

98
00:03:43,360 --> 00:03:46,560
okay so this is a notion that is closer

99
00:03:46,560 --> 00:03:49,280
to to practical scenarios

100
00:03:49,280 --> 00:03:51,200
and let us compare these these two

101
00:03:51,200 --> 00:03:53,439
notions so the left one the single user

102
00:03:53,439 --> 00:03:55,360
security is a standard one and the right

103
00:03:55,360 --> 00:03:59,200
one is the multi-user security

104
00:03:59,200 --> 00:04:02,319
so if we look at this then it is

105
00:04:02,319 --> 00:04:04,480
relatively straightforward to see that a

106
00:04:04,480 --> 00:04:07,200
reduction can just take this public key

107
00:04:07,200 --> 00:04:09,280
and embed it in a random

108
00:04:09,280 --> 00:04:12,000
public key of these and many

109
00:04:12,000 --> 00:04:15,040
and in the end if it guesses the index i

110
00:04:15,040 --> 00:04:18,639
star correctly then it wins so we have a

111
00:04:18,639 --> 00:04:20,639
straightforward guessing

112
00:04:20,639 --> 00:04:22,320
guessing argument

113
00:04:22,320 --> 00:04:24,560
that shows that asymptotically these two

114
00:04:24,560 --> 00:04:26,720
notions are equivalent meaning that if

115
00:04:26,720 --> 00:04:29,440
you satisfy single user security

116
00:04:29,440 --> 00:04:32,560
you also satisfy multi-user security

117
00:04:32,560 --> 00:04:34,800
and this somehow

118
00:04:34,800 --> 00:04:37,360
justifies that the left one is the

119
00:04:37,360 --> 00:04:38,720
standard notion

120
00:04:38,720 --> 00:04:40,840
but if we look at the

121
00:04:40,840 --> 00:04:42,720
argument

122
00:04:42,720 --> 00:04:44,240
in more detail then we see that the

123
00:04:44,240 --> 00:04:46,240
security loss that is

124
00:04:46,240 --> 00:04:47,199
that is

125
00:04:47,199 --> 00:04:48,800
related to this reduction is

126
00:04:48,800 --> 00:04:50,560
proportional to the number of users in

127
00:04:50,560 --> 00:04:51,840
the system

128
00:04:51,840 --> 00:04:53,919
and i will explain to you why this is

129
00:04:53,919 --> 00:04:56,160
not good and why we don't want to to

130
00:04:56,160 --> 00:04:57,759
have that

131
00:04:57,759 --> 00:05:00,479
so to do that let's look at the typical

132
00:05:00,479 --> 00:05:01,360
proof

133
00:05:01,360 --> 00:05:04,080
that we have in crypto cryptography

134
00:05:04,080 --> 00:05:06,160
so we have an adversary a

135
00:05:06,160 --> 00:05:09,039
that breaks the scheme and we say we can

136
00:05:09,039 --> 00:05:11,440
build a reduction that uses a as a

137
00:05:11,440 --> 00:05:14,240
subroutine and solves some hard problem

138
00:05:14,240 --> 00:05:16,800
when we do that we establish a relation

139
00:05:16,800 --> 00:05:18,800
between the success probabilities of

140
00:05:18,800 --> 00:05:20,960
these two algorithms

141
00:05:20,960 --> 00:05:22,720
and let's call this multiplicative

142
00:05:22,720 --> 00:05:26,320
factor the security loss

143
00:05:26,320 --> 00:05:28,960
so asymptotically you can take any

144
00:05:28,960 --> 00:05:31,680
polynomial security loss

145
00:05:31,680 --> 00:05:34,160
and you will end up in a secure scheme

146
00:05:34,160 --> 00:05:36,960
because if epsilon r is negligible l is

147
00:05:36,960 --> 00:05:39,440
polynomial then epsilon a is also

148
00:05:39,440 --> 00:05:41,680
negligible

149
00:05:41,680 --> 00:05:44,400
but if you want to use that reduction to

150
00:05:44,400 --> 00:05:46,400
derive concrete parameters for your

151
00:05:46,400 --> 00:05:49,600
scheme to use it in practice

152
00:05:49,600 --> 00:05:52,720
then this secure security loss l becomes

153
00:05:52,720 --> 00:05:55,600
important because if your

154
00:05:55,600 --> 00:05:57,440
security loss

155
00:05:57,440 --> 00:05:59,520
is let's say 2 to the 30 the number of

156
00:05:59,520 --> 00:06:02,560
users in the system then you need to pay

157
00:06:02,560 --> 00:06:05,440
30 bits of security so concretely assume

158
00:06:05,440 --> 00:06:09,600
you want to achieve 128 bit of security

159
00:06:09,600 --> 00:06:11,360
and your security loss is the number of

160
00:06:11,360 --> 00:06:13,600
users in the system as we saw in the

161
00:06:13,600 --> 00:06:15,919
slide before

162
00:06:15,919 --> 00:06:18,080
which can be 2 to the 30

163
00:06:18,080 --> 00:06:20,800
then this tells you you need to set the

164
00:06:20,800 --> 00:06:22,720
parameters of the underlying assumptions

165
00:06:22,720 --> 00:06:26,319
to support 158 bit of security

166
00:06:26,319 --> 00:06:28,000
which is

167
00:06:28,000 --> 00:06:30,319
or which will lead to to

168
00:06:30,319 --> 00:06:32,840
inefficient concrete

169
00:06:32,840 --> 00:06:36,240
parameters so motivated by this we want

170
00:06:36,240 --> 00:06:37,039
to

171
00:06:37,039 --> 00:06:39,520
have tight reductions tight security

172
00:06:39,520 --> 00:06:40,479
proofs

173
00:06:40,479 --> 00:06:42,639
where the security loss l is a small

174
00:06:42,639 --> 00:06:46,800
constant and we don't lose that much

175
00:06:46,840 --> 00:06:48,800
security okay

176
00:06:48,800 --> 00:06:50,240
so

177
00:06:50,240 --> 00:06:52,560
as i showed you the single user security

178
00:06:52,560 --> 00:06:55,039
notion for digital signatures

179
00:06:55,039 --> 00:06:57,280
non-tightly implies

180
00:06:57,280 --> 00:06:58,000
the

181
00:06:58,000 --> 00:07:00,160
multi-user notion

182
00:07:00,160 --> 00:07:02,800
and in fact the multi-user notion in

183
00:07:02,800 --> 00:07:04,880
addition to being close to real-world

184
00:07:04,880 --> 00:07:06,240
application

185
00:07:06,240 --> 00:07:09,199
it also tightly implies uh other

186
00:07:09,199 --> 00:07:10,639
cryptographic primitives like

187
00:07:10,639 --> 00:07:12,560
identity-based signatures and

188
00:07:12,560 --> 00:07:15,280
authenticated key exchange

189
00:07:15,280 --> 00:07:16,560
so

190
00:07:16,560 --> 00:07:18,240
it is somehow

191
00:07:18,240 --> 00:07:20,080
clear that if we want to have these

192
00:07:20,080 --> 00:07:22,800
primitives in a tight way then we should

193
00:07:22,800 --> 00:07:24,560
better

194
00:07:24,560 --> 00:07:26,560
construct tightly secure signature

195
00:07:26,560 --> 00:07:30,160
schemes in the multi-user setting

196
00:07:30,160 --> 00:07:33,360
okay so let's see what already exists in

197
00:07:33,360 --> 00:07:35,120
this in this area

198
00:07:35,120 --> 00:07:37,199
so let's see what is the state of the

199
00:07:37,199 --> 00:07:38,319
art for

200
00:07:38,319 --> 00:07:41,360
digital signatures in terms of tightness

201
00:07:41,360 --> 00:07:42,400
so

202
00:07:42,400 --> 00:07:44,720
for classical assumptions such as d-log

203
00:07:44,720 --> 00:07:46,000
and rsa

204
00:07:46,000 --> 00:07:47,919
we have tightly secure schemes in the

205
00:07:47,919 --> 00:07:49,599
single user setting

206
00:07:49,599 --> 00:07:51,199
and we also have such schemes for

207
00:07:51,199 --> 00:07:52,800
post-quantum assumptions such as

208
00:07:52,800 --> 00:07:54,479
lattices

209
00:07:54,479 --> 00:07:56,960
but as i'm motivated we should look at

210
00:07:56,960 --> 00:07:59,280
the multi-user notion

211
00:07:59,280 --> 00:08:01,039
if we want to say something about

212
00:08:01,039 --> 00:08:02,240
reality

213
00:08:02,240 --> 00:08:04,400
so

214
00:08:04,400 --> 00:08:06,960
let's see let's see what is there so in

215
00:08:06,960 --> 00:08:09,440
the classical in the classical setting

216
00:08:09,440 --> 00:08:13,440
we have two quite practical schemes

217
00:08:13,440 --> 00:08:16,319
uh one is from last year's pkc by dima

218
00:08:16,319 --> 00:08:17,680
de dal

219
00:08:17,680 --> 00:08:19,520
and

220
00:08:19,520 --> 00:08:21,199
the problem is that we don't have any

221
00:08:21,199 --> 00:08:23,680
such schemes in the pos quantum setting

222
00:08:23,680 --> 00:08:26,720
so we don't know how to do that and to

223
00:08:26,720 --> 00:08:28,080
fill this gap

224
00:08:28,080 --> 00:08:31,840
is our main main goal in this work

225
00:08:31,840 --> 00:08:33,679
okay so i should mention that there is a

226
00:08:33,679 --> 00:08:36,080
folklore approach where you can use an

227
00:08:36,080 --> 00:08:39,519
or proof and some online extractable

228
00:08:39,519 --> 00:08:42,240
nizik such as the unruh transform but

229
00:08:42,240 --> 00:08:44,640
that will lead to non-compact signatures

230
00:08:44,640 --> 00:08:46,720
in a sense that the number of group

231
00:08:46,720 --> 00:08:48,959
elements or vectors that are contained

232
00:08:48,959 --> 00:08:50,560
in one signature

233
00:08:50,560 --> 00:08:52,839
grows linearly with the security

234
00:08:52,839 --> 00:08:56,160
parameter and this is not efficient so

235
00:08:56,160 --> 00:08:58,000
we are not interested in this in this

236
00:08:58,000 --> 00:08:59,279
approach

237
00:08:59,279 --> 00:09:01,680
so to summarize our goal is to have a

238
00:09:01,680 --> 00:09:03,920
signature scheme with tight multi-user

239
00:09:03,920 --> 00:09:06,480
security from a post-quantum assumption

240
00:09:06,480 --> 00:09:09,200
such as lattice-based assumptions

241
00:09:09,200 --> 00:09:12,399
with compact signatures

242
00:09:12,399 --> 00:09:15,600
okay so let's see why this is not easy

243
00:09:15,600 --> 00:09:18,240
or not trivial to achieve so think about

244
00:09:18,240 --> 00:09:20,399
the following scenario you already

245
00:09:20,399 --> 00:09:22,320
constructed a scheme and now you want to

246
00:09:22,320 --> 00:09:25,279
prove the security of your scheme

247
00:09:25,279 --> 00:09:27,279
now the question is

248
00:09:27,279 --> 00:09:29,200
which of the secret keys of these end

249
00:09:29,200 --> 00:09:31,920
users should the reduction know

250
00:09:31,920 --> 00:09:33,920
because let's say you know all the

251
00:09:33,920 --> 00:09:38,000
secret keys except one this one

252
00:09:38,000 --> 00:09:38,800
then

253
00:09:38,800 --> 00:09:41,279
even if the adversary just randomly asks

254
00:09:41,279 --> 00:09:42,720
for one

255
00:09:42,720 --> 00:09:44,560
secret key then it will hit this with

256
00:09:44,560 --> 00:09:48,480
probability one over n meaning that

257
00:09:48,480 --> 00:09:50,560
we end up in an untied reduction and

258
00:09:50,560 --> 00:09:52,800
this means that

259
00:09:52,800 --> 00:09:54,800
our reduction should always be able to

260
00:09:54,800 --> 00:09:56,880
answer corruption queries meaning that

261
00:09:56,880 --> 00:09:59,360
it has to know all the secret keys

262
00:09:59,360 --> 00:10:00,320
okay

263
00:10:00,320 --> 00:10:03,040
but if we know all the secret keys

264
00:10:03,040 --> 00:10:05,200
then we can just forge without using the

265
00:10:05,200 --> 00:10:06,480
adversary

266
00:10:06,480 --> 00:10:09,040
and this is a contradiction right to the

267
00:10:09,040 --> 00:10:11,839
security of the underlying problem

268
00:10:11,839 --> 00:10:12,650
so

269
00:10:12,650 --> 00:10:14,800
[Music]

270
00:10:14,800 --> 00:10:18,800
this is this is a key idea

271
00:10:18,800 --> 00:10:21,200
that is underlying many

272
00:10:21,200 --> 00:10:23,800
impossibility results in this area of

273
00:10:23,800 --> 00:10:28,240
multi-user security and tightness

274
00:10:28,880 --> 00:10:31,200
so if we look at these impossibility

275
00:10:31,200 --> 00:10:34,720
results we see that they require somehow

276
00:10:34,720 --> 00:10:37,760
more or less than that that

277
00:10:37,760 --> 00:10:39,519
the secret keys for our scheme are

278
00:10:39,519 --> 00:10:41,440
unique

279
00:10:41,440 --> 00:10:43,920
and this already gives us an idea of how

280
00:10:43,920 --> 00:10:46,160
to circumvent these impossibility

281
00:10:46,160 --> 00:10:47,680
results namely we want to have

282
00:10:47,680 --> 00:10:50,240
non-unique secret keys so let's see how

283
00:10:50,240 --> 00:10:51,760
to do that

284
00:10:51,760 --> 00:10:54,720
so our higher level idea is that we have

285
00:10:54,720 --> 00:10:58,079
a public key that is composed of two

286
00:10:58,079 --> 00:11:00,079
public keys of some underlying scheme

287
00:11:00,079 --> 00:11:03,120
and a secret key is one of the two

288
00:11:03,120 --> 00:11:06,640
secret keys so the reduction knows one

289
00:11:06,640 --> 00:11:09,600
secret key for each of the users

290
00:11:09,600 --> 00:11:13,200
and which one this is chosen at random

291
00:11:13,200 --> 00:11:14,959
now

292
00:11:14,959 --> 00:11:17,040
the signatures should also not reveal to

293
00:11:17,040 --> 00:11:19,920
the adversary which um secret key the

294
00:11:19,920 --> 00:11:21,760
reduction holds so this should be some

295
00:11:21,760 --> 00:11:25,439
witness indistinguishable proof

296
00:11:26,240 --> 00:11:27,440
and

297
00:11:27,440 --> 00:11:30,240
we finally we also want that the default

298
00:11:30,240 --> 00:11:32,880
rate at the adversary returns

299
00:11:32,880 --> 00:11:35,279
can help the reduction if it is with

300
00:11:35,279 --> 00:11:36,880
respect to the key for which the

301
00:11:36,880 --> 00:11:39,600
reduction does not know a secret key

302
00:11:39,600 --> 00:11:41,440
and this means that in the end we

303
00:11:41,440 --> 00:11:43,839
succeed with probability one-half and we

304
00:11:43,839 --> 00:11:44,720
have

305
00:11:44,720 --> 00:11:47,600
a security loss of one bit which is

306
00:11:47,600 --> 00:11:49,360
tight

307
00:11:49,360 --> 00:11:51,920
okay so that's a high-level idea and to

308
00:11:51,920 --> 00:11:54,079
implement this we need some form of or

309
00:11:54,079 --> 00:11:55,760
proof

310
00:11:55,760 --> 00:11:58,079
to to to um

311
00:11:58,079 --> 00:12:00,160
to hide which which secret key the

312
00:12:00,160 --> 00:12:02,480
reduction actually knows

313
00:12:02,480 --> 00:12:05,360
and this high level idea is uh the core

314
00:12:05,360 --> 00:12:07,839
of of the demod at the whole framework

315
00:12:07,839 --> 00:12:10,959
from last year's pkc and they achieve

316
00:12:10,959 --> 00:12:12,399
tightly secure signatures in the

317
00:12:12,399 --> 00:12:13,920
multi-user setting

318
00:12:13,920 --> 00:12:16,240
from classical assumptions

319
00:12:16,240 --> 00:12:18,560
so let's see how this framework works

320
00:12:18,560 --> 00:12:22,720
and how we can transfer it or

321
00:12:22,720 --> 00:12:24,720
let's say generalize it

322
00:12:24,720 --> 00:12:27,040
to uh to achieve

323
00:12:27,040 --> 00:12:28,720
the same thing in the post quantum

324
00:12:28,720 --> 00:12:30,160
setting

325
00:12:30,160 --> 00:12:32,240
so dema data i'll start with a lossy

326
00:12:32,240 --> 00:12:34,360
identification scheme with some random

327
00:12:34,360 --> 00:12:37,440
self-reducibility property so i will

328
00:12:37,440 --> 00:12:38,880
tell you what a lossy identification

329
00:12:38,880 --> 00:12:41,519
scheme is in a few slides

330
00:12:41,519 --> 00:12:43,519
and then they use a sequential or proof

331
00:12:43,519 --> 00:12:46,240
which is just one form of or proof

332
00:12:46,240 --> 00:12:48,399
to transform it into a digital signature

333
00:12:48,399 --> 00:12:49,839
scheme

334
00:12:49,839 --> 00:12:51,760
and in the end they can instantiate

335
00:12:51,760 --> 00:12:53,120
their framework from classical

336
00:12:53,120 --> 00:12:55,839
assumptions such as ddh

337
00:12:55,839 --> 00:12:58,000
our first step is to

338
00:12:58,000 --> 00:13:00,639
generalize this notion of a lossy id and

339
00:13:00,639 --> 00:13:03,040
random self-reducibility to a so-called

340
00:13:03,040 --> 00:13:05,839
multi-key lossy identification scheme

341
00:13:05,839 --> 00:13:08,079
and then in the next step we show that

342
00:13:08,079 --> 00:13:10,480
you can achieve this multi-key lossy

343
00:13:10,480 --> 00:13:12,160
identification scheme

344
00:13:12,160 --> 00:13:15,040
if you start with a dual mode commitment

345
00:13:15,040 --> 00:13:16,720
and then we instantiate this dual mode

346
00:13:16,720 --> 00:13:19,360
commitment from lwe and the group action

347
00:13:19,360 --> 00:13:22,480
based assumption which captures isogenes

348
00:13:22,480 --> 00:13:25,200
and finally we also show that the demand

349
00:13:25,200 --> 00:13:27,600
at all instantiations are actually also

350
00:13:27,600 --> 00:13:29,680
instantiations of our more general

351
00:13:29,680 --> 00:13:31,519
framework

352
00:13:31,519 --> 00:13:33,200
so in the following i want to look at

353
00:13:33,200 --> 00:13:35,600
multi-key lossy identification

354
00:13:35,600 --> 00:13:36,480
and

355
00:13:36,480 --> 00:13:40,720
how we can construct it from from lwe

356
00:13:40,720 --> 00:13:41,839
okay

357
00:13:41,839 --> 00:13:44,639
so what is lossy identification

358
00:13:44,639 --> 00:13:46,480
we start with a canonical identification

359
00:13:46,480 --> 00:13:47,440
scheme

360
00:13:47,440 --> 00:13:50,079
where approver holding a secret key can

361
00:13:50,079 --> 00:13:52,240
convince a verifier holding a public key

362
00:13:52,240 --> 00:13:54,399
that he knows the secret key

363
00:13:54,399 --> 00:13:57,120
he does this by sending a message r

364
00:13:57,120 --> 00:13:58,959
receiving a challenge c

365
00:13:58,959 --> 00:14:01,680
and sending a response s back

366
00:14:01,680 --> 00:14:02,959
an example is the scenario

367
00:14:02,959 --> 00:14:04,959
identification scheme

368
00:14:04,959 --> 00:14:07,680
and then the verifier can verify this

369
00:14:07,680 --> 00:14:08,959
transcript and we want to have

370
00:14:08,959 --> 00:14:11,519
completeness in a sense that

371
00:14:11,519 --> 00:14:13,519
the honest prover can always convince

372
00:14:13,519 --> 00:14:16,160
the verifier

373
00:14:16,160 --> 00:14:16,880
now

374
00:14:16,880 --> 00:14:18,399
this is a canonical identification

375
00:14:18,399 --> 00:14:20,240
scheme what is a lossy identification

376
00:14:20,240 --> 00:14:23,279
scheme a lossy identification scheme

377
00:14:23,279 --> 00:14:25,680
is a special form of this identification

378
00:14:25,680 --> 00:14:28,639
scheme that has two modes of public keys

379
00:14:28,639 --> 00:14:30,800
so first we have a normal mode which is

380
00:14:30,800 --> 00:14:32,560
what i explained to you

381
00:14:32,560 --> 00:14:34,480
on the slide before so here we have

382
00:14:34,480 --> 00:14:36,240
completeness

383
00:14:36,240 --> 00:14:38,560
but we also have a lossy mode public

384
00:14:38,560 --> 00:14:40,639
keys which are generated without a

385
00:14:40,639 --> 00:14:42,800
secret key for which we have some form

386
00:14:42,800 --> 00:14:45,279
of statistical soundness so even an

387
00:14:45,279 --> 00:14:48,079
unbounded adversary cannot convince the

388
00:14:48,079 --> 00:14:51,600
verifier with non-negligible probability

389
00:14:51,600 --> 00:14:53,839
and finally we want to have that these

390
00:14:53,839 --> 00:14:55,760
null modes are computationally

391
00:14:55,760 --> 00:14:57,680
indistinguishable

392
00:14:57,680 --> 00:15:00,560
and aflt which introduced these

393
00:15:00,560 --> 00:15:02,560
primitives

394
00:15:02,560 --> 00:15:04,720
show that this tightly implies

395
00:15:04,720 --> 00:15:07,120
single user security for fiat chamier

396
00:15:07,120 --> 00:15:08,880
signatures

397
00:15:08,880 --> 00:15:10,399
so we want to look at multi-user

398
00:15:10,399 --> 00:15:12,639
security so we generalize this to

399
00:15:12,639 --> 00:15:14,959
multi-key lossy identification

400
00:15:14,959 --> 00:15:16,720
and here we have basically the same

401
00:15:16,720 --> 00:15:19,279
guarantees but now we want that n public

402
00:15:19,279 --> 00:15:20,320
keys

403
00:15:20,320 --> 00:15:22,240
are computationally indistinguishable

404
00:15:22,240 --> 00:15:24,959
from n keys that are output by our lossy

405
00:15:24,959 --> 00:15:26,480
key generator

406
00:15:26,480 --> 00:15:29,120
and they can possibly be correlated in

407
00:15:29,120 --> 00:15:31,759
some sense

408
00:15:32,079 --> 00:15:33,920
okay so

409
00:15:33,920 --> 00:15:36,000
we know that we can have a multi-key

410
00:15:36,000 --> 00:15:38,480
lossy identification scheme that implies

411
00:15:38,480 --> 00:15:40,800
a signature scheme using the sequential

412
00:15:40,800 --> 00:15:42,639
or proof technique as india data

413
00:15:42,639 --> 00:15:44,320
framework

414
00:15:44,320 --> 00:15:46,720
and the question is how can we construct

415
00:15:46,720 --> 00:15:49,600
this scheme from lattice assumptions

416
00:15:49,600 --> 00:15:51,600
so this is what i will

417
00:15:51,600 --> 00:15:54,399
tell you in in the following slides

418
00:15:54,399 --> 00:15:55,519
okay so

419
00:15:55,519 --> 00:15:57,360
first of all

420
00:15:57,360 --> 00:16:00,079
what is what is the problem here so we

421
00:16:00,079 --> 00:16:02,320
want to show that there is

422
00:16:02,320 --> 00:16:04,399
some way to generate n keys that is

423
00:16:04,399 --> 00:16:06,399
computationally indistinguishable from n

424
00:16:06,399 --> 00:16:10,079
lossy keys and

425
00:16:10,079 --> 00:16:11,759
in in particular as we want to have

426
00:16:11,759 --> 00:16:14,000
tight security this indistinguishability

427
00:16:14,000 --> 00:16:16,000
should not depend on the number of keys

428
00:16:16,000 --> 00:16:17,759
that we have here because that will

429
00:16:17,759 --> 00:16:19,839
correspond to the number of users in our

430
00:16:19,839 --> 00:16:21,680
system later

431
00:16:21,680 --> 00:16:23,120
now

432
00:16:23,120 --> 00:16:24,639
for lattices

433
00:16:24,639 --> 00:16:26,959
or in general when whenever you want to

434
00:16:26,959 --> 00:16:29,680
show this tightly the way to go is

435
00:16:29,680 --> 00:16:31,600
random self-reducibility

436
00:16:31,600 --> 00:16:33,360
but for lattices

437
00:16:33,360 --> 00:16:36,000
we only have this for the plain

438
00:16:36,000 --> 00:16:39,040
versions of the problem in a sense that

439
00:16:39,040 --> 00:16:41,920
the number of samples is not

440
00:16:41,920 --> 00:16:43,839
important for the security guarantees

441
00:16:43,839 --> 00:16:45,199
that you have

442
00:16:45,199 --> 00:16:47,519
and for structured variants such as ring

443
00:16:47,519 --> 00:16:50,079
lwe or module lwe we don't have this

444
00:16:50,079 --> 00:16:51,519
guarantee

445
00:16:51,519 --> 00:16:53,279
unfortunately

446
00:16:53,279 --> 00:16:54,880
if we look at existing lossy

447
00:16:54,880 --> 00:16:56,639
identification schemes we only know

448
00:16:56,639 --> 00:16:59,680
schemes for the ring and module version

449
00:16:59,680 --> 00:17:02,240
of this problem and then they make

450
00:17:02,240 --> 00:17:04,480
use of the ring structure and it's not

451
00:17:04,480 --> 00:17:07,039
clear how to transform them to the plane

452
00:17:07,039 --> 00:17:08,400
setting

453
00:17:08,400 --> 00:17:10,720
so our goal is to have a multi-key loss

454
00:17:10,720 --> 00:17:14,640
identification scheme from plane lwe

455
00:17:14,640 --> 00:17:17,119
and to do that we do not rely on these

456
00:17:17,119 --> 00:17:19,919
previous ideas but instead we rely on

457
00:17:19,919 --> 00:17:22,400
something

458
00:17:22,480 --> 00:17:24,480
that seems to be independent namely

459
00:17:24,480 --> 00:17:26,079
regif encryption

460
00:17:26,079 --> 00:17:28,400
so in regf encryption your public key is

461
00:17:28,400 --> 00:17:30,960
a matrix a which is

462
00:17:30,960 --> 00:17:34,000
basically an lwe sample

463
00:17:34,000 --> 00:17:37,120
now your ciphertext for message with

464
00:17:37,120 --> 00:17:40,000
some randomness set which is typically a

465
00:17:40,000 --> 00:17:41,120
gaussian

466
00:17:41,120 --> 00:17:43,600
is a time set plus an encoding of the

467
00:17:43,600 --> 00:17:44,559
message

468
00:17:44,559 --> 00:17:47,360
so the details do not matter here

469
00:17:47,360 --> 00:17:50,320
but we can already use this to construct

470
00:17:50,320 --> 00:17:52,960
our lossy mode for our identification

471
00:17:52,960 --> 00:17:54,240
scheme

472
00:17:54,240 --> 00:17:56,240
so in our lossy mode we first send a

473
00:17:56,240 --> 00:17:59,200
random ciphertext to the verifier

474
00:17:59,200 --> 00:18:01,919
and then we get back a random message

475
00:18:01,919 --> 00:18:05,200
and now our challenge is to open this

476
00:18:05,200 --> 00:18:08,320
cipher text to that message by sending

477
00:18:08,320 --> 00:18:10,960
the randomness set

478
00:18:10,960 --> 00:18:13,039
and of course this is an encryption

479
00:18:13,039 --> 00:18:15,200
scheme so

480
00:18:15,200 --> 00:18:16,400
so

481
00:18:16,400 --> 00:18:18,080
for each cipher text there's only one

482
00:18:18,080 --> 00:18:21,760
plain text that you can actually

483
00:18:21,760 --> 00:18:23,840
open open it to

484
00:18:23,840 --> 00:18:26,080
and therefore even unbounded adversary

485
00:18:26,080 --> 00:18:28,320
has no chance essentially of winning

486
00:18:28,320 --> 00:18:30,400
this game except with negligible

487
00:18:30,400 --> 00:18:33,039
probability

488
00:18:33,039 --> 00:18:35,919
okay so this is this is um

489
00:18:35,919 --> 00:18:37,919
the lossy mode now we also need a

490
00:18:37,919 --> 00:18:40,880
complete mode like a normal mode of our

491
00:18:40,880 --> 00:18:42,400
of our

492
00:18:42,400 --> 00:18:45,039
identification scheme

493
00:18:45,039 --> 00:18:46,640
and to do that we

494
00:18:46,640 --> 00:18:48,960
we generate a matrix with a trapdoor and

495
00:18:48,960 --> 00:18:51,200
such a trapper allows you to sample

496
00:18:51,200 --> 00:18:53,840
gaussian or short pre-images

497
00:18:53,840 --> 00:18:56,640
of the function that is induced by a

498
00:18:56,640 --> 00:18:59,039
and this is statistically close to a

499
00:18:59,039 --> 00:19:01,360
uniformly random matrix which is

500
00:19:01,360 --> 00:19:04,559
computationally close by lwe to our

501
00:19:04,559 --> 00:19:06,240
lossy mode

502
00:19:06,240 --> 00:19:07,120
key

503
00:19:07,120 --> 00:19:08,640
and then our

504
00:19:08,640 --> 00:19:11,280
final identification scheme

505
00:19:11,280 --> 00:19:13,840
which uses r as a secret key

506
00:19:13,840 --> 00:19:16,160
works like this you send a random cipher

507
00:19:16,160 --> 00:19:18,960
text you get a random message

508
00:19:18,960 --> 00:19:21,360
and now you can use your key your

509
00:19:21,360 --> 00:19:25,679
trapdoor to sample the randomness set

510
00:19:25,679 --> 00:19:27,200
that opens

511
00:19:27,200 --> 00:19:30,320
ciphertext to the message amp

512
00:19:30,320 --> 00:19:31,840
okay so

513
00:19:31,840 --> 00:19:35,039
what i showed you now is how to use lwe

514
00:19:35,039 --> 00:19:36,799
to get a multi-key lossy identification

515
00:19:36,799 --> 00:19:39,440
scheme and we know how to turn that into

516
00:19:39,440 --> 00:19:41,679
the signature scheme that we want

517
00:19:41,679 --> 00:19:42,559
so

518
00:19:42,559 --> 00:19:46,320
this is good but let's take a step back

519
00:19:46,320 --> 00:19:48,480
so we identified here that the rgf

520
00:19:48,480 --> 00:19:50,080
encryption scheme

521
00:19:50,080 --> 00:19:53,039
has some form of dual mode property

522
00:19:53,039 --> 00:19:55,919
where you can generate the keys either

523
00:19:55,919 --> 00:19:58,240
to use it as an encryption scheme

524
00:19:58,240 --> 00:20:00,160
or if you generate it differently the

525
00:20:00,160 --> 00:20:03,280
keys then you can use it as a perfectly

526
00:20:03,280 --> 00:20:05,679
hiding commitment trapped or commitment

527
00:20:05,679 --> 00:20:07,200
basically

528
00:20:07,200 --> 00:20:09,200
so we abstract this in the notion of a

529
00:20:09,200 --> 00:20:11,679
dual mode commitment scheme and we show

530
00:20:11,679 --> 00:20:14,400
that you can achieve this from lwe as i

531
00:20:14,400 --> 00:20:16,559
showed you and also from a group action

532
00:20:16,559 --> 00:20:19,440
based assumption

533
00:20:19,600 --> 00:20:22,400
and also from the classical assumptions

534
00:20:22,400 --> 00:20:25,840
so this is our final framework

535
00:20:25,840 --> 00:20:28,799
okay to summarize our results we have a

536
00:20:28,799 --> 00:20:30,480
generic framework from doing mode

537
00:20:30,480 --> 00:20:32,159
commitments to

538
00:20:32,159 --> 00:20:33,840
tightly secure signatures in the

539
00:20:33,840 --> 00:20:36,320
multi-user setting

540
00:20:36,320 --> 00:20:38,880
and we can instantiate it from a variety

541
00:20:38,880 --> 00:20:40,400
of assumptions

542
00:20:40,400 --> 00:20:42,159
even post-quantum assumptions such as

543
00:20:42,159 --> 00:20:44,400
lwe or isogenes

544
00:20:44,400 --> 00:20:46,400
and it gives us the first

545
00:20:46,400 --> 00:20:48,640
tightly secure post quantum

546
00:20:48,640 --> 00:20:50,320
signature scheme in the multi-user

547
00:20:50,320 --> 00:20:52,639
setting

548
00:20:52,960 --> 00:20:54,000
and

549
00:20:54,000 --> 00:20:55,520
the second contribution is an

550
00:20:55,520 --> 00:20:57,440
impossibility result which i didn't

551
00:20:57,440 --> 00:21:00,320
cover in this talk at all

552
00:21:00,320 --> 00:21:02,640
but what you what you have seen is that

553
00:21:02,640 --> 00:21:04,559
this framework of demeter dial and also

554
00:21:04,559 --> 00:21:07,039
our final framework use these sequential

555
00:21:07,039 --> 00:21:08,320
or proofs

556
00:21:08,320 --> 00:21:11,039
so this is a form of or proof

557
00:21:11,039 --> 00:21:13,280
but there is also a different prominent

558
00:21:13,280 --> 00:21:15,200
form of or proof which is a parallel or

559
00:21:15,200 --> 00:21:19,120
proof and in our work we show that using

560
00:21:19,120 --> 00:21:21,200
parallel law proofs you cannot achieve

561
00:21:21,200 --> 00:21:23,200
tightly secure signatures in the

562
00:21:23,200 --> 00:21:26,240
multi-user setting

563
00:21:27,760 --> 00:21:30,080
yeah so if you are interested in that i

564
00:21:30,080 --> 00:21:32,400
did not cover it in the talk um you can

565
00:21:32,400 --> 00:21:34,559
look into our paper

566
00:21:34,559 --> 00:21:36,880
okay so i want to conclude with some

567
00:21:36,880 --> 00:21:38,799
open problems which are related to our

568
00:21:38,799 --> 00:21:41,200
results and which can be useful for

569
00:21:41,200 --> 00:21:42,720
future work

570
00:21:42,720 --> 00:21:44,480
so we constructed a tightly secure

571
00:21:44,480 --> 00:21:46,080
signature scheme in the multi-user

572
00:21:46,080 --> 00:21:48,640
setting from lwe

573
00:21:48,640 --> 00:21:50,799
but what about other assumptions like

574
00:21:50,799 --> 00:21:53,120
search assumptions like sis

575
00:21:53,120 --> 00:21:56,240
or structured assumptions like ring lwe

576
00:21:56,240 --> 00:21:59,840
ring sis and so on this will definitely

577
00:21:59,840 --> 00:22:01,919
give us a more efficient scheme than

578
00:22:01,919 --> 00:22:05,360
what we have so far

579
00:22:05,360 --> 00:22:08,240
and also our scheme is proven secure in

580
00:22:08,240 --> 00:22:10,400
the random oracle model but for

581
00:22:10,400 --> 00:22:12,159
post-quantum assumptions you would like

582
00:22:12,159 --> 00:22:15,360
to have the quantum random oracle model

583
00:22:15,360 --> 00:22:17,200
or the standard model

584
00:22:17,200 --> 00:22:20,080
so this is the other direction what

585
00:22:20,080 --> 00:22:22,640
about the model right so can you can you

586
00:22:22,640 --> 00:22:25,600
achieve a more desirable model

587
00:22:25,600 --> 00:22:26,480
okay

588
00:22:26,480 --> 00:22:27,360
so

589
00:22:27,360 --> 00:22:29,600
that's that's it from my side i thank

590
00:22:29,600 --> 00:22:31,919
you for your attention and if you're

591
00:22:31,919 --> 00:22:34,159
interested you can look up our paper on

592
00:22:34,159 --> 00:22:35,440
eprint

593
00:22:35,440 --> 00:22:38,320
thank you

