1
00:00:00,880 --> 00:00:03,199
hello and thank you for clicking on this

2
00:00:03,199 --> 00:00:05,520
video where i will be talking about our

3
00:00:05,520 --> 00:00:08,639
latest work which is titled rational

4
00:00:08,639 --> 00:00:11,440
modular encoding in the dcr setting on

5
00:00:11,440 --> 00:00:13,599
interactive french proofs and by a base

6
00:00:13,599 --> 00:00:16,640
volume in the standard model so this is

7
00:00:16,640 --> 00:00:18,640
joint work with bernoulliber and thomas

8
00:00:18,640 --> 00:00:20,480
peters and

9
00:00:20,480 --> 00:00:22,560
as the title suggests

10
00:00:22,560 --> 00:00:24,800
we will be using a particular

11
00:00:24,800 --> 00:00:26,400
rational encoding

12
00:00:26,400 --> 00:00:28,800
in order to build an uninteractive range

13
00:00:28,800 --> 00:00:31,760
proof that satisfies constant rate and

14
00:00:31,760 --> 00:00:33,680
unboundedness

15
00:00:33,680 --> 00:00:36,640
and we also instantiate the narrow human

16
00:00:36,640 --> 00:00:40,800
paradigm under the dcr assumption

17
00:00:40,800 --> 00:00:43,120
so first let me tell you about range

18
00:00:43,120 --> 00:00:44,719
proofs

19
00:00:44,719 --> 00:00:46,960
the idea is that you have some

20
00:00:46,960 --> 00:00:48,640
intentional value

21
00:00:48,640 --> 00:00:51,360
that you do not want to reveal

22
00:00:51,360 --> 00:00:53,520
for instance the amount of money on your

23
00:00:53,520 --> 00:00:56,239
bank account

24
00:00:57,199 --> 00:00:59,440
but you want to prove that this value

25
00:00:59,440 --> 00:01:01,120
belongs to

26
00:01:01,120 --> 00:01:03,760
some range that you have enough money to

27
00:01:03,760 --> 00:01:06,799
buy something for instance

28
00:01:06,799 --> 00:01:08,640
so to do so you will commit to this

29
00:01:08,640 --> 00:01:10,479
value to a verifier

30
00:01:10,479 --> 00:01:12,400
and then you will have to give it a

31
00:01:12,400 --> 00:01:14,880
proof that it belongs to the

32
00:01:14,880 --> 00:01:17,360
intended range and the verifier must be

33
00:01:17,360 --> 00:01:20,320
convinced in the end

34
00:01:20,640 --> 00:01:23,040
the unboundedness property means that

35
00:01:23,040 --> 00:01:26,560
the cr is used to commit to the integer

36
00:01:26,560 --> 00:01:28,080
x

37
00:01:28,080 --> 00:01:32,560
does not bound the values a and b

38
00:01:32,560 --> 00:01:35,360
and the rate which we want constant it's

39
00:01:35,360 --> 00:01:37,439
the ratio of everything you send to the

40
00:01:37,439 --> 00:01:40,320
verifier over the length of your wing of

41
00:01:40,320 --> 00:01:42,960
your weakness your weakness

42
00:01:42,960 --> 00:01:46,798
being the integer you have committed to

43
00:01:47,439 --> 00:01:51,840
so we can look at two previous examples

44
00:01:51,840 --> 00:01:54,799
so first we could try to instantiate

45
00:01:54,799 --> 00:01:57,119
crotch eye proofs

46
00:01:57,119 --> 00:02:00,960
in a particular way to get range proof

47
00:02:00,960 --> 00:02:03,439
we may be achieving unboundedness but

48
00:02:03,439 --> 00:02:07,200
however we do not get the constant rate

49
00:02:07,200 --> 00:02:09,440
another interesting previous work which

50
00:02:09,440 --> 00:02:12,080
is more recent is work by couture and

51
00:02:12,080 --> 00:02:13,440
co-authors

52
00:02:13,440 --> 00:02:15,760
it uses duration of encoding that we

53
00:02:15,760 --> 00:02:17,760
will be using too

54
00:02:17,760 --> 00:02:20,640
and they use that in different settings

55
00:02:20,640 --> 00:02:22,720
but in all of those settings

56
00:02:22,720 --> 00:02:26,640
they don't get the unboundedness

57
00:02:26,640 --> 00:02:27,920
property

58
00:02:27,920 --> 00:02:31,840
and in our work we notice that if we use

59
00:02:31,840 --> 00:02:35,440
their ids in the dcr setting

60
00:02:35,440 --> 00:02:37,200
then we are able to achieve

61
00:02:37,200 --> 00:02:39,519
unboundedness and constant rates because

62
00:02:39,519 --> 00:02:42,800
of some property that dcr has and that

63
00:02:42,800 --> 00:02:45,200
i'll talk about later

64
00:02:45,200 --> 00:02:47,920
in a second time we'll be working on

65
00:02:47,920 --> 00:02:50,640
threshold public encryption schemes

66
00:02:50,640 --> 00:02:53,680
which are basically the same as pke

67
00:02:53,680 --> 00:02:55,680
except that you distribute the

68
00:02:55,680 --> 00:02:57,920
decryption algorithm

69
00:02:57,920 --> 00:03:00,640
so you have n servers each of them has

70
00:03:00,640 --> 00:03:01,760
some

71
00:03:01,760 --> 00:03:04,640
private key share and when they get a

72
00:03:04,640 --> 00:03:06,239
ciphertext they compute a partial

73
00:03:06,239 --> 00:03:07,360
decryption

74
00:03:07,360 --> 00:03:08,959
when you recover

75
00:03:08,959 --> 00:03:12,000
t out of n partial decryption then you

76
00:03:12,000 --> 00:03:13,840
can recombine them and recover the

77
00:03:13,840 --> 00:03:15,920
message and

78
00:03:15,920 --> 00:03:17,840
in this setting

79
00:03:17,840 --> 00:03:20,720
now young was already instantiated under

80
00:03:20,720 --> 00:03:22,800
the dcr assumption

81
00:03:22,800 --> 00:03:24,000
but

82
00:03:24,000 --> 00:03:26,640
the the proof they used for plain text

83
00:03:26,640 --> 00:03:29,280
equality the proof system they used was

84
00:03:29,280 --> 00:03:31,440
flow

85
00:03:31,440 --> 00:03:34,480
so it does not really hold anymore

86
00:03:34,480 --> 00:03:37,760
we could also compare our results with

87
00:03:37,760 --> 00:03:40,799
one of our previous work where we give

88
00:03:40,799 --> 00:03:42,640
also

89
00:03:42,640 --> 00:03:45,040
well a cpke

90
00:03:45,040 --> 00:03:46,879
in under the dcr assumption that

91
00:03:46,879 --> 00:03:49,760
satisfies the ncca to security against

92
00:03:49,760 --> 00:03:51,599
adaptive adversaries in the standard

93
00:03:51,599 --> 00:03:52,879
model

94
00:03:52,879 --> 00:03:55,360
because it has the drawback that the key

95
00:03:55,360 --> 00:03:56,799
shares

96
00:03:56,799 --> 00:04:01,439
grows with the number of servers

97
00:04:01,439 --> 00:04:03,599
in this work we are proposing a new

98
00:04:03,599 --> 00:04:05,920
sigma protocol and a new way to turn it

99
00:04:05,920 --> 00:04:08,400
into an uninteractive proof system

100
00:04:08,400 --> 00:04:10,640
that lets us instantiate narayan in a

101
00:04:10,640 --> 00:04:12,239
standard model

102
00:04:12,239 --> 00:04:14,080
we have a slightly weaker security

103
00:04:14,080 --> 00:04:16,000
because we're only secure against static

104
00:04:16,000 --> 00:04:17,839
adversaries

105
00:04:17,839 --> 00:04:19,839
uh and that's adaptive

106
00:04:19,839 --> 00:04:22,720
but the public key and key shares

107
00:04:22,720 --> 00:04:25,040
don't grow with the number of servers

108
00:04:25,040 --> 00:04:26,880
and so we have

109
00:04:26,880 --> 00:04:29,840
a smaller key

110
00:04:30,960 --> 00:04:33,360
so let me first recall what is the zeta

111
00:04:33,360 --> 00:04:35,040
decision composite residuality

112
00:04:35,040 --> 00:04:36,400
assumption

113
00:04:36,400 --> 00:04:38,880
so basically taking

114
00:04:38,880 --> 00:04:39,919
an

115
00:04:39,919 --> 00:04:42,960
rsa modulus it is hard to distinguish

116
00:04:42,960 --> 00:04:44,800
between a random

117
00:04:44,800 --> 00:04:47,280
and to the zeta residue but n to the

118
00:04:47,280 --> 00:04:48,800
zeta plus one

119
00:04:48,800 --> 00:04:50,720
and

120
00:04:50,720 --> 00:04:53,600
a random invertible element of z n to

121
00:04:53,600 --> 00:04:55,600
the theta plus one

122
00:04:55,600 --> 00:04:58,000
it has the nice property that will lets

123
00:04:58,000 --> 00:05:00,720
us reach the unboundedness

124
00:05:00,720 --> 00:05:02,000
that

125
00:05:02,000 --> 00:05:05,280
for any zeta polynomial in lambda then

126
00:05:05,280 --> 00:05:08,160
it's equivalent to the zeta

127
00:05:08,160 --> 00:05:09,919
dcr assumption is equivalent to the one

128
00:05:09,919 --> 00:05:12,800
dcr assumption so it means that with one

129
00:05:12,800 --> 00:05:17,039
crs comprised of and rsa modulus

130
00:05:17,039 --> 00:05:19,600
you are able to do a lot of different

131
00:05:19,600 --> 00:05:22,560
instantiations

132
00:05:23,360 --> 00:05:25,520
of dcr

133
00:05:25,520 --> 00:05:28,320
so that's the first tool

134
00:05:28,320 --> 00:05:30,160
what we want to build

135
00:05:30,160 --> 00:05:32,479
is a trader sigma protocol for gap

136
00:05:32,479 --> 00:05:35,120
language so gap language it's actually

137
00:05:35,120 --> 00:05:37,360
two languages with l sound being

138
00:05:37,360 --> 00:05:40,560
slightly bigger than l z k

139
00:05:40,560 --> 00:05:44,400
and so we will see that

140
00:05:44,400 --> 00:05:46,800
stuff that is done honestly

141
00:05:46,800 --> 00:05:49,520
belongs to lck

142
00:05:49,520 --> 00:05:50,400
but

143
00:05:50,400 --> 00:05:52,880
when we want to prove the soundness

144
00:05:52,880 --> 00:05:56,240
uh we only prove that outside of l sound

145
00:05:56,240 --> 00:05:57,759
you cannot do

146
00:05:57,759 --> 00:06:00,319
false proofs so we have some gap between

147
00:06:00,319 --> 00:06:01,840
what we can

148
00:06:01,840 --> 00:06:06,919
honestly prove and not honestly pull

149
00:06:07,280 --> 00:06:09,199
so other than that it is a sigma

150
00:06:09,199 --> 00:06:10,880
protocol in the sense that we have

151
00:06:10,880 --> 00:06:12,800
approver and a verifier the approver

152
00:06:12,800 --> 00:06:14,960
computes the first statement

153
00:06:14,960 --> 00:06:17,840
then the verifier returns a challenge

154
00:06:17,840 --> 00:06:19,759
and the approver must respond to that

155
00:06:19,759 --> 00:06:21,199
challenge

156
00:06:21,199 --> 00:06:24,240
depending on this response the verifier

157
00:06:24,240 --> 00:06:26,479
acceptor rejects

158
00:06:26,479 --> 00:06:28,720
we want the following properties for our

159
00:06:28,720 --> 00:06:30,560
trapdoor sigma protocols first the

160
00:06:30,560 --> 00:06:32,840
completeness which is if you do stuff

161
00:06:32,840 --> 00:06:35,120
correctly then

162
00:06:35,120 --> 00:06:37,039
verify your accents

163
00:06:37,039 --> 00:06:39,280
the special zero knowledge is that on

164
00:06:39,280 --> 00:06:40,960
input

165
00:06:40,960 --> 00:06:44,400
uh a statement x that belongs to ldk and

166
00:06:44,400 --> 00:06:45,840
a challenge

167
00:06:45,840 --> 00:06:46,880
then

168
00:06:46,880 --> 00:06:49,520
you can generate false transcripts that

169
00:06:49,520 --> 00:06:51,440
are indistinguishable from a real

170
00:06:51,440 --> 00:06:53,840
transcript

171
00:06:53,840 --> 00:06:56,800
so we have the special soundness so as i

172
00:06:56,800 --> 00:06:58,560
said this is here where we get the gap

173
00:06:58,560 --> 00:07:01,199
between lck and l sound because here if

174
00:07:01,199 --> 00:07:03,360
x does not belong to f sound

175
00:07:03,360 --> 00:07:06,000
then whatever first message you send

176
00:07:06,000 --> 00:07:10,000
and whatever challenge is then returned

177
00:07:10,000 --> 00:07:13,120
there is no accepting answer

178
00:07:13,120 --> 00:07:14,960
except for

179
00:07:14,960 --> 00:07:17,840
one challenge

180
00:07:19,440 --> 00:07:20,800
so

181
00:07:20,800 --> 00:07:22,319
this challenge will be computed by

182
00:07:22,319 --> 00:07:23,919
something called the bad challenge

183
00:07:23,919 --> 00:07:26,000
function

184
00:07:26,000 --> 00:07:28,400
but this best challenge function

185
00:07:28,400 --> 00:07:31,120
needs some

186
00:07:31,120 --> 00:07:34,400
supplementary information that is given

187
00:07:34,400 --> 00:07:36,160
by a trapdoor

188
00:07:36,160 --> 00:07:37,919
and to get this trapdoor you have to

189
00:07:37,919 --> 00:07:41,039
replace the generation of crs gem

190
00:07:41,039 --> 00:07:44,479
by the trap gen algorithm so think of it

191
00:07:44,479 --> 00:07:46,479
as

192
00:07:46,479 --> 00:07:49,280
the crs will always be

193
00:07:49,280 --> 00:07:51,599
some rsa modulus n

194
00:07:51,599 --> 00:07:54,000
and so the trapdoor will always be its

195
00:07:54,000 --> 00:07:56,960
factorization pq

196
00:07:56,960 --> 00:07:59,840
okay

197
00:08:00,400 --> 00:08:02,400
uh the next tool is

198
00:08:02,400 --> 00:08:03,360
this

199
00:08:03,360 --> 00:08:07,039
uh racial encoding so let's say we have

200
00:08:07,039 --> 00:08:10,840
some rational number r over s

201
00:08:10,840 --> 00:08:14,160
which belongs to so the numerator and

202
00:08:14,160 --> 00:08:15,919
denominator belongs to some specific

203
00:08:15,919 --> 00:08:17,520
range okay

204
00:08:17,520 --> 00:08:20,639
we are going to encode it as r times s

205
00:08:20,639 --> 00:08:23,680
to the minus one but n to the zeta where

206
00:08:23,680 --> 00:08:25,360
zeta is chosen

207
00:08:25,360 --> 00:08:27,919
in a particular way

208
00:08:27,919 --> 00:08:30,080
now how do we extract t from its

209
00:08:30,080 --> 00:08:31,919
encoding

210
00:08:31,919 --> 00:08:34,159
well we can define the following

211
00:08:34,159 --> 00:08:36,399
two-dimensional lattice lambda

212
00:08:36,399 --> 00:08:37,839
okay

213
00:08:37,839 --> 00:08:40,799
which is the x y that satisfies

214
00:08:40,799 --> 00:08:45,519
x s times x is equal to y times r but n

215
00:08:45,519 --> 00:08:47,040
to the zeta

216
00:08:47,040 --> 00:08:49,519
and we actually know a particular basis

217
00:08:49,519 --> 00:08:52,240
of this

218
00:08:52,959 --> 00:08:55,839
lattice okay this vector and this vector

219
00:08:55,839 --> 00:08:56,720
they

220
00:08:56,720 --> 00:08:59,760
form basis of it

221
00:08:59,839 --> 00:09:02,640
and so we are able to use ghost

222
00:09:02,640 --> 00:09:05,920
algorithm to recover r and s this was

223
00:09:05,920 --> 00:09:08,320
proven in a previous work so we can

224
00:09:08,320 --> 00:09:10,399
recover

225
00:09:10,399 --> 00:09:12,959
rns

226
00:09:13,040 --> 00:09:15,839
so using this we can define the

227
00:09:15,839 --> 00:09:18,800
following encryption over rationals

228
00:09:18,800 --> 00:09:21,040
so this is basically

229
00:09:21,040 --> 00:09:24,399
the damn guardian encryption scheme okay

230
00:09:24,399 --> 00:09:27,440
where the data is chosen accordingly

231
00:09:27,440 --> 00:09:30,560
depending on the size

232
00:09:30,560 --> 00:09:33,120
of the message that you want to encrypt

233
00:09:33,120 --> 00:09:34,720
like okay

234
00:09:34,720 --> 00:09:37,200
so you choose this setup any particular

235
00:09:37,200 --> 00:09:38,800
way and then you compute a pie

236
00:09:38,800 --> 00:09:41,839
encryption of the message over the data

237
00:09:41,839 --> 00:09:43,839
you've chosen

238
00:09:43,839 --> 00:09:45,279
and to decrypt

239
00:09:45,279 --> 00:09:47,360
you actually get some message prime

240
00:09:47,360 --> 00:09:49,920
using the same encryption algorithm as

241
00:09:49,920 --> 00:09:53,200
in the top gear jury encryption scheme

242
00:09:53,200 --> 00:09:56,560
but at the end you use ghost's algorithm

243
00:09:56,560 --> 00:09:59,600
to write the message as the encoding of

244
00:09:59,600 --> 00:10:02,880
some rational number

245
00:10:02,880 --> 00:10:07,680
okay so this lets you apply homomorphic

246
00:10:08,720 --> 00:10:11,440
homomorphic operations

247
00:10:11,440 --> 00:10:13,600
on ciphertext

248
00:10:13,600 --> 00:10:15,519
even overrationals

249
00:10:15,519 --> 00:10:17,680
but still get a correct decryption in

250
00:10:17,680 --> 00:10:20,079
the end

251
00:10:25,120 --> 00:10:27,600
so we move to the first

252
00:10:27,600 --> 00:10:30,079
result

253
00:10:30,800 --> 00:10:33,839
so let's say i have an integer x

254
00:10:33,839 --> 00:10:37,600
i take it in 0 b because if it was in

255
00:10:37,600 --> 00:10:40,959
some a i could simply consider x minus a

256
00:10:40,959 --> 00:10:44,079
to get it back to that case

257
00:10:44,079 --> 00:10:46,000
so the commitment i will consider to

258
00:10:46,000 --> 00:10:48,800
that intention is an encryption of it

259
00:10:48,800 --> 00:10:52,320
from the previous scheme okay

260
00:10:52,320 --> 00:10:54,160
and actually

261
00:10:54,160 --> 00:10:57,200
what we will do is we'll commit to the

262
00:10:57,200 --> 00:10:58,399
following

263
00:10:58,399 --> 00:10:59,760
uh

264
00:10:59,760 --> 00:11:02,560
to the following integers

265
00:11:02,560 --> 00:11:05,360
where we actually write one plus four

266
00:11:05,360 --> 00:11:07,600
times b minus x times x

267
00:11:07,600 --> 00:11:11,519
as the sum of three squares

268
00:11:11,519 --> 00:11:13,360
and so what we actually want to prove

269
00:11:13,360 --> 00:11:15,279
membership of

270
00:11:15,279 --> 00:11:16,320
it's

271
00:11:16,320 --> 00:11:17,440
of

272
00:11:17,440 --> 00:11:18,160
so

273
00:11:18,160 --> 00:11:20,720
you take four encryptions

274
00:11:20,720 --> 00:11:22,880
and you want to see that they are

275
00:11:22,880 --> 00:11:24,399
encryption

276
00:11:24,399 --> 00:11:26,079
of

277
00:11:26,079 --> 00:11:29,040
four integers that satisfies

278
00:11:29,040 --> 00:11:32,079
this relation this relation

279
00:11:32,079 --> 00:11:32,959
okay

280
00:11:32,959 --> 00:11:36,399
and actually what we can prove is that

281
00:11:36,399 --> 00:11:38,640
if we prove membership of that language

282
00:11:38,640 --> 00:11:40,560
then we prove

283
00:11:40,560 --> 00:11:43,200
we give a convincing proof that x is in

284
00:11:43,200 --> 00:11:45,680
zero b

285
00:11:46,079 --> 00:11:47,600
so we have to consider since we are

286
00:11:47,600 --> 00:11:49,360
working with gap

287
00:11:49,360 --> 00:11:52,959
languages we need a soundness language

288
00:11:52,959 --> 00:11:54,959
in this soundless language

289
00:11:54,959 --> 00:11:57,600
it's actually

290
00:11:57,600 --> 00:12:02,160
the same except that they are encryption

291
00:12:02,240 --> 00:12:04,320
uh

292
00:12:04,320 --> 00:12:06,720
of encoded rationals

293
00:12:06,720 --> 00:12:09,040
and because of the rounding operation at

294
00:12:09,040 --> 00:12:11,680
the end

295
00:12:11,680 --> 00:12:14,959
well when you decrypt you may not

296
00:12:14,959 --> 00:12:17,680
get this this to be true

297
00:12:17,680 --> 00:12:20,160
anymore even if it holds inside this

298
00:12:20,160 --> 00:12:22,240
language so this is why this this is a

299
00:12:22,240 --> 00:12:24,079
soundis language which is slightly

300
00:12:24,079 --> 00:12:25,279
bigger

301
00:12:25,279 --> 00:12:28,160
because this may not hold but

302
00:12:28,160 --> 00:12:30,399
the values are not too far

303
00:12:30,399 --> 00:12:33,200
from one another

304
00:12:33,360 --> 00:12:35,279
so how do we do that

305
00:12:35,279 --> 00:12:38,480
so let's say that i have so my statement

306
00:12:38,480 --> 00:12:41,040
is the commitment to my integer okay so

307
00:12:41,040 --> 00:12:43,040
that's the encryption

308
00:12:43,040 --> 00:12:46,800
and my witness it's x and

309
00:12:46,800 --> 00:12:49,760
the randomness i used

310
00:12:49,760 --> 00:12:51,200
so now

311
00:12:51,200 --> 00:12:53,920
p as we said before will generate

312
00:12:53,920 --> 00:12:57,519
encryption of the decomposition

313
00:12:57,519 --> 00:13:00,240
that we proposed before okay so this is

314
00:13:00,240 --> 00:13:01,040
all

315
00:13:01,040 --> 00:13:03,760
this is everything i put in right

316
00:13:03,760 --> 00:13:08,319
x i and the randomness si that were used

317
00:13:08,959 --> 00:13:11,360
then it will need fresh randomness that

318
00:13:11,360 --> 00:13:13,279
i put in green

319
00:13:13,279 --> 00:13:15,600
and it computes the following encryption

320
00:13:15,600 --> 00:13:18,800
r which may seem a bit weird at first

321
00:13:18,800 --> 00:13:21,920
but not the following if r 0

322
00:13:21,920 --> 00:13:26,000
you change it into b minus x 0

323
00:13:26,000 --> 00:13:30,480
and x r i you turn it into the red x i

324
00:13:30,480 --> 00:13:32,800
then all that

325
00:13:32,800 --> 00:13:37,120
okay it's just an encryption of one

326
00:13:37,920 --> 00:13:39,680
so this will be important later so try

327
00:13:39,680 --> 00:13:41,600
to keep it in mind

328
00:13:41,600 --> 00:13:44,639
and then for consistency it encrypts the

329
00:13:44,639 --> 00:13:49,279
r the ri you used before in big rr and

330
00:13:49,279 --> 00:13:51,199
it sends all of that in the end the

331
00:13:51,199 --> 00:13:52,560
commitment

332
00:13:52,560 --> 00:13:54,000
the encryption

333
00:13:54,000 --> 00:13:57,120
and the value r

334
00:13:57,120 --> 00:13:59,440
then it gets a challenge

335
00:13:59,440 --> 00:14:00,880
which belongs to zero to the lambda

336
00:14:00,880 --> 00:14:03,040
number -1

337
00:14:03,040 --> 00:14:06,480
and it is computing most importantly z i

338
00:14:06,480 --> 00:14:10,320
which is r i plus child times x i

339
00:14:10,320 --> 00:14:13,519
and then some randomness values that are

340
00:14:13,519 --> 00:14:16,480
consistent with the zi

341
00:14:16,480 --> 00:14:19,440
consistent in the following way

342
00:14:19,440 --> 00:14:20,800
v will be

343
00:14:20,800 --> 00:14:23,040
checking the following things

344
00:14:23,040 --> 00:14:26,240
first it checks that ri and ci are

345
00:14:26,240 --> 00:14:29,360
consistent with the zi

346
00:14:29,360 --> 00:14:31,279
in the sense that they must satisfy this

347
00:14:31,279 --> 00:14:34,320
property okay

348
00:14:34,800 --> 00:14:37,519
and most importantly

349
00:14:37,519 --> 00:14:39,839
it computes this value this boolean

350
00:14:39,839 --> 00:14:41,120
value

351
00:14:41,120 --> 00:14:42,959
and we see the following so c i to the

352
00:14:42,959 --> 00:14:44,880
minus z i

353
00:14:44,880 --> 00:14:46,800
when we look at it

354
00:14:46,800 --> 00:14:48,079
uh

355
00:14:48,079 --> 00:14:49,519
and expand it

356
00:14:49,519 --> 00:14:52,240
we see that the red parts as i said

357
00:14:52,240 --> 00:14:54,160
before you know

358
00:14:54,160 --> 00:14:56,240
all of that the beginning of the cipher

359
00:14:56,240 --> 00:14:59,519
text it will be an encryption of

360
00:14:59,519 --> 00:15:01,040
one

361
00:15:01,040 --> 00:15:03,279
times chart

362
00:15:03,279 --> 00:15:05,680
so this encryption of one times char

363
00:15:05,680 --> 00:15:08,000
we've computed it in the reverse way so

364
00:15:08,000 --> 00:15:10,720
we can remove it with the last

365
00:15:10,720 --> 00:15:13,120
thing we added here

366
00:15:13,120 --> 00:15:14,800
but we still have

367
00:15:14,800 --> 00:15:18,240
all of the leftover green stuff that is

368
00:15:18,240 --> 00:15:20,480
multiplied by the rate red stuff

369
00:15:20,480 --> 00:15:23,040
contained in the ci's

370
00:15:23,040 --> 00:15:24,160
and this is

371
00:15:24,160 --> 00:15:27,120
this will be exactly what r is you know

372
00:15:27,120 --> 00:15:28,720
because it is

373
00:15:28,720 --> 00:15:32,000
uh green stuff times red stuff

374
00:15:32,000 --> 00:15:34,079
this is just to give you an intuition of

375
00:15:34,079 --> 00:15:35,519
what's going on

376
00:15:35,519 --> 00:15:38,160
uh you can spend more time

377
00:15:38,160 --> 00:15:41,360
thinking about it

378
00:15:41,360 --> 00:15:43,759
and in the end we see that this sigma

379
00:15:43,759 --> 00:15:46,480
protocol is satisfying

380
00:15:46,480 --> 00:15:50,800
all of the desired uh properties

381
00:15:50,800 --> 00:15:52,839
so first it is

382
00:15:52,839 --> 00:15:56,079
complete it satisfies the special strand

383
00:15:56,079 --> 00:15:58,560
of edge property it also has the special

384
00:15:58,560 --> 00:16:01,600
soundness and cms indistinguishability

385
00:16:01,600 --> 00:16:03,680
and the bad challenge function is

386
00:16:03,680 --> 00:16:05,519
actually a bit complicated because it

387
00:16:05,519 --> 00:16:06,480
uses

388
00:16:06,480 --> 00:16:09,040
linear programming and let's try some

389
00:16:09,040 --> 00:16:11,599
delivery

390
00:16:11,920 --> 00:16:14,079
but the important result is that it

391
00:16:14,079 --> 00:16:17,680
satisfies unboundedness so it means that

392
00:16:17,680 --> 00:16:20,560
when we fix n

393
00:16:20,560 --> 00:16:22,800
so the crs you know it's

394
00:16:22,800 --> 00:16:25,040
n p times q

395
00:16:25,040 --> 00:16:27,920
and the thing is

396
00:16:27,920 --> 00:16:31,120
we are not constraining the value b here

397
00:16:31,120 --> 00:16:33,440
at all

398
00:16:33,440 --> 00:16:36,720
because whatever value b you take here

399
00:16:36,720 --> 00:16:38,880
then we will take the zeta for the

400
00:16:38,880 --> 00:16:40,079
commitment

401
00:16:40,079 --> 00:16:42,800
accordingly

402
00:16:48,160 --> 00:16:52,319
so this is why we reach unboundedness

403
00:16:52,480 --> 00:16:54,399
then we also

404
00:16:54,399 --> 00:16:58,639
achieve constant rates because

405
00:17:00,320 --> 00:17:02,399
well we can compute

406
00:17:02,399 --> 00:17:03,199
uh

407
00:17:03,199 --> 00:17:04,799
what it is

408
00:17:04,799 --> 00:17:09,039
that we have in a full transcript

409
00:17:09,119 --> 00:17:11,679
and we will see that because of the way

410
00:17:11,679 --> 00:17:13,919
we choose zeta to be the smallest

411
00:17:13,919 --> 00:17:16,480
integer that is close to

412
00:17:16,480 --> 00:17:19,839
the excise and x and everything

413
00:17:19,839 --> 00:17:20,559
uh

414
00:17:20,559 --> 00:17:23,679
we get the constant rate

415
00:17:23,679 --> 00:17:25,280
but most importantly we want a

416
00:17:25,280 --> 00:17:27,520
non-interactive range proof

417
00:17:27,520 --> 00:17:29,360
so to do so

418
00:17:29,360 --> 00:17:32,480
we want to compile all of that into a

419
00:17:32,480 --> 00:17:34,160
multi-theorem than interactive

420
00:17:34,160 --> 00:17:35,600
zero-knowledge proof

421
00:17:35,600 --> 00:17:37,200
but we don't want to lose the inbound in

422
00:17:37,200 --> 00:17:38,559
this property

423
00:17:38,559 --> 00:17:41,919
or nor the constant track property

424
00:17:41,919 --> 00:17:45,679
and we can do so using a different or

425
00:17:45,679 --> 00:17:46,720
tricks

426
00:17:46,720 --> 00:17:48,240
and

427
00:17:48,240 --> 00:17:51,520
over properties like that

428
00:17:52,720 --> 00:17:53,840
so next

429
00:17:53,840 --> 00:17:56,000
we move to

430
00:17:56,000 --> 00:17:58,559
how we instantiate it in our young

431
00:17:58,559 --> 00:18:01,440
paradigm under the dcr assumption in the

432
00:18:01,440 --> 00:18:03,200
threshold setting

433
00:18:03,200 --> 00:18:05,840
so to give you a bit more insight on how

434
00:18:05,840 --> 00:18:07,840
a threshold public key encryption scheme

435
00:18:07,840 --> 00:18:08,799
works

436
00:18:08,799 --> 00:18:10,720
it's actually a five or four of

437
00:18:10,720 --> 00:18:13,280
algorithms key generator keygen and

438
00:18:13,280 --> 00:18:14,880
partial decryptions

439
00:18:14,880 --> 00:18:17,520
partial verification and combine

440
00:18:17,520 --> 00:18:19,600
the partial verification algorithm i

441
00:18:19,600 --> 00:18:22,640
won't talk about here because this is

442
00:18:22,640 --> 00:18:25,440
something we can add on top of

443
00:18:25,440 --> 00:18:29,400
everything at the end

444
00:18:30,080 --> 00:18:32,240
so the idea is that

445
00:18:32,240 --> 00:18:35,200
for the sender nothing changes from a

446
00:18:35,200 --> 00:18:38,000
regular pke

447
00:18:38,000 --> 00:18:40,799
but when you want to decrypt

448
00:18:40,799 --> 00:18:42,400
you have forwarded

449
00:18:42,400 --> 00:18:45,520
secret key shares to each server

450
00:18:45,520 --> 00:18:47,520
so you forward the ciphertext to each of

451
00:18:47,520 --> 00:18:48,720
them

452
00:18:48,720 --> 00:18:51,520
and they compute a partial decryption

453
00:18:51,520 --> 00:18:53,440
of the message

454
00:18:53,440 --> 00:18:55,840
and when you have

455
00:18:55,840 --> 00:18:58,799
at least t uh at least t that you gave

456
00:18:58,799 --> 00:19:00,799
as a parameter here

457
00:19:00,799 --> 00:19:03,760
out of the number of servers

458
00:19:03,760 --> 00:19:05,600
then you can use the combined algorithm

459
00:19:05,600 --> 00:19:08,080
to recover the message and

460
00:19:08,080 --> 00:19:11,039
if if the tpk is correct

461
00:19:11,039 --> 00:19:14,400
so m prime is equal to m

462
00:19:15,200 --> 00:19:16,960
so what kind of

463
00:19:16,960 --> 00:19:19,120
security do we consider for

464
00:19:19,120 --> 00:19:20,400
tpke

465
00:19:20,400 --> 00:19:22,080
in our case we're interested in the

466
00:19:22,080 --> 00:19:25,840
static in cca to security

467
00:19:25,840 --> 00:19:27,440
the security

468
00:19:27,440 --> 00:19:30,240
is as follows the adversary chooses a

469
00:19:30,240 --> 00:19:32,720
num you know a threshold t

470
00:19:32,720 --> 00:19:36,720
and a set of corrupted adversaries

471
00:19:36,720 --> 00:19:39,520
c which is comprised of exactly t minus

472
00:19:39,520 --> 00:19:42,160
one servers

473
00:19:42,160 --> 00:19:45,039
and the challenger it will generate the

474
00:19:45,039 --> 00:19:47,120
public key and secret key accordingly to

475
00:19:47,120 --> 00:19:49,600
the choice of the threshold and it will

476
00:19:49,600 --> 00:19:52,480
return the public key and

477
00:19:52,480 --> 00:19:54,799
the secret key shares of corrupted

478
00:19:54,799 --> 00:19:57,440
servers

479
00:19:58,000 --> 00:20:01,280
so this is an ncca to security so

480
00:20:01,280 --> 00:20:03,919
you have access to not a decryption

481
00:20:03,919 --> 00:20:06,400
algorithm because there is none here but

482
00:20:06,400 --> 00:20:08,240
you have access to every partial

483
00:20:08,240 --> 00:20:10,159
decryption algorithm

484
00:20:10,159 --> 00:20:12,559
for each of the servers

485
00:20:12,559 --> 00:20:14,640
and also you have the challenge query at

486
00:20:14,640 --> 00:20:18,159
some point as in nccl to security for

487
00:20:18,159 --> 00:20:21,159
pkes

488
00:20:22,320 --> 00:20:24,480
and you have to guess which message was

489
00:20:24,480 --> 00:20:26,960
encrypted

490
00:20:27,039 --> 00:20:30,000
uh another interesting point is that you

491
00:20:30,000 --> 00:20:31,840
can make decryption queries for the

492
00:20:31,840 --> 00:20:34,400
challenge as long as you don't trivially

493
00:20:34,400 --> 00:20:36,320
win so it means that if you make

494
00:20:36,320 --> 00:20:39,360
decryption queries for the challenge

495
00:20:39,360 --> 00:20:41,200
then these queries must be made for

496
00:20:41,200 --> 00:20:42,559
servers that were corrected at the

497
00:20:42,559 --> 00:20:44,960
beginning

498
00:20:47,280 --> 00:20:48,400
so

499
00:20:48,400 --> 00:20:51,120
what we want to build uh in particular

500
00:20:51,120 --> 00:20:54,000
it is a treble sigma protocol

501
00:20:54,000 --> 00:20:56,000
for the language

502
00:20:56,000 --> 00:20:57,360
of

503
00:20:57,360 --> 00:21:00,320
cipher texts that encrypt the same

504
00:21:00,320 --> 00:21:05,039
message m but over different modulus n1

505
00:21:05,039 --> 00:21:06,480
and n2

506
00:21:06,480 --> 00:21:08,640
okay

507
00:21:08,640 --> 00:21:10,320
in the case

508
00:21:10,320 --> 00:21:12,240
of the soundness language

509
00:21:12,240 --> 00:21:15,360
since we are considering gap languages

510
00:21:15,360 --> 00:21:16,640
uh

511
00:21:16,640 --> 00:21:19,840
it is simply that we are encrypting

512
00:21:19,840 --> 00:21:20,799
not

513
00:21:20,799 --> 00:21:22,159
only

514
00:21:22,159 --> 00:21:25,039
a message an integer message

515
00:21:25,039 --> 00:21:27,360
but we are encrypting a rational which

516
00:21:27,360 --> 00:21:29,600
belongs to

517
00:21:29,600 --> 00:21:31,200
where the numerator and denominator

518
00:21:31,200 --> 00:21:34,640
belongs to this range

519
00:21:35,360 --> 00:21:36,640
okay

520
00:21:36,640 --> 00:21:39,360
of course uh zeta

521
00:21:39,360 --> 00:21:41,679
must correspond to

522
00:21:41,679 --> 00:21:44,640
some particular

523
00:21:44,640 --> 00:21:47,200
choice minimalizing

524
00:21:47,200 --> 00:21:48,000
the

525
00:21:48,000 --> 00:21:49,840
minimalizing the

526
00:21:49,840 --> 00:21:51,919
modulus

527
00:21:51,919 --> 00:21:53,840
but still allowing for correct

528
00:21:53,840 --> 00:21:56,640
decryption at the end

529
00:21:56,640 --> 00:21:58,799
so how do we do that

530
00:21:58,799 --> 00:21:59,919
well

531
00:21:59,919 --> 00:22:03,360
this is a bit more uh standard because

532
00:22:03,360 --> 00:22:04,880
we are actually

533
00:22:04,880 --> 00:22:09,760
encrypting some random first message

534
00:22:09,760 --> 00:22:12,400
for both modulus okay

535
00:22:12,400 --> 00:22:16,159
so we produce two two cypher texts

536
00:22:16,159 --> 00:22:18,320
then we get a random challenge

537
00:22:18,320 --> 00:22:21,360
and what we have to provide the verifier

538
00:22:21,360 --> 00:22:22,320
is

539
00:22:22,320 --> 00:22:24,799
the following message

540
00:22:24,799 --> 00:22:27,039
a plus child times m

541
00:22:27,039 --> 00:22:30,799
and we have to provide the randomness

542
00:22:30,799 --> 00:22:34,880
to make sure that we can compute

543
00:22:34,880 --> 00:22:37,919
well to make sure that if you encrypt z

544
00:22:37,919 --> 00:22:40,320
using this randomness then you get the

545
00:22:40,320 --> 00:22:42,960
homomorphic encryption

546
00:22:42,960 --> 00:22:46,400
of a plus channel m using the big a b

547
00:22:46,400 --> 00:22:50,679
and the commitment ct1ct2

548
00:22:50,799 --> 00:22:52,880
so what v is checking

549
00:22:52,880 --> 00:22:55,280
is indeed that

550
00:22:55,280 --> 00:22:57,120
if you compute this homomorphic

551
00:22:57,120 --> 00:22:59,919
encryption which is normally an

552
00:22:59,919 --> 00:23:01,679
encryption of c

553
00:23:01,679 --> 00:23:04,640
by choice of char

554
00:23:04,640 --> 00:23:06,880
then you should get exactly this

555
00:23:06,880 --> 00:23:08,480
encryption

556
00:23:08,480 --> 00:23:12,640
where everything was provided here

557
00:23:13,679 --> 00:23:15,440
so once again

558
00:23:15,440 --> 00:23:17,200
we have the completeness special zero

559
00:23:17,200 --> 00:23:18,880
knowledge special soundness and crs

560
00:23:18,880 --> 00:23:21,520
indistinguishability properties

561
00:23:21,520 --> 00:23:24,159
and once more the bad challenge function

562
00:23:24,159 --> 00:23:26,320
so it uses a strapped door the

563
00:23:26,320 --> 00:23:28,799
factorization of n1 and n2

564
00:23:28,799 --> 00:23:30,720
and it still needs to use linear

565
00:23:30,720 --> 00:23:33,200
programming and lens trans algorithm in

566
00:23:33,200 --> 00:23:36,559
order to find the bad challenge

567
00:23:36,559 --> 00:23:38,480
also

568
00:23:38,480 --> 00:23:41,760
for what we want to use it in

569
00:23:41,760 --> 00:23:44,559
we are actually giving

570
00:23:44,559 --> 00:23:48,400
a new way to turn

571
00:23:48,400 --> 00:23:50,720
this previous

572
00:23:50,720 --> 00:23:53,039
uh protocol

573
00:23:53,039 --> 00:23:55,039
into a one-time simulation sound and

574
00:23:55,039 --> 00:23:57,600
interactive zero on an edge proof system

575
00:23:57,600 --> 00:23:59,760
because this new compiler it lets us do

576
00:23:59,760 --> 00:24:02,000
so without imposing a bound on the plain

577
00:24:02,000 --> 00:24:04,720
text space which is exactly what we want

578
00:24:04,720 --> 00:24:07,919
because we would like to

579
00:24:07,919 --> 00:24:09,919
be as close as possible to the damn

580
00:24:09,919 --> 00:24:13,279
guardioric encryption scheme

581
00:24:14,720 --> 00:24:16,240
so

582
00:24:16,240 --> 00:24:18,159
to give you a brief intuition of the

583
00:24:18,159 --> 00:24:20,720
construction

584
00:24:20,720 --> 00:24:24,400
well we start by instantiating twice

585
00:24:24,400 --> 00:24:26,320
vanguard uric

586
00:24:26,320 --> 00:24:29,279
and we take the secret key of the first

587
00:24:29,279 --> 00:24:30,960
instantiation and share it using

588
00:24:30,960 --> 00:24:34,000
xiaomi's secret chain

589
00:24:34,000 --> 00:24:36,799
then what is a ciphertext

590
00:24:36,799 --> 00:24:39,360
ciphertext it's simply an encryption

591
00:24:39,360 --> 00:24:40,799
under

592
00:24:40,799 --> 00:24:42,720
both schemes

593
00:24:42,720 --> 00:24:45,360
and also we add a proof using our

594
00:24:45,360 --> 00:24:48,559
previous construction but the plain text

595
00:24:48,559 --> 00:24:52,799
encrypted are the same for both messages

596
00:24:52,799 --> 00:24:55,039
then how do we decrypt

597
00:24:55,039 --> 00:24:58,159
well we can use the partial secret key

598
00:24:58,159 --> 00:25:00,640
to so we can take

599
00:25:00,640 --> 00:25:03,520
first we verify the proof if

600
00:25:03,520 --> 00:25:05,200
the proof is wrong then we don't do

601
00:25:05,200 --> 00:25:06,480
anything

602
00:25:06,480 --> 00:25:09,440
if it's right if it's accepted then we

603
00:25:09,440 --> 00:25:10,960
use

604
00:25:10,960 --> 00:25:13,520
we compute the first cipher text to the

605
00:25:13,520 --> 00:25:16,400
power something times the partial secret

606
00:25:16,400 --> 00:25:17,360
key

607
00:25:17,360 --> 00:25:20,480
as would be the first step

608
00:25:20,480 --> 00:25:22,880
of

609
00:25:22,960 --> 00:25:25,760
the damn cardioid decryption

610
00:25:25,760 --> 00:25:27,279
and when we have enough partial

611
00:25:27,279 --> 00:25:30,480
decryptions then we can recombine

612
00:25:30,480 --> 00:25:32,880
to recombine we have to recover the

613
00:25:32,880 --> 00:25:34,799
secret key

614
00:25:34,799 --> 00:25:36,240
in the exponent

615
00:25:36,240 --> 00:25:38,000
of the decryptions

616
00:25:38,000 --> 00:25:40,559
so we can do it and then we can run the

617
00:25:40,559 --> 00:25:43,760
rest of the damn gatorade decryption

618
00:25:43,760 --> 00:25:46,158
scheme

619
00:25:47,039 --> 00:25:50,159
and by doing so we achieve cca to

620
00:25:50,159 --> 00:25:54,000
security under static corruption queries

621
00:25:54,000 --> 00:25:57,200
and moreover you'll notice that

622
00:25:57,200 --> 00:25:59,440
since we only have social media secret

623
00:25:59,440 --> 00:26:00,720
sharing

624
00:26:00,720 --> 00:26:01,679
and

625
00:26:01,679 --> 00:26:04,320
n1n2 has public keys

626
00:26:04,320 --> 00:26:05,520
then

627
00:26:05,520 --> 00:26:08,880
the public and secret key shares don't

628
00:26:08,880 --> 00:26:11,120
depend on the number of servers that we

629
00:26:11,120 --> 00:26:13,760
had before

630
00:26:14,400 --> 00:26:16,960
so this is it

631
00:26:16,960 --> 00:26:18,960
i thank you for your

632
00:26:18,960 --> 00:26:21,440
attention and for watching this video up

633
00:26:21,440 --> 00:26:25,000
until the end

634
00:26:26,320 --> 00:26:29,879
please look forward

