1
00:00:00,480 --> 00:00:04,000
the topic of this talk is traceable prfs

2
00:00:04,000 --> 00:00:06,080
full collision resistance and active

3
00:00:06,080 --> 00:00:07,359
security

4
00:00:07,359 --> 00:00:11,200
this is joint work with david wu

5
00:00:11,360 --> 00:00:13,360
the primary goal of traceable

6
00:00:13,360 --> 00:00:14,639
cryptography

7
00:00:14,639 --> 00:00:16,960
is to prevent unauthorized distribution

8
00:00:16,960 --> 00:00:18,160
of software

9
00:00:18,160 --> 00:00:20,000
and this is done by preventing

10
00:00:20,000 --> 00:00:22,000
unauthorized redistribution of

11
00:00:22,000 --> 00:00:24,080
cryptographic functionality

12
00:00:24,080 --> 00:00:26,160
functionalities

13
00:00:26,160 --> 00:00:28,720
typically in such a scheme we want to

14
00:00:28,720 --> 00:00:30,960
embed a mark within cryptographic

15
00:00:30,960 --> 00:00:32,800
objects

16
00:00:32,800 --> 00:00:35,280
and this can come in various forms for

17
00:00:35,280 --> 00:00:37,440
example decryption keys in an encryption

18
00:00:37,440 --> 00:00:38,879
scheme

19
00:00:38,879 --> 00:00:41,600
signing keys in a signature scheme and

20
00:00:41,600 --> 00:00:42,840
so on and so

21
00:00:42,840 --> 00:00:45,680
forth there is a pirate device which is

22
00:00:45,680 --> 00:00:47,760
attempting replication of the underlying

23
00:00:47,760 --> 00:00:49,760
functionality

24
00:00:49,760 --> 00:00:51,440
and the security requirement is the

25
00:00:51,440 --> 00:00:53,440
following if such a successful

26
00:00:53,440 --> 00:00:55,039
replication is

27
00:00:55,039 --> 00:00:58,559
achieved then we should be also able to

28
00:00:58,559 --> 00:01:00,559
successfully trace back to the set of

29
00:01:00,559 --> 00:01:02,399
corrupt identities

30
00:01:02,399 --> 00:01:07,040
that were used to build this device

31
00:01:08,880 --> 00:01:11,439
the notion of traceable pseudorandom

32
00:01:11,439 --> 00:01:14,479
functions was

33
00:01:14,479 --> 00:01:16,479
introduced by goyal at all in a very

34
00:01:16,479 --> 00:01:19,040
recent work in 2021

35
00:01:19,040 --> 00:01:21,119
informally it says that if there is a

36
00:01:21,119 --> 00:01:23,759
program c that can distinguish

37
00:01:23,759 --> 00:01:24,640
from

38
00:01:24,640 --> 00:01:27,360
a pseudorandom function from a random

39
00:01:27,360 --> 00:01:30,479
function on randomly sampled inputs then

40
00:01:30,479 --> 00:01:32,720
marked identities used to build the

41
00:01:32,720 --> 00:01:35,200
device should be traceable

42
00:01:35,200 --> 00:01:36,720
used to build the pilot device as we

43
00:01:36,720 --> 00:01:38,479
just saw

44
00:01:38,479 --> 00:01:40,720
so more formally or more generally this

45
00:01:40,720 --> 00:01:42,640
is the diagram

46
00:01:42,640 --> 00:01:44,720
so suppose an adversary is given the

47
00:01:44,720 --> 00:01:47,119
marked version of a prf

48
00:01:47,119 --> 00:01:47,920
then

49
00:01:47,920 --> 00:01:50,960
it outputs a program c

50
00:01:50,960 --> 00:01:52,640
which we call the distinguisher and it

51
00:01:52,640 --> 00:01:55,680
can see arbitrarily many input output

52
00:01:55,680 --> 00:01:57,040
pairs

53
00:01:57,040 --> 00:01:59,360
we say that the distinguisher c

54
00:01:59,360 --> 00:02:01,040
is good

55
00:02:01,040 --> 00:02:04,560
if given input output behavior of a

56
00:02:04,560 --> 00:02:06,399
pseudorandom function

57
00:02:06,399 --> 00:02:08,560
and a random function

58
00:02:08,560 --> 00:02:10,318
c should be able to tell these two

59
00:02:10,318 --> 00:02:13,120
distributions apart

60
00:02:13,120 --> 00:02:15,200
so in essence it should be able to break

61
00:02:15,200 --> 00:02:18,480
the pseudo security of the pseudorandom

62
00:02:18,480 --> 00:02:19,680
function

63
00:02:19,680 --> 00:02:22,319
however goel at all discussed in their

64
00:02:22,319 --> 00:02:23,200
work

65
00:02:23,200 --> 00:02:25,360
that this notion is not in general

66
00:02:25,360 --> 00:02:26,560
sufficient

67
00:02:26,560 --> 00:02:29,120
for example if the

68
00:02:29,120 --> 00:02:30,959
distinguisher c has

69
00:02:30,959 --> 00:02:33,519
hardwired in it the tuple x star come up

70
00:02:33,519 --> 00:02:35,519
here fk comma extra

71
00:02:35,519 --> 00:02:37,200
then this notion does not make sense

72
00:02:37,200 --> 00:02:39,599
because it can always break the

73
00:02:39,599 --> 00:02:41,280
security of the pseudo random function

74
00:02:41,280 --> 00:02:44,239
game so they relax this notion

75
00:02:44,239 --> 00:02:46,160
to say that c should be able to

76
00:02:46,160 --> 00:02:48,480
differentiate between input output pairs

77
00:02:48,480 --> 00:02:49,519
of

78
00:02:49,519 --> 00:02:51,360
those evaluations from a pseudorandom

79
00:02:51,360 --> 00:02:53,599
function and that from a random function

80
00:02:53,599 --> 00:02:57,200
on randomly sampled inputs of the domain

81
00:02:57,200 --> 00:02:58,879
which they called

82
00:02:58,879 --> 00:03:01,040
weak zero randomness

83
00:03:01,040 --> 00:03:03,280
so the tracing security informally means

84
00:03:03,280 --> 00:03:04,959
that

85
00:03:04,959 --> 00:03:07,440
the distinguisher c

86
00:03:07,440 --> 00:03:08,640
if

87
00:03:08,640 --> 00:03:10,640
can break weak pseudorandomness of the

88
00:03:10,640 --> 00:03:13,200
underlying traceable prf then the marked

89
00:03:13,200 --> 00:03:16,080
identities used to construct the prf

90
00:03:16,080 --> 00:03:19,200
should be traceable

91
00:03:19,200 --> 00:03:22,159
the syntax of a traceable prf consists

92
00:03:22,159 --> 00:03:24,560
of the following four algorithms

93
00:03:24,560 --> 00:03:26,720
first is the setup algorithm which

94
00:03:26,720 --> 00:03:28,879
samples a master secret key and a

95
00:03:28,879 --> 00:03:31,519
tracing key the tracing c key can be

96
00:03:31,519 --> 00:03:33,680
public or secret

97
00:03:33,680 --> 00:03:35,760
then comes the key generation algorithm

98
00:03:35,760 --> 00:03:38,799
which embeds an identity into the key so

99
00:03:38,799 --> 00:03:41,840
it takes as input and identity id and

100
00:03:41,840 --> 00:03:43,920
uses the master secret key

101
00:03:43,920 --> 00:03:44,640
to

102
00:03:44,640 --> 00:03:47,840
come up with this marked key sk id

103
00:03:47,840 --> 00:03:50,159
the eval algorithm plays the evaluation

104
00:03:50,159 --> 00:03:54,400
of the prf the pseudorandom function

105
00:03:54,400 --> 00:03:57,120
and finally we have the trace algorithm

106
00:03:57,120 --> 00:03:59,120
which is given oracle access to a weak

107
00:03:59,120 --> 00:04:00,879
prf distinguisher

108
00:04:00,879 --> 00:04:03,280
with this access the trace algorithm

109
00:04:03,280 --> 00:04:04,879
should be able to

110
00:04:04,879 --> 00:04:07,040
output an identity or a set of

111
00:04:07,040 --> 00:04:09,840
identities t

112
00:04:11,920 --> 00:04:14,159
the requirements for a traceable prf as

113
00:04:14,159 --> 00:04:16,639
introduced in that work also

114
00:04:16,639 --> 00:04:19,759
involve the following correctness

115
00:04:19,759 --> 00:04:22,240
which basically catches the essence of

116
00:04:22,240 --> 00:04:24,080
functionality preserving

117
00:04:24,080 --> 00:04:25,840
it says that the marked and unmarked

118
00:04:25,840 --> 00:04:28,320
keys agree almost everywhere so the eval

119
00:04:28,320 --> 00:04:30,560
mskx and eval ski id comma x should

120
00:04:30,560 --> 00:04:32,400
indeed match everywhere almost

121
00:04:32,400 --> 00:04:34,080
everywhere

122
00:04:34,080 --> 00:04:35,520
and of course we need the notion of

123
00:04:35,520 --> 00:04:37,840
pseudorandomness which means that the

124
00:04:37,840 --> 00:04:39,759
eval algorithm is actually a pseudo

125
00:04:39,759 --> 00:04:42,240
random function

126
00:04:42,240 --> 00:04:44,080
the tracing security as i already

127
00:04:44,080 --> 00:04:47,120
mentioned previously

128
00:04:47,120 --> 00:04:49,520
means that if the adversary is able to

129
00:04:49,520 --> 00:04:52,639
produce a useful distinguished d

130
00:04:52,639 --> 00:04:55,199
which can differentiate between the

131
00:04:55,199 --> 00:04:57,440
input output behavior of of the pseudo

132
00:04:57,440 --> 00:04:59,919
random function from the

133
00:04:59,919 --> 00:05:02,320
a truly random function on randomly

134
00:05:02,320 --> 00:05:04,400
sampled inputs that means it can break

135
00:05:04,400 --> 00:05:07,120
the security of the the weak suit

136
00:05:07,120 --> 00:05:09,440
security of the weak pseudorandomness

137
00:05:09,440 --> 00:05:12,080
you can break weak pseudorandomness

138
00:05:12,080 --> 00:05:14,800
then the identities that were used to

139
00:05:14,800 --> 00:05:15,600
make

140
00:05:15,600 --> 00:05:16,960
construct d

141
00:05:16,960 --> 00:05:19,680
should be traceable at least one of them

142
00:05:19,680 --> 00:05:22,400
so here is the game

143
00:05:22,400 --> 00:05:25,280
the adversary queries to the challenger

144
00:05:25,280 --> 00:05:27,759
an identity id to which the challenger

145
00:05:27,759 --> 00:05:29,600
responds a marked key

146
00:05:29,600 --> 00:05:31,919
and finally the adversary

147
00:05:31,919 --> 00:05:33,840
returns a distinguished d outputs a

148
00:05:33,840 --> 00:05:35,840
distinguished d

149
00:05:35,840 --> 00:05:37,680
and the security property precisely

150
00:05:37,680 --> 00:05:40,160
states that if d breaks a weak pseudo

151
00:05:40,160 --> 00:05:42,720
randomness of the eval algorithm with

152
00:05:42,720 --> 00:05:45,759
non-negligible advantage epsilon

153
00:05:45,759 --> 00:05:48,320
then the tracing algorithm should output

154
00:05:48,320 --> 00:05:50,479
identity with probability which is as

155
00:05:50,479 --> 00:05:53,919
close to as possible to epsilon

156
00:05:53,919 --> 00:05:56,240
this is the single key setup which means

157
00:05:56,240 --> 00:05:58,160
that the adversary is squaring to the

158
00:05:58,160 --> 00:06:00,479
challenger on only one identity so

159
00:06:00,479 --> 00:06:02,560
naturals

160
00:06:02,560 --> 00:06:04,880
next case is what happens if the

161
00:06:04,880 --> 00:06:08,000
adversary queries multiple times

162
00:06:08,000 --> 00:06:10,080
that brings us to the idea of collusion

163
00:06:10,080 --> 00:06:11,759
resistance

164
00:06:11,759 --> 00:06:14,080
we say that a traceable prf or in

165
00:06:14,080 --> 00:06:17,199
general any such scheme

166
00:06:17,199 --> 00:06:19,440
is a fully collision resistant if

167
00:06:19,440 --> 00:06:21,759
security holds against adversaries that

168
00:06:21,759 --> 00:06:24,080
can obtain any unbounded polynomial

169
00:06:24,080 --> 00:06:26,960
number of keys

170
00:06:26,960 --> 00:06:29,120
so the diagram is still the same the

171
00:06:29,120 --> 00:06:31,120
major change is here

172
00:06:31,120 --> 00:06:33,680
the adversary is squaring multiple times

173
00:06:33,680 --> 00:06:35,360
and these queries can be adaptive as

174
00:06:35,360 --> 00:06:37,360
well and for every such query the

175
00:06:37,360 --> 00:06:38,560
challenger responds with the

176
00:06:38,560 --> 00:06:41,039
corresponding mark key

177
00:06:41,039 --> 00:06:42,160
finally

178
00:06:42,160 --> 00:06:46,880
the adversary outputs a distinguisher d

179
00:06:47,120 --> 00:06:49,440
if d breaks weak pseudorandomness of

180
00:06:49,440 --> 00:06:52,080
eval with advantage

181
00:06:52,080 --> 00:06:54,639
non-negligible epsilon then the tracing

182
00:06:54,639 --> 00:06:56,720
algorithm should output at least one of

183
00:06:56,720 --> 00:06:59,440
the idgs

184
00:06:59,520 --> 00:07:01,599
so while it might seem more natural to

185
00:07:01,599 --> 00:07:03,360
require that the tracing algorithm

186
00:07:03,360 --> 00:07:05,120
should output all the identities which

187
00:07:05,120 --> 00:07:07,360
were queried by the adversary

188
00:07:07,360 --> 00:07:09,680
this requirement is in general not

189
00:07:09,680 --> 00:07:11,120
possible

190
00:07:11,120 --> 00:07:13,120
because the adversary may choose to

191
00:07:13,120 --> 00:07:14,400
construct d

192
00:07:14,400 --> 00:07:16,560
depending only on the response to the

193
00:07:16,560 --> 00:07:18,479
first query and ignores all the rest of

194
00:07:18,479 --> 00:07:21,120
it so as long as we are

195
00:07:21,120 --> 00:07:22,319
able

196
00:07:22,319 --> 00:07:24,880
to trace at least one of the identities

197
00:07:24,880 --> 00:07:27,599
the tracing security should be good this

198
00:07:27,599 --> 00:07:31,840
is a reasonable expectation to have

199
00:07:34,560 --> 00:07:37,039
so coil at all in their work

200
00:07:37,039 --> 00:07:40,240
proved the following assuming lwe

201
00:07:40,240 --> 00:07:42,000
they proved that there exists a single

202
00:07:42,000 --> 00:07:44,639
key traceable prf

203
00:07:44,639 --> 00:07:46,800
further assuming indistinguishability of

204
00:07:46,800 --> 00:07:48,720
first gation and injective one-way

205
00:07:48,720 --> 00:07:49,919
function

206
00:07:49,919 --> 00:07:51,759
they showed the existence of a fully

207
00:07:51,759 --> 00:07:56,080
collusion resistant traceable prf

208
00:07:56,879 --> 00:07:58,160
i should mention here that the

209
00:07:58,160 --> 00:08:00,720
construction they have from standard

210
00:08:00,720 --> 00:08:02,560
lattice assumptions

211
00:08:02,560 --> 00:08:04,240
the single key traceable prf

212
00:08:04,240 --> 00:08:06,560
construction is completely insecure if

213
00:08:06,560 --> 00:08:08,720
the adversary obtains even just two mod

214
00:08:08,720 --> 00:08:11,039
keys in fact what happens is that the

215
00:08:11,039 --> 00:08:13,360
adversary can recover the prs secret key

216
00:08:13,360 --> 00:08:16,639
from any two mark keys

217
00:08:17,360 --> 00:08:18,240
thus

218
00:08:18,240 --> 00:08:20,080
the natural question which motivates

219
00:08:20,080 --> 00:08:21,520
this work is

220
00:08:21,520 --> 00:08:23,840
can we obtain a fully collision

221
00:08:23,840 --> 00:08:26,400
resistant traceable prf

222
00:08:26,400 --> 00:08:28,400
without going through

223
00:08:28,400 --> 00:08:30,560
obfuscation

224
00:08:30,560 --> 00:08:32,240
such a construction would have the

225
00:08:32,240 --> 00:08:34,159
advantage of being plausibly post

226
00:08:34,159 --> 00:08:35,440
quantum secure

227
00:08:35,440 --> 00:08:37,599
and also will provide a more direct

228
00:08:37,599 --> 00:08:39,120
instantiation

229
00:08:39,120 --> 00:08:41,440
than going through the full power of

230
00:08:41,440 --> 00:08:42,958
indistinguishability

231
00:08:42,958 --> 00:08:45,680
of foscation

232
00:08:46,160 --> 00:08:48,560
this led us to our work as i said and

233
00:08:48,560 --> 00:08:50,720
this is the topic of this talk

234
00:08:50,720 --> 00:08:51,839
we

235
00:08:51,839 --> 00:08:54,959
proved this theorem that from lwe we

236
00:08:54,959 --> 00:08:56,880
construct a fully collision resistant

237
00:08:56,880 --> 00:08:59,519
traceable prf

238
00:08:59,519 --> 00:09:01,200
so

239
00:09:01,200 --> 00:09:03,360
we provide an algorithm to how to

240
00:09:03,360 --> 00:09:05,760
generically augment a single key

241
00:09:05,760 --> 00:09:07,760
traceable prf to a fully collision

242
00:09:07,760 --> 00:09:10,240
resistant traceable prf

243
00:09:10,240 --> 00:09:13,279
and our identity space is polynomial as

244
00:09:13,279 --> 00:09:14,480
i said

245
00:09:14,480 --> 00:09:16,080
collision resistance is actually

246
00:09:16,080 --> 00:09:18,720
meaningful and non-trivial to achieve

247
00:09:18,720 --> 00:09:20,560
even when the identity space is

248
00:09:20,560 --> 00:09:25,199
polynomial because as i mentioned

249
00:09:25,440 --> 00:09:27,519
the existing construction of a single

250
00:09:27,519 --> 00:09:29,600
key traceable prf

251
00:09:29,600 --> 00:09:31,279
is completely insecure even in the

252
00:09:31,279 --> 00:09:33,040
presence of two

253
00:09:33,040 --> 00:09:36,160
identities queried by the adversary

254
00:09:36,160 --> 00:09:37,519
so

255
00:09:37,519 --> 00:09:39,200
polynomial identity space is a

256
00:09:39,200 --> 00:09:42,080
reasonable start

257
00:09:42,720 --> 00:09:44,800
and here is a very quick overview i will

258
00:09:44,800 --> 00:09:46,959
elaborate on this very soon

259
00:09:46,959 --> 00:09:49,200
so what we do is we combine a single key

260
00:09:49,200 --> 00:09:51,519
traceable prf with a collision resistant

261
00:09:51,519 --> 00:09:53,839
fingerprinting code

262
00:09:53,839 --> 00:09:56,000
essentially single key security of the

263
00:09:56,000 --> 00:09:58,480
traceable prf binds the adversary to

264
00:09:58,480 --> 00:10:00,080
strategies that conform to the

265
00:10:00,080 --> 00:10:02,240
restrictions of the fingerprinting code

266
00:10:02,240 --> 00:10:03,600
model

267
00:10:03,600 --> 00:10:06,320
this in turn yields a fully collision

268
00:10:06,320 --> 00:10:09,440
resistant traceable prf

269
00:10:09,440 --> 00:10:12,240
so before we move on we need to review

270
00:10:12,240 --> 00:10:13,519
what a collision resistant

271
00:10:13,519 --> 00:10:15,360
fingerprinting code is

272
00:10:15,360 --> 00:10:17,680
and that brings us to this slide

273
00:10:17,680 --> 00:10:20,000
so fingerprinting codes are information

274
00:10:20,000 --> 00:10:22,399
theoretic objects

275
00:10:22,399 --> 00:10:24,800
the syntax consists of two algorithms

276
00:10:24,800 --> 00:10:27,440
first the gen algorithm which samples a

277
00:10:27,440 --> 00:10:29,279
code book gamma

278
00:10:29,279 --> 00:10:30,839
and a tracing key

279
00:10:30,839 --> 00:10:34,399
tk the code words in the code book gamma

280
00:10:34,399 --> 00:10:36,720
are l tuples

281
00:10:36,720 --> 00:10:39,839
0 they belong to 0 comma 1 bar l

282
00:10:39,839 --> 00:10:41,839
and this l is called the

283
00:10:41,839 --> 00:10:43,920
length of the fingerprinting code or the

284
00:10:43,920 --> 00:10:45,600
code length

285
00:10:45,600 --> 00:10:47,839
there is also the trace algorithm which

286
00:10:47,839 --> 00:10:50,079
takes as input the tracing key and the

287
00:10:50,079 --> 00:10:53,519
word w star and outputs an s

288
00:10:53,519 --> 00:10:56,000
which should be a subset of the identity

289
00:10:56,000 --> 00:10:56,880
space

290
00:10:56,880 --> 00:10:59,120
for the purposes of this work we can

291
00:10:59,120 --> 00:11:03,040
consider this to be our identity space

292
00:11:04,800 --> 00:11:08,160
we also require the notion of

293
00:11:08,160 --> 00:11:09,839
feasibility

294
00:11:09,839 --> 00:11:11,839
to better understand

295
00:11:11,839 --> 00:11:12,720
the

296
00:11:12,720 --> 00:11:15,120
security of the fingerprinting code

297
00:11:15,120 --> 00:11:17,200
so it goes as follows

298
00:11:17,200 --> 00:11:21,839
suppose we are given a subset w of gamma

299
00:11:21,839 --> 00:11:24,720
oh the gamma is the code book remember

300
00:11:24,720 --> 00:11:27,760
so a word w star is feasible for the set

301
00:11:27,760 --> 00:11:30,560
w it is often denoted by the notation f

302
00:11:30,560 --> 00:11:33,839
of w capital f of w

303
00:11:33,839 --> 00:11:37,040
if every bit in w star agrees with the

304
00:11:37,040 --> 00:11:39,839
corresponding bit in one of the code

305
00:11:39,839 --> 00:11:41,920
words in w so there should exist at

306
00:11:41,920 --> 00:11:44,160
least one code word in w

307
00:11:44,160 --> 00:11:46,480
so that if you look at w star 1 one of

308
00:11:46,480 --> 00:11:48,480
the code words has the same bit in the

309
00:11:48,480 --> 00:11:49,839
first

310
00:11:49,839 --> 00:11:51,760
position

311
00:11:51,760 --> 00:11:55,519
so for example if w is

312
00:11:55,519 --> 00:11:57,600
this set which consists of two elements

313
00:11:57,600 --> 00:12:00,639
0 0 0 and 1 1 1

314
00:12:00,639 --> 00:12:02,880
then the feasible set consists of 0 1

315
00:12:02,880 --> 00:12:05,680
power q because if you if we choose any

316
00:12:05,680 --> 00:12:09,120
element from this set 0 1 cube

317
00:12:09,120 --> 00:12:10,800
each of the bits can be matched up with

318
00:12:10,800 --> 00:12:14,160
one of the bits in these words

319
00:12:19,120 --> 00:12:20,959
next we talk about collision resistant

320
00:12:20,959 --> 00:12:23,040
codes and the idea is exactly similar to

321
00:12:23,040 --> 00:12:25,120
what we have done so far

322
00:12:25,120 --> 00:12:27,600
seen so far we say a fingerprinting code

323
00:12:27,600 --> 00:12:29,680
is fully collision resistant

324
00:12:29,680 --> 00:12:32,160
if tracing security holds against

325
00:12:32,160 --> 00:12:34,079
adversaries that can obtain any

326
00:12:34,079 --> 00:12:35,920
unbounded polynomial number of code

327
00:12:35,920 --> 00:12:37,839
words and the adversary can make

328
00:12:37,839 --> 00:12:39,839
adaptive queries

329
00:12:39,839 --> 00:12:41,760
so it's the same diagram as before the

330
00:12:41,760 --> 00:12:45,519
adversary makes queries identity queries

331
00:12:45,519 --> 00:12:47,600
which can be adaptive to the challenger

332
00:12:47,600 --> 00:12:49,920
and the challenger keeps responding

333
00:12:49,920 --> 00:12:52,800
with the corresponding code words this

334
00:12:52,800 --> 00:12:55,600
constitutes the set w of code words

335
00:12:55,600 --> 00:12:57,680
obtained by the adversary

336
00:12:57,680 --> 00:13:00,240
finally the adversary

337
00:13:00,240 --> 00:13:03,200
outputs a word w star and as one can

338
00:13:03,200 --> 00:13:05,120
guess the security requirement should be

339
00:13:05,120 --> 00:13:06,480
as follows

340
00:13:06,480 --> 00:13:09,360
if w star is feasible for the set w

341
00:13:09,360 --> 00:13:12,320
which is acquired by the adversary

342
00:13:12,320 --> 00:13:14,000
through its queries

343
00:13:14,000 --> 00:13:16,160
then the tracing algorithm should at

344
00:13:16,160 --> 00:13:18,720
least output one of the identities which

345
00:13:18,720 --> 00:13:22,160
was queried by the adversary

346
00:13:24,320 --> 00:13:26,320
so this brings us to the construction of

347
00:13:26,320 --> 00:13:28,720
the collision resistant traceable prf so

348
00:13:28,720 --> 00:13:30,480
as i have already mentioned the primary

349
00:13:30,480 --> 00:13:32,720
ingredients are number one a single key

350
00:13:32,720 --> 00:13:35,279
traceable prf which is guaranteed by

351
00:13:35,279 --> 00:13:37,360
goel adult's work

352
00:13:37,360 --> 00:13:39,600
so there were the domain range and

353
00:13:39,600 --> 00:13:41,440
identity space are suitably chosen so

354
00:13:41,440 --> 00:13:43,519
that we can the entire construction is

355
00:13:43,519 --> 00:13:45,600
compatible with each other

356
00:13:45,600 --> 00:13:47,279
each of its

357
00:13:47,279 --> 00:13:48,880
functioning parts

358
00:13:48,880 --> 00:13:50,399
and the second part is a collision

359
00:13:50,399 --> 00:13:52,720
resistant fingerprinting code with n

360
00:13:52,720 --> 00:13:56,079
code words wi and code length l

361
00:13:56,079 --> 00:13:59,600
where wi belongs to 0 1 power l

362
00:13:59,600 --> 00:14:02,160
so the primary idea that we use in this

363
00:14:02,160 --> 00:14:04,880
construction is the following

364
00:14:04,880 --> 00:14:07,760
take l independent copies of the

365
00:14:07,760 --> 00:14:11,040
traceable prf and just xor them

366
00:14:11,040 --> 00:14:12,880
and what do we use why do we need these

367
00:14:12,880 --> 00:14:14,720
l independent copies

368
00:14:14,720 --> 00:14:17,839
we use each of these copies to embed a

369
00:14:17,839 --> 00:14:20,480
single bit of the code word so we take

370
00:14:20,480 --> 00:14:22,880
the identity map it to its code word

371
00:14:22,880 --> 00:14:24,720
then look at the bits

372
00:14:24,720 --> 00:14:26,480
then embed

373
00:14:26,480 --> 00:14:27,600
that bit

374
00:14:27,600 --> 00:14:28,560
using

375
00:14:28,560 --> 00:14:32,800
the ith copy of the prf

376
00:14:32,800 --> 00:14:34,240
and that is how the construction goes

377
00:14:34,240 --> 00:14:38,000
and finally xor all of these together

378
00:14:41,680 --> 00:14:43,839
so the eval algorithm goes as follows

379
00:14:43,839 --> 00:14:45,360
i'm sorry i should not have said x or

380
00:14:45,360 --> 00:14:47,519
all of these together we output all

381
00:14:47,519 --> 00:14:50,160
those smart keys as a tuple as we see

382
00:14:50,160 --> 00:14:50,959
here

383
00:14:50,959 --> 00:14:53,600
so the construction goes as follows

384
00:14:53,600 --> 00:14:56,160
the eval algorithm is

385
00:14:56,160 --> 00:15:01,600
on input x we just xor prf ki comma x

386
00:15:01,760 --> 00:15:04,399
so xors of prfs are secured it is well

387
00:15:04,399 --> 00:15:06,720
known that this is xors are secure as

388
00:15:06,720 --> 00:15:08,480
long as one of the underlying prfs is

389
00:15:08,480 --> 00:15:10,560
secured that is the main idea behind

390
00:15:10,560 --> 00:15:12,720
this construction

391
00:15:12,720 --> 00:15:15,600
the marking scheme goes as follows

392
00:15:15,600 --> 00:15:18,560
the first step is we take an identity we

393
00:15:18,560 --> 00:15:20,959
map it to the corresponding code word

394
00:15:20,959 --> 00:15:23,279
then we look at the bits

395
00:15:23,279 --> 00:15:24,560
then we use

396
00:15:24,560 --> 00:15:26,720
the corresponding prfs

397
00:15:26,720 --> 00:15:27,600
to

398
00:15:27,600 --> 00:15:30,079
embed those bits and obtain these marked

399
00:15:30,079 --> 00:15:33,199
keys and finally we output sk1 to skl as

400
00:15:33,199 --> 00:15:35,599
a tuple

401
00:15:36,639 --> 00:15:38,320
the tracing algorithm which one can

402
00:15:38,320 --> 00:15:40,720
probably guess by now is that the

403
00:15:40,720 --> 00:15:42,639
distinguisher d if you are given for a

404
00:15:42,639 --> 00:15:44,800
distinct for the entire prf

405
00:15:44,800 --> 00:15:47,680
we constru util using that we construct

406
00:15:47,680 --> 00:15:49,040
it

407
00:15:49,040 --> 00:15:51,440
uh distinguish a di for each of the

408
00:15:51,440 --> 00:15:53,360
components prf ki

409
00:15:53,360 --> 00:15:55,839
then we run the trace

410
00:15:55,839 --> 00:15:58,399
algorithm for each of these to obtain

411
00:15:58,399 --> 00:16:00,880
these sets ti

412
00:16:00,880 --> 00:16:03,040
finally using this whatever output we

413
00:16:03,040 --> 00:16:06,320
have here we construct the word w star

414
00:16:06,320 --> 00:16:08,480
and feed it to the tracing algorithm of

415
00:16:08,480 --> 00:16:12,160
the underlying fingerprinting code

416
00:16:14,079 --> 00:16:16,240
so a limitation of our construction is

417
00:16:16,240 --> 00:16:19,279
that the marquees key ids are long as

418
00:16:19,279 --> 00:16:22,959
you can see the prf keys k is a tuple of

419
00:16:22,959 --> 00:16:25,360
l independent keys k1 to kl and also the

420
00:16:25,360 --> 00:16:28,000
marked keys are sk1 to skl so the

421
00:16:28,000 --> 00:16:29,759
marquis are quite long so this is one of

422
00:16:29,759 --> 00:16:31,199
the limitations

423
00:16:31,199 --> 00:16:33,920
so let me briefly talk about

424
00:16:33,920 --> 00:16:37,839
why this is secure

425
00:16:38,399 --> 00:16:40,399
notice that if this w star which we

426
00:16:40,399 --> 00:16:42,399
construct here w bar star if this is

427
00:16:42,399 --> 00:16:44,560
feasible then we can resort to the

428
00:16:44,560 --> 00:16:45,920
security of the underlying

429
00:16:45,920 --> 00:16:47,839
fingerprinting code now so all we need

430
00:16:47,839 --> 00:16:49,600
to guarantee

431
00:16:49,600 --> 00:16:50,639
is that

432
00:16:50,639 --> 00:16:54,560
the underlying word should be feasible

433
00:16:54,560 --> 00:16:57,439
but now note

434
00:16:57,519 --> 00:17:00,480
that feasibility here means that if all

435
00:17:00,480 --> 00:17:02,720
of the code words

436
00:17:02,720 --> 00:17:05,439
corresponding to identities which are

437
00:17:05,439 --> 00:17:08,240
requested by the adversary have the same

438
00:17:08,240 --> 00:17:10,480
bit in a particular position say at i

439
00:17:10,480 --> 00:17:12,240
naught the position i naught all of the

440
00:17:12,240 --> 00:17:14,319
bits have the same

441
00:17:14,319 --> 00:17:16,480
uh bit

442
00:17:16,480 --> 00:17:18,240
then the corresponding bit in this

443
00:17:18,240 --> 00:17:20,480
constructed word w bar star must also

444
00:17:20,480 --> 00:17:22,559
match

445
00:17:22,559 --> 00:17:24,799
but notice that in this case because the

446
00:17:24,799 --> 00:17:26,880
bits are the same the adversary actually

447
00:17:26,880 --> 00:17:29,280
receives only one mark

448
00:17:29,280 --> 00:17:30,720
key

449
00:17:30,720 --> 00:17:32,640
marked version

450
00:17:32,640 --> 00:17:34,720
so now we can resort to the security of

451
00:17:34,720 --> 00:17:36,400
the

452
00:17:36,400 --> 00:17:38,080
underlying single key security of the

453
00:17:38,080 --> 00:17:40,240
underlying traceable prf

454
00:17:40,240 --> 00:17:42,160
that is if there is a key associated

455
00:17:42,160 --> 00:17:44,240
with a single value then single key

456
00:17:44,240 --> 00:17:46,160
security guarantees that the adversary

457
00:17:46,160 --> 00:17:48,640
cannot change that bit

458
00:17:48,640 --> 00:17:50,880
thus we are guaranteed to make that the

459
00:17:50,880 --> 00:17:53,840
word w star is feasible and once we have

460
00:17:53,840 --> 00:17:54,640
that

461
00:17:54,640 --> 00:17:55,840
collusion resistance of the

462
00:17:55,840 --> 00:17:57,440
fingerprinting code

463
00:17:57,440 --> 00:18:01,360
ensures security for us

464
00:18:01,360 --> 00:18:02,960
so recapping

465
00:18:02,960 --> 00:18:04,559
the construction again

466
00:18:04,559 --> 00:18:06,960
the eval algorithm goes as follows we

467
00:18:06,960 --> 00:18:08,960
take l independent copies of the

468
00:18:08,960 --> 00:18:11,520
traceable single key traceable prf

469
00:18:11,520 --> 00:18:13,600
and we xor them

470
00:18:13,600 --> 00:18:15,760
and the marking algorithm is we take an

471
00:18:15,760 --> 00:18:18,400
identity map it to the code word look at

472
00:18:18,400 --> 00:18:20,240
the corresponding bits

473
00:18:20,240 --> 00:18:22,559
then use each of these prfs to embed

474
00:18:22,559 --> 00:18:24,640
those bits and output the tuple as a

475
00:18:24,640 --> 00:18:27,440
whole for the marked key

476
00:18:27,440 --> 00:18:29,919
the tracing algorithm goes as follows we

477
00:18:29,919 --> 00:18:31,919
have a distinguished d

478
00:18:31,919 --> 00:18:34,080
we construct using that we construct a

479
00:18:34,080 --> 00:18:36,000
distinguisher di for each of these

480
00:18:36,000 --> 00:18:38,960
components we run the trace algorithm

481
00:18:38,960 --> 00:18:42,080
get a set t i suitably construct w star

482
00:18:42,080 --> 00:18:43,360
and feed it

483
00:18:43,360 --> 00:18:45,440
to the tracing algorithm of the

484
00:18:45,440 --> 00:18:47,760
underlying fingerprinting code

485
00:18:47,760 --> 00:18:49,520
we should also mention that in the paper

486
00:18:49,520 --> 00:18:51,679
we actually provide a statistical test

487
00:18:51,679 --> 00:18:52,880
to check

488
00:18:52,880 --> 00:18:55,919
whether this how this distinguisher is

489
00:18:55,919 --> 00:18:57,440
if the

490
00:18:57,440 --> 00:18:59,200
efficient or not we actually provide a

491
00:18:59,200 --> 00:19:01,520
statistical test to check the efficacy

492
00:19:01,520 --> 00:19:03,360
that is needed in the security proof

493
00:19:03,360 --> 00:19:05,678
also

494
00:19:06,960 --> 00:19:08,880
so we also do this additional work in

495
00:19:08,880 --> 00:19:11,280
this paper we consider the notion of

496
00:19:11,280 --> 00:19:13,280
active security

497
00:19:13,280 --> 00:19:15,120
we additionally allow the adversary to

498
00:19:15,120 --> 00:19:18,080
make queries to the tracing oracle

499
00:19:18,080 --> 00:19:20,480
this is an intermediate security notion

500
00:19:20,480 --> 00:19:22,720
i use the word intermediate because it's

501
00:19:22,720 --> 00:19:24,400
intermediate between

502
00:19:24,400 --> 00:19:28,000
secret tracing and public tracing

503
00:19:28,000 --> 00:19:29,919
so such an intermediate notion was

504
00:19:29,919 --> 00:19:32,160
previously also considered in the

505
00:19:32,160 --> 00:19:36,080
setting of water markable prfs

506
00:19:36,240 --> 00:19:38,400
and we were able to show using the same

507
00:19:38,400 --> 00:19:41,200
idea that using lwe

508
00:19:41,200 --> 00:19:43,760
there exists a fully collision resistant

509
00:19:43,760 --> 00:19:45,440
traceable prf

510
00:19:45,440 --> 00:19:48,559
with active security against adversaries

511
00:19:48,559 --> 00:19:50,960
making up to queue tracing queries

512
00:19:50,960 --> 00:19:53,600
for any a priori bounded polynomial q

513
00:19:53,600 --> 00:19:55,440
which is q of lambda lambda is the

514
00:19:55,440 --> 00:19:58,240
security parameter here

515
00:19:58,240 --> 00:20:01,520
as i mentioned the same construction

516
00:20:01,520 --> 00:20:04,880
can be used as before the xoring idea

517
00:20:04,880 --> 00:20:05,600
the

518
00:20:05,600 --> 00:20:07,600
major difference is we just have to use

519
00:20:07,600 --> 00:20:09,520
a fingerprinting code

520
00:20:09,520 --> 00:20:10,480
which is

521
00:20:10,480 --> 00:20:12,159
fully collision resistant against

522
00:20:12,159 --> 00:20:15,280
adversaries making queue tracing queries

523
00:20:15,280 --> 00:20:16,960
so luckily for us

524
00:20:16,960 --> 00:20:18,720
such codes were shown to exist very

525
00:20:18,720 --> 00:20:20,880
recently by yang at all

526
00:20:20,880 --> 00:20:23,520
in their work in 2020 and we leveraged

527
00:20:23,520 --> 00:20:24,320
that

528
00:20:24,320 --> 00:20:26,640
in this construction to get the notion

529
00:20:26,640 --> 00:20:29,520
of active security

530
00:20:29,520 --> 00:20:31,600
with fully collision resistance of

531
00:20:31,600 --> 00:20:35,080
traceable prfs

532
00:20:35,280 --> 00:20:37,919
it is well known that prfs can be used

533
00:20:37,919 --> 00:20:39,840
to construct authenticated encryption

534
00:20:39,840 --> 00:20:42,159
schemes example via the encrypt and mac

535
00:20:42,159 --> 00:20:44,240
paradigm

536
00:20:44,240 --> 00:20:46,400
not surprisingly instantiating the

537
00:20:46,400 --> 00:20:48,640
encryption scheme with a traceable prf

538
00:20:48,640 --> 00:20:51,600
and composing with an arbitrary mac

539
00:20:51,600 --> 00:20:54,159
directly yields a trader tracing scheme

540
00:20:54,159 --> 00:20:56,080
where the underlying encryption scheme

541
00:20:56,080 --> 00:20:58,240
is an authenticated

542
00:20:58,240 --> 00:21:00,799
encryption and hence trivially satisfies

543
00:21:00,799 --> 00:21:02,960
cca security

544
00:21:02,960 --> 00:21:04,159
moreover

545
00:21:04,159 --> 00:21:06,240
if the underlying traceable prf is

546
00:21:06,240 --> 00:21:08,880
secure against q-bounded active

547
00:21:08,880 --> 00:21:11,200
adversaries then the resulting traitor

548
00:21:11,200 --> 00:21:13,760
tracing scheme is also secure against

549
00:21:13,760 --> 00:21:16,880
q-bounded active adversaries

550
00:21:16,880 --> 00:21:19,039
as i said we just have to instantiate

551
00:21:19,039 --> 00:21:21,440
the prf with a traceable prf with active

552
00:21:21,440 --> 00:21:24,000
security

553
00:21:24,559 --> 00:21:26,240
so this is one of the very important

554
00:21:26,240 --> 00:21:28,080
properties of traceable prf which was

555
00:21:28,080 --> 00:21:30,000
also pointed out in the works of goel at

556
00:21:30,000 --> 00:21:31,520
all

557
00:21:31,520 --> 00:21:34,320
that whenever we have

558
00:21:34,320 --> 00:21:37,520
an application which is built from a prf

559
00:21:37,520 --> 00:21:39,360
we can get a corresponding traceable

560
00:21:39,360 --> 00:21:41,440
version of that application

561
00:21:41,440 --> 00:21:43,760
by replacing the prf with a traceable

562
00:21:43,760 --> 00:21:45,760
prf and secret key trader tracing is

563
00:21:45,760 --> 00:21:49,039
simply an application of that

564
00:21:49,280 --> 00:21:51,120
so let me summarize whatever we have

565
00:21:51,120 --> 00:21:54,559
discussed in this talk so far

566
00:21:54,559 --> 00:21:56,799
we provide the first fully collision

567
00:21:56,799 --> 00:21:58,799
resistant traceable prf from standard

568
00:21:58,799 --> 00:22:00,320
lattice assumptions

569
00:22:00,320 --> 00:22:02,559
and we do this through the usage of

570
00:22:02,559 --> 00:22:04,480
fully collision resistant fingerprinting

571
00:22:04,480 --> 00:22:05,840
codes

572
00:22:05,840 --> 00:22:08,640
we generally generically augment of such

573
00:22:08,640 --> 00:22:10,240
a fully collision resistant traceable

574
00:22:10,240 --> 00:22:13,600
prf using two primary ingredients one is

575
00:22:13,600 --> 00:22:16,559
a single key traceable prf

576
00:22:16,559 --> 00:22:17,440
and

577
00:22:17,440 --> 00:22:19,039
number two is the

578
00:22:19,039 --> 00:22:20,880
fully collision resistant fingerprinting

579
00:22:20,880 --> 00:22:22,480
codes

580
00:22:22,480 --> 00:22:24,880
they also showed as we discussed that

581
00:22:24,880 --> 00:22:26,880
tracing security holds even against

582
00:22:26,880 --> 00:22:28,960
active adversaries that have oracle

583
00:22:28,960 --> 00:22:32,480
access to the tracing algorithm

584
00:22:33,760 --> 00:22:35,600
so i would like to end

585
00:22:35,600 --> 00:22:37,840
with two questions one of which i have

586
00:22:37,840 --> 00:22:39,840
already mentioned that one of the

587
00:22:39,840 --> 00:22:41,600
drawbacks of our construction is that

588
00:22:41,600 --> 00:22:44,480
the sizes of the marked keys

589
00:22:44,480 --> 00:22:47,120
is long it's sk1 to skl where l is the

590
00:22:47,120 --> 00:22:49,679
codeline can they be increa decreased

591
00:22:49,679 --> 00:22:52,080
efficiently

592
00:22:52,080 --> 00:22:53,760
and number two

593
00:22:53,760 --> 00:22:56,000
is the active security

594
00:22:56,000 --> 00:22:58,799
result that we had which dependent on q

595
00:22:58,799 --> 00:23:00,559
it had a polynomial bound q on the

596
00:23:00,559 --> 00:23:03,760
number of tracing queries

597
00:23:03,919 --> 00:23:06,400
this bound is appearing only because of

598
00:23:06,400 --> 00:23:08,000
the

599
00:23:08,000 --> 00:23:09,679
corresponding property of the

600
00:23:09,679 --> 00:23:11,360
fingerprinting underlying fingerprinting

601
00:23:11,360 --> 00:23:14,240
code that is a fingerprinting code

602
00:23:14,240 --> 00:23:16,159
has the same bound on the tracing number

603
00:23:16,159 --> 00:23:18,240
of tracing queries

604
00:23:18,240 --> 00:23:20,480
if that restriction can be lifted from

605
00:23:20,480 --> 00:23:22,240
the fingerprinting code the same can be

606
00:23:22,240 --> 00:23:23,679
done for the

607
00:23:23,679 --> 00:23:25,760
traceable prf as well

608
00:23:25,760 --> 00:23:27,919
so the natural question is

609
00:23:27,919 --> 00:23:31,600
can we construct such codes

610
00:23:31,600 --> 00:23:35,080
thank you very much

