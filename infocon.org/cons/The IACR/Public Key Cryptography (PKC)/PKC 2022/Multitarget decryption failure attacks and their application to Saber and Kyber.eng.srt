1
00:00:02,480 --> 00:00:04,640
welcome to this video on multi-target

2
00:00:04,640 --> 00:00:06,240
decryption theory attacks and their

3
00:00:06,240 --> 00:00:09,120
application to saber and kyber

4
00:00:09,120 --> 00:00:10,960
i'm yampito danvers and this is a joint

5
00:00:10,960 --> 00:00:13,519
work with cinebatslayer

6
00:00:13,519 --> 00:00:14,320
so

7
00:00:14,320 --> 00:00:16,079
what i will talk about in this video is

8
00:00:16,079 --> 00:00:17,920
first i will give an introduction to

9
00:00:17,920 --> 00:00:19,760
decryption theory attacks

10
00:00:19,760 --> 00:00:20,880
and then i will explain the

11
00:00:20,880 --> 00:00:23,039
contributions of our paper

12
00:00:23,039 --> 00:00:25,760
which is a leveled multi-target attack

13
00:00:25,760 --> 00:00:27,519
which is improvement to the cost

14
00:00:27,519 --> 00:00:30,320
estimation of decryption failure attacks

15
00:00:30,320 --> 00:00:31,679
and also

16
00:00:31,679 --> 00:00:33,840
specifically improvements of the custom

17
00:00:33,840 --> 00:00:36,320
estimation for existing schemes like

18
00:00:36,320 --> 00:00:38,640
saber and kyber

19
00:00:38,640 --> 00:00:41,200
so let's start with an introduction

20
00:00:41,200 --> 00:00:45,039
what are decryption failure attacks

21
00:00:45,039 --> 00:00:47,039
so decryption failure attacks are

22
00:00:47,039 --> 00:00:50,079
attacks on public key encryption schemes

23
00:00:50,079 --> 00:00:51,600
imagine that we have

24
00:00:51,600 --> 00:00:54,000
alice and pop who want to communicate

25
00:00:54,000 --> 00:00:57,120
but they have no pre-shared secret key

26
00:00:57,120 --> 00:01:00,160
so what alice can do is she can generate

27
00:01:00,160 --> 00:01:02,879
a public key and a secret key using a

28
00:01:02,879 --> 00:01:05,600
key key generation

29
00:01:05,600 --> 00:01:07,840
so she sends this public key to bob and

30
00:01:07,840 --> 00:01:10,479
bob can then use the public key

31
00:01:10,479 --> 00:01:12,320
using an encryption procedure to

32
00:01:12,320 --> 00:01:14,479
generate a cipher text for certain

33
00:01:14,479 --> 00:01:16,880
message or certain certain shared secret

34
00:01:16,880 --> 00:01:18,400
key

35
00:01:18,400 --> 00:01:20,400
so bob sends his cipher text back to

36
00:01:20,400 --> 00:01:21,600
alice

37
00:01:21,600 --> 00:01:24,159
where alice uses her secret key to

38
00:01:24,159 --> 00:01:26,960
decrypt this message uh to the crypt to

39
00:01:26,960 --> 00:01:30,720
the message or the shared secret key

40
00:01:30,720 --> 00:01:32,799
now evie is in the middle and eve of

41
00:01:32,799 --> 00:01:36,159
course being evil wants to learn the

42
00:01:36,159 --> 00:01:38,720
secret key of alice

43
00:01:38,720 --> 00:01:41,840
now she has as information the publicky

44
00:01:41,840 --> 00:01:44,159
and what she does is some evil stuff

45
00:01:44,159 --> 00:01:47,439
um to generate a ciphertext or something

46
00:01:47,439 --> 00:01:50,000
that looks like a ciphertext

47
00:01:50,000 --> 00:01:52,320
and she will submit this ciphertext to

48
00:01:52,320 --> 00:01:54,000
alice

49
00:01:54,000 --> 00:01:57,119
alice who just sees something coming in

50
00:01:57,119 --> 00:01:59,920
will decrypt the ciphertext

51
00:01:59,920 --> 00:02:02,000
using her secret key and will end up

52
00:02:02,000 --> 00:02:04,159
with a message

53
00:02:04,159 --> 00:02:06,719
and based on this message message or the

54
00:02:06,719 --> 00:02:10,160
secret key or the reaction of alice eve

55
00:02:10,160 --> 00:02:12,400
will learn something about the secret

56
00:02:12,400 --> 00:02:14,080
key

57
00:02:14,080 --> 00:02:16,319
now these type of attacks for many

58
00:02:16,319 --> 00:02:19,200
schemes are possible and are described

59
00:02:19,200 --> 00:02:21,120
in literature

60
00:02:21,120 --> 00:02:23,120
but luckily we can also protect against

61
00:02:23,120 --> 00:02:25,360
search attacks such chosen ciphertext

62
00:02:25,360 --> 00:02:27,200
attack

63
00:02:27,200 --> 00:02:28,160
so

64
00:02:28,160 --> 00:02:29,760
what do we do

65
00:02:29,760 --> 00:02:30,560
well

66
00:02:30,560 --> 00:02:32,720
we change the encryptions procedure a

67
00:02:32,720 --> 00:02:33,599
bit

68
00:02:33,599 --> 00:02:36,560
so what happens is we have bob who has a

69
00:02:36,560 --> 00:02:39,120
public key who has a message and he

70
00:02:39,120 --> 00:02:40,959
wants to encrypt

71
00:02:40,959 --> 00:02:43,120
but now instead of using randomness for

72
00:02:43,120 --> 00:02:45,440
his encryption procedure he will use

73
00:02:45,440 --> 00:02:48,080
pseudorandomness completely based on

74
00:02:48,080 --> 00:02:50,560
this message that he's gonna send

75
00:02:50,560 --> 00:02:52,080
so this means that the whole encryption

76
00:02:52,080 --> 00:02:54,959
procedure now becomes pseudorandom and

77
00:02:54,959 --> 00:02:56,800
if we know the public key in the message

78
00:02:56,800 --> 00:02:59,120
we can do this encryption and we will

79
00:02:59,120 --> 00:03:02,400
end up with the same cipher text

80
00:03:02,400 --> 00:03:05,120
now what alice is going to do is alice

81
00:03:05,120 --> 00:03:07,360
receives a ciphertext a secret she has a

82
00:03:07,360 --> 00:03:09,840
secret key and she can decrypt

83
00:03:09,840 --> 00:03:13,040
so she will find a message

84
00:03:13,040 --> 00:03:15,680
now she has the message and a public key

85
00:03:15,680 --> 00:03:18,640
which means she can do this encryption

86
00:03:18,640 --> 00:03:20,239
so she will do and we will call it a

87
00:03:20,239 --> 00:03:21,920
re-encryption

88
00:03:21,920 --> 00:03:24,480
so alice re-encrypts

89
00:03:24,480 --> 00:03:27,040
the message and the public key into a

90
00:03:27,040 --> 00:03:30,239
cipher text and now we can check

91
00:03:30,239 --> 00:03:32,159
if both ciphertext so the input

92
00:03:32,159 --> 00:03:33,840
ciphertext and the re-encrypted

93
00:03:33,840 --> 00:03:36,159
ciphertext are the same then clearly the

94
00:03:36,159 --> 00:03:38,159
ciphertext is valid and she will just

95
00:03:38,159 --> 00:03:39,920
continue

96
00:03:39,920 --> 00:03:40,879
but

97
00:03:40,879 --> 00:03:42,879
if the re-encrypted ciphertext is not

98
00:03:42,879 --> 00:03:45,040
the same as the input ciphertext then

99
00:03:45,040 --> 00:03:46,959
she know that she knows that something

100
00:03:46,959 --> 00:03:48,080
is up

101
00:03:48,080 --> 00:03:49,840
she knows that

102
00:03:49,840 --> 00:03:51,599
the cypher text was not honestly

103
00:03:51,599 --> 00:03:54,159
generated or at least not generated

104
00:03:54,159 --> 00:03:56,640
according to the right procedure

105
00:03:56,640 --> 00:03:58,400
and so in this case she knows she's

106
00:03:58,400 --> 00:04:00,799
under attack and she will just abort she

107
00:04:00,799 --> 00:04:02,640
will not release any sensitive

108
00:04:02,640 --> 00:04:04,400
information

109
00:04:04,400 --> 00:04:07,040
and this is called the fushitaki okamoto

110
00:04:07,040 --> 00:04:08,560
transformation

111
00:04:08,560 --> 00:04:10,879
so it's a transformation to protect

112
00:04:10,879 --> 00:04:12,840
against chosen cypher text

113
00:04:12,840 --> 00:04:16,560
attacks so an attacker now if he inputs

114
00:04:16,560 --> 00:04:19,918
a chosen circus and invalid ciphertext

115
00:04:19,918 --> 00:04:22,000
it gets decrypted we end up with a

116
00:04:22,000 --> 00:04:24,160
message but alice will end up with a

117
00:04:24,160 --> 00:04:26,400
different cipher text she will notice

118
00:04:26,400 --> 00:04:27,840
and she will not give away any

119
00:04:27,840 --> 00:04:29,759
information and so an attacker will not

120
00:04:29,759 --> 00:04:33,360
be able to learn anything

121
00:04:33,360 --> 00:04:36,000
so is this the end of the story no of

122
00:04:36,000 --> 00:04:37,360
course not

123
00:04:37,360 --> 00:04:39,040
otherwise they wouldn't

124
00:04:39,040 --> 00:04:41,040
we wouldn't have a paper

125
00:04:41,040 --> 00:04:41,759
now

126
00:04:41,759 --> 00:04:44,160
let's first look at the nist round two

127
00:04:44,160 --> 00:04:46,160
and around three

128
00:04:46,160 --> 00:04:48,240
candidates for encryption and we see

129
00:04:48,240 --> 00:04:50,720
four schemes in there there's kyber

130
00:04:50,720 --> 00:04:53,600
sabre and true and machilis

131
00:04:53,600 --> 00:04:55,759
now two of these schemes namely kyber

132
00:04:55,759 --> 00:04:57,520
and sabre have

133
00:04:57,520 --> 00:04:59,759
a special property

134
00:04:59,759 --> 00:05:03,199
and this property is that they are

135
00:05:03,199 --> 00:05:06,160
they can have decryption failures

136
00:05:06,160 --> 00:05:08,240
this means that with a very low

137
00:05:08,240 --> 00:05:10,240
probability the probability given on the

138
00:05:10,240 --> 00:05:11,360
slide

139
00:05:11,360 --> 00:05:13,600
with a very low probability

140
00:05:13,600 --> 00:05:16,800
even if you input the correct ciphertext

141
00:05:16,800 --> 00:05:19,919
these schemes will and end up

142
00:05:19,919 --> 00:05:22,320
not being able to recover the message

143
00:05:22,320 --> 00:05:25,120
so we will have a decryption failure

144
00:05:25,120 --> 00:05:27,039
a decryption failure a failure to

145
00:05:27,039 --> 00:05:29,520
decrypt the correct message with a very

146
00:05:29,520 --> 00:05:32,080
low probability

147
00:05:32,080 --> 00:05:36,160
so how does this enable an attack

148
00:05:36,160 --> 00:05:38,720
well as before we explained that if we

149
00:05:38,720 --> 00:05:41,039
input an invalid ciphertext then the

150
00:05:41,039 --> 00:05:42,800
message is wrong and alice is going to

151
00:05:42,800 --> 00:05:44,080
notice

152
00:05:44,080 --> 00:05:46,560
so the only thing we can do is input a

153
00:05:46,560 --> 00:05:48,800
valid ciphertext

154
00:05:48,800 --> 00:05:51,600
so now we input a valid ciphertext and

155
00:05:51,600 --> 00:05:54,639
we hope it's a decryption failure

156
00:05:54,639 --> 00:05:56,720
because if it's a decryption failure

157
00:05:56,720 --> 00:06:00,160
then the message is actually incorrect

158
00:06:00,160 --> 00:06:02,160
and so if the message is incorrect we do

159
00:06:02,160 --> 00:06:03,360
the encryption

160
00:06:03,360 --> 00:06:05,680
and we will see another cypher text

161
00:06:05,680 --> 00:06:08,080
and so alice will reject reject the

162
00:06:08,080 --> 00:06:11,120
cipher text even though the cypher text

163
00:06:11,120 --> 00:06:12,960
is actually valid

164
00:06:12,960 --> 00:06:16,000
so we input a valid cipher text

165
00:06:16,000 --> 00:06:18,560
we hope the decryption failure happens

166
00:06:18,560 --> 00:06:20,800
and if a decryption failure happens then

167
00:06:20,800 --> 00:06:22,880
we know something went wrong

168
00:06:22,880 --> 00:06:24,880
and this will give us some information

169
00:06:24,880 --> 00:06:27,919
about the secret key

170
00:06:28,160 --> 00:06:29,280
so

171
00:06:29,280 --> 00:06:32,159
what has been done

172
00:06:32,240 --> 00:06:34,000
first thing i want to talk about is a

173
00:06:34,000 --> 00:06:35,360
paper published in public key

174
00:06:35,360 --> 00:06:37,520
cryptography in 2019

175
00:06:37,520 --> 00:06:39,600
um talking about this decryption failure

176
00:06:39,600 --> 00:06:41,600
attacks

177
00:06:41,600 --> 00:06:43,840
and so the first thing this paper showed

178
00:06:43,840 --> 00:06:46,720
is that actually if you find decryption

179
00:06:46,720 --> 00:06:49,520
phase so if you find valid ciphertext

180
00:06:49,520 --> 00:06:51,599
that fail to decrypt

181
00:06:51,599 --> 00:06:53,919
then you can use this to reduce the

182
00:06:53,919 --> 00:06:56,479
security of the lwe problem

183
00:06:56,479 --> 00:06:59,919
so in essence you can use this as a hint

184
00:06:59,919 --> 00:07:03,120
towards the secret key and this is

185
00:07:03,120 --> 00:07:06,080
shown on this graph so on the x-axis you

186
00:07:06,080 --> 00:07:08,319
have the number of decryption phase that

187
00:07:08,319 --> 00:07:10,080
you have found

188
00:07:10,080 --> 00:07:12,319
and on the y-axis you have the security

189
00:07:12,319 --> 00:07:14,000
of the scheme

190
00:07:14,000 --> 00:07:17,199
and you see that if you can find enough

191
00:07:17,199 --> 00:07:19,919
decryption failures you can reduce the

192
00:07:19,919 --> 00:07:23,440
security of the underlying scheme

193
00:07:23,440 --> 00:07:25,039
with a certain

194
00:07:25,039 --> 00:07:26,400
value

195
00:07:26,400 --> 00:07:27,360
so

196
00:07:27,360 --> 00:07:29,199
finding decryption failures clearly

197
00:07:29,199 --> 00:07:32,080
works and this means that there is an

198
00:07:32,080 --> 00:07:34,560
attack where you just input

199
00:07:34,560 --> 00:07:36,160
random ciphertext

200
00:07:36,160 --> 00:07:37,919
and you hope you find decryption

201
00:07:37,919 --> 00:07:39,840
failures

202
00:07:39,840 --> 00:07:41,680
but remember that these encryption

203
00:07:41,680 --> 00:07:43,840
figures only happen with the very very

204
00:07:43,840 --> 00:07:45,520
low probability

205
00:07:45,520 --> 00:07:47,520
for example for for saber it's 2 to the

206
00:07:47,520 --> 00:07:49,840
minus 136

207
00:07:49,840 --> 00:07:53,520
so this attack is gonna be very costly

208
00:07:53,520 --> 00:07:55,759
so the natural question is can we do

209
00:07:55,759 --> 00:07:56,720
better

210
00:07:56,720 --> 00:07:58,479
and that's the second contribution

211
00:07:58,479 --> 00:08:00,080
of this paper

212
00:08:00,080 --> 00:08:02,879
they introduced a way of speeding up the

213
00:08:02,879 --> 00:08:03,759
search

214
00:08:03,759 --> 00:08:06,240
for failures

215
00:08:06,240 --> 00:08:08,319
speeding of the search for the christian

216
00:08:08,319 --> 00:08:10,240
figures

217
00:08:10,240 --> 00:08:12,960
so to get an idea of how we can do this

218
00:08:12,960 --> 00:08:14,240
i will first give a high-level

219
00:08:14,240 --> 00:08:17,440
introduction of lattice-based encryption

220
00:08:17,440 --> 00:08:19,759
and so lettuce-based encryption

221
00:08:19,759 --> 00:08:21,840
is based on the notion of learning with

222
00:08:21,840 --> 00:08:24,319
errors or learning with air sample

223
00:08:24,319 --> 00:08:27,599
so what is that imagine that we have a

224
00:08:27,599 --> 00:08:30,000
matrix a which is public and which is

225
00:08:30,000 --> 00:08:32,000
uniformly made

226
00:08:32,000 --> 00:08:34,479
and we have two small

227
00:08:34,479 --> 00:08:37,839
vectors s and e

228
00:08:37,919 --> 00:08:41,279
and so what we calculate is a and we

229
00:08:41,279 --> 00:08:43,839
also calculate b where b is a times s

230
00:08:43,839 --> 00:08:45,519
plus e

231
00:08:45,519 --> 00:08:49,440
so now we give out publicly a and b

232
00:08:49,440 --> 00:08:50,800
and the learning with errors problem

233
00:08:50,800 --> 00:08:53,120
states that from a and b

234
00:08:53,120 --> 00:08:56,080
it is hard to recover s and e

235
00:08:56,080 --> 00:08:58,240
it even states that it's hard to

236
00:08:58,240 --> 00:09:01,040
distinguish a and b from just uniformly

237
00:09:01,040 --> 00:09:03,200
random values

238
00:09:03,200 --> 00:09:06,320
so a and b we call that an lwe sample

239
00:09:06,320 --> 00:09:10,080
and we say that this this is secure

240
00:09:10,080 --> 00:09:12,399
so what alice is going to do is alice is

241
00:09:12,399 --> 00:09:14,800
going to generate such an ldp sample and

242
00:09:14,800 --> 00:09:17,040
send it to bob

243
00:09:17,040 --> 00:09:18,560
now bob

244
00:09:18,560 --> 00:09:21,040
will take both of these values a and b

245
00:09:21,040 --> 00:09:24,000
which look uniformly random to him

246
00:09:24,000 --> 00:09:25,600
will use them both

247
00:09:25,600 --> 00:09:28,000
in a new lw sample

248
00:09:28,000 --> 00:09:31,360
so he will multiply both by s prime and

249
00:09:31,360 --> 00:09:34,480
add some error to it

250
00:09:34,480 --> 00:09:37,360
and this will give him uh four values a

251
00:09:37,360 --> 00:09:39,920
b prime b and v prime

252
00:09:39,920 --> 00:09:41,760
and he will send over b prime and v

253
00:09:41,760 --> 00:09:44,880
prime back to alice

254
00:09:44,880 --> 00:09:48,480
and now alice ah and also of course

255
00:09:48,480 --> 00:09:49,760
he will add

256
00:09:49,760 --> 00:09:51,920
a message to this because we want to

257
00:09:51,920 --> 00:09:54,160
send over a message

258
00:09:54,160 --> 00:09:55,440
now alice

259
00:09:55,440 --> 00:09:58,800
can recover this message by

260
00:09:58,800 --> 00:10:00,800
by calculating v prime minus b prime

261
00:10:00,800 --> 00:10:02,480
times s

262
00:10:02,480 --> 00:10:04,800
so if you write this out you get this

263
00:10:04,800 --> 00:10:07,519
whole term um the message is equal to

264
00:10:07,519 --> 00:10:10,000
this whole term a lot of terms but

265
00:10:10,000 --> 00:10:11,839
we can simplify this because the two

266
00:10:11,839 --> 00:10:14,240
terms involving the big a

267
00:10:14,240 --> 00:10:16,079
cancel each other out

268
00:10:16,079 --> 00:10:18,480
so we end up with the message being

269
00:10:18,480 --> 00:10:20,079
equal to the message

270
00:10:20,079 --> 00:10:22,880
plus some error

271
00:10:22,880 --> 00:10:24,560
and as long as this error is small

272
00:10:24,560 --> 00:10:25,519
enough

273
00:10:25,519 --> 00:10:28,320
we will not have a decryption failure

274
00:10:28,320 --> 00:10:31,839
and we'll have a correct

275
00:10:31,839 --> 00:10:34,800
transmission transmission as a message

276
00:10:34,800 --> 00:10:37,600
now if this error term

277
00:10:37,600 --> 00:10:39,839
is actually bigger than q divided by

278
00:10:39,839 --> 00:10:40,640
four

279
00:10:40,640 --> 00:10:42,160
in absolute value and any of the

280
00:10:42,160 --> 00:10:43,440
coefficients

281
00:10:43,440 --> 00:10:47,760
then we will have a decryption failure

282
00:10:47,760 --> 00:10:48,640
so

283
00:10:48,640 --> 00:10:50,880
we can even simplify this further

284
00:10:50,880 --> 00:10:53,600
imagine that we take all the values of

285
00:10:53,600 --> 00:10:58,720
alice into a big s so this is s and e

286
00:10:58,720 --> 00:11:01,040
and all the values of bulb we take into

287
00:11:01,040 --> 00:11:04,480
a ciphertext vector vector c big c

288
00:11:04,480 --> 00:11:07,600
which is uh minus e prime s prime

289
00:11:07,600 --> 00:11:08,800
and also

290
00:11:08,800 --> 00:11:10,399
just for the sake of of this

291
00:11:10,399 --> 00:11:12,399
presentation we'll say that e prime

292
00:11:12,399 --> 00:11:15,600
prime is approximately zero

293
00:11:15,600 --> 00:11:18,160
now on the left we have an image

294
00:11:18,160 --> 00:11:19,600
representing this

295
00:11:19,600 --> 00:11:22,079
be aware this is a toy example um this

296
00:11:22,079 --> 00:11:24,800
is two dimensional while in reality

297
00:11:24,800 --> 00:11:27,360
these vectors would be like 1 500

298
00:11:27,360 --> 00:11:29,839
dimensional

299
00:11:30,640 --> 00:11:31,920
so

300
00:11:31,920 --> 00:11:34,640
given this big s and big c

301
00:11:34,640 --> 00:11:38,480
we can rewrite or simplify this

302
00:11:38,480 --> 00:11:41,040
fair equation as the inner product

303
00:11:41,040 --> 00:11:42,720
between s and c

304
00:11:42,720 --> 00:11:45,040
if this is bigger than q divided by 4

305
00:11:45,040 --> 00:11:48,480
then we have a decryption failure

306
00:11:48,480 --> 00:11:50,320
so let's continue working on this

307
00:11:50,320 --> 00:11:52,399
equation the inner product between two

308
00:11:52,399 --> 00:11:53,839
vectors

309
00:11:53,839 --> 00:11:56,160
we can also rewrite this at the norm of

310
00:11:56,160 --> 00:11:58,160
the first vector times the norm of the

311
00:11:58,160 --> 00:12:00,560
second vector times the angle between

312
00:12:00,560 --> 00:12:02,880
the two vectors

313
00:12:02,880 --> 00:12:04,399
and so we want to have decryption

314
00:12:04,399 --> 00:12:06,480
failure so we want this

315
00:12:06,480 --> 00:12:08,240
this inner product

316
00:12:08,240 --> 00:12:09,440
to be big

317
00:12:09,440 --> 00:12:10,639
so

318
00:12:10,639 --> 00:12:12,800
what we can what can we do well we can

319
00:12:12,800 --> 00:12:14,800
look at the norm of the secret we want

320
00:12:14,800 --> 00:12:16,959
this to be big but i mean we cannot

321
00:12:16,959 --> 00:12:18,399
influence the secret

322
00:12:18,399 --> 00:12:21,440
so we can't do anything with this

323
00:12:21,440 --> 00:12:24,480
we also want our ciphertext to be close

324
00:12:24,480 --> 00:12:26,800
to the secret vector because then we'll

325
00:12:26,800 --> 00:12:28,639
also have a higher value and a higher

326
00:12:28,639 --> 00:12:31,680
probability of decryption failures

327
00:12:31,680 --> 00:12:33,839
however we don't know the direction of a

328
00:12:33,839 --> 00:12:35,839
secret so we cannot do anything with

329
00:12:35,839 --> 00:12:38,079
this term

330
00:12:38,079 --> 00:12:40,480
so this leaves us with the ciphertext

331
00:12:40,480 --> 00:12:41,680
norm

332
00:12:41,680 --> 00:12:43,680
we want to have a ciphertext with a high

333
00:12:43,680 --> 00:12:44,800
norm

334
00:12:44,800 --> 00:12:46,000
and the higher the norm of the

335
00:12:46,000 --> 00:12:48,800
ciphertext the higher the probability of

336
00:12:48,800 --> 00:12:52,079
a decryption failure

337
00:12:52,079 --> 00:12:52,959
so

338
00:12:52,959 --> 00:12:54,959
solution found we just choose a very

339
00:12:54,959 --> 00:12:56,959
large normal c

340
00:12:56,959 --> 00:12:58,800
well this does not work

341
00:12:58,800 --> 00:13:00,880
because remember from before we have

342
00:13:00,880 --> 00:13:03,920
this fushisaki okamoto transformation

343
00:13:03,920 --> 00:13:05,600
alice is gonna check

344
00:13:05,600 --> 00:13:07,279
our ciphertext

345
00:13:07,279 --> 00:13:09,200
and so we cannot choose any arbitrary

346
00:13:09,200 --> 00:13:12,160
ciphertext we need to follow the correct

347
00:13:12,160 --> 00:13:15,120
encryption procedure

348
00:13:15,120 --> 00:13:18,959
so this leads us to failure boosting

349
00:13:18,959 --> 00:13:20,800
so what is aid

350
00:13:20,800 --> 00:13:23,120
we have a secret vector s

351
00:13:23,120 --> 00:13:24,959
and based on the secret vector there is

352
00:13:24,959 --> 00:13:27,360
a certain area and if the cypher text is

353
00:13:27,360 --> 00:13:29,680
in this area we'll have a decryption

354
00:13:29,680 --> 00:13:31,920
failure

355
00:13:31,920 --> 00:13:33,360
so we don't know the secret vector we

356
00:13:33,360 --> 00:13:36,399
don't know this area but we want to have

357
00:13:36,399 --> 00:13:38,560
an as high as possible probability of

358
00:13:38,560 --> 00:13:42,000
finding such a failure

359
00:13:42,000 --> 00:13:43,519
and this figure happens with the failure

360
00:13:43,519 --> 00:13:46,720
probability delta

361
00:13:46,720 --> 00:13:48,160
now what we're going to do is we're

362
00:13:48,160 --> 00:13:50,240
going to generate random but valid

363
00:13:50,240 --> 00:13:52,240
cipher texts

364
00:13:52,240 --> 00:13:54,240
and all these random ciphertexts they

365
00:13:54,240 --> 00:13:56,639
will be in this space but we will only

366
00:13:56,639 --> 00:13:59,279
keep weak ciphertext

367
00:13:59,279 --> 00:14:01,199
so this means ciphertext with a high

368
00:14:01,199 --> 00:14:02,639
failure probability

369
00:14:02,639 --> 00:14:05,440
or equivalently science text with a high

370
00:14:05,440 --> 00:14:06,480
norm

371
00:14:06,480 --> 00:14:09,120
so it will keep all cyc text outside a

372
00:14:09,120 --> 00:14:11,839
certain circle

373
00:14:11,839 --> 00:14:14,560
weak ciphertext

374
00:14:14,560 --> 00:14:16,720
and so if we plot this weak science text

375
00:14:16,720 --> 00:14:19,120
over the failure area we'll see that

376
00:14:19,120 --> 00:14:21,040
there is a higher overlap

377
00:14:21,040 --> 00:14:23,120
so we have just increased the

378
00:14:23,120 --> 00:14:25,680
probability of a decryption failure from

379
00:14:25,680 --> 00:14:28,560
delta to beta

380
00:14:28,560 --> 00:14:30,399
now this came at the cost because we had

381
00:14:30,399 --> 00:14:32,560
to do this precalculation we had to

382
00:14:32,560 --> 00:14:35,360
generate a bunch of ciphertext before we

383
00:14:35,360 --> 00:14:38,480
find such a weak ciphertext

384
00:14:38,480 --> 00:14:39,680
so we've

385
00:14:39,680 --> 00:14:42,079
transformed just random guessing into a

386
00:14:42,079 --> 00:14:44,399
two-step procedure where we first do a

387
00:14:44,399 --> 00:14:45,839
pre-calculation

388
00:14:45,839 --> 00:14:47,760
and then we

389
00:14:47,760 --> 00:14:50,160
can send in ciphertext weak septics with

390
00:14:50,160 --> 00:14:53,519
a higher failure probability

391
00:14:53,600 --> 00:14:55,839
now the total expected work to find the

392
00:14:55,839 --> 00:14:57,600
decryption failure now is this

393
00:14:57,600 --> 00:14:59,360
precalculation that we have to do for

394
00:14:59,360 --> 00:15:02,160
each ciphertext that we send in

395
00:15:02,160 --> 00:15:04,320
times the inverse of the failure

396
00:15:04,320 --> 00:15:06,880
probability

397
00:15:06,880 --> 00:15:09,360
and now the trick comes because what we

398
00:15:09,360 --> 00:15:11,839
can do is we can actually speed up this

399
00:15:11,839 --> 00:15:13,360
precalculation

400
00:15:13,360 --> 00:15:16,160
because this is just a search

401
00:15:16,160 --> 00:15:17,680
and a search of something that we can

402
00:15:17,680 --> 00:15:18,959
completely predict that we can

403
00:15:18,959 --> 00:15:21,440
completely compute so we can do this on

404
00:15:21,440 --> 00:15:23,360
a quantum computer

405
00:15:23,360 --> 00:15:25,760
the second part the sending in the

406
00:15:25,760 --> 00:15:27,519
ciphertext we cannot do on a quantum

407
00:15:27,519 --> 00:15:30,480
computer because we cannot simulate this

408
00:15:30,480 --> 00:15:31,839
we have we don't have all the

409
00:15:31,839 --> 00:15:35,040
information we don't have a secret key

410
00:15:35,040 --> 00:15:37,519
so in essence what we did was we split

411
00:15:37,519 --> 00:15:39,199
up this random guessing into two

412
00:15:39,199 --> 00:15:41,680
procedures a pre-calculation that we can

413
00:15:41,680 --> 00:15:42,880
speed up

414
00:15:42,880 --> 00:15:44,639
with the quantum computer using all the

415
00:15:44,639 --> 00:15:46,000
knowledge that we have

416
00:15:46,000 --> 00:15:48,320
and a second part where

417
00:15:48,320 --> 00:15:50,560
we increase the failure probability but

418
00:15:50,560 --> 00:15:52,720
a part that we cannot speed up using a

419
00:15:52,720 --> 00:15:55,519
quantum computer

420
00:15:55,519 --> 00:15:57,839
and so the result of this

421
00:15:57,839 --> 00:15:59,360
is given in this

422
00:15:59,360 --> 00:16:02,240
graph so on the x-axis you have the

423
00:16:02,240 --> 00:16:04,800
amount of work that you do into this

424
00:16:04,800 --> 00:16:06,959
pre-computation

425
00:16:06,959 --> 00:16:08,959
and on the y-axis you have the total

426
00:16:08,959 --> 00:16:11,360
work to generate a failure

427
00:16:11,360 --> 00:16:13,440
now on the complete left you have random

428
00:16:13,440 --> 00:16:15,600
guessing if you do no pre-computation

429
00:16:15,600 --> 00:16:18,320
work then you're just random guessing

430
00:16:18,320 --> 00:16:20,959
and you can see that actually using a

431
00:16:20,959 --> 00:16:22,720
quantum computer and using this grover

432
00:16:22,720 --> 00:16:25,440
search if you do a precomputation you

433
00:16:25,440 --> 00:16:27,440
actually bring down the cost to find a

434
00:16:27,440 --> 00:16:29,759
failure using this failure boosting

435
00:16:29,759 --> 00:16:30,880
procedure

436
00:16:30,880 --> 00:16:34,079
so we have just increased or decreased

437
00:16:34,079 --> 00:16:36,959
the cost of finding a failure

438
00:16:36,959 --> 00:16:39,199
now the advantage of failure boosting is

439
00:16:39,199 --> 00:16:41,519
not only a slower cost but maybe more

440
00:16:41,519 --> 00:16:44,240
importantly also that we have to send

441
00:16:44,240 --> 00:16:45,920
less queries

442
00:16:45,920 --> 00:16:48,000
before the theory probability was delta

443
00:16:48,000 --> 00:16:49,440
so we had to

444
00:16:49,440 --> 00:16:52,399
send in delta to the minus one craze

445
00:16:52,399 --> 00:16:54,079
now we've reduced the failure

446
00:16:54,079 --> 00:16:55,920
probability to beta

447
00:16:55,920 --> 00:16:57,120
which

448
00:16:57,120 --> 00:16:59,600
is a higher number so we have to send in

449
00:16:59,600 --> 00:17:02,399
less queries

450
00:17:02,959 --> 00:17:06,000
so this is the first paper

451
00:17:06,000 --> 00:17:07,839
or a quick overview of the results of

452
00:17:07,839 --> 00:17:09,439
this first paper

453
00:17:09,439 --> 00:17:10,559
i will also

454
00:17:10,559 --> 00:17:12,959
quickly talk about the second paper

455
00:17:12,959 --> 00:17:15,280
which looks at the scenario where you

456
00:17:15,280 --> 00:17:18,799
already find one decryption failure so

457
00:17:18,799 --> 00:17:20,640
imagine that we have found

458
00:17:20,640 --> 00:17:22,240
one decryption phase or one or more

459
00:17:22,240 --> 00:17:25,039
decryption failures

460
00:17:25,039 --> 00:17:27,359
now finding such decryption figure gives

461
00:17:27,359 --> 00:17:29,280
you some information

462
00:17:29,280 --> 00:17:31,200
because the decryption phase will be

463
00:17:31,200 --> 00:17:34,640
kind of in the direction of the secret

464
00:17:34,640 --> 00:17:38,000
which also means that we have an idea of

465
00:17:38,000 --> 00:17:39,760
the secret

466
00:17:39,760 --> 00:17:42,080
so as before we have this failure

467
00:17:42,080 --> 00:17:44,320
condition the inner product between s

468
00:17:44,320 --> 00:17:45,520
and c

469
00:17:45,520 --> 00:17:48,400
and we can still not influence cs

470
00:17:48,400 --> 00:17:50,480
and we still want to have a large norm

471
00:17:50,480 --> 00:17:52,080
of c

472
00:17:52,080 --> 00:17:54,000
but now additionally we have extra

473
00:17:54,000 --> 00:17:57,280
information because we roughly know the

474
00:17:57,280 --> 00:17:59,440
direction of the secret

475
00:17:59,440 --> 00:18:01,600
and so we can adapt

476
00:18:01,600 --> 00:18:03,120
this this weak

477
00:18:03,120 --> 00:18:06,480
cytex area from a circle into a more fit

478
00:18:06,480 --> 00:18:07,360
shape

479
00:18:07,360 --> 00:18:09,280
based on this direction

480
00:18:09,280 --> 00:18:11,280
so that there is a bigger overlap

481
00:18:11,280 --> 00:18:13,120
between

482
00:18:13,120 --> 00:18:16,000
the weak ciphertext and the failure area

483
00:18:16,000 --> 00:18:18,000
so we have a better prediction and we

484
00:18:18,000 --> 00:18:20,480
can search more efficiently towards the

485
00:18:20,480 --> 00:18:23,520
next decryption failure

486
00:18:23,520 --> 00:18:25,679
and so this graph depicts the results of

487
00:18:25,679 --> 00:18:27,520
this

488
00:18:27,520 --> 00:18:30,000
so on the x-axis you have the number of

489
00:18:30,000 --> 00:18:32,799
available ciphertexts the the number of

490
00:18:32,799 --> 00:18:34,960
um ciphertexts failing ciphertext that

491
00:18:34,960 --> 00:18:37,039
you have already found

492
00:18:37,039 --> 00:18:39,840
on the y-axis you have the total work

493
00:18:39,840 --> 00:18:41,200
and the total number of queries that you

494
00:18:41,200 --> 00:18:45,200
need to do to find the next failure

495
00:18:45,200 --> 00:18:48,400
and take into account that this graph is

496
00:18:48,400 --> 00:18:49,280
a

497
00:18:49,280 --> 00:18:51,840
logarithmic so this means that if you

498
00:18:51,840 --> 00:18:54,400
find a failure then finding the next

499
00:18:54,400 --> 00:18:57,120
sphere is much much cheaper and finding

500
00:18:57,120 --> 00:19:00,240
the next phase is even more cheap

501
00:19:00,240 --> 00:19:01,360
so

502
00:19:01,360 --> 00:19:02,720
it's kind of like a bootstrapping

503
00:19:02,720 --> 00:19:04,799
problem once you find one failure it

504
00:19:04,799 --> 00:19:06,480
becomes

505
00:19:06,480 --> 00:19:08,160
a lot cheaper to find the next and the

506
00:19:08,160 --> 00:19:10,880
next and so essentially you're limited

507
00:19:10,880 --> 00:19:13,440
by finding the first failure if you find

508
00:19:13,440 --> 00:19:15,919
one failure it really speeds up the rest

509
00:19:15,919 --> 00:19:18,559
of the process

510
00:19:18,640 --> 00:19:20,559
so this was the introduction now for

511
00:19:20,559 --> 00:19:23,760
people who want to get more into

512
00:19:23,760 --> 00:19:25,679
decryption failures there's two more

513
00:19:25,679 --> 00:19:28,559
resources that i can recommend apart

514
00:19:28,559 --> 00:19:30,240
from our paper of course

515
00:19:30,240 --> 00:19:32,480
the first one being my phd thesis

516
00:19:32,480 --> 00:19:34,320
chapter four

517
00:19:34,320 --> 00:19:36,000
this contains no

518
00:19:36,000 --> 00:19:39,200
radical new ids but gives an overview of

519
00:19:39,200 --> 00:19:41,360
the two previous papers

520
00:19:41,360 --> 00:19:43,200
and gives also some extra thoughts some

521
00:19:43,200 --> 00:19:45,679
extra discussion on all of these methods

522
00:19:45,679 --> 00:19:48,400
and gives a generalized framework so if

523
00:19:48,400 --> 00:19:49,919
you want to get into into decryption

524
00:19:49,919 --> 00:19:52,000
failure attacks i would highly recommend

525
00:19:52,000 --> 00:19:53,039
you

526
00:19:53,039 --> 00:19:55,360
to take a look at this

527
00:19:55,360 --> 00:19:57,360
a second one is a very interested

528
00:19:57,360 --> 00:20:00,000
interesting paper by nina bindalan john

529
00:20:00,000 --> 00:20:01,679
shank

530
00:20:01,679 --> 00:20:05,679
that looks at the effect of

531
00:20:05,760 --> 00:20:08,159
of successful decryption so what if you

532
00:20:08,159 --> 00:20:10,159
don't find decryption failure but what

533
00:20:10,159 --> 00:20:12,720
if you find a decryption success can you

534
00:20:12,720 --> 00:20:14,799
use this to find

535
00:20:14,799 --> 00:20:16,159
the more the next failure more

536
00:20:16,159 --> 00:20:19,159
efficiently

537
00:20:20,000 --> 00:20:22,640
now let's focus on the contributions

538
00:20:22,640 --> 00:20:25,600
in our paper and the first is a leveled

539
00:20:25,600 --> 00:20:28,320
multi-target attack

540
00:20:28,320 --> 00:20:30,559
so in our paper we focused on real-world

541
00:20:30,559 --> 00:20:33,120
impact of the encryption failure attacks

542
00:20:33,120 --> 00:20:34,480
and thus means

543
00:20:34,480 --> 00:20:37,600
constrained attacks so attacks in a real

544
00:20:37,600 --> 00:20:40,640
scenario or in a more real scenario

545
00:20:40,640 --> 00:20:43,200
with practical constraints

546
00:20:43,200 --> 00:20:45,440
and also attacks on real schemes like

547
00:20:45,440 --> 00:20:48,000
sabre and kyber

548
00:20:48,000 --> 00:20:49,679
so constraint attacks what do we mean

549
00:20:49,679 --> 00:20:51,520
with this

550
00:20:51,520 --> 00:20:53,440
remember that before we were talking

551
00:20:53,440 --> 00:20:55,600
about an amount of work that we need to

552
00:20:55,600 --> 00:20:57,679
do and an amount of queries that we need

553
00:20:57,679 --> 00:20:59,280
to do an amount of cipher text that we

554
00:20:59,280 --> 00:21:01,520
need to send to alice

555
00:21:01,520 --> 00:21:03,360
and in these attacks before we would

556
00:21:03,360 --> 00:21:05,679
have numbers like we need to send one

557
00:21:05,679 --> 00:21:07,280
two to the one hundred or two to one

558
00:21:07,280 --> 00:21:08,880
hundred twenty eight scythe text to

559
00:21:08,880 --> 00:21:10,640
alice

560
00:21:10,640 --> 00:21:13,760
now more than this being a key recovery

561
00:21:13,760 --> 00:21:15,760
attack like an attack where we

562
00:21:15,760 --> 00:21:17,679
learn the secret key

563
00:21:17,679 --> 00:21:20,080
this is gonna be a denial of service

564
00:21:20,080 --> 00:21:21,760
attack i mean we're sending so many

565
00:21:21,760 --> 00:21:22,960
queries that

566
00:21:22,960 --> 00:21:25,039
well before we learn anything about the

567
00:21:25,039 --> 00:21:27,679
secret the server will go down and and

568
00:21:27,679 --> 00:21:31,440
people will notice that something is up

569
00:21:31,440 --> 00:21:32,400
so

570
00:21:32,400 --> 00:21:34,480
these attacks are in this sense not

571
00:21:34,480 --> 00:21:35,679
practical and

572
00:21:35,679 --> 00:21:37,200
we're going to look at attacks where we

573
00:21:37,200 --> 00:21:40,240
can reduce this number of scifi texts or

574
00:21:40,240 --> 00:21:42,559
of messages that we have to send at one

575
00:21:42,559 --> 00:21:44,559
particular server

576
00:21:44,559 --> 00:21:45,919
and we're going to do that using

577
00:21:45,919 --> 00:21:47,919
multi-target attacks

578
00:21:47,919 --> 00:21:50,480
so the idea is to spread these queries

579
00:21:50,480 --> 00:21:52,240
over multiple targets

580
00:21:52,240 --> 00:21:54,799
to say for example we have a maximum of

581
00:21:54,799 --> 00:21:57,120
264 queries that we can send to one

582
00:21:57,120 --> 00:22:00,559
target but we consider

583
00:22:00,559 --> 00:22:03,440
uh more targets we consider an abundance

584
00:22:03,440 --> 00:22:04,640
of targets

585
00:22:04,640 --> 00:22:06,559
and our goal is to retrieve the secret

586
00:22:06,559 --> 00:22:09,520
key of one specific target of one target

587
00:22:09,520 --> 00:22:12,159
one random target out of this whole heap

588
00:22:12,159 --> 00:22:14,159
of targets

589
00:22:14,159 --> 00:22:17,280
for example we can do maximal uh

590
00:22:17,280 --> 00:22:19,840
2-64 queries

591
00:22:19,840 --> 00:22:22,240
at 2 to the 64 targets

592
00:22:22,240 --> 00:22:24,400
so in total this gives us still two to

593
00:22:24,400 --> 00:22:27,280
the 128th queries

594
00:22:27,280 --> 00:22:30,240
but now we distribute it over multiple

595
00:22:30,240 --> 00:22:34,000
servers over multiple iot nodes

596
00:22:34,000 --> 00:22:36,000
so naive approach

597
00:22:36,000 --> 00:22:38,559
would be to consider all these servers

598
00:22:38,559 --> 00:22:40,640
and in the first instance we're going to

599
00:22:40,640 --> 00:22:42,559
try to find one failure

600
00:22:42,559 --> 00:22:44,320
and we're going to say that we have a

601
00:22:44,320 --> 00:22:46,480
maximum of two to the 100

602
00:22:46,480 --> 00:22:47,520
100

603
00:22:47,520 --> 00:22:51,520
2 to the 127 queries to find one failure

604
00:22:51,520 --> 00:22:53,760
to find the first failure

605
00:22:53,760 --> 00:22:56,159
and once we find one failure

606
00:22:56,159 --> 00:22:58,320
we're gonna target this server and we're

607
00:22:58,320 --> 00:23:00,240
gonna find follow-up failures with

608
00:23:00,240 --> 00:23:03,840
maximum 263 queries

609
00:23:03,840 --> 00:23:06,159
why does this help this first step well

610
00:23:06,159 --> 00:23:08,640
remember that if we find the decryption

611
00:23:08,640 --> 00:23:11,120
failure then finding follow-up failures

612
00:23:11,120 --> 00:23:13,840
is much more efficient

613
00:23:13,840 --> 00:23:16,400
and this can be seen in this graph

614
00:23:16,400 --> 00:23:19,200
so on the x-axis you have the failure

615
00:23:19,200 --> 00:23:20,240
rate

616
00:23:20,240 --> 00:23:22,960
after a failure boosting so

617
00:23:22,960 --> 00:23:25,039
this is inversely proportional to the

618
00:23:25,039 --> 00:23:27,039
number of queries that you expect to be

619
00:23:27,039 --> 00:23:29,440
sent to two cents

620
00:23:29,440 --> 00:23:32,159
and on the exact on the y-axis you have

621
00:23:32,159 --> 00:23:35,440
the total work to find the failure

622
00:23:35,440 --> 00:23:37,280
so you see the blow the blue curve the

623
00:23:37,280 --> 00:23:39,679
curve to find the first failure is much

624
00:23:39,679 --> 00:23:42,159
higher than the orange curve

625
00:23:42,159 --> 00:23:46,080
so the co the the curve it's much less

626
00:23:46,080 --> 00:23:48,159
efficient or it's much more efficient to

627
00:23:48,159 --> 00:23:50,400
find the second failure than it is to

628
00:23:50,400 --> 00:23:53,600
find the first failure

629
00:23:53,600 --> 00:23:55,679
but there is another thing that is

630
00:23:55,679 --> 00:23:58,080
taking that is uh that needs to be taken

631
00:23:58,080 --> 00:23:59,279
into account

632
00:23:59,279 --> 00:24:01,120
and that is the fact that we have two to

633
00:24:01,120 --> 00:24:03,840
the 127 queries to find the first

634
00:24:03,840 --> 00:24:05,039
failure

635
00:24:05,039 --> 00:24:07,120
so to find the first phase we can be

636
00:24:07,120 --> 00:24:08,720
essentially anywhere on this blue curve

637
00:24:08,720 --> 00:24:10,320
and we can choose the most efficient

638
00:24:10,320 --> 00:24:12,159
points

639
00:24:12,159 --> 00:24:15,840
however in the follow up

640
00:24:15,840 --> 00:24:19,120
we are limited by this 2 to the 63

641
00:24:19,120 --> 00:24:20,640
queries that we can do

642
00:24:20,640 --> 00:24:22,799
so in the follow up we cannot be on the

643
00:24:22,799 --> 00:24:24,799
this optimal point in the curve we need

644
00:24:24,799 --> 00:24:27,440
to be on the right of the dotted line

645
00:24:27,440 --> 00:24:29,520
over the 2 to the 63

646
00:24:29,520 --> 00:24:30,960
line

647
00:24:30,960 --> 00:24:32,799
and so this is the naive multi-target

648
00:24:32,799 --> 00:24:35,200
attack that was already hinted at in the

649
00:24:35,200 --> 00:24:39,120
europa paper that i presented before

650
00:24:39,120 --> 00:24:41,760
so now in our paper we present a leveled

651
00:24:41,760 --> 00:24:43,279
approach

652
00:24:43,279 --> 00:24:45,600
so in a leveled approach we

653
00:24:45,600 --> 00:24:47,919
do the same thing as before so we attack

654
00:24:47,919 --> 00:24:50,559
to the 64 targets and we have for each

655
00:24:50,559 --> 00:24:54,559
target a maximum number of queries

656
00:24:54,720 --> 00:24:56,480
but what we're going to do is we're not

657
00:24:56,480 --> 00:24:58,799
going to try to find one failure we're

658
00:24:58,799 --> 00:25:01,279
going to try to find n phase so n

659
00:25:01,279 --> 00:25:02,880
servers that fail

660
00:25:02,880 --> 00:25:05,679
and we have a maximum of 2 to 127 crates

661
00:25:05,679 --> 00:25:07,840
for that

662
00:25:07,840 --> 00:25:11,200
now once we find n failures

663
00:25:11,200 --> 00:25:13,279
then we're going to look for a second

664
00:25:13,279 --> 00:25:15,120
failure and we're going to target

665
00:25:15,120 --> 00:25:16,720
these n

666
00:25:16,720 --> 00:25:18,320
servers

667
00:25:18,320 --> 00:25:20,480
so this means that we have a maximum of

668
00:25:20,480 --> 00:25:22,400
2 to the 62

669
00:25:22,400 --> 00:25:24,000
times n queries

670
00:25:24,000 --> 00:25:26,559
we have now more serves because we have

671
00:25:26,559 --> 00:25:29,279
n targets that we can use

672
00:25:29,279 --> 00:25:31,679
and then afterwards we just continue our

673
00:25:31,679 --> 00:25:34,159
attack as before

674
00:25:34,159 --> 00:25:36,799
so let's look at this from an from this

675
00:25:36,799 --> 00:25:38,799
perspective in this table the details

676
00:25:38,799 --> 00:25:40,480
are not important but if you compare the

677
00:25:40,480 --> 00:25:42,480
two attacks

678
00:25:42,480 --> 00:25:44,880
then the differences are given in bolt

679
00:25:44,880 --> 00:25:47,440
so the work for the first sphere goes up

680
00:25:47,440 --> 00:25:49,279
by a factor n

681
00:25:49,279 --> 00:25:51,039
because for the first failure we're

682
00:25:51,039 --> 00:25:52,880
doing this procedure n times we're

683
00:25:52,880 --> 00:25:56,559
trying to find n failures here

684
00:25:56,559 --> 00:25:59,039
however for the second failure now we

685
00:25:59,039 --> 00:26:01,520
have much more relaxed

686
00:26:01,520 --> 00:26:04,400
constraints because we can uh

687
00:26:04,400 --> 00:26:08,000
we can do n times more queries to find

688
00:26:08,000 --> 00:26:11,039
uh follow a second failure

689
00:26:11,039 --> 00:26:13,520
and the grass looks something like this

690
00:26:13,520 --> 00:26:15,840
so on the blue curve you see that we

691
00:26:15,840 --> 00:26:17,919
have this dot this dot so

692
00:26:17,919 --> 00:26:21,600
um instead of being on the x we do more

693
00:26:21,600 --> 00:26:23,520
we have a bigger cost because we do this

694
00:26:23,520 --> 00:26:26,799
n times so we will have be higher in in

695
00:26:26,799 --> 00:26:28,320
the graph

696
00:26:28,320 --> 00:26:29,360
but

697
00:26:29,360 --> 00:26:32,240
this corresponds to a lower cost in this

698
00:26:32,240 --> 00:26:34,400
in on the orange curve

699
00:26:34,400 --> 00:26:36,720
where instead of being needing to be on

700
00:26:36,720 --> 00:26:38,880
the right of the dollot line we can now

701
00:26:38,880 --> 00:26:41,679
be a little bit more relaxed we can

702
00:26:41,679 --> 00:26:44,400
shift the factor of n to the left and so

703
00:26:44,400 --> 00:26:46,880
we can reduce the attack on stair

704
00:26:46,880 --> 00:26:49,279
and so by balancing the two out we can

705
00:26:49,279 --> 00:26:51,279
reduce the attack cost

706
00:26:51,279 --> 00:26:53,200
and in this scenario we reduce the

707
00:26:53,200 --> 00:26:56,640
attack cost from 2 to 120 to

708
00:26:56,640 --> 00:27:00,640
approximately 2 to the 115

709
00:27:03,440 --> 00:27:06,799
improving the cost estimation

710
00:27:06,799 --> 00:27:08,320
improving the cost estimation what do we

711
00:27:08,320 --> 00:27:09,840
mean with this

712
00:27:09,840 --> 00:27:13,039
well we have this failure boosting id

713
00:27:13,039 --> 00:27:17,120
the idea of improving or increasing the

714
00:27:17,120 --> 00:27:18,640
increasing the speed of finding

715
00:27:18,640 --> 00:27:20,559
decryption phase decreasing the cost of

716
00:27:20,559 --> 00:27:22,640
finding encryption fares and the whole

717
00:27:22,640 --> 00:27:24,640
theory is

718
00:27:24,640 --> 00:27:26,559
is rather simple it's rather simple

719
00:27:26,559 --> 00:27:27,600
theory

720
00:27:27,600 --> 00:27:30,000
but then if you want to calculate how

721
00:27:30,000 --> 00:27:31,840
much it would cost

722
00:27:31,840 --> 00:27:33,600
if you want to calculate these curves

723
00:27:33,600 --> 00:27:35,520
this becomes actually very expensive and

724
00:27:35,520 --> 00:27:37,039
very hard to do

725
00:27:37,039 --> 00:27:39,360
and to do this in previous papers and

726
00:27:39,360 --> 00:27:40,880
also in our paper we have used

727
00:27:40,880 --> 00:27:43,520
approximations you use simplifications

728
00:27:43,520 --> 00:27:45,840
just to actually get numbers out in a

729
00:27:45,840 --> 00:27:48,159
reasonable reasonable amount of time and

730
00:27:48,159 --> 00:27:49,520
with a reasonable amount of

731
00:27:49,520 --> 00:27:52,640
computational resources

732
00:27:52,640 --> 00:27:54,640
now in our paper we include a few

733
00:27:54,640 --> 00:27:56,399
additional effects a few additional

734
00:27:56,399 --> 00:27:59,440
constraints to get a more

735
00:27:59,440 --> 00:28:00,559
a better

736
00:28:00,559 --> 00:28:03,440
idea of the real cost of decryption

737
00:28:03,440 --> 00:28:05,279
failure attacks

738
00:28:05,279 --> 00:28:07,360
and so the ideas that we worked on this

739
00:28:07,360 --> 00:28:09,200
paper is weak keys

740
00:28:09,200 --> 00:28:11,679
is a worse unexpected angle is a quantum

741
00:28:11,679 --> 00:28:13,600
computer depth a limited quantum

742
00:28:13,600 --> 00:28:15,279
computer depth and a limited message

743
00:28:15,279 --> 00:28:16,480
space

744
00:28:16,480 --> 00:28:18,559
and so in this presentation i will focus

745
00:28:18,559 --> 00:28:20,799
on the wiki effect and on a worse than

746
00:28:20,799 --> 00:28:23,200
expected angle

747
00:28:23,200 --> 00:28:25,200
so wikis

748
00:28:25,200 --> 00:28:26,799
remember that we are doing this

749
00:28:26,799 --> 00:28:28,960
multi-target attack so we are not only

750
00:28:28,960 --> 00:28:31,679
targeting one server we're targeting a

751
00:28:31,679 --> 00:28:34,320
whole a whole lot of service to the 64

752
00:28:34,320 --> 00:28:35,919
servers

753
00:28:35,919 --> 00:28:38,880
and each of his servers has his own

754
00:28:38,880 --> 00:28:40,720
secret key as

755
00:28:40,720 --> 00:28:43,520
now some servers will have a high

756
00:28:43,520 --> 00:28:45,600
secret key with a high norm and some

757
00:28:45,600 --> 00:28:47,120
servers will have a secret key with a

758
00:28:47,120 --> 00:28:49,120
loan arm

759
00:28:49,120 --> 00:28:50,880
now this also means that some of these

760
00:28:50,880 --> 00:28:52,880
servers are more prone to failures

761
00:28:52,880 --> 00:28:54,880
because if you have a high norm of s

762
00:28:54,880 --> 00:28:57,440
then you'll have more likely failures

763
00:28:57,440 --> 00:29:00,480
so some of these servers will have a

764
00:29:00,480 --> 00:29:03,039
higher probability of failure

765
00:29:03,039 --> 00:29:05,760
and so if we find a failure

766
00:29:05,760 --> 00:29:08,240
while looking querying all these targets

767
00:29:08,240 --> 00:29:10,880
if we find a failure then we can assume

768
00:29:10,880 --> 00:29:13,600
that this server actually has a higher

769
00:29:13,600 --> 00:29:16,720
than average norm of s

770
00:29:16,720 --> 00:29:18,799
this also means that if we want to find

771
00:29:18,799 --> 00:29:20,640
follow-up failures then it will be

772
00:29:20,640 --> 00:29:22,159
easier

773
00:29:22,159 --> 00:29:24,080
so because we're looking in this whole

774
00:29:24,080 --> 00:29:27,760
pool we will find servers with a higher

775
00:29:27,760 --> 00:29:29,760
probability of failure and so the rest

776
00:29:29,760 --> 00:29:32,480
of the attack will be easier so

777
00:29:32,480 --> 00:29:34,960
once we go to the second phase where we

778
00:29:34,960 --> 00:29:36,399
find the follow-up failures find the

779
00:29:36,399 --> 00:29:37,760
second the third phase the fourth

780
00:29:37,760 --> 00:29:40,320
failure this will be easier and this is

781
00:29:40,320 --> 00:29:42,960
the weak key effect

782
00:29:42,960 --> 00:29:45,679
and so we have in our paper

783
00:29:45,679 --> 00:29:47,279
incorporated

784
00:29:47,279 --> 00:29:49,600
described how to incorporate this wiki

785
00:29:49,600 --> 00:29:51,760
effect into the calculations and it's

786
00:29:51,760 --> 00:29:54,240
also taken all the curves that all the

787
00:29:54,240 --> 00:29:56,159
curves and the numbers that we generate

788
00:29:56,159 --> 00:29:59,120
in this paper are also include this weak

789
00:29:59,120 --> 00:30:01,678
key effect

790
00:30:01,840 --> 00:30:04,399
a second effect is a worse than expected

791
00:30:04,399 --> 00:30:06,000
angle

792
00:30:06,000 --> 00:30:07,279
remember that

793
00:30:07,279 --> 00:30:09,360
a fair happens if the norm of s times

794
00:30:09,360 --> 00:30:11,600
the norm of c times the angle between

795
00:30:11,600 --> 00:30:14,000
the secret and the ciphertext if this is

796
00:30:14,000 --> 00:30:16,880
bigger than q divided by four

797
00:30:16,880 --> 00:30:19,120
now due to the nature of these failures

798
00:30:19,120 --> 00:30:21,279
actually what you'll have is

799
00:30:21,279 --> 00:30:24,080
approximately this this this term will

800
00:30:24,080 --> 00:30:26,720
be approximately equal to q divided by

801
00:30:26,720 --> 00:30:28,240
four

802
00:30:28,240 --> 00:30:30,320
and now remember that

803
00:30:30,320 --> 00:30:31,919
from previous slide we have this weak

804
00:30:31,919 --> 00:30:33,200
key effect

805
00:30:33,200 --> 00:30:35,520
we have a higher norm of s

806
00:30:35,520 --> 00:30:37,440
than than you would expect

807
00:30:37,440 --> 00:30:39,120
at random

808
00:30:39,120 --> 00:30:41,200
also we're doing failure boosting so we

809
00:30:41,200 --> 00:30:44,880
have a higher norm of c than average

810
00:30:44,880 --> 00:30:46,880
and so the two combined

811
00:30:46,880 --> 00:30:47,919
will lead

812
00:30:47,919 --> 00:30:50,559
to a lower than average cosine

813
00:30:50,559 --> 00:30:52,320
of the angle between the two

814
00:30:52,320 --> 00:30:53,600
vectors

815
00:30:53,600 --> 00:30:56,159
so this means that if you find a failure

816
00:30:56,159 --> 00:30:57,840
then there's actually less information

817
00:30:57,840 --> 00:31:00,320
in it because your failure will be less

818
00:31:00,320 --> 00:31:03,279
in the direction of the secret

819
00:31:03,279 --> 00:31:05,679
so what did we do we have all these

820
00:31:05,679 --> 00:31:07,200
tricks we do failure boosting we have

821
00:31:07,200 --> 00:31:08,880
this weak effect

822
00:31:08,880 --> 00:31:10,720
and we do all of this

823
00:31:10,720 --> 00:31:13,760
to find the failure more easily

824
00:31:13,760 --> 00:31:15,840
but if we do this if we find the failure

825
00:31:15,840 --> 00:31:18,080
more easily due to this tricks we will

826
00:31:18,080 --> 00:31:20,640
have that the failure gives us less

827
00:31:20,640 --> 00:31:22,000
information

828
00:31:22,000 --> 00:31:23,120
a lower

829
00:31:23,120 --> 00:31:26,320
cosine between these two

830
00:31:26,320 --> 00:31:28,640
and so also this effect

831
00:31:28,640 --> 00:31:30,880
we quantified we described in the paper

832
00:31:30,880 --> 00:31:32,640
how to take this into account in the

833
00:31:32,640 --> 00:31:35,279
calculations and all the numbers also

834
00:31:35,279 --> 00:31:37,919
take this into account

835
00:31:37,919 --> 00:31:40,399
so if we combine the wiki effect and

836
00:31:40,399 --> 00:31:42,480
this worst unexpected angle we get the

837
00:31:42,480 --> 00:31:44,159
following curve

838
00:31:44,159 --> 00:31:46,320
so the blue is the previous estimates

839
00:31:46,320 --> 00:31:48,559
from previous papers and the orange is

840
00:31:48,559 --> 00:31:50,559
our new estimate

841
00:31:50,559 --> 00:31:52,399
on the x-axis you have the weak

842
00:31:52,399 --> 00:31:54,720
ciphertext failure rate so beta

843
00:31:54,720 --> 00:31:57,200
and on the y-axis you have the cost to

844
00:31:57,200 --> 00:31:58,080
find

845
00:31:58,080 --> 00:32:00,880
the next failure and so this is to find

846
00:32:00,880 --> 00:32:03,120
the second failure

847
00:32:03,120 --> 00:32:05,120
so the blue curve

848
00:32:05,120 --> 00:32:07,519
um so you see that the blue curve on the

849
00:32:07,519 --> 00:32:10,880
left side uh completely left is if we do

850
00:32:10,880 --> 00:32:12,559
random guessing so we don't do any

851
00:32:12,559 --> 00:32:15,120
preparation we just do random guessing

852
00:32:15,120 --> 00:32:17,039
and you see that the blue curve is

853
00:32:17,039 --> 00:32:18,640
actually higher than the orange curve so

854
00:32:18,640 --> 00:32:19,519
it's

855
00:32:19,519 --> 00:32:21,200
the previous estimates

856
00:32:21,200 --> 00:32:23,200
were higher and now because of the weak

857
00:32:23,200 --> 00:32:26,159
e effect we actually have a lower cost

858
00:32:26,159 --> 00:32:27,679
to do our attack

859
00:32:27,679 --> 00:32:30,080
so because of the wiki effect you can

860
00:32:30,080 --> 00:32:32,000
clearly see in this paper that the cost

861
00:32:32,000 --> 00:32:34,640
to find the next fear if we just random

862
00:32:34,640 --> 00:32:38,080
guessing completely on the left of this

863
00:32:38,080 --> 00:32:40,840
curve that the cost is actually

864
00:32:40,840 --> 00:32:44,000
lower but you also see that these two

865
00:32:44,000 --> 00:32:47,039
curves overlap that is cross and that if

866
00:32:47,039 --> 00:32:48,559
you go to the right if you do more

867
00:32:48,559 --> 00:32:51,679
failure boosting then we get actually a

868
00:32:51,679 --> 00:32:53,519
higher than expected or a higher than

869
00:32:53,519 --> 00:32:56,320
previously calculated cost and the

870
00:32:56,320 --> 00:32:58,799
reason is exactly this worse than

871
00:32:58,799 --> 00:33:00,480
expected angle

872
00:33:00,480 --> 00:33:02,720
because if our angle is worse than

873
00:33:02,720 --> 00:33:05,360
expected if if what we think is is the

874
00:33:05,360 --> 00:33:06,960
angle between the secret and scientix is

875
00:33:06,960 --> 00:33:09,279
worse than you expect

876
00:33:09,279 --> 00:33:10,880
then we will also have a worse than

877
00:33:10,880 --> 00:33:12,240
expected

878
00:33:12,240 --> 00:33:14,159
failure boosting procedure

879
00:33:14,159 --> 00:33:16,080
and this shows if you go more to the

880
00:33:16,080 --> 00:33:18,720
right if you do more failure boosting

881
00:33:18,720 --> 00:33:20,480
so in this curve you clearly see that

882
00:33:20,480 --> 00:33:22,880
there is a wiki effect and there is a

883
00:33:22,880 --> 00:33:25,279
worse unexpected angle effect and we've

884
00:33:25,279 --> 00:33:29,600
taken them into account in our new model

885
00:33:29,919 --> 00:33:31,760
improving the cost estimation for

886
00:33:31,760 --> 00:33:33,919
existing schemes

887
00:33:33,919 --> 00:33:35,919
what do i mean with this

888
00:33:35,919 --> 00:33:38,000
in the previous paper that looked at

889
00:33:38,000 --> 00:33:40,080
directional failure boosting so finding

890
00:33:40,080 --> 00:33:42,159
follow-up failures

891
00:33:42,159 --> 00:33:43,519
the second paper that we discussed in

892
00:33:43,519 --> 00:33:45,120
the introduction

893
00:33:45,120 --> 00:33:47,919
all the calculations were done on a toy

894
00:33:47,919 --> 00:33:49,519
scheme on a scheme that closely

895
00:33:49,519 --> 00:33:53,200
resembles saber and kyber but it has two

896
00:33:53,200 --> 00:33:56,240
differences two simplifications

897
00:33:56,240 --> 00:33:58,000
and the first simplification is that the

898
00:33:58,000 --> 00:34:01,600
variance of the s term and the secret

899
00:34:01,600 --> 00:34:04,080
term is equal to the variance of the

900
00:34:04,080 --> 00:34:07,039
noise term e and this is not the case

901
00:34:07,039 --> 00:34:10,320
for saber and not the case for kyber

902
00:34:10,320 --> 00:34:12,239
the second simplification is that there

903
00:34:12,239 --> 00:34:14,960
is no rounding of a ciphertext so the

904
00:34:14,960 --> 00:34:18,000
term e prime prime is assumed to be

905
00:34:18,000 --> 00:34:21,440
approximately zero and again this was

906
00:34:21,440 --> 00:34:23,199
the case for the story scheme but it's

907
00:34:23,199 --> 00:34:27,679
clearly not the case for saber nor kyber

908
00:34:27,679 --> 00:34:30,000
so in our paper we described we

909
00:34:30,000 --> 00:34:32,159
developed a new model to take into

910
00:34:32,159 --> 00:34:34,320
account schemes that do not fulfill

911
00:34:34,320 --> 00:34:36,879
these simplifications so schemes where

912
00:34:36,879 --> 00:34:38,639
the variance of s is not equal to the

913
00:34:38,639 --> 00:34:40,399
variance of c and where the rounding of

914
00:34:40,399 --> 00:34:42,879
the cypher text is it cannot be

915
00:34:42,879 --> 00:34:45,359
approximated to zero

916
00:34:45,359 --> 00:34:47,280
so our new model

917
00:34:47,280 --> 00:34:50,399
in this graph is given in orange

918
00:34:50,399 --> 00:34:52,480
and can be compared to the old model

919
00:34:52,480 --> 00:34:54,320
given in blue

920
00:34:54,320 --> 00:34:56,159
and so if you apply this to the toy

921
00:34:56,159 --> 00:34:58,720
scheme katana you see that both models

922
00:34:58,720 --> 00:35:01,200
so the geometric model the old model and

923
00:35:01,200 --> 00:35:04,079
the geometric uneven model they give

924
00:35:04,079 --> 00:35:06,160
approximately the same results

925
00:35:06,160 --> 00:35:08,240
which is what we want because katana

926
00:35:08,240 --> 00:35:10,560
fulfills these simplifications fulfills

927
00:35:10,560 --> 00:35:13,280
the conditions for the old

928
00:35:13,280 --> 00:35:14,640
model

929
00:35:14,640 --> 00:35:18,160
however if we apply it to saber then you

930
00:35:18,160 --> 00:35:20,160
see a clear difference between the old

931
00:35:20,160 --> 00:35:22,880
model the blue model and the new model

932
00:35:22,880 --> 00:35:24,560
the orange model

933
00:35:24,560 --> 00:35:29,359
you see that the blue model gives

934
00:35:29,359 --> 00:35:31,280
a very big

935
00:35:31,280 --> 00:35:34,400
uh underestimation of the attack costs

936
00:35:34,400 --> 00:35:37,040
of about 20 to 40 bits

937
00:35:37,040 --> 00:35:39,920
and so it's very clear that if you want

938
00:35:39,920 --> 00:35:42,320
to calculate the cost for sabre that you

939
00:35:42,320 --> 00:35:44,800
need to use our updated model our new

940
00:35:44,800 --> 00:35:46,960
model and that you cannot just assume

941
00:35:46,960 --> 00:35:50,800
the simplifications assume um the the

942
00:35:50,800 --> 00:35:53,520
simplified model from the

943
00:35:53,520 --> 00:35:56,720
eurogram paper that we discussed before

944
00:35:56,720 --> 00:35:59,359
so we applied our new model

945
00:35:59,359 --> 00:36:01,760
including the wiki effect including

946
00:36:01,760 --> 00:36:03,599
higher than average uh

947
00:36:03,599 --> 00:36:07,200
uh worse than an average angle including

948
00:36:07,200 --> 00:36:10,560
um this this

949
00:36:10,839 --> 00:36:13,440
extended simplification so so removing

950
00:36:13,440 --> 00:36:15,760
the simplifications and we apply this to

951
00:36:15,760 --> 00:36:17,920
saber to kyber and to kyber and the

952
00:36:17,920 --> 00:36:20,560
results are in this table

953
00:36:20,560 --> 00:36:22,640
i will not go into the details i will

954
00:36:22,640 --> 00:36:27,119
just give a conclusion or or the

955
00:36:27,119 --> 00:36:28,640
conclusion that you can draw from this

956
00:36:28,640 --> 00:36:31,280
table and the details are in the paper

957
00:36:31,280 --> 00:36:33,280
so for current schemes and with that i

958
00:36:33,280 --> 00:36:35,760
mean sabre or kyber

959
00:36:35,760 --> 00:36:39,200
single target attacks are really really

960
00:36:39,200 --> 00:36:41,359
impractical i mean the amount of queries

961
00:36:41,359 --> 00:36:43,839
that you need to do is far beyond the

962
00:36:43,839 --> 00:36:47,119
limit that nist said is far beyond any

963
00:36:47,119 --> 00:36:49,040
practical limit

964
00:36:49,040 --> 00:36:51,200
for multi-target attacks is essentially

965
00:36:51,200 --> 00:36:52,480
the same so

966
00:36:52,480 --> 00:36:54,800
if you take a very extreme case where

967
00:36:54,800 --> 00:36:57,520
you have 264 targets

968
00:36:57,520 --> 00:36:59,839
uh two to the 64

969
00:36:59,839 --> 00:37:03,200
queries for each target then

970
00:37:03,200 --> 00:37:05,200
theoretically you get a very small

971
00:37:05,200 --> 00:37:08,720
security reduction a few bits in in

972
00:37:08,720 --> 00:37:11,520
these very extreme cases but in practice

973
00:37:11,520 --> 00:37:13,599
if you want to do this attack the attack

974
00:37:13,599 --> 00:37:15,520
is really not deficient and you'd rather

975
00:37:15,520 --> 00:37:20,079
do a direct attack on the underlying lwe

976
00:37:20,079 --> 00:37:22,000
problem

977
00:37:22,000 --> 00:37:24,000
so if these attacks are are not

978
00:37:24,000 --> 00:37:25,200
practical

979
00:37:25,200 --> 00:37:27,280
why did we do this research

980
00:37:27,280 --> 00:37:29,520
well the first thing is that we want to

981
00:37:29,520 --> 00:37:30,800
have a better understanding of the

982
00:37:30,800 --> 00:37:32,960
attacks i mean there is a possibility

983
00:37:32,960 --> 00:37:35,760
that one of these schemes sabre kyber is

984
00:37:35,760 --> 00:37:38,000
going to be standardized in the future

985
00:37:38,000 --> 00:37:39,760
and having a better understanding of the

986
00:37:39,760 --> 00:37:41,680
attacks is really important so that we

987
00:37:41,680 --> 00:37:43,520
know that our

988
00:37:43,520 --> 00:37:45,440
future standardization

989
00:37:45,440 --> 00:37:48,480
future standard is actually secure

990
00:37:48,480 --> 00:37:51,440
against this type of attacks

991
00:37:51,440 --> 00:37:52,960
a second thing is more looking towards

992
00:37:52,960 --> 00:37:54,880
the future if we have a better

993
00:37:54,880 --> 00:37:56,800
understanding of attacks if we

994
00:37:56,800 --> 00:37:59,520
know what we can do without

995
00:37:59,520 --> 00:38:02,400
having a risk of of

996
00:38:02,400 --> 00:38:04,480
security problems we can lower our

997
00:38:04,480 --> 00:38:06,000
parameters so we can increase the

998
00:38:06,000 --> 00:38:08,240
failure probability which makes lower

999
00:38:08,240 --> 00:38:10,320
parameters lower bandwidth faster

1000
00:38:10,320 --> 00:38:12,079
schemes in general more efficient

1001
00:38:12,079 --> 00:38:13,200
schemes

1002
00:38:13,200 --> 00:38:15,520
so by doing this research we hope that

1003
00:38:15,520 --> 00:38:16,640
future

1004
00:38:16,640 --> 00:38:19,040
schemes can have

1005
00:38:19,040 --> 00:38:21,040
higher decryption failure attacks

1006
00:38:21,040 --> 00:38:24,079
without being subject to

1007
00:38:24,079 --> 00:38:25,599
attacks to

1008
00:38:25,599 --> 00:38:27,440
attacks that break the scheme and thus

1009
00:38:27,440 --> 00:38:30,560
that we can have more efficient schemes

1010
00:38:30,560 --> 00:38:32,240
so future work what can we do in the

1011
00:38:32,240 --> 00:38:33,440
future

1012
00:38:33,440 --> 00:38:35,440
well the first thing is that

1013
00:38:35,440 --> 00:38:37,920
we made this attack framework we made it

1014
00:38:37,920 --> 00:38:40,560
work for saber for kyber but maybe we

1015
00:38:40,560 --> 00:38:43,040
can also apply it to for example frodo

1016
00:38:43,040 --> 00:38:44,880
or other lattice-based encryption

1017
00:38:44,880 --> 00:38:47,520
schemes maybe also

1018
00:38:47,520 --> 00:38:49,119
we can apply them to schemes with error

1019
00:38:49,119 --> 00:38:50,960
correcting codes who have different

1020
00:38:50,960 --> 00:38:53,280
properties and where we really net where

1021
00:38:53,280 --> 00:38:55,280
really more research is needed to

1022
00:38:55,280 --> 00:38:57,280
predict the

1023
00:38:57,280 --> 00:38:58,800
the threat from decryption failure

1024
00:38:58,800 --> 00:39:02,320
attacks for example a scheme like luck

1025
00:39:02,320 --> 00:39:04,640
a third thing is uh code based crypto

1026
00:39:04,640 --> 00:39:06,000
some of the code based cryptographic

1027
00:39:06,000 --> 00:39:08,240
schemes also have a decryption

1028
00:39:08,240 --> 00:39:10,560
probability so can we port somebody of

1029
00:39:10,560 --> 00:39:12,800
the ids from this field from letters

1030
00:39:12,800 --> 00:39:16,400
lattice-based crypto to codebase crypto

1031
00:39:16,400 --> 00:39:19,200
so that is this for the attack framework

1032
00:39:19,200 --> 00:39:22,560
on another side we can look at improving

1033
00:39:22,560 --> 00:39:27,040
the security bound so the proofs there

1034
00:39:27,119 --> 00:39:29,200
the difference between what we can prove

1035
00:39:29,200 --> 00:39:32,000
is secure and actual attacks is at the

1036
00:39:32,000 --> 00:39:36,000
moment really big and so maybe we can

1037
00:39:36,000 --> 00:39:38,400
increase the proofs uh improve the

1038
00:39:38,400 --> 00:39:40,880
proofs and have a better provable

1039
00:39:40,880 --> 00:39:44,800
security of our schemes

