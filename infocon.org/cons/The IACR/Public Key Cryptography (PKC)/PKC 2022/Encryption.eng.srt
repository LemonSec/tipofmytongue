1
00:00:00,000 --> 00:00:02,879
come to the to the session uh so so the

2
00:00:02,879 --> 00:00:05,520
topic for this session is uh encryption

3
00:00:05,520 --> 00:00:06,399
so

4
00:00:06,399 --> 00:00:07,919
we have uh

5
00:00:07,919 --> 00:00:09,360
six talks

6
00:00:09,360 --> 00:00:10,639
so

7
00:00:10,639 --> 00:00:13,120
basically we'll have five minutes for

8
00:00:13,120 --> 00:00:14,880
for each talk and

9
00:00:14,880 --> 00:00:17,359
we have a five minute q a so it's

10
00:00:17,359 --> 00:00:20,160
possible that you can ask the question

11
00:00:20,160 --> 00:00:22,800
uh in the chat room or you can just

12
00:00:22,800 --> 00:00:24,880
speak out the questions

13
00:00:24,880 --> 00:00:25,680
so

14
00:00:25,680 --> 00:00:27,920
the first talk is efficient

15
00:00:27,920 --> 00:00:30,400
lattice-based inner product functional

16
00:00:30,400 --> 00:00:35,760
encryption by tilomas azam solomani

17
00:00:36,719 --> 00:00:38,800
using maria benboto

18
00:00:38,800 --> 00:00:42,160
sorry for my pronunciation

19
00:00:42,640 --> 00:00:43,430
and

20
00:00:43,430 --> 00:00:46,479
[Music]

21
00:00:46,960 --> 00:00:50,480
uh yeah hello everyone

22
00:00:50,480 --> 00:00:52,800
uh

23
00:00:53,440 --> 00:00:56,160
uh i hope you see my screen

24
00:00:56,160 --> 00:00:59,120
yes we do okay thank you uh yeah so my

25
00:00:59,120 --> 00:01:01,600
name is dylan martin i'll talk about uh

26
00:01:01,600 --> 00:01:04,159
our paper on efficient latest based

27
00:01:04,159 --> 00:01:06,080
inner product function encryption to and

28
00:01:06,080 --> 00:01:08,640
work with uh jose maria bermuda

29
00:01:08,640 --> 00:01:10,159
karma current

30
00:01:10,159 --> 00:01:13,479
assam soleimanian

31
00:01:13,760 --> 00:01:15,680
as you might know uh functional

32
00:01:15,680 --> 00:01:18,560
encryption is a generalization of public

33
00:01:18,560 --> 00:01:19,920
encryption

34
00:01:19,920 --> 00:01:22,400
where we have a setup process where we

35
00:01:22,400 --> 00:01:23,840
produce

36
00:01:23,840 --> 00:01:26,320
public parameters public keys that allow

37
00:01:26,320 --> 00:01:29,520
an encrypter say alice in our case

38
00:01:29,520 --> 00:01:31,680
to encrypt a message x

39
00:01:31,680 --> 00:01:34,159
and independent of that we have a key

40
00:01:34,159 --> 00:01:36,000
generation process

41
00:01:36,000 --> 00:01:37,920
that allows to produce so-called

42
00:01:37,920 --> 00:01:40,560
functional keys depending on a function

43
00:01:40,560 --> 00:01:41,680
f

44
00:01:41,680 --> 00:01:44,320
that uh given to a decrypter bob in our

45
00:01:44,320 --> 00:01:47,040
case um

46
00:01:47,040 --> 00:01:49,439
bob is able to to decrypt from the

47
00:01:49,439 --> 00:01:52,479
encrypted message x a function of x so f

48
00:01:52,479 --> 00:01:54,159
of x

49
00:01:54,159 --> 00:01:56,560
but without revealing the message itself

50
00:01:56,560 --> 00:01:58,799
so the only information bob should get

51
00:01:58,799 --> 00:02:02,640
is the result of this function

52
00:02:02,640 --> 00:02:04,320
so this is kind of similar to

53
00:02:04,320 --> 00:02:06,799
homomorphic encryption where

54
00:02:06,799 --> 00:02:09,598
we also have computation on encrypted

55
00:02:09,598 --> 00:02:11,120
encrypted data

56
00:02:11,120 --> 00:02:13,200
uh but here we demand additionally that

57
00:02:13,200 --> 00:02:16,160
uh the decrypter is able to then decrypt

58
00:02:16,160 --> 00:02:19,680
the result of this computation

59
00:02:19,920 --> 00:02:22,080
a lot of research has been done in the

60
00:02:22,080 --> 00:02:23,920
aerial function encryption but let me

61
00:02:23,920 --> 00:02:26,080
just point out a

62
00:02:26,080 --> 00:02:27,840
couple of things

63
00:02:27,840 --> 00:02:30,640
it is well known that

64
00:02:30,640 --> 00:02:32,560
constructing functional encryption

65
00:02:32,560 --> 00:02:35,280
schemes for arbitrary functions is

66
00:02:35,280 --> 00:02:37,239
equivalent to constructing

67
00:02:37,239 --> 00:02:39,840
indistinguishability of locations

68
00:02:39,840 --> 00:02:41,120
so

69
00:02:41,120 --> 00:02:44,239
this is a bit inefficient still

70
00:02:44,239 --> 00:02:46,160
but on the other hand another line of

71
00:02:46,160 --> 00:02:48,480
research was established

72
00:02:48,480 --> 00:02:51,560
say starting with uh abdallah at all in

73
00:02:51,560 --> 00:02:53,200
2015

74
00:02:53,200 --> 00:02:56,239
focusing on on functions uh on on

75
00:02:56,239 --> 00:02:58,959
schemes with limited functionality

76
00:02:58,959 --> 00:03:01,599
concretely for inner products linear

77
00:03:01,599 --> 00:03:04,800
functions quadratic functions

78
00:03:04,800 --> 00:03:05,519
and

79
00:03:05,519 --> 00:03:07,920
also

80
00:03:07,920 --> 00:03:10,720
so with emphasis on efficiency

81
00:03:10,720 --> 00:03:13,200
and being also constructed on

82
00:03:13,200 --> 00:03:16,159
well-established assumptions such as ddh

83
00:03:16,159 --> 00:03:19,280
dcr lwe

84
00:03:19,280 --> 00:03:22,239
our paper our work continues this line

85
00:03:22,239 --> 00:03:25,120
of research and we provide the

86
00:03:25,120 --> 00:03:28,080
ringcalwe based function encryption for

87
00:03:28,080 --> 00:03:30,000
inner product

88
00:03:30,000 --> 00:03:31,920
actually two schemes so one with

89
00:03:31,920 --> 00:03:35,519
selective one with adaptive security

90
00:03:35,519 --> 00:03:38,959
uh and to do so we also provide some new

91
00:03:38,959 --> 00:03:42,080
results on ideal lattices

92
00:03:42,080 --> 00:03:45,120
um the main goal of

93
00:03:45,120 --> 00:03:48,159
uh why trying to prove a scheme for ring

94
00:03:48,159 --> 00:03:51,120
held up based on wrinkle we assumption

95
00:03:51,120 --> 00:03:51,920
is

96
00:03:51,920 --> 00:03:54,640
because we truly are aiming at uh

97
00:03:54,640 --> 00:03:57,680
constructing something uh practical and

98
00:03:57,680 --> 00:04:00,080
to to argue that

99
00:04:00,080 --> 00:04:02,720
we did so we also provided

100
00:04:02,720 --> 00:04:04,879
an optimized implementation

101
00:04:04,879 --> 00:04:07,599
a publicly available one to to test the

102
00:04:07,599 --> 00:04:08,720
scheme

103
00:04:08,720 --> 00:04:11,360
uh in addition also compiler to to

104
00:04:11,360 --> 00:04:13,200
decentralized identity based

105
00:04:13,200 --> 00:04:15,599
multi-client settings so a setting where

106
00:04:15,599 --> 00:04:19,040
we have multiple encrypters

107
00:04:19,040 --> 00:04:21,358
just to give you a bit of taste of our

108
00:04:21,358 --> 00:04:23,600
schemes

109
00:04:23,600 --> 00:04:25,120
so

110
00:04:25,120 --> 00:04:26,560
the main idea

111
00:04:26,560 --> 00:04:28,160
in in inner product functional

112
00:04:28,160 --> 00:04:30,880
encryption schemes how to construct them

113
00:04:30,880 --> 00:04:34,880
is to construct a similarly to

114
00:04:34,880 --> 00:04:37,199
public key encryption schemes

115
00:04:37,199 --> 00:04:38,080
uh

116
00:04:38,080 --> 00:04:40,320
but here we want to encrypt vectors so

117
00:04:40,320 --> 00:04:45,040
we kind of produce multiple public keys

118
00:04:45,040 --> 00:04:47,280
and when we're encrypting we are

119
00:04:47,280 --> 00:04:48,320
encrypting

120
00:04:48,320 --> 00:04:50,320
each coordinate of a vector with a

121
00:04:50,320 --> 00:04:52,320
different public key

122
00:04:52,320 --> 00:04:54,840
but with a shared randomness across the

123
00:04:54,840 --> 00:04:57,280
encryption and and this allows us then

124
00:04:57,280 --> 00:04:59,199
to to generate uh

125
00:04:59,199 --> 00:05:00,800
keys uh

126
00:05:00,800 --> 00:05:02,960
as linear combinations of secrets so

127
00:05:02,960 --> 00:05:04,800
functional keys that allow you to to

128
00:05:04,800 --> 00:05:06,240
decrypt then

129
00:05:06,240 --> 00:05:09,120
an inner product uh in the end

130
00:05:09,120 --> 00:05:11,039
of this message without revealing the

131
00:05:11,039 --> 00:05:14,240
the message itself

132
00:05:14,479 --> 00:05:19,039
um maybe just uh to get a bit more uh

133
00:05:19,039 --> 00:05:21,360
feeling what's happening here

134
00:05:21,360 --> 00:05:22,560
um

135
00:05:22,560 --> 00:05:24,800
the main difficulty improving

136
00:05:24,800 --> 00:05:27,680
uh security of of function encryption

137
00:05:27,680 --> 00:05:30,880
schemes is to argue that cipher text

138
00:05:30,880 --> 00:05:31,600
are

139
00:05:31,600 --> 00:05:33,120
indistinguishable

140
00:05:33,120 --> 00:05:36,479
uh even after uh an adversary observed

141
00:05:36,479 --> 00:05:37,680
certain

142
00:05:37,680 --> 00:05:39,520
functional keys

143
00:05:39,520 --> 00:05:41,440
and what happens in many cases is that

144
00:05:41,440 --> 00:05:43,360
these functional keys might reveal a bit

145
00:05:43,360 --> 00:05:45,759
more information about

146
00:05:45,759 --> 00:05:46,800
about

147
00:05:46,800 --> 00:05:50,560
secrets than one would maybe want to

148
00:05:50,560 --> 00:05:53,199
naively assume so what happens in our

149
00:05:53,199 --> 00:05:56,000
case is that this uh functional case

150
00:05:56,000 --> 00:05:59,120
when an adversary has functional keys uh

151
00:05:59,120 --> 00:06:01,280
he or she obtains obtains some

152
00:06:01,280 --> 00:06:02,560
additional information about the

153
00:06:02,560 --> 00:06:05,199
randomness used in the encryption and

154
00:06:05,199 --> 00:06:07,759
also in the setup process

155
00:06:07,759 --> 00:06:10,319
uh so to to argue security

156
00:06:10,319 --> 00:06:11,840
distinguishability

157
00:06:11,840 --> 00:06:14,720
uh we we needed to have a version of

158
00:06:14,720 --> 00:06:17,600
wrinkle we a generalization of

159
00:06:17,600 --> 00:06:21,039
a ring lwe problem in which

160
00:06:21,039 --> 00:06:21,919
uh

161
00:06:21,919 --> 00:06:24,080
we well in this problem we still need to

162
00:06:24,080 --> 00:06:27,840
distinguish samples uh wrinkle w samples

163
00:06:27,840 --> 00:06:30,479
from in this from uniformity at random

164
00:06:30,479 --> 00:06:32,000
sampled values

165
00:06:32,000 --> 00:06:34,560
but with additional hints on the secrets

166
00:06:34,560 --> 00:06:37,360
and and in our paper we argued that

167
00:06:37,360 --> 00:06:40,880
for properly selected parameters um

168
00:06:40,880 --> 00:06:42,720
this problem is as hard as the

169
00:06:42,720 --> 00:06:45,759
underlying ring lwe problem

170
00:06:45,759 --> 00:06:47,199
so this trick

171
00:06:47,199 --> 00:06:49,280
we we used to district to prove

172
00:06:49,280 --> 00:06:51,759
selective security for adaptive security

173
00:06:51,759 --> 00:06:55,440
we also needed a version of laptops

174
00:06:55,440 --> 00:06:57,280
that we also proved

175
00:06:57,280 --> 00:07:00,080
uh but maybe for more details please uh

176
00:07:00,080 --> 00:07:03,280
check check our paper

177
00:07:03,280 --> 00:07:04,240
so

178
00:07:04,240 --> 00:07:06,240
the result we were quite happy with the

179
00:07:06,240 --> 00:07:08,720
result since the ring setting

180
00:07:08,720 --> 00:07:10,479
allowed us to

181
00:07:10,479 --> 00:07:12,560
to simplify the proofs leading to better

182
00:07:12,560 --> 00:07:14,319
parameters than

183
00:07:14,319 --> 00:07:18,479
when existing schemes based on lwe

184
00:07:18,479 --> 00:07:21,680
uh but drinks ring setting also produces

185
00:07:21,680 --> 00:07:25,680
smaller keys faster faster operations

186
00:07:25,680 --> 00:07:28,000
and additionally also allows to encrypt

187
00:07:28,000 --> 00:07:30,160
multiple vectors in parallel in one

188
00:07:30,160 --> 00:07:31,520
ciphertext

189
00:07:31,520 --> 00:07:35,840
so uh we our scheme supports uh

190
00:07:35,840 --> 00:07:39,199
let's say simd type of computation uh

191
00:07:39,199 --> 00:07:41,199
when you're able when you're decrypting

192
00:07:41,199 --> 00:07:43,360
you're decrypting say thousands of

193
00:07:43,360 --> 00:07:45,599
vectors in parallel with just one

194
00:07:45,599 --> 00:07:47,280
evaluation

195
00:07:47,280 --> 00:07:50,240
uh like i said there is an optimized

196
00:07:50,240 --> 00:07:53,759
implementation available online and

197
00:07:53,759 --> 00:07:57,199
you can check our paper for for

198
00:07:57,199 --> 00:08:00,319
evaluation of performance

199
00:08:00,319 --> 00:08:01,840
i will stop here

200
00:08:01,840 --> 00:08:05,360
thank you for for your attention

201
00:08:05,360 --> 00:08:06,879
okay thanks

202
00:08:06,879 --> 00:08:10,840
so any questions

203
00:08:16,800 --> 00:08:20,160
uh so i i have a question that uh um i

204
00:08:20,160 --> 00:08:21,680
think your paper achieve a

205
00:08:21,680 --> 00:08:23,199
indistinguishability

206
00:08:23,199 --> 00:08:25,199
that is the security right

207
00:08:25,199 --> 00:08:27,199
yeah true sure yes that's true

208
00:08:27,199 --> 00:08:29,919
so i was thinking that uh under like ddh

209
00:08:29,919 --> 00:08:32,799
assumption so we can achieve adaptive uh

210
00:08:32,799 --> 00:08:36,479
simulation-based security so i want to

211
00:08:36,479 --> 00:08:38,559
uh know whether it's possible to do this

212
00:08:38,559 --> 00:08:41,279
with rin

213
00:08:41,360 --> 00:08:43,599
so for for the adaptive we we also

214
00:08:43,599 --> 00:08:44,959
proved uh

215
00:08:44,959 --> 00:08:47,920
adaptive security in our scheme uh

216
00:08:47,920 --> 00:08:51,360
for for uh yeah for going even

217
00:08:51,360 --> 00:08:55,600
better security um well

218
00:08:55,600 --> 00:08:58,080
it's hard to say if it is possible

219
00:08:58,080 --> 00:08:59,839
probably it is

220
00:08:59,839 --> 00:09:02,720
but well if i had an answer then

221
00:09:02,720 --> 00:09:06,000
probably we would include it also

222
00:09:06,000 --> 00:09:09,600
okay so uh and uh i have a

223
00:09:09,600 --> 00:09:11,839
small question about uh uh multi-in the

224
00:09:11,839 --> 00:09:14,720
extended ring lw assumption so this

225
00:09:14,720 --> 00:09:17,360
assumption is interactive i mean uh for

226
00:09:17,360 --> 00:09:18,080
the

227
00:09:18,080 --> 00:09:20,959
for the hint you have many terms so this

228
00:09:20,959 --> 00:09:23,760
is yes functional just uh

229
00:09:23,760 --> 00:09:25,760
just to keep all the terms

230
00:09:25,760 --> 00:09:27,839
at the beginning

231
00:09:27,839 --> 00:09:30,320
um yeah so uh

232
00:09:30,320 --> 00:09:32,880
the idea here is that uh

233
00:09:32,880 --> 00:09:34,320
the only point is here that you get

234
00:09:34,320 --> 00:09:37,120
multiple hints on on the secret and uh

235
00:09:37,120 --> 00:09:38,880
and noise uh

236
00:09:38,880 --> 00:09:41,760
terms uh here in the in the

237
00:09:41,760 --> 00:09:43,600
ring lwe

238
00:09:43,600 --> 00:09:45,760
samples so so

239
00:09:45,760 --> 00:09:49,600
we we allow multiple hints

240
00:09:49,680 --> 00:09:51,440
on these values so

241
00:09:51,440 --> 00:09:53,519
these hints are especially structured

242
00:09:53,519 --> 00:09:55,519
they need to be

243
00:09:55,519 --> 00:09:57,200
obviously i mean it cannot be anything

244
00:09:57,200 --> 00:09:58,320
but uh

245
00:09:58,320 --> 00:09:59,360
um

246
00:09:59,360 --> 00:10:02,480
because in our case uh uh

247
00:10:02,480 --> 00:10:04,560
an adversary can ask for for many

248
00:10:04,560 --> 00:10:06,800
functional keys and gets

249
00:10:06,800 --> 00:10:10,640
quite a lot of information about uh

250
00:10:11,040 --> 00:10:13,440
the random values used so so

251
00:10:13,440 --> 00:10:16,480
we needed to to have a version where a

252
00:10:16,480 --> 00:10:19,839
lot of hints can be can be produced

253
00:10:19,839 --> 00:10:22,800
so so so this um

254
00:10:22,800 --> 00:10:26,480
so here the rf and ghs depend by the by

255
00:10:26,480 --> 00:10:28,240
the secret key

256
00:10:28,240 --> 00:10:29,040
um

257
00:10:29,040 --> 00:10:30,800
this air

258
00:10:30,800 --> 00:10:34,079
this r g and f and h uh

259
00:10:34,079 --> 00:10:38,720
uh are are some uh also random values um

260
00:10:38,720 --> 00:10:41,680
actually uh f and r can be selected

261
00:10:41,680 --> 00:10:44,079
arbitrary but not too big polynomials

262
00:10:44,079 --> 00:10:46,399
and but they need to be a bit

263
00:10:46,399 --> 00:10:47,680
uh

264
00:10:47,680 --> 00:10:50,560
noisy with this additional terms if they

265
00:10:50,560 --> 00:10:52,880
weren't noisy they were uh

266
00:10:52,880 --> 00:10:55,760
they you could directly extract s and e

267
00:10:55,760 --> 00:10:58,000
but uh um

268
00:10:58,000 --> 00:11:01,839
in our case they need to be not noisy

269
00:11:01,839 --> 00:11:03,680
okay okay

270
00:11:03,680 --> 00:11:04,800
thanks

271
00:11:04,800 --> 00:11:07,120
uh thank you thank you for the questions

272
00:11:07,120 --> 00:11:10,000
um so let's move to the

273
00:11:10,000 --> 00:11:12,880
second talk so the talk is a new

274
00:11:12,880 --> 00:11:15,760
security notion opac

275
00:11:15,760 --> 00:11:17,519
in the standard model

276
00:11:17,519 --> 00:11:20,800
weaker simpler and still realizing

277
00:11:20,800 --> 00:11:22,399
secure channel

278
00:11:22,399 --> 00:11:25,839
by vasili

279
00:11:26,320 --> 00:11:28,480
no

280
00:11:38,240 --> 00:11:41,880
will give the talk

281
00:11:42,160 --> 00:11:43,200
yeah

282
00:11:43,200 --> 00:11:46,000
hello everyone

283
00:11:47,600 --> 00:11:50,000
and i hope you can see my slides and

284
00:11:50,000 --> 00:11:53,680
hear me and see me well

285
00:11:54,000 --> 00:11:55,120
perfect

286
00:11:55,120 --> 00:11:56,560
so thank you very much for the

287
00:11:56,560 --> 00:11:58,720
introduction and

288
00:11:58,720 --> 00:12:01,519
as i said my name is astrid news and i

289
00:12:01,519 --> 00:12:03,920
will give you some first ideas of our

290
00:12:03,920 --> 00:12:06,320
results to motivate you having a closer

291
00:12:06,320 --> 00:12:08,240
look into our paper a new security

292
00:12:08,240 --> 00:12:10,240
notion for public key cryptography and

293
00:12:10,240 --> 00:12:12,480
the standard model weaker simpler and

294
00:12:12,480 --> 00:12:14,880
still realizing secure channels

295
00:12:14,880 --> 00:12:16,880
the paypal is joint work with vasily

296
00:12:16,880 --> 00:12:19,360
best governor of olankro yamila cuader

297
00:12:19,360 --> 00:12:20,560
and rebecca

298
00:12:20,560 --> 00:12:22,720
and most of my co-authors also joining

299
00:12:22,720 --> 00:12:24,240
right now to answer your questions

300
00:12:24,240 --> 00:12:25,760
afterwards

301
00:12:25,760 --> 00:12:28,560
so firstly i will try to motivate

302
00:12:28,560 --> 00:12:31,839
our research results by explaining the

303
00:12:31,839 --> 00:12:33,519
choice of our title

304
00:12:33,519 --> 00:12:36,240
so an important goal of cryptographic

305
00:12:36,240 --> 00:12:39,040
tools is to facilitate secure channels

306
00:12:39,040 --> 00:12:41,440
between communicating parties as seen

307
00:12:41,440 --> 00:12:43,760
here as with alice and bob

308
00:12:43,760 --> 00:12:45,600
in our particular setting we want to

309
00:12:45,600 --> 00:12:47,680
build them from authenticated channels

310
00:12:47,680 --> 00:12:49,920
in some form of encryption

311
00:12:49,920 --> 00:12:51,680
this was previously achieved in

312
00:12:51,680 --> 00:12:54,000
different works by use of classic public

313
00:12:54,000 --> 00:12:56,079
key or tech based encryption

314
00:12:56,079 --> 00:12:57,920
all the security notions employed for

315
00:12:57,920 --> 00:12:59,440
this however are known to be

316
00:12:59,440 --> 00:13:01,279
unnecessarily strong for the specific

317
00:13:01,279 --> 00:13:02,800
purpose

318
00:13:02,800 --> 00:13:04,160
in our work

319
00:13:04,160 --> 00:13:07,360
we develop a new game by security notion

320
00:13:07,360 --> 00:13:09,200
which is weaker than the previous ones

321
00:13:09,200 --> 00:13:11,920
and built for a simpler construction but

322
00:13:11,920 --> 00:13:14,079
at the same time still strong enough to

323
00:13:14,079 --> 00:13:16,320
realize secure message transfer from

324
00:13:16,320 --> 00:13:18,720
authenticated channels

325
00:13:18,720 --> 00:13:21,279
to show that this is not merely of

326
00:13:21,279 --> 00:13:23,360
theoretic interest we provide a concrete

327
00:13:23,360 --> 00:13:25,279
construction which we prove in the

328
00:13:25,279 --> 00:13:26,959
standard model to fulfill our new

329
00:13:26,959 --> 00:13:28,959
security notion

330
00:13:28,959 --> 00:13:30,800
this construction is more efficient than

331
00:13:30,800 --> 00:13:33,040
the previous one once which had to

332
00:13:33,040 --> 00:13:34,639
fulfill stronger security notion to

333
00:13:34,639 --> 00:13:37,519
realize secure channels

334
00:13:37,519 --> 00:13:39,279
i will now give you an overview of our

335
00:13:39,279 --> 00:13:42,320
contributions so firstly we developed a

336
00:13:42,320 --> 00:13:45,040
new type of an encryption scheme namely

337
00:13:45,040 --> 00:13:47,680
sender binding encryption which unifies

338
00:13:47,680 --> 00:13:49,600
prior approaches to construct secure

339
00:13:49,600 --> 00:13:51,360
message transfer from authenticated

340
00:13:51,360 --> 00:13:52,480
channels

341
00:13:52,480 --> 00:13:55,040
sender binding encryption

342
00:13:55,040 --> 00:13:56,959
ties the cipher text not only to the

343
00:13:56,959 --> 00:13:59,279
receiver as with classical publicly

344
00:13:59,279 --> 00:14:02,000
encryption but as well to the sending

345
00:14:02,000 --> 00:14:04,480
respectively encrypting party

346
00:14:04,480 --> 00:14:07,519
for this type of encryption we develop

347
00:14:07,519 --> 00:14:09,360
the corresponding game-based security

348
00:14:09,360 --> 00:14:10,399
notion

349
00:14:10,399 --> 00:14:11,199
our

350
00:14:11,199 --> 00:14:14,560
new security notion is called int sbcpa

351
00:14:14,560 --> 00:14:15,880
meaning the property of

352
00:14:15,880 --> 00:14:17,760
indistinguishability under sender

353
00:14:17,760 --> 00:14:21,920
binding choosing plain text attack

354
00:14:21,920 --> 00:14:22,800
as

355
00:14:22,800 --> 00:14:25,920
sbcpa secure standard binding encryption

356
00:14:25,920 --> 00:14:27,920
can be generically obtained by various

357
00:14:27,920 --> 00:14:30,320
transformations seen here on the side

358
00:14:30,320 --> 00:14:32,959
from other types of encryption scheme

359
00:14:32,959 --> 00:14:34,399
to construct

360
00:14:34,399 --> 00:14:35,680
a center binding encryption from a

361
00:14:35,680 --> 00:14:38,079
classical public key scheme we simply

362
00:14:38,079 --> 00:14:40,959
concatenate the sender id to the message

363
00:14:40,959 --> 00:14:43,839
this gives an nsb cpa

364
00:14:43,839 --> 00:14:45,920
sender binding encryption scheme as long

365
00:14:45,920 --> 00:14:48,000
as the underlying public key

366
00:14:48,000 --> 00:14:50,560
encryption key scheme fulfills the

367
00:14:50,560 --> 00:14:53,920
security notion of int rcca which lies

368
00:14:53,920 --> 00:14:58,000
quickly between cci1 and cca2 security

369
00:14:58,000 --> 00:15:00,560
in our paper we provide further details

370
00:15:00,560 --> 00:15:02,480
on this and the other transformations

371
00:15:02,480 --> 00:15:04,240
seen on the slides

372
00:15:04,240 --> 00:15:05,120
in

373
00:15:05,120 --> 00:15:06,639
a specially check it out for the

374
00:15:06,639 --> 00:15:08,399
transformation from dual receiver

375
00:15:08,399 --> 00:15:10,560
encryption as we provide concrete

376
00:15:10,560 --> 00:15:12,320
construction which are more efficient

377
00:15:12,320 --> 00:15:14,720
than previously one knowns

378
00:15:14,720 --> 00:15:16,959
we build one of the construction on the

379
00:15:16,959 --> 00:15:20,639
megalis as well as the lpn assumption

380
00:15:20,639 --> 00:15:22,320
which will be explained in detail in our

381
00:15:22,320 --> 00:15:23,440
video

382
00:15:23,440 --> 00:15:25,360
in addition in our paper you can find

383
00:15:25,360 --> 00:15:27,360
the construction based on the lwe

384
00:15:27,360 --> 00:15:28,720
assumption

385
00:15:28,720 --> 00:15:30,959
with these results on total on the right

386
00:15:30,959 --> 00:15:33,680
we can affirm the research question if

387
00:15:33,680 --> 00:15:36,480
weaker security notions lead to simpler

388
00:15:36,480 --> 00:15:38,079
and more efficient construction of

389
00:15:38,079 --> 00:15:41,120
secured channel in the standard model

390
00:15:41,120 --> 00:15:43,360
coming now to a more theoretical part of

391
00:15:43,360 --> 00:15:45,279
our contribution

392
00:15:45,279 --> 00:15:48,320
any encryption protocol satisfying our

393
00:15:48,320 --> 00:15:51,440
new security notion of indsb cpa can be

394
00:15:51,440 --> 00:15:53,279
used directly to realize the queue

395
00:15:53,279 --> 00:15:55,199
message transfer and the model

396
00:15:55,199 --> 00:15:57,680
of universal composability assuming the

397
00:15:57,680 --> 00:16:00,160
existence of accenty authenticated

398
00:16:00,160 --> 00:16:01,600
channels

399
00:16:01,600 --> 00:16:03,360
in the video and the paper we provide

400
00:16:03,360 --> 00:16:04,800
details on the protocol the

401
00:16:04,800 --> 00:16:07,440
functionalities we use and respectively

402
00:16:07,440 --> 00:16:10,079
adapt and the proof itself

403
00:16:10,079 --> 00:16:13,120
as last open question we show how the

404
00:16:13,120 --> 00:16:16,079
new sender binding cpa security notion

405
00:16:16,079 --> 00:16:18,320
fits into the current landscape of other

406
00:16:18,320 --> 00:16:20,639
game based security notions

407
00:16:20,639 --> 00:16:22,880
we compared ourselves to classic public

408
00:16:22,880 --> 00:16:25,279
key encryption notions as well as to the

409
00:16:25,279 --> 00:16:27,680
ones of tech based encryption

410
00:16:27,680 --> 00:16:30,720
note that in both cases there is some

411
00:16:30,720 --> 00:16:32,639
interpretation necessary

412
00:16:32,639 --> 00:16:35,759
to make the settings comparable

413
00:16:35,759 --> 00:16:37,839
regarding the public key

414
00:16:37,839 --> 00:16:40,079
notions the only relationship is that

415
00:16:40,079 --> 00:16:43,519
sender binding cpa implies classic cpa

416
00:16:43,519 --> 00:16:46,320
where there are no other implications

417
00:16:46,320 --> 00:16:48,160
the connection to tech based encryption

418
00:16:48,160 --> 00:16:50,320
notions is a bit stronger as the only

419
00:16:50,320 --> 00:16:52,480
assumption

420
00:16:52,480 --> 00:16:54,560
there is that the respective tag space

421
00:16:54,560 --> 00:16:56,320
is at least as large as the number of

422
00:16:56,320 --> 00:16:57,839
parties

423
00:16:57,839 --> 00:16:58,639
so

424
00:16:58,639 --> 00:17:00,959
if you are familiar with tbe the weakest

425
00:17:00,959 --> 00:17:02,800
prior tbe notions

426
00:17:02,800 --> 00:17:04,880
where adaptive tech and selective tag

427
00:17:04,880 --> 00:17:06,640
weak cca

428
00:17:06,640 --> 00:17:09,039
and in our paper we weaken those notions

429
00:17:09,039 --> 00:17:12,640
further to arrive at given tech weak cca

430
00:17:12,640 --> 00:17:15,439
to the gtech seen on the top

431
00:17:15,439 --> 00:17:18,720
which we then derive standard binding sb

432
00:17:18,720 --> 00:17:21,679
cpa from one benefit of these quite

433
00:17:21,679 --> 00:17:23,760
straightforward implications

434
00:17:23,760 --> 00:17:27,280
is that with our with our work

435
00:17:27,280 --> 00:17:29,919
selective tech weak cca itself is

436
00:17:29,919 --> 00:17:31,600
already enough to get secure message

437
00:17:31,600 --> 00:17:34,480
transfer with via authenticated channels

438
00:17:34,480 --> 00:17:36,160
without the need for further encryption

439
00:17:36,160 --> 00:17:37,679
constructions

440
00:17:37,679 --> 00:17:39,120
so thank you very much for your

441
00:17:39,120 --> 00:17:41,039
attention and i hope i could motivate

442
00:17:41,039 --> 00:17:42,960
you to have a look into our video or the

443
00:17:42,960 --> 00:17:45,280
paper itself and now as my colleagues

444
00:17:45,280 --> 00:17:47,280
are joining in we are happy to answer

445
00:17:47,280 --> 00:17:49,679
your questions

446
00:17:49,679 --> 00:17:52,080
hey thanks for the talk so any questions

447
00:17:52,080 --> 00:17:53,520
so you can also leave the question in

448
00:17:53,520 --> 00:17:56,679
the chat

449
00:18:01,760 --> 00:18:04,080
uh what what is the technical difficulty

450
00:18:04,080 --> 00:18:08,080
to achieve in the cpa dre from uh

451
00:18:08,080 --> 00:18:12,199
for example ddh assumption

452
00:18:14,559 --> 00:18:16,320
can you please just repeat the question

453
00:18:16,320 --> 00:18:18,160
once uh so

454
00:18:18,160 --> 00:18:21,679
yeah you constructed in the cpa dre uh

455
00:18:21,679 --> 00:18:25,360
from macris assumption or lw assumption

456
00:18:25,360 --> 00:18:26,320
right

457
00:18:26,320 --> 00:18:28,480
yes

458
00:18:28,480 --> 00:18:30,720
what is the technical hardware to

459
00:18:30,720 --> 00:18:32,720
achieve this from

460
00:18:32,720 --> 00:18:36,000
for example ddh

461
00:18:36,080 --> 00:18:38,080
is it any

462
00:18:38,080 --> 00:18:42,799
well why uh only from macris or lwe

463
00:18:42,799 --> 00:18:44,799
why cannot use

464
00:18:44,799 --> 00:18:46,880
ddh or pairings

465
00:18:46,880 --> 00:18:48,559
something like that

466
00:18:48,559 --> 00:18:51,360
best assumption

467
00:18:52,160 --> 00:18:53,360
so

468
00:18:53,360 --> 00:18:55,760
for the transformation maybe vaseline

469
00:18:55,760 --> 00:18:59,440
can join in but as we wanted to have the

470
00:18:59,440 --> 00:19:01,520
look more for the post quantum security

471
00:19:01,520 --> 00:19:04,640
we at least wanted to base our security

472
00:19:04,640 --> 00:19:07,520
notion on mcaleese or lwe and didn't

473
00:19:07,520 --> 00:19:10,640
look at the ddh barriers

474
00:19:10,640 --> 00:19:11,520
okay

475
00:19:11,520 --> 00:19:13,280
yeah but maybe for the

476
00:19:13,280 --> 00:19:14,480
practical

477
00:19:14,480 --> 00:19:16,960
for the practicability insights it might

478
00:19:16,960 --> 00:19:20,000
be a good idea to try to construct a ddh

479
00:19:20,000 --> 00:19:21,679
maybe there will be

480
00:19:21,679 --> 00:19:24,080
even more practical constructions

481
00:19:24,080 --> 00:19:26,480
possible

482
00:19:30,880 --> 00:19:34,360
is there any questions

483
00:19:38,559 --> 00:19:40,240
okay thanks for the talk and the thanks

484
00:19:40,240 --> 00:19:41,919
for the questions

485
00:19:41,919 --> 00:19:43,200
um

486
00:19:43,200 --> 00:19:46,960
so we move to the our third call which

487
00:19:46,960 --> 00:19:50,160
is uh encapsulated uh on a leaky

488
00:19:50,160 --> 00:19:54,480
resilient ibe with optimal repeat rate

489
00:19:54,480 --> 00:19:57,600
from lattice by cg life

490
00:19:57,600 --> 00:20:03,360
holyoke uh jordan 1 and the dji world

491
00:20:03,360 --> 00:20:05,520
hello everyone i hope you can see my

492
00:20:05,520 --> 00:20:08,000
slides

493
00:20:08,000 --> 00:20:09,679
yes we can

494
00:20:09,679 --> 00:20:12,480
yes uh hello everyone i'm chi chili my

495
00:20:12,480 --> 00:20:15,200
paper is a leakage resilient ib ab with

496
00:20:15,200 --> 00:20:17,760
optimally curated frown lattice this is

497
00:20:17,760 --> 00:20:19,440
a joint work with and hong

498
00:20:19,440 --> 00:20:20,320
on

499
00:20:20,320 --> 00:20:22,640
one concentrated resilience it always

500
00:20:22,640 --> 00:20:23,679
means that

501
00:20:23,679 --> 00:20:25,840
critical systems that are circular even

502
00:20:25,840 --> 00:20:26,640
when

503
00:20:26,640 --> 00:20:27,520
um

504
00:20:27,520 --> 00:20:29,600
a partial shield key is leaked in

505
00:20:29,600 --> 00:20:32,159
practice a cyclocryptal system

506
00:20:32,159 --> 00:20:36,400
may be broken if partial cp is leaked

507
00:20:36,400 --> 00:20:38,960
moreover liquid resilience can be used

508
00:20:38,960 --> 00:20:41,280
to achieve

509
00:20:41,280 --> 00:20:43,760
security for more complicated

510
00:20:43,760 --> 00:20:46,559
cryptosystems such as non-marble code

511
00:20:46,559 --> 00:20:48,559
and ktm security

512
00:20:48,559 --> 00:20:51,120
therefore leakage resilience has

513
00:20:51,120 --> 00:20:52,960
have been

514
00:20:52,960 --> 00:20:53,760
an

515
00:20:53,760 --> 00:20:56,559
active research subject

516
00:20:56,559 --> 00:20:58,640
more formally literature resilience can

517
00:20:58,640 --> 00:21:01,120
be described by the following security

518
00:21:01,120 --> 00:21:03,360
experiment between the challenger and

519
00:21:03,360 --> 00:21:05,200
the adversary

520
00:21:05,200 --> 00:21:07,520
at the beginning the challenges must

521
00:21:07,520 --> 00:21:09,840
publicly to the adversary then the

522
00:21:09,840 --> 00:21:11,600
adversary can conduct a key extra

523
00:21:11,600 --> 00:21:15,280
inquiry and kill it query adaptive v

524
00:21:15,280 --> 00:21:17,039
finally the diverse you can conduct

525
00:21:17,039 --> 00:21:19,440
challenge query and

526
00:21:19,440 --> 00:21:22,640
the challenger uh response with a random

527
00:21:22,640 --> 00:21:24,320
children

528
00:21:24,320 --> 00:21:25,360
bit b

529
00:21:25,360 --> 00:21:28,000
and we see that the verse reveals the

530
00:21:28,000 --> 00:21:31,760
experiment if uh it outputs a b2b prime

531
00:21:31,760 --> 00:21:34,720
such that b prime equals b

532
00:21:34,720 --> 00:21:38,240
in this paper we consider a model called

533
00:21:38,240 --> 00:21:39,280
um

534
00:21:39,280 --> 00:21:42,159
bonded leakage model in this model the

535
00:21:42,159 --> 00:21:43,919
adversary can obtain arbitrary

536
00:21:43,919 --> 00:21:46,640
information on script key as long as the

537
00:21:46,640 --> 00:21:49,360
number of linked bit is smaller than a

538
00:21:49,360 --> 00:21:51,600
parameter parameter l which is smaller

539
00:21:51,600 --> 00:21:53,520
than the size of 60.

540
00:21:53,520 --> 00:21:55,440
in order to characterize this

541
00:21:55,440 --> 00:21:57,679
requirement more clearly there are two

542
00:21:57,679 --> 00:21:58,720
important

543
00:21:58,720 --> 00:22:01,919
models studied in literature

544
00:22:01,919 --> 00:22:03,760
relatively to model and bounded

545
00:22:03,760 --> 00:22:06,480
retrieval model

546
00:22:06,480 --> 00:22:08,799
in a relative leakage model all

547
00:22:08,799 --> 00:22:11,200
efficiency parameters depend on the

548
00:22:11,200 --> 00:22:13,360
leakage value l

549
00:22:13,360 --> 00:22:15,760
in bonded retrieval model air is an

550
00:22:15,760 --> 00:22:18,320
important parameter which grows only

551
00:22:18,320 --> 00:22:20,640
with the size of a secret key

552
00:22:20,640 --> 00:22:23,440
therefore we think that

553
00:22:23,440 --> 00:22:25,840
bonded to model should be a much more

554
00:22:25,840 --> 00:22:27,919
preferable model

555
00:22:27,919 --> 00:22:29,600
however

556
00:22:29,600 --> 00:22:32,480
for concrete installations we always

557
00:22:32,480 --> 00:22:35,039
first construct a construction

558
00:22:35,039 --> 00:22:40,799
in the rlm and then enhance it into brm

559
00:22:40,799 --> 00:22:44,400
below for concurrent state of art uh for

560
00:22:44,400 --> 00:22:46,080
pre-quantum setting

561
00:22:46,080 --> 00:22:48,080
there is a beautiful and general

562
00:22:48,080 --> 00:22:50,880
framework called due system encryption

563
00:22:50,880 --> 00:22:53,600
we can't derive optimal liquid rate for

564
00:22:53,600 --> 00:22:57,760
ib and abe however for post-quantum 13

565
00:22:57,760 --> 00:22:59,520
it is still an interesting and

566
00:22:59,520 --> 00:23:00,720
challenging

567
00:23:00,720 --> 00:23:04,080
open problem for instantiating

568
00:23:04,080 --> 00:23:05,760
deus terminal inclusion from

569
00:23:05,760 --> 00:23:08,080
post-quantum assumptions

570
00:23:08,080 --> 00:23:10,799
on the other hand

571
00:23:10,799 --> 00:23:13,440
in prayer work there have been a pke

572
00:23:13,440 --> 00:23:15,760
construction that um

573
00:23:15,760 --> 00:23:17,200
um

574
00:23:17,200 --> 00:23:20,640
that are optimally rate however their

575
00:23:20,640 --> 00:23:24,080
turning cannot be generalized to

576
00:23:24,080 --> 00:23:28,639
more advanced settings such as ib ab

577
00:23:29,120 --> 00:23:31,679
so the mind question in this paper is

578
00:23:31,679 --> 00:23:34,400
how to achieve optimal liquid rate for

579
00:23:34,400 --> 00:23:37,600
ib abe in both relative and body

580
00:23:37,600 --> 00:23:39,760
retrieval model with the security

581
00:23:39,760 --> 00:23:41,440
matching existing

582
00:23:41,440 --> 00:23:45,360
non-liquid resilient ib abe under lwe

583
00:23:45,360 --> 00:23:48,320
and the my result of this paper consists

584
00:23:48,320 --> 00:23:49,200
of

585
00:23:49,200 --> 00:23:51,760
liquid resilient abe with optimal liquid

586
00:23:51,760 --> 00:23:53,600
rate in the

587
00:23:53,600 --> 00:23:57,039
rlm and the brm and with optimal blood

588
00:23:57,039 --> 00:24:00,720
leakage rate on multiple 6 keys

589
00:24:00,720 --> 00:24:02,960
for contacting

590
00:24:02,960 --> 00:24:04,960
according to the general framework for

591
00:24:04,960 --> 00:24:07,760
liquid reliance from weak heist proof

592
00:24:07,760 --> 00:24:10,960
system uh here we need to use

593
00:24:10,960 --> 00:24:13,440
a b double hps with the following

594
00:24:13,440 --> 00:24:15,760
properties standard key and adaptive

595
00:24:15,760 --> 00:24:17,760
security however

596
00:24:17,760 --> 00:24:20,799
all previous related constructions just

597
00:24:20,799 --> 00:24:23,600
satisfy samsung key with the selective

598
00:24:23,600 --> 00:24:26,480
security or adaptive security with the

599
00:24:26,480 --> 00:24:29,360
non-successful key so our next target is

600
00:24:29,360 --> 00:24:32,240
to consider how to achieve the required

601
00:24:32,240 --> 00:24:35,279
abw gps

602
00:24:35,360 --> 00:24:37,440
in order to describe our technique more

603
00:24:37,440 --> 00:24:38,559
clearly

604
00:24:38,559 --> 00:24:42,240
let us first recall the general abwps

605
00:24:42,240 --> 00:24:44,880
from any kp abe

606
00:24:44,880 --> 00:24:47,120
due to the time limit we defer the

607
00:24:47,120 --> 00:24:50,000
details to a paper uh according to this

608
00:24:50,000 --> 00:24:53,279
uh this construction we know that the

609
00:24:53,279 --> 00:24:55,039
literature rate is the upper bound by

610
00:24:55,039 --> 00:24:56,720
this ratio

611
00:24:56,720 --> 00:24:58,960
besides we know

612
00:24:58,960 --> 00:24:59,440
the that

613
00:24:59,440 --> 00:25:02,880
and the property of kpab will derive

614
00:25:02,880 --> 00:25:04,159
will derive

615
00:25:04,159 --> 00:25:05,200
the

616
00:25:05,200 --> 00:25:09,120
sizing key property of abw ps

617
00:25:09,120 --> 00:25:12,799
so for all four what is the other avwps

618
00:25:12,799 --> 00:25:16,240
we need abe with the properties of

619
00:25:16,240 --> 00:25:18,559
succinct key and adaptive security

620
00:25:18,559 --> 00:25:23,200
however or all existing abe from latin

621
00:25:23,200 --> 00:25:26,080
the the samsung key do not have adaptive

622
00:25:26,080 --> 00:25:27,679
security

623
00:25:27,679 --> 00:25:28,720
so

624
00:25:28,720 --> 00:25:31,440
in order to overcome this obstacle we

625
00:25:31,440 --> 00:25:33,279
introduced a new notion called a

626
00:25:33,279 --> 00:25:35,520
partially adaptive abe

627
00:25:35,520 --> 00:25:37,279
particularly we

628
00:25:37,279 --> 00:25:38,640
reque

629
00:25:38,640 --> 00:25:42,320
we require adaptive security for the

630
00:25:42,320 --> 00:25:46,000
first product of attribute vector x

631
00:25:46,000 --> 00:25:48,320
and selecting security for the little

632
00:25:48,320 --> 00:25:49,840
part of

633
00:25:49,840 --> 00:25:52,080
attribute ig

634
00:25:52,080 --> 00:25:55,039
with this notion we can actually we can

635
00:25:55,039 --> 00:25:59,039
obtain and desire the ebwps and then put

636
00:25:59,039 --> 00:26:01,600
all things together we can get a

637
00:26:01,600 --> 00:26:04,240
adaptive abe with optimal liquid rate in

638
00:26:04,240 --> 00:26:04,960
the

639
00:26:04,960 --> 00:26:08,159
relative liquid model

640
00:26:08,240 --> 00:26:10,799
due to time limit other techniques for

641
00:26:10,799 --> 00:26:12,559
or other results of this paper are

642
00:26:12,559 --> 00:26:15,039
deferred to our paper

643
00:26:15,039 --> 00:26:18,640
thank you for attention

644
00:26:18,640 --> 00:26:21,120
okay thanks for the talk uh so any

645
00:26:21,120 --> 00:26:24,120
questions

646
00:26:30,000 --> 00:26:32,640
i have a question that um

647
00:26:32,640 --> 00:26:33,600
so

648
00:26:33,600 --> 00:26:35,360
what kind of

649
00:26:35,360 --> 00:26:37,360
functionality you can support for your

650
00:26:37,360 --> 00:26:40,480
adaptive adaptively secure scheme

651
00:26:40,480 --> 00:26:42,960
oh yes

652
00:26:44,240 --> 00:26:46,159
generally

653
00:26:46,159 --> 00:26:47,039
thus

654
00:26:47,039 --> 00:26:49,520
all adaptive security imagine

655
00:26:49,520 --> 00:26:54,159
the existing non-non-linear nonlinearity

656
00:26:54,159 --> 00:26:55,679
abe

657
00:26:55,679 --> 00:26:57,600
such as a

658
00:26:57,600 --> 00:26:59,360
cnf

659
00:26:59,360 --> 00:26:59,910
and

660
00:26:59,910 --> 00:27:02,080
[Music]

661
00:27:02,080 --> 00:27:04,240
and

662
00:27:04,240 --> 00:27:08,240
identity the encryption

663
00:27:11,120 --> 00:27:13,760
uh okay i see i see yeah yes

664
00:27:13,760 --> 00:27:16,559
so if you can do uh um

665
00:27:16,559 --> 00:27:18,399
you can realize the functionality for

666
00:27:18,399 --> 00:27:21,039
the uh non-leakage incident so you can

667
00:27:21,039 --> 00:27:24,240
also do that yes yes just just match

668
00:27:24,240 --> 00:27:25,200
this

669
00:27:25,200 --> 00:27:27,840
okay i see i see so so another question

670
00:27:27,840 --> 00:27:30,000
is um do you consider the leakage of

671
00:27:30,000 --> 00:27:32,399
master secret keys

672
00:27:32,399 --> 00:27:35,279
no i think this is our future work

673
00:27:35,279 --> 00:27:37,919
okay okay so so so general question is

674
00:27:37,919 --> 00:27:41,039
um whether it is uh i mean i mean

675
00:27:41,039 --> 00:27:41,840
um

676
00:27:41,840 --> 00:27:43,120
is there a

677
00:27:43,120 --> 00:27:44,640
formal treatment

678
00:27:44,640 --> 00:27:47,279
uh showing that linkage i think if you

679
00:27:47,279 --> 00:27:50,480
can build a leakage resilience for the

680
00:27:50,480 --> 00:27:53,279
master secret key so it is also it it

681
00:27:53,279 --> 00:27:55,360
actually implied

682
00:27:55,360 --> 00:27:57,520
the liquid resilience for the user

683
00:27:57,520 --> 00:28:00,158
secret keys

684
00:28:01,440 --> 00:28:04,000
generally i think uh

685
00:28:04,000 --> 00:28:05,679
this should be uh two different

686
00:28:05,679 --> 00:28:07,520
questions um

687
00:28:07,520 --> 00:28:10,960
uh in this paper we use uh the general

688
00:28:10,960 --> 00:28:13,840
general framework of a hash pro system

689
00:28:13,840 --> 00:28:16,559
but generally this framework

690
00:28:16,559 --> 00:28:19,840
will derive a leakage for user key not

691
00:28:19,840 --> 00:28:22,159
for mass classification

692
00:28:22,159 --> 00:28:24,159
okay

693
00:28:24,159 --> 00:28:25,279
okay

694
00:28:25,279 --> 00:28:26,960
thank you thank you

695
00:28:26,960 --> 00:28:29,279
so any any questions

696
00:28:29,279 --> 00:28:32,960
let me check the channel

697
00:28:33,120 --> 00:28:35,360
okay

698
00:28:37,120 --> 00:28:39,760
so let's move to the to the next top

699
00:28:39,760 --> 00:28:41,200
which is uh

700
00:28:41,200 --> 00:28:44,159
which is encapsulated search index

701
00:28:44,159 --> 00:28:47,120
public key sub linear distributed and

702
00:28:47,120 --> 00:28:51,679
dedicatable by eric aronisti david cash

703
00:28:51,679 --> 00:28:54,320
uh irigini dodis

704
00:28:54,320 --> 00:28:57,120
daniel gallons christopher

705
00:28:57,120 --> 00:28:58,559
italy

706
00:28:58,559 --> 00:29:01,919
harris cash cassie cayenne

707
00:29:01,919 --> 00:29:03,760
owen t song

708
00:29:03,760 --> 00:29:05,919
so

709
00:29:05,919 --> 00:29:08,559
i wish you will give the talk

710
00:29:08,559 --> 00:29:11,600
um thanks for the introduction

711
00:29:11,600 --> 00:29:13,679
this is our joint work with our folks at

712
00:29:13,679 --> 00:29:15,679
atacama david castro university of

713
00:29:15,679 --> 00:29:18,640
chicago and you've gonna join us at nyu

714
00:29:18,640 --> 00:29:20,320
and we'll be talking about encapsulated

715
00:29:20,320 --> 00:29:21,600
search index

716
00:29:21,600 --> 00:29:24,080
um so let's get started right off the

717
00:29:24,080 --> 00:29:25,919
bat searchable encryption is something

718
00:29:25,919 --> 00:29:28,399
that has gotten really popular and the

719
00:29:28,399 --> 00:29:30,240
simple reason is that remote storage is

720
00:29:30,240 --> 00:29:32,159
ubiquitous my own presentation is

721
00:29:32,159 --> 00:29:33,520
probably stored on

722
00:29:33,520 --> 00:29:34,880
at least on two different cloud

723
00:29:34,880 --> 00:29:37,919
platforms but then we never trust

724
00:29:37,919 --> 00:29:38,720
uh

725
00:29:38,720 --> 00:29:40,320
the server because we are cryptographers

726
00:29:40,320 --> 00:29:42,080
we have pessimists we don't like to

727
00:29:42,080 --> 00:29:44,159
place trust easily we have trust issues

728
00:29:44,159 --> 00:29:46,799
uh but anyway uh so what we'd like to do

729
00:29:46,799 --> 00:29:48,799
is we try to throw encryption at it but

730
00:29:48,799 --> 00:29:50,880
we are very good at what we do so our

731
00:29:50,880 --> 00:29:53,520
encryptions may be a little too perfect

732
00:29:53,520 --> 00:29:55,360
and the downside is that it actually

733
00:29:55,360 --> 00:29:57,600
hides all information about the data so

734
00:29:57,600 --> 00:29:59,039
if i want to search i would have to

735
00:29:59,039 --> 00:30:00,640
locally download it and do these

736
00:30:00,640 --> 00:30:01,760
operations

737
00:30:01,760 --> 00:30:05,279
and so a better solution is to

738
00:30:05,279 --> 00:30:07,200
factor in the fact that the server is

739
00:30:07,200 --> 00:30:09,919
completely untrusted and in and then

740
00:30:09,919 --> 00:30:12,000
still do these operations so we use

741
00:30:12,000 --> 00:30:14,159
these additional encrypted structures uh

742
00:30:14,159 --> 00:30:16,000
which we call as index so there's some

743
00:30:16,000 --> 00:30:18,159
kind of secret key involved to make sure

744
00:30:18,159 --> 00:30:20,080
that uh i can

745
00:30:20,080 --> 00:30:22,559
uh make sure i can still work in the

746
00:30:22,559 --> 00:30:24,080
pattern in the paradigm that the server

747
00:30:24,080 --> 00:30:25,520
is untrusted

748
00:30:25,520 --> 00:30:27,600
so more specifically what is our

749
00:30:27,600 --> 00:30:28,960
motivation

750
00:30:28,960 --> 00:30:31,039
so most documents do not change which

751
00:30:31,039 --> 00:30:33,120
means that they are immutable

752
00:30:33,120 --> 00:30:34,960
uh so photos patterns and other

753
00:30:34,960 --> 00:30:36,799
documents so once you create it it

754
00:30:36,799 --> 00:30:38,159
exists

755
00:30:38,159 --> 00:30:40,480
um so what it gives us is that i can

756
00:30:40,480 --> 00:30:42,880
generate index done incrementally so i

757
00:30:42,880 --> 00:30:45,039
don't need to wait uh i have all of the

758
00:30:45,039 --> 00:30:48,159
document at the get go so i can index it

759
00:30:48,159 --> 00:30:50,880
and move on with my life and what it

760
00:30:50,880 --> 00:30:52,399
also gives me is that i don't need

761
00:30:52,399 --> 00:30:54,960
document specific tokens or what we call

762
00:30:54,960 --> 00:30:57,840
as universal indexing um so now so

763
00:30:57,840 --> 00:30:59,600
either we can have a document specific

764
00:30:59,600 --> 00:31:02,080
tokens meaning i can generate a token

765
00:31:02,080 --> 00:31:04,799
for this particular keyword for our this

766
00:31:04,799 --> 00:31:06,559
particular document so i don't need to

767
00:31:06,559 --> 00:31:10,240
universally text a generated token

768
00:31:10,240 --> 00:31:12,240
and we also want this feature of some

769
00:31:12,240 --> 00:31:14,240
delegation which is basically where i

770
00:31:14,240 --> 00:31:17,519
can uh have multiple search approvers

771
00:31:17,519 --> 00:31:19,679
so what it means is i can allow an

772
00:31:19,679 --> 00:31:21,919
encrypted index e that is built for a

773
00:31:21,919 --> 00:31:24,320
particular document d using public key

774
00:31:24,320 --> 00:31:26,640
secret key pair to be searched by

775
00:31:26,640 --> 00:31:29,279
another user with public key

776
00:31:29,279 --> 00:31:31,519
secret keypad pk prime sk prime and i

777
00:31:31,519 --> 00:31:34,159
need to do this without knowing these

778
00:31:34,159 --> 00:31:36,640
and without modifying e so i the index

779
00:31:36,640 --> 00:31:39,200
is uh e has been built and i don't want

780
00:31:39,200 --> 00:31:40,640
to reinvent the wheel i don't want to

781
00:31:40,640 --> 00:31:42,559
spend effort to recompute the index

782
00:31:42,559 --> 00:31:44,000
because the document d is no longer with

783
00:31:44,000 --> 00:31:46,640
my disposal so this is the setting of

784
00:31:46,640 --> 00:31:49,279
delegation and based on all of this we

785
00:31:49,279 --> 00:31:52,159
want to uh ask the question

786
00:31:52,159 --> 00:31:54,159
can we achieve sublinear search time

787
00:31:54,159 --> 00:31:56,720
because uh most standard day search

788
00:31:56,720 --> 00:31:58,399
structures like bloom filter balance

789
00:31:58,399 --> 00:32:00,399
search trees we can do better

790
00:32:00,399 --> 00:32:02,799
than ofn and we also want public key

791
00:32:02,799 --> 00:32:04,480
indexing because it gives us a powerful

792
00:32:04,480 --> 00:32:06,880
tool for multiple index creator an index

793
00:32:06,880 --> 00:32:09,760
creator by definition or as the name

794
00:32:09,760 --> 00:32:11,200
suggests is someone who creates the

795
00:32:11,200 --> 00:32:12,559
index

796
00:32:12,559 --> 00:32:14,960
so this is what we work with and

797
00:32:14,960 --> 00:32:16,559
especially because

798
00:32:16,559 --> 00:32:18,240
one uh the existing solution of

799
00:32:18,240 --> 00:32:20,480
symmetric searchable encryption uh gives

800
00:32:20,480 --> 00:32:21,679
us the powerful

801
00:32:21,679 --> 00:32:24,240
uh tool of sublinear searching but we

802
00:32:24,240 --> 00:32:26,159
lose out on public indexing whereas

803
00:32:26,159 --> 00:32:28,159
specs gives us public key indexing and

804
00:32:28,159 --> 00:32:29,600
does not give us sublinear search so we

805
00:32:29,600 --> 00:32:31,840
want to somehow marry the two together

806
00:32:31,840 --> 00:32:33,600
and have the best of both worlds and

807
00:32:33,600 --> 00:32:35,919
that is what we do when we introduce a

808
00:32:35,919 --> 00:32:38,080
primitive of encapsulated search index

809
00:32:38,080 --> 00:32:39,440
so this is how the index creation

810
00:32:39,440 --> 00:32:40,880
process works

811
00:32:40,880 --> 00:32:43,760
i have a phone which is secure and i

812
00:32:43,760 --> 00:32:45,519
have a desktop that's powerful but

813
00:32:45,519 --> 00:32:47,679
insecure so when i'm using it right now

814
00:32:47,679 --> 00:32:49,600
it's secure and after that i don't trust

815
00:32:49,600 --> 00:32:52,240
anyone um i don't trust it

816
00:32:52,240 --> 00:32:54,559
um so the public the phone generates a

817
00:32:54,559 --> 00:32:56,720
publicly secret key keep secret key for

818
00:32:56,720 --> 00:32:58,799
itself sends public key to the desktop

819
00:32:58,799 --> 00:33:00,640
now the desktop can use this public key

820
00:33:00,640 --> 00:33:02,080
to create an index

821
00:33:02,080 --> 00:33:03,200
uh e

822
00:33:03,200 --> 00:33:05,600
using this document d

823
00:33:05,600 --> 00:33:07,600
and specifically what it also gives us

824
00:33:07,600 --> 00:33:09,200
is this additional

825
00:33:09,200 --> 00:33:12,080
compact handle called c okay we will

826
00:33:12,080 --> 00:33:14,240
explain why all of these matters in just

827
00:33:14,240 --> 00:33:16,000
a couple of minutes but this is the

828
00:33:16,000 --> 00:33:18,240
index creation process and once it is

829
00:33:18,240 --> 00:33:21,120
done it erases the document d so because

830
00:33:21,120 --> 00:33:22,880
it's no longer trusted i don't want the

831
00:33:22,880 --> 00:33:24,880
desktop to continue to have the document

832
00:33:24,880 --> 00:33:27,519
in its possession so all that the um

833
00:33:27,519 --> 00:33:30,240
that the desktop has is index e and this

834
00:33:30,240 --> 00:33:32,080
handles c

835
00:33:32,080 --> 00:33:32,960
now

836
00:33:32,960 --> 00:33:35,279
uh if i want to search get a search

837
00:33:35,279 --> 00:33:38,080
approval for w i need some token uh

838
00:33:38,080 --> 00:33:40,559
which i can search in the index e so at

839
00:33:40,559 --> 00:33:42,720
this point uh the desktop will send the

840
00:33:42,720 --> 00:33:46,000
ciphertext c or the handle c and this

841
00:33:46,000 --> 00:33:49,679
the word w the keyword w and what we

842
00:33:49,679 --> 00:33:51,600
want at this point is the

843
00:33:51,600 --> 00:33:54,080
the property of privacy preserving what

844
00:33:54,080 --> 00:33:56,320
it means is that if i see c and w the

845
00:33:56,320 --> 00:33:57,600
phone does not learn any other

846
00:33:57,600 --> 00:33:59,200
information and it should hold

847
00:33:59,200 --> 00:34:01,039
information theoretically and we

848
00:34:01,039 --> 00:34:02,640
actually achieve this by simple virtue

849
00:34:02,640 --> 00:34:04,399
of our syntax where we have this

850
00:34:04,399 --> 00:34:06,399
modularity which gives us unconditional

851
00:34:06,399 --> 00:34:08,159
privacy preserving

852
00:34:08,159 --> 00:34:09,839
and so now the privacy preserving has

853
00:34:09,839 --> 00:34:12,719
been met the phone gets c and w and the

854
00:34:12,719 --> 00:34:14,560
search approver does this where it takes

855
00:34:14,560 --> 00:34:17,199
the secret key and cnw to produce a

856
00:34:17,199 --> 00:34:21,599
specific token zw for the keyword w

857
00:34:21,599 --> 00:34:22,639
great

858
00:34:22,639 --> 00:34:26,000
now it simply sends zw to the desktop

859
00:34:26,000 --> 00:34:29,520
now we want consistency check that zw

860
00:34:29,520 --> 00:34:31,839
is properly formed the most the phone

861
00:34:31,839 --> 00:34:34,000
can do is denial of service it can't

862
00:34:34,000 --> 00:34:35,679
make the desktop output incorrect

863
00:34:35,679 --> 00:34:38,079
answers and we also want token privacy

864
00:34:38,079 --> 00:34:40,639
is which is basically to say that uh

865
00:34:40,639 --> 00:34:44,079
seeing zw i have no information about

866
00:34:44,079 --> 00:34:47,440
any other w prime in the document d or

867
00:34:47,440 --> 00:34:49,760
the same keyword in any other document d

868
00:34:49,760 --> 00:34:51,679
prime not equal to d recall that we

869
00:34:51,679 --> 00:34:53,359
don't have the property of universal

870
00:34:53,359 --> 00:34:55,839
indexing so z w that we see is

871
00:34:55,839 --> 00:34:58,800
essentially unique to this document d

872
00:34:58,800 --> 00:35:01,359
for which e and c is the index and the

873
00:35:01,359 --> 00:35:03,839
handle and what it also gives us is the

874
00:35:03,839 --> 00:35:05,680
same public key security can be reused

875
00:35:05,680 --> 00:35:07,760
multiple times because e comma c is

876
00:35:07,760 --> 00:35:10,000
unique to a document d and we want this

877
00:35:10,000 --> 00:35:12,320
communication to be constant so note

878
00:35:12,320 --> 00:35:14,480
that it only sends c and w and not the

879
00:35:14,480 --> 00:35:16,640
index e because e could ask be as large

880
00:35:16,640 --> 00:35:19,119
as the number of keyboards so

881
00:35:19,119 --> 00:35:22,160
this is uh the s entire setting for esi

882
00:35:22,160 --> 00:35:25,520
uh and uh this finally we use the uh the

883
00:35:25,520 --> 00:35:28,480
e to search with zw and then

884
00:35:28,480 --> 00:35:30,480
we produce the matches so how do we

885
00:35:30,480 --> 00:35:32,160
actually build our construction what is

886
00:35:32,160 --> 00:35:34,640
the intuition so we index we will index

887
00:35:34,640 --> 00:35:36,800
it uh w which is the keyword by

888
00:35:36,800 --> 00:35:39,599
computing a pseudonym function on w so

889
00:35:39,599 --> 00:35:41,200
we will store this value in a sub linear

890
00:35:41,200 --> 00:35:43,680
search dictionary great but know that we

891
00:35:43,680 --> 00:35:45,359
wanted a public key setting so we need

892
00:35:45,359 --> 00:35:47,200
two different ways to compute prf one

893
00:35:47,200 --> 00:35:49,119
using uh the public key for index

894
00:35:49,119 --> 00:35:50,640
creator and one using the secret key for

895
00:35:50,640 --> 00:35:52,640
the search approval but recall we wanted

896
00:35:52,640 --> 00:35:55,040
consistency check so we have to throw in

897
00:35:55,040 --> 00:35:57,359
a vrf into the mix now we have this

898
00:35:57,359 --> 00:35:59,359
naive construction

899
00:35:59,359 --> 00:36:00,960
where an index creator can simply just

900
00:36:00,960 --> 00:36:04,160
sample a vrf key and it and i will end

901
00:36:04,160 --> 00:36:05,920
the index with this drf and then i'll

902
00:36:05,920 --> 00:36:09,200
simply encrypt this uh vrf key with

903
00:36:09,200 --> 00:36:10,640
the public key and send it to the search

904
00:36:10,640 --> 00:36:13,359
approver and it works but unfortunately

905
00:36:13,359 --> 00:36:16,079
this does not help um offer support for

906
00:36:16,079 --> 00:36:18,160
delegation and distribution which is two

907
00:36:18,160 --> 00:36:20,800
features that we want and uh we

908
00:36:20,800 --> 00:36:22,560
discussed the reasons why in the paper

909
00:36:22,560 --> 00:36:24,480
and in the full talk and so we

910
00:36:24,480 --> 00:36:25,920
introduced this new primitive called

911
00:36:25,920 --> 00:36:27,760
encapsulated verifiable random function

912
00:36:27,760 --> 00:36:29,200
with support for both delegation and

913
00:36:29,200 --> 00:36:30,320
distribution

914
00:36:30,320 --> 00:36:33,359
okay so what is this bevra

915
00:36:33,359 --> 00:36:36,240
i have alice i have bob alice generates

916
00:36:36,240 --> 00:36:38,800
public key secret key sends it to bob

917
00:36:38,800 --> 00:36:40,800
bob run this end cap runs this encap

918
00:36:40,800 --> 00:36:43,040
procedure to produce a trapdoor t and a

919
00:36:43,040 --> 00:36:44,400
ciphertext c

920
00:36:44,400 --> 00:36:46,800
so this is what bob has just the

921
00:36:46,800 --> 00:36:48,800
trapdoor and it sends the

922
00:36:48,800 --> 00:36:51,359
the ciphertext to alice alice runs the

923
00:36:51,359 --> 00:36:54,880
eval procedure which produce evr of x

924
00:36:54,880 --> 00:36:57,280
using the secret key which is y

925
00:36:57,280 --> 00:36:59,520
simultaneously bob can also do this comp

926
00:36:59,520 --> 00:37:01,440
procedure which takes this trap door to

927
00:37:01,440 --> 00:37:03,520
generate x

928
00:37:03,520 --> 00:37:05,760
um i'm going a bit fast but the security

929
00:37:05,760 --> 00:37:07,520
game is just an indistinguishability

930
00:37:07,520 --> 00:37:09,680
came the key thing is that i the

931
00:37:09,680 --> 00:37:12,560
adversary has access to this oracle eval

932
00:37:12,560 --> 00:37:13,760
so and then it's in classic

933
00:37:13,760 --> 00:37:15,839
indistinguishability here

934
00:37:15,839 --> 00:37:17,440
okay i'm i'm going to skip the

935
00:37:17,440 --> 00:37:20,160
construction uh because of lack of time

936
00:37:20,160 --> 00:37:21,839
but just to show that there is such a

937
00:37:21,839 --> 00:37:24,240
construction which does this value

938
00:37:24,240 --> 00:37:26,800
computation so what do we do how do we

939
00:37:26,800 --> 00:37:29,760
use this evr we have a generic

940
00:37:29,760 --> 00:37:32,160
construction where we say

941
00:37:32,160 --> 00:37:34,480
the key gen algorithm will just run the

942
00:37:34,480 --> 00:37:36,800
gen algorithm for evrf produces a public

943
00:37:36,800 --> 00:37:38,160
key secret key

944
00:37:38,160 --> 00:37:41,040
and then index procedure will be i will

945
00:37:41,040 --> 00:37:43,359
compute this end cap procedure we'll use

946
00:37:43,359 --> 00:37:45,680
the trap door t to compute the evrf

947
00:37:45,680 --> 00:37:46,720
value

948
00:37:46,720 --> 00:37:49,119
and then i will just build

949
00:37:49,119 --> 00:37:50,960
insert essentially every value and y

950
00:37:50,960 --> 00:37:53,440
into a sublinear search structure

951
00:37:53,440 --> 00:37:55,920
and this is e and c a search procedure

952
00:37:55,920 --> 00:37:58,160
will use the eval algorithm instead of

953
00:37:58,160 --> 00:38:01,680
the evr function and searches in this uh

954
00:38:01,680 --> 00:38:03,359
in the sub linear search

955
00:38:03,359 --> 00:38:06,960
dictionary and we achieve threshold

956
00:38:06,960 --> 00:38:09,440
by taking our standard ebrf and throwing

957
00:38:09,440 --> 00:38:11,520
verifiable summary secret sharing we get

958
00:38:11,520 --> 00:38:14,480
a tier of n security and we also have

959
00:38:14,480 --> 00:38:16,800
delegatable evrf

960
00:38:16,800 --> 00:38:17,760
where

961
00:38:17,760 --> 00:38:19,200
we can take

962
00:38:19,200 --> 00:38:21,119
a delegate function which takes a c

963
00:38:21,119 --> 00:38:24,640
ciphertext c1 and a secret key sk1 and

964
00:38:24,640 --> 00:38:26,480
another secret key sk2 to produce a

965
00:38:26,480 --> 00:38:29,839
ciphertext c2 such that the eval values

966
00:38:29,839 --> 00:38:33,119
on sk1c1 is exactly the same as sk2 and

967
00:38:33,119 --> 00:38:34,720
c2 that's the correctness of the

968
00:38:34,720 --> 00:38:37,040
location now the security definition

969
00:38:37,040 --> 00:38:39,440
itself has several subtleties we refer

970
00:38:39,440 --> 00:38:40,720
you to the paper

971
00:38:40,720 --> 00:38:43,040
uh the only thing that i would mention

972
00:38:43,040 --> 00:38:45,920
at this point is that uh the the big

973
00:38:45,920 --> 00:38:48,480
picture of why our standard ebrf is

974
00:38:48,480 --> 00:38:49,839
secure

975
00:38:49,839 --> 00:38:52,400
we essentially how we go achieve

976
00:38:52,400 --> 00:38:55,040
delegateable security is we replace this

977
00:38:55,040 --> 00:38:57,520
r prime and we separate this r prime and

978
00:38:57,520 --> 00:39:00,720
this r prime by throwing in another

979
00:39:00,720 --> 00:39:01,599
um

980
00:39:01,599 --> 00:39:02,960
term d

981
00:39:02,960 --> 00:39:06,320
so that's how we get away with it and

982
00:39:06,320 --> 00:39:09,200
i will wrap it up in just the slide

983
00:39:09,200 --> 00:39:11,599
what do we achieve at this paper we

984
00:39:11,599 --> 00:39:13,520
introduce this primitive that's brand

985
00:39:13,520 --> 00:39:15,280
new called encapsulated search index

986
00:39:15,280 --> 00:39:16,320
which has

987
00:39:16,320 --> 00:39:18,640
public key and sublinear where we

988
00:39:18,640 --> 00:39:20,560
critically rely on the fact that the

989
00:39:20,560 --> 00:39:22,800
document is available at the get-go and

990
00:39:22,800 --> 00:39:24,400
then we introduce also this primitive

991
00:39:24,400 --> 00:39:26,079
called encapsulated verifiable random

992
00:39:26,079 --> 00:39:28,880
function and a lot of these are

993
00:39:28,880 --> 00:39:31,280
i mean we say prove it secure in a under

994
00:39:31,280 --> 00:39:33,200
different security

995
00:39:33,200 --> 00:39:34,800
security levels and it's also

996
00:39:34,800 --> 00:39:37,119
commercially deployed by atacama uh and

997
00:39:37,119 --> 00:39:39,359
it's it's deployed and there are clients

998
00:39:39,359 --> 00:39:40,960
who are extensively using this in their

999
00:39:40,960 --> 00:39:43,200
day-to-day applications uh thank you so

1000
00:39:43,200 --> 00:39:45,520
much i will take questions otherwise you

1001
00:39:45,520 --> 00:39:47,359
can also refer to the paper or the full

1002
00:39:47,359 --> 00:39:49,200
version is available on youtube thank

1003
00:39:49,200 --> 00:39:50,480
you

1004
00:39:50,480 --> 00:39:55,160
hey thanks for the talk so any questions

1005
00:40:00,960 --> 00:40:03,440
i have a short question so so here

1006
00:40:03,440 --> 00:40:06,800
sublinear uh is in which parameter it's

1007
00:40:06,800 --> 00:40:08,800
a linear in the size of database or

1008
00:40:08,800 --> 00:40:11,440
something else it's a subliminal the

1009
00:40:11,440 --> 00:40:13,040
number of keywords in the dictionary in

1010
00:40:13,040 --> 00:40:15,599
the document so e is uh basically every

1011
00:40:15,599 --> 00:40:17,760
single value is inserted there

1012
00:40:17,760 --> 00:40:20,079
okay okay okay thanks

1013
00:40:20,079 --> 00:40:21,839
okay thank you

1014
00:40:21,839 --> 00:40:24,160
for any questions if there's no

1015
00:40:24,160 --> 00:40:25,760
questions we

1016
00:40:25,760 --> 00:40:27,440
will move to

1017
00:40:27,440 --> 00:40:30,880
to the next talk

1018
00:40:31,920 --> 00:40:35,440
okay so the next talk is uh kdm security

1019
00:40:35,440 --> 00:40:38,880
for the fujisaki okamoto transformation

1020
00:40:38,880 --> 00:40:40,560
in the quran

1021
00:40:40,560 --> 00:40:46,079
by friuki kakara and leonisimaki

1022
00:40:46,079 --> 00:40:49,839
i feel he will give the talk right

1023
00:40:49,839 --> 00:40:52,560
can you see my slides yes yes

1024
00:40:52,560 --> 00:40:55,119
oh so thank you for introduction uh i'm

1025
00:40:55,119 --> 00:40:58,079
frieki from ntt uh this is a joint work

1026
00:40:58,079 --> 00:41:00,800
with rio nishmaki from ntt

1027
00:41:00,800 --> 00:41:03,440
so this talk is about kdm security

1028
00:41:03,440 --> 00:41:05,520
so i will start with what is ktm

1029
00:41:05,520 --> 00:41:06,720
security

1030
00:41:06,720 --> 00:41:09,359
so key dependent message security or kdm

1031
00:41:09,359 --> 00:41:12,079
security for short guarantees that an

1032
00:41:12,079 --> 00:41:14,319
encryption scheme can securely encrypt

1033
00:41:14,319 --> 00:41:16,160
its secret key

1034
00:41:16,160 --> 00:41:19,520
so uh destruction of encrypting

1035
00:41:19,520 --> 00:41:21,520
secret keys naturally occur in many

1036
00:41:21,520 --> 00:41:24,400
cryptographic protocols

1037
00:41:24,400 --> 00:41:27,280
recently kdm security has found an

1038
00:41:27,280 --> 00:41:28,480
application

1039
00:41:28,480 --> 00:41:32,160
also in quantum cryptography

1040
00:41:32,800 --> 00:41:34,800
so in this work uh we tackle the

1041
00:41:34,800 --> 00:41:36,319
following question

1042
00:41:36,319 --> 00:41:39,680
uh does do existing practical in the cpa

1043
00:41:39,680 --> 00:41:43,440
or cca secure pk scheme uh satisfy kdm

1044
00:41:43,440 --> 00:41:46,800
security in the queue rom

1045
00:41:47,040 --> 00:41:49,680
especially as practical schemes uh we

1046
00:41:49,680 --> 00:41:51,280
focus on fujisakio common

1047
00:41:51,280 --> 00:41:53,200
transformations f4

1048
00:41:53,200 --> 00:41:55,760
and we ask whether for transformation

1049
00:41:55,760 --> 00:41:58,400
satisfy ktm security in the queue rom

1050
00:41:58,400 --> 00:42:00,640
without square root loss

1051
00:42:00,640 --> 00:42:02,720
so i will briefly review f4

1052
00:42:02,720 --> 00:42:05,359
transformations and the square root loss

1053
00:42:05,359 --> 00:42:08,480
problem in the qram

1054
00:42:08,960 --> 00:42:11,760
so as shown by juan's a12 f4

1055
00:42:11,760 --> 00:42:14,160
transformations can be decomposed into

1056
00:42:14,160 --> 00:42:16,960
two transformations t and u

1057
00:42:16,960 --> 00:42:20,319
so the t transformation converts an ncpa

1058
00:42:20,319 --> 00:42:23,119
secure pk scheme into a one-way cpa

1059
00:42:23,119 --> 00:42:25,680
secure deterministic pk scheme

1060
00:42:25,680 --> 00:42:27,920
and the eu transformation converts a

1061
00:42:27,920 --> 00:42:30,240
one-way cpa secure deterministic pk

1062
00:42:30,240 --> 00:42:33,839
scheme into an in cca secure cam

1063
00:42:33,839 --> 00:42:37,680
and there are three variants of u

1064
00:42:38,079 --> 00:42:40,000
and now i will talk about the square

1065
00:42:40,000 --> 00:42:42,720
root loss problem in the q rom

1066
00:42:42,720 --> 00:42:45,119
so in the queue loan many security

1067
00:42:45,119 --> 00:42:47,920
proofs suffer from the square root loss

1068
00:42:47,920 --> 00:42:50,000
so this is partially because

1069
00:42:50,000 --> 00:42:52,880
we have to use one way to hiding lemma

1070
00:42:52,880 --> 00:42:54,560
proposed by unlu

1071
00:42:54,560 --> 00:42:56,400
in order to justify random oracle

1072
00:42:56,400 --> 00:42:58,880
programming

1073
00:42:58,880 --> 00:43:01,119
so roughly speaking one way to hiding

1074
00:43:01,119 --> 00:43:02,960
grammar states that

1075
00:43:02,960 --> 00:43:05,599
there exists an extracted d

1076
00:43:05,599 --> 00:43:08,400
such that the advantage gap caused by

1077
00:43:08,400 --> 00:43:10,800
random oracle programming can be bounded

1078
00:43:10,800 --> 00:43:14,000
by square root of the probability that

1079
00:43:14,000 --> 00:43:16,400
the extractor d extract the program the

1080
00:43:16,400 --> 00:43:18,720
point

1081
00:43:19,599 --> 00:43:21,040
so the square root loss are

1082
00:43:21,040 --> 00:43:23,200
significantly degrees essentially of

1083
00:43:23,200 --> 00:43:25,200
cryptographic schemes

1084
00:43:25,200 --> 00:43:26,960
so we have to avoid it

1085
00:43:26,960 --> 00:43:28,720
especially when we study practical

1086
00:43:28,720 --> 00:43:31,118
schemes

1087
00:43:32,480 --> 00:43:34,640
uh improved variant one-way to hiding

1088
00:43:34,640 --> 00:43:37,040
limbo was recently proposed

1089
00:43:37,040 --> 00:43:39,040
it is called double-sided one-way to

1090
00:43:39,040 --> 00:43:40,800
hide in grammar

1091
00:43:40,800 --> 00:43:42,880
and by using the double sided one with

1092
00:43:42,880 --> 00:43:46,319
hiding grammar uh kukta etwa showed that

1093
00:43:46,319 --> 00:43:48,880
the in the cca security of a4

1094
00:43:48,880 --> 00:43:51,280
transformation can be proved without a

1095
00:43:51,280 --> 00:43:53,200
scale of loss

1096
00:43:53,200 --> 00:43:55,760
however the applicability of the

1097
00:43:55,760 --> 00:43:58,079
double-sided language to hiding lemma is

1098
00:43:58,079 --> 00:44:00,160
somewhat limited

1099
00:44:00,160 --> 00:44:03,119
especially uh it is not clear how to use

1100
00:44:03,119 --> 00:44:05,359
the double-sided translator hiding lemma

1101
00:44:05,359 --> 00:44:07,839
in the context of kdm security due to

1102
00:44:07,839 --> 00:44:10,799
the circularity issue

1103
00:44:12,000 --> 00:44:14,000
so this is our results

1104
00:44:14,000 --> 00:44:16,560
we obtain the following two results

1105
00:44:16,560 --> 00:44:17,599
first

1106
00:44:17,599 --> 00:44:20,720
we show that a pk scheme obtained by any

1107
00:44:20,720 --> 00:44:23,520
variant of f4 cam with a one-time

1108
00:44:23,520 --> 00:44:27,040
patterns them satisfies ktm cpa security

1109
00:44:27,040 --> 00:44:28,960
in the queue rom without square root

1110
00:44:28,960 --> 00:44:30,319
loss

1111
00:44:30,319 --> 00:44:31,520
and second

1112
00:44:31,520 --> 00:44:32,640
we show that

1113
00:44:32,640 --> 00:44:35,839
a pk scheme obtained by a single variant

1114
00:44:35,839 --> 00:44:38,800
of f4 cam with one time pattern mac as

1115
00:44:38,800 --> 00:44:42,160
them satisfies kdmcca security in the

1116
00:44:42,160 --> 00:44:46,000
qram without the square root loss

1117
00:44:46,640 --> 00:44:49,520
more concretely for the first result we

1118
00:44:49,520 --> 00:44:53,119
can use variants of u are called u bot

1119
00:44:53,119 --> 00:44:55,200
and u not the bot

1120
00:44:55,200 --> 00:44:57,200
and for the second result

1121
00:44:57,200 --> 00:45:00,240
we can use a variant of u called u vote

1122
00:45:00,240 --> 00:45:03,479
key conformation

1123
00:45:04,640 --> 00:45:07,280
and for this second result uh we require

1124
00:45:07,280 --> 00:45:09,680
a mild injectivity assumption

1125
00:45:09,680 --> 00:45:12,400
for the underlining in the cpa secure pk

1126
00:45:12,400 --> 00:45:13,440
scheme

1127
00:45:13,440 --> 00:45:15,839
uh this assumption is the same as that

1128
00:45:15,839 --> 00:45:18,800
required in the previous works showed in

1129
00:45:18,800 --> 00:45:21,760
the cca security of f4 transformations

1130
00:45:21,760 --> 00:45:24,960
without square root loss

1131
00:45:26,079 --> 00:45:28,480
so finally i will briefly talk about the

1132
00:45:28,480 --> 00:45:31,200
technical challenge in this work

1133
00:45:31,200 --> 00:45:34,319
so since we study kdm security of course

1134
00:45:34,319 --> 00:45:37,760
we have to solve the circularity issue

1135
00:45:37,760 --> 00:45:40,319
usually in the classical rom

1136
00:45:40,319 --> 00:45:42,960
we can easily solve the security issue

1137
00:45:42,960 --> 00:45:45,760
by just random oracle programming

1138
00:45:45,760 --> 00:45:46,960
however

1139
00:45:46,960 --> 00:45:49,119
we found that the solving the

1140
00:45:49,119 --> 00:45:50,960
circularity issue by random morocco

1141
00:45:50,960 --> 00:45:54,079
programming is not easy in the q rom

1142
00:45:54,079 --> 00:45:57,839
if we want to avoid square root loss

1143
00:45:58,319 --> 00:46:01,599
so concretely to prove effort security

1144
00:46:01,599 --> 00:46:03,280
in the queue rom without square root

1145
00:46:03,280 --> 00:46:04,160
loss

1146
00:46:04,160 --> 00:46:06,720
we currently need to use a double-sided

1147
00:46:06,720 --> 00:46:09,599
one-way to hiding lemma

1148
00:46:09,599 --> 00:46:10,960
this means that

1149
00:46:10,960 --> 00:46:12,640
in the security proof

1150
00:46:12,640 --> 00:46:15,119
if we program the random oracle

1151
00:46:15,119 --> 00:46:17,119
we have to deal with

1152
00:46:17,119 --> 00:46:19,839
a double-sided extractor who can get

1153
00:46:19,839 --> 00:46:22,240
access to both pre-programmed and

1154
00:46:22,240 --> 00:46:25,839
post-programmed random oracles

1155
00:46:26,319 --> 00:46:29,200
so in this case we can see that

1156
00:46:29,200 --> 00:46:31,760
even if the security issue is solved

1157
00:46:31,760 --> 00:46:34,000
from the view of an adversary by random

1158
00:46:34,000 --> 00:46:36,400
oracle programming the security issue

1159
00:46:36,400 --> 00:46:38,560
will appear to the view of the

1160
00:46:38,560 --> 00:46:40,720
double-sided extractor since the

1161
00:46:40,720 --> 00:46:43,280
double-sided extractor can get access to

1162
00:46:43,280 --> 00:46:46,720
pre-programmed random oracle

1163
00:46:47,200 --> 00:46:49,839
so due to this problem in fact it seems

1164
00:46:49,839 --> 00:46:52,160
difficult to solve the security issue

1165
00:46:52,160 --> 00:46:54,400
only by random oracle programming in the

1166
00:46:54,400 --> 00:46:56,720
qrom if we want to avoid square root

1167
00:46:56,720 --> 00:46:59,040
loss

1168
00:46:59,520 --> 00:47:01,760
so we need a new technique to handle the

1169
00:47:01,760 --> 00:47:04,160
security issue in the qrm in order to

1170
00:47:04,160 --> 00:47:05,920
achieve our goal

1171
00:47:05,920 --> 00:47:08,240
so our main technical contribution is to

1172
00:47:08,240 --> 00:47:09,280
propose

1173
00:47:09,280 --> 00:47:10,880
such a new technique

1174
00:47:10,880 --> 00:47:13,359
so if you're interested in our work or

1175
00:47:13,359 --> 00:47:15,599
our solution to this problem uh please

1176
00:47:15,599 --> 00:47:18,160
see our paper

1177
00:47:18,160 --> 00:47:21,680
yeah so thank you for your attention

1178
00:47:23,280 --> 00:47:24,960
okay thanks for the talk so any

1179
00:47:24,960 --> 00:47:27,440
questions

1180
00:47:35,680 --> 00:47:37,680
so i i have a question that you

1181
00:47:37,680 --> 00:47:40,640
mentioned the square root sequence loss

1182
00:47:40,640 --> 00:47:42,960
in the of several times so

1183
00:47:42,960 --> 00:47:45,280
i think it's quite important because

1184
00:47:45,280 --> 00:47:47,280
the the efficiency

1185
00:47:47,280 --> 00:47:49,760
will decrease if you have such a huge

1186
00:47:49,760 --> 00:47:51,680
security loss so

1187
00:47:51,680 --> 00:47:54,079
technically if we don't care about such

1188
00:47:54,079 --> 00:47:57,119
a security laws so do we have a simple

1189
00:47:57,119 --> 00:47:59,040
way to to achieve

1190
00:47:59,040 --> 00:48:00,319
uh

1191
00:48:00,319 --> 00:48:02,400
to achieve kdm security

1192
00:48:02,400 --> 00:48:04,240
yes the answer is yes

1193
00:48:04,240 --> 00:48:06,880
so and so in the classical rom uh when

1194
00:48:06,880 --> 00:48:10,000
we program random oracle uh we use a

1195
00:48:10,000 --> 00:48:12,480
tool called difference lemma

1196
00:48:12,480 --> 00:48:13,440
uh

1197
00:48:13,440 --> 00:48:14,480
right so

1198
00:48:14,480 --> 00:48:15,200
and

1199
00:48:15,200 --> 00:48:16,319
yeah

1200
00:48:16,319 --> 00:48:17,359
so

1201
00:48:17,359 --> 00:48:18,400
if we

1202
00:48:18,400 --> 00:48:20,400
don't care square root loss uh we can

1203
00:48:20,400 --> 00:48:22,960
use one way to hiding lemma as a

1204
00:48:22,960 --> 00:48:25,040
complete alternative of the difference

1205
00:48:25,040 --> 00:48:26,240
lemma

1206
00:48:26,240 --> 00:48:28,640
yeah so in this sense uh so if we don't

1207
00:48:28,640 --> 00:48:31,040
care square root loss we can easily

1208
00:48:31,040 --> 00:48:33,760
approve kdm security in the qrm

1209
00:48:33,760 --> 00:48:36,720
so difficulty is there only when we

1210
00:48:36,720 --> 00:48:39,280
care square root loss

1211
00:48:39,280 --> 00:48:41,599
okay thanks so any questions for this

1212
00:48:41,599 --> 00:48:44,599
talk

1213
00:48:49,119 --> 00:48:50,720
okay

1214
00:48:50,720 --> 00:48:53,359
so no question so we moved to the the

1215
00:48:53,359 --> 00:48:55,440
last talk in this session

1216
00:48:55,440 --> 00:48:58,240
uh which is uh the direction of update

1217
00:48:58,240 --> 00:49:01,359
for encryption does matter by leonie

1218
00:49:01,359 --> 00:49:03,599
smackie

1219
00:49:03,599 --> 00:49:07,130
and smack your we'll give the talk

1220
00:49:07,130 --> 00:49:08,960
[Music]

1221
00:49:08,960 --> 00:49:11,680
oh there there is a there is a question

1222
00:49:11,680 --> 00:49:14,480
for for

1223
00:49:15,040 --> 00:49:15,640
oh yuki

1224
00:49:16,720 --> 00:49:18,960
um

1225
00:49:18,960 --> 00:49:20,720
so how does the decryption failure

1226
00:49:20,720 --> 00:49:23,839
affect the security loss

1227
00:49:23,839 --> 00:49:26,319
i guess this is for you

1228
00:49:26,319 --> 00:49:28,960
okay description failure

1229
00:49:28,960 --> 00:49:30,400
oh

1230
00:49:30,400 --> 00:49:33,680
this is for another talk

1231
00:49:34,000 --> 00:49:36,079
yeah

1232
00:49:36,079 --> 00:49:38,000
encryption failure

1233
00:49:38,000 --> 00:49:39,839
yeah but

1234
00:49:39,839 --> 00:49:42,480
yeah in our work we basically

1235
00:49:42,480 --> 00:49:45,359
consider uh the secure the correctness

1236
00:49:45,359 --> 00:49:48,400
called uh almost all keys correctness so

1237
00:49:48,400 --> 00:49:50,960
in this case i think a degree decryption

1238
00:49:50,960 --> 00:49:55,119
failure is not an issue so okay

1239
00:49:55,119 --> 00:49:57,359
okay

1240
00:49:57,680 --> 00:49:59,599
okay so if we have a more question we

1241
00:49:59,599 --> 00:50:01,040
can uh

1242
00:50:01,040 --> 00:50:02,400
we can ask

1243
00:50:02,400 --> 00:50:04,880
after the last talk maybe

1244
00:50:04,880 --> 00:50:07,359
so so let's move to the to the last talk

1245
00:50:07,359 --> 00:50:08,400
by

1246
00:50:08,400 --> 00:50:10,470
by you

1247
00:50:10,470 --> 00:50:12,400
[Music]

1248
00:50:12,400 --> 00:50:15,119
thank you for interruption introduction

1249
00:50:15,119 --> 00:50:17,680
uh can you see my story

1250
00:50:17,680 --> 00:50:20,559
yes we can yes okay okay

1251
00:50:20,559 --> 00:50:23,280
uh thanks i'm going to talk about

1252
00:50:23,280 --> 00:50:25,920
updatable encryption

1253
00:50:25,920 --> 00:50:28,400
to explain updatable encryption let's

1254
00:50:28,400 --> 00:50:31,280
consider the following scenario alice

1255
00:50:31,280 --> 00:50:35,599
saves her encrypted data on cloud server

1256
00:50:35,599 --> 00:50:38,240
her computer is attacked and her secret

1257
00:50:38,240 --> 00:50:40,720
key is rigged

1258
00:50:40,720 --> 00:50:43,280
to protect her data she generates a new

1259
00:50:43,280 --> 00:50:46,000
secret key

1260
00:50:46,400 --> 00:50:47,839
she should not

1261
00:50:47,839 --> 00:50:49,760
reveal her

1262
00:50:49,760 --> 00:50:51,680
reveal the secret key to the cloud

1263
00:50:51,680 --> 00:50:54,160
server so she downloads all encrypted

1264
00:50:54,160 --> 00:50:57,040
data from the server decrypts them

1265
00:50:57,040 --> 00:50:58,960
encrypts them by the new secret key

1266
00:50:58,960 --> 00:51:01,839
again and approach them to the server

1267
00:51:01,839 --> 00:51:04,000
this includes significant efficiency

1268
00:51:04,000 --> 00:51:04,880
laws

1269
00:51:04,880 --> 00:51:07,839
to resolve this issue we use updateable

1270
00:51:07,839 --> 00:51:10,000
encryption

1271
00:51:10,000 --> 00:51:12,160
in app database encryption we can

1272
00:51:12,160 --> 00:51:14,480
periodically update the secret key and

1273
00:51:14,480 --> 00:51:16,079
ciphertext

1274
00:51:16,079 --> 00:51:18,480
an updateable encryption scheme has key

1275
00:51:18,480 --> 00:51:21,040
generation encryption and dedication

1276
00:51:21,040 --> 00:51:23,200
algorithms as a standard encryption

1277
00:51:23,200 --> 00:51:24,079
scheme

1278
00:51:24,079 --> 00:51:26,960
and has two additional algorithms

1279
00:51:26,960 --> 00:51:30,000
one is the token generation algorithm

1280
00:51:30,000 --> 00:51:32,480
we can generate an update token from two

1281
00:51:32,480 --> 00:51:34,000
secret keys

1282
00:51:34,000 --> 00:51:36,640
in this talk we focus on ciphertext

1283
00:51:36,640 --> 00:51:39,040
independent athletes where we do not

1284
00:51:39,040 --> 00:51:43,440
need a ciphertext for generating a token

1285
00:51:43,440 --> 00:51:46,319
the other one is an update algorithm

1286
00:51:46,319 --> 00:51:48,559
we can convert a ciphertext under

1287
00:51:48,559 --> 00:51:52,480
another key into one under new key by

1288
00:51:52,480 --> 00:51:56,079
using an update token

1289
00:51:56,640 --> 00:51:59,839
if ice uses updateable encryption in

1290
00:51:59,839 --> 00:52:01,680
this scenario

1291
00:52:01,680 --> 00:52:04,319
she generates a new key and an update

1292
00:52:04,319 --> 00:52:06,720
token

1293
00:52:06,880 --> 00:52:08,160
then

1294
00:52:08,160 --> 00:52:11,599
she pass the token to the server

1295
00:52:11,599 --> 00:52:14,480
and the server can update

1296
00:52:14,480 --> 00:52:18,599
her encrypted data

1297
00:52:22,000 --> 00:52:24,960
okay so uh here one issue is where there

1298
00:52:24,960 --> 00:52:26,160
are token

1299
00:52:26,160 --> 00:52:28,480
uh leaks information about secret keys

1300
00:52:28,480 --> 00:52:30,960
or not since the token is generated from

1301
00:52:30,960 --> 00:52:32,640
two secret keys

1302
00:52:32,640 --> 00:52:34,640
in previous works there are three

1303
00:52:34,640 --> 00:52:37,200
categories for key updates

1304
00:52:37,200 --> 00:52:39,839
the first one is the bi-directional key

1305
00:52:39,839 --> 00:52:40,800
update

1306
00:52:40,800 --> 00:52:43,280
we can infer a secret key from both

1307
00:52:43,280 --> 00:52:45,280
directions via token

1308
00:52:45,280 --> 00:52:48,400
that is we can infer a new key from

1309
00:52:48,400 --> 00:52:52,800
token under all the key and vice versa

1310
00:52:52,800 --> 00:52:55,119
the second one is the unidirectional key

1311
00:52:55,119 --> 00:52:56,160
update

1312
00:52:56,160 --> 00:52:58,960
we can infer a new key from a token

1313
00:52:58,960 --> 00:53:00,880
under old key

1314
00:53:00,880 --> 00:53:03,839
however we cannot infer an old key from

1315
00:53:03,839 --> 00:53:07,200
a token under new key

1316
00:53:08,079 --> 00:53:10,000
the last one is the no directional key

1317
00:53:10,000 --> 00:53:12,839
update we cannot install keys from a

1318
00:53:12,839 --> 00:53:15,920
token all previous updatable encryption

1319
00:53:15,920 --> 00:53:19,040
scheme have a bi-directional key update

1320
00:53:19,040 --> 00:53:21,839
this is not desirable since such token

1321
00:53:21,839 --> 00:53:25,040
leaks more information

1322
00:53:27,680 --> 00:53:29,520
the directional key updates are

1323
00:53:29,520 --> 00:53:31,599
similarly stronger than bi-directional

1324
00:53:31,599 --> 00:53:33,200
key updates

1325
00:53:33,200 --> 00:53:36,240
however jam proves that the security in

1326
00:53:36,240 --> 00:53:38,720
the bi-directional key update setting is

1327
00:53:38,720 --> 00:53:41,440
equivalent to the security in the unity

1328
00:53:41,440 --> 00:53:44,000
unidirectional key of this setting

1329
00:53:44,000 --> 00:53:46,400
this is surprising since the direction

1330
00:53:46,400 --> 00:53:50,480
of update rendition does not matter much

1331
00:53:50,480 --> 00:53:54,160
however here is a question

1332
00:53:54,160 --> 00:53:56,720
why do we consider the unidirectional

1333
00:53:56,720 --> 00:53:59,359
key approach where achieve influence in

1334
00:53:59,359 --> 00:54:01,760
the forward direction

1335
00:54:01,760 --> 00:54:04,000
we can consider another unidirectional

1336
00:54:04,000 --> 00:54:06,160
key update variant where our key

1337
00:54:06,160 --> 00:54:09,119
influence in the backward direction

1338
00:54:09,119 --> 00:54:12,079
that is we can infer on all the key from

1339
00:54:12,079 --> 00:54:14,880
a token under new key but cannot in the

1340
00:54:14,880 --> 00:54:16,640
opposite direction

1341
00:54:16,640 --> 00:54:19,440
we call this bar quadric unidirectional

1342
00:54:19,440 --> 00:54:22,160
key updates

1343
00:54:22,400 --> 00:54:24,800
to distinguish two types of individual

1344
00:54:24,800 --> 00:54:26,800
key updates we call the previous

1345
00:54:26,800 --> 00:54:29,359
unidirectional kia plates broadly

1346
00:54:29,359 --> 00:54:31,680
injection key upgrades

1347
00:54:31,680 --> 00:54:34,400
let's see the backward recognition key

1348
00:54:34,400 --> 00:54:38,000
updates are preferable to the quarterly

1349
00:54:38,000 --> 00:54:39,040
one

1350
00:54:39,040 --> 00:54:41,200
here we consider the unidirectional

1351
00:54:41,200 --> 00:54:42,720
ciphertext separate

1352
00:54:42,720 --> 00:54:44,799
this is reasonable in the back quadrant

1353
00:54:44,799 --> 00:54:47,280
injection key update setting but i omit

1354
00:54:47,280 --> 00:54:50,640
the reason in this short talk

1355
00:54:50,720 --> 00:54:53,040
suppose that the middle secret key is

1356
00:54:53,040 --> 00:54:54,000
rigged

1357
00:54:54,000 --> 00:54:56,640
then in the forward link setting we can

1358
00:54:56,640 --> 00:55:01,119
get the newest secret key vr token

1359
00:55:01,119 --> 00:55:02,640
in this case

1360
00:55:02,640 --> 00:55:05,280
even if we securely delete all the

1361
00:55:05,280 --> 00:55:08,319
ciphertext we cannot protect the newest

1362
00:55:08,319 --> 00:55:10,079
ciphertext

1363
00:55:10,079 --> 00:55:12,720
here updating ciphertext does not help

1364
00:55:12,720 --> 00:55:15,440
us since the newest key is informed br

1365
00:55:15,440 --> 00:55:17,839
token

1366
00:55:18,640 --> 00:55:20,880
in the back quadrantic setting we can

1367
00:55:20,880 --> 00:55:24,079
get the the oldest oldest secret key vr

1368
00:55:24,079 --> 00:55:25,599
token

1369
00:55:25,599 --> 00:55:29,599
in this case if we securely deleted

1370
00:55:29,599 --> 00:55:32,160
all all the ciphertext we can protect

1371
00:55:32,160 --> 00:55:35,040
the newest key and ciphertext

1372
00:55:35,040 --> 00:55:37,200
note that i assume that the ciphertext

1373
00:55:37,200 --> 00:55:40,720
update is unidirectional

1374
00:55:44,640 --> 00:55:46,960
so

1375
00:55:47,760 --> 00:55:49,839
so in this work we introduced the

1376
00:55:49,839 --> 00:55:52,319
definition of backward leak injection

1377
00:55:52,319 --> 00:55:55,520
key updates as i explained so far

1378
00:55:55,520 --> 00:55:59,200
surprisingly or unsurprisingly we also

1379
00:55:59,200 --> 00:56:00,839
showed that

1380
00:56:00,839 --> 00:56:03,839
backwardation key updates are strictly

1381
00:56:03,839 --> 00:56:06,480
stronger than the world league induction

1382
00:56:06,480 --> 00:56:08,079
key updates

1383
00:56:08,079 --> 00:56:10,559
this is sharp contrast to jan's

1384
00:56:10,559 --> 00:56:12,799
equivalence theorem

1385
00:56:12,799 --> 00:56:16,079
more concretely we showed that existing

1386
00:56:16,079 --> 00:56:18,720
secure ue schemes in the quarterly

1387
00:56:18,720 --> 00:56:21,520
intellectual key update setting are not

1388
00:56:21,520 --> 00:56:23,200
secure in the back quadrant

1389
00:56:23,200 --> 00:56:25,280
unidirectional key setting here this

1390
00:56:25,280 --> 00:56:27,200
setting

1391
00:56:27,200 --> 00:56:28,880
we present

1392
00:56:28,880 --> 00:56:32,000
uh two afflictable encryption schemes

1393
00:56:32,000 --> 00:56:34,079
one is secure in the back quadrant

1394
00:56:34,079 --> 00:56:35,119
encryption

1395
00:56:35,119 --> 00:56:37,200
key update setting under the learning

1396
00:56:37,200 --> 00:56:39,200
with errors assumption

1397
00:56:39,200 --> 00:56:41,280
the other one is secure in the node

1398
00:56:41,280 --> 00:56:44,160
direction setting and based on in this

1399
00:56:44,160 --> 00:56:46,079
indistinguishability obviously

1400
00:56:46,079 --> 00:56:48,799
and one way functions

1401
00:56:48,799 --> 00:56:51,440
uh this is our result

1402
00:56:51,440 --> 00:56:52,480
so

1403
00:56:52,480 --> 00:56:56,000
my uh take home message is the direction

1404
00:56:56,000 --> 00:56:58,880
of uploadable creation doesn't matter

1405
00:56:58,880 --> 00:57:03,040
that is thank you for attention

1406
00:57:03,040 --> 00:57:04,640
okay thanks for the talk so any

1407
00:57:04,640 --> 00:57:07,640
questions

1408
00:57:12,400 --> 00:57:15,440
um so so i have questions uh maybe a bit

1409
00:57:15,440 --> 00:57:17,280
general so uh

1410
00:57:17,280 --> 00:57:19,119
i don't work on the update for

1411
00:57:19,119 --> 00:57:21,599
encryption but uh uh from your

1412
00:57:21,599 --> 00:57:24,240
introduction so i feel that the notion

1413
00:57:24,240 --> 00:57:26,000
is quite similar to the notion of

1414
00:57:26,000 --> 00:57:29,440
re-encryption so

1415
00:57:29,839 --> 00:57:31,520
what is the difference between these two

1416
00:57:31,520 --> 00:57:32,720
notions

1417
00:57:32,720 --> 00:57:35,760
okay so yeah uh it is very similar to

1418
00:57:35,760 --> 00:57:39,119
proxy re-encryption however

1419
00:57:39,119 --> 00:57:41,359
so in the process re-encryption there

1420
00:57:41,359 --> 00:57:43,599
are multiple users right

1421
00:57:43,599 --> 00:57:46,319
uh for example uh

1422
00:57:46,319 --> 00:57:48,880
the encryption key from rs to both

1423
00:57:48,880 --> 00:57:51,440
something like that but in updateable

1424
00:57:51,440 --> 00:57:54,480
equation there is only one user one user

1425
00:57:54,480 --> 00:57:57,040
update uh she's or her

1426
00:57:57,040 --> 00:58:00,079
secret key update periodically there

1427
00:58:00,079 --> 00:58:01,280
right

1428
00:58:01,280 --> 00:58:03,520
so that's a is a big difference so and

1429
00:58:03,520 --> 00:58:04,240
uh

1430
00:58:04,240 --> 00:58:06,799
basically in updateable encryption there

1431
00:58:06,799 --> 00:58:10,640
is no public key just a secret key

1432
00:58:10,640 --> 00:58:13,119
because uh uh

1433
00:58:13,119 --> 00:58:16,640
only one user use the secret key uh

1434
00:58:16,640 --> 00:58:19,920
for her uh profile his or his encrypted

1435
00:58:19,920 --> 00:58:21,200
data

1436
00:58:21,200 --> 00:58:24,000
okay i see i see okay thanks

1437
00:58:24,000 --> 00:58:26,880
so any questions

1438
00:58:28,480 --> 00:58:30,799
okay so i think i should conclude these

1439
00:58:30,799 --> 00:58:33,440
sessions oh and uh thanks for all the

1440
00:58:33,440 --> 00:58:35,599
talks and all the speakers and things on

1441
00:58:35,599 --> 00:58:37,520
the audience so i think offline

1442
00:58:37,520 --> 00:58:39,839
discussion is possible so

1443
00:58:39,839 --> 00:58:42,799
uh we have uh we have a 20 minutes break

1444
00:58:42,799 --> 00:58:44,160
and uh

1445
00:58:44,160 --> 00:58:46,559
stephen will will share the next session

1446
00:58:46,559 --> 00:58:48,720
for

