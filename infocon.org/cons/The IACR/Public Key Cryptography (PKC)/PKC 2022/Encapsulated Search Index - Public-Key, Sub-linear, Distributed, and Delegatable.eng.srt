1
00:00:02,639 --> 00:00:04,640
hi everyone thank you so much for taking

2
00:00:04,640 --> 00:00:06,480
the time to view the full version of the

3
00:00:06,480 --> 00:00:08,480
talk about our research paper

4
00:00:08,480 --> 00:00:11,120
encapsulated search index publicly

5
00:00:11,120 --> 00:00:13,920
sublinear distributed and delegateable

6
00:00:13,920 --> 00:00:16,239
this is joint work with folks at atacama

7
00:00:16,239 --> 00:00:18,400
david cash at the university of chicago

8
00:00:18,400 --> 00:00:20,600
and my advisor you've gotta

9
00:00:20,600 --> 00:00:23,600
say my name is harish and i will be

10
00:00:23,600 --> 00:00:26,000
giving this talk

11
00:00:26,000 --> 00:00:28,720
so before we look at encapsulated search

12
00:00:28,720 --> 00:00:31,920
index it we can first take a pause and

13
00:00:31,920 --> 00:00:35,360
look at actually searchable encryption

14
00:00:35,360 --> 00:00:37,520
searchable encryption the motivation

15
00:00:37,520 --> 00:00:40,239
what why is it so popular why has it

16
00:00:40,239 --> 00:00:42,879
grown uh increasingly relevant this

17
00:00:42,879 --> 00:00:44,879
simple reason is remote storage has

18
00:00:44,879 --> 00:00:47,360
become ubiquitous cheap and convenient

19
00:00:47,360 --> 00:00:49,520
everyone wants to store things on the

20
00:00:49,520 --> 00:00:51,360
cloud for example this very presentation

21
00:00:51,360 --> 00:00:52,879
is at least stored on two cloud

22
00:00:52,879 --> 00:00:54,160
platforms

23
00:00:54,160 --> 00:00:57,280
but the flip side is that if do we ever

24
00:00:57,280 --> 00:00:59,600
trust the server that we should store

25
00:00:59,600 --> 00:01:01,840
this data on and if you ask a bunch of

26
00:01:01,840 --> 00:01:03,920
cryptographers the answer is always no

27
00:01:03,920 --> 00:01:06,000
because we have severe trust issues and

28
00:01:06,000 --> 00:01:08,880
we typically solve by um throwing

29
00:01:08,880 --> 00:01:10,000
encryption

30
00:01:10,000 --> 00:01:12,479
at it and this is an elegant solution

31
00:01:12,479 --> 00:01:14,159
but apparently our tools are a little

32
00:01:14,159 --> 00:01:16,320
too perfect because the flip side is

33
00:01:16,320 --> 00:01:18,320
that it does really do a good job of

34
00:01:18,320 --> 00:01:20,960
hiding all information about the data

35
00:01:20,960 --> 00:01:24,000
and consequently what needs to happen

36
00:01:24,000 --> 00:01:26,080
for us to do some operations on the data

37
00:01:26,080 --> 00:01:28,320
is for us to locally download and then

38
00:01:28,320 --> 00:01:30,240
perform the operations

39
00:01:30,240 --> 00:01:32,240
so searchable encryption was devised as

40
00:01:32,240 --> 00:01:34,640
a paradigm or a primitive where we can

41
00:01:34,640 --> 00:01:36,960
actually do something clever we where we

42
00:01:36,960 --> 00:01:39,200
will ask the server to help us perform

43
00:01:39,200 --> 00:01:42,320
this operation while being completely

44
00:01:42,320 --> 00:01:44,159
mindful of the fact that the server is

45
00:01:44,159 --> 00:01:46,399
untrusted and here

46
00:01:46,399 --> 00:01:49,280
all uh operations we talk about is such

47
00:01:49,280 --> 00:01:51,040
and the concept is therefore searchable

48
00:01:51,040 --> 00:01:53,280
encryption or private searching so what

49
00:01:53,280 --> 00:01:54,799
is the setting

50
00:01:54,799 --> 00:01:56,880
we basically throw some additional

51
00:01:56,880 --> 00:01:58,799
encrypted structures which we call as

52
00:01:58,799 --> 00:02:01,680
index and denoted by the letter e

53
00:02:01,680 --> 00:02:04,079
ah so because as encryption you can

54
00:02:04,079 --> 00:02:05,280
think that there is some kind of a

55
00:02:05,280 --> 00:02:07,360
secret key that is involved

56
00:02:07,360 --> 00:02:09,038
now there is the role of an index

57
00:02:09,038 --> 00:02:11,038
creator who is actually the person who

58
00:02:11,038 --> 00:02:12,640
creates the index

59
00:02:12,640 --> 00:02:14,080
search approver is someone who can

60
00:02:14,080 --> 00:02:16,000
control the search process who typically

61
00:02:16,000 --> 00:02:17,360
controls the

62
00:02:17,360 --> 00:02:19,520
secret key and therefore can provide

63
00:02:19,520 --> 00:02:22,720
information to selectively decrypt uh

64
00:02:22,720 --> 00:02:25,520
the index and finally the storage order

65
00:02:25,520 --> 00:02:27,680
is typically modif modeled as someone

66
00:02:27,680 --> 00:02:30,239
who is untrustworthy um

67
00:02:30,239 --> 00:02:31,920
controls the storage location on which

68
00:02:31,920 --> 00:02:33,680
the data is stored so if you were to

69
00:02:33,680 --> 00:02:35,680
look at the data flow you have a

70
00:02:35,680 --> 00:02:37,920
document that an index trader takes as

71
00:02:37,920 --> 00:02:40,400
input to produce an index e this is an

72
00:02:40,400 --> 00:02:43,040
encrypted index key now if i wanted to

73
00:02:43,040 --> 00:02:46,640
search uh for a keyword w it will take

74
00:02:46,640 --> 00:02:49,440
some um some secret information the

75
00:02:49,440 --> 00:02:52,959
sales approval uh to produce a token zw

76
00:02:52,959 --> 00:02:55,920
and zw on the index is combinedly used

77
00:02:55,920 --> 00:02:58,560
as an input uh for the storage location

78
00:02:58,560 --> 00:03:00,800
to actually produce the matches and here

79
00:03:00,800 --> 00:03:02,480
the security that we require is

80
00:03:02,480 --> 00:03:04,319
something known as index privacy or

81
00:03:04,319 --> 00:03:06,640
token privacy where even if i have the

82
00:03:06,640 --> 00:03:09,200
index in my hand and a bunch of keywords

83
00:03:09,200 --> 00:03:11,680
um sorry tokens for a bunch of keywords

84
00:03:11,680 --> 00:03:14,800
i have no information about how a token

85
00:03:14,800 --> 00:03:17,040
for a keyword w prime

86
00:03:17,040 --> 00:03:18,640
looks like if i have never seen it

87
00:03:18,640 --> 00:03:21,280
before and that is the goal that we want

88
00:03:21,280 --> 00:03:24,480
is for uh privacy of uh indices that

89
00:03:24,480 --> 00:03:26,640
have not been uh

90
00:03:26,640 --> 00:03:28,480
queried yet

91
00:03:28,480 --> 00:03:30,319
or keywords that have not been queried

92
00:03:30,319 --> 00:03:33,840
yet and in this setting we ask the

93
00:03:33,840 --> 00:03:36,720
question can we achieve sublinear search

94
00:03:36,720 --> 00:03:39,200
time and public key indexing the former

95
00:03:39,200 --> 00:03:41,360
is very attractive for simple reason

96
00:03:41,360 --> 00:03:43,599
that a lot of the data structure that

97
00:03:43,599 --> 00:03:46,080
are out there can a support search

98
00:03:46,080 --> 00:03:48,239
operations in sublinear time a bloom

99
00:03:48,239 --> 00:03:51,040
filter can give it an expected constant

100
00:03:51,040 --> 00:03:52,959
time whereas balanced search trees will

101
00:03:52,959 --> 00:03:56,159
do worst case uh log in the size of the

102
00:03:56,159 --> 00:03:58,640
uh tree or the number of entries stored

103
00:03:58,640 --> 00:04:00,959
in the data structure and public key

104
00:04:00,959 --> 00:04:03,439
indexing will have uh will have the

105
00:04:03,439 --> 00:04:05,760
feature of supporting multiple index

106
00:04:05,760 --> 00:04:07,760
creators so there is no bottleneck where

107
00:04:07,760 --> 00:04:09,760
i'm relying on explicitly one single

108
00:04:09,760 --> 00:04:11,680
person to do the job

109
00:04:11,680 --> 00:04:15,280
so specifically we look at this um

110
00:04:15,280 --> 00:04:17,918
construct or these two features of our

111
00:04:17,918 --> 00:04:20,399
searchable encryption primitive uh in

112
00:04:20,399 --> 00:04:23,440
this particular setting where most

113
00:04:23,440 --> 00:04:25,600
documents actually do not change that is

114
00:04:25,600 --> 00:04:28,160
immutable so what does it mean is that

115
00:04:28,160 --> 00:04:30,479
once it's created it's there and this

116
00:04:30,479 --> 00:04:33,280
gives us the powerful tool of ensuring

117
00:04:33,280 --> 00:04:35,680
that our index need not be created

118
00:04:35,680 --> 00:04:38,639
incrementally so i have it i can be done

119
00:04:38,639 --> 00:04:41,520
with it or by creating an index and

120
00:04:41,520 --> 00:04:43,360
consequently what it also means is that

121
00:04:43,360 --> 00:04:46,240
i can have document specific tokens what

122
00:04:46,240 --> 00:04:49,440
do i mean by that it means that i have

123
00:04:49,440 --> 00:04:52,160
tokens or keywords that is specific to

124
00:04:52,160 --> 00:04:54,000
this document so we do not need this

125
00:04:54,000 --> 00:04:56,320
feature of universal indexing for what

126
00:04:56,320 --> 00:04:58,160
we at least call as universal indexing

127
00:04:58,160 --> 00:05:01,280
where one single token can be used for

128
00:05:01,280 --> 00:05:03,680
any key for the same keyword across any

129
00:05:03,680 --> 00:05:05,680
number of documents

130
00:05:05,680 --> 00:05:08,000
okay so we have the setting where the

131
00:05:08,000 --> 00:05:09,759
user has two devices a phone and a

132
00:05:09,759 --> 00:05:11,919
desktop the desktop is really powerful

133
00:05:11,919 --> 00:05:14,720
but in sector so what i do is i use the

134
00:05:14,720 --> 00:05:16,720
desktop to actually handle sensitive

135
00:05:16,720 --> 00:05:18,400
documents and i index it separately and

136
00:05:18,400 --> 00:05:20,240
then i really remove the data because i

137
00:05:20,240 --> 00:05:22,560
can't leave it sitting so as long as i

138
00:05:22,560 --> 00:05:24,479
have control over it i can trust that

139
00:05:24,479 --> 00:05:27,840
it's not corrupted and then if i want to

140
00:05:27,840 --> 00:05:29,360
uh use uh

141
00:05:29,360 --> 00:05:31,840
the index to search on the index i need

142
00:05:31,840 --> 00:05:33,600
the phone to authorize the search and

143
00:05:33,600 --> 00:05:36,080
security goal as discussed before is

144
00:05:36,080 --> 00:05:38,320
index privacy

145
00:05:38,320 --> 00:05:40,240
and we also want the feature of

146
00:05:40,240 --> 00:05:42,400
delegation that is we want to support

147
00:05:42,400 --> 00:05:44,800
multiple search observers so

148
00:05:44,800 --> 00:05:47,039
we allow an encrypted index that's built

149
00:05:47,039 --> 00:05:49,919
for a particular document d using a

150
00:05:49,919 --> 00:05:52,960
paired secret key

151
00:05:53,600 --> 00:05:55,919
to be actually searched by another

152
00:05:55,919 --> 00:05:58,080
secret key public keypad sk prime pk

153
00:05:58,080 --> 00:06:01,759
prime but without i knowing d

154
00:06:01,759 --> 00:06:04,400
and without modifying e so essentially i

155
00:06:04,400 --> 00:06:07,759
do not want to reinvest effort to create

156
00:06:07,759 --> 00:06:10,720
a new index e prime but i rather i would

157
00:06:10,720 --> 00:06:13,280
still use the same e but i would just

158
00:06:13,280 --> 00:06:15,840
delegate the search process alone

159
00:06:15,840 --> 00:06:16,560
now

160
00:06:16,560 --> 00:06:18,400
this is the setting

161
00:06:18,400 --> 00:06:20,720
uh this is the story that we are telling

162
00:06:20,720 --> 00:06:22,880
this is the motivating application for

163
00:06:22,880 --> 00:06:25,440
which encapsulated search index makes

164
00:06:25,440 --> 00:06:28,000
sense where we have immutable documents

165
00:06:28,000 --> 00:06:29,600
and we want to achieve some linear

166
00:06:29,600 --> 00:06:31,759
search with support for public key

167
00:06:31,759 --> 00:06:34,639
indexing and delegation so more

168
00:06:34,639 --> 00:06:36,240
specifically if you were to look at the

169
00:06:36,240 --> 00:06:39,199
process flow i have a mobile phone that

170
00:06:39,199 --> 00:06:41,199
generates public key secret key keep

171
00:06:41,199 --> 00:06:43,199
secretly for itself and sends public key

172
00:06:43,199 --> 00:06:45,919
to the desktop now the desktop

173
00:06:45,919 --> 00:06:48,319
with access to the public key takes the

174
00:06:48,319 --> 00:06:52,080
document d as input and produces index e

175
00:06:52,080 --> 00:06:55,039
and handles c

176
00:06:55,039 --> 00:06:55,919
okay

177
00:06:55,919 --> 00:06:56,800
and

178
00:06:56,800 --> 00:06:59,360
deletes the data the original document d

179
00:06:59,360 --> 00:07:02,160
so does not have the document d anymore

180
00:07:02,160 --> 00:07:03,919
in its possession

181
00:07:03,919 --> 00:07:05,280
great

182
00:07:05,280 --> 00:07:07,120
so what do we have next

183
00:07:07,120 --> 00:07:09,280
we next want to search

184
00:07:09,280 --> 00:07:11,520
for the keyword w

185
00:07:11,520 --> 00:07:13,039
so all the

186
00:07:13,039 --> 00:07:16,560
desktop needs to do is send the handle c

187
00:07:16,560 --> 00:07:18,960
and the keyword w

188
00:07:18,960 --> 00:07:21,360
so what do i require security wise is

189
00:07:21,360 --> 00:07:23,919
that it's privacy preserving so phone

190
00:07:23,919 --> 00:07:26,880
learns nothing beyond w from c so no c

191
00:07:26,880 --> 00:07:28,960
it knows w there's no other information

192
00:07:28,960 --> 00:07:31,759
that's gained about the index e

193
00:07:31,759 --> 00:07:33,039
and they should hold information

194
00:07:33,039 --> 00:07:34,400
theoretically

195
00:07:34,400 --> 00:07:36,960
now having received this input uh the

196
00:07:36,960 --> 00:07:39,120
phone has the capability to use the

197
00:07:39,120 --> 00:07:41,360
secret key sk and the compact

198
00:07:41,360 --> 00:07:42,639
representation

199
00:07:42,639 --> 00:07:45,840
or the handle c and the word w to

200
00:07:45,840 --> 00:07:48,800
actually produce a top document

201
00:07:48,800 --> 00:07:50,479
sorry a token

202
00:07:50,479 --> 00:07:54,400
zw for the keyword w and to be specific

203
00:07:54,400 --> 00:07:56,879
it's also specific to the index e comma

204
00:07:56,879 --> 00:07:59,360
c for this document so this token is

205
00:07:59,360 --> 00:08:02,479
unique to this document or rather to

206
00:08:02,479 --> 00:08:05,199
this e comma c value

207
00:08:05,199 --> 00:08:08,240
okay and then what i want is the adver

208
00:08:08,240 --> 00:08:11,280
the desktop will now receive zw as input

209
00:08:11,280 --> 00:08:13,520
and we require the desktop to be

210
00:08:13,520 --> 00:08:16,479
empowered with the with the feature for

211
00:08:16,479 --> 00:08:19,360
verifying if zw is correct in form so we

212
00:08:19,360 --> 00:08:21,120
do not want

213
00:08:21,120 --> 00:08:24,160
the desktop to produce wrong output the

214
00:08:24,160 --> 00:08:26,080
most the phone can do is produce a

215
00:08:26,080 --> 00:08:28,800
denial of service attack

216
00:08:28,800 --> 00:08:31,440
and then we also want token privacy or

217
00:08:31,440 --> 00:08:34,320
kia index privacy where i give you a

218
00:08:34,320 --> 00:08:37,039
document i give you a document d and i

219
00:08:37,039 --> 00:08:40,479
produce a token zw for the keyword w in

220
00:08:40,479 --> 00:08:42,080
this document d

221
00:08:42,080 --> 00:08:44,880
then i have no information about w prime

222
00:08:44,880 --> 00:08:46,080
that's not

223
00:08:46,080 --> 00:08:47,120
uh

224
00:08:47,120 --> 00:08:49,279
that's different from w but is present

225
00:08:49,279 --> 00:08:52,399
in the document d but also for the same

226
00:08:52,399 --> 00:08:55,600
w that occurs in any other document

227
00:08:55,600 --> 00:08:57,680
so in both these counts we critically

228
00:08:57,680 --> 00:09:00,399
require uh privacy

229
00:09:00,399 --> 00:09:03,440
and finally the feature that we desire

230
00:09:03,440 --> 00:09:05,279
is that the same public key secret key

231
00:09:05,279 --> 00:09:07,440
pair can be used for different documents

232
00:09:07,440 --> 00:09:09,519
so e comma c is essentially unique to a

233
00:09:09,519 --> 00:09:12,000
document d so i can use it to compute e

234
00:09:12,000 --> 00:09:13,600
prime comma c prime for a document d

235
00:09:13,600 --> 00:09:15,519
prime and so on and so forth now the

236
00:09:15,519 --> 00:09:17,920
most important feature is that there is

237
00:09:17,920 --> 00:09:19,680
communication that's happening between

238
00:09:19,680 --> 00:09:21,040
the desktop

239
00:09:21,040 --> 00:09:23,600
and the phone and we require

240
00:09:23,600 --> 00:09:26,240
that this communication for the search

241
00:09:26,240 --> 00:09:28,000
procedure between the desktop and the

242
00:09:28,000 --> 00:09:31,200
phone should be constant so critically

243
00:09:31,200 --> 00:09:33,839
note that i said only c and w which are

244
00:09:33,839 --> 00:09:36,560
constant in size and not the entire

245
00:09:36,560 --> 00:09:39,200
index e because e can be as large as the

246
00:09:39,200 --> 00:09:41,440
number of keywords in a document

247
00:09:41,440 --> 00:09:43,839
now these are the

248
00:09:43,839 --> 00:09:46,080
required properties and the required

249
00:09:46,080 --> 00:09:48,640
process flow but and the formal syntax

250
00:09:48,640 --> 00:09:50,399
is as seen here and i have a gen

251
00:09:50,399 --> 00:09:52,080
algorithm that will generate public key

252
00:09:52,080 --> 00:09:54,240
secret key and the index algorithm that

253
00:09:54,240 --> 00:09:56,399
will actually produce the encrypted

254
00:09:56,399 --> 00:10:00,000
index uh e and a compact representation

255
00:10:00,000 --> 00:10:01,839
or a handle c

256
00:10:01,839 --> 00:10:04,399
so it is useful for us to split this

257
00:10:04,399 --> 00:10:06,399
index procedure as two sub algorithms

258
00:10:06,399 --> 00:10:08,399
one is called the prep algorithm or the

259
00:10:08,399 --> 00:10:10,560
prepared algorithm which takes us input

260
00:10:10,560 --> 00:10:14,320
p k and produces s and c think of s as a

261
00:10:14,320 --> 00:10:16,959
trap door and c as the handle and build

262
00:10:16,959 --> 00:10:19,279
index will take this trap doe and the

263
00:10:19,279 --> 00:10:21,760
original document d to produce e

264
00:10:21,760 --> 00:10:24,560
and here the e is the index for d and c

265
00:10:24,560 --> 00:10:26,800
is some compact representation which is

266
00:10:26,800 --> 00:10:28,800
the only thing that needs to be sent for

267
00:10:28,800 --> 00:10:31,279
the search approver to uh provide a

268
00:10:31,279 --> 00:10:32,480
token

269
00:10:32,480 --> 00:10:35,279
now a search process will take as album

270
00:10:35,279 --> 00:10:38,000
will take us input the secret key the e

271
00:10:38,000 --> 00:10:40,640
prime comma c prime and the keyword w

272
00:10:40,640 --> 00:10:43,120
and produces a bit that's either 0 or 1

273
00:10:43,120 --> 00:10:45,680
indicating if w was actually present in

274
00:10:45,680 --> 00:10:48,079
document d prime for which e prime and c

275
00:10:48,079 --> 00:10:50,160
prime are the index and the compact

276
00:10:50,160 --> 00:10:52,959
representation again for simplicity we

277
00:10:52,959 --> 00:10:54,560
have taken a modular approach in

278
00:10:54,560 --> 00:10:56,800
defining algorithms uh where we have

279
00:10:56,800 --> 00:10:58,720
split the search procedure into three

280
00:10:58,720 --> 00:11:01,839
sub procedures now this is not important

281
00:11:01,839 --> 00:11:04,560
but the important part here is that we

282
00:11:04,560 --> 00:11:06,000
achieve privacy preserving

283
00:11:06,000 --> 00:11:07,519
unconditionally

284
00:11:07,519 --> 00:11:10,000
and that is a feature of separating the

285
00:11:10,000 --> 00:11:12,480
index algorithm to two sub algorithms

286
00:11:12,480 --> 00:11:15,200
the prepared and the build index and the

287
00:11:15,200 --> 00:11:17,360
c that is produced the compact handle

288
00:11:17,360 --> 00:11:20,000
that is produced uh is independent of

289
00:11:20,000 --> 00:11:21,279
the document d

290
00:11:21,279 --> 00:11:22,959
so therefore even if i give you the

291
00:11:22,959 --> 00:11:26,160
secret key d naught and d one

292
00:11:26,160 --> 00:11:29,040
i will not be able to determine uh which

293
00:11:29,040 --> 00:11:31,839
of the two documents uh was encrypt was

294
00:11:31,839 --> 00:11:33,279
indexed

295
00:11:33,279 --> 00:11:35,920
and um that is the key part here where

296
00:11:35,920 --> 00:11:37,360
we achieve privacy preserving

297
00:11:37,360 --> 00:11:39,279
unconditionally uh and holds in

298
00:11:39,279 --> 00:11:41,839
information theoretically

299
00:11:41,839 --> 00:11:44,640
this is all great how do we go about

300
00:11:44,640 --> 00:11:46,399
instantiating or implementing this

301
00:11:46,399 --> 00:11:47,440
primitive

302
00:11:47,440 --> 00:11:49,279
now there is a naive solution there

303
00:11:49,279 --> 00:11:50,959
which achieves both public key and

304
00:11:50,959 --> 00:11:52,320
sublinear search and this is the

305
00:11:52,320 --> 00:11:53,760
solution there

306
00:11:53,760 --> 00:11:55,600
whereas it does not offer all of the

307
00:11:55,600 --> 00:11:57,120
features but it's a very useful

308
00:11:57,120 --> 00:11:59,279
launchpad for the rest of the

309
00:11:59,279 --> 00:12:01,279
talk how we come up with better

310
00:12:01,279 --> 00:12:02,800
primitives that achieves all the

311
00:12:02,800 --> 00:12:04,880
features that we want specifically that

312
00:12:04,880 --> 00:12:06,240
we have the phone and we have the

313
00:12:06,240 --> 00:12:07,760
desktop as before

314
00:12:07,760 --> 00:12:09,839
the phone basically generate runs the

315
00:12:09,839 --> 00:12:12,800
cca gen algorithm so think of cca there

316
00:12:12,800 --> 00:12:15,839
is a cca secure um encryption algorithm

317
00:12:15,839 --> 00:12:17,760
it generally runs the gen algorithm for

318
00:12:17,760 --> 00:12:20,560
this and produces public key secret key

319
00:12:20,560 --> 00:12:22,399
keep secret key for itself and sends

320
00:12:22,399 --> 00:12:26,240
public key to the desktop the desktop

321
00:12:26,240 --> 00:12:28,959
now runs the gen algorithm for a pseudo

322
00:12:28,959 --> 00:12:31,120
random function so it produces absolute

323
00:12:31,120 --> 00:12:33,839
random function key okay

324
00:12:33,839 --> 00:12:37,040
and now for each keyword in the document

325
00:12:37,040 --> 00:12:40,800
d it produces a token by running uh eval

326
00:12:40,800 --> 00:12:44,639
of this prf on the key k and on this

327
00:12:44,639 --> 00:12:46,480
input w

328
00:12:46,480 --> 00:12:49,760
and then it creates a set uh or a

329
00:12:49,760 --> 00:12:52,560
an array of all of these keywords

330
00:12:52,560 --> 00:12:54,160
uh sorry all of these tokens for all of

331
00:12:54,160 --> 00:12:56,399
these keywords and then i will just

332
00:12:56,399 --> 00:12:59,040
build an increment index by combining y

333
00:12:59,040 --> 00:13:01,680
with some sublinear dictionary so say

334
00:13:01,680 --> 00:13:03,040
think of it as a bloom filter or a

335
00:13:03,040 --> 00:13:04,480
balanced search tree in which i insert

336
00:13:04,480 --> 00:13:05,440
values

337
00:13:05,440 --> 00:13:08,320
um and then

338
00:13:08,320 --> 00:13:09,519
and then

339
00:13:09,519 --> 00:13:12,160
it runs the scca encryption algorithm to

340
00:13:12,160 --> 00:13:15,200
actually encrypt the prftk

341
00:13:15,200 --> 00:13:16,959
and to produce a compact handle or

342
00:13:16,959 --> 00:13:20,959
representation c and it deletes k

343
00:13:20,959 --> 00:13:23,680
okay so at the end

344
00:13:23,680 --> 00:13:26,079
and also deletes the document d at the

345
00:13:26,079 --> 00:13:27,200
end the desktop is left with the

346
00:13:27,200 --> 00:13:29,519
encrypted index e and the

347
00:13:29,519 --> 00:13:31,839
uh handle c for the cipher text c in

348
00:13:31,839 --> 00:13:32,880
this case

349
00:13:32,880 --> 00:13:34,560
and whenever it wants to search it will

350
00:13:34,560 --> 00:13:37,680
just send c and w as before

351
00:13:37,680 --> 00:13:39,440
now the phone with knowledge of the

352
00:13:39,440 --> 00:13:41,279
secret key can actually decrypt the

353
00:13:41,279 --> 00:13:43,920
ciphertext c to get recover the pr key k

354
00:13:43,920 --> 00:13:46,959
and then simply run the prp val function

355
00:13:46,959 --> 00:13:51,279
to get z w and send zw to the desktop

356
00:13:51,279 --> 00:13:53,199
recall that we want the feature where

357
00:13:53,199 --> 00:13:55,600
verifiability was required wherein we

358
00:13:55,600 --> 00:13:57,440
wanted to make sure that zw could be

359
00:13:57,440 --> 00:13:59,760
verified that it was correctly formed so

360
00:13:59,760 --> 00:14:02,079
all we do is replace prf to the vrf and

361
00:14:02,079 --> 00:14:03,680
we are still golden

362
00:14:03,680 --> 00:14:05,040
however

363
00:14:05,040 --> 00:14:06,959
that does not have support for

364
00:14:06,959 --> 00:14:08,639
distribution and delegation which were

365
00:14:08,639 --> 00:14:10,959
two key properties that we wanted and

366
00:14:10,959 --> 00:14:13,920
for completely different reasons these

367
00:14:13,920 --> 00:14:16,880
properties are not uh offered by this

368
00:14:16,880 --> 00:14:19,920
naive scheme and we refer you to uh our

369
00:14:19,920 --> 00:14:22,000
full version of this paper

370
00:14:22,000 --> 00:14:23,680
sorry the full version of the paper and

371
00:14:23,680 --> 00:14:26,000
also actually our conference uh sub

372
00:14:26,000 --> 00:14:28,800
proceedings to actually read about why

373
00:14:28,800 --> 00:14:30,480
this is true

374
00:14:30,480 --> 00:14:33,360
however we have a good framework on

375
00:14:33,360 --> 00:14:35,279
which we can build it so it's almost

376
00:14:35,279 --> 00:14:37,279
seems like the night this the the

377
00:14:37,279 --> 00:14:39,440
procedure to follow when we are creating

378
00:14:39,440 --> 00:14:42,000
a construction of this esi is as follows

379
00:14:42,000 --> 00:14:44,320
right we will index w by computing a

380
00:14:44,320 --> 00:14:46,639
pseudo random function on w so and when

381
00:14:46,639 --> 00:14:48,000
we store the value in a sublingual

382
00:14:48,000 --> 00:14:50,160
search dictionary because we have public

383
00:14:50,160 --> 00:14:51,920
key setting we almost need two different

384
00:14:51,920 --> 00:14:54,320
ways to compute this prf value

385
00:14:54,320 --> 00:14:56,399
and we need a consistency check which

386
00:14:56,399 --> 00:14:58,240
means that we need some kind of a vrf

387
00:14:58,240 --> 00:15:00,240
not a prf so we introduce this new

388
00:15:00,240 --> 00:15:02,399
primitive called encapsulated verifiable

389
00:15:02,399 --> 00:15:03,839
random function

390
00:15:03,839 --> 00:15:05,760
and this primitive has support for

391
00:15:05,760 --> 00:15:07,279
delegation and distribution and that's

392
00:15:07,279 --> 00:15:09,360
the key point here whereas the naive

393
00:15:09,360 --> 00:15:11,839
scheme does not have the easter support

394
00:15:11,839 --> 00:15:14,320
so what is the syntax of edre think

395
00:15:14,320 --> 00:15:17,199
alice think bob alice has public key

396
00:15:17,199 --> 00:15:19,120
secret key generated communicates public

397
00:15:19,120 --> 00:15:20,320
key to bob

398
00:15:20,320 --> 00:15:22,720
now bob has the power to run this

399
00:15:22,720 --> 00:15:24,959
encapsulation algorithm

400
00:15:24,959 --> 00:15:27,600
simply which is a randomized algorithm

401
00:15:27,600 --> 00:15:30,480
which takes us into public key pk and

402
00:15:30,480 --> 00:15:32,240
produces a trap door t and the

403
00:15:32,240 --> 00:15:34,240
ciphertext c

404
00:15:34,240 --> 00:15:36,560
so now it communicates

405
00:15:36,560 --> 00:15:39,519
the ciphertext c to alice and keeps

406
00:15:39,519 --> 00:15:41,279
trapdoor for itself

407
00:15:41,279 --> 00:15:43,199
so now alice wants to

408
00:15:43,199 --> 00:15:46,880
compute the evr value on an input x so

409
00:15:46,880 --> 00:15:49,680
what does it do it takes a cipher text c

410
00:15:49,680 --> 00:15:51,120
takes the eval

411
00:15:51,120 --> 00:15:53,920
takes the input x and uses a secret key

412
00:15:53,920 --> 00:15:58,880
to produce this value y y is evr f of x

413
00:15:58,880 --> 00:16:01,680
uh concurrently what bob can do is bob

414
00:16:01,680 --> 00:16:03,920
has this algorithm called comp which

415
00:16:03,920 --> 00:16:07,199
will take input x and the trap dot t to

416
00:16:07,199 --> 00:16:09,680
produce the same exact value

417
00:16:09,680 --> 00:16:12,240
so essentially we have produced a map

418
00:16:12,240 --> 00:16:15,040
for alice and bob to generate the same

419
00:16:15,040 --> 00:16:18,000
value y which is evr of x using two

420
00:16:18,000 --> 00:16:20,240
completely different ways

421
00:16:20,240 --> 00:16:22,560
and there's just the communication of

422
00:16:22,560 --> 00:16:24,560
just the c

423
00:16:24,560 --> 00:16:27,600
okay so what is the security requirement

424
00:16:27,600 --> 00:16:28,880
think

425
00:16:28,880 --> 00:16:31,680
challenger think adversary challenger

426
00:16:31,680 --> 00:16:34,480
guns is typical uh gen algorithm but in

427
00:16:34,480 --> 00:16:36,240
addition it also runs the end cap

428
00:16:36,240 --> 00:16:39,040
algorithm which is the encapsulation

429
00:16:39,040 --> 00:16:41,680
procedure to produce a ciphertext c and

430
00:16:41,680 --> 00:16:44,160
the uh trapdoor t

431
00:16:44,160 --> 00:16:47,360
it communicates p k and c to the uh

432
00:16:47,360 --> 00:16:50,480
adversary and keeps b s k and t for

433
00:16:50,480 --> 00:16:52,720
itself now the adversary has access to

434
00:16:52,720 --> 00:16:55,360
this eval oracle

435
00:16:55,360 --> 00:16:58,000
okay where it can make queries on inputs

436
00:16:58,000 --> 00:17:00,880
c prime comma x and it receives as

437
00:17:00,880 --> 00:17:05,599
response the e val on c prime and x

438
00:17:05,599 --> 00:17:07,839
and then finally communicates a

439
00:17:07,839 --> 00:17:09,039
challenge

440
00:17:09,039 --> 00:17:09,839
um

441
00:17:09,839 --> 00:17:11,439
input x star

442
00:17:11,439 --> 00:17:12,799
now the

443
00:17:12,799 --> 00:17:14,799
the challenger does the standard

444
00:17:14,799 --> 00:17:17,039
indistinguishability game by computing

445
00:17:17,039 --> 00:17:18,959
uh um

446
00:17:18,959 --> 00:17:22,079
why not by using the secret psk and the

447
00:17:22,079 --> 00:17:24,000
trapdoor about just the actual the

448
00:17:24,000 --> 00:17:26,720
secret key sk is sufficient um

449
00:17:26,720 --> 00:17:28,959
um

450
00:17:29,600 --> 00:17:31,600
sorry actually doesn't even

451
00:17:31,600 --> 00:17:33,039
my bad

452
00:17:33,039 --> 00:17:35,280
runs this y naught and y one it computes

453
00:17:35,280 --> 00:17:37,440
these two values and then communicates y

454
00:17:37,440 --> 00:17:39,760
underscore b to the adversary

455
00:17:39,760 --> 00:17:41,280
brilliant and the adversary responds

456
00:17:41,280 --> 00:17:43,200
with b prime and wins if b prime is

457
00:17:43,200 --> 00:17:44,480
equal to b

458
00:17:44,480 --> 00:17:46,640
okay this is a simple setting and to

459
00:17:46,640 --> 00:17:48,720
prevent meaning to prevent trivial

460
00:17:48,720 --> 00:17:50,960
attacks we require that c and x star was

461
00:17:50,960 --> 00:17:54,640
never queried by the adversary

462
00:17:54,640 --> 00:17:57,039
and now let us look at the construction

463
00:17:57,039 --> 00:17:59,520
right we have alice we have bob alice

464
00:17:59,520 --> 00:18:00,720
basically

465
00:18:00,720 --> 00:18:03,360
picks some random element a and computer

466
00:18:03,360 --> 00:18:06,000
and computes g to the a as the public

467
00:18:06,000 --> 00:18:06,880
key

468
00:18:06,880 --> 00:18:08,160
uh

469
00:18:08,160 --> 00:18:09,840
bob on the other hand runs this end cap

470
00:18:09,840 --> 00:18:11,120
procedure and communicates the

471
00:18:11,120 --> 00:18:13,200
ciphertext as in here

472
00:18:13,200 --> 00:18:14,320
and then

473
00:18:14,320 --> 00:18:16,799
it keeps the trapdoor for itself now

474
00:18:16,799 --> 00:18:19,760
alice can communicate compute y in this

475
00:18:19,760 --> 00:18:23,760
manner basically takes input e f h comma

476
00:18:23,760 --> 00:18:26,880
h of c comma x raised to the a comma c

477
00:18:26,880 --> 00:18:29,200
because it knows the a value and

478
00:18:29,200 --> 00:18:31,520
correspondingly it does the

479
00:18:31,520 --> 00:18:34,080
bob can do it by using the trap door

480
00:18:34,080 --> 00:18:36,000
which where it has the powerful element

481
00:18:36,000 --> 00:18:38,080
s which is nothing but a to the r or g

482
00:18:38,080 --> 00:18:39,679
to the ar

483
00:18:39,679 --> 00:18:40,960
so essentially

484
00:18:40,960 --> 00:18:43,760
a to a r will come as exponent outside

485
00:18:43,760 --> 00:18:46,160
and the same value is hash because c is

486
00:18:46,160 --> 00:18:47,919
equal to r

487
00:18:47,919 --> 00:18:49,919
this is a simple construction we can

488
00:18:49,919 --> 00:18:51,679
prove that this is secure under the bddh

489
00:18:51,679 --> 00:18:54,720
assumption in the random oracle model

490
00:18:54,720 --> 00:18:56,480
okay so now

491
00:18:56,480 --> 00:18:58,960
all we have seen is we have made a case

492
00:18:58,960 --> 00:19:01,120
that avrf is a primitive it's a useful

493
00:19:01,120 --> 00:19:03,360
primitive and we have shown that is a

494
00:19:03,360 --> 00:19:05,440
construction possible now let's see how

495
00:19:05,440 --> 00:19:08,080
to build this esi in a genetic fashion

496
00:19:08,080 --> 00:19:09,760
so the keygen algorithm is merely

497
00:19:09,760 --> 00:19:12,480
running the evr of keychain algorithm

498
00:19:12,480 --> 00:19:15,440
and then the index procedure runs the

499
00:19:15,440 --> 00:19:18,080
end cap to actually compute c comma t

500
00:19:18,080 --> 00:19:19,919
and the indexing the remaining indexing

501
00:19:19,919 --> 00:19:22,480
procedure is very similar to the naive

502
00:19:22,480 --> 00:19:24,160
solution except that instead of running

503
00:19:24,160 --> 00:19:26,080
prf.eval

504
00:19:26,080 --> 00:19:29,120
it will run evrf.com

505
00:19:29,120 --> 00:19:31,039
and then runs the data structure build

506
00:19:31,039 --> 00:19:33,760
algorithm to produce an index e and then

507
00:19:33,760 --> 00:19:35,840
returns e and c

508
00:19:35,840 --> 00:19:38,480
now the search procedure will simply do

509
00:19:38,480 --> 00:19:41,200
the same thing as uh what we saw before

510
00:19:41,200 --> 00:19:44,640
instead of running evr dot eval by first

511
00:19:44,640 --> 00:19:46,160
decrypting and then running the

512
00:19:46,160 --> 00:19:49,280
evaluator just run eval on sk and c and

513
00:19:49,280 --> 00:19:52,240
then run the ds.find algorithm now the

514
00:19:52,240 --> 00:19:54,400
beautiful part here is that we our

515
00:19:54,400 --> 00:19:56,559
composition result here will inherit the

516
00:19:56,559 --> 00:19:57,760
properties of distribution and

517
00:19:57,760 --> 00:20:00,000
delegation from the ebrf and we formally

518
00:20:00,000 --> 00:20:02,640
prove it in the paper so what do we get

519
00:20:02,640 --> 00:20:05,600
out of all of this we get threshold esi

520
00:20:05,600 --> 00:20:06,960
which achieves distributed token

521
00:20:06,960 --> 00:20:08,960
generation in a non-interactive manner

522
00:20:08,960 --> 00:20:11,280
so we take our standard ebrf and throw

523
00:20:11,280 --> 00:20:13,600
verifiable secret sharing and swami's

524
00:20:13,600 --> 00:20:15,840
secret sharing and the scheme is secure

525
00:20:15,840 --> 00:20:17,600
under the bddh assumption

526
00:20:17,600 --> 00:20:19,760
now are the more important feature that

527
00:20:19,760 --> 00:20:21,600
we want to present or delegate where i

528
00:20:21,600 --> 00:20:23,760
can take uh search approval one can

529
00:20:23,760 --> 00:20:25,360
delegate the search process to a search

530
00:20:25,360 --> 00:20:27,360
up to without having to recreate the

531
00:20:27,360 --> 00:20:30,080
index so we have this delegate algorithm

532
00:20:30,080 --> 00:20:33,360
that takes us input c1 sk1 and produces

533
00:20:33,360 --> 00:20:36,720
sk2 and c2 sorry also secret key of the

534
00:20:36,720 --> 00:20:40,159
intended recipient sk2 and to produce a

535
00:20:40,159 --> 00:20:42,880
handle or a representation c2 so this is

536
00:20:42,880 --> 00:20:45,440
not recreating the index but simply

537
00:20:45,440 --> 00:20:47,280
modifying the ciphertext or the handle

538
00:20:47,280 --> 00:20:49,440
alone and the verification procedure

539
00:20:49,440 --> 00:20:51,360
will either will verify if this

540
00:20:51,360 --> 00:20:52,960
delegation procedure has happened

541
00:20:52,960 --> 00:20:54,640
correctly

542
00:20:54,640 --> 00:20:57,440
now as we saw before uh or rather as we

543
00:20:57,440 --> 00:20:59,840
stated before delegatable esi can be

544
00:20:59,840 --> 00:21:02,559
built uh from delegatable erf it had its

545
00:21:02,559 --> 00:21:04,720
the properties so let's look at building

546
00:21:04,720 --> 00:21:07,440
a delegatable evr there so what do we

547
00:21:07,440 --> 00:21:09,600
want is again the search it's approval

548
00:21:09,600 --> 00:21:11,919
one somehow we can delegate the process

549
00:21:11,919 --> 00:21:14,080
so instead it will take ciphertext c1

550
00:21:14,080 --> 00:21:15,840
and c2 and the correctness of the

551
00:21:15,840 --> 00:21:18,240
delegation requires that for every

552
00:21:18,240 --> 00:21:19,840
single input the eval function is

553
00:21:19,840 --> 00:21:22,720
correct essentially and same is a useful

554
00:21:22,720 --> 00:21:24,720
algorithm that we will define which will

555
00:21:24,720 --> 00:21:26,799
return 1 if this correctness of

556
00:21:26,799 --> 00:21:30,000
delegation passes if pk1 c1 pk to c2 is

557
00:21:30,000 --> 00:21:31,919
given it is one if and only if the

558
00:21:31,919 --> 00:21:34,400
correctness of delegation passes

559
00:21:34,400 --> 00:21:35,360
okay

560
00:21:35,360 --> 00:21:36,880
so now

561
00:21:36,880 --> 00:21:39,280
and now i've done all of this but i want

562
00:21:39,280 --> 00:21:41,360
to now discuss how do we actually build

563
00:21:41,360 --> 00:21:43,679
this delegatable vdrf at least the basic

564
00:21:43,679 --> 00:21:44,559
thing

565
00:21:44,559 --> 00:21:47,760
okay so recall that we have

566
00:21:47,760 --> 00:21:50,559
um this has the standard evr

567
00:21:50,559 --> 00:21:51,760
construction

568
00:21:51,760 --> 00:21:54,159
okay and then i mean i've i've taken the

569
00:21:54,159 --> 00:21:55,760
the diagrammatic representation and put

570
00:21:55,760 --> 00:21:57,120
it

571
00:21:57,120 --> 00:21:57,600
of on a

572
00:21:57,600 --> 00:22:00,400
textual format okay now the key idea

573
00:22:00,400 --> 00:22:02,000
here is

574
00:22:02,000 --> 00:22:04,480
separate the r so i'm using this r twice

575
00:22:04,480 --> 00:22:06,480
here so i'm once i'm using it to hash

576
00:22:06,480 --> 00:22:08,480
the value and once i'm using it as a

577
00:22:08,480 --> 00:22:11,200
parameter for the bilinear map so let me

578
00:22:11,200 --> 00:22:13,200
see i wanted to separate the two process

579
00:22:13,200 --> 00:22:15,840
out okay so how do i do it

580
00:22:15,840 --> 00:22:18,400
i introduce this new term called d is

581
00:22:18,400 --> 00:22:20,080
equal to g to the r so essentially r is

582
00:22:20,080 --> 00:22:23,200
equal to d is equal to g to the r

583
00:22:23,200 --> 00:22:24,000
okay

584
00:22:24,000 --> 00:22:26,480
and i will also include

585
00:22:26,480 --> 00:22:29,760
the public key and this value d in c and

586
00:22:29,760 --> 00:22:31,679
t so this is the

587
00:22:31,679 --> 00:22:33,679
new definition and the delegate

588
00:22:33,679 --> 00:22:35,120
algorithm is this

589
00:22:35,120 --> 00:22:39,760
okay basically does a comma r comma d1

590
00:22:39,760 --> 00:22:42,480
raised to the a1 over a2 so a1 over a2

591
00:22:42,480 --> 00:22:45,440
think of it is basically a1 a2 inverse

592
00:22:45,440 --> 00:22:48,720
mod of b1 or mod of b basically the

593
00:22:48,720 --> 00:22:50,320
um the

594
00:22:50,320 --> 00:22:51,520
the prime order group that we are

595
00:22:51,520 --> 00:22:54,080
working with

596
00:22:54,080 --> 00:22:55,679
and

597
00:22:55,679 --> 00:22:59,039
a can now generate however this new

598
00:22:59,039 --> 00:23:02,080
ciphertext c prime as a squared comma r

599
00:23:02,080 --> 00:23:03,840
comma r squared if i see this i just

600
00:23:03,840 --> 00:23:05,280
need to spare it it's all public

601
00:23:05,280 --> 00:23:06,559
information

602
00:23:06,559 --> 00:23:07,440
now

603
00:23:07,440 --> 00:23:08,880
note that

604
00:23:08,880 --> 00:23:10,799
the minute this happens

605
00:23:10,799 --> 00:23:13,600
i can now query eval on

606
00:23:13,600 --> 00:23:17,039
this value c prime and x star and

607
00:23:17,039 --> 00:23:18,400
every check will pass right it will

608
00:23:18,400 --> 00:23:20,320
produce the correct result and

609
00:23:20,320 --> 00:23:22,400
unfortunately we need to prevent this so

610
00:23:22,400 --> 00:23:25,200
the way out is to basically throw in the

611
00:23:25,200 --> 00:23:28,000
public key that you also get also inside

612
00:23:28,000 --> 00:23:30,720
the hash function

613
00:23:30,720 --> 00:23:32,320
okay so that's the key thing here that

614
00:23:32,320 --> 00:23:34,400
public key also becomes a part of the

615
00:23:34,400 --> 00:23:37,679
hash value here that's computed

616
00:23:37,679 --> 00:23:38,559
okay

617
00:23:38,559 --> 00:23:40,559
and then so we have the delegate

618
00:23:40,559 --> 00:23:42,159
algorithm here

619
00:23:42,159 --> 00:23:44,080
and what's the next thing that we need

620
00:23:44,080 --> 00:23:47,120
to do we will throw in this additional

621
00:23:47,120 --> 00:23:48,159
check

622
00:23:48,159 --> 00:23:50,720
okay so what we want to make sure is to

623
00:23:50,720 --> 00:23:51,919
see if

624
00:23:51,919 --> 00:23:55,919
um this is essentially holds true that

625
00:23:55,919 --> 00:23:58,799
the component that we get from pk and

626
00:23:58,799 --> 00:24:00,640
the component we get from c prime are

627
00:24:00,640 --> 00:24:04,080
consistent with each other are correct

628
00:24:04,080 --> 00:24:06,320
then this is trivially true

629
00:24:06,320 --> 00:24:08,000
when i've not modified it when i have

630
00:24:08,000 --> 00:24:10,159
not done any delegation

631
00:24:10,159 --> 00:24:12,480
otherwise d prime is uniquely determined

632
00:24:12,480 --> 00:24:15,679
by a prime r prime and a

633
00:24:15,679 --> 00:24:18,320
and because the check passes right and

634
00:24:18,320 --> 00:24:20,320
the reason why this big exposition is

635
00:24:20,320 --> 00:24:21,919
that

636
00:24:21,919 --> 00:24:23,679
it's okay to not include d prime in the

637
00:24:23,679 --> 00:24:26,159
hash because we have done a prime we

638
00:24:26,159 --> 00:24:28,159
have done r prime in the hash but we are

639
00:24:28,159 --> 00:24:30,159
not including d prime but it's fine

640
00:24:30,159 --> 00:24:33,440
because this check passes and a prime r

641
00:24:33,440 --> 00:24:35,200
prime and a will therefore uniquely

642
00:24:35,200 --> 00:24:37,440
determine d prime so it's fine to not

643
00:24:37,440 --> 00:24:39,279
included it's fine to not

644
00:24:39,279 --> 00:24:43,200
verify that that is correct finally okay

645
00:24:43,200 --> 00:24:45,279
and the final point here is about the

646
00:24:45,279 --> 00:24:46,880
same function

647
00:24:46,880 --> 00:24:48,640
because we needed the same procedure

648
00:24:48,640 --> 00:24:49,520
right

649
00:24:49,520 --> 00:24:51,919
so these are the terms so pk1 is nothing

650
00:24:51,919 --> 00:24:55,360
but g comma a1 pk2 is g comma a2 and

651
00:24:55,360 --> 00:24:57,520
these are c1 and c2 right they are

652
00:24:57,520 --> 00:24:59,840
different a r and d one and this is some

653
00:24:59,840 --> 00:25:02,320
a prime r prime and 2 2

654
00:25:02,320 --> 00:25:05,600
if i were honestly delegated okay the

655
00:25:05,600 --> 00:25:07,600
first two terms will be the same so if a

656
00:25:07,600 --> 00:25:09,679
comma r and a prime comma r prime are

657
00:25:09,679 --> 00:25:11,679
the same then it was honestly delegated

658
00:25:11,679 --> 00:25:13,840
so i know that they will produce the

659
00:25:13,840 --> 00:25:16,000
same results the delegation is correct

660
00:25:16,000 --> 00:25:17,120
therefore it will produce the same

661
00:25:17,120 --> 00:25:18,240
results

662
00:25:18,240 --> 00:25:19,039
now

663
00:25:19,039 --> 00:25:22,720
if a e of a1 comma d1 a1 is the public

664
00:25:22,720 --> 00:25:24,799
key that we are dealing with and a2 is a

665
00:25:24,799 --> 00:25:27,440
publicated variable here if this value

666
00:25:27,440 --> 00:25:29,919
holds again we know that the eval

667
00:25:29,919 --> 00:25:31,520
function will produce the correct result

668
00:25:31,520 --> 00:25:33,360
it can be mathematically verified and we

669
00:25:33,360 --> 00:25:36,240
verify it in the paper but the key point

670
00:25:36,240 --> 00:25:38,559
here is that the same procedure will

671
00:25:38,559 --> 00:25:39,840
work like this

672
00:25:39,840 --> 00:25:43,120
if these two checks passes then i will

673
00:25:43,120 --> 00:25:45,200
return one

674
00:25:45,200 --> 00:25:47,440
okay and this is a basic delegateable

675
00:25:47,440 --> 00:25:50,240
pdrf and here we only enough for honest

676
00:25:50,240 --> 00:25:52,240
collocation which means that the

677
00:25:52,240 --> 00:25:55,440
adversary can only delegate

678
00:25:55,440 --> 00:25:57,919
uh to a secret key or a party whose

679
00:25:57,919 --> 00:26:00,000
secret key does not know and this is

680
00:26:00,000 --> 00:26:02,000
secure under the bdth

681
00:26:02,000 --> 00:26:04,960
now i can take this and i can also allow

682
00:26:04,960 --> 00:26:07,520
for a little bit of corruption okay what

683
00:26:07,520 --> 00:26:09,120
do i mean by a little bit of corruption

684
00:26:09,120 --> 00:26:14,158
is now i can specify sk2

685
00:26:14,400 --> 00:26:17,520
okay i can specify sk2 and

686
00:26:17,520 --> 00:26:19,360
we prove that the same construction we

687
00:26:19,360 --> 00:26:21,440
have some further extensions which will

688
00:26:21,440 --> 00:26:23,520
also support this extension and it's

689
00:26:23,520 --> 00:26:26,960
secure under bdh pdth both in and out

690
00:26:26,960 --> 00:26:30,480
delegation so now i can specify sk1 and

691
00:26:30,480 --> 00:26:33,679
ask to uh get sk2 or i can produce sk2

692
00:26:33,679 --> 00:26:37,039
and ask to an honest sk1 both of these

693
00:26:37,039 --> 00:26:39,520
are possible and we unfortunately we can

694
00:26:39,520 --> 00:26:42,320
only prove it to be secure in a very

695
00:26:42,320 --> 00:26:45,520
strong model ibd i the interactive bddh

696
00:26:45,520 --> 00:26:47,760
assumption uh unfortunately it's not

697
00:26:47,760 --> 00:26:50,559
well studied so we find try to find a

698
00:26:50,559 --> 00:26:52,080
middle ground which is the one time

699
00:26:52,080 --> 00:26:54,799
thing where only one in delegation there

700
00:26:54,799 --> 00:26:56,400
is allowed but any number of out

701
00:26:56,400 --> 00:26:58,080
delegation and we prove that the

702
00:26:58,080 --> 00:27:00,400
construction is secure under the ebddh

703
00:27:00,400 --> 00:27:01,520
assumption

704
00:27:01,520 --> 00:27:02,320
now

705
00:27:02,320 --> 00:27:04,080
now there's a lot of acronyms here

706
00:27:04,080 --> 00:27:07,360
there's a lot of um settings here but

707
00:27:07,360 --> 00:27:10,159
the key argument here is this right i

708
00:27:10,159 --> 00:27:14,720
can an attacker can simply take a query

709
00:27:14,720 --> 00:27:16,240
that

710
00:27:16,240 --> 00:27:19,279
um take a c that it receives as

711
00:27:19,279 --> 00:27:22,480
challenge and then asks it

712
00:27:22,480 --> 00:27:23,200
to

713
00:27:23,200 --> 00:27:25,200
basically

714
00:27:25,200 --> 00:27:28,240
delegate it honestly to a second party

715
00:27:28,240 --> 00:27:31,200
and then once the c has become c prime

716
00:27:31,200 --> 00:27:33,520
it can run c prime and x star and

717
00:27:33,520 --> 00:27:35,200
because we want it to be delegation

718
00:27:35,200 --> 00:27:38,000
correct this will pass we get the same

719
00:27:38,000 --> 00:27:41,120
value and the correctness is avoided

720
00:27:41,120 --> 00:27:43,840
right we bake the scheme trivially

721
00:27:43,840 --> 00:27:46,240
unfortunately uh i mean the way around

722
00:27:46,240 --> 00:27:48,880
this unfortunately rather is to use the

723
00:27:48,880 --> 00:27:50,480
same procedure and that is why we

724
00:27:50,480 --> 00:27:52,960
require the same procedure critically

725
00:27:52,960 --> 00:27:55,440
which will determine if

726
00:27:55,440 --> 00:27:57,760
the values that i'm playing with will

727
00:27:57,760 --> 00:28:01,200
actually produce the same result

728
00:28:01,200 --> 00:28:04,640
okay now i can do it once i can keep

729
00:28:04,640 --> 00:28:07,039
doing it multiple times at some point of

730
00:28:07,039 --> 00:28:10,640
time i can do it um i need to somehow re

731
00:28:10,640 --> 00:28:12,559
retrace the path and that's why

732
00:28:12,559 --> 00:28:15,120
bi-directional support for

733
00:28:15,120 --> 00:28:18,159
this kind of delegation um is quite you

734
00:28:18,159 --> 00:28:20,240
need some stronger assumptions to prove

735
00:28:20,240 --> 00:28:21,279
secure

736
00:28:21,279 --> 00:28:22,880
you can check the paper for details for

737
00:28:22,880 --> 00:28:25,840
more expansive discussion

738
00:28:25,840 --> 00:28:28,080
so now let's just basically summarize

739
00:28:28,080 --> 00:28:30,159
the talk what have we done here we

740
00:28:30,159 --> 00:28:32,399
introduce this primitive of encapsulated

741
00:28:32,399 --> 00:28:34,000
search index which has all of the

742
00:28:34,000 --> 00:28:36,320
features including the distribution and

743
00:28:36,320 --> 00:28:38,159
delegation

744
00:28:38,159 --> 00:28:39,760
and we also introduce this primitive of

745
00:28:39,760 --> 00:28:41,520
independent interest called encapsulated

746
00:28:41,520 --> 00:28:43,440
verifiable random function which

747
00:28:43,440 --> 00:28:45,520
achieves this computing of prf value

748
00:28:45,520 --> 00:28:47,039
through two different v

749
00:28:47,039 --> 00:28:48,799
through two different ways which can be

750
00:28:48,799 --> 00:28:50,159
done by two different independent

751
00:28:50,159 --> 00:28:51,440
parties

752
00:28:51,440 --> 00:28:52,399
and

753
00:28:52,399 --> 00:28:54,240
i can extend it to the distributed and

754
00:28:54,240 --> 00:28:55,600
delegated setting

755
00:28:55,600 --> 00:28:57,919
the basic version secure under the bddh

756
00:28:57,919 --> 00:29:01,039
assumption in the random oracle model

757
00:29:01,039 --> 00:29:02,480
now

758
00:29:02,480 --> 00:29:04,640
having said all of this i should also

759
00:29:04,640 --> 00:29:05,919
stress that this is commercially

760
00:29:05,919 --> 00:29:07,520
available it's a product that's out

761
00:29:07,520 --> 00:29:10,559
there uh atacama has deployed it cover

762
00:29:10,559 --> 00:29:12,880
in several companies and it's quite

763
00:29:12,880 --> 00:29:15,520
successful so all of this is not purely

764
00:29:15,520 --> 00:29:16,880
theoretical result we also have

765
00:29:16,880 --> 00:29:20,640
practical uh efficiency um guarantees

766
00:29:20,640 --> 00:29:23,120
because it's been deployed and used

767
00:29:23,120 --> 00:29:25,600
uh extensively by the clients and that's

768
00:29:25,600 --> 00:29:28,080
all i have time for you now please thank

769
00:29:28,080 --> 00:29:29,360
you so much for taking the time to see

770
00:29:29,360 --> 00:29:31,039
the full version of this talk i'll take

771
00:29:31,039 --> 00:29:33,200
questions during the live proceedings

772
00:29:33,200 --> 00:29:36,440
thank you

