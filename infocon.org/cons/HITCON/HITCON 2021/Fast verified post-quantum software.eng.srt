1
00:00:00,320 --> 00:00:02,480
known as djb

2
00:00:02,480 --> 00:00:04,400
the inventor of

3
00:00:04,400 --> 00:00:05,440
many

4
00:00:05,440 --> 00:00:07,759
cryptosystems currently used on the

5
00:00:07,759 --> 00:00:09,120
internet

6
00:00:09,120 --> 00:00:10,519
including

7
00:00:10,519 --> 00:00:12,960
2519 and

8
00:00:12,960 --> 00:00:16,960
cha-cha 20 and probably

9
00:00:38,320 --> 00:00:40,120
then

10
00:00:40,120 --> 00:00:41,230
[Music]

11
00:00:41,230 --> 00:00:47,840
[Applause]

12
00:00:47,840 --> 00:00:49,920
this is a talk about cryptographic

13
00:00:49,920 --> 00:00:52,559
software

14
00:00:52,719 --> 00:00:54,879
in case people don't recognize this

15
00:00:54,879 --> 00:00:57,600
picture this is a picture from a movie

16
00:00:57,600 --> 00:00:58,399
called

17
00:00:58,399 --> 00:01:00,160
the blues brothers

18
00:01:00,160 --> 00:01:03,600
now this is a documentary about american

19
00:01:03,600 --> 00:01:04,720
culture

20
00:01:04,720 --> 00:01:06,720
the blues brothers tells you everything

21
00:01:06,720 --> 00:01:09,040
you need to know about the united states

22
00:01:09,040 --> 00:01:11,200
of america and one of the things that

23
00:01:11,200 --> 00:01:12,799
the movie tells you

24
00:01:12,799 --> 00:01:15,200
is that the police

25
00:01:15,200 --> 00:01:18,240
in the united states are not very good

26
00:01:18,240 --> 00:01:19,680
at their jobs

27
00:01:19,680 --> 00:01:22,799
now this is an old movie it's from 1980

28
00:01:22,799 --> 00:01:23,920
but

29
00:01:23,920 --> 00:01:26,320
it's still true today that the police

30
00:01:26,320 --> 00:01:28,880
are not very good at their jobs

31
00:01:28,880 --> 00:01:29,759
now

32
00:01:29,759 --> 00:01:32,240
somebody else that's not very good at

33
00:01:32,240 --> 00:01:33,520
our jobs

34
00:01:33,520 --> 00:01:36,000
is cryptographers doing cryptographic

35
00:01:36,000 --> 00:01:37,520
software

36
00:01:37,520 --> 00:01:39,119
for example

37
00:01:39,119 --> 00:01:42,399
here is some cryptographic software from

38
00:01:42,399 --> 00:01:44,000
microsoft

39
00:01:44,000 --> 00:01:47,759
this is in windows 10. this was a recent

40
00:01:47,759 --> 00:01:49,200
announcement well

41
00:01:49,200 --> 00:01:51,600
not this year it was before the pandemic

42
00:01:51,600 --> 00:01:54,399
actually it was late 2019

43
00:01:54,399 --> 00:01:57,520
and this said that inside simcrypt this

44
00:01:57,520 --> 00:02:00,320
is windows cryptography simcrypt is the

45
00:02:00,320 --> 00:02:02,799
windows cryptographic library

46
00:02:02,799 --> 00:02:06,079
inside simcrypt there was a bug

47
00:02:06,079 --> 00:02:09,199
which allowed anybody to take down any

48
00:02:09,199 --> 00:02:11,840
windows server on the internet

49
00:02:11,840 --> 00:02:14,800
this was a report in forbes magazine it

50
00:02:14,800 --> 00:02:17,520
said it's a bug within simcrip the core

51
00:02:17,520 --> 00:02:20,480
cryptographic library responsible for

52
00:02:20,480 --> 00:02:22,959
implementing symmetric and asymmetric

53
00:02:22,959 --> 00:02:26,720
cryptographic algorithms inside windows

54
00:02:26,720 --> 00:02:27,520
now

55
00:02:27,520 --> 00:02:30,560
if you look at the details of this bug

56
00:02:30,560 --> 00:02:33,599
then what happens inside the bug is a

57
00:02:33,599 --> 00:02:37,200
very simple mathematical computation

58
00:02:37,200 --> 00:02:40,400
it's something that we teach students

59
00:02:40,400 --> 00:02:43,280
in number theory classes it's the

60
00:02:43,280 --> 00:02:45,599
euclidean algorithm

61
00:02:45,599 --> 00:02:47,680
it's actually a slight different

62
00:02:47,680 --> 00:02:50,720
algorithm called the extended euclidean

63
00:02:50,720 --> 00:02:53,599
algorithm but the euclidean algorithm is

64
00:02:53,599 --> 00:02:56,480
computing the greatest common divisor of

65
00:02:56,480 --> 00:02:59,360
two integers you divide one integer by

66
00:02:59,360 --> 00:03:01,519
the other and replace it with the

67
00:03:01,519 --> 00:03:04,159
remainder and then divide this integer

68
00:03:04,159 --> 00:03:06,800
by the next integer etc etc until you

69
00:03:06,800 --> 00:03:08,239
get to zero

70
00:03:08,239 --> 00:03:10,720
it's a very simple algorithm and it's

71
00:03:10,720 --> 00:03:13,599
something that textbooks tell you here's

72
00:03:13,599 --> 00:03:16,239
the algorithm here's the proof it always

73
00:03:16,239 --> 00:03:17,680
works

74
00:03:17,680 --> 00:03:19,680
just use it

75
00:03:19,680 --> 00:03:23,200
now microsoft implemented this algorithm

76
00:03:23,200 --> 00:03:24,640
and they

77
00:03:24,640 --> 00:03:27,680
managed to make an infinite loop

78
00:03:27,680 --> 00:03:30,480
the algorithm on some inputs

79
00:03:30,480 --> 00:03:32,319
would just run forever and forever and

80
00:03:32,319 --> 00:03:34,640
forever

81
00:03:34,640 --> 00:03:36,640
how did they do this why did they do

82
00:03:36,640 --> 00:03:37,760
this well

83
00:03:37,760 --> 00:03:40,720
when people write cryptographic software

84
00:03:40,720 --> 00:03:43,280
they want it to go quickly they want it

85
00:03:43,280 --> 00:03:46,319
to be as fast as possible they also want

86
00:03:46,319 --> 00:03:48,319
it to be constant time i'll talk more

87
00:03:48,319 --> 00:03:51,040
about that later and so they don't use

88
00:03:51,040 --> 00:03:54,000
exactly the textbook algorithm there are

89
00:03:54,000 --> 00:03:56,000
many many different algorithms that

90
00:03:56,000 --> 00:03:57,280
people use

91
00:03:57,280 --> 00:04:00,080
and so they make mistakes sometimes

92
00:04:00,080 --> 00:04:02,400
there's many different algorithms and

93
00:04:02,400 --> 00:04:04,959
sometimes people get them wrong

94
00:04:04,959 --> 00:04:07,439
another example from the

95
00:04:07,439 --> 00:04:09,840
nist post quantum cryptography

96
00:04:09,840 --> 00:04:12,720
standardization project this is about a

97
00:04:12,720 --> 00:04:14,799
submission called falcon

98
00:04:14,799 --> 00:04:17,120
it's one of a very small number of

99
00:04:17,120 --> 00:04:19,519
signature systems which are under

100
00:04:19,519 --> 00:04:22,320
consideration for standardization

101
00:04:22,320 --> 00:04:25,280
and this bug said that the signatures

102
00:04:25,280 --> 00:04:27,680
from the falcon software

103
00:04:27,680 --> 00:04:30,160
leaked your secret key

104
00:04:30,160 --> 00:04:32,960
so then anybody could sign messages

105
00:04:32,960 --> 00:04:36,080
complete security disaster in the falcon

106
00:04:36,080 --> 00:04:37,680
software

107
00:04:37,680 --> 00:04:39,919
and then the comment from the falcon

108
00:04:39,919 --> 00:04:43,040
software author he said the fact that

109
00:04:43,040 --> 00:04:46,400
these bugs existed in the first place

110
00:04:46,400 --> 00:04:48,639
shows that the traditional development

111
00:04:48,639 --> 00:04:51,759
methodology being super careful

112
00:04:51,759 --> 00:04:54,479
has failed

113
00:04:55,440 --> 00:04:58,639
okay they fixed the software maybe they

114
00:04:58,639 --> 00:05:00,240
fixed this bug

115
00:05:00,240 --> 00:05:04,800
but does the software work correctly now

116
00:05:04,960 --> 00:05:06,240
who knows

117
00:05:06,240 --> 00:05:08,720
maybe there's more bugs

118
00:05:08,720 --> 00:05:11,199
one more example minerva

119
00:05:11,199 --> 00:05:14,000
this one is a timing attack against

120
00:05:14,000 --> 00:05:16,479
elliptic curve cryptography

121
00:05:16,479 --> 00:05:19,120
and this one you can see many libraries

122
00:05:19,120 --> 00:05:22,240
mentioned here lib g-crypt that's

123
00:05:22,240 --> 00:05:25,280
the gnu cryptographic library wolf ssl

124
00:05:25,280 --> 00:05:28,160
crypto plus plus these have issued

125
00:05:28,160 --> 00:05:31,360
patches to fix this timing attack this

126
00:05:31,360 --> 00:05:35,120
is not a wrong computation the previous

127
00:05:35,120 --> 00:05:38,400
bugs were incorrect computations this

128
00:05:38,400 --> 00:05:41,840
one is a timing attack the software

129
00:05:41,840 --> 00:05:44,160
takes different amounts of time for

130
00:05:44,160 --> 00:05:46,960
different inputs and that leaks secret

131
00:05:46,960 --> 00:05:50,240
information because of the timing

132
00:05:50,240 --> 00:05:52,560
now this they discovered this timing

133
00:05:52,560 --> 00:05:54,240
attack worked against many many

134
00:05:54,240 --> 00:05:56,560
cryptographic libraries some of them

135
00:05:56,560 --> 00:05:59,440
fixed the the problem but

136
00:05:59,440 --> 00:06:03,600
are there more problems we don't know

137
00:06:03,759 --> 00:06:06,720
there was a paper a few months ago

138
00:06:06,720 --> 00:06:08,240
which was called

139
00:06:08,240 --> 00:06:10,319
you really shouldn't roll your own

140
00:06:10,319 --> 00:06:12,800
crypto an empirical study of

141
00:06:12,800 --> 00:06:14,720
vulnerabilities in cryptographic

142
00:06:14,720 --> 00:06:15,840
libraries

143
00:06:15,840 --> 00:06:18,560
now this paper looked at 10 years of

144
00:06:18,560 --> 00:06:23,280
cves from 2010 to 2020 they looked at

145
00:06:23,280 --> 00:06:27,120
all of the announced security holes in

146
00:06:27,120 --> 00:06:30,720
all of the major cryptographic libraries

147
00:06:30,720 --> 00:06:32,720
and they found well

148
00:06:32,720 --> 00:06:36,960
73 actual cryptographic vulnerabilities

149
00:06:36,960 --> 00:06:39,440
now what does actual mean

150
00:06:39,440 --> 00:06:43,199
they actually found many more cves these

151
00:06:43,199 --> 00:06:46,840
libraries have announced many many bugs

152
00:06:46,840 --> 00:06:50,000
but some of the bugs are buffer

153
00:06:50,000 --> 00:06:51,360
overflows

154
00:06:51,360 --> 00:06:54,960
or certificate mismanagement or some

155
00:06:54,960 --> 00:06:56,599
other kind of

156
00:06:56,599 --> 00:06:58,800
non-cryptographic bug it's a

157
00:06:58,800 --> 00:07:01,759
cryptographic library which does

158
00:07:01,759 --> 00:07:04,479
mathematical computations cryptographic

159
00:07:04,479 --> 00:07:07,199
computations and it does

160
00:07:07,199 --> 00:07:10,400
things like tls management certificate

161
00:07:10,400 --> 00:07:11,599
management

162
00:07:11,599 --> 00:07:13,919
and sometimes many of the the

163
00:07:13,919 --> 00:07:15,840
vulnerabilities are

164
00:07:15,840 --> 00:07:18,800
problems outside the cryptography in a

165
00:07:18,800 --> 00:07:21,520
cryptographic library

166
00:07:21,520 --> 00:07:25,919
73 bugs over 10 years those were in the

167
00:07:25,919 --> 00:07:28,880
actual cryptographic computations

168
00:07:28,880 --> 00:07:33,120
and out of those 11 were severe

169
00:07:33,120 --> 00:07:36,000
now what does severe mean severe means

170
00:07:36,000 --> 00:07:38,400
that the authors of the cryptographic

171
00:07:38,400 --> 00:07:39,919
library say

172
00:07:39,919 --> 00:07:43,039
oh you can definitely use that to expose

173
00:07:43,039 --> 00:07:45,199
user data

174
00:07:45,199 --> 00:07:49,039
what about the other 62 bugs

175
00:07:49,039 --> 00:07:50,479
well

176
00:07:50,479 --> 00:07:54,160
those were not called severe that means

177
00:07:54,160 --> 00:07:56,840
maybe they expose user data we don't

178
00:07:56,840 --> 00:07:59,039
know and then

179
00:07:59,039 --> 00:08:01,360
these bugs have been fixed what about

180
00:08:01,360 --> 00:08:04,319
the next 73 bugs

181
00:08:04,319 --> 00:08:06,879
who knows

182
00:08:07,280 --> 00:08:09,039
there are many reasons that

183
00:08:09,039 --> 00:08:13,039
cryptographic software is becoming more

184
00:08:13,039 --> 00:08:16,400
and more complicated and adding more and

185
00:08:16,400 --> 00:08:19,120
more bugs of course we try to fix the

186
00:08:19,120 --> 00:08:21,120
bugs but

187
00:08:21,120 --> 00:08:23,039
there's these pressures on the

188
00:08:23,039 --> 00:08:25,680
cryptographic ecosystem and let me go

189
00:08:25,680 --> 00:08:27,919
through the main pressures here

190
00:08:27,919 --> 00:08:30,080
first of all on the left side here

191
00:08:30,080 --> 00:08:33,839
people want the cryptography to be fast

192
00:08:33,839 --> 00:08:36,240
because cryptography is applied to all

193
00:08:36,240 --> 00:08:37,760
of your data

194
00:08:37,760 --> 00:08:39,360
everything that you're sending through

195
00:08:39,360 --> 00:08:40,399
the internet

196
00:08:40,399 --> 00:08:42,719
everything that you're storing encrypted

197
00:08:42,719 --> 00:08:45,760
on your flash or on your hard drive that

198
00:08:45,760 --> 00:08:48,399
is using cryptography and it has to be

199
00:08:48,399 --> 00:08:51,680
fast enough to handle all of that

200
00:08:51,680 --> 00:08:52,399
now

201
00:08:52,399 --> 00:08:54,560
in my title for today i mentioned

202
00:08:54,560 --> 00:08:57,519
post-quantum cryptography and this is

203
00:08:57,519 --> 00:09:00,000
trying to protect the cryptography

204
00:09:00,000 --> 00:09:02,880
against quantum computers

205
00:09:02,880 --> 00:09:04,399
right now

206
00:09:04,399 --> 00:09:08,360
ibm announced a quantum computer with

207
00:09:08,360 --> 00:09:12,000
127 cubits the eagle

208
00:09:12,000 --> 00:09:12,959
but

209
00:09:12,959 --> 00:09:14,959
that's not big enough to be a threat

210
00:09:14,959 --> 00:09:16,720
against cryptography

211
00:09:16,720 --> 00:09:19,279
they say their next processor will be

212
00:09:19,279 --> 00:09:22,640
400 and then a thousand and google has

213
00:09:22,640 --> 00:09:24,959
been working on their own processors and

214
00:09:24,959 --> 00:09:27,440
microsoft is trying well not very well

215
00:09:27,440 --> 00:09:29,920
but maybe they will succeed and build

216
00:09:29,920 --> 00:09:32,160
their own quantum computer

217
00:09:32,160 --> 00:09:34,560
once somebody builds a big enough

218
00:09:34,560 --> 00:09:37,519
quantum computer then lots and lots of

219
00:09:37,519 --> 00:09:40,320
cryptography is broken and we need to

220
00:09:40,320 --> 00:09:42,560
replace it with cryptography that

221
00:09:42,560 --> 00:09:44,880
survives quantum computers

222
00:09:44,880 --> 00:09:45,839
maybe

223
00:09:45,839 --> 00:09:48,880
code-based hash-based isogeny-based

224
00:09:48,880 --> 00:09:51,360
lattice-based cryptography or

225
00:09:51,360 --> 00:09:53,600
multivariate quadratics

226
00:09:53,600 --> 00:09:56,240
where's billion here's billion our top

227
00:09:56,240 --> 00:09:58,000
expert on multivariate quadratics in the

228
00:09:58,000 --> 00:09:59,279
whole world is sitting right there in

229
00:09:59,279 --> 00:10:01,040
the corner of the room

230
00:10:01,040 --> 00:10:02,640
all right

231
00:10:02,640 --> 00:10:04,800
another pressure on cryptographic

232
00:10:04,800 --> 00:10:08,399
software is these timing attacks

233
00:10:08,399 --> 00:10:10,640
when cryptographic software takes

234
00:10:10,640 --> 00:10:12,800
different amounts of time

235
00:10:12,800 --> 00:10:15,600
it can tell you secret information i'll

236
00:10:15,600 --> 00:10:18,240
give you an example later with actual

237
00:10:18,240 --> 00:10:22,079
software of where these leaks come from

238
00:10:22,079 --> 00:10:24,560
now people look at these pressures we

239
00:10:24,560 --> 00:10:27,120
want cryptography to be fast and post

240
00:10:27,120 --> 00:10:28,959
quantum and secure against timing

241
00:10:28,959 --> 00:10:32,399
attacks and people say okay

242
00:10:32,399 --> 00:10:33,360
we can

243
00:10:33,360 --> 00:10:35,760
write our cryptographic software to be

244
00:10:35,760 --> 00:10:38,320
as fast as possible

245
00:10:38,320 --> 00:10:40,880
and then we can write our cryptographic

246
00:10:40,880 --> 00:10:43,360
software to only use post quantum

247
00:10:43,360 --> 00:10:45,040
algorithms and we can write it to be

248
00:10:45,040 --> 00:10:47,680
constant time but that's complicated

249
00:10:47,680 --> 00:10:50,880
it's easier if you build specifications

250
00:10:50,880 --> 00:10:54,000
if you design cryptographic systems

251
00:10:54,000 --> 00:10:56,160
where you're thinking how can i make the

252
00:10:56,160 --> 00:10:59,519
software easier to build but it's still

253
00:10:59,519 --> 00:11:02,320
very very complicated in the end if you

254
00:11:02,320 --> 00:11:05,279
look at the post-quantum specifications

255
00:11:05,279 --> 00:11:07,680
which are trying to be post quantum

256
00:11:07,680 --> 00:11:09,279
trying to be fast and trying to be

257
00:11:09,279 --> 00:11:10,880
constant time

258
00:11:10,880 --> 00:11:14,560
there are many many pages just defining

259
00:11:14,560 --> 00:11:16,480
the algorithms

260
00:11:16,480 --> 00:11:19,440
and then when you write software for

261
00:11:19,440 --> 00:11:21,760
these post quantum systems

262
00:11:21,760 --> 00:11:24,160
it's very very complicated there are

263
00:11:24,160 --> 00:11:26,640
many many implementations of many

264
00:11:26,640 --> 00:11:29,360
different functions with many mistakes

265
00:11:29,360 --> 00:11:32,079
that people make

266
00:11:32,079 --> 00:11:34,240
here's an example of how complicated

267
00:11:34,240 --> 00:11:36,720
things get now this is one of the

268
00:11:36,720 --> 00:11:40,079
simplest cryptographic functions sha-3

269
00:11:40,079 --> 00:11:43,040
the ketchup function this function if

270
00:11:43,040 --> 00:11:45,360
you look at the specification it's

271
00:11:45,360 --> 00:11:48,000
possible to define it in less than one

272
00:11:48,000 --> 00:11:51,200
page and many cryptographic functions

273
00:11:51,200 --> 00:11:53,519
are much more complicated this is a

274
00:11:53,519 --> 00:11:55,839
reasonably simple one of the simplest

275
00:11:55,839 --> 00:11:58,079
cryptographic functions

276
00:11:58,079 --> 00:12:00,720
if you look in the official code package

277
00:12:00,720 --> 00:12:02,639
from the ketchup

278
00:12:02,639 --> 00:12:03,760
team

279
00:12:03,760 --> 00:12:07,279
then they have some reference c code

280
00:12:07,279 --> 00:12:10,720
and then they have x86 assembly

281
00:12:10,720 --> 00:12:13,839
now that x86 code is for

282
00:12:13,839 --> 00:12:18,639
running on intel chips and amd chips

283
00:12:18,959 --> 00:12:22,320
they also have avx2 code which is for

284
00:12:22,320 --> 00:12:26,959
running on intel chips and amd chips but

285
00:12:26,959 --> 00:12:30,800
not every intel chip has avx2

286
00:12:30,800 --> 00:12:34,720
instructions avx-2 is 256-bit

287
00:12:34,720 --> 00:12:36,800
vector instructions

288
00:12:36,800 --> 00:12:39,680
intel started putting avx2 in their

289
00:12:39,680 --> 00:12:43,600
chips in 2013 with the haswell processor

290
00:12:43,600 --> 00:12:47,360
but not every intel chip has avx2

291
00:12:47,360 --> 00:12:49,440
avx-512

292
00:12:49,440 --> 00:12:53,440
these are 512-bit vector instructions

293
00:12:53,440 --> 00:12:55,440
intel started putting those into their

294
00:12:55,440 --> 00:12:58,240
chips but most of the intel chips don't

295
00:12:58,240 --> 00:13:00,880
have avx-512

296
00:13:00,880 --> 00:13:03,279
and so depending on which machine you

297
00:13:03,279 --> 00:13:06,320
have maybe you can use the avx-512

298
00:13:06,320 --> 00:13:08,240
software or maybe

299
00:13:08,240 --> 00:13:10,639
only you can use avx2 or maybe you have

300
00:13:10,639 --> 00:13:13,440
to use this one or maybe you're using an

301
00:13:13,440 --> 00:13:16,240
arm cpu and they have some arm

302
00:13:16,240 --> 00:13:18,240
optimized software

303
00:13:18,240 --> 00:13:20,560
you can always use the reference

304
00:13:20,560 --> 00:13:21,680
software

305
00:13:21,680 --> 00:13:23,519
you can just say i'll compile the

306
00:13:23,519 --> 00:13:26,079
reference software with my optimizing

307
00:13:26,079 --> 00:13:28,639
compiler and that will give you

308
00:13:28,639 --> 00:13:31,760
code that works on whatever cpu

309
00:13:31,760 --> 00:13:34,800
but it's not very fast

310
00:13:34,800 --> 00:13:37,120
if your machine has

311
00:13:37,120 --> 00:13:39,680
avx2 instructions you get much better

312
00:13:39,680 --> 00:13:42,399
performance out of this avx2 assembly

313
00:13:42,399 --> 00:13:44,880
language instead of using the reference

314
00:13:44,880 --> 00:13:48,079
code compilers are not very smart about

315
00:13:48,079 --> 00:13:50,800
making code run fast humans are better

316
00:13:50,800 --> 00:13:52,959
at making code run fast

317
00:13:52,959 --> 00:13:54,880
and so they have many many many

318
00:13:54,880 --> 00:13:58,160
implementations for different chips plus

319
00:13:58,160 --> 00:14:01,040
what is this times 8

320
00:14:01,040 --> 00:14:04,800
times eight says i have eight different

321
00:14:04,800 --> 00:14:07,680
inputs and i want to hash all of those

322
00:14:07,680 --> 00:14:09,199
inputs

323
00:14:09,199 --> 00:14:11,519
and now they have a function which says

324
00:14:11,519 --> 00:14:14,560
i take all eight inputs i hash this one

325
00:14:14,560 --> 00:14:16,320
i hash this one i hash this one i hash

326
00:14:16,320 --> 00:14:18,079
this one it's all separate

327
00:14:18,079 --> 00:14:19,920
but that's faster

328
00:14:19,920 --> 00:14:20,880
than

329
00:14:20,880 --> 00:14:23,360
hashing each one first this one then

330
00:14:23,360 --> 00:14:25,519
this one because they can use vector

331
00:14:25,519 --> 00:14:28,000
instructions in a better way

332
00:14:28,000 --> 00:14:30,399
and so there are many of these times

333
00:14:30,399 --> 00:14:33,279
eight times four times two functions and

334
00:14:33,279 --> 00:14:35,360
again this is faster than what the

335
00:14:35,360 --> 00:14:38,000
compiler can figure out

336
00:14:38,000 --> 00:14:40,560
another example if you look at the nist

337
00:14:40,560 --> 00:14:43,519
post-quantum cryptography competition

338
00:14:43,519 --> 00:14:44,560
then

339
00:14:44,560 --> 00:14:45,920
they have

340
00:14:45,920 --> 00:14:48,800
well in the current round there are

341
00:14:48,800 --> 00:14:50,959
some lattice systems some code based

342
00:14:50,959 --> 00:14:53,519
systems some hash systems one isogeny

343
00:14:53,519 --> 00:14:57,600
system some multivariate systems and

344
00:14:57,600 --> 00:14:58,399
these

345
00:14:58,399 --> 00:15:02,959
systems all have hand optimized code

346
00:15:02,959 --> 00:15:05,839
they all have avx2 code some of them

347
00:15:05,839 --> 00:15:08,959
have more some of them have arm assembly

348
00:15:08,959 --> 00:15:10,959
for example

349
00:15:10,959 --> 00:15:13,920
but every single nist submission every

350
00:15:13,920 --> 00:15:16,720
single post quantum proposal for

351
00:15:16,720 --> 00:15:19,760
standardization and for usage has

352
00:15:19,760 --> 00:15:23,519
fast code written to use 256 bit vector

353
00:15:23,519 --> 00:15:26,399
instructions and whichever ones end up

354
00:15:26,399 --> 00:15:28,480
being deployed they're going to do more

355
00:15:28,480 --> 00:15:30,639
of these implementations so there's many

356
00:15:30,639 --> 00:15:33,199
many different versions of

357
00:15:33,199 --> 00:15:35,279
the software for these cryptographic

358
00:15:35,279 --> 00:15:37,680
systems

359
00:15:37,920 --> 00:15:38,639
now

360
00:15:38,639 --> 00:15:40,399
there's a very useful

361
00:15:40,399 --> 00:15:41,600
idea

362
00:15:41,600 --> 00:15:42,800
which

363
00:15:42,800 --> 00:15:46,480
people have been trying for many years

364
00:15:46,480 --> 00:15:48,079
and what i want to

365
00:15:48,079 --> 00:15:50,959
convince you of in the rest of this talk

366
00:15:50,959 --> 00:15:54,160
is that actually in many cases this is

367
00:15:54,160 --> 00:15:57,279
something you can use now and it works

368
00:15:57,279 --> 00:15:58,240
great

369
00:15:58,240 --> 00:16:01,040
what is called symbolic testing

370
00:16:01,040 --> 00:16:04,000
this is the idea that you can check your

371
00:16:04,000 --> 00:16:06,560
optimized software

372
00:16:06,560 --> 00:16:08,480
and your reference software

373
00:16:08,480 --> 00:16:11,199
always give the same results

374
00:16:11,199 --> 00:16:13,120
now you're thinking okay testing yeah i

375
00:16:13,120 --> 00:16:15,600
do that i try my reference software on

376
00:16:15,600 --> 00:16:17,440
some input and i try my optimized

377
00:16:17,440 --> 00:16:21,120
software on some input and then

378
00:16:21,120 --> 00:16:23,279
maybe they produce the same results good

379
00:16:23,279 --> 00:16:25,680
or maybe it's different results but

380
00:16:25,680 --> 00:16:28,160
and then i try another input and another

381
00:16:28,160 --> 00:16:32,480
input and okay that's normal testing

382
00:16:32,480 --> 00:16:35,440
symbolic testing says

383
00:16:35,440 --> 00:16:39,279
you try all possible inputs

384
00:16:39,279 --> 00:16:41,360
now that might sound like there's

385
00:16:41,360 --> 00:16:44,000
there's too many it's too slow you can't

386
00:16:44,000 --> 00:16:45,120
do that

387
00:16:45,120 --> 00:16:48,160
but there are fancy techniques that

388
00:16:48,160 --> 00:16:51,120
people have developed for doing symbolic

389
00:16:51,120 --> 00:16:52,160
testing

390
00:16:52,160 --> 00:16:55,199
and because of those techniques symbolic

391
00:16:55,199 --> 00:16:58,160
testing is something that sometimes you

392
00:16:58,160 --> 00:17:00,399
can actually use now

393
00:17:00,399 --> 00:17:01,279
so

394
00:17:01,279 --> 00:17:03,199
main thing that i want to convince you

395
00:17:03,199 --> 00:17:06,480
of is that the tools that exist right

396
00:17:06,480 --> 00:17:09,359
now are something that you can use to

397
00:17:09,359 --> 00:17:12,000
verify some important cryptographic

398
00:17:12,000 --> 00:17:13,280
software

399
00:17:13,280 --> 00:17:16,480
not complete post quantum systems yet

400
00:17:16,480 --> 00:17:19,599
but some subroutines you can verify and

401
00:17:19,599 --> 00:17:21,760
you symbolically test that the reference

402
00:17:21,760 --> 00:17:25,039
code is always equal to the optimized

403
00:17:25,039 --> 00:17:26,799
code and the reference code for every

404
00:17:26,799 --> 00:17:30,840
input give you the same results

405
00:17:30,840 --> 00:17:34,160
now i'll be telling you from the user

406
00:17:34,160 --> 00:17:36,720
perspective what it's like using

407
00:17:36,720 --> 00:17:39,760
one little tool called safe rewrite

408
00:17:39,760 --> 00:17:43,799
which you can find at pqsrc.cr.yp.to

409
00:17:44,880 --> 00:17:47,120
this is something which is just a little

410
00:17:47,120 --> 00:17:48,559
python script

411
00:17:48,559 --> 00:17:50,320
if you look at it it doesn't do very

412
00:17:50,320 --> 00:17:51,200
much

413
00:17:51,200 --> 00:17:54,400
but that's because it's using all sorts

414
00:17:54,400 --> 00:17:56,160
of useful tools

415
00:17:56,160 --> 00:17:58,640
now one of these valgrind for any

416
00:17:58,640 --> 00:18:00,480
programmers in the audience you should

417
00:18:00,480 --> 00:18:03,440
be using valgrind and address sanitizer

418
00:18:03,440 --> 00:18:05,760
these are very useful tools already and

419
00:18:05,760 --> 00:18:08,720
that's sort of the the very start of

420
00:18:08,720 --> 00:18:10,960
doing symbolic testing is these tools

421
00:18:10,960 --> 00:18:13,919
which can understand what your code is

422
00:18:13,919 --> 00:18:16,400
doing symbolically

423
00:18:16,400 --> 00:18:18,559
then inside valgrind there's a library

424
00:18:18,559 --> 00:18:20,559
which i won't say much about but just to

425
00:18:20,559 --> 00:18:22,400
point to one of the most important

426
00:18:22,400 --> 00:18:26,960
pieces vex is a library inside valgrind

427
00:18:26,960 --> 00:18:29,440
there's another tool the z3 theorem

428
00:18:29,440 --> 00:18:31,440
prover this is an example of what's

429
00:18:31,440 --> 00:18:34,720
called an smt solver satisfiability

430
00:18:34,720 --> 00:18:37,520
modulo theories it's something which can

431
00:18:37,520 --> 00:18:40,080
say for example yes this

432
00:18:40,080 --> 00:18:42,720
code is always equal to that code and it

433
00:18:42,720 --> 00:18:45,520
can do fancy reasoning to figure that

434
00:18:45,520 --> 00:18:48,160
out and guarantee yes it's always

435
00:18:48,160 --> 00:18:49,200
correct

436
00:18:49,200 --> 00:18:51,039
and then on top of these

437
00:18:51,039 --> 00:18:53,600
putting all of these together

438
00:18:53,600 --> 00:18:56,240
just right under safe rewrite say

439
00:18:56,240 --> 00:18:58,960
freewrite is using a toolkit called

440
00:18:58,960 --> 00:19:00,080
anger

441
00:19:00,080 --> 00:19:02,480
anger.io

442
00:19:02,480 --> 00:19:05,039
there's a graphical user interface if

443
00:19:05,039 --> 00:19:07,280
you want to try anger yourself you might

444
00:19:07,280 --> 00:19:09,600
like the graphical user interface just

445
00:19:09,600 --> 00:19:12,240
because of the name it's called anger

446
00:19:12,240 --> 00:19:15,840
management but in this

447
00:19:15,840 --> 00:19:17,840
talk i'm just going to be doing command

448
00:19:17,840 --> 00:19:21,360
line things so say free write uses anger

449
00:19:21,360 --> 00:19:23,760
which uses z3 uses vex

450
00:19:23,760 --> 00:19:26,240
inside valgrind safe rewrite also uses

451
00:19:26,240 --> 00:19:27,919
valgrind separately

452
00:19:27,919 --> 00:19:32,000
okay so what does safe rewrite do

453
00:19:32,160 --> 00:19:34,960
here's an example this is cryptographic

454
00:19:34,960 --> 00:19:36,559
code

455
00:19:36,559 --> 00:19:39,600
this code works correctly but

456
00:19:39,600 --> 00:19:42,640
some people have gotten this wrong

457
00:19:42,640 --> 00:19:43,760
so

458
00:19:43,760 --> 00:19:46,160
what is this code supposed to do

459
00:19:46,160 --> 00:19:49,679
well this is inside one of the post

460
00:19:49,679 --> 00:19:52,000
quantum systems a lattice-based system

461
00:19:52,000 --> 00:19:53,760
called frodo

462
00:19:53,760 --> 00:19:56,799
frodo is a chem a key encapsulation

463
00:19:56,799 --> 00:20:00,240
mechanism it's an encryption mechanism

464
00:20:00,240 --> 00:20:02,080
and one of the things that it does there

465
00:20:02,080 --> 00:20:04,880
are many subroutines inside frodo and

466
00:20:04,880 --> 00:20:07,440
one of the subroutines is simply

467
00:20:07,440 --> 00:20:09,760
comparing two arrays

468
00:20:09,760 --> 00:20:11,520
the inputs here

469
00:20:11,520 --> 00:20:14,960
x and y these are arrays of 16-bit

470
00:20:14,960 --> 00:20:16,000
integers

471
00:20:16,000 --> 00:20:19,679
each one has 64 16-bit integers

472
00:20:19,679 --> 00:20:22,000
and what this subroutine does

473
00:20:22,000 --> 00:20:24,880
is it says well if x 0 is different from

474
00:20:24,880 --> 00:20:28,159
y 0 return minus 1 if x 1 is different

475
00:20:28,159 --> 00:20:30,559
from y 1 return minus 1 if x 2 is

476
00:20:30,559 --> 00:20:33,200
different from y 2 return minus 1 etc

477
00:20:33,200 --> 00:20:34,720
etc etc

478
00:20:34,720 --> 00:20:38,159
if all of the x's the 64 x's equal all

479
00:20:38,159 --> 00:20:41,679
of the y's 64 y's then the code returns

480
00:20:41,679 --> 00:20:43,760
zero

481
00:20:43,760 --> 00:20:46,080
now this subroutine is something that i

482
00:20:46,080 --> 00:20:46,880
wrote

483
00:20:46,880 --> 00:20:50,000
from the specification frodo says

484
00:20:50,000 --> 00:20:51,840
this is the comparison that you're

485
00:20:51,840 --> 00:20:53,440
supposed to do

486
00:20:53,440 --> 00:20:54,880
very easy

487
00:20:54,880 --> 00:20:55,840
function

488
00:20:55,840 --> 00:20:58,400
took just a moment to write

489
00:20:58,400 --> 00:21:00,559
now

490
00:21:00,720 --> 00:21:03,520
when you ask safe rewrite what do you

491
00:21:03,520 --> 00:21:05,520
think about this code this is the

492
00:21:05,520 --> 00:21:07,520
reference code so before looking at

493
00:21:07,520 --> 00:21:09,039
optimized code let's look at this

494
00:21:09,039 --> 00:21:11,679
reference code so you just run safely

495
00:21:11,679 --> 00:21:13,919
right with that code and it says well

496
00:21:13,919 --> 00:21:15,520
first of all

497
00:21:15,520 --> 00:21:18,480
valgrind failure

498
00:21:18,480 --> 00:21:20,480
now what is this valgrind unsafe

499
00:21:20,480 --> 00:21:23,520
valgrind failure what does that mean

500
00:21:23,520 --> 00:21:26,240
well say freeride says

501
00:21:26,240 --> 00:21:28,880
i tried running that code

502
00:21:28,880 --> 00:21:31,280
and using valgrind to figure out what it

503
00:21:31,280 --> 00:21:34,240
does and valgrind told me

504
00:21:34,240 --> 00:21:37,840
that there were branches based on

505
00:21:37,840 --> 00:21:41,600
x0 and y0 if those are different then it

506
00:21:41,600 --> 00:21:44,640
does a branch does an if and that's

507
00:21:44,640 --> 00:21:48,240
something that leaks secret information

508
00:21:48,240 --> 00:21:51,440
if you think about it if x0 equals y0

509
00:21:51,440 --> 00:21:52,320
then

510
00:21:52,320 --> 00:21:53,120
well

511
00:21:53,120 --> 00:21:54,240
that will be

512
00:21:54,240 --> 00:21:55,760
going through the next part of the loop

513
00:21:55,760 --> 00:21:57,679
and then if x1 equals y1 goes through

514
00:21:57,679 --> 00:21:59,280
the next part of the loop if they're

515
00:21:59,280 --> 00:22:02,000
different the function stops i mean this

516
00:22:02,000 --> 00:22:04,320
let's go back to the the code here

517
00:22:04,320 --> 00:22:07,520
if any x i is different from y i

518
00:22:07,520 --> 00:22:09,600
then the function will stop

519
00:22:09,600 --> 00:22:14,159
at position i which means the time taken

520
00:22:14,159 --> 00:22:18,080
by this code is different depending on

521
00:22:18,080 --> 00:22:21,360
how much of x equals how much of y

522
00:22:21,360 --> 00:22:24,799
and usually one of these is secret data

523
00:22:24,799 --> 00:22:27,440
and then somebody can use the timing of

524
00:22:27,440 --> 00:22:29,760
this to figure out they'll try different

525
00:22:29,760 --> 00:22:32,480
x's if y is the secret and then they'll

526
00:22:32,480 --> 00:22:35,679
figure out that which x0 matches y0 and

527
00:22:35,679 --> 00:22:37,360
then once they know that they'll figure

528
00:22:37,360 --> 00:22:40,080
out which x1 matches y1 and so they can

529
00:22:40,080 --> 00:22:42,080
figure out all the secrets by trying

530
00:22:42,080 --> 00:22:44,000
different inputs

531
00:22:44,000 --> 00:22:46,240
okay so say freewrite says this

532
00:22:46,240 --> 00:22:50,080
reference code is not safe because it's

533
00:22:50,080 --> 00:22:52,400
not constant time

534
00:22:52,400 --> 00:22:55,280
and it also quantifies this so say

535
00:22:55,280 --> 00:22:58,159
freewrite will tell you that unrolling

536
00:22:58,159 --> 00:22:59,440
this code

537
00:22:59,440 --> 00:23:02,960
splits it into 65 cases

538
00:23:02,960 --> 00:23:05,360
maybe x0 is different from y0 that's one

539
00:23:05,360 --> 00:23:08,000
case maybe x0 equals y0 and x1 is

540
00:23:08,000 --> 00:23:09,840
different from y1 that's another case

541
00:23:09,840 --> 00:23:12,880
and there's 65 possibilities in this

542
00:23:12,880 --> 00:23:14,080
code

543
00:23:14,080 --> 00:23:17,039
say freewrite always unrolls whatever

544
00:23:17,039 --> 00:23:20,000
code you're looking it only handles

545
00:23:20,000 --> 00:23:23,520
fixed length inputs and whatever those

546
00:23:23,520 --> 00:23:26,480
inputs are it will unroll all of the

547
00:23:26,480 --> 00:23:28,799
loops that happen in processing those

548
00:23:28,799 --> 00:23:30,159
inputs

549
00:23:30,159 --> 00:23:32,080
all right so this is safe rewrite trying

550
00:23:32,080 --> 00:23:33,919
one compiler clang

551
00:23:33,919 --> 00:23:36,799
now it also tries another compiler with

552
00:23:36,799 --> 00:23:39,840
different options and again it says

553
00:23:39,840 --> 00:23:42,559
valgrind failure and says unroll split

554
00:23:42,559 --> 00:23:43,919
65

555
00:23:43,919 --> 00:23:46,400
and then it says equals

556
00:23:46,400 --> 00:23:48,320
ref with clang

557
00:23:48,320 --> 00:23:50,799
so this is saying say free write

558
00:23:50,799 --> 00:23:53,600
compiled the reference code with clang

559
00:23:53,600 --> 00:23:56,480
compiles it with gcc

560
00:23:56,480 --> 00:23:59,840
and then looks at the binaries and says

561
00:23:59,840 --> 00:24:02,799
those binaries always produce the same

562
00:24:02,799 --> 00:24:04,320
outputs

563
00:24:04,320 --> 00:24:06,240
which is what you expect i mean clang

564
00:24:06,240 --> 00:24:09,279
and gcc should produce the same results

565
00:24:09,279 --> 00:24:12,400
as what the original code says

566
00:24:12,400 --> 00:24:14,880
that's an example of symbolic testing

567
00:24:14,880 --> 00:24:17,039
this is something where

568
00:24:17,039 --> 00:24:18,559
if you

569
00:24:18,559 --> 00:24:21,279
normally look at clang and gcc and you

570
00:24:21,279 --> 00:24:23,200
look at their binaries and there's some

571
00:24:23,200 --> 00:24:26,240
bug in gcc or bug and clang

572
00:24:26,240 --> 00:24:27,279
then

573
00:24:27,279 --> 00:24:29,840
well maybe it passes all your tests but

574
00:24:29,840 --> 00:24:32,640
no symbolic testing says they always

575
00:24:32,640 --> 00:24:33,600
match

576
00:24:33,600 --> 00:24:34,720
maybe

577
00:24:34,720 --> 00:24:38,000
clang and gcc have the same bug but

578
00:24:38,000 --> 00:24:40,159
this is good for checking if there are

579
00:24:40,159 --> 00:24:41,760
compiler books

580
00:24:41,760 --> 00:24:43,679
now let's try another

581
00:24:43,679 --> 00:24:47,360
version of the same function this is

582
00:24:47,360 --> 00:24:50,400
reusing the c library don't write your

583
00:24:50,400 --> 00:24:51,200
own

584
00:24:51,200 --> 00:24:53,679
software to do this comparison there's a

585
00:24:53,679 --> 00:24:56,320
standard c function called memcamp

586
00:24:56,320 --> 00:24:59,919
so okay include string.h and now compare

587
00:24:59,919 --> 00:25:03,919
why is it 128 well there's 64

588
00:25:03,919 --> 00:25:07,520
16-bit integers so that's 128 bytes

589
00:25:07,520 --> 00:25:11,679
inside x and 128 bytes inside y

590
00:25:11,679 --> 00:25:15,440
now if you try safe rewrite on this code

591
00:25:15,440 --> 00:25:18,080
then first of all it says valgrind

592
00:25:18,080 --> 00:25:19,360
failure

593
00:25:19,360 --> 00:25:23,360
mamcom takes variable time

594
00:25:23,360 --> 00:25:25,520
actually it shouldn't take variable time

595
00:25:25,520 --> 00:25:27,760
if the people who wrote memcamp were

596
00:25:27,760 --> 00:25:29,279
optimizing it better then it would take

597
00:25:29,279 --> 00:25:31,039
constant time in all cases sometimes it

598
00:25:31,039 --> 00:25:32,559
does but anyway

599
00:25:32,559 --> 00:25:36,240
memcomp for the compiled code with gcc

600
00:25:36,240 --> 00:25:40,320
and clang takes variable time and also

601
00:25:40,320 --> 00:25:42,640
symbolic testing says hey this is

602
00:25:42,640 --> 00:25:44,080
different from

603
00:25:44,080 --> 00:25:46,480
the reference code

604
00:25:46,480 --> 00:25:48,480
the reason it's different is the

605
00:25:48,480 --> 00:25:51,679
original code was returning -1

606
00:25:51,679 --> 00:25:54,960
if the x and y were different

607
00:25:54,960 --> 00:25:57,120
this code well if you look at the

608
00:25:57,120 --> 00:25:59,360
definition of memcomp it says

609
00:25:59,360 --> 00:26:03,520
it returns something non-zero if x and y

610
00:26:03,520 --> 00:26:06,000
are different

611
00:26:06,240 --> 00:26:08,320
okay so let's fix that

612
00:26:08,320 --> 00:26:10,960
so this code is calling memcamp and then

613
00:26:10,960 --> 00:26:13,440
if the result is not zero it returns

614
00:26:13,440 --> 00:26:14,720
minus one

615
00:26:14,720 --> 00:26:17,760
and otherwise returns zero

616
00:26:17,760 --> 00:26:20,960
all right and now save rewrite says this

617
00:26:20,960 --> 00:26:24,159
equals the reference code good

618
00:26:24,159 --> 00:26:27,279
but well it still has branches based on

619
00:26:27,279 --> 00:26:29,039
secret data

620
00:26:29,039 --> 00:26:32,720
and this is basically the original frodo

621
00:26:32,720 --> 00:26:35,600
code for this subroutine the official

622
00:26:35,600 --> 00:26:38,880
frodo software submitted to nist for the

623
00:26:38,880 --> 00:26:42,720
post quantum competition used memcamp

624
00:26:42,720 --> 00:26:45,440
and then well last year there was a

625
00:26:45,440 --> 00:26:46,960
timing attack

626
00:26:46,960 --> 00:26:47,919
which

627
00:26:47,919 --> 00:26:50,080
showed that here's how you can extract

628
00:26:50,080 --> 00:26:52,799
secrets out of frodo so complete

629
00:26:52,799 --> 00:26:55,840
disaster for the software because it has

630
00:26:55,840 --> 00:26:58,000
branches based on secret data and takes

631
00:26:58,000 --> 00:27:01,120
variable amounts of time

632
00:27:01,279 --> 00:27:03,840
all right so frodo they said oh there's

633
00:27:03,840 --> 00:27:06,880
an attack we can fix it here is the

634
00:27:06,880 --> 00:27:10,720
official frodo june 2020 memory

635
00:27:10,720 --> 00:27:13,200
comparison code

636
00:27:13,200 --> 00:27:15,120
well it's a little bit weird

637
00:27:15,120 --> 00:27:17,200
there's these logic operations there's

638
00:27:17,200 --> 00:27:19,840
an or well there's an xor and an or and

639
00:27:19,840 --> 00:27:22,080
there's shifts and then

640
00:27:22,080 --> 00:27:24,880
different integer types running around

641
00:27:24,880 --> 00:27:26,080
well

642
00:27:26,080 --> 00:27:28,080
okay they

643
00:27:28,080 --> 00:27:29,919
published this code and said this i mean

644
00:27:29,919 --> 00:27:31,840
this is this is really all the previous

645
00:27:31,840 --> 00:27:34,159
ones were just simple examples but this

646
00:27:34,159 --> 00:27:37,840
is the real frodo code now

647
00:27:37,840 --> 00:27:39,760
let's try testing this and let's make

648
00:27:39,760 --> 00:27:41,760
sure that this always works it's i mean

649
00:27:41,760 --> 00:27:43,200
looking at it it's it's a little

650
00:27:43,200 --> 00:27:45,279
complicated and i mean somebody could

651
00:27:45,279 --> 00:27:47,120
make a mistake here right

652
00:27:47,120 --> 00:27:49,120
would it be obvious i mean does it look

653
00:27:49,120 --> 00:27:51,600
correct i don't know so let's try

654
00:27:51,600 --> 00:27:53,279
testing this

655
00:27:53,279 --> 00:27:54,080
now

656
00:27:54,080 --> 00:27:56,640
the the interface is a little different

657
00:27:56,640 --> 00:27:58,799
well different function name but also

658
00:27:58,799 --> 00:28:00,960
there's a variable length

659
00:28:00,960 --> 00:28:02,960
so let's make a little

660
00:28:02,960 --> 00:28:05,279
wrapper same function name now

661
00:28:05,279 --> 00:28:07,679
and the length is 64.

662
00:28:07,679 --> 00:28:11,039
and that's 64 is the number of positions

663
00:28:11,039 --> 00:28:13,600
in the two arrays

664
00:28:13,600 --> 00:28:16,399
okay so i took the frodo code and i

665
00:28:16,399 --> 00:28:18,240
wrote these three lines

666
00:28:18,240 --> 00:28:20,000
and then the reference code that we saw

667
00:28:20,000 --> 00:28:21,360
before

668
00:28:21,360 --> 00:28:23,840
and asked safe rewrite

669
00:28:23,840 --> 00:28:24,640
does

670
00:28:24,640 --> 00:28:28,320
this match the reference code

671
00:28:28,320 --> 00:28:31,120
i should say if you want to test

672
00:28:31,120 --> 00:28:34,320
variable length code you have to plug in

673
00:28:34,320 --> 00:28:36,320
particular lengths that you care about

674
00:28:36,320 --> 00:28:38,480
there's a limitation of safe rewrite

675
00:28:38,480 --> 00:28:41,039
again it always unrolls everything it

676
00:28:41,039 --> 00:28:44,559
only handles constant sizes of inputs

677
00:28:44,559 --> 00:28:46,960
but okay that's what frodo uses as some

678
00:28:46,960 --> 00:28:52,080
constant sizes 64 and some bigger sizes

679
00:28:52,080 --> 00:28:54,559
all right so say freewrite says

680
00:28:54,559 --> 00:28:56,840
this is constant time code

681
00:28:56,840 --> 00:29:00,720
good no more timing attack

682
00:29:00,720 --> 00:29:03,120
now say freewrite also says it's

683
00:29:03,120 --> 00:29:05,760
different from the reference code

684
00:29:05,760 --> 00:29:07,440
hmm

685
00:29:07,440 --> 00:29:09,840
maybe it's because of the minus one

686
00:29:09,840 --> 00:29:12,880
versus other non-zero numbers but no no

687
00:29:12,880 --> 00:29:15,440
this this code there's a more serious

688
00:29:15,440 --> 00:29:16,320
bug

689
00:29:16,320 --> 00:29:18,799
and because of this bug

690
00:29:18,799 --> 00:29:22,080
it's actually very easy to break the

691
00:29:22,080 --> 00:29:25,039
frodo official software from last year

692
00:29:25,039 --> 00:29:27,200
now this is something where

693
00:29:27,200 --> 00:29:29,520
in december last year

694
00:29:29,520 --> 00:29:31,840
this was announced that oops there's a

695
00:29:31,840 --> 00:29:34,240
bug in the photo in the new frodo

696
00:29:34,240 --> 00:29:36,559
software and you can exploit this so

697
00:29:36,559 --> 00:29:38,799
they fixed the timing attack and then

698
00:29:38,799 --> 00:29:41,440
made an exploitable constant time

699
00:29:41,440 --> 00:29:43,360
version

700
00:29:43,360 --> 00:29:45,360
and now here is

701
00:29:45,360 --> 00:29:47,279
working code for

702
00:29:47,279 --> 00:29:49,039
doing the same thing

703
00:29:49,039 --> 00:29:51,600
this is another version of the same

704
00:29:51,600 --> 00:29:55,120
comparison which is constant time and i

705
00:29:55,120 --> 00:29:57,600
mean looking at it again there's there's

706
00:29:57,600 --> 00:30:00,080
this there's the logic operations here

707
00:30:00,080 --> 00:30:01,840
and there's shifts and something's

708
00:30:01,840 --> 00:30:04,240
happening but like it looks sort of like

709
00:30:04,240 --> 00:30:05,840
the previous code but you have to think

710
00:30:05,840 --> 00:30:08,720
like does does this work correctly or

711
00:30:08,720 --> 00:30:11,520
instead of thinking you just use safe

712
00:30:11,520 --> 00:30:14,960
rewrite and say freewrite says this

713
00:30:14,960 --> 00:30:18,399
equals the reference code and this

714
00:30:18,399 --> 00:30:21,600
is constant time so this is finally a

715
00:30:21,600 --> 00:30:22,720
safe

716
00:30:22,720 --> 00:30:26,480
rewrite of the reference code

717
00:30:26,559 --> 00:30:29,520
all right if you download the

718
00:30:29,520 --> 00:30:31,279
safe rewrite package

719
00:30:31,279 --> 00:30:34,240
then you'll find 10 implementations of

720
00:30:34,240 --> 00:30:35,679
this function

721
00:30:35,679 --> 00:30:36,559
where

722
00:30:36,559 --> 00:30:39,279
one of them is written in assembly now

723
00:30:39,279 --> 00:30:41,279
this one is taking the

724
00:30:41,279 --> 00:30:42,880
open ssl

725
00:30:42,880 --> 00:30:45,279
crypto memcomp function which is so

726
00:30:45,279 --> 00:30:48,000
openssl for many years has its own

727
00:30:48,000 --> 00:30:50,799
version of memcomp called cryptomemcamp

728
00:30:50,799 --> 00:30:53,360
there's memcomp from the c library and

729
00:30:53,360 --> 00:30:56,880
there's cryptomemcamp from openssl

730
00:30:56,880 --> 00:31:00,320
the reason for cryptomemcamp is to run

731
00:31:00,320 --> 00:31:02,320
in constant time

732
00:31:02,320 --> 00:31:06,159
but they also have bugs for some

733
00:31:06,159 --> 00:31:08,399
versions of crypto memcamp for example

734
00:31:08,399 --> 00:31:09,679
2018

735
00:31:09,679 --> 00:31:10,640
uh

736
00:31:10,640 --> 00:31:13,360
for hp chips which are not very popular

737
00:31:13,360 --> 00:31:14,320
but

738
00:31:14,320 --> 00:31:17,919
there used to be some cpus called hp pa

739
00:31:17,919 --> 00:31:19,279
risk cpus

740
00:31:19,279 --> 00:31:22,559
and these cpus they wrote crypto memcamp

741
00:31:22,559 --> 00:31:24,640
in assembly in constant time for these

742
00:31:24,640 --> 00:31:26,159
cpus

743
00:31:26,159 --> 00:31:29,519
and well that code had a serious bug

744
00:31:29,519 --> 00:31:32,080
so it only checked one bit out of every

745
00:31:32,080 --> 00:31:33,760
byte oops

746
00:31:33,760 --> 00:31:35,679
if they tested enough they would have

747
00:31:35,679 --> 00:31:38,159
found this or say freewrite can

748
00:31:38,159 --> 00:31:42,000
automatically find these bugs

749
00:31:42,000 --> 00:31:44,240
there's also more functions if you

750
00:31:44,240 --> 00:31:45,519
download safety right there are many

751
00:31:45,519 --> 00:31:48,720
many examples now some of the examples

752
00:31:48,720 --> 00:31:50,000
are just

753
00:31:50,000 --> 00:31:51,360
to give you

754
00:31:51,360 --> 00:31:54,320
examples of what safe rewrite does for

755
00:31:54,320 --> 00:31:56,320
different kinds of bugs

756
00:31:56,320 --> 00:31:58,080
what happens if there's a buffer

757
00:31:58,080 --> 00:31:59,919
overflow what happens if you're not

758
00:31:59,919 --> 00:32:02,080
reading enough data

759
00:32:02,080 --> 00:32:04,640
all sorts of different api issues and

760
00:32:04,640 --> 00:32:06,080
memory issues

761
00:32:06,080 --> 00:32:08,640
these simple functions will show you

762
00:32:08,640 --> 00:32:10,640
what does safe rewrite do

763
00:32:10,640 --> 00:32:12,880
what will these tools tell you when you

764
00:32:12,880 --> 00:32:15,279
have different kinds of bugs

765
00:32:15,279 --> 00:32:18,640
some of these functions are more serious

766
00:32:18,640 --> 00:32:21,679
uh cryptographic subroutines and this is

767
00:32:21,679 --> 00:32:23,120
something where

768
00:32:23,120 --> 00:32:26,559
this is well getting rid of possible

769
00:32:26,559 --> 00:32:30,320
bugs in real cryptographic software

770
00:32:30,320 --> 00:32:32,720
i'll give you one bigger example of that

771
00:32:32,720 --> 00:32:35,279
on subsequent slides

772
00:32:35,279 --> 00:32:37,919
whenever safe rewrite says

773
00:32:37,919 --> 00:32:39,600
that

774
00:32:39,600 --> 00:32:41,760
the optimized code is different from the

775
00:32:41,760 --> 00:32:43,360
reference code

776
00:32:43,360 --> 00:32:46,880
then it says here's an example of inputs

777
00:32:46,880 --> 00:32:49,200
which give you different outputs

778
00:32:49,200 --> 00:32:51,279
and then you can try those examples and

779
00:32:51,279 --> 00:32:53,840
say ah okay this is what the code is

780
00:32:53,840 --> 00:32:56,320
doing differently you can use a normal

781
00:32:56,320 --> 00:32:58,559
debugger there's different ways to

782
00:32:58,559 --> 00:33:00,320
check those examples and see what's

783
00:33:00,320 --> 00:33:02,080
happening

784
00:33:02,080 --> 00:33:05,279
sometimes if you do normal tests just

785
00:33:05,279 --> 00:33:07,840
try some random inputs or try fuzzing

786
00:33:07,840 --> 00:33:09,840
for structured inputs

787
00:33:09,840 --> 00:33:12,559
sometimes you can find the same bugs

788
00:33:12,559 --> 00:33:15,919
without symbolic testing but sometimes

789
00:33:15,919 --> 00:33:18,159
it's really hard to find the bugs

790
00:33:18,159 --> 00:33:20,080
some of the bugs that have been found in

791
00:33:20,080 --> 00:33:22,640
cryptographic libraries were not found

792
00:33:22,640 --> 00:33:26,000
by normal testing they can be found by

793
00:33:26,000 --> 00:33:29,120
symbolic testing

794
00:33:29,519 --> 00:33:32,080
i should warn you if you download and

795
00:33:32,080 --> 00:33:33,679
try this package

796
00:33:33,679 --> 00:33:36,880
it will use every core it can find it

797
00:33:36,880 --> 00:33:39,760
will see how many cores you have on your

798
00:33:39,760 --> 00:33:43,039
cpu it'll look at your ssh config and

799
00:33:43,039 --> 00:33:45,760
log into every no no no it won't look it

800
00:33:45,760 --> 00:33:47,440
won't ssh but

801
00:33:47,440 --> 00:33:50,080
it will use many cores and it'll use

802
00:33:50,080 --> 00:33:51,519
lots of memory

803
00:33:51,519 --> 00:33:52,799
so

804
00:33:52,799 --> 00:33:55,600
what you can do to just try some simple

805
00:33:55,600 --> 00:33:58,480
examples like the comparisons is set

806
00:33:58,480 --> 00:34:01,600
sticky bits to decide which of the

807
00:34:01,600 --> 00:34:04,159
source examples you want to try for

808
00:34:04,159 --> 00:34:06,399
example just the comparisons and then it

809
00:34:06,399 --> 00:34:10,560
finishes quickly even on a laptop

810
00:34:10,560 --> 00:34:11,520
okay

811
00:34:11,520 --> 00:34:13,839
i said i would give you a big example

812
00:34:13,839 --> 00:34:16,800
so this is a subroutine which is

813
00:34:16,800 --> 00:34:20,560
one piece of one post post-quantum

814
00:34:20,560 --> 00:34:21,679
function

815
00:34:21,679 --> 00:34:23,679
this post-quantum system is called

816
00:34:23,679 --> 00:34:26,320
entroprime it's another lattice-based

817
00:34:26,320 --> 00:34:27,280
system

818
00:34:27,280 --> 00:34:31,760
and this one well if you look at the

819
00:34:31,760 --> 00:34:36,399
avx and code.c this is again using 256

820
00:34:36,399 --> 00:34:38,560
bit vector instructions

821
00:34:38,560 --> 00:34:42,639
and this for for one key size for 761

822
00:34:42,639 --> 00:34:47,760
this key size is using 245 lines in this

823
00:34:47,760 --> 00:34:49,199
subroutine

824
00:34:49,199 --> 00:34:52,879
and then each different size has another

825
00:34:52,879 --> 00:34:56,000
200 lines for this subroutine

826
00:34:56,000 --> 00:34:59,119
now all of these c files are generated

827
00:34:59,119 --> 00:35:00,800
automatically

828
00:35:00,800 --> 00:35:01,680
by

829
00:35:01,680 --> 00:35:04,320
a 200 line python script

830
00:35:04,320 --> 00:35:07,200
so instead of 200 lines of c for every

831
00:35:07,200 --> 00:35:09,680
different size you could read 200 lines

832
00:35:09,680 --> 00:35:12,480
of python for all the sizes

833
00:35:12,480 --> 00:35:15,200
but do those 200 lines of python work

834
00:35:15,200 --> 00:35:16,720
correctly

835
00:35:16,720 --> 00:35:19,280
it's not easy code the c code is not

836
00:35:19,280 --> 00:35:21,440
easy the python code is not easy it's

837
00:35:21,440 --> 00:35:24,480
not obvious what the code is doing

838
00:35:24,480 --> 00:35:27,440
the reference code for this encode

839
00:35:27,440 --> 00:35:29,920
function this is a much much smaller

840
00:35:29,920 --> 00:35:31,200
piece of code

841
00:35:31,200 --> 00:35:32,480
there's

842
00:35:32,480 --> 00:35:36,320
a 38 line in code.c which does whatever

843
00:35:36,320 --> 00:35:38,480
this encoding is doing

844
00:35:38,480 --> 00:35:40,480
and that is something shared across all

845
00:35:40,480 --> 00:35:42,079
the sizes

846
00:35:42,079 --> 00:35:45,280
and then there's a little wrapper

847
00:35:45,280 --> 00:35:47,680
which is that's easy code that's 18

848
00:35:47,680 --> 00:35:50,000
lines which you can look at and check by

849
00:35:50,000 --> 00:35:52,160
hand

850
00:35:52,160 --> 00:35:55,440
now is the optimized code the same as

851
00:35:55,440 --> 00:35:58,000
the reference code well you ask save

852
00:35:58,000 --> 00:35:59,680
rewrite and

853
00:35:59,680 --> 00:36:02,320
takes a little time and then says yes

854
00:36:02,320 --> 00:36:04,800
the optimized code is doing the same as

855
00:36:04,800 --> 00:36:07,119
the reference code so if the reference

856
00:36:07,119 --> 00:36:10,240
code is correct then this avx code is

857
00:36:10,240 --> 00:36:13,240
correct

858
00:36:13,440 --> 00:36:14,480
this is

859
00:36:14,480 --> 00:36:16,880
part of the encode.c

860
00:36:16,880 --> 00:36:19,680
this is an example of why you don't want

861
00:36:19,680 --> 00:36:22,960
to do this by hand i mean even writing a

862
00:36:22,960 --> 00:36:25,119
python script which generates this this

863
00:36:25,119 --> 00:36:26,560
is

864
00:36:26,560 --> 00:36:28,799
not

865
00:36:29,119 --> 00:36:30,960
straightforward code this there's all

866
00:36:30,960 --> 00:36:32,800
sorts of vector stuff happening and

867
00:36:32,800 --> 00:36:34,960
permutations between different vector

868
00:36:34,960 --> 00:36:37,520
positions basically every line has

869
00:36:37,520 --> 00:36:41,040
another vector instruction

870
00:36:41,040 --> 00:36:44,079
calling the c code well it's it's c plus

871
00:36:44,079 --> 00:36:47,040
vector intrinsics to use these 256 bit

872
00:36:47,040 --> 00:36:49,040
vector instructions and

873
00:36:49,040 --> 00:36:49,920
read

874
00:36:49,920 --> 00:36:53,200
verifying 200 lines of of code like this

875
00:36:53,200 --> 00:36:56,560
times different sizes or verifying the

876
00:36:56,560 --> 00:36:59,280
python code that prints out this code

877
00:36:59,280 --> 00:37:01,200
it's it's not fun

878
00:37:01,200 --> 00:37:03,359
but using say freewrite it's just

879
00:37:03,359 --> 00:37:05,680
automatic

880
00:37:05,680 --> 00:37:08,560
all right i've one last slide here just

881
00:37:08,560 --> 00:37:10,400
to give you an idea of

882
00:37:10,400 --> 00:37:12,400
what things are happening with say

883
00:37:12,400 --> 00:37:15,680
freewrite i've given you examples where

884
00:37:15,680 --> 00:37:18,079
it just works and it says yes the

885
00:37:18,079 --> 00:37:20,000
reference code for this subroutine

886
00:37:20,000 --> 00:37:22,480
matches the the optimized code

887
00:37:22,480 --> 00:37:23,359
but

888
00:37:23,359 --> 00:37:26,640
if you try bigger examples then

889
00:37:26,640 --> 00:37:28,960
it will suddenly get very very slow and

890
00:37:28,960 --> 00:37:30,880
use too much memory and use too much

891
00:37:30,880 --> 00:37:32,400
time it's

892
00:37:32,400 --> 00:37:35,520
safe rewrite it has a limit on how big

893
00:37:35,520 --> 00:37:38,640
the examples can be

894
00:37:38,800 --> 00:37:41,599
but there's work for extending it to

895
00:37:41,599 --> 00:37:44,480
handle more types of post quantum crypto

896
00:37:44,480 --> 00:37:46,800
more types of pre-quantum crypto

897
00:37:46,800 --> 00:37:49,119
also for checking that the code works

898
00:37:49,119 --> 00:37:50,400
correctly

899
00:37:50,400 --> 00:37:51,680
it's

900
00:37:51,680 --> 00:37:54,720
good to have not just c reference code

901
00:37:54,720 --> 00:37:57,599
but python reference code because python

902
00:37:57,599 --> 00:37:59,119
code is simpler

903
00:37:59,119 --> 00:38:01,200
and that's something which is planned to

904
00:38:01,200 --> 00:38:03,760
have safe rewrite taking python as input

905
00:38:03,760 --> 00:38:06,160
so then you can have the simple python

906
00:38:06,160 --> 00:38:08,960
reference checked against the c code

907
00:38:08,960 --> 00:38:10,560
and then there's more things to try to

908
00:38:10,560 --> 00:38:12,320
speed it up and make it easier to use

909
00:38:12,320 --> 00:38:14,480
for

910
00:38:14,720 --> 00:38:17,040
software engineering and to make sure

911
00:38:17,040 --> 00:38:19,359
everything uh works correctly and

912
00:38:19,359 --> 00:38:21,119
finally last lines here there are

913
00:38:21,119 --> 00:38:23,839
various other projects that uh

914
00:38:23,839 --> 00:38:26,000
you should take a look at i'll mention

915
00:38:26,000 --> 00:38:28,240
one of these which is crypto line which

916
00:38:28,240 --> 00:38:30,400
is developed right here at academia

917
00:38:30,400 --> 00:38:33,119
cynica and you have the top experts in

918
00:38:33,119 --> 00:38:35,599
the audience

919
00:38:36,079 --> 00:38:37,040
but

920
00:38:37,040 --> 00:38:38,320
well all of these projects have

921
00:38:38,320 --> 00:38:40,079
different cool things they can do and

922
00:38:40,079 --> 00:38:41,520
unfortunately i don't have enough time

923
00:38:41,520 --> 00:38:43,520
to go through all of them so i will stop

924
00:38:43,520 --> 00:38:46,700
here thank you for your attention

925
00:38:46,700 --> 00:38:47,410
[Applause]

926
00:38:47,410 --> 00:38:51,870
[Music]

927
00:38:52,240 --> 00:38:54,560
okay so uh

928
00:38:54,560 --> 00:38:57,760
i can translate any uh

929
00:38:57,760 --> 00:39:01,040
questions if needed

930
00:39:07,000 --> 00:39:10,000
[Music]

931
00:39:10,000 --> 00:39:13,400
is this okay

932
00:39:14,000 --> 00:39:16,480
you have warned us that

933
00:39:16,480 --> 00:39:17,280
this

934
00:39:17,280 --> 00:39:19,760
software safely write

935
00:39:19,760 --> 00:39:22,000
spend a lot of time and

936
00:39:22,000 --> 00:39:24,960
use a lot of memory when you use it for

937
00:39:24,960 --> 00:39:26,640
example in

938
00:39:26,640 --> 00:39:30,240
just simple encode dusty or or even even

939
00:39:30,240 --> 00:39:31,280
simpler

940
00:39:31,280 --> 00:39:32,480
comparison

941
00:39:32,480 --> 00:39:33,599
so

942
00:39:33,599 --> 00:39:36,720
uh what is that what is that is this is

943
00:39:36,720 --> 00:39:39,599
the amount of time

944
00:39:39,599 --> 00:39:40,560
memory

945
00:39:40,560 --> 00:39:43,200
we use can you give in

946
00:39:43,200 --> 00:39:44,160
and

947
00:39:44,160 --> 00:39:46,000
and

948
00:39:46,000 --> 00:39:49,040
is that example for example uh

949
00:39:49,040 --> 00:39:51,359
in the comparison case

950
00:39:51,359 --> 00:39:54,000
how many common memories

951
00:39:54,000 --> 00:39:54,960
are used

952
00:39:54,960 --> 00:39:57,200
and what why

953
00:39:57,200 --> 00:39:58,880
uh how

954
00:39:58,880 --> 00:40:00,079
how much time

955
00:40:00,079 --> 00:40:03,119
you use in some specific so this

956
00:40:03,119 --> 00:40:05,839
provider cpu

957
00:40:05,839 --> 00:40:08,560
so the the comparison example actually

958
00:40:08,560 --> 00:40:11,040
is reasonably fast it's not something

959
00:40:11,040 --> 00:40:12,880
that you would want to do

960
00:40:12,880 --> 00:40:16,240
inside a development cycle i mean we're

961
00:40:16,240 --> 00:40:18,800
talking like on the scale of a minute

962
00:40:18,800 --> 00:40:20,400
which you don't want to sit there

963
00:40:20,400 --> 00:40:22,720
waiting a minute for the

964
00:40:22,720 --> 00:40:24,480
computer but as part of like a

965
00:40:24,480 --> 00:40:26,800
continuous integration process then a

966
00:40:26,800 --> 00:40:28,079
minute is fine

967
00:40:28,079 --> 00:40:30,720
um some of the bigger examples like the

968
00:40:30,720 --> 00:40:34,000
encode doing that one fully is

969
00:40:34,000 --> 00:40:36,240
significantly longer but i mean less

970
00:40:36,240 --> 00:40:39,200
than a day um and then some bigger

971
00:40:39,200 --> 00:40:43,040
examples the the time can really explode

972
00:40:43,040 --> 00:40:45,280
because these i mean

973
00:40:45,280 --> 00:40:48,160
symbolic testing and in particular the

974
00:40:48,160 --> 00:40:50,800
things done inside z3 and in the theorem

975
00:40:50,800 --> 00:40:53,760
prover for smt solving they they

976
00:40:53,760 --> 00:40:56,319
understand many things but if it's just

977
00:40:56,319 --> 00:40:58,800
a little too complicated then they sit

978
00:40:58,800 --> 00:41:01,520
there forever i mean eventually in

979
00:41:01,520 --> 00:41:03,920
theory they'll finish but um they might

980
00:41:03,920 --> 00:41:07,359
use a ridiculous amount of time i mean

981
00:41:07,359 --> 00:41:08,240
in

982
00:41:08,240 --> 00:41:11,200
in the end it's possible for these

983
00:41:11,200 --> 00:41:13,760
smt solvers to fall back to basically

984
00:41:13,760 --> 00:41:15,440
trying every input

985
00:41:15,440 --> 00:41:17,040
which i mean something like the

986
00:41:17,040 --> 00:41:18,880
comparison example

987
00:41:18,880 --> 00:41:20,880
it's obviously much faster than trying

988
00:41:20,880 --> 00:41:22,079
every input

989
00:41:22,079 --> 00:41:22,960
but

990
00:41:22,960 --> 00:41:25,760
in the end the smt solvers well you can

991
00:41:25,760 --> 00:41:27,920
easily make cases where it just gets

992
00:41:27,920 --> 00:41:30,720
very very slow very like suddenly super

993
00:41:30,720 --> 00:41:34,000
slow um so then there's various games

994
00:41:34,000 --> 00:41:36,160
that well the the cuts line here there

995
00:41:36,160 --> 00:41:38,720
there's various techniques that are used

996
00:41:38,720 --> 00:41:39,440
to

997
00:41:39,440 --> 00:41:42,160
use smt solvers for parts of your

998
00:41:42,160 --> 00:41:45,040
reasoning and then put together several

999
00:41:45,040 --> 00:41:47,920
different uh chains of like make a chain

1000
00:41:47,920 --> 00:41:50,000
of reasoning from

1001
00:41:50,000 --> 00:41:51,520
saying here's your optimized code and

1002
00:41:51,520 --> 00:41:53,040
match that up to your your reference

1003
00:41:53,040 --> 00:41:54,079
code

1004
00:41:54,079 --> 00:41:56,079
and then the memory is

1005
00:41:56,079 --> 00:41:57,359
it's

1006
00:41:57,359 --> 00:41:59,280
again it can explode to some

1007
00:41:59,280 --> 00:42:02,079
unreasonable amount um that's tends to

1008
00:42:02,079 --> 00:42:03,920
be less of a problem than the the time

1009
00:42:03,920 --> 00:42:06,560
but it can be that the memory just if if

1010
00:42:06,560 --> 00:42:08,079
you don't have a reasonable amount of

1011
00:42:08,079 --> 00:42:10,000
memory you can get into trouble with

1012
00:42:10,000 --> 00:42:12,319
memory

1013
00:42:15,440 --> 00:42:18,400
we we have three more minutes any more

1014
00:42:18,400 --> 00:42:19,599
questions

1015
00:42:19,599 --> 00:42:22,480
hi owen tima

1016
00:42:29,200 --> 00:42:31,359
so uh

1017
00:42:31,359 --> 00:42:32,720
a uh

1018
00:42:32,720 --> 00:42:35,839
a question um which is uh

1019
00:42:35,839 --> 00:42:36,880
um

1020
00:42:36,880 --> 00:42:39,119
what other languages are you trying are

1021
00:42:39,119 --> 00:42:41,119
you hoping to support

1022
00:42:41,119 --> 00:42:42,880
uh so currently

1023
00:42:42,880 --> 00:42:45,839
it will take whatever c code you you

1024
00:42:45,839 --> 00:42:49,359
give it or assembly or rust there's a

1025
00:42:49,359 --> 00:42:51,599
few rust examples

1026
00:42:51,599 --> 00:42:54,000
and then compile those to machine

1027
00:42:54,000 --> 00:42:56,319
language and then

1028
00:42:56,319 --> 00:42:58,720
anything that can be compiled to machine

1029
00:42:58,720 --> 00:43:01,119
language should be easy to integrate

1030
00:43:01,119 --> 00:43:02,240
because

1031
00:43:02,240 --> 00:43:04,560
valgrind understands machine language

1032
00:43:04,560 --> 00:43:05,359
and

1033
00:43:05,359 --> 00:43:07,680
anger understands machine language so

1034
00:43:07,680 --> 00:43:09,520
it's anything that can turn into a

1035
00:43:09,520 --> 00:43:12,720
binary you can in principle use

1036
00:43:12,720 --> 00:43:14,720
right now and they the examples again

1037
00:43:14,720 --> 00:43:17,040
are c assembly and rust

1038
00:43:17,040 --> 00:43:17,920
now

1039
00:43:17,920 --> 00:43:20,480
in reality something like python if you

1040
00:43:20,480 --> 00:43:23,520
compile python into

1041
00:43:23,520 --> 00:43:25,680
well machine language with tools like

1042
00:43:25,680 --> 00:43:28,160
cython for example or just running pi pi

1043
00:43:28,160 --> 00:43:29,440
inside

1044
00:43:29,440 --> 00:43:31,839
an emulator um

1045
00:43:31,839 --> 00:43:34,240
you you end up with code which is much

1046
00:43:34,240 --> 00:43:37,040
too slow like much too big for these

1047
00:43:37,040 --> 00:43:38,800
tools to read through and that's another

1048
00:43:38,800 --> 00:43:41,040
of these sort of failure cases where in

1049
00:43:41,040 --> 00:43:43,520
theory it could work but in reality it's

1050
00:43:43,520 --> 00:43:44,319
uh

1051
00:43:44,319 --> 00:43:46,240
it's it's too slow

1052
00:43:46,240 --> 00:43:49,119
so the the idea of supporting python is

1053
00:43:49,119 --> 00:43:52,400
to have python converted directly into

1054
00:43:52,400 --> 00:43:55,280
unrolled code without going through

1055
00:43:55,280 --> 00:43:57,440
binaries and that will be something

1056
00:43:57,440 --> 00:43:59,680
which avoids all the complications of

1057
00:43:59,680 --> 00:44:01,200
dealing with

1058
00:44:01,200 --> 00:44:04,960
how what happens when you compile python

1059
00:44:04,960 --> 00:44:06,960
but anyway in principle it can be any

1060
00:44:06,960 --> 00:44:08,720
language that's converted into machine

1061
00:44:08,720 --> 00:44:12,160
language plus the ideas to support more

1062
00:44:12,160 --> 00:44:14,560
languages that are unrolled through

1063
00:44:14,560 --> 00:44:18,160
extra support for those languages

1064
00:44:20,960 --> 00:44:23,040
any problem any more questions from the

1065
00:44:23,040 --> 00:44:25,440
audience

1066
00:44:28,960 --> 00:44:31,230
here

1067
00:44:31,230 --> 00:44:32,800
[Applause]

1068
00:44:32,800 --> 00:44:34,500
[Music]

1069
00:44:34,500 --> 00:44:37,730
[Applause]

