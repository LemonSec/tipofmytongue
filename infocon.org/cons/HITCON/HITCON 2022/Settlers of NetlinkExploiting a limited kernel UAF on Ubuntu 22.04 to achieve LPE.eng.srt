1
00:01:05,119 --> 00:01:06,960
uh thanks for coming

2
00:01:06,960 --> 00:01:09,119
um yeah so i'm going to talk about a

3
00:01:09,119 --> 00:01:11,600
recent linux kernel use after free bug

4
00:01:11,600 --> 00:01:13,760
that we exploited

5
00:01:13,760 --> 00:01:15,680
so a little bit about me yeah i work for

6
00:01:15,680 --> 00:01:17,680
ncc group i specifically work for a

7
00:01:17,680 --> 00:01:18,720
group called

8
00:01:18,720 --> 00:01:20,960
edg exploit development group which is

9
00:01:20,960 --> 00:01:23,040
just three people

10
00:01:23,040 --> 00:01:24,799
mostly focusing on

11
00:01:24,799 --> 00:01:26,560
end days but recently we started doing

12
00:01:26,560 --> 00:01:28,479
some phone to own competitions

13
00:01:28,479 --> 00:01:30,799
so recently we targeted like a nas and a

14
00:01:30,799 --> 00:01:32,479
printer and released some blogs about

15
00:01:32,479 --> 00:01:33,360
that

16
00:01:33,360 --> 00:01:35,119
and yeah i've been living in taiwan for

17
00:01:35,119 --> 00:01:37,360
about three years and aside from some

18
00:01:37,360 --> 00:01:39,360
height issues which you can see i seem

19
00:01:39,360 --> 00:01:41,920
to be fitting in okay

20
00:01:41,920 --> 00:01:44,240
so yeah we basically originally wanted

21
00:01:44,240 --> 00:01:45,600
to

22
00:01:45,600 --> 00:01:48,479
participate in pawn to own desktop

23
00:01:48,479 --> 00:01:50,640
2022

24
00:01:50,640 --> 00:01:51,920
and we was going pretty good we

25
00:01:51,920 --> 00:01:54,159
originally found one vulnerability and

26
00:01:54,159 --> 00:01:55,920
exploited it and it was working fine and

27
00:01:55,920 --> 00:01:58,560
then it got publicly patched

28
00:01:58,560 --> 00:02:00,240
quite a bit before the competition and

29
00:02:00,240 --> 00:02:02,399
so we had to start from scratch

30
00:02:02,399 --> 00:02:04,799
and then we found a second bug and

31
00:02:04,799 --> 00:02:06,320
we're in the process of exploiting it

32
00:02:06,320 --> 00:02:09,038
and it also got published publicly and

33
00:02:09,038 --> 00:02:11,440
patched so we had to start again

34
00:02:11,440 --> 00:02:12,879
and then in the process of exploiting

35
00:02:12,879 --> 00:02:14,800
that we ended up falling short by about

36
00:02:14,800 --> 00:02:17,120
a week

37
00:02:17,680 --> 00:02:18,640
but

38
00:02:18,640 --> 00:02:20,560
we decided to disclose the bug anyways

39
00:02:20,560 --> 00:02:21,760
just because we didn't really want to

40
00:02:21,760 --> 00:02:22,879
wait a year

41
00:02:22,879 --> 00:02:24,319
just because there might be a collision

42
00:02:24,319 --> 00:02:25,920
and it just seemed weird to sit on it

43
00:02:25,920 --> 00:02:28,560
for a year so this talk is about

44
00:02:28,560 --> 00:02:30,239
basically how we exploited that third

45
00:02:30,239 --> 00:02:31,920
bug

46
00:02:31,920 --> 00:02:33,440
and we targeted the latest version of

47
00:02:33,440 --> 00:02:35,920
ubuntu which is running five our kernel

48
00:02:35,920 --> 00:02:37,519
5.15

49
00:02:37,519 --> 00:02:39,280
um as far as like the tooling that we

50
00:02:39,280 --> 00:02:41,680
used for uh kernel debugging and stuff

51
00:02:41,680 --> 00:02:43,280
it's all pretty standard i just wanted

52
00:02:43,280 --> 00:02:46,239
to mostly note that there's a kernel

53
00:02:46,239 --> 00:02:47,599
um

54
00:02:47,599 --> 00:02:49,200
like debugging python script that's

55
00:02:49,200 --> 00:02:51,400
included in the kernel sources called

56
00:02:51,400 --> 00:02:53,200
vmlinuxgdb.pi which it seems like a

57
00:02:53,200 --> 00:02:54,560
bunch of people don't know about and it

58
00:02:54,560 --> 00:02:56,160
helps with analyzing certain data

59
00:02:56,160 --> 00:02:57,440
structures and stuff so it's worth

60
00:02:57,440 --> 00:02:58,560
checking out

61
00:02:58,560 --> 00:03:00,480
and yeah otherwise we just use like pa

62
00:03:00,480 --> 00:03:03,120
hole for analyzing structure sizes and

63
00:03:03,120 --> 00:03:04,959
code ql to do some queries which i'll

64
00:03:04,959 --> 00:03:07,680
talk about in a little bit

65
00:03:07,680 --> 00:03:09,760
we also ended up writing a custom tool

66
00:03:09,760 --> 00:03:12,319
to do the slab cache analysis for the

67
00:03:12,319 --> 00:03:14,720
slab allocator we were originally using

68
00:03:14,720 --> 00:03:18,000
apptrace but we found it was not really

69
00:03:18,000 --> 00:03:20,640
suited to what we were wanting to do

70
00:03:20,640 --> 00:03:22,080
we're going to release it open source

71
00:03:22,080 --> 00:03:24,400
eventually but it's not

72
00:03:24,400 --> 00:03:26,239
publicly yet

73
00:03:26,239 --> 00:03:28,239
so you can check it out once we release

74
00:03:28,239 --> 00:03:29,360
it

75
00:03:29,360 --> 00:03:31,200
um yeah so basically i'm going to go

76
00:03:31,200 --> 00:03:34,159
over some background about just netlink

77
00:03:34,159 --> 00:03:36,159
netfilter and nf tables in the linux

78
00:03:36,159 --> 00:03:38,000
kernel and how they work quickly just

79
00:03:38,000 --> 00:03:39,599
enough to understand what the bug is and

80
00:03:39,599 --> 00:03:42,400
then how we exploited it in a quick

81
00:03:42,400 --> 00:03:45,120
overview of what the patch looked like

82
00:03:45,120 --> 00:03:46,640
so

83
00:03:46,640 --> 00:03:47,760
um

84
00:03:47,760 --> 00:03:50,000
some people that do linux admin or just

85
00:03:50,000 --> 00:03:51,680
use linux in general might be familiar

86
00:03:51,680 --> 00:03:53,760
with the nft command line

87
00:03:53,760 --> 00:03:55,519
interface and it's it's just like a

88
00:03:55,519 --> 00:03:57,200
command line tool for configuring the

89
00:03:57,200 --> 00:03:59,439
firewall and so like the example is if

90
00:03:59,439 --> 00:04:01,840
you want to block port 80 you just run

91
00:04:01,840 --> 00:04:04,159
nft and give it a little rule and it's

92
00:04:04,159 --> 00:04:05,760
really well documented there's all sorts

93
00:04:05,760 --> 00:04:07,120
of different rules you can build with

94
00:04:07,120 --> 00:04:08,799
lots of complexity and we're

95
00:04:08,799 --> 00:04:10,400
predominantly interested in what's going

96
00:04:10,400 --> 00:04:11,840
on underneath

97
00:04:11,840 --> 00:04:14,000
and so basically what's underneath is

98
00:04:14,000 --> 00:04:15,040
all built

99
00:04:15,040 --> 00:04:16,720
on something called netlink which is

100
00:04:16,720 --> 00:04:18,798
just like a socket that you can create

101
00:04:18,798 --> 00:04:21,600
for userland to talk with the kernel and

102
00:04:21,600 --> 00:04:23,360
access certain underlying network

103
00:04:23,360 --> 00:04:25,440
functionality and there's pretty good

104
00:04:25,440 --> 00:04:27,840
libraries for using it to

105
00:04:27,840 --> 00:04:29,440
abstract a lot of the complexity because

106
00:04:29,440 --> 00:04:32,720
it's kind of annoying to just do by hand

107
00:04:32,720 --> 00:04:34,160
and then generally you're talking with

108
00:04:34,160 --> 00:04:36,639
like this net filter layer which is like

109
00:04:36,639 --> 00:04:38,240
essentially a bunch of hooks into

110
00:04:38,240 --> 00:04:40,000
different parts of the

111
00:04:40,000 --> 00:04:42,880
linux networking subsystems that just

112
00:04:42,880 --> 00:04:44,639
expose some functionality that you can

113
00:04:44,639 --> 00:04:46,639
send packets to interact with so

114
00:04:46,639 --> 00:04:48,160
examples are like network address

115
00:04:48,160 --> 00:04:50,479
translation and the

116
00:04:50,479 --> 00:04:52,560
nf tables which is what we're interested

117
00:04:52,560 --> 00:04:54,880
in and basically nf tables is like a

118
00:04:54,880 --> 00:04:57,919
newer kernel newer like maybe 10 years

119
00:04:57,919 --> 00:04:59,280
old

120
00:04:59,280 --> 00:05:01,360
for the next generation firewall which

121
00:05:01,360 --> 00:05:04,000
basically replaced ip tables and it's

122
00:05:04,000 --> 00:05:06,080
also pretty annoying to

123
00:05:06,080 --> 00:05:07,680
interact with

124
00:05:07,680 --> 00:05:09,360
over netlink like if you have to craft

125
00:05:09,360 --> 00:05:10,800
everything yourself so there's also a

126
00:05:10,800 --> 00:05:12,960
pretty nice helper library that you can

127
00:05:12,960 --> 00:05:14,080
use for that

128
00:05:14,080 --> 00:05:16,000
and i guess most importantly from

129
00:05:16,000 --> 00:05:18,960
exploitation perspective it's

130
00:05:18,960 --> 00:05:21,759
all exposed through this net admin

131
00:05:21,759 --> 00:05:24,160
capability and basically an unprivileged

132
00:05:24,160 --> 00:05:26,160
user can get access to this capability

133
00:05:26,160 --> 00:05:29,680
by entering um a namespace and like on

134
00:05:29,680 --> 00:05:32,080
ubuntu by default is configured to allow

135
00:05:32,080 --> 00:05:34,000
unprivileged users to enter namespaces

136
00:05:34,000 --> 00:05:35,759
so that's how

137
00:05:35,759 --> 00:05:37,440
it gets exposed

138
00:05:37,440 --> 00:05:38,400
and

139
00:05:38,400 --> 00:05:40,320
yeah it turns out that like

140
00:05:40,320 --> 00:05:42,240
nf tables has been a pretty popular

141
00:05:42,240 --> 00:05:45,039
target this year

142
00:05:45,680 --> 00:05:47,280
there's been quite a few blog posts and

143
00:05:47,280 --> 00:05:49,360
bugs most notably there's one by david

144
00:05:49,360 --> 00:05:52,080
bowman which is in april 2022 and he

145
00:05:52,080 --> 00:05:54,240
goes through a whole bunch of details

146
00:05:54,240 --> 00:05:56,000
about how it works and

147
00:05:56,000 --> 00:05:58,880
um it's if you want to follow up on any

148
00:05:58,880 --> 00:06:00,960
of what i'm about to talk about or read

149
00:06:00,960 --> 00:06:02,000
the blog that we're going to end up

150
00:06:02,000 --> 00:06:03,199
releasing

151
00:06:03,199 --> 00:06:05,280
i definitely recommend you really are at

152
00:06:05,280 --> 00:06:07,199
the very minimum read the blog by david

153
00:06:07,199 --> 00:06:08,160
bowman

154
00:06:08,160 --> 00:06:10,240
um and another noteworthy thing this

155
00:06:10,240 --> 00:06:12,479
year was that someone actually succeeded

156
00:06:12,479 --> 00:06:14,880
at pawn to own in exploiting ubuntu and

157
00:06:14,880 --> 00:06:17,440
they ended up exploiting a different bug

158
00:06:17,440 --> 00:06:19,440
in nf tables

159
00:06:19,440 --> 00:06:21,919
um so yeah there's a few important sort

160
00:06:21,919 --> 00:06:23,919
of terms related to nf tables that you

161
00:06:23,919 --> 00:06:26,319
need to understand to unders like know

162
00:06:26,319 --> 00:06:28,319
how the bug works but basically

163
00:06:28,319 --> 00:06:31,280
everything's sort of

164
00:06:31,280 --> 00:06:33,440
grouped into tables so a table is

165
00:06:33,440 --> 00:06:35,600
typically like a group of chains that's

166
00:06:35,600 --> 00:06:37,680
associated with some networking protocol

167
00:06:37,680 --> 00:06:39,759
like ipv4 or whatever

168
00:06:39,759 --> 00:06:42,080
and then each chain actually holds like

169
00:06:42,080 --> 00:06:45,199
a set of rules um for processing packets

170
00:06:45,199 --> 00:06:46,960
that are coming in over that protocol

171
00:06:46,960 --> 00:06:48,880
and typically there's like an acceptor

172
00:06:48,880 --> 00:06:51,360
deny policy that's associated by default

173
00:06:51,360 --> 00:06:52,960
with that chain

174
00:06:52,960 --> 00:06:55,440
and then rule itself is basically a

175
00:06:55,440 --> 00:06:57,440
group of these things called expressions

176
00:06:57,440 --> 00:07:01,120
that each get sort of run

177
00:07:01,120 --> 00:07:03,360
in sequence to process the actual packet

178
00:07:03,360 --> 00:07:05,280
data that's coming in

179
00:07:05,280 --> 00:07:06,880
um

180
00:07:06,880 --> 00:07:08,479
and then yeah there's a whole bunch of

181
00:07:08,479 --> 00:07:10,880
different types of expressions there's

182
00:07:10,880 --> 00:07:13,120
way too many to cover in general but

183
00:07:13,120 --> 00:07:14,319
we're basically

184
00:07:14,319 --> 00:07:16,080
interested in three for the purposes of

185
00:07:16,080 --> 00:07:18,800
exploitation which i'll go over in a sec

186
00:07:18,800 --> 00:07:20,560
and then there's the context uh the

187
00:07:20,560 --> 00:07:22,560
concept of sets which is effectively

188
00:07:22,560 --> 00:07:24,479
just like sets of data that you can

189
00:07:24,479 --> 00:07:26,160
provide in these sort of rules that

190
00:07:26,160 --> 00:07:27,599
you're creating

191
00:07:27,599 --> 00:07:29,360
when you're using like nft so you can

192
00:07:29,360 --> 00:07:31,120
imagine if you have a list of ports that

193
00:07:31,120 --> 00:07:32,720
you want to

194
00:07:32,720 --> 00:07:34,960
block or like blacklisted ips or

195
00:07:34,960 --> 00:07:36,720
whatever whenever you have this set of

196
00:07:36,720 --> 00:07:38,720
like data elements it gets associated

197
00:07:38,720 --> 00:07:41,599
with this set structure and it all gets

198
00:07:41,599 --> 00:07:43,840
um stored in like a high performance

199
00:07:43,840 --> 00:07:46,080
data structure and each like piece of

200
00:07:46,080 --> 00:07:49,199
data is just referred to as an element

201
00:07:49,199 --> 00:07:51,599
um and so we're specifically interested

202
00:07:51,599 --> 00:07:55,599
in sets that's the name of the talk um

203
00:07:55,599 --> 00:07:57,039
and basically yeah it's a fairly

204
00:07:57,039 --> 00:07:59,440
complicated large structure

205
00:07:59,440 --> 00:08:01,520
just responsible for holding

206
00:08:01,520 --> 00:08:04,160
you know these lists of data

207
00:08:04,160 --> 00:08:05,440
so there's a few

208
00:08:05,440 --> 00:08:07,280
fields that we're especially interested

209
00:08:07,280 --> 00:08:09,759
in during exploitation

210
00:08:09,759 --> 00:08:11,759
the first one is the the member list

211
00:08:11,759 --> 00:08:13,520
which is effectively just a doubly

212
00:08:13,520 --> 00:08:15,759
linked list of other set structures

213
00:08:15,759 --> 00:08:18,400
associated with the same table

214
00:08:18,400 --> 00:08:20,400
there's also a bindings doubly linked

215
00:08:20,400 --> 00:08:21,919
list and basically

216
00:08:21,919 --> 00:08:24,639
an expression can reference some data on

217
00:08:24,639 --> 00:08:26,879
a set and when it does reference that

218
00:08:26,879 --> 00:08:29,199
set it's bound to the set and gets added

219
00:08:29,199 --> 00:08:31,680
to this doubly linked list

220
00:08:31,680 --> 00:08:33,519
and then there's stuff like a name

221
00:08:33,519 --> 00:08:35,200
of the set so when you're using an

222
00:08:35,200 --> 00:08:36,719
expression and you want to reference a

223
00:08:36,719 --> 00:08:37,760
set

224
00:08:37,760 --> 00:08:39,760
you need to look it up somehow and so it

225
00:08:39,760 --> 00:08:42,159
typically has a name associated with it

226
00:08:42,159 --> 00:08:43,440
and then there's things like reference

227
00:08:43,440 --> 00:08:44,959
count

228
00:08:44,959 --> 00:08:46,480
and interestingly there's there's the

229
00:08:46,480 --> 00:08:48,399
concept of user data so when you send

230
00:08:48,399 --> 00:08:49,760
like a netlink

231
00:08:49,760 --> 00:08:51,760
message to create a set you can provide

232
00:08:51,760 --> 00:08:53,839
a certain amount of like custom data

233
00:08:53,839 --> 00:08:56,240
that gets stored in line inside of the

234
00:08:56,240 --> 00:08:58,080
structure that's allocated on the slab

235
00:08:58,080 --> 00:08:58,959
cache

236
00:08:58,959 --> 00:08:59,760
and

237
00:08:59,760 --> 00:09:01,760
you can actually read that back after

238
00:09:01,760 --> 00:09:04,240
the fact from userland and so that's

239
00:09:04,240 --> 00:09:06,480
pointed to by the u data member and then

240
00:09:06,480 --> 00:09:08,320
there's also a ud lan which is just the

241
00:09:08,320 --> 00:09:10,640
length of whatever uh yeah custom data

242
00:09:10,640 --> 00:09:11,839
you provided

243
00:09:11,839 --> 00:09:14,160
and then there's a function pointer uh

244
00:09:14,160 --> 00:09:15,680
yeah function pointer table which is

245
00:09:15,680 --> 00:09:17,920
kind of uh useful

246
00:09:17,920 --> 00:09:19,360
and then um

247
00:09:19,360 --> 00:09:21,040
yeah so this structure

248
00:09:21,040 --> 00:09:23,760
normally is allocated on the 512 byte

249
00:09:23,760 --> 00:09:26,720
slab cache but because of the

250
00:09:26,720 --> 00:09:29,120
user data that you can add

251
00:09:29,120 --> 00:09:31,279
um

252
00:09:31,279 --> 00:09:34,000
you can also bump it up to 1024 bytes if

253
00:09:34,000 --> 00:09:34,839
you want

254
00:09:34,839 --> 00:09:36,720
to um

255
00:09:36,720 --> 00:09:37,839
so yeah

256
00:09:37,839 --> 00:09:38,959
we're going to be specifically

257
00:09:38,959 --> 00:09:40,880
interested in this bindings

258
00:09:40,880 --> 00:09:42,720
member as well so as i said it's

259
00:09:42,720 --> 00:09:44,560
basically a doubly linked list

260
00:09:44,560 --> 00:09:46,959
and any expression that references the

261
00:09:46,959 --> 00:09:48,959
set that is bound to it will have this

262
00:09:48,959 --> 00:09:51,440
embedded nft set binding structure in it

263
00:09:51,440 --> 00:09:53,519
which has a list member

264
00:09:53,519 --> 00:09:54,480
and

265
00:09:54,480 --> 00:09:56,240
basically that's what the doubly linked

266
00:09:56,240 --> 00:09:57,600
list is going to be pointing to it

267
00:09:57,600 --> 00:09:59,279
doesn't point to the

268
00:09:59,279 --> 00:10:03,120
head of the expression structure itself

269
00:10:03,120 --> 00:10:04,800
and then so that kind of leads nicely

270
00:10:04,800 --> 00:10:06,959
into what exactly is an expression look

271
00:10:06,959 --> 00:10:09,440
like um basically all expressions extend

272
00:10:09,440 --> 00:10:11,040
from this specific

273
00:10:11,040 --> 00:10:12,640
structure which is just called nft

274
00:10:12,640 --> 00:10:14,800
underscore expression and it's got one

275
00:10:14,800 --> 00:10:16,720
member which is a function pointer table

276
00:10:16,720 --> 00:10:19,279
and then just inline data so basically

277
00:10:19,279 --> 00:10:20,800
whenever you've got a specific

278
00:10:20,800 --> 00:10:23,360
expression type you end up calling this

279
00:10:23,360 --> 00:10:25,519
little helper function that just returns

280
00:10:25,519 --> 00:10:26,320
the

281
00:10:26,320 --> 00:10:28,399
pointer to data which has the actual

282
00:10:28,399 --> 00:10:31,680
like expression specific stuff inside

283
00:10:31,680 --> 00:10:33,680
but it all will like every expression

284
00:10:33,680 --> 00:10:35,920
will also contain this ops member and

285
00:10:35,920 --> 00:10:38,320
it's mostly just noteworthy because

286
00:10:38,320 --> 00:10:39,680
if you want to figure out where an

287
00:10:39,680 --> 00:10:41,760
expression like what slab cache and

288
00:10:41,760 --> 00:10:44,160
expression is actually allocated on and

289
00:10:44,160 --> 00:10:45,519
you just look at the expression

290
00:10:45,519 --> 00:10:47,440
structure it's going to be misleading so

291
00:10:47,440 --> 00:10:49,519
you need to keep in mind that it um

292
00:10:49,519 --> 00:10:51,279
includes this little bit

293
00:10:51,279 --> 00:10:53,120
so yeah as far as the strike like the

294
00:10:53,120 --> 00:10:54,959
expressions we're interested in there's

295
00:10:54,959 --> 00:10:56,880
one called a lookup structure which is

296
00:10:56,880 --> 00:10:59,120
basically just for fetching some value

297
00:10:59,120 --> 00:11:02,480
from a key in the set that you specify

298
00:11:02,480 --> 00:11:05,519
it's allocated on the 48 byte slab cache

299
00:11:05,519 --> 00:11:07,120
and we're mostly just interested in the

300
00:11:07,120 --> 00:11:08,800
fact that the binding member in that

301
00:11:08,800 --> 00:11:11,360
structure is at offset 10 it's the last

302
00:11:11,360 --> 00:11:13,360
member and similarly there's this other

303
00:11:13,360 --> 00:11:16,320
expression called dynamic set expression

304
00:11:16,320 --> 00:11:17,519
um

305
00:11:17,519 --> 00:11:20,079
and basically um

306
00:11:20,079 --> 00:11:22,720
yeah it's just on the 96 byte slab cache

307
00:11:22,720 --> 00:11:25,040
and again we're not so interested in

308
00:11:25,040 --> 00:11:26,640
what the expressions do themselves we're

309
00:11:26,640 --> 00:11:28,320
just interested in a bit of properties

310
00:11:28,320 --> 00:11:29,920
and you'll see why later

311
00:11:29,920 --> 00:11:33,120
but in this case the the binding list

312
00:11:33,120 --> 00:11:35,200
member is also at the end and it's at

313
00:11:35,200 --> 00:11:38,480
offset hex 38.

314
00:11:38,480 --> 00:11:40,160
so yeah what this would normally look

315
00:11:40,160 --> 00:11:42,720
like is you have some set and there's

316
00:11:42,720 --> 00:11:44,560
multiple expressions referencing it so

317
00:11:44,560 --> 00:11:46,160
they get added to

318
00:11:46,160 --> 00:11:48,240
the doubly linked list so just sort of

319
00:11:48,240 --> 00:11:50,800
normal linked list stuff and then again

320
00:11:50,800 --> 00:11:52,640
i mentioned the table can have multiple

321
00:11:52,640 --> 00:11:54,320
sets associated with it on its own

322
00:11:54,320 --> 00:11:56,480
linked list so this is just basically

323
00:11:56,480 --> 00:11:58,399
what that looks like and each set could

324
00:11:58,399 --> 00:12:00,399
have a certain number of expressions

325
00:12:00,399 --> 00:12:02,399
associated with it

326
00:12:02,399 --> 00:12:04,800
um and so there's another important

327
00:12:04,800 --> 00:12:06,399
important point which is that when

328
00:12:06,399 --> 00:12:08,800
you're creating a set

329
00:12:08,800 --> 00:12:09,680
um

330
00:12:09,680 --> 00:12:12,160
they basically let you embed expressions

331
00:12:12,160 --> 00:12:14,000
in the set and it's a little bit

332
00:12:14,000 --> 00:12:15,600
different than what i mentioned where

333
00:12:15,600 --> 00:12:18,000
expressions are run against packet data

334
00:12:18,000 --> 00:12:19,440
the idea is that you can basically

335
00:12:19,440 --> 00:12:21,839
describe certain expressions that get

336
00:12:21,839 --> 00:12:24,880
part like processed when data is being

337
00:12:24,880 --> 00:12:26,720
added to the set or

338
00:12:26,720 --> 00:12:28,639
changed on the set

339
00:12:28,639 --> 00:12:29,920
and so yeah basically when you're

340
00:12:29,920 --> 00:12:31,279
creating the site you can say here's

341
00:12:31,279 --> 00:12:33,200
some embedded expressions

342
00:12:33,200 --> 00:12:35,200
but there's a rule about that which is

343
00:12:35,200 --> 00:12:36,560
that they have to be stateful

344
00:12:36,560 --> 00:12:38,160
expressions and there's only a limited

345
00:12:38,160 --> 00:12:40,000
number of expressions

346
00:12:40,000 --> 00:12:42,160
of this type stateful

347
00:12:42,160 --> 00:12:44,399
so that's basically like a whirlwind

348
00:12:44,399 --> 00:12:46,639
tour of like the pieces that we need to

349
00:12:46,639 --> 00:12:49,200
know to sort of understand the bug

350
00:12:49,200 --> 00:12:50,880
um yeah so

351
00:12:50,880 --> 00:12:53,120
we release a pretty in-depth

352
00:12:53,120 --> 00:12:54,880
analysis of the bug already but we're

353
00:12:54,880 --> 00:12:56,399
going to release a blog with a lot more

354
00:12:56,399 --> 00:12:58,560
detail about everything later but

355
00:12:58,560 --> 00:13:00,160
basically we've

356
00:13:00,160 --> 00:13:02,720
we found the bug just using fuzzing and

357
00:13:02,720 --> 00:13:05,360
interestingly in this case

358
00:13:05,360 --> 00:13:07,040
ciscollar couldn't automatically

359
00:13:07,040 --> 00:13:10,480
regenerate or generate a reprofile which

360
00:13:10,480 --> 00:13:12,079
was kind of like compelling to us

361
00:13:12,079 --> 00:13:14,079
because we had already had two bugs that

362
00:13:14,079 --> 00:13:16,160
we exploited burned during

363
00:13:16,160 --> 00:13:18,560
our pondon attempt uh

364
00:13:18,560 --> 00:13:20,720
our research and so having one that

365
00:13:20,720 --> 00:13:21,920
other people might think was a little

366
00:13:21,920 --> 00:13:24,800
bit harder to triage or exploit was nice

367
00:13:24,800 --> 00:13:27,519
so we ended up just triaging it manually

368
00:13:27,519 --> 00:13:29,600
and basically in the end it's a use

369
00:13:29,600 --> 00:13:31,120
after free

370
00:13:31,120 --> 00:13:33,120
um while handling expressions on the

371
00:13:33,120 --> 00:13:34,399
bindings list which may not be

372
00:13:34,399 --> 00:13:36,160
surprising given how much i talked about

373
00:13:36,160 --> 00:13:37,839
that list

374
00:13:37,839 --> 00:13:41,200
and basically all it gives you is it

375
00:13:41,200 --> 00:13:42,880
it lets you write one uncontrolled

376
00:13:42,880 --> 00:13:44,800
pointer to an uncontrolled offset which

377
00:13:44,800 --> 00:13:46,639
is fairly limited

378
00:13:46,639 --> 00:13:48,399
and interestingly someone else noticed

379
00:13:48,399 --> 00:13:50,160
that the google fuzzing infrastructure

380
00:13:50,160 --> 00:13:52,399
had actually already found the bug and

381
00:13:52,399 --> 00:13:54,399
automatically closed it as invalid at

382
00:13:54,399 --> 00:13:56,639
some point i don't know why

383
00:13:56,639 --> 00:13:58,959
but so this is like a quick overview of

384
00:13:58,959 --> 00:14:00,560
what the bug sort of looks like

385
00:14:00,560 --> 00:14:02,399
basically i mentioned you when you're

386
00:14:02,399 --> 00:14:04,000
creating a set you can embed these

387
00:14:04,000 --> 00:14:06,000
expressions inside

388
00:14:06,000 --> 00:14:08,320
and this is the function responsible for

389
00:14:08,320 --> 00:14:09,680
handling

390
00:14:09,680 --> 00:14:11,839
embedded expression and so basically

391
00:14:11,839 --> 00:14:13,920
what it does first is it calls this nft

392
00:14:13,920 --> 00:14:16,560
expression init function

393
00:14:16,560 --> 00:14:17,600
um

394
00:14:17,600 --> 00:14:19,199
and and what that does is it actually

395
00:14:19,199 --> 00:14:21,680
allocates and initializes the expression

396
00:14:21,680 --> 00:14:24,399
or the yeah the expression entirely

397
00:14:24,399 --> 00:14:26,399
and then only afterwards it ends up

398
00:14:26,399 --> 00:14:28,639
checking the flags of that expression to

399
00:14:28,639 --> 00:14:31,040
see is it stateful or not and if it's

400
00:14:31,040 --> 00:14:32,639
not stateful it just immediately

401
00:14:32,639 --> 00:14:34,959
destroys it and frees it and this is

402
00:14:34,959 --> 00:14:36,480
like weird logic because you'd think it

403
00:14:36,480 --> 00:14:38,399
would check the flag first

404
00:14:38,399 --> 00:14:40,399
um to just know if it should use it at

405
00:14:40,399 --> 00:14:42,079
all and it kind of

406
00:14:42,079 --> 00:14:43,920
opens up this weird window of if there's

407
00:14:43,920 --> 00:14:45,920
sort of a desynchronization of logic

408
00:14:45,920 --> 00:14:48,320
between the initialization routine and

409
00:14:48,320 --> 00:14:50,320
how it expects to be destroyed there

410
00:14:50,320 --> 00:14:52,320
could be some bugs there

411
00:14:52,320 --> 00:14:53,680
um

412
00:14:53,680 --> 00:14:55,360
and yeah so basically the the

413
00:14:55,360 --> 00:14:56,959
destruction routine that gets called

414
00:14:56,959 --> 00:14:58,560
after it it's

415
00:14:58,560 --> 00:15:00,480
found not to be stateful

416
00:15:00,480 --> 00:15:02,959
basically it just calls um

417
00:15:02,959 --> 00:15:05,760
the expression specific destroy function

418
00:15:05,760 --> 00:15:08,480
pointer uh and then frees the expression

419
00:15:08,480 --> 00:15:10,959
so that that's it so basically if

420
00:15:10,959 --> 00:15:13,120
there's going to be um

421
00:15:13,120 --> 00:15:15,600
any like logic for unlinking from a list

422
00:15:15,600 --> 00:15:16,959
or whatever it's going to have to be

423
00:15:16,959 --> 00:15:19,279
inside of this expressions

424
00:15:19,279 --> 00:15:20,880
destruction routine

425
00:15:20,880 --> 00:15:23,440
so um interestingly the lookup and

426
00:15:23,440 --> 00:15:25,760
dynamic set expressions when you

427
00:15:25,760 --> 00:15:28,160
initialize them they because they both

428
00:15:28,160 --> 00:15:29,839
reference a set they're going to be

429
00:15:29,839 --> 00:15:31,680
bound to this bindings doubly linked

430
00:15:31,680 --> 00:15:34,800
list using nf tables bind set but in

431
00:15:34,800 --> 00:15:36,720
their destroy method doesn't actually

432
00:15:36,720 --> 00:15:39,839
remove themselves from the the bindings

433
00:15:39,839 --> 00:15:40,639
list

434
00:15:40,639 --> 00:15:43,199
and then they just get freed and so

435
00:15:43,199 --> 00:15:45,040
they're just left dangling on this set

436
00:15:45,040 --> 00:15:47,360
bindings list which is obviously use

437
00:15:47,360 --> 00:15:50,000
after free and so any like subsequent

438
00:15:50,000 --> 00:15:51,839
list updates of adding or removing

439
00:15:51,839 --> 00:15:54,639
elements on that list gives you a

440
00:15:54,639 --> 00:15:57,759
limited right primitive

441
00:15:58,000 --> 00:15:59,199
um

442
00:15:59,199 --> 00:16:01,120
yeah so if we look at the way like the

443
00:16:01,120 --> 00:16:03,759
dynamic set in is initialized we can see

444
00:16:03,759 --> 00:16:05,680
the function i mentioned bindset which

445
00:16:05,680 --> 00:16:08,560
will put it onto the set bindings list

446
00:16:08,560 --> 00:16:10,800
and if we take a quick look at the

447
00:16:10,800 --> 00:16:13,759
destruction routine

448
00:16:13,759 --> 00:16:16,560
it basically just does some things that

449
00:16:16,560 --> 00:16:18,959
aren't related to unbinding itself from

450
00:16:18,959 --> 00:16:19,920
the set

451
00:16:19,920 --> 00:16:22,399
and then it's just done um in the last

452
00:16:22,399 --> 00:16:24,800
case it tries to destroy the set itself

453
00:16:24,800 --> 00:16:26,480
but in this case it checks whether or

454
00:16:26,480 --> 00:16:28,160
not set bindings

455
00:16:28,160 --> 00:16:29,680
is empty or not which it won't be

456
00:16:29,680 --> 00:16:31,360
because there's an expression on that

457
00:16:31,360 --> 00:16:33,040
list so it doesn't destroy the set or

458
00:16:33,040 --> 00:16:34,560
anything it just basically doesn't do

459
00:16:34,560 --> 00:16:37,360
anything and it just leaves the what is

460
00:16:37,360 --> 00:16:38,639
now a free

461
00:16:38,639 --> 00:16:42,480
um chunk on that list afterwards

462
00:16:42,480 --> 00:16:46,000
so um with with the bug like that like

463
00:16:46,000 --> 00:16:48,639
uh we can take as an example of how to

464
00:16:48,639 --> 00:16:51,839
write the address of a set into the the

465
00:16:51,839 --> 00:16:53,759
chunk that will be freed

466
00:16:53,759 --> 00:16:55,680
so basically what we can do

467
00:16:55,680 --> 00:16:58,880
is we can create some valid set um

468
00:16:58,880 --> 00:17:02,000
with that has uh or that just exists so

469
00:17:02,000 --> 00:17:03,839
that expressions can actually reference

470
00:17:03,839 --> 00:17:05,520
it and be bound to it

471
00:17:05,520 --> 00:17:07,919
and then we can bind an existing express

472
00:17:07,919 --> 00:17:10,000
or bind a new expression to it and this

473
00:17:10,000 --> 00:17:11,839
expression is just valid and normal it's

474
00:17:11,839 --> 00:17:13,199
just to make sure that there's an entry

475
00:17:13,199 --> 00:17:15,199
on the set bindings list

476
00:17:15,199 --> 00:17:16,640
and then basically what we can do is we

477
00:17:16,640 --> 00:17:19,359
can create a new invalid set with these

478
00:17:19,359 --> 00:17:21,439
one of these lookup or dynamic set

479
00:17:21,439 --> 00:17:23,520
expressions embedded inside of it which

480
00:17:23,520 --> 00:17:24,880
is invalid

481
00:17:24,880 --> 00:17:27,439
and then that exp one of the invalid

482
00:17:27,439 --> 00:17:30,240
expression will get

483
00:17:30,240 --> 00:17:32,240
bound to binding so placed on the list

484
00:17:32,240 --> 00:17:34,320
and then immediately freed and then if

485
00:17:34,320 --> 00:17:36,240
we remove the original the first

486
00:17:36,240 --> 00:17:37,840
expression that we had added onto the

487
00:17:37,840 --> 00:17:40,160
bindings list because it will update the

488
00:17:40,160 --> 00:17:42,240
previous pointer of what is now a

489
00:17:42,240 --> 00:17:44,559
dangling pointer we can basically write

490
00:17:44,559 --> 00:17:47,360
the address of set bindings into a free

491
00:17:47,360 --> 00:17:48,480
chunk

492
00:17:48,480 --> 00:17:50,000
and i appreciate that's probably a

493
00:17:50,000 --> 00:17:51,520
little bit hard to visualize in your

494
00:17:51,520 --> 00:17:53,600
head so this is what it kind of looks

495
00:17:53,600 --> 00:17:56,640
like on the left we've got the set that

496
00:17:56,640 --> 00:17:58,960
like um that's going to be referenced

497
00:17:58,960 --> 00:18:01,520
we've next we've got a legitimate

498
00:18:01,520 --> 00:18:03,440
expression linked in and then on the

499
00:18:03,440 --> 00:18:05,520
right we've got an invalid set embedding

500
00:18:05,520 --> 00:18:07,440
this dynamic set that's going to be

501
00:18:07,440 --> 00:18:09,440
added to the bindings list

502
00:18:09,440 --> 00:18:11,679
and then it immediately gets freed so

503
00:18:11,679 --> 00:18:14,000
now this egg

504
00:18:14,000 --> 00:18:15,280
expression

505
00:18:15,280 --> 00:18:17,440
the next pointer is effectively dangling

506
00:18:17,440 --> 00:18:19,440
and pointing to a free chunk

507
00:18:19,440 --> 00:18:21,520
and then when we unlink that basically

508
00:18:21,520 --> 00:18:23,440
we end up writing into the free chunk so

509
00:18:23,440 --> 00:18:26,000
the previous pointer points back to set

510
00:18:26,000 --> 00:18:27,120
bindings

511
00:18:27,120 --> 00:18:29,200
and that's basically it that's all the

512
00:18:29,200 --> 00:18:32,000
bug really gives you which is um kind of

513
00:18:32,000 --> 00:18:33,520
interesting

514
00:18:33,520 --> 00:18:34,400
um

515
00:18:34,400 --> 00:18:36,000
so how do you go about exploiting

516
00:18:36,000 --> 00:18:39,120
something like this like some ideas um

517
00:18:39,120 --> 00:18:40,880
it would be nice if you could like

518
00:18:40,880 --> 00:18:43,600
replace the original like use after free

519
00:18:43,600 --> 00:18:45,200
chunk with some other object where

520
00:18:45,200 --> 00:18:47,520
there's a length parameter overlapping

521
00:18:47,520 --> 00:18:49,360
with where you can write a pointer to

522
00:18:49,360 --> 00:18:50,960
because maybe then you could get like a

523
00:18:50,960 --> 00:18:53,520
relative um out of bounds read and write

524
00:18:53,520 --> 00:18:55,039
primitive but we didn't find something

525
00:18:55,039 --> 00:18:57,200
like that so the other ideas would be

526
00:18:57,200 --> 00:18:59,360
something like overwrite

527
00:18:59,360 --> 00:19:01,360
some other pointer in an object with a

528
00:19:01,360 --> 00:19:02,640
new pointer which would be like the

529
00:19:02,640 --> 00:19:04,400
pointer to the set and then maybe build

530
00:19:04,400 --> 00:19:06,480
a better use after free primitive

531
00:19:06,480 --> 00:19:09,039
and then another idea would be to write

532
00:19:09,039 --> 00:19:10,640
just the pointer into some buffer that

533
00:19:10,640 --> 00:19:12,400
we can then read from userline in order

534
00:19:12,400 --> 00:19:14,640
to get a leak primitive a

535
00:19:14,640 --> 00:19:16,960
minimal leak primitive

536
00:19:16,960 --> 00:19:19,039
but it's pretty limited

537
00:19:19,039 --> 00:19:21,520
so to start we basically decided to just

538
00:19:21,520 --> 00:19:23,280
leak some address to confirm our mental

539
00:19:23,280 --> 00:19:25,280
model um

540
00:19:25,280 --> 00:19:26,000
and

541
00:19:26,000 --> 00:19:28,000
yeah basically what the address we leak

542
00:19:28,000 --> 00:19:29,280
is just whatever the offset of the

543
00:19:29,280 --> 00:19:31,440
bindings member is in the expression or

544
00:19:31,440 --> 00:19:32,400
the set

545
00:19:32,400 --> 00:19:34,480
and in order to do this we just use the

546
00:19:34,480 --> 00:19:36,720
pretty popular

547
00:19:36,720 --> 00:19:38,320
structure used for exploitation called

548
00:19:38,320 --> 00:19:40,799
user key payload and basically the idea

549
00:19:40,799 --> 00:19:42,640
is from userland you can add keys to the

550
00:19:42,640 --> 00:19:45,440
kernel that um and you can supply some

551
00:19:45,440 --> 00:19:47,840
additional user data in uh that gets

552
00:19:47,840 --> 00:19:49,600
allocated in this user key payload

553
00:19:49,600 --> 00:19:51,440
structure and the nice thing is because

554
00:19:51,440 --> 00:19:53,679
you you control the size of how much

555
00:19:53,679 --> 00:19:56,320
data you provide you can dictate which

556
00:19:56,320 --> 00:19:58,480
like slab cache the user key payload

557
00:19:58,480 --> 00:20:00,320
ends up getting allocated on

558
00:20:00,320 --> 00:20:03,039
and you can also read that data after uh

559
00:20:03,039 --> 00:20:04,720
whenever you want after you've created

560
00:20:04,720 --> 00:20:07,039
the key um

561
00:20:07,039 --> 00:20:09,679
so basically we'll re i'll refer to this

562
00:20:09,679 --> 00:20:12,640
like uh phases use after free one and

563
00:20:12,640 --> 00:20:14,559
the set that we're gonna use for this

564
00:20:14,559 --> 00:20:16,559
stage is set one

565
00:20:16,559 --> 00:20:19,360
so again same as last time we've got set

566
00:20:19,360 --> 00:20:21,200
one we've got an expression on the list

567
00:20:21,200 --> 00:20:22,720
that references it and then we've got

568
00:20:22,720 --> 00:20:24,960
this use after free dynamic set thing

569
00:20:24,960 --> 00:20:26,240
that we're going to free right away

570
00:20:26,240 --> 00:20:28,159
because it's deemed invalid so same as

571
00:20:28,159 --> 00:20:29,600
before

572
00:20:29,600 --> 00:20:31,919
and now instead we replace the free

573
00:20:31,919 --> 00:20:35,120
chunk with the user key payload and then

574
00:20:35,120 --> 00:20:37,280
we unlink the

575
00:20:37,280 --> 00:20:39,200
expression that was already on the list

576
00:20:39,200 --> 00:20:41,200
and that writes the pointer to of set

577
00:20:41,200 --> 00:20:43,760
one bindings into the payload portion of

578
00:20:43,760 --> 00:20:45,679
user key payload structure

579
00:20:45,679 --> 00:20:46,799
and then we can just read it from

580
00:20:46,799 --> 00:20:48,480
userland and so that gives us the

581
00:20:48,480 --> 00:20:50,400
address of set one

582
00:20:50,400 --> 00:20:53,200
uh on the slab cache which is not very

583
00:20:53,200 --> 00:20:55,200
useful but it's uh

584
00:20:55,200 --> 00:20:56,480
it's a start

585
00:20:56,480 --> 00:20:57,600
um

586
00:20:57,600 --> 00:20:59,520
and it's nice to know that like the

587
00:20:59,520 --> 00:21:01,520
mental model works and stuff like that

588
00:21:01,520 --> 00:21:03,360
so the next goal is to do something a

589
00:21:03,360 --> 00:21:04,960
little bit more powerful

590
00:21:04,960 --> 00:21:07,360
and so we want to try to free some other

591
00:21:07,360 --> 00:21:08,720
object

592
00:21:08,720 --> 00:21:10,799
and so the goal here is we basically

593
00:21:10,799 --> 00:21:12,720
need to find some other object that we

594
00:21:12,720 --> 00:21:16,080
can allocate on the 48 byte or 96 byte

595
00:21:16,080 --> 00:21:19,120
slab caches where they can

596
00:21:19,120 --> 00:21:20,960
those objects contain a pointer that

597
00:21:20,960 --> 00:21:23,679
overlaps with where the pointer

598
00:21:23,679 --> 00:21:27,280
of like the set will be written to

599
00:21:27,280 --> 00:21:28,240
um

600
00:21:28,240 --> 00:21:30,159
and the there's one constraint which is

601
00:21:30,159 --> 00:21:32,000
that this overlapping pointer must also

602
00:21:32,000 --> 00:21:33,919
be freeable on demand in order to give

603
00:21:33,919 --> 00:21:35,760
us like this more powerful free

604
00:21:35,760 --> 00:21:37,039
primitive

605
00:21:37,039 --> 00:21:38,080
um

606
00:21:38,080 --> 00:21:39,360
and yeah so

607
00:21:39,360 --> 00:21:40,320
uh

608
00:21:40,320 --> 00:21:42,159
there's basically two options of what we

609
00:21:42,159 --> 00:21:43,919
can do depending on how we order what's

610
00:21:43,919 --> 00:21:46,000
on the bindings list one is we could

611
00:21:46,000 --> 00:21:48,080
technically free

612
00:21:48,080 --> 00:21:49,280
like

613
00:21:49,280 --> 00:21:53,760
expression size bytes somewhere

614
00:21:53,919 --> 00:21:55,520
on the slab cache but it's a little bit

615
00:21:55,520 --> 00:21:57,200
quirky and i don't have time to really

616
00:21:57,200 --> 00:22:00,159
explain why but we ended up just um

617
00:22:00,159 --> 00:22:02,799
trying to free set itself like free an

618
00:22:02,799 --> 00:22:05,120
address from set bindings downwards and

619
00:22:05,120 --> 00:22:09,520
it frees basically 1024 byte or 512 byte

620
00:22:09,520 --> 00:22:11,200
depending on the size of the

621
00:22:11,200 --> 00:22:13,679
allocation um chunk

622
00:22:13,679 --> 00:22:15,120
so

623
00:22:15,120 --> 00:22:17,200
um we'll explain why the other technique

624
00:22:17,200 --> 00:22:18,880
is quirky in the blog

625
00:22:18,880 --> 00:22:20,400
but yeah so

626
00:22:20,400 --> 00:22:22,080
as you might be able to imagine finding

627
00:22:22,080 --> 00:22:23,919
like these types of structures with the

628
00:22:23,919 --> 00:22:25,600
overlapping constraints and stuff is

629
00:22:25,600 --> 00:22:27,600
kind of annoying so we ended up using

630
00:22:27,600 --> 00:22:29,760
code ql

631
00:22:29,760 --> 00:22:32,000
so basically we just wrote a codeql

632
00:22:32,000 --> 00:22:33,440
query

633
00:22:33,440 --> 00:22:35,280
and basically the idea is that it just

634
00:22:35,280 --> 00:22:36,400
goes through

635
00:22:36,400 --> 00:22:38,320
different functions and it finds an

636
00:22:38,320 --> 00:22:40,400
allocation like in this example on the

637
00:22:40,400 --> 00:22:41,600
96

638
00:22:41,600 --> 00:22:43,919
bytes slab cache so it knows that the

639
00:22:43,919 --> 00:22:46,080
allocation is coming from like k malek

640
00:22:46,080 --> 00:22:48,000
casey alec anything that will use the

641
00:22:48,000 --> 00:22:50,640
slab cache and then um whatever the

642
00:22:50,640 --> 00:22:52,640
resulting like

643
00:22:52,640 --> 00:22:55,200
structure is of that allocation it

644
00:22:55,200 --> 00:22:58,240
checks the types of overlapping

645
00:22:58,240 --> 00:23:00,480
um members of the structure at offsets

646
00:23:00,480 --> 00:23:02,159
we're interested in and if it's a

647
00:23:02,159 --> 00:23:03,440
pointer then

648
00:23:03,440 --> 00:23:05,360
we flag it and then basically you have

649
00:23:05,360 --> 00:23:06,880
to go through a big list of these

650
00:23:06,880 --> 00:23:09,679
candidates to see okay is it actually

651
00:23:09,679 --> 00:23:11,200
something we can allocate from user land

652
00:23:11,200 --> 00:23:12,799
and if so does that pointer that

653
00:23:12,799 --> 00:23:15,039
overlaps actually get freed at some

654
00:23:15,039 --> 00:23:16,640
point but

655
00:23:16,640 --> 00:23:18,640
believe it or not we did find at least

656
00:23:18,640 --> 00:23:20,640
one good candidate for that which is

657
00:23:20,640 --> 00:23:23,440
called c group fs context and basically

658
00:23:23,440 --> 00:23:25,600
when you create a new c group

659
00:23:25,600 --> 00:23:27,120
uh this structure ends up getting

660
00:23:27,120 --> 00:23:29,919
allocated on the 96 byte um

661
00:23:29,919 --> 00:23:32,080
slab cache which is nice and there's a

662
00:23:32,080 --> 00:23:33,840
there's a member called release agent

663
00:23:33,840 --> 00:23:35,840
which perfectly overlaps with the

664
00:23:35,840 --> 00:23:37,679
previous pointer of the bindings doubly

665
00:23:37,679 --> 00:23:40,000
linked list entry that we mentioned and

666
00:23:40,000 --> 00:23:41,600
basically yeah you can create a new c

667
00:23:41,600 --> 00:23:44,159
group from userland just calling fs open

668
00:23:44,159 --> 00:23:46,799
and you can actually free this the c

669
00:23:46,799 --> 00:23:49,120
group as well as these members on demand

670
00:23:49,120 --> 00:23:50,720
by just destroying

671
00:23:50,720 --> 00:23:51,919
the

672
00:23:51,919 --> 00:23:54,080
c group's file descriptor

673
00:23:54,080 --> 00:23:56,480
so basically what this looks like

674
00:23:56,480 --> 00:23:58,720
is the c group fs context structure

675
00:23:58,720 --> 00:24:00,400
looks like this and basically the name

676
00:24:00,400 --> 00:24:02,400
and release agent members happen to

677
00:24:02,400 --> 00:24:05,280
overlap with our bindings

678
00:24:05,280 --> 00:24:06,880
link list entry

679
00:24:06,880 --> 00:24:08,799
and if we look at this functions

680
00:24:08,799 --> 00:24:10,320
that gets called when you're destroying

681
00:24:10,320 --> 00:24:12,080
the c group we can see that there's a

682
00:24:12,080 --> 00:24:13,840
call to k free of

683
00:24:13,840 --> 00:24:16,080
the name and both the release agent so

684
00:24:16,080 --> 00:24:18,480
this basically allows us to build a free

685
00:24:18,480 --> 00:24:20,960
primitive that will allow us to free um

686
00:24:20,960 --> 00:24:22,480
the set

687
00:24:22,480 --> 00:24:25,520
so um in order to prepare to build this

688
00:24:25,520 --> 00:24:27,520
free primitive we have to actually first

689
00:24:27,520 --> 00:24:29,440
write into this c group fs context

690
00:24:29,440 --> 00:24:32,400
structure so the the preparation phase

691
00:24:32,400 --> 00:24:34,720
we have to trigger the the original use

692
00:24:34,720 --> 00:24:36,559
after free bug again so i refer to that

693
00:24:36,559 --> 00:24:38,480
as uaf2 and then we're going to use a

694
00:24:38,480 --> 00:24:41,200
separate set for this which is set to

695
00:24:41,200 --> 00:24:42,240
so

696
00:24:42,240 --> 00:24:44,240
again pretty much exactly the same

697
00:24:44,240 --> 00:24:46,159
before we have some set existing

698
00:24:46,159 --> 00:24:48,960
expression the use after free chunk

699
00:24:48,960 --> 00:24:51,440
the so that chunk gets freed we now have

700
00:24:51,440 --> 00:24:53,679
a dangling pointer in next this time we

701
00:24:53,679 --> 00:24:56,799
replace the use after free chunk with c

702
00:24:56,799 --> 00:24:59,039
group f as context we unlink the

703
00:24:59,039 --> 00:25:01,679
expression and now the release agent

704
00:25:01,679 --> 00:25:03,760
member is

705
00:25:03,760 --> 00:25:05,760
overwritten and pointing into set two

706
00:25:05,760 --> 00:25:08,240
bindings

707
00:25:08,640 --> 00:25:10,400
so now

708
00:25:10,400 --> 00:25:11,600
from there

709
00:25:11,600 --> 00:25:14,080
the goal is okay now we can freeze it

710
00:25:14,080 --> 00:25:16,240
like set two when we want to and then we

711
00:25:16,240 --> 00:25:18,640
can replace it with some fake data

712
00:25:18,640 --> 00:25:19,600
so

713
00:25:19,600 --> 00:25:21,360
this becomes like sort of a new use

714
00:25:21,360 --> 00:25:22,960
after free because the set still

715
00:25:22,960 --> 00:25:25,039
technically exists so we refer to it as

716
00:25:25,039 --> 00:25:26,400
uaf3

717
00:25:26,400 --> 00:25:29,279
and then we uh when we replace set two

718
00:25:29,279 --> 00:25:32,240
uh i would refer to it as fake set one

719
00:25:32,240 --> 00:25:34,000
so basically the idea is like at some

720
00:25:34,000 --> 00:25:35,840
point later we've created like we've

721
00:25:35,840 --> 00:25:37,360
prepared this fake set that we're going

722
00:25:37,360 --> 00:25:41,120
to put in memory and so we um delete

723
00:25:41,120 --> 00:25:42,960
like destroy the c group which ends up

724
00:25:42,960 --> 00:25:44,000
freeing

725
00:25:44,000 --> 00:25:45,039
um

726
00:25:45,039 --> 00:25:46,240
the

727
00:25:46,240 --> 00:25:48,080
set to from the bindings offset

728
00:25:48,080 --> 00:25:49,279
downwards and this is kind of an

729
00:25:49,279 --> 00:25:51,440
interesting quirk because the slab

730
00:25:51,440 --> 00:25:52,880
allocator

731
00:25:52,880 --> 00:25:54,960
actually lets you free misaligned

732
00:25:54,960 --> 00:25:56,640
addresses even though

733
00:25:56,640 --> 00:25:58,320
all of the chunks on the slab cast

734
00:25:58,320 --> 00:25:59,840
should be the same size so this seems

735
00:25:59,840 --> 00:26:01,279
like something that can be mitigated in

736
00:26:01,279 --> 00:26:02,960
the future probably

737
00:26:02,960 --> 00:26:05,600
but um yeah basically what we can do is

738
00:26:05,600 --> 00:26:09,039
then just replace all of the contents of

739
00:26:09,039 --> 00:26:11,039
the set

740
00:26:11,039 --> 00:26:12,320
with fake

741
00:26:12,320 --> 00:26:14,559
with a fake set and basically we use a

742
00:26:14,559 --> 00:26:16,640
really popular technique that's popular

743
00:26:16,640 --> 00:26:17,600
lately

744
00:26:17,600 --> 00:26:20,240
um using a fuse user line driver and

745
00:26:20,240 --> 00:26:22,960
this system called called sedex adder

746
00:26:22,960 --> 00:26:24,799
and i don't have time to really explain

747
00:26:24,799 --> 00:26:26,480
how it works in too much detail but the

748
00:26:26,480 --> 00:26:29,039
idea is that you can use sedex adder to

749
00:26:29,039 --> 00:26:31,039
allocate basically fully controlled data

750
00:26:31,039 --> 00:26:33,279
on an arbitrary slab cache

751
00:26:33,279 --> 00:26:35,600
um and then just hold it there until you

752
00:26:35,600 --> 00:26:37,039
want to free it and then you can kind of

753
00:26:37,039 --> 00:26:39,600
free it on demand so basically that just

754
00:26:39,600 --> 00:26:42,000
means we have a fully controlled

755
00:26:42,000 --> 00:26:43,919
set

756
00:26:43,919 --> 00:26:45,679
so then the idea is

757
00:26:45,679 --> 00:26:46,960
let's try to

758
00:26:46,960 --> 00:26:48,880
use this fake set to do some memory

759
00:26:48,880 --> 00:26:50,640
revelation so

760
00:26:50,640 --> 00:26:52,400
fortunately we already triggered the use

761
00:26:52,400 --> 00:26:54,000
after free the very first time so we

762
00:26:54,000 --> 00:26:56,320
know the address of set one on the slab

763
00:26:56,320 --> 00:26:57,919
cache somewhere

764
00:26:57,919 --> 00:27:02,159
um and and we we can leak it um and so

765
00:27:02,159 --> 00:27:04,720
once we replace set to with fake set we

766
00:27:04,720 --> 00:27:07,120
basically just replace a few members so

767
00:27:07,120 --> 00:27:09,679
we can point the user data pointer to

768
00:27:09,679 --> 00:27:11,919
the address that we leaked upset one we

769
00:27:11,919 --> 00:27:14,880
set the length to be the size of set one

770
00:27:14,880 --> 00:27:16,960
and then the name also has to be valid

771
00:27:16,960 --> 00:27:18,960
in order for us to continue to interact

772
00:27:18,960 --> 00:27:21,679
with this the apis that reference the

773
00:27:21,679 --> 00:27:23,679
set but we can just point it somewhere

774
00:27:23,679 --> 00:27:25,840
into set one and when we created set one

775
00:27:25,840 --> 00:27:27,600
way back in the beginning we could just

776
00:27:27,600 --> 00:27:29,679
pre-populate part of the user data with

777
00:27:29,679 --> 00:27:32,159
a known name and that just lets it work

778
00:27:32,159 --> 00:27:34,000
and this basically lets us leak the full

779
00:27:34,000 --> 00:27:36,400
contents of set one and as i mentioned

780
00:27:36,400 --> 00:27:38,320
in the beginning these set structures

781
00:27:38,320 --> 00:27:41,039
have a function table pointer and so

782
00:27:41,039 --> 00:27:43,440
that at least leaks us the address of

783
00:27:43,440 --> 00:27:46,159
the nf tables kernel module but actually

784
00:27:46,159 --> 00:27:48,080
in practice it's not a very good kernel

785
00:27:48,080 --> 00:27:50,559
module for doing um

786
00:27:50,559 --> 00:27:52,880
stuff in the context of this

787
00:27:52,880 --> 00:27:55,679
bug so it was kind of too limited but

788
00:27:55,679 --> 00:27:58,640
basically the way that looks is

789
00:27:58,640 --> 00:28:00,399
now we've got our fake set with and so

790
00:28:00,399 --> 00:28:02,480
the red fields just indicate the

791
00:28:02,480 --> 00:28:05,679
completely overwritten members of the

792
00:28:05,679 --> 00:28:08,240
um the set and yeah so we basically just

793
00:28:08,240 --> 00:28:09,840
point user data to the beginning of the

794
00:28:09,840 --> 00:28:11,840
set have the fake name and then we can

795
00:28:11,840 --> 00:28:14,000
just read the user data from set two

796
00:28:14,000 --> 00:28:15,760
which is now fake set one back to

797
00:28:15,760 --> 00:28:17,679
userland and then we'd leak all those

798
00:28:17,679 --> 00:28:18,880
contents

799
00:28:18,880 --> 00:28:20,559
but we we want to do better because of

800
00:28:20,559 --> 00:28:22,880
the rop gadget limitation

801
00:28:22,880 --> 00:28:24,000
and if you remember back at the

802
00:28:24,000 --> 00:28:26,320
beginning i said that the nft sets have

803
00:28:26,320 --> 00:28:28,080
this list doubly linked list which is a

804
00:28:28,080 --> 00:28:30,640
list of all of the sets associated with

805
00:28:30,640 --> 00:28:33,520
the same table so basically we can

806
00:28:33,520 --> 00:28:35,760
create set one and set two on the same

807
00:28:35,760 --> 00:28:36,640
table

808
00:28:36,640 --> 00:28:38,240
and when we leak

809
00:28:38,240 --> 00:28:40,320
set one we can also leak the address of

810
00:28:40,320 --> 00:28:42,799
set two which is nice because

811
00:28:42,799 --> 00:28:45,279
it's now also our fake set which has

812
00:28:45,279 --> 00:28:47,200
controlled data and we can also replace

813
00:28:47,200 --> 00:28:49,279
it again so we can change the data at

814
00:28:49,279 --> 00:28:52,240
that address so that's fairly powerful

815
00:28:52,240 --> 00:28:54,240
and also there's nothing stopping us

816
00:28:54,240 --> 00:28:56,000
from increasing the size of the user

817
00:28:56,000 --> 00:28:58,480
data length field so we don't just need

818
00:28:58,480 --> 00:29:01,760
to allocate the size of set one only we

819
00:29:01,760 --> 00:29:04,880
can basically alloc or leak as much

820
00:29:04,880 --> 00:29:07,200
data as we want within reason

821
00:29:07,200 --> 00:29:10,240
um and so basically the way we can abuse

822
00:29:10,240 --> 00:29:12,640
this to bypass kslr and leak a more

823
00:29:12,640 --> 00:29:14,159
interesting address

824
00:29:14,159 --> 00:29:17,279
is spray these tdy objects

825
00:29:17,279 --> 00:29:19,200
and basically when you open a pseudo

826
00:29:19,200 --> 00:29:20,720
terminal

827
00:29:20,720 --> 00:29:23,120
path there will be an allocation called

828
00:29:23,120 --> 00:29:25,600
tdy struct

829
00:29:25,600 --> 00:29:27,679
on the 1024 byte

830
00:29:27,679 --> 00:29:29,120
slab cache

831
00:29:29,120 --> 00:29:30,799
um and so

832
00:29:30,799 --> 00:29:32,880
yeah basically we can just spray a whole

833
00:29:32,880 --> 00:29:35,360
bunch of these tdys trucks and be

834
00:29:35,360 --> 00:29:36,480
reasonably

835
00:29:36,480 --> 00:29:38,799
sure that after we allocate the set one

836
00:29:38,799 --> 00:29:41,200
structure there'll be one of these tty

837
00:29:41,200 --> 00:29:43,919
structures adjacent to it and then that

838
00:29:43,919 --> 00:29:46,640
allows us to leak um yeah the address

839
00:29:46,640 --> 00:29:48,399
that allows us to

840
00:29:48,399 --> 00:29:50,960
defeat ks kaslr

841
00:29:50,960 --> 00:29:53,440
by knowing where vm linux is in memory

842
00:29:53,440 --> 00:29:55,600
and so basically it's fairly similar to

843
00:29:55,600 --> 00:29:57,440
the last diagram but the main difference

844
00:29:57,440 --> 00:30:00,080
is that udlen is now longer instead of

845
00:30:00,080 --> 00:30:03,679
1024 bytes it's 2048 bytes and as long

846
00:30:03,679 --> 00:30:05,520
as there's a tdy structure actually

847
00:30:05,520 --> 00:30:08,799
adjacent to the set one in memory we can

848
00:30:08,799 --> 00:30:11,039
leak the dot data address

849
00:30:11,039 --> 00:30:13,440
from the ops pointer of tdystruct and

850
00:30:13,440 --> 00:30:14,320
then

851
00:30:14,320 --> 00:30:15,120
um

852
00:30:15,120 --> 00:30:18,159
yeah we've got a kslr bypass

853
00:30:18,159 --> 00:30:20,480
so um

854
00:30:20,480 --> 00:30:22,000
so then the next step is how do you get

855
00:30:22,000 --> 00:30:24,640
code execution from this um we need to

856
00:30:24,640 --> 00:30:27,279
put the kslr adjusted pointer somewhere

857
00:30:27,279 --> 00:30:28,799
in controlled memory

858
00:30:28,799 --> 00:30:31,679
but um fortunately as i said we just

859
00:30:31,679 --> 00:30:34,000
leaked the address of fake set one and

860
00:30:34,000 --> 00:30:35,840
we control when it's free because of

861
00:30:35,840 --> 00:30:38,399
this fuse zx adder technique which is

862
00:30:38,399 --> 00:30:40,480
yeah really powerful technique

863
00:30:40,480 --> 00:30:41,520
um

864
00:30:41,520 --> 00:30:43,440
and basically we can just free fake set

865
00:30:43,440 --> 00:30:44,399
one

866
00:30:44,399 --> 00:30:46,720
uh on demand and then just replace it

867
00:30:46,720 --> 00:30:49,279
again with fake set two and fake set 2

868
00:30:49,279 --> 00:30:52,880
can contain just kslr adjusted pointers

869
00:30:52,880 --> 00:30:55,440
and so basically you can in in fake set

870
00:30:55,440 --> 00:30:57,600
2 you can update the ops function

871
00:30:57,600 --> 00:31:01,039
pointer table to point into itself and

872
00:31:01,039 --> 00:31:02,799
just prepare a fake set of function

873
00:31:02,799 --> 00:31:05,200
pointers that are kslr adjusted

874
00:31:05,200 --> 00:31:07,360
um in the inline data and that's enough

875
00:31:07,360 --> 00:31:09,840
to get um yeah controlled function

876
00:31:09,840 --> 00:31:11,360
pointer table

877
00:31:11,360 --> 00:31:14,480
so uh yeah in this case like we so we

878
00:31:14,480 --> 00:31:17,120
free fake set one which just frees again

879
00:31:17,120 --> 00:31:19,440
whatever from the bindings member list

880
00:31:19,440 --> 00:31:20,320
down

881
00:31:20,320 --> 00:31:22,480
and then we use fuse and sedex header

882
00:31:22,480 --> 00:31:24,559
again to replace it and we can just put

883
00:31:24,559 --> 00:31:26,080
whatever contents

884
00:31:26,080 --> 00:31:30,080
in in fake set 2 that we want

885
00:31:30,720 --> 00:31:32,880
so then the next step is okay we control

886
00:31:32,880 --> 00:31:34,559
this function pointer table so now we

887
00:31:34,559 --> 00:31:36,880
can presumably get like some amount of

888
00:31:36,880 --> 00:31:39,760
rip control so what do we do for like

889
00:31:39,760 --> 00:31:42,080
rop gadgets or or otherwise

890
00:31:42,080 --> 00:31:44,399
um the main problem is that the the

891
00:31:44,399 --> 00:31:45,600
functions that are called from this

892
00:31:45,600 --> 00:31:49,519
function pointer table are fairly um

893
00:31:49,519 --> 00:31:51,440
constrained as far as the register

894
00:31:51,440 --> 00:31:53,840
control goes so like about half of them

895
00:31:53,840 --> 00:31:56,640
basically you just have rdi and r14

896
00:31:56,640 --> 00:31:59,200
registers pointing into this the fake

897
00:31:59,200 --> 00:32:01,200
set and then the other ones you have rsi

898
00:32:01,200 --> 00:32:03,679
and r12 so it's somewhat limited

899
00:32:03,679 --> 00:32:05,600
but the advantage we have is that

900
00:32:05,600 --> 00:32:07,440
because fake set 2 is completely

901
00:32:07,440 --> 00:32:10,480
controlled by us so most of the data

902
00:32:10,480 --> 00:32:11,279
we

903
00:32:11,279 --> 00:32:13,600
can just be whatever we want

904
00:32:13,600 --> 00:32:15,120
you can still

905
00:32:15,120 --> 00:32:17,039
find some wiggle room to find a gadget

906
00:32:17,039 --> 00:32:19,039
that references certain offsets from one

907
00:32:19,039 --> 00:32:20,880
of these registers and maybe pulls a

908
00:32:20,880 --> 00:32:22,720
value out and then pulls a pointer out

909
00:32:22,720 --> 00:32:24,480
and writes that value to the pointer

910
00:32:24,480 --> 00:32:25,519
even though it's a little bit more

911
00:32:25,519 --> 00:32:28,240
annoying to find

912
00:32:28,240 --> 00:32:30,240
and we just ended up doing this manually

913
00:32:30,240 --> 00:32:32,000
actually just

914
00:32:32,000 --> 00:32:36,000
using the the rp tool and just prepping

915
00:32:36,000 --> 00:32:37,840
for stuff with the right registers to

916
00:32:37,840 --> 00:32:40,000
see what existed

917
00:32:40,000 --> 00:32:41,840
and so we came across a pretty nice

918
00:32:41,840 --> 00:32:43,760
gadget which is actually just a function

919
00:32:43,760 --> 00:32:45,600
it's not really like a misaligned gadget

920
00:32:45,600 --> 00:32:47,120
or anything and it's basically just a

921
00:32:47,120 --> 00:32:49,440
function that does a doubly linked list

922
00:32:49,440 --> 00:32:50,480
unlink

923
00:32:50,480 --> 00:32:52,799
and so again in this case rdi is

924
00:32:52,799 --> 00:32:55,519
controlled uh insofar as it points to

925
00:32:55,519 --> 00:32:58,480
our fake set and so you can see it pulls

926
00:32:58,480 --> 00:33:02,320
offset 60 into the rax register and then

927
00:33:02,320 --> 00:33:05,120
pulls offset 68 into rdx and then

928
00:33:05,120 --> 00:33:08,640
immediately writes rax into rdx and so

929
00:33:08,640 --> 00:33:10,480
this right there is like an eight byte

930
00:33:10,480 --> 00:33:11,600
um

931
00:33:11,600 --> 00:33:14,480
right primitive which is nice but as i

932
00:33:14,480 --> 00:33:16,559
mentioned it's a it's a unlink on a

933
00:33:16,559 --> 00:33:18,640
doubly linked list so it will still do

934
00:33:18,640 --> 00:33:20,080
the mirror right

935
00:33:20,080 --> 00:33:23,760
so as long as rax is not um null which

936
00:33:23,760 --> 00:33:25,679
it won't be if we want to write like a

937
00:33:25,679 --> 00:33:27,919
arbitrary value it ends up trying to

938
00:33:27,919 --> 00:33:30,480
write the rdx pointer back into where

939
00:33:30,480 --> 00:33:33,840
rax points and so technically unless the

940
00:33:33,840 --> 00:33:36,559
rax register is also a valid pointer it

941
00:33:36,559 --> 00:33:39,360
will oops and so the question is does it

942
00:33:39,360 --> 00:33:40,320
matter

943
00:33:40,320 --> 00:33:43,120
and actually on ubuntu and possibly

944
00:33:43,120 --> 00:33:45,360
other distros we didn't check they use a

945
00:33:45,360 --> 00:33:48,000
syscuddle setting called panic on oops

946
00:33:48,000 --> 00:33:49,760
and they set it to zero

947
00:33:49,760 --> 00:33:51,919
and basically what it means is like if

948
00:33:51,919 --> 00:33:54,080
the kernel encounters an oops

949
00:33:54,080 --> 00:33:56,799
should it panic or or just try to keep

950
00:33:56,799 --> 00:33:59,279
going and as long as it's a non-critical

951
00:33:59,279 --> 00:34:01,519
like execution path it'll just keep

952
00:34:01,519 --> 00:34:03,120
going and it will just terminate that

953
00:34:03,120 --> 00:34:05,360
threat and uh you so you just don't care

954
00:34:05,360 --> 00:34:07,760
that you basically oops the kernel it

955
00:34:07,760 --> 00:34:10,079
just spits something on the the syslog

956
00:34:10,079 --> 00:34:11,199
and that's it

957
00:34:11,199 --> 00:34:13,679
um and actually it turns out that star

958
00:34:13,679 --> 00:34:17,119
labs also ended up using a similar trick

959
00:34:17,119 --> 00:34:20,079
in an iou ring exploit recently but they

960
00:34:20,079 --> 00:34:22,399
actually figured out a way to make the

961
00:34:22,399 --> 00:34:25,119
both sides of the mirror right valid

962
00:34:25,119 --> 00:34:27,119
but we didn't need to

963
00:34:27,119 --> 00:34:28,560
go to that level but if you're

964
00:34:28,560 --> 00:34:30,239
interested it's it's an it's a pretty

965
00:34:30,239 --> 00:34:31,918
cool trick that they release too so you

966
00:34:31,918 --> 00:34:34,719
should check it out um yeah and as far

967
00:34:34,719 --> 00:34:36,399
as invoking the gadget there are some

968
00:34:36,399 --> 00:34:38,159
limitations on which functions we can

969
00:34:38,159 --> 00:34:39,599
call because

970
00:34:39,599 --> 00:34:42,800
um it depends on which values in

971
00:34:42,800 --> 00:34:44,399
fake set end up getting used by the

972
00:34:44,399 --> 00:34:46,079
gadget but we found this one which is

973
00:34:46,079 --> 00:34:48,960
called garbage collect in it that suits

974
00:34:48,960 --> 00:34:50,719
triggering the rock gadget fine

975
00:34:50,719 --> 00:34:53,040
basically the only constraint is that

976
00:34:53,040 --> 00:34:54,320
you have to

977
00:34:54,320 --> 00:34:57,119
in like initialize some expression that

978
00:34:57,119 --> 00:34:59,280
has this garbage collection flag

979
00:34:59,280 --> 00:35:01,359
associated with it and as far as we can

980
00:35:01,359 --> 00:35:02,800
tell there's actually only one called

981
00:35:02,800 --> 00:35:04,720
connection limit but it's enough to do

982
00:35:04,720 --> 00:35:07,040
the trick and so when you uh

983
00:35:07,040 --> 00:35:09,680
initialize a connection limit expression

984
00:35:09,680 --> 00:35:11,359
it um

985
00:35:11,359 --> 00:35:13,440
yeah it calls gc in it and then we can

986
00:35:13,440 --> 00:35:15,760
trigger the um

987
00:35:15,760 --> 00:35:17,920
the rop gadget

988
00:35:17,920 --> 00:35:20,240
so um so then the question is okay if

989
00:35:20,240 --> 00:35:22,160
we're going to use this rob gadget to do

990
00:35:22,160 --> 00:35:24,160
it eight bite right somewhere what do we

991
00:35:24,160 --> 00:35:24,960
do

992
00:35:24,960 --> 00:35:26,480
just for

993
00:35:26,480 --> 00:35:28,240
a quick win we use the trick that

994
00:35:28,240 --> 00:35:30,640
everybody's been using the last while

995
00:35:30,640 --> 00:35:32,800
maybe a couple years or a few years i

996
00:35:32,800 --> 00:35:33,599
guess

997
00:35:33,599 --> 00:35:35,440
and basically the idea is that there's

998
00:35:35,440 --> 00:35:37,839
some string this is typically writable

999
00:35:37,839 --> 00:35:40,240
depending on the kernel configuration

1000
00:35:40,240 --> 00:35:42,240
in the kernel

1001
00:35:42,240 --> 00:35:44,240
and it basically just is the path of

1002
00:35:44,240 --> 00:35:47,599
some binary that will be run when um the

1003
00:35:47,599 --> 00:35:49,040
system's trying to load a new kernel

1004
00:35:49,040 --> 00:35:51,119
module and so basically we can just

1005
00:35:51,119 --> 00:35:53,440
build a new string out of the eight byte

1006
00:35:53,440 --> 00:35:55,760
value that gets written to wherever we

1007
00:35:55,760 --> 00:35:57,839
want and so in this case we can just use

1008
00:35:57,839 --> 00:35:59,839
slash temp slash x

1009
00:35:59,839 --> 00:36:01,359
um

1010
00:36:01,359 --> 00:36:04,160
and then we basically can just trigger

1011
00:36:04,160 --> 00:36:04,960
um

1012
00:36:04,960 --> 00:36:06,880
a module load and it will run the path

1013
00:36:06,880 --> 00:36:08,160
that we control so we can just put

1014
00:36:08,160 --> 00:36:09,440
whatever we want

1015
00:36:09,440 --> 00:36:11,839
like a shell script or whatever in that

1016
00:36:11,839 --> 00:36:12,720
path

1017
00:36:12,720 --> 00:36:14,400
obviously there's some limitations to

1018
00:36:14,400 --> 00:36:16,480
that in the real world um like temp

1019
00:36:16,480 --> 00:36:18,800
could be mounted non-executable and if

1020
00:36:18,800 --> 00:36:20,320
you're actually trying to break out of a

1021
00:36:20,320 --> 00:36:22,960
container the temp folder that you put

1022
00:36:22,960 --> 00:36:24,560
your x file in

1023
00:36:24,560 --> 00:36:26,480
is going to be different like it's

1024
00:36:26,480 --> 00:36:27,839
probably going to be like an overlay

1025
00:36:27,839 --> 00:36:30,240
mount or something so temp x from the

1026
00:36:30,240 --> 00:36:32,160
container context that's actually

1027
00:36:32,160 --> 00:36:34,320
executing the module load

1028
00:36:34,320 --> 00:36:35,680
is going to be different so you're not

1029
00:36:35,680 --> 00:36:37,440
actually going to control that file so

1030
00:36:37,440 --> 00:36:38,960
it's a little bit harder in the real

1031
00:36:38,960 --> 00:36:40,720
world but for something like pawn to own

1032
00:36:40,720 --> 00:36:42,240
it works fine

1033
00:36:42,240 --> 00:36:45,520
um yeah so that basically this works uh

1034
00:36:45,520 --> 00:36:47,280
or this is what it looks like executing

1035
00:36:47,280 --> 00:36:48,720
the rop gadget

1036
00:36:48,720 --> 00:36:50,960
um basically the main point is like the

1037
00:36:50,960 --> 00:36:54,240
value it pulls from rd i plus 60 just

1038
00:36:54,240 --> 00:36:55,920
overlaps with i don't know if you can

1039
00:36:55,920 --> 00:36:57,760
read it from there but it's

1040
00:36:57,760 --> 00:37:00,400
just members called field count and use

1041
00:37:00,400 --> 00:37:03,920
and then offset 68 is number of elements

1042
00:37:03,920 --> 00:37:06,640
and another one but fortunately on the

1043
00:37:06,640 --> 00:37:07,520
the

1044
00:37:07,520 --> 00:37:10,000
invocation path of gc in it none of

1045
00:37:10,000 --> 00:37:11,599
these fields are used so we can just put

1046
00:37:11,599 --> 00:37:13,200
whatever we want there so we can just

1047
00:37:13,200 --> 00:37:15,359
put the address of mod probe

1048
00:37:15,359 --> 00:37:19,520
into um rdx and then temp x string value

1049
00:37:19,520 --> 00:37:22,480
into rax and and we win

1050
00:37:22,480 --> 00:37:25,839
so yeah just to put it back um

1051
00:37:25,839 --> 00:37:27,119
from the beginning just to remind

1052
00:37:27,119 --> 00:37:28,880
everybody so basically we have the first

1053
00:37:28,880 --> 00:37:31,280
use after free that we use to replace a

1054
00:37:31,280 --> 00:37:33,359
dynamic set um

1055
00:37:33,359 --> 00:37:35,920
and that lets us leak the address of a

1056
00:37:35,920 --> 00:37:39,200
set set one into userland

1057
00:37:39,200 --> 00:37:41,440
which we can use later and then the

1058
00:37:41,440 --> 00:37:43,599
second use after free is that we just

1059
00:37:43,599 --> 00:37:45,920
trigger the same bug again but we end up

1060
00:37:45,920 --> 00:37:48,160
using a special c group structure which

1061
00:37:48,160 --> 00:37:51,119
allows us to build a more useful free

1062
00:37:51,119 --> 00:37:52,160
primitive

1063
00:37:52,160 --> 00:37:53,040
so

1064
00:37:53,040 --> 00:37:55,680
the third use after free is basically

1065
00:37:55,680 --> 00:37:58,400
actually freeing set two and replacing

1066
00:37:58,400 --> 00:38:01,440
it with the fake set and that um

1067
00:38:01,440 --> 00:38:03,280
that primitive allows us to effectively

1068
00:38:03,280 --> 00:38:05,200
bypass kslr

1069
00:38:05,200 --> 00:38:07,280
and leak the address of set 2

1070
00:38:07,280 --> 00:38:09,520
which allows us to do more useful things

1071
00:38:09,520 --> 00:38:13,280
like hijack the function pointer table

1072
00:38:13,280 --> 00:38:14,720
and then use after free four is

1073
00:38:14,720 --> 00:38:16,560
basically just i mean it's not really a

1074
00:38:16,560 --> 00:38:17,920
use after free i guess but it's just

1075
00:38:17,920 --> 00:38:21,359
replacing fake set one with fake set two

1076
00:38:21,359 --> 00:38:25,040
which allows us to control um

1077
00:38:25,040 --> 00:38:26,079
the

1078
00:38:26,079 --> 00:38:27,760
yeah function pointer table and then we

1079
00:38:27,760 --> 00:38:30,000
just trigger a gc init to overwrite

1080
00:38:30,000 --> 00:38:31,760
modpro path and then from user land we

1081
00:38:31,760 --> 00:38:34,400
just trigger a module load and then we

1082
00:38:34,400 --> 00:38:36,720
run temp x as root

1083
00:38:36,720 --> 00:38:39,680
um and that's pretty much it

1084
00:38:39,680 --> 00:38:40,640
so

1085
00:38:40,640 --> 00:38:41,599
um

1086
00:38:41,599 --> 00:38:44,640
yeah as far as the patch goes the they

1087
00:38:44,640 --> 00:38:46,000
patched it a little bit differently than

1088
00:38:46,000 --> 00:38:47,839
we thought but it's like it's actually

1089
00:38:47,839 --> 00:38:51,200
better uh than i expected i guess which

1090
00:38:51,200 --> 00:38:53,520
is that they prevent the initialization

1091
00:38:53,520 --> 00:38:56,400
of any non-stateful expression at all

1092
00:38:56,400 --> 00:38:58,800
during set creation so they check the

1093
00:38:58,800 --> 00:39:03,040
flag first um and this is good because

1094
00:39:03,040 --> 00:39:04,400
any other

1095
00:39:04,400 --> 00:39:07,280
like desynchronization between the init

1096
00:39:07,280 --> 00:39:09,760
initialization and destruction logic

1097
00:39:09,760 --> 00:39:11,920
that might have existed there because

1098
00:39:11,920 --> 00:39:14,079
you can initialize and allocate it first

1099
00:39:14,079 --> 00:39:16,240
well just gets killed at the same time

1100
00:39:16,240 --> 00:39:18,560
and we actually had another um bug that

1101
00:39:18,560 --> 00:39:21,040
we found

1102
00:39:21,200 --> 00:39:23,839
that was also just yeah squashed by that

1103
00:39:23,839 --> 00:39:25,200
the way they patched it so that's kind

1104
00:39:25,200 --> 00:39:27,359
of interesting

1105
00:39:27,359 --> 00:39:30,400
um yeah so if we look at the fix

1106
00:39:30,400 --> 00:39:33,119
basically now instead of doing like uh

1107
00:39:33,119 --> 00:39:34,880
the expression initialization they

1108
00:39:34,880 --> 00:39:36,240
introduce this new function called

1109
00:39:36,240 --> 00:39:38,800
expression parse and it basically parses

1110
00:39:38,800 --> 00:39:40,720
the information out of the expression

1111
00:39:40,720 --> 00:39:41,920
type

1112
00:39:41,920 --> 00:39:44,960
just structure and says okay

1113
00:39:44,960 --> 00:39:46,320
just put it somewhere else that we can

1114
00:39:46,320 --> 00:39:48,400
reference the flag's value first and say

1115
00:39:48,400 --> 00:39:50,560
is it stateful or not and only if it's

1116
00:39:50,560 --> 00:39:52,640
stateful actually do the initialization

1117
00:39:52,640 --> 00:39:54,000
and so that

1118
00:39:54,000 --> 00:39:56,400
removes all of the problems

1119
00:39:56,400 --> 00:39:58,240
that we ran into

1120
00:39:58,240 --> 00:40:01,520
so yeah um in conclusion like i guess nf

1121
00:40:01,520 --> 00:40:03,760
tables is pretty rich attack surface uh

1122
00:40:03,760 --> 00:40:06,480
as it was shown there's a lot of

1123
00:40:06,480 --> 00:40:08,160
research this year already and i suspect

1124
00:40:08,160 --> 00:40:09,839
there'll be more

1125
00:40:09,839 --> 00:40:12,000
and just the same old stuff with like

1126
00:40:12,000 --> 00:40:13,920
linux kernel exploitation lately

1127
00:40:13,920 --> 00:40:16,000
unprivileged namespaces expose a huge

1128
00:40:16,000 --> 00:40:18,079
attack surface so i guess a lot of

1129
00:40:18,079 --> 00:40:20,000
people probably want to disable them if

1130
00:40:20,000 --> 00:40:22,000
you don't need them

1131
00:40:22,000 --> 00:40:24,079
panic on oops is dangerous user land

1132
00:40:24,079 --> 00:40:26,800
fuse is like uh userlandfuse driver is

1133
00:40:26,800 --> 00:40:29,440
super popular technique these days so it

1134
00:40:29,440 --> 00:40:31,040
may i don't know

1135
00:40:31,040 --> 00:40:32,560
people find a way to squash it or

1136
00:40:32,560 --> 00:40:33,760
something

1137
00:40:33,760 --> 00:40:35,200
um

1138
00:40:35,200 --> 00:40:38,000
but i guess interestingly is what what

1139
00:40:38,000 --> 00:40:39,599
ways could you potentially mitigate this

1140
00:40:39,599 --> 00:40:41,680
kind of stuff um

1141
00:40:41,680 --> 00:40:43,680
i guess one way which i didn't list i

1142
00:40:43,680 --> 00:40:45,760
don't think is

1143
00:40:45,760 --> 00:40:48,400
um possibly the slab cache allocator

1144
00:40:48,400 --> 00:40:50,160
could be modified to not allow you to

1145
00:40:50,160 --> 00:40:52,480
free a misaligned

1146
00:40:52,480 --> 00:40:54,720
slab object just because it seems weird

1147
00:40:54,720 --> 00:40:55,920
i don't know that that should ever

1148
00:40:55,920 --> 00:40:58,480
happen intentionally

1149
00:40:58,480 --> 00:40:59,760
and then there's some other interesting

1150
00:40:59,760 --> 00:41:01,200
stuff which i don't have too much time

1151
00:41:01,200 --> 00:41:02,960
to explain but gr security has this

1152
00:41:02,960 --> 00:41:04,960
thing called auto slab and google

1153
00:41:04,960 --> 00:41:06,480
announced like last week or something

1154
00:41:06,480 --> 00:41:08,640
some new mitigations experimental

1155
00:41:08,640 --> 00:41:09,920
mitigations

1156
00:41:09,920 --> 00:41:12,880
um that do object-specific slab caches

1157
00:41:12,880 --> 00:41:13,680
so

1158
00:41:13,680 --> 00:41:15,440
you can't like

1159
00:41:15,440 --> 00:41:18,160
allocate and free one uh object on a

1160
00:41:18,160 --> 00:41:19,920
cache and then replace it with an object

1161
00:41:19,920 --> 00:41:21,920
of a different type at all

1162
00:41:21,920 --> 00:41:24,640
um there's some other like tricks like

1163
00:41:24,640 --> 00:41:27,520
cross cache type tricks you can use but

1164
00:41:27,520 --> 00:41:28,640
it seems like they're working on

1165
00:41:28,640 --> 00:41:30,960
mitigating those as well something like

1166
00:41:30,960 --> 00:41:33,280
control flow integrity would obviously

1167
00:41:33,280 --> 00:41:35,920
make the rop gadget execution annoying

1168
00:41:35,920 --> 00:41:38,000
but it seems to only be enabled on

1169
00:41:38,000 --> 00:41:39,520
android and i don't know if it is

1170
00:41:39,520 --> 00:41:42,160
available or will be available for x64

1171
00:41:42,160 --> 00:41:43,359
anytime soon

1172
00:41:43,359 --> 00:41:45,599
you could always just turn panic on oops

1173
00:41:45,599 --> 00:41:46,880
on

1174
00:41:46,880 --> 00:41:48,319
but it might be annoying in the real

1175
00:41:48,319 --> 00:41:49,680
world

1176
00:41:49,680 --> 00:41:51,200
um just because

1177
00:41:51,200 --> 00:41:53,440
i think the linux kernel oopses from

1178
00:41:53,440 --> 00:41:55,520
time to time and if that killed your box

1179
00:41:55,520 --> 00:41:57,680
every time you might not like it

1180
00:41:57,680 --> 00:41:59,599
um and yeah i mentioned way back that

1181
00:41:59,599 --> 00:42:02,000
there is a kernel config called static

1182
00:42:02,000 --> 00:42:03,520
user mode helper and that basically

1183
00:42:03,520 --> 00:42:05,280
prevents the mod pro path from being

1184
00:42:05,280 --> 00:42:07,200
writable at all

1185
00:42:07,200 --> 00:42:08,960
and then of course just no on privilege

1186
00:42:08,960 --> 00:42:11,839
namespaces disable fuse server support

1187
00:42:11,839 --> 00:42:13,440
and stuff like that

1188
00:42:13,440 --> 00:42:15,200
um yeah and that's basically it we're

1189
00:42:15,200 --> 00:42:19,119
gonna release a blog soon uh after this

1190
00:42:19,119 --> 00:42:20,800
um and yeah if you have questions you

1191
00:42:20,800 --> 00:42:23,040
can feel free to find me after the talk

1192
00:42:23,040 --> 00:42:25,520
uh and talk about it um

1193
00:42:25,520 --> 00:42:27,200
and it it wasn't just me that did this

1194
00:42:27,200 --> 00:42:29,359
research i worked for a team of three

1195
00:42:29,359 --> 00:42:32,000
um so cedric and alex both helped with

1196
00:42:32,000 --> 00:42:33,760
lots of different parts

1197
00:42:33,760 --> 00:42:36,000
and we are hiring if this kind of stuff

1198
00:42:36,000 --> 00:42:37,520
is interesting and you think you might

1199
00:42:37,520 --> 00:42:39,920
want to do this kind of stuff with us

1200
00:42:39,920 --> 00:42:44,560
um and i i have a like a quick note um

1201
00:42:44,560 --> 00:42:46,000
just for the end that doesn't have

1202
00:42:46,000 --> 00:42:47,839
anything to do with what i did really

1203
00:42:47,839 --> 00:42:50,079
but i have like really bad repetitive

1204
00:42:50,079 --> 00:42:52,880
strain injury uh for a really long time

1205
00:42:52,880 --> 00:42:56,880
and for about the last two years

1206
00:42:57,280 --> 00:42:59,040
all of my research is done using my

1207
00:42:59,040 --> 00:43:02,480
voice and an eye tracking uh

1208
00:43:02,480 --> 00:43:04,000
thing on my monitor that basically

1209
00:43:04,000 --> 00:43:05,520
tracks where my eyes are and so i don't

1210
00:43:05,520 --> 00:43:08,000
have to use a mouse and so i use this

1211
00:43:08,000 --> 00:43:09,839
like project which is a free project

1212
00:43:09,839 --> 00:43:12,319
that works on windows mac os and linux

1213
00:43:12,319 --> 00:43:14,319
called talon so i just wanted to give a

1214
00:43:14,319 --> 00:43:17,119
shout out to that project because it

1215
00:43:17,119 --> 00:43:19,520
basically keeps me being able to do my

1216
00:43:19,520 --> 00:43:20,960
job when otherwise i probably wouldn't

1217
00:43:20,960 --> 00:43:22,000
be able to

1218
00:43:22,000 --> 00:43:24,079
and it's just a reminder to everybody to

1219
00:43:24,079 --> 00:43:25,680
you know sit up straight and actually

1220
00:43:25,680 --> 00:43:27,359
take breaks for your hands because if

1221
00:43:27,359 --> 00:43:30,000
you don't it can catch up with you after

1222
00:43:30,000 --> 00:43:32,079
20 years of being in the industry or

1223
00:43:32,079 --> 00:43:34,000
whatever

1224
00:43:34,000 --> 00:43:37,720
yep so that's it

1225
00:43:52,319 --> 00:43:55,319
foreign

1226
00:43:58,240 --> 00:44:00,560
so actually someone's asking on the

1227
00:44:00,560 --> 00:44:03,680
internet why the multpaths are all uh by

1228
00:44:03,680 --> 00:44:06,720
default writable

1229
00:44:07,280 --> 00:44:09,200
actually

1230
00:44:09,200 --> 00:44:10,880
i don't know i i

1231
00:44:10,880 --> 00:44:13,040
i i've only used it for exploitation so

1232
00:44:13,040 --> 00:44:14,800
i actually don't know the legitimate

1233
00:44:14,800 --> 00:44:16,319
reason that it's

1234
00:44:16,319 --> 00:44:18,480
writable um

1235
00:44:18,480 --> 00:44:20,560
yeah i'm assuming there's some reason

1236
00:44:20,560 --> 00:44:23,599
like that like especially ubuntu users

1237
00:44:23,599 --> 00:44:26,160
or something just might run into i don't

1238
00:44:26,160 --> 00:44:28,880
think it's by default on all distros

1239
00:44:28,880 --> 00:44:31,520
but um yeah it i think it is on like

1240
00:44:31,520 --> 00:44:34,240
debian maybe seuss ubuntu so there must

1241
00:44:34,240 --> 00:44:35,599
be a good reason but yeah unfortunately

1242
00:44:35,599 --> 00:44:38,400
i'm i'm not sure

1243
00:44:39,119 --> 00:44:41,359
okay

1244
00:44:45,520 --> 00:44:47,510
adam

1245
00:44:47,510 --> 00:44:50,369
[Applause]

