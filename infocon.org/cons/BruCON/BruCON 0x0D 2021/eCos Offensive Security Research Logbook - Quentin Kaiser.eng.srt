1
00:00:00,080 --> 00:00:02,080
hello uh good afternoon everyone hope

2
00:00:02,080 --> 00:00:03,840
you had a great start at brook on this

3
00:00:03,840 --> 00:00:06,879
morning um so welcome to eco's offensive

4
00:00:06,879 --> 00:00:09,200
security research logbook it's a

5
00:00:09,200 --> 00:00:11,280
mouthful um it's a condensed

6
00:00:11,280 --> 00:00:13,120
presentation of all my ecos research i

7
00:00:13,120 --> 00:00:15,200
did between march 2020

8
00:00:15,200 --> 00:00:18,480
and may 2021 the idea is to share tools

9
00:00:18,480 --> 00:00:20,320
and techniques i apply to a custom

10
00:00:20,320 --> 00:00:22,880
branch of ecos so that other researchers

11
00:00:22,880 --> 00:00:26,640
can reproduce on other targets

12
00:00:26,640 --> 00:00:29,039
you know the drill quick disclaimers

13
00:00:29,039 --> 00:00:30,160
the views expressed during this

14
00:00:30,160 --> 00:00:32,399
presentation are my own and do not

15
00:00:32,399 --> 00:00:34,399
reflect those of my past or current

16
00:00:34,399 --> 00:00:37,440
employers nor their customers

17
00:00:37,440 --> 00:00:39,840
all the content is cc by sharealike and

18
00:00:39,840 --> 00:00:42,879
a hundred percent of the

19
00:00:42,879 --> 00:00:44,719
tools and code i will demonstrate today

20
00:00:44,719 --> 00:00:48,079
are open source and available on github

21
00:00:48,079 --> 00:00:50,800
um quick word about me before we dive in

22
00:00:50,800 --> 00:00:52,800
uh i'm quentin kaiser i worked as a

23
00:00:52,800 --> 00:00:54,800
consulting person pen tester for six

24
00:00:54,800 --> 00:00:57,199
years before going on a small sabbatical

25
00:00:57,199 --> 00:00:59,440
that thrown me into

26
00:00:59,440 --> 00:01:02,719
a binary analysis nerd i'm now a

27
00:01:02,719 --> 00:01:04,959
security researcher at iot inspector

28
00:01:04,959 --> 00:01:06,400
research lab

29
00:01:06,400 --> 00:01:07,920
you may have seen of research on the

30
00:01:07,920 --> 00:01:11,439
freeltech sdk broadcom sdk and a

31
00:01:11,439 --> 00:01:13,520
cisco advisory we've released this

32
00:01:13,520 --> 00:01:14,400
morning

33
00:01:14,400 --> 00:01:16,640
and i'm currently focusing on binary

34
00:01:16,640 --> 00:01:17,840
exploitation

35
00:01:17,840 --> 00:01:20,560
of embedded devices and automating book

36
00:01:20,560 --> 00:01:23,840
findings in large firmware blobs

37
00:01:23,840 --> 00:01:26,400
so to this battle plan is quite simple

38
00:01:26,400 --> 00:01:28,560
we'll start by a quick introduction to

39
00:01:28,560 --> 00:01:30,799
e-course what it is what it isn't where

40
00:01:30,799 --> 00:01:33,920
it's deployed and why it's important i

41
00:01:33,920 --> 00:01:36,159
will then demonstrate how to extract the

42
00:01:36,159 --> 00:01:38,320
e-cos firmware from different devices

43
00:01:38,320 --> 00:01:40,720
we'll then analyze them developing tools

44
00:01:40,720 --> 00:01:43,040
and techniques to make that analysis

45
00:01:43,040 --> 00:01:45,280
easier for reversers

46
00:01:45,280 --> 00:01:47,759
and once we got a nice disassembled view

47
00:01:47,759 --> 00:01:49,840
of the firmware we'll find bugs exploit

48
00:01:49,840 --> 00:01:52,880
them and gain long-term persistence

49
00:01:52,880 --> 00:01:55,520
i'll close with a section on future work

50
00:01:55,520 --> 00:01:57,920
and research ids

51
00:01:57,920 --> 00:02:00,320
so let's start by defining what is ecos

52
00:02:00,320 --> 00:02:04,000
uh by a show then who knew about ecos or

53
00:02:04,000 --> 00:02:06,479
played with equals in the past

54
00:02:06,479 --> 00:02:08,399
okay great

55
00:02:08,399 --> 00:02:10,800
um it's a free and open source uh

56
00:02:10,800 --> 00:02:12,640
real-time operating system it's mostly

57
00:02:12,640 --> 00:02:14,640
implemented in c and c plus plus but

58
00:02:14,640 --> 00:02:15,680
some

59
00:02:15,680 --> 00:02:17,680
uh sometime in pure assembly we'll see

60
00:02:17,680 --> 00:02:20,080
that later it's built with the one

61
00:02:20,080 --> 00:02:22,879
process multiple threads architecture

62
00:02:22,879 --> 00:02:25,440
and speaking of architecture it supports

63
00:02:25,440 --> 00:02:27,360
a lot of them

64
00:02:27,360 --> 00:02:30,239
be its arm mips super edge spark

65
00:02:30,239 --> 00:02:32,720
there are supporting it and it's

66
00:02:32,720 --> 00:02:36,400
everywhere consumer electronics like the

67
00:02:36,400 --> 00:02:39,599
wireless chipsets of playstations

68
00:02:39,599 --> 00:02:41,200
networking gears like routers and

69
00:02:41,200 --> 00:02:42,560
switches

70
00:02:42,560 --> 00:02:45,440
industrial devices like plcs payment

71
00:02:45,440 --> 00:02:48,000
systems like smart cards readers you

72
00:02:48,000 --> 00:02:50,080
have in shops

73
00:02:50,080 --> 00:02:52,800
mostly in europe satellites in space

74
00:02:52,800 --> 00:02:55,280
missile launcher controllers the most of

75
00:02:55,280 --> 00:02:56,560
them run

76
00:02:56,560 --> 00:02:58,959
on ecos and the latest release is close

77
00:02:58,959 --> 00:03:00,959
to 10 years old but given its

78
00:03:00,959 --> 00:03:02,159
application

79
00:03:02,159 --> 00:03:05,280
it's there to stay for some time

80
00:03:05,280 --> 00:03:07,920
taking observer bias in consideration uh

81
00:03:07,920 --> 00:03:09,680
and being fully aware that this is only

82
00:03:09,680 --> 00:03:11,840
free search content that got released

83
00:03:11,840 --> 00:03:12,800
into the

84
00:03:12,800 --> 00:03:15,519
public domain this is mostly how i

85
00:03:15,519 --> 00:03:18,480
picture the history of ecos security

86
00:03:18,480 --> 00:03:19,519
research

87
00:03:19,519 --> 00:03:22,080
so we can observe three eras you have

88
00:03:22,080 --> 00:03:24,000
the early days the first memory

89
00:03:24,000 --> 00:03:27,680
corruptions crashes and the first fully

90
00:03:27,680 --> 00:03:28,799
working

91
00:03:28,799 --> 00:03:30,400
end-to-end exploits

92
00:03:30,400 --> 00:03:31,599
at the end

93
00:03:31,599 --> 00:03:32,799
so

94
00:03:32,799 --> 00:03:35,280
during the early days we'll see the uh

95
00:03:35,280 --> 00:03:38,879
successive releases of ecos from 1998 to

96
00:03:38,879 --> 00:03:41,920
2009 at least for the

97
00:03:41,920 --> 00:03:44,400
non-commercially supported versions

98
00:03:44,400 --> 00:03:46,239
but then starting from 2010 we see

99
00:03:46,239 --> 00:03:48,159
reports of stack overflows affecting

100
00:03:48,159 --> 00:03:50,720
cable modems running on ecos

101
00:03:50,720 --> 00:03:53,040
and those reports only mention uh the

102
00:03:53,040 --> 00:03:55,599
risk of denial of service the proof of

103
00:03:55,599 --> 00:03:57,680
concept just crashed the device they're

104
00:03:57,680 --> 00:03:59,599
not taking

105
00:03:59,599 --> 00:04:00,480
control

106
00:04:00,480 --> 00:04:01,439
of

107
00:04:01,439 --> 00:04:04,400
devices that are targeted interestingly

108
00:04:04,400 --> 00:04:06,959
um these devices starts to appear in

109
00:04:06,959 --> 00:04:09,760
2010 because in 2009 broadcom starts

110
00:04:09,760 --> 00:04:12,239
selling its cable modem packages based

111
00:04:12,239 --> 00:04:15,439
on ecos version 2.

112
00:04:15,439 --> 00:04:17,358
in 2016 we see the publication of

113
00:04:17,358 --> 00:04:20,399
dedicated reversing tools one to extract

114
00:04:20,399 --> 00:04:21,358
firmware

115
00:04:21,358 --> 00:04:23,360
from equals based

116
00:04:23,360 --> 00:04:26,800
broadcom devices and another to extract

117
00:04:26,800 --> 00:04:30,000
the from fs from former images

118
00:04:30,000 --> 00:04:32,160
and it in terms of equals focused

119
00:04:32,160 --> 00:04:35,120
security research it all really started

120
00:04:35,120 --> 00:04:38,560
with the release of cable owned in 2020

121
00:04:38,560 --> 00:04:41,440
it's a research paper by a layer bird

122
00:04:41,440 --> 00:04:42,960
which uh

123
00:04:42,960 --> 00:04:46,000
demonstrates remote command execution

124
00:04:46,000 --> 00:04:49,280
on equals devices mainly the technicolor

125
00:04:49,280 --> 00:04:50,960
and sergeant-comb

126
00:04:50,960 --> 00:04:53,280
cable modems

127
00:04:53,280 --> 00:04:55,600
i was really interested in that paper

128
00:04:55,600 --> 00:04:59,759
and a year later i released two

129
00:04:59,759 --> 00:05:02,320
research papers one targeting the

130
00:05:02,320 --> 00:05:04,880
netgear device deployed by voo in

131
00:05:04,880 --> 00:05:07,360
belgium and the other one targeting ask

132
00:05:07,360 --> 00:05:08,720
devices

133
00:05:08,720 --> 00:05:11,600
deployed by orange belgium

134
00:05:11,600 --> 00:05:12,479
so

135
00:05:12,479 --> 00:05:14,240
the first step of our journey is to

136
00:05:14,240 --> 00:05:17,120
extract firmware from target devices

137
00:05:17,120 --> 00:05:20,160
these devices being managed by isps

138
00:05:20,160 --> 00:05:21,919
their firmware are custom and they

139
00:05:21,919 --> 00:05:23,600
cannot be downloaded from the vendor's

140
00:05:23,600 --> 00:05:25,280
website so

141
00:05:25,280 --> 00:05:27,360
like updates are usually applied over

142
00:05:27,360 --> 00:05:30,240
tftp following the docsis protocol but

143
00:05:30,240 --> 00:05:31,680
you can't

144
00:05:31,680 --> 00:05:33,680
like get the firmware out of it so we

145
00:05:33,680 --> 00:05:36,800
have to extract it from live devices

146
00:05:36,800 --> 00:05:38,960
thankfully jcleaner fell is a tool

147
00:05:38,960 --> 00:05:41,120
called bcm2utools that is dedicated to

148
00:05:41,120 --> 00:05:42,400
do just that

149
00:05:42,400 --> 00:05:44,800
um and we're mostly interested in

150
00:05:44,800 --> 00:05:47,520
bcm2dump a utility to them from and

151
00:05:47,520 --> 00:05:49,759
flash content it's actually taking

152
00:05:49,759 --> 00:05:52,000
advantage of a free 3-memory command

153
00:05:52,000 --> 00:05:55,440
that is exposed on the cli

154
00:05:55,520 --> 00:05:57,600
but before we can dump the memory we

155
00:05:57,600 --> 00:05:59,919
need to get the memory addresses offsets

156
00:05:59,919 --> 00:06:02,720
and sizes from device in order to write

157
00:06:02,720 --> 00:06:05,440
a model specific memory map that will be

158
00:06:05,440 --> 00:06:09,199
used by bcm to them to read the memory

159
00:06:09,199 --> 00:06:11,280
so broadcom cable modems

160
00:06:11,280 --> 00:06:13,840
always use two flash storage chips and

161
00:06:13,840 --> 00:06:15,840
spi flash for boot loaders and

162
00:06:15,840 --> 00:06:19,120
non-volatile data and a non-flash to

163
00:06:19,120 --> 00:06:21,039
store the firmware files you have two

164
00:06:21,039 --> 00:06:23,840
images image one and image two image two

165
00:06:23,840 --> 00:06:26,479
acting as a backup if image one gets

166
00:06:26,479 --> 00:06:29,039
corrupted

167
00:06:29,520 --> 00:06:31,039
to get the shell you have two ways

168
00:06:31,039 --> 00:06:32,720
either connect over telnet if it's

169
00:06:32,720 --> 00:06:36,000
exposed usually it's not or connect over

170
00:06:36,000 --> 00:06:39,360
uart here it's the outdoor layout of a

171
00:06:39,360 --> 00:06:42,240
netgear cg series

172
00:06:42,240 --> 00:06:44,720
and you have 2p nodes so

173
00:06:44,720 --> 00:06:47,360
some cable modems most of those broadcom

174
00:06:47,360 --> 00:06:48,560
packages

175
00:06:48,560 --> 00:06:50,720
they can run two independent systems you

176
00:06:50,720 --> 00:06:53,280
have the cm for cable modem that runs on

177
00:06:53,280 --> 00:06:56,160
ecos and dms for media server that runs

178
00:06:56,160 --> 00:06:57,440
on linux

179
00:06:57,440 --> 00:06:59,520
that's why you always have between two

180
00:06:59,520 --> 00:07:02,880
and three uart pinots you can connect to

181
00:07:02,880 --> 00:07:05,280
it using any circle to usb adapter there

182
00:07:05,280 --> 00:07:08,319
i was using the bus pirates

183
00:07:08,319 --> 00:07:11,199
and it will land you on a cm console

184
00:07:11,199 --> 00:07:13,120
where you can

185
00:07:13,120 --> 00:07:15,280
take advantage of building commands to

186
00:07:15,280 --> 00:07:17,599
gather information about flash chips in

187
00:07:17,599 --> 00:07:18,800
use

188
00:07:18,800 --> 00:07:21,840
calling show under the flash menu will

189
00:07:21,840 --> 00:07:24,160
display all the information we need we

190
00:07:24,160 --> 00:07:27,680
first see the spi flash with the memory

191
00:07:27,680 --> 00:07:29,039
map

192
00:07:29,039 --> 00:07:31,039
so we have offset sizes of each region

193
00:07:31,039 --> 00:07:32,720
we are interes interested in the

194
00:07:32,720 --> 00:07:34,960
bootloader and the two permanent and

195
00:07:34,960 --> 00:07:37,520
dynamic non-volatile

196
00:07:37,520 --> 00:07:38,639
data

197
00:07:38,639 --> 00:07:41,280
and then we have the non-flash details

198
00:07:41,280 --> 00:07:43,199
again with the memory map of that

199
00:07:43,199 --> 00:07:45,520
non-flash with offsets and sizes of each

200
00:07:45,520 --> 00:07:46,720
region

201
00:07:46,720 --> 00:07:50,240
image 1 and image 2 namely

202
00:07:50,240 --> 00:07:52,639
using that information we can write a

203
00:07:52,639 --> 00:07:55,120
device profile that is shown on screen

204
00:07:55,120 --> 00:07:57,759
so the nvram section corresponds to the

205
00:07:57,759 --> 00:08:00,240
spi flash and the flash section

206
00:08:00,240 --> 00:08:03,759
corresponds to the nvram so we see the

207
00:08:03,759 --> 00:08:08,080
offset the size and an optional name

208
00:08:08,080 --> 00:08:10,240
so with that new profile compiled in bcm

209
00:08:10,240 --> 00:08:11,919
totem we can pull the content of the

210
00:08:11,919 --> 00:08:14,479
device and at the bottom we can see our

211
00:08:14,479 --> 00:08:17,280
firmware image at least the header

212
00:08:17,280 --> 00:08:21,280
with the firmware name on top

213
00:08:21,280 --> 00:08:23,680
but that was the easy way

214
00:08:23,680 --> 00:08:25,120
so

215
00:08:25,120 --> 00:08:27,440
this works on that device but some

216
00:08:27,440 --> 00:08:29,440
devices have custom settings that can be

217
00:08:29,440 --> 00:08:32,080
set by isps to disable disable console

218
00:08:32,080 --> 00:08:33,760
access

219
00:08:33,760 --> 00:08:34,640
so

220
00:08:34,640 --> 00:08:36,640
this bcm2dump

221
00:08:36,640 --> 00:08:39,200
tool has another mode where it will

222
00:08:39,200 --> 00:08:42,559
patch bootloader instructions at runtime

223
00:08:42,559 --> 00:08:43,839
so you can

224
00:08:43,839 --> 00:08:46,160
you can dump the memory content

225
00:08:46,160 --> 00:08:49,040
uh over a serial connection but to do

226
00:08:49,040 --> 00:08:51,360
that we need to acquire a dump of the

227
00:08:51,360 --> 00:08:53,200
bootloader in order to identify

228
00:08:53,200 --> 00:08:56,800
functions we need to patch so to dump

229
00:08:56,800 --> 00:08:58,640
the bootloader we need to know where

230
00:08:58,640 --> 00:09:00,880
it's mapped in from and the easiest way

231
00:09:00,880 --> 00:09:03,600
to do that is to make it crash

232
00:09:03,600 --> 00:09:05,680
that's where what we are doing here from

233
00:09:05,680 --> 00:09:10,240
the bootloader menu so we are writing a

234
00:09:10,240 --> 00:09:13,200
dumb instructions at a specific

235
00:09:13,200 --> 00:09:16,320
address we jump to it it crashes

236
00:09:16,320 --> 00:09:19,120
and the return address on the bottom

237
00:09:19,120 --> 00:09:21,120
right is actually where it's mapped in

238
00:09:21,120 --> 00:09:23,040
ram

239
00:09:23,040 --> 00:09:24,480
so we just have to dump the frame

240
00:09:24,480 --> 00:09:26,320
content from that address minus let's

241
00:09:26,320 --> 00:09:31,120
say 1k page for let's say 256 kilobytes

242
00:09:31,120 --> 00:09:33,760
give her that our length is longer and

243
00:09:33,760 --> 00:09:35,600
like the offsets are wrong we need to do

244
00:09:35,600 --> 00:09:37,680
some cleanup it's quite easy to do

245
00:09:37,680 --> 00:09:40,240
because before the bootloader it's full

246
00:09:40,240 --> 00:09:42,640
of null bytes after the bootloader is

247
00:09:42,640 --> 00:09:47,120
full of 0xffs so we clean that up

248
00:09:47,120 --> 00:09:48,000
and

249
00:09:48,000 --> 00:09:49,680
now that we have a clean bootloader we

250
00:09:49,680 --> 00:09:52,800
can load it in gydra as a pro mips 32

251
00:09:52,800 --> 00:09:55,120
big engine image with the base address

252
00:09:55,120 --> 00:09:58,080
we just identified before

253
00:09:58,080 --> 00:10:00,080
the cool thing is that procom

254
00:10:00,080 --> 00:10:03,360
booth orders left have lots of logs and

255
00:10:03,360 --> 00:10:06,160
debug strings in the final binary and we

256
00:10:06,160 --> 00:10:09,920
can use them to identify functions

257
00:10:09,920 --> 00:10:12,240
so this is an example

258
00:10:12,240 --> 00:10:14,079
it's unnamed because you don't have

259
00:10:14,079 --> 00:10:17,040
symbols intro binary but this is a local

260
00:10:17,040 --> 00:10:19,440
for non-flash read colon blah blah blah

261
00:10:19,440 --> 00:10:21,120
and non-flash read is actually the

262
00:10:21,120 --> 00:10:22,560
function name

263
00:10:22,560 --> 00:10:23,920
so

264
00:10:23,920 --> 00:10:28,160
we can write a script to identify locals

265
00:10:28,160 --> 00:10:29,839
extract the function name from the local

266
00:10:29,839 --> 00:10:31,760
and rename the function

267
00:10:31,760 --> 00:10:34,399
from where it's called using that value

268
00:10:34,399 --> 00:10:36,959
i just did that with radar 2 and r2 pipe

269
00:10:36,959 --> 00:10:39,120
which allows us to pinpoint the

270
00:10:39,120 --> 00:10:42,079
functions we need namely non-flash read

271
00:10:42,079 --> 00:10:44,399
and spr flash read we have the function

272
00:10:44,399 --> 00:10:45,680
offsets

273
00:10:45,680 --> 00:10:49,680
and we can put that into our bcm2 dump

274
00:10:49,680 --> 00:10:50,959
profile

275
00:10:50,959 --> 00:10:52,800
so um

276
00:10:52,800 --> 00:10:54,640
you have the offsets to create from

277
00:10:54,640 --> 00:10:56,399
flash the offset of the function to

278
00:10:56,399 --> 00:10:58,880
reinfor to read from the spi

279
00:10:58,880 --> 00:11:00,880
the mode is actually the function

280
00:11:00,880 --> 00:11:03,040
signature so when you see vol it's

281
00:11:03,040 --> 00:11:05,440
buffer offset length when you see obl

282
00:11:05,440 --> 00:11:08,079
it's offset buffer length you also need

283
00:11:08,079 --> 00:11:09,040
the

284
00:11:09,040 --> 00:11:11,040
function offset of printf because we

285
00:11:11,040 --> 00:11:12,880
need to print out the content over

286
00:11:12,880 --> 00:11:15,839
serial and in an interesting thing on

287
00:11:15,839 --> 00:11:18,640
top is the magic you have an address and

288
00:11:18,640 --> 00:11:23,200
then a value and the tool will read

289
00:11:23,200 --> 00:11:25,120
a string from that address and if it

290
00:11:25,120 --> 00:11:27,519
matches the string just after that it

291
00:11:27,519 --> 00:11:30,800
will auto detect the device

292
00:11:30,800 --> 00:11:32,720
so we can validate our profile using the

293
00:11:32,720 --> 00:11:34,640
auto detection feature that will free

294
00:11:34,640 --> 00:11:36,160
the string

295
00:11:36,160 --> 00:11:37,120
um

296
00:11:37,120 --> 00:11:40,079
that's what's shown here and here we can

297
00:11:40,079 --> 00:11:42,320
see it in operation with broadcom to

298
00:11:42,320 --> 00:11:45,360
dump first patching the code on the

299
00:11:45,360 --> 00:11:47,680
first three line and then proceeding on

300
00:11:47,680 --> 00:11:51,760
dumping the requested memory content

301
00:11:51,760 --> 00:11:54,639
the process is clearly more tedious but

302
00:11:54,639 --> 00:11:56,720
it can be fully automated

303
00:11:56,720 --> 00:11:58,959
as i've shown with a bit of python and

304
00:11:58,959 --> 00:12:00,480
trade r2

305
00:12:00,480 --> 00:12:02,480
and it's way faster like the initial

306
00:12:02,480 --> 00:12:05,279
method of using the equals console it

307
00:12:05,279 --> 00:12:08,240
takes around seven hours to dump a full

308
00:12:08,240 --> 00:12:09,760
firmware image

309
00:12:09,760 --> 00:12:12,000
with this technique it takes like 30

310
00:12:12,000 --> 00:12:14,639
minutes and of course sometimes there is

311
00:12:14,639 --> 00:12:16,480
no other way it's either that or

312
00:12:16,480 --> 00:12:19,839
patching the spi flash using like soic

313
00:12:19,839 --> 00:12:22,639
clips and a programmer so

314
00:12:22,639 --> 00:12:24,800
whichever you like but this is a

315
00:12:24,800 --> 00:12:26,560
technique that you can do without too

316
00:12:26,560 --> 00:12:29,760
much of um hardware hacking

317
00:12:29,760 --> 00:12:30,720
all right

318
00:12:30,720 --> 00:12:33,279
so back to our firmware dump although it

319
00:12:33,279 --> 00:12:34,560
looks like

320
00:12:34,560 --> 00:12:36,880
ready to be loaded in your software

321
00:12:36,880 --> 00:12:40,160
reverse engineering tool of choice

322
00:12:40,160 --> 00:12:42,639
it's actually not so firmware are packed

323
00:12:42,639 --> 00:12:45,200
into program store images it's a custom

324
00:12:45,200 --> 00:12:47,040
format from broadcom

325
00:12:47,040 --> 00:12:49,440
that starts with a well-defined header

326
00:12:49,440 --> 00:12:51,600
followed by the compressed binary

327
00:12:51,600 --> 00:12:53,920
content of that former

328
00:12:53,920 --> 00:12:56,639
so the header format is really simple

329
00:12:56,639 --> 00:12:58,720
but we usually we're really interested

330
00:12:58,720 --> 00:13:00,720
in two specific values

331
00:13:00,720 --> 00:13:03,040
the program load address that we will

332
00:13:03,040 --> 00:13:05,279
need when loading it in gitra and the

333
00:13:05,279 --> 00:13:06,720
crc

334
00:13:06,720 --> 00:13:09,279
that we need to recompute if we are

335
00:13:09,279 --> 00:13:12,720
three packing custom firmwares

336
00:13:12,720 --> 00:13:15,279
and also so most firmware images are

337
00:13:15,279 --> 00:13:18,240
compressed using lcma

338
00:13:18,240 --> 00:13:19,680
interestingly broadcom released the

339
00:13:19,680 --> 00:13:21,680
source code of its program store utility

340
00:13:21,680 --> 00:13:23,360
it can be used to unpack and repack

341
00:13:23,360 --> 00:13:24,720
firmware images

342
00:13:24,720 --> 00:13:26,720
um they've released it as part of their

343
00:13:26,720 --> 00:13:29,360
new rtos called zephyr

344
00:13:29,360 --> 00:13:31,600
and we can use it to extract the actual

345
00:13:31,600 --> 00:13:34,399
firmware so you see the different header

346
00:13:34,399 --> 00:13:37,040
being printed out and the actual

347
00:13:37,040 --> 00:13:40,639
binary is written to an output file

348
00:13:40,639 --> 00:13:42,399
so now that we have our firmware image

349
00:13:42,399 --> 00:13:45,279
it's time to analyze it we can load it

350
00:13:45,279 --> 00:13:48,320
in ketra as a mips 32 big engine binary

351
00:13:48,320 --> 00:13:50,160
with the load address we just read from

352
00:13:50,160 --> 00:13:52,880
the program store header however there

353
00:13:52,880 --> 00:13:54,320
is a big

354
00:13:54,320 --> 00:13:56,160
problem we don't have symbols we don't

355
00:13:56,160 --> 00:13:57,760
have function names we don't have memory

356
00:13:57,760 --> 00:14:00,880
mappings it's a huge block of codes that

357
00:14:00,880 --> 00:14:03,680
makes almost no sense uh so you have to

358
00:14:03,680 --> 00:14:05,519
remember that there is no concept of

359
00:14:05,519 --> 00:14:08,079
syscalls on real-time operating systems

360
00:14:08,079 --> 00:14:10,639
like ecos so you can't do bottom-up

361
00:14:10,639 --> 00:14:12,560
tracing like you would do on a linux

362
00:14:12,560 --> 00:14:15,440
firmware um identifying for example the

363
00:14:15,440 --> 00:14:18,079
syscall to exactly e and then

364
00:14:18,079 --> 00:14:20,000
doing a bottom-up approach to find

365
00:14:20,000 --> 00:14:22,320
ellipse functions that

366
00:14:22,320 --> 00:14:24,079
implement exactly e

367
00:14:24,079 --> 00:14:27,440
so let's see what we can do to fix this

368
00:14:27,440 --> 00:14:28,480
so

369
00:14:28,480 --> 00:14:31,120
this is the plan um we want to identify

370
00:14:31,120 --> 00:14:33,120
standard library functions we want to

371
00:14:33,120 --> 00:14:34,399
rename a good

372
00:14:34,399 --> 00:14:37,040
portion of the functions identify c plus

373
00:14:37,040 --> 00:14:38,800
plus v tables and get a good

374
00:14:38,800 --> 00:14:42,240
understanding of memory mappings

375
00:14:42,240 --> 00:14:45,120
so the first step is to identify eco

376
00:14:45,120 --> 00:14:47,360
standard library functions using a

377
00:14:47,360 --> 00:14:50,240
signature library you can call it flirt

378
00:14:50,240 --> 00:14:52,720
function id signature libraries or

379
00:14:52,720 --> 00:14:56,160
signature if you are a fan of reader two

380
00:14:56,160 --> 00:14:58,480
it's all the same it's function pattern

381
00:14:58,480 --> 00:14:59,760
matching

382
00:14:59,760 --> 00:15:02,560
um and eco source code being gpl

383
00:15:02,560 --> 00:15:05,440
licensed uh vendors are obligated to

384
00:15:05,440 --> 00:15:06,959
release their

385
00:15:06,959 --> 00:15:09,199
own version of ecos

386
00:15:09,199 --> 00:15:11,760
not the added layer but the actual ecos

387
00:15:11,760 --> 00:15:14,079
core that they used to build those

388
00:15:14,079 --> 00:15:16,800
firmwares so what we can do is download

389
00:15:16,800 --> 00:15:18,000
the code

390
00:15:18,000 --> 00:15:19,040
compile

391
00:15:19,040 --> 00:15:21,120
shared objects with debug symbols for

392
00:15:21,120 --> 00:15:23,040
our target architecture

393
00:15:23,040 --> 00:15:25,120
load them into gitra generate function

394
00:15:25,120 --> 00:15:28,000
id databases and then use that to auto

395
00:15:28,000 --> 00:15:31,040
identify standard libraries within gitra

396
00:15:31,040 --> 00:15:32,800
it's fully automated there's a tool

397
00:15:32,800 --> 00:15:35,199
online that i publish to do that

398
00:15:35,199 --> 00:15:36,880
i won't cover all the details but it

399
00:15:36,880 --> 00:15:39,360
took some serious time

400
00:15:39,360 --> 00:15:42,000
due to weird requirements like 12 12

401
00:15:42,000 --> 00:15:45,519
years old gcc versions patches from ecos

402
00:15:45,519 --> 00:15:47,600
i ended up running everything in a

403
00:15:47,600 --> 00:15:50,160
really audited centers vm

404
00:15:50,160 --> 00:15:52,320
if you want to reproduce that

405
00:15:52,320 --> 00:15:54,959
there is a vagrant file online

406
00:15:54,959 --> 00:15:56,959
but i

407
00:15:56,959 --> 00:15:59,600
also published the function id databases

408
00:15:59,600 --> 00:16:01,120
so at the end of the process we have

409
00:16:01,120 --> 00:16:03,440
more than 1200 functions signatures

410
00:16:03,440 --> 00:16:06,480
spanning 26 standard libraries

411
00:16:06,480 --> 00:16:10,079
that's nice but i actually wanted more

412
00:16:10,079 --> 00:16:12,320
so we will see

413
00:16:12,320 --> 00:16:14,800
if we can apply the function

414
00:16:14,800 --> 00:16:16,720
renaming technique i used in the

415
00:16:16,720 --> 00:16:21,040
bootloader but for the main firmware

416
00:16:21,279 --> 00:16:23,600
and formers are full of function tracing

417
00:16:23,600 --> 00:16:25,199
login calls that contain the function

418
00:16:25,199 --> 00:16:27,600
name you have an example here

419
00:16:27,600 --> 00:16:30,880
um this is another example another

420
00:16:30,880 --> 00:16:33,759
example you have actually four different

421
00:16:33,759 --> 00:16:35,839
logging functions that are used

422
00:16:35,839 --> 00:16:38,720
throughout the firmware

423
00:16:38,720 --> 00:16:40,320
so given a list of known logging

424
00:16:40,320 --> 00:16:42,160
functions we can identify

425
00:16:42,160 --> 00:16:43,839
where they're from where they're called

426
00:16:43,839 --> 00:16:45,120
extract the function name from the

427
00:16:45,120 --> 00:16:46,720
parameter and rename the calling

428
00:16:46,720 --> 00:16:48,839
function with that

429
00:16:48,839 --> 00:16:51,680
name um

430
00:16:51,680 --> 00:16:54,720
so another thing is that um given that

431
00:16:54,720 --> 00:16:56,560
most of the firmware has been developed

432
00:16:56,560 --> 00:16:58,720
in c plus plus when you extract the

433
00:16:58,720 --> 00:17:01,199
function name it will follow the c plus

434
00:17:01,199 --> 00:17:03,440
convention of class name colon colon

435
00:17:03,440 --> 00:17:04,799
function name

436
00:17:04,799 --> 00:17:07,520
so we know the class name from which

437
00:17:07,520 --> 00:17:10,000
we can identify functions that are part

438
00:17:10,000 --> 00:17:11,199
of a c

439
00:17:11,199 --> 00:17:14,079
class and automatically

440
00:17:14,079 --> 00:17:16,640
set the calling convention of that

441
00:17:16,640 --> 00:17:18,480
function to this call

442
00:17:18,480 --> 00:17:21,439
which will make the this value point to

443
00:17:21,439 --> 00:17:22,799
the v table

444
00:17:22,799 --> 00:17:23,919
and

445
00:17:23,919 --> 00:17:26,400
knowing where the v table is located

446
00:17:26,400 --> 00:17:28,720
usually in getra you have a label on top

447
00:17:28,720 --> 00:17:31,600
of the v table which is usually ptr

448
00:17:31,600 --> 00:17:33,919
underscore fun underscore

449
00:17:33,919 --> 00:17:35,679
something

450
00:17:35,679 --> 00:17:38,480
and here with a script we can rename the

451
00:17:38,480 --> 00:17:40,880
label to get like class name colon

452
00:17:40,880 --> 00:17:42,799
column fee table

453
00:17:42,799 --> 00:17:44,640
and this is what it looks like we have

454
00:17:44,640 --> 00:17:47,600
protcom ecos message queue

455
00:17:47,600 --> 00:17:49,440
class with its fee table and the

456
00:17:49,440 --> 00:17:51,280
different functions that are part of

457
00:17:51,280 --> 00:17:53,200
that class

458
00:17:53,200 --> 00:17:55,600
it's super useful because a side effect

459
00:17:55,600 --> 00:17:58,720
of it is that we can understand how the

460
00:17:58,720 --> 00:18:00,640
developers used inheritance and

461
00:18:00,640 --> 00:18:02,080
polymorphism

462
00:18:02,080 --> 00:18:04,559
and in this case you have like some

463
00:18:04,559 --> 00:18:06,799
functions that were not renamed but

464
00:18:06,799 --> 00:18:09,360
given where they're located and to which

465
00:18:09,360 --> 00:18:13,679
class they belong we can do a proper

466
00:18:13,679 --> 00:18:16,080
guestimation of what they're actually

467
00:18:16,080 --> 00:18:18,000
doing

468
00:18:18,000 --> 00:18:19,600
with all these methods put together we

469
00:18:19,600 --> 00:18:21,840
can identify close to 10 percent of any

470
00:18:21,840 --> 00:18:24,080
given broadcast based ecosformer which

471
00:18:24,080 --> 00:18:25,919
is seems

472
00:18:25,919 --> 00:18:28,000
not a lot but it actually is because

473
00:18:28,000 --> 00:18:29,520
there's lots of

474
00:18:29,520 --> 00:18:32,880
garbage functions within farmers

475
00:18:32,880 --> 00:18:33,760
um

476
00:18:33,760 --> 00:18:37,039
so now that we have auto renamed a good

477
00:18:37,039 --> 00:18:39,760
chunk of protcom's functions we also

478
00:18:39,760 --> 00:18:41,360
identified and renamed simplest was

479
00:18:41,360 --> 00:18:43,679
vtables it's time to get a good

480
00:18:43,679 --> 00:18:46,960
understanding of the memory mapping

481
00:18:46,960 --> 00:18:48,880
so by memory mapping i mean how the

482
00:18:48,880 --> 00:18:52,559
firmware is loaded in from at runtime

483
00:18:52,559 --> 00:18:54,080
ideally we would like to know the

484
00:18:54,080 --> 00:18:56,400
address of vectors the text segments

485
00:18:56,400 --> 00:18:59,120
data segment bss segment the stack and

486
00:18:59,120 --> 00:19:01,919
eve locations

487
00:19:01,919 --> 00:19:03,840
i won't cover vectors here because we

488
00:19:03,840 --> 00:19:06,799
don't have hours but if you're really

489
00:19:06,799 --> 00:19:09,760
into mips assembly interrupt and

490
00:19:09,760 --> 00:19:11,600
exception vectors

491
00:19:11,600 --> 00:19:14,400
everything is documented on the ecos.wtf

492
00:19:14,400 --> 00:19:15,919
blog

493
00:19:15,919 --> 00:19:17,679
the text is always mapped at the load

494
00:19:17,679 --> 00:19:19,760
address that was easy we can extract it

495
00:19:19,760 --> 00:19:21,440
from the

496
00:19:21,440 --> 00:19:23,840
program store header

497
00:19:23,840 --> 00:19:25,840
the data segments there always are to

498
00:19:25,840 --> 00:19:29,039
map precisely for uh show firmware uh

499
00:19:29,039 --> 00:19:31,200
binaries unless it always starts with

500
00:19:31,200 --> 00:19:32,880
the same string which is the case with

501
00:19:32,880 --> 00:19:34,000
broadcom

502
00:19:34,000 --> 00:19:37,039
um that always starts with bcm0 which is

503
00:19:37,039 --> 00:19:38,559
the first

504
00:19:38,559 --> 00:19:41,120
of its network interface name and the

505
00:19:41,120 --> 00:19:43,600
end of that data segment can also be

506
00:19:43,600 --> 00:19:45,760
easily identified because it's full of

507
00:19:45,760 --> 00:19:48,720
null bytes like thousands of them

508
00:19:48,720 --> 00:19:50,559
and the identification can be fully

509
00:19:50,559 --> 00:19:52,559
automated using python screen string

510
00:19:52,559 --> 00:19:54,640
matching code like the one

511
00:19:54,640 --> 00:19:56,000
here

512
00:19:56,000 --> 00:19:57,919
um

513
00:19:57,919 --> 00:20:00,799
so for the bss segment it's actually

514
00:20:00,799 --> 00:20:02,880
zeroed out on boots

515
00:20:02,880 --> 00:20:05,520
by the an equal score function called rc

516
00:20:05,520 --> 00:20:06,799
row bss

517
00:20:06,799 --> 00:20:09,360
and for our target architecture it's

518
00:20:09,360 --> 00:20:11,679
defined in pure mips assembly in

519
00:20:11,679 --> 00:20:14,559
vectors.s

520
00:20:14,559 --> 00:20:16,320
but was the most important bits of

521
00:20:16,320 --> 00:20:18,480
information from the assembly are that

522
00:20:18,480 --> 00:20:19,600
the code

523
00:20:19,600 --> 00:20:21,520
loads the start address of the bss

524
00:20:21,520 --> 00:20:24,640
segment into register a0 and the end

525
00:20:24,640 --> 00:20:27,360
address of the bss segment into register

526
00:20:27,360 --> 00:20:29,918
a1

527
00:20:30,320 --> 00:20:33,200
and on top of that also bss is always

528
00:20:33,200 --> 00:20:35,600
located at the same offset

529
00:20:35,600 --> 00:20:37,679
for all of broadcom firmware images

530
00:20:37,679 --> 00:20:40,480
regardless of vendors be it technical or

531
00:20:40,480 --> 00:20:42,559
netgear as key

532
00:20:42,559 --> 00:20:44,480
they're always located at the same

533
00:20:44,480 --> 00:20:47,440
offset so we can

534
00:20:47,440 --> 00:20:49,679
given an arbitrary firmware file we can

535
00:20:49,679 --> 00:20:51,600
disassemble the function at that offset

536
00:20:51,600 --> 00:20:54,480
to obtain bss start and bss end

537
00:20:54,480 --> 00:20:57,919
and this is an example from a netgear

538
00:20:57,919 --> 00:21:00,480
firmware where we can see that

539
00:21:00,480 --> 00:21:05,360
bss starts at uh 81 61 68 c8 and bss end

540
00:21:05,360 --> 00:21:09,120
at 81 b5 2570

541
00:21:09,120 --> 00:21:10,720
um

542
00:21:10,720 --> 00:21:13,440
now for the stack location uh the

543
00:21:13,440 --> 00:21:15,280
console prompt allows you to print all

544
00:21:15,280 --> 00:21:17,919
the training tasks by typing task show

545
00:21:17,919 --> 00:21:21,039
and if you order them by task id you

546
00:21:21,039 --> 00:21:23,440
will find that tstartup is always the

547
00:21:23,440 --> 00:21:25,039
first thread

548
00:21:25,039 --> 00:21:26,159
to

549
00:21:26,159 --> 00:21:28,080
be launched

550
00:21:28,080 --> 00:21:30,559
once the device is booted that's where

551
00:21:30,559 --> 00:21:32,960
it is

552
00:21:33,280 --> 00:21:36,000
therefore that specific threads stack

553
00:21:36,000 --> 00:21:37,760
based address will be the whole system

554
00:21:37,760 --> 00:21:40,879
stacks base address

555
00:21:41,200 --> 00:21:44,400
and so tasks are launched on ecos using

556
00:21:44,400 --> 00:21:46,480
a standard function called seek thread

557
00:21:46,480 --> 00:21:50,000
create and we here we can see uh the t

558
00:21:50,000 --> 00:21:51,919
startup thread being launched in

559
00:21:51,919 --> 00:21:53,200
assembly

560
00:21:53,200 --> 00:21:56,400
uh and this uh thick sig thread create

561
00:21:56,400 --> 00:21:58,960
function expects eight parameters two of

562
00:21:58,960 --> 00:22:01,120
them are of interest to us

563
00:22:01,120 --> 00:22:04,159
the thread name and the stack base

564
00:22:04,159 --> 00:22:05,280
address

565
00:22:05,280 --> 00:22:07,600
so knowing all this we can also identify

566
00:22:07,600 --> 00:22:09,280
the stack based address for any given

567
00:22:09,280 --> 00:22:12,159
firmware by finding the t startup string

568
00:22:12,159 --> 00:22:14,720
doing a cross reference of that string

569
00:22:14,720 --> 00:22:17,200
where it's used as a parameter to seek

570
00:22:17,200 --> 00:22:19,840
thread create and then extract the stack

571
00:22:19,840 --> 00:22:23,520
base parameter from that call

572
00:22:23,520 --> 00:22:26,000
finding the eep start address was way

573
00:22:26,000 --> 00:22:27,840
easier it always starts immediately

574
00:22:27,840 --> 00:22:31,280
after the bss segment so done

575
00:22:31,280 --> 00:22:33,840
and all of this can be implemented with

576
00:22:33,840 --> 00:22:35,760
a dumb pattern matching code that does

577
00:22:35,760 --> 00:22:38,320
not even disassemble the firmware code

578
00:22:38,320 --> 00:22:40,080
this code is open source available on

579
00:22:40,080 --> 00:22:43,520
github and you will get the whole um

580
00:22:43,520 --> 00:22:45,360
memory map

581
00:22:45,360 --> 00:22:47,440
and if we put everything together this

582
00:22:47,440 --> 00:22:49,600
is what the front time memory of an

583
00:22:49,600 --> 00:22:52,480
ecosystem looks like on mips

584
00:22:52,480 --> 00:22:55,200
so you have the um vectors interrupt

585
00:22:55,200 --> 00:22:58,240
anglers at uh the lowest addresses then

586
00:22:58,240 --> 00:23:00,640
your executable code at the text segment

587
00:23:00,640 --> 00:23:03,200
your data segment the bss where the

588
00:23:03,200 --> 00:23:06,000
stack is located and then your heap

589
00:23:06,000 --> 00:23:08,000
the stack grows upwards and the heap

590
00:23:08,000 --> 00:23:10,000
grows downwards

591
00:23:10,000 --> 00:23:12,000
um one thing to note is that all of

592
00:23:12,000 --> 00:23:14,480
these membrane regions are freeze right

593
00:23:14,480 --> 00:23:17,280
executes there's no permissions flags

594
00:23:17,280 --> 00:23:19,600
on memory pages there's no execute bits

595
00:23:19,600 --> 00:23:20,799
there's no

596
00:23:20,799 --> 00:23:23,120
buy there's no slr it's a flight

597
00:23:23,120 --> 00:23:25,600
anywhere from anything uh type of system

598
00:23:25,600 --> 00:23:26,720
which is good

599
00:23:26,720 --> 00:23:29,600
i mean to us

600
00:23:29,679 --> 00:23:32,559
so going back to our memory map offsets

601
00:23:32,559 --> 00:23:34,240
we can now use them to get an even

602
00:23:34,240 --> 00:23:36,960
better picture of our system in gitra

603
00:23:36,960 --> 00:23:39,120
you could even alt the system take a

604
00:23:39,120 --> 00:23:41,760
full snapshot and analyze that snapshot

605
00:23:41,760 --> 00:23:43,440
in gateway

606
00:23:43,440 --> 00:23:46,080
with all these offsets

607
00:23:46,080 --> 00:23:47,120
right

608
00:23:47,120 --> 00:23:49,200
so now that we have everything we need

609
00:23:49,200 --> 00:23:51,840
let's find bugs

610
00:23:51,919 --> 00:23:54,400
so outside of logical bugs the most

611
00:23:54,400 --> 00:23:56,159
interesting books from an offensive

612
00:23:56,159 --> 00:23:57,919
security perspective are memory

613
00:23:57,919 --> 00:23:59,200
corruptions

614
00:23:59,200 --> 00:24:01,279
arbitrary command injection

615
00:24:01,279 --> 00:24:04,640
injections do not exist on ecos given

616
00:24:04,640 --> 00:24:06,559
that it does not implement like

617
00:24:06,559 --> 00:24:09,200
subprocess course apis like system exec

618
00:24:09,200 --> 00:24:11,360
ve or p open

619
00:24:11,360 --> 00:24:14,000
so let's start by covering a few memory

620
00:24:14,000 --> 00:24:16,720
corruption books i found

621
00:24:16,720 --> 00:24:19,760
i hope it's readable um so this is the

622
00:24:19,760 --> 00:24:22,640
first one i found on the netgear devices

623
00:24:22,640 --> 00:24:24,880
here it's a classic call to store copy

624
00:24:24,880 --> 00:24:26,080
to copy

625
00:24:26,080 --> 00:24:28,880
untrusted user input into a fixed size

626
00:24:28,880 --> 00:24:31,440
buffer on the stack

627
00:24:31,440 --> 00:24:35,039
it's part of the parental control

628
00:24:35,039 --> 00:24:38,240
page of the web administration interface

629
00:24:38,240 --> 00:24:41,919
this is uh how it can be triggered

630
00:24:41,919 --> 00:24:43,919
so you send a bunch of a's as part of

631
00:24:43,919 --> 00:24:45,919
the text block parameter and it will

632
00:24:45,919 --> 00:24:48,000
overflow

633
00:24:48,000 --> 00:24:49,919
this is another stack overflow this time

634
00:24:49,919 --> 00:24:51,760
targeting the

635
00:24:51,760 --> 00:24:54,720
tcg 300 from asp

636
00:24:54,720 --> 00:24:58,000
another classic called the storycuts

637
00:24:58,000 --> 00:25:00,080
to copy and trusted user input into a

638
00:25:00,080 --> 00:25:02,960
fixed size buffer the error here is that

639
00:25:02,960 --> 00:25:04,559
they

640
00:25:04,559 --> 00:25:06,400
compute the length of untrusted user

641
00:25:06,400 --> 00:25:09,679
input and the length is tainted so like

642
00:25:09,679 --> 00:25:12,240
you have an overflow

643
00:25:12,240 --> 00:25:14,400
double can be triggered with this simple

644
00:25:14,400 --> 00:25:17,200
request uh and in this case the user

645
00:25:17,200 --> 00:25:19,279
needs to be authenticated interestingly

646
00:25:19,279 --> 00:25:22,240
it also affects the parental controls

647
00:25:22,240 --> 00:25:24,559
page even though it's a different vendor

648
00:25:24,559 --> 00:25:27,279
and a different feature like different

649
00:25:27,279 --> 00:25:29,679
implementation

650
00:25:29,679 --> 00:25:33,120
and this one is a heap overflow i won't

651
00:25:33,120 --> 00:25:34,720
cover the full chain but it basically

652
00:25:34,720 --> 00:25:36,880
parses http requests line by line

653
00:25:36,880 --> 00:25:39,039
matching on fixed header

654
00:25:39,039 --> 00:25:42,400
names such as host or content linked

655
00:25:42,400 --> 00:25:44,799
and then performs an unsafe copy of the

656
00:25:44,799 --> 00:25:47,120
header value into a structure allocated

657
00:25:47,120 --> 00:25:48,640
on the heap

658
00:25:48,640 --> 00:25:51,840
and this is the easiest triggers of all

659
00:25:51,840 --> 00:25:53,840
just send a bunch of face as part of the

660
00:25:53,840 --> 00:25:57,840
host editor make the device crash

661
00:25:58,000 --> 00:26:00,559
so all of these bugs will trigger this

662
00:26:00,559 --> 00:26:02,880
kind of message over the serial

663
00:26:02,880 --> 00:26:05,039
connection there is a custom handler

664
00:26:05,039 --> 00:26:06,559
defined for

665
00:26:06,559 --> 00:26:08,960
things like segfaults store load

666
00:26:08,960 --> 00:26:11,440
exceptions breakpoints and it will dump

667
00:26:11,440 --> 00:26:13,120
all the register values the program

668
00:26:13,120 --> 00:26:15,760
contour and the affected threats details

669
00:26:15,760 --> 00:26:18,240
so in our case the return address is now

670
00:26:18,240 --> 00:26:21,679
41 41 14 141 because we sent a bunch of

671
00:26:21,679 --> 00:26:23,039
a's

672
00:26:23,039 --> 00:26:27,200
um given the lack of debugging abilities

673
00:26:27,200 --> 00:26:29,440
on this platform with the exception of

674
00:26:29,440 --> 00:26:32,159
the register dump on segfaults i've just

675
00:26:32,159 --> 00:26:34,720
shown the best strategy is to craft a

676
00:26:34,720 --> 00:26:36,799
very small drop chain

677
00:26:36,799 --> 00:26:39,279
that i would call a stage one that will

678
00:26:39,279 --> 00:26:41,600
fetch or receive a second stage that we

679
00:26:41,600 --> 00:26:44,240
can compile for our target this way we

680
00:26:44,240 --> 00:26:46,400
don't have to debug overly long drop

681
00:26:46,400 --> 00:26:49,120
chains by constantly crashing capturing

682
00:26:49,120 --> 00:26:51,200
output rebooting crashing capturing

683
00:26:51,200 --> 00:26:52,559
output

684
00:26:52,559 --> 00:26:55,600
and we can do everything with a single

685
00:26:55,600 --> 00:26:58,559
um really simple drop chain

686
00:26:58,559 --> 00:27:02,880
so the id is this one it's actually

687
00:27:02,880 --> 00:27:04,559
it's actually from

688
00:27:04,559 --> 00:27:07,200
the exploit method from liao board that

689
00:27:07,200 --> 00:27:09,440
published a cable homed

690
00:27:09,440 --> 00:27:13,520
paper so the isd is that you

691
00:27:13,520 --> 00:27:15,520
take control of the return address you

692
00:27:15,520 --> 00:27:18,000
execute your crop chain the drop chain

693
00:27:18,000 --> 00:27:18,720
will

694
00:27:18,720 --> 00:27:20,960
establish a connection to a remote

695
00:27:20,960 --> 00:27:23,279
server pull the payload write the

696
00:27:23,279 --> 00:27:25,200
payload to memory and jump to that

697
00:27:25,200 --> 00:27:27,840
specific payload but the payload

698
00:27:27,840 --> 00:27:31,039
actually will reuse the same socket file

699
00:27:31,039 --> 00:27:32,480
descriptor so

700
00:27:32,480 --> 00:27:34,960
like your stage 2 delivery will be the

701
00:27:34,960 --> 00:27:36,799
same using the same channel as your

702
00:27:36,799 --> 00:27:40,080
reverse shell it's done by just

703
00:27:40,080 --> 00:27:42,720
saving the file descriptor integer value

704
00:27:42,720 --> 00:27:44,960
to a fixed address in memory in this

705
00:27:44,960 --> 00:27:48,559
case named sock fd underscore addr

706
00:27:48,559 --> 00:27:50,320
and this

707
00:27:50,320 --> 00:27:53,039
value is also known to your payload so

708
00:27:53,039 --> 00:27:55,200
it will just fetch the file descriptor

709
00:27:55,200 --> 00:27:57,120
value and reuse that

710
00:27:57,120 --> 00:27:59,360
socket

711
00:27:59,360 --> 00:28:01,440
the shell code

712
00:28:01,440 --> 00:28:03,679
we actually need to do some reverse

713
00:28:03,679 --> 00:28:06,880
engineering to create a console object

714
00:28:06,880 --> 00:28:08,960
which will be similar to like calling

715
00:28:08,960 --> 00:28:11,679
binsh on linux

716
00:28:11,679 --> 00:28:14,000
because that does not exist like you

717
00:28:14,000 --> 00:28:16,320
don't have default method of doing that

718
00:28:16,320 --> 00:28:19,039
on ecoso we need to reverse how broadcom

719
00:28:19,039 --> 00:28:21,440
did it

720
00:28:21,520 --> 00:28:24,159
right so let's recap the exploitation

721
00:28:24,159 --> 00:28:26,559
phase so we identified different kinds

722
00:28:26,559 --> 00:28:28,559
of memory corruption vulnerabilities we

723
00:28:28,559 --> 00:28:30,880
managed to gain control over the program

724
00:28:30,880 --> 00:28:32,880
counter and designed the airshop chain

725
00:28:32,880 --> 00:28:34,080
to

726
00:28:34,080 --> 00:28:37,440
pull shellcode from a remote server

727
00:28:37,440 --> 00:28:38,559
but

728
00:28:38,559 --> 00:28:41,039
let's do a quick

729
00:28:41,039 --> 00:28:42,399
demo

730
00:28:42,399 --> 00:28:45,360
so

731
00:28:45,360 --> 00:28:48,720
we are on netgear so this is the device

732
00:28:48,720 --> 00:28:50,960
here i'm connecting or connected over

733
00:28:50,960 --> 00:28:53,039
lan they're not emitting any wireless

734
00:28:53,039 --> 00:28:54,399
signal

735
00:28:54,399 --> 00:28:58,080
no need to try exploiting them

736
00:28:58,080 --> 00:29:02,639
so hopefully this should work uh

737
00:29:04,000 --> 00:29:05,039
all right

738
00:29:05,039 --> 00:29:06,159
yeah

739
00:29:06,159 --> 00:29:08,720
um so we got a reverse channel on the

740
00:29:08,720 --> 00:29:13,039
device this is what the menu looks like

741
00:29:13,039 --> 00:29:14,399
yeah

742
00:29:14,399 --> 00:29:15,919
so you have access to a bunch of

743
00:29:15,919 --> 00:29:18,559
features you can uh edit routing uh

744
00:29:18,559 --> 00:29:21,360
floating rules you can access

745
00:29:21,360 --> 00:29:23,919
credentials you can do some monitoring

746
00:29:23,919 --> 00:29:24,840
you can

747
00:29:24,840 --> 00:29:26,399
inject a

748
00:29:26,399 --> 00:29:28,880
custom shell code at runtime because you

749
00:29:28,880 --> 00:29:32,399
have like write and read memory

750
00:29:32,399 --> 00:29:34,480
command options

751
00:29:34,480 --> 00:29:35,360
so

752
00:29:35,360 --> 00:29:37,440
like it's full control of the device

753
00:29:37,440 --> 00:29:39,919
it's similar to getting fruit on any

754
00:29:39,919 --> 00:29:43,279
kind of server

755
00:29:43,760 --> 00:29:46,480
the exploit is public but the payload is

756
00:29:46,480 --> 00:29:49,600
not so you will get like a callback but

757
00:29:49,600 --> 00:29:52,080
that's all

758
00:29:52,480 --> 00:29:56,559
i think that's no

759
00:29:58,799 --> 00:29:59,840
right

760
00:29:59,840 --> 00:30:02,080
okay

761
00:30:04,640 --> 00:30:07,440
okay so speaking of shell code so

762
00:30:07,440 --> 00:30:09,600
shellcode is the art of building binary

763
00:30:09,600 --> 00:30:11,120
code for a custom target that will

764
00:30:11,120 --> 00:30:13,279
execute a specific action

765
00:30:13,279 --> 00:30:15,440
uh usually this is a piece of malicious

766
00:30:15,440 --> 00:30:17,200
code in our case we want this piece of

767
00:30:17,200 --> 00:30:20,480
code to establish a reverse shell 2 or

768
00:30:20,480 --> 00:30:24,080
c2 like i uh demonstrated

769
00:30:24,080 --> 00:30:26,960
so given equals posix apis we have

770
00:30:26,960 --> 00:30:29,039
access to something really close to leap

771
00:30:29,039 --> 00:30:31,200
c so you have access to bind connect

772
00:30:31,200 --> 00:30:33,919
select malloc memcopy

773
00:30:33,919 --> 00:30:36,399
all of these functions that were

774
00:30:36,399 --> 00:30:38,399
actually identified using the function

775
00:30:38,399 --> 00:30:41,520
id database i demonstrated earlier and

776
00:30:41,520 --> 00:30:43,840
we can use that to write custom shell

777
00:30:43,840 --> 00:30:44,720
code

778
00:30:44,720 --> 00:30:47,360
but as i said i we need to reverse the

779
00:30:47,360 --> 00:30:49,679
interactive console implementation if

780
00:30:49,679 --> 00:30:51,840
you remember just there is no syscalls

781
00:30:51,840 --> 00:30:54,559
so no exact ve be nssh that does not

782
00:30:54,559 --> 00:30:56,720
exist there

783
00:30:56,720 --> 00:30:59,200
so we have two ways of building

784
00:30:59,200 --> 00:31:01,440
our own ecoshell codes either manual

785
00:31:01,440 --> 00:31:03,679
function hooking and code fix up it's

786
00:31:03,679 --> 00:31:07,039
the methods used by a liar board

787
00:31:07,039 --> 00:31:09,600
but it's really prone to errors it's

788
00:31:09,600 --> 00:31:11,279
kind of so they're using the same

789
00:31:11,279 --> 00:31:14,320
techniques that you would use to

790
00:31:14,320 --> 00:31:16,960
hook functions using ld preload the

791
00:31:16,960 --> 00:31:18,960
problem is that the shell code is not

792
00:31:18,960 --> 00:31:22,080
location aware so if you have

793
00:31:22,080 --> 00:31:25,279
a jump instructions it tends to jump

794
00:31:25,279 --> 00:31:27,200
somewhere else

795
00:31:27,200 --> 00:31:29,679
so it fails and another technique is

796
00:31:29,679 --> 00:31:32,000
using simply the gcc linker which i

797
00:31:32,000 --> 00:31:34,720
consider the best method

798
00:31:34,720 --> 00:31:37,360
it was inspired by ah research from

799
00:31:37,360 --> 00:31:39,760
someone who turned those cable modems

800
00:31:39,760 --> 00:31:42,000
into fm receivers because we have like

801
00:31:42,000 --> 00:31:43,760
the coaxial cable

802
00:31:43,760 --> 00:31:47,039
coaxial antenna behind

803
00:31:47,039 --> 00:31:51,200
and this is what it looks like

804
00:31:51,440 --> 00:31:53,679
right

805
00:31:53,679 --> 00:31:56,000
so

806
00:31:58,480 --> 00:32:00,880
if it's not readable tell me i will zoom

807
00:32:00,880 --> 00:32:01,840
in

808
00:32:01,840 --> 00:32:05,279
um so this is our make file um we can

809
00:32:05,279 --> 00:32:07,120
build a different kind of shell code we

810
00:32:07,120 --> 00:32:09,120
have bind shell reverse shell

811
00:32:09,120 --> 00:32:10,799
uh whatever

812
00:32:10,799 --> 00:32:11,600
we

813
00:32:11,600 --> 00:32:14,640
select a platform so either a netgear

814
00:32:14,640 --> 00:32:18,480
one or an as key and we are loading a

815
00:32:18,480 --> 00:32:19,679
specific

816
00:32:19,679 --> 00:32:23,919
linker definition for that platform

817
00:32:23,919 --> 00:32:26,000
the linker definition is simply this so

818
00:32:26,000 --> 00:32:28,320
you provide all the addresses of the

819
00:32:28,320 --> 00:32:30,880
functions we you want to use in your

820
00:32:30,880 --> 00:32:33,360
shell code and they will be linked by

821
00:32:33,360 --> 00:32:37,200
gcc when you compile the shell code

822
00:32:37,200 --> 00:32:38,640
and of course

823
00:32:38,640 --> 00:32:40,480
so

824
00:32:40,480 --> 00:32:42,799
let's say you will map your shell code

825
00:32:42,799 --> 00:32:45,760
at a specific memory offset you need to

826
00:32:45,760 --> 00:32:49,039
provide it there so all the call like

827
00:32:49,039 --> 00:32:50,799
the jump calls will be

828
00:32:50,799 --> 00:32:54,559
computed based on based on that

829
00:32:55,120 --> 00:32:56,399
and this is

830
00:32:56,399 --> 00:32:57,679
what the

831
00:32:57,679 --> 00:33:00,399
reversal implementation looks like

832
00:33:00,399 --> 00:33:02,640
um it's quite simple

833
00:33:02,640 --> 00:33:05,679
like the usual you open a socket you

834
00:33:05,679 --> 00:33:07,039
connect to it

835
00:33:07,039 --> 00:33:09,120
you allocate a buffer and what's really

836
00:33:09,120 --> 00:33:11,519
interested is the pro com implementation

837
00:33:11,519 --> 00:33:13,360
for the console

838
00:33:13,360 --> 00:33:17,200
so you get a singleton

839
00:33:17,200 --> 00:33:18,080
um

840
00:33:18,080 --> 00:33:19,919
this is used to

841
00:33:19,919 --> 00:33:22,480
like those three lines for from 4c7 to

842
00:33:22,480 --> 00:33:25,600
49 is to redirect io to the file

843
00:33:25,600 --> 00:33:30,320
descriptor that is linked to your socket

844
00:33:30,880 --> 00:33:33,440
and then you set so you receive a

845
00:33:33,440 --> 00:33:36,640
command from the c2 you assign it to the

846
00:33:36,640 --> 00:33:38,880
singleton and then use

847
00:33:38,880 --> 00:33:40,799
provide that singleton as protcom

848
00:33:40,799 --> 00:33:43,519
console execute current command

849
00:33:43,519 --> 00:33:46,080
and it will execute it that's how

850
00:33:46,080 --> 00:33:46,799
the

851
00:33:46,799 --> 00:33:48,399
reversal

852
00:33:48,399 --> 00:33:51,200
here is working

853
00:33:51,200 --> 00:33:55,519
uh and in a nice final touch is the exit

854
00:33:55,519 --> 00:33:58,399
call where it will reassign the

855
00:33:58,399 --> 00:34:01,919
i o to the original handler so for

856
00:34:01,919 --> 00:34:03,760
example if you're connected over serial

857
00:34:03,760 --> 00:34:06,480
or telnet when you get a free version on

858
00:34:06,480 --> 00:34:08,719
it you can't type any more on telnet or

859
00:34:08,719 --> 00:34:11,359
serial so you need to reassign the i o

860
00:34:11,359 --> 00:34:14,960
to that specific handler

861
00:34:15,119 --> 00:34:17,679
all right

862
00:34:17,918 --> 00:34:21,359
and another example is this one which is

863
00:34:21,359 --> 00:34:24,159
a bit more complex because i'm actually

864
00:34:24,159 --> 00:34:26,480
using threads

865
00:34:26,480 --> 00:34:30,639
so i'm using the ecos api to create like

866
00:34:30,639 --> 00:34:32,839
a stack for all

867
00:34:32,839 --> 00:34:36,000
threads i'm creating it and i'm

868
00:34:36,000 --> 00:34:37,280
launching it

869
00:34:37,280 --> 00:34:39,839
and basically like

870
00:34:39,839 --> 00:34:42,399
the threads will run this function with

871
00:34:42,399 --> 00:34:44,960
which is exactly the same one as i uh

872
00:34:44,960 --> 00:34:47,440
shown just uh just before

873
00:34:47,440 --> 00:34:50,159
um there were some

874
00:34:50,159 --> 00:34:52,719
difficulties in writing this like

875
00:34:52,719 --> 00:34:55,199
given that you are compiling static

876
00:34:55,199 --> 00:34:58,000
shell codes you can't allocate on some

877
00:34:58,000 --> 00:35:00,720
large memory in a data segment for

878
00:35:00,720 --> 00:35:04,000
example so i had to reuse the heap so

879
00:35:04,000 --> 00:35:04,800
it's

880
00:35:04,800 --> 00:35:06,640
quite complex but it's an interesting

881
00:35:06,640 --> 00:35:11,279
treat if you want to look into it

882
00:35:11,440 --> 00:35:15,440
right so persistence so we have a

883
00:35:15,440 --> 00:35:16,720
reversal

884
00:35:16,720 --> 00:35:19,119
access on those devices

885
00:35:19,119 --> 00:35:20,960
and we want to gain long-term

886
00:35:20,960 --> 00:35:23,920
persistence so either via a fruit kit a

887
00:35:23,920 --> 00:35:26,640
former implant or boot kit a bootloader

888
00:35:26,640 --> 00:35:28,079
implant

889
00:35:28,079 --> 00:35:30,720
let's see how we can do that so there is

890
00:35:30,720 --> 00:35:32,960
no secure boot implementations uh there

891
00:35:32,960 --> 00:35:35,280
is no signature checking as long as the

892
00:35:35,280 --> 00:35:38,000
uh crc off or firmware matches the

893
00:35:38,000 --> 00:35:39,920
platform will run it

894
00:35:39,920 --> 00:35:42,000
and of course there are built-in

895
00:35:42,000 --> 00:35:43,839
commands to update the firmware image

896
00:35:43,839 --> 00:35:46,000
over tftp

897
00:35:46,000 --> 00:35:48,480
so there are those

898
00:35:48,480 --> 00:35:50,400
two commands

899
00:35:50,400 --> 00:35:52,560
that are doing the exact same thing

900
00:35:52,560 --> 00:35:54,720
download and save the firmware to flash

901
00:35:54,720 --> 00:35:56,640
it's just that they take different path

902
00:35:56,640 --> 00:35:59,520
so ipl will run over the lan and docsis

903
00:35:59,520 --> 00:36:02,560
ctl will go over the cmts network over

904
00:36:02,560 --> 00:36:06,160
the coaxial connection

905
00:36:06,720 --> 00:36:08,960
so the idea to

906
00:36:08,960 --> 00:36:11,119
create an implant is to identify a

907
00:36:11,119 --> 00:36:13,200
function that is not required for a

908
00:36:13,200 --> 00:36:15,280
normal operation

909
00:36:15,280 --> 00:36:17,760
in my case so you need to find a

910
00:36:17,760 --> 00:36:20,079
function that is called on boot and that

911
00:36:20,079 --> 00:36:22,400
will launch a thread so we need to find

912
00:36:22,400 --> 00:36:24,640
a thread that is not

913
00:36:24,640 --> 00:36:26,720
necessary for the device normal

914
00:36:26,720 --> 00:36:29,839
operation in my case i'm using an ipsec

915
00:36:29,839 --> 00:36:32,400
handler because well it's there it's

916
00:36:32,400 --> 00:36:34,720
part of proton packages but they're not

917
00:36:34,720 --> 00:36:37,280
used by those

918
00:36:37,280 --> 00:36:38,839
isp

919
00:36:38,839 --> 00:36:42,240
devices so you'll find that function you

920
00:36:42,240 --> 00:36:44,160
find the start of sets and the end

921
00:36:44,160 --> 00:36:46,560
offsets you create a shell code and you

922
00:36:46,560 --> 00:36:49,760
just overwrite that segment within your

923
00:36:49,760 --> 00:36:52,400
firmware then you free packets into a

924
00:36:52,400 --> 00:36:54,800
program store file

925
00:36:54,800 --> 00:37:00,079
and you can just have your implant saved

926
00:37:00,079 --> 00:37:01,440
for bootkit

927
00:37:01,440 --> 00:37:03,520
it's the same thing no secure boot

928
00:37:03,520 --> 00:37:06,000
implementation or signature checking

929
00:37:06,000 --> 00:37:08,160
the platform will run any bootloader

930
00:37:08,160 --> 00:37:10,079
freely and again building commands to

931
00:37:10,079 --> 00:37:12,480
update the bootloader over tftp

932
00:37:12,480 --> 00:37:14,640
same thing than before

933
00:37:14,640 --> 00:37:17,119
so backdooring the bootloader is totally

934
00:37:17,119 --> 00:37:19,359
doable i did some demonstration just

935
00:37:19,359 --> 00:37:20,640
printing out

936
00:37:20,640 --> 00:37:23,040
some custom strings

937
00:37:23,040 --> 00:37:26,640
the ideal boot kit would be a bootloader

938
00:37:26,640 --> 00:37:28,720
that injects custom code into the

939
00:37:28,720 --> 00:37:31,119
firmware images before booting it which

940
00:37:31,119 --> 00:37:32,640
would mean like shell access for the

941
00:37:32,640 --> 00:37:34,480
next 10 years because firmwares can

942
00:37:34,480 --> 00:37:36,960
still be uploaded if something something

943
00:37:36,960 --> 00:37:39,920
is detected

944
00:37:40,000 --> 00:37:44,320
but i didn't go as far as that however

945
00:37:44,320 --> 00:37:48,400
i have a demonstration for persistence

946
00:37:48,400 --> 00:37:51,400
so

947
00:37:51,760 --> 00:37:53,839
let's open a

948
00:37:53,839 --> 00:37:57,839
serial connection to our device

949
00:37:57,839 --> 00:38:02,279
and let's reboot it

950
00:38:06,079 --> 00:38:07,119
okay

951
00:38:07,119 --> 00:38:08,000
um

952
00:38:08,000 --> 00:38:11,040
so this is the um so we have two

953
00:38:11,040 --> 00:38:13,119
firmware uh there's image one and image

954
00:38:13,119 --> 00:38:15,680
two in image two you see that it's

955
00:38:15,680 --> 00:38:18,640
actually called uh implant.oh which is

956
00:38:18,640 --> 00:38:20,079
the implanted

957
00:38:20,079 --> 00:38:22,240
firmware

958
00:38:22,240 --> 00:38:23,680
i'm just

959
00:38:23,680 --> 00:38:26,320
hitting enter we don't care about those

960
00:38:26,320 --> 00:38:28,800
so we will boot from flash and select

961
00:38:28,800 --> 00:38:32,680
the second image

962
00:38:33,200 --> 00:38:35,598
okay

963
00:38:36,720 --> 00:38:38,880
so we'll let it boot we see that it's

964
00:38:38,880 --> 00:38:42,000
loading image two

965
00:38:44,160 --> 00:38:46,240
it's actually printed out the debug

966
00:38:46,240 --> 00:38:49,520
output of like launching a bind uh list

967
00:38:49,520 --> 00:38:52,320
a bunch of listener but it's usually too

968
00:38:52,320 --> 00:38:55,920
fast to see it so we'll see

969
00:38:56,240 --> 00:38:58,000
launching the ap

970
00:38:58,000 --> 00:39:00,240
access point

971
00:39:00,240 --> 00:39:02,959
just waiting

972
00:39:06,960 --> 00:39:09,440
all right so

973
00:39:09,440 --> 00:39:10,320
let's

974
00:39:10,320 --> 00:39:12,640
demonstrate that so

975
00:39:12,640 --> 00:39:15,680
we are connected over lan

976
00:39:15,680 --> 00:39:17,119
we should

977
00:39:17,119 --> 00:39:19,200
be able to reach it

978
00:39:19,200 --> 00:39:20,160
yeah

979
00:39:20,160 --> 00:39:24,200
so if i do this

980
00:39:29,599 --> 00:39:31,200
we have a

981
00:39:31,200 --> 00:39:34,079
buying shell on the device because the

982
00:39:34,079 --> 00:39:37,119
firmware is uh has a specific shell code

983
00:39:37,119 --> 00:39:39,760
implant in it which can't be

984
00:39:39,760 --> 00:39:40,800
detected

985
00:39:40,800 --> 00:39:42,480
right now

986
00:39:42,480 --> 00:39:44,400
that's it

987
00:39:44,400 --> 00:39:46,480
let's get back

988
00:39:46,480 --> 00:39:47,359
so

989
00:39:47,359 --> 00:39:49,200
let's go over some recommendations

990
00:39:49,200 --> 00:39:51,839
before we close this session

991
00:39:51,839 --> 00:39:54,400
for isp customers

992
00:39:54,400 --> 00:39:56,320
they should disable guest wi-fi they

993
00:39:56,320 --> 00:39:58,720
should use non-default settings for psk

994
00:39:58,720 --> 00:40:02,000
psk and ssids uh this is based on

995
00:40:02,000 --> 00:40:04,960
existing research i did on netgear and

996
00:40:04,960 --> 00:40:06,000
asq

997
00:40:06,000 --> 00:40:07,599
like the

998
00:40:07,599 --> 00:40:10,960
eap overflow is exploitable uh from by

999
00:40:10,960 --> 00:40:12,960
an authenticated user connected to your

1000
00:40:12,960 --> 00:40:15,920
guest wi-fi so just disable it

1001
00:40:15,920 --> 00:40:20,000
um default psk and ssids are derivable

1002
00:40:20,000 --> 00:40:21,839
or can be used as oracle when you

1003
00:40:21,839 --> 00:40:24,720
exploit those netgear devices so please

1004
00:40:24,720 --> 00:40:27,839
do this if you are using those devices

1005
00:40:27,839 --> 00:40:30,480
for isps um i think they should do

1006
00:40:30,480 --> 00:40:32,240
complete and in-depth pen test of

1007
00:40:32,240 --> 00:40:34,480
devices they deploy the cost of breach

1008
00:40:34,480 --> 00:40:37,200
or large large-scale exploitation is way

1009
00:40:37,200 --> 00:40:40,560
higher than the cost of such a test

1010
00:40:40,560 --> 00:40:43,040
as a measure the vulnerabilities i

1011
00:40:43,040 --> 00:40:45,760
identified if who in vu

1012
00:40:45,760 --> 00:40:46,480
took

1013
00:40:46,480 --> 00:40:48,960
nine months of dedicated effort by the

1014
00:40:48,960 --> 00:40:51,200
security team to deploy configuration

1015
00:40:51,200 --> 00:40:52,960
changes

1016
00:40:52,960 --> 00:40:55,599
and some of them hurt their help desk

1017
00:40:55,599 --> 00:40:57,920
really badly

1018
00:40:57,920 --> 00:41:00,160
and isps should also take into

1019
00:41:00,160 --> 00:41:02,720
consideration consideration the support

1020
00:41:02,720 --> 00:41:06,000
provided by the device manufacturers

1021
00:41:06,000 --> 00:41:07,920
is the device will the device still be

1022
00:41:07,920 --> 00:41:10,240
deployed when it reaches end of life

1023
00:41:10,240 --> 00:41:11,920
what happens if a block is found and

1024
00:41:11,920 --> 00:41:14,319
can't be fixed in code which is the case

1025
00:41:14,319 --> 00:41:17,920
in those two devices

1026
00:41:18,400 --> 00:41:19,280
for

1027
00:41:19,280 --> 00:41:22,319
manufacturers like netgear or ask i

1028
00:41:22,319 --> 00:41:23,920
think they should disable the crash

1029
00:41:23,920 --> 00:41:26,160
handler so that exploits writers are

1030
00:41:26,160 --> 00:41:27,119
blind

1031
00:41:27,119 --> 00:41:29,760
uh it's pretty much writing getting back

1032
00:41:29,760 --> 00:41:31,760
to writing clock chains on pen and paper

1033
00:41:31,760 --> 00:41:34,800
which is a pain in the ass do source

1034
00:41:34,800 --> 00:41:36,560
course reviews

1035
00:41:36,560 --> 00:41:38,960
scsts are cheap now

1036
00:41:38,960 --> 00:41:40,960
use strong default speed for passwords

1037
00:41:40,960 --> 00:41:43,280
protocols ciphers

1038
00:41:43,280 --> 00:41:45,359
provide long term support

1039
00:41:45,359 --> 00:41:47,680
or at least be explicit in your

1040
00:41:47,680 --> 00:41:50,000
construction agreements

1041
00:41:50,000 --> 00:41:53,280
maybe sign your firmware

1042
00:41:53,280 --> 00:41:55,599
cryptographically even though i'm sure

1043
00:41:55,599 --> 00:41:58,800
it will never happened on this platform

1044
00:41:58,800 --> 00:42:01,520
for broadcom source code review again

1045
00:42:01,520 --> 00:42:02,640
please do it

1046
00:42:02,640 --> 00:42:05,680
um hard on your ip manager it's just a

1047
00:42:05,680 --> 00:42:07,680
joke at this point it's look like it's

1048
00:42:07,680 --> 00:42:10,880
been threatened by an undergrad

1049
00:42:10,880 --> 00:42:13,119
maybe looking to secure boots i know

1050
00:42:13,119 --> 00:42:15,520
they're looking into it for more recent

1051
00:42:15,520 --> 00:42:20,160
rtos they're working on like zephyr

1052
00:42:20,160 --> 00:42:22,480
and for future work i would like to look

1053
00:42:22,480 --> 00:42:25,119
at other well i'm looking at other ecos

1054
00:42:25,119 --> 00:42:27,520
implementations uh things like ot

1055
00:42:27,520 --> 00:42:31,839
devices and plcs from moxa zeixo

1056
00:42:31,839 --> 00:42:34,640
or switches from other switches

1057
00:42:34,640 --> 00:42:36,800
from netgear

1058
00:42:36,800 --> 00:42:39,599
i would like also this was an initially

1059
00:42:39,599 --> 00:42:41,359
thought to be published today but i'm

1060
00:42:41,359 --> 00:42:44,319
not there yet it's to build a gdp stub

1061
00:42:44,319 --> 00:42:46,640
for the cable modem that is injectable

1062
00:42:46,640 --> 00:42:47,920
at runtime

1063
00:42:47,920 --> 00:42:50,240
um i know it's doable that's why i

1064
00:42:50,240 --> 00:42:52,079
reversed the interrupt and exception

1065
00:42:52,079 --> 00:42:55,520
vectors on ecos but i'm not there yet

1066
00:42:55,520 --> 00:42:58,160
there is a lot of engineering effort

1067
00:42:58,160 --> 00:43:00,880
that needs to be put into it

1068
00:43:00,880 --> 00:43:03,040
you're already here if you're interested

1069
00:43:03,040 --> 00:43:05,040
in ecos

1070
00:43:05,040 --> 00:43:07,040
all the tools i demonstrated are open

1071
00:43:07,040 --> 00:43:08,640
source so

1072
00:43:08,640 --> 00:43:11,520
reverse engineering tools git reloaders

1073
00:43:11,520 --> 00:43:13,760
uh the shellcode generator

1074
00:43:13,760 --> 00:43:16,400
exploits that are defunct for some of

1075
00:43:16,400 --> 00:43:17,280
them

1076
00:43:17,280 --> 00:43:20,400
a bunch of references but all of the the

1077
00:43:20,400 --> 00:43:23,760
complete list like with uh hence of

1078
00:43:23,760 --> 00:43:27,119
references are on ecos.wtf

1079
00:43:27,119 --> 00:43:30,400
i will now thank you for your attention

1080
00:43:30,400 --> 00:43:33,440
and we can move to q a

1081
00:43:33,440 --> 00:43:36,440
thanks

1082
00:43:37,110 --> 00:43:42,579
[Applause]

1083
00:43:47,520 --> 00:43:50,520
this

1084
00:43:58,240 --> 00:43:59,520
thank you

1085
00:43:59,520 --> 00:44:00,880
uh okay so

1086
00:44:00,880 --> 00:44:03,440
i'm i'm mainly excited about the end

1087
00:44:03,440 --> 00:44:05,599
when you mention the future work

1088
00:44:05,599 --> 00:44:08,000
are you already familiar with some otics

1089
00:44:08,000 --> 00:44:10,480
implementations for for ecos i'm just

1090
00:44:10,480 --> 00:44:12,480
curious to know more about that and what

1091
00:44:12,480 --> 00:44:14,000
directions

1092
00:44:14,000 --> 00:44:15,760
you have two main vendors that are using

1093
00:44:15,760 --> 00:44:17,839
equals for plcs

1094
00:44:17,839 --> 00:44:18,720
or

1095
00:44:18,720 --> 00:44:20,000
for example

1096
00:44:20,000 --> 00:44:22,450
ethernet to modbus um

1097
00:44:22,450 --> 00:44:23,520
[Music]

1098
00:44:23,520 --> 00:44:25,440
translators um

1099
00:44:25,440 --> 00:44:28,560
it's zeixel and moxa

1100
00:44:28,560 --> 00:44:30,480
they're quite different from those

1101
00:44:30,480 --> 00:44:32,319
devices because they're using arm and

1102
00:44:32,319 --> 00:44:34,079
not not mips

1103
00:44:34,079 --> 00:44:36,400
but you can apply the same thing like

1104
00:44:36,400 --> 00:44:38,000
getting access to the source code

1105
00:44:38,000 --> 00:44:39,920
building function id databases doing the

1106
00:44:39,920 --> 00:44:42,640
reverse engineering work filing flows

1107
00:44:42,640 --> 00:44:43,680
um

1108
00:44:43,680 --> 00:44:44,480
so

1109
00:44:44,480 --> 00:44:46,400
those are the two

1110
00:44:46,400 --> 00:44:48,240
vendors i'm looking into at the moment

1111
00:44:48,240 --> 00:44:50,640
and the other is netgear but it's

1112
00:44:50,640 --> 00:44:53,200
basically just dumb switches

1113
00:44:53,200 --> 00:44:54,480
that are not

1114
00:44:54,480 --> 00:44:59,119
perfectly related to plc's or ot devices

1115
00:44:59,119 --> 00:45:01,090
all right thank you

1116
00:45:01,090 --> 00:45:07,599
[Applause]

1117
00:45:07,599 --> 00:45:09,680
you

