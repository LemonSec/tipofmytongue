1
00:00:06,540 --> 00:00:10,420
okay good morning everyone thank you for

2
00:00:09,670 --> 00:00:12,910
the introduction

3
00:00:10,420 --> 00:00:16,119
so I've checked and this is already the

4
00:00:12,910 --> 00:00:18,009
for time I'm speaking at Brooklyn so

5
00:00:16,119 --> 00:00:22,030
it's great to be here again I hope

6
00:00:18,010 --> 00:00:24,340
you'll enjoy the talk so today I'm going

7
00:00:22,030 --> 00:00:27,310
to present some work with it on WPA

8
00:00:24,340 --> 00:00:30,880
three and I did this together with Al

9
00:00:27,310 --> 00:00:34,329
Ronan but today I'm here to present it

10
00:00:30,880 --> 00:00:37,530
so let's start first with a quick

11
00:00:34,329 --> 00:00:41,440
introduction I'm talking here about

12
00:00:37,530 --> 00:00:44,109
dragonfly handshake of WPA three well

13
00:00:41,440 --> 00:00:47,318
actually before I get into the details I

14
00:00:44,109 --> 00:00:49,420
have one other thing to mention and this

15
00:00:47,319 --> 00:00:52,690
is that this work was also presented at

16
00:00:49,420 --> 00:00:53,350
blackhat where it was nice enough that

17
00:00:52,690 --> 00:00:55,568
we won

18
00:00:53,350 --> 00:00:57,850
boney Awards for the work that we did

19
00:00:55,569 --> 00:01:00,749
here for the best cryptographic attack

20
00:00:57,850 --> 00:01:03,309
and I think there are two main reasons

21
00:01:00,749 --> 00:01:06,040
why we were lucky enough to get this

22
00:01:03,309 --> 00:01:08,470
award the first is because in this work

23
00:01:06,040 --> 00:01:11,200
we cover various attacks against

24
00:01:08,470 --> 00:01:15,039
cryptographic protocols so it's also a

25
00:01:11,200 --> 00:01:17,170
good overview to know what all the

26
00:01:15,040 --> 00:01:20,950
possible things that can go wrong when

27
00:01:17,170 --> 00:01:22,930
you implement a crypto protocol are the

28
00:01:20,950 --> 00:01:26,110
second thing is that this research also

29
00:01:22,930 --> 00:01:28,390
has an interesting story because the

30
00:01:26,110 --> 00:01:31,060
designers of wp3 they were actually

31
00:01:28,390 --> 00:01:32,890
warned about some weaknesses but somehow

32
00:01:31,060 --> 00:01:35,890
it made it into the WPA three

33
00:01:32,890 --> 00:01:37,690
specification anyway I think those are

34
00:01:35,890 --> 00:01:41,350
two reasons that contributed to this

35
00:01:37,690 --> 00:01:43,840
nice award but let's get back to our

36
00:01:41,350 --> 00:01:48,250
story here I wanted to introduce the

37
00:01:43,840 --> 00:01:50,380
dragonfly handshake of WPA three and the

38
00:01:48,250 --> 00:01:52,560
dragonfly handshake is a handshake that

39
00:01:50,380 --> 00:01:56,860
already existed for a while in fact

40
00:01:52,560 --> 00:02:01,060
because it's also used in the EPW deme

41
00:01:56,860 --> 00:02:04,120
protocol now what is the EPW D protocol

42
00:02:01,060 --> 00:02:07,180
well this is a protocol that is also

43
00:02:04,120 --> 00:02:10,060
used in enterprise Wi-Fi networks to

44
00:02:07,180 --> 00:02:13,840
authenticate users for example and about

45
00:02:10,060 --> 00:02:16,390
I would say 5% of error on networks on a

46
00:02:13,840 --> 00:02:18,740
small percentage of

47
00:02:16,390 --> 00:02:20,359
also maybe company networks where you

48
00:02:18,740 --> 00:02:23,660
have to login using a username on a

49
00:02:20,360 --> 00:02:28,460
password and about 5% of those the epp

50
00:02:23,660 --> 00:02:30,470
WD protocol is used on this dragonfly

51
00:02:28,460 --> 00:02:34,520
handshake that is used internally on

52
00:02:30,470 --> 00:02:38,090
both ewd and WPA 3 we call it a pig a

53
00:02:34,520 --> 00:02:41,120
password authenticated key exchange now

54
00:02:38,090 --> 00:02:43,850
what does that mean well what that means

55
00:02:41,120 --> 00:02:46,010
is that this handshake provides mutual

56
00:02:43,850 --> 00:02:47,989
authentication the client has to prove

57
00:02:46,010 --> 00:02:49,579
that it knows the password on the access

58
00:02:47,990 --> 00:02:51,920
point also has to prove that it knows

59
00:02:49,580 --> 00:02:53,390
the password in other words with this

60
00:02:51,920 --> 00:02:57,589
handshake you're also sure that you're

61
00:02:53,390 --> 00:02:59,690
not connecting to a rogue network at the

62
00:02:57,590 --> 00:03:02,240
same time this handshake also negotiates

63
00:02:59,690 --> 00:03:04,640
a fresh session key on this session key

64
00:03:02,240 --> 00:03:09,170
will be used after the handshake to

65
00:03:04,640 --> 00:03:11,779
secure your normal data traffic and the

66
00:03:09,170 --> 00:03:14,000
most important property of the dragonfly

67
00:03:11,780 --> 00:03:17,270
handshake is that it also prevents

68
00:03:14,000 --> 00:03:20,240
forward secrecy honored defense against

69
00:03:17,270 --> 00:03:24,200
dictionary attacks what does that mean

70
00:03:20,240 --> 00:03:27,200
well as you may already know with wpa2

71
00:03:24,200 --> 00:03:29,839
an attacker can simply passively monitor

72
00:03:27,200 --> 00:03:32,000
or sniff the handshake and he can then

73
00:03:29,840 --> 00:03:34,100
take that handshake offline and perform

74
00:03:32,000 --> 00:03:36,470
dictionary on brute-force attacks

75
00:03:34,100 --> 00:03:39,230
against this captured handshake on a

76
00:03:36,470 --> 00:03:42,770
laptop or on GPUs and very efficiently

77
00:03:39,230 --> 00:03:44,209
try to crack the password but with wp3

78
00:03:42,770 --> 00:03:47,390
that is no longer possible

79
00:03:44,209 --> 00:03:49,760
if you passively capture a wp3 handshake

80
00:03:47,390 --> 00:03:51,589
you cannot take that handshake offline

81
00:03:49,760 --> 00:03:55,190
and then try to do dictionary or brute

82
00:03:51,590 --> 00:03:58,100
force attacks against it and forward

83
00:03:55,190 --> 00:04:00,440
secrecy means that if you capture some

84
00:03:58,100 --> 00:04:02,120
network traffic now on a year later I

85
00:04:00,440 --> 00:04:04,600
learned learn the password of the

86
00:04:02,120 --> 00:04:07,040
network I cannot go back in time and

87
00:04:04,600 --> 00:04:08,000
decrypt the traffic I captured a year

88
00:04:07,040 --> 00:04:10,700
ago

89
00:04:08,000 --> 00:04:13,880
why would WPA 3 that is possible with

90
00:04:10,700 --> 00:04:15,709
WPA 3 I can collect someone's network

91
00:04:13,880 --> 00:04:17,480
traffic on the FIDE and later on learn

92
00:04:15,709 --> 00:04:20,630
the password I can go back in time and

93
00:04:17,480 --> 00:04:22,320
decrypt the traffic but what w play 3

94
00:04:20,630 --> 00:04:24,750
that's not possible

95
00:04:22,320 --> 00:04:28,620
so those are two very interesting

96
00:04:24,750 --> 00:04:32,070
properties and they make wp3 a much

97
00:04:28,620 --> 00:04:36,930
better choice on actually just a modern

98
00:04:32,070 --> 00:04:40,230
crypto protocol one last thing I want to

99
00:04:36,930 --> 00:04:42,930
mention here is that certain other pigs

100
00:04:40,230 --> 00:04:45,330
they also provide one fourth property

101
00:04:42,930 --> 00:04:48,630
and that is that they protect against a

102
00:04:45,330 --> 00:04:51,180
so called server compromise so what I

103
00:04:48,630 --> 00:04:53,540
mean with this is that some pigs but

104
00:04:51,180 --> 00:04:56,280
dragonfly doesn't have that property

105
00:04:53,540 --> 00:04:57,930
they provide a defense if your access

106
00:04:56,280 --> 00:04:58,909
point of it or if your server is

107
00:04:57,930 --> 00:05:00,780
compromised

108
00:04:58,910 --> 00:05:03,330
basically the way and you have to

109
00:05:00,780 --> 00:05:05,789
imagine this is that with some pigs you

110
00:05:03,330 --> 00:05:08,760
can store the password and a salted

111
00:05:05,790 --> 00:05:12,030
version but with wp3 that is not the

112
00:05:08,760 --> 00:05:14,159
case with wp3 both the access point the

113
00:05:12,030 --> 00:05:16,320
router on the client they need to store

114
00:05:14,160 --> 00:05:18,630
a plain text version of the password

115
00:05:16,320 --> 00:05:20,760
which means if your router or a client

116
00:05:18,630 --> 00:05:25,380
is compromised the adversary will know

117
00:05:20,760 --> 00:05:27,150
will learn the plaintext password so

118
00:05:25,380 --> 00:05:31,050
that's a very quick introduction of

119
00:05:27,150 --> 00:05:34,859
about properties of WPA 3 I'll now very

120
00:05:31,050 --> 00:05:36,530
briefly explain how this handshake works

121
00:05:34,860 --> 00:05:39,660
in practice

122
00:05:36,530 --> 00:05:41,609
let's say that we have a client here

123
00:05:39,660 --> 00:05:46,950
that wants to connect to the access

124
00:05:41,610 --> 00:05:49,440
point and they are using WPA 3 the first

125
00:05:46,950 --> 00:05:51,960
thing that both these devices need to do

126
00:05:49,440 --> 00:05:54,000
is they need to convert the plaintext

127
00:05:51,960 --> 00:05:56,250
password which is for example just an

128
00:05:54,000 --> 00:05:58,500
ASCII or in Unicode they need to

129
00:05:56,250 --> 00:06:02,040
transform this to a so called group

130
00:05:58,500 --> 00:06:04,740
elements P now what is this group

131
00:06:02,040 --> 00:06:05,910
element P I will go into MIT in a bit

132
00:06:04,740 --> 00:06:08,760
more detail later on

133
00:06:05,910 --> 00:06:10,800
but basically is it's sort of a

134
00:06:08,760 --> 00:06:12,990
mathematical presentation of the

135
00:06:10,800 --> 00:06:15,180
passwords which you will be able to use

136
00:06:12,990 --> 00:06:17,970
in the actual cryptographic protocols on

137
00:06:15,180 --> 00:06:21,060
the cryptographic calculations because

138
00:06:17,970 --> 00:06:22,800
you know an S key password isn't really

139
00:06:21,060 --> 00:06:25,950
a valid number you have to convert it

140
00:06:22,800 --> 00:06:29,370
somehow into a mathematical object so to

141
00:06:25,950 --> 00:06:31,200
speak this is the first thing that both

142
00:06:29,370 --> 00:06:33,210
devices need to do they need to convert

143
00:06:31,200 --> 00:06:34,990
the password in something that can be

144
00:06:33,210 --> 00:06:37,539
used in our crypto

145
00:06:34,990 --> 00:06:40,270
the calculations on once that is done

146
00:06:37,540 --> 00:06:43,300
they can execute the actual handshake

147
00:06:40,270 --> 00:06:46,479
and this handshake consists of two main

148
00:06:43,300 --> 00:06:49,420
phases the first phase is called the

149
00:06:46,480 --> 00:06:51,880
commit phase and to simplify it a bit

150
00:06:49,420 --> 00:06:55,540
here the commit phase essentially

151
00:06:51,880 --> 00:06:59,590
negotiates a shared key between both the

152
00:06:55,540 --> 00:07:02,340
clients on the access point the second

153
00:06:59,590 --> 00:07:05,679
phase is called the confirmed phase and

154
00:07:02,340 --> 00:07:07,719
in this phase both devices confirm that

155
00:07:05,680 --> 00:07:09,970
they negotiated the same session key

156
00:07:07,720 --> 00:07:12,340
which in turn also means that they use

157
00:07:09,970 --> 00:07:15,580
the same password so if the confirmed

158
00:07:12,340 --> 00:07:17,619
phase succeeds then both parties know of

159
00:07:15,580 --> 00:07:19,450
each other that the other one indeed has

160
00:07:17,620 --> 00:07:25,570
the correct password and is allowed to

161
00:07:19,450 --> 00:07:29,200
connect now the important thing about

162
00:07:25,570 --> 00:07:31,090
the dragonfly handshake arms where

163
00:07:29,200 --> 00:07:34,090
actually most of the things will go

164
00:07:31,090 --> 00:07:36,789
wrong and that we will discuss is in how

165
00:07:34,090 --> 00:07:41,619
this password is converted into a group

166
00:07:36,790 --> 00:07:43,660
element and I will now explain in a bit

167
00:07:41,620 --> 00:07:47,080
more detail how this password is

168
00:07:43,660 --> 00:07:49,300
converted to this element B but before I

169
00:07:47,080 --> 00:07:51,820
do this I have one more important remark

170
00:07:49,300 --> 00:07:54,430
and this is that the dragonfly handshake

171
00:07:51,820 --> 00:07:57,700
can be executed using two different

172
00:07:54,430 --> 00:07:59,980
so-called cryptographic groups the first

173
00:07:57,700 --> 00:08:02,520
is called multiple groups on the second

174
00:07:59,980 --> 00:08:05,770
is called elliptic curve elliptic curves

175
00:08:02,520 --> 00:08:08,640
I will briefly introduce both on the

176
00:08:05,770 --> 00:08:11,859
Alex Alec will explain for both variants

177
00:08:08,640 --> 00:08:15,010
how this algorithm works that converts

178
00:08:11,860 --> 00:08:17,470
the passwords into a group element P so

179
00:08:15,010 --> 00:08:20,860
the first case is here as you can see

180
00:08:17,470 --> 00:08:23,110
the mod P groups now I don't expect any

181
00:08:20,860 --> 00:08:25,180
of you to know what mod P groups are so

182
00:08:23,110 --> 00:08:28,300
let me give you a very quick

183
00:08:25,180 --> 00:08:30,520
introduction on don't worry we're not

184
00:08:28,300 --> 00:08:34,770
gonna use a lot of math here it's gonna

185
00:08:30,520 --> 00:08:39,429
be quite simple so what is a mod P group

186
00:08:34,770 --> 00:08:43,090
well we can treat this in very simple

187
00:08:39,429 --> 00:08:44,020
terms basically it means that we are

188
00:08:43,090 --> 00:08:47,110
working

189
00:08:44,020 --> 00:08:49,360
numbers so all our crypto operations are

190
00:08:47,110 --> 00:08:52,480
done on numbers and all these numbers

191
00:08:49,360 --> 00:08:53,710
are smaller than a certain prime and

192
00:08:52,480 --> 00:08:57,130
that's the only thing you need to

193
00:08:53,710 --> 00:08:59,320
remember one other thing is that the

194
00:08:57,130 --> 00:09:01,720
numbers we are working on here they need

195
00:08:59,320 --> 00:09:03,580
to satisfy a certain equation but

196
00:09:01,720 --> 00:09:06,670
understanding that equation won't be too

197
00:09:03,580 --> 00:09:08,830
important and for the rest of you that

198
00:09:06,670 --> 00:09:10,870
are wondering the queue here represents

199
00:09:08,830 --> 00:09:13,090
the amount of elements in the group but

200
00:09:10,870 --> 00:09:15,760
again that that's not too important to

201
00:09:13,090 --> 00:09:17,560
understand the talk just remember that

202
00:09:15,760 --> 00:09:20,230
all the numbers who are operating on

203
00:09:17,560 --> 00:09:22,380
they have to be smaller than the prime P

204
00:09:20,230 --> 00:09:25,840
that we are using here in other words

205
00:09:22,380 --> 00:09:28,510
all operations are done modulo the prime

206
00:09:25,840 --> 00:09:33,370
and that's also why it's called mod P

207
00:09:28,510 --> 00:09:35,890
groups because it's modulo P ok so

208
00:09:33,370 --> 00:09:39,670
that's a very quick introduction to

209
00:09:35,890 --> 00:09:42,580
multiple groups so now the question is

210
00:09:39,670 --> 00:09:47,250
how can we convert a plaintext passwords

211
00:09:42,580 --> 00:09:52,210
into a number that has these properties

212
00:09:47,250 --> 00:09:57,340
well a naive way to do it is the

213
00:09:52,210 --> 00:10:00,460
following way here we take the plaintext

214
00:09:57,340 --> 00:10:02,950
passwords and we hash it together with a

215
00:10:00,460 --> 00:10:07,060
MAC address of the clients on the access

216
00:10:02,950 --> 00:10:10,860
point and the result of this hash inputs

217
00:10:07,060 --> 00:10:13,150
we interpret it as a value as an integer

218
00:10:10,860 --> 00:10:15,130
now there is one more thing that we need

219
00:10:13,150 --> 00:10:17,860
to do we need to make sure that this

220
00:10:15,130 --> 00:10:20,620
integer here that it satisfies this

221
00:10:17,860 --> 00:10:22,780
special equation and without going into

222
00:10:20,620 --> 00:10:25,000
too much detail to make sure that this

223
00:10:22,780 --> 00:10:27,370
is the case we can simply perform this

224
00:10:25,000 --> 00:10:30,040
calculation and then we are sure that

225
00:10:27,370 --> 00:10:32,710
the value P here is indeed a member of

226
00:10:30,040 --> 00:10:34,780
this mod P group so you don't need to

227
00:10:32,710 --> 00:10:37,840
know why this works just accept that

228
00:10:34,780 --> 00:10:39,760
this works if I execute this P as a

229
00:10:37,840 --> 00:10:45,250
valid member of the group and then we

230
00:10:39,760 --> 00:10:47,710
are done now this would

231
00:10:45,250 --> 00:10:52,330
this seems to work but there is actually

232
00:10:47,710 --> 00:10:55,330
one small problem and turns out this is

233
00:10:52,330 --> 00:10:58,600
going to be a major problem the problem

234
00:10:55,330 --> 00:11:01,540
is that for certain mod P groups there's

235
00:10:58,600 --> 00:11:04,060
a high chance that this value here the

236
00:11:01,540 --> 00:11:10,660
output of the hash will be bigger than

237
00:11:04,060 --> 00:11:13,510
the prime of the mod P group again I'm

238
00:11:10,660 --> 00:11:15,280
doing a high-level explanation here but

239
00:11:13,510 --> 00:11:17,620
if this value is bigger than the prime

240
00:11:15,280 --> 00:11:20,050
of the group then this formula would not

241
00:11:17,620 --> 00:11:22,240
be 100% correct because then there are

242
00:11:20,050 --> 00:11:24,760
some biases on maybe the adversary can

243
00:11:22,240 --> 00:11:27,100
abuse this so essentially we have to

244
00:11:24,760 --> 00:11:30,340
make sure that this output here this

245
00:11:27,100 --> 00:11:34,840
value it has to be smaller than the

246
00:11:30,340 --> 00:11:37,300
prime of the group especially for mod P

247
00:11:34,840 --> 00:11:40,060
groups for specific mod P groups this

248
00:11:37,300 --> 00:11:43,089
has a high probability of happening now

249
00:11:40,060 --> 00:11:48,400
fortunately the designers realized this

250
00:11:43,090 --> 00:11:51,400
and they decided to fix this what was

251
00:11:48,400 --> 00:11:53,890
their solution well they simply decided

252
00:11:51,400 --> 00:11:56,290
to put an if test here until gonna check

253
00:11:53,890 --> 00:11:58,030
if this value is bigger or equal than

254
00:11:56,290 --> 00:12:02,199
than the prime then we need to do

255
00:11:58,030 --> 00:12:05,530
something now what did they decide to do

256
00:12:02,200 --> 00:12:08,260
well they decided to include a counter

257
00:12:05,530 --> 00:12:11,160
in this algorithm so the counter starts

258
00:12:08,260 --> 00:12:13,360
at 1 it's included in the hash function

259
00:12:11,160 --> 00:12:16,600
and if we then get a value that is

260
00:12:13,360 --> 00:12:19,030
bigger than P or equal to P we simply

261
00:12:16,600 --> 00:12:21,460
execute a new loop meaning we increase

262
00:12:19,030 --> 00:12:23,920
the counter since the counter here is

263
00:12:21,460 --> 00:12:26,440
included in the hash this will result in

264
00:12:23,920 --> 00:12:29,319
a new output for value on hopefully on

265
00:12:26,440 --> 00:12:33,730
the second y value is smaller than P and

266
00:12:29,320 --> 00:12:36,760
we can continue the algorithm and it can

267
00:12:33,730 --> 00:12:41,320
be that we need multiple iterations here

268
00:12:36,760 --> 00:12:43,240
in this algorithm but also as a quick

269
00:12:41,320 --> 00:12:45,040
remark if you have questions during the

270
00:12:43,240 --> 00:12:48,670
talk you feel also free to raise your

271
00:12:45,040 --> 00:12:50,930
hands and ask them it's always nice to

272
00:12:48,670 --> 00:12:55,790
have some interaction as well

273
00:12:50,930 --> 00:12:58,758
now my question here is now what is

274
00:12:55,790 --> 00:13:01,009
wrong with this algorithm based on this

275
00:12:58,759 --> 00:13:07,420
description you can already see what

276
00:13:01,009 --> 00:13:10,879
will go wrong the problem here is that

277
00:13:07,420 --> 00:13:13,490
if we look here at the password we can

278
00:13:10,879 --> 00:13:16,040
see that the password will influence how

279
00:13:13,490 --> 00:13:20,470
many iterations are needed to convert

280
00:13:16,040 --> 00:13:23,748
the password into this group element P

281
00:13:20,470 --> 00:13:25,579
for example for password a I might

282
00:13:23,749 --> 00:13:28,129
immediately get a value that is smaller

283
00:13:25,579 --> 00:13:30,439
than P and I might immediately find the

284
00:13:28,129 --> 00:13:32,660
group element here but for a different

285
00:13:30,439 --> 00:13:35,689
password for password B I maybe need

286
00:13:32,660 --> 00:13:39,050
multiple iterations here in this for

287
00:13:35,689 --> 00:13:41,269
loop and this means that the execution

288
00:13:39,050 --> 00:13:44,179
time of this algorithm depends on the

289
00:13:41,269 --> 00:13:45,499
password being used and this is a bad

290
00:13:44,179 --> 00:13:48,619
thing because this is essentially a

291
00:13:45,499 --> 00:13:51,079
timing side-channel and we will be able

292
00:13:48,619 --> 00:13:55,819
to abuse this leaked information to them

293
00:13:51,079 --> 00:13:57,138
brute-force the password this is a bit

294
00:13:55,819 --> 00:13:59,479
surprising that there are no

295
00:13:57,139 --> 00:14:02,509
countermeasures against this timing link

296
00:13:59,480 --> 00:14:05,300
because the designers of this diagram

297
00:14:02,509 --> 00:14:09,980
they were actually once by this issue by

298
00:14:05,300 --> 00:14:11,959
both the IETF on the CFR gene now I

299
00:14:09,980 --> 00:14:16,240
assume maybe some of you know already

300
00:14:11,959 --> 00:14:18,559
what ITF is but basically the CFR G it's

301
00:14:16,240 --> 00:14:21,620
you can just consider it an online

302
00:14:18,559 --> 00:14:23,629
mailing list where people can propose an

303
00:14:21,620 --> 00:14:25,329
algorithm to cryptographers and they

304
00:14:23,629 --> 00:14:28,639
will then perform some sanity checks

305
00:14:25,329 --> 00:14:31,939
they will try to break the algorithm so

306
00:14:28,639 --> 00:14:34,129
to speak and on both these mailing lists

307
00:14:31,939 --> 00:14:37,719
some researchers actually found some

308
00:14:34,129 --> 00:14:41,959
flaws on they warned the designers in

309
00:14:37,720 --> 00:14:43,819
fact this was already back in 2010 when

310
00:14:41,959 --> 00:14:46,758
this handshake was report work was

311
00:14:43,819 --> 00:14:49,399
proposed already then some people said

312
00:14:46,759 --> 00:14:51,829
you know this algorithm is not a good

313
00:14:49,399 --> 00:14:54,999
idea because it's likely vulnerable to

314
00:14:51,829 --> 00:14:54,998
timing attacks

315
00:14:55,779 --> 00:15:02,170
unfortunately this comment was dismissed

316
00:14:58,790 --> 00:15:04,480
because the reaction was basically

317
00:15:02,170 --> 00:15:07,329
we're not really sure how important this

318
00:15:04,480 --> 00:15:09,640
timing league is yeah there might be

319
00:15:07,330 --> 00:15:11,230
this timing leak but you know I don't

320
00:15:09,640 --> 00:15:14,860
think it will leak the actual password

321
00:15:11,230 --> 00:15:16,390
so didn't think it was serious and I

322
00:15:14,860 --> 00:15:19,270
thought it wouldn't be a trivial attack

323
00:15:16,390 --> 00:15:21,730
so they essentially ignored this comment

324
00:15:19,270 --> 00:15:27,060
and it turns out that this is going to

325
00:15:21,730 --> 00:15:29,590
be a major flaw in the algorithm now

326
00:15:27,060 --> 00:15:31,900
let's come back to this remark here

327
00:15:29,590 --> 00:15:36,910
where initially they thought it wouldn't

328
00:15:31,900 --> 00:15:40,329
leak the password so how can this timing

329
00:15:36,910 --> 00:15:44,589
leak leak the password that you are

330
00:15:40,330 --> 00:15:47,230
using now let me explain this with an

331
00:15:44,590 --> 00:15:49,900
example let's say that we have an access

332
00:15:47,230 --> 00:15:53,140
point that is running somewhere and we

333
00:15:49,900 --> 00:15:55,000
are able to initiate a WPA 3 handshake

334
00:15:53,140 --> 00:15:57,010
with it at least the first phase of the

335
00:15:55,000 --> 00:15:58,720
handshake because we don't know you the

336
00:15:57,010 --> 00:16:01,030
password yet so we cannot complete the

337
00:15:58,720 --> 00:16:02,590
handshake but we can initiate the

338
00:16:01,030 --> 00:16:04,540
handshake with the access points on

339
00:16:02,590 --> 00:16:07,240
let's assume that we are able to measure

340
00:16:04,540 --> 00:16:10,480
how many iterations this access point

341
00:16:07,240 --> 00:16:14,920
needs to convert the password into this

342
00:16:10,480 --> 00:16:16,570
group element P so to repeat that we

343
00:16:14,920 --> 00:16:18,339
have an access point and we're going to

344
00:16:16,570 --> 00:16:22,120
measure how many iterations of this

345
00:16:18,340 --> 00:16:23,860
algorithm the access point needs on the

346
00:16:22,120 --> 00:16:25,720
first step of the attack we're going to

347
00:16:23,860 --> 00:16:30,640
connect with a client that has MAC

348
00:16:25,720 --> 00:16:33,010
address a so our own laptop is using MAC

349
00:16:30,640 --> 00:16:35,020
address a and we perform a timing attack

350
00:16:33,010 --> 00:16:37,930
to learn how many iterations the access

351
00:16:35,020 --> 00:16:39,880
point needed out in my example here the

352
00:16:37,930 --> 00:16:42,400
access point needed two iterations to

353
00:16:39,880 --> 00:16:46,950
convert the passwords into this elements

354
00:16:42,400 --> 00:16:50,020
P what I can do now is I can take a

355
00:16:46,950 --> 00:16:51,910
dictionary of passwords here in my

356
00:16:50,020 --> 00:16:54,850
example I'm just going to use three

357
00:16:51,910 --> 00:16:57,280
passwords and I can then run this

358
00:16:54,850 --> 00:17:00,760
algorithm offline on my own computer

359
00:16:57,280 --> 00:17:04,119
with this password so I can take here I

360
00:17:00,760 --> 00:17:06,250
can guess a password I can compute the

361
00:17:04,119 --> 00:17:08,109
algorithm that I just showed myself and

362
00:17:06,250 --> 00:17:10,160
I can then determine how many iterations

363
00:17:08,109 --> 00:17:15,619
would be needed

364
00:17:10,160 --> 00:17:18,230
indeed we are using this password um my

365
00:17:15,619 --> 00:17:20,060
example here if the access point if the

366
00:17:18,230 --> 00:17:22,819
network would have been using password 1

367
00:17:20,060 --> 00:17:28,339
then this algorithm would have needed

368
00:17:22,819 --> 00:17:30,560
one iteration in the algorithm and this

369
00:17:28,339 --> 00:17:32,510
doesn't match our observation because we

370
00:17:30,560 --> 00:17:36,470
measured the actual access points that

371
00:17:32,510 --> 00:17:39,350
it uses two iterations this means here

372
00:17:36,470 --> 00:17:42,500
that password 1 cannot possibly anews be

373
00:17:39,350 --> 00:17:45,290
used by the network because if it was

374
00:17:42,500 --> 00:17:47,120
used the access point would also execute

375
00:17:45,290 --> 00:17:53,330
one iteration but that's not the case

376
00:17:47,120 --> 00:17:55,310
now as you can see here password 2 and 3

377
00:17:53,330 --> 00:17:57,710
are still possible because if we

378
00:17:55,310 --> 00:18:00,260
simulate the algorithm offline we notice

379
00:17:57,710 --> 00:18:03,770
that they both also need 2 iterations to

380
00:18:00,260 --> 00:18:06,080
convert the password this matches what

381
00:18:03,770 --> 00:18:08,360
we observed from the access point

382
00:18:06,080 --> 00:18:10,850
so both these passwords are still

383
00:18:08,360 --> 00:18:13,490
possible so now the question is how can

384
00:18:10,850 --> 00:18:17,929
we further reduce the amount of possible

385
00:18:13,490 --> 00:18:20,630
passwords well the interesting thing is

386
00:18:17,930 --> 00:18:23,510
if we go back to the algorithm here we

387
00:18:20,630 --> 00:18:25,580
can see that the MAC addresses of the

388
00:18:23,510 --> 00:18:28,580
client on the access point they will

389
00:18:25,580 --> 00:18:30,350
also influence this algorithm because if

390
00:18:28,580 --> 00:18:32,750
you use a different client MAC address

391
00:18:30,350 --> 00:18:36,409
the output of this hash function will be

392
00:18:32,750 --> 00:18:38,540
different on this means you again get a

393
00:18:36,410 --> 00:18:43,460
different amount of iterations that are

394
00:18:38,540 --> 00:18:46,550
needed so that's the core idea here the

395
00:18:43,460 --> 00:18:48,950
core idea is that we can spoof a

396
00:18:46,550 --> 00:18:50,930
different client MAC address and then we

397
00:18:48,950 --> 00:18:53,210
can again measure how many iterations

398
00:18:50,930 --> 00:18:56,630
the access point will need in our

399
00:18:53,210 --> 00:18:59,120
algorithm so if we go back to our

400
00:18:56,630 --> 00:19:02,000
example here what an adversary can do

401
00:18:59,120 --> 00:19:04,360
after this first step is that he or she

402
00:19:02,000 --> 00:19:07,250
can now spoof a different MAC address

403
00:19:04,360 --> 00:19:09,350
then we can again do a timing attack to

404
00:19:07,250 --> 00:19:11,600
measure how many iterations the access

405
00:19:09,350 --> 00:19:14,870
point needs or in this case the access

406
00:19:11,600 --> 00:19:16,879
point needs for example one iteration we

407
00:19:14,870 --> 00:19:19,280
can then take our remaining possible

408
00:19:16,880 --> 00:19:20,620
passwords simulate this algorithm

409
00:19:19,280 --> 00:19:22,629
offline

410
00:19:20,620 --> 00:19:25,270
here we see that password to would need

411
00:19:22,630 --> 00:19:27,490
two iterations that doesn't match our

412
00:19:25,270 --> 00:19:30,820
observation here meaning we can again

413
00:19:27,490 --> 00:19:32,580
exclude the password and we can continue

414
00:19:30,820 --> 00:19:35,470
doing this with multiple MAC addresses

415
00:19:32,580 --> 00:19:39,720
until we uniquely determines the

416
00:19:35,470 --> 00:19:43,090
passwords being used by the access point

417
00:19:39,720 --> 00:19:45,630
now to give you an idea how many MAC

418
00:19:43,090 --> 00:19:49,689
addresses we need to spoof in this way

419
00:19:45,630 --> 00:19:52,419
if we would take the RockYou database as

420
00:19:49,690 --> 00:19:55,899
a reference and if you want to try to

421
00:19:52,419 --> 00:19:57,640
uniquely determine the password in the

422
00:19:55,899 --> 00:20:00,459
rock your database assuming this

423
00:19:57,640 --> 00:20:03,419
password is in this database now we need

424
00:20:00,460 --> 00:20:07,000
to spoof on average 17 MAC addresses

425
00:20:03,419 --> 00:20:09,279
which is not too much on the intuition

426
00:20:07,000 --> 00:20:11,950
behind this here is that for every MAC

427
00:20:09,279 --> 00:20:14,289
address we can eliminate say roughly

428
00:20:11,950 --> 00:20:20,230
half of all the passwords in the

429
00:20:14,289 --> 00:20:23,230
database now in case this was a bit fake

430
00:20:20,230 --> 00:20:26,260
the main takeaway message here is that

431
00:20:23,230 --> 00:20:28,240
by measuring how many iterations that

432
00:20:26,260 --> 00:20:31,059
the access point needed to convert the

433
00:20:28,240 --> 00:20:34,059
passwords this information essentially

434
00:20:31,059 --> 00:20:35,678
forms a signature of the password so

435
00:20:34,059 --> 00:20:37,779
that's the one thing I want you to

436
00:20:35,679 --> 00:20:39,970
remember here the amount of iterations

437
00:20:37,779 --> 00:20:42,130
that the access point needed it forms a

438
00:20:39,970 --> 00:20:43,330
signature of the passwords on this

439
00:20:42,130 --> 00:20:49,450
signature can then be used to

440
00:20:43,330 --> 00:20:52,299
brute-force the password offline okay so

441
00:20:49,450 --> 00:20:55,419
we now almost completely covered this

442
00:20:52,299 --> 00:20:58,418
initial attack there is one thing I

443
00:20:55,419 --> 00:21:00,460
didn't explain yet and that is whether

444
00:20:58,419 --> 00:21:02,919
it is actually an feasible and practice

445
00:21:00,460 --> 00:21:07,330
to measure how many iterations that the

446
00:21:02,919 --> 00:21:11,380
access point needs so we decided to test

447
00:21:07,330 --> 00:21:15,850
this out in real life and what we did is

448
00:21:11,380 --> 00:21:17,679
we took a Raspberry Pi one be on the

449
00:21:15,850 --> 00:21:20,049
reason we took this Raspberry Pi one be

450
00:21:17,679 --> 00:21:22,840
is because it's CPU matches the CPU of

451
00:21:20,049 --> 00:21:25,570
common home routers and also the CPU of

452
00:21:22,840 --> 00:21:27,220
some professional access point because

453
00:21:25,570 --> 00:21:28,649
generally your own router doesn't have

454
00:21:27,220 --> 00:21:31,140
the most performance

455
00:21:28,650 --> 00:21:37,170
CPU and we found that the Raspberry Pi

456
00:21:31,140 --> 00:21:39,090
was a fairly decent match when we did

457
00:21:37,170 --> 00:21:41,430
this work there were a few professional

458
00:21:39,090 --> 00:21:43,169
access points available so that's also

459
00:21:41,430 --> 00:21:47,580
another reason why we use the Raspberry

460
00:21:43,170 --> 00:21:50,070
Pi but for the software that we ran on

461
00:21:47,580 --> 00:21:52,280
our Raspberry Pi we use the host AP

462
00:21:50,070 --> 00:21:55,679
which is an open source implementation

463
00:21:52,280 --> 00:21:58,020
of an access point and it is in fact

464
00:21:55,680 --> 00:22:00,540
heavily used in Linux on Android and

465
00:21:58,020 --> 00:22:02,610
practically every home router will be

466
00:22:00,540 --> 00:22:04,470
running host AP and even some

467
00:22:02,610 --> 00:22:09,209
professional routers they also use a

468
00:22:04,470 --> 00:22:11,970
host AP so with this setup with our host

469
00:22:09,210 --> 00:22:15,330
AP running on a Raspberry Pi one we

470
00:22:11,970 --> 00:22:18,390
performed our timing attack and based on

471
00:22:15,330 --> 00:22:21,540
this graph we can see that if the access

472
00:22:18,390 --> 00:22:23,880
point here needs only one iteration it

473
00:22:21,540 --> 00:22:26,670
clearly has a different response time

474
00:22:23,880 --> 00:22:29,520
than if the access point would need two

475
00:22:26,670 --> 00:22:32,180
iterations so here this orange line is

476
00:22:29,520 --> 00:22:37,290
if the access point needs two iterations

477
00:22:32,180 --> 00:22:39,690
we can see here that this indeed is

478
00:22:37,290 --> 00:22:42,030
measurable and to give more more

479
00:22:39,690 --> 00:22:44,640
concrete number here if I want to

480
00:22:42,030 --> 00:22:46,800
determine against this specific setup

481
00:22:44,640 --> 00:22:49,140
how many iterations that the access

482
00:22:46,800 --> 00:22:53,940
point executed then I need to perform

483
00:22:49,140 --> 00:22:57,960
around 75 timing measurements so as an

484
00:22:53,940 --> 00:23:01,650
adversary I need to initiate 75 in

485
00:22:57,960 --> 00:23:04,440
complete wp3 handshakes and after doing

486
00:23:01,650 --> 00:23:08,490
this I learn with a high probability how

487
00:23:04,440 --> 00:23:10,380
many iterations were needed in other

488
00:23:08,490 --> 00:23:12,870
words this timing attack is definitely

489
00:23:10,380 --> 00:23:19,680
feasible and practice especially against

490
00:23:12,870 --> 00:23:21,419
devices with a weaker CPU maybe one

491
00:23:19,680 --> 00:23:23,400
other remark here is that I executed

492
00:23:21,420 --> 00:23:26,010
this attack in my own apartment so there

493
00:23:23,400 --> 00:23:28,770
was some background noise so I wouldn't

494
00:23:26,010 --> 00:23:30,390
say this wasn't in the worst situation

495
00:23:28,770 --> 00:23:32,870
but we also didn't do this in the

496
00:23:30,390 --> 00:23:35,250
optimal case it's just an average day

497
00:23:32,870 --> 00:23:37,580
environments that we performed this

498
00:23:35,250 --> 00:23:37,580
attack

499
00:23:37,670 --> 00:23:43,920
so going to be already covered quite a

500
00:23:40,410 --> 00:23:46,620
bit now this is the timing attack that

501
00:23:43,920 --> 00:23:48,930
we discovered and it's I would say one

502
00:23:46,620 --> 00:23:52,020
of the main issues that we found naming

503
00:23:48,930 --> 00:23:54,650
these timing leaks but there's actually

504
00:23:52,020 --> 00:23:57,750
a second part to the story as well

505
00:23:54,650 --> 00:23:59,640
because remember that I said that the

506
00:23:57,750 --> 00:24:01,680
Dragonfly handshake can be executed

507
00:23:59,640 --> 00:24:04,430
using a term odd P groups but it can

508
00:24:01,680 --> 00:24:07,200
also be executed using elliptic curves

509
00:24:04,430 --> 00:24:09,540
so now the question is if we use

510
00:24:07,200 --> 00:24:12,030
elliptic curves do we also have a timing

511
00:24:09,540 --> 00:24:15,120
linked do we also have a timing leak or

512
00:24:12,030 --> 00:24:17,340
are we secure in that case now to

513
00:24:15,120 --> 00:24:19,800
understand this and to answer this

514
00:24:17,340 --> 00:24:22,070
question let me give a one minute

515
00:24:19,800 --> 00:24:24,210
introduction to elliptic curves

516
00:24:22,070 --> 00:24:26,550
essentially if we use elliptic curves

517
00:24:24,210 --> 00:24:31,680
all operations are performed here on a

518
00:24:26,550 --> 00:24:33,570
point x and y and again both both the x

519
00:24:31,680 --> 00:24:36,270
and y coordinates need to be smaller

520
00:24:33,570 --> 00:24:38,550
than the prime that is being used now

521
00:24:36,270 --> 00:24:42,840
the second condition is that x and y

522
00:24:38,550 --> 00:24:44,430
need to satisfy this equation here on

523
00:24:42,840 --> 00:24:46,770
again that's all we need to know we're

524
00:24:44,430 --> 00:24:51,300
not going to use any more math other

525
00:24:46,770 --> 00:24:53,639
than this the question now is how can we

526
00:24:51,300 --> 00:24:56,639
again convert the plaintext s key

527
00:24:53,640 --> 00:25:03,360
passwords in this case into a point X Y

528
00:24:56,640 --> 00:25:05,610
here on the elliptic curve um the way

529
00:25:03,360 --> 00:25:08,729
that this is done for wp3 is very

530
00:25:05,610 --> 00:25:11,520
similar to the mod p case because we

531
00:25:08,730 --> 00:25:13,860
again have an algorithm here that here

532
00:25:11,520 --> 00:25:15,840
it takes the password it hashes it

533
00:25:13,860 --> 00:25:17,459
together with a counter on the MAC

534
00:25:15,840 --> 00:25:20,370
address of the clients on the access

535
00:25:17,460 --> 00:25:22,980
point but in this case the outputs of

536
00:25:20,370 --> 00:25:27,500
the hash function is treated as the

537
00:25:22,980 --> 00:25:29,940
x-coordinate of our points that we want

538
00:25:27,500 --> 00:25:32,490
and then the ideas we take this

539
00:25:29,940 --> 00:25:34,950
x-coordinate on we can see and then we

540
00:25:32,490 --> 00:25:38,640
check if there is a corresponding Y

541
00:25:34,950 --> 00:25:40,230
value as well on this Y value we would

542
00:25:38,640 --> 00:25:44,460
have to calculate it here using the

543
00:25:40,230 --> 00:25:46,100
square root and to give a simplified

544
00:25:44,460 --> 00:25:48,170
explanation here

545
00:25:46,100 --> 00:25:52,280
there won't be a corresponding y-value

546
00:25:48,170 --> 00:25:54,310
for every x coordinate on the intuition

547
00:25:52,280 --> 00:25:56,930
here is that we have a square root and

548
00:25:54,310 --> 00:25:59,419
you know if we take the square root of a

549
00:25:56,930 --> 00:26:02,960
negative number that doesn't exist on

550
00:25:59,420 --> 00:26:06,590
the same situation at least intuitively

551
00:26:02,960 --> 00:26:10,070
implies here as well this square root

552
00:26:06,590 --> 00:26:12,320
doesn't always have a solution so that's

553
00:26:10,070 --> 00:26:13,909
why if we have this x value we first

554
00:26:12,320 --> 00:26:16,639
need to check does this square root

555
00:26:13,910 --> 00:26:19,040
actually have a solution on if it does

556
00:26:16,640 --> 00:26:21,050
then we know that we found a point x and

557
00:26:19,040 --> 00:26:27,620
y that indeed lies on the elliptic curve

558
00:26:21,050 --> 00:26:30,889
and that we can use so I hope that's a

559
00:26:27,620 --> 00:26:35,090
bit clearer and what's the interesting

560
00:26:30,890 --> 00:26:38,180
thing here is that remember that the

561
00:26:35,090 --> 00:26:42,290
dragonfly handshake is used both by wp3

562
00:26:38,180 --> 00:26:47,600
but also by EPW and it turns out and the

563
00:26:42,290 --> 00:26:49,580
EPW protocol PWD protocol which we call

564
00:26:47,600 --> 00:26:51,080
it is used in Wi-Fi networks where you

565
00:26:49,580 --> 00:26:54,169
have to login using a username and a

566
00:26:51,080 --> 00:26:56,659
password then exactly this algorithm is

567
00:26:54,170 --> 00:26:59,330
being used to convert the passwords into

568
00:26:56,660 --> 00:27:03,320
a elliptic curve into a point on the

569
00:26:59,330 --> 00:27:05,510
elliptic curve and this is problematic

570
00:27:03,320 --> 00:27:08,240
because here we have exactly the same

571
00:27:05,510 --> 00:27:11,240
vulnerability as before the password

572
00:27:08,240 --> 00:27:14,420
here influences the number of iterations

573
00:27:11,240 --> 00:27:16,610
that this algorithm executes so again we

574
00:27:14,420 --> 00:27:21,260
have a very basic timing link here on

575
00:27:16,610 --> 00:27:26,080
the EPW deep protocol is exploitable and

576
00:27:21,260 --> 00:27:32,990
exactly the same way as we saw before so

577
00:27:26,080 --> 00:27:35,360
that's bad for EPW for wp3 the situation

578
00:27:32,990 --> 00:27:37,310
is a bit more interesting because in

579
00:27:35,360 --> 00:27:40,189
this case the designers actually

580
00:27:37,310 --> 00:27:43,850
realized that this timing leak exists

581
00:27:40,190 --> 00:27:45,500
and when using elliptic curves they

582
00:27:43,850 --> 00:27:50,899
actually have a countermeasure against

583
00:27:45,500 --> 00:27:55,450
it what I do here in wp3 is they always

584
00:27:50,900 --> 00:27:58,640
execute 40 loops of the iterations

585
00:27:55,450 --> 00:28:02,000
for the element B they simply pick the

586
00:27:58,640 --> 00:28:03,350
first solution here that we find so if

587
00:28:02,000 --> 00:28:05,900
you find a solution and the first

588
00:28:03,350 --> 00:28:09,980
iteration we assign the result to P and

589
00:28:05,900 --> 00:28:12,320
then we execute 39 additional iterations

590
00:28:09,980 --> 00:28:14,980
so that this algorithm always executes

591
00:28:12,320 --> 00:28:17,570
40 loops and then the idea is that there

592
00:28:14,980 --> 00:28:20,030
won't be a timing leak because the

593
00:28:17,570 --> 00:28:24,800
algorithm always executes in a constant

594
00:28:20,030 --> 00:28:26,990
amount of time and this number 40 here

595
00:28:24,800 --> 00:28:28,940
was chosen such that the probability of

596
00:28:26,990 --> 00:28:31,970
needing more than 40 iterations is

597
00:28:28,940 --> 00:28:37,310
extremely low that it normally shouldn't

598
00:28:31,970 --> 00:28:39,980
occur in practice on at first sight this

599
00:28:37,310 --> 00:28:43,179
actually looks like a solution that will

600
00:28:39,980 --> 00:28:47,360
indeed defend against these timing leaks

601
00:28:43,180 --> 00:28:50,090
however there is one problem and the

602
00:28:47,360 --> 00:28:52,399
problem is that if we use a certain type

603
00:28:50,090 --> 00:28:54,320
of elliptic curves because when you're

604
00:28:52,400 --> 00:28:56,060
using elliptic curves you have multiple

605
00:28:54,320 --> 00:28:58,939
choices of the curves you want to use

606
00:28:56,060 --> 00:29:01,639
for example you can use nist elliptic

607
00:28:58,940 --> 00:29:06,350
curves in which case this would be quite

608
00:29:01,640 --> 00:29:10,760
safe to use but wp3 also supports

609
00:29:06,350 --> 00:29:13,580
so-called brain pool curves and it turns

610
00:29:10,760 --> 00:29:16,730
out when we use brain pool curves we

611
00:29:13,580 --> 00:29:20,659
have a similar problem as before namely

612
00:29:16,730 --> 00:29:22,190
this outputs value here and the output

613
00:29:20,660 --> 00:29:24,920
of the hash function which will be equal

614
00:29:22,190 --> 00:29:27,110
to X it has a high chance of being

615
00:29:24,920 --> 00:29:30,500
higher than the prime of the elliptic

616
00:29:27,110 --> 00:29:32,570
curve and again this would cause issues

617
00:29:30,500 --> 00:29:35,480
in the remaining calculations because it

618
00:29:32,570 --> 00:29:38,030
might introduce bias but the thing to

619
00:29:35,480 --> 00:29:41,090
remember here is we want this x value to

620
00:29:38,030 --> 00:29:45,980
be smaller than P to avoid any possible

621
00:29:41,090 --> 00:29:47,810
issues so they had to implement a

622
00:29:45,980 --> 00:29:50,750
defense against this they has to somehow

623
00:29:47,810 --> 00:29:53,030
handle the case that X is bigger or

624
00:29:50,750 --> 00:29:55,310
equal than P now how did they solve this

625
00:29:53,030 --> 00:29:59,240
well they simply added an if condition

626
00:29:55,310 --> 00:30:01,250
here so what I did is if X is bigger or

627
00:29:59,240 --> 00:30:03,940
equal than P then we just execute

628
00:30:01,250 --> 00:30:07,070
another iteration

629
00:30:03,940 --> 00:30:12,230
so does anyone have any idea what is

630
00:30:07,070 --> 00:30:14,178
wrong here with this algorithm now yes

631
00:30:12,230 --> 00:30:17,809
you again get a different execution time

632
00:30:14,179 --> 00:30:21,590
because this amount of code here is then

633
00:30:17,809 --> 00:30:23,570
skipped and even more problematic the

634
00:30:21,590 --> 00:30:29,209
amount of times that this code is

635
00:30:23,570 --> 00:30:32,360
skipped will depend on the password so

636
00:30:29,210 --> 00:30:35,179
again we have a timing leak here now

637
00:30:32,360 --> 00:30:37,070
I'm simplifying here the the the

638
00:30:35,179 --> 00:30:39,140
high-level explanation of the algorithm

639
00:30:37,070 --> 00:30:41,570
a bit and practice there are some

640
00:30:39,140 --> 00:30:43,510
additional technicalities that we have

641
00:30:41,570 --> 00:30:45,918
to handle when we want to exploit this

642
00:30:43,510 --> 00:30:47,870
but essentially we have the same

643
00:30:45,919 --> 00:30:50,570
vulnerability and also the same exploit

644
00:30:47,870 --> 00:30:52,668
mechanism as before we can measure the

645
00:30:50,570 --> 00:30:55,010
execution time of the access point or

646
00:30:52,669 --> 00:30:57,650
even of the clients we can measure how

647
00:30:55,010 --> 00:30:59,900
many times this block of code was

648
00:30:57,650 --> 00:31:04,669
skipped on degan this forms a signature

649
00:30:59,900 --> 00:31:06,350
of the password now this is simplified a

650
00:31:04,669 --> 00:31:08,960
little bit but the high-level idea is

651
00:31:06,350 --> 00:31:11,360
the same that's again what I want you to

652
00:31:08,960 --> 00:31:13,370
remember here the execution time so the

653
00:31:11,360 --> 00:31:15,590
amount of iterations that are needed in

654
00:31:13,370 --> 00:31:18,049
this case the amount of times that this

655
00:31:15,590 --> 00:31:20,090
block was skipped it will again form a

656
00:31:18,049 --> 00:31:21,950
signature or the password on this

657
00:31:20,090 --> 00:31:23,899
signature we can take offline to then

658
00:31:21,950 --> 00:31:30,230
perform dictionary or brute force

659
00:31:23,900 --> 00:31:32,450
attacks okay good so we now covered all

660
00:31:30,230 --> 00:31:35,480
the possible timing leaks against this

661
00:31:32,450 --> 00:31:38,870
algorithm in my opinion these are really

662
00:31:35,480 --> 00:31:40,309
design flaws and WPA three technically

663
00:31:38,870 --> 00:31:43,520
you could implement this algorithm to

664
00:31:40,309 --> 00:31:47,090
avoid all these timing links but you

665
00:31:43,520 --> 00:31:49,520
know as a ordinary programmer or even as

666
00:31:47,090 --> 00:31:52,909
a good programmer if you are not aware

667
00:31:49,520 --> 00:31:55,010
of all these possible issues and it's

668
00:31:52,910 --> 00:31:58,040
very hard to implement this in a secure

669
00:31:55,010 --> 00:31:59,600
way on even for crypto experts this can

670
00:31:58,040 --> 00:32:02,178
be tricky to implement in a constant

671
00:31:59,600 --> 00:32:05,719
time way because it's very easy to screw

672
00:32:02,179 --> 00:32:10,100
up basically so yeah in my opinion this

673
00:32:05,720 --> 00:32:12,620
is a design flaw so we now covered

674
00:32:10,100 --> 00:32:14,570
timing leaks the second thing I briefly

675
00:32:12,620 --> 00:32:16,030
want to mention is that it's also

676
00:32:14,570 --> 00:32:20,560
possible to perform

677
00:32:16,030 --> 00:32:25,870
- attacks so let me again go back to our

678
00:32:20,560 --> 00:32:27,760
algorithm here essentially what I as an

679
00:32:25,870 --> 00:32:31,060
attacker want to know in order to break

680
00:32:27,760 --> 00:32:34,030
this algorithm I want to know in which

681
00:32:31,060 --> 00:32:35,620
iteration a solution was found because

682
00:32:34,030 --> 00:32:37,930
if we would know exactly in which

683
00:32:35,620 --> 00:32:40,659
iteration a solution was found then we

684
00:32:37,930 --> 00:32:44,260
can then we again have information about

685
00:32:40,660 --> 00:32:45,850
the password and we can again use this

686
00:32:44,260 --> 00:32:49,420
leaked information and offline

687
00:32:45,850 --> 00:32:52,379
brute-force attack and what we can do

688
00:32:49,420 --> 00:32:55,330
here is we can use flushed and reloads

689
00:32:52,380 --> 00:33:00,250
to detect when this piece of code is

690
00:32:55,330 --> 00:33:02,139
being executed now you don't need to

691
00:33:00,250 --> 00:33:05,470
know the details of how flush and reload

692
00:33:02,140 --> 00:33:08,080
works just assume that as an adversary

693
00:33:05,470 --> 00:33:10,720
we can determine whether this piece of

694
00:33:08,080 --> 00:33:14,320
code is executed and we want to know in

695
00:33:10,720 --> 00:33:16,450
which iteration it is executed there's

696
00:33:14,320 --> 00:33:18,790
one problem though and this is that you

697
00:33:16,450 --> 00:33:21,310
know this code will always be executed

698
00:33:18,790 --> 00:33:23,500
at some point it can be an iteration one

699
00:33:21,310 --> 00:33:26,679
it can be an iteration ten it can be an

700
00:33:23,500 --> 00:33:29,620
iteration 30 so we don't just need to

701
00:33:26,680 --> 00:33:32,410
know that this code is executed we also

702
00:33:29,620 --> 00:33:36,520
need to know in which iteration it was

703
00:33:32,410 --> 00:33:39,640
executed and now the question is how can

704
00:33:36,520 --> 00:33:41,080
we determine using flush and reload to

705
00:33:39,640 --> 00:33:45,580
determine in which iteration that is

706
00:33:41,080 --> 00:33:48,370
executed well our solution here is to

707
00:33:45,580 --> 00:33:50,409
also use flush and reload to monitor how

708
00:33:48,370 --> 00:33:53,679
many times the hash function here is

709
00:33:50,410 --> 00:33:55,480
executed as well on essentially we use

710
00:33:53,680 --> 00:33:57,630
that as a timer to know in which

711
00:33:55,480 --> 00:34:00,280
iteration we are

712
00:33:57,630 --> 00:34:02,320
for example using flush and reload we

713
00:34:00,280 --> 00:34:04,570
can determine the first time that this

714
00:34:02,320 --> 00:34:06,429
hash function was executed and we can

715
00:34:04,570 --> 00:34:09,370
also detect the second time that this

716
00:34:06,430 --> 00:34:12,460
has function was executed and we can

717
00:34:09,370 --> 00:34:15,489
then check whether between the first and

718
00:34:12,460 --> 00:34:19,600
second execution if this code was

719
00:34:15,489 --> 00:34:21,939
executed as well to summarize this will

720
00:34:19,600 --> 00:34:26,339
allow us to determine whether a solution

721
00:34:21,940 --> 00:34:26,340
was found in the first iteration or not

722
00:34:26,489 --> 00:34:34,419
now again the main takeaway message here

723
00:34:31,510 --> 00:34:36,550
is that by using these attacks we again

724
00:34:34,420 --> 00:34:40,990
learn a signature of the password we

725
00:34:36,550 --> 00:34:43,300
again know some leaked information and

726
00:34:40,989 --> 00:34:47,259
we can use this in an offline dictionary

727
00:34:43,300 --> 00:34:49,000
or brute-force attack what I do want to

728
00:34:47,260 --> 00:34:51,630
mention about this attack here is that

729
00:34:49,000 --> 00:34:55,060
it requires a quite powerful adversary

730
00:34:51,630 --> 00:34:57,180
because in order to perform these cache

731
00:34:55,060 --> 00:35:00,600
attacks you need to be able to run

732
00:34:57,180 --> 00:35:03,850
unprivileged codes on the victim machine

733
00:35:00,600 --> 00:35:06,279
there on the machine of the victim now

734
00:35:03,850 --> 00:35:08,410
in the case of smartphones this might be

735
00:35:06,280 --> 00:35:10,570
possible while making the victim install

736
00:35:08,410 --> 00:35:14,830
some kind of application application

737
00:35:10,570 --> 00:35:18,190
doesn't need special permission so this

738
00:35:14,830 --> 00:35:21,460
can be possible in practice and if you

739
00:35:18,190 --> 00:35:23,950
use an old browser an adversary can even

740
00:35:21,460 --> 00:35:26,730
perform these attacks from JavaScript if

741
00:35:23,950 --> 00:35:29,319
some other conditions are met as well

742
00:35:26,730 --> 00:35:31,480
the second condition is that the

743
00:35:29,320 --> 00:35:34,120
attacker also has to be within range of

744
00:35:31,480 --> 00:35:37,750
the victim in order to either set up a

745
00:35:34,120 --> 00:35:40,630
malicious client or access point now as

746
00:35:37,750 --> 00:35:43,990
you can see here these are more strict

747
00:35:40,630 --> 00:35:47,020
conditions so in practice it's unlikely

748
00:35:43,990 --> 00:35:50,740
that someone will exploit this but for

749
00:35:47,020 --> 00:35:52,270
modern crypto algorithm you know it has

750
00:35:50,740 --> 00:35:54,189
to be able to defend against this this

751
00:35:52,270 --> 00:35:55,990
is not acceptable for a modern crypto

752
00:35:54,190 --> 00:36:00,400
protocol to be vulnerable to this type

753
00:35:55,990 --> 00:36:02,589
of attack and here again we can abuse

754
00:36:00,400 --> 00:36:06,580
this leaked information as I mentioned

755
00:36:02,590 --> 00:36:08,320
to perform to try to determine the

756
00:36:06,580 --> 00:36:11,290
password and here we use the same

757
00:36:08,320 --> 00:36:13,960
technique that we spoof multiple MAC

758
00:36:11,290 --> 00:36:19,240
addresses to get enough information to

759
00:36:13,960 --> 00:36:21,760
then uniquely determine the password one

760
00:36:19,240 --> 00:36:23,759
thing I also want to discuss here is

761
00:36:21,760 --> 00:36:25,930
that I've always been talking about

762
00:36:23,760 --> 00:36:28,120
performing these dictionaries on these

763
00:36:25,930 --> 00:36:31,649
brute force attacks but I haven't yet

764
00:36:28,120 --> 00:36:34,029
explained how costly those attacks are

765
00:36:31,650 --> 00:36:37,030
the reason why I waited with explaining

766
00:36:34,030 --> 00:36:38,320
that is that we can use exactly the same

767
00:36:37,030 --> 00:36:40,810
route force

768
00:36:38,320 --> 00:36:43,540
vote for timing attacks on for our cash

769
00:36:40,810 --> 00:36:45,670
attacks so that's nice we can implement

770
00:36:43,540 --> 00:36:48,160
our brute-force algorithm once and we

771
00:36:45,670 --> 00:36:53,170
can use it in both the cases that I just

772
00:36:48,160 --> 00:36:56,080
discussed now what we did is we try to

773
00:36:53,170 --> 00:36:59,320
optimize on the estimate the cost of a

774
00:36:56,080 --> 00:37:02,770
brute-force attacks using GPUs on the

775
00:36:59,320 --> 00:37:04,690
air we found that we can go through a

776
00:37:02,770 --> 00:37:07,030
dictionary of 10 to the power 10

777
00:37:04,690 --> 00:37:11,170
passwords for less than a dollar on

778
00:37:07,030 --> 00:37:15,850
Amazon ec2 instances now what does this

779
00:37:11,170 --> 00:37:18,130
number mean here 10 to the power 10 this

780
00:37:15,850 --> 00:37:20,440
number is bigger than any password um

781
00:37:18,130 --> 00:37:22,540
you can find online it's bigger than the

782
00:37:20,440 --> 00:37:25,360
rock your password dump it's bigger than

783
00:37:22,540 --> 00:37:28,360
all the passwords on have I been pwned

784
00:37:25,360 --> 00:37:31,630
it's also bigger than nearly all English

785
00:37:28,360 --> 00:37:34,900
dictionaries that we found which means

786
00:37:31,630 --> 00:37:37,260
that if you take all the password terms

787
00:37:34,900 --> 00:37:40,000
you can find if you add all the English

788
00:37:37,260 --> 00:37:41,770
dictionaries to it it will be smaller

789
00:37:40,000 --> 00:37:43,060
than this number and you'll be able to

790
00:37:41,770 --> 00:37:45,550
go through that dictionary

791
00:37:43,060 --> 00:37:50,670
for less than a dollar so this is quite

792
00:37:45,550 --> 00:37:54,010
efficient and inspired by this we also

793
00:37:50,670 --> 00:37:57,010
decide decided to calculate how much it

794
00:37:54,010 --> 00:37:59,770
would cost to perform a full brute-force

795
00:37:57,010 --> 00:38:03,220
attack of all possible 8 character

796
00:37:59,770 --> 00:38:06,520
passwords and in this case we assume

797
00:38:03,220 --> 00:38:08,200
that every character can have all 256

798
00:38:06,520 --> 00:38:12,310
possibilities so we're really checking

799
00:38:08,200 --> 00:38:14,950
every possible password of length 8 and

800
00:38:12,310 --> 00:38:17,560
then we found that if we attack mod P or

801
00:38:14,950 --> 00:38:23,740
brain pool groups brute-forcing this

802
00:38:17,560 --> 00:38:26,799
costs less than $70 which kind of a

803
00:38:23,740 --> 00:38:29,169
bigger price but still fairly doable if

804
00:38:26,800 --> 00:38:31,410
we attack list curves then in this case

805
00:38:29,170 --> 00:38:35,080
the cost is much higher it would be

806
00:38:31,410 --> 00:38:38,049
$14,000 now on one hand this is a big

807
00:38:35,080 --> 00:38:40,660
amount on the other hand the fact that

808
00:38:38,050 --> 00:38:43,180
we can attack a modern crypto algorithm

809
00:38:40,660 --> 00:38:45,160
for only this small amount is again

810
00:38:43,180 --> 00:38:48,399
unacceptable

811
00:38:45,160 --> 00:38:50,710
on facts in the meantime we found some

812
00:38:48,400 --> 00:38:53,349
other ideas to optimize this so likely

813
00:38:50,710 --> 00:38:55,839
we can make this number much lower and

814
00:38:53,349 --> 00:38:58,240
practice but this shows that these

815
00:38:55,839 --> 00:39:01,869
dictionaries dictionary text on these

816
00:38:58,240 --> 00:39:04,029
brute-force attacks at least

817
00:39:01,869 --> 00:39:10,300
computationally they would be feasible

818
00:39:04,030 --> 00:39:12,670
to do in practice as well so we now

819
00:39:10,300 --> 00:39:15,099
covered the timing of text we have our

820
00:39:12,670 --> 00:39:17,589
cache attacks we can do our dictionary

821
00:39:15,099 --> 00:39:20,170
attacks you'd think by now we covered

822
00:39:17,589 --> 00:39:24,190
most of the vulnerabilities but we're

823
00:39:20,170 --> 00:39:26,920
not done quite yet one thing we also did

824
00:39:24,190 --> 00:39:29,710
is we looked at implementations of

825
00:39:26,920 --> 00:39:33,309
dragonfly so on one hand we looked at

826
00:39:29,710 --> 00:39:36,880
some early wp3 implementations but we

827
00:39:33,309 --> 00:39:40,510
also looked at each PWD implementations

828
00:39:36,880 --> 00:39:41,950
the reason why is that remember as I

829
00:39:40,510 --> 00:39:44,319
said in the beginning the dragonfly

830
00:39:41,950 --> 00:39:46,390
handshake is also used and the e PWD

831
00:39:44,319 --> 00:39:48,190
protocol and it has been around much

832
00:39:46,390 --> 00:39:52,328
longer so there are more implementations

833
00:39:48,190 --> 00:39:53,680
of it the first attack that we checked

834
00:39:52,329 --> 00:39:57,579
for is a so called

835
00:39:53,680 --> 00:40:00,368
invalid curve attack now what happens in

836
00:39:57,579 --> 00:40:03,490
this attack well if we are using

837
00:40:00,369 --> 00:40:05,530
elliptic curves and we are using the

838
00:40:03,490 --> 00:40:07,720
dragonfly handshake then the first

839
00:40:05,530 --> 00:40:10,299
message that the client sends it will

840
00:40:07,720 --> 00:40:13,078
includes a point x and y on the curve

841
00:40:10,299 --> 00:40:16,750
this is simply part of the protocol and

842
00:40:13,079 --> 00:40:19,569
a legitimate clients always sends a

843
00:40:16,750 --> 00:40:23,559
point X on Y that is on the curve that

844
00:40:19,569 --> 00:40:25,869
satisfies that special equation but if

845
00:40:23,559 --> 00:40:28,450
we are an adversary we don't need to do

846
00:40:25,869 --> 00:40:33,309
that we can just send a point that isn't

847
00:40:28,450 --> 00:40:35,740
on the curve normally a proper client or

848
00:40:33,309 --> 00:40:37,480
a proper access point is supposed to

849
00:40:35,740 --> 00:40:40,209
check this it's supposed to check

850
00:40:37,480 --> 00:40:42,670
whether the received point x and y is on

851
00:40:40,210 --> 00:40:44,589
the curve or not on if it's not on the

852
00:40:42,670 --> 00:40:47,260
curve it's supposed to just ignore the

853
00:40:44,589 --> 00:40:49,150
message but we found several

854
00:40:47,260 --> 00:40:51,609
implementations that don't perform this

855
00:40:49,150 --> 00:40:52,900
check they don't check whether X and Y's

856
00:40:51,609 --> 00:40:57,029
on the curve

857
00:40:52,900 --> 00:41:00,640
as an adversary we can very carefully

858
00:40:57,029 --> 00:41:02,589
select the values for x and y here so

859
00:41:00,640 --> 00:41:07,808
that the negotiated session key only has

860
00:41:02,589 --> 00:41:09,759
a very small set of possible values so

861
00:41:07,809 --> 00:41:12,130
again by very carefully selecting the

862
00:41:09,759 --> 00:41:14,319
values for x and y assuming that the

863
00:41:12,130 --> 00:41:16,950
access point is vulnerable there only

864
00:41:14,319 --> 00:41:18,970
say about three possible values of the

865
00:41:16,950 --> 00:41:22,629
negotiated of the key that is being

866
00:41:18,970 --> 00:41:24,999
negotiated a vulnerable access point

867
00:41:22,630 --> 00:41:28,089
won't realize this tool simply reply

868
00:41:24,999 --> 00:41:30,788
using a commit and then we as an

869
00:41:28,089 --> 00:41:33,460
adversary we can guess the key that the

870
00:41:30,789 --> 00:41:36,130
access point calculated here and we have

871
00:41:33,460 --> 00:41:38,440
about more than 60% chance of guessing

872
00:41:36,130 --> 00:41:41,440
this correctly and then we can just

873
00:41:38,440 --> 00:41:45,249
continue the handshake as usual and if

874
00:41:41,440 --> 00:41:48,880
we successfully guessed the key which

875
00:41:45,249 --> 00:41:50,890
again there's more than 60% of guessing

876
00:41:48,880 --> 00:41:53,309
it correctly then we effectively

877
00:41:50,890 --> 00:41:55,749
completely bypassed authentication

878
00:41:53,309 --> 00:42:00,069
meaning we can login under any amount

879
00:41:55,749 --> 00:42:02,319
any username on or with wp3 we can just

880
00:42:00,069 --> 00:42:06,759
access the network without knowing the

881
00:42:02,319 --> 00:42:09,130
password now the most surprising thing

882
00:42:06,759 --> 00:42:13,029
here is that we looked at several EEP

883
00:42:09,130 --> 00:42:16,089
PWD implementations and all of them were

884
00:42:13,029 --> 00:42:20,410
vulnerable to this attack which was very

885
00:42:16,089 --> 00:42:23,288
surprising the only bright side I would

886
00:42:20,410 --> 00:42:25,899
say is that if you have an EP PWD

887
00:42:23,289 --> 00:42:29,079
implementation which uses a newer

888
00:42:25,900 --> 00:42:30,849
version of open SSL then open SSL

889
00:42:29,079 --> 00:42:33,640
already contains a defensive check

890
00:42:30,849 --> 00:42:36,039
against this on then implementation

891
00:42:33,640 --> 00:42:39,279
won't be vulnerable but if you for

892
00:42:36,039 --> 00:42:41,980
example use free radius or radiator with

893
00:42:39,279 --> 00:42:44,829
an older but still maintains version of

894
00:42:41,980 --> 00:42:46,930
open SSL then you can simply bypass

895
00:42:44,829 --> 00:42:49,140
authentication and you can log in as any

896
00:42:46,930 --> 00:42:52,299
one that you want

897
00:42:49,140 --> 00:42:54,999
what WPA 3 the situation was a bit

898
00:42:52,299 --> 00:42:57,029
better there we only found one

899
00:42:54,999 --> 00:43:02,379
implementation that was vulnerable to a

900
00:42:57,029 --> 00:43:05,820
variant of this attack so that covers

901
00:43:02,380 --> 00:43:09,150
the first implementation specific issue

902
00:43:05,820 --> 00:43:11,760
we also found another issue on this is

903
00:43:09,150 --> 00:43:16,200
that one implementation in particular

904
00:43:11,760 --> 00:43:20,840
namely the EPW implementation of Aruba

905
00:43:16,200 --> 00:43:22,980
it uses predictable random numbers

906
00:43:20,840 --> 00:43:27,390
whenever your random numbers are

907
00:43:22,980 --> 00:43:30,600
predictable you have a problem and in

908
00:43:27,390 --> 00:43:36,420
the case of wp3 this problem is actually

909
00:43:30,600 --> 00:43:38,460
quite bad because if a wp3 you use a bad

910
00:43:36,420 --> 00:43:41,760
source of randomness you can in fact

911
00:43:38,460 --> 00:43:45,030
recover here the password element be on

912
00:43:41,760 --> 00:43:48,810
with that with that information you can

913
00:43:45,030 --> 00:43:49,920
just connect to any network yeah you can

914
00:43:48,810 --> 00:43:52,230
just connect to the network you

915
00:43:49,920 --> 00:43:56,250
basically know the password of the

916
00:43:52,230 --> 00:44:00,330
network and this situation is in fact

917
00:43:56,250 --> 00:44:02,760
worse than wpa2 because if you use a bad

918
00:44:00,330 --> 00:44:06,600
source of randomness with wpa2 the

919
00:44:02,760 --> 00:44:08,700
impact is fairly minor while with wp3 if

920
00:44:06,600 --> 00:44:11,730
the implementation uses predictable

921
00:44:08,700 --> 00:44:14,370
random numbers all bets are off because

922
00:44:11,730 --> 00:44:18,150
you can recover P and then you can as an

923
00:44:14,370 --> 00:44:19,740
adversary connect with the network and I

924
00:44:18,150 --> 00:44:21,630
think this can be quite risky in

925
00:44:19,740 --> 00:44:25,350
practice because I can imagine certain

926
00:44:21,630 --> 00:44:27,480
IOT devices or at least devices that are

927
00:44:25,350 --> 00:44:28,890
very resource constrained and don't

928
00:44:27,480 --> 00:44:31,140
really have a proper source of

929
00:44:28,890 --> 00:44:32,850
randomness I expect that in the future

930
00:44:31,140 --> 00:44:34,379
some of them might be vulnerable to this

931
00:44:32,850 --> 00:44:37,290
they might use a bad source of

932
00:44:34,380 --> 00:44:42,900
randomness and then you can basically

933
00:44:37,290 --> 00:44:46,310
break wk3 another implementation bug

934
00:44:42,900 --> 00:44:52,140
that I want to discuss is specific to

935
00:44:46,310 --> 00:44:56,160
free radius and what free radius does is

936
00:44:52,140 --> 00:44:58,529
that in this algorithm that converts the

937
00:44:56,160 --> 00:45:00,629
plaintext passwords into this group

938
00:44:58,530 --> 00:45:03,840
element P remember that we need a

939
00:45:00,630 --> 00:45:06,540
variable amount of iterations strangely

940
00:45:03,840 --> 00:45:08,780
enough free radius aborts the handshake

941
00:45:06,540 --> 00:45:12,150
of more than 10 iterations are needed

942
00:45:08,780 --> 00:45:14,400
and we as a adversary can easily detect

943
00:45:12,150 --> 00:45:17,100
this because in this case free radius

944
00:45:14,400 --> 00:45:19,080
just sends a failure message message so

945
00:45:17,100 --> 00:45:23,580
we can detect when free radius needed

946
00:45:19,080 --> 00:45:26,220
more than ten iterations on in practice

947
00:45:23,580 --> 00:45:28,110
about one in every two thousand

948
00:45:26,220 --> 00:45:30,540
handshakes or at least connection

949
00:45:28,110 --> 00:45:33,990
attempts indeed need more than ten

950
00:45:30,540 --> 00:45:36,930
iterations so as an adversary what I can

951
00:45:33,990 --> 00:45:40,500
do now is I can try to initiate two

952
00:45:36,930 --> 00:45:43,589
thousand connection attempts to the free

953
00:45:40,500 --> 00:45:45,930
radius server on average one of those

954
00:45:43,590 --> 00:45:48,270
connections will fail on on the

955
00:45:45,930 --> 00:45:50,279
connection that fails I then know that

956
00:45:48,270 --> 00:45:53,520
three radius needed more than ten

957
00:45:50,280 --> 00:45:55,290
iterations and this information is again

958
00:45:53,520 --> 00:45:57,660
forms the signature of the password and

959
00:45:55,290 --> 00:46:01,490
we can use that signature to brute force

960
00:45:57,660 --> 00:46:03,720
the password so the lesson here is that

961
00:46:01,490 --> 00:46:05,490
aborting this algorithm if you need

962
00:46:03,720 --> 00:46:07,859
higher than a certain amount of

963
00:46:05,490 --> 00:46:09,450
iterations that's bad you should not do

964
00:46:07,860 --> 00:46:13,740
that because then you again leak

965
00:46:09,450 --> 00:46:15,750
information a similar problem is also

966
00:46:13,740 --> 00:46:17,879
present in the implementation of aruba

967
00:46:15,750 --> 00:46:22,410
it aborts when you need more than 30

968
00:46:17,880 --> 00:46:24,540
iterations but this is very hard to

969
00:46:22,410 --> 00:46:27,089
exploit and practice because you really

970
00:46:24,540 --> 00:46:29,160
need to send an absurd amount of

971
00:46:27,090 --> 00:46:32,810
connection attempts in order to ever

972
00:46:29,160 --> 00:46:34,859
cause Aruba to abort the connection

973
00:46:32,810 --> 00:46:37,740
because needing more than 10 iterations

974
00:46:34,860 --> 00:46:42,540
has has a very low probability in

975
00:46:37,740 --> 00:46:45,720
practice okay so there are all the

976
00:46:42,540 --> 00:46:48,870
implementation issues we aren't done yet

977
00:46:45,720 --> 00:46:51,720
I still have one more thing one more set

978
00:46:48,870 --> 00:46:54,630
of attacks to discuss on those attacks

979
00:46:51,720 --> 00:46:59,430
they're all more specific to the Wi-Fi

980
00:46:54,630 --> 00:47:02,330
area in particular let's go back here to

981
00:46:59,430 --> 00:47:05,580
the initial scheme of our handshake

982
00:47:02,330 --> 00:47:07,290
remember in you should definitely know

983
00:47:05,580 --> 00:47:08,759
that by now in the beginning we have to

984
00:47:07,290 --> 00:47:13,440
convert our password to this group

985
00:47:08,760 --> 00:47:16,500
element B and one downside is that the

986
00:47:13,440 --> 00:47:19,050
access points cannot cache the resulting

987
00:47:16,500 --> 00:47:20,790
group elements being here it cannot

988
00:47:19,050 --> 00:47:22,530
calculate this once and then later on

989
00:47:20,790 --> 00:47:24,360
keep reusing this for subsequent

990
00:47:22,530 --> 00:47:26,550
connections

991
00:47:24,360 --> 00:47:30,510
always needs to calculate this form

992
00:47:26,550 --> 00:47:33,030
scratch whenever a client connects on

993
00:47:30,510 --> 00:47:34,980
the reason why is that this element be

994
00:47:33,030 --> 00:47:37,680
here also depends on the MAC address of

995
00:47:34,980 --> 00:47:39,750
the clients and of course we cannot

996
00:47:37,680 --> 00:47:42,750
predict at least in general the MAC

997
00:47:39,750 --> 00:47:45,210
addresses of our clients which means

998
00:47:42,750 --> 00:47:47,880
whenever a client will connect an access

999
00:47:45,210 --> 00:47:50,400
point needs to execute this algorithm on

1000
00:47:47,880 --> 00:47:53,970
this algorithm is quite computationally

1001
00:47:50,400 --> 00:47:56,610
intensive because remember for when we

1002
00:47:53,970 --> 00:48:02,160
use elliptic curves we always use at

1003
00:47:56,610 --> 00:48:04,920
least 40 iterations on what we tested

1004
00:48:02,160 --> 00:48:08,670
here is we took professional access

1005
00:48:04,920 --> 00:48:10,920
points that already supports wp3 we

1006
00:48:08,670 --> 00:48:13,980
configured it to use the most secure and

1007
00:48:10,920 --> 00:48:16,020
also the most biggest elliptic curve and

1008
00:48:13,980 --> 00:48:18,750
in that case we found out that if we

1009
00:48:16,020 --> 00:48:23,160
initiate eight connections per seconds

1010
00:48:18,750 --> 00:48:25,470
then we get 100% CPU usage on the access

1011
00:48:23,160 --> 00:48:27,299
point so essentially it only supports

1012
00:48:25,470 --> 00:48:30,810
eight connection attempts per seconds

1013
00:48:27,300 --> 00:48:32,100
which is very low and this is an engine

1014
00:48:30,810 --> 00:48:36,660
essentially forms a denial of service

1015
00:48:32,100 --> 00:48:40,230
attack against WPA three now if you use

1016
00:48:36,660 --> 00:48:42,810
a smaller elliptic curve but still one

1017
00:48:40,230 --> 00:48:45,750
that is insecure the situation gets a

1018
00:48:42,810 --> 00:48:48,240
bit better in that case if you make

1019
00:48:45,750 --> 00:48:52,800
around 60 to 70 connection attempts only

1020
00:48:48,240 --> 00:48:56,580
then and the CPU is saturated but still

1021
00:48:52,800 --> 00:48:58,860
it's not an ideal situation on this also

1022
00:48:56,580 --> 00:49:02,970
highlights in my opinion the biggest

1023
00:48:58,860 --> 00:49:05,940
problem in WPA suite which is either you

1024
00:49:02,970 --> 00:49:08,580
have an implementation of this algorithm

1025
00:49:05,940 --> 00:49:10,800
which which immediately reserve returns

1026
00:49:08,580 --> 00:49:12,569
the point P but in that case you're

1027
00:49:10,800 --> 00:49:15,930
vulnerable to timing leaks because you

1028
00:49:12,570 --> 00:49:18,000
don't always execute 40 iterations all

1029
00:49:15,930 --> 00:49:19,620
you decide to always implement these 40

1030
00:49:18,000 --> 00:49:21,920
iterations but then you might be

1031
00:49:19,620 --> 00:49:24,600
vulnerable to a denial of service attack

1032
00:49:21,920 --> 00:49:26,880
so especially if you have a resource

1033
00:49:24,600 --> 00:49:28,860
constraint device there is no optimal

1034
00:49:26,880 --> 00:49:30,780
choice if you don't implement these

1035
00:49:28,860 --> 00:49:33,170
devices under vulnerable to the timing

1036
00:49:30,780 --> 00:49:37,040
attacks or you do implement them on

1037
00:49:33,170 --> 00:49:41,750
the computations are expensive on ya you

1038
00:49:37,040 --> 00:49:44,450
might be vulnerable to a dose one other

1039
00:49:41,750 --> 00:49:47,630
thing I want to mention is downgrade

1040
00:49:44,450 --> 00:49:50,960
attacks because as we all can imagine

1041
00:49:47,630 --> 00:49:53,329
and as we all see right now it will take

1042
00:49:50,960 --> 00:49:56,059
a time for W pastry to be implemented

1043
00:49:53,329 --> 00:49:59,240
and practice so we need some way that a

1044
00:49:56,059 --> 00:50:02,359
network and support bo wpa2 on three at

1045
00:49:59,240 --> 00:50:04,640
the same time and all the Wi-Fi lines

1046
00:50:02,359 --> 00:50:07,400
decided to tackle this issue is that

1047
00:50:04,640 --> 00:50:10,730
okay an access point can simply set up a

1048
00:50:07,400 --> 00:50:14,690
network so one single SSID name on this

1049
00:50:10,730 --> 00:50:17,660
SSID will support both W 2 & 3 using the

1050
00:50:14,690 --> 00:50:21,890
same password now the question is is

1051
00:50:17,660 --> 00:50:23,930
this secure to do well against one

1052
00:50:21,890 --> 00:50:26,839
attack scenario this actually provides

1053
00:50:23,930 --> 00:50:28,970
some security because let's say we have

1054
00:50:26,839 --> 00:50:32,808
a client on an access point that both

1055
00:50:28,970 --> 00:50:34,430
already support wk3 if I then would try

1056
00:50:32,809 --> 00:50:37,040
to do a man on the middle attack against

1057
00:50:34,430 --> 00:50:41,000
them and try to downgrade these devices

1058
00:50:37,040 --> 00:50:42,619
into using wpa2 the WBP a two handshake

1059
00:50:41,000 --> 00:50:45,170
would actually detect this down raid

1060
00:50:42,619 --> 00:50:47,480
attack it would realize oh no there's

1061
00:50:45,170 --> 00:50:50,510
actually a stronger handshake available

1062
00:50:47,480 --> 00:50:52,400
on the handshake will be aborted which

1063
00:50:50,510 --> 00:50:56,960
means that this solution provides

1064
00:50:52,400 --> 00:50:59,690
forward secrecy unfortunately there is a

1065
00:50:56,960 --> 00:51:02,569
big problem with this though and this is

1066
00:50:59,690 --> 00:51:04,970
that even though when we perform this

1067
00:51:02,569 --> 00:51:08,299
downgrade attack the wpa2 handshake

1068
00:51:04,970 --> 00:51:10,759
would be aborted the partial wpa2

1069
00:51:08,299 --> 00:51:13,609
handshake that is executed is enough to

1070
00:51:10,760 --> 00:51:18,079
perform an old-school dictionary attack

1071
00:51:13,609 --> 00:51:21,730
against wpa2 so if you configure your

1072
00:51:18,079 --> 00:51:24,650
network to work in wp3 transition modes

1073
00:51:21,730 --> 00:51:28,240
this means that an adversary can still

1074
00:51:24,650 --> 00:51:31,130
downgrade your clients into using wpa2

1075
00:51:28,240 --> 00:51:33,020
the client will eventually abort the

1076
00:51:31,130 --> 00:51:35,059
handshake but the adversary will have

1077
00:51:33,020 --> 00:51:38,720
enough information to still do a

1078
00:51:35,059 --> 00:51:40,700
dictionary attack so now you might be

1079
00:51:38,720 --> 00:51:44,149
wondering well okay this is a problem

1080
00:51:40,700 --> 00:51:47,200
but can we actually defend against this

1081
00:51:44,150 --> 00:51:49,430
I mean seems like a hard thing to do

1082
00:51:47,200 --> 00:51:52,730
unfortunately there is one solution it's

1083
00:51:49,430 --> 00:51:57,080
not 100% perfect but it makes the text a

1084
00:51:52,730 --> 00:51:59,180
lot harder which the thing that we do

1085
00:51:57,080 --> 00:52:03,319
there is we let the clients remember if

1086
00:51:59,180 --> 00:52:05,210
a network previously supported WPA 3 and

1087
00:52:03,320 --> 00:52:07,940
if we know that we previously connected

1088
00:52:05,210 --> 00:52:09,890
to a network using WP 3 then in the

1089
00:52:07,940 --> 00:52:13,820
future we won't we're not going to fall

1090
00:52:09,890 --> 00:52:16,730
back into using WPA 2 that would prevent

1091
00:52:13,820 --> 00:52:18,260
a lot of automated attacks on this idea

1092
00:52:16,730 --> 00:52:23,980
is similar to the trust on the first

1093
00:52:18,260 --> 00:52:27,620
usage of SSH and also to HTTPS with

1094
00:52:23,980 --> 00:52:31,550
strict Transport Security so its first

1095
00:52:27,620 --> 00:52:34,400
and first usage and the good thing here

1096
00:52:31,550 --> 00:52:36,410
is that by now the network manager of

1097
00:52:34,400 --> 00:52:39,890
Linux is in fact implementing this

1098
00:52:36,410 --> 00:52:41,930
defense so if you use the latest Linux

1099
00:52:39,890 --> 00:52:42,850
distribution then you will have this

1100
00:52:41,930 --> 00:52:45,919
countermeasure

1101
00:52:42,850 --> 00:52:48,049
the same is true if you use pixel 3

1102
00:52:45,920 --> 00:52:50,240
smartphone in that case it is also

1103
00:52:48,050 --> 00:52:52,130
implementing this countermeasure where

1104
00:52:50,240 --> 00:52:54,649
once you connect to a network that

1105
00:52:52,130 --> 00:53:00,560
supports WP three it won't automatically

1106
00:52:54,650 --> 00:53:03,920
downgrade to a wpa2 okay so that covers

1107
00:53:00,560 --> 00:53:06,250
downgrade attack number one there are

1108
00:53:03,920 --> 00:53:08,870
more downgrade attacks the second

1109
00:53:06,250 --> 00:53:13,730
downgrade attacks is a downgraded attack

1110
00:53:08,870 --> 00:53:15,589
against a crypto group remember that we

1111
00:53:13,730 --> 00:53:18,410
can execute the dragonfly handshake

1112
00:53:15,590 --> 00:53:20,780
using a tor mod P groups or elliptic

1113
00:53:18,410 --> 00:53:24,859
curves and the question is how do we

1114
00:53:20,780 --> 00:53:27,650
negotiate which group we are using well

1115
00:53:24,860 --> 00:53:29,930
this is done very simply the client

1116
00:53:27,650 --> 00:53:32,120
basically proposes a group to be used

1117
00:53:29,930 --> 00:53:34,549
when it decides to connect and then the

1118
00:53:32,120 --> 00:53:36,710
as the access point error accepts that

1119
00:53:34,550 --> 00:53:38,360
group or it sends a reject message

1120
00:53:36,710 --> 00:53:42,170
saying hey I don't support this group

1121
00:53:38,360 --> 00:53:44,360
use something else now it turns out that

1122
00:53:42,170 --> 00:53:47,180
this reject message is very easy to

1123
00:53:44,360 --> 00:53:49,060
spoof on on top of that after the

1124
00:53:47,180 --> 00:53:51,160
handshake would complete

1125
00:53:49,060 --> 00:53:52,660
there is no way to that the protocol

1126
00:53:51,160 --> 00:53:55,930
verifies that there were no downgrade

1127
00:53:52,660 --> 00:53:58,870
text so the summary here is that we can

1128
00:53:55,930 --> 00:54:01,089
force the client or access point into

1129
00:53:58,870 --> 00:54:03,880
using a specific elliptic curve or a

1130
00:54:01,090 --> 00:54:09,270
specific mod P group and this is again

1131
00:54:03,880 --> 00:54:11,650
really a a design flaw in the handshake

1132
00:54:09,270 --> 00:54:13,450
so this is downgrade attack number two

1133
00:54:11,650 --> 00:54:18,030
does anyone think there will be a third

1134
00:54:13,450 --> 00:54:21,189
downgrade attack of course there will be

1135
00:54:18,030 --> 00:54:23,110
but this one is specific to

1136
00:54:21,190 --> 00:54:26,620
implementations so the previous two

1137
00:54:23,110 --> 00:54:29,590
there were my opinion more in the area

1138
00:54:26,620 --> 00:54:31,810
of design flaws this is only an

1139
00:54:29,590 --> 00:54:35,230
implementation specific downgrade tech

1140
00:54:31,810 --> 00:54:38,320
and what happens here is that for

1141
00:54:35,230 --> 00:54:40,720
certain devices I'm talking here now

1142
00:54:38,320 --> 00:54:45,460
about client devices if they connect to

1143
00:54:40,720 --> 00:54:47,169
a WPA 3 only network in that case you

1144
00:54:45,460 --> 00:54:50,140
know there's no reason for this client

1145
00:54:47,170 --> 00:54:51,670
to ever down worry to wpa2 because when

1146
00:54:50,140 --> 00:54:54,759
it connected to the network this network

1147
00:54:51,670 --> 00:54:56,770
only supported wp3 so there's zero

1148
00:54:54,760 --> 00:54:59,740
reason to assume that in the future it

1149
00:54:56,770 --> 00:55:02,850
will switch back to wpa2 unless you are

1150
00:54:59,740 --> 00:55:05,709
in exceptional condition

1151
00:55:02,850 --> 00:55:10,569
unfortunately it turns out that with the

1152
00:55:05,710 --> 00:55:14,080
galaxy s 10 and also with the Linux iwd

1153
00:55:10,570 --> 00:55:17,140
Wi-Fi client which is a fairly recent

1154
00:55:14,080 --> 00:55:19,540
open source Wi-Fi client against these

1155
00:55:17,140 --> 00:55:22,839
devices is if they previously connected

1156
00:55:19,540 --> 00:55:25,420
to a WPA 3 network we can simply set up

1157
00:55:22,840 --> 00:55:27,340
a wpa2 network with the same SSID and

1158
00:55:25,420 --> 00:55:30,100
then these implementations will happily

1159
00:55:27,340 --> 00:55:34,150
connect to the wpa2 network meaning we

1160
00:55:30,100 --> 00:55:37,690
can still do all the attacks of wpa2 the

1161
00:55:34,150 --> 00:55:42,970
good news is that it's now patched on

1162
00:55:37,690 --> 00:55:45,580
the s10 I think if you have updates it

1163
00:55:42,970 --> 00:55:49,120
should be fixed now I don't know exactly

1164
00:55:45,580 --> 00:55:51,100
the situation with iwd but again this is

1165
00:55:49,120 --> 00:55:54,990
an implementation specific attack it

1166
00:55:51,100 --> 00:55:57,759
isn't really a flaw in the specification

1167
00:55:54,990 --> 00:56:00,069
now I'm going to leave sometimes for a

1168
00:55:57,760 --> 00:56:02,770
question as well so I'm going to skip

1169
00:56:00,069 --> 00:56:05,140
part of the disclosure that we followed

1170
00:56:02,770 --> 00:56:09,220
the one thing I want to mention here is

1171
00:56:05,140 --> 00:56:12,549
that the Wi-Fi standard is now being

1172
00:56:09,220 --> 00:56:14,558
updated to be more secure in particular

1173
00:56:12,549 --> 00:56:17,109
the standard is being updated to prevent

1174
00:56:14,559 --> 00:56:18,789
some of these downgrade attacks and on

1175
00:56:17,109 --> 00:56:21,130
top of that the standard is now also

1176
00:56:18,789 --> 00:56:24,010
being updated with a different algorithm

1177
00:56:21,130 --> 00:56:26,950
to convert the passwords into this group

1178
00:56:24,010 --> 00:56:29,799
elements being on this algorithm is a

1179
00:56:26,950 --> 00:56:31,779
constant time algorithm meaning there

1180
00:56:29,799 --> 00:56:36,759
are no more timing links on there are no

1181
00:56:31,780 --> 00:56:39,549
more cache attacks on this is done both

1182
00:56:36,760 --> 00:56:42,970
for mod P on elliptic curve groups so in

1183
00:56:39,549 --> 00:56:44,500
both these cases a different algorithm

1184
00:56:42,970 --> 00:56:47,339
is being proposed so that there are no

1185
00:56:44,500 --> 00:56:51,099
more timing leaks on top of that

1186
00:56:47,339 --> 00:56:53,440
previously it was unclear which elliptic

1187
00:56:51,099 --> 00:56:56,020
curves on mod P groups you are allowed

1188
00:56:53,440 --> 00:56:58,180
to use as an implementer they now also

1189
00:56:56,020 --> 00:57:03,119
have more clear guidelines on which

1190
00:56:58,180 --> 00:57:07,299
groups are secure on which are weak so

1191
00:57:03,119 --> 00:57:09,369
this might actually lead to WP 3 or 3.1

1192
00:57:07,299 --> 00:57:12,609
it's unclear how this will be handled in

1193
00:57:09,369 --> 00:57:14,559
practice but I do want to warn about the

1194
00:57:12,609 --> 00:57:18,400
risk of possible downgrade attacks here

1195
00:57:14,559 --> 00:57:21,029
so they are working on these updates to

1196
00:57:18,400 --> 00:57:23,740
the protocol but the risk here is that

1197
00:57:21,029 --> 00:57:28,650
maybe implementations can't ill be

1198
00:57:23,740 --> 00:57:31,180
downgraded to the first version of WPA 3

1199
00:57:28,650 --> 00:57:33,520
the last thing I want to mention is that

1200
00:57:31,180 --> 00:57:38,078
we saw a lot of attacks against WPA 3

1201
00:57:33,520 --> 00:57:41,619
here but even with its flaws right now

1202
00:57:38,079 --> 00:57:44,200
WPA 3 is still better than WPA 2 so if

1203
00:57:41,619 --> 00:57:47,140
your devices support WPA 3 you should

1204
00:57:44,200 --> 00:57:49,029
still start using it because with

1205
00:57:47,140 --> 00:57:51,750
attacks we discussed we can do

1206
00:57:49,029 --> 00:57:55,180
dictionary on brute-force attacks after

1207
00:57:51,750 --> 00:57:57,970
performing these rather tedious timing

1208
00:57:55,180 --> 00:57:59,440
on cache attacks well I will wpa2 you

1209
00:57:57,970 --> 00:58:01,180
simply need to passively capture the

1210
00:57:59,440 --> 00:58:04,089
handshake and then you can do all the

1211
00:58:01,180 --> 00:58:05,970
attacks but with WP 3 this is still a

1212
00:58:04,089 --> 00:58:08,609
lot harder to do

1213
00:58:05,970 --> 00:58:12,598
on top of that because we were early and

1214
00:58:08,609 --> 00:58:15,680
finding these flaws my expectation is

1215
00:58:12,599 --> 00:58:19,170
that a lot of vendors will match this

1216
00:58:15,680 --> 00:58:20,879
these flaws and that as an adversary it

1217
00:58:19,170 --> 00:58:23,339
won't make sense to invest a lot of time

1218
00:58:20,880 --> 00:58:26,369
to make these attacks practical so my

1219
00:58:23,339 --> 00:58:28,890
hunch is that this dictionary on

1220
00:58:26,369 --> 00:58:33,540
brute-force attacks hopefully they won't

1221
00:58:28,890 --> 00:58:36,150
be applicable in real life so that leads

1222
00:58:33,540 --> 00:58:38,250
to my conclusion essentially the first

1223
00:58:36,150 --> 00:58:41,430
version of WPA 3 was vulnerable to

1224
00:58:38,250 --> 00:58:43,530
seishun attacks the countermeasures are

1225
00:58:41,430 --> 00:58:45,328
quite costly on tedious to implement

1226
00:58:43,530 --> 00:58:48,240
that's why the standard is now being

1227
00:58:45,329 --> 00:58:50,940
updated but even with this remember that

1228
00:58:48,240 --> 00:58:53,250
WPA 3 is at least for now still better

1229
00:58:50,940 --> 00:58:57,150
than WPA 2 so if you have the chance to

1230
00:58:53,250 --> 00:58:58,660
switch to WPA 3 so with that thank you

1231
00:58:57,150 --> 00:59:10,469
for your attention

1232
00:58:58,660 --> 00:59:10,469
[Applause]

1233
00:59:11,229 --> 00:59:17,189
are there any questions

1234
00:59:14,619 --> 00:59:17,190
yeah

1235
00:59:20,910 --> 00:59:26,180
I think there's one question

1236
00:59:31,740 --> 00:59:38,240
[Music]

1237
00:59:33,500 --> 00:59:40,790
I take a full talk I mean so saying the

1238
00:59:38,240 --> 00:59:42,618
standard is being updated but you

1239
00:59:40,790 --> 00:59:44,480
mentioned that the manufacturers don't

1240
00:59:42,619 --> 00:59:47,240
respect the standards in the

1241
00:59:44,480 --> 00:59:49,869
implementation of the thing that will

1242
00:59:47,240 --> 00:59:49,868
work in the future

1243
00:59:51,700 --> 00:59:57,169
so most vendors I mean they do have to

1244
00:59:55,670 --> 01:00:02,960
respect the standards in order to be

1245
00:59:57,170 --> 01:00:04,760
compliant so right now I think most

1246
01:00:02,960 --> 01:00:08,780
vendors are following the standard as

1247
01:00:04,760 --> 01:00:12,349
best as they can actually I think the

1248
01:00:08,780 --> 01:00:16,340
main so I don't know how vendors will

1249
01:00:12,349 --> 01:00:19,820
react I do believe that most vendors

1250
01:00:16,340 --> 01:00:22,010
will implement these defenses and the

1251
01:00:19,820 --> 01:00:24,680
reason why is because the algorithm that

1252
01:00:22,010 --> 01:00:26,300
is used there is much more efficient so

1253
01:00:24,680 --> 01:00:27,950
here we had this implement we had this

1254
01:00:26,300 --> 01:00:30,470
defense where you had to execute a

1255
01:00:27,950 --> 01:00:31,609
variable amount of iterations and if you

1256
01:00:30,470 --> 01:00:34,759
implement the defense you have to

1257
01:00:31,609 --> 01:00:36,890
perform 40 iterations this update to the

1258
01:00:34,760 --> 01:00:39,830
stander is actually much more efficient

1259
01:00:36,890 --> 01:00:41,750
meaning there's a good motivation for

1260
01:00:39,830 --> 01:00:44,359
vendors to switch to it because it means

1261
01:00:41,750 --> 01:00:48,230
it's uses less resources it would save

1262
01:00:44,359 --> 01:00:50,589
on your battery life and so on that's

1263
01:00:48,230 --> 01:00:50,589
not the question

1264
01:00:52,589 --> 01:00:57,090
okay cool thank you everybody thank you

1265
01:00:56,080 --> 01:01:05,098
sir

1266
01:00:57,090 --> 01:01:05,099
[Applause]

