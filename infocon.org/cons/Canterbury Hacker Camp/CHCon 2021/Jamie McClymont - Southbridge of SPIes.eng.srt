1
00:00:05,839 --> 00:00:07,520
hey um

2
00:00:07,520 --> 00:00:09,760
early last year i bought a laptop and

3
00:00:09,760 --> 00:00:11,759
specifically i bought this laptop this

4
00:00:11,759 --> 00:00:14,799
is a huawei matebook pro

5
00:00:14,799 --> 00:00:17,119
it's very cheap and it has acceptable

6
00:00:17,119 --> 00:00:18,800
specs for the price

7
00:00:18,800 --> 00:00:20,480
um

8
00:00:20,480 --> 00:00:23,760
no it's not playing the the webcam pops

9
00:00:23,760 --> 00:00:25,519
out from between the f6 and f7 keys

10
00:00:25,519 --> 00:00:26,560
which is

11
00:00:26,560 --> 00:00:28,000
a incredibly cool gimmick and the main

12
00:00:28,000 --> 00:00:31,359
reason i bought it

13
00:00:31,359 --> 00:00:32,800
there were no speaker notes on my screen

14
00:00:32,800 --> 00:00:35,360
hold on sorry

15
00:00:35,360 --> 00:00:36,880
another way

16
00:00:36,880 --> 00:00:38,960
everything on it worked when i installed

17
00:00:38,960 --> 00:00:40,800
linux on the first day

18
00:00:40,800 --> 00:00:42,239
because it's 2020. that's how things

19
00:00:42,239 --> 00:00:44,160
work now except for the fingerprint

20
00:00:44,160 --> 00:00:46,000
sensor in the power button there was a

21
00:00:46,000 --> 00:00:47,440
fingerprint sensor which is really

22
00:00:47,440 --> 00:00:48,960
convenient for the five minutes i had

23
00:00:48,960 --> 00:00:50,640
windows on it you can

24
00:00:50,640 --> 00:00:52,320
unlock windows and it's fast and you

25
00:00:52,320 --> 00:00:54,160
don't type in your password

26
00:00:54,160 --> 00:00:55,520
um and i wanted to know why it didn't

27
00:00:55,520 --> 00:00:57,440
work and i wanted to make it work so we

28
00:00:57,440 --> 00:00:58,640
need to talk a little bit about the

29
00:00:58,640 --> 00:01:01,199
history of fingerprint sensor technology

30
00:01:01,199 --> 00:01:04,879
this is oh okay now it works

31
00:01:04,879 --> 00:01:06,880
this is the battle days

32
00:01:06,880 --> 00:01:08,640
this is the ibm flink pad and it has an

33
00:01:08,640 --> 00:01:10,640
optical fingerprint sensor

34
00:01:10,640 --> 00:01:13,119
unlike unlike the modern ones it's it it

35
00:01:13,119 --> 00:01:14,960
works like the arm of a photocopier that

36
00:01:14,960 --> 00:01:17,119
moves along under a piece of paper so

37
00:01:17,119 --> 00:01:19,040
you scan your finger down it slowly and

38
00:01:19,040 --> 00:01:20,240
it pieces together an image of the

39
00:01:20,240 --> 00:01:22,000
fingerprint like that

40
00:01:22,000 --> 00:01:23,600
and they're pretty unreliable and pretty

41
00:01:23,600 --> 00:01:25,280
slow you have to get the scanning speed

42
00:01:25,280 --> 00:01:27,360
exactly right

43
00:01:27,360 --> 00:01:29,439
and these only ever really

44
00:01:29,439 --> 00:01:31,600
were popular in business model laptops

45
00:01:31,600 --> 00:01:33,360
they never they never came into consumer

46
00:01:33,360 --> 00:01:34,799
devices

47
00:01:34,799 --> 00:01:38,079
but they had very good linux support

48
00:01:38,079 --> 00:01:38,960
there was

49
00:01:38,960 --> 00:01:39,680
the

50
00:01:39,680 --> 00:01:41,200
think finger was the original project

51
00:01:41,200 --> 00:01:42,880
and then libya print

52
00:01:42,880 --> 00:01:45,119
um which which made these work really

53
00:01:45,119 --> 00:01:46,560
well it just plugs into pam and

54
00:01:46,560 --> 00:01:48,159
everything is great

55
00:01:48,159 --> 00:01:50,799
and in 2013 apple introduced the iphone

56
00:01:50,799 --> 00:01:52,399
5s

57
00:01:52,399 --> 00:01:54,320
and this had a new type of fingerprint

58
00:01:54,320 --> 00:01:56,399
sensor this is a capacitive fingerprint

59
00:01:56,399 --> 00:01:57,439
sensor

60
00:01:57,439 --> 00:01:59,920
um so it the the scanning technology is

61
00:01:59,920 --> 00:02:01,600
the same as a multi-touch touchscreen

62
00:02:01,600 --> 00:02:03,360
just made really small the same way it

63
00:02:03,360 --> 00:02:05,040
senses where all your fingers are it's

64
00:02:05,040 --> 00:02:07,119
the same scanner it's just sensing where

65
00:02:07,119 --> 00:02:09,919
all the ridges of your finger are

66
00:02:09,919 --> 00:02:12,480
and this this capacitive sensor is much

67
00:02:12,480 --> 00:02:14,000
more convenient it's much faster you

68
00:02:14,000 --> 00:02:15,280
don't need to swipe your finger at the

69
00:02:15,280 --> 00:02:17,120
right speed

70
00:02:17,120 --> 00:02:20,640
um and so it was quite popular and it

71
00:02:20,640 --> 00:02:22,480
it was it was good in the iphone and it

72
00:02:22,480 --> 00:02:24,000
made its way into android phones and

73
00:02:24,000 --> 00:02:26,319
then into laptops and this time not just

74
00:02:26,319 --> 00:02:28,160
the high-end business laptops it made

75
00:02:28,160 --> 00:02:31,040
its way into consumer laptop models

76
00:02:31,040 --> 00:02:32,800
but these sensors

77
00:02:32,800 --> 00:02:34,800
never really ended up being supported on

78
00:02:34,800 --> 00:02:36,800
linux despite a lot of people online

79
00:02:36,800 --> 00:02:38,319
saying hey i'd love to be able to use

80
00:02:38,319 --> 00:02:40,640
this can anyone make a driver

81
00:02:40,640 --> 00:02:42,879
it just never happened and i um the

82
00:02:42,879 --> 00:02:44,720
reason for that is kind of hidden on

83
00:02:44,720 --> 00:02:45,519
this

84
00:02:45,519 --> 00:02:47,360
apple announcement page

85
00:02:47,360 --> 00:02:49,040
where it says your fingerprint can also

86
00:02:49,040 --> 00:02:50,720
approve purchases from the itunes store

87
00:02:50,720 --> 00:02:52,319
the app store and the ibook store so you

88
00:02:52,319 --> 00:02:54,800
don't have to enter your password

89
00:02:54,800 --> 00:02:57,200
and if you used ios before this

90
00:02:57,200 --> 00:02:58,560
and you think about it it's kind of

91
00:02:58,560 --> 00:03:00,640
weird right because you used to have to

92
00:03:00,640 --> 00:03:02,000
enter your apple account password to

93
00:03:02,000 --> 00:03:03,440
make a purchase you're authenticating

94
00:03:03,440 --> 00:03:05,200
with apple's servers

95
00:03:05,200 --> 00:03:07,440
to you know use your payment information

96
00:03:07,440 --> 00:03:08,879
you're not just typing in your phone pin

97
00:03:08,879 --> 00:03:09,760
code

98
00:03:09,760 --> 00:03:12,720
so to be able to do this authentication

99
00:03:12,720 --> 00:03:14,319
how are they implementing that there's a

100
00:03:14,319 --> 00:03:15,920
few there's a few approaches they could

101
00:03:15,920 --> 00:03:18,000
just trust the phone when it says yeah i

102
00:03:18,000 --> 00:03:19,920
just scan the fingerprint i've unlocked

103
00:03:19,920 --> 00:03:21,440
the unlock the payment information but

104
00:03:21,440 --> 00:03:23,599
that's probably not a great approach you

105
00:03:23,599 --> 00:03:25,760
lose the you lose the security boundary

106
00:03:25,760 --> 00:03:28,159
that's in place here

107
00:03:28,159 --> 00:03:30,400
you could do what is arguably the

108
00:03:30,400 --> 00:03:32,159
equivalent of the password model where

109
00:03:32,159 --> 00:03:34,159
you just send a picture you scan the

110
00:03:34,159 --> 00:03:35,440
fingerprint and it gets the picture of

111
00:03:35,440 --> 00:03:36,560
your fingerprint and it sends it to

112
00:03:36,560 --> 00:03:38,640
apple service and apple's servers would

113
00:03:38,640 --> 00:03:40,400
have all of your finger everyone's

114
00:03:40,400 --> 00:03:42,080
fingerprint in a database

115
00:03:42,080 --> 00:03:43,840
and they would match it against that

116
00:03:43,840 --> 00:03:46,000
but that doesn't work very well because

117
00:03:46,000 --> 00:03:48,640
of this situation right

118
00:03:48,640 --> 00:03:50,799
when apple's servers are hacked or the

119
00:03:50,799 --> 00:03:51,520
servers of some

120
00:03:51,520 --> 00:03:52,799
[Music]

121
00:03:52,799 --> 00:03:55,360
website with even worse security

122
00:03:55,360 --> 00:03:57,439
the the step three on have it's been

123
00:03:57,439 --> 00:03:59,120
prone needs to be modified because you

124
00:03:59,120 --> 00:04:02,000
can't you can't rotate this credential

125
00:04:02,000 --> 00:04:03,599
you can't just change your password

126
00:04:03,599 --> 00:04:05,840
right

127
00:04:07,920 --> 00:04:10,000
so having having everyone's training

128
00:04:10,000 --> 00:04:11,760
appearance on apple servers is a bad

129
00:04:11,760 --> 00:04:14,640
idea and ideally given that you can

130
00:04:14,640 --> 00:04:16,560
never rotate this in your entire life

131
00:04:16,560 --> 00:04:19,120
and malware exists and people run

132
00:04:19,120 --> 00:04:20,720
malicious code

133
00:04:20,720 --> 00:04:22,560
ideally i wouldn't actually have a

134
00:04:22,560 --> 00:04:24,320
picture of my fingerprints stored in my

135
00:04:24,320 --> 00:04:25,360
phone

136
00:04:25,360 --> 00:04:27,600
right like ios jailbreaks exist the

137
00:04:27,600 --> 00:04:29,199
vulnerabilities that enable them exist

138
00:04:29,199 --> 00:04:30,720
so if someone can get my fingerprint

139
00:04:30,720 --> 00:04:31,759
with that

140
00:04:31,759 --> 00:04:33,440
then again i can never rotate this

141
00:04:33,440 --> 00:04:35,840
credential and that's pretty annoying

142
00:04:35,840 --> 00:04:37,360
so there's a third way to implement this

143
00:04:37,360 --> 00:04:38,800
and this is what apple did with the with

144
00:04:38,800 --> 00:04:40,720
the iphone um which is called a secure

145
00:04:40,720 --> 00:04:42,560
enclave

146
00:04:42,560 --> 00:04:44,160
and so this is a separate chip off to

147
00:04:44,160 --> 00:04:45,840
the side of the main

148
00:04:45,840 --> 00:04:48,560
main iphone cpu which

149
00:04:48,560 --> 00:04:50,560
it it has its own storage where it keeps

150
00:04:50,560 --> 00:04:53,440
the fingerprint image and and

151
00:04:53,440 --> 00:04:55,759
it only runs

152
00:04:55,759 --> 00:04:57,680
trusted signed code with a very small

153
00:04:57,680 --> 00:04:59,440
attack surface and that code will read

154
00:04:59,440 --> 00:05:00,720
images from the fingerprint sensor which

155
00:05:00,720 --> 00:05:02,720
it's connected to it'll check it against

156
00:05:02,720 --> 00:05:04,160
the image that's in its own storage that

157
00:05:04,160 --> 00:05:06,320
ios can't read and if it likes what it

158
00:05:06,320 --> 00:05:07,919
sees it'll sign what's called an

159
00:05:07,919 --> 00:05:09,680
attestation using a private key that's

160
00:05:09,680 --> 00:05:11,759
also only it can read

161
00:05:11,759 --> 00:05:14,080
um and the status station is just a a a

162
00:05:14,080 --> 00:05:16,080
signed bit of information that says yep

163
00:05:16,080 --> 00:05:19,199
i just scan the fingerprint it matches

164
00:05:19,199 --> 00:05:20,720
and they can get sent to the phone which

165
00:05:20,720 --> 00:05:22,240
can verify okay cool i just saw

166
00:05:22,240 --> 00:05:24,000
fingerprint unlock the os but more

167
00:05:24,000 --> 00:05:25,840
importantly you can send that to apple

168
00:05:25,840 --> 00:05:27,440
and you can send it to any other website

169
00:05:27,440 --> 00:05:29,280
to say yep i just scanned i just

170
00:05:29,280 --> 00:05:31,280
verified this biometric

171
00:05:31,280 --> 00:05:33,520
biometric identity thing

172
00:05:33,520 --> 00:05:35,120
i mean so this model works really well

173
00:05:35,120 --> 00:05:37,280
and when it came to laptops microsoft

174
00:05:37,280 --> 00:05:39,440
encouraged the laptop manufacturers to

175
00:05:39,440 --> 00:05:41,120
to bring

176
00:05:41,120 --> 00:05:42,960
bring the secure enclave model as well

177
00:05:42,960 --> 00:05:45,199
as the capacitive sensors and this is

178
00:05:45,199 --> 00:05:46,800
they call it windows hello in in

179
00:05:46,800 --> 00:05:48,720
microsoft land

180
00:05:48,720 --> 00:05:50,400
um and you can use it not only to unlock

181
00:05:50,400 --> 00:05:51,759
windows but also to unlock your

182
00:05:51,759 --> 00:05:53,919
bitlocker keys using the secure enclave

183
00:05:53,919 --> 00:05:57,359
and to log into azure ad

184
00:05:57,440 --> 00:05:59,360
but it's a bit more complex than the

185
00:05:59,360 --> 00:06:01,840
model i just laid out sgx which is the

186
00:06:01,840 --> 00:06:04,639
secure enclave on intel cpus isn't some

187
00:06:04,639 --> 00:06:05,919
chip off to the side that's plugged into

188
00:06:05,919 --> 00:06:07,199
the fingerprint sensor and has its own

189
00:06:07,199 --> 00:06:09,280
storage it's an execution mode of the

190
00:06:09,280 --> 00:06:11,440
main cpu

191
00:06:11,440 --> 00:06:12,240
which

192
00:06:12,240 --> 00:06:14,160
can run code that's signed by intel and

193
00:06:14,160 --> 00:06:15,759
if the if the code is correctly signed

194
00:06:15,759 --> 00:06:17,199
then it can access

195
00:06:17,199 --> 00:06:19,360
special storage that only sgx applets

196
00:06:19,360 --> 00:06:21,120
can read so that's where they keep the

197
00:06:21,120 --> 00:06:22,639
fingerprint template and the private key

198
00:06:22,639 --> 00:06:24,800
for signing at the stations

199
00:06:24,800 --> 00:06:26,479
um but it doesn't talk directly to the

200
00:06:26,479 --> 00:06:28,240
fingerprint sensor it's not a windows

201
00:06:28,240 --> 00:06:29,840
driver it can't like actually talk to

202
00:06:29,840 --> 00:06:33,199
devices in the chip in the in the laptop

203
00:06:33,199 --> 00:06:36,000
so there is still a windows driver that

204
00:06:36,000 --> 00:06:37,280
talks to the fingerprint sensor but

205
00:06:37,280 --> 00:06:39,280
there needs to be some sort of secure

206
00:06:39,280 --> 00:06:42,240
tunnel between the secure enclave applet

207
00:06:42,240 --> 00:06:44,880
the sgx airplane and the microcontroller

208
00:06:44,880 --> 00:06:46,560
and the fingerprint sensor and that

209
00:06:46,560 --> 00:06:47,840
tunnel needs to be encrypted so that

210
00:06:47,840 --> 00:06:50,240
windows can't see the fingerprint images

211
00:06:50,240 --> 00:06:51,759
and it needs to be authenticated so the

212
00:06:51,759 --> 00:06:53,520
serve the sensor knows that it's talking

213
00:06:53,520 --> 00:06:56,160
to the legitimate sgx software because

214
00:06:56,160 --> 00:06:57,360
that's the only software that can be

215
00:06:57,360 --> 00:06:58,880
trusted to look at a fingerprint image

216
00:06:58,880 --> 00:07:01,199
and not leak it in this model

217
00:07:01,199 --> 00:07:03,120
so my goal in making the fingerprint

218
00:07:03,120 --> 00:07:05,199
sensor work on linux

219
00:07:05,199 --> 00:07:07,280
it's elevated from from reverse

220
00:07:07,280 --> 00:07:09,039
engineering and writing a driver for

221
00:07:09,039 --> 00:07:11,120
some hardware to

222
00:07:11,120 --> 00:07:13,599
breaking some security right because we

223
00:07:13,599 --> 00:07:15,280
need to break this model to be able to

224
00:07:15,280 --> 00:07:17,680
use it on linux to get images from the

225
00:07:17,680 --> 00:07:21,199
sensor in normal user space software

226
00:07:21,199 --> 00:07:22,720
so that's what i went into this research

227
00:07:22,720 --> 00:07:23,840
trying to do

228
00:07:23,840 --> 00:07:25,520
i'll go over this quickly because we're

229
00:07:25,520 --> 00:07:28,479
short on time the this is an acpi tab

230
00:07:28,479 --> 00:07:30,479
this is how when your operating system

231
00:07:30,479 --> 00:07:32,000
boots up it knows what devices are

232
00:07:32,000 --> 00:07:34,080
plugged into it um with the exception

233
00:07:34,080 --> 00:07:36,240
obviously of of

234
00:07:36,240 --> 00:07:38,319
you know hot pluggable devices like usb

235
00:07:38,319 --> 00:07:40,479
ones but this you can see here there's a

236
00:07:40,479 --> 00:07:42,720
serial peripheral bus which is defined

237
00:07:42,720 --> 00:07:44,639
for this gxfp which is the goodx

238
00:07:44,639 --> 00:07:47,120
fingerprint sensor um and so this is the

239
00:07:47,120 --> 00:07:50,080
the physical electrical connections that

240
00:07:50,080 --> 00:07:52,000
define a stream of bytes that the

241
00:07:52,000 --> 00:07:53,520
operating system can exchange with this

242
00:07:53,520 --> 00:07:55,599
hardware device and so it knows how to

243
00:07:55,599 --> 00:07:56,800
exchange stream of bytes with this

244
00:07:56,800 --> 00:07:58,400
device

245
00:07:58,400 --> 00:07:59,840
obviously this doesn't say anything

246
00:07:59,840 --> 00:08:01,520
about what protocol you need to speak

247
00:08:01,520 --> 00:08:02,800
over that so we still need to reverse

248
00:08:02,800 --> 00:08:04,720
engineer the windows driver to figure

249
00:08:04,720 --> 00:08:06,639
out what we actually how how to actually

250
00:08:06,639 --> 00:08:08,400
talk to it

251
00:08:08,400 --> 00:08:10,639
um so i did that i installed linux again

252
00:08:10,639 --> 00:08:12,879
so installed windows again and

253
00:08:12,879 --> 00:08:14,960
looked at the driver that got installed

254
00:08:14,960 --> 00:08:16,800
in gidva which is what i was using at

255
00:08:16,800 --> 00:08:18,560
the time before i discovered the magic

256
00:08:18,560 --> 00:08:21,360
of binary ninja

257
00:08:21,360 --> 00:08:24,000
and it's a massive dll file and it has a

258
00:08:24,000 --> 00:08:25,440
bunch of calls to logging functions

259
00:08:25,440 --> 00:08:26,639
which are really helpful because they

260
00:08:26,639 --> 00:08:28,400
all have the name of the calling

261
00:08:28,400 --> 00:08:30,000
function when it's when it's making a

262
00:08:30,000 --> 00:08:31,360
log message

263
00:08:31,360 --> 00:08:33,039
but these logs never actually got

264
00:08:33,039 --> 00:08:34,559
produced at runtime when i was using the

265
00:08:34,559 --> 00:08:36,000
fingerprint sensor so the first thing i

266
00:08:36,000 --> 00:08:38,320
did was reverse engineer how to enable

267
00:08:38,320 --> 00:08:40,159
the logging um and that was that was

268
00:08:40,159 --> 00:08:42,399
quite simple there's just a registry key

269
00:08:42,399 --> 00:08:44,080
which you care that you can flip on this

270
00:08:44,080 --> 00:08:45,600
was my first

271
00:08:45,600 --> 00:08:48,000
real binary reverse engineering project

272
00:08:48,000 --> 00:08:51,200
outside of very basic ctf challenges

273
00:08:51,200 --> 00:08:53,040
and i found that having something like

274
00:08:53,040 --> 00:08:54,959
this which is a completely

275
00:08:54,959 --> 00:08:57,680
untime constrained project where i can

276
00:08:57,680 --> 00:08:58,720
i can

277
00:08:58,720 --> 00:09:00,399
you know mess around with trying to

278
00:09:00,399 --> 00:09:01,760
understand a binary without the time

279
00:09:01,760 --> 00:09:03,680
constraints of a ctf

280
00:09:03,680 --> 00:09:05,600
is a much better way to learn binary

281
00:09:05,600 --> 00:09:08,640
reverse engineering than in a cdf i

282
00:09:08,640 --> 00:09:10,560
don't recommend that at all

283
00:09:10,560 --> 00:09:13,279
um and i i was basically useless at it

284
00:09:13,279 --> 00:09:16,399
having just done it in ctf contexts

285
00:09:16,399 --> 00:09:17,760
so yeah i can get the logs out and these

286
00:09:17,760 --> 00:09:19,360
logs have some information about what

287
00:09:19,360 --> 00:09:20,800
the driver is doing

288
00:09:20,800 --> 00:09:22,880
at runtime when it's running on windows

289
00:09:22,880 --> 00:09:24,080
um

290
00:09:24,080 --> 00:09:25,680
one thing that's useful in these logs is

291
00:09:25,680 --> 00:09:27,279
there's a little table of different

292
00:09:27,279 --> 00:09:29,440
types of message so you can see like ima

293
00:09:29,440 --> 00:09:31,519
is short for image ftt fingerprint

294
00:09:31,519 --> 00:09:33,120
detection and so we have these numbers

295
00:09:33,120 --> 00:09:34,720
but we don't have like the full messages

296
00:09:34,720 --> 00:09:36,399
that are being exchanged we don't have

297
00:09:36,399 --> 00:09:38,080
full dumps of all of the packets in and

298
00:09:38,080 --> 00:09:40,160
out of this device or bytes whatever

299
00:09:40,160 --> 00:09:41,440
they are

300
00:09:41,440 --> 00:09:42,320
um

301
00:09:42,320 --> 00:09:43,680
and so i'd like that because i'm trying

302
00:09:43,680 --> 00:09:46,320
to implement this protocol so i used x60

303
00:09:46,320 --> 00:09:48,399
40 buck i'm not a windows person and i

304
00:09:48,399 --> 00:09:51,200
chose x64 debug somewhat at random and

305
00:09:51,200 --> 00:09:53,920
it doesn't it had a lot of i had a lot

306
00:09:53,920 --> 00:09:55,279
of issues with it it seems to have a lot

307
00:09:55,279 --> 00:09:56,080
of

308
00:09:56,080 --> 00:09:57,680
undocumented limitations if there's a

309
00:09:57,680 --> 00:09:58,800
better thing i should be using please

310
00:09:58,800 --> 00:10:00,640
let me know um

311
00:10:00,640 --> 00:10:02,160
but what i can do right is once i've

312
00:10:02,160 --> 00:10:04,800
figured out the spi's universe and send

313
00:10:04,800 --> 00:10:06,959
and receive functions that just send

314
00:10:06,959 --> 00:10:08,480
messages back and forth over the stream

315
00:10:08,480 --> 00:10:09,600
of bytes

316
00:10:09,600 --> 00:10:11,120
um you can hook those with breakpoints

317
00:10:11,120 --> 00:10:12,480
in the debugger and instead of normal

318
00:10:12,480 --> 00:10:13,920
breakpoints where you just stop for

319
00:10:13,920 --> 00:10:16,240
interactive checking it out you can set

320
00:10:16,240 --> 00:10:17,839
up breakpoints that will just log you

321
00:10:17,839 --> 00:10:19,600
know the memory that's pointed to by

322
00:10:19,600 --> 00:10:21,120
this register for the length of this

323
00:10:21,120 --> 00:10:23,040
register and that'll log it into a x64

324
00:10:23,040 --> 00:10:24,880
debug log file

325
00:10:24,880 --> 00:10:26,079
and with that

326
00:10:26,079 --> 00:10:28,000
um what i decided to do and i found this

327
00:10:28,000 --> 00:10:29,680
very useful and i highly recommend it if

328
00:10:29,680 --> 00:10:30,880
you're doing any

329
00:10:30,880 --> 00:10:32,640
binary protocol reverse engineering as i

330
00:10:32,640 --> 00:10:34,720
put it into wireshark

331
00:10:34,720 --> 00:10:36,160
um you can see we've got these like i've

332
00:10:36,160 --> 00:10:40,320
got fake 1.1.1.1 and 2.2 2 udp packets

333
00:10:40,320 --> 00:10:41,680
that's not necessary but it was the

334
00:10:41,680 --> 00:10:42,880
easiest way to get it in there just

335
00:10:42,880 --> 00:10:45,279
generating a pickup file with that

336
00:10:45,279 --> 00:10:46,640
um and so you can see the stream of

337
00:10:46,640 --> 00:10:48,240
packets and all of these names are from

338
00:10:48,240 --> 00:10:49,519
a little lewis script i wrote they have

339
00:10:49,519 --> 00:10:51,920
a really simple api for writing writing

340
00:10:51,920 --> 00:10:54,079
scripts they're called dissectors um

341
00:10:54,079 --> 00:10:55,279
which will which will figure out what's

342
00:10:55,279 --> 00:10:56,640
going on in the binary protocol and

343
00:10:56,640 --> 00:10:58,320
display it like like all the standard

344
00:10:58,320 --> 00:11:00,480
protocols

345
00:11:00,480 --> 00:11:02,000
and

346
00:11:02,000 --> 00:11:03,440
especially useful about this right is

347
00:11:03,440 --> 00:11:05,279
that if you're going to be implementing

348
00:11:05,279 --> 00:11:07,760
your own version of your own

349
00:11:07,760 --> 00:11:09,279
thing that implements the same protocol

350
00:11:09,279 --> 00:11:10,720
that you're reversing once you've

351
00:11:10,720 --> 00:11:12,320
figured out the protocol

352
00:11:12,320 --> 00:11:13,839
you can run your new code through that

353
00:11:13,839 --> 00:11:15,839
and and check it against you know does

354
00:11:15,839 --> 00:11:17,279
your dissector see the right thing or is

355
00:11:17,279 --> 00:11:19,120
there a bug in your code that's that's

356
00:11:19,120 --> 00:11:21,200
that's making it wrong that's a really

357
00:11:21,200 --> 00:11:22,560
great a really good way to cross-check

358
00:11:22,560 --> 00:11:23,760
your work when you're doing this sort of

359
00:11:23,760 --> 00:11:24,800
thing

360
00:11:24,800 --> 00:11:26,720
um and so these messages are all pretty

361
00:11:26,720 --> 00:11:28,880
boring like i said these names of these

362
00:11:28,880 --> 00:11:30,480
things are just from reverse engineering

363
00:11:30,480 --> 00:11:32,399
the windows driver matching things up to

364
00:11:32,399 --> 00:11:34,000
if it's sending this then it logs i'm

365
00:11:34,000 --> 00:11:37,200
going to send a thing with this name

366
00:11:37,200 --> 00:11:38,399
so with that

367
00:11:38,399 --> 00:11:39,600
all of these things are yeah these are

368
00:11:39,600 --> 00:11:41,120
boring these are the the initial

369
00:11:41,120 --> 00:11:42,720
start-up messages when it's setting up

370
00:11:42,720 --> 00:11:44,560
the fingerprint sensor chip

371
00:11:44,560 --> 00:11:45,839
where it gets interesting is when we

372
00:11:45,839 --> 00:11:47,920
scroll down to here and we see tls 1.2

373
00:11:47,920 --> 00:11:49,760
client hello

374
00:11:49,760 --> 00:11:51,839
and this is insane

375
00:11:51,839 --> 00:11:53,600
as an industry we have been telling

376
00:11:53,600 --> 00:11:55,839
people for so long not to roll their own

377
00:11:55,839 --> 00:11:57,120
crypto right

378
00:11:57,120 --> 00:12:00,000
don't just grab aes and assume that it

379
00:12:00,000 --> 00:12:01,920
does everything you need for your

380
00:12:01,920 --> 00:12:02,880
you know

381
00:12:02,880 --> 00:12:04,480
it has all the integrity and everything

382
00:12:04,480 --> 00:12:06,560
that you need for your protocol just use

383
00:12:06,560 --> 00:12:07,360
some

384
00:12:07,360 --> 00:12:08,720
fully featured protocol that actual

385
00:12:08,720 --> 00:12:10,800
cryptographers have looked at and made

386
00:12:10,800 --> 00:12:11,920
something

387
00:12:11,920 --> 00:12:14,639
that will suit your use case and so

388
00:12:14,639 --> 00:12:16,240
we've gone too far because now there's

389
00:12:16,240 --> 00:12:18,240
tls between my cpu and my fingerprint

390
00:12:18,240 --> 00:12:21,200
sensor and my laptop

391
00:12:21,519 --> 00:12:24,160
you can see it's um it's not normal tls

392
00:12:24,160 --> 00:12:26,399
it's tlspsk it's a standard type but

393
00:12:26,399 --> 00:12:27,920
it's not what you're used to in web

394
00:12:27,920 --> 00:12:30,240
browsers so psk is short for pre-shared

395
00:12:30,240 --> 00:12:31,200
key

396
00:12:31,200 --> 00:12:32,399
that means there's just a big long

397
00:12:32,399 --> 00:12:35,600
random key that both sides know

398
00:12:35,600 --> 00:12:36,880
in advance

399
00:12:36,880 --> 00:12:39,200
and if they during the handshake process

400
00:12:39,200 --> 00:12:40,399
they can prove to each other that they

401
00:12:40,399 --> 00:12:42,560
have this key and if they do both share

402
00:12:42,560 --> 00:12:43,839
the same key then they'll set up a

403
00:12:43,839 --> 00:12:45,760
secure authenticated and encrypted

404
00:12:45,760 --> 00:12:47,760
channel between the two sites and so how

405
00:12:47,760 --> 00:12:49,440
this works in a laptop context at the

406
00:12:49,440 --> 00:12:53,200
huawei factory um the they will generate

407
00:12:53,200 --> 00:12:54,480
a big long random password for each

408
00:12:54,480 --> 00:12:55,920
laptop they will stamp that into the

409
00:12:55,920 --> 00:12:57,600
chip of the fingerprint sensor and into

410
00:12:57,600 --> 00:12:59,600
the sgx storage that the enclave can

411
00:12:59,600 --> 00:13:01,440
read and then both of those sides can

412
00:13:01,440 --> 00:13:02,800
prove to each other who they are and

413
00:13:02,800 --> 00:13:05,600
establish a secure connection

414
00:13:05,600 --> 00:13:08,480
um but like the rest of this stream all

415
00:13:08,480 --> 00:13:10,639
of the stuff in wireshark it's not it's

416
00:13:10,639 --> 00:13:12,560
not encrypted right the only other

417
00:13:12,560 --> 00:13:13,920
encrypted packet apart from the

418
00:13:13,920 --> 00:13:16,399
handshake is when you request an image

419
00:13:16,399 --> 00:13:18,959
with a clear text windows driver message

420
00:13:18,959 --> 00:13:21,040
it responds with a tls application data

421
00:13:21,040 --> 00:13:23,040
instead of just an image

422
00:13:23,040 --> 00:13:24,560
um and

423
00:13:24,560 --> 00:13:26,880
this is great because there's only only

424
00:13:26,880 --> 00:13:28,160
one packet that's encrypted only one

425
00:13:28,160 --> 00:13:29,920
packet that we that we need to figure

426
00:13:29,920 --> 00:13:31,279
out the contents of but obviously it's

427
00:13:31,279 --> 00:13:32,639
the important one right if we're writing

428
00:13:32,639 --> 00:13:33,920
a fingerprint sensor driver we need to

429
00:13:33,920 --> 00:13:36,639
get an image from the fingerprint sensor

430
00:13:36,639 --> 00:13:38,240
but we have this whole attack surface of

431
00:13:38,240 --> 00:13:39,680
commands that aren't encrypted and

432
00:13:39,680 --> 00:13:41,440
aren't authenticated more importantly

433
00:13:41,440 --> 00:13:43,680
which means we can try and attack

434
00:13:43,680 --> 00:13:45,519
something right

435
00:13:45,519 --> 00:13:47,839
because of this symmetric model with tls

436
00:13:47,839 --> 00:13:49,839
psk we could do it

437
00:13:49,839 --> 00:13:51,440
we have we have a choice for how to how

438
00:13:51,440 --> 00:13:53,120
to approach this we could attack the

439
00:13:53,120 --> 00:13:55,120
enclave side um

440
00:13:55,120 --> 00:13:57,440
because sgx is just a special operating

441
00:13:57,440 --> 00:13:59,440
mode of the main cpu

442
00:13:59,440 --> 00:14:01,360
the whole meltdown inspector family are

443
00:14:01,360 --> 00:14:03,120
applicable here

444
00:14:03,120 --> 00:14:04,720
especially since like i can downgrade

445
00:14:04,720 --> 00:14:06,560
windows and i can have i can choose to

446
00:14:06,560 --> 00:14:08,160
have worse intel microcode and things

447
00:14:08,160 --> 00:14:10,079
that don't have these patches

448
00:14:10,079 --> 00:14:12,000
um and after i did this research there

449
00:14:12,000 --> 00:14:14,079
was plundervolt which is probably even

450
00:14:14,079 --> 00:14:15,440
more useful for

451
00:14:15,440 --> 00:14:17,120
for the specific attack but that's not

452
00:14:17,120 --> 00:14:18,880
what i decided to do i decided to attack

453
00:14:18,880 --> 00:14:20,800
the firmware of the fingerprint sensor

454
00:14:20,800 --> 00:14:23,120
itself

455
00:14:24,000 --> 00:14:26,639
to get the psk um and like i said all of

456
00:14:26,639 --> 00:14:27,680
these unencrypted messages

457
00:14:27,680 --> 00:14:29,600
unauthenticated we can send these and we

458
00:14:29,600 --> 00:14:30,800
can

459
00:14:30,800 --> 00:14:33,680
we can talk to the talk to the chip and

460
00:14:33,680 --> 00:14:35,600
do whatever we need so

461
00:14:35,600 --> 00:14:37,040
specifically the one that caught my eye

462
00:14:37,040 --> 00:14:38,160
we have this table of of the

463
00:14:38,160 --> 00:14:39,519
abbreviations for the different type of

464
00:14:39,519 --> 00:14:42,959
messages is oxf up fw

465
00:14:42,959 --> 00:14:45,920
which is short for update firmware right

466
00:14:45,920 --> 00:14:47,680
we can actually the windows driver when

467
00:14:47,680 --> 00:14:49,440
it starts up it asks the chip for its

468
00:14:49,440 --> 00:14:51,199
version firmware version if it doesn't

469
00:14:51,199 --> 00:14:53,279
like what it sees it'll send it new

470
00:14:53,279 --> 00:14:55,040
firmware from a blob that's inside the

471
00:14:55,040 --> 00:14:56,079
dll

472
00:14:56,079 --> 00:14:57,360
and this blob if we just look at it

473
00:14:57,360 --> 00:14:58,959
engage where we can pull it out and it's

474
00:14:58,959 --> 00:15:02,639
a a a totally normal looking thumb

475
00:15:02,639 --> 00:15:04,639
arm assembly blob

476
00:15:04,639 --> 00:15:06,560
um we can tell from the from the

477
00:15:06,560 --> 00:15:07,920
firmware version name that it's for an

478
00:15:07,920 --> 00:15:10,079
stm32f411

479
00:15:10,079 --> 00:15:12,160
chip which is uh you know something

480
00:15:12,160 --> 00:15:13,440
where you can just get the data sheets

481
00:15:13,440 --> 00:15:14,480
and find the addresses of all the

482
00:15:14,480 --> 00:15:16,720
peripherals so i reverse engineered this

483
00:15:16,720 --> 00:15:18,320
and checked in how the firmware update

484
00:15:18,320 --> 00:15:20,000
algorithm worked and i confirmed like

485
00:15:20,000 --> 00:15:22,000
there's no tls there's no

486
00:15:22,000 --> 00:15:24,720
signatures on the firmware blob itself

487
00:15:24,720 --> 00:15:26,560
it's totally just the windows driver can

488
00:15:26,560 --> 00:15:28,720
send a firmware and

489
00:15:28,720 --> 00:15:31,600
have it be on the chip

490
00:15:31,600 --> 00:15:32,399
so

491
00:15:32,399 --> 00:15:33,839
rather than writing a whole new open

492
00:15:33,839 --> 00:15:35,120
source firmware for this fingerprint

493
00:15:35,120 --> 00:15:36,800
sensor

494
00:15:36,800 --> 00:15:39,199
what we can do is just add a back door

495
00:15:39,199 --> 00:15:40,959
to the thing to the firmware

496
00:15:40,959 --> 00:15:42,399
right we can do this which is just a

497
00:15:42,399 --> 00:15:44,079
little function that replaces the

498
00:15:44,079 --> 00:15:46,240
handlers for one of these messages

499
00:15:46,240 --> 00:15:47,680
the one that i hadn't seen used by the

500
00:15:47,680 --> 00:15:50,160
windows driver and instead of doing

501
00:15:50,160 --> 00:15:51,600
whatever fingerprint sensor stuff it's

502
00:15:51,600 --> 00:15:52,880
supposed to do it's just an arbitrary

503
00:15:52,880 --> 00:15:54,800
read primitive if i want it to have a

504
00:15:54,800 --> 00:15:56,480
vulnerability i can just

505
00:15:56,480 --> 00:15:57,519
write some code that is the

506
00:15:57,519 --> 00:15:59,600
vulnerability and take this compile this

507
00:15:59,600 --> 00:16:01,440
with the right gcc object copy out just

508
00:16:01,440 --> 00:16:02,959
this one function

509
00:16:02,959 --> 00:16:04,320
put it on the end of the firmware with

510
00:16:04,320 --> 00:16:06,880
the right alignment and then edit hex

511
00:16:06,880 --> 00:16:08,560
edit the address for the for the handler

512
00:16:08,560 --> 00:16:10,639
function for this type of command

513
00:16:10,639 --> 00:16:12,240
and hook the windows driver in the

514
00:16:12,240 --> 00:16:14,320
debugger to make it upload alphabet

515
00:16:14,320 --> 00:16:16,720
instead of the original firmware

516
00:16:16,720 --> 00:16:19,199
um and this works right once you up once

517
00:16:19,199 --> 00:16:20,560
you upload this custom firmware i can

518
00:16:20,560 --> 00:16:22,720
send messages asking for an address i

519
00:16:22,720 --> 00:16:24,320
want the memory at and i know the

520
00:16:24,320 --> 00:16:25,680
address that the psk should be from

521
00:16:25,680 --> 00:16:27,120
reverse engineering

522
00:16:27,120 --> 00:16:28,800
so we can get the psk out

523
00:16:28,800 --> 00:16:32,240
and that's the psk for my laptop

524
00:16:32,240 --> 00:16:34,240
if they're doing things right then

525
00:16:34,240 --> 00:16:36,079
it's a completely random psk and this is

526
00:16:36,079 --> 00:16:37,600
different to all other laptops i haven't

527
00:16:37,600 --> 00:16:40,399
checked i achieved that success

528
00:16:40,399 --> 00:16:42,639
um but because this is standard tls psk

529
00:16:42,639 --> 00:16:44,079
we can just put it into wireshark press

530
00:16:44,079 --> 00:16:46,480
your keybox and in the tls settings and

531
00:16:46,480 --> 00:16:48,399
decrypt the stuff so where we used to

532
00:16:48,399 --> 00:16:49,680
have application data when we were

533
00:16:49,680 --> 00:16:51,519
getting an image then now we have an

534
00:16:51,519 --> 00:16:53,440
image data

535
00:16:53,440 --> 00:16:55,120
and this is really cool we get this big

536
00:16:55,120 --> 00:16:56,959
blob of bytes which from the windows

537
00:16:56,959 --> 00:16:58,959
driver i can see and from looking at it

538
00:16:58,959 --> 00:17:01,600
i can see it's just a raw bitmap

539
00:17:01,600 --> 00:17:03,199
and we can plot that bitmap and it looks

540
00:17:03,199 --> 00:17:04,959
like this

541
00:17:04,959 --> 00:17:07,119
and if you've ever seen my finger

542
00:17:07,119 --> 00:17:08,640
you'll know that it doesn't really look

543
00:17:08,640 --> 00:17:11,039
like this

544
00:17:12,400 --> 00:17:14,480
and i scratched my head and i i went

545
00:17:14,480 --> 00:17:16,240
back and i reverse engineered the the

546
00:17:16,240 --> 00:17:17,760
bitmap unpacking algorithm from the

547
00:17:17,760 --> 00:17:20,240
windows driver and i i decided there was

548
00:17:20,240 --> 00:17:21,679
something wrong there so i looked at the

549
00:17:21,679 --> 00:17:23,520
packing algorithm in the in the firmware

550
00:17:23,520 --> 00:17:25,199
because you know i've got both copies of

551
00:17:25,199 --> 00:17:26,160
this

552
00:17:26,160 --> 00:17:28,400
um and there was actually a gauge bug

553
00:17:28,400 --> 00:17:29,840
which was slightly affecting things but

554
00:17:29,840 --> 00:17:31,520
but even so after after getting past

555
00:17:31,520 --> 00:17:33,520
that this is what i have um and then i

556
00:17:33,520 --> 00:17:34,720
remembered that i got to put my finger

557
00:17:34,720 --> 00:17:37,520
on it um so when you put your finger on

558
00:17:37,520 --> 00:17:38,880
it it looks like this

559
00:17:38,880 --> 00:17:40,160
uh where you can see the fingerprint

560
00:17:40,160 --> 00:17:41,760
this isn't my fingerprint right i'm not

561
00:17:41,760 --> 00:17:43,760
projecting that it's it's from my palm

562
00:17:43,760 --> 00:17:45,440
wrinkles further down

563
00:17:45,440 --> 00:17:47,360
but it's the same idea it's still a bit

564
00:17:47,360 --> 00:17:48,720
messy though but we've still got these

565
00:17:48,720 --> 00:17:50,160
horizontal lines that you could see in

566
00:17:50,160 --> 00:17:52,400
the original picture and these are sort

567
00:17:52,400 --> 00:17:53,840
of

568
00:17:53,840 --> 00:17:55,200
due to the the construction of the

569
00:17:55,200 --> 00:17:56,880
fingerprint sensor itself

570
00:17:56,880 --> 00:17:58,320
um

571
00:17:58,320 --> 00:17:59,840
they're just it has it has these good

572
00:17:59,840 --> 00:18:01,280
lines and this gradient across the whole

573
00:18:01,280 --> 00:18:03,200
thing but what the windows driver does

574
00:18:03,200 --> 00:18:05,200
and what we can replicate is it takes a

575
00:18:05,200 --> 00:18:06,640
picture from the fingerprint so it's

576
00:18:06,640 --> 00:18:08,559
startup and then when it actually wants

577
00:18:08,559 --> 00:18:10,240
a fingerprint image it gets there and it

578
00:18:10,240 --> 00:18:11,679
subtracts out the original image to get

579
00:18:11,679 --> 00:18:15,280
a much clearer picture

580
00:18:15,280 --> 00:18:17,840
and then what

581
00:18:18,160 --> 00:18:21,039
i have done all this research with the

582
00:18:21,039 --> 00:18:23,210
goal of making a linux driver that will

583
00:18:23,210 --> 00:18:24,320
[Music]

584
00:18:24,320 --> 00:18:25,280
that will

585
00:18:25,280 --> 00:18:26,960
make it really easy you just install

586
00:18:26,960 --> 00:18:28,480
linux on this laptop on your first day

587
00:18:28,480 --> 00:18:31,440
that you have it and

588
00:18:31,440 --> 00:18:32,880
it set up the figure printing so it all

589
00:18:32,880 --> 00:18:34,799
works really easily like it does on

590
00:18:34,799 --> 00:18:36,160
windows

591
00:18:36,160 --> 00:18:38,720
but in doing this research i've realized

592
00:18:38,720 --> 00:18:39,679
that

593
00:18:39,679 --> 00:18:41,760
i actually quite like the security model

594
00:18:41,760 --> 00:18:43,360
that i've just broken

595
00:18:43,360 --> 00:18:46,080
right i don't i don't necessarily want

596
00:18:46,080 --> 00:18:48,000
to make foot guns

597
00:18:48,000 --> 00:18:50,240
i don't want to make

598
00:18:50,240 --> 00:18:52,400
just build into the standard fingerprint

599
00:18:52,400 --> 00:18:55,360
sensor libraries the ability to

600
00:18:55,360 --> 00:18:56,960
easily without thinking through what

601
00:18:56,960 --> 00:18:58,400
you're doing

602
00:18:58,400 --> 00:18:59,760
have

603
00:18:59,760 --> 00:19:01,440
your fingerprint image stored on your

604
00:19:01,440 --> 00:19:03,760
laptop where if it gets hacked the

605
00:19:03,760 --> 00:19:07,200
credential is permanently compromised

606
00:19:07,200 --> 00:19:10,559
so i didn't end up i i do have a

607
00:19:10,559 --> 00:19:12,080
most of a linux driver i can get

608
00:19:12,080 --> 00:19:14,559
fingerprint images from from linux um i

609
00:19:14,559 --> 00:19:16,640
haven't fully integrated it into live

610
00:19:16,640 --> 00:19:18,720
effect and i'm not going to because i

611
00:19:18,720 --> 00:19:20,320
don't really think i want to put that

612
00:19:20,320 --> 00:19:22,160
out into the world i don't

613
00:19:22,160 --> 00:19:23,360
i don't actually want to have my

614
00:19:23,360 --> 00:19:24,400
fingerprint on my laptop now i've

615
00:19:24,400 --> 00:19:27,200
thought about this more

616
00:19:28,400 --> 00:19:29,919
um

617
00:19:29,919 --> 00:19:31,120
but i think

618
00:19:31,120 --> 00:19:33,440
in the process of doing this i stumbled

619
00:19:33,440 --> 00:19:34,880
upon something more interesting which is

620
00:19:34,880 --> 00:19:36,400
the idea of firmware implants in the

621
00:19:36,400 --> 00:19:38,799
fingerprint sensor right because when i

622
00:19:38,799 --> 00:19:41,200
uploaded this new firmware to the sensor

623
00:19:41,200 --> 00:19:43,200
everything still works i had it

624
00:19:43,200 --> 00:19:44,960
registered in windows and it still was

625
00:19:44,960 --> 00:19:46,559
registered in windows and i could still

626
00:19:46,559 --> 00:19:49,360
unlock bitlocker and unlock windows and

627
00:19:49,360 --> 00:19:52,400
if i had it set up log into azure id

628
00:19:52,400 --> 00:19:54,160
and so this raises interesting

629
00:19:54,160 --> 00:19:56,000
possibilities for evil mate attacks

630
00:19:56,000 --> 00:19:57,039
right

631
00:19:57,039 --> 00:19:58,640
i don't you don't because you don't need

632
00:19:58,640 --> 00:19:59,760
to negotiate to your lease you don't

633
00:19:59,760 --> 00:20:01,280
need to prove you have the psk to upload

634
00:20:01,280 --> 00:20:03,840
the firmware you can just come up to a

635
00:20:03,840 --> 00:20:05,120
laptop

636
00:20:05,120 --> 00:20:07,039
boot linux from a live usb even if it's

637
00:20:07,039 --> 00:20:09,440
got you know an encrypted disk for on

638
00:20:09,440 --> 00:20:11,280
the main main operating system builders

639
00:20:11,280 --> 00:20:13,200
from a live usb in 20 seconds or

640
00:20:13,200 --> 00:20:15,440
whatever you can have a backdoor

641
00:20:15,440 --> 00:20:17,520
firmware on your target's fingerprint

642
00:20:17,520 --> 00:20:18,480
sensor

643
00:20:18,480 --> 00:20:19,919
and that firmware instead of just

644
00:20:19,919 --> 00:20:22,240
reading out the psk it could save and

645
00:20:22,240 --> 00:20:23,840
replay fingerprints

646
00:20:23,840 --> 00:20:26,000
so when somebody

647
00:20:26,000 --> 00:20:27,520
comes up to the laptop and scans their

648
00:20:27,520 --> 00:20:29,280
finger and then goes away and you come

649
00:20:29,280 --> 00:20:31,520
back you can do some special combination

650
00:20:31,520 --> 00:20:33,440
of taps and it'll replay the last good

651
00:20:33,440 --> 00:20:34,640
fingerprint

652
00:20:34,640 --> 00:20:36,720
two windows using this trusted channel

653
00:20:36,720 --> 00:20:39,440
and unlock their bitlocker windows azure

654
00:20:39,440 --> 00:20:40,240
id

655
00:20:40,240 --> 00:20:41,919
or if ever made attacks are out of the

656
00:20:41,919 --> 00:20:44,159
question this still means that if you

657
00:20:44,159 --> 00:20:46,559
have code exec then you can exfiltrate

658
00:20:46,559 --> 00:20:49,360
the fingerprint image and access other

659
00:20:49,360 --> 00:20:51,200
systems that use fingerprint

660
00:20:51,200 --> 00:20:52,799
authentication or see what crime scenes

661
00:20:52,799 --> 00:20:55,440
someone was at

662
00:20:55,520 --> 00:20:57,360
and that's

663
00:20:57,360 --> 00:21:00,080
the end of of of what i did right i i

664
00:21:00,080 --> 00:21:01,600
think there's some interesting questions

665
00:21:01,600 --> 00:21:02,960
there but

666
00:21:02,960 --> 00:21:05,039
i decided not to not to finish writing

667
00:21:05,039 --> 00:21:06,720
the linux driver

668
00:21:06,720 --> 00:21:09,090
so that's my time thank you

669
00:21:09,090 --> 00:21:17,270
[Applause]

670
00:21:19,200 --> 00:21:21,280
you

