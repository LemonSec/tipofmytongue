1
00:00:00,000 --> 00:00:06,759
thanks for having me here hopefully give
you the overview you're looking for and

2
00:00:06,759 --> 00:00:10,960
everything so this presentations a
little bit about this open source

3
00:00:10,960 --> 00:00:15,450
hardware project I've been working on
its almost the total opposite of his

4
00:00:15,450 --> 00:00:20,009
project because rather than securing us
it's trying to break security devices so

5
00:00:20,010 --> 00:00:24,000
you know you need both this is what
you'll see so hopefully you're not sick

6
00:00:24,000 --> 00:00:29,650
of hardware and math because this is
also in my presentation too so I'm from

7
00:00:29,650 --> 00:00:35,460
halifax Nova Scotia Canada and I'm
almost done a PhD at Dalhousie

8
00:00:35,460 --> 00:00:39,430
University there as part of that I
developed this open source hardware and

9
00:00:39,430 --> 00:00:43,550
have been spinning up the company
basically trying to sell the hardware if

10
00:00:43,550 --> 00:00:47,370
anyone has done the PhD and then started
doing something else you know this last

11
00:00:47,370 --> 00:00:53,010
step takes awhile because you get so
distracted so that's really what are we

12
00:00:53,010 --> 00:00:57,218
doing here I want to show you
fundamentally a type of physical attack

13
00:00:57,219 --> 00:01:02,440
you can use on hardware and when I say
hardware I'm really thinking and stuff

14
00:01:02,440 --> 00:01:07,509
like embedded devices chip and pin
credit cards you know little Internet of

15
00:01:07,510 --> 00:01:11,140
Things devices village also applicable
to mobile phone's hardware security

16
00:01:11,140 --> 00:01:15,979
modules all sorts of hard work even up
to PCs some people have applied these

17
00:01:15,979 --> 00:01:20,840
attacks these attacks have been known
for a long time but I'm showing you how

18
00:01:20,840 --> 00:01:26,189
to do them with open source hardware and
software as well as fully documented so

19
00:01:26,189 --> 00:01:29,658
this is sort of the real difference from
previous presentations you might have

20
00:01:29,659 --> 00:01:34,680
seen is that a lot of these techniques
and tools you can just download it and

21
00:01:34,680 --> 00:01:38,220
use you might already have an
oscilloscope you can use with them or

22
00:01:38,220 --> 00:01:43,420
you might need some low-cost hardware
build your own hardware so the open

23
00:01:43,420 --> 00:01:47,079
source tools on chip was for.com if
you're interested although get repose

24
00:01:47,079 --> 00:01:48,570
and everything over there

25
00:01:48,570 --> 00:01:54,258
the websites of the company's new 80.com
so that has some other details of the

26
00:01:54,259 --> 00:01:59,710
tools and I also have a website at
fling.com which has my blog on various

27
00:01:59,710 --> 00:02:04,229
things I've done with the project and
related topics so all these links will

28
00:02:04,229 --> 00:02:06,440
be at the end and these slides are
posted on the

29
00:02:06,440 --> 00:02:12,410
line as well so you can you get all the
links in here so I'm gonna give you the

30
00:02:12,410 --> 00:02:17,780
one caveat to this presentation I always
give is that everyone wants the sausage

31
00:02:17,780 --> 00:02:22,620
everyone wants the you know the awesome
attack that you put your hardware on the

32
00:02:22,620 --> 00:02:27,540
table and you plug it into the magic
device and it just works it's impossible

33
00:02:27,540 --> 00:02:33,239
for the attacks I'm talking about
fundamental you have to understand how

34
00:02:33,240 --> 00:02:38,440
it works how both be harder to raise
your attacking is made what the

35
00:02:38,440 --> 00:02:43,570
underlying algorithms using some details
of how it's implemented even and you

36
00:02:43,570 --> 00:02:47,019
have to use that and then apply these
attacks are you need to know how it's

37
00:02:47,020 --> 00:02:52,440
made before you can get to this stage so
that's the other caveat I give you and

38
00:02:52,440 --> 00:02:56,270
as part of that I'm going to be giving
you know some really quick overview of

39
00:02:56,270 --> 00:03:00,750
the math involved in these attacks but
also you as you realize I live attacks

40
00:03:00,750 --> 00:03:06,290
as well to show its not as difficult as
you might think at first as well as I

41
00:03:06,290 --> 00:03:10,690
mentioned I'm doing a few she that's my
blog thereof lynda.com I previously

42
00:03:10,690 --> 00:03:15,579
worked at Mels and serving bedded
engineer doing a lot of Internet of

43
00:03:15,580 --> 00:03:20,800
Things critical so obviously I hate
Internet of Things devices now having

44
00:03:20,800 --> 00:03:26,780
spent so on developing them I've also
done a lot of security talks since then

45
00:03:26,780 --> 00:03:30,080
I moved into embedded security so I've
been to DEFCON in black and stuff like

46
00:03:30,080 --> 00:03:33,820
that and more recently done this open
source project ship was four and I'm

47
00:03:33,820 --> 00:03:35,370
here to talk to you about it

48
00:03:35,370 --> 00:03:41,800
chipper itself we recently did a
Kickstarter so if you're interested in

49
00:03:41,800 --> 00:03:46,220
Kickstarter you can talk to me about
that and there's about 300 ish people

50
00:03:46,220 --> 00:03:52,440
are so 331 backers around 300 got a
little bored and you know the objective

51
00:03:52,440 --> 00:03:56,350
is to teach you about side channel power
analysis this will be a little over

52
00:03:56,350 --> 00:03:58,329
Europe

53
00:03:58,330 --> 00:04:03,630
so the most basic side channels you may
be familiar with is the time you attack

54
00:04:03,630 --> 00:04:08,870
so the timing attack says you know say
we have some crappy C code that's

55
00:04:08,870 --> 00:04:13,230
designed to check up in has been entered
so you know it's not totally brain-dead

56
00:04:13,230 --> 00:04:17,238
we read the pen from the buttons away
from the user to answer all six

57
00:04:17,238 --> 00:04:22,570
characters in this case and once it read
six characters it's gonna check you know

58
00:04:22,570 --> 00:04:27,560
is this pin the crack been and easiest
way to do that is you have a little loop

59
00:04:27,560 --> 00:04:33,250
and as soon as it's wrong we break out
of the loop in return to this right away

60
00:04:33,250 --> 00:04:38,840
opens up just timing attack because if
the first digit is ron so if the correct

61
00:04:38,840 --> 00:04:45,770
ten years 123456 you know if the user
puts in 0000 it's going to see the first

62
00:04:45,770 --> 00:04:50,109
digits round I returned so based on how
long it takes whereas if you know the

63
00:04:50,110 --> 00:04:53,790
first digit rate it'll go through the
loop once and then if the second quarter

64
00:04:53,790 --> 00:05:00,530
on a break then so based on how long
that takes to exit you know which might

65
00:05:00,530 --> 00:05:06,510
be that it puts an LED high and says
that's Ron you learn something about

66
00:05:06,510 --> 00:05:10,740
what digit of the pen is wrong and this
isn't you know like people put up these

67
00:05:10,740 --> 00:05:14,770
slides and you go on though and really
does that surely as soon as an example

68
00:05:14,770 --> 00:05:19,659
this was sort of a crappy
password-protected hard drive it never

69
00:05:19,660 --> 00:05:24,540
claimed to encrypt the data as a note
all it did was mangled the partition

70
00:05:24,540 --> 00:05:28,780
table when you put in the right pin it
on mangled partition table so windows

71
00:05:28,780 --> 00:05:32,679
could see it so it never claimed to have
encryption but it did say you know if

72
00:05:32,680 --> 00:05:37,419
you don't put in the pen it's useless
and they do that mangling so that if you

73
00:05:37,419 --> 00:05:41,340
remove the drive from this enclosure and
just plugged into your computer it also

74
00:05:41,340 --> 00:05:47,750
went to appear so wasn't completely
terrible but it had the same really

75
00:05:47,750 --> 00:05:52,630
basic time unit access to give you an
idea I opened up the cover of the drive

76
00:05:52,630 --> 00:05:56,780
and there's a silico probes on two
things one of them is on a button so you

77
00:05:56,780 --> 00:06:01,809
can sort of see here there's a button
one is on a pin of a chip and this pin

78
00:06:01,810 --> 00:06:06,040
goes to be led then it turns on when you
put in the wrong

79
00:06:06,040 --> 00:06:11,380
the only you know there's always a
little bit of extra work involved to

80
00:06:11,380 --> 00:06:15,159
apply it in real life in this case you
need to figure out that the

81
00:06:15,160 --> 00:06:18,780
microcontroller isn't always waiting for
you to press a button you know our meet

82
00:06:18,780 --> 00:06:23,289
hands are very slow for the
microcontroller so it just wakes up

83
00:06:23,290 --> 00:06:26,370
every hundred milliseconds and says hey
did you press the button ok I'm going

84
00:06:26,370 --> 00:06:31,860
back to sleep so you have to you end up
having to check one of these lines

85
00:06:31,860 --> 00:06:36,150
because it'll put the line high when he
goes to read the button and you can then

86
00:06:36,150 --> 00:06:41,270
get the time from when it reads the
button to land that error led comes on

87
00:06:41,270 --> 00:06:47,320
so it's like about so in these slides
the blue line here this is the the

88
00:06:47,320 --> 00:06:53,710
button this is this weird pattern is it
doing the scan and the redline go-slow

89
00:06:53,710 --> 00:06:58,799
you know when the error led goes out and
you can see there's this difference in

90
00:06:58,800 --> 00:07:06,760
time so the right password is 123456 so
if I put in 06 xxx we see this certain

91
00:07:06,760 --> 00:07:14,039
time delay between 40 going high or from
the scan of the buttons and from the era

92
00:07:14,040 --> 00:07:20,440
led if I put in 1666 you see you even a
little longer and that's because it's

93
00:07:20,440 --> 00:07:25,570
now gone through the loop an extra time
before the air led went on and if I go

94
00:07:25,570 --> 00:07:30,580
123 so the first three digits are
cracked we see so you might not be able

95
00:07:30,580 --> 00:07:34,890
to read but it's pretty the Delta time
of year so this is like 60 maker seconds

96
00:07:34,890 --> 00:07:41,219
and then 64 maker seconds and then 8479
microseconds so you can see it is you

97
00:07:41,220 --> 00:07:46,250
know taking a little longer to go
through this and it's just a one of

98
00:07:46,250 --> 00:07:50,680
these chips here i think is an 8051 core
somewhere that's running the actual

99
00:07:50,680 --> 00:07:54,630
algorithm which one pretty sure that guy

100
00:07:54,630 --> 00:08:01,850
you know so that's that's a basic timing
attack and what people might do is the

101
00:08:01,850 --> 00:08:06,850
same ok well that's easy to fix all I'm
gonna do is do a random delay you know

102
00:08:06,850 --> 00:08:13,180
after I fail so they can get no time
information or they might say I'm not

103
00:08:13,180 --> 00:08:16,450
gonna give any response when rock so if
you put in the wrong password the Dr

104
00:08:16,450 --> 00:08:23,140
just locks it never has an output so you
know this error is never going to change

105
00:08:23,140 --> 00:08:26,760
state because it doesn't tell you when
you aired it only tells you when you're

106
00:08:26,760 --> 00:08:33,909
correct the problem is we can still see
what the devices doing when we look at

107
00:08:33,909 --> 00:08:39,199
the power usage of the race so this is
another I don't have it here but this

108
00:08:39,200 --> 00:08:43,770
was a bootloader where it had a password
protection on it if you sent the wrong

109
00:08:43,770 --> 00:08:48,000
password it simply never responded to
just spun into a loop and you had to

110
00:08:48,000 --> 00:08:52,810
power cycle the device the problem lies
because it was a very small bootloader

111
00:08:52,810 --> 00:08:58,699
tried to make it a small as possible it
would as soon as detected the wrong

112
00:08:58,700 --> 00:09:03,110
digit password it spun into that
infinite loop and what you can see here

113
00:09:03,110 --> 00:09:03,700
is this

114
00:09:03,700 --> 00:09:09,490
in blue is the power usage of the device
so power usage and when is actively

115
00:09:09,490 --> 00:09:15,280
receiving the password it's taking more
power so this is because of the

116
00:09:15,280 --> 00:09:22,510
measurement its inverted so more power
is this way lots more and less is up and

117
00:09:22,510 --> 00:09:25,810
you see that you know it's doing
processing of the data as soon as it

118
00:09:25,810 --> 00:09:32,180
stops listening the power usage changes
substantially and so you can know that

119
00:09:32,180 --> 00:09:36,670
right away he did that by was the wrong
one so we just have to enumerate you

120
00:09:36,670 --> 00:09:42,020
know for each by what the possibilities
are greatly reduced our our key search

121
00:09:42,020 --> 00:09:43,680
faced

122
00:09:43,680 --> 00:09:47,010
these types of attacks there's an
example where ever you know the first

123
00:09:47,010 --> 00:09:53,670
fight sounds easy right away it stops
receiving so for all of these attacks

124
00:09:53,670 --> 00:09:59,339
and we'll be talking about we need ways
to measure the power very briefly we

125
00:09:59,339 --> 00:10:03,290
have you know a microcontroller so if we
were doing it against this device

126
00:10:03,290 --> 00:10:09,849
there's various chips that are using
power and what we want to do is we want

127
00:10:09,850 --> 00:10:15,450
to insert a resistor into the paralyzed
so this would be you know the VCC pin

128
00:10:15,450 --> 00:10:20,540
for the checks this is your
microcontroller MCU and we're just

129
00:10:20,540 --> 00:10:24,579
measuring the voltage across that
resistor really with an oscilloscope now

130
00:10:24,580 --> 00:10:31,510
with a DMM and this is how we get a nice
power usage waveforms and if you have a

131
00:10:31,510 --> 00:10:35,529
real border attacking that can actually
be not too difficult so this is a view

132
00:10:35,529 --> 00:10:40,529
of what's called the TQFP package this
is sort of a top you see you can see the

133
00:10:40,529 --> 00:10:45,689
use of that the individual pins here and
all I've done is one has been lifted up

134
00:10:45,690 --> 00:10:51,880
and a very small resistor inserted into
it and over here there's a wire going on

135
00:10:51,880 --> 00:10:57,689
and it otherwise goes to the rest of the
PowerPoint so this is exactly like the

136
00:10:57,690 --> 00:11:03,100
so that's the resistor there at this is
exactly like this diagram major show

137
00:11:03,100 --> 00:11:07,050
we're able to achieve this para
measurement on a real bored you know

138
00:11:07,050 --> 00:11:11,180
with a fairly simple modification

139
00:11:11,180 --> 00:11:15,219
thing we can do is we don't even have to
physically modified things we can use

140
00:11:15,220 --> 00:11:20,029
what's known as a each field pro
basically a change in current generates

141
00:11:20,029 --> 00:11:25,209
a changing magnetic field I we have
simple probes that look like this so you

142
00:11:25,209 --> 00:11:31,319
can build something like this for a few
dollars or by 14 52,000 if you want to

143
00:11:31,320 --> 00:11:36,900
really high-end probe but this probe
consensus that changing magnetic field

144
00:11:36,900 --> 00:11:40,779
the field lines through it generates a
very small voltage which you can detect

145
00:11:40,779 --> 00:11:45,860
this changing magnetic field is related
to the current and therefore we can do

146
00:11:45,860 --> 00:11:49,589
this exact same analysis you know as we
were doing with the resistor without

147
00:11:49,589 --> 00:11:53,500
modifying it also means you can attack
if you have a VGA device of the ball

148
00:11:53,500 --> 00:11:54,350
grid array

149
00:11:54,350 --> 00:12:00,590
where you can't lift the pins you can't
do this unless things that photo

150
00:12:00,590 --> 00:12:07,310
disappeared from my slides for some
reason you could use the HP Pro so

151
00:12:07,310 --> 00:12:12,770
that's how we measure the power and
that's just you know real simple power

152
00:12:12,770 --> 00:12:18,030
analysis to detect what the devices
doing which is cool but not the limit of

153
00:12:18,030 --> 00:12:21,680
what we can learn what's really
interesting is that we can directly

154
00:12:21,680 --> 00:12:26,939
break a cryptographic keys out of
hardware devices and this is something

155
00:12:26,940 --> 00:12:32,020
called differential power analysis which
is an even more powerful to how this

156
00:12:32,020 --> 00:12:37,150
works is that on a digital device
internally it has these lines that it

157
00:12:37,150 --> 00:12:41,850
switches to these bus lines that run all
over the chip and the microcontroller

158
00:12:41,850 --> 00:12:46,720
can switch these lines either high or
low so if it changes it till 18 connects

159
00:12:46,720 --> 00:12:52,300
the you know what I call the VCC here
the positive supplies to that rail if it

160
00:12:52,300 --> 00:12:59,540
changes it 20 it conducts the ground
zero volts apply to everyone know that

161
00:12:59,540 --> 00:13:04,130
rail you know is literally piece of wire
inside the chip has some capacitance so

162
00:13:04,130 --> 00:13:08,450
really what we're doing is we're
changing the voltage on this capacitor

163
00:13:08,450 --> 00:13:14,350
here you know when it might be 3.3 volts
3.3 volt pirate and then it might have

164
00:13:14,350 --> 00:13:18,670
to change it 20 goals you know a few
members of the high school physics

165
00:13:18,670 --> 00:13:23,089
changing the voltage on a capacitor
physically means we're moving a charge

166
00:13:23,090 --> 00:13:28,160
physically means we're taking power so
if you were to look inside look at the

167
00:13:28,160 --> 00:13:33,469
digital device and say what happens when
two of you know the data lines so

168
00:13:33,470 --> 00:13:39,030
typically the data buses might have
eight bits 16 bit 32 bit 64 bits however

169
00:13:39,030 --> 00:13:45,079
big to standard injuries normally what
if we look at the power consumption as

170
00:13:45,080 --> 00:13:46,660
it puts

171
00:13:46,660 --> 00:13:51,329
a word with you know to ones on the the
date of us who have two of those data

172
00:13:51,329 --> 00:13:56,250
lines are switching to high we actually
see a larger spike then it's just one of

173
00:13:56,250 --> 00:14:00,829
those data lines are switching to high
or if neither of the data lines are

174
00:14:00,829 --> 00:14:04,099
switching to house of the switching low
we won't see this positive speak at all

175
00:14:04,100 --> 00:14:09,399
looking on one of the parallels so what
this would suggest is that the peres

176
00:14:09,399 --> 00:14:14,709
consumption and a very very very fine
level is actually directly related to

177
00:14:14,709 --> 00:14:18,439
how many ones are going on the date of
us which seems crazy because we're

178
00:14:18,439 --> 00:14:23,849
learning quite a bit of information
about the chip and this is actually

179
00:14:23,850 --> 00:14:28,589
completely the case so this was some
measurements I did and hemingway is the

180
00:14:28,589 --> 00:14:33,589
number of one's going on the data bus
and this is a measurement of the power

181
00:14:33,589 --> 00:14:38,009
related to the power and you can see
it's almost a perfectly linear fit the

182
00:14:38,009 --> 00:14:43,240
crazy thing at the end here possibly due
to scheduling issues but you do see if

183
00:14:43,240 --> 00:14:48,959
it works very nicely so you really can
work this information about what's going

184
00:14:48,959 --> 00:14:56,518
on inside the chip with just power
measurements so at this point it's still

185
00:14:56,519 --> 00:15:01,620
may not seem like it's a dangerous
because all we're learning is you know

186
00:15:01,620 --> 00:15:06,920
how many ones around the data bus of
this ship here so let me break some

187
00:15:06,920 --> 00:15:11,349
crypto for you with that simple
information I have a system under attack

188
00:15:11,350 --> 00:15:18,110
here this is you know your chip I have a
scope to measure the power so this is

189
00:15:18,110 --> 00:15:22,720
your resistor for the peres measurement
here in inside that device lets say I

190
00:15:22,720 --> 00:15:28,399
know it XO offers some input data with
some unknown secret key here so we have

191
00:15:28,399 --> 00:15:34,360
the secret key it's actually in that
input dinner with with the secret key

192
00:15:34,360 --> 00:15:39,649
and critically I don't have access to
this year I don't wear goes goes inside

193
00:15:39,649 --> 00:15:43,839
the chip or you know something crazy
like that I don't know but I'd still

194
00:15:43,839 --> 00:15:47,130
like to recover the secret key which
would seem impossible but using this

195
00:15:47,130 --> 00:15:52,920
para measurement we can do that because
you can consider that well what if you

196
00:15:52,920 --> 00:15:58,349
know let's say I put in a tax I know
what exercise it with the secret key in

197
00:15:58,350 --> 00:16:06,339
this case yes it's going to generate X
67 X 67 has five bit set to one so if

198
00:16:06,339 --> 00:16:11,630
you can vary better binary number of
once and same thing with every other

199
00:16:11,630 --> 00:16:16,560
input we get we could figure out what
the hemingway it should be over the data

200
00:16:16,560 --> 00:16:23,680
bus now eliminate what we don't know we
don't know the secret key you know this

201
00:16:23,680 --> 00:16:28,760
year we don't know and we don't know
what that is but we do know around

202
00:16:28,760 --> 00:16:34,700
claiming we do know is the Hamming
weight of that output data that eating

203
00:16:34,700 --> 00:16:38,680
the chip so we actually know what the
results should be just the hemingway

204
00:16:38,680 --> 00:16:47,019
final step is we just a real simple
guess we can check every possibility for

205
00:16:47,019 --> 00:16:54,220
that secret key so here at 700 and I
said ok I put in X 80 X 100 and see if

206
00:16:54,220 --> 00:16:59,320
what we expect to measure this
hypothetical measurement of the number

207
00:16:59,320 --> 00:17:03,860
ones matches what we actually measured
on the physical device we don't know any

208
00:17:03,860 --> 00:17:08,480
of that in all we do is we then try to
get that didn't work because you know I

209
00:17:08,480 --> 00:17:16,370
measured to 43 44 and expected to
measure 5635 so it's Ron 01 you know

210
00:17:16,369 --> 00:17:21,790
doesn't match every game eventually
we'll get to the point where we say well

211
00:17:21,790 --> 00:17:28,850
if I guess the secret of a bite of the
secret key was yeah those what I would

212
00:17:28,850 --> 00:17:33,100
expect that intermediate value to
meaning what I had expected to leak

213
00:17:33,100 --> 00:17:37,490
actually measures are leakage so we have
a model of what we expected to leak and

214
00:17:37,490 --> 00:17:39,600
we have measurements and we simply match
them up

215
00:17:39,600 --> 00:17:46,139
so this is the basics of differential
power analysis what makes their school

216
00:17:46,140 --> 00:17:51,010
is that when we look at a lot of
algorithms this is a yes 128 how it

217
00:17:51,010 --> 00:17:55,980
operates is that you know it has 228
dead so it has the 16 bytes imports the

218
00:17:55,980 --> 00:18:02,470
16 byte keys but raided the import it
actually just operates on one page of

219
00:18:02,470 --> 00:18:07,309
the key one bite of the plane tax it
exercise them together and actually

220
00:18:07,309 --> 00:18:11,020
passes them through a lookup table what
this means is that with this

221
00:18:11,020 --> 00:18:17,750
differential power analysis we no longer
care that its 220 bits or if it's a yes

222
00:18:17,750 --> 00:18:21,220
256 it doesn't matter because we're
breaking it

223
00:18:21,220 --> 00:18:25,690
eight bits of the time and that guess
and check you know oh it's only 256

224
00:18:25,690 --> 00:18:32,190
guesses and adjust scales linearly with
however many sites we have no longer

225
00:18:32,190 --> 00:18:37,150
have this crazy growth in the search
space so you can break it on the show

226
00:18:37,150 --> 00:18:43,770
you on a laptop instead of a few seconds
safe thing the only real thing you have

227
00:18:43,770 --> 00:18:49,168
to remember is so when we were doing
these measurements the crypto device is

228
00:18:49,169 --> 00:18:53,140
running with the secret keys so this is
the real important thing to remember

229
00:18:53,140 --> 00:18:58,970
side channel analysis needs you know
Decrypter device running with the secret

230
00:18:58,970 --> 00:19:07,220
key you care about you may not need to
control the safer tax or the plain text

231
00:19:07,220 --> 00:19:09,370
you don't necessarily need to control
them

232
00:19:09,370 --> 00:19:13,100
you do need to be able to use their did
you still wanna go two of them so either

233
00:19:13,100 --> 00:19:18,980
the plain text or the safer tax or
possibly a part of it if you know part

234
00:19:18,980 --> 00:19:22,880
of its fixed and part of its not that's
enough so camera modes and stuff you can

235
00:19:22,880 --> 00:19:27,610
still attack it's a tiny bit more
complicated but very doable but the

236
00:19:27,610 --> 00:19:31,669
critical part is that the secret key has
three in the device running

237
00:19:31,670 --> 00:19:35,160
why you see that is that you know if you
have a hard drive on a table that's been

238
00:19:35,160 --> 00:19:39,350
encrypted side channel analysis is no
good for you it's not actively doing

239
00:19:39,350 --> 00:19:43,459
anything you know encrypt or decrypt the
data if it's just sitting there

240
00:19:43,460 --> 00:19:48,440
the keys not loaded into the engine so
you can't use it if it was you know

241
00:19:48,440 --> 00:19:53,310
actively being in use by the user you
then could use such an analysis on the

242
00:19:53,310 --> 00:19:59,750
device despite that there have been a
lot of devices that have been broken so

243
00:19:59,750 --> 00:20:05,200
this was various papers some of them you
may have heard of some of them not so

244
00:20:05,200 --> 00:20:10,600
number of them for example refugee A's
that have protection in them against

245
00:20:10,600 --> 00:20:17,409
loading stealing the designer no loading
unsigned files you can break them are

246
00:20:17,410 --> 00:20:22,150
some crypto engine so this X Mega for
example was just a peripheral and

247
00:20:22,150 --> 00:20:29,230
microcontrollers breakable these devices
where these HSC devices are key fobs

248
00:20:29,230 --> 00:20:35,950
turnover older maybe new involves using
too but they use a broken basically

249
00:20:35,950 --> 00:20:40,020
algorithm and implementation of the
algorithm in the check that you can

250
00:20:40,020 --> 00:20:45,389
break so there's a whole bunch of stuff
that it has been applied to just because

251
00:20:45,390 --> 00:20:48,880
you have hardware crypto was the point
doesn't mean it's secure against this so

252
00:20:48,880 --> 00:20:53,710
Google vault recently had their own set
of hardware security module thing I

253
00:20:53,710 --> 00:20:59,220
don't I never fully saw the details if
they were all released but as part of

254
00:20:59,220 --> 00:21:04,560
that they hadn't a yes FPGAs core and
you know they had some notes in there

255
00:21:04,560 --> 00:21:08,340
that they're designed avoids
differential power analysis attacks

256
00:21:08,340 --> 00:21:14,320
because they use some other design this
was entirely false you can perform a

257
00:21:14,320 --> 00:21:18,520
differential power analysis attacks on
their implementation just as easily as

258
00:21:18,520 --> 00:21:23,610
not so a lot of the reason this happens
is people don't have the experience of

259
00:21:23,610 --> 00:21:27,820
doing the attacks themselves they don't
have the resources so part of starting

260
00:21:27,820 --> 00:21:32,210
this whole project is to give any
engineer doing any sort of crypto tools

261
00:21:32,210 --> 00:21:34,140
the ability to

262
00:21:34,140 --> 00:21:39,180
to know do differential power analysis
attacks test hardware malady bender

263
00:21:39,180 --> 00:21:45,110
claims and that's really the point of
this whole project right so that's the

264
00:21:45,110 --> 00:21:54,360
math introduction let me show you a
basic hair analysis attack so what I

265
00:21:54,360 --> 00:22:01,000
have is a have this this was when we did
the Kickstarter for so it does a

266
00:22:01,000 --> 00:22:13,220
combination of the just get a shot of it
up here for you

267
00:22:13,220 --> 00:22:17,929
so this is the board and basically what
you have is there's half of the board is

268
00:22:17,929 --> 00:22:22,190
programmed with an algorithm Aventuras I
saw this case I'm just doing you know

269
00:22:22,190 --> 00:22:28,830
sort of research type work I'm showing
you I'm not as hacking a commercially

270
00:22:28,830 --> 00:22:32,840
available device I've taken this device
and I programmed it with an open source

271
00:22:32,840 --> 00:22:37,928
implementation this one is a year crypto
live is what I'm using but you know

272
00:22:37,929 --> 00:22:42,250
there's a few other implementations you
can't ask this half of the board so

273
00:22:42,250 --> 00:22:46,610
that's half aboard the other half of the
board here actually does the physical

274
00:22:46,610 --> 00:22:50,789
power measurements what has you know an
EDC and amplifier and stuff like that

275
00:22:50,789 --> 00:22:55,669
to perform this parameter me and then
download it to the computer via a USB

276
00:22:55,669 --> 00:23:04,400
microcontroller and FPGA

277
00:23:04,400 --> 00:23:12,210
what you're seeing here is the what
you're seeing here is that we form is

278
00:23:12,210 --> 00:23:16,820
the power consumption of the device as
it's doing AES encryption as you can

279
00:23:16,820 --> 00:23:22,450
view for example the important verifying
that it's actually performing the

280
00:23:22,450 --> 00:23:27,700
correct encryption so just encrypting 16
bytes just as a simple tasks you can see

281
00:23:27,700 --> 00:23:32,490
for example if I tell it to encrypt the
same data over and over

282
00:23:32,490 --> 00:23:36,410
you'll notice this power consumption
curve isn't jumping around quite as much

283
00:23:36,410 --> 00:23:42,370
as if I go back to telling it to encrypt
random data what you'll see is that you

284
00:23:42,370 --> 00:23:45,840
can see some of the spikes moving up and
down so it's just showing some data

285
00:23:45,840 --> 00:23:54,000
dependency within the within the traces
sooted actually doing attack what I need

286
00:23:54,000 --> 00:23:58,160
to do is tell it to encrypt a bunch of
traces a bunch of data and see if

287
00:23:58,160 --> 00:24:05,280
there's racism should call test team so
I'm just recording the data so it only

288
00:24:05,280 --> 00:24:10,139
takes a few seconds of sentiment adidas
encrypted and saves the power

289
00:24:10,140 --> 00:24:17,500
consumption varies the other half of
this all this by the way is open source

290
00:24:17,500 --> 00:24:23,070
written in Python the only caveat I give
you is that I started this project three

291
00:24:23,070 --> 00:24:24,210
years ago

292
00:24:24,210 --> 00:24:29,460
three and a half years ago I had never
used Python so if you look back to some

293
00:24:29,460 --> 00:24:33,110
of the original code the qualities that
improves over time as they learn how to

294
00:24:33,110 --> 00:24:40,290
program in Python so a lot of its been
fixed since then but not all of it it so

295
00:24:40,290 --> 00:24:44,600
this is the capture so this is sort of
the waveforms I just captured and it's

296
00:24:44,600 --> 00:24:51,610
just gonna do this guess and check with
increasing amounts of traces

297
00:24:51,610 --> 00:24:57,809
so I'm gonna make it run by default it
runs too fast making good Demel so

298
00:24:57,809 --> 00:25:01,950
what's happening here is in a red the
correct key bite I told it was there is

299
00:25:01,950 --> 00:25:04,510
correct he bite is will filter to the
top

300
00:25:04,510 --> 00:25:10,070
its ranking what the most likely key is
based on how many traces its using so

301
00:25:10,070 --> 00:25:17,260
you'll see normally around 50 it depends
how noisy everything is great forty

302
00:25:17,260 --> 00:25:20,670
traces are all in red you see the
correct key is now at the top so it's

303
00:25:20,670 --> 00:25:22,030
completely recovered

304
00:25:22,030 --> 00:25:30,720
828 key in a real open source
implementation of the AES encryption

305
00:25:30,720 --> 00:25:43,110
algorithm and it doesn't take very long
at all so the other question people have

306
00:25:43,110 --> 00:25:47,250
is you know like how do it how did I
know when to look for the power because

307
00:25:47,250 --> 00:25:51,760
it's doing a whole lot of stuff the cool
thing is that everything that's not the

308
00:25:51,760 --> 00:25:57,010
encryption sort of filters away in the
algorithm so what I've done here is this

309
00:25:57,010 --> 00:26:01,650
is actually showing you several points
in time so it's three thousand samples

310
00:26:01,650 --> 00:26:06,650
in real life what you would do is you
send it you know the command to say in

311
00:26:06,650 --> 00:26:10,299
cryptic reality you might centered on
that occasion command and just start

312
00:26:10,299 --> 00:26:15,490
recording power until it returns the
result when I read the algorithm you see

313
00:26:15,490 --> 00:26:21,000
this big spike and this is for
recovering bite number three of a if I

314
00:26:21,000 --> 00:26:25,260
say ok where did you recover by four
you'll notice this other red spike at

315
00:26:25,260 --> 00:26:30,090
the next point in time and in this case
there's just a for loop in a yes you

316
00:26:30,090 --> 00:26:34,699
know during each of those exercise an
Xbox lookups and you can see that it

317
00:26:34,700 --> 00:26:38,460
simply you know you can see the the
offset of how long it's taking to run

318
00:26:38,460 --> 00:26:45,360
through that loop so you don't really
need to know exactly where the EAS

319
00:26:45,360 --> 00:26:51,370
itself is having the algorithm or pulled
out information for you and as it goes

320
00:26:51,370 --> 00:26:52,129
on

321
00:26:52,130 --> 00:26:56,150
comes a little slower in redrawn but you
see the same you know marching on in

322
00:26:56,150 --> 00:26:58,870
time and that's just the for loop inside
the C code

323
00:26:58,870 --> 00:27:10,080
as it's raining so that's a really basic
attack so you know in that case I have a

324
00:27:10,080 --> 00:27:13,669
device programs that just does a yes and
returns the results how do you apply

325
00:27:13,670 --> 00:27:20,650
this to real life so few other examples
I've sort of documented AES 256

326
00:27:20,650 --> 00:27:27,830
bootloader so in this case it's a su 56
instead of 128 it's based heavily on a

327
00:27:27,830 --> 00:27:31,320
number of microcontroller manufacturers
make these app note to say hey you wanna

328
00:27:31,320 --> 00:27:35,389
bootloader a great you can now have a
bootloader the only accepts you know

329
00:27:35,390 --> 00:27:40,530
assigned code and you can post the
firmware files but no one can use it

330
00:27:40,530 --> 00:27:45,200
because it needs the key inside your
device

331
00:27:45,200 --> 00:27:49,820
the problem with this is that you know
when I sent to the firmware file it's

332
00:27:49,820 --> 00:27:54,610
going to decrypt it it's gonna throw it
away once it realizes it's fake but it's

333
00:27:54,610 --> 00:27:59,199
going to do this a yes description in
this is all we need for a side channel

334
00:27:59,200 --> 00:28:04,390
attacks so if I'm able to send it bogus
firmware file I know what did I sent it

335
00:28:04,390 --> 00:28:09,800
I know when it does the decryption
roughly and i cant force it to do a

336
00:28:09,800 --> 00:28:14,250
whole bunch of just reset the device and
send a new file so in this case the

337
00:28:14,250 --> 00:28:20,230
format so online published one of
basically collected among Japanese and

338
00:28:20,230 --> 00:28:25,910
rewrote written a generic bootloader but
it uses all the same principles most of

339
00:28:25,910 --> 00:28:26,410
them

340
00:28:26,410 --> 00:28:31,200
designer on small devices what you have
is you take the bike years you know the

341
00:28:31,200 --> 00:28:36,440
Hawks unencrypted file or whatever
binary so that's the file they want to

342
00:28:36,440 --> 00:28:44,100
distribute they chop it up into their
using 12 by tanks and he just had four

343
00:28:44,100 --> 00:28:48,428
fixed sites at the beginning to this
gives you your sixteen by block the idea

344
00:28:48,429 --> 00:28:51,970
of these four fixed sites as that's
going to be their signature every block

345
00:28:51,970 --> 00:28:56,510
to decrypt they're gonna check do those
four bytes match what I expect if not

346
00:28:56,510 --> 00:29:03,440
you know stop don't know it through the
way they then use a yes 256 in CBC mode

347
00:29:03,440 --> 00:29:06,020
so there's an initialization vector

348
00:29:06,020 --> 00:29:10,960
which is also programmed into device
will need to break bad as well they then

349
00:29:10,960 --> 00:29:14,930
add you know a header in Searcy and
everything else do you expect such a

350
00:29:14,930 --> 00:29:19,060
really basic serial communications
protocol for downloading updated for a

351
00:29:19,060 --> 00:29:23,520
sort of break this to you wouldn't
physically need the device because

352
00:29:23,520 --> 00:29:29,090
that's the device with the encryption
key and me and all I would do is i just

353
00:29:29,090 --> 00:29:36,510
send it a bunch of random binaries and
in fact all I'm going to use is the you

354
00:29:36,510 --> 00:29:41,470
know you could synchronized in a large
file how many descriptions it does in my

355
00:29:41,470 --> 00:29:48,130
case i just send it the first block to
decrypt and then resets our objective is

356
00:29:48,130 --> 00:29:51,810
to things we want to recover the
decryption the key used in the AES 256

357
00:29:51,810 --> 00:29:57,179
decryption and we want to recover the
initialization vector I used as part of

358
00:29:57,180 --> 00:30:02,730
CBC mode as a no you don't fully need
that because if you don't recover this

359
00:30:02,730 --> 00:30:06,230
so if you're unable to recover the
initialization vector which is actually

360
00:30:06,230 --> 00:30:12,210
slightly harder you would still have the
contents of the entirety of the file

361
00:30:12,210 --> 00:30:16,020
except those first 16 bytes

362
00:30:16,020 --> 00:30:18,970
so if you just wanted to reverse
engineer it that's probably fine

363
00:30:18,970 --> 00:30:23,850
normally that first 16 bytes just like a
jump table or something like that it's

364
00:30:23,850 --> 00:30:27,740
not too difficult to figure out you know
what it should be

365
00:30:27,740 --> 00:30:33,490
so in that case you don't necessarily
care it may be too if you know whether

366
00:30:33,490 --> 00:30:36,910
his first 16 bytes would be because you
know the architecture it has a very

367
00:30:36,910 --> 00:30:41,920
standard sort of beginning part of the
file if it's just the jump table and

368
00:30:41,920 --> 00:30:46,470
it's using some standard addresses you
can actually break the IV by sort of

369
00:30:46,470 --> 00:30:51,940
reversing that once you know the AES 256
key if you knew those first plain text

370
00:30:51,940 --> 00:30:57,410
you could figure out the initialization
vector the only difference with AES 256

371
00:30:57,410 --> 00:31:05,090
in this case is that it doesn't into 16
byte chunks so the first the first bit

372
00:31:05,090 --> 00:31:08,620
of the decryption is almost the same as
when I showed you before you know we

373
00:31:08,620 --> 00:31:09,870
have the the secret key

374
00:31:09,870 --> 00:31:14,189
we have the input the ciphertext in this
case and we're looking at the output of

375
00:31:14,190 --> 00:31:20,530
this inverse ask box lookup table again
and we can recover that once we recover

376
00:31:20,530 --> 00:31:24,570
that key so we have to do that attack
first week and then attacked the next

377
00:31:24,570 --> 00:31:30,010
round because it uses the next 16 bytes
of the key are used it in that output

378
00:31:30,010 --> 00:31:34,559
and then it just continues on so once we
have those first two bytes are the first

379
00:31:34,559 --> 00:31:40,639
to sixteen blocks we can run the AES
algorithm backwards to get the complete

380
00:31:40,640 --> 00:31:46,559
initial keep so those are the two things
we need to attack right now there's a

381
00:31:46,559 --> 00:31:51,649
tiny bit of complexity when you
physically do it in this case the AES

382
00:31:51,650 --> 00:31:58,250
implementation so I'm using one from the
app new works fine for that first 16

383
00:31:58,250 --> 00:32:01,720
bytes of their very nicely synchronize
so this is like you know twenty

384
00:32:01,720 --> 00:32:08,690
descriptions so I sent it 20 I don't
think I ever ate but you get the idea

385
00:32:08,690 --> 00:32:13,780
20 blocks and I'm doing the power
consumption what you see is that you

386
00:32:13,780 --> 00:32:16,950
know they look it looks very nice
aligned at some point looks really messy

387
00:32:16,950 --> 00:32:21,670
so they're all there no longer line you
know all that happens is stuff becomes d

388
00:32:21,670 --> 00:32:25,540
synchronize their some you know random
delay when it's going through the loop

389
00:32:25,540 --> 00:32:30,600
in these cases to have a timing attack
in there a yes but it could be you have

390
00:32:30,600 --> 00:32:34,240
an interrupt you know if it's raining
with an OS may have an interrupt my way

391
00:32:34,240 --> 00:32:37,940
through the encryption so you've got a
recent nice stuff that's very easy to do

392
00:32:37,940 --> 00:32:43,700
in the the software shifts in all based
on a pattern this stuff is well known in

393
00:32:43,700 --> 00:32:51,230
image processing and video processing
it's not remotely newer difficult what

394
00:32:51,230 --> 00:32:59,630
you get is the same sort of device a
small microcontroller you know 6280

395
00:32:59,630 --> 00:33:05,320
traces somewhere around here with almost
a hundred percent of the time so the

396
00:33:05,320 --> 00:33:10,070
success rate is seen how often do I
recover the entire key almost a hundred

397
00:33:10,070 --> 00:33:14,178
percent of the time in about 60
decryption operations I can recover

398
00:33:14,179 --> 00:33:20,380
those first 16 bytes it takes a little
longer to recover the next 16 bytes and

399
00:33:20,380 --> 00:33:25,850
in this case up to about a hundred and
twenty it is almost always recovering

400
00:33:25,850 --> 00:33:31,990
the full AES 256 key so it doesn't take
a lot of operation 420 christians you

401
00:33:31,990 --> 00:33:35,250
can do that and you know five minutes
even if you have to reset the device in

402
00:33:35,250 --> 00:33:41,560
between every attempt one example
another example of something like a

403
00:33:41,560 --> 00:33:47,580
needle to 54 notes so this is a true 254
if you don't know you might know about

404
00:33:47,580 --> 00:33:53,280
the names eg you get you there's a bunch
of different versions of it but it's

405
00:33:53,280 --> 00:33:58,200
just a sort of lower layer protocol for
low-power radio devices it's actually

406
00:33:58,200 --> 00:34:04,190
used by a lot of other protocols as sort
of an underlying layer including thread

407
00:34:04,190 --> 00:34:09,950
I believe is the mass of the nest
thermometer user's fifty-four percent of

408
00:34:09,949 --> 00:34:14,080
its local communications what's really
interesting about this is that a lot of

409
00:34:14,080 --> 00:34:19,080
15 for nodes will thus have something
else on them so they might have wifi

410
00:34:19,080 --> 00:34:25,739
Ethernet a lot of the time they connect
into a larger network so if we can get

411
00:34:25,739 --> 00:34:29,739
an attack on the 54 side we may actually
be able to you know funds that interface

412
00:34:29,739 --> 00:34:35,469
to find bugs to hop over to another
interface and that's what sort of makes

413
00:34:35,469 --> 00:34:40,080
a really interesting it's not just the
case of yours have to go to 54 ok you

414
00:34:40,080 --> 00:34:44,889
can turn off my lights or something dumb
you might be able to get further onto

415
00:34:44,889 --> 00:34:50,270
the network using this as a base and the
sort of threat mother were using is that

416
00:34:50,270 --> 00:34:55,500
we assume these 80 215 for nodes again
are normally cheap and crappy like light

417
00:34:55,500 --> 00:35:00,280
switches lights little thermometers it
might be pretty easy to actually capture

418
00:35:00,280 --> 00:35:02,770
one of these

419
00:35:02,770 --> 00:35:09,390
so the research I did was I'm using this
is a hero to 15 for development board so

420
00:35:09,390 --> 00:35:16,150
it's loaded with a legitimate 80 254
staff that respects all the standards in

421
00:35:16,150 --> 00:35:20,130
one of the fun things wrote the piece
taxes as you would expect if I send it

422
00:35:20,130 --> 00:35:26,570
an encrypted encrypted frame oh it's
gonna do it doesn validations you know

423
00:35:26,570 --> 00:35:33,620
does this framework valid and at some
point it to grips with the entire frame

424
00:35:33,620 --> 00:35:39,640
which is what you expected to do the
message authentication code fails when

425
00:35:39,640 --> 00:35:43,210
it tries to validated its just gonna
throw it away as you're expected to do

426
00:35:43,210 --> 00:35:48,480
and it won't tell anyone about that low
level thing it as soon as the noise or

427
00:35:48,480 --> 00:35:54,650
someone misconfigured something but what
this means to us as we actually now have

428
00:35:54,650 --> 00:35:59,960
you this attack ability because we can
force it to do descriptions you know

429
00:35:59,960 --> 00:36:05,320
when we wanted to the question is do we
control the empire and more or less we

430
00:36:05,320 --> 00:36:10,600
do it doesn't it's used in counter mode
so you only control little bits of it

431
00:36:10,600 --> 00:36:16,650
there's an AES counter which is always
said 20 at the start of a frame so for

432
00:36:16,650 --> 00:36:21,520
us it's only zero always control really
is there's four bytes of frame counter

433
00:36:21,520 --> 00:36:25,930
the address stuff you have to use
legitimate address because it validates

434
00:36:25,930 --> 00:36:30,669
that addresses one its talk to you can
spoof of that super easy but it has to

435
00:36:30,670 --> 00:36:35,680
be one of you know unknown address we
have four bytes of what it calls the

436
00:36:35,680 --> 00:36:40,060
frame counter so we control these four
bytes of the ASM put everything else is

437
00:36:40,060 --> 00:36:47,500
more or less a fixed value the hardware
itself so this node internally has heard

438
00:36:47,500 --> 00:36:48,530
were a yes

439
00:36:48,530 --> 00:36:52,460
accelerator so it's not doing the
software version I was just showing you

440
00:36:52,460 --> 00:36:57,130
it actually has a pressure on the micro
thats decrypting

441
00:36:57,130 --> 00:37:01,240
as it turns out this hardware a yes

442
00:37:01,240 --> 00:37:07,629
engine is vulnerable to the side channel
power analysis attack which is mostly

443
00:37:07,630 --> 00:37:11,140
the case for any device that's not
designed to be resistant to its your

444
00:37:11,140 --> 00:37:12,049
credit card

445
00:37:12,049 --> 00:37:16,589
designed to be resistant an off the
shelf microcontroller is not in what

446
00:37:16,589 --> 00:37:21,269
this shows you is that you know did that
by the way the scale on this one is the

447
00:37:21,269 --> 00:37:25,738
inverse it's called the the partial
guessing centerpiece of the entropy in

448
00:37:25,739 --> 00:37:29,650
the key how many guesses do I have left
in the key before it recovered the

449
00:37:29,650 --> 00:37:34,359
cracked one if he goes to zero no more
guessing as needed there's no enter p.m.

450
00:37:34,359 --> 00:37:40,679
I just keep so it's more or less recover
what you end up with is somewhere around

451
00:37:40,679 --> 00:37:45,189
six to ten thousand it either recovers
the key or it's so easy to guess it

452
00:37:45,189 --> 00:37:50,078
because there's like a hundred guesses
last it's effectively covered it and so

453
00:37:50,079 --> 00:37:52,160
what's interesting here is that you know
if I sent it

454
00:37:52,160 --> 00:38:00,249
10,000 passengers were able to break
this this is encryption algorithm and

455
00:38:00,249 --> 00:38:05,839
its not that hard to send it 10,000
messages just a wireless device and get

456
00:38:05,839 --> 00:38:10,609
it to decrypt them the other cool thing
is that I've never broken this device

457
00:38:10,609 --> 00:38:14,369
have never you know opened it up and
never reflash it still gonna be on the

458
00:38:14,369 --> 00:38:18,279
network if it's in radio range it's
still responding to all the normal

459
00:38:18,279 --> 00:38:22,130
messages so it would be also hard to
detect this type of attack

460
00:38:22,130 --> 00:38:27,479
eventually once you get the key at this
point you be able to send messages back

461
00:38:27,479 --> 00:38:32,959
to this guy the energy 54 coordinator
and whether thats that you wanted to

462
00:38:32,959 --> 00:38:38,009
pretend you're the a side note or more
likely you want to use that exploit

463
00:38:38,009 --> 00:38:42,579
further up the chain that's another
reason you might want to care about side

464
00:38:42,579 --> 00:38:48,089
channel power analysis there's a whole
so that was breaking the cryptic there's

465
00:38:48,089 --> 00:38:52,609
a whole other field that's interesting
hold glitching and this is almost

466
00:38:52,609 --> 00:38:59,259
certainly more announced a basic but
more fundamental way around some of

467
00:38:59,259 --> 00:39:03,769
these security measures and what this is
you know if you have some sort of

468
00:39:03,769 --> 00:39:08,488
authentication module there's always
somewhere that it's it has a check so in

469
00:39:08,489 --> 00:39:09,550
this case this is in

470
00:39:09,550 --> 00:39:15,590
Linux authorization so it says you know
if the user ID is not equal to 0 do

471
00:39:15,590 --> 00:39:22,020
these checks otherwise returns your
return true so if you could cause it to

472
00:39:22,020 --> 00:39:26,600
execute this check incorrectly you won't
even have to break any of the you know

473
00:39:26,600 --> 00:39:30,970
password Store the crypto on the device
you might just be able to get the

474
00:39:30,970 --> 00:39:34,470
authorization you need right away

475
00:39:34,470 --> 00:39:40,339
same thing with Android so verify
password and unlock at some point it has

476
00:39:40,340 --> 00:39:49,010
attacks attracted says you know check
password password is good you know says

477
00:39:49,010 --> 00:39:53,630
okay we're fine otherwise it goes
through its failed attempt so regardless

478
00:39:53,630 --> 00:40:06,760
of whether that actually happened we can
do what our objective is to simply screw

479
00:40:06,760 --> 00:40:10,380
up the system in a predictable manner
such that it thinks the password past

480
00:40:10,380 --> 00:40:13,430
the check but we don't know what the
password is but we just make it pretend

481
00:40:13,430 --> 00:40:19,100
to pass so I can show you two
quake-damaged of this you can do this a

482
00:40:19,100 --> 00:40:25,430
little bit microcontrollers again just
like you know what I have here and this

483
00:40:25,430 --> 00:40:29,819
hardware by the way is able to do some
of the power glitching and in clock what

484
00:40:29,820 --> 00:40:32,940
you gonna be showing you but I want to
show it to you on something you know

485
00:40:32,940 --> 00:40:38,250
more interesting than just that little
microcontroller so I have two videos of

486
00:40:38,250 --> 00:40:42,610
running it on the Raspberry Pi in an
Android phone to the general crude I'm

487
00:40:42,610 --> 00:40:44,560
running to make it you know

488
00:40:44,560 --> 00:40:48,980
easier to see after the demo purposes is
I just have this for loop as those in

489
00:40:48,980 --> 00:40:54,640
inner loop and an error and the
objective is simply to cause it to break

490
00:40:54,640 --> 00:40:59,430
out of this loop or otherwise do this
county incorrectly what this means is

491
00:40:59,430 --> 00:41:02,980
that it either skipped over an
instruction or executed it incorrectly

492
00:41:02,980 --> 00:41:09,360
in practice what this means is that if
you're able to get that to work it's

493
00:41:09,360 --> 00:41:14,090
more or less a matter of your time
interlock to try to get it to break over

494
00:41:14,090 --> 00:41:17,190
specific instructions within the device

495
00:41:17,190 --> 00:41:25,670
for the Raspberry Pi I'm gonna do this
is actually going to short to power

496
00:41:25,670 --> 00:41:31,349
supply of the red grape pie in a very
very predictable manner so on the

497
00:41:31,349 --> 00:41:36,950
Raspberry Pi has this core voltage is
here and all I do is I have a wire

498
00:41:36,950 --> 00:41:44,279
attached to that section of the board so
the core voltages and the other side of

499
00:41:44,280 --> 00:41:49,270
it so there's the side of the capacitor
this little tiny wire soldered on on the

500
00:41:49,270 --> 00:41:52,500
other side of it I have it connected to
an electronic switch services like a

501
00:41:52,500 --> 00:41:58,540
MOSFET that's $1 off digi-key knows it's
all stuff you can experiment with and

502
00:41:58,540 --> 00:42:03,009
all these switches gonna do is when it's
an able to this is the regular voltage

503
00:42:03,010 --> 00:42:12,260
here is I think you can't quite see but
it's about 1.2 volts like that so when i

504
00:42:12,260 --> 00:42:17,520
turn on the switch it goes down to zero
voltage shorting out and actually when I

505
00:42:17,520 --> 00:42:21,990
release it due to how the power
distribution in the Raspberry Pi works

506
00:42:21,990 --> 00:42:25,990
you see it actually shoot way up because
like we're in a range and has this crazy

507
00:42:25,990 --> 00:42:31,439
rain and stuff like that this is not
good for the electronics and it will

508
00:42:31,440 --> 00:42:45,930
cause these glitches to happen so your
movie of that

509
00:42:45,930 --> 00:42:54,470
there's no sound on the movies are not
missing out on anything don't worry ok

510
00:42:54,470 --> 00:42:58,540
so this is the raspberry PI's same thing
I'm showing you in I'm going to compile

511
00:42:58,540 --> 00:43:04,609
that really simple loop on top of Linux
so I'm not running this you know raid on

512
00:43:04,609 --> 00:43:10,790
the hardware on the side there the
screen I have device spinning just

513
00:43:10,790 --> 00:43:15,420
confirmed that its operating the whole
time and have that same setup I showed

514
00:43:15,420 --> 00:43:18,800
you the MOSFET and it's connected to
this case I'm using chip was for a

515
00:43:18,800 --> 00:43:23,450
device to generate that pulse you can
affect use a pulse generator or program

516
00:43:23,450 --> 00:43:28,529
Arduino to say I hope in low and high
for certain amount of time it's all

517
00:43:28,530 --> 00:43:34,950
about generating just that controlled
short on the parallel and again this is

518
00:43:34,950 --> 00:43:42,890
the code I'm using it so you can see it
it's giving us the account in the inner

519
00:43:42,890 --> 00:43:46,690
loop to counter the elderly and the to
multiply together which is just the

520
00:43:46,690 --> 00:43:51,579
total number of counts it's gone through
so have something screws out those count

521
00:43:51,579 --> 00:43:54,470
should become in crack because it's
going to skip over one of the loop

522
00:43:54,470 --> 00:43:59,930
sandal think it executed it but it
actually didn't so you'll see the total

523
00:43:59,930 --> 00:44:03,020
count be wrong because it didn't run
through all of the loops the number of

524
00:44:03,020 --> 00:44:07,970
times it think it thinks it did so all
I'm doing is I'm inserting those

525
00:44:07,970 --> 00:44:14,790
glitches you can see live Paris change
there and if we look back at the the

526
00:44:14,790 --> 00:44:19,950
window here they don't scroll out we can
see at the top here there's like this

527
00:44:19,950 --> 00:44:28,868
million 4990 5000 stops I was off by one
when I started that number and so that

528
00:44:28,869 --> 00:44:34,450
you can see it's incorrectly done the
count and if we have both of them here I

529
00:44:34,450 --> 00:44:39,069
can try that again and you'll see it
incorrectly do the count and you notice

530
00:44:39,069 --> 00:44:44,460
it didn't crash so it's still hanging
over the Penguins there but it's still

531
00:44:44,460 --> 00:44:48,839
running the Linux system it's only
glitch that user land application so

532
00:44:48,839 --> 00:44:52,710
that's what sort of interesting is that
it's not like we have to be very

533
00:44:52,710 --> 00:44:53,900
concerned that it's

534
00:44:53,900 --> 00:44:58,810
only running one thing you can in fact
cause glitches in applications running

535
00:44:58,810 --> 00:45:10,460
on generic hardware and the same thing
for a android phone so you don't have

536
00:45:10,460 --> 00:45:20,560
any photos with that

537
00:45:20,560 --> 00:45:27,470
this is a really old Android phone and
want to break my actual phone so I've

538
00:45:27,470 --> 00:45:31,680
done more or less the same thing I have
food will come up here in a second but

539
00:45:31,680 --> 00:45:35,890
there's a very fine wire that's going to
one of the core voltages on the the main

540
00:45:35,890 --> 00:45:39,400
stock there and you know that sock as a
whole bunch of stuff in it so you can

541
00:45:39,400 --> 00:45:42,910
see kind of that wire and that wire goes
to my electronic switch to short the

542
00:45:42,910 --> 00:45:50,600
short the power supplies and we're sort
of doing the same thing so I'm gonna

543
00:45:50,600 --> 00:45:59,339
have a very human here have a little
double for loop and when it start it

544
00:45:59,340 --> 00:46:03,810
just doesn't calculations and put it the
results on the screen so I never wrote

545
00:46:03,810 --> 00:46:08,120
an Android application for this is the
first 1 I've done so you'll see it's got

546
00:46:08,120 --> 00:46:13,660
issues but you see the same thing 5,000
5,000 25 million so it's just doing

547
00:46:13,660 --> 00:46:18,230
these these two loops and checking he
did I go through all the loops or did I

548
00:46:18,230 --> 00:46:23,580
screw up if I screwed up it means that I
jumped over an instruction or I thought

549
00:46:23,580 --> 00:46:30,700
I went through something I did but if I
insert glitches while doing it we can

550
00:46:30,700 --> 00:46:36,520
cause incorrect our results to happen so
I think the next time I do a glitch on

551
00:46:36,520 --> 00:46:40,380
the Android as you'll see sometimes it
doesn't work as you expect so I have the

552
00:46:40,380 --> 00:46:41,720
same setup here

553
00:46:41,720 --> 00:46:46,790
generates a glitch in this case of
accidents crash the application so it's

554
00:46:46,790 --> 00:46:53,759
not a hundred percent reliable but it
will work sometimes you'll see it it's

555
00:46:53,760 --> 00:46:57,610
still running you know all the
background house obviously so running so

556
00:46:57,610 --> 00:47:03,000
there you can see one of the iterations
through the loop he gave the totally

557
00:47:03,000 --> 00:47:06,800
wrong number so it seems like it'd be
said about you and ran through too much

558
00:47:06,800 --> 00:47:12,120
more times or something like that so
it's interesting because it's very easy

559
00:47:12,120 --> 00:47:16,310
to do it doesn't you know I haven't done
any intent invasive really invasive

560
00:47:16,310 --> 00:47:23,370
modifications to the hardware side on
some wires and this time they see

561
00:47:23,370 --> 00:47:25,290
another inserted there

562
00:47:25,290 --> 00:47:32,040
r so that's a real quick introduction to
glitching and you can do that on so for

563
00:47:32,040 --> 00:47:36,050
my generals I've done this on you know
the x-men gone this done and on other

564
00:47:36,050 --> 00:47:44,170
small microcontrollers arm
microcontrollers cortex and 40 so it's a

565
00:47:44,170 --> 00:47:46,200
very generic type of attack you can do

566
00:47:46,200 --> 00:47:52,560
causing these incorrect regulations well
here you know I talked about using it to

567
00:47:52,560 --> 00:47:56,950
bypass passwords you actually can use
this to break crypto as well because you

568
00:47:56,950 --> 00:48:00,910
can do stuff like you know a yes should
be running through 10 rounds if it only

569
00:48:00,910 --> 00:48:04,640
runs through one or two that's not good
because it will now leaked information

570
00:48:04,640 --> 00:48:10,060
into the safer text just as I have
broken the the for loop here you can

571
00:48:10,060 --> 00:48:13,660
break the for loop within crypto
algorithms to cause them to be

572
00:48:13,660 --> 00:48:18,350
considerably weaker because they haven't
run through every possible loop and this

573
00:48:18,350 --> 00:48:24,190
is both hardware and software has a
stable realities of the final thing

574
00:48:24,190 --> 00:48:28,680
people often ask about is what about
triggering there's a few different ways

575
00:48:28,680 --> 00:48:32,990
of this is how do I determine wind
either glitch or when to trigger you

576
00:48:32,990 --> 00:48:37,319
know my age at my side channel
measurements the two most basic things I

577
00:48:37,320 --> 00:48:43,420
can show you with that is one is the
communications protocol so you know I'm

578
00:48:43,420 --> 00:48:49,620
triggering on data sent to the device so
when I send it the allocation request I

579
00:48:49,620 --> 00:48:54,830
can trigger on the pattern indicating
that messages going over the wire and

580
00:48:54,830 --> 00:48:59,360
trigger the capture the other thing we
can do is actually trigger on patterns

581
00:48:59,360 --> 00:49:05,710
within the power measurement so in this
case these lines here is actually part

582
00:49:05,710 --> 00:49:12,000
of a for a little while to copy and some
pin code to an internal copying the

583
00:49:12,000 --> 00:49:16,050
actual pin codes are some internal
register and we can actually see that

584
00:49:16,050 --> 00:49:20,990
happen he goes through you know Force
five times these are made very unique

585
00:49:20,990 --> 00:49:26,609
signatures and you're able to set up
triggers to actually look for them in

586
00:49:26,610 --> 00:49:30,780
real time in the measurement and trigger
on that so some of the chip was for FPGA

587
00:49:30,780 --> 00:49:32,069
code is able to do that

588
00:49:32,069 --> 00:49:36,849
at not this little version I have with
you get an earlier version we had again

589
00:49:36,849 --> 00:49:40,809
everything's open source you can mix and
match you don't have to just use this

590
00:49:40,809 --> 00:49:45,019
isn't just a tool to buy something to
experiment with it but it's possible to

591
00:49:45,019 --> 00:49:51,279
do that so this is what I was talking
about the original version of the trip

592
00:49:51,279 --> 00:49:57,739
was for a used the a large FPGA board
the plugged-in it was kind of expensive

593
00:49:57,739 --> 00:50:00,699
because you have these different boards
I had to plug together came from

594
00:50:00,699 --> 00:50:05,900
different places but it was designed you
know what let's try to make a simple as

595
00:50:05,900 --> 00:50:12,009
we can to lab setup again it's not quite
at the level that hobbyists can use it

596
00:50:12,009 --> 00:50:18,839
does it cost like $1500 or if you build
it it's fairly complicated so the real

597
00:50:18,839 --> 00:50:23,109
objectives issued earlier was to do this
Kickstarter for really low cost fully

598
00:50:23,109 --> 00:50:28,989
open source of the PCB design the FPGA
and the firmware in the micro and thus

599
00:50:28,989 --> 00:50:34,779
offers all GPL license all freely
available so it's it's not one of these

600
00:50:34,779 --> 00:50:39,670
projects that has a fake no commercial
or something that's legitimate Lee you

601
00:50:39,670 --> 00:50:40,819
can do whatever you want with it

602
00:50:40,819 --> 00:50:47,019
the software ivory shoujo the
interesting thing with the software so

603
00:50:47,019 --> 00:50:53,399
this was the capturing the analyzer is
that you don't necessarily need to use

604
00:50:53,400 --> 00:50:58,839
it with just this hardware so there's
other PGA bored you can interface too if

605
00:50:58,839 --> 00:51:06,449
you want to do the capture so this is
using the ATC board here with a avnet

606
00:51:06,449 --> 00:51:13,930
ATC at lax and I'm bored here and it's
connected to a breadboard where have the

607
00:51:13,930 --> 00:51:20,069
AVR microcontroller set up to do the
test algorithms you can build your own

608
00:51:20,069 --> 00:51:24,799
so this is like a Arduino ask you know
totally bored and connected to an

609
00:51:24,799 --> 00:51:29,930
oscilloscope seniority drivers to use to
go scope in one or two other scopes in

610
00:51:29,930 --> 00:51:34,730
this office that's for doing the just
the peres measurements not the glitching

611
00:51:34,730 --> 00:51:39,619
in all of this has clearly what I
consider fairly good for an open source

612
00:51:39,619 --> 00:51:48,140
project documentation so there's a wiki
page with some of the stuff and as well

613
00:51:48,140 --> 00:51:52,270
as in you know documentation that goes
through the tutorials of hey here's how

614
00:51:52,270 --> 00:51:58,350
you do an AESA cures and you do the AES
256 bootloader type so I really hope

615
00:51:58,350 --> 00:52:02,560
that it encourages you to say hey this
is something I can go through and I can

616
00:52:02,560 --> 00:52:07,140
look at these attacks and start to learn
about how to perform them as well as had

617
00:52:07,140 --> 00:52:11,720
a test of my own hardware might be
designing stuff I'm using from vendors

618
00:52:11,720 --> 00:52:18,350
anything like that that's the real
objective of this and as a bonus because

619
00:52:18,350 --> 00:52:22,319
it's a hassle the travel stuff had the
chip whisper late here and choose

620
00:52:22,320 --> 00:52:27,230
interest in one we're gonna have a
throwaway contest here this section to

621
00:52:27,230 --> 00:52:36,890
section ok we do here if you really
don't want to give it to someone with

622
00:52:36,890 --> 00:52:39,569
her hand up I can't go that far

623
00:52:39,570 --> 00:52:49,690
acts like this ever gonna do this empty
box

624
00:52:49,690 --> 00:52:59,960
feels better let's come up to me after
the long run without either any

625
00:52:59,960 --> 00:53:17,110
questions on the project or a general
analysis and general thank you

626
00:53:17,110 --> 00:53:46,610
have a built one learns how would you
say that you would counter engaging

627
00:53:46,610 --> 00:53:52,180
problems when you're developing these
things we do as a developer to not

628
00:53:52,180 --> 00:53:57,270
worried about switching problems it's
very hard to glitching problems because

629
00:53:57,270 --> 00:54:01,820
you know it's really just that you can't
necessarily trust these offered actually

630
00:54:01,820 --> 00:54:04,190
execute this stuff correctly

631
00:54:04,190 --> 00:54:08,020
a lot of the the glitching problems
overlap with really high reliability

632
00:54:08,020 --> 00:54:13,310
software were you know they don't trust
the hardware for other reasons

633
00:54:13,310 --> 00:54:18,460
running in space to some of the
solutions from that where they all do

634
00:54:18,460 --> 00:54:24,180
the same operations a few times and then
check the results can help it's hard

635
00:54:24,180 --> 00:54:28,660
because if you attackers explicitly
trying to screw up your hardware it's

636
00:54:28,660 --> 00:54:32,640
not the same problem as random cosmic
rays looking a bit your attacker might

637
00:54:32,640 --> 00:54:38,900
be able to flip that same bit three
times in a row off and it's not very

638
00:54:38,900 --> 00:54:44,110
easy problem to solve most of it is
considering what if I don't trust every

639
00:54:44,110 --> 00:54:50,210
every correct execution of every single
instruction most of the time if you can

640
00:54:50,210 --> 00:54:57,520
fix that that's a smart cards the smart
card there's another they have

641
00:54:57,520 --> 00:55:01,880
protection built into hardware so they
basically try to design into the

642
00:55:01,880 --> 00:55:07,700
hardware circuitry that it doesn't it's
more resistant to this you can do stuff

643
00:55:07,700 --> 00:55:12,259
you know on the chip to make it such
that if the power drop so it resets

644
00:55:12,260 --> 00:55:14,130
right away instead of

645
00:55:14,130 --> 00:55:22,440
even that people got around but it's
more difficult to have questions for

646
00:55:22,440 --> 00:55:31,250
sure we have really

647
00:55:31,250 --> 00:55:32,110
case

