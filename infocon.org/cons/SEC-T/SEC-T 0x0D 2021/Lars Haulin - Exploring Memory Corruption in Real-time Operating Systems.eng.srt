1
00:00:03,840 --> 00:00:06,240
so hello everyone my name is laura

2
00:00:06,240 --> 00:00:08,559
charlene i'm going to present my

3
00:00:08,559 --> 00:00:10,800
presentation called exploring memory

4
00:00:10,800 --> 00:00:12,639
corruption on real-time operating

5
00:00:12,639 --> 00:00:13,679
systems

6
00:00:13,679 --> 00:00:16,480
just first a quick question uh anyone

7
00:00:16,480 --> 00:00:18,080
here familiar with the real-time

8
00:00:18,080 --> 00:00:20,160
operating systems or embedded systems in

9
00:00:20,160 --> 00:00:21,760
general

10
00:00:21,760 --> 00:00:22,880
so uh

11
00:00:22,880 --> 00:00:24,640
small minority

12
00:00:24,640 --> 00:00:27,599
memory corruption

13
00:00:28,240 --> 00:00:29,760
a bit more

14
00:00:29,760 --> 00:00:31,599
security implications

15
00:00:31,599 --> 00:00:33,840
from

16
00:00:34,160 --> 00:00:36,239
bugs

17
00:00:36,239 --> 00:00:38,640
yeah

18
00:00:38,879 --> 00:00:40,960
so

19
00:00:40,960 --> 00:00:43,120
who am i my name is laura charlene i

20
00:00:43,120 --> 00:00:45,840
work as a cyber security engineer

21
00:00:45,840 --> 00:00:47,520
i have previously been working as cyber

22
00:00:47,520 --> 00:00:50,160
security consultant doing pen testing

23
00:00:50,160 --> 00:00:51,920
and also been working as an embedded

24
00:00:51,920 --> 00:00:53,600
systems developer

25
00:00:53,600 --> 00:00:57,680
in automotive and medical industries

26
00:00:57,680 --> 00:00:59,920
engineering physics in the in the ground

27
00:00:59,920 --> 00:01:02,559
or not but currently i'm a cyber

28
00:01:02,559 --> 00:01:05,519
security engineer which means that i

29
00:01:05,519 --> 00:01:08,400
do threat modeling risk assessment and

30
00:01:08,400 --> 00:01:10,560
educate my

31
00:01:10,560 --> 00:01:12,880
the developers that i cooperate with

32
00:01:12,880 --> 00:01:14,240
i also

33
00:01:14,240 --> 00:01:17,040
been playing a lot of ctfs for the last

34
00:01:17,040 --> 00:01:18,960
10 plus years since before they were

35
00:01:18,960 --> 00:01:21,200
called ctfs they were called war games

36
00:01:21,200 --> 00:01:22,320
back then

37
00:01:22,320 --> 00:01:24,960
and i also coached a student ctf team at

38
00:01:24,960 --> 00:01:27,200
uppsala university

39
00:01:27,200 --> 00:01:29,119
so when i take

40
00:01:29,119 --> 00:01:31,280
all of everything that i'm interested in

41
00:01:31,280 --> 00:01:34,079
and put it together risk evaluation cdfs

42
00:01:34,079 --> 00:01:36,159
embedded systems electronics and try to

43
00:01:36,159 --> 00:01:37,680
create something that gives a learning

44
00:01:37,680 --> 00:01:38,960
experience

45
00:01:38,960 --> 00:01:41,600
i ended up with this project that i'm

46
00:01:41,600 --> 00:01:44,000
going to present now i have created a

47
00:01:44,000 --> 00:01:45,280
playground

48
00:01:45,280 --> 00:01:47,360
a dockerized environment with a that

49
00:01:47,360 --> 00:01:49,600
compiles real-time operating systems

50
00:01:49,600 --> 00:01:52,320
with small vulnerable applications

51
00:01:52,320 --> 00:01:53,520
and

52
00:01:53,520 --> 00:01:54,960
i wanted to be

53
00:01:54,960 --> 00:01:58,240
the mingo i wanted to evaluate the

54
00:01:58,240 --> 00:02:00,560
exploit mitigation mechanisms that were

55
00:02:00,560 --> 00:02:03,119
present in those systems

56
00:02:03,119 --> 00:02:04,159
and uh

57
00:02:04,159 --> 00:02:06,159
i also wanted to be able to emulate a

58
00:02:06,159 --> 00:02:08,479
microcontroller without hardware

59
00:02:08,479 --> 00:02:10,000
it is usually best when you have

60
00:02:10,000 --> 00:02:12,080
hardware but if you don't have access to

61
00:02:12,080 --> 00:02:14,400
it it's nice if you can emulate it in a

62
00:02:14,400 --> 00:02:16,160
good and easy way

63
00:02:16,160 --> 00:02:18,720
and this is what i prepared

64
00:02:18,720 --> 00:02:20,319
in the container

65
00:02:20,319 --> 00:02:22,400
and the side results that i'm going to

66
00:02:22,400 --> 00:02:24,080
present here is

67
00:02:24,080 --> 00:02:26,319
something that i hope will be useful

68
00:02:26,319 --> 00:02:29,200
interesting and and fun

69
00:02:29,200 --> 00:02:31,840
so overall agenda there weren't many

70
00:02:31,840 --> 00:02:34,959
like here who had been

71
00:02:34,959 --> 00:02:36,239
having experience with real-time

72
00:02:36,239 --> 00:02:38,239
operating systems so i will mention that

73
00:02:38,239 --> 00:02:39,200
a bit

74
00:02:39,200 --> 00:02:42,080
and what kind of threats and risks that

75
00:02:42,080 --> 00:02:43,920
are present there

76
00:02:43,920 --> 00:02:46,080
also a bit about the microcontroller

77
00:02:46,080 --> 00:02:48,720
memory space that i have looked at

78
00:02:48,720 --> 00:02:51,440
and we're going to do a small demo of

79
00:02:51,440 --> 00:02:53,760
the playground i created some

80
00:02:53,760 --> 00:02:56,319
conclusions and future work

81
00:02:56,319 --> 00:02:58,800
i did assume that i didn't have to

82
00:02:58,800 --> 00:03:01,280
introduce memory corruption any further

83
00:03:01,280 --> 00:03:02,840
that from the

84
00:03:02,840 --> 00:03:04,640
smaller hands

85
00:03:04,640 --> 00:03:05,680
up

86
00:03:05,680 --> 00:03:07,840
before i maybe should mention that it's

87
00:03:07,840 --> 00:03:08,879
when you have

88
00:03:08,879 --> 00:03:11,280
a programming language where you access

89
00:03:11,280 --> 00:03:13,360
memory out of bounds

90
00:03:13,360 --> 00:03:16,159
that you're not supposed to

91
00:03:16,159 --> 00:03:16,840
and

92
00:03:16,840 --> 00:03:18,640
uh

93
00:03:18,640 --> 00:03:21,280
you can override pointers and make bad

94
00:03:21,280 --> 00:03:23,480
stuff happen and there are protection

95
00:03:23,480 --> 00:03:25,920
mechanisms against that

96
00:03:25,920 --> 00:03:27,920
and that is what i'm going to look a bit

97
00:03:27,920 --> 00:03:29,200
down

98
00:03:29,200 --> 00:03:31,360
but first out real-time operating

99
00:03:31,360 --> 00:03:33,200
systems

100
00:03:33,200 --> 00:03:36,000
um a real-time operating system

101
00:03:36,000 --> 00:03:38,480
is a small operator it's usually small

102
00:03:38,480 --> 00:03:40,159
there are big ones as well

103
00:03:40,159 --> 00:03:42,400
but the main design goal with the

104
00:03:42,400 --> 00:03:44,159
real-time operating system is to be

105
00:03:44,159 --> 00:03:46,640
quick to respond to events in a

106
00:03:46,640 --> 00:03:48,799
guaranteed bounded time

107
00:03:48,799 --> 00:03:50,560
typically you have

108
00:03:50,560 --> 00:03:53,200
things controlling real world

109
00:03:53,200 --> 00:03:54,400
stuff like

110
00:03:54,400 --> 00:03:57,120
engine controllers pumps or

111
00:03:57,120 --> 00:04:00,239
airplane autopilots or the quad

112
00:04:00,239 --> 00:04:02,959
quadcopter

113
00:04:03,040 --> 00:04:06,000
regulating mechanisms and those kinds of

114
00:04:06,000 --> 00:04:06,959
things

115
00:04:06,959 --> 00:04:08,799
they're usually very tailored to their

116
00:04:08,799 --> 00:04:09,760
purpose

117
00:04:09,760 --> 00:04:11,920
they need to be fast have a low overhead

118
00:04:11,920 --> 00:04:15,280
and execute efficiently and because of

119
00:04:15,280 --> 00:04:17,918
those constraints they're written in

120
00:04:17,918 --> 00:04:19,839
low-level implementation languages such

121
00:04:19,839 --> 00:04:21,519
as c

122
00:04:21,519 --> 00:04:23,199
which leads to the question about memory

123
00:04:23,199 --> 00:04:24,560
corruption because

124
00:04:24,560 --> 00:04:26,800
those low-level languages usually

125
00:04:26,800 --> 00:04:29,440
handles pointers directly in buffers and

126
00:04:29,440 --> 00:04:30,160
so

127
00:04:30,160 --> 00:04:31,120
so

128
00:04:31,120 --> 00:04:32,560
there can be

129
00:04:32,560 --> 00:04:34,479
memory corruption occurring in these

130
00:04:34,479 --> 00:04:36,800
systems

131
00:04:36,800 --> 00:04:39,199
so the threats against these kinds of

132
00:04:39,199 --> 00:04:42,320
systems is much the same as normal

133
00:04:42,320 --> 00:04:44,160
operating systems

134
00:04:44,160 --> 00:04:45,199
but

135
00:04:45,199 --> 00:04:47,280
whereas normal operating system usually

136
00:04:47,280 --> 00:04:49,520
have a focus on the confidentiality that

137
00:04:49,520 --> 00:04:51,680
you want to keep the information in the

138
00:04:51,680 --> 00:04:54,960
information system secret

139
00:04:54,960 --> 00:04:56,720
when you interact with the real-time

140
00:04:56,720 --> 00:04:58,560
operating system you're

141
00:04:58,560 --> 00:05:01,759
an attacker is um often more interested

142
00:05:01,759 --> 00:05:03,120
in

143
00:05:03,120 --> 00:05:06,320
affecting the function of the system

144
00:05:06,320 --> 00:05:08,800
um so

145
00:05:08,800 --> 00:05:11,840
same threat but the prioritation can get

146
00:05:11,840 --> 00:05:13,919
a bit different

147
00:05:13,919 --> 00:05:16,000
and most of these

148
00:05:16,000 --> 00:05:17,919
threats that we have they can be caused

149
00:05:17,919 --> 00:05:21,280
by memory corruption programs

150
00:05:21,280 --> 00:05:22,400
so

151
00:05:22,400 --> 00:05:24,960
a bunk-free program program probably

152
00:05:24,960 --> 00:05:26,400
doesn't have any memory corruption

153
00:05:26,400 --> 00:05:28,320
vulnerabilities so why don't we just

154
00:05:28,320 --> 00:05:31,039
write correct code from the beginning

155
00:05:31,039 --> 00:05:33,039
isn't that what every programmer thinks

156
00:05:33,039 --> 00:05:34,000
about

157
00:05:34,000 --> 00:05:36,240
how to write correct code

158
00:05:36,240 --> 00:05:37,919
for embedded systems and real-time

159
00:05:37,919 --> 00:05:40,240
operations and there are a few good

160
00:05:40,240 --> 00:05:42,400
standards to avoid this the

161
00:05:42,400 --> 00:05:44,560
motor industry have their standards and

162
00:05:44,560 --> 00:05:47,039
the medical device software industry

163
00:05:47,039 --> 00:05:49,680
have their standards with there are also

164
00:05:49,680 --> 00:05:51,360
a lot of tools

165
00:05:51,360 --> 00:05:52,400
to

166
00:05:52,400 --> 00:05:54,240
go through your code and

167
00:05:54,240 --> 00:05:57,360
to see that all bounds are verified

168
00:05:57,360 --> 00:05:59,120
you can also use

169
00:05:59,120 --> 00:06:02,639
the newer modern memory safe languages

170
00:06:02,639 --> 00:06:06,400
that are low level such as rust but the

171
00:06:06,400 --> 00:06:09,520
industry is a bit slow in this area so

172
00:06:09,520 --> 00:06:11,120
we will see when it

173
00:06:11,120 --> 00:06:12,560
comes ahead

174
00:06:12,560 --> 00:06:15,440
but the main conclusion is that writing

175
00:06:15,440 --> 00:06:17,600
good correct code

176
00:06:17,600 --> 00:06:20,160
takes time and effort

177
00:06:20,160 --> 00:06:23,120
um if we look a bit further into the

178
00:06:23,120 --> 00:06:24,960
medical device software standard about

179
00:06:24,960 --> 00:06:27,199
software life cycle processes

180
00:06:27,199 --> 00:06:31,199
um yeah the iec 62303 it's a standard

181
00:06:31,199 --> 00:06:33,520
for how to make a risk-based software

182
00:06:33,520 --> 00:06:34,720
development

183
00:06:34,720 --> 00:06:36,960
because if you make a medical device

184
00:06:36,960 --> 00:06:39,280
you need to consider all kind of impacts

185
00:06:39,280 --> 00:06:41,199
it could have on health

186
00:06:41,199 --> 00:06:42,960
and it can be very tedious to follow all

187
00:06:42,960 --> 00:06:45,039
this because there are many people

188
00:06:45,039 --> 00:06:46,800
involved a line of code written i think

189
00:06:46,800 --> 00:06:47,600
we

190
00:06:47,600 --> 00:06:49,759
we counted to nine

191
00:06:49,759 --> 00:06:52,160
per line of code in the project i was

192
00:06:52,160 --> 00:06:53,919
involved in and it was include

193
00:06:53,919 --> 00:06:56,960
implementation direct review more formal

194
00:06:56,960 --> 00:07:00,240
review testing and review of the testing

195
00:07:00,240 --> 00:07:02,400
and then formal sign off for every line

196
00:07:02,400 --> 00:07:03,440
of code

197
00:07:03,440 --> 00:07:05,759
so that's a lot of work

198
00:07:05,759 --> 00:07:07,919
but that is only for the code that you

199
00:07:07,919 --> 00:07:09,680
write yourself

200
00:07:09,680 --> 00:07:11,759
what about library code that you import

201
00:07:11,759 --> 00:07:14,880
into your program how do we

202
00:07:14,880 --> 00:07:17,759
we i guess most of us who program have

203
00:07:17,759 --> 00:07:20,080
have used code that you haven't

204
00:07:20,080 --> 00:07:21,520
written yourself

205
00:07:21,520 --> 00:07:24,000
but can you be really sure that it is

206
00:07:24,000 --> 00:07:25,759
actually well behaving

207
00:07:25,759 --> 00:07:27,440
and that it does not have any memory

208
00:07:27,440 --> 00:07:29,280
corruption vulnerabilities you can run

209
00:07:29,280 --> 00:07:32,160
these scanner tools that are available

210
00:07:32,160 --> 00:07:33,120
but

211
00:07:33,120 --> 00:07:34,960
usually when you run such a tool for the

212
00:07:34,960 --> 00:07:36,080
first time

213
00:07:36,080 --> 00:07:38,160
you get a lot of warnings like there

214
00:07:38,160 --> 00:07:39,680
you're missing a type cost here it's

215
00:07:39,680 --> 00:07:42,240
implicit you need to be explicit

216
00:07:42,240 --> 00:07:43,280
so

217
00:07:43,280 --> 00:07:46,720
it can be a lot of effort to do this

218
00:07:46,720 --> 00:07:48,800
so it's a risk-based decision if you

219
00:07:48,800 --> 00:07:50,960
want to include libraries and how you go

220
00:07:50,960 --> 00:07:52,639
on including it

221
00:07:52,639 --> 00:07:54,560
there is a name

222
00:07:54,560 --> 00:07:55,520
for

223
00:07:55,520 --> 00:07:58,479
in the iec 6233

224
00:07:58,479 --> 00:08:00,080
for this kind of software it's called

225
00:08:00,080 --> 00:08:03,199
software of unknown provenance

226
00:08:03,199 --> 00:08:05,440
and this is software that either has

227
00:08:05,440 --> 00:08:07,199
already been developed

228
00:08:07,199 --> 00:08:09,680
so like normal libraries

229
00:08:09,680 --> 00:08:11,440
um

230
00:08:11,440 --> 00:08:14,319
or it is some kind of internally based

231
00:08:14,319 --> 00:08:15,919
software maybe from a previous project

232
00:08:15,919 --> 00:08:17,599
that hasn't been having a formal

233
00:08:17,599 --> 00:08:19,280
development process

234
00:08:19,280 --> 00:08:20,879
so you don't have any guarantees that

235
00:08:20,879 --> 00:08:22,720
this code does what it's actually

236
00:08:22,720 --> 00:08:24,800
supposed to do

237
00:08:24,800 --> 00:08:25,599
so

238
00:08:25,599 --> 00:08:27,039
what you want to do in those cancer

239
00:08:27,039 --> 00:08:28,879
cases if you have if you have a system

240
00:08:28,879 --> 00:08:31,199
that is life critical like

241
00:08:31,199 --> 00:08:32,799
this machine

242
00:08:32,799 --> 00:08:35,440
makes sure that some a person is staying

243
00:08:35,440 --> 00:08:36,640
alive

244
00:08:36,640 --> 00:08:38,958
then you must be really really sure that

245
00:08:38,958 --> 00:08:40,719
you have an acceptable risk level in

246
00:08:40,719 --> 00:08:42,240
your software

247
00:08:42,240 --> 00:08:43,440
and the

248
00:08:43,440 --> 00:08:46,480
overall goal of this the the highest

249
00:08:46,480 --> 00:08:48,560
degree of taking it to the most extreme

250
00:08:48,560 --> 00:08:50,480
level is to have code actually running

251
00:08:50,480 --> 00:08:53,120
on different processors you put

252
00:08:53,120 --> 00:08:55,839
a small separate processor running the

253
00:08:55,839 --> 00:08:58,959
things you want to really control

254
00:08:58,959 --> 00:09:01,120
and then you maybe interface that with a

255
00:09:01,120 --> 00:09:03,680
very well-defined communication link

256
00:09:03,680 --> 00:09:04,480
to

257
00:09:04,480 --> 00:09:07,120
the libraries that you need to use

258
00:09:07,120 --> 00:09:10,640
but not all systems are life critical so

259
00:09:10,640 --> 00:09:12,720
you need to make you do some kind of

260
00:09:12,720 --> 00:09:15,440
reasonable decision to run the code on

261
00:09:15,440 --> 00:09:17,120
the same processor

262
00:09:17,120 --> 00:09:22,040
but then you need to rely on other um

263
00:09:22,720 --> 00:09:25,760
protection mechanisms to make sure that

264
00:09:25,760 --> 00:09:26,880
you actually

265
00:09:26,880 --> 00:09:29,200
if there should be a bug that is not

266
00:09:29,200 --> 00:09:32,560
trivial to exploit

267
00:09:32,560 --> 00:09:35,120
so on normal operating like general

268
00:09:35,120 --> 00:09:36,959
purpose operating systems and computers

269
00:09:36,959 --> 00:09:38,640
we have been having this

270
00:09:38,640 --> 00:09:42,160
protection mechanisms for a long time

271
00:09:42,160 --> 00:09:43,760
they have also been explored on

272
00:09:43,760 --> 00:09:45,680
real-time operating systems and if

273
00:09:45,680 --> 00:09:47,040
you're interested to know more about

274
00:09:47,040 --> 00:09:49,519
this there is a really great talk about

275
00:09:49,519 --> 00:09:51,519
about this called the artos exploit

276
00:09:51,519 --> 00:09:55,680
mitigation blues by jos vetzels

277
00:09:55,680 --> 00:09:57,760
it has been an inspiration for me when i

278
00:09:57,760 --> 00:09:59,120
created my

279
00:09:59,120 --> 00:10:01,360
hands-on environment that i wanted to

280
00:10:01,360 --> 00:10:02,880
like

281
00:10:02,880 --> 00:10:04,320
when i when i wanted to see those

282
00:10:04,320 --> 00:10:07,519
mechanisms hands-on uh this talk that i

283
00:10:07,519 --> 00:10:11,120
saw made me want to do this

284
00:10:11,120 --> 00:10:13,279
so uh

285
00:10:13,279 --> 00:10:16,640
first a small message

286
00:10:16,720 --> 00:10:19,279
i i need to mention one thing before we

287
00:10:19,279 --> 00:10:22,000
go through to the uh uh

288
00:10:22,000 --> 00:10:24,320
and that is uh one case such kind of

289
00:10:24,320 --> 00:10:26,160
protection and it's called stack

290
00:10:26,160 --> 00:10:27,920
canneries anyone heard of stack

291
00:10:27,920 --> 00:10:30,720
generates before

292
00:10:30,720 --> 00:10:33,040
quite a few so

293
00:10:33,040 --> 00:10:36,320
uh what what it is uh for those who if

294
00:10:36,320 --> 00:10:37,839
you haven't heard of it it's if you have

295
00:10:37,839 --> 00:10:39,279
a memory buffer

296
00:10:39,279 --> 00:10:41,839
that is on on the stack

297
00:10:41,839 --> 00:10:44,959
uh and you are not sure that you maybe

298
00:10:44,959 --> 00:10:46,640
write more to this buffer than you're

299
00:10:46,640 --> 00:10:47,839
supposed to

300
00:10:47,839 --> 00:10:50,800
you put a small value here right off the

301
00:10:50,800 --> 00:10:53,519
buffer so if you should write

302
00:10:53,519 --> 00:10:55,920
100 bytes instead of the 20 bytes that

303
00:10:55,920 --> 00:10:57,440
the buffer was

304
00:10:57,440 --> 00:11:00,480
able to hold then this value will be

305
00:11:00,480 --> 00:11:03,279
overwritten and it will be detected so

306
00:11:03,279 --> 00:11:04,959
that you can see that oh something wrong

307
00:11:04,959 --> 00:11:07,440
has happened we should abort the

308
00:11:07,440 --> 00:11:09,279
execution of the system

309
00:11:09,279 --> 00:11:11,279
because something bad has happened

310
00:11:11,279 --> 00:11:13,680
should ultimately be

311
00:11:13,680 --> 00:11:15,519
hard to predict what this value is

312
00:11:15,519 --> 00:11:18,399
because if you know what this value is

313
00:11:18,399 --> 00:11:20,240
then an attacker can

314
00:11:20,240 --> 00:11:22,800
write filled up the buffer and then

315
00:11:22,800 --> 00:11:24,959
write the exact value and then write

316
00:11:24,959 --> 00:11:26,959
more data and overwrite other data

317
00:11:26,959 --> 00:11:29,279
structures in the systems

318
00:11:29,279 --> 00:11:31,440
but this is one of the the protection

319
00:11:31,440 --> 00:11:34,160
mechanisms that i've been looking at

320
00:11:34,160 --> 00:11:36,880
i have also been uh for my case study

321
00:11:36,880 --> 00:11:40,000
i've been showing a microcontroller

322
00:11:40,000 --> 00:11:41,920
and there are many and they have all

323
00:11:41,920 --> 00:11:43,360
kind of strange

324
00:11:43,360 --> 00:11:45,680
memory layouts but i have chosen arm

325
00:11:45,680 --> 00:11:48,160
cortex and processor it's very common in

326
00:11:48,160 --> 00:11:50,800
use it has a 32-bit address space and

327
00:11:50,800 --> 00:11:53,360
it's well documented

328
00:11:53,360 --> 00:11:54,560
this is uh

329
00:11:54,560 --> 00:11:56,560
i realize this is a really small picture

330
00:11:56,560 --> 00:11:59,200
but this is from the cortex-m4 technical

331
00:11:59,200 --> 00:12:00,560
reference manual

332
00:12:00,560 --> 00:12:02,160
so the memory

333
00:12:02,160 --> 00:12:05,200
the the important thing from this uh uh

334
00:12:05,200 --> 00:12:07,519
see i think i can do

335
00:12:07,519 --> 00:12:10,560
no i can't do laser point a yo yeah

336
00:12:10,560 --> 00:12:11,519
so

337
00:12:11,519 --> 00:12:13,920
the memory is divided into eight regions

338
00:12:13,920 --> 00:12:16,880
and we have the code memory in flash and

339
00:12:16,880 --> 00:12:20,240
the sram and we have the peripherals

340
00:12:20,240 --> 00:12:21,360
because

341
00:12:21,360 --> 00:12:23,040
when

342
00:12:23,040 --> 00:12:25,839
a microcontroller is interacting with

343
00:12:25,839 --> 00:12:27,360
this world it can

344
00:12:27,360 --> 00:12:29,120
read electrical signals write their

345
00:12:29,120 --> 00:12:31,519
electrical signals or

346
00:12:31,519 --> 00:12:34,880
maybe blink lamps or

347
00:12:34,880 --> 00:12:37,279
send radio signals then it does this by

348
00:12:37,279 --> 00:12:40,000
writing to these memory addresses

349
00:12:40,000 --> 00:12:42,399
so and this is important because if we

350
00:12:42,399 --> 00:12:45,360
get arbitrary memory writes in this

351
00:12:45,360 --> 00:12:47,200
processor then that would

352
00:12:47,200 --> 00:12:49,360
be then we will be able to write to the

353
00:12:49,360 --> 00:12:52,000
peripheral registers and affect things

354
00:12:52,000 --> 00:12:54,800
in the physical real world

355
00:12:54,800 --> 00:12:56,560
um

356
00:12:56,560 --> 00:12:58,079
but the important thing for us to know

357
00:12:58,079 --> 00:13:02,079
is like uh writing to a memory can be

358
00:13:02,079 --> 00:13:03,680
the same thing as

359
00:13:03,680 --> 00:13:06,480
affecting something in the real world

360
00:13:06,480 --> 00:13:08,959
but now on to

361
00:13:08,959 --> 00:13:11,279
what i have created i have created a

362
00:13:11,279 --> 00:13:12,480
playground

363
00:13:12,480 --> 00:13:15,519
and what i wanted to be able to was to

364
00:13:15,519 --> 00:13:17,920
build emulate

365
00:13:17,920 --> 00:13:20,000
and debug small real-time operating

366
00:13:20,000 --> 00:13:22,240
systems programs and

367
00:13:22,240 --> 00:13:24,320
one of my goals was this should be easy

368
00:13:24,320 --> 00:13:26,240
to set up and use

369
00:13:26,240 --> 00:13:29,040
so i chose to make tokyo container to do

370
00:13:29,040 --> 00:13:31,600
this for me

371
00:13:31,600 --> 00:13:32,320
and

372
00:13:32,320 --> 00:13:34,480
this docu container automates the

373
00:13:34,480 --> 00:13:36,000
download installation of compiler

374
00:13:36,000 --> 00:13:38,480
toolchains installs an emulator and

375
00:13:38,480 --> 00:13:42,000
debugger and source code and

376
00:13:42,000 --> 00:13:44,079
it does everything so you just start

377
00:13:44,079 --> 00:13:46,160
this build it and

378
00:13:46,160 --> 00:13:48,399
you're ready to go you can emulate this

379
00:13:48,399 --> 00:13:50,639
microcontroller and you can also debug

380
00:13:50,639 --> 00:13:54,160
it using the same container

381
00:13:54,160 --> 00:13:55,680
um

382
00:13:55,680 --> 00:13:57,040
and

383
00:13:57,040 --> 00:13:58,639
i have

384
00:13:58,639 --> 00:14:00,480
taken my

385
00:14:00,480 --> 00:14:02,720
hobby project and try to polish it

386
00:14:02,720 --> 00:14:05,040
together into something that i dared to

387
00:14:05,040 --> 00:14:06,480
show to others

388
00:14:06,480 --> 00:14:07,519
you

389
00:14:07,519 --> 00:14:10,959
and in that i have included two separate

390
00:14:10,959 --> 00:14:12,880
real-time operating systems i will

391
00:14:12,880 --> 00:14:14,639
mainly be focusing on sapphire from the

392
00:14:14,639 --> 00:14:16,399
linux foundation

393
00:14:16,399 --> 00:14:18,800
but the results i also included

394
00:14:18,800 --> 00:14:21,199
one example application for free rtos

395
00:14:21,199 --> 00:14:23,360
because uh i will come to later why i

396
00:14:23,360 --> 00:14:24,639
did that

397
00:14:24,639 --> 00:14:26,160
so uh

398
00:14:26,160 --> 00:14:29,199
the usage for this one it's just

399
00:14:29,199 --> 00:14:31,120
git clone

400
00:14:31,120 --> 00:14:32,720
change directory

401
00:14:32,720 --> 00:14:34,800
run the build and extract script but you

402
00:14:34,800 --> 00:14:37,120
can't do this now because it takes 25

403
00:14:37,120 --> 00:14:38,480
minutes and i don't have

404
00:14:38,480 --> 00:14:40,320
i don't have that much time

405
00:14:40,320 --> 00:14:42,800
and then you just do docker compose run

406
00:14:42,800 --> 00:14:44,959
with this application

407
00:14:44,959 --> 00:14:48,240
so this uh simple stack buff for buffer

408
00:14:48,240 --> 00:14:49,360
overflow

409
00:14:49,360 --> 00:14:52,959
it's a demo oh sorry not that

410
00:14:52,959 --> 00:14:54,399
it's

411
00:14:54,399 --> 00:14:57,360
this is what it looks like

412
00:14:57,360 --> 00:14:58,959
so um

413
00:14:58,959 --> 00:15:00,639
it's just a small vulnerable function

414
00:15:00,639 --> 00:15:02,160
with a small buffer

415
00:15:02,160 --> 00:15:04,160
and it prints out the prompts

416
00:15:04,160 --> 00:15:05,440
and then it

417
00:15:05,440 --> 00:15:08,560
reads a line and copies to this buffer

418
00:15:08,560 --> 00:15:10,480
and if you write some this buffer is

419
00:15:10,480 --> 00:15:13,279
only designed to contain 32 characters

420
00:15:13,279 --> 00:15:15,120
if you write more then we will overwrite

421
00:15:15,120 --> 00:15:16,880
control structures in this program and

422
00:15:16,880 --> 00:15:18,880
we will

423
00:15:18,880 --> 00:15:21,120
we will probably make it crash

424
00:15:21,120 --> 00:15:23,120
but i will now do a

425
00:15:23,120 --> 00:15:25,199
live demo of this

426
00:15:25,199 --> 00:15:28,320
so here i am is this too small i can

427
00:15:28,320 --> 00:15:30,320
probably

428
00:15:30,320 --> 00:15:33,040
change the font size a bit

429
00:15:33,040 --> 00:15:36,399
so here we are in the uh i have cloned

430
00:15:36,399 --> 00:15:38,959
the the um and i have cloned and built

431
00:15:38,959 --> 00:15:41,920
it so it won't take 25 minutes

432
00:15:41,920 --> 00:15:44,399
so and we just do we run this stack

433
00:15:44,399 --> 00:15:46,240
buffer overflow container

434
00:15:46,240 --> 00:15:47,440
and the

435
00:15:47,440 --> 00:15:49,440
rm is because i don't want to keep it

436
00:15:49,440 --> 00:15:50,880
after i've done so it's we'll just

437
00:15:50,880 --> 00:15:52,560
remove it

438
00:15:52,560 --> 00:15:55,839
so we run this

439
00:15:57,759 --> 00:15:59,920
it takes a while but then the x with the

440
00:15:59,920 --> 00:16:01,680
image just starts so we can do

441
00:16:01,680 --> 00:16:02,880
something

442
00:16:02,880 --> 00:16:05,279
and it will copy things to the to the

443
00:16:05,279 --> 00:16:07,759
buffer but if we write more than 32

444
00:16:07,759 --> 00:16:09,360
characters

445
00:16:09,360 --> 00:16:12,639
do you have any guess what would happen

446
00:16:15,120 --> 00:16:18,160
well yes it would have been segfault if

447
00:16:18,160 --> 00:16:20,399
we had been on a higher level operating

448
00:16:20,399 --> 00:16:22,720
system but this is a low level option so

449
00:16:22,720 --> 00:16:24,800
we get a memory protection unit fault

450
00:16:24,800 --> 00:16:27,680
which is a bit more closer to the metal

451
00:16:27,680 --> 00:16:29,680
but we get this instruction access

452
00:16:29,680 --> 00:16:33,440
violation and if we're trying to execute

453
00:16:33,440 --> 00:16:37,839
on this address 41 41 41 40.

454
00:16:37,839 --> 00:16:39,040
and the

455
00:16:39,040 --> 00:16:41,759
the hexadecimal character for the big a

456
00:16:41,759 --> 00:16:43,360
is 41.

457
00:16:43,360 --> 00:16:46,639
and the reason that we get 40 is because

458
00:16:46,639 --> 00:16:47,519
on

459
00:16:47,519 --> 00:16:51,120
arm we the lowest bit in an address

460
00:16:51,120 --> 00:16:53,759
is used to specify if it should be a 16

461
00:16:53,759 --> 00:16:56,079
16 bit or 32 bit instruction and they

462
00:16:56,079 --> 00:16:59,120
are always 16 bit aligned

463
00:16:59,120 --> 00:17:00,160
so

464
00:17:00,160 --> 00:17:03,360
that's why it's not 41 in the end

465
00:17:03,360 --> 00:17:06,400
so uh now right now you can see that it

466
00:17:06,400 --> 00:17:08,480
is hanged but we can what we can do is

467
00:17:08,480 --> 00:17:11,359
to with the this is qmo so we can enter

468
00:17:11,359 --> 00:17:15,119
the monitor we're doing control ac

469
00:17:15,119 --> 00:17:18,160
and we can quit and then we get back to

470
00:17:18,160 --> 00:17:20,240
bash instead

471
00:17:20,240 --> 00:17:21,199
so

472
00:17:21,199 --> 00:17:22,160
um

473
00:17:22,160 --> 00:17:24,959
back to uh so this was the simple stack

474
00:17:24,959 --> 00:17:26,720
buffer overflow

475
00:17:26,720 --> 00:17:27,439
but

476
00:17:27,439 --> 00:17:30,240
what can we do to add protections here

477
00:17:30,240 --> 00:17:33,440
um we can use this exact same code

478
00:17:33,440 --> 00:17:36,559
but we add this line to the the build

479
00:17:36,559 --> 00:17:37,919
configure

480
00:17:37,919 --> 00:17:40,559
to use the stack canaries instead

481
00:17:40,559 --> 00:17:42,880
and uh

482
00:17:42,880 --> 00:17:47,120
i have prepared that as well so

483
00:17:48,559 --> 00:17:50,000
should be

484
00:17:50,000 --> 00:17:51,200
canary

485
00:17:51,200 --> 00:17:53,760
yes tab completion takes a bit time

486
00:17:53,760 --> 00:17:56,880
so if you run this it looks

487
00:17:56,880 --> 00:18:00,160
this function is the same

488
00:18:00,160 --> 00:18:02,080
should be at least but now if we try to

489
00:18:02,080 --> 00:18:04,559
do this

490
00:18:04,799 --> 00:18:07,840
what do you think will happen

491
00:18:08,000 --> 00:18:10,720
well the same thing happened

492
00:18:10,720 --> 00:18:11,760
no

493
00:18:11,760 --> 00:18:13,600
we can we can try we can test out this

494
00:18:13,600 --> 00:18:17,520
is hands-on we get stack check fail

495
00:18:17,520 --> 00:18:18,240
so

496
00:18:18,240 --> 00:18:20,559
even before we try to execute memory at

497
00:18:20,559 --> 00:18:22,640
this address that we overwrote

498
00:18:22,640 --> 00:18:25,360
the program recognizes that something as

499
00:18:25,360 --> 00:18:27,440
bad has happened to the memory layout so

500
00:18:27,440 --> 00:18:31,600
we the execution is supported

501
00:18:31,679 --> 00:18:34,160
and that is

502
00:18:34,320 --> 00:18:36,799
uh yeah so that is how the the

503
00:18:36,799 --> 00:18:39,360
protection for that works

504
00:18:39,360 --> 00:18:41,280
um

505
00:18:41,280 --> 00:18:43,679
i will also like make a third mode like

506
00:18:43,679 --> 00:18:46,640
how how does debugging work on this

507
00:18:46,640 --> 00:18:47,760
so uh

508
00:18:47,760 --> 00:18:50,960
i have prepared now two terminals

509
00:18:50,960 --> 00:18:51,919
uh

510
00:18:51,919 --> 00:18:55,039
so what we do then is we run

511
00:18:55,039 --> 00:18:56,720
this we can write the same with the

512
00:18:56,720 --> 00:18:58,960
canary

513
00:18:58,960 --> 00:19:00,799
but now we also need when we want to do

514
00:19:00,799 --> 00:19:03,840
debugging uh we should specify that we

515
00:19:03,840 --> 00:19:05,200
want to

516
00:19:05,200 --> 00:19:07,520
be able to communicate with the network

517
00:19:07,520 --> 00:19:11,840
ports on this so we add a service

518
00:19:11,919 --> 00:19:14,559
ports

519
00:19:14,559 --> 00:19:17,600
and then start this

520
00:19:19,600 --> 00:19:23,879
no what did i do wrong

521
00:19:30,400 --> 00:19:34,120
all right thank you

522
00:19:40,559 --> 00:19:41,600
yeah

523
00:19:41,600 --> 00:19:44,080
so now when we want to enable debugging

524
00:19:44,080 --> 00:19:47,520
we should go in rtos presentation

525
00:19:47,520 --> 00:19:52,039
uh artists play

526
00:19:52,799 --> 00:19:54,720
playground sapphire

527
00:19:54,720 --> 00:19:57,120
sapphire is the operating system we're

528
00:19:57,120 --> 00:19:59,200
using here so the the one from the linux

529
00:19:59,200 --> 00:20:01,440
foundation so what we do now is we do

530
00:20:01,440 --> 00:20:05,120
almost the same we do a dark

531
00:20:05,120 --> 00:20:08,320
darker compose

532
00:20:10,080 --> 00:20:11,280
run

533
00:20:11,280 --> 00:20:12,720
r m

534
00:20:12,720 --> 00:20:14,880
and the uh

535
00:20:14,880 --> 00:20:18,440
stack buff

536
00:20:22,320 --> 00:20:24,159
but now we've run this with a special

537
00:20:24,159 --> 00:20:25,600
command we run it

538
00:20:25,600 --> 00:20:27,840
with the debug

539
00:20:27,840 --> 00:20:30,000
but before we run this we want to tell

540
00:20:30,000 --> 00:20:32,720
uh the original emulated program that we

541
00:20:32,720 --> 00:20:36,480
want to listen to gdp so we open the

542
00:20:36,480 --> 00:20:40,400
monitor for qmo with the control adc

543
00:20:40,400 --> 00:20:44,080
and we do gdb server

544
00:20:44,080 --> 00:20:46,000
now we're listening for a gdp connection

545
00:20:46,000 --> 00:20:48,480
for this device

546
00:20:48,480 --> 00:20:52,159
and we start the debug script here

547
00:20:52,159 --> 00:20:54,080
and this will start a

548
00:20:54,080 --> 00:20:55,360
gdb

549
00:20:55,360 --> 00:20:58,400
and it will run it and connect it so we

550
00:20:58,400 --> 00:21:00,080
connect and we can see that when we're

551
00:21:00,080 --> 00:21:03,840
connected we were in cpu idle

552
00:21:04,159 --> 00:21:07,200
great so we can

553
00:21:07,520 --> 00:21:10,240
go back to the normals so we can now

554
00:21:10,240 --> 00:21:11,760
know that this program is running but we

555
00:21:11,760 --> 00:21:13,679
also have the debugger

556
00:21:13,679 --> 00:21:17,039
so what we can do is to

557
00:21:17,039 --> 00:21:19,200
let's say we break

558
00:21:19,200 --> 00:21:21,159
and we disassemble this

559
00:21:21,159 --> 00:21:23,919
vulnerability vulnerable function it's

560
00:21:23,919 --> 00:21:26,320
called vol

561
00:21:26,320 --> 00:21:28,720
i don't know how many here read the arm

562
00:21:28,720 --> 00:21:31,840
assembler fluently

563
00:21:32,960 --> 00:21:35,280
yeah a few so

564
00:21:35,280 --> 00:21:37,360
this these are the the uh the

565
00:21:37,360 --> 00:21:39,039
microcontroller instructions that are

566
00:21:39,039 --> 00:21:41,039
running here so

567
00:21:41,039 --> 00:21:43,200
what what we want we can look at the

568
00:21:43,200 --> 00:21:46,080
function calls uh it runs is a sprint

569
00:21:46,080 --> 00:21:47,520
and then it gets the line and then it

570
00:21:47,520 --> 00:21:49,200
has a string copy

571
00:21:49,200 --> 00:21:51,679
and then it is some kind of conditional

572
00:21:51,679 --> 00:21:53,760
jump and if

573
00:21:53,760 --> 00:21:56,080
it com here it compares two registers

574
00:21:56,080 --> 00:21:58,159
and if they are not equal then it will

575
00:21:58,159 --> 00:22:00,799
call this stack check handler

576
00:22:00,799 --> 00:22:03,919
so we would like to break just before

577
00:22:03,919 --> 00:22:06,159
this uh stack

578
00:22:06,159 --> 00:22:07,360
check

579
00:22:07,360 --> 00:22:08,880
so that would be

580
00:22:08,880 --> 00:22:12,000
here before they are compared

581
00:22:12,000 --> 00:22:14,080
and so we do a

582
00:22:14,080 --> 00:22:15,120
break

583
00:22:15,120 --> 00:22:16,240
at

584
00:22:16,240 --> 00:22:17,760
this point

585
00:22:17,760 --> 00:22:19,840
continue and if we now write something

586
00:22:19,840 --> 00:22:21,360
in something short we don't want to

587
00:22:21,360 --> 00:22:22,320
crash

588
00:22:22,320 --> 00:22:24,880
because we get a break and if we then

589
00:22:24,880 --> 00:22:27,120
look at the

590
00:22:27,120 --> 00:22:28,880
r2 and r3

591
00:22:28,880 --> 00:22:31,039
you can see that these values are the

592
00:22:31,039 --> 00:22:33,280
same

593
00:22:33,360 --> 00:22:35,679
so we continue

594
00:22:35,679 --> 00:22:36,880
and

595
00:22:36,880 --> 00:22:40,720
we make something a bit longer

596
00:22:40,720 --> 00:22:43,039
so what happened now we get break point

597
00:22:43,039 --> 00:22:45,200
we look at the registers we can now see

598
00:22:45,200 --> 00:22:46,159
that

599
00:22:46,159 --> 00:22:48,799
one of these values have been filled

600
00:22:48,799 --> 00:22:50,240
with 41s

601
00:22:50,240 --> 00:22:52,159
so they are not the same and they will

602
00:22:52,159 --> 00:22:54,080
not be

603
00:22:54,080 --> 00:22:56,240
but something that we cannot notice here

604
00:22:56,240 --> 00:22:58,159
that i

605
00:22:58,159 --> 00:23:00,640
i don't know if i have done a mistake in

606
00:23:00,640 --> 00:23:02,799
my compilation setup but

607
00:23:02,799 --> 00:23:04,480
can you see something strange about

608
00:23:04,480 --> 00:23:06,559
these two values here from the first run

609
00:23:06,559 --> 00:23:08,080
and the second run

610
00:23:08,080 --> 00:23:09,520
i mentioned before that the canary

611
00:23:09,520 --> 00:23:11,679
values should be hard to predict

612
00:23:11,679 --> 00:23:14,080
but in this case they are the same

613
00:23:14,080 --> 00:23:16,080
both times

614
00:23:16,080 --> 00:23:18,480
so this value here is

615
00:23:18,480 --> 00:23:20,159
it starts with the two which means it's

616
00:23:20,159 --> 00:23:21,679
a ram address

617
00:23:21,679 --> 00:23:24,880
so if we look at the what this actually

618
00:23:24,880 --> 00:23:25,600
is

619
00:23:25,600 --> 00:23:28,080
is this is the address of the stack

620
00:23:28,080 --> 00:23:29,200
check card

621
00:23:29,200 --> 00:23:31,200
no it's not the value of the stack

622
00:23:31,200 --> 00:23:34,000
checker but the actual address of it

623
00:23:34,000 --> 00:23:35,440
so

624
00:23:35,440 --> 00:23:37,280
that is a bit sketchy and i'm not sure

625
00:23:37,280 --> 00:23:38,720
if i have made something wrong or if

626
00:23:38,720 --> 00:23:42,400
someone at the the operating system

627
00:23:42,400 --> 00:23:45,039
has made something wrong but i i will

628
00:23:45,039 --> 00:23:47,279
look into that because

629
00:23:47,279 --> 00:23:49,600
if it is

630
00:23:49,600 --> 00:23:53,520
um not me then it's bad

631
00:23:55,039 --> 00:23:56,480
so um

632
00:23:56,480 --> 00:23:59,039
what i wanted to but even if we look at

633
00:23:59,039 --> 00:24:01,039
the value of this cannery we can see

634
00:24:01,039 --> 00:24:03,520
that it is quite small

635
00:24:03,520 --> 00:24:05,520
so i was looking it's

636
00:24:05,520 --> 00:24:07,360
mostly zeros and then a small value so

637
00:24:07,360 --> 00:24:09,520
if you run this a few times

638
00:24:09,520 --> 00:24:10,960
i did this

639
00:24:10,960 --> 00:24:13,440
about a thousand times

640
00:24:13,440 --> 00:24:15,360
um

641
00:24:15,360 --> 00:24:17,279
i noticed that i made another small

642
00:24:17,279 --> 00:24:20,320
program they just printed out this value

643
00:24:20,320 --> 00:24:21,840
and i saw that

644
00:24:21,840 --> 00:24:24,159
they are always low and they are the

645
00:24:24,159 --> 00:24:26,640
value of this stack henry it's set to

646
00:24:26,640 --> 00:24:28,640
the number of clock cycles it takes to

647
00:24:28,640 --> 00:24:30,480
boot up that is not the same all that

648
00:24:30,480 --> 00:24:31,600
all the time

649
00:24:31,600 --> 00:24:34,720
but it's not very different either

650
00:24:34,720 --> 00:24:36,960
so i made a

651
00:24:36,960 --> 00:24:38,960
it's a cumulative probability

652
00:24:38,960 --> 00:24:42,000
distribution also something that is not

653
00:24:42,000 --> 00:24:44,559
heard of yeah what this is like

654
00:24:44,559 --> 00:24:46,880
is this how common how the values are

655
00:24:46,880 --> 00:24:49,279
distributed and if it's steep then it

656
00:24:49,279 --> 00:24:51,039
means that there are many

657
00:24:51,039 --> 00:24:53,440
so there are quite a lot that only take

658
00:24:53,440 --> 00:24:54,400
like

659
00:24:54,400 --> 00:24:57,440
c 0 0 clock cycles to start up this is

660
00:24:57,440 --> 00:25:00,320
about 3 000 and this is about six

661
00:25:00,320 --> 00:25:02,159
thousand if you look at it in uh in

662
00:25:02,159 --> 00:25:04,799
decimal so there are only about

663
00:25:04,799 --> 00:25:07,200
three thousand values but with a high

664
00:25:07,200 --> 00:25:08,080
skew

665
00:25:08,080 --> 00:25:11,200
against somewhere between three south

666
00:25:11,200 --> 00:25:14,480
cent and three thousand five hundred so

667
00:25:14,480 --> 00:25:16,000
this is not a lot

668
00:25:16,000 --> 00:25:18,480
i tried to compute the how much

669
00:25:18,480 --> 00:25:20,000
information content this actually have

670
00:25:20,000 --> 00:25:22,880
and it's about 6 to 10 bits of entropy

671
00:25:22,880 --> 00:25:25,360
which means you need to try about 500

672
00:25:25,360 --> 00:25:28,400
times before you can guess this value so

673
00:25:28,400 --> 00:25:30,320
this is in in my setup this

674
00:25:30,320 --> 00:25:33,919
microcontroller the ios did not have a

675
00:25:33,919 --> 00:25:35,279
um

676
00:25:35,279 --> 00:25:37,679
cryptographically secure random number

677
00:25:37,679 --> 00:25:40,480
generator and so

678
00:25:40,480 --> 00:25:42,559
it had to use something that that was

679
00:25:42,559 --> 00:25:43,919
different all the time so it used to be

680
00:25:43,919 --> 00:25:46,159
clock cycles this this can be improved

681
00:25:46,159 --> 00:25:46,880
on

682
00:25:46,880 --> 00:25:51,200
but still not not really optimal

683
00:25:51,200 --> 00:25:53,490
so as a summary um

684
00:25:53,490 --> 00:25:54,880
[Music]

685
00:25:54,880 --> 00:25:57,039
this uh this playground is available on

686
00:25:57,039 --> 00:26:00,720
github and any polar request issues

687
00:26:00,720 --> 00:26:04,159
anything is very welcome it's a github

688
00:26:04,159 --> 00:26:06,640
artist playground artists playground

689
00:26:06,640 --> 00:26:08,480
and for the future i plan to add some

690
00:26:08,480 --> 00:26:11,200
some more examples there are some some

691
00:26:11,200 --> 00:26:14,080
printf examples as well that i

692
00:26:14,080 --> 00:26:16,159
didn't show now

693
00:26:16,159 --> 00:26:19,039
but i also plan to do some some heap

694
00:26:19,039 --> 00:26:20,240
threads

695
00:26:20,240 --> 00:26:22,320
and the reason i included freeartos is

696
00:26:22,320 --> 00:26:24,159
because it has four different types of

697
00:26:24,159 --> 00:26:26,320
heap implementation regarding what kind

698
00:26:26,320 --> 00:26:28,080
of performance or

699
00:26:28,080 --> 00:26:29,360
you you were looking for if you're

700
00:26:29,360 --> 00:26:32,320
looking for speed or memory efficiency

701
00:26:32,320 --> 00:26:34,640
and also naturally documentation

702
00:26:34,640 --> 00:26:35,760
tutorials

703
00:26:35,760 --> 00:26:38,559
more artists and perhaps the possibility

704
00:26:38,559 --> 00:26:41,760
to run this on real hardware targets

705
00:26:41,760 --> 00:26:42,240
so

706
00:26:42,240 --> 00:26:43,360
[Music]

707
00:26:43,360 --> 00:26:44,799
that's me

708
00:26:44,799 --> 00:26:47,120
that's all i had and thank you for

709
00:26:47,120 --> 00:26:50,600
listening to this

710
00:26:52,480 --> 00:26:56,749
[Applause]

711
00:26:58,159 --> 00:27:00,240
you

