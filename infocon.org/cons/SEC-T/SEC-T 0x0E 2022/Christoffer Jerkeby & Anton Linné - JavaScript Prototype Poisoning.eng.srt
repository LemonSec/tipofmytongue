1
00:00:02,879 --> 00:00:05,160
all right

2
00:00:05,160 --> 00:00:07,140
um thank you all for coming out

3
00:00:07,140 --> 00:00:09,059
um today we're going to talk about the

4
00:00:09,059 --> 00:00:11,880
new uh bug class called prototype

5
00:00:11,880 --> 00:00:12,980
poisoning

6
00:00:12,980 --> 00:00:16,859
which we found almost a year ago

7
00:00:16,859 --> 00:00:17,699
um

8
00:00:17,699 --> 00:00:20,400
and a little presentation about us

9
00:00:20,400 --> 00:00:23,460
um my name is Christopher Jacoby I'm an

10
00:00:23,460 --> 00:00:26,039
independent security consultant I work

11
00:00:26,039 --> 00:00:29,160
with penetration testing and I work with

12
00:00:29,160 --> 00:00:31,500
change in security and trying to improve

13
00:00:31,500 --> 00:00:34,140
organizations

14
00:00:34,140 --> 00:00:35,880
um I have a Twitter account and it's a

15
00:00:35,880 --> 00:00:37,140
cook official

16
00:00:37,140 --> 00:00:39,360
you know this guy he also has a Twitter

17
00:00:39,360 --> 00:00:42,320
account from today

18
00:00:42,899 --> 00:00:45,540
I saw them at it right now but let's

19
00:00:45,540 --> 00:00:47,640
show it later in the slideshow uh but

20
00:00:47,640 --> 00:00:50,039
I'm I'm Anton I'm a independent security

21
00:00:50,039 --> 00:00:53,879
consultant at Intel squirrel uh mainly

22
00:00:53,879 --> 00:00:56,520
focus on security testing for mainly for

23
00:00:56,520 --> 00:00:59,699
web applications I'm really big into OS

24
00:00:59,699 --> 00:01:03,059
open source intelligence

25
00:01:03,059 --> 00:01:05,040
um I'm also a really big fan of

26
00:01:05,040 --> 00:01:07,020
JavaScript which is the language we're

27
00:01:07,020 --> 00:01:09,360
going to speak about today uh love

28
00:01:09,360 --> 00:01:13,820
building application uh still do

29
00:01:14,340 --> 00:01:16,140
all right so

30
00:01:16,140 --> 00:01:19,380
this whole thing started when I had

31
00:01:19,380 --> 00:01:21,180
become an independent consultant I did

32
00:01:21,180 --> 00:01:23,159
some some subcontracting for a

33
00:01:23,159 --> 00:01:24,600
stockholm-based security company called

34
00:01:24,600 --> 00:01:26,759
xpd that's probably around here

35
00:01:26,759 --> 00:01:29,040
somewhere and they asked me to do a

36
00:01:29,040 --> 00:01:31,259
black box test or one other clients

37
00:01:31,259 --> 00:01:36,439
and in that test I found a bug in a

38
00:01:36,439 --> 00:01:39,840
server-side schema validation service

39
00:01:39,840 --> 00:01:42,540
that means that the input I was sending

40
00:01:42,540 --> 00:01:45,180
into the service was not validated

41
00:01:45,180 --> 00:01:46,619
appropriately

42
00:01:46,619 --> 00:01:49,860
and I was attempting to do something

43
00:01:49,860 --> 00:01:51,840
called prototype pollution based on a

44
00:01:51,840 --> 00:01:53,880
tutorial I'd found online

45
00:01:53,880 --> 00:01:56,460
but ended up somewhere completely

46
00:01:56,460 --> 00:02:00,180
different and when the job was done I

47
00:02:00,180 --> 00:02:03,180
had to reach out to Anton here who is a

48
00:02:03,180 --> 00:02:06,299
great JavaScript specialist to get some

49
00:02:06,299 --> 00:02:08,098
help because I could not for my life

50
00:02:08,098 --> 00:02:09,840
understand what was going on so I could

51
00:02:09,840 --> 00:02:12,599
not even write a bug report about it and

52
00:02:12,599 --> 00:02:16,620
this is the story about how that went

53
00:02:16,620 --> 00:02:18,060
so

54
00:02:18,060 --> 00:02:20,940
I could see from the output of the

55
00:02:20,940 --> 00:02:22,620
application that it was running a

56
00:02:22,620 --> 00:02:25,560
library called Joey Joy is an open

57
00:02:25,560 --> 00:02:28,500
source JavaScript library that validates

58
00:02:28,500 --> 00:02:31,379
the input and checks that I'm using the

59
00:02:31,379 --> 00:02:33,599
right type of boundaries and the right

60
00:02:33,599 --> 00:02:36,780
type of format for the inputs that I'm

61
00:02:36,780 --> 00:02:38,400
sending which means it's really really

62
00:02:38,400 --> 00:02:40,080
hard to hack that application because

63
00:02:40,080 --> 00:02:42,599
everything is strictly checked it's

64
00:02:42,599 --> 00:02:44,879
written by a guy called Aaron Hammer

65
00:02:44,879 --> 00:02:46,739
who's a well-known security researcher

66
00:02:46,739 --> 00:02:50,879
who also wrote oauth 2 and that means

67
00:02:50,879 --> 00:02:53,400
I'm screwed right and

68
00:02:53,400 --> 00:02:57,180
turns out there were holes in it

69
00:02:57,180 --> 00:03:00,540
and the way Joy works that with the

70
00:03:00,540 --> 00:03:02,280
scheme of validation that you you create

71
00:03:02,280 --> 00:03:04,920
your own schema so for example here uh

72
00:03:04,920 --> 00:03:06,120
we have the username and the password

73
00:03:06,120 --> 00:03:08,640
and the username it's a string it should

74
00:03:08,640 --> 00:03:11,280
be alphanumeric at least three character

75
00:03:11,280 --> 00:03:13,940
and maximum 30 characters and has to be

76
00:03:13,940 --> 00:03:16,620
uh present

77
00:03:16,620 --> 00:03:18,480
um the password as you can see you have

78
00:03:18,480 --> 00:03:19,980
a reg export

79
00:03:19,980 --> 00:03:22,400
um so no super

80
00:03:22,400 --> 00:03:27,659
difficult and then you pass uh you use

81
00:03:27,659 --> 00:03:29,760
the validate method and you pass the

82
00:03:29,760 --> 00:03:32,640
object you want to validate and in case

83
00:03:32,640 --> 00:03:34,440
everything is fine which it would be in

84
00:03:34,440 --> 00:03:37,379
this case uh it passes so you would have

85
00:03:37,379 --> 00:03:39,780
the the object itself

86
00:03:39,780 --> 00:03:42,299
uh if you would add something extra like

87
00:03:42,299 --> 00:03:44,040
I've done in this case and that that's

88
00:03:44,040 --> 00:03:46,799
what we mainly did when we uh tested a

89
00:03:46,799 --> 00:03:49,260
application and saw something was weird

90
00:03:49,260 --> 00:03:51,480
that we added something and we got back

91
00:03:51,480 --> 00:03:54,360
400 bad requests and extra is not

92
00:03:54,360 --> 00:03:56,879
allowed so we're not allowed to add

93
00:03:56,879 --> 00:03:58,739
anything more to the object we're

94
00:03:58,739 --> 00:04:01,260
sending in right this is by the way the

95
00:04:01,260 --> 00:04:03,239
message that made us see that this is

96
00:04:03,239 --> 00:04:07,319
probably Joy going down yes because that

97
00:04:07,319 --> 00:04:09,360
message is pretty unique to that Library

98
00:04:09,360 --> 00:04:10,980
so we identified that this is a library

99
00:04:10,980 --> 00:04:12,959
being used and we could start model the

100
00:04:12,959 --> 00:04:15,120
same type of thing ourselves yes exactly

101
00:04:15,120 --> 00:04:17,040
it was a black box test we didn't have

102
00:04:17,040 --> 00:04:19,079
any code to look at but we asked it was

103
00:04:19,079 --> 00:04:22,079
the Orion it was

104
00:04:22,079 --> 00:04:25,139
um but then some when we're trying to to

105
00:04:25,139 --> 00:04:27,780
send in a lot of different stuff which

106
00:04:27,780 --> 00:04:30,900
you usually do and you fantastic uh we

107
00:04:30,900 --> 00:04:33,900
realized that when we send her in uh the

108
00:04:33,900 --> 00:04:37,199
Proto key with the extra everything was

109
00:04:37,199 --> 00:04:38,820
fine

110
00:04:38,820 --> 00:04:42,000
so we really didn't understand what what

111
00:04:42,000 --> 00:04:43,680
is actually happening here because we

112
00:04:43,680 --> 00:04:46,740
can't send the extra parameter uh

113
00:04:46,740 --> 00:04:48,840
immediately that we can send it when we

114
00:04:48,840 --> 00:04:50,759
wrap it in the Proto

115
00:04:50,759 --> 00:04:53,340
and it only works with the word Proto

116
00:04:53,340 --> 00:04:54,780
yes

117
00:04:54,780 --> 00:04:56,040
and

118
00:04:56,040 --> 00:04:59,340
what this means is that we are somehow

119
00:04:59,340 --> 00:05:04,880
changing the input object type prototype

120
00:05:05,460 --> 00:05:07,080
and

121
00:05:07,080 --> 00:05:09,780
so the bug was already reported after

122
00:05:09,780 --> 00:05:11,160
the assignment we figured out what was

123
00:05:11,160 --> 00:05:14,280
going on we sent a bug report to the Joy

124
00:05:14,280 --> 00:05:15,960
project where we contacted them and we

125
00:05:15,960 --> 00:05:17,699
found out that there already was one so

126
00:05:17,699 --> 00:05:19,620
there was no point in trying it was done

127
00:05:19,620 --> 00:05:21,900
in 2019

128
00:05:21,900 --> 00:05:24,419
and they had labeled the issue and won't

129
00:05:24,419 --> 00:05:27,240
fix so it means that this packet is

130
00:05:27,240 --> 00:05:29,100
still vulnerable to this exact thing

131
00:05:29,100 --> 00:05:30,720
that we showed now you can still do this

132
00:05:30,720 --> 00:05:34,800
thing today and Aaron Hammer who's

133
00:05:34,800 --> 00:05:36,900
obviously super smart said the bad news

134
00:05:36,900 --> 00:05:39,120
is that there is nothing nothing to

135
00:05:39,120 --> 00:05:41,520
blame other than JavaScript itself it's

136
00:05:41,520 --> 00:05:44,100
much harder getting it fixed this means

137
00:05:44,100 --> 00:05:45,300
that

138
00:05:45,300 --> 00:05:47,699
this is not just the problem with this

139
00:05:47,699 --> 00:05:50,520
Library it's a problem with how input

140
00:05:50,520 --> 00:05:53,940
validation works or how how structures

141
00:05:53,940 --> 00:05:58,160
are handled in JavaScript in general

142
00:05:58,680 --> 00:06:02,039
so some background about happy and joy

143
00:06:02,039 --> 00:06:04,320
and who Aaron is it could be interesting

144
00:06:04,320 --> 00:06:05,820
to know so

145
00:06:05,820 --> 00:06:08,699
every Autumn coming to Winter there is a

146
00:06:08,699 --> 00:06:11,160
holiday called The Black Friday where

147
00:06:11,160 --> 00:06:12,600
people buy

148
00:06:12,600 --> 00:06:16,380
sheep stuff and and and fight over

149
00:06:16,380 --> 00:06:17,940
getting into stores but if you do this

150
00:06:17,940 --> 00:06:19,020
online

151
00:06:19,020 --> 00:06:21,300
going to Walmart you're meeting a web

152
00:06:21,300 --> 00:06:24,360
framework called happy enjoy happy was a

153
00:06:24,360 --> 00:06:25,800
really really fast way of building web

154
00:06:25,800 --> 00:06:28,500
applications pretty cool Joy was an

155
00:06:28,500 --> 00:06:30,120
add-on to that to do input validation

156
00:06:30,120 --> 00:06:33,300
for security specifically and still it

157
00:06:33,300 --> 00:06:34,620
was enjoy that we found the

158
00:06:34,620 --> 00:06:36,319
vulnerability so

159
00:06:36,319 --> 00:06:38,940
Aaron had received a bug report just

160
00:06:38,940 --> 00:06:42,180
like ours back in 2019 by a company

161
00:06:42,180 --> 00:06:43,740
called LOB

162
00:06:43,740 --> 00:06:46,800
lob engineering is developers but

163
00:06:46,800 --> 00:06:49,199
they're sending a pretty nice bug report

164
00:06:49,199 --> 00:06:52,440
to him explaining that this bug we're

165
00:06:52,440 --> 00:06:54,300
seeing right now can actually be

166
00:06:54,300 --> 00:06:56,520
exploited to cause a lot of trouble in

167
00:06:56,520 --> 00:06:59,220
happy not just go past the input

168
00:06:59,220 --> 00:07:01,979
validation but actually cause execution

169
00:07:01,979 --> 00:07:04,380
issues you could actually change how the

170
00:07:04,380 --> 00:07:06,600
program was running inside of it

171
00:07:06,600 --> 00:07:10,080
uh and um if you have access to these

172
00:07:10,080 --> 00:07:11,699
slides afterwards following this link

173
00:07:11,699 --> 00:07:15,419
leads to blog post by Aaron about how he

174
00:07:15,419 --> 00:07:17,400
tried to fix the problem how he failed

175
00:07:17,400 --> 00:07:19,440
to fix the problem and why they decided

176
00:07:19,440 --> 00:07:22,680
to do nothing about it in the end

177
00:07:22,680 --> 00:07:25,560
um he eventually wrote another library

178
00:07:25,560 --> 00:07:28,380
to to handle the issue but uh it's a

179
00:07:28,380 --> 00:07:30,660
pretty tricky problem yep

180
00:07:30,660 --> 00:07:31,979
and

181
00:07:31,979 --> 00:07:33,840
I mean we really want to get to the

182
00:07:33,840 --> 00:07:36,120
bottom to what is actually happening and

183
00:07:36,120 --> 00:07:38,160
to understand what is actually happening

184
00:07:38,160 --> 00:07:39,720
you have to understand how JavaScript

185
00:07:39,720 --> 00:07:41,759
works so

186
00:07:41,759 --> 00:07:44,759
um just the basics of JavaScript uh to

187
00:07:44,759 --> 00:07:46,259
create you have different ways of

188
00:07:46,259 --> 00:07:48,539
creating an objects which I am in the

189
00:07:48,539 --> 00:07:50,340
top but this is the most common this is

190
00:07:50,340 --> 00:07:52,440
an object literal

191
00:07:52,440 --> 00:07:54,660
um and what I'm doing here is that I'm

192
00:07:54,660 --> 00:07:57,720
creating an empty object and still I can

193
00:07:57,720 --> 00:08:00,900
call a method called tostring and that's

194
00:08:00,900 --> 00:08:02,639
quite weird I mean how am I supposed to

195
00:08:02,639 --> 00:08:04,139
do that because it's it's an empty

196
00:08:04,139 --> 00:08:05,819
object right

197
00:08:05,819 --> 00:08:07,800
um but the way that works is that

198
00:08:07,800 --> 00:08:09,120
JavaScript uses something called

199
00:08:09,120 --> 00:08:11,400
prototypes so

200
00:08:11,400 --> 00:08:14,940
compared to to Java and SQL plus uh it

201
00:08:14,940 --> 00:08:16,979
doesn't have a true class it uses

202
00:08:16,979 --> 00:08:20,160
prototypes instead and the prototypes is

203
00:08:20,160 --> 00:08:23,419
just a way that JavaScript can share

204
00:08:23,419 --> 00:08:26,039
methods and values and properties

205
00:08:26,039 --> 00:08:28,860
between objects that's how you do it so

206
00:08:28,860 --> 00:08:31,560
you create a property uh sorry a

207
00:08:31,560 --> 00:08:35,099
prototype and then other objects can

208
00:08:35,099 --> 00:08:37,140
inherit from that

209
00:08:37,140 --> 00:08:39,419
and automatically when you create a new

210
00:08:39,419 --> 00:08:41,940
object and an empty object a prototype

211
00:08:41,940 --> 00:08:44,159
is being assigned which is the global

212
00:08:44,159 --> 00:08:46,200
object

213
00:08:46,200 --> 00:08:49,380
and how it actually looks for for

214
00:08:49,380 --> 00:08:51,000
properties uh when you look for

215
00:08:51,000 --> 00:08:53,760
something is uh it starts by looking at

216
00:08:53,760 --> 00:08:55,860
your object the properties in your

217
00:08:55,860 --> 00:08:58,980
object if it doesn't exist there it goes

218
00:08:58,980 --> 00:09:02,100
up to the Prototype itself and it will

219
00:09:02,100 --> 00:09:04,620
Traverse up through the chain until it

220
00:09:04,620 --> 00:09:06,240
reaches null because then we're out of

221
00:09:06,240 --> 00:09:08,100
prototypes there's nothing else to look

222
00:09:08,100 --> 00:09:11,399
for so in this case if I look for a

223
00:09:11,399 --> 00:09:14,040
property called known non-existent in an

224
00:09:14,040 --> 00:09:16,140
empty object it will start looking in

225
00:09:16,140 --> 00:09:18,779
the object which is it's nothing it will

226
00:09:18,779 --> 00:09:20,399
look in a prototype and in this case

227
00:09:20,399 --> 00:09:23,339
we'll referring to the global objects

228
00:09:23,339 --> 00:09:26,100
prototype which is inherited from the

229
00:09:26,100 --> 00:09:30,620
global object so it sits on the object

230
00:09:30,660 --> 00:09:32,700
um and it doesn't exist there and then

231
00:09:32,700 --> 00:09:35,100
in the end since we have no more uh

232
00:09:35,100 --> 00:09:38,339
prototypes it's returning null and then

233
00:09:38,339 --> 00:09:39,839
we're out and that's when we get

234
00:09:39,839 --> 00:09:41,100
undefined

235
00:09:41,100 --> 00:09:43,560
because we're out of something

236
00:09:43,560 --> 00:09:47,040
and a way to reach the Prototype uh uh

237
00:09:47,040 --> 00:09:49,260
in JavaScript there's something called a

238
00:09:49,260 --> 00:09:51,060
dollar Proto

239
00:09:51,060 --> 00:09:54,660
um which is just an excessor to to get

240
00:09:54,660 --> 00:09:57,000
to to yeah to access the Prototype

241
00:09:57,000 --> 00:09:59,100
itself and

242
00:09:59,100 --> 00:10:01,620
uh it's not when you create an object

243
00:10:01,620 --> 00:10:03,720
it's not actually it's not a property

244
00:10:03,720 --> 00:10:05,279
itself it's just a prototype an

245
00:10:05,279 --> 00:10:08,160
accessory to that prototype and in this

246
00:10:08,160 --> 00:10:09,660
particular case where we're sending in

247
00:10:09,660 --> 00:10:12,720
the Proto uh the donda Proto property in

248
00:10:12,720 --> 00:10:16,380
the in the object in a payload and it it

249
00:10:16,380 --> 00:10:19,620
did go well so uh naturally we thought

250
00:10:19,620 --> 00:10:21,480
we had something called prototype

251
00:10:21,480 --> 00:10:26,880
pollution turns out we were wrong yeah

252
00:10:26,880 --> 00:10:29,580
um pretty much and what's actually

253
00:10:29,580 --> 00:10:31,680
happening here is that we create an

254
00:10:31,680 --> 00:10:34,800
object and directly with setting a Proto

255
00:10:34,800 --> 00:10:36,540
so we're setting a prototype on this

256
00:10:36,540 --> 00:10:39,480
object which has a property called Foo

257
00:10:39,480 --> 00:10:41,700
and the value bar

258
00:10:41,700 --> 00:10:43,500
and what we realized we're we're

259
00:10:43,500 --> 00:10:46,079
controlling the the object's prototype

260
00:10:46,079 --> 00:10:48,300
in this case uh but we're not

261
00:10:48,300 --> 00:10:50,820
controlling the global object prototype

262
00:10:50,820 --> 00:10:52,620
which is something you want to do when

263
00:10:52,620 --> 00:10:54,839
you Pro you want to pollute the

264
00:10:54,839 --> 00:10:57,060
Prototype of the global object

265
00:10:57,060 --> 00:10:58,980
you want to change something you want to

266
00:10:58,980 --> 00:11:02,279
change meters like a two strings but we

267
00:11:02,279 --> 00:11:05,040
were only able to to access our own

268
00:11:05,040 --> 00:11:07,880
prototype

269
00:11:08,579 --> 00:11:11,220
um as an analogy that means that we can

270
00:11:11,220 --> 00:11:14,220
only poison one individual object and

271
00:11:14,220 --> 00:11:16,380
not other objects poisoning multiple

272
00:11:16,380 --> 00:11:19,440
objects is polluting right yeah

273
00:11:19,440 --> 00:11:22,440
and so I thought okay but if I change

274
00:11:22,440 --> 00:11:24,300
something if I change because if we go

275
00:11:24,300 --> 00:11:26,880
back to to this slide if I chain it I

276
00:11:26,880 --> 00:11:29,100
say proto.proto which is something

277
00:11:29,100 --> 00:11:31,440
pretty common when you you want

278
00:11:31,440 --> 00:11:33,420
prototype pollution

279
00:11:33,420 --> 00:11:37,019
um so I'm sending another Provo and the

280
00:11:37,019 --> 00:11:39,839
results were just I was going further

281
00:11:39,839 --> 00:11:41,579
further away from the object I really

282
00:11:41,579 --> 00:11:43,440
wanted I was so close which is one step

283
00:11:43,440 --> 00:11:44,700
away

284
00:11:44,700 --> 00:11:47,160
so but I couldn't reach it was

285
00:11:47,160 --> 00:11:49,380
impossible

286
00:11:49,380 --> 00:11:50,399
um

287
00:11:50,399 --> 00:11:53,040
so what we understand then that

288
00:11:53,040 --> 00:11:56,040
um we're only able to mutate the input

289
00:11:56,040 --> 00:11:59,040
objects prototype that's it and we

290
00:11:59,040 --> 00:12:01,560
couldn't mutate any other prototype that

291
00:12:01,560 --> 00:12:04,800
was being used yeah

292
00:12:04,800 --> 00:12:08,160
and uh what we figured and that what

293
00:12:08,160 --> 00:12:10,079
what might be actually happening is if

294
00:12:10,079 --> 00:12:12,120
you create an object with the Donna

295
00:12:12,120 --> 00:12:14,459
Proto property which something like the

296
00:12:14,459 --> 00:12:15,779
extra and the payload in the beginning

297
00:12:15,779 --> 00:12:18,060
if you actually get the proper type

298
00:12:18,060 --> 00:12:20,339
properties of that object it will return

299
00:12:20,339 --> 00:12:23,160
an empty array it's not there

300
00:12:23,160 --> 00:12:26,399
but if I actually call it it's there

301
00:12:26,399 --> 00:12:30,300
so this is something uh we understood

302
00:12:30,300 --> 00:12:33,360
this is built in in the JavaScript so it

303
00:12:33,360 --> 00:12:35,160
always allows you to create a prototype

304
00:12:35,160 --> 00:12:38,940
when creating a new uh object

305
00:12:38,940 --> 00:12:42,540
so right now we're talking about bug

306
00:12:42,540 --> 00:12:44,700
classes we're not talking about how to

307
00:12:44,700 --> 00:12:46,500
perform the attack we have definitely

308
00:12:46,500 --> 00:12:48,120
not talked about impact

309
00:12:48,120 --> 00:12:51,420
but these are different ways to mutate

310
00:12:51,420 --> 00:12:53,100
prototypes

311
00:12:53,100 --> 00:12:55,260
or other

312
00:12:55,260 --> 00:12:59,279
input objects to alter how the flow of

313
00:12:59,279 --> 00:13:00,959
the program goes so if you have

314
00:13:00,959 --> 00:13:02,459
prototype pollution in a client

315
00:13:02,459 --> 00:13:04,920
application that can lead to cross-site

316
00:13:04,920 --> 00:13:06,480
scripting

317
00:13:06,480 --> 00:13:08,880
and many other things

318
00:13:08,880 --> 00:13:11,339
if you have product prototype poisoning

319
00:13:11,339 --> 00:13:14,519
you can replace individual properties in

320
00:13:14,519 --> 00:13:16,380
that object and that's called property

321
00:13:16,380 --> 00:13:18,800
injection there is another bug class

322
00:13:18,800 --> 00:13:22,680
called hidden property abuse

323
00:13:22,680 --> 00:13:25,800
and the research behind this bug glass

324
00:13:25,800 --> 00:13:28,740
is pretty brilliant I think

325
00:13:28,740 --> 00:13:30,540
the problem

326
00:13:30,540 --> 00:13:32,820
that we're facing right now is it's very

327
00:13:32,820 --> 00:13:35,160
hard for us to describe how bad this is

328
00:13:35,160 --> 00:13:37,560
because these bugs can all be shown

329
00:13:37,560 --> 00:13:39,600
together so if you find multiple bugs in

330
00:13:39,600 --> 00:13:42,420
one project of these kinds you can chain

331
00:13:42,420 --> 00:13:44,940
them together and you can pretty much

332
00:13:44,940 --> 00:13:47,399
control the input of the program so you

333
00:13:47,399 --> 00:13:48,959
have three different weapons that you

334
00:13:48,959 --> 00:13:50,639
can use at once against the target

335
00:13:50,639 --> 00:13:52,980
application and this is where this gets

336
00:13:52,980 --> 00:13:54,839
a bit complex

337
00:13:54,839 --> 00:13:57,899
I'm going to try to explain the

338
00:13:57,899 --> 00:14:01,440
briefly try to explain how hidden

339
00:14:01,440 --> 00:14:04,079
property abuse works because the people

340
00:14:04,079 --> 00:14:06,000
or the guy who made that type of

341
00:14:06,000 --> 00:14:08,100
research or that research explained a

342
00:14:08,100 --> 00:14:10,920
lot of attacks in such a way that it was

343
00:14:10,920 --> 00:14:12,980
inspiring for us

344
00:14:12,980 --> 00:14:15,779
for this research so it was it was

345
00:14:15,779 --> 00:14:17,279
something that we thought that we might

346
00:14:17,279 --> 00:14:20,880
be able to do as well so think Chao is a

347
00:14:20,880 --> 00:14:24,000
guy who study at um in an American

348
00:14:24,000 --> 00:14:27,540
University and he found a way to inject

349
00:14:27,540 --> 00:14:29,820
properties into JavaScript to alter

350
00:14:29,820 --> 00:14:32,220
program flows and during one year 2019

351
00:14:32,220 --> 00:14:36,060
to 2020 he found 15 CVS using a scanning

352
00:14:36,060 --> 00:14:38,220
method where he is doing symbolic

353
00:14:38,220 --> 00:14:40,740
instrumentation or looking at the

354
00:14:40,740 --> 00:14:43,920
execution flow of the 100 Java Script

355
00:14:43,920 --> 00:14:46,560
projects and from that he got 15 CVS

356
00:14:46,560 --> 00:14:50,459
ranging from remote code execution and

357
00:14:50,459 --> 00:14:53,160
there was input validation bypassed

358
00:14:53,160 --> 00:14:55,680
denial of service and a lot of SQL

359
00:14:55,680 --> 00:14:58,320
injections and we think that we also

360
00:14:58,320 --> 00:15:00,959
have the same type of impacts in this by

361
00:15:00,959 --> 00:15:03,180
class and it's even worse if you combine

362
00:15:03,180 --> 00:15:04,620
them

363
00:15:04,620 --> 00:15:08,160
so the way hidden property abuse works

364
00:15:08,160 --> 00:15:09,600
is that

365
00:15:09,600 --> 00:15:11,519
when you send input like the input you

366
00:15:11,519 --> 00:15:13,920
saw before with username and password

367
00:15:13,920 --> 00:15:17,220
imagine that you simply add without

368
00:15:17,220 --> 00:15:20,279
having property Proto involved at all

369
00:15:20,279 --> 00:15:23,339
you just add one more field called

370
00:15:23,339 --> 00:15:26,519
Constructor and in there you define name

371
00:15:26,519 --> 00:15:29,519
this will be inherited when the program

372
00:15:29,519 --> 00:15:33,420
runs in such a way that it overwrites

373
00:15:33,420 --> 00:15:35,279
the Constructor for other objects that's

374
00:15:35,279 --> 00:15:36,899
being merged with this one it's very

375
00:15:36,899 --> 00:15:38,760
rare that it happens

376
00:15:38,760 --> 00:15:41,220
but it does happen often enough that if

377
00:15:41,220 --> 00:15:42,899
you start scanning open source projects

378
00:15:42,899 --> 00:15:45,120
just keep seeing a pattern of programs

379
00:15:45,120 --> 00:15:46,740
that are vulnerable to this and you can

380
00:15:46,740 --> 00:15:49,019
start altering Pro program flow and do

381
00:15:49,019 --> 00:15:51,899
really really nasty stuff

382
00:15:51,899 --> 00:15:53,940
what he didn't know when he did this was

383
00:15:53,940 --> 00:15:55,740
that simultaneously there was research

384
00:15:55,740 --> 00:15:58,139
going on with prototype poisoning and if

385
00:15:58,139 --> 00:16:00,060
you combine these two it's starting to

386
00:16:00,060 --> 00:16:02,579
get a bit scary so app specific

387
00:16:02,579 --> 00:16:04,980
attribute manipulation is a method

388
00:16:04,980 --> 00:16:07,440
within HPA not hacking freaking energy

389
00:16:07,440 --> 00:16:11,899
Anarchy it's hidden property abuse

390
00:16:11,899 --> 00:16:15,120
this attack method means that you create

391
00:16:15,120 --> 00:16:16,440
a

392
00:16:16,440 --> 00:16:19,560
a property like a debug colon true or

393
00:16:19,560 --> 00:16:20,699
something like that and it's being

394
00:16:20,699 --> 00:16:23,940
inherited through the program so that a

395
00:16:23,940 --> 00:16:26,040
Target object now enables debugging and

396
00:16:26,040 --> 00:16:28,260
that changes the outcome of things it

397
00:16:28,260 --> 00:16:30,540
could be authenticated it's true or in

398
00:16:30,540 --> 00:16:32,820
this case is overwriting the proper the

399
00:16:32,820 --> 00:16:36,360
prototype by having a legitimate object

400
00:16:36,360 --> 00:16:39,560
object property called constructor.name

401
00:16:39,560 --> 00:16:42,779
with some given content and by producing

402
00:16:42,779 --> 00:16:46,399
different types of uh failures and

403
00:16:46,399 --> 00:16:49,820
execution flows he is

404
00:16:49,820 --> 00:16:51,839
altering the flow of the program and

405
00:16:51,839 --> 00:16:53,639
here's an example because this is quite

406
00:16:53,639 --> 00:16:56,160
conceptual right now

407
00:16:56,160 --> 00:16:59,040
this is SQL injection in a library

408
00:16:59,040 --> 00:17:02,459
called Taffy Taffy is a library that

409
00:17:02,459 --> 00:17:07,140
does mongodb database queries

410
00:17:07,140 --> 00:17:09,000
so the database looks like this it has

411
00:17:09,000 --> 00:17:12,359
ID gender username password Etc it's

412
00:17:12,359 --> 00:17:13,919
just an example of a database what it

413
00:17:13,919 --> 00:17:15,059
could look like

414
00:17:15,059 --> 00:17:19,199
if you have an input query that happens

415
00:17:19,199 --> 00:17:21,000
to have an object name called underscore

416
00:17:21,000 --> 00:17:22,859
underscore and then this long

417
00:17:22,859 --> 00:17:25,439
predictable string you can start looking

418
00:17:25,439 --> 00:17:28,020
at other fields that you weren't

419
00:17:28,020 --> 00:17:30,720
intended to because ID underscore

420
00:17:30,720 --> 00:17:33,240
underscore ID is a private

421
00:17:33,240 --> 00:17:36,419
um property member that is being used

422
00:17:36,419 --> 00:17:37,980
much much later in the program it's

423
00:17:37,980 --> 00:17:39,539
being inherited all the way down into

424
00:17:39,539 --> 00:17:41,100
the program and it's being called and

425
00:17:41,100 --> 00:17:43,620
referenced and when that happens all of

426
00:17:43,620 --> 00:17:46,020
a sudden you can start picking out the

427
00:17:46,020 --> 00:17:47,700
username and password field of other

428
00:17:47,700 --> 00:17:50,520
users this is pretty messed up and

429
00:17:50,520 --> 00:17:52,860
finding this is pretty complex but what

430
00:17:52,860 --> 00:17:56,220
uh Feng did was to write this tool to

431
00:17:56,220 --> 00:17:59,039
scan for these we think that it's

432
00:17:59,039 --> 00:18:01,260
possible to write a scanner that

433
00:18:01,260 --> 00:18:04,919
combines these type of attacks to scan

434
00:18:04,919 --> 00:18:06,260
for

435
00:18:06,260 --> 00:18:08,940
prototype poisoning vulnerabilities in

436
00:18:08,940 --> 00:18:10,440
combination with these where you can

437
00:18:10,440 --> 00:18:13,260
create flaws to disable logging and at

438
00:18:13,260 --> 00:18:14,820
the same time for instance do SQL

439
00:18:14,820 --> 00:18:16,500
injection or extract other type of

440
00:18:16,500 --> 00:18:18,679
information

441
00:18:20,820 --> 00:18:22,919
all right so

442
00:18:22,919 --> 00:18:25,140
we haven't talked enough about what

443
00:18:25,140 --> 00:18:28,500
prototype pollution is so in reality the

444
00:18:28,500 --> 00:18:29,880
distinction between poisoning and

445
00:18:29,880 --> 00:18:32,400
pollution is that with poisoning you're

446
00:18:32,400 --> 00:18:34,860
only hurting one person usually with

447
00:18:34,860 --> 00:18:36,179
pollution you're hurting the entire

448
00:18:36,179 --> 00:18:37,260
environment

449
00:18:37,260 --> 00:18:40,140
what happens with pollution is that

450
00:18:40,140 --> 00:18:42,120
you're able to overwrite a prototype

451
00:18:42,120 --> 00:18:43,980
that's used by multiple different

452
00:18:43,980 --> 00:18:46,620
objects so say it's used for input and

453
00:18:46,620 --> 00:18:48,600
output writing and suddenly you're

454
00:18:48,600 --> 00:18:51,299
messing with the member functions inside

455
00:18:51,299 --> 00:18:54,120
of the object for output printing

456
00:18:54,120 --> 00:18:57,840
and in this case you have three inputs

457
00:18:57,840 --> 00:19:00,900
it's key one key two and value those are

458
00:19:00,900 --> 00:19:02,940
user controls so imagine the first value

459
00:19:02,940 --> 00:19:05,820
is now Proto the second one is polluted

460
00:19:05,820 --> 00:19:08,160
and then the last one is true then

461
00:19:08,160 --> 00:19:11,520
all objects that use this prototype will

462
00:19:11,520 --> 00:19:13,799
be polluted and now have a member called

463
00:19:13,799 --> 00:19:15,600
polluted equals true

464
00:19:15,600 --> 00:19:19,440
it's one where you're measuring this

465
00:19:19,440 --> 00:19:21,120
I mentioned before that all these three

466
00:19:21,120 --> 00:19:22,679
can be chained together

467
00:19:22,679 --> 00:19:25,080
we have seen indications that you can

468
00:19:25,080 --> 00:19:27,120
create prototype pollution

469
00:19:27,120 --> 00:19:29,340
vulnerabilities on the server side from

470
00:19:29,340 --> 00:19:31,559
prototype poisoning

471
00:19:31,559 --> 00:19:33,299
and this is something that's starting to

472
00:19:33,299 --> 00:19:36,539
scare us a bit yeah and to talk about a

473
00:19:36,539 --> 00:19:38,160
bit more what prototype poisoning is

474
00:19:38,160 --> 00:19:40,799
which is not prototype pollution so

475
00:19:40,799 --> 00:19:44,340
you're only able to mutate your own

476
00:19:44,340 --> 00:19:47,100
prototype you're not able to mutate any

477
00:19:47,100 --> 00:19:49,020
other shared prototypes at all just

478
00:19:49,020 --> 00:19:51,360
around because you're creating your own

479
00:19:51,360 --> 00:19:53,820
prototype so in case in in this example

480
00:19:53,820 --> 00:19:55,980
we have the object we actually have two

481
00:19:55,980 --> 00:19:57,840
prototypes in this case because we had

482
00:19:57,840 --> 00:19:59,520
our own prototype and then we have the

483
00:19:59,520 --> 00:20:01,320
global objects prototype but we're

484
00:20:01,320 --> 00:20:04,860
mutating our own prototypes so in case I

485
00:20:04,860 --> 00:20:05,940
would run

486
00:20:05,940 --> 00:20:06,799
um

487
00:20:06,799 --> 00:20:10,679
object.2 string it will be null

488
00:20:10,679 --> 00:20:12,539
this is actually what's that that's

489
00:20:12,539 --> 00:20:14,100
basically what's happening so as

490
00:20:14,100 --> 00:20:16,200
Christopher said we you you can only

491
00:20:16,200 --> 00:20:17,700
hurt one person you're only hurting

492
00:20:17,700 --> 00:20:19,380
yourself but this is bad enough because

493
00:20:19,380 --> 00:20:21,960
when uh you're selling that object

494
00:20:21,960 --> 00:20:23,700
somewhere else you still have those

495
00:20:23,700 --> 00:20:27,980
properties on it because they're hidden

496
00:20:28,320 --> 00:20:31,500
so we started looking for other exploit

497
00:20:31,500 --> 00:20:33,900
channels that were related to this

498
00:20:33,900 --> 00:20:36,120
vulnerability but not coming from Jason

499
00:20:36,120 --> 00:20:38,220
so Jason was the input format we looked

500
00:20:38,220 --> 00:20:40,260
at before with the curly braces

501
00:20:40,260 --> 00:20:43,080
you have probably made a post request or

502
00:20:43,080 --> 00:20:45,299
a get request to a JavaScript or Express

503
00:20:45,299 --> 00:20:46,799
server at some time

504
00:20:46,799 --> 00:20:49,620
the library that received that request

505
00:20:49,620 --> 00:20:52,020
and parsed it is called query string

506
00:20:52,020 --> 00:20:54,059
query string is a parser that

507
00:20:54,059 --> 00:20:56,400
understands that input

508
00:20:56,400 --> 00:20:58,679
that Library had a vulnerability that's

509
00:20:58,679 --> 00:21:01,860
now fixed since q1 in 2022

510
00:21:01,860 --> 00:21:04,620
where you can overwrite the Prototype of

511
00:21:04,620 --> 00:21:07,140
the input object into request body on

512
00:21:07,140 --> 00:21:09,780
every single post and get request

513
00:21:09,780 --> 00:21:12,900
in every single application out there

514
00:21:12,900 --> 00:21:15,360
in JavaScript I mean this is all of them

515
00:21:15,360 --> 00:21:18,360
this was this bug was in every single

516
00:21:18,360 --> 00:21:20,539
program

517
00:21:20,940 --> 00:21:24,620
everyone uses this library and this was

518
00:21:24,620 --> 00:21:27,419
obviously not a good thing I'm not sure

519
00:21:27,419 --> 00:21:29,760
everyone has patched this yet but I hope

520
00:21:29,760 --> 00:21:32,120
they have

521
00:21:34,260 --> 00:21:37,380
so what we want to achieve now we've

522
00:21:37,380 --> 00:21:40,559
been babbling about how it works and

523
00:21:40,559 --> 00:21:42,419
stuff but what we want to achieve as

524
00:21:42,419 --> 00:21:43,740
attackers that's what we're going to get

525
00:21:43,740 --> 00:21:47,220
into now is we want to do we want to

526
00:21:47,220 --> 00:21:49,200
bypass input validation of course we

527
00:21:49,200 --> 00:21:51,539
want to remove all kinds of obstacles to

528
00:21:51,539 --> 00:21:54,419
to check our input or control what we

529
00:21:54,419 --> 00:21:55,799
are doing because we want to be free

530
00:21:55,799 --> 00:21:57,900
inside the application then we want to

531
00:21:57,900 --> 00:22:00,000
do injection attacks command reaction is

532
00:22:00,000 --> 00:22:03,120
the best coding action second best and

533
00:22:03,120 --> 00:22:04,679
then SQL in action on the third place

534
00:22:04,679 --> 00:22:06,659
that's something we want to be doing as

535
00:22:06,659 --> 00:22:09,059
attackers right we want to avoid logging

536
00:22:09,059 --> 00:22:10,740
so the logger we want to crash that

537
00:22:10,740 --> 00:22:13,020
maybe even call step

538
00:22:13,020 --> 00:22:15,419
to break somehow we want to bypass

539
00:22:15,419 --> 00:22:17,100
authentication so we want to reach

540
00:22:17,100 --> 00:22:18,360
functionality that requires

541
00:22:18,360 --> 00:22:20,640
authentication and use it otherwise even

542
00:22:20,640 --> 00:22:22,140
though we're not authenticated if we can

543
00:22:22,140 --> 00:22:25,559
we want to overwrite default methods so

544
00:22:25,559 --> 00:22:27,419
methods that are used for things we want

545
00:22:27,419 --> 00:22:29,760
to make them break so

546
00:22:29,760 --> 00:22:30,539
um

547
00:22:30,539 --> 00:22:32,280
yeah we'll get to that and we want to

548
00:22:32,280 --> 00:22:33,840
change the outcome of conditional

549
00:22:33,840 --> 00:22:35,280
statements so

550
00:22:35,280 --> 00:22:37,620
things that check if this is that we

551
00:22:37,620 --> 00:22:38,940
want to change it to something else we

552
00:22:38,940 --> 00:22:39,900
want to control of the program

553
00:22:39,900 --> 00:22:42,659
essentially right

554
00:22:42,659 --> 00:22:44,880
so let's look at the attack tree of this

555
00:22:44,880 --> 00:22:47,580
where what it can actually lead to and

556
00:22:47,580 --> 00:22:49,140
this is where it's starting to become

557
00:22:49,140 --> 00:22:50,940
speculation for us we've seen other

558
00:22:50,940 --> 00:22:53,280
attacks so we've read a lot of code and

559
00:22:53,280 --> 00:22:55,860
fixes of a lot of code to come up with

560
00:22:55,860 --> 00:22:58,440
this list but we think there are

561
00:22:58,440 --> 00:23:00,179
multiple ways to bypass authentication

562
00:23:00,179 --> 00:23:02,640
multiple ways to course SQL injection

563
00:23:02,640 --> 00:23:04,799
that you just saw before

564
00:23:04,799 --> 00:23:06,659
with the app specific attribute

565
00:23:06,659 --> 00:23:08,400
manipulation techniques that means we

566
00:23:08,400 --> 00:23:09,840
understand the node app so we have the

567
00:23:09,840 --> 00:23:11,580
source code for the Target application

568
00:23:11,580 --> 00:23:14,100
we know the library we're hacking then

569
00:23:14,100 --> 00:23:16,080
we can cause denial of service by doing

570
00:23:16,080 --> 00:23:17,580
infinite loops

571
00:23:17,580 --> 00:23:19,080
I'll show examples of that you can

572
00:23:19,080 --> 00:23:21,000
create recursions by making function

573
00:23:21,000 --> 00:23:23,280
call themselves and that's really really

574
00:23:23,280 --> 00:23:25,740
bad in JavaScript we can change the

575
00:23:25,740 --> 00:23:28,440
control flow of the application and we

576
00:23:28,440 --> 00:23:30,900
can do or we want to do arbitrary code

577
00:23:30,900 --> 00:23:33,240
injection where we send our code into

578
00:23:33,240 --> 00:23:35,580
the application if we can if there is

579
00:23:35,580 --> 00:23:37,260
the evaluation somewhere

580
00:23:37,260 --> 00:23:39,299
we also want to achieve prototype

581
00:23:39,299 --> 00:23:40,620
pollution because that means we can

582
00:23:40,620 --> 00:23:42,299
overwrite any object

583
00:23:42,299 --> 00:23:45,480
anywhere inside of or multiple objects

584
00:23:45,480 --> 00:23:47,400
but preferably any object because then

585
00:23:47,400 --> 00:23:48,659
we can start controlling the entire

586
00:23:48,659 --> 00:23:50,940
application exactly what it's doing

587
00:23:50,940 --> 00:23:54,059
and avoid logging and do all the other

588
00:23:54,059 --> 00:23:57,059
bad things and if we want to be stealthy

589
00:23:57,059 --> 00:23:58,919
we want to pass hidden members past the

590
00:23:58,919 --> 00:24:01,320
input validation and do argument

591
00:24:01,320 --> 00:24:03,780
injection which is a another new

592
00:24:03,780 --> 00:24:05,280
technique that I think Anton was first

593
00:24:05,280 --> 00:24:09,480
too yeah find and this was actually what

594
00:24:09,480 --> 00:24:12,059
we found in the joy Library you had

595
00:24:12,059 --> 00:24:15,000
something called hidden members and when

596
00:24:15,000 --> 00:24:16,620
you create an object

597
00:24:16,620 --> 00:24:18,360
um it's it's not really being shown

598
00:24:18,360 --> 00:24:20,460
because you you hide it in the Proto in

599
00:24:20,460 --> 00:24:22,380
the Prototype so it still works with the

600
00:24:22,380 --> 00:24:24,179
Prototype shame because when you chain

601
00:24:24,179 --> 00:24:27,179
up it's still there but it's not in the

602
00:24:27,179 --> 00:24:29,039
object itself it's not a property on the

603
00:24:29,039 --> 00:24:31,260
object and

604
00:24:31,260 --> 00:24:32,880
this is

605
00:24:32,880 --> 00:24:37,200
um we saw this in in multiple uh schema

606
00:24:37,200 --> 00:24:39,240
validation libraries as well

607
00:24:39,240 --> 00:24:41,760
um that they they look for the keys in

608
00:24:41,760 --> 00:24:43,679
object but that's it that that's the

609
00:24:43,679 --> 00:24:45,780
only thing they're looking for and a way

610
00:24:45,780 --> 00:24:48,600
you can bypass this for example if um

611
00:24:48,600 --> 00:24:49,980
uh

612
00:24:49,980 --> 00:24:52,260
you would have yeah as we showed before

613
00:24:52,260 --> 00:24:54,240
you create an object and you override

614
00:24:54,240 --> 00:24:56,760
the the string method to for example to

615
00:24:56,760 --> 00:24:58,799
to console log one uh when you're

616
00:24:58,799 --> 00:25:00,659
running the object to string this is

617
00:25:00,659 --> 00:25:03,360
actually what will be run so if you uh

618
00:25:03,360 --> 00:25:06,299
are possible it's possible to inject

619
00:25:06,299 --> 00:25:09,059
that payload itself into that object

620
00:25:09,059 --> 00:25:12,419
well then anytime that method will be

621
00:25:12,419 --> 00:25:15,299
run for this object uh you will have a

622
00:25:15,299 --> 00:25:17,400
console log one and of course you can do

623
00:25:17,400 --> 00:25:19,980
whatever else you want to do

624
00:25:19,980 --> 00:25:21,720
um same with xss

625
00:25:21,720 --> 00:25:24,059
this is client side by the way

626
00:25:24,059 --> 00:25:26,460
yeah this this is a pretty pretty nice

627
00:25:26,460 --> 00:25:28,860
line uh what What's actually happening

628
00:25:28,860 --> 00:25:30,360
when you're running uh when you're using

629
00:25:30,360 --> 00:25:33,480
a template literal so you create your

630
00:25:33,480 --> 00:25:35,640
string and used uh input whatever you

631
00:25:35,640 --> 00:25:37,440
want in the first string you actually

632
00:25:37,440 --> 00:25:39,840
I'm just inputting an empty object

633
00:25:39,840 --> 00:25:42,360
but the string method is actually called

634
00:25:42,360 --> 00:25:45,179
so what you can do in this case that you

635
00:25:45,179 --> 00:25:48,059
passed a prototype for this object and

636
00:25:48,059 --> 00:25:49,980
you set the tostring method to something

637
00:25:49,980 --> 00:25:53,700
like alert one so in this case uh when

638
00:25:53,700 --> 00:25:55,799
the line would be run with your object

639
00:25:55,799 --> 00:25:58,740
you would actually have a prototype

640
00:25:58,740 --> 00:26:00,360
intuition mutation or prototype

641
00:26:00,360 --> 00:26:03,059
poisoning attack in xss

642
00:26:03,059 --> 00:26:06,779
so all you bug bounty hunters out there

643
00:26:06,779 --> 00:26:09,620
make notes

644
00:26:10,080 --> 00:26:11,279
so

645
00:26:11,279 --> 00:26:13,440
there are

646
00:26:13,440 --> 00:26:14,820
limitations there are plenty of

647
00:26:14,820 --> 00:26:17,940
limitations frankly one of them is the

648
00:26:17,940 --> 00:26:19,980
input format so the input format the

649
00:26:19,980 --> 00:26:22,860
channel of exploit matters a lot to what

650
00:26:22,860 --> 00:26:26,159
you can do imagine that now we talked

651
00:26:26,159 --> 00:26:28,260
about a body where it contains Jason

652
00:26:28,260 --> 00:26:30,240
then we're confined within the format of

653
00:26:30,240 --> 00:26:33,020
Json you cannot in Json Define

654
00:26:33,020 --> 00:26:35,340
functional code for instance you can

655
00:26:35,340 --> 00:26:37,320
overwrite to string if you want to yes

656
00:26:37,320 --> 00:26:39,480
but we cannot override it with code that

657
00:26:39,480 --> 00:26:40,620
executes

658
00:26:40,620 --> 00:26:43,200
we can all write with nil or null or we

659
00:26:43,200 --> 00:26:45,240
can override it with a string that does

660
00:26:45,240 --> 00:26:47,820
something but it will always crash if

661
00:26:47,820 --> 00:26:49,620
someone tries to run the function to

662
00:26:49,620 --> 00:26:51,380
string

663
00:26:51,380 --> 00:26:54,840
unless there is base64 decoding involved

664
00:26:54,840 --> 00:26:58,440
or you're using a more generous input

665
00:26:58,440 --> 00:27:00,419
format we've been looking into a format

666
00:27:00,419 --> 00:27:02,520
called Beeson which is part of the

667
00:27:02,520 --> 00:27:05,340
mongodb framework that's a binary

668
00:27:05,340 --> 00:27:08,520
version of Json that has code as a data

669
00:27:08,520 --> 00:27:09,840
type by the way so it can actually

670
00:27:09,840 --> 00:27:11,580
execute the code that you put in there

671
00:27:11,580 --> 00:27:14,159
might be an interesting vector

672
00:27:14,159 --> 00:27:16,500
also potentially you can do things with

673
00:27:16,500 --> 00:27:19,980
the web sockets XML files

674
00:27:19,980 --> 00:27:23,779
well there might be more yeah

675
00:27:24,659 --> 00:27:26,520
this is an example that I gave before

676
00:27:26,520 --> 00:27:28,500
but it's for posterity it's worth

677
00:27:28,500 --> 00:27:31,140
mentioning again so now we're going

678
00:27:31,140 --> 00:27:33,480
through examples of inputs that you can

679
00:27:33,480 --> 00:27:36,360
send into JavaScript application and it

680
00:27:36,360 --> 00:27:38,580
might change things so here we are

681
00:27:38,580 --> 00:27:40,440
enabling debugging

682
00:27:40,440 --> 00:27:43,500
potentially in an external feature that

683
00:27:43,500 --> 00:27:46,500
has a check for debugging that it does

684
00:27:46,500 --> 00:27:48,900
but it no one is has set this prototype

685
00:27:48,900 --> 00:27:51,299
it's just something that is being read

686
00:27:51,299 --> 00:27:53,400
by a third-party application at some

687
00:27:53,400 --> 00:27:54,240
point

688
00:27:54,240 --> 00:27:56,520
maybe it's not necessarily a bad thing

689
00:27:56,520 --> 00:27:59,340
but if we can control the control flow

690
00:27:59,340 --> 00:28:02,279
of the application it could result in

691
00:28:02,279 --> 00:28:03,779
something that would be relevant for us

692
00:28:03,779 --> 00:28:05,700
later

693
00:28:05,700 --> 00:28:08,159
here's another one denial of service not

694
00:28:08,159 --> 00:28:09,900
so funny for the bug Bounty people but

695
00:28:09,900 --> 00:28:12,419
funny for the rest of us

696
00:28:12,419 --> 00:28:15,299
the number here on length is two one

697
00:28:15,299 --> 00:28:17,460
four seven four eight three six four

698
00:28:17,460 --> 00:28:20,220
seven is the maximum integer in the Json

699
00:28:20,220 --> 00:28:24,059
format if you change length to this and

700
00:28:24,059 --> 00:28:25,760
now

701
00:28:25,760 --> 00:28:27,900
request.body.length will actually be

702
00:28:27,900 --> 00:28:29,340
that value

703
00:28:29,340 --> 00:28:32,460
that might make this Loop very very slow

704
00:28:32,460 --> 00:28:34,380
if you make the request multiple times

705
00:28:34,380 --> 00:28:36,779
you can block the worker thread of that

706
00:28:36,779 --> 00:28:40,559
application and and have it die same

707
00:28:40,559 --> 00:28:42,659
thing if you change the data type of

708
00:28:42,659 --> 00:28:44,940
length to true you could maybe make that

709
00:28:44,940 --> 00:28:49,100
while loop go on forever potentially

710
00:28:52,260 --> 00:28:53,880
here's an example that I brought up

711
00:28:53,880 --> 00:28:56,400
before as well but the ice

712
00:28:56,400 --> 00:28:59,279
authentication bypass ideas simply

713
00:28:59,279 --> 00:29:01,380
defining authenticated or setting it too

714
00:29:01,380 --> 00:29:03,600
true saying that yes I'm authenticated

715
00:29:03,600 --> 00:29:05,820
you'll have to Define what username you

716
00:29:05,820 --> 00:29:08,039
used somewhere else but this could

717
00:29:08,039 --> 00:29:10,200
potentially be one target that might

718
00:29:10,200 --> 00:29:12,900
turn out to be interesting because

719
00:29:12,900 --> 00:29:14,100
um

720
00:29:14,100 --> 00:29:17,400
a lot of times in JavaScript the input

721
00:29:17,400 --> 00:29:20,220
is merged with a state object so the

722
00:29:20,220 --> 00:29:21,559
input which is usually called

723
00:29:21,559 --> 00:29:25,380
request.body is merged with the object

724
00:29:25,380 --> 00:29:27,960
that's used for handling your state and

725
00:29:27,960 --> 00:29:30,000
this is where you now overwrite the

726
00:29:30,000 --> 00:29:33,240
Prototype and also that state is now

727
00:29:33,240 --> 00:29:36,120
authenticated set to true

728
00:29:36,120 --> 00:29:38,520
and get some pseudocode I put together

729
00:29:38,520 --> 00:29:40,559
but this is something that

730
00:29:40,559 --> 00:29:43,520
quite I quite often see that you have

731
00:29:43,520 --> 00:29:47,399
some kind of method and if the the

732
00:29:47,399 --> 00:29:51,240
property exists like in case email which

733
00:29:51,240 --> 00:29:54,000
you shouldn't run but sometimes you do

734
00:29:54,000 --> 00:29:56,100
um it will it will be run but before you

735
00:29:56,100 --> 00:29:58,020
do that you actually filter something so

736
00:29:58,020 --> 00:30:01,380
you filter uh if the the the the object

737
00:30:01,380 --> 00:30:03,659
you send in has a property called eval

738
00:30:03,659 --> 00:30:05,580
well it should just return don't run the

739
00:30:05,580 --> 00:30:08,340
the method itself but otherwise if if it

740
00:30:08,340 --> 00:30:10,860
doesn't exist on the in the property of

741
00:30:10,860 --> 00:30:12,720
the object then it's fine run the method

742
00:30:12,720 --> 00:30:14,039
right

743
00:30:14,039 --> 00:30:17,640
and if we hide uh for example the evil

744
00:30:17,640 --> 00:30:20,880
in the Proto uh a prototype of the

745
00:30:20,880 --> 00:30:23,039
object well it's actually there so this

746
00:30:23,039 --> 00:30:24,539
will be run this is something you can

747
00:30:24,539 --> 00:30:26,279
bypass so sometimes

748
00:30:26,279 --> 00:30:27,600
um and that that's usually what happens

749
00:30:27,600 --> 00:30:29,640
when you have a scheme of validation you

750
00:30:29,640 --> 00:30:32,279
you think that the object after the

751
00:30:32,279 --> 00:30:34,200
validation is secure right because

752
00:30:34,200 --> 00:30:36,659
that's why you set up your your schema

753
00:30:36,659 --> 00:30:38,760
um but it's not you you have properties

754
00:30:38,760 --> 00:30:41,399
on it which is not it's it's quite

755
00:30:41,399 --> 00:30:44,100
hidden but still there uh so if this

756
00:30:44,100 --> 00:30:46,799
will be run well then you would have a

757
00:30:46,799 --> 00:30:50,480
remote code execution for example

758
00:30:51,720 --> 00:30:53,760
um moving into patching this is where

759
00:30:53,760 --> 00:30:56,399
the story turns a bit more sad

760
00:30:56,399 --> 00:30:58,380
because

761
00:30:58,380 --> 00:31:01,080
well we have this patch in inquiry

762
00:31:01,080 --> 00:31:03,240
string which is great because that saves

763
00:31:03,240 --> 00:31:06,179
the body parser which is like the most

764
00:31:06,179 --> 00:31:09,419
essential part of all Java Script

765
00:31:09,419 --> 00:31:12,419
Express things but

766
00:31:12,419 --> 00:31:15,240
the JavaScript Express framework has an

767
00:31:15,240 --> 00:31:16,860
ongoing conversation about this

768
00:31:16,860 --> 00:31:21,480
vulnerability starting back in 2019 and

769
00:31:21,480 --> 00:31:23,399
it's still ongoing

770
00:31:23,399 --> 00:31:25,500
that means that no one has found a

771
00:31:25,500 --> 00:31:27,299
solution to this issue because the issue

772
00:31:27,299 --> 00:31:29,460
is the language itself I mean there are

773
00:31:29,460 --> 00:31:31,679
other JavaScript like languages like

774
00:31:31,679 --> 00:31:34,320
Dino for instance that have patched this

775
00:31:34,320 --> 00:31:37,620
essentially by removing the dunder Proto

776
00:31:37,620 --> 00:31:41,640
string name completely from from the the

777
00:31:41,640 --> 00:31:44,039
specification but in the ekma JavaScript

778
00:31:44,039 --> 00:31:47,399
this Still Remains and the issue does

779
00:31:47,399 --> 00:31:49,380
remain

780
00:31:49,380 --> 00:31:52,919
and this means that very very few

781
00:31:52,919 --> 00:31:54,600
projects that have this reported

782
00:31:54,600 --> 00:31:56,460
actually do something about it it just

783
00:31:56,460 --> 00:31:59,399
turns into discussion and dice

784
00:31:59,399 --> 00:32:00,899
uh

785
00:32:00,899 --> 00:32:04,080
and that's means that the bug class is

786
00:32:04,080 --> 00:32:05,580
still at large in the language I mean

787
00:32:05,580 --> 00:32:07,080
it's it's still here some people know

788
00:32:07,080 --> 00:32:08,880
about it but many people don't talk

789
00:32:08,880 --> 00:32:10,380
about it and

790
00:32:10,380 --> 00:32:13,020
as a community we need to start working

791
00:32:13,020 --> 00:32:16,220
on Solutions here I think

792
00:32:17,940 --> 00:32:21,360
yep and a quite easy way to identify or

793
00:32:21,360 --> 00:32:23,039
uh

794
00:32:23,039 --> 00:32:27,600
uh if if you're able to send in a Proto

795
00:32:27,600 --> 00:32:30,120
object this is the default methods you

796
00:32:30,120 --> 00:32:32,460
have on an object so you can set

797
00:32:32,460 --> 00:32:34,380
everything to null or can you set the

798
00:32:34,380 --> 00:32:36,659
product null and it should actually

799
00:32:36,659 --> 00:32:37,740
throw back

800
00:32:37,740 --> 00:32:40,500
a Thai power and if it's not handled you

801
00:32:40,500 --> 00:32:43,440
you get a 500 back uh usually but you

802
00:32:43,440 --> 00:32:44,940
can look for that type error because it

803
00:32:44,940 --> 00:32:48,600
would say well uh if you would try to to

804
00:32:48,600 --> 00:32:50,520
run for example the tostring method it

805
00:32:50,520 --> 00:32:52,200
will say well this is not a this is not

806
00:32:52,200 --> 00:32:55,260
a method so it won't be able to run

807
00:32:55,260 --> 00:32:58,080
um so before we move on this is the time

808
00:32:58,080 --> 00:32:59,580
to take a print screen all the pen

809
00:32:59,580 --> 00:33:02,940
testers everyone in bug Bounty if you

810
00:33:02,940 --> 00:33:05,820
have a Json structure that is you know

811
00:33:05,820 --> 00:33:09,179
is valid append this Json structure to

812
00:33:09,179 --> 00:33:10,380
it

813
00:33:10,380 --> 00:33:12,299
that's what you need to do you can take

814
00:33:12,299 --> 00:33:14,039
either one of them but preferably the

815
00:33:14,039 --> 00:33:16,200
lower one because it's simply matching

816
00:33:16,200 --> 00:33:18,120
everything in the Proto and makes it

817
00:33:18,120 --> 00:33:19,679
null which means that nothing is

818
00:33:19,679 --> 00:33:22,200
executable anymore of these functions or

819
00:33:22,200 --> 00:33:23,580
whatever functions that happens to be in

820
00:33:23,580 --> 00:33:25,019
there the top one is for the default

821
00:33:25,019 --> 00:33:26,340
ones but

822
00:33:26,340 --> 00:33:27,899
you might be able to destroy something

823
00:33:27,899 --> 00:33:30,179
else yeah

824
00:33:30,179 --> 00:33:33,000
um and also another way the the way we

825
00:33:33,000 --> 00:33:35,519
actually did it how we found out this

826
00:33:35,519 --> 00:33:39,000
this vulnerability is you send in uh the

827
00:33:39,000 --> 00:33:41,100
pro to object in a schema validation for

828
00:33:41,100 --> 00:33:43,260
example and if everything is fine then

829
00:33:43,260 --> 00:33:45,120
you know that something is fishy you

830
00:33:45,120 --> 00:33:48,120
shouldn't be able to do this at all

831
00:33:48,120 --> 00:33:50,220
yeah the application to stop you from

832
00:33:50,220 --> 00:33:52,640
doing it

833
00:33:55,260 --> 00:33:59,580
so there is another way around this

834
00:33:59,580 --> 00:34:02,940
and going back to this guy Aaron so

835
00:34:02,940 --> 00:34:06,080
Aaron didn't leave this completely

836
00:34:06,080 --> 00:34:09,480
uh to the world to exploit so he wrote a

837
00:34:09,480 --> 00:34:11,219
library called born

838
00:34:11,219 --> 00:34:14,460
and born is a library that scans the

839
00:34:14,460 --> 00:34:16,679
request body or whatever you tell it to

840
00:34:16,679 --> 00:34:18,780
scan for the word

841
00:34:18,780 --> 00:34:22,739
Proto and removes it from the input this

842
00:34:22,739 --> 00:34:24,659
is a really really shitty solution

843
00:34:24,659 --> 00:34:27,179
really no offense I think he agrees but

844
00:34:27,179 --> 00:34:30,960
it's the best shitty solution we have

845
00:34:30,960 --> 00:34:32,940
that's that's the way to do this right

846
00:34:32,940 --> 00:34:35,339
now so you before you start working with

847
00:34:35,339 --> 00:34:37,500
a request body if you have an

848
00:34:37,500 --> 00:34:38,820
application

849
00:34:38,820 --> 00:34:41,099
scan it for the string Proto and have it

850
00:34:41,099 --> 00:34:44,159
removed there's multiple ways to bypass

851
00:34:44,159 --> 00:34:46,080
these type of scanners born is pretty

852
00:34:46,080 --> 00:34:47,879
clever about this so for instance you

853
00:34:47,879 --> 00:34:49,739
can use one of the many of the Unicode

854
00:34:49,739 --> 00:34:52,619
methods to bypass these matches by

855
00:34:52,619 --> 00:34:55,260
having character flip around things from

856
00:34:55,260 --> 00:34:57,660
the Arabic language for instance those

857
00:34:57,660 --> 00:34:59,940
things tend to bypass but Aaron thought

858
00:34:59,940 --> 00:35:01,680
about it so I think he's

859
00:35:01,680 --> 00:35:05,040
pretty it's pretty safe to use born to

860
00:35:05,040 --> 00:35:07,320
parse your inputs or to scan the input

861
00:35:07,320 --> 00:35:10,200
prior to sending it into your real input

862
00:35:10,200 --> 00:35:13,260
validator but considering that we chose

863
00:35:13,260 --> 00:35:16,560
this language and shows these libraries

864
00:35:16,560 --> 00:35:18,960
and Frameworks because they were fast

865
00:35:18,960 --> 00:35:20,880
this feels like a pretty shitty thing to

866
00:35:20,880 --> 00:35:22,320
do you have to scan them like three

867
00:35:22,320 --> 00:35:25,560
times before they reach your application

868
00:35:25,560 --> 00:35:28,500
just because of a quirk in the language

869
00:35:28,500 --> 00:35:30,839
it's unfortunate but on the other hand

870
00:35:30,839 --> 00:35:34,020
they're also pretty good performance I

871
00:35:34,020 --> 00:35:36,420
mean in this it's it's pretty well

872
00:35:36,420 --> 00:35:41,119
written code so that helps yep

873
00:35:42,060 --> 00:35:45,200
let's do it

874
00:35:45,240 --> 00:35:46,760
so

875
00:35:46,760 --> 00:35:51,920
we need you losers please help us

876
00:35:52,380 --> 00:35:55,980
we need you to get in touch with us and

877
00:35:55,980 --> 00:35:57,900
actually contribute to Resource we are

878
00:35:57,900 --> 00:36:00,720
on the key base uh which is an encrypted

879
00:36:00,720 --> 00:36:03,960
chat Network sort of we're called kyog

880
00:36:03,960 --> 00:36:06,420
and soft sopa and we also have Twitter

881
00:36:06,420 --> 00:36:08,880
we've made a blog post detailing how to

882
00:36:08,880 --> 00:36:11,460
do this gave away all our secrets

883
00:36:11,460 --> 00:36:14,760
completely for free we haven't made any

884
00:36:14,760 --> 00:36:17,099
Bounty money or anything like that yet

885
00:36:17,099 --> 00:36:19,619
but we are ready to work with you if you

886
00:36:19,619 --> 00:36:20,700
want to

887
00:36:20,700 --> 00:36:23,099
figure out Solutions if you can bring up

888
00:36:23,099 --> 00:36:25,800
similar findings stories anything

889
00:36:25,800 --> 00:36:28,079
related to prototype pollution might be

890
00:36:28,079 --> 00:36:30,980
interesting because it's so related

891
00:36:30,980 --> 00:36:33,180
we're trying to build a community around

892
00:36:33,180 --> 00:36:34,920
these type of bugs because we first need

893
00:36:34,920 --> 00:36:36,720
to understand them completely and teach

894
00:36:36,720 --> 00:36:39,240
others about them especially developers

895
00:36:39,240 --> 00:36:42,660
so that we can find ways to or clever

896
00:36:42,660 --> 00:36:46,520
more clever ways to avoid it

897
00:36:46,740 --> 00:36:49,079
all right

898
00:36:49,079 --> 00:36:52,640
thank you thank you

899
00:36:57,900 --> 00:37:00,240
we do have time for questions right yes

900
00:37:00,240 --> 00:37:02,280
we do I think

901
00:37:02,280 --> 00:37:04,680
are we allowed to have questions

902
00:37:04,680 --> 00:37:07,700
uh there's a question

903
00:37:08,220 --> 00:37:11,400
what sound is asleep

904
00:37:11,400 --> 00:37:16,079
yes we're getting the money sorry

905
00:37:16,380 --> 00:37:18,780
all right thank you

906
00:37:18,780 --> 00:37:22,079
um so obviously they didn't fix it in

907
00:37:22,079 --> 00:37:24,240
the JavaScript language because uh

908
00:37:24,240 --> 00:37:26,940
backwards competitive I guess

909
00:37:26,940 --> 00:37:30,720
um but in other tools like SAS tools or

910
00:37:30,720 --> 00:37:33,540
in IDs do you see it fixed there or like

911
00:37:33,540 --> 00:37:35,940
warned about there

912
00:37:35,940 --> 00:37:38,280
I haven't seen anything yet uh I mean no

913
00:37:38,280 --> 00:37:41,880
this this is quite hard to

914
00:37:41,880 --> 00:37:45,240
um yeah I think what the community is

915
00:37:45,240 --> 00:37:46,920
fixing right now

916
00:37:46,920 --> 00:37:49,260
is what Joy is trying to do to just

917
00:37:49,260 --> 00:37:52,079
remove any other type of input that's

918
00:37:52,079 --> 00:37:54,660
not there that's essentially fixing the

919
00:37:54,660 --> 00:37:57,599
bug called hidden property abuse where

920
00:37:57,599 --> 00:37:59,420
you just append real

921
00:37:59,420 --> 00:38:02,220
user control things that's the bug that

922
00:38:02,220 --> 00:38:03,720
the community is working on right now

923
00:38:03,720 --> 00:38:07,079
not this one necessarily in total and I

924
00:38:07,079 --> 00:38:08,880
think it's because people don't remind

925
00:38:08,880 --> 00:38:11,960
them that this is a thing

926
00:38:12,780 --> 00:38:14,820
do you have any other questions there

927
00:38:14,820 --> 00:38:16,440
yes over there

928
00:38:16,440 --> 00:38:18,540
I'd like while you walk I'd like to

929
00:38:18,540 --> 00:38:20,880
mention also that it wasn't easy for us

930
00:38:20,880 --> 00:38:22,920
to find this it wasn't easy for us to

931
00:38:22,920 --> 00:38:24,960
find their previous research

932
00:38:24,960 --> 00:38:26,640
and I think that's an issue that's

933
00:38:26,640 --> 00:38:28,200
limiting people from understanding it

934
00:38:28,200 --> 00:38:29,220
too

935
00:38:29,220 --> 00:38:33,119
great talk I've watched half of it so

936
00:38:33,119 --> 00:38:34,560
sorry if you answered my question

937
00:38:34,560 --> 00:38:37,980
earlier in this so JavaScript poisoning

938
00:38:37,980 --> 00:38:40,380
prototype poisoning Etc it's an error I

939
00:38:40,380 --> 00:38:41,540
see a lot

940
00:38:41,540 --> 00:38:44,579
and it's one that developers are having

941
00:38:44,579 --> 00:38:48,300
like the less awareness about let me

942
00:38:48,300 --> 00:38:51,540
rephrase developers are falling into

943
00:38:51,540 --> 00:38:54,180
this error all the time without like

944
00:38:54,180 --> 00:38:57,060
realizing with arrays being implicitly

945
00:38:57,060 --> 00:39:00,359
defined Etc I would love to know your

946
00:39:00,359 --> 00:39:04,200
insights your your idea your opinion on

947
00:39:04,200 --> 00:39:07,140
why this happens all the time in terms

948
00:39:07,140 --> 00:39:09,839
of developers why JavaScript prototype

949
00:39:09,839 --> 00:39:13,079
poisoning is still such a big thing when

950
00:39:13,079 --> 00:39:16,260
people are writing code

951
00:39:16,260 --> 00:39:19,079
I mean it's the question white actually

952
00:39:19,079 --> 00:39:22,079
exists like white White's still there uh

953
00:39:22,079 --> 00:39:24,060
because developers kind of know about

954
00:39:24,060 --> 00:39:25,640
prototype illusion is that the question

955
00:39:25,640 --> 00:39:29,040
so my question is why is it in my

956
00:39:29,040 --> 00:39:32,400
opinion one of the top uh things I see

957
00:39:32,400 --> 00:39:35,520
in JavaScript written in code all the

958
00:39:35,520 --> 00:39:37,859
time without realizing that it's a

959
00:39:37,859 --> 00:39:41,040
mistake yeah I I think what where we are

960
00:39:41,040 --> 00:39:43,079
right now if you

961
00:39:43,079 --> 00:39:47,579
remember how it was back in 2001 with

962
00:39:47,579 --> 00:39:49,800
the SQL injection this is where we are

963
00:39:49,800 --> 00:39:52,500
with prototype related bugs right no one

964
00:39:52,500 --> 00:39:54,060
knows how the developers hackers are

965
00:39:54,060 --> 00:39:56,940
getting to know it and right now a field

966
00:39:56,940 --> 00:39:59,099
or a Mason Labyrinth is opening up and

967
00:39:59,099 --> 00:40:00,839
we are sort of rush in there and squash

968
00:40:00,839 --> 00:40:04,578
things fight dragons and monsters

969
00:40:08,700 --> 00:40:10,920
why not just fix it in the

970
00:40:10,920 --> 00:40:14,220
um Json parser like I know that doesn't

971
00:40:14,220 --> 00:40:15,720
fix all the problem right but like make

972
00:40:15,720 --> 00:40:18,119
the default Json parser if it sees the

973
00:40:18,119 --> 00:40:19,980
Prototype keyword

974
00:40:19,980 --> 00:40:21,780
triple Escape it or something like that

975
00:40:21,780 --> 00:40:24,900
you could and they actually kind of

976
00:40:24,900 --> 00:40:27,780
fixed it uh not really but it kind of

977
00:40:27,780 --> 00:40:31,079
fix it in in Json Parts uh but still you

978
00:40:31,079 --> 00:40:33,060
have I mean what if you get input in

979
00:40:33,060 --> 00:40:34,859
other ways like you get it in XML or or

980
00:40:34,859 --> 00:40:38,040
query string or uh for example like

981
00:40:38,040 --> 00:40:40,380
Beeson that we're uh about to

982
00:40:40,380 --> 00:40:43,320
investigate that you have you have the

983
00:40:43,320 --> 00:40:45,839
the issue is in JavaScript when you

984
00:40:45,839 --> 00:40:48,180
create a new object you're always able

985
00:40:48,180 --> 00:40:49,619
to create your own prototype for that

986
00:40:49,619 --> 00:40:51,420
object

987
00:40:51,420 --> 00:40:53,820
um so yes you could but it doesn't

988
00:40:53,820 --> 00:40:56,760
really stop everything from there is

989
00:40:56,760 --> 00:40:58,740
also another reason and this is a bit

990
00:40:58,740 --> 00:41:00,119
unfortunate but people are actually

991
00:41:00,119 --> 00:41:03,900
using the dunder Proto string invalid at

992
00:41:03,900 --> 00:41:05,640
real applications it's actually being

993
00:41:05,640 --> 00:41:08,040
used in communication between front-end

994
00:41:08,040 --> 00:41:10,440
and back end in applications so if you

995
00:41:10,440 --> 00:41:12,359
break that

996
00:41:12,359 --> 00:41:14,640
and that's why Joy didn't fix it because

997
00:41:14,640 --> 00:41:18,780
they had users of that library that

998
00:41:18,780 --> 00:41:22,640
deliberately used Proto

999
00:41:25,700 --> 00:41:27,780
it's like a real question over there

1000
00:41:27,780 --> 00:41:29,280
right

1001
00:41:29,280 --> 00:41:32,280
yes

1002
00:41:37,760 --> 00:41:40,200
so you were talking about the solution

1003
00:41:40,200 --> 00:41:43,380
using Proto filtering strings

1004
00:41:43,380 --> 00:41:45,780
what I'm wondering is kind of to use

1005
00:41:45,780 --> 00:41:48,000
replace the Prototype object with a safe

1006
00:41:48,000 --> 00:41:49,560
prototype object when you are creating

1007
00:41:49,560 --> 00:41:51,060
the object itself

1008
00:41:51,060 --> 00:41:54,119
right so that means so what he's

1009
00:41:54,119 --> 00:41:55,920
suggesting is that you overwrite the

1010
00:41:55,920 --> 00:41:58,320
Prototype on input you had this idea

1011
00:41:58,320 --> 00:41:59,880
before we talked about noddling the

1012
00:41:59,880 --> 00:42:02,640
Prototype right yes I mean you you uh a

1013
00:42:02,640 --> 00:42:05,400
way to I mean to protect yourself from

1014
00:42:05,400 --> 00:42:07,200
prototype pollution is to create a null

1015
00:42:07,200 --> 00:42:08,820
prototype in that I'll say you create

1016
00:42:08,820 --> 00:42:12,420
object start crate and unknown but the

1017
00:42:12,420 --> 00:42:13,800
issue here is

1018
00:42:13,800 --> 00:42:17,040
um uh you since we're sending in a new

1019
00:42:17,040 --> 00:42:19,079
prototype even though the object has a

1020
00:42:19,079 --> 00:42:20,460
null prototype you're creating the

1021
00:42:20,460 --> 00:42:22,440
Prototype yourself

1022
00:42:22,440 --> 00:42:24,180
so

1023
00:42:24,180 --> 00:42:24,980
um

1024
00:42:24,980 --> 00:42:28,140
it's it is hard to protect against this

1025
00:42:28,140 --> 00:42:31,320
um not sure if you have any commenting

1026
00:42:31,320 --> 00:42:35,160
uh I think it might work in some cases

1027
00:42:35,160 --> 00:42:38,280
to do it uh

1028
00:42:38,280 --> 00:42:41,780
I think one issue is that uh

1029
00:42:41,780 --> 00:42:43,320
still

1030
00:42:43,320 --> 00:42:44,099
um

1031
00:42:44,099 --> 00:42:46,440
if you don't check the input you can

1032
00:42:46,440 --> 00:42:48,180
still alter the Prototype unless it's

1033
00:42:48,180 --> 00:42:50,400
frozen right so you can always alter the

1034
00:42:50,400 --> 00:42:52,380
Prototype if it's merged with another

1035
00:42:52,380 --> 00:42:55,200
input object at some point somewhere one

1036
00:42:55,200 --> 00:42:56,579
structure that we didn't mention during

1037
00:42:56,579 --> 00:42:58,680
this talk we're thinking about is that

1038
00:42:58,680 --> 00:43:01,980
the HTTP header itself is a structured

1039
00:43:01,980 --> 00:43:03,000
format

1040
00:43:03,000 --> 00:43:05,520
that could contain a prototype you could

1041
00:43:05,520 --> 00:43:06,839
have a header called underscore

1042
00:43:06,839 --> 00:43:08,640
underscore Proto underscore underscore

1043
00:43:08,640 --> 00:43:10,260
colon and then

1044
00:43:10,260 --> 00:43:13,020
a list of something

1045
00:43:13,020 --> 00:43:16,160
I mean that's another one

1046
00:43:16,220 --> 00:43:19,380
do we have any more questions before we

1047
00:43:19,380 --> 00:43:22,220
end this evening

1048
00:43:34,260 --> 00:43:35,400
hmm

1049
00:43:35,400 --> 00:43:39,240
yeah so my question would be on the

1050
00:43:39,240 --> 00:43:43,079
server side is the Purdue still being

1051
00:43:43,079 --> 00:43:48,540
checked or can you still inject uh like

1052
00:43:48,540 --> 00:43:51,180
arbitrary code to execute on this other

1053
00:43:51,180 --> 00:43:53,419
side

1054
00:43:53,480 --> 00:43:55,859
like on the server side you should check

1055
00:43:55,859 --> 00:43:58,680
for Proto case or like I mean if you use

1056
00:43:58,680 --> 00:44:01,560
expressed or with node.js for example

1057
00:44:01,560 --> 00:44:05,000
and I sent some

1058
00:44:05,000 --> 00:44:07,200
JavaScript code

1059
00:44:07,200 --> 00:44:09,880
and then also inject some

1060
00:44:09,880 --> 00:44:11,700
[Music]

1061
00:44:11,700 --> 00:44:14,700
arbitrary code in the Proto object how

1062
00:44:14,700 --> 00:44:17,400
would the server handle it as of now uh

1063
00:44:17,400 --> 00:44:20,400
I mean if for example if you're able to

1064
00:44:20,400 --> 00:44:22,859
send in a function as a key and that

1065
00:44:22,859 --> 00:44:24,119
will be around later then you have

1066
00:44:24,119 --> 00:44:26,640
remote code execution but that's one of

1067
00:44:26,640 --> 00:44:28,740
the limitations with Json for example uh

1068
00:44:28,740 --> 00:44:30,359
when you send that you know user inputs

1069
00:44:30,359 --> 00:44:32,280
uh I mean you can't really send a

1070
00:44:32,280 --> 00:44:34,140
function right you can only send a

1071
00:44:34,140 --> 00:44:38,819
string or like Boolean or uh integer but

1072
00:44:38,819 --> 00:44:39,740
um

1073
00:44:39,740 --> 00:44:43,759
uh I mean

1074
00:44:45,180 --> 00:44:46,260
um

1075
00:44:46,260 --> 00:44:48,300
it is possible to have a remote code

1076
00:44:48,300 --> 00:44:50,520
execution with this you should always

1077
00:44:50,520 --> 00:44:52,140
look for the protokeys and you any

1078
00:44:52,140 --> 00:44:54,180
anytime you have user inputs I mean you

1079
00:44:54,180 --> 00:44:56,819
should ignore the Proto case always uh

1080
00:44:56,819 --> 00:44:59,280
it's not really nice that a user should

1081
00:44:59,280 --> 00:45:01,560
send in a prototype for for the object I

1082
00:45:01,560 --> 00:45:03,660
mean even though you would have like

1083
00:45:03,660 --> 00:45:06,599
microservices architecture it's it's

1084
00:45:06,599 --> 00:45:09,599
really bad to to have I mean Services

1085
00:45:09,599 --> 00:45:12,000
sending prototypes to each other in that

1086
00:45:12,000 --> 00:45:15,240
way and so Express and node will not

1087
00:45:15,240 --> 00:45:18,000
filter or limit any of these attacks it

1088
00:45:18,000 --> 00:45:20,040
would rather actually help them slightly

1089
00:45:20,040 --> 00:45:22,560
so getting getting the data in there is

1090
00:45:22,560 --> 00:45:24,839
right now not the problem uh as an

1091
00:45:24,839 --> 00:45:26,520
attacker though getting into execution

1092
00:45:26,520 --> 00:45:28,260
is a bit tricky because you need to

1093
00:45:28,260 --> 00:45:30,900
reach a function that does evaluation of

1094
00:45:30,900 --> 00:45:33,599
what you're typing as a string so string

1095
00:45:33,599 --> 00:45:35,460
evaluation into code that's what you

1096
00:45:35,460 --> 00:45:37,920
want to find and for us as testers to

1097
00:45:37,920 --> 00:45:40,079
find this brute forcing is not a good

1098
00:45:40,079 --> 00:45:43,440
option what we need is a symbolic

1099
00:45:43,440 --> 00:45:46,200
symbolic execution scanner that scans

1100
00:45:46,200 --> 00:45:49,859
every possible input with every possible

1101
00:45:49,859 --> 00:45:51,660
dangerous function that we would want to

1102
00:45:51,660 --> 00:45:54,240
reach like eval or system or whatever

1103
00:45:54,240 --> 00:45:57,420
thing you want to hit and doing that

1104
00:45:57,420 --> 00:45:59,160
over a large code basis that's the

1105
00:45:59,160 --> 00:46:01,500
solution to start identifying where

1106
00:46:01,500 --> 00:46:03,839
these bugs are so some might be

1107
00:46:03,839 --> 00:46:07,800
vulnerable to to rce as you suggest some

1108
00:46:07,800 --> 00:46:10,079
might go into SQL injection or something

1109
00:46:10,079 --> 00:46:12,119
different you also need a hacker's

1110
00:46:12,119 --> 00:46:14,220
mindset and I to see which one is which

1111
00:46:14,220 --> 00:46:15,900
because you will get plenty of false

1112
00:46:15,900 --> 00:46:17,819
positives trying to do this and in a lot

1113
00:46:17,819 --> 00:46:19,560
of cases overwrite really shitty things

1114
00:46:19,560 --> 00:46:21,780
to do basically nothing

1115
00:46:21,780 --> 00:46:24,300
so you will get requests where the

1116
00:46:24,300 --> 00:46:26,760
service has 500 error crash lots of

1117
00:46:26,760 --> 00:46:29,940
times first

1118
00:46:30,119 --> 00:46:32,160
do we have any more questions we have a

1119
00:46:32,160 --> 00:46:34,759
little more time

1120
00:46:44,660 --> 00:46:48,259
thank you foreign

1121
00:46:54,740 --> 00:46:58,020
did you do it uh in practice

1122
00:46:58,020 --> 00:46:59,940
so if we combine this with this

1123
00:46:59,940 --> 00:47:01,920
realization we'll start the question no

1124
00:47:01,920 --> 00:47:05,640
yeah you mentioned that uh during uh

1125
00:47:05,640 --> 00:47:07,740
digitalization Zone format some code

1126
00:47:07,740 --> 00:47:10,560
evaluated in the mongodb driver or

1127
00:47:10,560 --> 00:47:14,220
mongodb package have you exploited it if

1128
00:47:14,220 --> 00:47:18,180
you can exploit the mongodb yeah we

1129
00:47:18,180 --> 00:47:19,619
haven't been able to explore that I

1130
00:47:19,619 --> 00:47:22,260
haven't really uh investigated it yet

1131
00:47:22,260 --> 00:47:24,960
but as we can see with HPA that it was

1132
00:47:24,960 --> 00:47:26,760
possible to exploit it yeah

1133
00:47:26,760 --> 00:47:29,579
vulnerability should uh or could

1134
00:47:29,579 --> 00:47:31,980
possibly be so there has been three

1135
00:47:31,980 --> 00:47:35,460
mongodb related exploits in this sort of

1136
00:47:35,460 --> 00:47:37,740
field of bug classes and those were

1137
00:47:37,740 --> 00:47:40,040
published by uh thing

1138
00:47:40,040 --> 00:47:44,220
earlier where he found that in one case

1139
00:47:44,220 --> 00:47:46,920
you could in Express for instance

1140
00:47:46,920 --> 00:47:49,500
you could create an ad document that

1141
00:47:49,500 --> 00:47:52,740
would end up in a safer eval function

1142
00:47:52,740 --> 00:47:54,900
and there he could do basic evaluation

1143
00:47:54,900 --> 00:47:57,420
and that was in RC for instance he did

1144
00:47:57,420 --> 00:47:59,760
that in he found an SQL injection

1145
00:47:59,760 --> 00:48:03,119
in the mongodb connector which made it

1146
00:48:03,119 --> 00:48:04,920
so that you could have it in one given

1147
00:48:04,920 --> 00:48:07,440
input field you could overwrite any

1148
00:48:07,440 --> 00:48:10,560
other field so say I have name as an

1149
00:48:10,560 --> 00:48:12,720
input as long as I can control the Json

1150
00:48:12,720 --> 00:48:14,940
string as an attacker I could just add

1151
00:48:14,940 --> 00:48:17,220
the fields to to change where the data

1152
00:48:17,220 --> 00:48:20,220
would end up which is an SQL reaction so

1153
00:48:20,220 --> 00:48:22,500
there was plenty of attacks that were

1154
00:48:22,500 --> 00:48:24,060
going in that certain

1155
00:48:24,060 --> 00:48:26,280
Direction I think

1156
00:48:26,280 --> 00:48:29,700
um it's not necessarily something that

1157
00:48:29,700 --> 00:48:33,859
will work with our combined attack thing

1158
00:48:33,859 --> 00:48:37,560
what this is better for right now is to

1159
00:48:37,560 --> 00:48:39,599
create exceptions to course exceptions

1160
00:48:39,599 --> 00:48:41,760
because we can override functions so

1161
00:48:41,760 --> 00:48:43,560
that they cannot run so we can cause

1162
00:48:43,560 --> 00:48:46,079
type errors we can make printing not

1163
00:48:46,079 --> 00:48:48,660
work we can create console log errors so

1164
00:48:48,660 --> 00:48:50,819
that logging doesn't work anymore those

1165
00:48:50,819 --> 00:48:53,280
type of things that's the level of

1166
00:48:53,280 --> 00:48:55,140
attack phase that we are in right now

1167
00:48:55,140 --> 00:48:58,260
but if you start scanning for it you can

1168
00:48:58,260 --> 00:48:59,640
find combinations where you would

1169
00:48:59,640 --> 00:49:00,839
potentially be able to overwrite the

1170
00:49:00,839 --> 00:49:02,819
global if you can override to go Global

1171
00:49:02,819 --> 00:49:05,160
you can things up badly so that's

1172
00:49:05,160 --> 00:49:07,040
one example of

1173
00:49:07,040 --> 00:49:10,740
finding a different attack path here the

1174
00:49:10,740 --> 00:49:12,780
recursive Loops the length those type of

1175
00:49:12,780 --> 00:49:16,380
things evals is of course good and any

1176
00:49:16,380 --> 00:49:18,540
type of interpreter that goes to a shell

1177
00:49:18,540 --> 00:49:21,720
or a third-party thing is is a target

1178
00:49:21,720 --> 00:49:24,060
that we want to go for we are going to

1179
00:49:24,060 --> 00:49:26,099
look into mongodb that's the thing for

1180
00:49:26,099 --> 00:49:28,800
sure you know because mongodb is using

1181
00:49:28,800 --> 00:49:31,760
Json so yes

1182
00:49:32,700 --> 00:49:36,660
so any more follow-up questions

1183
00:49:36,660 --> 00:49:39,060
over there a lot of questions thank you

1184
00:49:39,060 --> 00:49:42,319
for all the questions yeah

1185
00:49:45,079 --> 00:49:49,440
so assuming oh wow this feels weird so

1186
00:49:49,440 --> 00:49:52,319
assuming that these hidden fields are

1187
00:49:52,319 --> 00:49:54,780
also excluded from when you try to

1188
00:49:54,780 --> 00:49:56,819
re-serialize the object

1189
00:49:56,819 --> 00:49:59,780
wouldn't one very brain dead

1190
00:49:59,780 --> 00:50:02,400
sanitization method be to deserialize

1191
00:50:02,400 --> 00:50:04,920
re-serializing and deserialize again

1192
00:50:04,920 --> 00:50:09,140
which should remove all prototypes

1193
00:50:09,540 --> 00:50:12,240
good question I I have no idea no I I

1194
00:50:12,240 --> 00:50:13,560
don't know either

1195
00:50:13,560 --> 00:50:14,460
um

1196
00:50:14,460 --> 00:50:18,240
I I haven't thought about it sorry

1197
00:50:18,240 --> 00:50:21,180
but yeah we might get there but let's

1198
00:50:21,180 --> 00:50:23,220
talk later seriously that might be

1199
00:50:23,220 --> 00:50:24,300
interesting

1200
00:50:24,300 --> 00:50:26,480
yep

1201
00:50:26,480 --> 00:50:29,160
reach a hand if you have a one last

1202
00:50:29,160 --> 00:50:31,460
question

1203
00:50:36,000 --> 00:50:38,300
foreign

1204
00:50:38,579 --> 00:50:40,560
so

1205
00:50:40,560 --> 00:50:43,920
I want to gladly thank Christopher kibi

1206
00:50:43,920 --> 00:50:47,180
and Anton Leneer

1207
00:50:47,940 --> 00:50:50,040
was a great speech and great questions

1208
00:50:50,040 --> 00:50:52,980
yep thank you all right thank you very

1209
00:50:52,980 --> 00:50:55,700
much thank you

