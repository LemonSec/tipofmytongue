1
00:00:03,380 --> 00:00:06,600
okay so we'll start our talk we are very

2
00:00:06,600 --> 00:00:08,519
happy to be here again in Sweden

3
00:00:08,519 --> 00:00:11,099
Stockholm sector the land of Vikings and

4
00:00:11,099 --> 00:00:14,340
Ikea and today we will present how we

5
00:00:14,340 --> 00:00:16,260
found the many vulnerabilities in

6
00:00:16,260 --> 00:00:18,900
third-party drivers in Linux in a

7
00:00:18,900 --> 00:00:20,880
colorful way

8
00:00:20,880 --> 00:00:23,340
I'm Iran shimoni a security researcher

9
00:00:23,340 --> 00:00:25,680
at cyberwork primarily focusing on the

10
00:00:25,680 --> 00:00:27,960
Discovery and exploitation of local

11
00:00:27,960 --> 00:00:30,240
privileges Collision bugs across via

12
00:00:30,240 --> 00:00:32,460
operating systems and I really enjoy

13
00:00:32,460 --> 00:00:35,040
Also drinking and mixing cocktails and

14
00:00:35,040 --> 00:00:37,559
sometimes doing meditation can happen on

15
00:00:37,559 --> 00:00:39,840
the same time hello everyone my name is

16
00:00:39,840 --> 00:00:42,000
and I'm a vulnerability researcher at

17
00:00:42,000 --> 00:00:44,219
several Labs focusing mainly on

18
00:00:44,219 --> 00:00:46,739
operating system internals and except

19
00:00:46,739 --> 00:00:48,719
playing with Colonel as I'm enjoying a

20
00:00:48,719 --> 00:00:49,920
CrossFit

21
00:00:49,920 --> 00:00:51,840
so let's see what we have on our menu

22
00:00:51,840 --> 00:00:53,640
today we will start with the difference

23
00:00:53,640 --> 00:00:56,219
between a research in open source based

24
00:00:56,219 --> 00:00:58,680
closed Source after that we will have

25
00:00:58,680 --> 00:01:01,260
some Linux kernel internals 101 enough

26
00:01:01,260 --> 00:01:03,180
for us to understand the bugs but not

27
00:01:03,180 --> 00:01:05,400
too much to make you fall asleep

28
00:01:05,400 --> 00:01:07,740
after that we will go to a very

29
00:01:07,740 --> 00:01:09,720
important piece in every privileged

30
00:01:09,720 --> 00:01:12,659
escalation research to which privileged

31
00:01:12,659 --> 00:01:16,020
part can I talk from on the unprivileged

32
00:01:16,020 --> 00:01:18,659
later we will see how messing up with

33
00:01:18,659 --> 00:01:20,580
the colors on your keyboards can affect

34
00:01:20,580 --> 00:01:23,700
to bugs and lastly we will examine a new

35
00:01:23,700 --> 00:01:25,500
mitigation in the Linux kernel that

36
00:01:25,500 --> 00:01:28,439
greatly reduces the severity of buffer

37
00:01:28,439 --> 00:01:30,720
overflow attacks from the potential of

38
00:01:30,720 --> 00:01:32,880
privileged escalation to a mere denial

39
00:01:32,880 --> 00:01:34,439
of service

40
00:01:34,439 --> 00:01:36,720
so let's start closed Source base open

41
00:01:36,720 --> 00:01:38,220
source

42
00:01:38,220 --> 00:01:40,920
on the right we have the beautiful

43
00:01:40,920 --> 00:01:43,740
penguin indicating the lovely operating

44
00:01:43,740 --> 00:01:47,100
system of Linux and on the left we have

45
00:01:47,100 --> 00:01:49,439
the nonso lovely Broken Window

46
00:01:49,439 --> 00:01:51,360
indicating the operating system of

47
00:01:51,360 --> 00:01:52,500
windows

48
00:01:52,500 --> 00:01:54,600
so those are the two operating system we

49
00:01:54,600 --> 00:01:57,119
will talk about we can also honorably

50
00:01:57,119 --> 00:01:59,100
mention Mac which is kind of in between

51
00:01:59,100 --> 00:02:01,020
between open source and a closed Source

52
00:02:01,020 --> 00:02:03,299
because you can argue this new kernel is

53
00:02:03,299 --> 00:02:06,119
open source but the rest is closed

54
00:02:06,119 --> 00:02:07,439
source

55
00:02:07,439 --> 00:02:09,840
so what is so special about closed

56
00:02:09,840 --> 00:02:11,160
Source well

57
00:02:11,160 --> 00:02:14,040
obviously we lack the code of it so in

58
00:02:14,040 --> 00:02:15,660
order to understand what happens under

59
00:02:15,660 --> 00:02:18,180
the hood we either need to execute it

60
00:02:18,180 --> 00:02:21,060
which really doesn't add anything when

61
00:02:21,060 --> 00:02:23,400
we talk about drivers or reverse

62
00:02:23,400 --> 00:02:25,860
engineer the hell of it now in order to

63
00:02:25,860 --> 00:02:27,480
reverse engineer and understand what

64
00:02:27,480 --> 00:02:29,099
happens we need to have strong knowledge

65
00:02:29,099 --> 00:02:32,340
of low level operating system and they

66
00:02:32,340 --> 00:02:35,640
have the ability to have like to exploit

67
00:02:35,640 --> 00:02:39,480
things which is a very tiresome

68
00:02:39,480 --> 00:02:42,959
the action and it takes time the good

69
00:02:42,959 --> 00:02:44,879
and the plus about it is that usually

70
00:02:44,879 --> 00:02:47,280
those tend to be harder to exploit so

71
00:02:47,280 --> 00:02:50,580
vendors pay nicer bug bounties as we

72
00:02:50,580 --> 00:02:53,040
wrote compared to open source projects

73
00:02:53,040 --> 00:02:55,620
the approach we are going forward in

74
00:02:55,620 --> 00:02:57,900
this type of research is first we try to

75
00:02:57,900 --> 00:03:00,300
gather every possible Intel over our

76
00:03:00,300 --> 00:03:03,060
Target if for instance we try to find a

77
00:03:03,060 --> 00:03:05,819
bug in the windows kernel grapher win42

78
00:03:05,819 --> 00:03:08,099
cases that consists of several thousand

79
00:03:08,099 --> 00:03:10,560
functions it will be impractical to

80
00:03:10,560 --> 00:03:13,440
start with just reversing the binary so

81
00:03:13,440 --> 00:03:16,739
every blog piece or talk about it is

82
00:03:16,739 --> 00:03:19,560
greatly beneficial for the task later we

83
00:03:19,560 --> 00:03:22,260
will try to find any possible code licks

84
00:03:22,260 --> 00:03:24,420
now every version of the windows kernel

85
00:03:24,420 --> 00:03:27,900
had code licks in its history so and

86
00:03:27,900 --> 00:03:29,819
doing a patch diff between a decompiled

87
00:03:29,819 --> 00:03:31,800
or disassembled output to the source

88
00:03:31,800 --> 00:03:34,019
code even though if it could be a bit

89
00:03:34,019 --> 00:03:36,540
dated is very helpful than just having

90
00:03:36,540 --> 00:03:37,980
nothing

91
00:03:37,980 --> 00:03:40,319
after that it's very important to Define

92
00:03:40,319 --> 00:03:42,780
our Target very closely because it's

93
00:03:42,780 --> 00:03:46,019
very easy to get spared away while doing

94
00:03:46,019 --> 00:03:48,360
research like if you reverse engineer

95
00:03:48,360 --> 00:03:50,099
you're familiar that we use start with

96
00:03:50,099 --> 00:03:51,959
one function and one function leads to

97
00:03:51,959 --> 00:03:54,239
100 functions and it's very important

98
00:03:54,239 --> 00:03:56,159
for us to have a straight line at our

99
00:03:56,159 --> 00:03:57,060
Target

100
00:03:57,060 --> 00:03:58,920
so the way we do it is mostly via

101
00:03:58,920 --> 00:04:01,860
reversing and also via fuzzing but we

102
00:04:01,860 --> 00:04:05,700
will touch about fuzzing soon

103
00:04:05,700 --> 00:04:08,220
and open source on the other hand of

104
00:04:08,220 --> 00:04:09,900
course we have the source code we can

105
00:04:09,900 --> 00:04:11,580
understand anything that actually

106
00:04:11,580 --> 00:04:14,159
happens besides that we can use the

107
00:04:14,159 --> 00:04:16,260
tools called Static analysis in order to

108
00:04:16,260 --> 00:04:19,738
find low hanging fruit bugs and more and

109
00:04:19,738 --> 00:04:22,260
lastly we can compile and add debugging

110
00:04:22,260 --> 00:04:24,540
Snippets instrumentation into the code

111
00:04:24,540 --> 00:04:26,220
that will help us in the exploitation

112
00:04:26,220 --> 00:04:27,360
phase

113
00:04:27,360 --> 00:04:29,520
now the first step of course you know

114
00:04:29,520 --> 00:04:32,280
open source open source research is to

115
00:04:32,280 --> 00:04:35,639
find the damn code via GitHub git or if

116
00:04:35,639 --> 00:04:38,220
you use the dark technology called SVN

117
00:04:38,220 --> 00:04:40,860
you can go there of course

118
00:04:40,860 --> 00:04:43,380
now the second step is to run several

119
00:04:43,380 --> 00:04:45,660
static analysis tools now those tools

120
00:04:45,660 --> 00:04:47,400
are very beneficial because they can

121
00:04:47,400 --> 00:04:49,620
help us remember they can help us find

122
00:04:49,620 --> 00:04:51,840
memory corruption type of bugs divide by

123
00:04:51,840 --> 00:04:54,720
zero integer overflow and underflow in a

124
00:04:54,720 --> 00:04:56,280
pretty short time

125
00:04:56,280 --> 00:04:58,139
additionally there are some Advanced

126
00:04:58,139 --> 00:05:00,180
tools like code ql that allow you to

127
00:05:00,180 --> 00:05:02,400
write Advanced queries to that treat

128
00:05:02,400 --> 00:05:04,560
your database that treat your code as a

129
00:05:04,560 --> 00:05:07,080
database and then you can really track

130
00:05:07,080 --> 00:05:08,880
the data flow from one function to

131
00:05:08,880 --> 00:05:11,460
another which is another great tool

132
00:05:11,460 --> 00:05:15,060
after that we compile and build the open

133
00:05:15,060 --> 00:05:18,060
source usually add in some debug

134
00:05:18,060 --> 00:05:20,880
statement that give us Vision about the

135
00:05:20,880 --> 00:05:24,080
state of the software in important parts

136
00:05:24,080 --> 00:05:27,900
and lastly if we manage to actually find

137
00:05:27,900 --> 00:05:30,120
a vulnerability in the code base there

138
00:05:30,120 --> 00:05:31,800
are good chances these vulnerabilities

139
00:05:31,800 --> 00:05:34,199
again can read away the way to other

140
00:05:34,199 --> 00:05:36,060
products as well as you're probably

141
00:05:36,060 --> 00:05:38,820
familiar developers are humans and

142
00:05:38,820 --> 00:05:41,160
humans are a bit lazy and we copy code

143
00:05:41,160 --> 00:05:44,400
from one project to another so once we

144
00:05:44,400 --> 00:05:45,960
find the vulnerability we can probably

145
00:05:45,960 --> 00:05:48,600
find it in different places and we will

146
00:05:48,600 --> 00:05:49,440
see it

147
00:05:49,440 --> 00:05:52,919
and now there is the question of fuzzing

148
00:05:52,919 --> 00:05:55,080
if you are not familiar fuzzing usually

149
00:05:55,080 --> 00:05:57,840
consists of generating input towards the

150
00:05:57,840 --> 00:06:00,120
torrent function with some kind of

151
00:06:00,120 --> 00:06:02,460
feedback mechanism that tracks the code

152
00:06:02,460 --> 00:06:05,460
coverage code coverage basically is the

153
00:06:05,460 --> 00:06:08,100
way the amount of paths you went into

154
00:06:08,100 --> 00:06:10,880
the target software sounds fantastic

155
00:06:10,880 --> 00:06:13,860
well one of the problem that it takes

156
00:06:13,860 --> 00:06:16,560
time everyone who used fuzzer Let It Be

157
00:06:16,560 --> 00:06:19,440
AFL leave fuzzer or C scholar is

158
00:06:19,440 --> 00:06:21,240
familiar with the thing that it takes

159
00:06:21,240 --> 00:06:23,819
time to cosmetize the fuzzer to your own

160
00:06:23,819 --> 00:06:25,199
solution

161
00:06:25,199 --> 00:06:27,000
one approach that is kind of in the

162
00:06:27,000 --> 00:06:29,460
middle and the one that we used in this

163
00:06:29,460 --> 00:06:32,520
research is the usage of a Dom fuzzer a

164
00:06:32,520 --> 00:06:34,380
downforcer does not have any fancy

165
00:06:34,380 --> 00:06:37,259
feedback mechanism it just tries many

166
00:06:37,259 --> 00:06:39,720
input that we have some prior knowledge

167
00:06:39,720 --> 00:06:42,539
about this software beforehand and it's

168
00:06:42,539 --> 00:06:45,479
very useful in the case we know the

169
00:06:45,479 --> 00:06:47,340
specifics of the target for instance we

170
00:06:47,340 --> 00:06:48,900
know we need to go to a particular

171
00:06:48,900 --> 00:06:50,880
function and we don't need really to

172
00:06:50,880 --> 00:06:52,979
spread out the entire in the entire code

173
00:06:52,979 --> 00:06:53,880
base

174
00:06:53,880 --> 00:06:55,919
and of course if you have more time

175
00:06:55,919 --> 00:06:58,319
several weeks or months you can use a

176
00:06:58,319 --> 00:07:01,860
full-blown fuzzer and in some cases the

177
00:07:01,860 --> 00:07:04,500
most advanced the more advanced project

178
00:07:04,500 --> 00:07:08,340
you need to use a better fuzzer

179
00:07:08,340 --> 00:07:10,380
so what are the main takeaways of Open

180
00:07:10,380 --> 00:07:12,240
Source research and why it's a bit

181
00:07:12,240 --> 00:07:14,759
easier we have endless examples that we

182
00:07:14,759 --> 00:07:16,860
can learn from people in the community

183
00:07:16,860 --> 00:07:19,080
are usually very supportive so we can

184
00:07:19,080 --> 00:07:22,080
ask them about them people tend to focus

185
00:07:22,080 --> 00:07:24,479
Less on open source of more low-hanging

186
00:07:24,479 --> 00:07:26,460
fruits and those low-hanging fruits but

187
00:07:26,460 --> 00:07:29,160
can be impactful as a very difficult bug

188
00:07:29,160 --> 00:07:30,840
it really doesn't matter

189
00:07:30,840 --> 00:07:34,199
you have the option to add a code into

190
00:07:34,199 --> 00:07:36,720
the code base and compile it of course

191
00:07:36,720 --> 00:07:39,080
making debug in life a lot easier

192
00:07:39,080 --> 00:07:42,060
fuzzing is also easier because most of

193
00:07:42,060 --> 00:07:43,440
the fuzzing revolves around

194
00:07:43,440 --> 00:07:46,139
instrumentation and it's pretty out of

195
00:07:46,139 --> 00:07:47,759
the box if you can debug the program

196
00:07:47,759 --> 00:07:50,460
with adding code and lastly reverse

197
00:07:50,460 --> 00:07:52,979
engineering is also easier because if

198
00:07:52,979 --> 00:07:54,720
you have the source code and you have

199
00:07:54,720 --> 00:07:56,759
the decompiled output and if the

200
00:07:56,759 --> 00:07:58,860
compiler puts some Shenanigans inside of

201
00:07:58,860 --> 00:08:00,800
it you can pretty much easily understand

202
00:08:00,800 --> 00:08:03,660
what has been done

203
00:08:03,660 --> 00:08:06,720
so maybe if you were here last year you

204
00:08:06,720 --> 00:08:08,400
remember that we gave a talk about how

205
00:08:08,400 --> 00:08:10,560
to find bugs in Windows drivers and

206
00:08:10,560 --> 00:08:14,099
third parties using KFL but today we are

207
00:08:14,099 --> 00:08:16,020
not going to talk to talk about Windows

208
00:08:16,020 --> 00:08:17,520
we are going to talk about a specific

209
00:08:17,520 --> 00:08:18,720
penguin

210
00:08:18,720 --> 00:08:20,759
yeah so as you maybe have figured out

211
00:08:20,759 --> 00:08:22,620
the penguin in the room is the Linux

212
00:08:22,620 --> 00:08:25,139
kernel or my specifically Linux kernel

213
00:08:25,139 --> 00:08:27,180
modules but to understand what Linux

214
00:08:27,180 --> 00:08:28,620
kernel modules are all experts

215
00:08:28,620 --> 00:08:30,599
understand the general architecture of

216
00:08:30,599 --> 00:08:32,700
the Linux operating system

217
00:08:32,700 --> 00:08:35,099
so most of the operating system are

218
00:08:35,099 --> 00:08:37,380
divided into two mainly Parts the user

219
00:08:37,380 --> 00:08:39,479
space and the kernel space the main

220
00:08:39,479 --> 00:08:41,099
difference between them is that the

221
00:08:41,099 --> 00:08:43,260
kernel space is the actually privileged

222
00:08:43,260 --> 00:08:45,360
part of the operation system that can

223
00:08:45,360 --> 00:08:47,820
interact with the hardware an example of

224
00:08:47,820 --> 00:08:49,800
that could be when the user requests to

225
00:08:49,800 --> 00:08:51,899
read a file from the disk the request

226
00:08:51,899 --> 00:08:53,700
actually goes through the kernel which

227
00:08:53,700 --> 00:08:55,440
then proceed to reach the data from the

228
00:08:55,440 --> 00:08:58,320
disk and returns back to the user space

229
00:08:58,320 --> 00:09:00,720
when installing an operating system like

230
00:09:00,720 --> 00:09:03,000
Ubuntu you will get the kernel obviously

231
00:09:03,000 --> 00:09:05,100
installed with it so if you're

232
00:09:05,100 --> 00:09:06,720
installing Ubuntu for example you will

233
00:09:06,720 --> 00:09:08,399
get the Linux kernel installed with it

234
00:09:08,399 --> 00:09:11,060
but it doesn't mean that you cannot and

235
00:09:11,060 --> 00:09:13,140
cannot update or cannot add

236
00:09:13,140 --> 00:09:16,019
functionality to the kernel in runtime

237
00:09:16,019 --> 00:09:17,640
adding functionality and currently

238
00:09:17,640 --> 00:09:20,100
runtime it's done via kernel modules for

239
00:09:20,100 --> 00:09:22,440
example you can add new hardware devices

240
00:09:22,440 --> 00:09:25,260
supports a new kernel devices and new

241
00:09:25,260 --> 00:09:28,019
keyboard devices USB and everything that

242
00:09:28,019 --> 00:09:29,880
uses the hardware most likely will

243
00:09:29,880 --> 00:09:32,279
require a driver to know how to interact

244
00:09:32,279 --> 00:09:34,200
with it

245
00:09:34,200 --> 00:09:36,660
so we've conducted our research focusing

246
00:09:36,660 --> 00:09:38,880
on the Linux kernel because essentially

247
00:09:38,880 --> 00:09:41,580
each bug in the kernel is critical due

248
00:09:41,580 --> 00:09:43,440
to the fact that the kernel is always

249
00:09:43,440 --> 00:09:46,260
privileged and one of the best places to

250
00:09:46,260 --> 00:09:48,779
hunt for bugs in kernel are third-party

251
00:09:48,779 --> 00:09:51,000
kernel modules because most of the time

252
00:09:51,000 --> 00:09:53,220
they're less examined and are accessible

253
00:09:53,220 --> 00:09:56,040
by restricted user

254
00:09:56,040 --> 00:09:58,740
exploiting kernel models bug can lead to

255
00:09:58,740 --> 00:10:00,600
the same impact as exploiting vulnerable

256
00:10:00,600 --> 00:10:03,300
vulnerabilities in the kernel itself so

257
00:10:03,300 --> 00:10:04,800
it can be exploited to add another

258
00:10:04,800 --> 00:10:07,140
service or to a full local future

259
00:10:07,140 --> 00:10:10,320
escalation for example

260
00:10:10,320 --> 00:10:12,660
the way we've done it is by looking for

261
00:10:12,660 --> 00:10:14,940
big third-party vendors and examining

262
00:10:14,940 --> 00:10:16,980
their code which one of them was

263
00:10:16,980 --> 00:10:20,519
openrazer so if you may know Razer is a

264
00:10:20,519 --> 00:10:22,560
big peripheral Hardware vendor focusing

265
00:10:22,560 --> 00:10:25,320
mainly on gaming gear and if you want to

266
00:10:25,320 --> 00:10:26,700
interact with them in a Linux

267
00:10:26,700 --> 00:10:28,980
environment you will most likely use the

268
00:10:28,980 --> 00:10:31,080
open open razor software which is open

269
00:10:31,080 --> 00:10:32,399
sourced

270
00:10:32,399 --> 00:10:34,680
so it lets you to customize your

271
00:10:34,680 --> 00:10:36,300
Hardware so for example lets you to

272
00:10:36,300 --> 00:10:38,760
create a custom macros for your keyboard

273
00:10:38,760 --> 00:10:41,820
custom RGB it even lets you to customize

274
00:10:41,820 --> 00:10:44,160
RGB colors for your mag holder for

275
00:10:44,160 --> 00:10:46,140
example which is amazing

276
00:10:46,140 --> 00:10:48,240
and again it lets you to set different

277
00:10:48,240 --> 00:10:50,700
DPI and every configuration that you may

278
00:10:50,700 --> 00:10:51,660
think about

279
00:10:51,660 --> 00:10:53,700
every type of Hardware device that you

280
00:10:53,700 --> 00:10:55,740
can see here translate to an additional

281
00:10:55,740 --> 00:10:57,839
driver that you have to load into the

282
00:10:57,839 --> 00:11:00,420
kernel to interact with it which expands

283
00:11:00,420 --> 00:11:02,700
greatly our attack surface

284
00:11:02,700 --> 00:11:05,339
an example of what you can do with the

285
00:11:05,339 --> 00:11:07,680
open the open razor will be

286
00:11:07,680 --> 00:11:09,420
for example a

287
00:11:09,420 --> 00:11:13,399
the great Swedish flag

288
00:11:13,560 --> 00:11:15,660
one of the Prime things that we need to

289
00:11:15,660 --> 00:11:17,220
understand while conducting a

290
00:11:17,220 --> 00:11:19,140
vulnerability research is how we can

291
00:11:19,140 --> 00:11:21,300
communicate between the not privileged

292
00:11:21,300 --> 00:11:23,519
and the privileged part and in our case

293
00:11:23,519 --> 00:11:25,920
how we can transfer data between the

294
00:11:25,920 --> 00:11:28,140
user space and the kernel space

295
00:11:28,140 --> 00:11:30,300
in Linux there are multi-paced ways to

296
00:11:30,300 --> 00:11:32,100
do it which will go briefly over the

297
00:11:32,100 --> 00:11:33,839
main ones

298
00:11:33,839 --> 00:11:36,540
so first of all a kernel driver kernel

299
00:11:36,540 --> 00:11:38,220
modules can implement the normal read

300
00:11:38,220 --> 00:11:40,320
and write operation which then can be

301
00:11:40,320 --> 00:11:42,839
accessed on an exposed file via the read

302
00:11:42,839 --> 00:11:44,579
or write sysc codes

303
00:11:44,579 --> 00:11:47,339
otherwise the kernel module can oops

304
00:11:47,339 --> 00:11:49,560
okay otherwise the kernel module can

305
00:11:49,560 --> 00:11:52,860
implement the ioctal API interface which

306
00:11:52,860 --> 00:11:54,420
usually each functionality is

307
00:11:54,420 --> 00:11:56,279
distinguished by the command parameter

308
00:11:56,279 --> 00:11:58,920
this way is very nice to use when using

309
00:11:58,920 --> 00:12:01,440
a non-generic functionality so basically

310
00:12:01,440 --> 00:12:03,180
everything besides reading and just

311
00:12:03,180 --> 00:12:07,560
writing normal data to the device

312
00:12:07,560 --> 00:12:09,899
another way to do it is by using shared

313
00:12:09,899 --> 00:12:11,760
memory between the users and the kernel

314
00:12:11,760 --> 00:12:13,800
Space by doing this it will be the

315
00:12:13,800 --> 00:12:15,480
fastest way of communication between the

316
00:12:15,480 --> 00:12:17,160
user the kernel

317
00:12:17,160 --> 00:12:20,040
Linux also allows you to use exposed

318
00:12:20,040 --> 00:12:22,380
file on a virtual file system like csfs

319
00:12:22,380 --> 00:12:24,959
for example this way is very nice to use

320
00:12:24,959 --> 00:12:26,700
because most of the time each

321
00:12:26,700 --> 00:12:28,800
functionality will be exposed on a

322
00:12:28,800 --> 00:12:32,160
different file via this file system and

323
00:12:32,160 --> 00:12:33,779
it's really nice to use it when you want

324
00:12:33,779 --> 00:12:35,880
to interact with your kernel modules via

325
00:12:35,880 --> 00:12:37,620
shell scripts because again interacting

326
00:12:37,620 --> 00:12:40,079
and just writing and reading to files is

327
00:12:40,079 --> 00:12:41,040
very easy

328
00:12:41,040 --> 00:12:42,899
and lastly there's another way I wanted

329
00:12:42,899 --> 00:12:45,240
to mention which is using the netlink

330
00:12:45,240 --> 00:12:48,120
socket this is a really nice way way if

331
00:12:48,120 --> 00:12:50,459
you don't want to just use files it's

332
00:12:50,459 --> 00:12:53,220
just creating a net link type socket in

333
00:12:53,220 --> 00:12:55,200
the kernel and then it can be using like

334
00:12:55,200 --> 00:12:57,420
normal socket communication via the user

335
00:12:57,420 --> 00:12:59,599
space

336
00:12:59,820 --> 00:13:02,339
so how can we even communicate with our

337
00:13:02,339 --> 00:13:03,420
devices

338
00:13:03,420 --> 00:13:05,940
so if you we will use the Linux so first

339
00:13:05,940 --> 00:13:07,740
of all we need to make sure that the

340
00:13:07,740 --> 00:13:09,839
kernel modules are loaded into the

341
00:13:09,839 --> 00:13:12,420
kernel this can be done by running LS

342
00:13:12,420 --> 00:13:15,060
mode LS mode show us all the kernel

343
00:13:15,060 --> 00:13:16,620
modules that are loaded into the kernel

344
00:13:16,620 --> 00:13:18,779
when grabbing Razer will show us the

345
00:13:18,779 --> 00:13:20,339
drivers

346
00:13:20,339 --> 00:13:23,700
because open razor chose the VFS type of

347
00:13:23,700 --> 00:13:26,160
filex or functionality exposed we need

348
00:13:26,160 --> 00:13:28,200
to know what's the path of the exposed

349
00:13:28,200 --> 00:13:30,360
file so to know that we need to make

350
00:13:30,360 --> 00:13:32,399
sure what that we know what's the vendor

351
00:13:32,399 --> 00:13:34,139
ID and what's the product ID of the

352
00:13:34,139 --> 00:13:37,740
device this can be done by running lsusb

353
00:13:37,740 --> 00:13:40,440
just have a note that Razer will always

354
00:13:40,440 --> 00:13:43,820
raise us vendor ID will be always

355
00:13:43,820 --> 00:13:46,980
hexa1532 and by running lsusb it will

356
00:13:46,980 --> 00:13:49,200
show us all the connected devices via

357
00:13:49,200 --> 00:13:51,839
OSB and we can now watch the product ID

358
00:13:51,839 --> 00:13:55,019
and lastly we can read or write into the

359
00:13:55,019 --> 00:13:57,120
exposed file for example if we're

360
00:13:57,120 --> 00:13:59,040
echoing one which is just writing one

361
00:13:59,040 --> 00:14:01,740
into the file called Matrix effect wave

362
00:14:01,740 --> 00:14:03,540
it will trigger the implemented

363
00:14:03,540 --> 00:14:05,880
functionality in the kernel module which

364
00:14:05,880 --> 00:14:08,480
supposed to lastly

365
00:14:08,480 --> 00:14:11,519
use the wave effect on the device so it

366
00:14:11,519 --> 00:14:15,860
will do this and we can see it also here

367
00:14:18,720 --> 00:14:20,880
all right so now that we know how we can

368
00:14:20,880 --> 00:14:22,920
interact with the internal modules let's

369
00:14:22,920 --> 00:14:25,560
go to the fun part of hunting bugs thank

370
00:14:25,560 --> 00:14:27,500
you

371
00:14:27,500 --> 00:14:30,779
so what are we after we after memory

372
00:14:30,779 --> 00:14:32,940
corruption type of bugs and more

373
00:14:32,940 --> 00:14:35,279
specifically null pointer dereference

374
00:14:35,279 --> 00:14:37,320
arbitrary Point Energy reference any

375
00:14:37,320 --> 00:14:39,600
kind of pointer dereferences but for

376
00:14:39,600 --> 00:14:41,519
underflow and the classical familial

377
00:14:41,519 --> 00:14:43,079
buffer overflow

378
00:14:43,079 --> 00:14:46,380
now the potential places that we aim to

379
00:14:46,380 --> 00:14:49,260
find them is that of copying data from

380
00:14:49,260 --> 00:14:52,500
one way to another like in mem copy SDR

381
00:14:52,500 --> 00:14:55,139
copy and so on and while doing the

382
00:14:55,139 --> 00:14:57,300
reference operation without doing proper

383
00:14:57,300 --> 00:14:59,100
checks about the point return values

384
00:14:59,100 --> 00:15:00,660
beforehand

385
00:15:00,660 --> 00:15:04,139
and let's introduce two very

386
00:15:04,139 --> 00:15:07,860
actually famous terms source and things

387
00:15:07,860 --> 00:15:10,560
so on the left we have Nikola Tesla the

388
00:15:10,560 --> 00:15:13,560
inventor of the light bulb we found we

389
00:15:13,560 --> 00:15:15,540
fought him the wooden B probably RGB

390
00:15:15,540 --> 00:15:17,820
colors and we wouldn't be here thank you

391
00:15:17,820 --> 00:15:19,980
so Props for him thank you

392
00:15:19,980 --> 00:15:23,459
and on the right we have a sink

393
00:15:23,459 --> 00:15:25,800
with blue color and so on

394
00:15:25,800 --> 00:15:29,040
so the both the two approach that we use

395
00:15:29,040 --> 00:15:30,600
in order to find vulnerabilities is

396
00:15:30,600 --> 00:15:32,459
either go from the source to the target

397
00:15:32,459 --> 00:15:35,399
from or from the target to The Source in

398
00:15:35,399 --> 00:15:38,160
other words we first map where we can

399
00:15:38,160 --> 00:15:40,920
enter where our payload from the user

400
00:15:40,920 --> 00:15:43,440
enters to the kernel and then where the

401
00:15:43,440 --> 00:15:45,360
target is for instance a vulnerable mem

402
00:15:45,360 --> 00:15:46,800
copy operation

403
00:15:46,800 --> 00:15:48,779
after that we do the other way around

404
00:15:48,779 --> 00:15:52,260
from the mem copy operation we trace the

405
00:15:52,260 --> 00:15:54,600
path into the source

406
00:15:54,600 --> 00:15:57,660
in other words first we ask ourselves to

407
00:15:57,660 --> 00:15:59,880
which function do we have access to from

408
00:15:59,880 --> 00:16:03,600
unprivileged user next we try to

409
00:16:03,600 --> 00:16:05,579
determine which arguments we have

410
00:16:05,579 --> 00:16:07,980
control over and what affects them then

411
00:16:07,980 --> 00:16:10,139
we will look for data copying operations

412
00:16:10,139 --> 00:16:12,899
like the mem copy Str copy and pointer D

413
00:16:12,899 --> 00:16:15,060
references any one of those operations

414
00:16:15,060 --> 00:16:17,579
is a good place to look for a bug and

415
00:16:17,579 --> 00:16:19,560
then what we do backward tracing we're

416
00:16:19,560 --> 00:16:22,800
going back from the sync to the source

417
00:16:22,800 --> 00:16:25,440
so we again look for all the vulnerable

418
00:16:25,440 --> 00:16:28,560
operation we see how the arguments in

419
00:16:28,560 --> 00:16:30,120
between are changed and then we

420
00:16:30,120 --> 00:16:32,220
determine if the function is even

421
00:16:32,220 --> 00:16:34,980
accessible while doing those two things

422
00:16:34,980 --> 00:16:37,019
we are like grasping a stick in two

423
00:16:37,019 --> 00:16:39,480
hands and going going into the middle

424
00:16:39,480 --> 00:16:41,880
allowing us to have better understanding

425
00:16:41,880 --> 00:16:44,399
if there is a vulnerability here that we

426
00:16:44,399 --> 00:16:46,320
can exploit from under from a

427
00:16:46,320 --> 00:16:49,019
non-privileged user so let's have an

428
00:16:49,019 --> 00:16:52,079
example this is like a real example in

429
00:16:52,079 --> 00:16:55,800
one of Fraser kernel models the function

430
00:16:55,800 --> 00:16:57,839
is called razor comma extended metrics

431
00:16:57,839 --> 00:17:00,540
set custom frame 2 and it's responsible

432
00:17:00,540 --> 00:17:03,000
to change the lives of your keyboard

433
00:17:03,000 --> 00:17:05,400
you can see that it receives an argument

434
00:17:05,400 --> 00:17:07,500
called the war index the row of your

435
00:17:07,500 --> 00:17:10,140
keyboard start column and stop column

436
00:17:10,140 --> 00:17:13,319
also it receive RGB data which is the

437
00:17:13,319 --> 00:17:16,140
color of the you know the thing you want

438
00:17:16,140 --> 00:17:18,299
to change on your keyboard can you maybe

439
00:17:18,299 --> 00:17:21,918
spot a vulnerability here

440
00:17:26,520 --> 00:17:29,580
so a good place to look is the mem copy

441
00:17:29,580 --> 00:17:32,460
instruction and we also need to know

442
00:17:32,460 --> 00:17:34,380
that I didn't tell you that that the

443
00:17:34,380 --> 00:17:36,240
report argument buffer is in the length

444
00:17:36,240 --> 00:17:38,640
of 80 bytes

445
00:17:38,640 --> 00:17:41,520
now there is the third parameter of the

446
00:17:41,520 --> 00:17:43,620
mem copy instruction the raw length and

447
00:17:43,620 --> 00:17:45,960
the row length is being calculated in

448
00:17:45,960 --> 00:17:48,660
stop column plus one minus start column

449
00:17:48,660 --> 00:17:50,940
times three

450
00:17:50,940 --> 00:17:53,039
and you're probably familiar that the

451
00:17:53,039 --> 00:17:57,240
max size of unsigned car is 255 bytes 2

452
00:17:57,240 --> 00:17:59,580
to the power of 8 minus 1.

453
00:17:59,580 --> 00:18:01,860
and while multiple it by 3 we get the

454
00:18:01,860 --> 00:18:03,140
value of

455
00:18:03,140 --> 00:18:06,240
765. now the way the mem copy

456
00:18:06,240 --> 00:18:09,000
instruction works is that you copy the

457
00:18:09,000 --> 00:18:11,580
first 80 bytes into the buffer and then

458
00:18:11,580 --> 00:18:13,160
we have a lovely

459
00:18:13,160 --> 00:18:17,100
685 bytes of overflow on the stack the

460
00:18:17,100 --> 00:18:20,520
very classic stock overflow bug now that

461
00:18:20,520 --> 00:18:23,100
itself is not enough like to escalate

462
00:18:23,100 --> 00:18:25,440
into root or to run code in the kernel

463
00:18:25,440 --> 00:18:28,200
but alongside another primitive of an

464
00:18:28,200 --> 00:18:31,080
info leak for instance is enough to pass

465
00:18:31,080 --> 00:18:34,500
every mitigation so we thought but short

466
00:18:34,500 --> 00:18:37,320
about that now another vulnerable code

467
00:18:37,320 --> 00:18:40,320
as we said earlier one code can carried

468
00:18:40,320 --> 00:18:42,600
away to another project

469
00:18:42,600 --> 00:18:45,120
this is the Razer report Razer chroma

470
00:18:45,120 --> 00:18:47,820
miscuan row set custom frame function

471
00:18:47,820 --> 00:18:49,860
and it has

472
00:18:49,860 --> 00:18:52,200
suffers from the same bug and this

473
00:18:52,200 --> 00:18:54,539
lovely function is responsible for this

474
00:18:54,539 --> 00:18:56,760
very important device

475
00:18:56,760 --> 00:18:59,820
so by having this mug holder it makes

476
00:18:59,820 --> 00:19:01,080
you vulnerable

477
00:19:01,080 --> 00:19:03,000
to the not of service attack and

478
00:19:03,000 --> 00:19:05,640
privilege escalation ones in the kernel

479
00:19:05,640 --> 00:19:08,520
so this metal fin can be hot it can be

480
00:19:08,520 --> 00:19:10,320
called and it's most definitely

481
00:19:10,320 --> 00:19:13,280
vulnerable to code

482
00:19:14,900 --> 00:19:18,000
and lastly another place we found design

483
00:19:18,000 --> 00:19:20,340
vulnerability in Razer chroma standard

484
00:19:20,340 --> 00:19:23,100
metric set custom frame is for your

485
00:19:23,100 --> 00:19:26,160
mouse to change the colors of your mouse

486
00:19:26,160 --> 00:19:28,559
so the message here is

487
00:19:28,559 --> 00:19:30,059
don't connect

488
00:19:30,059 --> 00:19:33,419
things to your computer with cool colors

489
00:19:33,419 --> 00:19:35,220
I don't know

490
00:19:35,220 --> 00:19:37,620
now let's see a demo show in case that

491
00:19:37,620 --> 00:19:39,660
so the first thing we do as we seen

492
00:19:39,660 --> 00:19:43,620
earlier is running LSU USB

493
00:19:43,620 --> 00:19:47,580
yeah papa LS USB

494
00:19:47,580 --> 00:19:50,160
and we can see here that we have the

495
00:19:50,160 --> 00:19:53,039
vendor ID and the product ID of Razer

496
00:19:53,039 --> 00:19:55,500
let's run LS mode to see if it's indeed

497
00:19:55,500 --> 00:19:58,640
loaded in memory

498
00:19:59,640 --> 00:20:01,440
we can see the we have the Eraser

499
00:20:01,440 --> 00:20:04,980
accessory here now let's present our

500
00:20:04,980 --> 00:20:07,020
payload

501
00:20:07,020 --> 00:20:09,059
it's a very simple preload we can see

502
00:20:09,059 --> 00:20:12,179
here that we must have the vendor ID the

503
00:20:12,179 --> 00:20:14,760
product ID the target function that we

504
00:20:14,760 --> 00:20:16,799
send the payload into is Matrix custom

505
00:20:16,799 --> 00:20:19,500
frame which is responsible to like this

506
00:20:19,500 --> 00:20:22,679
nice thing we can see our buffer is

507
00:20:22,679 --> 00:20:25,860
longer than 80 bytes and hopefully

508
00:20:25,860 --> 00:20:28,020
if everything works we will crush the

509
00:20:28,020 --> 00:20:31,620
kernel so let's try the moment of truth

510
00:20:31,620 --> 00:20:35,280
no let's see what happened I know I know

511
00:20:35,280 --> 00:20:37,580
I know

512
00:20:47,419 --> 00:20:51,679
yeah one sec please

513
00:20:51,720 --> 00:20:55,080
every time we reboot the machine we need

514
00:20:55,080 --> 00:20:58,440
to change the number of the device and

515
00:20:58,440 --> 00:21:01,380
now hopefully anything will work yeah

516
00:21:01,380 --> 00:21:04,919
okay and we crush the kernel and we are

517
00:21:04,919 --> 00:21:07,600
very happy about that

518
00:21:07,600 --> 00:21:14,179
[Applause]

519
00:21:15,000 --> 00:21:17,220
all right so uh during the exploit

520
00:21:17,220 --> 00:21:19,620
development with the Carter a newly

521
00:21:19,620 --> 00:21:21,539
added feature into the Linux kernel

522
00:21:21,539 --> 00:21:23,760
which was a part of fortify Source

523
00:21:23,760 --> 00:21:25,200
mitigation

524
00:21:25,200 --> 00:21:28,020
fortify cells basically aims to detect

525
00:21:28,020 --> 00:21:31,080
buffer overflow in compilation time and

526
00:21:31,080 --> 00:21:33,539
to mitigate them in runtime an example

527
00:21:33,539 --> 00:21:35,460
of frontal investigation could be when

528
00:21:35,460 --> 00:21:37,440
using a mem copy operation with a

529
00:21:37,440 --> 00:21:39,480
dynamic size

530
00:21:39,480 --> 00:21:42,179
the 45 Source originally came from

531
00:21:42,179 --> 00:21:44,940
jlipsy but got introduced into the Linux

532
00:21:44,940 --> 00:21:48,360
kernel into multiple steps in yes which

533
00:21:48,360 --> 00:21:50,340
will call them mods which introduce two

534
00:21:50,340 --> 00:21:52,679
mods which we'll call them Mod 0 and mod

535
00:21:52,679 --> 00:21:54,000
1.

536
00:21:54,000 --> 00:21:56,940
mode 0 aims to detect buffer overflow

537
00:21:56,940 --> 00:22:00,419
over an entire struct and mode 1 M to

538
00:22:00,419 --> 00:22:03,000
detect buffer overflows even in specific

539
00:22:03,000 --> 00:22:05,340
members on a struct let's have an

540
00:22:05,340 --> 00:22:06,720
example

541
00:22:06,720 --> 00:22:09,000
let's assume that we have this object

542
00:22:09,000 --> 00:22:11,880
struct which has three members arguan

543
00:22:11,880 --> 00:22:14,340
which is in size of two bytes an array

544
00:22:14,340 --> 00:22:16,380
in the size of six bytes and another

545
00:22:16,380 --> 00:22:18,840
member called the arc2 in a size of four

546
00:22:18,840 --> 00:22:21,419
bytes followed by a memco app operation

547
00:22:21,419 --> 00:22:23,580
on the Arrow buffer

548
00:22:23,580 --> 00:22:25,919
if we compile our kernel model with

549
00:22:25,919 --> 00:22:29,100
fortify Source enabled in mod 0 we can

550
00:22:29,100 --> 00:22:31,980
indeed still overflow our buffer thus

551
00:22:31,980 --> 00:22:35,460
overriding the data stored in arc2 but

552
00:22:35,460 --> 00:22:38,460
if we run in 45 source with Mod 1 we

553
00:22:38,460 --> 00:22:41,580
cannot overflow The Arc too thus much

554
00:22:41,580 --> 00:22:44,059
safer

555
00:22:44,159 --> 00:22:47,460
so let's see the example in our code

556
00:22:47,460 --> 00:22:49,200
um I'm showing the disassemble code

557
00:22:49,200 --> 00:22:51,659
because again this mitigation is

558
00:22:51,659 --> 00:22:54,840
inserted in compilation time this is our

559
00:22:54,840 --> 00:22:57,419
vulnerable main copy operation without

560
00:22:57,419 --> 00:23:00,299
45 Source enabled as you can see there's

561
00:23:00,299 --> 00:23:03,480
no any validation on row length thus we

562
00:23:03,480 --> 00:23:07,140
can easily as you saw Crush but if we

563
00:23:07,140 --> 00:23:10,080
compile the kernel module with 45 Source

564
00:23:10,080 --> 00:23:12,299
enabled we can see that a check was

565
00:23:12,299 --> 00:23:14,700
added that checking if indeed our row

566
00:23:14,700 --> 00:23:17,100
length is bigger than the allowed copy

567
00:23:17,100 --> 00:23:19,679
size into the buffer which here will be

568
00:23:19,679 --> 00:23:24,240
0x for D and if indeed the size will be

569
00:23:24,240 --> 00:23:26,460
bigger than the value we will call 45

570
00:23:26,460 --> 00:23:29,460
Panic which will crash more safely the

571
00:23:29,460 --> 00:23:30,360
driver

572
00:23:30,360 --> 00:23:33,419
just have a note okay let's see the 45

573
00:23:33,419 --> 00:23:34,679
Source history

574
00:23:34,679 --> 00:23:38,400
so fortify source mitigations and first

575
00:23:38,400 --> 00:23:40,679
introduced in the Linux kernel in kernel

576
00:23:40,679 --> 00:23:44,340
version 4 is 4.13 we're mode zero again

577
00:23:44,340 --> 00:23:46,740
for just checking an entire extract got

578
00:23:46,740 --> 00:23:49,559
introduced for both Ester copy and mem

579
00:23:49,559 --> 00:23:51,539
copy family of function

580
00:23:51,539 --> 00:23:55,320
later on on kernel version 5.11 mod 1

581
00:23:55,320 --> 00:23:57,659
got introduced for Str copy family

582
00:23:57,659 --> 00:24:00,600
function but still Mod 0 was turned on

583
00:24:00,600 --> 00:24:03,480
for mem copy of volume function very

584
00:24:03,480 --> 00:24:06,840
recently in kernel version 5.18 mod 1

585
00:24:06,840 --> 00:24:09,419
was turned on for both of them but still

586
00:24:09,419 --> 00:24:12,000
the mem copy only had the compile time

587
00:24:12,000 --> 00:24:14,340
mitigation so the runtime mitigation was

588
00:24:14,340 --> 00:24:16,559
similarly enabled and very like last

589
00:24:16,559 --> 00:24:19,740
week the random mitigation for mod 1 for

590
00:24:19,740 --> 00:24:22,200
mem copy got introduced

591
00:24:22,200 --> 00:24:24,600
again this mitigation only exists

592
00:24:24,600 --> 00:24:26,760
currently in the Linux but again for

593
00:24:26,760 --> 00:24:28,280
older version that you see here

594
00:24:28,280 --> 00:24:30,720
exploiting buffer overflows in the

595
00:24:30,720 --> 00:24:33,539
kernel is can still be exploited into

596
00:24:33,539 --> 00:24:37,400
everything Beyond denial of service

597
00:24:38,159 --> 00:24:39,900
all right after finding the

598
00:24:39,900 --> 00:24:41,940
vulnerabilities we reported them to the

599
00:24:41,940 --> 00:24:44,400
open source project with a fixing period

600
00:24:44,400 --> 00:24:45,960
which was merged and released on the

601
00:24:45,960 --> 00:24:48,539
same day multiple cves were assigned to

602
00:24:48,539 --> 00:24:50,159
different abilities and we have couple

603
00:24:50,159 --> 00:24:52,500
more under disclosure and a blog post

604
00:24:52,500 --> 00:24:55,260
about this topic that goes more deeply

605
00:24:55,260 --> 00:24:57,240
into the vulnerabilities and the 45

606
00:24:57,240 --> 00:25:01,320
cells mitigation just published today so

607
00:25:01,320 --> 00:25:03,600
I go check it out in saber rock labs

608
00:25:03,600 --> 00:25:06,360
site

609
00:25:06,360 --> 00:25:09,360
you may ask yourself what's next so last

610
00:25:09,360 --> 00:25:11,760
year we've covered windows DC recovering

611
00:25:11,760 --> 00:25:14,460
Linux and maybe next year we'll cover a

612
00:25:14,460 --> 00:25:16,919
more upper-leash operating system or

613
00:25:16,919 --> 00:25:20,760
more pinkish we don't know yet

614
00:25:20,760 --> 00:25:23,539
thank you

615
00:25:30,000 --> 00:25:33,179
feel free to ask any questions

616
00:25:33,179 --> 00:25:35,779
please

617
00:25:37,799 --> 00:25:40,279
sorry

618
00:25:43,620 --> 00:25:45,600
how does it interact with our

619
00:25:45,600 --> 00:25:47,220
vulnerability well the kernel model is

620
00:25:47,220 --> 00:25:48,299
loaded

621
00:25:48,299 --> 00:25:51,600
you have the open functions that you can

622
00:25:51,600 --> 00:25:53,940
send actually the payload into that

623
00:25:53,940 --> 00:25:56,039
change the color of the mouthful for

624
00:25:56,039 --> 00:26:00,000
instance or the keyboard and that's it

625
00:26:00,000 --> 00:26:03,320
it's like calling a function

626
00:26:04,320 --> 00:26:08,299
any more questions from the audience

627
00:26:10,320 --> 00:26:13,320
okay then thank you very much for the

628
00:26:13,320 --> 00:26:14,630
presentation thank you

629
00:26:14,630 --> 00:26:18,249
[Applause]

