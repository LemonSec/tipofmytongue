1
00:00:00,030 --> 00:00:06,899
hi everyone welcome to my talk on

2
00:00:02,550 --> 00:00:09,780
machine learning and code review so my

3
00:00:06,899 --> 00:00:12,599
name is philip before starting on a

4
00:00:09,780 --> 00:00:14,639
subject who am i I'm a sick researcher

5
00:00:12,599 --> 00:00:17,640
for a gold seeker it's a security

6
00:00:14,639 --> 00:00:20,820
company based in Montreal recently

7
00:00:17,640 --> 00:00:23,850
emerged acquisition when I call a gun

8
00:00:20,820 --> 00:00:25,849
secure country tag what do I do for the

9
00:00:23,850 --> 00:00:30,599
research team I'm mainly focusing on

10
00:00:25,849 --> 00:00:34,860
finding new VLT class developing to some

11
00:00:30,599 --> 00:00:37,320
to our open source so because I like I'm

12
00:00:34,860 --> 00:00:39,600
I used to be a developer and I rely at

13
00:00:37,320 --> 00:00:41,670
sec I've sought to develop as that

14
00:00:39,600 --> 00:00:44,850
second Isis to that I'm gonna present

15
00:00:41,670 --> 00:00:47,460
also in this talk so one of them is fine

16
00:00:44,850 --> 00:00:50,100
CPD bugs it's an extension for spot bugs

17
00:00:47,460 --> 00:00:53,309
and it's focused it's adding a lot of

18
00:00:50,100 --> 00:00:56,670
rule for security to this project that

19
00:00:53,309 --> 00:00:59,218
is called spot bugs so this will cover

20
00:00:56,670 --> 00:01:02,609
any project that is Java related Gutman

21
00:00:59,219 --> 00:01:04,650
groovy Scallon there's another project

22
00:01:02,609 --> 00:01:08,040
that I've started it's called a secret

23
00:01:04,650 --> 00:01:10,290
econ scam this won't be the mentioned in

24
00:01:08,040 --> 00:01:13,590
the talk but it's covering a mostly

25
00:01:10,290 --> 00:01:16,560
vb.net and c-sharp and because I've done

26
00:01:13,590 --> 00:01:18,930
a pen test in the past I've come to

27
00:01:16,560 --> 00:01:22,409
develop multiple burp extensions so

28
00:01:18,930 --> 00:01:25,320
maybe you have used one I have the rope

29
00:01:22,409 --> 00:01:27,780
I am NOT an expert in machinery but in

30
00:01:25,320 --> 00:01:30,298
the past year I've started using it for

31
00:01:27,780 --> 00:01:32,820
our project so that's what I'm going to

32
00:01:30,299 --> 00:01:35,250
present that today so in the first

33
00:01:32,820 --> 00:01:37,679
section I'm gonna go through some basic

34
00:01:35,250 --> 00:01:40,650
as the second is this concept this is

35
00:01:37,680 --> 00:01:43,920
gonna be a mostly theory I managed to

36
00:01:40,650 --> 00:01:46,020
slide in a demo in this part but this is

37
00:01:43,920 --> 00:01:49,079
because I really need to introduce some

38
00:01:46,020 --> 00:01:51,030
concept that will be used when I'm gonna

39
00:01:49,079 --> 00:01:55,020
present the model I'm using for machine

40
00:01:51,030 --> 00:01:58,829
learning for this project I'm gonna have

41
00:01:55,020 --> 00:02:00,840
a demonstration of the final tool which

42
00:01:58,829 --> 00:02:03,149
is still experimental but I have a demo

43
00:02:00,840 --> 00:02:05,640
of this tool and I'm gonna conclude with

44
00:02:03,149 --> 00:02:08,128
a lesson learn from my first experience

45
00:02:05,640 --> 00:02:10,288
giving a real project with machine

46
00:02:08,128 --> 00:02:12,780
learning so maybe if you're starting

47
00:02:10,288 --> 00:02:14,260
your own project or you have some ID

48
00:02:12,780 --> 00:02:18,550
this is something

49
00:02:14,260 --> 00:02:22,329
two things that you could consider so

50
00:02:18,550 --> 00:02:25,150
first this is gonna be a slightly heavy

51
00:02:22,330 --> 00:02:27,730
so it's only a bit of theory but I have

52
00:02:25,150 --> 00:02:30,720
just shoe concept to introduce you to

53
00:02:27,730 --> 00:02:34,149
make sure we're all on the same line so

54
00:02:30,720 --> 00:02:37,959
the first element force in second

55
00:02:34,150 --> 00:02:41,370
insists that most semi advanced system

56
00:02:37,959 --> 00:02:43,840
is to will do is symbolic execution is

57
00:02:41,370 --> 00:02:46,239
contrary to dynamic tool we don't have

58
00:02:43,840 --> 00:02:49,450
access to a runtime leader when we

59
00:02:46,239 --> 00:02:52,630
analyze code were purely looking at a

60
00:02:49,450 --> 00:02:55,599
school so extensively yeah I have a

61
00:02:52,630 --> 00:02:58,120
pseudo code on the right and the idea

62
00:02:55,599 --> 00:03:01,660
with symbolic execution is we're gonna

63
00:02:58,120 --> 00:03:04,299
either try to resolve condition or try

64
00:03:01,660 --> 00:03:08,709
to violate state available at a specific

65
00:03:04,299 --> 00:03:12,400
moment so for example this piece of the

66
00:03:08,709 --> 00:03:15,489
code we might want to test how can we

67
00:03:12,400 --> 00:03:17,560
reach the condition where it's true so

68
00:03:15,489 --> 00:03:20,200
then we transform the condition into an

69
00:03:17,560 --> 00:03:23,859
equation and try to solve it so that's

70
00:03:20,200 --> 00:03:26,980
one use cases that our condition would

71
00:03:23,859 --> 00:03:30,819
resolve into an equation but can be

72
00:03:26,980 --> 00:03:34,328
possible so then I have a quick example

73
00:03:30,819 --> 00:03:36,970
to show you how it works so really

74
00:03:34,329 --> 00:03:39,480
simple example so I have first this

75
00:03:36,970 --> 00:03:41,620
variable that is initialized called a

76
00:03:39,480 --> 00:03:45,488
then a second variable that is

77
00:03:41,620 --> 00:03:47,230
initialized named B and now we have a

78
00:03:45,489 --> 00:03:50,739
small operation multiplication between

79
00:03:47,230 --> 00:03:53,160
two variable now C instead of having the

80
00:03:50,739 --> 00:03:57,760
actual data at runtime it's gonna

81
00:03:53,160 --> 00:04:01,599
contain input 2 x 2 so we keep only the

82
00:03:57,760 --> 00:04:02,349
symbolic form of it now in select

83
00:04:01,599 --> 00:04:04,660
execution

84
00:04:02,349 --> 00:04:07,410
every time we're gonna eat a branch or a

85
00:04:04,660 --> 00:04:10,450
condition we're gonna try to evaluate

86
00:04:07,410 --> 00:04:13,418
the different state so we're gonna copy

87
00:04:10,450 --> 00:04:16,478
each state so first we're gonna do the

88
00:04:13,419 --> 00:04:17,410
path where the condition is true so we

89
00:04:16,478 --> 00:04:19,870
have this state

90
00:04:17,410 --> 00:04:22,630
until we reach the end of the method for

91
00:04:19,870 --> 00:04:25,319
example and now we have the state at the

92
00:04:22,630 --> 00:04:28,360
end of the method of each parallel

93
00:04:25,319 --> 00:04:31,360
because there was another path if the

94
00:04:28,360 --> 00:04:36,130
condition was found where he was added

95
00:04:31,360 --> 00:04:39,280
44 now we have another state that could

96
00:04:36,130 --> 00:04:43,060
have been rich so this is the theory

97
00:04:39,280 --> 00:04:46,409
behind a symbolic execution with a quick

98
00:04:43,060 --> 00:04:49,180
example symbolic execution is

99
00:04:46,410 --> 00:04:51,069
interesting if you want to test how can

100
00:04:49,180 --> 00:04:53,680
we reach specific paths so for example

101
00:04:51,069 --> 00:04:56,949
if you're testing C++ code that of the

102
00:04:53,680 --> 00:05:02,319
bug rely on can we reach this state with

103
00:04:56,949 --> 00:05:07,240
this bound plus one or whatever when I

104
00:05:02,319 --> 00:05:07,810
retain that that will affect me in any

105
00:05:07,240 --> 00:05:09,460
language

106
00:05:07,810 --> 00:05:11,979
is we're trying to look at the state of

107
00:05:09,460 --> 00:05:14,650
variable so more than just that your

108
00:05:11,979 --> 00:05:21,130
value we're going to look for is it safe

109
00:05:14,650 --> 00:05:25,030
or unsafe or think or on think so here I

110
00:05:21,130 --> 00:05:28,599
have two code example so the two things

111
00:05:25,030 --> 00:05:32,590
we're gonna track with analysis is the

112
00:05:28,599 --> 00:05:35,469
sources so are these safe source or or

113
00:05:32,590 --> 00:05:37,270
tainted if they come from user input but

114
00:05:35,469 --> 00:05:39,969
also we're gonna track their

115
00:05:37,270 --> 00:05:42,789
transformation so as we do the exit the

116
00:05:39,969 --> 00:05:45,159
symbolic execution work on the decide

117
00:05:42,789 --> 00:05:48,039
mind change because there might be a

118
00:05:45,159 --> 00:05:49,750
validation act with a rightness there

119
00:05:48,039 --> 00:05:51,729
might be a validation with reg X that

120
00:05:49,750 --> 00:05:55,770
might be some encoding with some

121
00:05:51,729 --> 00:05:58,300
function appropriate for the context and

122
00:05:55,770 --> 00:06:01,299
we're gonna do some validation when we

123
00:05:58,300 --> 00:06:04,840
reach some sensible API that does maybe

124
00:06:01,300 --> 00:06:08,490
a SQL queries receive as input a

125
00:06:04,840 --> 00:06:10,840
template that's our sort of API and

126
00:06:08,490 --> 00:06:16,469
we're gonna check the state of the the

127
00:06:10,840 --> 00:06:20,500
sensible parameter so so the left

128
00:06:16,469 --> 00:06:22,719
pseudocode because it's a config you can

129
00:06:20,500 --> 00:06:24,780
assume that it's not something that is

130
00:06:22,719 --> 00:06:28,030
gonna be controllable from the user

131
00:06:24,780 --> 00:06:31,559
perspective so from an external attacker

132
00:06:28,030 --> 00:06:35,638
for example well an issue parameter

133
00:06:31,560 --> 00:06:35,639
likely to be manipulative

134
00:06:36,470 --> 00:06:44,850
so like the symbolic execution I have a

135
00:06:39,780 --> 00:06:48,299
quick step-by-step example of our data

136
00:06:44,850 --> 00:06:49,800
analysis work so it's going to be

137
00:06:48,300 --> 00:06:51,780
similar to the previous code we saw so

138
00:06:49,800 --> 00:06:54,300
first there's a variable that is

139
00:06:51,780 --> 00:06:58,349
initialized with user ID equal so this

140
00:06:54,300 --> 00:07:00,570
is a static string and I find security

141
00:06:58,350 --> 00:07:04,560
bugs this gonna have the state constant

142
00:07:00,570 --> 00:07:06,169
so consider to be safe then we have a

143
00:07:04,560 --> 00:07:08,550
second variable that is initialized

144
00:07:06,169 --> 00:07:11,099
that's gonna be tainted because it's a

145
00:07:08,550 --> 00:07:15,389
gnome API and get parameter we know it's

146
00:07:11,099 --> 00:07:19,139
it's my can be user input now we have

147
00:07:15,389 --> 00:07:21,840
concatenation so we have a constant and

148
00:07:19,139 --> 00:07:26,130
attaint variable that are combined this

149
00:07:21,840 --> 00:07:28,698
will result into a tank values meaning

150
00:07:26,130 --> 00:07:31,380
that once we reach this apply filter

151
00:07:28,699 --> 00:07:35,190
that I think was either a Scala or

152
00:07:31,380 --> 00:07:38,370
groovy API basically apply a filter in

153
00:07:35,190 --> 00:07:41,159
SQL now we can check the state of the

154
00:07:38,370 --> 00:07:43,010
variable C at this moment and confirm

155
00:07:41,159 --> 00:07:47,570
that it's tainted so we should report

156
00:07:43,010 --> 00:07:57,810
this bug as a potential penalties

157
00:07:47,570 --> 00:08:00,419
already a demonstration so quick

158
00:07:57,810 --> 00:08:04,680
question any people in the audience have

159
00:08:00,419 --> 00:08:08,669
already used fine speedy bugs yeah I'm

160
00:08:04,680 --> 00:08:10,759
gonna zoom in the code so anybody by

161
00:08:08,669 --> 00:08:16,859
rezerve and I've used fine skill bugs

162
00:08:10,759 --> 00:08:20,190
okay one person so so the idea why I

163
00:08:16,860 --> 00:08:24,720
decided to extend a spot bug which was

164
00:08:20,190 --> 00:08:27,599
called a fine bugs few years ago is spot

165
00:08:24,720 --> 00:08:31,289
bugs already as integration into ID so

166
00:08:27,599 --> 00:08:33,240
by developing rules with this API then I

167
00:08:31,289 --> 00:08:36,598
could've let my tenth analysis and it

168
00:08:33,240 --> 00:08:39,599
would integrate with NetBeans eclipse

169
00:08:36,599 --> 00:08:43,200
and regime but also sonarqube and other

170
00:08:39,599 --> 00:08:45,089
platforms oh yeah is that a dropper

171
00:08:43,200 --> 00:08:48,660
would have is project with code here I'm

172
00:08:45,089 --> 00:08:52,200
using a old webgoat version

173
00:08:48,660 --> 00:08:56,100
and all it has to do is Nam in assume I

174
00:08:52,200 --> 00:08:59,000
have the plug-in for fine bugs and I

175
00:08:56,100 --> 00:09:02,370
canalize all the project file this way

176
00:08:59,000 --> 00:09:04,620
I'm gonna do it slightly quickly I'm

177
00:09:02,370 --> 00:09:13,190
gonna scan a specific file just to give

178
00:09:04,620 --> 00:09:18,240
you an example so I'm just triggering

179
00:09:13,190 --> 00:09:22,250
analysis for this specific farm won't

180
00:09:18,240 --> 00:09:22,250
take long so

181
00:09:29,180 --> 00:09:36,949
okay so we can see we have three warning

182
00:09:32,030 --> 00:09:41,470
here there were multiple how to execute

183
00:09:36,950 --> 00:09:45,140
query but only three that resolve into a

184
00:09:41,470 --> 00:09:48,020
warning so for each one aim if we click

185
00:09:45,140 --> 00:09:52,040
on it we will see that in this

186
00:09:48,020 --> 00:09:54,470
integration of spot bugs will get few

187
00:09:52,040 --> 00:09:58,520
property including the category of the

188
00:09:54,470 --> 00:10:00,440
bugs and will also get a small

189
00:09:58,520 --> 00:10:03,050
description brief description of the

190
00:10:00,440 --> 00:10:06,980
risk what not to do what you should do

191
00:10:03,050 --> 00:10:12,620
so a good indicator on what the solution

192
00:10:06,980 --> 00:10:15,260
would be to resolve this denardis now

193
00:10:12,620 --> 00:10:20,510
what's interesting is that in this code

194
00:10:15,260 --> 00:10:23,170
I hope I'm moving not too fast not all

195
00:10:20,510 --> 00:10:25,700
execute query how we're flag as

196
00:10:23,170 --> 00:10:28,010
potential energy and that's important

197
00:10:25,700 --> 00:10:31,880
because you don't want to flag every car

198
00:10:28,010 --> 00:10:34,370
because the security analyst will just

199
00:10:31,880 --> 00:10:37,130
do some triage and at some point we'll

200
00:10:34,370 --> 00:10:39,260
get some fatigue and we'll miss some

201
00:10:37,130 --> 00:10:42,290
actual Grampy's all those that we can

202
00:10:39,260 --> 00:10:44,600
confirm as safe for sure we should try

203
00:10:42,290 --> 00:10:47,920
to eliminate them this way it's less

204
00:10:44,600 --> 00:10:51,110
work for the developer or CDN is so here

205
00:10:47,920 --> 00:10:54,189
the reason it didn't show trigger

206
00:10:51,110 --> 00:10:58,670
vanellope it's like i described before

207
00:10:54,190 --> 00:11:00,890
this is using a string builder and all

208
00:10:58,670 --> 00:11:03,020
the value I combined into the string

209
00:11:00,890 --> 00:11:05,270
builder or a constant value so they are

210
00:11:03,020 --> 00:11:08,810
safe because we know where they are

211
00:11:05,270 --> 00:11:13,160
coming from in this case there's no

212
00:11:08,810 --> 00:11:15,589
reason to to flag this so even if

213
00:11:13,160 --> 00:11:19,490
there's some branch we can identify that

214
00:11:15,590 --> 00:11:23,270
at any point in this method the the

215
00:11:19,490 --> 00:11:27,620
string builder will use safe source the

216
00:11:23,270 --> 00:11:29,960
second example if you look quickly you

217
00:11:27,620 --> 00:11:33,140
might say it's a renewable but here

218
00:11:29,960 --> 00:11:34,970
there is a small transformation because

219
00:11:33,140 --> 00:11:37,370
it's an end

220
00:11:34,970 --> 00:11:39,710
there's no injection point that will be

221
00:11:37,370 --> 00:11:41,400
useful for an attacker it will only be

222
00:11:39,710 --> 00:11:44,670
able to specify a number

223
00:11:41,400 --> 00:11:49,790
so you won't be able to do a union or

224
00:11:44,670 --> 00:11:52,199
any malicious injection with that so

225
00:11:49,790 --> 00:11:54,420
here the cool example are pretty

226
00:11:52,200 --> 00:11:56,940
straightforward but it's doing complete

227
00:11:54,420 --> 00:11:58,979
symbolic execution on all the methods so

228
00:11:56,940 --> 00:12:02,150
even if you have assignment it will

229
00:11:58,980 --> 00:12:05,490
track down the variable along the way

230
00:12:02,150 --> 00:12:08,520
here we have another cases that is

231
00:12:05,490 --> 00:12:12,570
supported is here we're having an input

232
00:12:08,520 --> 00:12:14,279
that will eventually reach the SQL

233
00:12:12,570 --> 00:12:18,060
queries but here we have a

234
00:12:14,279 --> 00:12:21,230
transformation it's not good code I was

235
00:12:18,060 --> 00:12:24,119
just trying to give example along SQL

236
00:12:21,230 --> 00:12:27,750
injection example obviously you should

237
00:12:24,120 --> 00:12:31,740
prefer a paper statement over manual

238
00:12:27,750 --> 00:12:33,810
encoding but here were using si P that

239
00:12:31,740 --> 00:12:38,250
will encode the parameter specifically

240
00:12:33,810 --> 00:12:40,709
for SQL so what finally bug will do in

241
00:12:38,250 --> 00:12:42,450
this case it won't mark it as safe but

242
00:12:40,710 --> 00:12:45,450
it will add a tag that is safe

243
00:12:42,450 --> 00:12:48,600
specifically for SQL it's mean you

244
00:12:45,450 --> 00:12:51,630
cannot use an encoder SQL encoder for

245
00:12:48,600 --> 00:12:55,140
example to mitigate against XSS or vice

246
00:12:51,630 --> 00:12:59,600
versa so those are all three cases that

247
00:12:55,140 --> 00:13:01,680
are managed but there are other cases

248
00:12:59,600 --> 00:13:07,400
just one quickly

249
00:13:01,680 --> 00:13:10,890
that won't be a mitigate here we have

250
00:13:07,400 --> 00:13:14,339
web session which is a custom class from

251
00:13:10,890 --> 00:13:17,279
a web goat it's you calling get user

252
00:13:14,339 --> 00:13:19,890
name and the return value is used in the

253
00:13:17,279 --> 00:13:22,290
query because finds feed bugs doesn't

254
00:13:19,890 --> 00:13:24,630
know about this API doesn't know for

255
00:13:22,290 --> 00:13:27,420
sure if it's a safe value and if it can

256
00:13:24,630 --> 00:13:31,740
be trusted so for this reason we're

257
00:13:27,420 --> 00:13:34,410
gonna write an error so this was to give

258
00:13:31,740 --> 00:13:36,900
you a quick overview about the tool I'm

259
00:13:34,410 --> 00:13:40,050
talking since the beginning so you have

260
00:13:36,900 --> 00:13:42,420
a better idea and also our tetanus work

261
00:13:40,050 --> 00:13:47,270
and what type of cases we try to

262
00:13:42,420 --> 00:13:50,370
eliminate there are still many obstacle

263
00:13:47,270 --> 00:13:52,020
right now Frankie bugs does data

264
00:13:50,370 --> 00:13:54,839
analysis

265
00:13:52,020 --> 00:13:57,810
at metal level so it won't look by

266
00:13:54,839 --> 00:14:00,660
default at method calling other metals

267
00:13:57,810 --> 00:14:03,079
so we won't backtrack for a variable

268
00:14:00,660 --> 00:14:10,069
tracking across multiple method and

269
00:14:03,080 --> 00:14:12,930
there are many reason why we cannot why

270
00:14:10,070 --> 00:14:17,550
backtracking I against multiple method

271
00:14:12,930 --> 00:14:19,620
will miss a few things first the one of

272
00:14:17,550 --> 00:14:22,649
the stucco to static code analysis is

273
00:14:19,620 --> 00:14:24,540
reflection which frameworks there's ton

274
00:14:22,649 --> 00:14:26,399
of value that will be prefilled

275
00:14:24,540 --> 00:14:30,329
automatically either method call or

276
00:14:26,399 --> 00:14:32,880
field just by design of the framework so

277
00:14:30,330 --> 00:14:34,470
those are ordered to see from acetic

278
00:14:32,880 --> 00:14:36,180
analysis perspective because the call is

279
00:14:34,470 --> 00:14:40,760
not in the code it's indirectly

280
00:14:36,180 --> 00:14:43,199
at runtime the method will be defined so

281
00:14:40,760 --> 00:14:45,209
dependency injection really similar so

282
00:14:43,200 --> 00:14:46,529
the idea is you have your gonna have

283
00:14:45,209 --> 00:14:49,079
multiple services in your web

284
00:14:46,529 --> 00:14:50,939
application and every of your services

285
00:14:49,080 --> 00:14:53,279
will expose an interface instead of the

286
00:14:50,940 --> 00:14:55,649
class directly so anything related to

287
00:14:53,279 --> 00:14:58,950
inheritance it's more level of

288
00:14:55,649 --> 00:15:02,130
indirection a second order of the knob T

289
00:14:58,950 --> 00:15:04,770
this will implies a database or data

290
00:15:02,130 --> 00:15:07,470
storage think for example if you're

291
00:15:04,770 --> 00:15:10,380
having a ecommerce website when you

292
00:15:07,470 --> 00:15:13,410
click the submit order button at this

293
00:15:10,380 --> 00:15:15,870
moment not everything will be done so it

294
00:15:13,410 --> 00:15:18,149
would more like looks like he'd be a

295
00:15:15,870 --> 00:15:20,730
push to a queue then there will be some

296
00:15:18,149 --> 00:15:23,550
payment verification then some other

297
00:15:20,730 --> 00:15:26,250
services will do Amy Parham processing

298
00:15:23,550 --> 00:15:29,459
then that may be a the stock will be a

299
00:15:26,250 --> 00:15:32,160
verify etc so not everything is done in

300
00:15:29,459 --> 00:15:34,050
line because the data is stores on in

301
00:15:32,160 --> 00:15:37,290
for example in the database and then

302
00:15:34,050 --> 00:15:39,930
read after it's order for the tool to

303
00:15:37,290 --> 00:15:44,550
know if value read from database is

304
00:15:39,930 --> 00:15:46,739
actually user input and the last two are

305
00:15:44,550 --> 00:15:50,750
more related to design so these are not

306
00:15:46,740 --> 00:15:53,430
bad practices but these are effect that

307
00:15:50,750 --> 00:15:56,250
will have an effect on assets equal

308
00:15:53,430 --> 00:15:58,680
access or encapsulation anytime you wrap

309
00:15:56,250 --> 00:16:02,910
some API because there are commonly use

310
00:15:58,680 --> 00:16:05,400
in your application the static analysis

311
00:16:02,910 --> 00:16:05,699
tool will have our time and find what

312
00:16:05,400 --> 00:16:08,669
its

313
00:16:05,699 --> 00:16:11,608
actually being used just by because

314
00:16:08,669 --> 00:16:13,529
you're rapping at the API and anytime

315
00:16:11,609 --> 00:16:16,109
you have custom framework so for the

316
00:16:13,529 --> 00:16:20,429
example of webgoat where they wrap all

317
00:16:16,109 --> 00:16:24,239
the HTTP part in web session classes

318
00:16:20,429 --> 00:16:26,910
it's Rita class for the second sis tool

319
00:16:24,239 --> 00:16:30,179
it's all mystery what those API are

320
00:16:26,910 --> 00:16:31,829
actually doing so but this doesn't mean

321
00:16:30,179 --> 00:16:34,769
that these are bad practices these are

322
00:16:31,829 --> 00:16:37,049
actually good practices for other thing

323
00:16:34,769 --> 00:16:39,929
than security so I'm not saying don't

324
00:16:37,049 --> 00:16:44,309
use framework or don't use dependency

325
00:16:39,929 --> 00:16:48,269
injection but there's two main

326
00:16:44,309 --> 00:16:51,238
challenges that result into trying

327
00:16:48,269 --> 00:16:56,609
machine on in I would say the two main

328
00:16:51,239 --> 00:17:00,569
were I know they might want seem to have

329
00:16:56,609 --> 00:17:02,339
a link but in the end boat will motivate

330
00:17:00,569 --> 00:17:06,289
the machine learning part I'm going to

331
00:17:02,339 --> 00:17:08,519
talk about so because we're not doing

332
00:17:06,289 --> 00:17:10,648
interprocedural data frozen

333
00:17:08,519 --> 00:17:13,230
interprocedural is just return to say

334
00:17:10,648 --> 00:17:16,888
we're doing that flow across multiple

335
00:17:13,230 --> 00:17:22,039
methods so this in general explored the

336
00:17:16,888 --> 00:17:24,719
graph and the call to check this as many

337
00:17:22,039 --> 00:17:27,419
this as some caveats but some

338
00:17:24,720 --> 00:17:29,970
interesting advantage so one thing I

339
00:17:27,419 --> 00:17:33,750
always add in mind is I don't want to

340
00:17:29,970 --> 00:17:36,120
eliminate a vanity because I'm seeing

341
00:17:33,750 --> 00:17:39,179
one pad and one case there's a safe

342
00:17:36,120 --> 00:17:41,100
source because I'm not 100% sure that I

343
00:17:39,179 --> 00:17:43,740
have all the code often you're analyzing

344
00:17:41,100 --> 00:17:45,959
just a small component so you don't know

345
00:17:43,740 --> 00:17:48,570
the big picture sometimes you'll miss

346
00:17:45,960 --> 00:17:50,010
all the framework work so if there's

347
00:17:48,570 --> 00:17:52,168
some dependency injection that you don't

348
00:17:50,010 --> 00:17:54,480
see or some reflection that you don't

349
00:17:52,169 --> 00:17:56,730
see you might not see all the path so

350
00:17:54,480 --> 00:18:01,260
it's really hard to rely on the on this

351
00:17:56,730 --> 00:18:02,820
to remove head cases but it would be

352
00:18:01,260 --> 00:18:05,340
interesting that if we can find a path

353
00:18:02,820 --> 00:18:08,279
where it's exploitable like we can see

354
00:18:05,340 --> 00:18:11,459
that a tinted source can reach a valid

355
00:18:08,279 --> 00:18:13,519
thing then would be interesting to put

356
00:18:11,460 --> 00:18:16,649
it in priority to the developer to see

357
00:18:13,519 --> 00:18:18,419
this case we're pretty sure you should

358
00:18:16,649 --> 00:18:20,350
fix it because we have one case where

359
00:18:18,419 --> 00:18:23,000
it's exploitable

360
00:18:20,350 --> 00:18:24,439
so we're not necessarily eliminating

361
00:18:23,000 --> 00:18:27,740
fast cause did that's why I didn't put

362
00:18:24,440 --> 00:18:31,610
the effort into it in the early years of

363
00:18:27,740 --> 00:18:34,370
science for the bodies also preparatory

364
00:18:31,610 --> 00:18:36,939
have from work and it's really it's an

365
00:18:34,370 --> 00:18:40,129
interesting problem because we cannot

366
00:18:36,940 --> 00:18:43,130
predict our company would name their

367
00:18:40,130 --> 00:18:47,180
internal classes but at the same time is

368
00:18:43,130 --> 00:18:48,890
record enough metadata not necessarily

369
00:18:47,180 --> 00:18:50,510
on the cloud or whatever but if we

370
00:18:48,890 --> 00:18:54,110
record them

371
00:18:50,510 --> 00:18:58,010
we could see potentially patterns if a

372
00:18:54,110 --> 00:18:59,919
specific source is reaching an API and

373
00:18:58,010 --> 00:19:04,400
it's always marked as false positive

374
00:18:59,920 --> 00:19:06,940
maybe this API is something safe maybe a

375
00:19:04,400 --> 00:19:12,050
configuration class or something local

376
00:19:06,940 --> 00:19:14,270
so that's the idea so the perspective

377
00:19:12,050 --> 00:19:16,550
I'm trying to do with machine learning

378
00:19:14,270 --> 00:19:19,550
is trying more to prioritize rather than

379
00:19:16,550 --> 00:19:22,010
eliminate cases because in security

380
00:19:19,550 --> 00:19:24,770
compared to maybe other field that would

381
00:19:22,010 --> 00:19:27,050
use that second axis in security one or

382
00:19:24,770 --> 00:19:28,520
two venality might be critical and make

383
00:19:27,050 --> 00:19:33,050
a big difference so we don't want to

384
00:19:28,520 --> 00:19:35,750
miss any so the prioritization will help

385
00:19:33,050 --> 00:19:39,050
on the efficiency without eliminating

386
00:19:35,750 --> 00:19:41,570
and IDing as potential beneficial that's

387
00:19:39,050 --> 00:19:42,730
the mindset I had when I started the

388
00:19:41,570 --> 00:19:47,000
project

389
00:19:42,730 --> 00:19:50,180
so why machine learning I I had always

390
00:19:47,000 --> 00:19:52,790
thought those two a idea in mind trying

391
00:19:50,180 --> 00:19:55,610
to do prioritization and I listened to a

392
00:19:52,790 --> 00:20:00,340
few machine learning talks and I really

393
00:19:55,610 --> 00:20:03,199
saw it seems to connect with my needs so

394
00:20:00,340 --> 00:20:05,629
the general definition of machine

395
00:20:03,200 --> 00:20:09,980
learning is we're gonna use that's

396
00:20:05,630 --> 00:20:13,100
called technique - based on the data

397
00:20:09,980 --> 00:20:16,130
produce algorithm so without explicitly

398
00:20:13,100 --> 00:20:18,800
program if-else condition with specific

399
00:20:16,130 --> 00:20:21,140
value those algorithm would ever

400
00:20:18,800 --> 00:20:24,830
depending on the data were inputting to

401
00:20:21,140 --> 00:20:26,540
the machine learning algorithm so that's

402
00:20:24,830 --> 00:20:29,240
interesting because I can be really

403
00:20:26,540 --> 00:20:33,100
creative at extracting data that might

404
00:20:29,240 --> 00:20:35,980
describe the API and the property

405
00:20:33,100 --> 00:20:37,929
but it won't be 100% reliable but

406
00:20:35,980 --> 00:20:40,090
because machine learning is flexible and

407
00:20:37,930 --> 00:20:45,040
can adapt to the data were giving as

408
00:20:40,090 --> 00:20:47,590
input this could work so there are two

409
00:20:45,040 --> 00:20:50,370
main class of machine learning

410
00:20:47,590 --> 00:20:54,340
there are supervised and unsupervised

411
00:20:50,370 --> 00:20:56,500
supervised rely on human classification

412
00:20:54,340 --> 00:20:58,389
so you need to have a portion of the

413
00:20:56,500 --> 00:21:02,290
data set that was previously classified

414
00:20:58,390 --> 00:21:04,680
by Yoona unsupervised it's actually a

415
00:21:02,290 --> 00:21:10,060
different objective when we're trying to

416
00:21:04,680 --> 00:21:12,640
cluster data together so we don't need a

417
00:21:10,060 --> 00:21:14,379
human that would classify a specific

418
00:21:12,640 --> 00:21:17,820
entry instead it will try to group them

419
00:21:14,380 --> 00:21:20,650
for example doing image recognition to

420
00:21:17,820 --> 00:21:23,889
find similar images so we're not trying

421
00:21:20,650 --> 00:21:25,330
to find specific things in in the

422
00:21:23,890 --> 00:21:31,840
picture but we're trying to find similar

423
00:21:25,330 --> 00:21:33,460
one I put an arrow because obviously my

424
00:21:31,840 --> 00:21:37,139
use case is supervised classification

425
00:21:33,460 --> 00:21:40,480
because I want to classify few bugs and

426
00:21:37,140 --> 00:21:45,130
get the resulting the remaining bugs

427
00:21:40,480 --> 00:21:48,190
prioritized and evolve over time so we

428
00:21:45,130 --> 00:21:51,010
can do a supervised classification if we

429
00:21:48,190 --> 00:21:54,220
need to target specific classes so in

430
00:21:51,010 --> 00:21:57,760
the case of my project it is it a false

431
00:21:54,220 --> 00:21:59,560
positive or an actual / naughty there's

432
00:21:57,760 --> 00:22:02,530
also another class that I won't touch

433
00:21:59,560 --> 00:22:05,200
here it's a supervision supervised

434
00:22:02,530 --> 00:22:08,320
regression and this is if we want to

435
00:22:05,200 --> 00:22:11,290
calculate a continuous value so estimate

436
00:22:08,320 --> 00:22:13,689
promising process of alzene for example

437
00:22:11,290 --> 00:22:18,090
time of recovery of an incident anything

438
00:22:13,690 --> 00:22:18,090
that has not a fixed number of classes

439
00:22:18,750 --> 00:22:24,280
so when I say machine learning is

440
00:22:21,670 --> 00:22:27,490
producing algorithm there are multiple

441
00:22:24,280 --> 00:22:30,340
type of algorithm that can produce naive

442
00:22:27,490 --> 00:22:34,000
Bayes series of conditions of decision

443
00:22:30,340 --> 00:22:36,850
tree I have an example won't be too

444
00:22:34,000 --> 00:22:38,860
small to read but basically when we're

445
00:22:36,850 --> 00:22:41,459
gonna have new data is unclassified

446
00:22:38,860 --> 00:22:44,860
we'll start from the top of the tree and

447
00:22:41,460 --> 00:22:45,850
based on each condition we'll go left or

448
00:22:44,860 --> 00:22:47,830
right

449
00:22:45,850 --> 00:22:50,530
and at the end we'll get our value for

450
00:22:47,830 --> 00:22:53,830
the prediction so that's the type of

451
00:22:50,530 --> 00:22:56,710
algorithm is producing a neural network

452
00:22:53,830 --> 00:22:58,270
is another one and the idea is that

453
00:22:56,710 --> 00:23:01,450
those algorithm are not explicitly

454
00:22:58,270 --> 00:23:03,760
programmed so it will all be based on

455
00:23:01,450 --> 00:23:09,190
the data the training set that we're

456
00:23:03,760 --> 00:23:11,860
gonna give to those librarian before

457
00:23:09,190 --> 00:23:14,169
starting to use machine learning the

458
00:23:11,860 --> 00:23:16,899
first part that you should do is just

459
00:23:14,169 --> 00:23:18,909
visualize your data because sometimes

460
00:23:16,900 --> 00:23:20,500
you might not need the machine learning

461
00:23:18,909 --> 00:23:26,100
or you might not need something that

462
00:23:20,500 --> 00:23:29,470
advanced so when I load this is a

463
00:23:26,100 --> 00:23:33,189
juliette test suit so soon so these are

464
00:23:29,470 --> 00:23:36,010
test cases do not see but that are made

465
00:23:33,190 --> 00:23:39,909
on purpose it's produced by the NIST so

466
00:23:36,010 --> 00:23:43,150
there are about 30,000 even opti that

467
00:23:39,909 --> 00:23:45,940
are generated by its pod bugs and those

468
00:23:43,150 --> 00:23:47,799
are all the reported realities those on

469
00:23:45,940 --> 00:23:51,309
the left are actual realities those on

470
00:23:47,799 --> 00:23:55,500
the left right are all false positives

471
00:23:51,309 --> 00:23:58,870
so just by looking at the sample graph

472
00:23:55,500 --> 00:24:01,809
we can see that for some realities there

473
00:23:58,870 --> 00:24:03,370
are actually no false positives so we're

474
00:24:01,809 --> 00:24:06,190
good when we're going to try to enrich

475
00:24:03,370 --> 00:24:09,158
our model and add attribute we should

476
00:24:06,190 --> 00:24:11,380
not focus on those because those at the

477
00:24:09,159 --> 00:24:13,510
moment for for at for the specific

478
00:24:11,380 --> 00:24:19,179
attitude there are no false positives oh

479
00:24:13,510 --> 00:24:21,730
and what are they I realize is that most

480
00:24:19,179 --> 00:24:23,640
of the penalties that add false

481
00:24:21,730 --> 00:24:27,070
positives in this test shoot were

482
00:24:23,640 --> 00:24:33,929
injection related so think of API like

483
00:24:27,070 --> 00:24:38,230
SQL injection expat stuff like that so

484
00:24:33,929 --> 00:24:40,059
the the value you'll get out of machine

485
00:24:38,230 --> 00:24:41,710
learning will be as good as the

486
00:24:40,059 --> 00:24:44,289
attribute that you give as input so

487
00:24:41,710 --> 00:24:47,620
garbage in garbage out if you just give

488
00:24:44,289 --> 00:24:49,780
primitive data that even a human with

489
00:24:47,620 --> 00:24:52,090
infinite time wouldn't be able to cover

490
00:24:49,780 --> 00:24:55,720
it in anything it won't work

491
00:24:52,090 --> 00:24:58,240
so what I thought about is we're going

492
00:24:55,720 --> 00:24:59,500
to look for attribute that code reviewer

493
00:24:58,240 --> 00:25:01,240
actually look in

494
00:24:59,500 --> 00:25:06,010
the code when they do the triage

495
00:25:01,240 --> 00:25:07,570
themselves so if we had a SQL query what

496
00:25:06,010 --> 00:25:10,870
would be the first thing that a

497
00:25:07,570 --> 00:25:13,389
developer or a sequin is do is it'll

498
00:25:10,870 --> 00:25:15,310
search for any data flow reaching this

499
00:25:13,390 --> 00:25:16,720
point and look back

500
00:25:15,310 --> 00:25:21,399
are there any variable that are

501
00:25:16,720 --> 00:25:22,870
attempted from this path but so in an

502
00:25:21,400 --> 00:25:26,260
idea it would look like this

503
00:25:22,870 --> 00:25:28,860
so the idea will generate all the paths

504
00:25:26,260 --> 00:25:32,020
to the specific variable until it reach

505
00:25:28,860 --> 00:25:36,070
here we can see that account number is

506
00:25:32,020 --> 00:25:38,260
the dynamic value and then from this it

507
00:25:36,070 --> 00:25:41,379
could be a method call or parameter

508
00:25:38,260 --> 00:25:43,629
whatever then the developer would take a

509
00:25:41,380 --> 00:25:45,940
decision based on this but what is in

510
00:25:43,630 --> 00:25:48,610
what's the context so the developer will

511
00:25:45,940 --> 00:25:53,080
be able to describe what's the business

512
00:25:48,610 --> 00:25:54,879
behind this specific API but here we're

513
00:25:53,080 --> 00:25:58,870
gonna be able maybe to record the API

514
00:25:54,880 --> 00:26:00,880
for example so I won't go through all

515
00:25:58,870 --> 00:26:03,280
the attribute that we ask add to the

516
00:26:00,880 --> 00:26:06,340
model but I'll go to the main one so the

517
00:26:03,280 --> 00:26:09,220
first thing we we have add to the model

518
00:26:06,340 --> 00:26:13,780
is we're gonna record for every bug the

519
00:26:09,220 --> 00:26:16,870
source so if a value is returned and add

520
00:26:13,780 --> 00:26:19,720
to a query or part of the sensible

521
00:26:16,870 --> 00:26:22,600
parameter we're gonna record the exact

522
00:26:19,720 --> 00:26:24,310
signature so for example the idea is

523
00:26:22,600 --> 00:26:27,520
that we have something like a property

524
00:26:24,310 --> 00:26:29,830
encoder that encode specifically HTML if

525
00:26:27,520 --> 00:26:33,400
there's some pattern where it's commonly

526
00:26:29,830 --> 00:26:36,929
used and it end up end up being mark as

527
00:26:33,400 --> 00:26:40,960
positive then the machine learning

528
00:26:36,930 --> 00:26:44,200
hopefully we'll be able to detect it if

529
00:26:40,960 --> 00:26:47,680
we have again encapsulation on a non API

530
00:26:44,200 --> 00:26:52,390
that you won't see configuration so

531
00:26:47,680 --> 00:26:54,400
anything that would be safe and the same

532
00:26:52,390 --> 00:26:59,730
will be the API that is triggering the

533
00:26:54,400 --> 00:27:02,920
vanity so either SQL air path reverse on

534
00:26:59,730 --> 00:27:07,730
another element is we're going to start

535
00:27:02,920 --> 00:27:11,029
do enter procedural analysis

536
00:27:07,730 --> 00:27:13,970
but we're kind of limited we need to fit

537
00:27:11,029 --> 00:27:17,960
those value into either a binary value

538
00:27:13,970 --> 00:27:20,299
or a finite number of values so if we

539
00:27:17,960 --> 00:27:24,620
have multiple source we cannot have

540
00:27:20,299 --> 00:27:26,120
infinite column in our model so the way

541
00:27:24,620 --> 00:27:28,370
we implement it first in the first

542
00:27:26,120 --> 00:27:31,250
iteration is we're going to first have

543
00:27:28,370 --> 00:27:34,668
the state does one source is safe

544
00:27:31,250 --> 00:27:36,889
those ones source is tainted and if one

545
00:27:34,669 --> 00:27:43,159
source is unknown unknown being any

546
00:27:36,889 --> 00:27:45,110
unknown API yeah there are some property

547
00:27:43,159 --> 00:27:49,159
Ritu to localization so the module name

548
00:27:45,110 --> 00:27:52,219
in which the code is located in for

549
00:27:49,159 --> 00:27:56,450
funding so if some component is more

550
00:27:52,220 --> 00:28:00,080
critical there might be more risk in

551
00:27:56,450 --> 00:28:02,830
those component that was the ID in

552
00:28:00,080 --> 00:28:07,730
practice those didn't work really well

553
00:28:02,830 --> 00:28:11,629
so in order to do those kind of complex

554
00:28:07,730 --> 00:28:15,019
query to attain does it ask at least one

555
00:28:11,630 --> 00:28:17,659
things source one safe source we need to

556
00:28:15,019 --> 00:28:22,309
model a graph that will cover the

557
00:28:17,659 --> 00:28:27,529
complete application so even in this

558
00:28:22,309 --> 00:28:30,529
short code sample were having a method

559
00:28:27,529 --> 00:28:35,120
load user that will call the PIO create

560
00:28:30,529 --> 00:28:38,090
query so this is a SQL query and just

561
00:28:35,120 --> 00:28:41,600
for the sample comm we'll have three

562
00:28:38,090 --> 00:28:44,799
nodes so we don't want to model

563
00:28:41,600 --> 00:28:46,760
otherwise all the interaction all the

564
00:28:44,799 --> 00:28:49,789
assignment inside the method because

565
00:28:46,760 --> 00:28:53,480
this is static this won't change but the

566
00:28:49,789 --> 00:28:57,980
relation between method will be a more

567
00:28:53,480 --> 00:28:59,750
volatile so the ideas will track the the

568
00:28:57,980 --> 00:29:02,380
relation between input and output only

569
00:28:59,750 --> 00:29:05,840
but internal state of method won't be

570
00:29:02,380 --> 00:29:08,450
put into detail into the graph so the

571
00:29:05,840 --> 00:29:10,129
first node we're creating is the node

572
00:29:08,450 --> 00:29:13,340
one which will be the parrot or input

573
00:29:10,130 --> 00:29:17,570
and will be linked with the parameter of

574
00:29:13,340 --> 00:29:19,428
index 0 of create query so even though

575
00:29:17,570 --> 00:29:21,080
there are still concatenation atma it

576
00:29:19,429 --> 00:29:23,899
might have some

577
00:29:21,080 --> 00:29:26,389
intimate delivery state were only gonna

578
00:29:23,899 --> 00:29:30,018
attract the output which is the method

579
00:29:26,389 --> 00:29:30,889
cow that is sensible and it linked with

580
00:29:30,019 --> 00:29:34,009
where it came from

581
00:29:30,889 --> 00:29:36,649
so it could be if you have a method that

582
00:29:34,009 --> 00:29:39,529
returned a value or a parameter here in

583
00:29:36,649 --> 00:29:43,399
this case we also need to create another

584
00:29:39,529 --> 00:29:48,289
node that will cover the specific API

585
00:29:43,399 --> 00:29:51,709
that was a bone so this is needed to

586
00:29:48,289 --> 00:29:56,480
cover to be able to later search on our

587
00:29:51,710 --> 00:29:59,889
graph model so it's gonna named Rob and

588
00:29:56,480 --> 00:30:02,869
I was using a new 4G for this project so

589
00:29:59,889 --> 00:30:05,869
we're gonna have node for every state

590
00:30:02,869 --> 00:30:09,949
and with this graph we're gonna be able

591
00:30:05,869 --> 00:30:13,009
to search for specific a place for each

592
00:30:09,950 --> 00:30:15,799
county to map to the specific variable

593
00:30:13,009 --> 00:30:19,869
state so we're not seeing the complete

594
00:30:15,799 --> 00:30:23,710
query here but it was searching for any

595
00:30:19,869 --> 00:30:30,049
value that was add to the add other API

596
00:30:23,710 --> 00:30:33,409
so but I have a full query in X so with

597
00:30:30,049 --> 00:30:35,929
the graph database you can interact with

598
00:30:33,409 --> 00:30:40,399
different API one of the more standard

599
00:30:35,929 --> 00:30:42,470
API is a cipher so it's kind of

600
00:30:40,399 --> 00:30:46,039
interesting at the syntax the first

601
00:30:42,470 --> 00:30:48,379
segment you write it like if it would be

602
00:30:46,039 --> 00:30:51,070
ASCII art so you're a different node

603
00:30:48,379 --> 00:30:54,189
you're describing them with arrows and

604
00:30:51,070 --> 00:30:58,090
each variable you can add some filter

605
00:30:54,190 --> 00:31:01,580
like specific matching name stuff so

606
00:30:58,090 --> 00:31:07,549
basically we're looking for this node

607
00:31:01,580 --> 00:31:10,970
will be the element calling the the

608
00:31:07,549 --> 00:31:13,369
renewable sync so to make sure we're not

609
00:31:10,970 --> 00:31:15,139
calling for example exit query

610
00:31:13,369 --> 00:31:16,658
everywhere it's been called in the

611
00:31:15,139 --> 00:31:18,859
application but this specific occurrence

612
00:31:16,659 --> 00:31:25,669
related to the bugs we're looking for

613
00:31:18,859 --> 00:31:30,109
and we're going up to eight in depth so

614
00:31:25,669 --> 00:31:32,090
this is reasonably far we're going to

615
00:31:30,109 --> 00:31:34,749
match for specific sync and source so

616
00:31:32,090 --> 00:31:34,749
this way

617
00:31:35,540 --> 00:31:43,590
yeah and the source is for this one to

618
00:31:41,970 --> 00:32:01,440
make sure what we're looking at the

619
00:31:43,590 --> 00:32:03,540
right code already the demo so one thing

620
00:32:01,440 --> 00:32:06,780
I always try to do when I develop tool

621
00:32:03,540 --> 00:32:09,830
is look for existing tool and instead of

622
00:32:06,780 --> 00:32:13,440
the looping my own UI for classification

623
00:32:09,830 --> 00:32:17,340
I'm reusing sonarqube which is a tool

624
00:32:13,440 --> 00:32:21,990
that basically allows you to classify

625
00:32:17,340 --> 00:32:24,870
blog so you can review all the reporter

626
00:32:21,990 --> 00:32:28,560
the issue from friends kill bugs in this

627
00:32:24,870 --> 00:32:30,899
URL and then I can have a state I can

628
00:32:28,560 --> 00:32:33,540
put it as false positive or confirm if

629
00:32:30,900 --> 00:32:38,250
it's an actual entity so what I've

630
00:32:33,540 --> 00:32:40,379
previously done is I've scan webgoat all

631
00:32:38,250 --> 00:32:43,110
the lessons or all the exercise there

632
00:32:40,380 --> 00:32:46,770
were about 50 potential penalty I

633
00:32:43,110 --> 00:32:48,780
classify for the something just enough

634
00:32:46,770 --> 00:32:57,560
but I'm still having some grantee or

635
00:32:48,780 --> 00:33:00,330
unclassified so at the moment we have

636
00:32:57,560 --> 00:33:05,360
command-line interface but the the more

637
00:33:00,330 --> 00:33:11,510
stable API is the one using maven so

638
00:33:05,360 --> 00:33:16,290
this is the web goat project the first

639
00:33:11,510 --> 00:33:20,790
step I'm gonna do I'm gonna zoom in a

640
00:33:16,290 --> 00:33:23,810
moment the first one step is generating

641
00:33:20,790 --> 00:33:26,670
the the data so when you're gonna

642
00:33:23,810 --> 00:33:29,970
interact with different tools often is

643
00:33:26,670 --> 00:33:33,000
gonna be either CSV or CSV + + load

644
00:33:29,970 --> 00:33:35,280
usually different tool will have a

645
00:33:33,000 --> 00:33:36,900
different format but the CSV will have

646
00:33:35,280 --> 00:33:38,879
also metadata describing the different

647
00:33:36,900 --> 00:33:45,070
attribute but it will be mostly CSV

648
00:33:38,880 --> 00:33:55,030
format and in this case so I would

649
00:33:45,070 --> 00:33:57,730
just the whole check so on the right I

650
00:33:55,030 --> 00:33:59,980
don't need to zoom the this will be the

651
00:33:57,730 --> 00:34:06,010
generated file on the for the different

652
00:33:59,980 --> 00:34:07,870
steps so the first part I don't need

653
00:34:06,010 --> 00:34:10,750
necessarily to look specifically on the

654
00:34:07,870 --> 00:34:13,060
left but we're gonna aggregate first the

655
00:34:10,750 --> 00:34:17,340
result from the different report from

656
00:34:13,060 --> 00:34:20,350
spot bugs there's close to 20 sub-module

657
00:34:17,340 --> 00:34:23,710
we're also gonna aggregate to each of

658
00:34:20,350 --> 00:34:26,409
those bugs the different property that I

659
00:34:23,710 --> 00:34:29,590
was talking about like x related stuff

660
00:34:26,409 --> 00:34:31,928
and say for unknown state we took to the

661
00:34:29,590 --> 00:34:34,510
graph so these were generated for every

662
00:34:31,929 --> 00:34:39,000
bugs we also add the different API for

663
00:34:34,510 --> 00:34:42,520
same source etc and another meter meter

664
00:34:39,000 --> 00:34:46,540
from Sanaa I'm also poking the state for

665
00:34:42,520 --> 00:34:52,270
every gonna see that was classified or

666
00:34:46,540 --> 00:34:55,779
not so we'll have three data set so the

667
00:34:52,270 --> 00:34:58,540
result is including everything label 1

668
00:34:55,780 --> 00:35:00,340
are those that I have confirmed or mark

669
00:34:58,540 --> 00:35:03,790
as false positives so this will be our

670
00:35:00,340 --> 00:35:09,060
training set the only ball one is those

671
00:35:03,790 --> 00:35:13,360
that I have not classified yet so

672
00:35:09,060 --> 00:35:18,570
there's only two command left there's

673
00:35:13,360 --> 00:35:18,570
the train comin oops

674
00:35:21,540 --> 00:35:29,410
so this command will generate a model so

675
00:35:25,870 --> 00:35:31,859
this model can be reused and basically

676
00:35:29,410 --> 00:35:35,560
that is this will be a naive Bayes

677
00:35:31,860 --> 00:35:37,960
algorithm that is used so once you input

678
00:35:35,560 --> 00:35:40,900
into the model new value it will

679
00:35:37,960 --> 00:35:43,740
classify it and tell you a result is it

680
00:35:40,900 --> 00:35:48,460
a nationality or is it a false positive

681
00:35:43,740 --> 00:35:50,560
so this is just an intermediate State

682
00:35:48,460 --> 00:35:57,730
if we have the model that is generated

683
00:35:50,560 --> 00:35:59,650
and finally what we want to see we're

684
00:35:57,730 --> 00:36:03,640
gonna try to predict for the remaining

685
00:35:59,650 --> 00:36:04,240
venality some result so just make sure

686
00:36:03,640 --> 00:36:08,379
it works

687
00:36:04,240 --> 00:36:15,279
okay okay I'm good to show you a

688
00:36:08,380 --> 00:36:18,820
specific example so previously I showed

689
00:36:15,280 --> 00:36:22,150
you that some cases were already

690
00:36:18,820 --> 00:36:27,460
eliminated by the basic finds 50 bugs

691
00:36:22,150 --> 00:36:30,820
due to local data instance we still add

692
00:36:27,460 --> 00:36:34,840
three cases that were marked as

693
00:36:30,820 --> 00:36:39,400
potential penalties so when I classify

694
00:36:34,840 --> 00:36:42,000
the potential extra injection every time

695
00:36:39,400 --> 00:36:46,860
I was seen in session get user name

696
00:36:42,000 --> 00:36:51,460
market as a false positive because I

697
00:36:46,860 --> 00:36:54,360
assume that this variable would have

698
00:36:51,460 --> 00:36:58,150
been validated before and it was not

699
00:36:54,360 --> 00:37:00,460
user input directly well for example get

700
00:36:58,150 --> 00:37:03,940
R a parameter this is reading directly

701
00:37:00,460 --> 00:37:07,720
from HP parameter so every time I was

702
00:37:03,940 --> 00:37:11,610
saying this that led to a SQL query I

703
00:37:07,720 --> 00:37:14,890
would mark this as confirm so hopefully

704
00:37:11,610 --> 00:37:17,770
the result of our prediction we put this

705
00:37:14,890 --> 00:37:23,200
one higher on the list and there's

706
00:37:17,770 --> 00:37:28,180
another one which is against those

707
00:37:23,200 --> 00:37:30,640
called our dummy code so this sample six

708
00:37:28,180 --> 00:37:32,480
method is never called so it has an

709
00:37:30,640 --> 00:37:35,330
unknown variable

710
00:37:32,480 --> 00:37:37,400
and yeah so we don't know where it's

711
00:37:35,330 --> 00:37:41,720
coming from so might be using input but

712
00:37:37,400 --> 00:37:44,300
we don't know for sure so hopefully this

713
00:37:41,720 --> 00:37:47,060
one will also be ire then this one that

714
00:37:44,300 --> 00:37:51,440
repeatedly we have put as false positive

715
00:37:47,060 --> 00:37:54,619
at least two or three times so it's not

716
00:37:51,440 --> 00:37:58,790
a big data set so the accuracy won't be

717
00:37:54,619 --> 00:38:00,530
a that I four other bugs but hopefully

718
00:37:58,790 --> 00:38:06,350
for this one because I know on purpose

719
00:38:00,530 --> 00:38:09,590
that in other cases I've put a username

720
00:38:06,350 --> 00:38:12,880
as false positive I'm going to search

721
00:38:09,590 --> 00:38:16,190
specifically for those three guesses

722
00:38:12,880 --> 00:38:19,580
so the the prediction it's pretty

723
00:38:16,190 --> 00:38:21,800
primitive the the UI it's it's gonna

724
00:38:19,580 --> 00:38:23,210
include the metadata plus link to

725
00:38:21,800 --> 00:38:25,760
different resource so if you want to

726
00:38:23,210 --> 00:38:27,680
look at the description of the bug it's

727
00:38:25,760 --> 00:38:30,470
gonna link you to the description on a

728
00:38:27,680 --> 00:38:34,100
fence if debug website so you get

729
00:38:30,470 --> 00:38:36,140
similar something similar to the ID but

730
00:38:34,100 --> 00:38:40,069
really if you need to validate the code

731
00:38:36,140 --> 00:38:44,390
you would need to do it into the you

732
00:38:40,070 --> 00:38:47,450
know in an ID or a sawn-off cube for

733
00:38:44,390 --> 00:38:50,600
example so here it's gonna open and we

734
00:38:47,450 --> 00:38:52,700
get to the body one thing I need to

735
00:38:50,600 --> 00:38:54,980
precise over here the probability is the

736
00:38:52,700 --> 00:38:57,710
probability of being I go through being

737
00:38:54,980 --> 00:39:00,410
a false positives I didn't do this

738
00:38:57,710 --> 00:39:03,400
interface so at first I was confused and

739
00:39:00,410 --> 00:39:08,930
I was wondering why it didn't work so

740
00:39:03,400 --> 00:39:09,800
those two are less likely to be a verbal

741
00:39:08,930 --> 00:39:13,580
than this one

742
00:39:09,800 --> 00:39:19,640
with at any 8% is likely to be a false

743
00:39:13,580 --> 00:39:23,350
positive so and if we open it this one

744
00:39:19,640 --> 00:39:26,180
is the one where it's using get username

745
00:39:23,350 --> 00:39:30,380
so this source because we know that in

746
00:39:26,180 --> 00:39:35,060
other instances of SQL injection this

747
00:39:30,380 --> 00:39:37,190
API was used as source then it is less

748
00:39:35,060 --> 00:39:41,299
likely than the other two to result into

749
00:39:37,190 --> 00:39:45,509
an actual vanadis so the expected use

750
00:39:41,300 --> 00:39:47,969
cases or the method to use would be

751
00:39:45,509 --> 00:39:51,779
you sort the bugs into the probability

752
00:39:47,969 --> 00:39:53,729
and the lowers percentage would be those

753
00:39:51,779 --> 00:39:58,380
that are the more likely to be actual

754
00:39:53,729 --> 00:40:01,529
reality and until the yeah so if you

755
00:39:58,380 --> 00:40:04,409
will have more bugs then you can just

756
00:40:01,529 --> 00:40:08,249
review ten or twenty and then we do that

757
00:40:04,409 --> 00:40:10,889
step I did to retrain and predict again

758
00:40:08,249 --> 00:40:13,319
so maybe there would be some change if

759
00:40:10,889 --> 00:40:16,919
for example you it few type of dirty

760
00:40:13,319 --> 00:40:19,159
that are often false polluted then maybe

761
00:40:16,919 --> 00:40:27,449
that retraining the order will be better

762
00:40:19,159 --> 00:40:31,979
so that's the general demo back to the

763
00:40:27,449 --> 00:40:36,299
slide so I'll go quickly to Twitter

764
00:40:31,979 --> 00:40:38,249
resolve this graph I realized that with

765
00:40:36,299 --> 00:40:41,880
the color it won't be real clear but

766
00:40:38,249 --> 00:40:45,598
anyway so initially this was the Juliet

767
00:40:41,880 --> 00:40:47,999
test shoot so all the reported naughty

768
00:40:45,599 --> 00:40:50,699
were expected to be bad because they

769
00:40:47,999 --> 00:40:54,598
were reported but everything on the

770
00:40:50,699 --> 00:40:57,959
right is false positive now after

771
00:40:54,599 --> 00:40:59,999
reclassification with those attribute

772
00:40:57,959 --> 00:41:03,359
that I mentioned all the dots that you

773
00:40:59,999 --> 00:41:04,589
see that are not matching those so the

774
00:41:03,359 --> 00:41:07,649
color doesn't match with the previous

775
00:41:04,589 --> 00:41:11,369
graphic that's the thing so every blue

776
00:41:07,649 --> 00:41:14,069
dot that you see on the left right part

777
00:41:11,369 --> 00:41:16,649
are going to be false positive and every

778
00:41:14,069 --> 00:41:18,839
red dot on the left will be a false

779
00:41:16,649 --> 00:41:20,189
positive that are not actually bad but

780
00:41:18,839 --> 00:41:23,038
should have been placed on the other

781
00:41:20,189 --> 00:41:27,749
side so we can see that on large scale

782
00:41:23,039 --> 00:41:31,880
it's worked pretty well the thing with

783
00:41:27,749 --> 00:41:34,259
the reality so Juliet is Marathi with

784
00:41:31,880 --> 00:41:38,069
that are kind of fake because they are

785
00:41:34,259 --> 00:41:41,189
semi generated and it's a large data set

786
00:41:38,069 --> 00:41:45,329
that include not a positive but almost

787
00:41:41,189 --> 00:41:47,908
as much actual realities this is the

788
00:41:45,329 --> 00:41:50,130
result we got with the whispering

789
00:41:47,909 --> 00:41:53,999
framework and it's a complete different

790
00:41:50,130 --> 00:41:56,999
data set in terms of the number of

791
00:41:53,999 --> 00:41:58,609
actual variety so might be encouraging

792
00:41:56,999 --> 00:42:02,520
to see up

793
00:41:58,609 --> 00:42:04,290
95% accuracy but this is something to be

794
00:42:02,520 --> 00:42:07,020
aware especially if you're buying tools

795
00:42:04,290 --> 00:42:10,740
that give you stats about Oh our passion

796
00:42:07,020 --> 00:42:13,619
learning is working so well the accuracy

797
00:42:10,740 --> 00:42:17,129
is based on true positive plus true

798
00:42:13,619 --> 00:42:21,210
negative on all other cases if I look at

799
00:42:17,130 --> 00:42:26,910
the confusion matrix here I classified

800
00:42:21,210 --> 00:42:29,160
about just over 600 bugs but only 28 of

801
00:42:26,910 --> 00:42:32,609
those were actual grantees that mean the

802
00:42:29,160 --> 00:42:34,339
of those were false positive and there's

803
00:42:32,609 --> 00:42:38,240
a small percentage that didn't review

804
00:42:34,340 --> 00:42:42,810
there were maybe a 700 at all

805
00:42:38,240 --> 00:42:44,490
so the accuracy is only based on those

806
00:42:42,810 --> 00:42:49,410
that were perfectly safai but the thing

807
00:42:44,490 --> 00:42:53,040
is there so little actual vanity that

808
00:42:49,410 --> 00:42:55,500
the percentage climb really I so there's

809
00:42:53,040 --> 00:42:58,020
two things that we can enter through

810
00:42:55,500 --> 00:43:02,040
this so first we could take the approach

811
00:42:58,020 --> 00:43:07,800
okay because in this case we have so

812
00:43:02,040 --> 00:43:09,359
many actually zero false negative all

813
00:43:07,800 --> 00:43:12,480
right yeah first thing else it doesn't

814
00:43:09,359 --> 00:43:15,299
mean that we could for example in a CI

815
00:43:12,480 --> 00:43:18,390
alert developer directly because we're

816
00:43:15,300 --> 00:43:22,400
so sure that the debug that are going to

817
00:43:18,390 --> 00:43:25,410
be classified higher than 50% are

818
00:43:22,400 --> 00:43:27,660
actually empty then maybe we could alert

819
00:43:25,410 --> 00:43:30,690
them directly to developer because their

820
00:43:27,660 --> 00:43:33,118
upper don't have infinite time to pass

821
00:43:30,690 --> 00:43:35,030
for security so every time you need to

822
00:43:33,119 --> 00:43:38,910
spend time on security it needs to be a

823
00:43:35,030 --> 00:43:41,330
well worth another thing is we can lower

824
00:43:38,910 --> 00:43:44,790
the threshold for example by default

825
00:43:41,330 --> 00:43:47,029
algorithm are using 50% because if we

826
00:43:44,790 --> 00:43:50,160
try just to have the maximum accuracy

827
00:43:47,030 --> 00:43:51,810
but if we're able to tolerate some false

828
00:43:50,160 --> 00:43:54,690
negative

829
00:43:51,810 --> 00:43:58,339
actually no these are 22 are the false

830
00:43:54,690 --> 00:44:03,539
negative here we add 0 false positive

831
00:43:58,339 --> 00:44:05,459
but anyway so for some drone t-type it

832
00:44:03,539 --> 00:44:08,189
worked well like there were four

833
00:44:05,459 --> 00:44:10,499
excesses and it was always finding those

834
00:44:08,189 --> 00:44:12,359
and the thing is there were different

835
00:44:10,499 --> 00:44:20,339
villainy classes for almost all of them

836
00:44:12,359 --> 00:44:23,069
so maybe didn't help we're still using a

837
00:44:20,339 --> 00:44:24,569
tool to find bugs just to feed our model

838
00:44:23,069 --> 00:44:28,589
because that's the main thing were

839
00:44:24,569 --> 00:44:30,989
missing when we're not having large

840
00:44:28,589 --> 00:44:33,449
unity that our actual mentee it's easy

841
00:44:30,989 --> 00:44:35,039
with julia to have thirty thousand three

842
00:44:33,449 --> 00:44:39,749
auntie but these are not real world

843
00:44:35,039 --> 00:44:43,619
unity so were can continuing to find

844
00:44:39,749 --> 00:44:47,819
some grantees so just just before the

845
00:44:43,619 --> 00:44:52,109
summer report few noticed in spring that

846
00:44:47,819 --> 00:44:54,380
were done doing out here and recently we

847
00:44:52,109 --> 00:44:59,459
have started to do more preparatory

848
00:44:54,380 --> 00:45:01,769
library and it seems to be cases where

849
00:44:59,459 --> 00:45:05,578
worse finding much more advantage

850
00:45:01,769 --> 00:45:08,819
compared to open source library so we're

851
00:45:05,579 --> 00:45:11,939
gonna release an article and maybe next

852
00:45:08,819 --> 00:45:13,589
month related to the different RC that

853
00:45:11,939 --> 00:45:16,348
we have found so these are not all

854
00:45:13,589 --> 00:45:21,150
around peep I'm excluding all the medium

855
00:45:16,349 --> 00:45:23,789
one and let's interesting one so let

856
00:45:21,150 --> 00:45:27,299
alone if you you would have to start a

857
00:45:23,789 --> 00:45:29,939
machine learning project but I would

858
00:45:27,299 --> 00:45:32,849
like to tell you is first focus more on

859
00:45:29,939 --> 00:45:35,489
a model then the algorithm so it's easy

860
00:45:32,849 --> 00:45:38,059
to just activity that you have that is

861
00:45:35,489 --> 00:45:40,409
probably poor and try two different

862
00:45:38,059 --> 00:45:43,829
article to gain one percent or two

863
00:45:40,409 --> 00:45:45,299
percent better but if you have a quality

864
00:45:43,829 --> 00:45:48,150
attribute this is going to do the

865
00:45:45,299 --> 00:45:52,469
difference I always inspect your data

866
00:45:48,150 --> 00:45:55,559
SEC it's easy to generate dynamically

867
00:45:52,469 --> 00:45:58,679
some value and you realize that I felt

868
00:45:55,559 --> 00:46:02,130
I'm value is missing or it's not as

869
00:45:58,679 --> 00:46:04,019
expected one thing that my collegia as

870
00:46:02,130 --> 00:46:06,329
observed is that some machine learning

871
00:46:04,019 --> 00:46:09,808
if you don't specify a value like it's

872
00:46:06,329 --> 00:46:12,069
not like it doesn't apply because some

873
00:46:09,809 --> 00:46:15,459
algorithm don't support empty values

874
00:46:12,069 --> 00:46:17,890
there's some skip the the data so this

875
00:46:15,459 --> 00:46:22,359
is pretty bad and it won't trigger any

876
00:46:17,890 --> 00:46:25,209
warning so try to place a dummy value to

877
00:46:22,359 --> 00:46:28,769
see doesn't apply any or whatever this

878
00:46:25,209 --> 00:46:32,140
way you're sure that it won't eliminate

879
00:46:28,769 --> 00:46:34,930
your data basic stuff

880
00:46:32,140 --> 00:46:40,569
don't mix training setting and test set

881
00:46:34,930 --> 00:46:42,640
and these are do I have still a few

882
00:46:40,569 --> 00:46:46,660
minutes okay perfect so I finish the

883
00:46:42,640 --> 00:46:48,489
slide the training set need to be close

884
00:46:46,660 --> 00:46:50,949
to the test set so one of the main prime

885
00:46:48,489 --> 00:46:53,589
we add is if we review different

886
00:46:50,949 --> 00:46:56,349
libraries often the API use in those I

887
00:46:53,589 --> 00:46:58,449
really won't match others so it's really

888
00:46:56,349 --> 00:47:00,489
hard we were trying to add more

889
00:46:58,449 --> 00:47:04,979
attribute that are more generic but it's

890
00:47:00,489 --> 00:47:07,719
really hard to have significant so

891
00:47:04,979 --> 00:47:11,078
that's one of the reason I've started to

892
00:47:07,719 --> 00:47:13,209
pull hundred-twenty spring libraries and

893
00:47:11,079 --> 00:47:16,329
focus on those because my expectation

894
00:47:13,209 --> 00:47:20,979
was that at least some component will be

895
00:47:16,329 --> 00:47:24,369
used some some of the simple and at the

896
00:47:20,979 --> 00:47:27,788
moment I creating a that I said doesn't

897
00:47:24,369 --> 00:47:29,469
work as well as expected so at the

898
00:47:27,789 --> 00:47:31,239
moment the demo I've done it's

899
00:47:29,469 --> 00:47:34,599
experimental that the code is out it's

900
00:47:31,239 --> 00:47:36,849
on github the graph part is was release

901
00:47:34,599 --> 00:47:39,099
end of last year but it's still

902
00:47:36,849 --> 00:47:41,589
experimental I wouldn't use it in

903
00:47:39,099 --> 00:47:44,289
production because you can add some good

904
00:47:41,589 --> 00:47:45,609
results some week and the next week you

905
00:47:44,289 --> 00:47:49,180
do some classification and it's not

906
00:47:45,609 --> 00:47:52,328
working as expected and so the good news

907
00:47:49,180 --> 00:47:56,169
is I'm using it in a different way than

908
00:47:52,329 --> 00:48:00,839
I expected so just by scanning massively

909
00:47:56,170 --> 00:48:03,400
a code I'm I'm seeing from a statical

910
00:48:00,839 --> 00:48:05,380
perspective so when I analyze for

911
00:48:03,400 --> 00:48:07,839
example a decision tree that are

912
00:48:05,380 --> 00:48:09,670
generated measuring I'm saying for

913
00:48:07,839 --> 00:48:12,190
example Bach type that has very high

914
00:48:09,670 --> 00:48:14,109
fast positive that I didn't expected so

915
00:48:12,190 --> 00:48:17,019
we're gonna try to produce some profile

916
00:48:14,109 --> 00:48:19,359
that they made those so that people that

917
00:48:17,019 --> 00:48:21,968
don't have just short amount of time to

918
00:48:19,359 --> 00:48:23,600
do scanning can use those profile to a

919
00:48:21,969 --> 00:48:27,800
make some noise

920
00:48:23,600 --> 00:48:30,080
also we're seeing some source that are

921
00:48:27,800 --> 00:48:31,760
maybe actually a encoding method that we

922
00:48:30,080 --> 00:48:36,799
should add in the configuration of

923
00:48:31,760 --> 00:48:38,420
finally button so if it's always first

924
00:48:36,800 --> 00:48:39,620
positive when this method is used and

925
00:48:38,420 --> 00:48:42,470
it's a public API

926
00:48:39,620 --> 00:48:45,980
why not added to the finally bugs as an

927
00:48:42,470 --> 00:48:47,959
encoder if it applied also sometimes

928
00:48:45,980 --> 00:48:50,510
saying that always trigger false

929
00:48:47,960 --> 00:48:53,270
positive like I have one case in mind

930
00:48:50,510 --> 00:48:57,440
that we're gonna remove from frankly

931
00:48:53,270 --> 00:49:01,700
bugs there was a XSS vector in a send

932
00:48:57,440 --> 00:49:03,800
error in g2e that was there was a

933
00:49:01,700 --> 00:49:06,109
excesses that applied but only under a

934
00:49:03,800 --> 00:49:08,300
more version of Tomcat so it made sense

935
00:49:06,110 --> 00:49:11,480
four years ago when we had the rule to

936
00:49:08,300 --> 00:49:14,120
detect potential XSS but now if you

937
00:49:11,480 --> 00:49:21,170
didn't update the Tomcat at this point

938
00:49:14,120 --> 00:49:22,910
you have bigger problem so so I'm I'm

939
00:49:21,170 --> 00:49:25,040
done with the representation on the

940
00:49:22,910 --> 00:49:26,480
project with tomorrow if you want to

941
00:49:25,040 --> 00:49:28,630
have ends own experience on machine

942
00:49:26,480 --> 00:49:31,090
learning this is gonna be a entry level

943
00:49:28,630 --> 00:49:34,700
so if you have no prior knowledge of

944
00:49:31,090 --> 00:49:39,110
machine learning I'm gonna use orange as

945
00:49:34,700 --> 00:49:40,700
a tool for the exercise so Orange

946
00:49:39,110 --> 00:49:43,550
the interesting part is there's a

947
00:49:40,700 --> 00:49:46,720
library part but it's also a GUI part so

948
00:49:43,550 --> 00:49:49,220
we're gonna do no programming so only

949
00:49:46,720 --> 00:49:52,339
inserting in the canvas widget

950
00:49:49,220 --> 00:49:54,950
connecting them we're gonna be able to

951
00:49:52,340 --> 00:49:57,680
train some algorithms and get some

952
00:49:54,950 --> 00:50:01,009
visualization so if you want some end on

953
00:49:57,680 --> 00:50:03,169
end zone experience to have an ID we're

954
00:50:01,010 --> 00:50:05,840
gonna use two that has set data set

955
00:50:03,170 --> 00:50:09,800
which is a classic one using machine

956
00:50:05,840 --> 00:50:12,020
learning and the final exercise is with

957
00:50:09,800 --> 00:50:13,640
data produced in my project to give you

958
00:50:12,020 --> 00:50:16,700
more security perspective

959
00:50:13,640 --> 00:50:18,350
so that's tomorrow if you are interested

960
00:50:16,700 --> 00:50:20,299
in machine learning and maybe try to

961
00:50:18,350 --> 00:50:24,290
experiment for project at work or

962
00:50:20,300 --> 00:50:26,620
personal and I'm done so if you have any

963
00:50:24,290 --> 00:50:26,620
question

964
00:50:26,960 --> 00:50:51,409
[Music]

