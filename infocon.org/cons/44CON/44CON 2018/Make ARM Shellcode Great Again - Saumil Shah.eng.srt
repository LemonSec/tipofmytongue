1
00:00:00,060 --> 00:00:04,879
all right well welcome to track two

2
00:00:03,870 --> 00:00:08,849
ladies and gentlemen

3
00:00:04,879 --> 00:00:13,620
sorry for the delay on on the startup

4
00:00:08,849 --> 00:00:16,770
and just when I get started with my talk

5
00:00:13,620 --> 00:00:23,759
I have another apology to offer 20

6
00:00:16,770 --> 00:00:27,539
minutes ago I RM my slides it's one of

7
00:00:23,760 --> 00:00:28,789
those days where yes command-line

8
00:00:27,539 --> 00:00:31,980
doesn't help you

9
00:00:28,789 --> 00:00:33,210
you couldn't controls edit so these

10
00:00:31,980 --> 00:00:35,730
slides that you see have been put

11
00:00:33,210 --> 00:00:42,300
together in the last 17 minutes and then

12
00:00:35,730 --> 00:00:44,879
I then I ran down however however the

13
00:00:42,300 --> 00:00:47,519
demos work and we will be just note

14
00:00:44,879 --> 00:00:49,170
padding and demoing the talk so at least

15
00:00:47,520 --> 00:00:50,940
I've got everything working which is

16
00:00:49,170 --> 00:00:54,750
good I hope the VM doesn't evaporate

17
00:00:50,940 --> 00:00:59,149
while we while I present and and make me

18
00:00:54,750 --> 00:01:02,910
look like a complete monkey all right

19
00:00:59,149 --> 00:01:07,890
without much further ado let's let's get

20
00:01:02,910 --> 00:01:14,360
this show going so my name is Sami Lucia

21
00:01:07,890 --> 00:01:17,220
I apologize for screwing up the slides

22
00:01:14,360 --> 00:01:21,840
what we going to talk about in this next

23
00:01:17,220 --> 00:01:25,350
hour is basically my own research on arm

24
00:01:21,840 --> 00:01:26,549
shellcode this is some part of it might

25
00:01:25,350 --> 00:01:29,339
be new some part of it might be

26
00:01:26,549 --> 00:01:31,100
repetitive but repetitive but this is

27
00:01:29,340 --> 00:01:35,850
stuff that I have been playing around I

28
00:01:31,100 --> 00:01:38,009
got it working and presentable enough

29
00:01:35,850 --> 00:01:40,289
and this is the first time I'm giving

30
00:01:38,009 --> 00:01:44,729
this talk off to a great start with the

31
00:01:40,290 --> 00:01:47,880
slides being bought I will publish the

32
00:01:44,729 --> 00:01:50,009
sides tomorrow for sure the code will be

33
00:01:47,880 --> 00:01:53,939
uploaded on github it's just a bunch of

34
00:01:50,009 --> 00:01:56,130
arm assembly files so with this being

35
00:01:53,939 --> 00:01:59,758
said and done let me just give you an

36
00:01:56,130 --> 00:02:01,350
idea about the gender I just start off

37
00:01:59,759 --> 00:02:04,320
with a little bit of background about

38
00:02:01,350 --> 00:02:07,199
arm shellcode which might be about 90

39
00:02:04,320 --> 00:02:09,810
seconds long and then I'll talk about

40
00:02:07,200 --> 00:02:13,830
the three areas that I have been working

41
00:02:09,810 --> 00:02:17,880
on arm shellcode the first stage

42
00:02:13,830 --> 00:02:20,880
I was working was on cache coherency but

43
00:02:17,880 --> 00:02:23,670
this problem has been solved before in

44
00:02:20,880 --> 00:02:26,880
several other in several other

45
00:02:23,670 --> 00:02:31,859
techniques so what I'm going to focus

46
00:02:26,880 --> 00:02:35,130
upon today is shellcode where space is

47
00:02:31,860 --> 00:02:38,460
tight and you have really limited space

48
00:02:35,130 --> 00:02:41,310
and some polyglot tricks that I've been

49
00:02:38,460 --> 00:02:43,710
working upon why because I love

50
00:02:41,310 --> 00:02:46,320
polyglots as you may have known from my

51
00:02:43,710 --> 00:02:49,350
previous work I love to confuse file

52
00:02:46,320 --> 00:02:51,720
formats I love to confuse instructions I

53
00:02:49,350 --> 00:02:56,370
love to confuse scripts and I love to

54
00:02:51,720 --> 00:02:59,460
confuse people so we're gonna see some

55
00:02:56,370 --> 00:03:06,120
polyglot tricks the demos are all

56
00:02:59,460 --> 00:03:09,810
working ok the first the first portion

57
00:03:06,120 --> 00:03:13,920
of this talk will be about how to handle

58
00:03:09,810 --> 00:03:18,450
shellcode when space is really tight ok

59
00:03:13,920 --> 00:03:22,010
before that the the background stuff on

60
00:03:18,450 --> 00:03:24,149
shellcode is kind of interesting it's

61
00:03:22,010 --> 00:03:28,590
somewhat like rolling the clock back to

62
00:03:24,150 --> 00:03:31,980
2008 10 years ago where x86 shellcode

63
00:03:28,590 --> 00:03:33,480
was just maturing you had additions

64
00:03:31,980 --> 00:03:36,480
contributed to the Metasploit framework

65
00:03:33,480 --> 00:03:38,340
you had shellcode archives people are

66
00:03:36,480 --> 00:03:40,500
cutting and pasting code and sometimes

67
00:03:38,340 --> 00:03:42,000
they would backdoor themselves if the

68
00:03:40,500 --> 00:03:44,430
kiddies don't know what they're doing

69
00:03:42,000 --> 00:03:46,110
there was that fantastic Apache exploit

70
00:03:44,430 --> 00:03:49,950
which actually added a backdoor route

71
00:03:46,110 --> 00:03:52,440
into your own system things in the arm

72
00:03:49,950 --> 00:03:54,750
space are like that there's not too much

73
00:03:52,440 --> 00:03:59,250
work being done or not too much work

74
00:03:54,750 --> 00:04:01,560
done in the shellcode space you can kind

75
00:03:59,250 --> 00:04:03,300
of get by with the limited shellcode

76
00:04:01,560 --> 00:04:05,370
that's available but the limited

77
00:04:03,300 --> 00:04:07,739
shellcode I mean the classic exactly by

78
00:04:05,370 --> 00:04:12,959
in shell reverse shell little bit of

79
00:04:07,739 --> 00:04:16,108
stagers there is an arm meterpreter semi

80
00:04:12,959 --> 00:04:20,100
working the challenge with arm shellcode

81
00:04:16,108 --> 00:04:24,979
is it's not like the ARM architecture

82
00:04:20,100 --> 00:04:27,670
especially MV 6 and 7 is not like intel

83
00:04:24,979 --> 00:04:30,490
intel gives you a lot of luxury

84
00:04:27,670 --> 00:04:33,370
you get unaligned memory access for fun

85
00:04:30,490 --> 00:04:35,770
and profit you get cash synchronization

86
00:04:33,370 --> 00:04:37,690
automatically done so you can have

87
00:04:35,770 --> 00:04:39,969
self-modifying shellcode you can have

88
00:04:37,690 --> 00:04:41,310
encoders and then decode the shellcode

89
00:04:39,970 --> 00:04:45,400
on-the-fly

90
00:04:41,310 --> 00:04:48,160
all that fun stuff works as is on Intel

91
00:04:45,400 --> 00:04:51,400
not so much in arm things will work

92
00:04:48,160 --> 00:04:53,230
things may not work things work on an b7

93
00:04:51,400 --> 00:04:56,320
they don't work on our b6 and some

94
00:04:53,230 --> 00:04:58,300
variants of our b7 don't work with

95
00:04:56,320 --> 00:05:01,150
encoded or self-modifying shellcode so

96
00:04:58,300 --> 00:05:04,780
there's a plethora of complexity when it

97
00:05:01,150 --> 00:05:07,299
comes to running on shellcode on actual

98
00:05:04,780 --> 00:05:10,510
hardware it'll run in QEMU but not not

99
00:05:07,300 --> 00:05:13,030
on actual hardware so the overall goal

100
00:05:10,510 --> 00:05:16,630
for all my shellcode research is try to

101
00:05:13,030 --> 00:05:19,570
keep the shellcode nan modifying nan

102
00:05:16,630 --> 00:05:22,810
self-modifying if we could modify the

103
00:05:19,570 --> 00:05:24,190
shellcode in inflight then polymorphism

104
00:05:22,810 --> 00:05:26,650
and all those tricks will be very easy

105
00:05:24,190 --> 00:05:27,160
you just do shake at a guy or something

106
00:05:26,650 --> 00:05:30,460
like that

107
00:05:27,160 --> 00:05:35,860
so all this work is without having cells

108
00:05:30,460 --> 00:05:39,400
modifying shellcode yeah so first thing

109
00:05:35,860 --> 00:05:45,840
we're going to see is how do we go about

110
00:05:39,400 --> 00:05:45,840
dealing with shellcode in tight spaces

111
00:05:46,290 --> 00:05:52,090
the most common approach as we know from

112
00:05:49,330 --> 00:05:55,060
the x86 world has been the egg hunter

113
00:05:52,090 --> 00:05:58,810
and egg Hunter stuff has been around for

114
00:05:55,060 --> 00:06:00,880
a long long time you kind of split up

115
00:05:58,810 --> 00:06:04,090
your attack shellcode in two different

116
00:06:00,880 --> 00:06:06,100
memory regions the memory region that is

117
00:06:04,090 --> 00:06:08,349
delivered with the part of the memory

118
00:06:06,100 --> 00:06:11,110
corruption exploit like a stack or flow

119
00:06:08,350 --> 00:06:14,410
or a format string bug the shellcode

120
00:06:11,110 --> 00:06:17,410
contained is very very compact it's like

121
00:06:14,410 --> 00:06:21,340
a small string the egg hunter

122
00:06:17,410 --> 00:06:24,760
code does nothing but searches all your

123
00:06:21,340 --> 00:06:27,250
process memory pages up and down and it

124
00:06:24,760 --> 00:06:29,409
looks for a pattern the pattern is

125
00:06:27,250 --> 00:06:32,170
typically a four byte value of your

126
00:06:29,410 --> 00:06:35,410
choice and this four byte value is

127
00:06:32,170 --> 00:06:37,600
checked twice because first time the

128
00:06:35,410 --> 00:06:40,290
four byte value can occur in different

129
00:06:37,600 --> 00:06:41,370
places so if these two eggs appear

130
00:06:40,290 --> 00:06:43,949
consecutive

131
00:06:41,370 --> 00:06:46,560
then we can say that okay the rest of

132
00:06:43,949 --> 00:06:49,410
the shellcode follows the egg so if

133
00:06:46,560 --> 00:06:53,010
you're exploiting a web server you may

134
00:06:49,410 --> 00:06:55,889
send the overflow in the URL and you may

135
00:06:53,010 --> 00:06:59,520
send the large payload as a part of the

136
00:06:55,889 --> 00:07:03,210
post content the URL may trigger a stack

137
00:06:59,520 --> 00:07:07,169
overflow the shellcode may be lying on

138
00:07:03,210 --> 00:07:09,299
the heap you need a way to somehow find

139
00:07:07,169 --> 00:07:12,840
out where the shellcode is on the heap

140
00:07:09,300 --> 00:07:14,880
because the other area where data is

141
00:07:12,840 --> 00:07:17,280
loaded is not predictable and that's why

142
00:07:14,880 --> 00:07:19,800
the egg hunter is important cause I will

143
00:07:17,280 --> 00:07:24,239
go and scan through memory for

144
00:07:19,800 --> 00:07:26,729
occurrences of these two eggs once it

145
00:07:24,240 --> 00:07:29,610
finds them at any given location it will

146
00:07:26,729 --> 00:07:31,469
Jen jump to the shellcode following it I

147
00:07:29,610 --> 00:07:34,229
had animations and everything for this

148
00:07:31,470 --> 00:07:36,120
trust but they're all gone so I wrote I

149
00:07:34,229 --> 00:07:37,800
have to use the thousand words instead

150
00:07:36,120 --> 00:07:46,010
of a single picture to deliver this

151
00:07:37,800 --> 00:07:46,010
message right so the the main the main

152
00:07:46,039 --> 00:07:54,090
workhorse component of the egg hunter is

153
00:07:50,240 --> 00:07:56,099
a loop you're looking at page boundaries

154
00:07:54,090 --> 00:07:59,010
now it may so happen that in your

155
00:07:56,099 --> 00:08:01,950
virtual memory space some pages may not

156
00:07:59,010 --> 00:08:04,409
be mapped so how do you get around it if

157
00:08:01,950 --> 00:08:06,810
you try to like load memory from that

158
00:08:04,410 --> 00:08:10,530
page you might sing for yourself so we

159
00:08:06,810 --> 00:08:12,960
can't test memory pages from user space

160
00:08:10,530 --> 00:08:15,000
virtual addresses you've got to go to

161
00:08:12,960 --> 00:08:18,539
the kernel to test the memory pages and

162
00:08:15,000 --> 00:08:21,120
the best way to do it is via Sisco so

163
00:08:18,539 --> 00:08:22,800
you choose a syscall which doesn't kill

164
00:08:21,120 --> 00:08:25,020
you don't choose exit or anything like

165
00:08:22,800 --> 00:08:26,789
that because your code will aim but if

166
00:08:25,020 --> 00:08:30,299
you choose a syscall which takes a

167
00:08:26,789 --> 00:08:32,939
memory pointer and performs some non

168
00:08:30,300 --> 00:08:35,010
destructive operation on it like check

169
00:08:32,940 --> 00:08:38,820
for access or check for permissions or

170
00:08:35,010 --> 00:08:40,799
something like that and if that memory

171
00:08:38,820 --> 00:08:42,900
page is valid the syscall will return

172
00:08:40,799 --> 00:08:45,569
you some value if it is not valid it

173
00:08:42,900 --> 00:08:47,850
will say ìno mem or some other error but

174
00:08:45,570 --> 00:08:49,770
it won't kill your code so every time

175
00:08:47,850 --> 00:08:52,170
you check a page boundary go make a cyst

176
00:08:49,770 --> 00:08:54,270
call if it is valid then scan through

177
00:08:52,170 --> 00:08:55,229
the page for the egg if not go to the

178
00:08:54,270 --> 00:08:56,939
next page boundaries

179
00:08:55,230 --> 00:09:00,690
can through the page and so on and so

180
00:08:56,940 --> 00:09:03,060
forth so this is how the this is how the

181
00:09:00,690 --> 00:09:05,640
whole egg hunter used to work by

182
00:09:03,060 --> 00:09:08,189
repeatedly checking each page boundary

183
00:09:05,640 --> 00:09:11,580
with a Cisco and there were choices of

184
00:09:08,190 --> 00:09:13,650
syscall spoon amanda escapes paper with

185
00:09:11,580 --> 00:09:16,800
when they were building the Metasploit

186
00:09:13,650 --> 00:09:18,870
2.0 framework they did a lot of work on

187
00:09:16,800 --> 00:09:21,240
shell code and published some excellent

188
00:09:18,870 --> 00:09:23,460
work so i am kind of standing on the

189
00:09:21,240 --> 00:09:25,860
shoulders of giants over here i have not

190
00:09:23,460 --> 00:09:27,840
really reinvented the egg hunter but

191
00:09:25,860 --> 00:09:29,580
kind of adapted it to modern day

192
00:09:27,840 --> 00:09:32,970
exploitation where i have run into

193
00:09:29,580 --> 00:09:37,440
limitations with exploiting are my OT

194
00:09:32,970 --> 00:09:40,080
hardware devices so the common problems

195
00:09:37,440 --> 00:09:41,520
with the egg hunter the first major

196
00:09:40,080 --> 00:09:45,330
common problem is data execution

197
00:09:41,520 --> 00:09:48,750
prevention like let's say you have your

198
00:09:45,330 --> 00:09:52,080
memory corruption layout where the egg

199
00:09:48,750 --> 00:09:55,380
hunter is on the stack memory and the

200
00:09:52,080 --> 00:09:57,480
real shell code is in the heap with data

201
00:09:55,380 --> 00:10:01,500
see different prevention both these

202
00:09:57,480 --> 00:10:07,280
memory regions are non-executable we

203
00:10:01,500 --> 00:10:11,340
have a solution for that the solution is

204
00:10:07,280 --> 00:10:13,230
rob chains we all know what rob chains

205
00:10:11,340 --> 00:10:15,920
know they're they're these magic trick

206
00:10:13,230 --> 00:10:18,420
stringy thingies and they will turn

207
00:10:15,920 --> 00:10:21,540
stack memory or any memory that you

208
00:10:18,420 --> 00:10:23,310
choose into executable memory I am NOT

209
00:10:21,540 --> 00:10:25,439
going to drive into I'm Rob chains over

210
00:10:23,310 --> 00:10:28,619
here I'll spare you the agony we will

211
00:10:25,440 --> 00:10:32,010
straight away go to the application of

212
00:10:28,620 --> 00:10:34,110
rock Rob chains but what Rob chains

213
00:10:32,010 --> 00:10:36,540
won't solve everything for us let us

214
00:10:34,110 --> 00:10:39,570
consider the same case where your code

215
00:10:36,540 --> 00:10:41,310
is split across two regions your memory

216
00:10:39,570 --> 00:10:43,590
corruption is in the stack your option

217
00:10:41,310 --> 00:10:46,699
is in the stack when you apply the Rob

218
00:10:43,590 --> 00:10:51,360
chain you need to be able to specify

219
00:10:46,700 --> 00:10:53,490
which memory region you want to rwx or

220
00:10:51,360 --> 00:10:56,130
you might allocate new memory and then

221
00:10:53,490 --> 00:10:58,230
copy the code over there for fancy stuff

222
00:10:56,130 --> 00:11:01,500
you need space but then we are out of

223
00:10:58,230 --> 00:11:05,960
space over here so we have to have some

224
00:11:01,500 --> 00:11:08,380
trick where even after the Rob chained

225
00:11:05,960 --> 00:11:11,920
the memory region

226
00:11:08,380 --> 00:11:15,040
where our shellcode resides must also be

227
00:11:11,920 --> 00:11:18,160
turned executable so if the Rob chained

228
00:11:15,040 --> 00:11:19,920
can help you apply our W X to the stack

229
00:11:18,160 --> 00:11:23,110
and your shellcode is in the heap

230
00:11:19,920 --> 00:11:26,130
somehow we also want the heap memory

231
00:11:23,110 --> 00:11:29,860
containing a shellcode to be executable

232
00:11:26,130 --> 00:11:33,070
for this I came up with a slightly

233
00:11:29,860 --> 00:11:34,680
clever trick at best calling it the M

234
00:11:33,070 --> 00:11:38,200
protect egg hunter

235
00:11:34,680 --> 00:11:40,060
the trick is really simple remember I

236
00:11:38,200 --> 00:11:42,850
told you about the syscall that is used

237
00:11:40,060 --> 00:11:45,040
to test the memory pages well this is

238
00:11:42,850 --> 00:11:47,380
the SIS called not only do you test the

239
00:11:45,040 --> 00:11:49,709
memory pages but if it exists RW exited

240
00:11:47,380 --> 00:11:52,630
everything so you kind of you know

241
00:11:49,710 --> 00:11:54,490
painting the memory pages as you go

242
00:11:52,630 --> 00:11:56,710
along and if you do it long enough a

243
00:11:54,490 --> 00:12:00,160
large part of your virtual address space

244
00:11:56,710 --> 00:12:04,180
might be just RW xed by the end of the

245
00:12:00,160 --> 00:12:10,500
shellcode so this is a quick little demo

246
00:12:04,180 --> 00:12:19,079
I will show you how this game works

247
00:12:10,500 --> 00:12:19,080
right my cheat sheet

248
00:12:37,950 --> 00:12:44,720
okay

249
00:12:40,550 --> 00:12:44,719
so I'll show you two

250
00:12:56,400 --> 00:12:59,240
Sorry Sorry

251
00:13:00,010 --> 00:13:09,730
I'll show you two demos let me push up

252
00:13:07,570 --> 00:13:11,940
the phones and see make it make it

253
00:13:09,730 --> 00:13:11,940
legible

254
00:13:22,680 --> 00:13:30,000
I have two programs over here to test

255
00:13:26,580 --> 00:13:32,370
the stuff there is the first demo

256
00:13:30,000 --> 00:13:34,530
program is called egg break and the

257
00:13:32,370 --> 00:13:41,280
other is called egg victim let me show

258
00:13:34,530 --> 00:13:44,180
the egg victim first so egg victim is

259
00:13:41,280 --> 00:13:48,120
actually a really simple simple stunt

260
00:13:44,180 --> 00:13:50,400
you have assimilated the shell code

261
00:13:48,120 --> 00:13:54,420
being loaded in the heap with some

262
00:13:50,400 --> 00:13:56,430
really really ugly string copy code just

263
00:13:54,420 --> 00:14:00,930
allocating a variable and loading the

264
00:13:56,430 --> 00:14:03,420
shell code and the egg over here is hack

265
00:14:00,930 --> 00:14:04,589
hack repeated twice can you read this

266
00:14:03,420 --> 00:14:06,630
all the way at the back or do you want

267
00:14:04,590 --> 00:14:08,670
me to push up the fonts a little more

268
00:14:06,630 --> 00:14:10,920
okay I can't see you all the way at the

269
00:14:08,670 --> 00:14:13,140
back you oh good oh good very good

270
00:14:10,920 --> 00:14:18,229
excellent it's just my eyesight is bad

271
00:14:13,140 --> 00:14:21,540
not yours and then here you have the

272
00:14:18,230 --> 00:14:25,640
here you have the classic stack overflow

273
00:14:21,540 --> 00:14:28,170
function so when we overflow this this

274
00:14:25,640 --> 00:14:29,189
code we're going to get memory

275
00:14:28,170 --> 00:14:31,229
corruption of the stack whether

276
00:14:29,190 --> 00:14:36,380
shellcode is in the heat and we need to

277
00:14:31,230 --> 00:14:46,140
do something to jump to the code right

278
00:14:36,380 --> 00:14:50,420
let me show you the first two the first

279
00:14:46,140 --> 00:14:50,420
two attempts

280
00:15:24,139 --> 00:15:29,069
so I have two attack vectors already

281
00:15:26,730 --> 00:15:35,100
loaded I will show you the attack script

282
00:15:29,069 --> 00:15:39,748
for the first one so the first one is

283
00:15:35,100 --> 00:15:43,769
your classic stack overflow because the

284
00:15:39,749 --> 00:15:46,679
memory is not executable we have to have

285
00:15:43,769 --> 00:15:50,579
a rope chain so here's my impro tech

286
00:15:46,679 --> 00:15:54,269
drop chain and once I also the buffer

287
00:15:50,579 --> 00:15:58,349
I will invoke em protect and after em

288
00:15:54,269 --> 00:16:00,889
protect I will then jump to the egg

289
00:15:58,350 --> 00:16:00,889
hunter

290
00:16:00,899 --> 00:16:06,179
the egg hunter will then go and find out

291
00:16:03,079 --> 00:16:08,729
the shellcode that exists in the heap it

292
00:16:06,179 --> 00:16:10,439
ends with this egg called hack this is

293
00:16:08,730 --> 00:16:12,660
what it's going to search and then once

294
00:16:10,439 --> 00:16:15,719
it finds it it's gonna transfer control

295
00:16:12,660 --> 00:16:19,679
to it so this is the attack that we're

296
00:16:15,720 --> 00:16:27,419
going to try out first let me show you

297
00:16:19,679 --> 00:16:29,850
the attack the other program that I'm

298
00:16:27,419 --> 00:16:32,600
gonna demo it on is called egg break

299
00:16:29,850 --> 00:16:34,889
which is basically the same

300
00:16:32,600 --> 00:16:39,299
vulnerability but instead of shell code

301
00:16:34,889 --> 00:16:41,730
I have got I got breakpoints loaded over

302
00:16:39,299 --> 00:16:50,459
here so we'll halt and we'll be able to

303
00:16:41,730 --> 00:16:56,999
check the memory okay I'm going to run

304
00:16:50,459 --> 00:17:03,779
this in the debugger first we will run

305
00:16:56,999 --> 00:17:10,139
this we just run this sake first classic

306
00:17:03,779 --> 00:17:12,148
overflow good enough you're going to

307
00:17:10,138 --> 00:17:15,418
crash it we're going to get control of

308
00:17:12,148 --> 00:17:19,918
the program counter we get control of

309
00:17:15,419 --> 00:17:27,449
the stack memory and if we look at the

310
00:17:19,919 --> 00:17:29,730
memory layout we notice that whoops if

311
00:17:27,449 --> 00:17:32,059
we look at the memory layout from the

312
00:17:29,730 --> 00:17:35,220
crash we notice that the stack is

313
00:17:32,059 --> 00:17:37,360
readwrite and the heap is readwrite

314
00:17:35,220 --> 00:17:41,440
there is no executable privileges

315
00:17:37,360 --> 00:17:43,570
given to us we control them we control

316
00:17:41,440 --> 00:17:46,090
the registers so yes we do have a

317
00:17:43,570 --> 00:17:48,340
program counter in our control now when

318
00:17:46,090 --> 00:17:50,350
we run the rob chain what we're going to

319
00:17:48,340 --> 00:17:52,870
see is the stack memory is going to

320
00:17:50,350 --> 00:17:55,230
become executable the heap will still

321
00:17:52,870 --> 00:17:59,110
not be executable because M protec just

322
00:17:55,230 --> 00:18:00,850
protects at one region and then we will

323
00:17:59,110 --> 00:18:02,919
invoke the egg hunter and see how the

324
00:18:00,850 --> 00:18:08,379
memory pages are marked executable and

325
00:18:02,920 --> 00:18:14,140
and we will will then move to the other

326
00:18:08,380 --> 00:18:24,520
demo so let me run this again this time

327
00:18:14,140 --> 00:18:29,710
with just the Rob chained so here I'm

328
00:18:24,520 --> 00:18:33,160
invoking the the the program with the

329
00:18:29,710 --> 00:18:35,680
Rob chained as a payload we still get a

330
00:18:33,160 --> 00:18:38,680
crash those of you in my class will

331
00:18:35,680 --> 00:18:41,590
recognize PC equal to 48 48 48 48 is my

332
00:18:38,680 --> 00:18:48,070
preferred crash point but at the moment

333
00:18:41,590 --> 00:18:50,230
if we look at the process memory we do

334
00:18:48,070 --> 00:18:54,490
notice that M protect has done its work

335
00:18:50,230 --> 00:18:56,380
and applied rwx to the stack so the

336
00:18:54,490 --> 00:19:00,040
stack is in our control thanks to the

337
00:18:56,380 --> 00:19:02,920
memory corruption bug the heap is not

338
00:19:00,040 --> 00:19:08,260
yet in our control like if you look at

339
00:19:02,920 --> 00:19:10,650
the heap if I dumped the memory at the

340
00:19:08,260 --> 00:19:10,650
heap

341
00:19:17,260 --> 00:19:24,740
so here's my here's my egg sitting in

342
00:19:21,740 --> 00:19:30,080
the heap this is the hack hack I will

343
00:19:24,740 --> 00:19:33,320
dump it as a string so here is the egg

344
00:19:30,080 --> 00:19:36,740
sitting over here at address 1 1 0 0 8

345
00:19:33,320 --> 00:19:39,889
and if I check the page permissions of

346
00:19:36,740 --> 00:19:41,809
that address it is still read right it

347
00:19:39,890 --> 00:19:46,340
is not executable so if you jump here

348
00:19:41,809 --> 00:19:53,750
you will spectacularly fail now let me

349
00:19:46,340 --> 00:19:55,189
show the egg Hunter code so here's the

350
00:19:53,750 --> 00:19:59,870
egg hunter shell code I'm going to be

351
00:19:55,190 --> 00:20:02,990
publishing it the 800 code right now is

352
00:19:59,870 --> 00:20:05,510
60 bytes long which is not ideally very

353
00:20:02,990 --> 00:20:07,549
compact but is as compact as it could

354
00:20:05,510 --> 00:20:10,280
make it with my limited knowledge of arm

355
00:20:07,549 --> 00:20:13,070
assembly but I'm sure there's some

356
00:20:10,280 --> 00:20:15,770
optimizations possible so here we start

357
00:20:13,070 --> 00:20:19,100
with the main loop we invoke the M

358
00:20:15,770 --> 00:20:21,860
protect sis call every time this is the

359
00:20:19,100 --> 00:20:24,949
page sizes and this is the rwx

360
00:20:21,860 --> 00:20:28,639
permissions and every time you invoke M

361
00:20:24,950 --> 00:20:31,160
protect if it fails with a no ma'am that

362
00:20:28,640 --> 00:20:34,730
means there is no page existing then you

363
00:20:31,160 --> 00:20:37,160
kind of subtract it subtract 12 from it

364
00:20:34,730 --> 00:20:39,950
go back to the loop increment it to the

365
00:20:37,160 --> 00:20:42,860
next address the moment you exit this is

366
00:20:39,950 --> 00:20:46,070
called loop you will be having a valid

367
00:20:42,860 --> 00:20:49,729
page and from this valid page onwards

368
00:20:46,070 --> 00:20:53,480
you can test whether the egg exists

369
00:20:49,730 --> 00:20:56,510
twice and if the egg exists twice then

370
00:20:53,480 --> 00:20:58,280
you simply jump to the code following

371
00:20:56,510 --> 00:21:00,080
the egg I am NOT going to go into the

372
00:20:58,280 --> 00:21:05,059
details of the arm assembly but that's

373
00:21:00,080 --> 00:21:08,750
at a high level what it does now we will

374
00:21:05,059 --> 00:21:11,260
switch over to let me look at the cheat

375
00:21:08,750 --> 00:21:11,260
sheet again

376
00:21:17,860 --> 00:21:29,270
so yeah now we're going to invoke the

377
00:21:25,360 --> 00:21:31,760
we're gonna invoke the egg Hunter chain

378
00:21:29,270 --> 00:21:35,270
not crash we're going to run egg break

379
00:21:31,760 --> 00:21:38,000
again if everything works we will get

380
00:21:35,270 --> 00:21:46,070
control to our shell code in the heap

381
00:21:38,000 --> 00:21:47,780
and halt at the breakpoints so we run

382
00:21:46,070 --> 00:21:50,600
the final shell code I mean the final

383
00:21:47,780 --> 00:21:53,178
egg Hunter code and notice that we are

384
00:21:50,600 --> 00:21:54,860
now crashing at these BK PT instructions

385
00:21:53,179 --> 00:21:58,130
these are the breakpoints that we have

386
00:21:54,860 --> 00:22:00,229
thrown in the contrast isn't very

387
00:21:58,130 --> 00:22:02,330
favorable on the projector but these two

388
00:22:00,230 --> 00:22:04,549
words that have highlighted they say

389
00:22:02,330 --> 00:22:07,399
these are the letters hak hak which is

390
00:22:04,549 --> 00:22:10,820
the egg so it went over there let me

391
00:22:07,400 --> 00:22:14,720
show you the memory first so if I do a

392
00:22:10,820 --> 00:22:17,059
if I do the attack string at one one

393
00:22:14,720 --> 00:22:18,919
zero zero eight this is the pointer to

394
00:22:17,059 --> 00:22:22,070
one one zero zero eight and we're

395
00:22:18,919 --> 00:22:24,470
crashing at one one zero one zero so the

396
00:22:22,070 --> 00:22:26,659
string at one one zero zero eight is

397
00:22:24,470 --> 00:22:32,000
here's your egg hack hack and this is

398
00:22:26,660 --> 00:22:35,030
the breakpoint sequence let's look at

399
00:22:32,000 --> 00:22:37,669
the memory privileges now here's what

400
00:22:35,030 --> 00:22:39,889
the egg hunter has done so after you

401
00:22:37,669 --> 00:22:42,080
execute the hunter from the stack it

402
00:22:39,890 --> 00:22:44,900
started at the top of the process memory

403
00:22:42,080 --> 00:22:47,389
and started painting all the pages rwx

404
00:22:44,900 --> 00:22:49,309
out of you excited of UX until it hit

405
00:22:47,390 --> 00:22:51,980
the heap by this time the heap is

406
00:22:49,309 --> 00:22:54,580
already executable now we can

407
00:22:51,980 --> 00:22:58,250
straightaway jump to our shell code and

408
00:22:54,580 --> 00:23:00,379
make it work so the last demo will be

409
00:22:58,250 --> 00:23:04,640
the same one with the real shell code

410
00:23:00,380 --> 00:23:07,210
exactly loaded into the heap and this

411
00:23:04,640 --> 00:23:07,210
should give us

412
00:23:15,760 --> 00:23:28,310
and you have a share okay so this is

413
00:23:25,880 --> 00:23:32,890
half a successful talk right the second

414
00:23:28,310 --> 00:23:32,889
half let's see how it goes all right

415
00:23:42,370 --> 00:23:49,520
the only few points about the egg hunter

416
00:23:46,640 --> 00:23:51,920
is it could have been a little shorter

417
00:23:49,520 --> 00:23:55,010
but I wanted to make sure that there are

418
00:23:51,920 --> 00:23:58,580
no null bites in the shell code and it

419
00:23:55,010 --> 00:24:02,420
should run as is without much without

420
00:23:58,580 --> 00:24:06,710
much modification again I will publish

421
00:24:02,420 --> 00:24:09,500
this code on github just after I get the

422
00:24:06,710 --> 00:24:11,120
slides and all working by the I mean by

423
00:24:09,500 --> 00:24:16,990
tomorrow you should have all the stuff

424
00:24:11,120 --> 00:24:23,389
and much better slides published okay so

425
00:24:16,990 --> 00:24:27,140
with that done let us talk about the

426
00:24:23,390 --> 00:24:32,570
polyglot stuff so here we saw the egg

427
00:24:27,140 --> 00:24:37,450
hunter work with this trick with M

428
00:24:32,570 --> 00:24:40,340
protect now let's look at the polyglot

429
00:24:37,450 --> 00:24:42,080
now before we get into the arm polyglot

430
00:24:40,340 --> 00:24:44,810
shellcode I want to preface this by

431
00:24:42,080 --> 00:24:47,689
saying this is not like polymorphic

432
00:24:44,810 --> 00:24:49,399
shellcode it's very different it's not

433
00:24:47,690 --> 00:24:51,350
like I'm transforming the shellcode

434
00:24:49,400 --> 00:24:53,450
arbitrarily to something else

435
00:24:51,350 --> 00:24:56,750
there is no steganography nothing of the

436
00:24:53,450 --> 00:24:59,390
sort going on but this is a polyglot

437
00:24:56,750 --> 00:25:02,660
this is a polyglot technique with

438
00:24:59,390 --> 00:25:04,220
instruction sets now a lot of work with

439
00:25:02,660 --> 00:25:06,050
polyglot instructions has been done

440
00:25:04,220 --> 00:25:09,290
before you can mix architectures like

441
00:25:06,050 --> 00:25:11,540
x86 and PowerPC and SPARC and all and

442
00:25:09,290 --> 00:25:16,790
there have been universal shell code

443
00:25:11,540 --> 00:25:19,490
starters code that runs on x86 on spar

444
00:25:16,790 --> 00:25:22,190
on PowerPC and automatically switches

445
00:25:19,490 --> 00:25:24,560
you to the architecture independent of

446
00:25:22,190 --> 00:25:26,840
prior knowledge of what your targets

447
00:25:24,560 --> 00:25:27,270
gonna be this trick is somewhat like

448
00:25:26,840 --> 00:25:29,520
that

449
00:25:27,270 --> 00:25:35,070
but it's a it's a polyglot with in arm

450
00:25:29,520 --> 00:25:36,360
itself now one of one of the common

451
00:25:35,070 --> 00:25:38,669
things you're going to do as a shellcode

452
00:25:36,360 --> 00:25:42,540
writer whenever you're dealing with a

453
00:25:38,670 --> 00:25:45,150
shellcode is remember that arm always

454
00:25:42,540 --> 00:25:49,620
has fixed with instructions 32 bits in

455
00:25:45,150 --> 00:25:53,790
our mode but arm also has a smaller

456
00:25:49,620 --> 00:25:57,000
subset of popularly known instruct used

457
00:25:53,790 --> 00:25:59,670
instructions called the thumb mode where

458
00:25:57,000 --> 00:26:03,060
a thumb is half the size of the arm not

459
00:25:59,670 --> 00:26:05,220
really my thumb is much smaller but if I

460
00:26:03,060 --> 00:26:08,820
had a very short time then thumb is the

461
00:26:05,220 --> 00:26:11,130
size the half the size of that right I'm

462
00:26:08,820 --> 00:26:16,379
sorry I just have jokes too a few not

463
00:26:11,130 --> 00:26:19,650
proper slides so one of the things we

464
00:26:16,380 --> 00:26:21,570
want as a shell co-author to do is we

465
00:26:19,650 --> 00:26:25,140
want to write the shell code and compact

466
00:26:21,570 --> 00:26:29,070
thumb mode for two purposes a it saves

467
00:26:25,140 --> 00:26:31,080
size it's compact B we're free of bad

468
00:26:29,070 --> 00:26:33,240
characters we don't have null bytes you

469
00:26:31,080 --> 00:26:37,710
don't have problematic things tripping

470
00:26:33,240 --> 00:26:39,270
us up and the commonly is known of the

471
00:26:37,710 --> 00:26:41,670
commonly used instructions are still

472
00:26:39,270 --> 00:26:44,639
available in thumb mode and that helps

473
00:26:41,670 --> 00:26:46,860
us a lot so when you write shell code

474
00:26:44,640 --> 00:26:48,990
the first thing you want to do is you

475
00:26:46,860 --> 00:26:51,330
want to switch from arm mode to thumb

476
00:26:48,990 --> 00:26:54,000
mode and this is usually a to buy trick

477
00:26:51,330 --> 00:26:55,949
you add r1 equal to PC plus one branch

478
00:26:54,000 --> 00:26:57,510
to r1 boom you are in thumb mode and

479
00:26:55,950 --> 00:27:01,290
then the rest of the shell code follows

480
00:26:57,510 --> 00:27:03,900
the thumb mode so this is what I'd been

481
00:27:01,290 --> 00:27:06,030
teaching in class and sure enough three

482
00:27:03,900 --> 00:27:08,460
years of teaching in class somebody is

483
00:27:06,030 --> 00:27:11,399
gonna pipe up right right oh wait but I

484
00:27:08,460 --> 00:27:14,310
can signature this the moment I hear the

485
00:27:11,400 --> 00:27:18,750
word IDs or signatures and any any crap

486
00:27:14,310 --> 00:27:20,700
like that I go deaf and I go mad like

487
00:27:18,750 --> 00:27:23,580
this is ridiculous like we are doing

488
00:27:20,700 --> 00:27:25,620
InfoSec for 20 years and all we depend

489
00:27:23,580 --> 00:27:28,139
upon his very signatures and updates for

490
00:27:25,620 --> 00:27:31,260
security something fundamentally wrong

491
00:27:28,140 --> 00:27:33,600
here anyway I will not get into my rant

492
00:27:31,260 --> 00:27:36,180
about signatures but whenever I see

493
00:27:33,600 --> 00:27:39,120
signatures I am really motivated to

494
00:27:36,180 --> 00:27:40,710
defeat them and not defeat them by just

495
00:27:39,120 --> 00:27:42,570
obvious creating it I am going to

496
00:27:40,710 --> 00:27:45,630
you feed them in style with a technique

497
00:27:42,570 --> 00:27:48,750
that okay like yeah signature this here

498
00:27:45,630 --> 00:27:50,970
here's a whole new class of approach and

499
00:27:48,750 --> 00:27:53,309
good luck so exhilarating this that was

500
00:27:50,970 --> 00:27:55,830
my motivation for stable sploit yeah I'm

501
00:27:53,309 --> 00:27:58,049
going to put JavaScript attacks as

502
00:27:55,830 --> 00:28:00,389
pixels on an image now tell me whether

503
00:27:58,049 --> 00:28:02,760
this code is bad or good you know all

504
00:28:00,390 --> 00:28:04,559
this technology depends upon is trying

505
00:28:02,760 --> 00:28:06,779
to figure out the intent behind a piece

506
00:28:04,559 --> 00:28:08,730
of data is it going to do bad or is

507
00:28:06,779 --> 00:28:11,940
it able to do good now if I

508
00:28:08,730 --> 00:28:15,149
transform the bad stuff into what looks

509
00:28:11,940 --> 00:28:17,039
really good then you can't tell good and

510
00:28:15,149 --> 00:28:19,139
bad apart and that's that's why all

511
00:28:17,039 --> 00:28:22,860
these technologies fail so somebody

512
00:28:19,140 --> 00:28:24,750
wrote yarra rules to detect this arm

513
00:28:22,860 --> 00:28:26,340
thumb switch and catch him so of course

514
00:28:24,750 --> 00:28:31,169
you have to go one up I have to go one

515
00:28:26,340 --> 00:28:33,570
up so I I i did this technique the

516
00:28:31,169 --> 00:28:35,460
second case was pointed to me by travis

517
00:28:33,570 --> 00:28:37,439
Goodspeed that and sure enough there are

518
00:28:35,460 --> 00:28:39,870
some processors especially cortex-m

519
00:28:37,440 --> 00:28:42,899
processors which are pure thumb

520
00:28:39,870 --> 00:28:46,469
processors so if i have a vulnerability

521
00:28:42,899 --> 00:28:48,270
and i don't know which processor it's

522
00:28:46,470 --> 00:28:50,159
running on it's running on an ARM

523
00:28:48,270 --> 00:28:52,679
processor or it's running on a thumb

524
00:28:50,159 --> 00:28:55,860
only processor i should be able to hit

525
00:28:52,679 --> 00:29:01,590
it with the same shellcode which means

526
00:28:55,860 --> 00:29:05,189
that you have one shell code which can

527
00:29:01,590 --> 00:29:07,860
run the same way whether it started in

528
00:29:05,190 --> 00:29:10,380
arm mode or whether it started in thumb

529
00:29:07,860 --> 00:29:15,389
mode and this is where the polyglot

530
00:29:10,380 --> 00:29:20,520
stunt comes in handy we will have a

531
00:29:15,390 --> 00:29:22,500
series of instructions which will end up

532
00:29:20,520 --> 00:29:24,870
landing you into thumb mode and then you

533
00:29:22,500 --> 00:29:26,610
can put your regular shellcode at the

534
00:29:24,870 --> 00:29:27,600
end of it thumb mode is the least common

535
00:29:26,610 --> 00:29:29,729
denominator

536
00:29:27,600 --> 00:29:33,090
every ARM processor will switch to thumb

537
00:29:29,730 --> 00:29:35,520
but if it's an m' cortex-m then there's

538
00:29:33,090 --> 00:29:37,379
only thumb mode available and another

539
00:29:35,520 --> 00:29:40,370
goal for me was to write it for the

540
00:29:37,380 --> 00:29:43,169
lowest common denominator of

541
00:29:40,370 --> 00:29:45,330
architecture so no thumb to no wide

542
00:29:43,169 --> 00:29:48,299
thumbs thumb to is like 32-bit thumb

543
00:29:45,330 --> 00:29:53,199
mode is kind of counter intuitive it's

544
00:29:48,299 --> 00:29:56,470
like two thumbs 16 plus 16 so

545
00:29:53,200 --> 00:30:00,070
I started the research on this purely

546
00:29:56,470 --> 00:30:02,409
upon impulse and intuition and then of

547
00:30:00,070 --> 00:30:06,689
course it takes you then have to involve

548
00:30:02,409 --> 00:30:09,429
some background knowledge of

549
00:30:06,690 --> 00:30:12,639
instructions and such and a little bit

550
00:30:09,429 --> 00:30:15,330
of lateral thinking and this with this I

551
00:30:12,639 --> 00:30:17,709
will present to you my techniques on

552
00:30:15,330 --> 00:30:18,129
universal mode half time thank you very

553
00:30:17,710 --> 00:30:23,139
much

554
00:30:18,130 --> 00:30:24,639
Universal Mode shellcode so basically

555
00:30:23,139 --> 00:30:27,820
what the universal mode shellcode will

556
00:30:24,639 --> 00:30:31,629
do is no matter how you start it it will

557
00:30:27,820 --> 00:30:33,870
always land up in some mode it's like a

558
00:30:31,630 --> 00:30:38,110
cat you throw it from the roof it lands

559
00:30:33,870 --> 00:30:40,059
feet feet down I should come up with a

560
00:30:38,110 --> 00:30:42,340
nice name maybe you can choose a name

561
00:30:40,059 --> 00:30:45,399
for me and tweet it out I will adopt it

562
00:30:42,340 --> 00:30:47,080
before a publisher to github so the rest

563
00:30:45,399 --> 00:30:48,850
of the shell code is simple you can like

564
00:30:47,080 --> 00:30:50,500
at the end of this series of

565
00:30:48,850 --> 00:30:52,600
instructions you can tack on whatever

566
00:30:50,500 --> 00:30:57,570
you want reverse shell exactly shell

567
00:30:52,600 --> 00:31:03,189
whatever it is so I have a demo on this

568
00:30:57,570 --> 00:31:05,710
I will show you the the construction of

569
00:31:03,190 --> 00:31:08,590
the polyglot code for which I had all

570
00:31:05,710 --> 00:31:14,230
the arm encoding slides which you know

571
00:31:08,590 --> 00:31:18,959
where they are now gone burned but here

572
00:31:14,230 --> 00:31:22,480
so what we need for the polyglot code is

573
00:31:18,960 --> 00:31:27,580
first we need a very deep understanding

574
00:31:22,480 --> 00:31:31,809
of how instruction encoding works on arm

575
00:31:27,580 --> 00:31:35,830
and thumb mode fortunately these are

576
00:31:31,809 --> 00:31:40,269
fixed with instructions arm is 32 bits

577
00:31:35,830 --> 00:31:42,580
thumb is 16 bits a single arm

578
00:31:40,269 --> 00:31:46,960
instruction can therefore be split into

579
00:31:42,580 --> 00:31:50,379
two thumb instructions now we need to be

580
00:31:46,960 --> 00:31:53,710
able to choose carefully what these what

581
00:31:50,380 --> 00:31:58,059
the 32 bit value is which results into

582
00:31:53,710 --> 00:31:58,750
two non-destructive thump instructions

583
00:31:58,059 --> 00:32:02,279
for us

584
00:31:58,750 --> 00:32:04,340
they shouldn't trip up our shellcode

585
00:32:02,279 --> 00:32:07,450
what do we consider

586
00:32:04,340 --> 00:32:09,889
destructive branches are destructive

587
00:32:07,450 --> 00:32:11,240
loading from the memory is destructive

588
00:32:09,890 --> 00:32:12,919
if you don't know the register you

589
00:32:11,240 --> 00:32:14,870
loading from you might say fold yourself

590
00:32:12,919 --> 00:32:20,600
writing back to the memory is

591
00:32:14,870 --> 00:32:22,489
destructive some push pops not push

592
00:32:20,600 --> 00:32:25,010
pause but load multiple store multiples

593
00:32:22,490 --> 00:32:28,940
can be destructive so we want to avoid

594
00:32:25,010 --> 00:32:32,440
all of those and then use only a few

595
00:32:28,940 --> 00:32:37,159
thumb instructions to do the job for us

596
00:32:32,440 --> 00:32:39,710
the benefit that our mode gives you

597
00:32:37,159 --> 00:32:43,659
which is often overlooked in shellcode

598
00:32:39,710 --> 00:32:46,669
is the power of conditional instructions

599
00:32:43,659 --> 00:32:49,220
every armed instruction the first the

600
00:32:46,669 --> 00:32:53,299
most significant four bits of an armed

601
00:32:49,220 --> 00:32:58,309
instruction are conditional flags and if

602
00:32:53,299 --> 00:33:00,860
a condition exists you can trigger the

603
00:32:58,309 --> 00:33:03,020
instruction if the condition does not

604
00:33:00,860 --> 00:33:06,649
exist the instruction becomes a lot and

605
00:33:03,020 --> 00:33:08,000
simply falls through so what we want to

606
00:33:06,649 --> 00:33:10,789
do is we want to lay out a series of

607
00:33:08,000 --> 00:33:13,010
steps which will execute or fall through

608
00:33:10,789 --> 00:33:15,140
depending upon instructions in our mode

609
00:33:13,010 --> 00:33:17,149
but then when you cut them all up as

610
00:33:15,140 --> 00:33:20,240
thumb mode they just fall through all of

611
00:33:17,149 --> 00:33:23,209
them without disturbing us and it's it's

612
00:33:20,240 --> 00:33:27,080
a it's a nice exercise which requires

613
00:33:23,210 --> 00:33:32,450
luck and perseverance with this let me

614
00:33:27,080 --> 00:33:36,110
give you the demo now large part of this

615
00:33:32,450 --> 00:33:43,779
demo is going to be with notepad and I'm

616
00:33:36,110 --> 00:33:48,610
sorry about that again I follow J's okay

617
00:33:43,779 --> 00:33:54,679
so let's start with really really simple

618
00:33:48,610 --> 00:34:01,209
shell code we'll do like an armed thumb

619
00:33:54,679 --> 00:34:04,850
switch which is the basically the most

620
00:34:01,210 --> 00:34:07,700
simplest of them all so here is code to

621
00:34:04,850 --> 00:34:12,799
do an armed thumb switch and we push it

622
00:34:07,700 --> 00:34:14,899
up a bit to make it clear this is

623
00:34:12,800 --> 00:34:17,570
whenever you start your code let's say

624
00:34:14,899 --> 00:34:20,270
you're starting in arm mode this

625
00:34:17,570 --> 00:34:23,780
- these two instructions will switch you

626
00:34:20,270 --> 00:34:27,050
to thumb mode and then these

627
00:34:23,780 --> 00:34:28,550
instructions I haven't really added real

628
00:34:27,050 --> 00:34:31,280
shellcode at the end of it but I'm just

629
00:34:28,550 --> 00:34:33,200
setting our seven equal to eleven just

630
00:34:31,280 --> 00:34:35,419
as a proof of concept and then breaking

631
00:34:33,199 --> 00:34:43,939
so at the end of this code execution

632
00:34:35,418 --> 00:35:00,170
you'll get our seven equals eleven now

633
00:34:43,940 --> 00:35:04,300
let's see how this works I'm going to

634
00:35:00,170 --> 00:35:04,300
single step through these instructions

635
00:35:05,980 --> 00:35:10,640
so here are your instructions you have

636
00:35:08,660 --> 00:35:16,089
the arm to thumb switch and the rest of

637
00:35:10,640 --> 00:35:19,940
it is in thumb mode if we single step

638
00:35:16,090 --> 00:35:23,120
the first notice that our mode of

639
00:35:19,940 --> 00:35:27,110
execution is our mode the thumb flag is

640
00:35:23,120 --> 00:35:29,630
off the second one the moment we do the

641
00:35:27,110 --> 00:35:31,670
second one our thumb flag becomes on so

642
00:35:29,630 --> 00:35:34,580
the switch has happened and now you'll

643
00:35:31,670 --> 00:35:41,060
move seven into you move eleven into our

644
00:35:34,580 --> 00:35:45,710
seven and crash so the end your crash

645
00:35:41,060 --> 00:35:51,740
has our seven equal to 11 this is the

646
00:35:45,710 --> 00:36:00,020
regular version all right now let's see

647
00:35:51,740 --> 00:36:05,080
what happens when we when we object dump

648
00:36:00,020 --> 00:36:09,680
this so I'm going to object dump

649
00:36:05,080 --> 00:36:14,400
disassemble this code into both arm and

650
00:36:09,680 --> 00:36:16,710
thumb mode so

651
00:36:14,400 --> 00:36:18,990
the arm mode I mean this is the regular

652
00:36:16,710 --> 00:36:21,960
disassembly where you see the switch and

653
00:36:18,990 --> 00:36:27,660
it goes on if I force disassemble this

654
00:36:21,960 --> 00:36:31,290
in thumb mode supposing the processor

655
00:36:27,660 --> 00:36:36,960
started in thumb mode then you see how

656
00:36:31,290 --> 00:36:39,630
this 32 bit value e 2 8 F 1 0 0 1 now

657
00:36:36,960 --> 00:36:43,380
becomes 2 thumb instructions right over

658
00:36:39,630 --> 00:36:45,780
here the first thumb instruction is kind

659
00:36:43,380 --> 00:36:48,180
of okay it shifts the register doesn't

660
00:36:45,780 --> 00:36:50,760
kill us the second one is a branch

661
00:36:48,180 --> 00:36:53,970
that's going to ruin you the third one

662
00:36:50,760 --> 00:36:59,160
over here so this BX instruction becomes

663
00:36:53,970 --> 00:37:00,779
a monster it becomes like this vector

664
00:36:59,160 --> 00:37:01,529
floating point instruction there's this

665
00:37:00,780 --> 00:37:04,320
gonna kill us

666
00:37:01,530 --> 00:37:09,690
all the BX instructions if we look at

667
00:37:04,320 --> 00:37:12,630
the encoding have the second operand all

668
00:37:09,690 --> 00:37:16,620
bits are set to high so this is always

669
00:37:12,630 --> 00:37:19,740
BFF and if you now cut this word up into

670
00:37:16,620 --> 00:37:21,600
thumb mode then all instructions FF

671
00:37:19,740 --> 00:37:23,279
becomes something number two or

672
00:37:21,600 --> 00:37:26,250
something crazy or something that'll

673
00:37:23,280 --> 00:37:27,540
kill us so now as you as you play with

674
00:37:26,250 --> 00:37:29,160
these instructions you're going to see

675
00:37:27,540 --> 00:37:32,100
some restrictions being applied on

676
00:37:29,160 --> 00:37:34,560
certain bit fields and we then go to

677
00:37:32,100 --> 00:37:36,440
choose these bit fields carefully if I

678
00:37:34,560 --> 00:37:43,500
run this in thumb mode it's going to die

679
00:37:36,440 --> 00:37:47,430
so I do I do one test case and I will

680
00:37:43,500 --> 00:37:55,050
show you what this test case is the test

681
00:37:47,430 --> 00:37:58,200
case is Universal mode 1 dot this now

682
00:37:55,050 --> 00:38:01,560
instead of two instructions ad + BX have

683
00:37:58,200 --> 00:38:04,970
turned them into four instructions so

684
00:38:01,560 --> 00:38:08,340
now I want to use the conditional bits

685
00:38:04,970 --> 00:38:10,410
the top 16 bits should be a valid thumb

686
00:38:08,340 --> 00:38:12,990
instruction the bottom 16 bits should be

687
00:38:10,410 --> 00:38:14,549
a valid thumb instruction the top 16

688
00:38:12,990 --> 00:38:16,649
bits in an arm instruction are

689
00:38:14,550 --> 00:38:18,720
conditional bits and the opcode the

690
00:38:16,650 --> 00:38:21,060
bottom 16 bits are registers and

691
00:38:18,720 --> 00:38:23,100
operands I can choose the registers and

692
00:38:21,060 --> 00:38:23,759
operands easily but the opcodes are kind

693
00:38:23,100 --> 00:38:26,040
of tricky

694
00:38:23,760 --> 00:38:27,360
I need the opcode so I'm going to use

695
00:38:26,040 --> 00:38:30,060
the condition bits

696
00:38:27,360 --> 00:38:33,570
to tweak the top four bits to be able to

697
00:38:30,060 --> 00:38:35,820
get a valid instruction so and I'm using

698
00:38:33,570 --> 00:38:38,430
a pair of instructions the conditions

699
00:38:35,820 --> 00:38:40,650
are now complimentary so if you see that

700
00:38:38,430 --> 00:38:43,080
ad has now become an ad if not equals

701
00:38:40,650 --> 00:38:44,940
and a diffi quills one of them is always

702
00:38:43,080 --> 00:38:45,810
going to trigger no matter what the

703
00:38:44,940 --> 00:38:48,420
condition is

704
00:38:45,810 --> 00:38:51,779
and the second one the branch became

705
00:38:48,420 --> 00:38:54,510
move pc comma r1 move if not equals and

706
00:38:51,780 --> 00:38:56,070
move if equals again one of them is

707
00:38:54,510 --> 00:38:58,950
always going to trigger so it's either

708
00:38:56,070 --> 00:39:01,410
going to be AC or BD in terms of

709
00:38:58,950 --> 00:39:05,000
execution or what the conditions have

710
00:39:01,410 --> 00:39:07,980
done is it's given me the power to craft

711
00:39:05,000 --> 00:39:11,420
two valid AM instructions with these

712
00:39:07,980 --> 00:39:22,530
bits let me show you how this works so

713
00:39:11,420 --> 00:39:26,310
I'm going to object dump this normally

714
00:39:22,530 --> 00:39:28,920
this is in regular arm mode so here are

715
00:39:26,310 --> 00:39:41,279
four arm instructions and when we object

716
00:39:28,920 --> 00:39:44,460
dump this in thumb mode yeah when we

717
00:39:41,280 --> 00:39:47,150
object on this in thumb mode I will draw

718
00:39:44,460 --> 00:39:47,150
parallels

719
00:40:04,710 --> 00:40:11,650
so here's the object dump in armoire on

720
00:40:09,430 --> 00:40:16,930
this side so this single instruction

721
00:40:11,650 --> 00:40:21,220
here has now become these two

722
00:40:16,930 --> 00:40:23,290
instructions over here so the add

723
00:40:21,220 --> 00:40:25,270
instruction the add not equals now

724
00:40:23,290 --> 00:40:29,320
becomes two arithmetic shift right

725
00:40:25,270 --> 00:40:32,650
instructions the second add instruction

726
00:40:29,320 --> 00:40:37,540
becomes an arithmetic shift right and a

727
00:40:32,650 --> 00:40:41,440
logical shift left this is achieved by

728
00:40:37,540 --> 00:40:44,710
tweaking these highlighted bytes thanks

729
00:40:41,440 --> 00:40:47,320
to the conditional execution the problem

730
00:40:44,710 --> 00:40:49,090
is with these move instructions we still

731
00:40:47,320 --> 00:40:50,710
have I mean these are valid

732
00:40:49,090 --> 00:40:52,810
thump instructions but these are thumb

733
00:40:50,710 --> 00:40:54,820
two instructions these are wide and

734
00:40:52,810 --> 00:40:56,770
instruction I don't want thumb two

735
00:40:54,820 --> 00:40:59,530
because then that restricts me only to

736
00:40:56,770 --> 00:41:04,410
our mv7 so let me show you how the

737
00:40:59,530 --> 00:41:13,240
encoding goes this is this is where the

738
00:41:04,410 --> 00:41:16,990
slides would have greatly helped so

739
00:41:13,240 --> 00:41:21,370
here's the encoding if you if you look

740
00:41:16,990 --> 00:41:22,810
at this add instruction it splits up

741
00:41:21,370 --> 00:41:26,470
into the first four bytes our

742
00:41:22,810 --> 00:41:33,490
conditional flags then the immediate

743
00:41:26,470 --> 00:41:36,910
mode is 0 0 1 then the add part is from

744
00:41:33,490 --> 00:41:42,430
this 0 1 0 0 that decodes to add the S

745
00:41:36,910 --> 00:41:46,149
is the status update RS is the source

746
00:41:42,430 --> 00:41:48,069
register so source register is hex is 16

747
00:41:46,150 --> 00:41:50,350
which is a program counter the

748
00:41:48,070 --> 00:41:53,260
destination register is 1 which is our 1

749
00:41:50,350 --> 00:41:56,950
and this is the operand which is decimal

750
00:41:53,260 --> 00:41:58,480
9 now this same instruction the single

751
00:41:56,950 --> 00:42:01,810
instruction when you split it into two

752
00:41:58,480 --> 00:42:10,960
thumbs you have an arithmetic shift

753
00:42:01,810 --> 00:42:13,930
right so these these bits these 0 0 1 0

754
00:42:10,960 --> 00:42:16,540
0 that are highlighted they become the

755
00:42:13,930 --> 00:42:17,589
first 5 bits of the second instruction

756
00:42:16,540 --> 00:42:20,680
which is arithmetic

757
00:42:17,590 --> 00:42:24,540
shift right then this is like a full

758
00:42:20,680 --> 00:42:27,250
shift 32 bits so it's equivalent to zero

759
00:42:24,540 --> 00:42:31,420
the disassembler shows you 32 for some

760
00:42:27,250 --> 00:42:35,140
reason and this is a shift our one with

761
00:42:31,420 --> 00:42:37,750
our one itself so this one zero zero

762
00:42:35,140 --> 00:42:42,160
nine becomes an arithmetic shift right

763
00:42:37,750 --> 00:42:45,790
instruction the other one the one two 8f

764
00:42:42,160 --> 00:42:48,670
the top half of this instruction up to

765
00:42:45,790 --> 00:42:52,000
here that becomes another arithmetic

766
00:42:48,670 --> 00:42:53,230
shift right instruction down there so

767
00:42:52,000 --> 00:42:55,960
this is how you're going to cleverly

768
00:42:53,230 --> 00:42:58,900
split it by controlling the condition

769
00:42:55,960 --> 00:43:01,600
bits and the registers to be able to get

770
00:42:58,900 --> 00:43:03,010
you to valid thumb instructions they

771
00:43:01,600 --> 00:43:04,900
will mock up the registers but they

772
00:43:03,010 --> 00:43:07,000
won't destroy the code execution you

773
00:43:04,900 --> 00:43:09,880
want to lose something let's lose a

774
00:43:07,000 --> 00:43:12,180
registers value that's okay and the

775
00:43:09,880 --> 00:43:17,200
other one also becomes into two thumbs

776
00:43:12,180 --> 00:43:20,350
similarly so then I kind of went ahead

777
00:43:17,200 --> 00:43:22,720
with my wits with some more choices this

778
00:43:20,350 --> 00:43:26,670
is going to give you this demo bit over

779
00:43:22,720 --> 00:43:28,540
here so then you can try and play with

780
00:43:26,670 --> 00:43:35,800
you can try and play with different

781
00:43:28,540 --> 00:43:38,110
conditionals so I have ad CS and add CC

782
00:43:35,800 --> 00:43:40,090
so Kerry said Kerry clear move Kerry

783
00:43:38,110 --> 00:43:43,300
said Kerry clear so each of these

784
00:43:40,090 --> 00:43:45,460
conditional Flags these are 60 these are

785
00:43:43,300 --> 00:43:48,250
four bits so they can they can have 16

786
00:43:45,460 --> 00:43:51,720
possible values and they will result in

787
00:43:48,250 --> 00:43:55,600
two different one so I kept on trying

788
00:43:51,720 --> 00:43:58,299
the first ones become end and the moves

789
00:43:55,600 --> 00:44:01,410
also become NW I was trying to get rid

790
00:43:58,300 --> 00:44:05,260
of this this high F over here and

791
00:44:01,410 --> 00:44:06,690
finally I have Universal mode 3 which is

792
00:44:05,260 --> 00:44:09,870
the winner

793
00:44:06,690 --> 00:44:14,650
basically this end W will work as well

794
00:44:09,870 --> 00:44:15,910
except that this will run only on arm v7

795
00:44:14,650 --> 00:44:18,640
architectures this is non-destructive

796
00:44:15,910 --> 00:44:22,180
this works quite well if you want to go

797
00:44:18,640 --> 00:44:28,089
to on v6 or below then we cannot afford

798
00:44:22,180 --> 00:44:30,790
to have wide thumb instructions and this

799
00:44:28,090 --> 00:44:31,510
brings me to the last iteration of the

800
00:44:30,790 --> 00:44:37,350
universe

801
00:44:31,510 --> 00:44:47,940
shell called stub which is universal mod

802
00:44:37,350 --> 00:44:52,810
3 so here I could not do the branch by

803
00:44:47,940 --> 00:44:57,280
move PC comma some register so I had to

804
00:44:52,810 --> 00:45:00,430
literally pull push a register and pop

805
00:44:57,280 --> 00:45:03,280
it back into the program counter so the

806
00:45:00,430 --> 00:45:08,049
register I'm using is r4 which will hold

807
00:45:03,280 --> 00:45:09,970
the next PC relative address our 4 is

808
00:45:08,050 --> 00:45:13,270
being pushed on the stack and being

809
00:45:09,970 --> 00:45:15,100
popped into program counter now in our

810
00:45:13,270 --> 00:45:17,950
mode you have something called a

811
00:45:15,100 --> 00:45:20,799
register list this curly braces thingy

812
00:45:17,950 --> 00:45:22,930
is a bit field containing which

813
00:45:20,800 --> 00:45:25,540
registers are to be pushed or popped and

814
00:45:22,930 --> 00:45:27,580
this is the last 16 bits of the

815
00:45:25,540 --> 00:45:30,250
instruction so we have to choose

816
00:45:27,580 --> 00:45:34,120
registers so that there are no null

817
00:45:30,250 --> 00:45:36,550
bytes and they they don't conflict with

818
00:45:34,120 --> 00:45:38,410
us the order of the registers is also

819
00:45:36,550 --> 00:45:41,350
important you can only have registers

820
00:45:38,410 --> 00:45:43,480
which are numerically increasing so with

821
00:45:41,350 --> 00:45:45,700
a lot of tweaking I figured out that I

822
00:45:43,480 --> 00:45:47,530
can push four values on the stack but

823
00:45:45,700 --> 00:45:49,930
pop only three and that's good enough

824
00:45:47,530 --> 00:45:52,390
and this is somehow if I pop the fourth

825
00:45:49,930 --> 00:45:55,060
one then I got instructions which are

826
00:45:52,390 --> 00:45:58,509
not very happy in thumb mode so this is

827
00:45:55,060 --> 00:46:00,910
a lot of back-and-forth going on had to

828
00:45:58,510 --> 00:46:02,980
play around with it so you have add you

829
00:46:00,910 --> 00:46:05,140
have the move so I transfer the stack

830
00:46:02,980 --> 00:46:06,790
pointer into r3 because I got to restore

831
00:46:05,140 --> 00:46:09,490
it back otherwise my stack is going to

832
00:46:06,790 --> 00:46:11,350
be completely screwed and then I push

833
00:46:09,490 --> 00:46:14,770
the r3 and restore it back into the

834
00:46:11,350 --> 00:46:16,240
stack push the r4 restore it into PC and

835
00:46:14,770 --> 00:46:18,430
again you have these complimentary

836
00:46:16,240 --> 00:46:21,490
conditions so again you have one three

837
00:46:18,430 --> 00:46:23,470
five or two four or six happening this

838
00:46:21,490 --> 00:46:25,839
is going to drop you into thumb mode no

839
00:46:23,470 --> 00:46:29,500
matter what the architecture is and no

840
00:46:25,840 --> 00:46:31,180
matter what mode you're starting in let

841
00:46:29,500 --> 00:46:33,100
me show you the object dump then I will

842
00:46:31,180 --> 00:46:36,669
have a small demo to prove that this

843
00:46:33,100 --> 00:46:42,580
stunt works and then hopefully I survive

844
00:46:36,670 --> 00:46:48,400
this talk as

845
00:46:42,580 --> 00:46:51,930
oh wait yes did I do the whole thing

846
00:46:48,400 --> 00:46:56,350
with that thing in the middle yes I did

847
00:46:51,930 --> 00:47:09,299
nurse so I'll walk you through the

848
00:46:56,350 --> 00:47:16,420
object dump in our mode so here's your

849
00:47:09,300 --> 00:47:18,970
stub in our mode so our four is program

850
00:47:16,420 --> 00:47:21,910
counter plus relative offset our three

851
00:47:18,970 --> 00:47:24,370
stack pointer then you push them and pop

852
00:47:21,910 --> 00:47:28,000
them back into our push our three or

853
00:47:24,370 --> 00:47:31,390
four pop them into SPP see I had to have

854
00:47:28,000 --> 00:47:34,750
r1 + r8 to avoid null bytes in the

855
00:47:31,390 --> 00:47:37,120
resulting thump instructions and at the

856
00:47:34,750 --> 00:47:39,280
end of this you should be into thumb

857
00:47:37,120 --> 00:47:44,970
mode and this code should execute

858
00:47:39,280 --> 00:47:44,970
normally let me force disassemble this

859
00:47:52,310 --> 00:47:57,430
we force disassemble this into thumb

860
00:47:54,080 --> 00:48:00,460
mode if you go to thumb mode it looks

861
00:47:57,430 --> 00:48:00,460
quite different

862
00:48:04,060 --> 00:48:10,940
so in thumb mode a single add

863
00:48:07,550 --> 00:48:14,300
instruction over here is now transformed

864
00:48:10,940 --> 00:48:17,150
into and and add then the next one is

865
00:48:14,300 --> 00:48:20,720
also hand and move the third one is to

866
00:48:17,150 --> 00:48:22,490
adds the the fourth one now becomes add

867
00:48:20,720 --> 00:48:30,529
and move the fifth one

868
00:48:22,490 --> 00:48:35,569
so the pushes become LS LS and subs I

869
00:48:30,530 --> 00:48:45,980
also have the the encoding for the

870
00:48:35,570 --> 00:48:49,520
pushes that I'm going to show you so

871
00:48:45,980 --> 00:48:55,370
here is how the push instruction is

872
00:48:49,520 --> 00:48:57,680
encoded to give you an example so pushes

873
00:48:55,370 --> 00:49:00,950
these are data transfer instructions so

874
00:48:57,680 --> 00:49:03,560
they are kind of complex the condition

875
00:49:00,950 --> 00:49:07,189
bits are the first four bits then these

876
00:49:03,560 --> 00:49:11,890
indicate 100 over here I mean 1 0 0

877
00:49:07,190 --> 00:49:11,890
means it's load store instructions the

878
00:49:12,400 --> 00:49:19,970
the P is for push or no sorry what is a

879
00:49:16,790 --> 00:49:28,910
P for P is for something I forgot what

880
00:49:19,970 --> 00:49:31,669
it is for you is up or down this is the

881
00:49:28,910 --> 00:49:34,549
forward or reverse s is update the

882
00:49:31,670 --> 00:49:37,190
status flag the bang is if you want to

883
00:49:34,550 --> 00:49:40,340
write back to the base register and this

884
00:49:37,190 --> 00:49:43,250
bit is load or store so if it's zero it

885
00:49:40,340 --> 00:49:46,600
is store if it's 1 it is load so

886
00:49:43,250 --> 00:49:50,410
basically these bits translate to push

887
00:49:46,600 --> 00:49:56,750
that is store with the stack pointer and

888
00:49:50,410 --> 00:49:59,029
this these bits and imply pop that is

889
00:49:56,750 --> 00:50:03,670
load with the stack pointer so stack

890
00:49:59,030 --> 00:50:07,410
pointer is this is the base

891
00:50:03,670 --> 00:50:07,410
register which is the stack pointer are

892
00:50:08,670 --> 00:50:16,890
at 13 yeah this is our 13 is a stack

893
00:50:12,790 --> 00:50:20,710
pointer and this bit field is a 16-bit

894
00:50:16,890 --> 00:50:22,960
register list the the bit field starts

895
00:50:20,710 --> 00:50:24,970
from the least significant bit so if a

896
00:50:22,960 --> 00:50:27,309
bit is on that corresponding register

897
00:50:24,970 --> 00:50:33,399
will be populated so this is going to be

898
00:50:27,309 --> 00:50:34,990
r1 r3 r4 + r8 this r8 had to be there

899
00:50:33,400 --> 00:50:37,150
otherwise has a null byte that was

900
00:50:34,990 --> 00:50:40,149
creeping up and that was damaging the

901
00:50:37,150 --> 00:50:45,369
instruction and this other one is just

902
00:50:40,150 --> 00:50:48,670
pop I am only popping three and these

903
00:50:45,369 --> 00:50:54,730
they get decoded to a shift instruction

904
00:50:48,670 --> 00:50:58,569
and a subtract instruction the other one

905
00:50:54,730 --> 00:51:00,460
the pop gets transformed to an add

906
00:50:58,569 --> 00:51:02,500
instruction and a subtract instruction

907
00:51:00,460 --> 00:51:05,859
so there you have to play a lot with

908
00:51:02,500 --> 00:51:08,619
this encoding stuff and then once you

909
00:51:05,859 --> 00:51:15,700
get it right hopefully this stuff should

910
00:51:08,619 --> 00:51:20,609
work okay so as far as the demo goes I

911
00:51:15,700 --> 00:51:20,609
have a test case

912
00:51:32,770 --> 00:51:40,009
so has a universal test arm dot s this

913
00:51:37,880 --> 00:51:42,260
is basically just starting off in our

914
00:51:40,010 --> 00:51:43,520
mode these instructions will drop you to

915
00:51:42,260 --> 00:51:46,010
thumb mode which is kind of obvious

916
00:51:43,520 --> 00:51:48,170
because that's what they are I have just

917
00:51:46,010 --> 00:51:50,810
placed them as arbitrary shell code for

918
00:51:48,170 --> 00:51:57,100
a test but let me show you the thumb

919
00:51:50,810 --> 00:52:00,259
test which will be more interesting so

920
00:51:57,100 --> 00:52:02,230
what I'm going to do is in this test I

921
00:52:00,260 --> 00:52:07,390
will forcibly switch to thermode and

922
00:52:02,230 --> 00:52:11,720
then invoke these same instructions but

923
00:52:07,390 --> 00:52:13,879
the code is compiled as code 16 which is

924
00:52:11,720 --> 00:52:16,359
this will be forcibly assembled as thumb

925
00:52:13,880 --> 00:52:22,670
mode and just laying these out as as

926
00:52:16,360 --> 00:52:25,550
literals now what it should do is all

927
00:52:22,670 --> 00:52:28,160
these little should switch you to thumb

928
00:52:25,550 --> 00:52:30,800
mode while being in thumb mode keep you

929
00:52:28,160 --> 00:52:37,430
in thumb mode sorry and then you will X

930
00:52:30,800 --> 00:52:54,290
or R 2 and set R 7 equal to 11 okay bro

931
00:52:37,430 --> 00:52:56,359
gdb Universal test thumb break start so

932
00:52:54,290 --> 00:52:59,720
here we will switch to thumb mode after

933
00:52:56,360 --> 00:53:10,130
the first two instructions say step 2

934
00:52:59,720 --> 00:53:16,220
and so after a step 2 we are now in

935
00:53:10,130 --> 00:53:18,980
thumb mode and the add CS move CS and

936
00:53:16,220 --> 00:53:21,549
the pushes have now been transformed to

937
00:53:18,980 --> 00:53:27,380
a series of and add moves and all these

938
00:53:21,550 --> 00:53:29,570
so if I keep let's let me skip four

939
00:53:27,380 --> 00:53:31,760
instructions at a time so step through

940
00:53:29,570 --> 00:53:34,790
four instruction at a time so the first

941
00:53:31,760 --> 00:53:41,000
four went through no problem the next

942
00:53:34,790 --> 00:53:46,170
four will go through and the last four

943
00:53:41,000 --> 00:53:48,490
will go through there's this more

944
00:53:46,170 --> 00:53:52,330
yeah the last four are now remaining

945
00:53:48,490 --> 00:53:55,509
over here so if this is non-destructive

946
00:53:52,330 --> 00:53:58,120
all good now we are at or our proof of

947
00:53:55,510 --> 00:54:02,430
concept code we're still in some mode

948
00:53:58,120 --> 00:54:05,440
and if we if we finish up we will get

949
00:54:02,430 --> 00:54:09,730
the register - which is zeroed out and

950
00:54:05,440 --> 00:54:11,380
our seven is set to Allah so you start

951
00:54:09,730 --> 00:54:13,540
in our mode you drop two thermode you

952
00:54:11,380 --> 00:54:18,700
start in thumb mode you stay in thumb

953
00:54:13,540 --> 00:54:21,910
mode the code doesn't change now this is

954
00:54:18,700 --> 00:54:27,480
a I mean this is like one iteration or

955
00:54:21,910 --> 00:54:30,609
one turn out of the of the code sequence

956
00:54:27,480 --> 00:54:33,760
you can use your imagination you can use

957
00:54:30,610 --> 00:54:36,550
your fluency with assembly conditional

958
00:54:33,760 --> 00:54:40,840
execution and play with op codes and get

959
00:54:36,550 --> 00:54:42,970
like a large set of polyglot sequences

960
00:54:40,840 --> 00:54:48,250
to then drop you into thumb mode so to

961
00:54:42,970 --> 00:54:50,200
the Yara rule-makers a signature that so

962
00:54:48,250 --> 00:54:53,800
this kind of brings it to the end again

963
00:54:50,200 --> 00:54:55,210
I apologize for the slides they will be

964
00:54:53,800 --> 00:54:57,850
published tomorrow and the code will be

965
00:54:55,210 --> 00:55:01,960
pushed on github you can play with it if

966
00:54:57,850 --> 00:55:03,910
you find any additional stuff this is I

967
00:55:01,960 --> 00:55:06,730
know this room has more arm experts and

968
00:55:03,910 --> 00:55:08,470
me who played with a lot of stuff please

969
00:55:06,730 --> 00:55:10,660
let me know it would be great to improve

970
00:55:08,470 --> 00:55:13,180
the shell code and collaborate or you

971
00:55:10,660 --> 00:55:14,890
can fork it or merge it back it'll be

972
00:55:13,180 --> 00:55:18,580
it'll be a pleasure to work with you on

973
00:55:14,890 --> 00:55:19,990
this ideas are most welcome I will be

974
00:55:18,580 --> 00:55:22,930
tweeting tomorrow and the slides are up

975
00:55:19,990 --> 00:55:25,720
so with this thank you very much thanks

976
00:55:22,930 --> 00:55:29,200
for putting up with my semi broken talk

977
00:55:25,720 --> 00:55:31,029
and enjoy 44 corn and there's a bus full

978
00:55:29,200 --> 00:55:34,810
of gin waiting outside

979
00:55:31,030 --> 00:55:57,690
[Applause]

980
00:55:34,810 --> 00:55:57,690
[Music]

