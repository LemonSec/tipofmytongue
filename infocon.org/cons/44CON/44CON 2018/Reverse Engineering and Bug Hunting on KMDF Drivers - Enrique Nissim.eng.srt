1
00:00:00,030 --> 00:00:08,209
hello thanks for joining in this last

2
00:00:03,140 --> 00:00:10,590
briefing today I'm going to talk about

3
00:00:08,210 --> 00:00:13,349
reverse engineering at Bank hunting on

4
00:00:10,590 --> 00:00:16,830
this particular class of drivers in

5
00:00:13,349 --> 00:00:18,840
Windows just came in the F this is my

6
00:00:16,830 --> 00:00:26,250
first time in 44 Khan and in London some

7
00:00:18,840 --> 00:00:31,910
a very happy to be here well I mean I'm

8
00:00:26,250 --> 00:00:34,410
a senior security consultant at IRT and

9
00:00:31,910 --> 00:00:43,980
well that's my Twitter handle right

10
00:00:34,410 --> 00:00:46,890
there if you want to connect so what I'm

11
00:00:43,980 --> 00:00:51,148
going to talk about here it's not really

12
00:00:46,890 --> 00:00:53,399
based on exploitation I'm going to put

13
00:00:51,149 --> 00:00:56,100
the focus on how to find box in this

14
00:00:53,399 --> 00:00:57,660
kind of drivers and what are the

15
00:00:56,100 --> 00:01:01,739
interesting functions that we want to

16
00:00:57,660 --> 00:01:04,438
look at this is not a neck full

17
00:01:01,739 --> 00:01:09,179
reference of course you have the MSDN to

18
00:01:04,438 --> 00:01:10,979
the two for that and the actual source

19
00:01:09,180 --> 00:01:17,759
code of a MDF because it's open source

20
00:01:10,979 --> 00:01:21,630
now and why well the thing is I had this

21
00:01:17,759 --> 00:01:28,049
project for an OEM several months back

22
00:01:21,630 --> 00:01:30,990
and we we've been tasked to look at the

23
00:01:28,049 --> 00:01:35,729
driver package of the one of the latest

24
00:01:30,990 --> 00:01:39,119
laptop that they have and we well I

25
00:01:35,729 --> 00:01:40,920
found several bites in the came DF

26
00:01:39,119 --> 00:01:43,740
drivers the Bucks were really easy to

27
00:01:40,920 --> 00:01:47,070
find and some of them were in components

28
00:01:43,740 --> 00:01:50,070
that they'd back in 2012 so that I think

29
00:01:47,070 --> 00:01:53,610
that that was interesting and I decided

30
00:01:50,070 --> 00:01:58,380
to you know make a summary of everything

31
00:01:53,610 --> 00:02:02,670
I learned through that these are some of

32
00:01:58,380 --> 00:02:05,759
the facts I reported system to some

33
00:02:02,670 --> 00:02:08,940
vendors you have a Intel camera camera

34
00:02:05,759 --> 00:02:11,899
driver touchable drivers from LPS

35
00:02:08,940 --> 00:02:11,899
synaptics

36
00:02:12,200 --> 00:02:18,619
the EOPS is really bad one there's also

37
00:02:16,730 --> 00:02:22,899
one named deal and it's not listed there

38
00:02:18,620 --> 00:02:25,520
and these are used by different OEMs and

39
00:02:22,900 --> 00:02:27,950
modified by audience before they are put

40
00:02:25,520 --> 00:02:30,200
into your laptops so they probably have

41
00:02:27,950 --> 00:02:35,329
some variation of this but the base code

42
00:02:30,200 --> 00:02:40,519
is probably one of these another ones

43
00:02:35,330 --> 00:02:44,120
interval is to spray some mass drivers

44
00:02:40,520 --> 00:02:46,489
from Microsoft and some gaming devices

45
00:02:44,120 --> 00:02:50,209
as well all the gaming devices like

46
00:02:46,489 --> 00:02:53,420
gamepad of joysticks or even headphones

47
00:02:50,209 --> 00:02:57,410
those probably deploy came the F drivers

48
00:02:53,420 --> 00:03:02,029
nowadays so I mostly used for bus

49
00:02:57,410 --> 00:03:07,070
drivers or hardware device drivers so I

50
00:03:02,030 --> 00:03:10,340
will leave here a quick recap on how wdn

51
00:03:07,070 --> 00:03:15,140
works for people that never play with

52
00:03:10,340 --> 00:03:18,950
drivers before then I'll just enter full

53
00:03:15,140 --> 00:03:21,500
into km DF I highlight the interesting

54
00:03:18,950 --> 00:03:23,720
functions common errors and we end with

55
00:03:21,500 --> 00:03:25,299
some completions at the end I have some

56
00:03:23,720 --> 00:03:32,269
demos to show

57
00:03:25,299 --> 00:03:33,890
so hopefully you are entertained so in

58
00:03:32,269 --> 00:03:38,840
Windows you have different driver models

59
00:03:33,890 --> 00:03:41,059
the first on base one is the WDM but you

60
00:03:38,840 --> 00:03:43,310
have a bunch of them came DF is just

61
00:03:41,060 --> 00:03:46,850
another model runs on top it's an

62
00:03:43,310 --> 00:03:49,160
abstraction but you also have WDDM which

63
00:03:46,850 --> 00:03:52,489
stands for graphics and this which is

64
00:03:49,160 --> 00:03:54,200
from network have file system type of

65
00:03:52,489 --> 00:03:59,329
different different modes of file system

66
00:03:54,200 --> 00:04:01,459
types the idea is that you in order to

67
00:03:59,329 --> 00:04:03,799
to approach each one of this you need to

68
00:04:01,459 --> 00:04:06,049
understand the model of course it's 90%

69
00:04:03,799 --> 00:04:08,329
understanding the model and 10% of

70
00:04:06,049 --> 00:04:18,048
reverse engineering that's how it is in

71
00:04:08,329 --> 00:04:20,269
in Windows so starting with WDM the this

72
00:04:18,048 --> 00:04:22,520
is the standard for all all the other

73
00:04:20,269 --> 00:04:25,820
models use this one under the hood and

74
00:04:22,520 --> 00:04:27,919
you need to understand this model is

75
00:04:25,820 --> 00:04:34,390
even if you are actually programming in

76
00:04:27,920 --> 00:04:38,600
KMD f or WD WDDM or anything because

77
00:04:34,390 --> 00:04:40,219
that's the way you get most of of the

78
00:04:38,600 --> 00:04:43,610
driver models you're actually developing

79
00:04:40,220 --> 00:04:47,150
up and if you don't understand this you

80
00:04:43,610 --> 00:04:49,460
probably have bugs anyway and for

81
00:04:47,150 --> 00:04:52,159
software drivers meaning drivers that

82
00:04:49,460 --> 00:04:54,799
are not actually managing a device this

83
00:04:52,160 --> 00:04:59,420
is the model that still most vendors are

84
00:04:54,800 --> 00:05:02,360
using so what's a driver well driver is

85
00:04:59,420 --> 00:05:05,060
just code that it's loaded into kernel

86
00:05:02,360 --> 00:05:08,990
space and executed with ring seed of

87
00:05:05,060 --> 00:05:12,290
privileges the i/o manager loads the

88
00:05:08,990 --> 00:05:15,620
driver in in this space and creates a

89
00:05:12,290 --> 00:05:18,440
driver object and after that it calls

90
00:05:15,620 --> 00:05:21,080
the driver entry routine which it's like

91
00:05:18,440 --> 00:05:23,960
the main function for the for the driver

92
00:05:21,080 --> 00:05:26,900
and that driver entry routine initialize

93
00:05:23,960 --> 00:05:29,060
the rest of the thing like all the

94
00:05:26,900 --> 00:05:31,880
callbacks that is going to be used like

95
00:05:29,060 --> 00:05:34,190
dispatch functions interrupt service

96
00:05:31,880 --> 00:05:37,550
routines and everything and it also

97
00:05:34,190 --> 00:05:40,030
creates a device object that device

98
00:05:37,550 --> 00:05:43,040
subject is the instance through which we

99
00:05:40,030 --> 00:05:45,919
say user mode application or another

100
00:05:43,040 --> 00:05:47,990
party will connect to the driver so when

101
00:05:45,920 --> 00:05:49,880
we actually talk to the driver we are

102
00:05:47,990 --> 00:05:52,130
doing it through a device object we

103
00:05:49,880 --> 00:05:54,680
create a handle to a device object we

104
00:05:52,130 --> 00:05:56,990
read from a device object we write to a

105
00:05:54,680 --> 00:05:59,510
device object and by doing that we are

106
00:05:56,990 --> 00:06:03,890
exercising the dispatch routines that

107
00:05:59,510 --> 00:06:05,570
the drive your entry set okay and of

108
00:06:03,890 --> 00:06:07,310
course a driver can manage more than one

109
00:06:05,570 --> 00:06:11,330
device it can create more one but one

110
00:06:07,310 --> 00:06:16,370
device object each one of those can have

111
00:06:11,330 --> 00:06:18,500
different ACLs so we need to look at the

112
00:06:16,370 --> 00:06:21,410
ACL for each one of the device object at

113
00:06:18,500 --> 00:06:25,760
the traffic creates what they're looking

114
00:06:21,410 --> 00:06:28,490
here are is device objects that are sir

115
00:06:25,760 --> 00:06:33,770
regular users without privileges I mean

116
00:06:28,490 --> 00:06:36,350
no non administrative privileges and we

117
00:06:33,770 --> 00:06:38,870
can interact with right those are the

118
00:06:36,350 --> 00:06:43,770
ones that we're looking for

119
00:06:38,870 --> 00:06:45,930
so the driver entry calls this API are

120
00:06:43,770 --> 00:06:49,530
your create device to actually create a

121
00:06:45,930 --> 00:06:52,080
device subject and it passes it has

122
00:06:49,530 --> 00:06:54,419
different different fields the one I

123
00:06:52,080 --> 00:06:56,909
wanted to highlight are the world the

124
00:06:54,420 --> 00:07:00,900
device name but also the device

125
00:06:56,910 --> 00:07:04,230
characteristics when you create a device

126
00:07:00,900 --> 00:07:08,060
object every every object comes with an

127
00:07:04,230 --> 00:07:11,510
Associated namespace and this is because

128
00:07:08,060 --> 00:07:14,040
every device object in Windows is

129
00:07:11,510 --> 00:07:19,409
actually treated as a file system

130
00:07:14,040 --> 00:07:22,620
basically and you have different paths

131
00:07:19,410 --> 00:07:24,900
in in the plane space of course so

132
00:07:22,620 --> 00:07:27,690
unless you are a file system driver you

133
00:07:24,900 --> 00:07:30,419
have to specify file device secure open

134
00:07:27,690 --> 00:07:34,469
in the device characteristic otherwise

135
00:07:30,420 --> 00:07:38,280
you can get any user mode program open

136
00:07:34,470 --> 00:07:40,350
and handle to your device by passing

137
00:07:38,280 --> 00:07:42,659
your ICL because the system doesn't

138
00:07:40,350 --> 00:07:46,560
ensure the ACL in every part of the

139
00:07:42,660 --> 00:07:49,830
design space I'll get into that more in

140
00:07:46,560 --> 00:07:53,340
more detail in a few slides but if this

141
00:07:49,830 --> 00:07:56,490
is bad and I have seen several in the

142
00:07:53,340 --> 00:07:59,520
past in 2015 several antivirus systems

143
00:07:56,490 --> 00:08:02,010
deploy drivers with this not being said

144
00:07:59,520 --> 00:08:04,219
and so you can do whatever you want back

145
00:08:02,010 --> 00:08:04,219
then

146
00:08:05,030 --> 00:08:14,059
well it's virtual teens are the actual

147
00:08:09,000 --> 00:08:16,740
entry points this this article that are

148
00:08:14,060 --> 00:08:20,250
executed when you call create read write

149
00:08:16,740 --> 00:08:23,910
or i/o control so this is the things

150
00:08:20,250 --> 00:08:25,500
that we are trying to to get to

151
00:08:23,910 --> 00:08:31,710
understand to reverse engineer and see

152
00:08:25,500 --> 00:08:34,950
how they work there are different major

153
00:08:31,710 --> 00:08:38,189
functions cause with a dispatch the

154
00:08:34,950 --> 00:08:40,080
thing will treat differently so of

155
00:08:38,190 --> 00:08:43,620
course the driver doesn't have to

156
00:08:40,080 --> 00:08:46,760
support all of them but most of the time

157
00:08:43,620 --> 00:08:49,920
they want that we are interesting

158
00:08:46,760 --> 00:08:51,510
interested in is are the device IO

159
00:08:49,920 --> 00:08:55,729
control read and write wait

160
00:08:51,510 --> 00:09:00,540
things that we can control this is the

161
00:08:55,730 --> 00:09:02,940
base code of a WDM driver basically what

162
00:09:00,540 --> 00:09:05,610
it does is creates a device net by

163
00:09:02,940 --> 00:09:09,900
subject with the API I I pointed out

164
00:09:05,610 --> 00:09:12,690
before then it sets some dispatch hats

165
00:09:09,900 --> 00:09:14,840
dispatch hundred teams and then it

166
00:09:12,690 --> 00:09:18,180
creates assembling creating that symlink

167
00:09:14,840 --> 00:09:20,310
allows user mode applications to open

168
00:09:18,180 --> 00:09:22,829
handle to it otherwise just another

169
00:09:20,310 --> 00:09:25,949
kernel mode a component can interact

170
00:09:22,830 --> 00:09:28,260
with its driver and if you look at the

171
00:09:25,950 --> 00:09:31,950
device characteristics it's being said

172
00:09:28,260 --> 00:09:33,480
to know so what does mean is that if we

173
00:09:31,950 --> 00:09:37,320
talked to a driver from a user mode

174
00:09:33,480 --> 00:09:40,650
program even if the driver set a strict

175
00:09:37,320 --> 00:09:43,110
strict ACL with only administrative

176
00:09:40,650 --> 00:09:46,319
users can open a handle we can bypass

177
00:09:43,110 --> 00:09:50,100
that just by just adding a double slash

178
00:09:46,320 --> 00:09:53,250
in the create file okay just by adding

179
00:09:50,100 --> 00:09:55,560
that we are saying that we are want to

180
00:09:53,250 --> 00:09:58,560
access a part of its name this namespace

181
00:09:55,560 --> 00:10:05,069
and given its not file device like you

182
00:09:58,560 --> 00:10:07,530
Robin we will get a handle and then we

183
00:10:05,070 --> 00:10:10,140
have some functions like read file write

184
00:10:07,530 --> 00:10:13,560
file and device layer control that's how

185
00:10:10,140 --> 00:10:15,870
we interact with a driver they see

186
00:10:13,560 --> 00:10:18,000
different buffer sizes but that's

187
00:10:15,870 --> 00:10:21,090
basically it's mostly like a file right

188
00:10:18,000 --> 00:10:25,590
and with that we are actually exercising

189
00:10:21,090 --> 00:10:26,840
the code that the driver set as it

190
00:10:25,590 --> 00:10:30,030
specialties

191
00:10:26,840 --> 00:10:33,870
these are different Siskel's that we can

192
00:10:30,030 --> 00:10:35,400
invoke and on the on the on the left and

193
00:10:33,870 --> 00:10:38,460
on the right we have the dispatch

194
00:10:35,400 --> 00:10:41,880
routines that we will exercise if are

195
00:10:38,460 --> 00:10:43,710
being set by the driver there are a

196
00:10:41,880 --> 00:10:48,120
bunch of them some of them we have

197
00:10:43,710 --> 00:10:51,890
parameters that we control this we need

198
00:10:48,120 --> 00:10:54,780
to see what the drivers actually does

199
00:10:51,890 --> 00:10:57,150
okay under dispatch routines working in

200
00:10:54,780 --> 00:11:00,600
terms of interrupt request packets which

201
00:10:57,150 --> 00:11:04,230
are herbs the ear is created by the i/o

202
00:11:00,600 --> 00:11:05,290
manager upon we do a call for instance

203
00:11:04,230 --> 00:11:10,510
if we do a read

204
00:11:05,290 --> 00:11:13,300
the wreath it's it enters into an Tosh

205
00:11:10,510 --> 00:11:15,310
Karl and toast colonel day creates the

206
00:11:13,300 --> 00:11:18,540
inter request packet and then that is

207
00:11:15,310 --> 00:11:21,699
what we receive in our dispatch the team

208
00:11:18,540 --> 00:11:23,980
the air pass all the information

209
00:11:21,700 --> 00:11:30,420
necessary for the request including the

210
00:11:23,980 --> 00:11:37,500
buffers and an air I or stack locations

211
00:11:30,420 --> 00:11:41,650
the stack locations are well they are

212
00:11:37,500 --> 00:11:44,980
more information about the particular

213
00:11:41,650 --> 00:11:47,980
request and we have a stack location for

214
00:11:44,980 --> 00:11:50,560
every driver in a layered architecture

215
00:11:47,980 --> 00:11:54,760
so let's say we have a file system

216
00:11:50,560 --> 00:11:56,859
driver and also a filter driver from an

217
00:11:54,760 --> 00:11:58,750
from an antivirus whenever we want to

218
00:11:56,860 --> 00:12:01,000
read from a file system we'll go through

219
00:11:58,750 --> 00:12:02,980
the filter driver first maybe and then

220
00:12:01,000 --> 00:12:04,540
to the file system driver right well in

221
00:12:02,980 --> 00:12:06,910
that case we have of course just a

222
00:12:04,540 --> 00:12:10,390
single ear but we had two stacked

223
00:12:06,910 --> 00:12:12,760
locations one for each driver and each

224
00:12:10,390 --> 00:12:15,069
driver access it's it's a particular

225
00:12:12,760 --> 00:12:18,370
stack location so we had the parameters

226
00:12:15,070 --> 00:12:24,040
such as how what's the size of the

227
00:12:18,370 --> 00:12:27,370
buffer was the IO control code etc there

228
00:12:24,040 --> 00:12:29,740
are different forms or that the driver

229
00:12:27,370 --> 00:12:33,700
can use to access the data in the

230
00:12:29,740 --> 00:12:38,520
buffers so the first one it's called

231
00:12:33,700 --> 00:12:41,860
buffer in which when we send a request

232
00:12:38,520 --> 00:12:43,900
for instance I don't know writing a we

233
00:12:41,860 --> 00:12:47,620
want to write some data the i/o manager

234
00:12:43,900 --> 00:12:50,380
takes that data copies it into a kernel

235
00:12:47,620 --> 00:12:52,780
allocated space so it's basically

236
00:12:50,380 --> 00:12:55,000
copying all the data into a new buffer

237
00:12:52,780 --> 00:12:58,209
and that is the buffer that it's passed

238
00:12:55,000 --> 00:13:00,580
to the driver so that's the most secure

239
00:12:58,210 --> 00:13:03,400
way it actually the the i/o manager

240
00:13:00,580 --> 00:13:06,100
takes care of all the checks but of

241
00:13:03,400 --> 00:13:10,230
course it's low if you have a lot of

242
00:13:06,100 --> 00:13:14,020
transfer so then you have do I mean do

243
00:13:10,230 --> 00:13:18,040
what happens is that the i/o manager

244
00:13:14,020 --> 00:13:19,000
locks your buffer your user buffer so

245
00:13:18,040 --> 00:13:21,250
you cannot

246
00:13:19,000 --> 00:13:23,589
that memory and then it creates another

247
00:13:21,250 --> 00:13:27,639
virtual address for that same physical

248
00:13:23,589 --> 00:13:30,180
page so you have to be little addresses

249
00:13:27,639 --> 00:13:33,790
pointing to the same physical page and

250
00:13:30,180 --> 00:13:39,160
it's interesting because if you're if

251
00:13:33,790 --> 00:13:41,410
the driver is not aware of that you can

252
00:13:39,160 --> 00:13:44,230
change the data in the user mode program

253
00:13:41,410 --> 00:13:47,800
and have a race condition if there are

254
00:13:44,230 --> 00:13:50,920
multiple reads from the buffer nobody

255
00:13:47,800 --> 00:13:52,719
prevents the user mode program to change

256
00:13:50,920 --> 00:13:57,759
the data it cannot have map the memory

257
00:13:52,720 --> 00:14:00,730
but it can change the data so you can't

258
00:13:57,759 --> 00:14:02,649
have race conditions there and lastly

259
00:14:00,730 --> 00:14:05,189
you have the neither method in which the

260
00:14:02,649 --> 00:14:08,230
AI manager doesn't get involved with the

261
00:14:05,189 --> 00:14:11,800
operation of the buffer at all it just

262
00:14:08,230 --> 00:14:13,269
sends the user mode buffer the the the

263
00:14:11,800 --> 00:14:16,719
address of the user mode buffer to the

264
00:14:13,269 --> 00:14:19,120
driver and that's all this initiation to

265
00:14:16,720 --> 00:14:21,430
the driver so a driver has to check the

266
00:14:19,120 --> 00:14:24,279
length has to check that the memories

267
00:14:21,430 --> 00:14:26,258
map and everything of course the add

268
00:14:24,279 --> 00:14:31,889
method was the source of all the

269
00:14:26,259 --> 00:14:31,889
problems in drivers from previous years

270
00:14:33,930 --> 00:14:39,609
how do you set the things well for read

271
00:14:37,720 --> 00:14:42,309
and write and all those operations you

272
00:14:39,610 --> 00:14:44,290
can set it in you you will see that this

273
00:14:42,309 --> 00:14:47,410
set in the device Flags device optic

274
00:14:44,290 --> 00:14:50,889
flags but for i/o control based

275
00:14:47,410 --> 00:14:53,949
operations that's encoded in the i/o

276
00:14:50,889 --> 00:14:57,819
control code which is the number we've

277
00:14:53,949 --> 00:15:01,740
seen before passing to the NT device

278
00:14:57,819 --> 00:15:04,959
layer control and it's just a

279
00:15:01,740 --> 00:15:08,019
combination of values that are packed

280
00:15:04,959 --> 00:15:10,540
into a D Ward the interesting fields are

281
00:15:08,019 --> 00:15:13,449
the transfer type which again indicates

282
00:15:10,540 --> 00:15:18,910
what kind of transfer data transfer are

283
00:15:13,449 --> 00:15:24,250
we using and the required access which

284
00:15:18,910 --> 00:15:27,490
is which dictates what permissions your

285
00:15:24,250 --> 00:15:28,959
handle needs in order to issue that I

286
00:15:27,490 --> 00:15:30,720
your control and that's very interesting

287
00:15:28,959 --> 00:15:34,920
because

288
00:15:30,720 --> 00:15:37,230
you can sometimes find device subjects

289
00:15:34,920 --> 00:15:39,990
that have something like that you see

290
00:15:37,230 --> 00:15:43,410
the group everyone doesn't seem to have

291
00:15:39,990 --> 00:15:46,380
any operations I mean it doesn't seems

292
00:15:43,410 --> 00:15:49,380
to be able to open handle with read

293
00:15:46,380 --> 00:15:54,420
permissions or with write permissions to

294
00:15:49,380 --> 00:15:56,340
that device but you can pass no and you

295
00:15:54,420 --> 00:15:59,459
can open a handle with no permissions

296
00:15:56,340 --> 00:16:02,670
right and that will return a handle and

297
00:15:59,460 --> 00:16:05,130
what you can do is then start issuing IO

298
00:16:02,670 --> 00:16:08,189
controls that are set with the transfer

299
00:16:05,130 --> 00:16:13,430
type again with a transfer type of file

300
00:16:08,190 --> 00:16:19,170
any access and it will work and the same

301
00:16:13,430 --> 00:16:23,099
is for things for for read or write in

302
00:16:19,170 --> 00:16:26,430
the end you need to audit the what what

303
00:16:23,100 --> 00:16:30,720
translate what access required is for

304
00:16:26,430 --> 00:16:33,390
each control code of course if you don't

305
00:16:30,720 --> 00:16:35,610
appear in the in the ACL then you won't

306
00:16:33,390 --> 00:16:37,680
be able to open a handle but if you see

307
00:16:35,610 --> 00:16:43,080
something like this then you need to to

308
00:16:37,680 --> 00:16:46,140
get into it in the lidium was very easy

309
00:16:43,080 --> 00:16:47,580
to find this stuff you just open the

310
00:16:46,140 --> 00:16:50,390
driver in either probe and you will see

311
00:16:47,580 --> 00:16:55,470
patterns like this and you are certainly

312
00:16:50,390 --> 00:16:58,260
you can be certainly certain that those

313
00:16:55,470 --> 00:17:02,610
are the dispatch the teens and what can

314
00:16:58,260 --> 00:17:05,490
go wrong here a lot of things you should

315
00:17:02,610 --> 00:17:07,500
check that presentation because really a

316
00:17:05,490 --> 00:17:11,130
lot of things can go wrong and all udm

317
00:17:07,500 --> 00:17:15,839
programming and that's why they came

318
00:17:11,130 --> 00:17:18,600
with caramell driver framework a MDF is

319
00:17:15,839 --> 00:17:25,889
just an abstraction on top of the old

320
00:17:18,599 --> 00:17:27,480
EDM and because is certain it's you know

321
00:17:25,890 --> 00:17:27,930
more difficult to understand what it's

322
00:17:27,480 --> 00:17:30,390
doing

323
00:17:27,930 --> 00:17:33,030
new drivers are supposed to be reading

324
00:17:30,390 --> 00:17:36,810
link MDF and device drivers and bus

325
00:17:33,030 --> 00:17:40,010
drivers are software drivers are not for

326
00:17:36,810 --> 00:17:40,010
some reason but

327
00:17:40,470 --> 00:17:44,549
it's difficult it's more difficult

328
00:17:42,389 --> 00:17:47,879
because of this to get to the actual

329
00:17:44,549 --> 00:17:54,059
code base and I will show you in in a

330
00:17:47,879 --> 00:17:56,340
demo why so what happens is that came

331
00:17:54,059 --> 00:17:59,840
the F sets its own dispatch routines for

332
00:17:56,340 --> 00:18:05,639
you so he traps all the requests and

333
00:17:59,840 --> 00:18:08,639
then rubs those into better objects or

334
00:18:05,639 --> 00:18:11,129
more object oriented and you get for

335
00:18:08,639 --> 00:18:15,000
instance in get instead of herbs you get

336
00:18:11,129 --> 00:18:18,000
a request instead of having in dispatch

337
00:18:15,000 --> 00:18:23,669
routine you have a callback for one

338
00:18:18,000 --> 00:18:26,340
queue so what happens is that the driver

339
00:18:23,669 --> 00:18:29,789
creates a queue and set different

340
00:18:26,340 --> 00:18:31,590
callbacks for those for instance call us

341
00:18:29,789 --> 00:18:33,600
when it comes a read request so that

342
00:18:31,590 --> 00:18:37,439
write request or device IO control

343
00:18:33,600 --> 00:18:39,840
request there is also a default which

344
00:18:37,440 --> 00:18:42,509
actually gets called when there's no

345
00:18:39,840 --> 00:18:45,480
specific there when there's no specific

346
00:18:42,509 --> 00:18:48,029
callback for reading for instance if I

347
00:18:45,480 --> 00:18:51,200
said no to read and I set the default a

348
00:18:48,029 --> 00:18:53,370
read will get into the default one

349
00:18:51,200 --> 00:18:59,250
that's interesting as well kiss I've

350
00:18:53,370 --> 00:19:03,000
seen some issues I was show a basic game

351
00:18:59,250 --> 00:19:11,340
the F driver starts by creating the

352
00:19:03,000 --> 00:19:12,659
actual driver object it creates it calls

353
00:19:11,340 --> 00:19:16,110
that wdf

354
00:19:12,659 --> 00:19:20,399
driver create and specifies a callback

355
00:19:16,110 --> 00:19:25,830
heaven device app and that is what

356
00:19:20,399 --> 00:19:27,689
actually created the device and in here

357
00:19:25,830 --> 00:19:29,309
file device with Europe and is set by

358
00:19:27,690 --> 00:19:31,139
default so we don't need to worry about

359
00:19:29,309 --> 00:19:38,668
that namespace issue that we had before

360
00:19:31,139 --> 00:19:41,668
and then it will create a queue in this

361
00:19:38,669 --> 00:19:45,960
case it's only setting the device IO

362
00:19:41,669 --> 00:19:48,240
default so all requests are going to be

363
00:19:45,960 --> 00:19:52,430
handled by that particular call back and

364
00:19:48,240 --> 00:19:55,640
then it's creating a device interface

365
00:19:52,430 --> 00:19:59,270
that device interface is what is similar

366
00:19:55,640 --> 00:20:02,480
to a symlink is what user applications

367
00:19:59,270 --> 00:20:07,070
can use or other components can use to

368
00:20:02,480 --> 00:20:10,820
open handle to this device it's setting

369
00:20:07,070 --> 00:20:15,409
a GUI and we need to know that specific

370
00:20:10,820 --> 00:20:19,129
do it in order to open it handle so our

371
00:20:15,410 --> 00:20:21,770
actual driver entry the code that you

372
00:20:19,130 --> 00:20:24,230
will see in the source code you won't

373
00:20:21,770 --> 00:20:27,650
see that directly when you open your

374
00:20:24,230 --> 00:20:29,630
binary in either because came the F the

375
00:20:27,650 --> 00:20:33,980
game via flattery will rub that and

376
00:20:29,630 --> 00:20:37,340
we'll call WTF version bind to us to -

377
00:20:33,980 --> 00:20:40,760
well do the binding of your driver to

378
00:20:37,340 --> 00:20:46,010
any specific version of the km DF

379
00:20:40,760 --> 00:20:50,500
library and with that it will set a

380
00:20:46,010 --> 00:20:54,170
structure that specifies how many

381
00:20:50,500 --> 00:20:57,280
functions are the version and the

382
00:20:54,170 --> 00:21:00,380
pointer to a function which has all the

383
00:20:57,280 --> 00:21:02,120
the Kovaks became the f callback tell

384
00:21:00,380 --> 00:21:06,230
your driver that the driver that you're

385
00:21:02,120 --> 00:21:12,439
targeting is going to call later we need

386
00:21:06,230 --> 00:21:14,179
to actually get into that and and set at

387
00:21:12,440 --> 00:21:17,150
least some those names because otherwise

388
00:21:14,179 --> 00:21:19,809
we own that we won't understand what the

389
00:21:17,150 --> 00:21:23,630
driver is doing we just see call to

390
00:21:19,809 --> 00:21:25,220
different calls to two different section

391
00:21:23,630 --> 00:21:30,350
of the drivers but we don't see the

392
00:21:25,220 --> 00:21:34,130
names we don't see anything and a device

393
00:21:30,350 --> 00:21:38,059
interface so came the F again is mostly

394
00:21:34,130 --> 00:21:40,910
for device drivers and bus drivers they

395
00:21:38,059 --> 00:21:46,870
cannot use names they are using state

396
00:21:40,910 --> 00:21:50,600
codes and we need to do another kind of

397
00:21:46,870 --> 00:21:54,139
steps to open a handle we cannot just

398
00:21:50,600 --> 00:21:57,020
pass a GUI of course and as we don't

399
00:21:54,140 --> 00:21:59,540
have the name we have to get it names

400
00:21:57,020 --> 00:22:03,860
like those okay so for instance the

401
00:21:59,540 --> 00:22:05,580
first one is the device path of the

402
00:22:03,860 --> 00:22:09,270
management engine

403
00:22:05,580 --> 00:22:12,419
driver the second one is from one Intel

404
00:22:09,270 --> 00:22:16,110
audio driver we need to get to pass that

405
00:22:12,420 --> 00:22:18,780
string to create file okay how do we get

406
00:22:16,110 --> 00:22:20,580
that well either by dynamically with

407
00:22:18,780 --> 00:22:27,030
winnable sorry

408
00:22:20,580 --> 00:22:30,179
with win object or by reverse

409
00:22:27,030 --> 00:22:36,330
engineering the driver getting the

410
00:22:30,180 --> 00:22:39,090
gooood and then using this code to get

411
00:22:36,330 --> 00:22:43,260
the actual the actual device but this is

412
00:22:39,090 --> 00:22:46,860
using the set up di api of the OS and

413
00:22:43,260 --> 00:22:50,330
that gets the actual device path that

414
00:22:46,860 --> 00:22:54,750
you need rights it's a mess but it works

415
00:22:50,330 --> 00:22:56,760
and one thing to know this I don't know

416
00:22:54,750 --> 00:22:59,610
why but when object doesn't actually

417
00:22:56,760 --> 00:23:02,180
show you the reference string so the

418
00:22:59,610 --> 00:23:07,459
reference string in the case of the

419
00:23:02,180 --> 00:23:07,460
second device spot is that gray powder

420
00:23:09,230 --> 00:23:19,410
onion did you need that again when you

421
00:23:14,430 --> 00:23:23,370
do this by default you have open HCL's

422
00:23:19,410 --> 00:23:25,200
for low privileged users so unless they

423
00:23:23,370 --> 00:23:27,300
are setting on a strict ACL you can

424
00:23:25,200 --> 00:23:29,280
actually open a handle to the device and

425
00:23:27,300 --> 00:23:36,260
even then you still have to check the

426
00:23:29,280 --> 00:23:40,250
any access of all the i/o controls okay

427
00:23:36,260 --> 00:23:44,760
and how does came DF access the buffers

428
00:23:40,250 --> 00:23:48,600
before they have to to check the istick

429
00:23:44,760 --> 00:23:51,390
locations now they get a request and

430
00:23:48,600 --> 00:23:55,469
they can use this nice API to specify a

431
00:23:51,390 --> 00:23:57,270
minimum required length and they

432
00:23:55,470 --> 00:24:01,590
actually get the the actual length in

433
00:23:57,270 --> 00:24:05,910
the fourth parameter and if this I seen

434
00:24:01,590 --> 00:24:08,340
people seen drivers using this API in a

435
00:24:05,910 --> 00:24:12,690
bad way because they either put that to

436
00:24:08,340 --> 00:24:15,780
zero which is bad or they put that to

437
00:24:12,690 --> 00:24:17,880
some value but then the reference an

438
00:24:15,780 --> 00:24:18,910
offset that is beyond the minimum

439
00:24:17,880 --> 00:24:22,150
required length

440
00:24:18,910 --> 00:24:24,550
so you can actually get an out of bounds

441
00:24:22,150 --> 00:24:33,490
free the right depending on the

442
00:24:24,550 --> 00:24:35,500
operation yeah and well you have the

443
00:24:33,490 --> 00:24:38,620
same set of API for retrieving the open

444
00:24:35,500 --> 00:24:42,460
buffers and in the case you are doing

445
00:24:38,620 --> 00:24:52,590
directa yo you're also can can do the

446
00:24:42,460 --> 00:24:52,590
the second set which artful 4md else and

447
00:24:52,710 --> 00:25:00,220
fermented neither Kim D F doesn't want

448
00:24:55,870 --> 00:25:03,389
you to use method neither so to if you

449
00:25:00,220 --> 00:25:08,920
really want to do this you will see that

450
00:25:03,390 --> 00:25:11,350
you need to call those API so WTF

451
00:25:08,920 --> 00:25:13,720
request retrieve unsafe user input

452
00:25:11,350 --> 00:25:15,699
buffer there the name suggest to the

453
00:25:13,720 --> 00:25:18,790
developer that what they do in our work

454
00:25:15,700 --> 00:25:21,310
is wrong and it has to be called in a

455
00:25:18,790 --> 00:25:24,310
special context so I haven't seen any

456
00:25:21,310 --> 00:25:28,360
driver using this really at least a

457
00:25:24,310 --> 00:25:30,460
third party about non PNP these are

458
00:25:28,360 --> 00:25:40,209
software drivers so for drivers that do

459
00:25:30,460 --> 00:25:42,940
not manage a device from PNP what what

460
00:25:40,210 --> 00:25:47,080
matters is that they set a special flag

461
00:25:42,940 --> 00:25:49,030
in the create in the WD DF driver config

462
00:25:47,080 --> 00:25:51,730
and then they create a control device

463
00:25:49,030 --> 00:25:54,820
object the control device object is

464
00:25:51,730 --> 00:25:58,540
pretty much the same as the normal

465
00:25:54,820 --> 00:26:02,310
device object that we know for from WDM

466
00:25:58,540 --> 00:26:05,950
they follow that flow they create a

467
00:26:02,310 --> 00:26:07,629
control device in it and then they

468
00:26:05,950 --> 00:26:11,130
assign in the name they create device

469
00:26:07,630 --> 00:26:17,140
create the same link creates a queue and

470
00:26:11,130 --> 00:26:20,590
assigns 1100 to it and that's it what

471
00:26:17,140 --> 00:26:23,350
matters in here is the first call wdf

472
00:26:20,590 --> 00:26:26,560
control device in its allocate actually

473
00:26:23,350 --> 00:26:30,040
receives an sedl string that specified

474
00:26:26,560 --> 00:26:37,090
what are the permissions what's the

475
00:26:30,040 --> 00:26:40,409
the dacl we can get that in the

476
00:26:37,090 --> 00:26:43,418
progression engineering through Ryder

477
00:26:40,410 --> 00:26:49,690
get the sedl string and use a tool like

478
00:26:43,419 --> 00:26:52,960
a CDL barstool like that and we see that

479
00:26:49,690 --> 00:26:55,510
the strings the NASA tonicity string

480
00:26:52,960 --> 00:26:58,630
that is being passed to a CDL parses

481
00:26:55,510 --> 00:27:01,090
well part and we see that the everyone

482
00:26:58,630 --> 00:27:02,860
group is able to open a handle with

483
00:27:01,090 --> 00:27:12,250
rhythm and right people digits in this

484
00:27:02,860 --> 00:27:23,729
case so that's good I will now show a

485
00:27:12,250 --> 00:27:23,730
quick demo how everything is

486
00:27:29,340 --> 00:27:43,270
okay so I have either bro here this is a

487
00:27:35,670 --> 00:27:54,040
ap filter don't have the symbols of

488
00:27:43,270 --> 00:27:57,520
course and I made this nasty script that

489
00:27:54,040 --> 00:28:01,059
will help us to put the names to to get

490
00:27:57,520 --> 00:28:09,129
to the stuff that we care while we are

491
00:28:01,059 --> 00:28:13,090
reversing for bug hunting okay so we're

492
00:28:09,130 --> 00:28:15,460
there and you see I before actually

493
00:28:13,090 --> 00:28:20,080
executing the script this is a driver

494
00:28:15,460 --> 00:28:24,130
entry but if you see that the this is

495
00:28:20,080 --> 00:28:31,210
actually the rapper from a MDF there

496
00:28:24,130 --> 00:28:33,250
this is a call to WTF version bind this

497
00:28:31,210 --> 00:28:41,460
is the structure

498
00:28:33,250 --> 00:28:46,960
WTF find info as a subversion here so an

499
00:28:41,460 --> 00:28:51,870
actual driver entry should be here this

500
00:28:46,960 --> 00:28:55,059
one and again we see calls and calls but

501
00:28:51,870 --> 00:28:58,270
we see things like this right we don't

502
00:28:55,059 --> 00:29:05,280
really know what it's doing it's

503
00:28:58,270 --> 00:29:05,280
difficult but running this

504
00:29:14,539 --> 00:29:22,459
well it puts the names on it now we can

505
00:29:18,849 --> 00:29:26,809
more easily navigate through what I just

506
00:29:22,459 --> 00:29:32,839
described here's the driver ad so we can

507
00:29:26,809 --> 00:29:35,629
work here and yeah some are you control

508
00:29:32,839 --> 00:29:40,070
routine there and it also opens some

509
00:29:35,629 --> 00:29:43,928
information here for instance it's a

510
00:29:40,070 --> 00:29:52,519
control device as DDL at this location

511
00:29:43,929 --> 00:29:59,479
so if you go there we see them actualize

512
00:29:52,519 --> 00:30:01,369
DDL if we do the xref we see several

513
00:29:59,479 --> 00:30:04,569
instances of this being used so that

514
00:30:01,369 --> 00:30:10,129
means several devices are being created

515
00:30:04,569 --> 00:30:13,519
and for instance in this case we had

516
00:30:10,129 --> 00:30:18,158
here this is the same link so apparently

517
00:30:13,519 --> 00:30:26,559
there is a device named simply called up

518
00:30:18,159 --> 00:30:30,889
filter ap filter and then it calls the

519
00:30:26,559 --> 00:30:34,789
device create trace the symbolic link

520
00:30:30,889 --> 00:30:37,639
and then increase a queue and it sets a

521
00:30:34,789 --> 00:30:41,719
device higher control here right so

522
00:30:37,639 --> 00:30:43,609
that's something we can look at we need

523
00:30:41,719 --> 00:30:47,329
to parse out STL and see if we can open

524
00:30:43,609 --> 00:30:49,968
a handle or we can do it dynamically of

525
00:30:47,329 --> 00:30:52,489
course but I'm showing the reversion

526
00:30:49,969 --> 00:30:55,879
approach and this in this case now that

527
00:30:52,489 --> 00:30:58,549
we found this particular callback can go

528
00:30:55,879 --> 00:31:01,369
here and we can start actually reverse

529
00:30:58,549 --> 00:31:04,369
engineering this which if you see it's

530
00:31:01,369 --> 00:31:08,079
pretty nasty and big okay they're

531
00:31:04,369 --> 00:31:14,799
certainly they're likely to be bugs and

532
00:31:08,079 --> 00:31:18,339
actually if we all show some one quickly

533
00:31:14,799 --> 00:31:18,339
have it here

534
00:31:20,780 --> 00:31:24,350
yeah sorry

535
00:31:30,730 --> 00:31:33,480
hmm

536
00:31:41,270 --> 00:31:47,300
okay have it here it's comparing the IO

537
00:31:44,330 --> 00:31:52,060
control to this value and if it's if it

538
00:31:47,300 --> 00:31:54,800
matches then it goes here right and

539
00:31:52,060 --> 00:32:00,080
cause this function and if you go into

540
00:31:54,800 --> 00:32:02,000
this function we by looking at this we

541
00:32:00,080 --> 00:32:04,310
get the idea of what this is doing this

542
00:32:02,000 --> 00:32:08,420
is retrieving the an output buffer this

543
00:32:04,310 --> 00:32:13,129
is mapping memory that we can specify

544
00:32:08,420 --> 00:32:15,620
the address and size and then it is

545
00:32:13,130 --> 00:32:20,830
calling this function if we opened it we

546
00:32:15,620 --> 00:32:23,179
see this is kind of man copy right and

547
00:32:20,830 --> 00:32:24,949
then it's done it's sun mapping and

548
00:32:23,180 --> 00:32:27,290
returning that content so this is

549
00:32:24,950 --> 00:32:38,860
basically arbitrary physical memory

550
00:32:27,290 --> 00:32:38,860
reading from user mode right okay

551
00:32:41,920 --> 00:32:52,060
okay about new waters in WDM when you

552
00:32:49,770 --> 00:32:54,490
specify it when you call device head

553
00:32:52,060 --> 00:32:58,899
control with null for buffer lengths or

554
00:32:54,490 --> 00:33:02,590
no just just a new buffer you get the

555
00:32:58,900 --> 00:33:06,670
ear system buffer and MDL address said

556
00:33:02,590 --> 00:33:09,300
to know and if a driver doesn't check

557
00:33:06,670 --> 00:33:13,060
that of course you get a blue stream

558
00:33:09,300 --> 00:33:18,340
that still happens in 2019 I have some

559
00:33:13,060 --> 00:33:22,720
actual box related add-in and this not

560
00:33:18,340 --> 00:33:24,939
exactly that thing but similar but in

561
00:33:22,720 --> 00:33:27,760
the case of K and EF it's no longer like

562
00:33:24,940 --> 00:33:31,420
that because you get again that nice API

563
00:33:27,760 --> 00:33:32,770
and the first condition is that the

564
00:33:31,420 --> 00:33:35,530
minimum required length should be zero

565
00:33:32,770 --> 00:33:41,590
okay so the developer should have said

566
00:33:35,530 --> 00:33:45,520
that zero so you can get a request to to

567
00:33:41,590 --> 00:33:48,370
actually be read by the driver the

568
00:33:45,520 --> 00:33:51,870
second thing is that even if that's set

569
00:33:48,370 --> 00:33:58,979
to zero as we see in that case the

570
00:33:51,870 --> 00:34:02,020
status from the callback is nonzero so

571
00:33:58,980 --> 00:34:06,640
unless the developer also forgot to

572
00:34:02,020 --> 00:34:10,989
check the status you will not get a new

573
00:34:06,640 --> 00:34:14,230
reference out of that the code actually

574
00:34:10,989 --> 00:34:17,560
automatically says stead that when the

575
00:34:14,230 --> 00:34:19,179
length is zero returned the status

576
00:34:17,560 --> 00:34:24,009
buffer too small and that's different

577
00:34:19,179 --> 00:34:26,320
than zero non-success the same thing

578
00:34:24,010 --> 00:34:29,770
goes for read and write request you have

579
00:34:26,320 --> 00:34:33,040
to have a queue specifying the allowed

580
00:34:29,770 --> 00:34:34,810
length requested to true zero length

581
00:34:33,040 --> 00:34:38,620
request set to true and by default is

582
00:34:34,810 --> 00:34:40,509
false so it's very hard to find those

583
00:34:38,620 --> 00:34:45,730
kind of issues now I know the references

584
00:34:40,510 --> 00:34:47,980
of dos kind are really hard to find so

585
00:34:45,730 --> 00:34:53,050
what kind of issues we find well with

586
00:34:47,980 --> 00:34:55,719
Luke I'm fine well unsanitized data like

587
00:34:53,050 --> 00:35:00,049
indexes offset pointers

588
00:34:55,719 --> 00:35:04,629
also when the Emmentaler default type is

589
00:35:00,049 --> 00:35:06,829
used you can have a type confusion

590
00:35:04,630 --> 00:35:11,599
privilege operation exposed that the one

591
00:35:06,829 --> 00:35:14,599
that I just saw and like more things

592
00:35:11,599 --> 00:35:17,140
like registry key settings I approach

593
00:35:14,599 --> 00:35:20,829
reading and writing which will mean

594
00:35:17,140 --> 00:35:23,390
pound but just wait because of that

595
00:35:20,829 --> 00:35:25,789
object leakage rate conditions when

596
00:35:23,390 --> 00:35:28,190
using directa yo and cannot point to

597
00:35:25,789 --> 00:35:31,640
leakage in output buffers as well that's

598
00:35:28,190 --> 00:35:36,619
pretty common so this is a camera driver

599
00:35:31,640 --> 00:35:40,640
from Intel you see that it's actually

600
00:35:36,619 --> 00:35:43,339
checking the length to be 648

601
00:35:40,640 --> 00:35:46,160
underpasses that's well we we pass a

602
00:35:43,339 --> 00:35:49,279
buffer which larger than that but then

603
00:35:46,160 --> 00:35:53,299
what it's doing is taking the first D

604
00:35:49,279 --> 00:35:55,430
word and using it to construct an index

605
00:35:53,299 --> 00:35:58,309
under reference indirectly so that's bad

606
00:35:55,430 --> 00:36:01,819
you have an an out of both reads there

607
00:35:58,309 --> 00:36:06,259
I think since English eyes are pretty

608
00:36:01,819 --> 00:36:09,529
common came the effort won't save you

609
00:36:06,259 --> 00:36:14,589
there so another thing that I saw is

610
00:36:09,529 --> 00:36:17,710
when using the event il default callback

611
00:36:14,589 --> 00:36:19,788
again this is the callback that gets

612
00:36:17,710 --> 00:36:23,539
called by the framework when there's no

613
00:36:19,789 --> 00:36:26,779
another specific set for instance for

614
00:36:23,539 --> 00:36:30,440
reading or writing and what I saw once

615
00:36:26,779 --> 00:36:34,400
is that I could pass that get the ear

616
00:36:30,440 --> 00:36:38,029
got the hip get to get the buffer length

617
00:36:34,400 --> 00:36:40,730
it just added 10 which was weird and

618
00:36:38,029 --> 00:36:44,779
then calls a function that I call finish

619
00:36:40,730 --> 00:36:46,579
processing which then took the the

620
00:36:44,779 --> 00:36:50,509
buffer length and the reference that

621
00:36:46,579 --> 00:36:55,039
plus 28 so that basically took a length

622
00:36:50,509 --> 00:36:56,509
as a pointer and I don't know at first I

623
00:36:55,039 --> 00:37:00,289
didn't know what happened then I

624
00:36:56,509 --> 00:37:02,890
realized okay what happened is that they

625
00:37:00,289 --> 00:37:07,160
were expecting another kind of request

626
00:37:02,890 --> 00:37:09,410
but by setting that by setting an actual

627
00:37:07,160 --> 00:37:13,310
IO control you can

628
00:37:09,410 --> 00:37:20,299
did with that length there and that's

629
00:37:13,310 --> 00:37:28,580
bad another kind of fish as well I found

630
00:37:20,300 --> 00:37:31,700
that for bus drivers in in in Windows

631
00:37:28,580 --> 00:37:35,299
there is this sample code that you can

632
00:37:31,700 --> 00:37:38,120
have for the ischial driver and you have

633
00:37:35,300 --> 00:37:43,340
this toast driver toaster driver that is

634
00:37:38,120 --> 00:37:47,950
public in in the Microsoft github and I

635
00:37:43,340 --> 00:37:50,770
found out what the code was doing is

636
00:37:47,950 --> 00:37:53,810
exposing an API that allows you to add

637
00:37:50,770 --> 00:37:57,110
device objects to the bus driver so the

638
00:37:53,810 --> 00:38:01,670
bus driver needs to enumerate devices

639
00:37:57,110 --> 00:38:02,870
right and on each enumeration it passes

640
00:38:01,670 --> 00:38:06,770
informations to the play and play

641
00:38:02,870 --> 00:38:11,359
manager that uses it to build the device

642
00:38:06,770 --> 00:38:15,350
three came the F for this provides what

643
00:38:11,360 --> 00:38:17,390
it's called a child list and each time a

644
00:38:15,350 --> 00:38:20,690
bus driver identifies a child device it

645
00:38:17,390 --> 00:38:22,549
must add the child device descriptions

646
00:38:20,690 --> 00:38:25,370
to the child list and then create a

647
00:38:22,550 --> 00:38:30,500
physical device object that happens by

648
00:38:25,370 --> 00:38:32,810
calling that API there now that ABI

649
00:38:30,500 --> 00:38:35,900
should be call in two situations now

650
00:38:32,810 --> 00:38:38,420
first when you have an interrupt for

651
00:38:35,900 --> 00:38:41,210
instance you plug a device so the bar

652
00:38:38,420 --> 00:38:44,570
ability text that should add a new

653
00:38:41,210 --> 00:38:47,510
instance of a child and then when there

654
00:38:44,570 --> 00:38:50,720
is a device that enters it's working

655
00:38:47,510 --> 00:38:54,470
state again after being asleep so I

656
00:38:50,720 --> 00:38:57,470
found that in the Microsoft code the

657
00:38:54,470 --> 00:39:00,379
sample code they were posting that

658
00:38:57,470 --> 00:39:02,750
operation as an IO control so you can

659
00:39:00,380 --> 00:39:04,910
call it infinite in infinite times the

660
00:39:02,750 --> 00:39:07,790
system will collapse because the object

661
00:39:04,910 --> 00:39:11,120
will start leaking if you close your

662
00:39:07,790 --> 00:39:12,940
program you will do you object and still

663
00:39:11,120 --> 00:39:15,560
be there so it's actually object leakage

664
00:39:12,940 --> 00:39:19,280
yeah if you open the Vice you will see

665
00:39:15,560 --> 00:39:20,900
something like that you have a parent

666
00:39:19,280 --> 00:39:23,349
device and all those devices as

667
00:39:20,900 --> 00:39:28,460
thousands of devices created

668
00:39:23,349 --> 00:39:30,170
now that's there I saw some concrete

669
00:39:28,460 --> 00:39:33,710
implementations of this in Microsoft

670
00:39:30,170 --> 00:39:36,770
visual with the bus driver intro will

671
00:39:33,710 --> 00:39:41,210
display as well and some other gaming

672
00:39:36,770 --> 00:39:43,490
devices as well gaming drivers not only

673
00:39:41,210 --> 00:39:47,060
that but also when when you when you

674
00:39:43,490 --> 00:39:49,430
have this implementation you all's your

675
00:39:47,060 --> 00:39:51,650
attack self is also increases because as

676
00:39:49,430 --> 00:39:54,200
you can pass the identification

677
00:39:51,650 --> 00:39:55,910
description an address description those

678
00:39:54,200 --> 00:40:01,819
instructors are and those structures are

679
00:39:55,910 --> 00:40:04,220
driver defined you can end up attacking

680
00:40:01,819 --> 00:40:09,859
you can attack the implementation of

681
00:40:04,220 --> 00:40:12,379
those calls down there those are the the

682
00:40:09,859 --> 00:40:17,960
functions that the driver said in order

683
00:40:12,380 --> 00:40:20,150
to have the the new child device to the

684
00:40:17,960 --> 00:40:21,589
child list he has to parse what you

685
00:40:20,150 --> 00:40:24,470
specify in the identification

686
00:40:21,589 --> 00:40:29,029
description and address description so

687
00:40:24,470 --> 00:40:31,669
it's more attack surface basically as an

688
00:40:29,030 --> 00:40:36,050
example of kernel pointer leakage I have

689
00:40:31,670 --> 00:40:39,170
the synaptic touch pad driver seen GP

690
00:40:36,050 --> 00:40:43,190
dot says ii i saw this driver being used

691
00:40:39,170 --> 00:40:47,680
by some HP laptops lenovo and also a sir

692
00:40:43,190 --> 00:40:51,430
i don't know if other laptops uses maybe

693
00:40:47,680 --> 00:40:54,290
for all those i/o control calls they all

694
00:40:51,430 --> 00:40:57,379
return kernel pointers so it was really

695
00:40:54,290 --> 00:41:01,400
bad we found this to sign ethics they

696
00:40:57,380 --> 00:41:03,770
fix it but they they then came back to

697
00:41:01,400 --> 00:41:05,300
us saying that not all audience are

698
00:41:03,770 --> 00:41:09,319
actually you're using the official

699
00:41:05,300 --> 00:41:11,270
update for different reasons so if you

700
00:41:09,319 --> 00:41:13,099
have this you should check your actual

701
00:41:11,270 --> 00:41:17,329
implementation i couldn't check

702
00:41:13,099 --> 00:41:18,560
everything of course i have a video of

703
00:41:17,329 --> 00:41:22,540
this if you want to see it

704
00:41:18,560 --> 00:41:22,540
so just a sec

705
00:41:30,769 --> 00:41:41,959
so that's the device this is a this is a

706
00:41:38,910 --> 00:41:44,279
I think it is a buying go machine I

707
00:41:41,960 --> 00:41:53,309
don't know if it's known here this is

708
00:41:44,279 --> 00:41:56,119
known in Argentina and I'm showing now

709
00:41:53,309 --> 00:41:59,809
that any user can actually open it

710
00:41:56,119 --> 00:42:06,569
handle to the control device of

711
00:41:59,809 --> 00:42:20,880
synaptics everyone has read and write

712
00:42:06,569 --> 00:42:23,519
permissions so we just call it right and

713
00:42:20,880 --> 00:42:31,410
yeah all of those are current pointers

714
00:42:23,519 --> 00:42:33,328
valid kernel pointers I have to stop

715
00:42:31,410 --> 00:42:44,640
because I mean it really looks a lot I

716
00:42:33,329 --> 00:42:47,640
don't know okay okay how do you find

717
00:42:44,640 --> 00:42:50,788
this it's easy you just work for every

718
00:42:47,640 --> 00:42:52,650
binary you have asset driver and check

719
00:42:50,789 --> 00:42:54,299
that they are importing from that

720
00:42:52,650 --> 00:42:58,799
library it's the importer library it's

721
00:42:54,299 --> 00:43:03,420
certainly a canvas and you can start

722
00:42:58,799 --> 00:43:05,579
analyzing it so yeah you need to check

723
00:43:03,420 --> 00:43:07,019
the drivers the third party bus drivers

724
00:43:05,579 --> 00:43:07,559
are a good target talked about drivers

725
00:43:07,019 --> 00:43:09,930
as well

726
00:43:07,559 --> 00:43:13,650
camera gamer devices those are really

727
00:43:09,930 --> 00:43:15,690
good as well so as the conclusion came

728
00:43:13,650 --> 00:43:18,059
the F yeah dusting hay security by

729
00:43:15,690 --> 00:43:21,480
default it by default sets file device

730
00:43:18,059 --> 00:43:24,390
secured up and no more of that ACL

731
00:43:21,480 --> 00:43:26,849
bypass that I showed before no new

732
00:43:24,390 --> 00:43:30,868
buffers unless you really want to you

733
00:43:26,849 --> 00:43:34,019
know new buffers it also discussed the

734
00:43:30,869 --> 00:43:36,079
use of method neither there are better

735
00:43:34,019 --> 00:43:38,220
api's to access the request and

736
00:43:36,079 --> 00:43:40,210
deformations to check sizes everything

737
00:43:38,220 --> 00:43:42,669
so that's good

738
00:43:40,210 --> 00:43:46,890
but there are many things that still can

739
00:43:42,670 --> 00:43:49,750
go wrong by the ACL for device object

740
00:43:46,890 --> 00:43:51,940
because privilege operations are being

741
00:43:49,750 --> 00:43:55,569
exposed and it shouldn't be accessed by

742
00:43:51,940 --> 00:43:59,500
regular applications regular users the

743
00:43:55,569 --> 00:44:02,710
data buffer the the data in the buffer

744
00:43:59,500 --> 00:44:05,410
should be treated carefully and the API

745
00:44:02,710 --> 00:44:08,130
is even in there if they are better they

746
00:44:05,410 --> 00:44:10,720
can be used wrongly as I show before

747
00:44:08,130 --> 00:44:17,040
there can still be race condition with

748
00:44:10,720 --> 00:44:19,118
when using direct IO and well they

749
00:44:17,040 --> 00:44:20,558
double-check the content being reading

750
00:44:19,119 --> 00:44:23,260
into the orbit buffer code we have

751
00:44:20,559 --> 00:44:28,510
things like that synaptics touchpad

752
00:44:23,260 --> 00:44:31,000
drivers we see well those are the

753
00:44:28,510 --> 00:44:32,880
references and that's all if you have

754
00:44:31,000 --> 00:44:57,340
any questions

755
00:44:32,880 --> 00:44:57,340
[Music]

