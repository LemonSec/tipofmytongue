1
00:00:00,030 --> 00:00:03,240
all right so good afternoon everybody my

2
00:00:03,240 --> 00:00:06,150
name is Mercurius okie and I'm doing a

3
00:00:06,150 --> 00:00:08,220
PhD in Worcester Polytechnic Institute

4
00:00:08,220 --> 00:00:12,030
in Massachusetts and the topic of my

5
00:00:12,030 --> 00:00:13,679
research project is side-channel attacks

6
00:00:13,679 --> 00:00:15,389
in the cloud and that's what I'm going

7
00:00:15,389 --> 00:00:18,570
to try to explain today this is the

8
00:00:18,570 --> 00:00:21,180
outline that we're gonna follow first of

9
00:00:21,180 --> 00:00:22,080
all we're gonna talk about the

10
00:00:22,080 --> 00:00:24,510
motivation for us to spend money in such

11
00:00:24,510 --> 00:00:25,369
a project

12
00:00:25,369 --> 00:00:29,779
then we're gonna if a brief overview of

13
00:00:29,779 --> 00:00:32,549
the Welcome that we need to understand

14
00:00:32,549 --> 00:00:34,530
the attacks wielding the cloud and then

15
00:00:34,530 --> 00:00:35,850
we're gonna actually explain the attacks

16
00:00:35,850 --> 00:00:37,020
with it the two attacks that we did

17
00:00:37,020 --> 00:00:40,020
Bernstein and flash and reload then

18
00:00:40,020 --> 00:00:41,190
we're going to discuss some possible

19
00:00:41,190 --> 00:00:43,110
confirmations and then give some

20
00:00:43,110 --> 00:00:47,550
conclusions so let's start they want to

21
00:00:47,550 --> 00:00:49,050
assume for us is pretty clear we have a

22
00:00:49,050 --> 00:00:50,940
widely used system which is the cloud

23
00:00:50,940 --> 00:00:53,430
system right and actually we can see

24
00:00:53,430 --> 00:00:55,620
that in a graph i'm showing to you we

25
00:00:55,620 --> 00:00:58,109
can see let's see if the mouse works yes

26
00:00:58,109 --> 00:01:00,449
so we can see that in 2005 the usage of

27
00:01:00,449 --> 00:01:02,039
physical machines which was much more

28
00:01:02,039 --> 00:01:05,280
than the usage of virtual machines but

29
00:01:05,280 --> 00:01:06,600
we also see that we have a tipping point

30
00:01:06,600 --> 00:01:09,390
in 2009 in which the usage of both of

31
00:01:09,390 --> 00:01:12,299
them were was almost even and in 2013

32
00:01:12,299 --> 00:01:14,070
actually the usage of will to machine

33
00:01:14,070 --> 00:01:16,140
machines increased a lot so that almost

34
00:01:16,140 --> 00:01:18,420
doubles the usage of Britain of physical

35
00:01:18,420 --> 00:01:22,619
machines so as researchers we asked

36
00:01:22,619 --> 00:01:26,540
ourselves if these beautiful machines

37
00:01:26,540 --> 00:01:29,670
implement some Sun box in some box in

38
00:01:29,670 --> 00:01:31,619
techniques to try solid processes right

39
00:01:31,619 --> 00:01:33,329
so if one brutal machine can recover

40
00:01:33,329 --> 00:01:35,369
information from other bit to machine

41
00:01:35,369 --> 00:01:38,250
and since we're working in side channel

42
00:01:38,250 --> 00:01:41,520
attacks we actually are gonna focus in

43
00:01:41,520 --> 00:01:43,890
hardware leakage right we're interested

44
00:01:43,890 --> 00:01:46,649
in since we know that the cloud is based

45
00:01:46,649 --> 00:01:48,450
on offering resources for more than one

46
00:01:48,450 --> 00:01:50,939
user if we have to build two machines

47
00:01:50,939 --> 00:01:52,320
using the same hardware we want to know

48
00:01:52,320 --> 00:01:56,340
if the usage of the usage of a shared

49
00:01:56,340 --> 00:01:58,229
hardware leaks some information to an

50
00:01:58,229 --> 00:02:00,060
attacker interesting them on inference

51
00:02:00,060 --> 00:02:03,689
on some kind of key for example so the

52
00:02:03,689 --> 00:02:04,890
child these are the kind of questions

53
00:02:04,890 --> 00:02:07,020
that motivated that motivated us to

54
00:02:07,020 --> 00:02:09,750
start a project the project but also the

55
00:02:09,750 --> 00:02:11,940
previous publications that have been

56
00:02:11,940 --> 00:02:13,980
done right for example one of the

57
00:02:13,980 --> 00:02:15,629
important ones is hey you get off my

58
00:02:15,629 --> 00:02:19,290
cloud was written by wrist and part and

59
00:02:19,290 --> 00:02:20,970
so mobile called force and what they

60
00:02:20,970 --> 00:02:23,930
managed to is in public cloud system

61
00:02:23,930 --> 00:02:27,810
they co-located the attackers built on

62
00:02:27,810 --> 00:02:29,790
machine with a big team spirit of

63
00:02:29,790 --> 00:02:32,040
machines so that they are both using the

64
00:02:32,040 --> 00:02:34,920
same the same shared hardware this is

65
00:02:34,920 --> 00:02:36,900
really important because now that we can

66
00:02:36,900 --> 00:02:38,519
kalokhe eight big team spirit of machine

67
00:02:38,519 --> 00:02:39,900
and attackers crypto machine we can

68
00:02:39,900 --> 00:02:42,390
actually implement non side-channel

69
00:02:42,390 --> 00:02:45,659
attacks in the cloud and that's what

70
00:02:45,659 --> 00:02:47,220
actually sang and some other co-authors

71
00:02:47,220 --> 00:02:50,190
did in the in their paper home alone in

72
00:02:50,190 --> 00:02:52,680
which they are using a side channel well

73
00:02:52,680 --> 00:02:54,000
side channel techniques to the tech

74
00:02:54,000 --> 00:02:56,040
water they are using along the hardware

75
00:02:56,040 --> 00:02:57,480
or they are co-located with some other

76
00:02:57,480 --> 00:03:01,739
tenant but also they they use that side

77
00:03:01,739 --> 00:03:04,109
channel technique to attack an alchemy

78
00:03:04,109 --> 00:03:05,310
link will to recover an elgamal

79
00:03:05,310 --> 00:03:07,950
encryption key across X n brutal

80
00:03:07,950 --> 00:03:10,109
machines with well the name of this

81
00:03:10,109 --> 00:03:11,700
channel taking experiment proof we will

82
00:03:11,700 --> 00:03:13,019
see it later on so don't worry about

83
00:03:13,019 --> 00:03:15,660
that so yeah this is kind of the

84
00:03:15,660 --> 00:03:17,129
motivation we needed to start the

85
00:03:17,129 --> 00:03:19,889
project and before we implement any

86
00:03:19,889 --> 00:03:21,239
attack we need to have some background

87
00:03:21,239 --> 00:03:23,069
right and that's what that's why we

88
00:03:23,069 --> 00:03:25,560
decided to do this outline and actually

89
00:03:25,560 --> 00:03:26,760
the first thing we have to know is how

90
00:03:26,760 --> 00:03:28,950
the cloud works right and here we're

91
00:03:28,950 --> 00:03:30,930
gonna give some main characteristics out

92
00:03:30,930 --> 00:03:33,359
the cloud systems well the first one I

93
00:03:33,359 --> 00:03:35,400
already mention it right and resources

94
00:03:35,400 --> 00:03:37,470
for one of one physical hosts are

95
00:03:37,470 --> 00:03:40,230
provided for more than one client so

96
00:03:40,230 --> 00:03:41,790
this means that users are gonna share

97
00:03:41,790 --> 00:03:43,680
Hardware right so we have many users

98
00:03:43,680 --> 00:03:46,410
here using for example infrastructure

99
00:03:46,410 --> 00:03:51,389
cellular storage server so but also we

100
00:03:51,389 --> 00:03:52,709
have to have some hidden details of

101
00:03:52,709 --> 00:03:54,030
infrastructure because since we are

102
00:03:54,030 --> 00:03:55,620
sharing the hardware with other people

103
00:03:55,620 --> 00:03:58,139
we cannot have a full access to a

104
00:03:58,139 --> 00:03:59,220
hardware because that would mean

105
00:03:59,220 --> 00:04:01,829
compromising other people's data so we

106
00:04:01,829 --> 00:04:03,769
have to have some here and details there

107
00:04:03,769 --> 00:04:06,629
also these services are always on this

108
00:04:06,629 --> 00:04:09,269
means that if I want to run a

109
00:04:09,269 --> 00:04:11,099
computation that that takes for example

110
00:04:11,099 --> 00:04:13,470
10 hours and I'd rather do it in the

111
00:04:13,470 --> 00:04:15,989
cloud because in that way I'm not gonna

112
00:04:15,989 --> 00:04:18,389
consume my that my own resources like my

113
00:04:18,389 --> 00:04:19,978
laptop for example I can do something

114
00:04:19,978 --> 00:04:21,779
else in my laptop and then after 10

115
00:04:21,779 --> 00:04:23,190
hours I can go to a cloud and check if

116
00:04:23,190 --> 00:04:26,270
the result has been done

117
00:04:26,500 --> 00:04:28,150
also of course like everything in this

118
00:04:28,150 --> 00:04:30,730
life this is not free of course we have

119
00:04:30,730 --> 00:04:32,950
to pay for that and usually cloud

120
00:04:32,950 --> 00:04:35,560
providers they have a like a price and

121
00:04:35,560 --> 00:04:37,510
depending on the on the machine we're

122
00:04:37,510 --> 00:04:39,160
using so the more powerful the machine

123
00:04:39,160 --> 00:04:42,160
is the more expensive the price is going

124
00:04:42,160 --> 00:04:45,460
to be also these servers are accessed

125
00:04:45,460 --> 00:04:47,380
remotely so we might be using a hardware

126
00:04:47,380 --> 00:04:49,120
that is for example in California or

127
00:04:49,120 --> 00:04:51,130
Seattle while we're here so this is

128
00:04:51,130 --> 00:04:53,370
amazing

129
00:04:53,370 --> 00:04:57,220
well examples of public cloud providers

130
00:04:57,220 --> 00:04:59,920
for example well cloud projects can

131
00:04:59,920 --> 00:05:01,240
offer many services one of them is

132
00:05:01,240 --> 00:05:03,670
storage and I guess all of us know

133
00:05:03,670 --> 00:05:05,710
Dropbox right this is one of the main

134
00:05:05,710 --> 00:05:08,860
examples of storage cloud providers but

135
00:05:08,860 --> 00:05:10,210
it's not the only one surprisingly right

136
00:05:10,210 --> 00:05:11,380
we have more options we have Google

137
00:05:11,380 --> 00:05:13,510
Drive for example we have the spider

138
00:05:13,510 --> 00:05:15,850
Road and we have whoops sorry and we

139
00:05:15,850 --> 00:05:16,570
have onedrive

140
00:05:16,570 --> 00:05:19,810
so all these providers I offer storage

141
00:05:19,810 --> 00:05:22,720
so that we can store data in in their

142
00:05:22,720 --> 00:05:25,990
servers rather than in our computer but

143
00:05:25,990 --> 00:05:28,120
also infrastructure services coming can

144
00:05:28,120 --> 00:05:30,100
be offered this means that cloud Troyer

145
00:05:30,100 --> 00:05:32,560
so they're gonna offer powerful machines

146
00:05:32,560 --> 00:05:34,540
the powerful machines so that users are

147
00:05:34,540 --> 00:05:36,840
going to rent the the resources to

148
00:05:36,840 --> 00:05:39,160
compute for example heavy load heavy

149
00:05:39,160 --> 00:05:43,410
load computations and examples of this

150
00:05:43,410 --> 00:05:46,510
public cloud this kind of public cloud

151
00:05:46,510 --> 00:05:47,530
providers are Amazon

152
00:05:47,530 --> 00:05:50,440
Rackspace Google and Windows for example

153
00:05:50,440 --> 00:05:53,050
so you can see and big companies are

154
00:05:53,050 --> 00:05:55,150
starting to offer these this kind of

155
00:05:55,150 --> 00:05:57,310
service because they're seeing that it's

156
00:05:57,310 --> 00:05:59,380
widely used and you get benefit out of

157
00:05:59,380 --> 00:06:02,320
that so from now on in the presentation

158
00:06:02,320 --> 00:06:03,550
we're gonna focus on infrastructure

159
00:06:03,550 --> 00:06:08,740
cloud right and as we said well share is

160
00:06:08,740 --> 00:06:10,600
well resources are provide from for more

161
00:06:10,600 --> 00:06:12,550
than one user right but we explain how

162
00:06:12,550 --> 00:06:14,560
this is achieved right well it's it is

163
00:06:14,560 --> 00:06:16,090
achieved thanks to a virtualization

164
00:06:16,090 --> 00:06:19,450
technique in which well which has three

165
00:06:19,450 --> 00:06:21,160
main tasks first of all it has to

166
00:06:21,160 --> 00:06:23,470
provide virtual machines to the client

167
00:06:23,470 --> 00:06:25,180
so the client can feel like he's using

168
00:06:25,180 --> 00:06:28,360
his own OS or his desired OS in his

169
00:06:28,360 --> 00:06:31,150
humble in his own machine but also it

170
00:06:31,150 --> 00:06:33,460
has to give again abstraction of with

171
00:06:33,460 --> 00:06:35,770
the physical machine because again more

172
00:06:35,770 --> 00:06:37,000
than one user as we can see in the

173
00:06:37,000 --> 00:06:39,010
picture of the picture you can see three

174
00:06:39,010 --> 00:06:40,389
different

175
00:06:40,389 --> 00:06:44,439
that are using different oases right so

176
00:06:44,439 --> 00:06:45,519
since we have more than one usually

177
00:06:45,519 --> 00:06:47,799
using the same hardware we have to again

178
00:06:47,799 --> 00:06:49,299
have some abstraction with the physical

179
00:06:49,299 --> 00:06:51,639
machine if not we if we could access the

180
00:06:51,639 --> 00:06:53,559
whole memory we would be compromised in

181
00:06:53,559 --> 00:06:57,939
the dirt and said again and to control

182
00:06:57,939 --> 00:07:00,009
that we have a BM n BM m or hypervisor

183
00:07:00,009 --> 00:07:03,159
which actually controls the the accesses

184
00:07:03,159 --> 00:07:05,019
to a Hardware of each of which one of

185
00:07:05,019 --> 00:07:06,999
the guests of each one of the builds of

186
00:07:06,999 --> 00:07:09,099
machines and examples of these beams as

187
00:07:09,099 --> 00:07:12,309
I say there are x10 VMware well we have

188
00:07:12,309 --> 00:07:14,829
more we have kb m as well and hyper-v

189
00:07:14,829 --> 00:07:17,499
which are for me the four most known

190
00:07:17,499 --> 00:07:21,639
ones also this is the cloud and and

191
00:07:21,639 --> 00:07:23,229
what's the main concern here seen

192
00:07:23,229 --> 00:07:25,659
concerned since we're using the hardware

193
00:07:25,659 --> 00:07:27,939
with more than one people so the big

194
00:07:27,939 --> 00:07:30,249
concern is if my privacy is being

195
00:07:30,249 --> 00:07:34,299
compromised right so I guess this the

196
00:07:34,299 --> 00:07:35,949
answer to this question depends on the

197
00:07:35,949 --> 00:07:37,599
person you're asking - you're asking

198
00:07:37,599 --> 00:07:39,549
well we have an example feel example of

199
00:07:39,549 --> 00:07:43,419
this two weeks ago we had for example if

200
00:07:43,419 --> 00:07:45,849
we ask to iCloud or Apple we're already

201
00:07:45,849 --> 00:07:48,249
gonna say yeah my cloud doesn't have any

202
00:07:48,249 --> 00:07:51,459
any flaw in their security system but

203
00:07:51,459 --> 00:07:53,679
what happens if we ask Jennifer Lawrence

204
00:07:53,679 --> 00:07:55,839
or Kristin dust they're pretty sure that

205
00:07:55,839 --> 00:07:59,550
well this is Twitter that Kristen just

206
00:07:59,550 --> 00:08:02,769
wrote so yeah or all these sectors that

207
00:08:02,769 --> 00:08:04,719
have been hot will I guess their answer

208
00:08:04,719 --> 00:08:06,219
is gonna be pretty different to the

209
00:08:06,219 --> 00:08:08,979
answer of the cloud providers and my

210
00:08:08,979 --> 00:08:11,019
answer here is gonna be or the answer

211
00:08:11,019 --> 00:08:13,289
that I'm trying to say here is that an

212
00:08:13,289 --> 00:08:15,639
there is some hardware leakage that can

213
00:08:15,639 --> 00:08:18,099
be that should be avoided because that

214
00:08:18,099 --> 00:08:19,809
leakage can be converted into invalid

215
00:08:19,809 --> 00:08:23,589
information for an attacker and how are

216
00:08:23,589 --> 00:08:25,239
we going to do this well as I say here

217
00:08:25,239 --> 00:08:26,649
we're going to be thanks to side channel

218
00:08:26,649 --> 00:08:28,419
attacks and since we want to use and use

219
00:08:28,419 --> 00:08:31,119
them we have to explain what they are

220
00:08:31,119 --> 00:08:35,049
well side channel attacks so basically

221
00:08:35,049 --> 00:08:36,938
it's a tena attacks and measure a

222
00:08:36,938 --> 00:08:38,889
leakage coming from a secure process and

223
00:08:38,889 --> 00:08:40,599
income and I convert this leakage to

224
00:08:40,599 --> 00:08:42,429
valid information and the main idea is

225
00:08:42,429 --> 00:08:44,709
the one we've seen in the picture in

226
00:08:44,709 --> 00:08:47,319
which we have a box and we all know what

227
00:08:47,319 --> 00:08:49,630
the box contains when instead of opening

228
00:08:49,630 --> 00:08:51,670
it which would be the direct channel

229
00:08:51,670 --> 00:08:54,010
let's say we make sure it's powerful

230
00:08:54,010 --> 00:08:55,780
function for example and figure out

231
00:08:55,780 --> 00:08:57,070
what's inside the box

232
00:08:57,070 --> 00:08:59,380
so we're using a cover channel instead

233
00:08:59,380 --> 00:09:01,180
of the direct channel that's why we call

234
00:09:01,180 --> 00:09:03,030
them side channel attacks

235
00:09:03,030 --> 00:09:06,550
well these needs can come in many forms

236
00:09:06,550 --> 00:09:07,960
for example let's assume that we have

237
00:09:07,960 --> 00:09:10,030
any device here running at it say for

238
00:09:10,030 --> 00:09:13,780
example and we can actually measure the

239
00:09:13,780 --> 00:09:15,730
power consumption of this device and

240
00:09:15,730 --> 00:09:16,750
we're going to see that for different

241
00:09:16,750 --> 00:09:18,370
keys the power traces are going to look

242
00:09:18,370 --> 00:09:20,530
different so thanks to these differences

243
00:09:20,530 --> 00:09:22,450
we can infer what key has been used by

244
00:09:22,450 --> 00:09:26,590
the embed processor we can also do the

245
00:09:26,590 --> 00:09:27,430
same thing with the electromagnetic

246
00:09:27,430 --> 00:09:29,110
leakage we can measure electromagnetic

247
00:09:29,110 --> 00:09:31,000
emanation so we're going to see again

248
00:09:31,000 --> 00:09:32,620
that different electron Honda

249
00:09:32,620 --> 00:09:34,860
combinations yep

250
00:09:34,860 --> 00:09:38,560
refer to different keys bow so we can do

251
00:09:38,560 --> 00:09:40,120
the same thing with the execution time

252
00:09:40,120 --> 00:09:41,980
of a process there are some processes

253
00:09:41,980 --> 00:09:44,290
that are called execution time of some

254
00:09:44,290 --> 00:09:46,060
processes is key dependent this means

255
00:09:46,060 --> 00:09:48,160
that for one key we're gonna have more

256
00:09:48,160 --> 00:09:49,510
cycles for another key we're gonna have

257
00:09:49,510 --> 00:09:51,250
less this cycles and again this

258
00:09:51,250 --> 00:09:54,400
difference is in Hardware cycles and we

259
00:09:54,400 --> 00:09:55,780
can use them to to infer the key it has

260
00:09:55,780 --> 00:10:00,070
been used so right we want to use side

261
00:10:00,070 --> 00:10:01,360
channel attack we want to do them in the

262
00:10:01,360 --> 00:10:03,250
cloud but first of all the first thing

263
00:10:03,250 --> 00:10:05,710
we have to to find is good cover channel

264
00:10:05,710 --> 00:10:08,650
in the cloud right and this depends on

265
00:10:08,650 --> 00:10:09,670
the assumption that we're going to make

266
00:10:09,670 --> 00:10:10,770
as attackers

267
00:10:10,770 --> 00:10:12,880
first of all the first assumption is

268
00:10:12,880 --> 00:10:14,380
gonna be that we are the attacker and

269
00:10:14,380 --> 00:10:15,670
victim are co-located in the same

270
00:10:15,670 --> 00:10:17,830
physical machine but we have to be more

271
00:10:17,830 --> 00:10:19,390
specific here because the tiger and

272
00:10:19,390 --> 00:10:21,280
victim can be located in the same car in

273
00:10:21,280 --> 00:10:25,030
which case the attacker can use any any

274
00:10:25,030 --> 00:10:26,920
resource that is private per core right

275
00:10:26,920 --> 00:10:28,780
for example branch predictors level 1

276
00:10:28,780 --> 00:10:30,850
cache as we see in the picture so we see

277
00:10:30,850 --> 00:10:32,920
in the picture that the core 1 well Dale

278
00:10:32,920 --> 00:10:35,860
sorry the level 1 cache is private for

279
00:10:35,860 --> 00:10:37,870
each core so we can use the level 1

280
00:10:37,870 --> 00:10:40,570
cache branch predictors tlvs as well and

281
00:10:40,570 --> 00:10:42,640
so on but this is kind of a strong

282
00:10:42,640 --> 00:10:45,910
assumption because so public cloud

283
00:10:45,910 --> 00:10:47,860
providers offer machines that have maybe

284
00:10:47,860 --> 00:10:50,260
20 course so being located in the same

285
00:10:50,260 --> 00:10:52,690
course might be more or less difficult

286
00:10:52,690 --> 00:10:54,760
so what if we want to go farther away

287
00:10:54,760 --> 00:10:56,830
what if we want to be located in a

288
00:10:56,830 --> 00:10:57,610
different color

289
00:10:57,610 --> 00:11:00,070
well in this case we have to look for

290
00:11:00,070 --> 00:11:01,480
something shared a course course right

291
00:11:01,480 --> 00:11:03,820
something some Harvard research that is

292
00:11:03,820 --> 00:11:05,110
shared across curves

293
00:11:05,110 --> 00:11:07,570
and luckily for us and most modern

294
00:11:07,570 --> 00:11:10,720
processors have a last shared level of

295
00:11:10,720 --> 00:11:12,579
cache which we can use to attack

296
00:11:12,579 --> 00:11:15,519
accesses right so this is more or less

297
00:11:15,519 --> 00:11:17,170
the scenario that we're gonna follow so

298
00:11:17,170 --> 00:11:18,339
we have we're gonna have a big thing

299
00:11:18,339 --> 00:11:20,320
here making accesses to this chair level

300
00:11:20,320 --> 00:11:22,420
of cache while another attacker is gonna

301
00:11:22,420 --> 00:11:24,700
try to infer what what this access is

302
00:11:24,700 --> 00:11:29,440
were so nice we have a smooth level

303
00:11:29,440 --> 00:11:31,420
cover channel which is the cache right

304
00:11:31,420 --> 00:11:33,370
but we explain what the cache is the

305
00:11:33,370 --> 00:11:34,540
cache is basically a small memory

306
00:11:34,540 --> 00:11:36,990
located between the CPU and RAM and

307
00:11:36,990 --> 00:11:40,600
whose goal is to avoid penalties of well

308
00:11:40,600 --> 00:11:42,519
the penalty of going to a memory and the

309
00:11:42,519 --> 00:11:43,720
data from that from the memory

310
00:11:43,720 --> 00:11:48,459
so we have well this small memory that

311
00:11:48,459 --> 00:11:49,839
we're gonna insert well that Harvard

312
00:11:49,839 --> 00:11:51,250
assigns are going serve it in the memory

313
00:11:51,250 --> 00:11:54,130
on the under and the CPUs first of all

314
00:11:54,130 --> 00:11:55,420
it's gonna come it's going to store data

315
00:11:55,420 --> 00:11:57,339
that has been accessed recently because

316
00:11:57,339 --> 00:11:58,870
the CPU predicts that this data are

317
00:11:58,870 --> 00:12:01,899
gonna be accessed soon but also it

318
00:12:01,899 --> 00:12:02,860
stores data

319
00:12:02,860 --> 00:12:04,959
well data in nearby locations to the

320
00:12:04,959 --> 00:12:06,790
data that has been accessed again

321
00:12:06,790 --> 00:12:08,410
because the CPU predicts that are gonna

322
00:12:08,410 --> 00:12:10,930
be accessed soon again so this is the

323
00:12:10,930 --> 00:12:13,449
way it looks like we have two cores here

324
00:12:13,449 --> 00:12:15,399
and we have private level one cache for

325
00:12:15,399 --> 00:12:16,750
each one well the level 1 cache is

326
00:12:16,750 --> 00:12:18,430
divided into data and instruction cache

327
00:12:18,430 --> 00:12:20,769
and then we have a shared cache a shared

328
00:12:20,769 --> 00:12:22,709
level 2 cache and the main memory right

329
00:12:22,709 --> 00:12:25,660
so clearly and accesses to these small

330
00:12:25,660 --> 00:12:27,550
memories are gonna be faster than

331
00:12:27,550 --> 00:12:29,829
accesses to this shared unified cache

332
00:12:29,829 --> 00:12:32,290
and accesses to this shared unified

333
00:12:32,290 --> 00:12:33,970
cache organized faster than accesses to

334
00:12:33,970 --> 00:12:36,519
the main memory so this is these

335
00:12:36,519 --> 00:12:39,130
differences in access times is the what

336
00:12:39,130 --> 00:12:40,720
we're gonna use to to infer the key that

337
00:12:40,720 --> 00:12:44,649
has been used by a secure process so

338
00:12:44,649 --> 00:12:46,720
since we're gonna use cache side-channel

339
00:12:46,720 --> 00:12:48,130
attacks we need to know what's out there

340
00:12:48,130 --> 00:12:49,959
in ten in terms of cache side-channel

341
00:12:49,959 --> 00:12:52,329
attacks and we find out the first thing

342
00:12:52,329 --> 00:12:53,980
we find out is that they can be divided

343
00:12:53,980 --> 00:12:56,320
into three main categories the first one

344
00:12:56,320 --> 00:12:58,660
is accessed during attacks the second

345
00:12:58,660 --> 00:13:00,610
one is traced during attacks and the

346
00:13:00,610 --> 00:13:03,370
third ones are time driven attacks and

347
00:13:03,370 --> 00:13:05,140
the difference between all these

348
00:13:05,140 --> 00:13:07,720
categories is that all these are the

349
00:13:07,720 --> 00:13:10,540
capabilities that attacker has so in the

350
00:13:10,540 --> 00:13:12,579
first line access during cache attacks

351
00:13:12,579 --> 00:13:14,740
they kept the attacker knows the cache

352
00:13:14,740 --> 00:13:16,000
lines that have been accessed by the

353
00:13:16,000 --> 00:13:18,730
victim in trace during attacks and the

354
00:13:18,730 --> 00:13:20,410
Thackeray knows only a portion of the

355
00:13:20,410 --> 00:13:21,579
cash that has been accessed by the

356
00:13:21,579 --> 00:13:23,380
victim but he doesn't know the specific

357
00:13:23,380 --> 00:13:25,510
line that the victim accessed and

358
00:13:25,510 --> 00:13:27,639
intended any attacks and the tiger only

359
00:13:27,639 --> 00:13:29,380
knows the overall execution time of a

360
00:13:29,380 --> 00:13:32,920
sacred process so in order to illustrate

361
00:13:32,920 --> 00:13:35,320
you how cash attacks work I prepared two

362
00:13:35,320 --> 00:13:37,720
examples I have the instructions here

363
00:13:37,720 --> 00:13:39,250
but I guess it's better to see it

364
00:13:39,250 --> 00:13:41,350
graphically so we have let's say that we

365
00:13:41,350 --> 00:13:42,579
have the cache like this we have these

366
00:13:42,579 --> 00:13:46,389
memorylanes in the cache and let's say

367
00:13:46,389 --> 00:13:48,339
that we evict this line a week means

368
00:13:48,339 --> 00:13:50,260
that we'd replace it with some other

369
00:13:50,260 --> 00:13:52,510
memo some other memory line and so this

370
00:13:52,510 --> 00:13:53,920
one is going to go to a level 2 cache

371
00:13:53,920 --> 00:13:56,800
for example or to a main memory so if we

372
00:13:56,800 --> 00:13:59,440
do that and then evicting executors

373
00:13:59,440 --> 00:14:01,720
execute his AES encryption for example

374
00:14:01,720 --> 00:14:04,360
and AES didn't use discussion that we

375
00:14:04,360 --> 00:14:06,639
have octets from the cache this

376
00:14:06,639 --> 00:14:08,110
execution time is clearly gonna be

377
00:14:08,110 --> 00:14:09,940
shorter than if we do this let's say

378
00:14:09,940 --> 00:14:11,589
that we week the first one and a es

379
00:14:11,589 --> 00:14:14,500
needs it since we have it the first

380
00:14:14,500 --> 00:14:16,300
memory line and AES actually needs it

381
00:14:16,300 --> 00:14:18,070
and instead of recovering it from the

382
00:14:18,070 --> 00:14:19,660
level 1 cache it's gonna recover it from

383
00:14:19,660 --> 00:14:22,060
the level 2 cache or main memory

384
00:14:22,060 --> 00:14:24,130
this execution time is going to be short

385
00:14:24,130 --> 00:14:25,540
and this execution time is gonna be long

386
00:14:25,540 --> 00:14:29,920
so these differences and well thanks to

387
00:14:29,920 --> 00:14:31,720
this the difference on on execution

388
00:14:31,720 --> 00:14:33,190
times we know which caching has been

389
00:14:33,190 --> 00:14:36,910
accessed by the secure process so this

390
00:14:36,910 --> 00:14:39,100
is my example now I'm gonna show you

391
00:14:39,100 --> 00:14:40,569
another example which is primum proof

392
00:14:40,569 --> 00:14:43,120
which is the one that sang and your

393
00:14:43,120 --> 00:14:45,670
authors used in the in the paper I told

394
00:14:45,670 --> 00:14:49,000
you about before so this time we're

395
00:14:49,000 --> 00:14:50,620
gonna fill the cache with all attacker

396
00:14:50,620 --> 00:14:51,790
is going to fill the cache with his

397
00:14:51,790 --> 00:14:55,019
sound data some cache lines for example

398
00:14:55,019 --> 00:14:58,959
so now the attacker is gonna show you

399
00:14:58,959 --> 00:15:00,130
the big team is gonna run the AES

400
00:15:00,130 --> 00:15:02,230
encryption and and two things can happen

401
00:15:02,230 --> 00:15:05,050
here either the victim didn't access any

402
00:15:05,050 --> 00:15:07,029
of the cache lines that we that that the

403
00:15:07,029 --> 00:15:09,459
attacker has in the cache so in this

404
00:15:09,459 --> 00:15:10,750
case the attacker is going to reload

405
00:15:10,750 --> 00:15:12,490
each of what each one of these this

406
00:15:12,490 --> 00:15:14,139
memory lines that he has in the cache

407
00:15:14,139 --> 00:15:17,079
and of course since they reside in the

408
00:15:17,079 --> 00:15:18,940
level 1 cache the it's gonna be assured

409
00:15:18,940 --> 00:15:21,459
proof time so the time well the access

410
00:15:21,459 --> 00:15:22,779
time for this for each one of this

411
00:15:22,779 --> 00:15:25,240
memory line is gonna be small but what

412
00:15:25,240 --> 00:15:26,980
if the AES encryption needs one of the

413
00:15:26,980 --> 00:15:29,339
questions that the attacker is occupying

414
00:15:29,339 --> 00:15:31,120
well

415
00:15:31,120 --> 00:15:33,069
look something like this right it would

416
00:15:33,069 --> 00:15:34,629
look something like this so one of the

417
00:15:34,629 --> 00:15:36,069
memory lanes of the tiger has been

418
00:15:36,069 --> 00:15:38,980
evicted by in the level one cache so it

419
00:15:38,980 --> 00:15:42,100
wasn't maybe two level two cache so now

420
00:15:42,100 --> 00:15:44,499
when the attacker tries to reload he's

421
00:15:44,499 --> 00:15:46,449
gonna find out that this memory line

422
00:15:46,449 --> 00:15:48,370
takes short time because it's still in

423
00:15:48,370 --> 00:15:50,019
the level 1 cache this memory line take

424
00:15:50,019 --> 00:15:52,660
takes a still small time because or

425
00:15:52,660 --> 00:15:54,040
short time because it's still in the

426
00:15:54,040 --> 00:15:56,139
cache and this one as well but this one

427
00:15:56,139 --> 00:15:58,720
the one he had here it's been kicked out

428
00:15:58,720 --> 00:16:01,509
to a level 2 cache for example and now

429
00:16:01,509 --> 00:16:03,339
he has to retrieve retrieve it from

430
00:16:03,339 --> 00:16:06,309
there so this means that it it takes

431
00:16:06,309 --> 00:16:09,220
more longer time to access it so in this

432
00:16:09,220 --> 00:16:10,930
way the attacker knows which cousin has

433
00:16:10,930 --> 00:16:17,319
been accessed by by areas so this is how

434
00:16:17,319 --> 00:16:18,970
Kashi attacks work and since we're gonna

435
00:16:18,970 --> 00:16:21,279
attack AES let's have a brief a yes

436
00:16:21,279 --> 00:16:24,819
review so is basically symmetric block

437
00:16:24,819 --> 00:16:28,329
cipher that takes 16 bytes of plaintext

438
00:16:28,329 --> 00:16:29,769
and converts them to 16 bytes of

439
00:16:29,769 --> 00:16:33,699
ciphertext and accepts keys of 16 24 32

440
00:16:33,699 --> 00:16:38,529
bytes of size and what's gonna change in

441
00:16:38,529 --> 00:16:41,529
the AES execution if we select 16 24 32

442
00:16:41,529 --> 00:16:43,899
well the AES is gonna run more number of

443
00:16:43,899 --> 00:16:47,110
rounds here so this is how a es looks

444
00:16:47,110 --> 00:16:50,350
like um we have 4 Minister four main

445
00:16:50,350 --> 00:16:53,170
stages that are repeated 9 11 or 13

446
00:16:53,170 --> 00:16:55,600
rounds in depending on the key size that

447
00:16:55,600 --> 00:16:57,999
we selected this four main stages are

448
00:16:57,999 --> 00:17:00,309
sub byte she froze mixed coms and a

449
00:17:00,309 --> 00:17:04,959
drunken and actually we see that in all

450
00:17:04,959 --> 00:17:07,179
of the cases we have a last round in

451
00:17:07,179 --> 00:17:09,130
which which looks pretty similar but

452
00:17:09,130 --> 00:17:11,409
doesn't have the mixcolumns operation so

453
00:17:11,409 --> 00:17:12,669
I want you to notice is because then

454
00:17:12,669 --> 00:17:14,500
we're gonna use it as a fact on in one

455
00:17:14,500 --> 00:17:19,059
of our attacks but yep what

456
00:17:19,059 --> 00:17:21,069
cryptographic library the developers

457
00:17:21,069 --> 00:17:22,720
what they usually do is they merge these

458
00:17:22,720 --> 00:17:24,909
three stages into two stages a table

459
00:17:24,909 --> 00:17:27,390
lookup operation and XOR operation and

460
00:17:27,390 --> 00:17:29,440
actually this is where the leakage comes

461
00:17:29,440 --> 00:17:31,240
from because what is the table lookup

462
00:17:31,240 --> 00:17:34,149
it's simply a table to which we give an

463
00:17:34,149 --> 00:17:36,370
input and it gives the corresponding

464
00:17:36,370 --> 00:17:40,149
output right so the CPU - to see which

465
00:17:40,149 --> 00:17:42,070
output corresponds to the input we are

466
00:17:42,070 --> 00:17:44,230
inserting let's say that we insert input

467
00:17:44,230 --> 00:17:44,860
1 1

468
00:17:44,860 --> 00:17:47,170
right so now the CPU is gonna go to a

469
00:17:47,170 --> 00:17:49,299
memory to see what's the output

470
00:17:49,299 --> 00:17:52,000
corresponding to input 1 1 and therefore

471
00:17:52,000 --> 00:17:55,120
since it's accessing output 1 1 this is

472
00:17:55,120 --> 00:17:57,340
gonna be in the cache right and unlike

473
00:17:57,340 --> 00:17:58,570
the other ones which are not being

474
00:17:58,570 --> 00:18:02,799
accessed so these are the the memory

475
00:18:02,799 --> 00:18:04,299
memory lines that we're trying to figure

476
00:18:04,299 --> 00:18:06,960
out if the victim access or not and why

477
00:18:06,960 --> 00:18:09,610
because the first round of a es with the

478
00:18:09,610 --> 00:18:11,049
tea-table implementation looks like this

479
00:18:11,049 --> 00:18:14,170
so we have well here I present only 4

480
00:18:14,170 --> 00:18:16,900
bytes and this should be 16 bytes but

481
00:18:16,900 --> 00:18:18,549
anyway for the scope of the presentation

482
00:18:18,549 --> 00:18:21,760
it's ok it's enough so let's see that we

483
00:18:21,760 --> 00:18:24,070
have a key Edition a TT of luke

484
00:18:24,070 --> 00:18:25,630
operation and then this is a state for

485
00:18:25,630 --> 00:18:27,940
the next round so if we know the

486
00:18:27,940 --> 00:18:29,500
tea-table value that has been accessed

487
00:18:29,500 --> 00:18:31,000
and we know the plaintext that we are

488
00:18:31,000 --> 00:18:33,100
inserting by a simple lecture we can

489
00:18:33,100 --> 00:18:35,320
know the key and this is why knowing the

490
00:18:35,320 --> 00:18:36,970
tea-table value it has been accessed is

491
00:18:36,970 --> 00:18:41,679
that useful the first thing the same

492
00:18:41,679 --> 00:18:43,120
thing happens with with the last one in

493
00:18:43,120 --> 00:18:44,350
which you have something like this and

494
00:18:44,350 --> 00:18:47,380
if we know the ciphertext that that well

495
00:18:47,380 --> 00:18:48,910
if we need ciphertext and we know that

496
00:18:48,910 --> 00:18:50,320
it evolved I would have that has been

497
00:18:50,320 --> 00:18:52,210
accessed by a simple X or we can

498
00:18:52,210 --> 00:18:54,190
actually know the key that that AES is

499
00:18:54,190 --> 00:18:56,230
using and this is the fact that we're

500
00:18:56,230 --> 00:18:59,290
gonna use in in triple to implement our

501
00:18:59,290 --> 00:19:01,679
attacks

502
00:19:01,679 --> 00:19:05,440
well it seems well now we know how a is

503
00:19:05,440 --> 00:19:07,299
looks like and we know how cache

504
00:19:07,299 --> 00:19:09,040
side-channel attacks look like as well

505
00:19:09,040 --> 00:19:10,809
so now let's talk out the attacks the

506
00:19:10,809 --> 00:19:12,010
two attacks that we implemented in a

507
00:19:12,010 --> 00:19:15,030
cloud one of them is Bernstein's attack

508
00:19:15,030 --> 00:19:17,740
it's a time dreaming attack why because

509
00:19:17,740 --> 00:19:19,570
it only requires the execution time of a

510
00:19:19,570 --> 00:19:22,240
process and it was first proposed by

511
00:19:22,240 --> 00:19:26,110
this guy who's da Bernstein in 2005 it's

512
00:19:26,110 --> 00:19:27,850
one of the first cache side-channel

513
00:19:27,850 --> 00:19:30,340
attacks implementations people have

514
00:19:30,340 --> 00:19:32,549
discussed it radically before him but

515
00:19:32,549 --> 00:19:35,110
yeah he came up with a practical

516
00:19:35,110 --> 00:19:36,610
implementation of this kind of attacks

517
00:19:36,610 --> 00:19:40,510
and it's based on the fact that

518
00:19:40,510 --> 00:19:41,860
different memory lines have different

519
00:19:41,860 --> 00:19:43,679
access time access values for example

520
00:19:43,679 --> 00:19:46,600
this is how they accesses to a tea table

521
00:19:46,600 --> 00:19:49,059
that I I was talking about look look

522
00:19:49,059 --> 00:19:51,160
like for example we see that for

523
00:19:51,160 --> 00:19:52,780
different positions of the of the tea

524
00:19:52,780 --> 00:19:55,059
table we have different access values

525
00:19:55,059 --> 00:19:58,720
right and with this

526
00:19:58,720 --> 00:20:00,820
such patterns we can actually infer what

527
00:20:00,820 --> 00:20:02,890
the what key has been used by

528
00:20:02,890 --> 00:20:05,800
correlation of traces we will see later

529
00:20:05,800 --> 00:20:09,070
on but of course the first the first

530
00:20:09,070 --> 00:20:10,420
thing we need here is that both the

531
00:20:10,420 --> 00:20:11,890
attacker and and victim had the same

532
00:20:11,890 --> 00:20:13,810
correspondence between access times and

533
00:20:13,810 --> 00:20:15,490
member anteed table values the access

534
00:20:15,490 --> 00:20:18,430
and this is achieved thing two things to

535
00:20:18,430 --> 00:20:20,470
a library alignment process that Linux

536
00:20:20,470 --> 00:20:21,100
implements

537
00:20:21,100 --> 00:20:23,710
so basically nooks aligns the shared

538
00:20:23,710 --> 00:20:26,170
libraries with page boundaries so it

539
00:20:26,170 --> 00:20:27,490
doesn't matter if the victims library is

540
00:20:27,490 --> 00:20:29,050
that starts here and Atticus library

541
00:20:29,050 --> 00:20:31,210
starts here both of them are gonna have

542
00:20:31,210 --> 00:20:33,550
the same correspondence between memory

543
00:20:33,550 --> 00:20:37,420
lines and access times so now that we

544
00:20:37,420 --> 00:20:39,670
know this let's see how Bernstein works

545
00:20:39,670 --> 00:20:41,590
well we have three minutes three main

546
00:20:41,590 --> 00:20:43,870
stages one of them is the study phase in

547
00:20:43,870 --> 00:20:45,700
which the attacker profiles his own

548
00:20:45,700 --> 00:20:48,100
cache architecture with a gnome key

549
00:20:48,100 --> 00:20:50,200
let's assume that we have an odd zero

550
00:20:50,200 --> 00:20:53,230
key and also your game so entry table

551
00:20:53,230 --> 00:20:54,520
it's gonna look something like this

552
00:20:54,520 --> 00:20:56,830
right in which let's say that we have

553
00:20:56,830 --> 00:20:58,900
control over the plaintext so in this

554
00:20:58,900 --> 00:21:00,520
phase we profile the cache architecture

555
00:21:00,520 --> 00:21:02,740
in the second phase we have an unknown

556
00:21:02,740 --> 00:21:06,550
key then let's assume again that we have

557
00:21:06,550 --> 00:21:09,700
control over the plaintext so but we

558
00:21:09,700 --> 00:21:10,900
have we don't have we don't know the key

559
00:21:10,900 --> 00:21:12,730
that has been used right so clearly

560
00:21:12,730 --> 00:21:14,440
these two axes are going to look similar

561
00:21:14,440 --> 00:21:16,240
or the access times to these two these

562
00:21:16,240 --> 00:21:18,220
two accesses are going to look similar

563
00:21:18,220 --> 00:21:21,910
when both of them are equal right and if

564
00:21:21,910 --> 00:21:23,620
we know that both of them are equal we

565
00:21:23,620 --> 00:21:25,030
can if and if we have control over the

566
00:21:25,030 --> 00:21:26,770
plaintext by a simple X or we can

567
00:21:26,770 --> 00:21:28,200
actually know the key that has been used

568
00:21:28,200 --> 00:21:30,820
and this is how the output of a

569
00:21:30,820 --> 00:21:32,980
Bernstein attack looks like in the first

570
00:21:32,980 --> 00:21:36,520
column we can see that these are the

571
00:21:36,520 --> 00:21:38,920
number of yeah we the first thing we see

572
00:21:38,920 --> 00:21:41,080
that it's is that the key space has been

573
00:21:41,080 --> 00:21:43,000
reduced so we don't get the whole the

574
00:21:43,000 --> 00:21:45,940
full key but we reduce the key space but

575
00:21:45,940 --> 00:21:47,440
this is important because as a daggers

576
00:21:47,440 --> 00:21:49,090
what do we want to know is what we want

577
00:21:49,090 --> 00:21:51,220
what we want to do is just reduce the

578
00:21:51,220 --> 00:21:53,560
key space so that a brute a brute force

579
00:21:53,560 --> 00:21:55,270
attack is possible with the remaining

580
00:21:55,270 --> 00:21:59,410
key space so the first column first of

581
00:21:59,410 --> 00:22:03,580
all yeah it says how many possible key

582
00:22:03,580 --> 00:22:06,310
bytes each that the key between ax been

583
00:22:06,310 --> 00:22:08,830
tested a has for example the Q by number

584
00:22:08,830 --> 00:22:11,620
0 has 48 possible values

585
00:22:11,620 --> 00:22:13,600
and these are the values from most

586
00:22:13,600 --> 00:22:19,330
likely to us likely so thanks to the

587
00:22:19,330 --> 00:22:21,520
relationship it was ordered a relation

588
00:22:21,520 --> 00:22:24,520
between tea tables and and and plaintext

589
00:22:24,520 --> 00:22:26,650
or cipher text with the key this attack

590
00:22:26,650 --> 00:22:28,180
can be planned in the first one or in

591
00:22:28,180 --> 00:22:29,620
the last round but we decided to

592
00:22:29,620 --> 00:22:30,970
implement it in the first round because

593
00:22:30,970 --> 00:22:32,740
it's it's it's less noisy environment

594
00:22:32,740 --> 00:22:35,590
and what we required to run it in the

595
00:22:35,590 --> 00:22:37,180
cloud is first of all a synchronized

596
00:22:37,180 --> 00:22:39,250
communication with an aes server which

597
00:22:39,250 --> 00:22:40,870
is going to be the victim we don't wanna

598
00:22:40,870 --> 00:22:42,940
we're not going to know which key is the

599
00:22:42,940 --> 00:22:45,160
es server using we're just gonna request

600
00:22:45,160 --> 00:22:47,590
encryption and then colocation with the

601
00:22:47,590 --> 00:22:50,170
server so that both attacker and victim

602
00:22:50,170 --> 00:22:51,370
are providing the same cache

603
00:22:51,370 --> 00:22:56,380
architecture so for our test setup we

604
00:22:56,380 --> 00:22:59,590
use the iPhone i5 3 3 2 0 it has 4 cores

605
00:22:59,590 --> 00:23:02,800
2.60 guards and it has a level 1 cache

606
00:23:02,800 --> 00:23:04,990
size of 32 kilobytes so it looks

607
00:23:04,990 --> 00:23:07,179
something like this and ya notice that

608
00:23:07,179 --> 00:23:08,920
it has a shared level of cache because

609
00:23:08,920 --> 00:23:10,840
we're gonna use it later on in the next

610
00:23:10,840 --> 00:23:13,919
attack that we're gonna present

611
00:23:13,950 --> 00:23:16,270
yeah our so for environment it's gonna

612
00:23:16,270 --> 00:23:19,240
we're gonna use VMware ESXi 5.5 and exam

613
00:23:19,240 --> 00:23:22,990
4.1 as our cloud providers we're gonna

614
00:23:22,990 --> 00:23:24,700
use the AES implementation of open

615
00:23:24,700 --> 00:23:27,220
instead of 101 or one of the most recent

616
00:23:27,220 --> 00:23:30,100
ones we're gonna assume that all BMS are

617
00:23:30,100 --> 00:23:33,370
using a 1 2 1204 and of course since

618
00:23:33,370 --> 00:23:35,260
it's gonna be a cross vm attack studyin

619
00:23:35,260 --> 00:23:37,120
and an attack of states are gonna be

620
00:23:37,120 --> 00:23:38,500
performing different built on machines

621
00:23:38,500 --> 00:23:40,510
so we have something like this in which

622
00:23:40,510 --> 00:23:42,690
the attacker has a built on machine and

623
00:23:42,690 --> 00:23:45,010
performs a steady state first of all to

624
00:23:45,010 --> 00:23:47,679
profile his castle key texture and then

625
00:23:47,679 --> 00:23:50,350
he's gonna attack and well another bit

626
00:23:50,350 --> 00:23:52,110
of machine that is co-located with him

627
00:23:52,110 --> 00:23:54,429
that in this case gonna be IES server

628
00:23:54,429 --> 00:23:57,610
running encrypting with unknown key with

629
00:23:57,610 --> 00:24:00,940
a private key so these are the results

630
00:24:00,940 --> 00:24:06,910
that we get yeah the important one is so

631
00:24:06,910 --> 00:24:09,220
it's this one and this one because it's

632
00:24:09,220 --> 00:24:11,530
across VMs scenario with the latest

633
00:24:11,530 --> 00:24:13,330
version of open SSL so we see that we

634
00:24:13,330 --> 00:24:15,250
reduce the kiss well the first thing we

635
00:24:15,250 --> 00:24:18,390
have to say is that the vertical axis

636
00:24:18,390 --> 00:24:21,220
refers to the number of key bits

637
00:24:21,220 --> 00:24:24,250
recovered and the the horizontal axis

638
00:24:24,250 --> 00:24:25,130
refers to an

639
00:24:25,130 --> 00:24:27,080
encryptions in it so the first thing we

640
00:24:27,080 --> 00:24:29,090
have to notice is that first of all

641
00:24:29,090 --> 00:24:30,770
we'll record a folky this book if we

642
00:24:30,770 --> 00:24:33,380
record the folk do a hokey we would be

643
00:24:33,380 --> 00:24:36,770
in 128 values here but no we only record

644
00:24:36,770 --> 00:24:41,060
40 42 43 bits of the game and also a

645
00:24:41,060 --> 00:24:43,730
notice that we need to - 829 encryptions

646
00:24:43,730 --> 00:24:46,610
receipt which is quite high and i want

647
00:24:46,610 --> 00:24:48,350
you to remember this this this data

648
00:24:48,350 --> 00:24:51,500
because yeah we're going to compare it

649
00:24:51,500 --> 00:24:53,270
later on with the next attack that we

650
00:24:53,270 --> 00:24:55,460
present so we see that we reduce the key

651
00:24:55,460 --> 00:24:58,010
space in 42 bits more or less but again

652
00:24:58,010 --> 00:24:59,390
this is important because now the left

653
00:24:59,390 --> 00:25:01,970
the key the key space left is like 220

654
00:25:01,970 --> 00:25:05,720
to 280 which is close to the to the key

655
00:25:05,720 --> 00:25:07,820
space that can be broken by brute force

656
00:25:07,820 --> 00:25:10,390
attack nowadays

657
00:25:10,390 --> 00:25:12,950
so yeah let's present the next attack

658
00:25:12,950 --> 00:25:15,260
that we did it's flash and reload it's a

659
00:25:15,260 --> 00:25:17,120
low noise crash attack and we'll explain

660
00:25:17,120 --> 00:25:21,410
later why we call it low noise and it

661
00:25:21,410 --> 00:25:23,960
exploits basically a shared memory

662
00:25:23,960 --> 00:25:25,760
shared memory pages and duplication

663
00:25:25,760 --> 00:25:27,340
processes that are implemented in

664
00:25:27,340 --> 00:25:32,840
overseas and BMS so basically and they

665
00:25:32,840 --> 00:25:34,820
inst well when two processes are using

666
00:25:34,820 --> 00:25:36,260
the same shared library for example

667
00:25:36,260 --> 00:25:37,610
instead of holding two copies in a

668
00:25:37,610 --> 00:25:39,830
memory what this duplication processes

669
00:25:39,830 --> 00:25:42,830
are gonna do is just store one copy in

670
00:25:42,830 --> 00:25:44,270
the physical memory see that both

671
00:25:44,270 --> 00:25:46,970
processes are using the same the same

672
00:25:46,970 --> 00:25:49,130
physical memory and that's what we are

673
00:25:49,130 --> 00:25:51,920
gonna explode with this attack and yeah

674
00:25:51,920 --> 00:25:53,900
so again no rhiannon copies are stored

675
00:25:53,900 --> 00:25:57,050
when more than one processes are using

676
00:25:57,050 --> 00:25:58,970
the same shared library look something

677
00:25:58,970 --> 00:26:01,400
like this where we have let's say to

678
00:26:01,400 --> 00:26:04,190
build two machines using new TLS as a

679
00:26:04,190 --> 00:26:06,500
shared library and instead of holding

680
00:26:06,500 --> 00:26:08,210
two copies here in the in the in the

681
00:26:08,210 --> 00:26:10,460
server in the physical storage well

682
00:26:10,460 --> 00:26:12,860
we're gonna ester only one of them so

683
00:26:12,860 --> 00:26:14,510
that both processes or both built in

684
00:26:14,510 --> 00:26:15,680
machines are using the same physical

685
00:26:15,680 --> 00:26:20,180
memory so what is this implemented this

686
00:26:20,180 --> 00:26:22,010
simply didn't kernel same it same page

687
00:26:22,010 --> 00:26:25,930
margin which is which appears in Linux

688
00:26:25,930 --> 00:26:29,720
and in kbm as well which is basically a

689
00:26:29,720 --> 00:26:32,780
Linux baseball Linux OS based bmm so

690
00:26:32,780 --> 00:26:35,150
what basically they do basically is to

691
00:26:35,150 --> 00:26:37,910
take a Linux OS and they convert it into

692
00:26:37,910 --> 00:26:38,750
bmm so that

693
00:26:38,750 --> 00:26:41,210
you can yeah it can provide a beautiful

694
00:26:41,210 --> 00:26:43,490
machine spiritualization and so on so

695
00:26:43,490 --> 00:26:46,760
that's why it appears in both of them it

696
00:26:46,760 --> 00:26:49,340
first appeared in Corel two-point 6.32

697
00:26:49,340 --> 00:26:52,250
and yeah it does what it does is

698
00:26:52,250 --> 00:26:53,570
basically high chopper ations in the

699
00:26:53,570 --> 00:26:56,419
memory page level so it takes those

700
00:26:56,419 --> 00:26:58,730
candidates while those pages that are

701
00:26:58,730 --> 00:27:01,460
candy is to be shared and it performs

702
00:27:01,460 --> 00:27:03,409
hush-hush operations in them and

703
00:27:03,409 --> 00:27:05,419
whenever it sees that too harsh

704
00:27:05,419 --> 00:27:07,340
operations have the same output it

705
00:27:07,340 --> 00:27:09,559
merges them so that both processes are

706
00:27:09,559 --> 00:27:12,380
using again the same physical memory but

707
00:27:12,380 --> 00:27:13,730
the image is not the only one implement

708
00:27:13,730 --> 00:27:15,350
in this also BM worries implementing

709
00:27:15,350 --> 00:27:17,600
this but with a different name which is

710
00:27:17,600 --> 00:27:18,710
transparent page

711
00:27:18,710 --> 00:27:21,559
TPS but yeah it's the prostitute is

712
00:27:21,559 --> 00:27:23,150
basically the same harsh operations at

713
00:27:23,150 --> 00:27:24,679
the page level and then merging those

714
00:27:24,679 --> 00:27:28,330
pages that have the same hash output and

715
00:27:28,330 --> 00:27:30,770
so now we're going to explain the steps

716
00:27:30,770 --> 00:27:33,200
of the flash and reload attack and here

717
00:27:33,200 --> 00:27:35,840
I'm gonna stop by a little bit so this

718
00:27:35,840 --> 00:27:37,250
time we're gonna work with memory lines

719
00:27:37,250 --> 00:27:38,600
rather than cache lines and we're gonna

720
00:27:38,600 --> 00:27:41,030
flash the desired memory lines flash

721
00:27:41,030 --> 00:27:42,530
doesn't mean a big it's not the same

722
00:27:42,530 --> 00:27:44,809
flash means that we kick it out from all

723
00:27:44,809 --> 00:27:46,340
the cache hierarchy of all the cores

724
00:27:46,340 --> 00:27:47,750
present in the physical force that we

725
00:27:47,750 --> 00:27:51,110
are analyzing then we wait until the

726
00:27:51,110 --> 00:27:53,690
victim runs his process and then we

727
00:27:53,690 --> 00:27:54,830
reload the memory lines that we are

728
00:27:54,830 --> 00:27:56,510
monitoring and measure the reload time

729
00:27:56,510 --> 00:27:58,820
so we're going to sit better graphically

730
00:27:58,820 --> 00:28:00,530
we have a share level of cache here and

731
00:28:00,530 --> 00:28:02,419
a memory line that were monitoring for

732
00:28:02,419 --> 00:28:05,120
example the red one and what we do is we

733
00:28:05,120 --> 00:28:07,070
flash it flash means put it in the main

734
00:28:07,070 --> 00:28:09,260
memory so no longer present in any of

735
00:28:09,260 --> 00:28:11,510
the cache hierarchy all in the cache

736
00:28:11,510 --> 00:28:14,210
hierarchy of the physical host so now

737
00:28:14,210 --> 00:28:15,500
the victim is going to run the AES

738
00:28:15,500 --> 00:28:17,659
encryption again and two things can

739
00:28:17,659 --> 00:28:19,039
happen here either

740
00:28:19,039 --> 00:28:20,539
AES used the memory line that were

741
00:28:20,539 --> 00:28:22,760
monitoring so in that case and since we

742
00:28:22,760 --> 00:28:24,530
have a shared level of cache and we're

743
00:28:24,530 --> 00:28:26,210
working with with shared libraries with

744
00:28:26,210 --> 00:28:28,460
the application processes this is gonna

745
00:28:28,460 --> 00:28:29,900
be present in the shared level of cache

746
00:28:29,900 --> 00:28:32,659
and when we reload this it's gonna take

747
00:28:32,659 --> 00:28:34,789
a short time we're gonna see later on

748
00:28:34,789 --> 00:28:37,970
yeah I know graphic but if a ESD and

749
00:28:37,970 --> 00:28:39,490
used a memory lane that were monitoring

750
00:28:39,490 --> 00:28:42,140
yeah this still resides in the memory

751
00:28:42,140 --> 00:28:44,450
and actually this reload time takes a

752
00:28:44,450 --> 00:28:48,200
long time so idea clear right I'm small

753
00:28:48,200 --> 00:28:50,090
real time if line is in the cache long

754
00:28:50,090 --> 00:28:50,650
video

755
00:28:50,650 --> 00:28:52,180
Merlin's in the memory and it looks

756
00:28:52,180 --> 00:28:54,040
actually something like this so this

757
00:28:54,040 --> 00:28:55,840
experiment was performed in an Intel

758
00:28:55,840 --> 00:28:58,450
Excel to six and zero which is like the

759
00:28:58,450 --> 00:29:01,060
ones that amazon has in his cloud

760
00:29:01,060 --> 00:29:04,690
Yankees cloud system and the reddish

761
00:29:04,690 --> 00:29:06,730
line refers to a memory line that is

762
00:29:06,730 --> 00:29:09,460
present in the access times to the to a

763
00:29:09,460 --> 00:29:10,810
memory line that is in the share level

764
00:29:10,810 --> 00:29:13,240
of cache and the blue line refers to our

765
00:29:13,240 --> 00:29:15,280
line well the accesses to a memory line

766
00:29:15,280 --> 00:29:17,380
that resides in the main memory or in

767
00:29:17,380 --> 00:29:19,570
the ROM so as we see the difference here

768
00:29:19,570 --> 00:29:21,520
is quite big right the accesses to the

769
00:29:21,520 --> 00:29:24,220
cache are like 70 cycles and accesses to

770
00:29:24,220 --> 00:29:26,560
a main memory are like two hundred

771
00:29:26,560 --> 00:29:29,410
cycles so this is quite big so if we put

772
00:29:29,410 --> 00:29:31,090
the threshold here we can actually this

773
00:29:31,090 --> 00:29:33,160
thing is pretty well between our cache

774
00:29:33,160 --> 00:29:35,170
accesses and main memory accesses so

775
00:29:35,170 --> 00:29:36,490
that's why we call it low noise because

776
00:29:36,490 --> 00:29:37,870
if we put the threshold here in the

777
00:29:37,870 --> 00:29:41,080
middle here in the middle we're gonna

778
00:29:41,080 --> 00:29:45,520
have low misprediction rate so nice we

779
00:29:45,520 --> 00:29:47,620
have a super cool detector yeah

780
00:29:47,620 --> 00:29:49,450
detection method but how do we apply

781
00:29:49,450 --> 00:29:51,220
this to a yes well again we're gonna

782
00:29:51,220 --> 00:29:52,900
observe we're gonna monitor the

783
00:29:52,900 --> 00:29:54,640
tea-table values that have been accessed

784
00:29:54,640 --> 00:29:57,640
by AES so we're gonna see an example

785
00:29:57,640 --> 00:29:59,620
here well first of all we have to say

786
00:29:59,620 --> 00:30:01,740
that we apply this to the last round

787
00:30:01,740 --> 00:30:03,580
because it doesn't have the mixcolumns

788
00:30:03,580 --> 00:30:05,530
operations and and it looks something

789
00:30:05,530 --> 00:30:07,620
like this so it gives us a quite

790
00:30:07,620 --> 00:30:10,210
straightforward question here if we know

791
00:30:10,210 --> 00:30:12,040
this and we know the ciphertext we can

792
00:30:12,040 --> 00:30:14,290
buy a simple external the key that has

793
00:30:14,290 --> 00:30:17,710
been used but in this this time we're

794
00:30:17,710 --> 00:30:19,510
gonna work with some first positions of

795
00:30:19,510 --> 00:30:20,860
the table it's gonna look something like

796
00:30:20,860 --> 00:30:23,260
this so let's again put the question

797
00:30:23,260 --> 00:30:26,890
here and then the picture there so this

798
00:30:26,890 --> 00:30:29,020
time we're gonna monitor one memory line

799
00:30:29,020 --> 00:30:30,550
let's assume that the memory line holds

800
00:30:30,550 --> 00:30:33,910
for 40 table values T 0 T 1 T 2 T 3 so

801
00:30:33,910 --> 00:30:34,840
these are the values that we are

802
00:30:34,840 --> 00:30:37,590
monitoring if they have in access or not

803
00:30:37,590 --> 00:30:39,670
what's gonna happen since the key is

804
00:30:39,670 --> 00:30:44,170
fixed and constant here this if this

805
00:30:44,170 --> 00:30:45,910
theta values have been accessed we are

806
00:30:45,910 --> 00:30:47,500
gonna be mapped into four different

807
00:30:47,500 --> 00:30:51,670
ciphertext right C 0 C 1 C 2 and C 3 so

808
00:30:51,670 --> 00:30:53,020
each time this T table values are

809
00:30:53,020 --> 00:30:54,790
accessed they're gonna up to one of

810
00:30:54,790 --> 00:30:57,340
those but since this is a memory line

811
00:30:57,340 --> 00:30:59,110
it's like loaded like this you know in

812
00:30:59,110 --> 00:31:01,300
the cache we don't know which sees which

813
00:31:01,300 --> 00:31:03,880
ciphertext corresponds to which TTL

814
00:31:03,880 --> 00:31:04,450
value

815
00:31:04,450 --> 00:31:06,669
so how we solve these we're close to get

816
00:31:06,669 --> 00:31:08,080
the key but how would how do we solve

817
00:31:08,080 --> 00:31:13,720
this well we can actually XOR the HC 0

818
00:31:13,720 --> 00:31:16,200
well it's ciphertext value with each

819
00:31:16,200 --> 00:31:19,679
t-table value so basically we're kind of

820
00:31:19,679 --> 00:31:22,629
seen all the possible keys that can

821
00:31:22,629 --> 00:31:25,929
could have been produced what could have

822
00:31:25,929 --> 00:31:28,659
been used so Forex using CC rocks or DC

823
00:31:28,659 --> 00:31:30,940
do X or T 1 X or T 2 X or T 3 and the

824
00:31:30,940 --> 00:31:33,039
same with all the ciphertext so we're

825
00:31:33,039 --> 00:31:34,840
gonna get some something like this for

826
00:31:34,840 --> 00:31:37,659
set in which we have a random values

827
00:31:37,659 --> 00:31:39,460
here but the correct key is gonna appear

828
00:31:39,460 --> 00:31:42,009
in all the sets so that's how we're

829
00:31:42,009 --> 00:31:44,230
gonna ask how we're gonna decide what

830
00:31:44,230 --> 00:31:49,450
key has been used and this is that

831
00:31:49,450 --> 00:31:50,619
commit translate into a cloud

832
00:31:50,619 --> 00:31:53,139
environment as well as the well as long

833
00:31:53,139 --> 00:31:55,059
as the the server has a sheer level of

834
00:31:55,059 --> 00:31:57,309
cache yeah that occurred on the

835
00:31:57,309 --> 00:31:59,049
beginning of course are physically

836
00:31:59,049 --> 00:32:00,879
co-located and they're using the same

837
00:32:00,879 --> 00:32:02,859
hardware and therefore the same shared

838
00:32:02,859 --> 00:32:05,769
level of cache and as long as the bmm

839
00:32:05,769 --> 00:32:07,779
implements some memories application

840
00:32:07,779 --> 00:32:10,899
processes because in that way we can

841
00:32:10,899 --> 00:32:14,559
access the in physical memory so for our

842
00:32:14,559 --> 00:32:16,389
scenario for our test scenarios we're

843
00:32:16,389 --> 00:32:18,759
gonna do three of them the first one is

844
00:32:18,759 --> 00:32:21,220
going to be that one in which we're

845
00:32:21,220 --> 00:32:25,059
gonna have whoops oh yeah a physical

846
00:32:25,059 --> 00:32:27,399
machine with the brutalization only one

847
00:32:27,399 --> 00:32:29,590
OS and we're gonna run two processes one

848
00:32:29,590 --> 00:32:31,090
of them is running AES and the other one

849
00:32:31,090 --> 00:32:33,039
is running flash and reload to attack

850
00:32:33,039 --> 00:32:37,049
which accesses this AES process is doing

851
00:32:37,049 --> 00:32:40,029
the second scenario we're gonna have a

852
00:32:40,029 --> 00:32:42,359
we're gonna move all these to the cloud

853
00:32:42,359 --> 00:32:44,950
and we're gonna have a spy processing in

854
00:32:44,950 --> 00:32:46,509
a built on machine so we have a single

855
00:32:46,509 --> 00:32:48,580
virtual machine here in the cloud but

856
00:32:48,580 --> 00:32:50,109
within the same build to machine we're

857
00:32:50,109 --> 00:32:53,859
gonna run the two processes and one of

858
00:32:53,859 --> 00:32:55,749
them is again when I take the accesses

859
00:32:55,749 --> 00:32:58,480
that AES is doing and the failure

860
00:32:58,480 --> 00:32:59,980
scenario and the more challenging one

861
00:32:59,980 --> 00:33:01,600
and we're going to do a cross beam

862
00:33:01,600 --> 00:33:03,100
attack in which we have to build two

863
00:33:03,100 --> 00:33:04,749
little machines one of them is running

864
00:33:04,749 --> 00:33:05,980
in flash and reload the other one is

865
00:33:05,980 --> 00:33:08,529
running AES and of course using the same

866
00:33:08,529 --> 00:33:15,460
hardware so again our tested app vmware

867
00:33:15,460 --> 00:33:17,720
esxi 5.5

868
00:33:17,720 --> 00:33:20,810
12:04 for the guests oasis we're gonna

869
00:33:20,810 --> 00:33:23,210
do we're gonna do this until I 5/3 to

870
00:33:23,210 --> 00:33:25,400
Syria again and yeah I told you before

871
00:33:25,400 --> 00:33:26,900
that to notice that the sheer level of

872
00:33:26,900 --> 00:33:29,480
Cassatt that this processor has or this

873
00:33:29,480 --> 00:33:32,030
computer has so we're gonna use yeah

874
00:33:32,030 --> 00:33:33,650
this share level of cache as our cover

875
00:33:33,650 --> 00:33:36,620
channel and again we're going to work

876
00:33:36,620 --> 00:33:38,660
with open assess the implementation of a

877
00:33:38,660 --> 00:33:39,170
yes

878
00:33:39,170 --> 00:33:41,240
and of course transparent page sharing

879
00:33:41,240 --> 00:33:43,100
is enabled and to perform this

880
00:33:43,100 --> 00:33:47,450
application processes so these are the

881
00:33:47,450 --> 00:33:50,780
results that we get yeah let me explain

882
00:33:50,780 --> 00:33:52,880
first of all so the vertical line refers

883
00:33:52,880 --> 00:33:55,190
to the number of key buys a key whites

884
00:33:55,190 --> 00:33:57,770
that we guessed correctly so from 0 to

885
00:33:57,770 --> 00:34:00,050
16 because we only have 16 bytes in the

886
00:34:00,050 --> 00:34:04,520
key and then they act the horizontal

887
00:34:04,520 --> 00:34:06,170
axis refers to the number of encryptions

888
00:34:06,170 --> 00:34:08,719
that we need yeah the first thing to

889
00:34:08,719 --> 00:34:10,489
notice here compared to the previous

890
00:34:10,489 --> 00:34:12,489
attack is that we get the whole key so

891
00:34:12,489 --> 00:34:14,900
for the three scenarios well yeah you

892
00:34:14,900 --> 00:34:16,880
can say this but the blue the blue line

893
00:34:16,880 --> 00:34:18,440
refers to the first a scenario in which

894
00:34:18,440 --> 00:34:20,929
we have a spy process in a single OS the

895
00:34:20,929 --> 00:34:22,730
green line refers to the second scenario

896
00:34:22,730 --> 00:34:25,040
which we have a single VM and the red

897
00:34:25,040 --> 00:34:27,050
line refers to the third scenario in

898
00:34:27,050 --> 00:34:29,030
which we have a crossbeam attack so we

899
00:34:29,030 --> 00:34:30,889
see that for all of them will recover

900
00:34:30,889 --> 00:34:32,659
the whole key honesty unlike the other

901
00:34:32,659 --> 00:34:36,260
in the other case but also another thing

902
00:34:36,260 --> 00:34:37,730
to notice here is that the number of

903
00:34:37,730 --> 00:34:39,440
encryption that we need for example in

904
00:34:39,440 --> 00:34:41,810
the first case is it's 100,000

905
00:34:41,810 --> 00:34:43,909
encryptions in the second one is 200,000

906
00:34:43,909 --> 00:34:46,489
encryptions and the third one is 400,000

907
00:34:46,489 --> 00:34:48,860
encryptions so clearly these are like

908
00:34:48,860 --> 00:34:51,350
this number is much lower than the one

909
00:34:51,350 --> 00:34:53,540
we saw before this was to do a 29 or to

910
00:34:53,540 --> 00:34:57,230
do a 30 so this means this this number

911
00:34:57,230 --> 00:34:59,510
this number of encryption may seem a lot

912
00:34:59,510 --> 00:35:01,970
but these all these measurements were

913
00:35:01,970 --> 00:35:06,410
taken under a minute so this is going to

914
00:35:06,410 --> 00:35:08,720
be like 12 seconds this one took like 25

915
00:35:08,720 --> 00:35:11,750
and this one take like 55 seconds so

916
00:35:11,750 --> 00:35:13,460
important thing here is that we recover

917
00:35:13,460 --> 00:35:15,080
in AES key thanks to side channel

918
00:35:15,080 --> 00:35:16,910
attacks in less than one minute

919
00:35:16,910 --> 00:35:19,280
so by brute force attacks we shouldn't

920
00:35:19,280 --> 00:35:21,350
be able to recover an aes key with the

921
00:35:21,350 --> 00:35:22,790
computational resources that we have

922
00:35:22,790 --> 00:35:26,500
right right now but we're getting it

923
00:35:26,500 --> 00:35:28,880
yeah in in in less than I mean so that's

924
00:35:28,880 --> 00:35:30,830
how powerful side-channel attacks can

925
00:35:30,830 --> 00:35:31,220
can

926
00:35:31,220 --> 00:35:34,160
and me and actually if we compare our

927
00:35:34,160 --> 00:35:35,840
attack with other attacks that in the in

928
00:35:35,840 --> 00:35:38,540
the area so in the same yeah what is the

929
00:35:38,540 --> 00:35:42,349
mouse so in the same scenario we have

930
00:35:42,349 --> 00:35:45,590
that we we are doing better than done a

931
00:35:45,590 --> 00:35:47,359
big plus time prime improve and some

932
00:35:47,359 --> 00:35:49,880
other collision time in attack well this

933
00:35:49,880 --> 00:35:51,380
one is doing better than us because

934
00:35:51,380 --> 00:35:54,650
they're assuming that a SDS execution

935
00:35:54,650 --> 00:35:56,030
can be blocked and we are not assuming

936
00:35:56,030 --> 00:35:58,730
that because we think it's not too

937
00:35:58,730 --> 00:36:01,400
realistic and inclusive in terms of

938
00:36:01,400 --> 00:36:02,869
course p.m. attacks we can only compare

939
00:36:02,869 --> 00:36:05,150
it with with our attack because we don't

940
00:36:05,150 --> 00:36:07,520
have anymore yeah we see the difference

941
00:36:07,520 --> 00:36:09,290
to do a three encryptions 400,000

942
00:36:09,290 --> 00:36:12,109
encryptions and in the in this in this

943
00:36:12,109 --> 00:36:13,730
experiment we didn't get the Hulk you

944
00:36:13,730 --> 00:36:18,680
only get got a reduced key space so we

945
00:36:18,680 --> 00:36:21,020
definitely improved a lot from one

946
00:36:21,020 --> 00:36:25,250
attack to the your head so now that it's

947
00:36:25,250 --> 00:36:26,540
got some possible countermeasures that

948
00:36:26,540 --> 00:36:29,690
we can apply to this so first of all

949
00:36:29,690 --> 00:36:31,460
we'll gonna divide it into three

950
00:36:31,460 --> 00:36:34,250
categories so in order to be well to

951
00:36:34,250 --> 00:36:35,869
avoid trace different cache attacks what

952
00:36:35,869 --> 00:36:38,210
we can do is in the case of a yes cache

953
00:36:38,210 --> 00:36:39,609
prefetching and cache flushing it's

954
00:36:39,609 --> 00:36:42,109
pretty much well it's very similar but

955
00:36:42,109 --> 00:36:45,380
some differences so catch cache

956
00:36:45,380 --> 00:36:48,260
prefetching what means is that before

957
00:36:48,260 --> 00:36:50,000
the encryption or before each round of

958
00:36:50,000 --> 00:36:52,520
encryption instead of accessing only one

959
00:36:52,520 --> 00:36:54,349
value we're gonna put all the TT of all

960
00:36:54,349 --> 00:36:56,390
values in the cache so now that tackle

961
00:36:56,390 --> 00:36:58,160
is gonna have is gonna see what when he

962
00:36:58,160 --> 00:36:59,869
checks if one TT already has been

963
00:36:59,869 --> 00:37:01,880
accessed or not he's gonna find out that

964
00:37:01,880 --> 00:37:03,770
all the T table values have been

965
00:37:03,770 --> 00:37:05,150
accessed and he cannot distinguish

966
00:37:05,150 --> 00:37:08,660
between accessed or not access we have

967
00:37:08,660 --> 00:37:10,070
cash flashing as well which is pretty

968
00:37:10,070 --> 00:37:12,619
much the same but in the opposite

969
00:37:12,619 --> 00:37:14,780
direction and instead of putting all of

970
00:37:14,780 --> 00:37:17,150
them in the cache the the idea is to put

971
00:37:17,150 --> 00:37:18,950
all of them in the memory so the

972
00:37:18,950 --> 00:37:20,930
attacker doesn't know again which which

973
00:37:20,930 --> 00:37:24,470
TD all value has been accessed we can

974
00:37:24,470 --> 00:37:25,880
increase the efficacy in time driven

975
00:37:25,880 --> 00:37:29,030
attacks how well we saw that this

976
00:37:29,030 --> 00:37:30,770
attacks are based on different access

977
00:37:30,770 --> 00:37:33,020
values on the memory lines right so what

978
00:37:33,020 --> 00:37:34,550
we can do is instead of accessing one

979
00:37:34,550 --> 00:37:36,320
single value we can access all of them

980
00:37:36,320 --> 00:37:38,630
again and now the time is going to be

981
00:37:38,630 --> 00:37:40,310
constant for for each value that we

982
00:37:40,310 --> 00:37:43,160
access or also

983
00:37:43,160 --> 00:37:45,710
we can actually prevent alignment to

984
00:37:45,710 --> 00:37:47,480
page boundaries in this case in the

985
00:37:47,480 --> 00:37:50,630
second case the the Decker spot yeah the

986
00:37:50,630 --> 00:37:53,960
correspondence between memory lines

987
00:37:53,960 --> 00:37:56,180
accessed and access time she's not going

988
00:37:56,180 --> 00:37:57,950
to be the same for victim and attacker

989
00:37:57,950 --> 00:38:00,650
so that a girl cannot actually infer or

990
00:38:00,650 --> 00:38:02,120
he's gonna inferred the wrong key he's

991
00:38:02,120 --> 00:38:04,040
gonna find out that the wrong he was so

992
00:38:04,040 --> 00:38:08,060
used and we can have Harkin term issues

993
00:38:08,060 --> 00:38:10,970
as well in which for example we prevent

994
00:38:10,970 --> 00:38:12,860
the users to use the same portion of the

995
00:38:12,860 --> 00:38:14,330
cache so we have the level three cache

996
00:38:14,330 --> 00:38:15,860
for example this is a share level of

997
00:38:15,860 --> 00:38:18,080
cache and we split it into pieces so

998
00:38:18,080 --> 00:38:20,000
that tenant one is using one portion ten

999
00:38:20,000 --> 00:38:21,500
and two is using another portion ten

1000
00:38:21,500 --> 00:38:24,140
entries using a third portion and ten

1001
00:38:24,140 --> 00:38:25,880
for another one so now since we don't

1002
00:38:25,880 --> 00:38:29,120
have interferences here between these

1003
00:38:29,120 --> 00:38:31,100
portions of the cache cache side-channel

1004
00:38:31,100 --> 00:38:34,960
attacks are pretty much impossible to

1005
00:38:35,170 --> 00:38:38,720
but what we could also do it's a let's

1006
00:38:38,720 --> 00:38:41,660
say that BM w-- m BM one sorry access is

1007
00:38:41,660 --> 00:38:44,330
one one memory line so when the memory

1008
00:38:44,330 --> 00:38:47,420
loads this memory lane to the cache we

1009
00:38:47,420 --> 00:38:51,670
apply a private offset per VM so now

1010
00:38:51,670 --> 00:38:54,620
offset will be n1 has offset 1 or X

1011
00:38:54,620 --> 00:38:56,990
source with offset one and when BM to

1012
00:38:56,990 --> 00:38:58,790
access the same memory line in the cache

1013
00:38:58,790 --> 00:39:01,700
even with the application if another

1014
00:39:01,700 --> 00:39:06,380
offset is applied to BM to now they're

1015
00:39:06,380 --> 00:39:07,940
gonna be or they're gonna find out that

1016
00:39:07,940 --> 00:39:09,800
in the cache this data doesn't look this

1017
00:39:09,800 --> 00:39:12,140
equal and also they're going to go to

1018
00:39:12,140 --> 00:39:13,610
different cache lines so the access

1019
00:39:13,610 --> 00:39:14,960
times is going to be pretty different as

1020
00:39:14,960 --> 00:39:19,370
well so conclusions how the work we've

1021
00:39:19,370 --> 00:39:22,100
done and so there is there exists some

1022
00:39:22,100 --> 00:39:24,110
hardware leakage occurs beyond that we

1023
00:39:24,110 --> 00:39:27,050
have to get rid of how we have to

1024
00:39:27,050 --> 00:39:29,060
perform isolation techniques to avoid

1025
00:39:29,060 --> 00:39:30,530
hardware leakage because this can be

1026
00:39:30,530 --> 00:39:32,210
painful and actually we have two

1027
00:39:32,210 --> 00:39:35,060
scenarios right of how side-channel

1028
00:39:35,060 --> 00:39:37,040
attacks can recover this one of them a

1029
00:39:37,040 --> 00:39:40,670
and a is key for example in the first

1030
00:39:40,670 --> 00:39:41,900
night we didn't have the application

1031
00:39:41,900 --> 00:39:43,430
activated so we could use Princeton

1032
00:39:43,430 --> 00:39:46,220
attack to get a reduced key space I in

1033
00:39:46,220 --> 00:39:47,480
the second is there we had the

1034
00:39:47,480 --> 00:39:49,610
applications the application process is

1035
00:39:49,610 --> 00:39:51,050
going on so we could use flash and

1036
00:39:51,050 --> 00:39:54,500
reload attack so we find we found out

1037
00:39:54,500 --> 00:39:56,470
that the application is a potential risk

1038
00:39:56,470 --> 00:39:57,970
because we got the Navy ask in less than

1039
00:39:57,970 --> 00:40:00,160
a minute so we we communicated this to

1040
00:40:00,160 --> 00:40:02,830
VMware and they respond they actually

1041
00:40:02,830 --> 00:40:06,010
reproduced our attacks in their in their

1042
00:40:06,010 --> 00:40:08,500
yeah in their company or in their

1043
00:40:08,500 --> 00:40:11,200
physical machines and yeah they released

1044
00:40:11,200 --> 00:40:12,910
a document that we can actually take a

1045
00:40:12,910 --> 00:40:16,240
look at explaining how what's the

1046
00:40:16,240 --> 00:40:18,280
configuration to avoid this this kind of

1047
00:40:18,280 --> 00:40:21,609
side-channel attacks in the cloud so you

1048
00:40:21,609 --> 00:40:24,010
can take a look and see and yeah what's

1049
00:40:24,010 --> 00:40:25,020
out there

1050
00:40:25,020 --> 00:40:27,160
so I guess this is all thank you

1051
00:40:27,160 --> 00:40:30,270
everybody and yeah I'll answer

