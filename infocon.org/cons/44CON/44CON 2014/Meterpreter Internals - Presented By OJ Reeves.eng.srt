1
00:00:00,030 --> 00:00:03,030
so my name is AJ I go by the name the

2
00:00:03,030 --> 00:00:05,069
colonial and I'm here to talk to you

3
00:00:05,069 --> 00:00:09,990
about the guts of meterpreter so I had a

4
00:00:09,990 --> 00:00:11,250
couple of personal goals I'm putting

5
00:00:11,250 --> 00:00:12,599
this talk together and the first one is

6
00:00:12,599 --> 00:00:15,269
to try and try and get rid of the myth

7
00:00:15,269 --> 00:00:17,520
that meterpreter is like black magic and

8
00:00:17,520 --> 00:00:19,260
that it's hard to build and it has all

9
00:00:19,260 --> 00:00:20,580
these are really obscure things that it

10
00:00:20,580 --> 00:00:21,900
doesn't no one understands it's actually

11
00:00:21,900 --> 00:00:23,340
really really simple it's just been a

12
00:00:23,340 --> 00:00:25,050
little bit difficult to contribute to

13
00:00:25,050 --> 00:00:27,090
for quite a while so I want to do that I

14
00:00:27,090 --> 00:00:28,590
want to show you how things work

15
00:00:28,590 --> 00:00:30,330
internally in a couple of scenarios and

16
00:00:30,330 --> 00:00:33,059
hopefully inspire a couple of you people

17
00:00:33,059 --> 00:00:35,520
who know better see or whatever - to

18
00:00:35,520 --> 00:00:37,050
dive in and contribute something of your

19
00:00:37,050 --> 00:00:40,649
own so I'm gonna go through what my

20
00:00:40,649 --> 00:00:42,000
server is or at least what I think it is

21
00:00:42,000 --> 00:00:43,170
there seems to be a few different

22
00:00:43,170 --> 00:00:45,270
definitions the bits and pieces that

23
00:00:45,270 --> 00:00:46,770
make it up particularly from a coms

24
00:00:46,770 --> 00:00:49,140
perspective and how you might sort of

25
00:00:49,140 --> 00:00:50,820
use that if you were adding or extending

26
00:00:50,820 --> 00:00:53,039
it and then go through my favorite

27
00:00:53,039 --> 00:00:55,980
feature which is migration by the way

28
00:00:55,980 --> 00:00:58,829
he's a pen tester in here Johanssen lots

29
00:00:58,829 --> 00:01:03,030
of pen testers so he uses Metasploit who

30
00:01:03,030 --> 00:01:06,420
uses material I love you guys yeah

31
00:01:06,420 --> 00:01:08,580
awesome okay so and then hopefully at

32
00:01:08,580 --> 00:01:10,290
the end we'll have we'll have time for

33
00:01:10,290 --> 00:01:11,580
questions but I've got a lot to get

34
00:01:11,580 --> 00:01:12,780
through so I might I'm going to talk a

35
00:01:12,780 --> 00:01:14,790
little bit quickly but throw our

36
00:01:14,790 --> 00:01:16,110
questions at me along the way if you

37
00:01:16,110 --> 00:01:17,549
like I'm happy to take an earth bullet

38
00:01:17,549 --> 00:01:21,630
if if if it adds context we're alright

39
00:01:21,630 --> 00:01:23,610
so what is it um so back in the day when

40
00:01:23,610 --> 00:01:24,990
everyone was popping shells everyone

41
00:01:24,990 --> 00:01:26,490
loves shells shells are really good but

42
00:01:26,490 --> 00:01:27,869
they don't necessarily give you

43
00:01:27,869 --> 00:01:29,159
everything that you want to do when

44
00:01:29,159 --> 00:01:30,360
you've got the chance to do post

45
00:01:30,360 --> 00:01:32,310
exploitation so that's where meterpreter

46
00:01:32,310 --> 00:01:34,350
comes in or the meta interpreter who

47
00:01:34,350 --> 00:01:36,500
knew that it was the meta interpreter

48
00:01:36,500 --> 00:01:38,400
yeah I didn't know that until about a

49
00:01:38,400 --> 00:01:40,680
week ago either so it's the Miller

50
00:01:40,680 --> 00:01:42,360
interpreter I mean it's kind of it's a

51
00:01:42,360 --> 00:01:44,970
payload it's a brat it's a you know it's

52
00:01:44,970 --> 00:01:46,560
it's good if you're a pen tester it's

53
00:01:46,560 --> 00:01:51,149
bad if you're you're a victim it's a

54
00:01:51,149 --> 00:01:54,060
multi-platform tool comes in a variety

55
00:01:54,060 --> 00:01:56,189
of flavors it's running on windows

56
00:01:56,189 --> 00:01:59,460
32-bit 64-bit and this Java versions

57
00:01:59,460 --> 00:02:00,840
there's Android versions and we're

58
00:02:00,840 --> 00:02:02,219
really close to having an OSX version

59
00:02:02,219 --> 00:02:04,469
running as well which is really cool and

60
00:02:04,469 --> 00:02:06,299
the goal of meterpreter really is to be

61
00:02:06,299 --> 00:02:08,369
as forensic ly silent as possible so

62
00:02:08,369 --> 00:02:10,860
don't write to disk and hide itself in

63
00:02:10,860 --> 00:02:11,410
memory

64
00:02:11,410 --> 00:02:13,090
encrypt communications and all that kind

65
00:02:13,090 --> 00:02:14,290
of stuff so that you know if something

66
00:02:14,290 --> 00:02:15,760
does go bad or you have incident

67
00:02:15,760 --> 00:02:17,620
responders trying to track you down it's

68
00:02:17,620 --> 00:02:19,120
not a particularly easy thing for them

69
00:02:19,120 --> 00:02:20,560
to do you actually have to scan memory

70
00:02:20,560 --> 00:02:22,960
to find it gives you a lot more control

71
00:02:22,960 --> 00:02:24,880
as compared to it you know a normal

72
00:02:24,880 --> 00:02:26,650
shell gives you really good sort of

73
00:02:26,650 --> 00:02:29,680
things like pivoting gives you a bunch

74
00:02:29,680 --> 00:02:31,570
of post modules that come with with

75
00:02:31,570 --> 00:02:35,230
Metasploit and yeah it's it's a lot of

76
00:02:35,230 --> 00:02:38,440
fun all right so it's it's huge like the

77
00:02:38,440 --> 00:02:40,630
code base is huge it's five or six

78
00:02:40,630 --> 00:02:43,540
different versions can't possibly cover

79
00:02:43,540 --> 00:02:45,640
all of them in this talk in fact I

80
00:02:45,640 --> 00:02:47,830
wanted to sort of add three or four more

81
00:02:47,830 --> 00:02:51,100
bits to the end of this but yeah there's

82
00:02:51,100 --> 00:02:52,090
just there's no way I was going to

83
00:02:52,090 --> 00:02:54,130
squeeze it in so given there are so many

84
00:02:54,130 --> 00:02:55,960
different implementations I kind of had

85
00:02:55,960 --> 00:02:57,760
to choose one and I chose the one that I

86
00:02:57,760 --> 00:02:59,440
know the most about and that's um the

87
00:02:59,440 --> 00:03:00,850
Windows version so what I'm gonna be

88
00:03:00,850 --> 00:03:05,230
covering is mainly x86 and win32 but a

89
00:03:05,230 --> 00:03:06,580
lot of what I talked about will map

90
00:03:06,580 --> 00:03:09,340
pretty much directly to 64-bit and some

91
00:03:09,340 --> 00:03:10,840
warm after POSIX but all the other ones

92
00:03:10,840 --> 00:03:12,940
are actually very different so but dive

93
00:03:12,940 --> 00:03:14,260
into the code bases and have a look is

94
00:03:14,260 --> 00:03:16,300
there really interesting all right so

95
00:03:16,300 --> 00:03:18,820
the main bits that it's made of first

96
00:03:18,820 --> 00:03:22,030
bit is C in C++ which everyone loves I

97
00:03:22,030 --> 00:03:24,040
know I love and who loves C++

98
00:03:24,040 --> 00:03:27,120
ah you'd admitted it publicly fantastic

99
00:03:27,120 --> 00:03:29,590
so yeah there's a lot of scene C++ so if

100
00:03:29,590 --> 00:03:31,180
you're gonna contribute to at least the

101
00:03:31,180 --> 00:03:32,950
windows or POSIX interpreters he gonna

102
00:03:32,950 --> 00:03:35,560
be diving in the C and C++ land there's

103
00:03:35,560 --> 00:03:38,080
also some sprinklings of assembly both

104
00:03:38,080 --> 00:03:40,930
on the MSF side and on the interpreter

105
00:03:40,930 --> 00:03:42,880
side but and the good thing about it is

106
00:03:42,880 --> 00:03:44,800
that the assembly is not even in Lion

107
00:03:44,800 --> 00:03:47,200
it's just blobs of shell code so if you

108
00:03:47,200 --> 00:03:50,080
want to fix that up be my guest and then

109
00:03:50,080 --> 00:03:52,750
finally a good dose of Ruby I really

110
00:03:52,750 --> 00:03:56,620
love Ruby not really but the only reason

111
00:03:56,620 --> 00:03:57,730
I mention is because obviously

112
00:03:57,730 --> 00:04:00,070
Metasploit is completely written in in

113
00:04:00,070 --> 00:04:02,080
Ruby although it used to be in Perl and

114
00:04:02,080 --> 00:04:05,140
and you'll probably see sprinklings of

115
00:04:05,140 --> 00:04:07,030
all three well you will see sprinklings

116
00:04:07,030 --> 00:04:09,070
of all three a little bit of Ruby a lot

117
00:04:09,070 --> 00:04:11,739
of C and a dabbling of C plus sorry

118
00:04:11,739 --> 00:04:14,709
deviling of assembly so rather than just

119
00:04:14,709 --> 00:04:16,298
sort of throw code in your face without

120
00:04:16,298 --> 00:04:17,829
any context what I wanted to do was run

121
00:04:17,829 --> 00:04:19,298
through a scenario that I think everyone

122
00:04:19,298 --> 00:04:20,649
who's used meterpreter before has

123
00:04:20,649 --> 00:04:21,839
probably seen

124
00:04:21,839 --> 00:04:23,970
and that's establishing a session using

125
00:04:23,970 --> 00:04:30,720
reserve reverse TCP so this is a tried

126
00:04:30,720 --> 00:04:32,669
and proven MSO 8o 67

127
00:04:32,669 --> 00:04:34,139
it's unfortunate it will probably die a

128
00:04:34,139 --> 00:04:37,139
death sometime soon so here what I've

129
00:04:37,139 --> 00:04:39,210
done is I've configured Metasploit to a

130
00:04:39,210 --> 00:04:41,220
point to an XP box as vulnerable to this

131
00:04:41,220 --> 00:04:43,350
bug and we're sitting there ready to go

132
00:04:43,350 --> 00:04:47,419
and all I need to do is type exploit so

133
00:04:47,419 --> 00:04:49,710
so when I type exploit in this

134
00:04:49,710 --> 00:04:51,930
particular case municipal it kicks up a

135
00:04:51,930 --> 00:04:53,639
listener on the port that I've asked so

136
00:04:53,639 --> 00:04:56,729
4 4 4 4 4 and and it sits there and and

137
00:04:56,729 --> 00:04:58,500
the next thing that it does at least in

138
00:04:58,500 --> 00:04:59,940
the case of this exploit is it

139
00:04:59,940 --> 00:05:02,520
fingerprints the target so not all

140
00:05:02,520 --> 00:05:04,530
exploits do this but in this case it's

141
00:05:04,530 --> 00:05:06,570
it's poking the SMB service they're

142
00:05:06,570 --> 00:05:08,460
sitting on 4 or 5 on the on the XP

143
00:05:08,460 --> 00:05:10,200
machine in it fingerprints it a little

144
00:05:10,200 --> 00:05:12,419
bit and says ok well I've detected of

145
00:05:12,419 --> 00:05:14,430
this XP sp2 and it's got an X enabled

146
00:05:14,430 --> 00:05:16,260
that kind of stuff you won't necessarily

147
00:05:16,260 --> 00:05:19,200
see that in every exploit and then after

148
00:05:19,200 --> 00:05:21,960
that it attempts to trigger the

149
00:05:21,960 --> 00:05:23,370
vulnerability so what it's done there is

150
00:05:23,370 --> 00:05:25,290
this is generated some shell code and

151
00:05:25,290 --> 00:05:27,120
it's it's hurling a big buffer at the

152
00:05:27,120 --> 00:05:29,940
target and and hopefully you're gonna

153
00:05:29,940 --> 00:05:31,470
end up with a meterpreter session but

154
00:05:31,470 --> 00:05:33,870
you know to really understand and this

155
00:05:33,870 --> 00:05:35,250
is the point of this talk what's going

156
00:05:35,250 --> 00:05:38,010
on here we're gonna dive just a little

157
00:05:38,010 --> 00:05:41,160
bit deeper so here's the scenario right

158
00:05:41,160 --> 00:05:42,780
we've got our attacking machine running

159
00:05:42,780 --> 00:05:45,060
my our Metasploit on the left and our

160
00:05:45,060 --> 00:05:47,460
target machine running the vulnerable

161
00:05:47,460 --> 00:05:49,430
SMB service on the right hand side so

162
00:05:49,430 --> 00:05:51,780
that's sitting there listening on 4 or 5

163
00:05:51,780 --> 00:05:54,510
and we on our side have our exploit

164
00:05:54,510 --> 00:05:57,600
ready to go so when we kick it off we

165
00:05:57,600 --> 00:05:59,840
fire up our listener on their port and

166
00:05:59,840 --> 00:06:04,139
then we connect to that service on 4 4 5

167
00:06:04,139 --> 00:06:06,960
now at that point some functionality

168
00:06:06,960 --> 00:06:09,360
runs and the sake sort of delegates

169
00:06:09,360 --> 00:06:11,520
responsibility or a function which has a

170
00:06:11,520 --> 00:06:13,139
buffer sitting on the stack and we need

171
00:06:13,139 --> 00:06:14,669
to go after that buffer you've got a

172
00:06:14,669 --> 00:06:17,610
return address pretty basic exploitation

173
00:06:17,610 --> 00:06:18,930
stuff here right so we send them off of

174
00:06:18,930 --> 00:06:21,120
this way TV we override the return

175
00:06:21,120 --> 00:06:22,889
address with something we control and

176
00:06:22,889 --> 00:06:25,110
the goal is to sort of change control

177
00:06:25,110 --> 00:06:26,970
flow so that our own shell code gets

178
00:06:26,970 --> 00:06:30,120
executed now there's a lot of magic that

179
00:06:30,120 --> 00:06:31,260
kind of goes on there there might be Rob

180
00:06:31,260 --> 00:06:32,580
chains and various other things but

181
00:06:32,580 --> 00:06:34,750
that's kind of beyond the scope of this

182
00:06:34,750 --> 00:06:37,180
and from there that shellcodes gonna

183
00:06:37,180 --> 00:06:39,100
connect back to our listener all right

184
00:06:39,100 --> 00:06:40,330
everyone's sort of seen this happen

185
00:06:40,330 --> 00:06:42,720
before I was pretty pretty simple stuff

186
00:06:42,720 --> 00:06:45,280
okay so then what you see in your

187
00:06:45,280 --> 00:06:47,080
console is this message saying sending

188
00:06:47,080 --> 00:06:50,770
stage now sending stage so there's

189
00:06:50,770 --> 00:06:52,180
there's a number of stages involved in

190
00:06:52,180 --> 00:06:54,490
this process but again I kind of want

191
00:06:54,490 --> 00:06:56,260
you to know what that stages and what

192
00:06:56,260 --> 00:06:58,240
it's made of so again I'm gonna go

193
00:06:58,240 --> 00:07:01,420
deeper now at the first stage after

194
00:07:01,420 --> 00:07:03,610
shell Co consists of a dll called MIT

195
00:07:03,610 --> 00:07:07,030
surf net service kind of like their it's

196
00:07:07,030 --> 00:07:08,800
the first thing that we send up its

197
00:07:08,800 --> 00:07:10,480
minimalistic and the goal is to sort of

198
00:07:10,480 --> 00:07:12,550
establish secure communication so that

199
00:07:12,550 --> 00:07:15,310
we can do more what it does is

200
00:07:15,310 --> 00:07:17,500
Metasploit will take a copy of that off

201
00:07:17,500 --> 00:07:19,300
disk and it'll generate a little

202
00:07:19,300 --> 00:07:19,990
bootstrapper

203
00:07:19,990 --> 00:07:22,450
and it will overwrite part of the DOS

204
00:07:22,450 --> 00:07:24,940
header with that bootstrapper and then

205
00:07:24,940 --> 00:07:26,620
send it up amongst a bunch of other

206
00:07:26,620 --> 00:07:28,570
things it sends it up to the target and

207
00:07:28,570 --> 00:07:30,970
the target executes sit bootstraps and

208
00:07:30,970 --> 00:07:33,430
does a bunch of other magic now in the

209
00:07:33,430 --> 00:07:36,490
case of HTTP or HTTPS payloads which

210
00:07:36,490 --> 00:07:37,570
this isn't what we're going through

211
00:07:37,570 --> 00:07:39,340
there are other things that it patches

212
00:07:39,340 --> 00:07:41,260
as well so that when it kicks off it

213
00:07:41,260 --> 00:07:43,360
knows sort of how to connect back but

214
00:07:43,360 --> 00:07:44,950
it's kind of not too interesting in this

215
00:07:44,950 --> 00:07:48,520
particular case so I'm I love assembly

216
00:07:48,520 --> 00:07:49,600
language you're probably gonna see a

217
00:07:49,600 --> 00:07:50,770
little bit more of it during this talk

218
00:07:50,770 --> 00:07:53,830
which I apologize for but this is

219
00:07:53,830 --> 00:07:55,390
effectively the stub that gets

220
00:07:55,390 --> 00:07:57,910
overwritten sorry that over writes the

221
00:07:57,910 --> 00:08:00,340
DOS header the first thing it does is it

222
00:08:00,340 --> 00:08:01,600
just tries to figure out where it lives

223
00:08:01,600 --> 00:08:03,070
in memory so there's a bunch of

224
00:08:03,070 --> 00:08:04,090
different techniques in which to do that

225
00:08:04,090 --> 00:08:06,430
so that's all is doing and then the next

226
00:08:06,430 --> 00:08:09,310
thing it does is it attempts to run

227
00:08:09,310 --> 00:08:11,070
something called the reflective loader

228
00:08:11,070 --> 00:08:15,790
now you'll notice that here we've got 20

229
00:08:15,790 --> 00:08:20,260
DX e bx eb x becomes a pointer to where

230
00:08:20,260 --> 00:08:21,970
we are in memory and we need to know

231
00:08:21,970 --> 00:08:24,100
based on where we are in memory where

232
00:08:24,100 --> 00:08:25,510
the reflective loader is so we have an

233
00:08:25,510 --> 00:08:26,470
offset stash somewhere

234
00:08:26,470 --> 00:08:29,530
so these question marks here are a value

235
00:08:29,530 --> 00:08:31,210
that's actually written to this shell

236
00:08:31,210 --> 00:08:33,669
code by Metasploit so Metasploit will

237
00:08:33,669 --> 00:08:35,679
look at the DLL pull out an offset a

238
00:08:35,679 --> 00:08:37,599
reflective loader punch it into the

239
00:08:37,599 --> 00:08:39,280
shell code send it up and so in this

240
00:08:39,280 --> 00:08:41,409
execute it knows well where to jump to

241
00:08:41,409 --> 00:08:44,190
so that's exactly what's happening there

242
00:08:44,190 --> 00:08:46,450
so what is the reflective loader who

243
00:08:46,450 --> 00:08:48,040
knows anything about reflective Deal

244
00:08:48,040 --> 00:08:52,180
Injection you might be bored I hope you

245
00:08:52,180 --> 00:08:54,310
went before this is really really cool

246
00:08:54,310 --> 00:08:56,589
stuff all right so this guy's Steven

247
00:08:56,589 --> 00:08:58,959
fuer he's a bit of a bit of a machine

248
00:08:58,959 --> 00:09:00,639
this guy he's based in Ireland he runs a

249
00:09:00,639 --> 00:09:02,079
saint company called harmony security

250
00:09:02,079 --> 00:09:04,029
he's the guy that came up at least with

251
00:09:04,029 --> 00:09:05,769
this implementation of reflective DLL

252
00:09:05,769 --> 00:09:08,649
injection so IDI is it's kind of like a

253
00:09:08,649 --> 00:09:11,620
mini in-memory P loader that doesn't do

254
00:09:11,620 --> 00:09:13,389
things that like the load library API

255
00:09:13,389 --> 00:09:16,240
does so it doesn't read from disk it

256
00:09:16,240 --> 00:09:17,649
pulls things straight out of memory it

257
00:09:17,649 --> 00:09:19,600
doesn't register any of the dll's that

258
00:09:19,600 --> 00:09:21,069
are reflectively loaded with the host

259
00:09:21,069 --> 00:09:22,420
process so things like sysinternals

260
00:09:22,420 --> 00:09:25,389
can't figure out what dll has been

261
00:09:25,389 --> 00:09:27,490
loaded again in an effort to sort of not

262
00:09:27,490 --> 00:09:31,540
be visible and in our case we've made a

263
00:09:31,540 --> 00:09:33,550
couple of small adjustments to our di to

264
00:09:33,550 --> 00:09:35,560
make it live nicely within the MSF

265
00:09:35,560 --> 00:09:39,009
ecosystem all right so I'm gonna go

266
00:09:39,009 --> 00:09:40,180
through it and I'm gonna show you the

267
00:09:40,180 --> 00:09:42,819
code just please just bear with me this

268
00:09:42,819 --> 00:09:43,930
couple of bits in there were a little

269
00:09:43,930 --> 00:09:46,779
bit tricky but it's worth it all right

270
00:09:46,779 --> 00:09:48,610
so the steps are the first thing we need

271
00:09:48,610 --> 00:09:50,259
to do is we've been pushed up to a

272
00:09:50,259 --> 00:09:51,610
remote area we don't know where we live

273
00:09:51,610 --> 00:09:53,380
in memory so go figure out where the

274
00:09:53,380 --> 00:09:55,630
start of our images so that we can go on

275
00:09:55,630 --> 00:09:57,010
head and reflectively load it

276
00:09:57,010 --> 00:09:58,899
after that we need to iterate through

277
00:09:58,899 --> 00:10:01,360
the process environment block and get

278
00:10:01,360 --> 00:10:03,610
access to help of dll's and functions

279
00:10:03,610 --> 00:10:05,050
that we can then use to sort of do more

280
00:10:05,050 --> 00:10:07,720
interesting stuff and once we've done

281
00:10:07,720 --> 00:10:09,279
that we need to allocate some memory and

282
00:10:09,279 --> 00:10:10,810
prepare it for where this new am you're

283
00:10:10,810 --> 00:10:13,510
just going to go and then we import all

284
00:10:13,510 --> 00:10:14,980
these functions manually so we're kind

285
00:10:14,980 --> 00:10:16,269
of doing what the operating system does

286
00:10:16,269 --> 00:10:19,180
for is when we load library we deal with

287
00:10:19,180 --> 00:10:21,190
all the relocations thanks to run PE

288
00:10:21,190 --> 00:10:23,110
files not handling position independent

289
00:10:23,110 --> 00:10:25,180
code and then finally when it's loaded

290
00:10:25,180 --> 00:10:27,069
we then invoke DLL main which is the

291
00:10:27,069 --> 00:10:30,699
entry point to a Windows DLL okay excuse

292
00:10:30,699 --> 00:10:31,019
me

293
00:10:31,019 --> 00:10:34,600
all right here we go this is the this is

294
00:10:34,600 --> 00:10:36,579
the fun stuff all right so first of all

295
00:10:36,579 --> 00:10:38,319
we're gonna find the images location and

296
00:10:38,319 --> 00:10:39,880
this is what it looks like up down

297
00:10:39,880 --> 00:10:41,889
version of what it looks like so this

298
00:10:41,889 --> 00:10:44,290
first call here caller is actually a

299
00:10:44,290 --> 00:10:46,300
macro the wraps an intrinsic function

300
00:10:46,300 --> 00:10:48,339
that literally says what's the address

301
00:10:48,339 --> 00:10:52,689
of the thing that called me now if you

302
00:10:52,689 --> 00:10:54,459
kind of remember back to our our di stub

303
00:10:54,459 --> 00:10:56,410
before when we were calling this

304
00:10:56,410 --> 00:10:57,730
function we were actually writing as

305
00:10:57,730 --> 00:11:00,150
start of the bootloader the DOS header

306
00:11:00,150 --> 00:11:02,100
so we can't figure out where that

307
00:11:02,100 --> 00:11:04,260
calling addresses and then we start

308
00:11:04,260 --> 00:11:05,940
iterating backwards to find that the

309
00:11:05,940 --> 00:11:07,980
start of the image so that's what this

310
00:11:07,980 --> 00:11:09,960
next bit does saying have we actually

311
00:11:09,960 --> 00:11:11,340
stumbled across something that looks

312
00:11:11,340 --> 00:11:13,800
like a DOS header and then once it's

313
00:11:13,800 --> 00:11:15,480
found it you know there's a as an inch

314
00:11:15,480 --> 00:11:17,580
case at least in 64-bit mode where we

315
00:11:17,580 --> 00:11:19,020
might actually end up looking at

316
00:11:19,020 --> 00:11:20,250
something that's not a header so there's

317
00:11:20,250 --> 00:11:21,000
an extra Shack

318
00:11:21,000 --> 00:11:23,520
then afterwards we look for the NT

319
00:11:23,520 --> 00:11:24,990
signature as well and we kind of assume

320
00:11:24,990 --> 00:11:27,030
that if at that location is das header

321
00:11:27,030 --> 00:11:28,560
and here we've got int signature then

322
00:11:28,560 --> 00:11:30,660
we're good to go we found the start of

323
00:11:30,660 --> 00:11:32,760
our image and so this library address

324
00:11:32,760 --> 00:11:35,370
here is the value that we know is the

325
00:11:35,370 --> 00:11:39,360
start of our our image in memory okay so

326
00:11:39,360 --> 00:11:42,120
with that in place we want to go through

327
00:11:42,120 --> 00:11:43,950
now and and pull stuff out of the

328
00:11:43,950 --> 00:11:45,270
environment so that we can do things

329
00:11:45,270 --> 00:11:46,770
like get proc address and load library

330
00:11:46,770 --> 00:11:50,640
ourselves so this code is a little bit

331
00:11:50,640 --> 00:11:53,670
quicker this first part here so in in

332
00:11:53,670 --> 00:11:57,030
Windows 48 bytes off from the file

333
00:11:57,030 --> 00:11:59,940
segment is the process environment block

334
00:11:59,940 --> 00:12:01,800
and that's just a bunch of descriptors

335
00:12:01,800 --> 00:12:03,750
that can contain metadata about how the

336
00:12:03,750 --> 00:12:05,250
process is running and what libraries

337
00:12:05,250 --> 00:12:07,920
elated and so from there we can get an

338
00:12:07,920 --> 00:12:10,140
offset to just a bit of pointer

339
00:12:10,140 --> 00:12:11,850
arithmetic and we figure out exactly

340
00:12:11,850 --> 00:12:13,950
where the import import address table is

341
00:12:13,950 --> 00:12:15,930
and from that import address table we're

342
00:12:15,930 --> 00:12:16,980
going to be able to find things like

343
00:12:16,980 --> 00:12:20,190
camel 32 and user 32 and all those other

344
00:12:20,190 --> 00:12:22,020
libraries that have really useful

345
00:12:22,020 --> 00:12:26,820
functions and so moving on again once

346
00:12:26,820 --> 00:12:28,440
we've got that pointer we want to run

347
00:12:28,440 --> 00:12:30,330
through the table and we want to figure

348
00:12:30,330 --> 00:12:32,310
out exactly which libraries have been

349
00:12:32,310 --> 00:12:33,630
loaded and find the ones we're

350
00:12:33,630 --> 00:12:35,940
interested in but in order to do that we

351
00:12:35,940 --> 00:12:38,040
need to be able to identify those those

352
00:12:38,040 --> 00:12:40,140
things so what we're doing here we get

353
00:12:40,140 --> 00:12:42,240
our pointers to the start of the import

354
00:12:42,240 --> 00:12:43,920
address table and we start looping

355
00:12:43,920 --> 00:12:46,170
through it now those so I get to come

356
00:12:46,170 --> 00:12:47,610
back and say these two things here this

357
00:12:47,610 --> 00:12:50,700
is the name of the dll so kernel32 and

358
00:12:50,700 --> 00:12:52,890
this tells us the length of that DLL

359
00:12:52,890 --> 00:12:54,720
because this is in this is a Unicode

360
00:12:54,720 --> 00:12:56,700
buffer it's not ANSI so it's not null

361
00:12:56,700 --> 00:12:58,980
terminated from there we do a little

362
00:12:58,980 --> 00:13:02,100
hash when I say we I mean Steven Steven

363
00:13:02,100 --> 00:13:03,840
does a little hash and what this is

364
00:13:03,840 --> 00:13:05,310
doing it's a really simple hashing

365
00:13:05,310 --> 00:13:07,470
algorithm and it's got some pretty crazy

366
00:13:07,470 --> 00:13:10,020
properties like hashing all of the

367
00:13:10,020 --> 00:13:12,810
modules or at least all over the base

368
00:13:12,810 --> 00:13:13,649
module names

369
00:13:13,649 --> 00:13:15,899
us windows that are common to all the

370
00:13:15,899 --> 00:13:17,910
operating systems doesn't result in a

371
00:13:17,910 --> 00:13:20,249
clash which is kind of cool and the same

372
00:13:20,249 --> 00:13:23,160
goes for function names within those

373
00:13:23,160 --> 00:13:24,930
things so it's really simple but it's a

374
00:13:24,930 --> 00:13:26,490
really easy way of identifying a

375
00:13:26,490 --> 00:13:28,709
function or a module name I'm just by

376
00:13:28,709 --> 00:13:29,970
running this little algorithm it's just

377
00:13:29,970 --> 00:13:32,939
kind of like a rotate 13 bits pull the

378
00:13:32,939 --> 00:13:35,429
next value in at it rotate 13 bits etc

379
00:13:35,429 --> 00:13:37,079
so that gives us a hash value which we

380
00:13:37,079 --> 00:13:40,019
can then then use later on now the

381
00:13:40,019 --> 00:13:41,459
reason why we do this with hashing

382
00:13:41,459 --> 00:13:44,040
instead of saying loading strings is so

383
00:13:44,040 --> 00:13:45,990
strings of a pretty big and null

384
00:13:45,990 --> 00:13:49,740
terminated they kind of they bloat

385
00:13:49,740 --> 00:13:53,040
payload size and and part of the goal

386
00:13:53,040 --> 00:13:55,170
for this was to make their the hashing

387
00:13:55,170 --> 00:13:56,790
algorithm and that the process that's

388
00:13:56,790 --> 00:13:58,800
used to locate functions in memory very

389
00:13:58,800 --> 00:14:00,179
similar to something called the block

390
00:14:00,179 --> 00:14:02,279
API which is another thing that's even

391
00:14:02,279 --> 00:14:04,529
if you were created that lets you do

392
00:14:04,529 --> 00:14:07,139
similar sort of stuff in shell code so

393
00:14:07,139 --> 00:14:09,179
anywhere having a 32 bit hashing memory

394
00:14:09,179 --> 00:14:10,980
is obviously a bit bit of a savior's

395
00:14:10,980 --> 00:14:12,540
compared to having dozens of strings for

396
00:14:12,540 --> 00:14:13,679
functions that you're really interested

397
00:14:13,679 --> 00:14:16,259
in so that's why we hashed anyway once

398
00:14:16,259 --> 00:14:18,149
we found a valid hash so here we've

399
00:14:18,149 --> 00:14:19,980
calculated the hash in value C and then

400
00:14:19,980 --> 00:14:21,420
we compare it to our known hash for

401
00:14:21,420 --> 00:14:23,519
camel 32 that's the dll that we're

402
00:14:23,519 --> 00:14:26,759
interested in and from there more magic

403
00:14:26,759 --> 00:14:29,129
pointer arithmetic and really all this

404
00:14:29,129 --> 00:14:30,360
is doing is saying okay I've got the

405
00:14:30,360 --> 00:14:32,220
module now I want to go and find all of

406
00:14:32,220 --> 00:14:33,779
the functions that are exported for that

407
00:14:33,779 --> 00:14:34,800
module and we're going to start

408
00:14:34,800 --> 00:14:37,019
iterating through those nothing too

409
00:14:37,019 --> 00:14:41,249
tricky okay now once we've found that

410
00:14:41,249 --> 00:14:43,679
address table either modules table we're

411
00:14:43,679 --> 00:14:45,749
going to calculate the hash for each

412
00:14:45,749 --> 00:14:49,110
individual function within that module

413
00:14:49,110 --> 00:14:51,420
and there will be things like load

414
00:14:51,420 --> 00:14:53,249
librarian and all those other functions

415
00:14:53,249 --> 00:14:55,980
so once we've got that hash value and

416
00:14:55,980 --> 00:14:58,290
the hash algorithm is exactly the same

417
00:14:58,290 --> 00:14:59,639
as the one I just described before this

418
00:14:59,639 --> 00:15:01,379
is in a helper function because these

419
00:15:01,379 --> 00:15:03,240
are ANSI strings and hence we don't need

420
00:15:03,240 --> 00:15:05,699
to worry about lengths so we've got a

421
00:15:05,699 --> 00:15:08,819
hash and one of those values is one that

422
00:15:08,819 --> 00:15:11,220
we're going to be interested in so once

423
00:15:11,220 --> 00:15:12,949
we found a library we're interested in

424
00:15:12,949 --> 00:15:16,019
the next thing we do is we get the

425
00:15:16,019 --> 00:15:21,779
address of the function itself which is

426
00:15:21,779 --> 00:15:23,819
not particularly fascinating but here

427
00:15:23,819 --> 00:15:25,319
what we do is we say ok well if this

428
00:15:25,319 --> 00:15:26,339
hash points to the

429
00:15:26,339 --> 00:15:27,569
function then what we want to actually

430
00:15:27,569 --> 00:15:30,290
do is we want to patch or want to take a

431
00:15:30,290 --> 00:15:33,540
copy of that address and cast it to a

432
00:15:33,540 --> 00:15:35,069
function type that we know we can call

433
00:15:35,069 --> 00:15:36,800
so you see there's just a couple of

434
00:15:36,800 --> 00:15:39,509
casts going on here we know that this in

435
00:15:39,509 --> 00:15:41,459
the case of load library is going to be

436
00:15:41,459 --> 00:15:42,720
the load library function so we've got

437
00:15:42,720 --> 00:15:44,249
our own sort of type def that says well

438
00:15:44,249 --> 00:15:45,569
that's a function pointer that takes a

439
00:15:45,569 --> 00:15:47,999
bunch of types and so we cast that value

440
00:15:47,999 --> 00:15:50,399
to to some particular type and then we

441
00:15:50,399 --> 00:15:51,990
stash it so that we can use it later

442
00:15:51,990 --> 00:15:54,449
and we do that for a number of functions

443
00:15:54,449 --> 00:15:55,740
I've only just shown a couple here you

444
00:15:55,740 --> 00:15:57,240
can see the rest in the code if you're

445
00:15:57,240 --> 00:16:00,269
interested so we've got all our modules

446
00:16:00,269 --> 00:16:01,829
we've got all our functions that we need

447
00:16:01,829 --> 00:16:04,319
to use to do more pee-yew loading and so

448
00:16:04,319 --> 00:16:06,149
from now on we can start using those

449
00:16:06,149 --> 00:16:07,529
functions to do more interesting stuff

450
00:16:07,529 --> 00:16:11,189
like creating a valid p image so the

451
00:16:11,189 --> 00:16:12,899
next thing we want to do is we want to

452
00:16:12,899 --> 00:16:14,910
allocate some memory and kind of move

453
00:16:14,910 --> 00:16:17,370
things over anyone familiar with PE

454
00:16:17,370 --> 00:16:22,949
loading room same guy okay so the P

455
00:16:22,949 --> 00:16:25,410
image requires a certain sort of layout

456
00:16:25,410 --> 00:16:27,809
in memory and the size on disk isn't

457
00:16:27,809 --> 00:16:29,459
necessarily the same as the size that it

458
00:16:29,459 --> 00:16:31,920
needs to be in memory so that's why we

459
00:16:31,920 --> 00:16:33,389
can't assume that the DLL that we've

460
00:16:33,389 --> 00:16:35,850
already pushed up is kind of okay to use

461
00:16:35,850 --> 00:16:38,579
where it currently is and so we need to

462
00:16:38,579 --> 00:16:40,110
sort of allocate memory and move it over

463
00:16:40,110 --> 00:16:41,519
and make sure there's enough space for

464
00:16:41,519 --> 00:16:43,319
each section deal with relocation so

465
00:16:43,319 --> 00:16:44,519
that's the reason why we're doing this

466
00:16:44,519 --> 00:16:46,620
plus the memory we may have just been

467
00:16:46,620 --> 00:16:49,170
written to at least to a point may not

468
00:16:49,170 --> 00:16:55,160
be executable right so what are we doing

469
00:16:55,160 --> 00:16:59,449
we are we're going to do some more um

470
00:16:59,449 --> 00:17:02,309
pointer arithmetic to get a pointer to a

471
00:17:02,309 --> 00:17:05,159
location in memory that's um that tells

472
00:17:05,159 --> 00:17:07,140
us where where the images that we're

473
00:17:07,140 --> 00:17:08,849
going to be loading and then from there

474
00:17:08,849 --> 00:17:11,369
we're allocating space the only thing

475
00:17:11,369 --> 00:17:12,750
that's really worthy of note here is

476
00:17:12,750 --> 00:17:14,069
that we're making sure that the memory

477
00:17:14,069 --> 00:17:16,199
is executable readable and writeable so

478
00:17:16,199 --> 00:17:17,250
that once we've actually copied

479
00:17:17,250 --> 00:17:18,539
everything over we can just kick off a

480
00:17:18,539 --> 00:17:19,919
thread and it'll go ahead and execute

481
00:17:19,919 --> 00:17:23,549
happily and here you can see slightly

482
00:17:23,549 --> 00:17:25,439
off screen that we've specifying the

483
00:17:25,439 --> 00:17:27,179
actual size of the image not the size of

484
00:17:27,179 --> 00:17:28,950
the file on disk so we should have

485
00:17:28,950 --> 00:17:30,240
enough space in which to put everything

486
00:17:30,240 --> 00:17:34,110
in and then from there this is this very

487
00:17:34,110 --> 00:17:35,490
slight enhancement that we do with

488
00:17:35,490 --> 00:17:36,690
Metasploit that isn't in the original

489
00:17:36,690 --> 00:17:38,390
RDI implementation

490
00:17:38,390 --> 00:17:41,030
that is we request with the operating

491
00:17:41,030 --> 00:17:42,590
system that the memory space that we've

492
00:17:42,590 --> 00:17:45,020
just allocated does not ever appear in

493
00:17:45,020 --> 00:17:46,760
the page file so if you've got that

494
00:17:46,760 --> 00:17:48,890
quirky scenario where you've just been

495
00:17:48,890 --> 00:17:50,750
paged to disk and then the OS crashes

496
00:17:50,750 --> 00:17:52,370
and then incident response kicks in like

497
00:17:52,370 --> 00:17:53,510
you're going to be in the page file

498
00:17:53,510 --> 00:17:55,160
right we kind of don't want that to

499
00:17:55,160 --> 00:17:57,170
happen so this function call allows us

500
00:17:57,170 --> 00:17:58,940
to do that however the documentation

501
00:17:58,940 --> 00:18:00,770
says well you can ask us to do it we're

502
00:18:00,770 --> 00:18:02,000
not necessarily going to guarantee that

503
00:18:02,000 --> 00:18:04,190
you won't appear on disk but for the

504
00:18:04,190 --> 00:18:07,030
most part I mean I haven't seen you guys

505
00:18:07,030 --> 00:18:09,080
so that's one of the things we try and

506
00:18:09,080 --> 00:18:11,330
do again destroy itself disk and then

507
00:18:11,330 --> 00:18:14,030
from here we just do a byte by byte copy

508
00:18:14,030 --> 00:18:16,760
of the existing PE header including the

509
00:18:16,760 --> 00:18:17,240
patched

510
00:18:17,240 --> 00:18:18,860
DOS header which windows generally

511
00:18:18,860 --> 00:18:20,690
doesn't care about anyway so that first

512
00:18:20,690 --> 00:18:21,980
part is then moved over to the new

513
00:18:21,980 --> 00:18:25,070
memory block now when that's done I'm

514
00:18:25,070 --> 00:18:26,690
gonna rip through and do the section so

515
00:18:26,690 --> 00:18:28,490
there's there's not really that much

516
00:18:28,490 --> 00:18:30,380
tricky stuff going on here we calculate

517
00:18:30,380 --> 00:18:32,690
various bits and pieces about the

518
00:18:32,690 --> 00:18:34,280
section including its size that it

519
00:18:34,280 --> 00:18:36,710
should actually be in memory we pull out

520
00:18:36,710 --> 00:18:37,850
the number of sections we iterate

521
00:18:37,850 --> 00:18:40,160
through each one and and again we're

522
00:18:40,160 --> 00:18:44,360
doing a byte by byte copy so size of raw

523
00:18:44,360 --> 00:18:47,180
data rather than the size that it is on

524
00:18:47,180 --> 00:18:49,670
disk basic point of stuff that figures

525
00:18:49,670 --> 00:18:51,050
our virtual address is based on the

526
00:18:51,050 --> 00:18:52,490
offset at the start of the image and

527
00:18:52,490 --> 00:18:54,770
then we just copy it over and by doing

528
00:18:54,770 --> 00:18:56,870
it this way we end up allowing for the

529
00:18:56,870 --> 00:18:58,820
space for each section rather than it

530
00:18:58,820 --> 00:18:59,900
just being the size that it was

531
00:18:59,900 --> 00:19:07,710
specified on disk exactly as so far okay

532
00:19:07,710 --> 00:19:10,080
okay so from here we've got this steel L

533
00:19:10,080 --> 00:19:12,330
sitting in memory but it's obviously got

534
00:19:12,330 --> 00:19:15,690
some dependencies those dependencies

535
00:19:15,690 --> 00:19:17,520
haven't been loaded so if we attempted

536
00:19:17,520 --> 00:19:19,710
to run the DLL now and it assembly to

537
00:19:19,710 --> 00:19:20,850
hit the the IAC

538
00:19:20,850 --> 00:19:22,770
and run a function it would crash

539
00:19:22,770 --> 00:19:24,630
because it doesn't actually have a valid

540
00:19:24,630 --> 00:19:26,220
address so we need to go through now and

541
00:19:26,220 --> 00:19:28,020
for each one of the values in the import

542
00:19:28,020 --> 00:19:29,549
address table we need to go on find the

543
00:19:29,549 --> 00:19:31,679
module and the function that it's

544
00:19:31,679 --> 00:19:33,980
looking for and manually why they didn't

545
00:19:33,980 --> 00:19:37,470
so here's where we start figure out

546
00:19:37,470 --> 00:19:39,120
exactly where the import address table

547
00:19:39,120 --> 00:19:43,529
is and then again more magic point of

548
00:19:43,529 --> 00:19:45,270
stuff that points directly the VA fir

549
00:19:45,270 --> 00:19:48,179
for that table and then while we're sort

550
00:19:48,179 --> 00:19:49,799
of luke while we actually have a valid

551
00:19:49,799 --> 00:19:52,409
entry that we're looking at what we do

552
00:19:52,409 --> 00:19:55,980
is is we call load library on the entry

553
00:19:55,980 --> 00:19:58,200
so again we pulled a load library out

554
00:19:58,200 --> 00:20:00,059
when we did our sort of process

555
00:20:00,059 --> 00:20:02,279
environment block iteration before so we

556
00:20:02,279 --> 00:20:03,570
have that function we've got a valid

557
00:20:03,570 --> 00:20:05,100
function pointer and now we're going to

558
00:20:05,100 --> 00:20:06,659
load that library from disk based on its

559
00:20:06,659 --> 00:20:10,649
name that's just a little bit of error

560
00:20:10,649 --> 00:20:12,330
checking a stable if we couldn't load it

561
00:20:12,330 --> 00:20:13,860
we'll just carry on and hope that

562
00:20:13,860 --> 00:20:15,690
nothing dies later on when a functions

563
00:20:15,690 --> 00:20:19,590
call and so from there there's two

564
00:20:19,590 --> 00:20:21,210
different ways in which a library can be

565
00:20:21,210 --> 00:20:23,789
sort of linked with with a dll and one

566
00:20:23,789 --> 00:20:25,770
of them is by ordinal only which is just

567
00:20:25,770 --> 00:20:28,049
like an offset into a function table

568
00:20:28,049 --> 00:20:30,120
list and the other one is by name so

569
00:20:30,120 --> 00:20:32,279
this is catering for both cases it's

570
00:20:32,279 --> 00:20:33,750
checking to see whether the ordinal flag

571
00:20:33,750 --> 00:20:36,149
is set and from there again just a big

572
00:20:36,149 --> 00:20:38,580
bunch of pointer arithmetic all it's

573
00:20:38,580 --> 00:20:41,399
doing is offsetting based on an ordinal

574
00:20:41,399 --> 00:20:43,470
into a table of functions figuring out a

575
00:20:43,470 --> 00:20:44,940
virtual address space on where that is

576
00:20:44,940 --> 00:20:46,860
currently in memory after loading it

577
00:20:46,860 --> 00:20:48,690
into memory and then you'll see down the

578
00:20:48,690 --> 00:20:51,990
bottom here we actually patch the

579
00:20:51,990 --> 00:20:54,570
current value which is inside the import

580
00:20:54,570 --> 00:20:56,640
address table in our parent module with

581
00:20:56,640 --> 00:20:57,809
the value that we've just calculated

582
00:20:57,809 --> 00:21:01,230
based on loading the the new librarians

583
00:21:01,230 --> 00:21:03,240
memory so really Shirley's going ok

584
00:21:03,240 --> 00:21:04,559
we're gonna rip through we need load

585
00:21:04,559 --> 00:21:06,000
library all we need them so we need

586
00:21:06,000 --> 00:21:08,460
kernel32 so let's load that up load it

587
00:21:08,460 --> 00:21:10,140
into memory we're gonna find a module

588
00:21:10,140 --> 00:21:11,940
within it and wide that function pointer

589
00:21:11,940 --> 00:21:13,590
in and then slowly but surely as we've

590
00:21:13,590 --> 00:21:15,360
gone through all of the table we'll end

591
00:21:15,360 --> 00:21:16,980
up with a hopefully we'll end up with an

592
00:21:16,980 --> 00:21:19,380
image that has all of the IAT entries so

593
00:21:19,380 --> 00:21:20,580
that when we kick it off it's not going

594
00:21:20,580 --> 00:21:22,610
to

595
00:21:22,610 --> 00:21:24,780
this is the less interesting one and

596
00:21:24,780 --> 00:21:27,330
much simpler so in the else case this is

597
00:21:27,330 --> 00:21:29,010
when we do actually have a library name

598
00:21:29,010 --> 00:21:32,100
that we can loan as you can see we we

599
00:21:32,100 --> 00:21:34,050
get the name the address of the name and

600
00:21:34,050 --> 00:21:35,970
then we call get proper dress so get

601
00:21:35,970 --> 00:21:38,160
proper dress says for this module tell

602
00:21:38,160 --> 00:21:39,630
me where I can find this function by

603
00:21:39,630 --> 00:21:41,970
name and it will return a pointer and we

604
00:21:41,970 --> 00:21:43,620
use that pointer again to patch straight

605
00:21:43,620 --> 00:21:45,150
into the IAT so that we can call it

606
00:21:45,150 --> 00:21:50,090
later on pretty simple right right so

607
00:21:50,090 --> 00:21:52,410
with that in place the only thing really

608
00:21:52,410 --> 00:21:53,640
that we've got left to make sure that

609
00:21:53,640 --> 00:21:55,320
the P is I'm going to crash is dealing

610
00:21:55,320 --> 00:21:58,080
with relocations relocations anyone know

611
00:21:58,080 --> 00:22:01,500
relocations are yeah same guy yep okay

612
00:22:01,500 --> 00:22:04,770
so the PE image doesn't really support

613
00:22:04,770 --> 00:22:06,420
the idea of having position independent

614
00:22:06,420 --> 00:22:08,790
code what it has is a preferred base

615
00:22:08,790 --> 00:22:11,070
address and a bunch of functions that

616
00:22:11,070 --> 00:22:12,900
kind of call based on that return

617
00:22:12,900 --> 00:22:15,330
address but if Windows isn't able to

618
00:22:15,330 --> 00:22:17,010
learn and load that library into that

619
00:22:17,010 --> 00:22:18,630
exact address what has to happen is

620
00:22:18,630 --> 00:22:21,630
relocation so wherever it is based a

621
00:22:21,630 --> 00:22:23,700
bunch of offsets and calculations happen

622
00:22:23,700 --> 00:22:25,890
and each individual call is patched and

623
00:22:25,890 --> 00:22:27,900
this is kind of what it looks like in

624
00:22:27,900 --> 00:22:30,630
pseudo kind of form because the code

625
00:22:30,630 --> 00:22:32,280
around this stuff is it's very hard to

626
00:22:32,280 --> 00:22:34,770
put on a slide and not have you walk out

627
00:22:34,770 --> 00:22:37,680
while I'm talking about it so really in

628
00:22:37,680 --> 00:22:38,910
theory all it's doing is like there's a

629
00:22:38,910 --> 00:22:40,770
bunch of relocation block entries and

630
00:22:40,770 --> 00:22:42,360
inside those relocation blocks there's

631
00:22:42,360 --> 00:22:44,730
detail of individual relocations and so

632
00:22:44,730 --> 00:22:46,440
we just do a a double sort of for loop

633
00:22:46,440 --> 00:22:48,930
and we iterate through and based on the

634
00:22:48,930 --> 00:22:51,330
address that we started at and we look

635
00:22:51,330 --> 00:22:52,830
at the preferred address for the image

636
00:22:52,830 --> 00:22:55,290
basic offset and we roof through all the

637
00:22:55,290 --> 00:22:57,630
relocations and either add or subtract a

638
00:22:57,630 --> 00:22:59,430
value based on that offset and that's

639
00:22:59,430 --> 00:23:00,780
really all it does it just looks a

640
00:23:00,780 --> 00:23:01,560
little bit messy

641
00:23:01,560 --> 00:23:04,800
hence the hence the slide so when that's

642
00:23:04,800 --> 00:23:07,740
seen in place we now have a completely

643
00:23:07,740 --> 00:23:10,200
valid DLL sitting in memory that we can

644
00:23:10,200 --> 00:23:12,000
invoke that hasn't been registered with

645
00:23:12,000 --> 00:23:13,440
the host process and hopefully will

646
00:23:13,440 --> 00:23:17,730
never touch disk okay so we then invoke

647
00:23:17,730 --> 00:23:20,220
DLL main so we want the DLL be

648
00:23:20,220 --> 00:23:23,280
initialized excuse me and so we figure

649
00:23:23,280 --> 00:23:24,630
out the address of the entry point based

650
00:23:24,630 --> 00:23:26,910
on the metadata in the header once

651
00:23:26,910 --> 00:23:29,370
you've got that pointer we call DLL main

652
00:23:29,370 --> 00:23:31,350
with DLL process attached so this is

653
00:23:31,350 --> 00:23:32,980
we're back in sort of standard Devlin

654
00:23:32,980 --> 00:23:35,590
now the DLL is kicking off exactly as it

655
00:23:35,590 --> 00:23:38,650
should but because we need to actually

656
00:23:38,650 --> 00:23:41,680
deal with dear DLL main in other

657
00:23:41,680 --> 00:23:44,530
scenarios due to MSF we also returned

658
00:23:44,530 --> 00:23:47,590
that function pointed back back to the

659
00:23:47,590 --> 00:23:51,880
bootloader that we looked at before so

660
00:23:51,880 --> 00:23:54,340
we're kind of back here now so this call

661
00:23:54,340 --> 00:23:57,370
here is what we've just executed and we

662
00:23:57,370 --> 00:23:59,140
come back out of that and so DLL mains

663
00:23:59,140 --> 00:24:01,330
pointer is in EAX where the return value

664
00:24:01,330 --> 00:24:03,130
comes from then we stashed that you need

665
00:24:03,130 --> 00:24:05,320
a BX the uvx register which doesn't get

666
00:24:05,320 --> 00:24:06,550
trounced when you make up the course

667
00:24:06,550 --> 00:24:08,080
right so we've now got a persistent

668
00:24:08,080 --> 00:24:10,060
location to deal I mean and we'll be

669
00:24:10,060 --> 00:24:12,580
calling that a couple more times so the

670
00:24:12,580 --> 00:24:15,400
first time this is Metasploit specific

671
00:24:15,400 --> 00:24:16,630
in case you didn't notice what we're

672
00:24:16,630 --> 00:24:18,160
doing is we're taking a copy of the

673
00:24:18,160 --> 00:24:19,180
socket we're currently doing

674
00:24:19,180 --> 00:24:20,950
communications on which is sitting in

675
00:24:20,950 --> 00:24:23,440
another register called EDI we take that

676
00:24:23,440 --> 00:24:25,390
stick it on the stack pass some

677
00:24:25,390 --> 00:24:27,430
Metasploit attach so all of the

678
00:24:27,430 --> 00:24:29,050
components of Metasploit and colluding

679
00:24:29,050 --> 00:24:30,160
that serve and a bunch of other

680
00:24:30,160 --> 00:24:33,010
extensions will look for this and and

681
00:24:33,010 --> 00:24:34,630
handle functionality based on that

682
00:24:34,630 --> 00:24:36,160
rather than just doing it as part of

683
00:24:36,160 --> 00:24:39,100
them of process attached so this is

684
00:24:39,100 --> 00:24:41,800
actually a blocking call in this case

685
00:24:41,800 --> 00:24:43,690
we're invoking net serve that first

686
00:24:43,690 --> 00:24:45,670
stage and met serve is going to take the

687
00:24:45,670 --> 00:24:47,200
socket descriptor and handle

688
00:24:47,200 --> 00:24:48,820
communications from there on it's going

689
00:24:48,820 --> 00:24:50,680
to wrap it in ssl and do a bunch of

690
00:24:50,680 --> 00:24:52,990
other bits and pieces and so this blocks

691
00:24:52,990 --> 00:24:55,420
until you've asked meterpreter to shut

692
00:24:55,420 --> 00:24:57,040
down or it crashes or incident response

693
00:24:57,040 --> 00:24:59,140
man is just to shut you down and when

694
00:24:59,140 --> 00:25:03,040
that finishes it will come back sorry

695
00:25:03,040 --> 00:25:07,240
it'll come back here and call Metasploit

696
00:25:07,240 --> 00:25:09,400
detach now when you're setting up an

697
00:25:09,400 --> 00:25:10,750
exploit in Metasploit you guys are

698
00:25:10,750 --> 00:25:12,490
probably familiar you specify in your

699
00:25:12,490 --> 00:25:14,770
payload what kind of exit functionality

700
00:25:14,770 --> 00:25:15,910
you want so if you know that your

701
00:25:15,910 --> 00:25:18,400
exploit is smashing an SCH film ability

702
00:25:18,400 --> 00:25:20,320
then you've got the ability to say well

703
00:25:20,320 --> 00:25:21,850
this is an SCH exploit I want you to

704
00:25:21,850 --> 00:25:23,890
exit in this way if you know that you're

705
00:25:23,890 --> 00:25:25,300
running in a separate thread we just

706
00:25:25,300 --> 00:25:26,500
want to terminate the thread so that the

707
00:25:26,500 --> 00:25:27,880
process doesn't crash so this what this

708
00:25:27,880 --> 00:25:29,860
exit functionality actually is and again

709
00:25:29,860 --> 00:25:32,560
this is patched in by Metasploit in the

710
00:25:32,560 --> 00:25:34,540
shell code prior to that little

711
00:25:34,540 --> 00:25:39,100
bootstrapper being uploaded okay so

712
00:25:39,100 --> 00:25:41,170
there's more fun stuff in Metasploit

713
00:25:41,170 --> 00:25:43,930
attached and we're gonna go a little bit

714
00:25:43,930 --> 00:25:44,990
deeper

715
00:25:44,990 --> 00:25:48,600
okay so we're running net surf

716
00:25:48,600 --> 00:25:51,630
we're in DLL main we've the first thing

717
00:25:51,630 --> 00:25:53,159
that we do is we create a server thread

718
00:25:53,159 --> 00:25:54,779
so there's this thread running behind

719
00:25:54,779 --> 00:25:57,059
the scenes and when we get a command

720
00:25:57,059 --> 00:25:59,340
that's been sent for a meta split that's

721
00:25:59,340 --> 00:26:00,840
the thread that's going to execute the

722
00:26:00,840 --> 00:26:04,049
command on top of that we take over as a

723
00:26:04,049 --> 00:26:06,149
suit communications we fire up an open

724
00:26:06,149 --> 00:26:09,179
SSL I mean make sure that everything's

725
00:26:09,179 --> 00:26:10,260
encrypted from there on in that's

726
00:26:10,260 --> 00:26:12,390
recently been patched by Todd Beardsley

727
00:26:12,390 --> 00:26:14,580
so that it's not susceptible to

728
00:26:14,580 --> 00:26:16,889
client-side heartbleed attacks which is

729
00:26:16,889 --> 00:26:19,950
cool once that's in place we then kick

730
00:26:19,950 --> 00:26:22,139
off something called a scheduler so

731
00:26:22,139 --> 00:26:23,820
those familiar with meterpreter all know

732
00:26:23,820 --> 00:26:25,380
that you can do things like interactive

733
00:26:25,380 --> 00:26:27,000
shells or you can do port forwards and a

734
00:26:27,000 --> 00:26:28,289
bunch of other cool things that kind of

735
00:26:28,289 --> 00:26:30,539
run behind the scenes that's handled by

736
00:26:30,539 --> 00:26:32,700
the scheduler so that's that's when

737
00:26:32,700 --> 00:26:34,169
that's initialized and then from there

738
00:26:34,169 --> 00:26:35,639
once those two threads are running and

739
00:26:35,639 --> 00:26:37,169
they're doing their thing we kick off

740
00:26:37,169 --> 00:26:38,460
something called The Dispatch loop which

741
00:26:38,460 --> 00:26:40,380
is kind of not too dissimilar from a

742
00:26:40,380 --> 00:26:42,419
win32 message pump we're just listening

743
00:26:42,419 --> 00:26:43,500
on a socket instead

744
00:26:43,500 --> 00:26:45,029
okay so we're sitting there waiting for

745
00:26:45,029 --> 00:26:47,600
messages from from Metasploit to come in

746
00:26:47,600 --> 00:26:50,059
so is that it

747
00:26:50,059 --> 00:26:53,429
not quite there's there's we're almost

748
00:26:53,429 --> 00:26:55,320
there the only problem we've got now is

749
00:26:55,320 --> 00:26:57,269
that while we've got comms up and it's

750
00:26:57,269 --> 00:26:57,809
encrypted

751
00:26:57,809 --> 00:26:59,909
we don't have any functionality that we

752
00:26:59,909 --> 00:27:02,100
can use and the reason for that is

753
00:27:02,100 --> 00:27:03,419
because MIT serve doesn't have anything

754
00:27:03,419 --> 00:27:05,490
else in it and the goal there is to make

755
00:27:05,490 --> 00:27:08,039
that first stage as small as possible so

756
00:27:08,039 --> 00:27:09,389
that we can establish Tom's and we've

757
00:27:09,389 --> 00:27:11,070
got less stuff going up in the clear so

758
00:27:11,070 --> 00:27:12,990
it can't be fingerprinted or caught by

759
00:27:12,990 --> 00:27:15,330
IDs or anything like that so what we

760
00:27:15,330 --> 00:27:16,710
need to do is we need to push up more

761
00:27:16,710 --> 00:27:18,870
stuff that gives us the functionality

762
00:27:18,870 --> 00:27:20,179
that we're looking for

763
00:27:20,179 --> 00:27:24,870
okay so anyone ever got to this point

764
00:27:24,870 --> 00:27:26,610
here and run a command and it said

765
00:27:26,610 --> 00:27:30,539
command not found yeah lots of people

766
00:27:30,539 --> 00:27:31,710
this happens all it's nice one of those

767
00:27:31,710 --> 00:27:33,510
common questions right why is it it says

768
00:27:33,510 --> 00:27:35,370
I've got a session but it doesn't so at

769
00:27:35,370 --> 00:27:37,590
this point met serve is running but you

770
00:27:37,590 --> 00:27:39,630
don't have any commands so if your

771
00:27:39,630 --> 00:27:42,149
connection is really laggy or for

772
00:27:42,149 --> 00:27:43,649
whatever reason it takes a while to

773
00:27:43,649 --> 00:27:44,909
upload the next bit so you can be

774
00:27:44,909 --> 00:27:46,500
sitting there saying you know get system

775
00:27:46,500 --> 00:27:48,000
get you ID or whatever it happens to be

776
00:27:48,000 --> 00:27:50,100
but the components haven't been loaded

777
00:27:50,100 --> 00:27:52,350
and that's why it doesn't work so if you

778
00:27:52,350 --> 00:27:54,779
wait a little while and try again it

779
00:27:54,779 --> 00:27:56,140
will probably work

780
00:27:56,140 --> 00:27:59,800
except when it doesn't alright so you'll

781
00:27:59,800 --> 00:28:01,210
go deeper into this again I think all

782
00:28:01,210 --> 00:28:02,650
right so there's there's two components

783
00:28:02,650 --> 00:28:05,890
in the windows world standard API and

784
00:28:05,890 --> 00:28:08,680
proof now standard API also lives in all

785
00:28:08,680 --> 00:28:10,690
of the other mature four implementations

786
00:28:10,690 --> 00:28:12,640
but previous something that's specific

787
00:28:12,640 --> 00:28:14,350
to Windows because there's Windows

788
00:28:14,350 --> 00:28:16,240
specific privilege escalation and start

789
00:28:16,240 --> 00:28:17,830
stuff so the guts of the get system

790
00:28:17,830 --> 00:28:19,840
command which I'm hoping everyone loves

791
00:28:19,840 --> 00:28:24,220
lives inside proof so the guts when I

792
00:28:24,220 --> 00:28:25,480
say the guts I'm talking about the

793
00:28:25,480 --> 00:28:27,430
basics like Who am I where am i running

794
00:28:27,430 --> 00:28:30,790
file uploads file downloads back being

795
00:28:30,790 --> 00:28:32,800
able to open a channel just to send data

796
00:28:32,800 --> 00:28:34,330
back and forth that kind of stuff that's

797
00:28:34,330 --> 00:28:36,340
that's exactly what standard API gives

798
00:28:36,340 --> 00:28:39,640
us and so what happens in the Windows

799
00:28:39,640 --> 00:28:41,770
sense is we get our meterpreter session

800
00:28:41,770 --> 00:28:43,900
running and then Metasploit straightaway

801
00:28:43,900 --> 00:28:46,300
sends up a copy of standard api and then

802
00:28:46,300 --> 00:28:50,080
sends up a copy of proof now these two

803
00:28:50,080 --> 00:28:52,480
are officially extensions to meterpreter

804
00:28:52,480 --> 00:28:54,400
which you guys will go away and create

805
00:28:54,400 --> 00:28:58,060
your own I'm sure and so in order to do

806
00:28:58,060 --> 00:28:59,260
that you need to know a little bit about

807
00:28:59,260 --> 00:29:01,630
how it works so every extension needs to

808
00:29:01,630 --> 00:29:03,790
have this this table of commands that

809
00:29:03,790 --> 00:29:07,300
they support so here I mean he's

810
00:29:07,300 --> 00:29:10,150
familiar with railgun railguns awesome

811
00:29:10,150 --> 00:29:13,180
so railgun is pretty amazing but I won't

812
00:29:13,180 --> 00:29:14,800
dive into that now this is basically

813
00:29:14,800 --> 00:29:16,930
just saying I'm gonna take this identify

814
00:29:16,930 --> 00:29:19,030
this command and I'm gonna associate it

815
00:29:19,030 --> 00:29:21,520
with a function pointer and so what

816
00:29:21,520 --> 00:29:23,920
happens is when when the extensions

817
00:29:23,920 --> 00:29:27,220
loaded this function here gets invoked

818
00:29:27,220 --> 00:29:30,820
by Metz Earth and here we just call in

819
00:29:30,820 --> 00:29:32,680
command register all on that array of

820
00:29:32,680 --> 00:29:34,510
commands that we had so that's turning

821
00:29:34,510 --> 00:29:35,830
around to met servants saying here are

822
00:29:35,830 --> 00:29:37,300
all the commands that I currently

823
00:29:37,300 --> 00:29:39,970
support as my extension and it'll rip

824
00:29:39,970 --> 00:29:41,890
through that list wire in a bunch of

825
00:29:41,890 --> 00:29:43,300
function pointers and then effectively

826
00:29:43,300 --> 00:29:45,520
it's established and ready to go so then

827
00:29:45,520 --> 00:29:49,060
if you type in get UID that's when it'll

828
00:29:49,060 --> 00:29:51,040
be able to look up that identifier in

829
00:29:51,040 --> 00:29:53,410
the table and execute the function so

830
00:29:53,410 --> 00:29:54,580
that's why you can get a little bit of

831
00:29:54,580 --> 00:29:56,050
disconnect so it's pretty simple to get

832
00:29:56,050 --> 00:29:58,930
away it in right so going back to our

833
00:29:58,930 --> 00:30:01,360
exploitation scenario we've called back

834
00:30:01,360 --> 00:30:03,940
and down here the first thing we're

835
00:30:03,940 --> 00:30:05,170
going to do is send up a copy of net

836
00:30:05,170 --> 00:30:07,030
serve so we copied the binary over with

837
00:30:07,030 --> 00:30:09,160
a bit of passing and then it's

838
00:30:09,160 --> 00:30:09,910
reflectively

839
00:30:09,910 --> 00:30:11,740
loaded so that it actually becomes a

840
00:30:11,740 --> 00:30:13,750
valid P in memory and it's taking over

841
00:30:13,750 --> 00:30:15,490
communications and we sort of

842
00:30:15,490 --> 00:30:17,170
established and then from there standard

843
00:30:17,170 --> 00:30:19,990
API goes over reflectively loaded proof

844
00:30:19,990 --> 00:30:22,690
goes over reflectively loaded and then

845
00:30:22,690 --> 00:30:24,640
from there you're actually finally ready

846
00:30:24,640 --> 00:30:27,970
to go so from you can load incognito

847
00:30:27,970 --> 00:30:30,190
more more plugins than you can poke a

848
00:30:30,190 --> 00:30:33,160
stick at they have really really cool

849
00:30:33,160 --> 00:30:35,260
functionality in there as well so that

850
00:30:35,260 --> 00:30:37,660
that process for for loading is the same

851
00:30:37,660 --> 00:30:40,170
when you type in like use incognito

852
00:30:40,170 --> 00:30:42,820
pushes it up gets patched reflectively

853
00:30:42,820 --> 00:30:45,520
loaded commands get wired in bang off

854
00:30:45,520 --> 00:30:51,400
you go it makes sense all right are we

855
00:30:51,400 --> 00:30:51,760
there yet

856
00:30:51,760 --> 00:30:53,410
yes we're finally there you actually

857
00:30:53,410 --> 00:30:54,670
have a fully functional meterpreter

858
00:30:54,670 --> 00:30:57,340
session so now my job when I first

859
00:30:57,340 --> 00:30:58,630
started working on this for visa to

860
00:30:58,630 --> 00:31:01,240
understand that and recently someone

861
00:31:01,240 --> 00:31:02,950
submitted something sick reactions that

862
00:31:02,950 --> 00:31:04,270
really summed it up for me and it looks

863
00:31:04,270 --> 00:31:07,920
like this you guys seen this before

864
00:31:15,330 --> 00:31:20,140
all right so I've been doing this for

865
00:31:20,140 --> 00:31:21,250
nine months now and I still feel like

866
00:31:21,250 --> 00:31:22,899
dancing every time I see a session I've

867
00:31:22,899 --> 00:31:25,149
been is fantastic so like for us now

868
00:31:25,149 --> 00:31:27,190
when we when we talk you know exploit

869
00:31:27,190 --> 00:31:29,380
and off it goes there's actually a lot

870
00:31:29,380 --> 00:31:30,940
of magic that goes on behind the scenes

871
00:31:30,940 --> 00:31:34,149
so next next time you get shells I want

872
00:31:34,149 --> 00:31:38,620
you to sweet yeah I'm tempted to just

873
00:31:38,620 --> 00:31:39,909
leave this slide up for the rest of the

874
00:31:39,909 --> 00:31:42,039
talk because people think that I thought

875
00:31:42,039 --> 00:31:43,140
you're laughing at me when you're not

876
00:31:43,140 --> 00:31:45,519
alright so I'll put this back on at the

877
00:31:45,519 --> 00:31:49,450
end okay so you now you know how how

878
00:31:49,450 --> 00:31:51,309
much surfer actually gets into memory

879
00:31:51,309 --> 00:31:53,889
it's running you're kind of hopefully

880
00:31:53,889 --> 00:31:58,120
avoiding detection what I want to do now

881
00:31:58,120 --> 00:32:01,210
is dive into migration everyone's used

882
00:32:01,210 --> 00:32:04,450
migration right yeah so migration is a

883
00:32:04,450 --> 00:32:06,159
really fantastic thing and me as a dev

884
00:32:06,159 --> 00:32:08,260
he's only recently joined security was

885
00:32:08,260 --> 00:32:09,850
kind of blown away by the idea of this

886
00:32:09,850 --> 00:32:12,970
thing it's by far my favorite feature

887
00:32:12,970 --> 00:32:14,679
for what it does and it allows you to

888
00:32:14,679 --> 00:32:16,179
jump across process boundaries just

889
00:32:16,179 --> 00:32:18,010
really you know there's no other way of

890
00:32:18,010 --> 00:32:20,289
summing it up but the fact that it

891
00:32:20,289 --> 00:32:21,760
doesn't drop connectivity is the thing

892
00:32:21,760 --> 00:32:22,990
that really gets me I just think it's

893
00:32:22,990 --> 00:32:25,480
awesome so the good thing about this is

894
00:32:25,480 --> 00:32:26,559
like you might have popped someone's

895
00:32:26,559 --> 00:32:28,570
browser or some other buggy third party

896
00:32:28,570 --> 00:32:30,220
app which is unstable as a result of

897
00:32:30,220 --> 00:32:32,769
exploitation or for some other reason

898
00:32:32,769 --> 00:32:34,179
you just think you're living in a host

899
00:32:34,179 --> 00:32:35,860
process that isn't going to last very

900
00:32:35,860 --> 00:32:38,320
long last thing we want is for that user

901
00:32:38,320 --> 00:32:40,870
to shut that window down and kill off

902
00:32:40,870 --> 00:32:43,299
your meterpreter session so what we want

903
00:32:43,299 --> 00:32:45,279
to be able to do is is jump somewhere

904
00:32:45,279 --> 00:32:47,320
else without making the noise of setting

905
00:32:47,320 --> 00:32:48,820
up new connections and all that other

906
00:32:48,820 --> 00:32:51,130
stuff just so that if they do decide to

907
00:32:51,130 --> 00:32:52,600
shut it down it doesn't matter you'll

908
00:32:52,600 --> 00:32:54,190
still still got a bit of persistence on

909
00:32:54,190 --> 00:32:55,559
the box

910
00:32:55,559 --> 00:32:57,490
okay so we'll run through it a little

911
00:32:57,490 --> 00:32:59,980
bit again here's me just running the

912
00:32:59,980 --> 00:33:01,809
system info command so you can see I'm

913
00:33:01,809 --> 00:33:03,730
running on the same XP machine that I

914
00:33:03,730 --> 00:33:06,700
was running on before it's a win32

915
00:33:06,700 --> 00:33:11,789
instance I'm running as a pleb user and

916
00:33:11,789 --> 00:33:14,679
this is our process ID three five four

917
00:33:14,679 --> 00:33:16,809
eight just to prove that this is running

918
00:33:16,809 --> 00:33:18,580
under internet explorer you can see

919
00:33:18,580 --> 00:33:20,200
three five four eight here and it's

920
00:33:20,200 --> 00:33:21,460
internet explorer so I'm kind of

921
00:33:21,460 --> 00:33:23,230
simulating that I've popped someone's

922
00:33:23,230 --> 00:33:24,700
browser and they may actually close it

923
00:33:24,700 --> 00:33:25,850
or if they've been fish

924
00:33:25,850 --> 00:33:28,070
they might go where I probably shouldn't

925
00:33:28,070 --> 00:33:29,330
have clicked on that so I'm gonna close

926
00:33:29,330 --> 00:33:31,490
the browser now so what I'm going to be

927
00:33:31,490 --> 00:33:32,540
able to do is to move to something

928
00:33:32,540 --> 00:33:33,830
that's probably going to persist a

929
00:33:33,830 --> 00:33:35,090
little bit longer than Internet Explorer

930
00:33:35,090 --> 00:33:37,970
particularly ie6 and that is look for

931
00:33:37,970 --> 00:33:39,950
explorer.exe which is going to live for

932
00:33:39,950 --> 00:33:42,290
the life of the users logon session as

933
00:33:42,290 --> 00:33:47,660
you can see the processor ID is 18:20 so

934
00:33:47,660 --> 00:33:49,160
from there what I want to do is I type

935
00:33:49,160 --> 00:33:53,930
in migrate 1820 you sit there for

936
00:33:53,930 --> 00:33:55,520
another minute or so depending on how

937
00:33:55,520 --> 00:33:57,500
fast your connection is and at the end

938
00:33:57,500 --> 00:34:02,930
it just says this is why I didn't demo

939
00:34:02,930 --> 00:34:04,280
this because it's not really impressive

940
00:34:04,280 --> 00:34:08,150
demo is it but as you can see we have

941
00:34:08,150 --> 00:34:10,040
actually migrated our process ID is now

942
00:34:10,040 --> 00:34:13,429
1820 so I've used this so many times I'm

943
00:34:13,429 --> 00:34:15,440
hoping you guys have too but despite a

944
00:34:15,440 --> 00:34:17,780
little bit of little bit of time a lot

945
00:34:17,780 --> 00:34:19,010
of crafts going on behind the scenes

946
00:34:19,010 --> 00:34:20,270
which i think is really cool and that's

947
00:34:20,270 --> 00:34:22,760
when we show you so again we're gonna go

948
00:34:22,760 --> 00:34:26,389
deeper so this is the step or the number

949
00:34:26,389 --> 00:34:27,679
of steps that we go through when we're

950
00:34:27,679 --> 00:34:30,050
doing migration from the Metasploit side

951
00:34:30,050 --> 00:34:32,000
so I'm the Metasploit so when we type

952
00:34:32,000 --> 00:34:33,949
migrate the first thing we're gonna do

953
00:34:33,949 --> 00:34:37,639
is check for the basics am i migrating

954
00:34:37,639 --> 00:34:39,920
to myself is that's pretty stupid do we

955
00:34:39,920 --> 00:34:41,719
have permission to actually modify

956
00:34:41,719 --> 00:34:43,460
memory space of the target process

957
00:34:43,460 --> 00:34:45,080
because if we don't then we're not even

958
00:34:45,080 --> 00:34:46,940
going to attempt to do it we're gonna

959
00:34:46,940 --> 00:34:48,320
figure out what the target process

960
00:34:48,320 --> 00:34:50,780
architecture is cuz migration allows you

961
00:34:50,780 --> 00:34:54,530
to jump from 32 to 64 or 64 to 32 and a

962
00:34:54,530 --> 00:34:55,820
caters for all the different scenarios

963
00:34:55,820 --> 00:34:58,790
for you but in order to do that we need

964
00:34:58,790 --> 00:35:01,490
to know what we we're migrating to once

965
00:35:01,490 --> 00:35:03,440
we've done that we figure out or we

966
00:35:03,440 --> 00:35:05,810
generate a new payload that is specific

967
00:35:05,810 --> 00:35:07,370
to the architecture of the process that

968
00:35:07,370 --> 00:35:09,080
where we're going to jump to and that

969
00:35:09,080 --> 00:35:10,730
gets shipped up so that's why there's

970
00:35:10,730 --> 00:35:13,070
that little bit of time at start when

971
00:35:13,070 --> 00:35:15,050
you type migrate it's actually sending

972
00:35:15,050 --> 00:35:16,970
MIT serve up again and we have to do

973
00:35:16,970 --> 00:35:18,470
that because we can't sort of copy

974
00:35:18,470 --> 00:35:19,970
ourselves out of memory because we might

975
00:35:19,970 --> 00:35:21,590
be changing architectures those be

976
00:35:21,590 --> 00:35:24,350
jumping across process boundaries so

977
00:35:24,350 --> 00:35:26,180
once that's done we then send a command

978
00:35:26,180 --> 00:35:27,890
which contains you know the target

979
00:35:27,890 --> 00:35:30,170
architecture the idea of the process and

980
00:35:30,170 --> 00:35:32,300
the payload ship that up and then it's

981
00:35:32,300 --> 00:35:34,880
time for them to put it and take over on

982
00:35:34,880 --> 00:35:36,200
this side we sit here and we wait for

983
00:35:36,200 --> 00:35:37,670
Migration to finish we get a signal from

984
00:35:37,670 --> 00:35:38,520
interpreter

985
00:35:38,520 --> 00:35:40,050
and then we just carry on as we did

986
00:35:40,050 --> 00:35:42,000
before however the the interesting thing

987
00:35:42,000 --> 00:35:43,830
at the AMEX again I really like is it

988
00:35:43,830 --> 00:35:45,450
keeps track of all of the extensions

989
00:35:45,450 --> 00:35:47,520
that you had loaded prior to doing

990
00:35:47,520 --> 00:35:49,320
migration so if you were running packet

991
00:35:49,320 --> 00:35:51,720
sniffing or something like that it will

992
00:35:51,720 --> 00:35:53,250
push that extension out for you so you

993
00:35:53,250 --> 00:35:54,690
kind of your whole session just kind of

994
00:35:54,690 --> 00:35:56,580
shifts over it even carries over port

995
00:35:56,580 --> 00:35:57,810
forwards which i think is pretty nifty

996
00:35:57,810 --> 00:36:03,270
too so bit of code Ruby nothing really

997
00:36:03,270 --> 00:36:04,980
mind-blowing here we make sure that we

998
00:36:04,980 --> 00:36:06,540
attempt to open the process we've got a

999
00:36:06,540 --> 00:36:08,760
handle to a process object in Ruby and

1000
00:36:08,760 --> 00:36:09,990
the first thing we do is like did we get

1001
00:36:09,990 --> 00:36:11,580
one does it actually exist if not we

1002
00:36:11,580 --> 00:36:13,500
bomb out the next thing we check to see

1003
00:36:13,500 --> 00:36:15,300
if there's a little bit of a hack

1004
00:36:15,300 --> 00:36:18,090
because if the architecture flag of

1005
00:36:18,090 --> 00:36:20,580
value inside this dictionary doesn't

1006
00:36:20,580 --> 00:36:21,930
exist it means that we weren't able to

1007
00:36:21,930 --> 00:36:23,850
read metadata out of the process which

1008
00:36:23,850 --> 00:36:25,440
implies we don't have permission to do

1009
00:36:25,440 --> 00:36:27,119
what we need to do so that's what that's

1010
00:36:27,119 --> 00:36:29,940
doing and then finally we going is it me

1011
00:36:29,940 --> 00:36:32,910
whoops is it me and if it's me don't

1012
00:36:32,910 --> 00:36:34,530
don't migrate to me that's a pretty

1013
00:36:34,530 --> 00:36:36,930
stupid thing to do a little bit more

1014
00:36:36,930 --> 00:36:39,690
Ruby so what we're doing here is based

1015
00:36:39,690 --> 00:36:41,700
on the architecture we're figuring out a

1016
00:36:41,700 --> 00:36:43,940
new payload and we generate this little

1017
00:36:43,940 --> 00:36:46,740
class in memory that's able to sort of

1018
00:36:46,740 --> 00:36:49,260
produce a new bootloader and a new copy

1019
00:36:49,260 --> 00:36:51,450
of net serve that is going to function

1020
00:36:51,450 --> 00:36:54,510
inside the target process and when

1021
00:36:54,510 --> 00:36:56,910
that's done kind of instantiate it

1022
00:36:56,910 --> 00:36:58,320
because we you know how Ruby works right

1023
00:36:58,320 --> 00:37:00,480
it's it's Sam if it looks like a duck

1024
00:37:00,480 --> 00:37:03,440
and quacks like a duck it's a fish yeah

1025
00:37:03,440 --> 00:37:06,119
so we're kind of creating a hybrid fish

1026
00:37:06,119 --> 00:37:07,800
in memory before we create an instance

1027
00:37:07,800 --> 00:37:09,630
of it and then once we create an

1028
00:37:09,630 --> 00:37:11,010
instance of it we say you know use this

1029
00:37:11,010 --> 00:37:12,450
copy of net serve and then go and

1030
00:37:12,450 --> 00:37:14,520
generate a blob of binary so this stuff

1031
00:37:14,520 --> 00:37:16,320
down here is just a big blob of shell

1032
00:37:16,320 --> 00:37:20,880
code that's been patched ok finally yum

1033
00:37:20,880 --> 00:37:23,250
we're getting close now so what we need

1034
00:37:23,250 --> 00:37:25,020
to do when we create a request that's

1035
00:37:25,020 --> 00:37:26,250
going to be sent up to Metasploit

1036
00:37:26,250 --> 00:37:28,890
there's this packet object and there's a

1037
00:37:28,890 --> 00:37:30,330
create request function and the first

1038
00:37:30,330 --> 00:37:32,340
thing we give it is the identity of the

1039
00:37:32,340 --> 00:37:33,720
command that we want to run so this

1040
00:37:33,720 --> 00:37:35,160
could be a rail-dump thing it could be

1041
00:37:35,160 --> 00:37:36,750
my grade it could be could be anything

1042
00:37:36,750 --> 00:37:39,210
in this case obviously it's migrated so

1043
00:37:39,210 --> 00:37:40,530
we create an instance of this request

1044
00:37:40,530 --> 00:37:42,359
packet and then we need to wire in

1045
00:37:42,359 --> 00:37:44,369
values that are going to be sent up to

1046
00:37:44,369 --> 00:37:47,060
the target that's what these tlvs are

1047
00:37:47,060 --> 00:37:50,460
now took me like six months to figure

1048
00:37:50,460 --> 00:37:51,900
out what TLV actually

1049
00:37:51,900 --> 00:37:54,200
for so I'm gonna save you the pain and

1050
00:37:54,200 --> 00:37:57,359
I'm going to explain it by going a

1051
00:37:57,359 --> 00:38:00,119
little bit deeper so TR V stands for

1052
00:38:00,119 --> 00:38:02,339
type length and value although the first

1053
00:38:02,339 --> 00:38:03,749
part is a little bit misleading because

1054
00:38:03,749 --> 00:38:07,740
the type also contains the identity of

1055
00:38:07,740 --> 00:38:11,089
the value that we're pushing up so um

1056
00:38:11,089 --> 00:38:13,829
after that so that's a 32-bit value

1057
00:38:13,829 --> 00:38:16,049
regardless of what architecture that's a

1058
00:38:16,049 --> 00:38:17,730
32-bit value that it gets written to the

1059
00:38:17,730 --> 00:38:19,829
pac at first immediately after that

1060
00:38:19,829 --> 00:38:21,990
there is another 32-bit value that

1061
00:38:21,990 --> 00:38:24,599
specifies how long the data is that is

1062
00:38:24,599 --> 00:38:27,749
part of this TLV okay so in the case of

1063
00:38:27,749 --> 00:38:29,549
like if I'm sending up an integer that's

1064
00:38:29,549 --> 00:38:31,619
32 bits if I'm sending up a boolean it's

1065
00:38:31,619 --> 00:38:33,569
probably 32 bits again I mean if it's a

1066
00:38:33,569 --> 00:38:35,099
string then I'll calculate the length of

1067
00:38:35,099 --> 00:38:36,329
the string and that's what will get

1068
00:38:36,329 --> 00:38:37,559
written to the length and then

1069
00:38:37,559 --> 00:38:39,630
immediately after that the value is what

1070
00:38:39,630 --> 00:38:43,380
gets written and so the the packets that

1071
00:38:43,380 --> 00:38:44,789
get sent across the wire inside

1072
00:38:44,789 --> 00:38:46,799
meterpreter and Metasploit i literally

1073
00:38:46,799 --> 00:38:49,619
just a header followed by a TLV and then

1074
00:38:49,619 --> 00:38:51,480
the next TL B and then the next TL being

1075
00:38:51,480 --> 00:38:53,220
it's kind of like a simplest thing that

1076
00:38:53,220 --> 00:38:55,470
could possibly work you read four bytes

1077
00:38:55,470 --> 00:38:57,180
and you know it's type and identity you

1078
00:38:57,180 --> 00:38:58,349
read four bytes you know it's length

1079
00:38:58,349 --> 00:38:59,609
once you've got the length that's how

1080
00:38:59,609 --> 00:39:01,079
many bytes you read and then you're the

1081
00:39:01,079 --> 00:39:03,599
next TL v you rinse repeat it's pretty

1082
00:39:03,599 --> 00:39:06,299
much how you get the data round in the

1083
00:39:06,299 --> 00:39:07,680
case of migration this is what they're

1084
00:39:07,680 --> 00:39:09,420
defined as this isn't too interesting

1085
00:39:09,420 --> 00:39:11,069
other than I just wanted you to see how

1086
00:39:11,069 --> 00:39:14,849
an identity is made up of a type and a

1087
00:39:14,849 --> 00:39:17,700
unique number so when you guys are going

1088
00:39:17,700 --> 00:39:19,170
away and building your extensions you're

1089
00:39:19,170 --> 00:39:20,249
gonna have to go and create your own

1090
00:39:20,249 --> 00:39:22,049
ones of these and why other min so

1091
00:39:22,049 --> 00:39:23,190
that's why I think it's important for

1092
00:39:23,190 --> 00:39:25,829
you guys to see it so going back to Ruby

1093
00:39:25,829 --> 00:39:28,140
land this is where we were before once

1094
00:39:28,140 --> 00:39:30,809
we created this request packet we have

1095
00:39:30,809 --> 00:39:32,880
to do is go send it up to the client and

1096
00:39:32,880 --> 00:39:35,549
sit there and wait most of the time when

1097
00:39:35,549 --> 00:39:37,200
you see clients send requests you won't

1098
00:39:37,200 --> 00:39:38,549
see this extra parameter at the end

1099
00:39:38,549 --> 00:39:39,989
which is just an indication of how long

1100
00:39:39,989 --> 00:39:41,430
we want to wait for that command to

1101
00:39:41,430 --> 00:39:43,349
timeout and the reason why it's a bit

1102
00:39:43,349 --> 00:39:45,420
longer with migration is because we're

1103
00:39:45,420 --> 00:39:46,829
kind of establishing a whole new

1104
00:39:46,829 --> 00:39:48,269
meterpreter session and that could take

1105
00:39:48,269 --> 00:39:49,829
a little longer than what we would

1106
00:39:49,829 --> 00:39:53,819
expect excuse me so back into a

1107
00:39:53,819 --> 00:39:56,009
meterpreter world now we've got our

1108
00:39:56,009 --> 00:39:58,440
dispatcher thread sitting there it

1109
00:39:58,440 --> 00:40:01,950
receives this command what does it do so

1110
00:40:01,950 --> 00:40:03,329
the first thing it does is it reads all

1111
00:40:03,329 --> 00:40:05,240
of the TLV values out

1112
00:40:05,240 --> 00:40:07,220
and from there because we're actually

1113
00:40:07,220 --> 00:40:08,810
going to be going to be creating a

1114
00:40:08,810 --> 00:40:10,820
thread running in a separate process and

1115
00:40:10,820 --> 00:40:12,200
those two threads are all going to be

1116
00:40:12,200 --> 00:40:14,420
vying for control of the communications

1117
00:40:14,420 --> 00:40:16,010
on that single socket so we need a

1118
00:40:16,010 --> 00:40:17,570
synchronization primitive to make sure

1119
00:40:17,570 --> 00:40:19,160
that you know only one side is doing

1120
00:40:19,160 --> 00:40:20,930
things at once otherwise bad things

1121
00:40:20,930 --> 00:40:21,640
happen

1122
00:40:21,640 --> 00:40:25,820
so once that's in place we then prepare

1123
00:40:25,820 --> 00:40:27,260
some memory in the target process which

1124
00:40:27,260 --> 00:40:29,390
again is like rwx so that we can copy

1125
00:40:29,390 --> 00:40:32,060
things over and it cetera and then after

1126
00:40:32,060 --> 00:40:34,670
that the existing process kind of

1127
00:40:34,670 --> 00:40:36,530
relinquishes control for the other

1128
00:40:36,530 --> 00:40:38,390
process to take over and when that's

1129
00:40:38,390 --> 00:40:43,240
done it shuts itself down all right so

1130
00:40:43,240 --> 00:40:47,480
let's dive a little bit deeper again now

1131
00:40:47,480 --> 00:40:49,880
this migration context is just it's a

1132
00:40:49,880 --> 00:40:51,410
extra structure that contains a little

1133
00:40:51,410 --> 00:40:52,670
bit of metadata now if you can imagine

1134
00:40:52,670 --> 00:40:55,250
we've got information sitting inside our

1135
00:40:55,250 --> 00:40:57,050
current process we actually want to copy

1136
00:40:57,050 --> 00:40:59,030
some of that stuff over so the three

1137
00:40:59,030 --> 00:41:00,260
things that are really important to us

1138
00:41:00,260 --> 00:41:03,020
when we do this is the handle that we're

1139
00:41:03,020 --> 00:41:05,240
using for synchronization so obviously

1140
00:41:05,240 --> 00:41:06,920
you can you can share that handle and

1141
00:41:06,920 --> 00:41:09,920
you can do signaling there's the payload

1142
00:41:09,920 --> 00:41:11,540
the actual net serve thing itself

1143
00:41:11,540 --> 00:41:13,520
because without that obviously we're in

1144
00:41:13,520 --> 00:41:15,170
a bit of trouble and some information

1145
00:41:15,170 --> 00:41:17,750
about the socket that we're going to be

1146
00:41:17,750 --> 00:41:19,400
doing coms on I'll get into that in just

1147
00:41:19,400 --> 00:41:19,700
a minute

1148
00:41:19,700 --> 00:41:22,730
the thing that I think is really cool is

1149
00:41:22,730 --> 00:41:26,030
the the abuse of unions in this scenario

1150
00:41:26,030 --> 00:41:27,170
so for those people who aren't familiar

1151
00:41:27,170 --> 00:41:30,770
with C or C++ a union says all of the

1152
00:41:30,770 --> 00:41:32,690
variables inside this scope can share

1153
00:41:32,690 --> 00:41:35,180
exactly the same place in memory so this

1154
00:41:35,180 --> 00:41:36,890
is like C's equivalent of it can be a

1155
00:41:36,890 --> 00:41:38,390
duck and a fish at the same time

1156
00:41:38,390 --> 00:41:41,980
depending on which value so I could go

1157
00:41:41,980 --> 00:41:44,630
e8 event and it'll assume that it's a

1158
00:41:44,630 --> 00:41:46,970
handle or I could go a dot B padding and

1159
00:41:46,970 --> 00:41:47,930
it will assume that it's an array of

1160
00:41:47,930 --> 00:41:50,510
bytes now the reason we do this is

1161
00:41:50,510 --> 00:41:55,160
because we're going from 32 to 64 64 to

1162
00:41:55,160 --> 00:41:58,820
32 a handle is actually a pointer size

1163
00:41:58,820 --> 00:42:01,160
so in 32-bit land it's only four bytes

1164
00:42:01,160 --> 00:42:04,369
but in 64-bit land it's eight bytes so

1165
00:42:04,369 --> 00:42:06,200
if I send the context over there that is

1166
00:42:06,200 --> 00:42:07,970
only four bytes when it should be eight

1167
00:42:07,970 --> 00:42:10,090
we know this gets a little bit upset

1168
00:42:10,090 --> 00:42:12,410
same story with this pointer here to

1169
00:42:12,410 --> 00:42:14,060
memory so they what we're doing is we're

1170
00:42:14,060 --> 00:42:15,710
just effectively forcing it to always be

1171
00:42:15,710 --> 00:42:17,900
eight bytes so the regardless of the

1172
00:42:17,900 --> 00:42:18,760
direction we're going

1173
00:42:18,760 --> 00:42:20,410
the structure is the same size and

1174
00:42:20,410 --> 00:42:23,080
pointers actually makes sense yeah that

1175
00:42:23,080 --> 00:42:23,910
make sense

1176
00:42:23,910 --> 00:42:29,859
awesome okay so these the migration and

1177
00:42:29,859 --> 00:42:31,210
shutdown commands are a little bit

1178
00:42:31,210 --> 00:42:34,090
special in in meterpreter because they

1179
00:42:34,090 --> 00:42:35,800
needs to tell the server when to shut

1180
00:42:35,800 --> 00:42:38,080
down so when you've migrated and you say

1181
00:42:38,080 --> 00:42:39,820
please go and shut down nicely saying

1182
00:42:39,820 --> 00:42:41,619
with the typical shutdown command so

1183
00:42:41,619 --> 00:42:43,690
you'll see this is an inline request

1184
00:42:43,690 --> 00:42:45,250
which implies that we run it on the

1185
00:42:45,250 --> 00:42:46,960
dispatcher thread rather than kicking it

1186
00:42:46,960 --> 00:42:48,609
off into a different thread to run as

1187
00:42:48,609 --> 00:42:50,890
part of the server so that's how that's

1188
00:42:50,890 --> 00:42:54,040
defined now the header of this function

1189
00:42:54,040 --> 00:42:55,720
is not really that interesting except

1190
00:42:55,720 --> 00:42:57,940
for one thing now this packet here is

1191
00:42:57,940 --> 00:42:59,800
the structure that contains all of the

1192
00:42:59,800 --> 00:43:02,100
the TL visits what came across the wire

1193
00:43:02,100 --> 00:43:04,780
when this command was actually invoked

1194
00:43:04,780 --> 00:43:06,520
so all those TVs we poked in on the

1195
00:43:06,520 --> 00:43:08,140
Metasploit side will appear in this

1196
00:43:08,140 --> 00:43:14,260
packet these steps pretty simple stuff

1197
00:43:14,260 --> 00:43:15,430
right where we're just pulling out

1198
00:43:15,430 --> 00:43:16,960
values whoops we're pulling out values

1199
00:43:16,960 --> 00:43:20,470
from the TL these unfortunately see

1200
00:43:20,470 --> 00:43:22,450
doesn't quite have the nasty duck typing

1201
00:43:22,450 --> 00:43:24,250
features of Ruby and so we need to bake

1202
00:43:24,250 --> 00:43:25,720
the types into the function names

1203
00:43:25,720 --> 00:43:28,330
because we can't vary based on return

1204
00:43:28,330 --> 00:43:31,840
values okay so we have you int and and

1205
00:43:31,840 --> 00:43:33,700
boolean and string and all these other

1206
00:43:33,700 --> 00:43:34,960
bits and pieces but really all it's

1207
00:43:34,960 --> 00:43:36,700
doing is saying for this packet please

1208
00:43:36,700 --> 00:43:39,100
get whatever value that's associated

1209
00:43:39,100 --> 00:43:40,960
with this identifier which is in this

1210
00:43:40,960 --> 00:43:43,240
case a 32-bit number and we pull that

1211
00:43:43,240 --> 00:43:44,790
out and stash it in a local variable

1212
00:43:44,790 --> 00:43:47,109
same story with architecture and payload

1213
00:43:47,109 --> 00:43:49,450
length and the payload buffer itself so

1214
00:43:49,450 --> 00:43:50,770
now we've pulled all the data out of the

1215
00:43:50,770 --> 00:43:54,220
packet we can continue on so the first

1216
00:43:54,220 --> 00:43:55,060
thing we're going to do is we're going

1217
00:43:55,060 --> 00:43:57,040
to attempt to get a handle to the

1218
00:43:57,040 --> 00:43:58,180
process we're going to start migrating

1219
00:43:58,180 --> 00:44:00,220
to and in order to do that we actually

1220
00:44:00,220 --> 00:44:01,840
need a lot of permissions not just

1221
00:44:01,840 --> 00:44:03,460
read/write and bytes or other things so

1222
00:44:03,460 --> 00:44:05,290
this this massive bit mask here is

1223
00:44:05,290 --> 00:44:07,119
saying these are all the things that I

1224
00:44:07,119 --> 00:44:09,369
know I'm gonna need if I can't get any

1225
00:44:09,369 --> 00:44:11,470
of them I'm not going to attempt to

1226
00:44:11,470 --> 00:44:14,200
continue so-called open process with the

1227
00:44:14,200 --> 00:44:16,030
process identifier we pulled out of the

1228
00:44:16,030 --> 00:44:19,260
TLB and if that didn't work we bomb out

1229
00:44:19,260 --> 00:44:21,760
now the next thing is kind of specific

1230
00:44:21,760 --> 00:44:25,060
to TCP payloads only because in HTTP and

1231
00:44:25,060 --> 00:44:26,800
HTTPS the whole idea of sort of

1232
00:44:26,800 --> 00:44:28,540
relinquishing cons is pretty simple

1233
00:44:28,540 --> 00:44:30,130
right one just stops and the other one

1234
00:44:30,130 --> 00:44:32,130
starts polling via HTTP

1235
00:44:32,130 --> 00:44:34,020
and there's no synchronization required

1236
00:44:34,020 --> 00:44:36,840
but in the case of TCP when we were

1237
00:44:36,840 --> 00:44:38,850
using the socket again we actually want

1238
00:44:38,850 --> 00:44:42,900
to duplicate the socket information now

1239
00:44:42,900 --> 00:44:45,300
I see this context dot info value here

1240
00:44:45,300 --> 00:44:47,640
this is an instance of that migration

1241
00:44:47,640 --> 00:44:49,140
context we were looking at before and

1242
00:44:49,140 --> 00:44:51,990
the dot info is just a blob of space

1243
00:44:51,990 --> 00:44:53,580
inside that context that's going to

1244
00:44:53,580 --> 00:44:56,580
contain just socket metadata so what we

1245
00:44:56,580 --> 00:44:57,930
do when we migrate we're going to copy

1246
00:44:57,930 --> 00:44:59,490
this whole thing over and we can then

1247
00:44:59,490 --> 00:45:01,260
create a socket in the other process

1248
00:45:01,260 --> 00:45:03,600
based on that metadata and we kind of

1249
00:45:03,600 --> 00:45:05,340
share socket coms across the two

1250
00:45:05,340 --> 00:45:08,450
processes so that's what this is doing

1251
00:45:08,450 --> 00:45:10,740
from there this this isn't very

1252
00:45:10,740 --> 00:45:12,090
interesting either but creating events

1253
00:45:12,090 --> 00:45:13,860
we're creating basically just a handle

1254
00:45:13,860 --> 00:45:16,050
that we can signal on so that across

1255
00:45:16,050 --> 00:45:19,320
processes were able to communicate but

1256
00:45:19,320 --> 00:45:21,390
what we need to be able to do is we

1257
00:45:21,390 --> 00:45:25,410
specify we create a duplicate handle for

1258
00:45:25,410 --> 00:45:27,660
this thing and here you'll see I got

1259
00:45:27,660 --> 00:45:30,120
something in there no I don't these

1260
00:45:30,120 --> 00:45:32,100
first two parameters here are saying I

1261
00:45:32,100 --> 00:45:34,650
want to take this event that is

1262
00:45:34,650 --> 00:45:36,000
currently associated with this process

1263
00:45:36,000 --> 00:45:38,880
and I want to create a handle that works

1264
00:45:38,880 --> 00:45:41,370
inside this process and store it in here

1265
00:45:41,370 --> 00:45:43,830
so straightaway we're taking a copy of

1266
00:45:43,830 --> 00:45:45,780
what we've got in that current world and

1267
00:45:45,780 --> 00:45:46,830
we're putting in a place where we're

1268
00:45:46,830 --> 00:45:48,030
going to copy it over to the next

1269
00:45:48,030 --> 00:45:53,580
process so from here we check to see

1270
00:45:53,580 --> 00:45:55,110
which architecture we're migrating to

1271
00:45:55,110 --> 00:45:57,360
I'm focusing again on 32-bit but it

1272
00:45:57,360 --> 00:46:00,570
could be 64 and baked in is a blob of

1273
00:46:00,570 --> 00:46:02,250
shell code that will kind of handle the

1274
00:46:02,250 --> 00:46:04,130
case when we're actually kicking off

1275
00:46:04,130 --> 00:46:06,120
migration which we are going to dive

1276
00:46:06,120 --> 00:46:08,780
into in just a minute

1277
00:46:08,780 --> 00:46:12,530
next thing we're allocating memory as

1278
00:46:12,530 --> 00:46:15,210
interesting questions around why Windows

1279
00:46:15,210 --> 00:46:17,040
even creates API is that let you do this

1280
00:46:17,040 --> 00:46:19,350
it's like it wants you to do nasty

1281
00:46:19,350 --> 00:46:21,330
things so you can not only open process

1282
00:46:21,330 --> 00:46:23,040
you can write you can allocate memory

1283
00:46:23,040 --> 00:46:25,020
and target processes you can you can

1284
00:46:25,020 --> 00:46:26,880
write data to those processes you can

1285
00:46:26,880 --> 00:46:28,530
kick off threads in those processes so

1286
00:46:28,530 --> 00:46:31,470
why would you want to do that it's

1287
00:46:31,470 --> 00:46:32,970
probably good use cases and it certainly

1288
00:46:32,970 --> 00:46:35,430
works for us so anyway we allocate some

1289
00:46:35,430 --> 00:46:37,260
memory and then we do a little

1290
00:46:37,260 --> 00:46:39,570
calculation that says okay we've

1291
00:46:39,570 --> 00:46:41,670
allocated memory here you'll see four

1292
00:46:41,670 --> 00:46:44,010
three things the size of the migration

1293
00:46:44,010 --> 00:46:45,280
stub which we're going to look at

1294
00:46:45,280 --> 00:46:46,990
just a minute the size of the migrate

1295
00:46:46,990 --> 00:46:48,910
context which has those two unions and

1296
00:46:48,910 --> 00:46:51,610
the socket internet and then the length

1297
00:46:51,610 --> 00:46:53,560
of the pelo so we've got this big block

1298
00:46:53,560 --> 00:46:55,180
of contiguous memory that we know we can

1299
00:46:55,180 --> 00:46:57,880
write all of these things to and here

1300
00:46:57,880 --> 00:47:00,070
the calculation we're doing is we're

1301
00:47:00,070 --> 00:47:01,660
just figuring out where inside this

1302
00:47:01,660 --> 00:47:03,700
block of memory we are going to write

1303
00:47:03,700 --> 00:47:06,100
the Met serve payload to because later

1304
00:47:06,100 --> 00:47:07,710
on we're going to need to invoke that

1305
00:47:07,710 --> 00:47:10,120
okay

1306
00:47:10,120 --> 00:47:12,430
the next step is we're all going to do

1307
00:47:12,430 --> 00:47:13,990
is we're going to write each individual

1308
00:47:13,990 --> 00:47:16,300
component to the appropriate location so

1309
00:47:16,300 --> 00:47:18,100
to start with we write the migration

1310
00:47:18,100 --> 00:47:19,840
stub first at the start of the memory

1311
00:47:19,840 --> 00:47:21,760
address and then after that we skip that

1312
00:47:21,760 --> 00:47:24,580
and write the migration context and then

1313
00:47:24,580 --> 00:47:26,230
finally we write the actual payload

1314
00:47:26,230 --> 00:47:29,530
itself so that's all sitting in memory

1315
00:47:29,530 --> 00:47:32,650
now or ready to go and what we need to

1316
00:47:32,650 --> 00:47:35,920
be able to do is create a thread now

1317
00:47:35,920 --> 00:47:38,190
this kind of sounds simple but

1318
00:47:38,190 --> 00:47:42,660
unfortunately it's not this function in

1319
00:47:42,660 --> 00:47:45,640
inject via remote thread what it tries

1320
00:47:45,640 --> 00:47:49,720
to do is it'll start by hitting a

1321
00:47:49,720 --> 00:47:51,610
function called create create remote

1322
00:47:51,610 --> 00:47:53,560
thread and that does exist on some

1323
00:47:53,560 --> 00:47:55,840
versions of Windows and not on others it

1324
00:47:55,840 --> 00:47:58,020
exists on some versions but doesn't work

1325
00:47:58,020 --> 00:48:00,970
so behind the scenes here we try a

1326
00:48:00,970 --> 00:48:02,410
number of different ways in which to

1327
00:48:02,410 --> 00:48:03,820
create a remote thread and if none of

1328
00:48:03,820 --> 00:48:06,220
those work which does happen on say

1329
00:48:06,220 --> 00:48:08,650
Windows 2003 we drop through to this

1330
00:48:08,650 --> 00:48:10,690
thing called a PC thread and this is

1331
00:48:10,690 --> 00:48:13,060
actually hijacking threads rather than

1332
00:48:13,060 --> 00:48:15,520
creating new ones so what it does is it

1333
00:48:15,520 --> 00:48:16,960
iterates through all of the threads that

1334
00:48:16,960 --> 00:48:18,580
are running inside that process and it

1335
00:48:18,580 --> 00:48:20,710
suspends them and then based on some

1336
00:48:20,710 --> 00:48:22,570
pretty basic sort of heuristics it'll

1337
00:48:22,570 --> 00:48:24,010
say I'm going to pick this thread and

1338
00:48:24,010 --> 00:48:26,020
I'm going to take its context and

1339
00:48:26,020 --> 00:48:27,580
overwrite it with information that

1340
00:48:27,580 --> 00:48:29,470
points to me instead of where it was

1341
00:48:29,470 --> 00:48:31,570
before and then we'll just resume every

1342
00:48:31,570 --> 00:48:32,830
thread in the process and hope it

1343
00:48:32,830 --> 00:48:35,260
doesn't die so we can't create a new

1344
00:48:35,260 --> 00:48:36,670
thread but we'll take one that's already

1345
00:48:36,670 --> 00:48:38,860
there and use it for our own purposes so

1346
00:48:38,860 --> 00:48:40,690
that's what the AP a PC thread technique

1347
00:48:40,690 --> 00:48:42,100
is and I'm not going to dive deeper into

1348
00:48:42,100 --> 00:48:43,540
that because I know I don't really have

1349
00:48:43,540 --> 00:48:47,260
that much time but the two things are

1350
00:48:47,260 --> 00:48:48,880
important to note here is that each one

1351
00:48:48,880 --> 00:48:50,770
of these takes two parameters first

1352
00:48:50,770 --> 00:48:52,600
being the pointer to the allocated block

1353
00:48:52,600 --> 00:48:53,980
of memory where we've put all of this

1354
00:48:53,980 --> 00:48:57,520
stuff and the second is a location from

1355
00:48:57,520 --> 00:48:58,390
that

1356
00:48:58,390 --> 00:48:59,619
which points to the start of the

1357
00:48:59,619 --> 00:49:01,510
migration context because that is

1358
00:49:01,510 --> 00:49:03,910
required when we're actually executing

1359
00:49:03,910 --> 00:49:08,079
our migrate bootstrapper okay so once

1360
00:49:08,079 --> 00:49:09,039
that's in place and we've actually

1361
00:49:09,039 --> 00:49:10,690
created a thread the create the thread

1362
00:49:10,690 --> 00:49:12,789
is actually created resumed and and it

1363
00:49:12,789 --> 00:49:14,440
is i--sorry suspended and it is then

1364
00:49:14,440 --> 00:49:18,609
resumed so we're gonna go into the

1365
00:49:18,609 --> 00:49:20,049
migration stub I'm not going to show you

1366
00:49:20,049 --> 00:49:22,089
the 64-bit version because that's I

1367
00:49:22,089 --> 00:49:24,970
don't really know how it works but the

1368
00:49:24,970 --> 00:49:29,500
32-bit version looks like this let me

1369
00:49:29,500 --> 00:49:32,829
know when you're finished yeah yeah oh

1370
00:49:32,829 --> 00:49:35,230
good all right yeah maybe I'm telling

1371
00:49:35,230 --> 00:49:36,789
you a little bit okay this is what it

1372
00:49:36,789 --> 00:49:39,039
actually looks like in source form which

1373
00:49:39,039 --> 00:49:41,680
is much better right assembly all of a

1374
00:49:41,680 --> 00:49:43,480
sudden looks really nice compared to the

1375
00:49:43,480 --> 00:49:45,690
thing that we're looking at alright so

1376
00:49:45,690 --> 00:49:47,859
this is this might look a little scary

1377
00:49:47,859 --> 00:49:50,319
but it's really not first thing that

1378
00:49:50,319 --> 00:49:52,869
we're doing is so when you call a

1379
00:49:52,869 --> 00:49:54,849
function right function parameters go on

1380
00:49:54,849 --> 00:49:57,700
the stack so when this is called as per

1381
00:49:57,700 --> 00:50:00,339
normal functionality the stack plus four

1382
00:50:00,339 --> 00:50:02,049
bytes is actually where the migration

1383
00:50:02,049 --> 00:50:04,329
context is so we take that value and we

1384
00:50:04,329 --> 00:50:06,220
stick it in ESI so that we have a base

1385
00:50:06,220 --> 00:50:08,559
location that we can sort of offset from

1386
00:50:08,559 --> 00:50:10,269
to pull out the values like where the

1387
00:50:10,269 --> 00:50:12,130
payload lives where the event handles

1388
00:50:12,130 --> 00:50:14,019
are and all the other side okay so

1389
00:50:14,019 --> 00:50:17,769
that's what we do first we then kind of

1390
00:50:17,769 --> 00:50:22,990
do a little jump from here to here and

1391
00:50:22,990 --> 00:50:24,400
to do the reason we're doing that is

1392
00:50:24,400 --> 00:50:25,809
because we're leaping over the top of

1393
00:50:25,809 --> 00:50:27,819
this block ap I think the other thing

1394
00:50:27,819 --> 00:50:29,200
that I mentioned before the Stevens you

1395
00:50:29,200 --> 00:50:30,730
are creating now this this blob of

1396
00:50:30,730 --> 00:50:32,319
assembly which again I can't go into

1397
00:50:32,319 --> 00:50:34,779
base on time is something that does all

1398
00:50:34,779 --> 00:50:36,970
that magic hashing stuff that we saw

1399
00:50:36,970 --> 00:50:39,700
when we did reflective DLL injection but

1400
00:50:39,700 --> 00:50:41,859
what it does is it allows us to say I

1401
00:50:41,859 --> 00:50:44,950
want to on these parameters to be passed

1402
00:50:44,950 --> 00:50:48,190
to a function here's the the hash of the

1403
00:50:48,190 --> 00:50:50,079
function go and call it and the block

1404
00:50:50,079 --> 00:50:52,000
API will go on find the function

1405
00:50:52,000 --> 00:50:55,390
wherever it is in memory and and invoke

1406
00:50:55,390 --> 00:50:57,160
it and when it's invoked control will

1407
00:50:57,160 --> 00:50:58,720
return immediately back to where you

1408
00:50:58,720 --> 00:51:00,279
call it from just like a normal function

1409
00:51:00,279 --> 00:51:03,279
courts genius should go and read it if

1410
00:51:03,279 --> 00:51:07,180
you're looking to to deal with sleeping

1411
00:51:07,180 --> 00:51:07,980
issues

1412
00:51:07,980 --> 00:51:09,990
okay so here's an example of that cool

1413
00:51:09,990 --> 00:51:13,109
you see pop EVP the reason why it's

1414
00:51:13,109 --> 00:51:14,850
doing that is like the enjoy the return

1415
00:51:14,850 --> 00:51:17,340
address from making this call is the

1416
00:51:17,340 --> 00:51:19,380
first instruction to the block API right

1417
00:51:19,380 --> 00:51:21,150
so that's the entry point to the block

1418
00:51:21,150 --> 00:51:23,580
API functionality and so we pop that

1419
00:51:23,580 --> 00:51:25,590
into EBP and that becomes our our

1420
00:51:25,590 --> 00:51:27,030
reference point for being able to call

1421
00:51:27,030 --> 00:51:30,300
block API so here what we're doing is

1422
00:51:30,300 --> 00:51:32,550
we're pushing a string onto the stack

1423
00:51:32,550 --> 00:51:36,090
that it contains ws 232 which is the

1424
00:51:36,090 --> 00:51:37,920
windsock library so effectively the

1425
00:51:37,920 --> 00:51:40,109
Windows socket functionality push that

1426
00:51:40,109 --> 00:51:41,670
onto the stack and then a pointer to

1427
00:51:41,670 --> 00:51:43,800
that onto the stack and then we ask

1428
00:51:43,800 --> 00:51:48,540
block API to call load library inside

1429
00:51:48,540 --> 00:51:51,240
kernel32 and that's what this hash is so

1430
00:51:51,240 --> 00:51:53,550
pass that in block API we'll go and

1431
00:51:53,550 --> 00:51:55,619
figure out which function and which

1432
00:51:55,619 --> 00:51:58,710
module matches that hash that will then

1433
00:51:58,710 --> 00:52:00,630
call the function for you so that's a

1434
00:52:00,630 --> 00:52:01,890
really cheap way of saying can you

1435
00:52:01,890 --> 00:52:03,600
please go and load the Windows socket

1436
00:52:03,600 --> 00:52:07,859
library for me immediately after that we

1437
00:52:07,859 --> 00:52:09,480
need to initialize the socket

1438
00:52:09,480 --> 00:52:11,280
functionality and it's correctly cuz in

1439
00:52:11,280 --> 00:52:13,230
in Windows you can initialize sockets

1440
00:52:13,230 --> 00:52:15,180
twice and the process is happy and given

1441
00:52:15,180 --> 00:52:16,740
that we may have migrated to something

1442
00:52:16,740 --> 00:52:18,270
that hasn't touched the network for any

1443
00:52:18,270 --> 00:52:20,520
reason we need to initialize it just in

1444
00:52:20,520 --> 00:52:21,840
case it hasn't been done before again

1445
00:52:21,840 --> 00:52:26,340
otherwise bad things would happen okay

1446
00:52:26,340 --> 00:52:28,170
what do we go here so this is the last

1447
00:52:28,170 --> 00:52:30,150
part of the block of assembly that I'm

1448
00:52:30,150 --> 00:52:32,790
going to show you this bit here is is

1449
00:52:32,790 --> 00:52:36,720
creating a call to the socket func w SI

1450
00:52:36,720 --> 00:52:39,270
saket w SI saket allows us to create

1451
00:52:39,270 --> 00:52:41,190
socket handles and here that really the

1452
00:52:41,190 --> 00:52:44,850
key thing to note is this offset from

1453
00:52:44,850 --> 00:52:47,730
psi is a pointer to the socket metadata

1454
00:52:47,730 --> 00:52:49,830
that we copied from our existing process

1455
00:52:49,830 --> 00:52:51,750
so here we're saying go and create me a

1456
00:52:51,750 --> 00:52:53,790
valid socket handle based on this

1457
00:52:53,790 --> 00:52:56,070
metadata and from this point we now have

1458
00:52:56,070 --> 00:52:57,450
a functioning socket handle in which to

1459
00:52:57,450 --> 00:53:00,480
view communications so this is when we

1460
00:53:00,480 --> 00:53:04,320
say we'll stash the socket in EDI EDI is

1461
00:53:04,320 --> 00:53:06,119
like the magic socket register so if

1462
00:53:06,119 --> 00:53:06,900
you're gonna go and create your own

1463
00:53:06,900 --> 00:53:09,000
stages or any other bits and pieces that

1464
00:53:09,000 --> 00:53:10,890
kind of resemble this you need to put

1465
00:53:10,890 --> 00:53:12,900
socket handles inside EDI prior to

1466
00:53:12,900 --> 00:53:15,000
kicking off anything that a separator

1467
00:53:15,000 --> 00:53:19,740
related so once we've done this we we

1468
00:53:19,740 --> 00:53:21,910
take a reference to

1469
00:53:21,910 --> 00:53:24,339
the event handle it was also part of our

1470
00:53:24,339 --> 00:53:25,599
migrate contacts that's right at the

1471
00:53:25,599 --> 00:53:27,699
start of the migrate context and then we

1472
00:53:27,699 --> 00:53:30,880
call set event so on the existing

1473
00:53:30,880 --> 00:53:32,380
meterpreter that's running it's sitting

1474
00:53:32,380 --> 00:53:33,849
there and it's waiting on that socket

1475
00:53:33,849 --> 00:53:35,739
handle for a signal and that's exactly

1476
00:53:35,739 --> 00:53:37,180
what this is doing it's saying okay

1477
00:53:37,180 --> 00:53:39,789
we've pretty much set up I'm executing

1478
00:53:39,789 --> 00:53:41,559
I've created my socket everything's

1479
00:53:41,559 --> 00:53:44,799
initialized you can now shut down and so

1480
00:53:44,799 --> 00:53:48,489
at this point at this point the other

1481
00:53:48,489 --> 00:53:50,519
meterpreter is now shutting down and

1482
00:53:50,519 --> 00:53:53,499
here all we're going to do is invoke the

1483
00:53:53,499 --> 00:53:56,019
payload so yes I plus 8 which is 8 bytes

1484
00:53:56,019 --> 00:53:58,479
past the event handle start of the

1485
00:53:58,479 --> 00:54:00,489
payload off you go

1486
00:54:00,489 --> 00:54:04,119
so this point this is when migration

1487
00:54:04,119 --> 00:54:06,819
actually completes because the ID I stub

1488
00:54:06,819 --> 00:54:08,890
is invoked little bootstrapper is

1489
00:54:08,890 --> 00:54:11,680
invokes MS service reflectively loaded

1490
00:54:11,680 --> 00:54:13,959
standard API goes up proof goes up

1491
00:54:13,959 --> 00:54:15,699
Metasploit and pushes up all the

1492
00:54:15,699 --> 00:54:17,049
extensions that you already had loaded

1493
00:54:17,049 --> 00:54:19,779
pushes the port forwards over just like

1494
00:54:19,779 --> 00:54:21,819
I said before and we're basically back

1495
00:54:21,819 --> 00:54:23,349
to where we started but living in

1496
00:54:23,349 --> 00:54:26,579
another process so that wasn't too scary

1497
00:54:26,579 --> 00:54:29,979
okay all right now I don't know how much

1498
00:54:29,979 --> 00:54:31,989
time I've got left I think I'm pretty

1499
00:54:31,989 --> 00:54:33,699
much bang on but here's the obligatory

1500
00:54:33,699 --> 00:54:36,339
links slide so you can find the source

1501
00:54:36,339 --> 00:54:39,369
of meterpreter on github it's not that

1502
00:54:39,369 --> 00:54:39,880
scary

1503
00:54:39,880 --> 00:54:41,859
I promise you it's really not that scary

1504
00:54:41,859 --> 00:54:44,709
except for the Java version don't don't

1505
00:54:44,709 --> 00:54:46,959
go and play with the Java version so

1506
00:54:46,959 --> 00:54:48,609
that I don't have to that would be

1507
00:54:48,609 --> 00:54:50,739
really good Metasploit framework is in a

1508
00:54:50,739 --> 00:54:52,890
similar location buffered i/o is my blog

1509
00:54:52,890 --> 00:54:55,449
Metasploit on freenode is a really good

1510
00:54:55,449 --> 00:54:56,979
place to go if you want to get stuck

1511
00:54:56,979 --> 00:54:59,559
into this stuff rapid7

1512
00:54:59,559 --> 00:55:00,699
I've got to pimp them because they're a

1513
00:55:00,699 --> 00:55:02,680
great bunch of people I had a really

1514
00:55:02,680 --> 00:55:03,759
good time working with them though I

1515
00:55:03,759 --> 00:55:05,920
don't work for them so I'm not I'm not

1516
00:55:05,920 --> 00:55:07,690
getting any cash or anything for it and

1517
00:55:07,690 --> 00:55:09,219
beyond binary is is my company in

1518
00:55:09,219 --> 00:55:12,699
Australia so I'm look forward to your

1519
00:55:12,699 --> 00:55:15,190
pull requests you feel gutsy enough to

1520
00:55:15,190 --> 00:55:17,499
do them and that's it there's there any

1521
00:55:17,499 --> 00:55:19,859
questions

1522
00:55:21,890 --> 00:55:26,580
No all right so yeah so you're gonna

1523
00:55:26,580 --> 00:55:27,720
just go away inside

1524
00:55:27,720 --> 00:55:34,399
[Applause]

