1
00:00:00,000 --> 00:00:02,029
Oh

2
00:00:04,290 --> 00:00:09,219
alright welcome to an intro to glib C

3
00:00:07,450 --> 00:00:11,860
heap exploitation my name is Max and

4
00:00:09,220 --> 00:00:14,349
it's my quest to convince people that

5
00:00:11,860 --> 00:00:16,689
Linux heap exploitation isn't a

6
00:00:14,349 --> 00:00:19,420
difficult as it seems if you haven't

7
00:00:16,690 --> 00:00:22,600
done so already please exercise poor

8
00:00:19,420 --> 00:00:23,980
cyber hygiene by plugging B sticks into

9
00:00:22,600 --> 00:00:27,160
your laptop does anybody need one of

10
00:00:23,980 --> 00:00:28,450
these stick your hand up just this

11
00:00:27,160 --> 00:00:35,320
gentleman over here can someone pass him

12
00:00:28,450 --> 00:00:36,609
a spare one if not go catch boot up full

13
00:00:35,320 --> 00:00:38,140
screen there should be a VM on there

14
00:00:36,609 --> 00:00:40,329
sorry should work without the VirtualBox

15
00:00:38,140 --> 00:00:42,730
with VMware boot up full screen it sort

16
00:00:40,329 --> 00:00:43,989
out the resolution etc they should log

17
00:00:42,730 --> 00:00:46,659
in automatically but if they're not

18
00:00:43,989 --> 00:00:48,940
playing the game username is heap lab

19
00:00:46,659 --> 00:00:51,550
one word all lowercase and the password

20
00:00:48,940 --> 00:00:52,870
is also heap lab one word lowercase so

21
00:00:51,550 --> 00:00:56,968
if they mess you around just use that

22
00:00:52,870 --> 00:00:56,968
and you can su do or all you like

23
00:01:01,979 --> 00:01:05,710
alright so once you guys saw that stuff

24
00:01:04,390 --> 00:01:08,619
out I'll give you a brief description

25
00:01:05,710 --> 00:01:11,169
what we're doing here today so for those

26
00:01:08,619 --> 00:01:13,560
who are unfamiliar with it Lib C or G

27
00:01:11,170 --> 00:01:16,060
Lib C stands for the good new C library

28
00:01:13,560 --> 00:01:19,869
it's a shared object of Linux equivalent

29
00:01:16,060 --> 00:01:22,570
of a DLL just like any other it's also a

30
00:01:19,869 --> 00:01:24,579
fundamental part any Linux operating

31
00:01:22,570 --> 00:01:27,788
systems both desktop and embedded

32
00:01:24,579 --> 00:01:31,740
including distros like ubuntu debian and

33
00:01:27,789 --> 00:01:34,060
arch linux to name a few and simply put

34
00:01:31,740 --> 00:01:35,740
on your average Linux distro that

35
00:01:34,060 --> 00:01:38,500
doesn't use a Lib C alternative like

36
00:01:35,740 --> 00:01:42,839
muscle to find a process that doesn't

37
00:01:38,500 --> 00:01:42,840
map the glib C shared object into memory

38
00:01:42,990 --> 00:01:48,100
an old Lib C actually does is provide

39
00:01:46,659 --> 00:01:51,159
some boilerplate code functions like

40
00:01:48,100 --> 00:01:54,189
memory and printf to programs written in

41
00:01:51,159 --> 00:01:56,049
c and c++ and by extension some of the

42
00:01:54,189 --> 00:02:02,520
higher-level languages like python whose

43
00:01:56,049 --> 00:02:05,649
interpreters now glib see also provides

44
00:02:02,520 --> 00:02:07,149
dynamic memory allocator known as malloc

45
00:02:05,649 --> 00:02:09,220
dynamic memory allocator is used when a

46
00:02:07,149 --> 00:02:11,440
program can't know the size or number of

47
00:02:09,220 --> 00:02:15,489
objects in these try to run time a

48
00:02:11,440 --> 00:02:16,630
Malik's job shall so-called chunks of

49
00:02:15,489 --> 00:02:19,930
that dynamic memory

50
00:02:16,630 --> 00:02:21,910
two processes at runtime and those

51
00:02:19,930 --> 00:02:25,450
chunks come from large contiguous blocks

52
00:02:21,910 --> 00:02:28,990
of memory known as heat if you've ever

53
00:02:25,450 --> 00:02:31,929
dealt in Si chances are you've used

54
00:02:28,990 --> 00:02:33,910
malloc little more abstracted than new

55
00:02:31,930 --> 00:02:36,400
and delete operators are thin wrappers

56
00:02:33,910 --> 00:02:39,400
around malloc as are by extension make

57
00:02:36,400 --> 00:02:42,640
shared and make unique even if your code

58
00:02:39,400 --> 00:02:44,050
doesn't explicitly invoke malloc chances

59
00:02:42,640 --> 00:02:47,230
are one of the library functions you're

60
00:02:44,050 --> 00:02:47,710
using does start the new threads open in

61
00:02:47,230 --> 00:02:49,690
a file

62
00:02:47,710 --> 00:02:52,630
dealing with i/o all use malloc under

63
00:02:49,690 --> 00:02:55,600
the hood so the fact that malloc is so

64
00:02:52,630 --> 00:02:57,269
widely used combined with the fact that

65
00:02:55,600 --> 00:02:59,799
it's used in languages like C and C++

66
00:02:57,270 --> 00:03:02,170
for which memory corruption is still an

67
00:02:59,800 --> 00:03:04,630
issue both make a great target for

68
00:03:02,170 --> 00:03:07,480
exploitation and that's what we're doing

69
00:03:04,630 --> 00:03:09,070
here today we're going to learn to heap

70
00:03:07,480 --> 00:03:11,109
exploitation techniques the first called

71
00:03:09,070 --> 00:03:13,660
the house of force and the second known

72
00:03:11,110 --> 00:03:15,460
as a fast spin doop our tools in the

73
00:03:13,660 --> 00:03:16,840
trade of the good new debugger gdb

74
00:03:15,460 --> 00:03:19,030
enhanced with a Python library called

75
00:03:16,840 --> 00:03:20,770
pwned bag and help us interact with the

76
00:03:19,030 --> 00:03:22,930
vulnerable binaries will be exploited

77
00:03:20,770 --> 00:03:24,730
later a second Python library called

78
00:03:22,930 --> 00:03:27,130
pwned tools I'm sure a lot of you are

79
00:03:24,730 --> 00:03:29,530
familiar with so if everybody's

80
00:03:27,130 --> 00:03:31,329
comfortable what we doing will dive

81
00:03:29,530 --> 00:03:33,100
straight in and those of you have just

82
00:03:31,330 --> 00:03:34,840
arrived if you can grab a USB stick off

83
00:03:33,100 --> 00:03:41,799
or someone else should be able to import

84
00:03:34,840 --> 00:03:49,960
the VM did you need a USB setting or you

85
00:03:41,800 --> 00:03:53,830
go on so malloc itself is just a

86
00:03:49,960 --> 00:03:55,750
collection of functions and metadata for

87
00:03:53,830 --> 00:03:59,080
the purpose of dishing out those chunks

88
00:03:55,750 --> 00:04:00,220
a heap memory to processes and today

89
00:03:59,080 --> 00:04:02,650
we're concerned with two of my log

90
00:04:00,220 --> 00:04:05,310
functions malloc itself for requesting

91
00:04:02,650 --> 00:04:08,080
heap memory and free for recycle in it

92
00:04:05,310 --> 00:04:09,940
yes is a little bit confusing to have a

93
00:04:08,080 --> 00:04:11,410
function called malloc used to request

94
00:04:09,940 --> 00:04:15,010
heap memory from the dynamic memory

95
00:04:11,410 --> 00:04:17,108
allocator also called malloc but at

96
00:04:15,010 --> 00:04:19,420
least it's a simple function it takes a

97
00:04:17,108 --> 00:04:21,729
single argument the size in bytes of

98
00:04:19,420 --> 00:04:23,440
memory that you want and it returns a

99
00:04:21,730 --> 00:04:26,260
pointer to that amount of memory or

100
00:04:23,440 --> 00:04:28,290
slightly more for you to do is as you

101
00:04:26,260 --> 00:04:30,360
wish

102
00:04:28,290 --> 00:04:32,430
and to help us visualize how heat memory

103
00:04:30,360 --> 00:04:36,180
is requested to our malloc we're going

104
00:04:32,430 --> 00:04:38,490
to debug a small demo binary so switch

105
00:04:36,180 --> 00:04:42,540
fire to your VMs hopefully you've all

106
00:04:38,490 --> 00:04:45,300
got one running and open a terminal and

107
00:04:42,540 --> 00:04:47,910
navigate to the house of force directory

108
00:04:45,300 --> 00:04:48,600
in which you'll see a couple of binaries

109
00:04:47,910 --> 00:04:57,180
and scripts

110
00:04:48,600 --> 00:05:00,560
she looks there with can you read out

111
00:04:57,180 --> 00:05:02,340
the back is all right awesome

112
00:05:00,560 --> 00:05:03,510
so you should be able to see a couple of

113
00:05:02,340 --> 00:05:06,900
binaries and scripts in there we're

114
00:05:03,510 --> 00:05:11,070
going to debug the demo binary under gdb

115
00:05:06,900 --> 00:05:12,479
with the command once you've done that

116
00:05:11,070 --> 00:05:15,150
we're going to set a breakpoint on the

117
00:05:12,480 --> 00:05:18,900
main function with break main or just B

118
00:05:15,150 --> 00:05:26,729
main and then we're gonna run the binary

119
00:05:18,900 --> 00:05:28,109
with run or just our can you read what's

120
00:05:26,730 --> 00:05:30,660
in the bottom left there or is that

121
00:05:28,110 --> 00:05:32,510
still covered up by the lectern all

122
00:05:30,660 --> 00:05:34,890
right close enough

123
00:05:32,510 --> 00:05:36,810
what kind of poem bag so if you've used

124
00:05:34,890 --> 00:05:39,479
other gdb enhancement Suites you should

125
00:05:36,810 --> 00:05:41,580
be right at home and there's a lot going

126
00:05:39,480 --> 00:05:43,860
on the screen but all we're concerned

127
00:05:41,580 --> 00:05:45,840
with today is the source panel about

128
00:05:43,860 --> 00:05:47,310
third from the bottom in which we can

129
00:05:45,840 --> 00:05:49,020
see that all this program does is

130
00:05:47,310 --> 00:05:52,650
request heap memory with the malloc

131
00:05:49,020 --> 00:05:54,900
function a bunch of times starting with

132
00:05:52,650 --> 00:05:57,239
this request for 9 bytes just an

133
00:05:54,900 --> 00:06:00,780
arbitrary number and it will save the

134
00:05:57,240 --> 00:06:02,130
return value in a variable called a so

135
00:06:00,780 --> 00:06:04,799
before we let it do that we're going to

136
00:06:02,130 --> 00:06:07,500
introspect the heap with the command VM

137
00:06:04,800 --> 00:06:10,050
map that's going to print a virtual

138
00:06:07,500 --> 00:06:11,280
memory map of this process and we can

139
00:06:10,050 --> 00:06:13,770
see from the legend at the top that the

140
00:06:11,280 --> 00:06:16,559
heap should be colored in blue but

141
00:06:13,770 --> 00:06:18,690
there's no blue text in this output

142
00:06:16,560 --> 00:06:20,220
that's because malloc won't request heat

143
00:06:18,690 --> 00:06:22,050
memory from the kernel until it's

144
00:06:20,220 --> 00:06:24,930
actually required so we're going to use

145
00:06:22,050 --> 00:06:27,240
the next command to execute that next

146
00:06:24,930 --> 00:06:29,400
line of code and now we've executed that

147
00:06:27,240 --> 00:06:32,360
first request to malloc for 9 bytes if

148
00:06:29,400 --> 00:06:34,710
we follow that up with a VM map command

149
00:06:32,360 --> 00:06:37,800
we can see that now we have a heap and

150
00:06:34,710 --> 00:06:40,979
address hex 400 500 whoa and that heap

151
00:06:37,800 --> 00:06:41,760
is hex to 1 triple 0 bytes long about

152
00:06:40,980 --> 00:06:44,790
135

153
00:06:41,760 --> 00:06:46,860
five thousand bytes now we're going to

154
00:06:44,790 --> 00:06:48,720
introspect that heat memory with the VIS

155
00:06:46,860 --> 00:06:58,560
heap chunks command which you can

156
00:06:48,720 --> 00:07:00,000
shorten to this in fact and I'll do my

157
00:06:58,560 --> 00:07:03,060
best to explain what we're seeing here

158
00:07:00,000 --> 00:07:04,650
that region colored yellow is the chunk

159
00:07:03,060 --> 00:07:06,630
returned from that first request to

160
00:07:04,650 --> 00:07:10,260
malloc from 9 bytes and we can confirm

161
00:07:06,630 --> 00:07:11,820
this with print a or just a p.a to check

162
00:07:10,260 --> 00:07:14,099
out what the return value was the

163
00:07:11,820 --> 00:07:15,570
address hex 405 o1o which is this

164
00:07:14,100 --> 00:07:17,870
address here wanting to the first

165
00:07:15,570 --> 00:07:19,680
quadword of user data that this chunk

166
00:07:17,870 --> 00:07:23,820
first thing you'll notice is that we've

167
00:07:19,680 --> 00:07:25,770
got more than 9 bytes 3 quad words at 24

168
00:07:23,820 --> 00:07:29,520
bytes to be precise turns out that

169
00:07:25,770 --> 00:07:33,060
system size mark will give you if we use

170
00:07:29,520 --> 00:07:38,539
next again to request just one bite from

171
00:07:33,060 --> 00:07:41,400
malloc or time to request 0 from Mallik

172
00:07:38,540 --> 00:07:43,260
this shows us that both times we've got

173
00:07:41,400 --> 00:07:48,000
the same sized chunk with 24 bytes of

174
00:07:43,260 --> 00:07:50,250
user data so minimum size chunk you

175
00:07:48,000 --> 00:07:55,290
might also be wondering what this value

176
00:07:50,250 --> 00:07:58,400
here is now malloc data which means that

177
00:07:55,290 --> 00:08:01,440
much like some stack metadata such as

178
00:07:58,400 --> 00:08:03,169
shared but say base pointers and return

179
00:08:01,440 --> 00:08:05,520
addresses are stored on the stack itself

180
00:08:03,170 --> 00:08:08,460
malloc stores some of its Hebe metadata

181
00:08:05,520 --> 00:08:10,500
on the heap in this case a size field

182
00:08:08,460 --> 00:08:12,299
every chunk has a size field and

183
00:08:10,500 --> 00:08:15,480
indicates the sum total of bytes that

184
00:08:12,300 --> 00:08:18,300
make up that chunk including the size

185
00:08:15,480 --> 00:08:21,860
field itself so in this case 24 bytes

186
00:08:18,300 --> 00:08:26,670
plus 8 for the size field is hex to 0

187
00:08:21,860 --> 00:08:29,130
but we're seeing hex to one reason for

188
00:08:26,670 --> 00:08:32,909
that is the malloc chunk sizes increase

189
00:08:29,130 --> 00:08:35,130
in increments of 16 bytes so for example

190
00:08:32,909 --> 00:08:38,579
if we use the next command to request

191
00:08:35,130 --> 00:08:42,689
exactly 24 bytes of user data this shows

192
00:08:38,580 --> 00:08:45,330
us that we get a chunk size of hex t1

193
00:08:42,690 --> 00:08:49,620
with 24 bytes of user data however if we

194
00:08:45,330 --> 00:08:51,450
use next again to request 25 bytes this

195
00:08:49,620 --> 00:08:54,300
shows us that we get the next chunk size

196
00:08:51,450 --> 00:08:55,080
up hex 3-0 with 40 bytes of user data

197
00:08:54,300 --> 00:08:57,060
and that

198
00:08:55,080 --> 00:09:00,240
is the low-order nibble of every chunk

199
00:08:57,060 --> 00:09:02,400
size field isn't used for isn't used to

200
00:09:00,240 --> 00:09:04,410
indicate size and that leaves it free to

201
00:09:02,400 --> 00:09:07,530
indicate flags in this case the least

202
00:09:04,410 --> 00:09:09,510
significant bit is set indicating the

203
00:09:07,530 --> 00:09:12,839
Previn use flag simply meaning that the

204
00:09:09,510 --> 00:09:14,569
previous chunk is in use previous chunk

205
00:09:12,840 --> 00:09:18,570
being the adjacent chunk in lower memory

206
00:09:14,570 --> 00:09:20,190
since all of these chunks are in use we

207
00:09:18,570 --> 00:09:24,360
have the Previn OU's bit set in all the

208
00:09:20,190 --> 00:09:26,550
chunks we've requested you might also be

209
00:09:24,360 --> 00:09:29,400
wondering why this first chunk didn't

210
00:09:26,550 --> 00:09:31,109
start at the beginning of the heap well

211
00:09:29,400 --> 00:09:33,150
from Malik's perspective it does from

212
00:09:31,110 --> 00:09:40,290
Malik's perspective all chunk starts 16

213
00:09:33,150 --> 00:09:42,090
bytes prior to their user data and it

214
00:09:40,290 --> 00:09:46,020
turns out that chunk shapes at least

215
00:09:42,090 --> 00:09:48,090
when viewed like this are variable so I

216
00:09:46,020 --> 00:09:49,290
may depend on for example the size of

217
00:09:48,090 --> 00:09:50,430
the chunk the size of the previous chunk

218
00:09:49,290 --> 00:09:52,140
and whether either or both of those

219
00:09:50,430 --> 00:09:53,939
chunks are free in fact in the Malik's

220
00:09:52,140 --> 00:09:57,840
sauce alongside the chunk struct

221
00:09:53,940 --> 00:10:01,110
definition oak struct definition is

222
00:09:57,840 --> 00:10:03,080
misleading fortunately for us we're only

223
00:10:01,110 --> 00:10:05,910
going to deal with this sort of offset

224
00:10:03,080 --> 00:10:08,880
chunk shape today not having to have to

225
00:10:05,910 --> 00:10:10,230
concern ourselves with that lastly I'm

226
00:10:08,880 --> 00:10:14,280
gonna draw your attention to this region

227
00:10:10,230 --> 00:10:15,720
here labeled the top chunk now you

228
00:10:14,280 --> 00:10:18,780
recall from the output of our VM map

229
00:10:15,720 --> 00:10:22,080
command that this heap is about 135,000

230
00:10:18,780 --> 00:10:25,140
but we're only see 100 or so of those

231
00:10:22,080 --> 00:10:27,480
bytes here and malloc treats that

232
00:10:25,140 --> 00:10:30,150
remaining as yet unused heap memory as a

233
00:10:27,480 --> 00:10:32,340
single large chunk it calls the top

234
00:10:30,150 --> 00:10:33,090
chunk and every time we've requested

235
00:10:32,340 --> 00:10:34,860
heat mem

236
00:10:33,090 --> 00:10:37,050
it's broken off a piece of that top

237
00:10:34,860 --> 00:10:45,000
chunk and giving it to us and the top

238
00:10:37,050 --> 00:10:49,530
chunk shrinks is exhausted and to keep

239
00:10:45,000 --> 00:10:56,730
track of how it gets a size field as

240
00:10:49,530 --> 00:11:01,500
well this value here and isn't subject

241
00:10:56,730 --> 00:11:02,970
to any integrity checks the basis of the

242
00:11:01,500 --> 00:11:05,490
house of force

243
00:11:02,970 --> 00:11:08,190
so with that in mind close your debug it

244
00:11:05,490 --> 00:11:10,350
with quit or control-d and then we're

245
00:11:08,190 --> 00:11:14,790
gonna run the house of force vulnerable

246
00:11:10,350 --> 00:11:23,220
binary it's a small CTF style binary

247
00:11:14,790 --> 00:11:26,760
written in C it's got a he bug to make

248
00:11:23,220 --> 00:11:28,050
an arbitrary write so run the binary I

249
00:11:26,760 --> 00:11:30,420
have a mess have a play around with it

250
00:11:28,050 --> 00:11:32,160
run it in gdb if you fancy see if you

251
00:11:30,420 --> 00:11:44,699
can find the bug and in the meantime

252
00:11:32,160 --> 00:11:54,209
I'll explain what's going on I'm gonna

253
00:11:44,700 --> 00:11:55,740
run mine under G so the first thing is

254
00:11:54,210 --> 00:11:58,290
binary does after printing out that

255
00:11:55,740 --> 00:11:59,670
little splash screen is it leaks a lip

256
00:11:58,290 --> 00:12:01,530
see in a heap address now the house of

257
00:11:59,670 --> 00:12:04,800
forced technique doesn't necessarily

258
00:12:01,530 --> 00:12:06,569
require either of these and indeed you

259
00:12:04,800 --> 00:12:10,589
can use heap corruption to leak both

260
00:12:06,570 --> 00:12:12,120
heap and Lib C addresses today we're

261
00:12:10,590 --> 00:12:13,740
gonna let the binary do it for us so

262
00:12:12,120 --> 00:12:17,520
that we can focus on the technique at

263
00:12:13,740 --> 00:12:19,500
hand below that is a small numbered menu

264
00:12:17,520 --> 00:12:22,350
option one allows us to request chunks

265
00:12:19,500 --> 00:12:24,090
by a mullah so option one will request

266
00:12:22,350 --> 00:12:26,730
the chunk and then we can send it size

267
00:12:24,090 --> 00:12:30,210
and then we can write some data to it as

268
00:12:26,730 --> 00:12:31,620
well if I control C to break in gdb and

269
00:12:30,210 --> 00:12:33,030
use the VIS command like we would do in

270
00:12:31,620 --> 00:12:36,210
a moment ago we can see that I've

271
00:12:33,030 --> 00:12:39,569
requested a minimum sized chunk and now

272
00:12:36,210 --> 00:12:48,000
I've written some capital wise to its

273
00:12:39,570 --> 00:12:50,970
user data option to prints a target now

274
00:12:48,000 --> 00:12:52,200
our objective is to leverage the House

275
00:12:50,970 --> 00:12:54,180
of force technique to overwrite the

276
00:12:52,200 --> 00:12:56,220
target which is a short string capital

277
00:12:54,180 --> 00:12:58,109
X's that resides in the data section of

278
00:12:56,220 --> 00:13:00,360
this binary this binary is non pick

279
00:12:58,110 --> 00:13:05,400
which means we know its address now I

280
00:13:00,360 --> 00:13:07,170
know overwriting strings use the house

281
00:13:05,400 --> 00:13:09,500
of force to make an arbitrary write

282
00:13:07,170 --> 00:13:11,900
which is a very powerful primitive

283
00:13:09,500 --> 00:13:14,670
without having to dig into all sorts of

284
00:13:11,900 --> 00:13:16,769
peripheral exploit development stuff if

285
00:13:14,670 --> 00:13:19,878
you do variants you can drop

286
00:13:16,769 --> 00:13:19,879
she´ll on this binary that's what the

287
00:13:21,170 --> 00:13:31,199
and then drop a shell on it in the

288
00:13:25,619 --> 00:13:32,819
meantime has anybody found a bug all

289
00:13:31,199 --> 00:13:39,389
right well I can tell you that there is

290
00:13:32,819 --> 00:13:43,319
an overflow on the heap I'm using this

291
00:13:39,389 --> 00:13:45,420
one we can just make this one up if you

292
00:13:43,319 --> 00:13:47,729
fancy that oh sorry guys I didn't

293
00:13:45,420 --> 00:13:53,579
realize that Mike was dying on me my bad

294
00:13:47,730 --> 00:13:55,589
oh all right I'll just talk louder and

295
00:13:53,579 --> 00:13:59,128
shout through the microphone okay so

296
00:13:55,589 --> 00:14:01,019
there isn't per when we were when we can

297
00:13:59,129 --> 00:14:02,489
when we write data to these chunks so

298
00:14:01,019 --> 00:14:04,769
for example if I request another chunk

299
00:14:02,489 --> 00:14:06,329
of minimum size any value between 0 and

300
00:14:04,769 --> 00:14:09,569
24 as we've seen will get me a minimum

301
00:14:06,329 --> 00:14:11,309
sized chunk and then I fill it with a

302
00:14:09,569 --> 00:14:13,279
bunch of capital wise because while at

303
00:14:11,309 --> 00:14:15,569
the capital a is have all the fun

304
00:14:13,279 --> 00:14:18,179
breaking with control C and then this

305
00:14:15,569 --> 00:14:22,049
shows us that that second chunk I

306
00:14:18,179 --> 00:14:24,389
requested was allocated here I filled up

307
00:14:22,049 --> 00:14:27,799
those 24 bytes of user data with my

308
00:14:24,389 --> 00:14:30,839
Capital y input how's the microphone and

309
00:14:27,799 --> 00:14:33,149
then the last eight bytes my input ended

310
00:14:30,839 --> 00:14:34,529
up overflowing and overwriting the top

311
00:14:33,149 --> 00:14:37,139
chunk size field which another said

312
00:14:34,529 --> 00:14:38,819
isn't subject to integrity checks and is

313
00:14:37,139 --> 00:14:43,290
an integral part of the house of force

314
00:14:38,819 --> 00:14:45,509
technique so now that we can corrupt the

315
00:14:43,290 --> 00:14:48,389
top chunk size field with this overflow

316
00:14:45,509 --> 00:14:49,980
bug in our binary what are we going to

317
00:14:48,389 --> 00:14:52,019
do with it it's a size field so we can

318
00:14:49,980 --> 00:14:56,509
either make it a very small value or a

319
00:14:52,019 --> 00:14:56,509
very large value any suggestions

320
00:15:09,350 --> 00:15:13,439
interesting idea and in fact shrinking

321
00:15:11,819 --> 00:15:16,019
or increasing the size of the top chunk

322
00:15:13,439 --> 00:15:17,849
is a valid part of different heap

323
00:15:16,019 --> 00:15:19,769
exploitation techniques however the

324
00:15:17,850 --> 00:15:21,660
house of force requires that we make the

325
00:15:19,769 --> 00:15:24,389
top chunk a large value and we're gonna

326
00:15:21,660 --> 00:15:27,660
make it the largest value and I'll

327
00:15:24,389 --> 00:15:29,220
explain why in a moment in the meantime

328
00:15:27,660 --> 00:15:30,050
we're gonna script what we've achieved

329
00:15:29,220 --> 00:15:31,550
here

330
00:15:30,050 --> 00:15:33,920
that we can make it repeatable and we

331
00:15:31,550 --> 00:15:37,069
can do things like send non-printing

332
00:15:33,920 --> 00:15:38,660
characters and do a little math so close

333
00:15:37,070 --> 00:15:41,209
the binary or any debugging sessions you

334
00:15:38,660 --> 00:15:43,550
have open and make a copy of the poem

335
00:15:41,209 --> 00:15:46,430
tools templates script I'm going to call

336
00:15:43,550 --> 00:15:48,349
mine xpl dot pi short for exploit pi you

337
00:15:46,430 --> 00:15:51,290
can call yours what you want except

338
00:15:48,350 --> 00:15:53,329
Honan dot pi it's very tempting to call

339
00:15:51,290 --> 00:15:55,370
it Pope I don't do that first thing

340
00:15:53,329 --> 00:15:56,660
these scripts do is from pone import

341
00:15:55,370 --> 00:15:58,910
star meaning it will try and import

342
00:15:56,660 --> 00:15:59,600
itself and the universe will implode so

343
00:15:58,910 --> 00:16:01,699
I'm told

344
00:15:59,600 --> 00:16:04,490
once you made a copy of the poems

345
00:16:01,700 --> 00:16:06,740
template script open it up in your

346
00:16:04,490 --> 00:16:09,170
editor of choice you have a choice

347
00:16:06,740 --> 00:16:12,079
between atom available from the command

348
00:16:09,170 --> 00:16:14,899
available from the taskbar at the bottom

349
00:16:12,079 --> 00:16:16,760
the green icon or vim on the command

350
00:16:14,899 --> 00:16:20,690
line if you fancy I'm going to use vim

351
00:16:16,760 --> 00:16:22,880
and this is the start of our first cone

352
00:16:20,690 --> 00:16:24,350
tool script pontiff is an awesome little

353
00:16:22,880 --> 00:16:25,519
framework written by Zack Tribble it's

354
00:16:24,350 --> 00:16:27,589
going to allow us to do some rapid

355
00:16:25,519 --> 00:16:29,329
exploit development in this case one's

356
00:16:27,589 --> 00:16:32,329
going to do is run the binary send it

357
00:16:29,329 --> 00:16:34,420
some input deal with some math that

358
00:16:32,329 --> 00:16:37,339
we're gonna do on the output etc etc now

359
00:16:34,420 --> 00:16:39,349
there's a lot going on but most of this

360
00:16:37,339 --> 00:16:40,490
is poems boilerplate and some wrapper

361
00:16:39,350 --> 00:16:42,260
functions that I've put together to

362
00:16:40,490 --> 00:16:43,339
avoid this becoming too much of an

363
00:16:42,260 --> 00:16:45,560
exercise in Python

364
00:16:43,339 --> 00:16:48,950
fear not we're only gonna write three

365
00:16:45,560 --> 00:16:50,599
lines of Python to pone this binary so

366
00:16:48,950 --> 00:16:52,040
if you scroll down to the bottom we're

367
00:16:50,600 --> 00:16:54,079
only concerned with what's between these

368
00:16:52,040 --> 00:16:55,610
dashed lines which right now is some

369
00:16:54,079 --> 00:16:59,870
example text which we're going to delete

370
00:16:55,610 --> 00:17:02,360
in a moment so that heap leak has been

371
00:16:59,870 --> 00:17:05,780
captured in a variable called heap and

372
00:17:02,360 --> 00:17:07,970
we use that shortly symbols in the

373
00:17:05,780 --> 00:17:10,790
binary are available with elf sim dot

374
00:17:07,970 --> 00:17:13,880
symbol name so elf dhalsim dot target is

375
00:17:10,790 --> 00:17:15,139
going to be useful to us and there's a

376
00:17:13,880 --> 00:17:16,819
malloc wrapper function that I've

377
00:17:15,140 --> 00:17:18,559
written that will be the equivalent of

378
00:17:16,819 --> 00:17:20,270
sending a 1 to the binary to pick the

379
00:17:18,559 --> 00:17:23,449
malloc option and then its first

380
00:17:20,270 --> 00:17:25,069
argument will be the size and then the

381
00:17:23,449 --> 00:17:27,410
second argument will be the data that we

382
00:17:25,069 --> 00:17:29,149
want to send it lastly there's a delta

383
00:17:27,410 --> 00:17:32,179
wrapper function that we'll get to

384
00:17:29,150 --> 00:17:35,000
shortly so I want you guys to delete all

385
00:17:32,179 --> 00:17:37,100
of that I'm going to start by using the

386
00:17:35,000 --> 00:17:38,630
malloc wrapper function to emulate what

387
00:17:37,100 --> 00:17:40,790
I just did in gdb

388
00:17:38,630 --> 00:17:44,020
so we're going to request a minimum size

389
00:17:40,790 --> 00:17:45,490
chunk I'm going to request 24 bytes

390
00:17:44,020 --> 00:17:46,990
so that I just it's a nice little

391
00:17:45,490 --> 00:17:50,530
reminder for me that we're gonna get

392
00:17:46,990 --> 00:17:56,710
exactly 24 bytes of user data Oh bear

393
00:17:50,530 --> 00:17:57,210
with me I have a u.s. keyboard there we

394
00:17:56,710 --> 00:18:01,030
go

395
00:17:57,210 --> 00:18:04,000
and then following on from that we're

396
00:18:01,030 --> 00:18:06,280
going to send 24 bytes of garbage that

397
00:18:04,000 --> 00:18:08,260
should fill up the user data of that

398
00:18:06,280 --> 00:18:09,910
chunk we could request the larger chunk

399
00:18:08,260 --> 00:18:11,440
than a201 but we might as well keep

400
00:18:09,910 --> 00:18:13,780
things compact for now and that way we

401
00:18:11,440 --> 00:18:15,280
have to send less data now anything

402
00:18:13,780 --> 00:18:18,210
after this of course is going to

403
00:18:15,280 --> 00:18:21,490
overflow into the top chunk size field

404
00:18:18,210 --> 00:18:23,890
so we want to send a large value and in

405
00:18:21,490 --> 00:18:28,390
fact we'll send the largest value 64 bit

406
00:18:23,890 --> 00:18:38,320
all the one bit sir so 16 F F F F F F F

407
00:18:28,390 --> 00:18:39,910
F F F F F F F F F F and of course we

408
00:18:38,320 --> 00:18:41,649
can't concatenate strings with integers

409
00:18:39,910 --> 00:18:45,690
in Python so we're gonna wrap all those

410
00:18:41,650 --> 00:18:48,130
x FS in a core to the P 64 function

411
00:18:45,690 --> 00:18:50,590
piece exported poem to us function short

412
00:18:48,130 --> 00:18:52,630
for pack 64 allows us to pack an integer

413
00:18:50,590 --> 00:18:53,889
as a string and deal with stuff like nd

414
00:18:52,630 --> 00:18:56,950
in this that way we don't have to tie

415
00:18:53,890 --> 00:18:58,510
with a bunch of backslash X's in and we

416
00:18:56,950 --> 00:19:00,930
can deal with in this case it's not

417
00:18:58,510 --> 00:19:04,960
important but endianness when we send

418
00:19:00,930 --> 00:19:07,300
addresses and all that good stuff so if

419
00:19:04,960 --> 00:19:08,650
everybody's got that line down we're

420
00:19:07,300 --> 00:19:09,879
gonna run this script if you're using

421
00:19:08,650 --> 00:19:11,680
Atem there might be a way to run your

422
00:19:09,880 --> 00:19:13,060
scripts I'm not sure there's also a leaf

423
00:19:11,680 --> 00:19:15,250
pad I think if you're some sort of

424
00:19:13,060 --> 00:19:17,770
psychopath in the case of vim you can

425
00:19:15,250 --> 00:19:19,810
use the dot at the bank / percent

426
00:19:17,770 --> 00:19:23,379
command to run this script otherwise

427
00:19:19,810 --> 00:19:24,909
just run it on the command line and what

428
00:19:23,380 --> 00:19:28,300
Potence is going to do hopefully you

429
00:19:24,910 --> 00:19:29,530
guys can see that is run our binary send

430
00:19:28,300 --> 00:19:31,450
the input and then drop us into an

431
00:19:29,530 --> 00:19:33,639
interactive shell with it so we can mash

432
00:19:31,450 --> 00:19:35,680
enter and we'll get the menu printed out

433
00:19:33,640 --> 00:19:38,470
we can see that our script has requested

434
00:19:35,680 --> 00:19:41,200
one minimum size chunk for us well hm

435
00:19:38,470 --> 00:19:43,440
but that's all you can see that's not

436
00:19:41,200 --> 00:19:43,440
particularly

437
00:19:45,010 --> 00:19:53,260
oh sorry yes yeah okay so that's some

438
00:19:51,670 --> 00:19:56,230
pone two of stuff that it's printing out

439
00:19:53,260 --> 00:19:57,610
as it reads in the binary as it reads in

440
00:19:56,230 --> 00:20:03,880
the Lib C version all that good stuff

441
00:19:57,610 --> 00:20:05,649
oh I'm so sorry yeah you can just do it

442
00:20:03,880 --> 00:20:10,800
on the command line so from vim like I

443
00:20:05,650 --> 00:20:14,380
say bang tops laughs % like show that

444
00:20:10,800 --> 00:20:16,780
you got it yeah bang dot slash % is in

445
00:20:14,380 --> 00:20:19,630
like bang do a command dot slash this

446
00:20:16,780 --> 00:20:22,780
directory % in vim is the name of this

447
00:20:19,630 --> 00:20:23,860
script otherwise just dot slash in the

448
00:20:22,780 --> 00:20:28,920
name of your script on the command line

449
00:20:23,860 --> 00:20:31,209
everyone happy with that awesome

450
00:20:28,920 --> 00:20:34,360
so now drop us back into an interactive

451
00:20:31,210 --> 00:20:36,070
shell we can put the target but this

452
00:20:34,360 --> 00:20:37,899
isn't particularly useful so what we're

453
00:20:36,070 --> 00:20:41,139
gonna do is close that and then this

454
00:20:37,900 --> 00:20:42,430
time we're gonna run and in fact what I

455
00:20:41,140 --> 00:20:44,980
might do is just run this stuff from the

456
00:20:42,430 --> 00:20:49,210
command line so you guys can see run

457
00:20:44,980 --> 00:20:50,710
scripts with the gdb option in capitals

458
00:20:49,210 --> 00:20:54,760
capital is important so it's a name your

459
00:20:50,710 --> 00:20:56,470
script space gdb like this that's gonna

460
00:20:54,760 --> 00:20:58,270
do exactly the same thing it's gonna run

461
00:20:56,470 --> 00:21:00,130
the binary but it's going to attach a

462
00:20:58,270 --> 00:21:01,750
gdb debugging session in the meantime

463
00:21:00,130 --> 00:21:06,250
and then it's going to send our input

464
00:21:01,750 --> 00:21:10,420
and we can alt tab or option tab on Mac

465
00:21:06,250 --> 00:21:14,260
between the binary and the debugger so

466
00:21:10,420 --> 00:21:17,740
ctrl C is break in gdb and then we're

467
00:21:14,260 --> 00:21:20,320
gonna use the VIS command again and we

468
00:21:17,740 --> 00:21:22,300
can see that our script did exactly what

469
00:21:20,320 --> 00:21:24,040
we wanted we sent all those capital X's

470
00:21:22,300 --> 00:21:26,560
or whatever you sent 24 bytes of garbage

471
00:21:24,040 --> 00:21:29,320
followed by all the air so now we've set

472
00:21:26,560 --> 00:21:33,919
the top chunk size field to a very very

473
00:21:29,320 --> 00:21:37,049
large value great what use is that

474
00:21:33,920 --> 00:21:37,049
[Music]

475
00:21:41,950 --> 00:21:48,020
well this is a simplified version of the

476
00:21:46,400 --> 00:21:50,390
output from the VM map command that we

477
00:21:48,020 --> 00:21:52,490
saw earlier simplified process map

478
00:21:50,390 --> 00:21:54,530
typically on x86 Linux you'll see the

479
00:21:52,490 --> 00:21:55,880
application a low memory followed by the

480
00:21:54,530 --> 00:21:57,920
heap and a region known as a program

481
00:21:55,880 --> 00:21:59,780
break and a large gap followed by the

482
00:21:57,920 --> 00:22:02,690
libraries including the Lib C in the VDS

483
00:21:59,780 --> 00:22:04,460
oh and then finally the stack and what

484
00:22:02,690 --> 00:22:06,380
we've done by leveraging this overflow

485
00:22:04,460 --> 00:22:08,450
to write a large value to the top chunk

486
00:22:06,380 --> 00:22:13,160
size field is convinced malloc that the

487
00:22:08,450 --> 00:22:15,560
heap is huge so if we made a

488
00:22:13,160 --> 00:22:19,280
particularly large request to malloc now

489
00:22:15,560 --> 00:22:20,899
could we crash the heap into the

490
00:22:19,280 --> 00:22:25,970
libraries or the stack and start

491
00:22:20,900 --> 00:22:27,740
overwriting sensitive data because if we

492
00:22:25,970 --> 00:22:30,020
made a particularly large request could

493
00:22:27,740 --> 00:22:33,050
we wrap around the VA space and start

494
00:22:30,020 --> 00:22:38,570
tampering data in lower addresses to

495
00:22:33,050 --> 00:22:39,740
thee now even in 64-bit we can and

496
00:22:38,570 --> 00:22:41,899
that's exactly what we're going to do

497
00:22:39,740 --> 00:22:43,610
we're going to make a huge request to

498
00:22:41,900 --> 00:22:45,110
malloc that's going to be satisfied from

499
00:22:43,610 --> 00:22:46,490
the top chunk that malloc thinks we'll

500
00:22:45,110 --> 00:22:48,770
be able to provide this kind of memory

501
00:22:46,490 --> 00:22:50,540
and it's going to stop just shy of our

502
00:22:48,770 --> 00:22:52,730
target though that short string of

503
00:22:50,540 --> 00:22:54,889
capital X's in the date session of our

504
00:22:52,730 --> 00:22:57,920
binary and then the next request we make

505
00:22:54,890 --> 00:23:00,580
is going to overlap that target and any

506
00:22:57,920 --> 00:23:04,880
data we put into it is gonna over Isis

507
00:23:00,580 --> 00:23:12,020
everyone happy with that alright so head

508
00:23:04,880 --> 00:23:13,460
back to your editor and we're gonna make

509
00:23:12,020 --> 00:23:14,780
that second request so we're going to

510
00:23:13,460 --> 00:23:17,900
use the malloc wrapper function again

511
00:23:14,780 --> 00:23:20,060
and in the size field we're going to use

512
00:23:17,900 --> 00:23:20,590
that Delta function that I mentioned

513
00:23:20,060 --> 00:23:22,879
earlier

514
00:23:20,590 --> 00:23:25,730
Delta takes two arguments all it does is

515
00:23:22,880 --> 00:23:28,820
is calculate Li that this hook will wrap

516
00:23:25,730 --> 00:23:31,670
around distance between two addresses so

517
00:23:28,820 --> 00:23:33,320
the start address is going to be the top

518
00:23:31,670 --> 00:23:35,600
chuck and remember that Heatley was

519
00:23:33,320 --> 00:23:38,929
captured in the variable called heap and

520
00:23:35,600 --> 00:23:41,300
we want to add hex 2-0 to that which

521
00:23:38,930 --> 00:23:43,310
because we requested a 2-0 size chunk

522
00:23:41,300 --> 00:23:46,100
will be the actual address of the top

523
00:23:43,310 --> 00:23:48,740
Chun and we want Delta to calculate the

524
00:23:46,100 --> 00:23:51,620
distance between that and our target so

525
00:23:48,740 --> 00:23:53,840
elf sim target

526
00:23:51,620 --> 00:23:57,110
and we want to take hex to zero bytes

527
00:23:53,840 --> 00:23:58,760
away from that because we don't want to

528
00:23:57,110 --> 00:24:00,799
overlap the target with this request we

529
00:23:58,760 --> 00:24:02,658
could but we're going to have to end up

530
00:24:00,799 --> 00:24:03,889
writing a lot of data to catch up with

531
00:24:02,659 --> 00:24:05,960
it and in doing so almost certainly

532
00:24:03,890 --> 00:24:08,210
write to an unmapped or read-only

533
00:24:05,960 --> 00:24:09,650
address in the meantime Malik's going to

534
00:24:08,210 --> 00:24:11,240
get away with requesting such a large

535
00:24:09,650 --> 00:24:13,039
amount of memory because it's only going

536
00:24:11,240 --> 00:24:15,260
to write to the first and last quad

537
00:24:13,039 --> 00:24:16,070
words of that chunk we should poke

538
00:24:15,260 --> 00:24:18,320
you're gonna be mapped

539
00:24:16,070 --> 00:24:21,770
it's writable and then we're going to

540
00:24:18,320 --> 00:24:23,330
send a single byte of garbage so we can

541
00:24:21,770 --> 00:24:28,129
just satisfy the malloc wrapper

542
00:24:23,330 --> 00:24:31,789
functions signature is everybody happy

543
00:24:28,130 --> 00:24:38,659
with that awesome so run this with the

544
00:24:31,789 --> 00:24:45,789
gdb option again and we had a horrible

545
00:24:38,659 --> 00:24:47,929
death oh I can't type there with me I

546
00:24:45,789 --> 00:24:53,000
hope you guys didn't copy exactly what I

547
00:24:47,929 --> 00:24:59,179
did because it was wrong I forgot to

548
00:24:53,000 --> 00:25:00,350
close the bracket didn't I remove that

549
00:24:59,179 --> 00:25:02,299
my apologies

550
00:25:00,350 --> 00:25:04,490
wasting your time Delta takes two

551
00:25:02,299 --> 00:25:06,320
arguments that I shouldn't close the

552
00:25:04,490 --> 00:25:10,700
bracket off the he plus X to zero once

553
00:25:06,320 --> 00:25:13,520
you've made that correction run this on

554
00:25:10,700 --> 00:25:15,140
the gdb again this time it's happy we

555
00:25:13,520 --> 00:25:16,399
can alt tab to the binary mash enter a

556
00:25:15,140 --> 00:25:18,529
bunch of times make sure hasn't crashed

557
00:25:16,399 --> 00:25:20,809
which is good since we're requesting

558
00:25:18,529 --> 00:25:27,049
chunks now within with a corrupted top

559
00:25:20,809 --> 00:25:28,279
chunk size field and don't use the vids

560
00:25:27,049 --> 00:25:30,620
compiled at this point home bag I'll

561
00:25:28,279 --> 00:25:34,460
have a write meltdown instead we're

562
00:25:30,620 --> 00:25:37,850
gonna DQ for dump quad target and this

563
00:25:34,460 --> 00:25:39,169
is the target address hex 400 401 and we

564
00:25:37,850 --> 00:25:46,549
can see there those capital X is

565
00:25:39,169 --> 00:25:50,809
represented by hex 5/8 values if we dump

566
00:25:46,549 --> 00:25:52,639
quads target - hex 101 - 16 you can see

567
00:25:50,809 --> 00:25:54,700
the two code words leading up to the

568
00:25:52,640 --> 00:25:57,919
target with this suspicious value here

569
00:25:54,700 --> 00:25:59,690
now if we print main underscore Arena

570
00:25:57,919 --> 00:26:02,149
dot top now we're gonna get into what a

571
00:25:59,690 --> 00:26:03,710
reader's are with our next technique but

572
00:26:02,149 --> 00:26:05,199
for now please take my word for it that

573
00:26:03,710 --> 00:26:07,149
this prints the address that

574
00:26:05,200 --> 00:26:10,269
mark thinks the top chunk resides that

575
00:26:07,149 --> 00:26:14,289
which is hex 400 400 whoa right here

576
00:26:10,269 --> 00:26:16,179
making this the top chunk size field so

577
00:26:14,289 --> 00:26:18,789
now the top chunky sat right before our

578
00:26:16,179 --> 00:26:21,760
target data and the next request we make

579
00:26:18,789 --> 00:26:25,809
the first quadword of that should nicely

580
00:26:21,760 --> 00:26:28,679
overlap target data and in fact we can

581
00:26:25,809 --> 00:26:31,928
do this manually if you hit c4 continue

582
00:26:28,679 --> 00:26:36,639
head back to your binary and make one

583
00:26:31,929 --> 00:26:43,630
more request of minimum size any data

584
00:26:36,639 --> 00:26:45,070
that you send Oh we'll end up

585
00:26:43,630 --> 00:26:46,720
overlapping the target and you can check

586
00:26:45,070 --> 00:26:48,490
the target with option number two and

587
00:26:46,720 --> 00:26:51,750
see that you've successfully overwritten

588
00:26:48,490 --> 00:26:53,710
it with whatever data you wrote there

589
00:26:51,750 --> 00:26:55,330
but we might as well just add this to

590
00:26:53,710 --> 00:26:56,860
our exploit so you can make one final

591
00:26:55,330 --> 00:27:00,668
request using the mallet wrapper

592
00:26:56,860 --> 00:27:03,850
function for any amount of data and then

593
00:27:00,669 --> 00:27:07,450
any data that you've sent so in my case

594
00:27:03,850 --> 00:27:09,250
just a much win string that request is

595
00:27:07,450 --> 00:27:11,970
going to overlap our target and then you

596
00:27:09,250 --> 00:27:20,260
can just run this without the gdb option

597
00:27:11,970 --> 00:27:21,519
and check the target with option two and

598
00:27:20,260 --> 00:27:24,610
that's all there is to the house of

599
00:27:21,519 --> 00:27:27,039
force in summary we leverage an overflow

600
00:27:24,610 --> 00:27:29,199
into the top chunk size field to make it

601
00:27:27,039 --> 00:27:31,210
a very large value tricking malloc into

602
00:27:29,200 --> 00:27:34,149
thinking that the top chunk was massive

603
00:27:31,210 --> 00:27:35,769
then we made a large request to span the

604
00:27:34,149 --> 00:27:37,658
gap between the top chunks current

605
00:27:35,769 --> 00:27:39,429
position and as our target which

606
00:27:37,659 --> 00:27:41,110
happened to be in the de section of this

607
00:27:39,429 --> 00:27:43,750
binary so it was able to wrap around the

608
00:27:41,110 --> 00:27:45,969
VA space to do that that meant that the

609
00:27:43,750 --> 00:27:47,679
last request we made overlapped our

610
00:27:45,970 --> 00:27:52,179
target and we were able to write

611
00:27:47,679 --> 00:27:53,620
arbitrary data to it simple as that so

612
00:27:52,179 --> 00:27:56,409
before we move on to our second

613
00:27:53,620 --> 00:28:01,719
technique are there any questions on the

614
00:27:56,409 --> 00:28:06,250
house of force awesome did everybody get

615
00:28:01,720 --> 00:28:09,130
that down just briefly for those of you

616
00:28:06,250 --> 00:28:10,480
for whom it's not working or if I've

617
00:28:09,130 --> 00:28:12,610
made some horrible typos

618
00:28:10,480 --> 00:28:15,190
there is a dope file got pwned hall

619
00:28:12,610 --> 00:28:16,918
solution - target in this directory that

620
00:28:15,190 --> 00:28:18,680
does exactly what we just did

621
00:28:16,919 --> 00:28:21,980
sorry

622
00:28:18,680 --> 00:28:23,480
on the screen dot pone tools for

623
00:28:21,980 --> 00:28:24,710
underscore solution - target that is

624
00:28:23,480 --> 00:28:26,540
exactly what we just did and it's got a

625
00:28:24,710 --> 00:28:28,490
bunch of comments as well so if you were

626
00:28:26,540 --> 00:28:31,280
unable to get that working will crack on

627
00:28:28,490 --> 00:28:32,510
for time purposes but you can you can

628
00:28:31,280 --> 00:28:44,420
edit that and read the comments and

629
00:28:32,510 --> 00:28:45,590
check it out later if you fancy okay all

630
00:28:44,420 --> 00:28:49,940
right let's move on to our second

631
00:28:45,590 --> 00:28:51,889
technique the fast bin do now one of the

632
00:28:49,940 --> 00:28:56,060
things that the heap is better at than

633
00:28:51,890 --> 00:28:58,100
the staff is dealing with recycling on

634
00:28:56,060 --> 00:28:59,780
news memory and this is achieved by the

635
00:28:58,100 --> 00:29:02,449
second of Malick's functions we're going

636
00:28:59,780 --> 00:29:04,910
to look at today free it frees another

637
00:29:02,450 --> 00:29:06,770
dead simple function all you do is pass

638
00:29:04,910 --> 00:29:09,380
a pointer to a chunk that you no longer

639
00:29:06,770 --> 00:29:11,420
need and then you can forget about it

640
00:29:09,380 --> 00:29:13,190
safe and the knowledge that that chunk

641
00:29:11,420 --> 00:29:16,250
would be recycled if and when is

642
00:29:13,190 --> 00:29:18,380
necessary from Malik's perspective

643
00:29:16,250 --> 00:29:19,520
however that chunk is going to be

644
00:29:18,380 --> 00:29:22,430
eventually linked into one of several

645
00:29:19,520 --> 00:29:25,100
free lists which are as they sound lists

646
00:29:22,430 --> 00:29:26,900
of free chunks of interest to us today

647
00:29:25,100 --> 00:29:29,810
or a collection of these free lists

648
00:29:26,900 --> 00:29:31,790
known as the fast bins fast because the

649
00:29:29,810 --> 00:29:34,070
free chunks in the more recycled fast

650
00:29:31,790 --> 00:29:35,780
and bins because that's what the malloc

651
00:29:34,070 --> 00:29:43,040
maintain is like to call lists when they

652
00:29:35,780 --> 00:29:45,490
feel like it and the fast bins

653
00:29:43,040 --> 00:29:48,920
themselves are just a small collection

654
00:29:45,490 --> 00:29:51,470
singly linked non circular lists each

655
00:29:48,920 --> 00:29:53,870
whole chunks free chunks of a specific

656
00:29:51,470 --> 00:29:56,090
size and to help us visualize how the

657
00:29:53,870 --> 00:29:58,250
fast bins work we're in a debug another

658
00:29:56,090 --> 00:30:00,709
small demo binary so switch fire back to

659
00:29:58,250 --> 00:30:04,040
your VMs and this time navigate to the

660
00:30:00,710 --> 00:30:06,080
fast bin dupe directory and once more

661
00:30:04,040 --> 00:30:12,170
we're gonna be bug the demo binary and

662
00:30:06,080 --> 00:30:15,169
the gdb what gdb has started gdb demo

663
00:30:12,170 --> 00:30:16,520
commands we're gonna break main again to

664
00:30:15,170 --> 00:30:20,290
set break bottom the main function and

665
00:30:16,520 --> 00:30:20,290
then we're gonna run it with run

666
00:30:23,590 --> 00:30:28,399
this time we can see the first thing

667
00:30:25,700 --> 00:30:30,410
this binary does is request three

668
00:30:28,400 --> 00:30:32,690
minimum size chunks using malloc

669
00:30:30,410 --> 00:30:37,610
we know exactly how that works so next

670
00:30:32,690 --> 00:30:39,500
three like this he's going to execute

671
00:30:37,610 --> 00:30:41,479
those lines and then we can use the VIS

672
00:30:39,500 --> 00:30:43,040
command to show that the heap is in

673
00:30:41,480 --> 00:30:45,530
exactly the same state as would expect

674
00:30:43,040 --> 00:30:52,550
with three minimum sized hex to zero

675
00:30:45,530 --> 00:30:55,990
chunks next thing is binary does is free

676
00:30:52,550 --> 00:31:00,620
those three chunks in order a B and C or

677
00:30:55,990 --> 00:31:05,480
green yellow I want to say turquoise and

678
00:31:00,620 --> 00:31:07,939
then purple and the heads of the fast

679
00:31:05,480 --> 00:31:10,070
bins that I talked about resides in a

680
00:31:07,940 --> 00:31:12,500
memory region called the main arena in

681
00:31:10,070 --> 00:31:14,419
the Lipsey's data section now arenas are

682
00:31:12,500 --> 00:31:17,390
just where Malik stores its non inline

683
00:31:14,420 --> 00:31:19,220
heat metadata and the main arena is the

684
00:31:17,390 --> 00:31:27,440
arena for the default heap the one we're

685
00:31:19,220 --> 00:31:29,960
using fortunately for us we don't have

686
00:31:27,440 --> 00:31:34,040
to manually introspect main arena memory

687
00:31:29,960 --> 00:31:35,780
we can use bone bags fast bins come at

688
00:31:34,040 --> 00:31:37,220
the output from which tells us that

689
00:31:35,780 --> 00:31:39,649
there are on the default conditions

690
00:31:37,220 --> 00:31:42,470
seven of these fast bins these seven

691
00:31:39,650 --> 00:31:44,030
singularly linked non-circular lists and

692
00:31:42,470 --> 00:31:46,070
each of them hold free chunks of a

693
00:31:44,030 --> 00:31:47,899
specific size so there's a 2-0 fast bin

694
00:31:46,070 --> 00:31:50,270
the Holts chunks of size two zero three

695
00:31:47,900 --> 00:31:54,410
zero fast bin etc all the way up to

696
00:31:50,270 --> 00:31:58,910
eight zero so let's use the next command

697
00:31:54,410 --> 00:32:00,890
to free that first chunk now a

698
00:31:58,910 --> 00:32:02,420
combination the fast bins and VIS

699
00:32:00,890 --> 00:32:05,780
commands are going to show us that that

700
00:32:02,420 --> 00:32:07,970
first chunk at hex 400 500 remember that

701
00:32:05,780 --> 00:32:10,010
malloc considers chunks to start 16

702
00:32:07,970 --> 00:32:11,660
bytes before their user data so that

703
00:32:10,010 --> 00:32:14,270
chunk starts here according to my lock

704
00:32:11,660 --> 00:32:16,580
that first chunk has been freed into the

705
00:32:14,270 --> 00:32:19,160
2-0 fast bin and all that means is that

706
00:32:16,580 --> 00:32:22,070
its address hex 400 500 has been written

707
00:32:19,160 --> 00:32:26,410
into the 2-0 fasting slot in the main

708
00:32:22,070 --> 00:32:26,409
arena somewhere in live C state section

709
00:32:28,840 --> 00:32:38,918
so let's free the next chunk it next now

710
00:32:33,279 --> 00:32:41,889
we've freed chunk be fast bins and this

711
00:32:38,919 --> 00:32:44,679
commands are going to show us that thou

712
00:32:41,889 --> 00:32:47,709
chunk be the I'm gonna say turquoise

713
00:32:44,679 --> 00:32:49,149
chunk has been linked into the 2-0 fast

714
00:32:47,710 --> 00:32:51,100
bin and it's at the head but the 2-0

715
00:32:49,149 --> 00:32:53,498
fast bin fast wins are last in first out

716
00:32:51,100 --> 00:32:55,299
or LIFO structures I mean every time we

717
00:32:53,499 --> 00:32:57,549
free a chunk into one of these bins it's

718
00:32:55,299 --> 00:32:59,408
gonna be written to the heads that bin

719
00:32:57,549 --> 00:33:03,009
so there's one slot in the main arena

720
00:32:59,409 --> 00:33:05,679
for each of these bins now the address

721
00:33:03,009 --> 00:33:07,749
of chunk be turquoise chunk has been

722
00:33:05,679 --> 00:33:09,759
written into that slot but there's no

723
00:33:07,749 --> 00:33:11,259
more space for the rest of these the

724
00:33:09,759 --> 00:33:13,389
metadata for this list in the main arena

725
00:33:11,259 --> 00:33:15,279
like I said there's one slot and the

726
00:33:13,389 --> 00:33:17,469
rest of that data is held on the heap

727
00:33:15,279 --> 00:33:20,110
itself in line and we can see that the

728
00:33:17,470 --> 00:33:22,299
first quadword of user data of chunk B

729
00:33:20,110 --> 00:33:25,928
has been repurposed by malloc as a

730
00:33:22,299 --> 00:33:28,869
forward pointer or FD and that points or

731
00:33:25,929 --> 00:33:30,700
holds the address of chunk a chunk aft

732
00:33:28,869 --> 00:33:33,850
is null indicating the end of the list

733
00:33:30,700 --> 00:33:36,249
because it's a non circular list a model

734
00:33:33,850 --> 00:33:38,199
can repurpose up to six quadwords of

735
00:33:36,249 --> 00:33:41,679
user data of a chunk every time it's

736
00:33:38,200 --> 00:33:44,409
freed so we're gonna free the next we're

737
00:33:41,679 --> 00:33:46,059
gonna free chunk C with next and then

738
00:33:44,409 --> 00:33:47,919
class pins and vis shows us that as we

739
00:33:46,059 --> 00:33:51,309
expect chunk C is the head of the 2-0

740
00:33:47,919 --> 00:33:55,119
fast bin chunk C's FD points the chunk

741
00:33:51,309 --> 00:33:58,149
B's address here chunk B's FTE pointer

742
00:33:55,119 --> 00:34:00,850
chunk a and chunk a SF b is now

743
00:33:58,149 --> 00:34:04,629
indicating the end of the list so last

744
00:34:00,850 --> 00:34:06,908
thing first up and we can see that hone

745
00:34:04,629 --> 00:34:15,969
bag is annotated this to the right-hand

746
00:34:06,909 --> 00:34:17,889
side as well so fast but 0 1 2 so I said

747
00:34:15,969 --> 00:34:22,779
they were last in first out structures

748
00:34:17,889 --> 00:34:24,849
meaning that if we use next 3 to execute

749
00:34:22,780 --> 00:34:27,339
those three further request to malloc

750
00:34:24,849 --> 00:34:28,510
for minimum size chunks this is going to

751
00:34:27,339 --> 00:34:30,549
show us that despite the fact that we've

752
00:34:28,510 --> 00:34:33,849
now requested 6 chunks of minimum size

753
00:34:30,550 --> 00:34:35,349
we still only have 3 on the heap fast

754
00:34:33,849 --> 00:34:36,579
bins is going to show us now the 2-0

755
00:34:35,349 --> 00:34:38,020
fast bin is empty

756
00:34:36,579 --> 00:34:40,089
those three chunks will allocate from

757
00:34:38,020 --> 00:34:42,420
the 2-0 fast bit so the fast bins take

758
00:34:40,089 --> 00:34:47,860
precedence over allocating from the top

759
00:34:42,420 --> 00:34:51,700
because that faster and if we use print

760
00:34:47,860 --> 00:34:53,230
D print e and print F we can see that we

761
00:34:51,699 --> 00:34:54,879
got the user data addresses of those

762
00:34:53,230 --> 00:34:56,440
three chunks back in reverse order so

763
00:34:54,880 --> 00:34:58,510
chunk C was the last one to be freed and

764
00:34:56,440 --> 00:35:00,820
therefore was the first one out of that

765
00:34:58,510 --> 00:35:04,360
fast bit so we got chunk C then we got

766
00:35:00,820 --> 00:35:05,710
chunk B 4 or 5 or 3 oh and then finally

767
00:35:04,360 --> 00:35:09,430
we've got chunk a again you've got these

768
00:35:05,710 --> 00:35:11,520
used data addresses so if everybody's

769
00:35:09,430 --> 00:35:13,870
comfortable with how the fast bins work

770
00:35:11,520 --> 00:35:16,240
we're gonna start messing with up our

771
00:35:13,870 --> 00:35:17,440
vulnerable binary so close your

772
00:35:16,240 --> 00:35:21,549
debugging session we've controlled

773
00:35:17,440 --> 00:35:26,910
people quit and have a play with the

774
00:35:21,550 --> 00:35:29,590
fast bindu binary and once again a small

775
00:35:26,910 --> 00:35:31,810
CTF star binary written in C this one

776
00:35:29,590 --> 00:35:33,670
has a different type of heat bug that

777
00:35:31,810 --> 00:35:36,549
we're going to leverage the house of the

778
00:35:33,670 --> 00:35:39,970
fast been duped technique against for

779
00:35:36,550 --> 00:35:41,740
another arbitrary right so have a play

780
00:35:39,970 --> 00:35:44,109
with it again run under gdb see if you

781
00:35:41,740 --> 00:35:45,939
can find the bug this time and in the

782
00:35:44,110 --> 00:36:04,210
mean time once more I'll explain what's

783
00:35:45,940 --> 00:36:07,600
going on so I'm going to run my binary

784
00:36:04,210 --> 00:36:09,550
under gdb and the first thing it does is

785
00:36:07,600 --> 00:36:10,870
leak a heap at leak a Lib C address

786
00:36:09,550 --> 00:36:11,980
we're not going to use that but we'll

787
00:36:10,870 --> 00:36:14,410
come back to it when we're dropping

788
00:36:11,980 --> 00:36:15,970
shells on these binaries or like I say

789
00:36:14,410 --> 00:36:17,529
if you're into your exploit dev you can

790
00:36:15,970 --> 00:36:20,709
use that leak now to drop a shell on

791
00:36:17,530 --> 00:36:23,410
this binary after that it requests a

792
00:36:20,710 --> 00:36:26,620
username for now we're gonna type any

793
00:36:23,410 --> 00:36:29,470
old garbage into that field and we'll

794
00:36:26,620 --> 00:36:31,359
come back to that later a little menu

795
00:36:29,470 --> 00:36:34,509
allows us to request up to seven chunks

796
00:36:31,360 --> 00:36:37,720
this time so option one however the size

797
00:36:34,510 --> 00:36:40,120
field is limited limited to fast bin

798
00:36:37,720 --> 00:36:41,890
size chunks only so 120 bytes of user

799
00:36:40,120 --> 00:36:46,359
data maximum that will give us an 8-0

800
00:36:41,890 --> 00:36:47,950
sized chunk so I can request a minimum

801
00:36:46,360 --> 00:36:51,850
size chunk again and send a bunch of

802
00:36:47,950 --> 00:36:54,640
data to it option 2 allows us to free

803
00:36:51,850 --> 00:36:58,239
these chunks by index starting at 0

804
00:36:54,640 --> 00:36:59,680
you can't free incorrect indices so I

805
00:36:58,239 --> 00:37:03,519
can't free index one cuz only requested

806
00:36:59,680 --> 00:37:06,430
one chunk sorry I can't put this any

807
00:37:03,519 --> 00:37:11,049
higher on the screen but I can free

808
00:37:06,430 --> 00:37:12,759
index 0 like that option 3 prints and

809
00:37:11,049 --> 00:37:14,410
talk again once more our objective is to

810
00:37:12,759 --> 00:37:20,079
over at that target that short string of

811
00:37:14,410 --> 00:37:29,710
X's in the binaries data section so does

812
00:37:20,079 --> 00:37:31,269
anybody found the bug well this time as

813
00:37:29,710 --> 00:37:34,150
a different type of bug could have

814
00:37:31,269 --> 00:37:37,149
double free which allows us to free the

815
00:37:34,150 --> 00:37:41,259
same chunk twice without allocating it

816
00:37:37,150 --> 00:37:45,099
in between now that sounds kind of

817
00:37:41,259 --> 00:37:47,380
benign right but freeing the same chunk

818
00:37:45,099 --> 00:37:49,989
into the same fast bin twice without

819
00:37:47,380 --> 00:37:51,970
allocating it between in between it's

820
00:37:49,989 --> 00:37:54,640
gonna write that chunks address to that

821
00:37:51,970 --> 00:37:56,488
fast bin twice meaning that it might be

822
00:37:54,640 --> 00:38:00,339
allocated for two different purposes

823
00:37:56,489 --> 00:38:02,529
simultaneously so for example if this

824
00:38:00,339 --> 00:38:06,069
program were to allocate a chunk to hold

825
00:38:02,529 --> 00:38:07,749
an admin password half for example it

826
00:38:06,069 --> 00:38:09,430
might also allocate that chunk

827
00:38:07,749 --> 00:38:12,549
simultaneously if it's been double free

828
00:38:09,430 --> 00:38:14,470
to us the user to hold some benign user

829
00:38:12,549 --> 00:38:16,960
data we might be able to leverage that

830
00:38:14,470 --> 00:38:20,200
situation to read or write to that admin

831
00:38:16,960 --> 00:38:23,559
password hash so let's try that now if

832
00:38:20,200 --> 00:38:26,529
you request a chunk of any size write

833
00:38:23,559 --> 00:38:30,880
some data to it and then attempt to free

834
00:38:26,529 --> 00:38:38,829
at once and then free it again what

835
00:38:30,880 --> 00:38:40,960
happens we get an abort turns out that

836
00:38:38,829 --> 00:38:42,519
the glib see main taylors are wise in

837
00:38:40,960 --> 00:38:46,180
this they know that double fries are

838
00:38:42,519 --> 00:38:48,669
dangerous and there is a an export

839
00:38:46,180 --> 00:38:51,640
mitigation in the fast bins as part of

840
00:38:48,670 --> 00:38:54,279
the free function and that mitigation

841
00:38:51,640 --> 00:38:57,098
works thus if you free a chunk into a

842
00:38:54,279 --> 00:38:59,019
fast bin and that chunk is already the

843
00:38:57,099 --> 00:39:01,630
head of that fast bin so it was the last

844
00:38:59,019 --> 00:39:03,988
time to be freed in then that's clearly

845
00:39:01,630 --> 00:39:07,839
a double free scenario abort

846
00:39:03,989 --> 00:39:08,569
so are we scuppers or can anybody think

847
00:39:07,839 --> 00:39:13,269
of a where

848
00:39:08,569 --> 00:39:13,269
this little protection any suggestions

849
00:39:13,869 --> 00:39:17,509
precisely yeah we've just free a

850
00:39:15,949 --> 00:39:23,380
different chunk in between it's that

851
00:39:17,509 --> 00:39:25,669
simple so if you run the binary again

852
00:39:23,380 --> 00:39:28,309
request a couple of different chunks as

853
00:39:25,669 --> 00:39:29,660
long as they're the same size just on

854
00:39:28,309 --> 00:39:33,349
the request one chunk of minimum size

855
00:39:29,660 --> 00:39:35,149
and another chunk of minimum size then

856
00:39:33,349 --> 00:39:36,769
I'm gonna free chunk zero like I did

857
00:39:35,150 --> 00:39:37,429
before but instead of freeing again

858
00:39:36,769 --> 00:39:39,649
straightaway

859
00:39:37,429 --> 00:39:42,259
I'm gonna free chunk one now I'm gonna

860
00:39:39,650 --> 00:39:45,380
double free chunk zero and the binary

861
00:39:42,259 --> 00:39:47,949
doesn't complain simple so we bypassed

862
00:39:45,380 --> 00:39:50,809
that first double free exploit

863
00:39:47,949 --> 00:39:54,650
mitigation by as you man said just

864
00:39:50,809 --> 00:40:01,880
freeing a different chunk in between so

865
00:39:54,650 --> 00:40:04,009
let's script this up once more make a

866
00:40:01,880 --> 00:40:07,549
copy of your pone Tools template Python

867
00:40:04,009 --> 00:40:15,199
script and then open it up in your

868
00:40:07,549 --> 00:40:24,819
editor of choice not like that once

869
00:40:15,199 --> 00:40:24,819
again we have ambient music in there

870
00:40:27,699 --> 00:40:34,130
that's really cool that's really hot

871
00:40:31,209 --> 00:40:36,828
alright let's just crack on definitely

872
00:40:34,130 --> 00:40:38,719
not coming from any of my devices so

873
00:40:36,829 --> 00:40:42,829
this time I scrip is gonna set the

874
00:40:38,719 --> 00:40:45,559
username field for us and it's gonna

875
00:40:42,829 --> 00:40:47,359
send 16 capitalized 16 bytes of garbage

876
00:40:45,559 --> 00:40:49,239
like I said yes just to sort that field

877
00:40:47,359 --> 00:40:53,779
out we're gonna come back to that later

878
00:40:49,239 --> 00:40:54,919
and this time we have a malloc wrapper

879
00:40:53,779 --> 00:40:57,140
function that works just like before

880
00:40:54,919 --> 00:40:58,669
with the size field followed by whatever

881
00:40:57,140 --> 00:41:00,679
data you want to send this time there's

882
00:40:58,669 --> 00:41:02,959
no overflow so if you request 8 bytes

883
00:41:00,679 --> 00:41:04,039
you can only send 8 bytes you try and

884
00:41:02,959 --> 00:41:05,390
send a bunch more you're just gonna see

885
00:41:04,039 --> 00:41:07,549
that menu get printed out a bunch and

886
00:41:05,390 --> 00:41:09,408
you know something went wrong this time

887
00:41:07,549 --> 00:41:11,599
we also have a free wrapper function so

888
00:41:09,409 --> 00:41:14,869
we can free 0 free one and that'll free

889
00:41:11,599 --> 00:41:16,849
indexes 0 and 1 so delete all that stuff

890
00:41:14,869 --> 00:41:18,559
that's why we made a copy and once more

891
00:41:16,849 --> 00:41:21,200
we're gonna emulate what we just did in

892
00:41:18,559 --> 00:41:22,850
gdb so let's request our two

893
00:41:21,200 --> 00:41:24,649
I'm gonna use minimum size chunk you

894
00:41:22,850 --> 00:41:25,880
guys can request any fast bin size

895
00:41:24,650 --> 00:41:30,620
chunks you like as long as they're the

896
00:41:25,880 --> 00:41:34,070
same size so I'm gonna use malloc and

897
00:41:30,620 --> 00:41:35,540
I'm gonna use a I'm gonna request eight

898
00:41:34,070 --> 00:41:38,530
bytes for a minimum size chunk and I'm

899
00:41:35,540 --> 00:41:44,150
just gonna write eight bytes of garbage

900
00:41:38,530 --> 00:41:45,560
and then we're gonna do that again I'm

901
00:41:44,150 --> 00:41:47,420
just marking them up with some A's and

902
00:41:45,560 --> 00:41:51,470
B's so that we know where they came from

903
00:41:47,420 --> 00:42:02,810
and then we want a free chunk 0 followed

904
00:41:51,470 --> 00:42:05,629
by chunk one and then chunk 0 once you

905
00:42:02,810 --> 00:42:09,920
guys have got that sorted run your

906
00:42:05,630 --> 00:42:17,240
script with the gdb options look up when

907
00:42:09,920 --> 00:42:22,610
you're done typing as well thank you for

908
00:42:17,240 --> 00:42:23,540
putting in that happens yes we do go

909
00:42:22,610 --> 00:42:25,760
ahead of myself

910
00:42:23,540 --> 00:42:27,950
if you can't just mash the undo button

911
00:42:25,760 --> 00:42:31,310
which is you in this case and get back

912
00:42:27,950 --> 00:42:37,430
to this state and then quickly quickly

913
00:42:31,310 --> 00:42:39,140
correct it all then just make another

914
00:42:37,430 --> 00:42:52,250
copy of the file thank you for pointing

915
00:42:39,140 --> 00:42:53,540
that out so yes we need the all right

916
00:42:52,250 --> 00:42:55,490
there we go should look more like this

917
00:42:53,540 --> 00:42:57,860
we need to do the username interaction

918
00:42:55,490 --> 00:43:00,410
as you said then we're gonna request our

919
00:42:57,860 --> 00:43:01,640
two chunks followed by freeing them let

920
00:43:00,410 --> 00:43:03,319
someone point that out before I got

921
00:43:01,640 --> 00:43:12,259
really confused and just sort of let it

922
00:43:03,320 --> 00:43:14,440
crack on okay my apologies all right

923
00:43:12,260 --> 00:43:22,850
once you guys have got that written down

924
00:43:14,440 --> 00:43:24,620
run your script with the gdb option we

925
00:43:22,850 --> 00:43:27,799
can all tab to the binary you see that

926
00:43:24,620 --> 00:43:30,370
that works and then ctrl C to break in

927
00:43:27,800 --> 00:43:30,370
gdb

928
00:43:34,170 --> 00:43:40,690
that's gone off the screen a little bit

929
00:43:36,160 --> 00:43:42,730
so beer right now we're going to use the

930
00:43:40,690 --> 00:43:44,560
VIS and fast bins commands to once again

931
00:43:42,730 --> 00:43:46,900
introspect the heap and the fast bins

932
00:43:44,560 --> 00:43:48,970
and we can see that we've got different

933
00:43:46,900 --> 00:43:51,460
addresses this time that's because when

934
00:43:48,970 --> 00:43:53,200
you attach with gdb using the poem tools

935
00:43:51,460 --> 00:43:56,410
gdb functionality everything is going to

936
00:43:53,200 --> 00:43:58,450
be subject to a SLR so even though it's

937
00:43:56,410 --> 00:44:01,180
not really a drama with us what you can

938
00:43:58,450 --> 00:44:04,210
do is run your scripts with the know a

939
00:44:01,180 --> 00:44:07,720
SLR option so just like you did gdb in

940
00:44:04,210 --> 00:44:10,540
caps so run the script gdb no a SLR or

941
00:44:07,720 --> 00:44:12,100
caps you don't need to use this but it

942
00:44:10,540 --> 00:44:15,930
just makes debugging a little bit easier

943
00:44:12,100 --> 00:44:22,180
and then once again ctrl C to break and

944
00:44:15,930 --> 00:44:23,379
then fast bins followed by this and we

945
00:44:22,180 --> 00:44:24,879
can see now that the addresses are kind

946
00:44:23,380 --> 00:44:26,410
of back to what we're used to and we can

947
00:44:24,880 --> 00:44:27,850
just run it without the know s that no a

948
00:44:26,410 --> 00:44:31,060
SLR option when we want to do this in

949
00:44:27,850 --> 00:44:33,009
production so chunk a is linked into the

950
00:44:31,060 --> 00:44:36,220
2-0 fast bin to begin with at the head a

951
00:44:33,010 --> 00:44:38,110
hex 400 500 followed by chunk B or one I

952
00:44:36,220 --> 00:44:40,680
suppose I should say chunk 0 then chunk

953
00:44:38,110 --> 00:44:43,570
1 a hex 400 500 - OH

954
00:44:40,680 --> 00:44:47,440
but as you can see from the VIS output

955
00:44:43,570 --> 00:44:50,260
chunk B's F D points back to chunk a and

956
00:44:47,440 --> 00:44:52,420
vice-versa so now we've turned by

957
00:44:50,260 --> 00:44:55,150
leveraging this double doing this double

958
00:44:52,420 --> 00:44:57,760
free we've turned a singly linked non

959
00:44:55,150 --> 00:44:59,200
circular list into a circular list it's

960
00:44:57,760 --> 00:45:03,010
going to keep giving us these two chunks

961
00:44:59,200 --> 00:45:05,230
back now unfortunately the example I

962
00:45:03,010 --> 00:45:07,420
gave you is pretty useless in this

963
00:45:05,230 --> 00:45:09,220
scenario and we don't have any admin

964
00:45:07,420 --> 00:45:10,780
password hashes on the heap we control

965
00:45:09,220 --> 00:45:14,649
over user date it something useful for

966
00:45:10,780 --> 00:45:17,650
us there instead what if we requested

967
00:45:14,650 --> 00:45:19,660
chunk zero back to us so that we could

968
00:45:17,650 --> 00:45:22,870
manipulate its user data we can write

969
00:45:19,660 --> 00:45:24,609
arbitrary data to these chunks but also

970
00:45:22,870 --> 00:45:26,680
kept it in the 2-0 fast bin

971
00:45:24,610 --> 00:45:28,510
simultaneously where that first chunk of

972
00:45:26,680 --> 00:45:31,870
that first quadword of its user data is

973
00:45:28,510 --> 00:45:33,880
being used as a forward pointer then if

974
00:45:31,870 --> 00:45:35,680
we can overwrite that forward pointer

975
00:45:33,880 --> 00:45:37,210
because we can legitimately right to

976
00:45:35,680 --> 00:45:39,430
this chunk having allocated it back to

977
00:45:37,210 --> 00:45:42,340
us we might be able to link in a fake

978
00:45:39,430 --> 00:45:44,589
chunk into this 2-0 fast bin perhaps

979
00:45:42,340 --> 00:45:45,500
that overlaps the target and then

980
00:45:44,590 --> 00:45:47,930
request that

981
00:45:45,500 --> 00:45:51,410
chump back from the 2-0 fast bin and

982
00:45:47,930 --> 00:45:53,270
write arbitrary data to our target so

983
00:45:51,410 --> 00:45:55,910
let's give that a go you close your

984
00:45:53,270 --> 00:46:00,050
debugging session and head back to your

985
00:45:55,910 --> 00:46:02,000
script we're gonna make a request using

986
00:46:00,050 --> 00:46:04,340
the malloc wrapper function for for 8

987
00:46:02,000 --> 00:46:09,380
bytes so we can cover that first

988
00:46:04,340 --> 00:46:11,870
quadword and we are going to pack 64 elf

989
00:46:09,380 --> 00:46:17,390
dot sim dot this time we're going to use

990
00:46:11,870 --> 00:46:19,279
user now in this binary there is a user

991
00:46:17,390 --> 00:46:21,560
struct that contains the target that's

992
00:46:19,280 --> 00:46:24,020
why we're using user Holmes doesn't cope

993
00:46:21,560 --> 00:46:25,970
with structs very well either that or I

994
00:46:24,020 --> 00:46:28,640
just can't use pone tools well enough

995
00:46:25,970 --> 00:46:31,069
probably the latter by the way I hope

996
00:46:28,640 --> 00:46:33,799
that simple user is the address of the

997
00:46:31,070 --> 00:46:36,920
user struct which is happens to start 16

998
00:46:33,800 --> 00:46:37,970
bytes before the target address so

999
00:46:36,920 --> 00:46:39,590
that's what we want we want that malloc

1000
00:46:37,970 --> 00:46:42,230
address 16 bytes before the value that

1001
00:46:39,590 --> 00:46:44,210
we want to overwrite and also we'll see

1002
00:46:42,230 --> 00:46:45,800
that our user names the first part of

1003
00:46:44,210 --> 00:46:49,400
that struct which I'm sure will become

1004
00:46:45,800 --> 00:46:51,080
clear so once you've got that sorted run

1005
00:46:49,400 --> 00:46:52,550
the script with the gdb option and no

1006
00:46:51,080 --> 00:46:56,630
aslr if you want to have those

1007
00:46:52,550 --> 00:47:04,160
comfortable addresses again break with

1008
00:46:56,630 --> 00:47:06,590
control C and now the fast Bin's command

1009
00:47:04,160 --> 00:47:09,200
is going to show us that we've corrupted

1010
00:47:06,590 --> 00:47:11,660
that fast bin links list to this address

1011
00:47:09,200 --> 00:47:15,169
hex 404 o1o which we can view with dump

1012
00:47:11,660 --> 00:47:18,109
quod ampersand user does he hex 404 at

1013
00:47:15,170 --> 00:47:19,670
one oh that's how user name there 16

1014
00:47:18,110 --> 00:47:21,380
bytes of capital wise and this is the

1015
00:47:19,670 --> 00:47:23,510
target those capital X is followed by a

1016
00:47:21,380 --> 00:47:26,570
null bytes a hex 404 Oh - OH

1017
00:47:23,510 --> 00:47:29,120
so we've linked a fake chunk into the

1018
00:47:26,570 --> 00:47:33,170
2-0 fast bin by overwriting one of the

1019
00:47:29,120 --> 00:47:35,420
forward pointers so we need to do now is

1020
00:47:33,170 --> 00:47:38,480
allocate out these two rogue chunks here

1021
00:47:35,420 --> 00:47:40,520
their chunk 1 and chunk 0 as we called

1022
00:47:38,480 --> 00:47:41,900
them and then the third allocation that

1023
00:47:40,520 --> 00:47:43,970
we made from the 2-0 fast spinning will

1024
00:47:41,900 --> 00:47:46,010
be a fake chunk overlapping our target

1025
00:47:43,970 --> 00:47:47,899
and then we can just write arbitrary

1026
00:47:46,010 --> 00:47:51,380
data to it easy

1027
00:47:47,900 --> 00:47:53,870
so let's script that up now we want to

1028
00:47:51,380 --> 00:47:56,570
make another two requests to malloc for

1029
00:47:53,870 --> 00:47:59,440
minimum size chunks so again I'm just

1030
00:47:56,570 --> 00:47:59,440
going to write 8 bytes

1031
00:48:02,799 --> 00:48:06,799
like that you can copy/paste what you

1032
00:48:05,239 --> 00:48:08,779
had above there as well for the sake of

1033
00:48:06,799 --> 00:48:14,089
speed and then run it with the gdb

1034
00:48:08,779 --> 00:48:15,589
option again break with ctrl C and now

1035
00:48:14,089 --> 00:48:16,630
fast means command shows us that the

1036
00:48:15,589 --> 00:48:20,808
next chunk we're going to allocate

1037
00:48:16,630 --> 00:48:24,890
overlaps you use a struct and should be

1038
00:48:20,809 --> 00:48:27,079
able to override our target simple so

1039
00:48:24,890 --> 00:48:28,999
let's try that manually if you see 4

1040
00:48:27,079 --> 00:48:31,489
compare 4 continue alt tab back to the

1041
00:48:28,999 --> 00:48:36,259
binary and then make your last request

1042
00:48:31,489 --> 00:48:39,199
of minimum size and unfortunately we get

1043
00:48:36,259 --> 00:48:42,019
call out a second time if you can read

1044
00:48:39,199 --> 00:48:44,059
that says malloc memory corruption and

1045
00:48:42,019 --> 00:48:47,180
we've been hit by a second exploit

1046
00:48:44,059 --> 00:48:49,999
mitigation in malloc this time it's a

1047
00:48:47,180 --> 00:48:51,558
little more insidious this malloc

1048
00:48:49,999 --> 00:48:52,669
corruption fast doesn't really give us

1049
00:48:51,559 --> 00:48:55,219
much of a hint as to what's going on

1050
00:48:52,670 --> 00:48:57,949
turns out there is a size field check

1051
00:48:55,219 --> 00:49:00,769
when requesting chunks from the fast

1052
00:48:57,949 --> 00:49:02,569
bins and marks just going to check to

1053
00:49:00,769 --> 00:49:05,029
make sure that that chunk size makes

1054
00:49:02,569 --> 00:49:08,029
sense if you allocate enough a 5-0 or

1055
00:49:05,029 --> 00:49:10,339
you know x200 chunk from the 2-0 fast

1056
00:49:08,029 --> 00:49:16,489
bin that doesn't make any sense so it's

1057
00:49:10,339 --> 00:49:21,949
going to abort so if you head back to

1058
00:49:16,489 --> 00:49:24,289
your editor in fact tell a lie don't go

1059
00:49:21,949 --> 00:49:27,979
back to your editor run another

1060
00:49:24,289 --> 00:49:31,630
debugging session and this time jump

1061
00:49:27,979 --> 00:49:33,649
quad ampersand user and as we saw before

1062
00:49:31,630 --> 00:49:36,170
we are in the lucky position of

1063
00:49:33,650 --> 00:49:38,539
controlling some of the data prior to

1064
00:49:36,170 --> 00:49:40,489
our target so we're gonna Forge a fake

1065
00:49:38,539 --> 00:49:42,259
size field to trick my lock into

1066
00:49:40,489 --> 00:49:45,769
thinking this is a legitimate chunk that

1067
00:49:42,259 --> 00:49:47,719
we've linked in so now head back to your

1068
00:49:45,769 --> 00:49:49,368
editor and we want to mess with that

1069
00:49:47,719 --> 00:49:52,099
username field at the beginning of this

1070
00:49:49,369 --> 00:49:54,529
script so instead of writing 16 bytes of

1071
00:49:52,099 --> 00:49:58,849
garbage we're gonna write 8 bytes of

1072
00:49:54,529 --> 00:50:03,039
garbage and then we're going to use PAC

1073
00:49:58,849 --> 00:50:03,039
64 hex to 1

1074
00:50:04,460 --> 00:50:19,500
once you've done that debug it again and

1075
00:50:16,970 --> 00:50:21,569
this time dump quad ampersand users

1076
00:50:19,500 --> 00:50:27,060
going to show us that we Forge that fake

1077
00:50:21,570 --> 00:50:30,060
size field hex - well now this is lab

1078
00:50:27,060 --> 00:50:31,680
environment so we happen to have control

1079
00:50:30,060 --> 00:50:33,690
of the court word right before our

1080
00:50:31,680 --> 00:50:35,580
target which is pretty convenient but

1081
00:50:33,690 --> 00:50:37,890
remember that fast bins got to size hex

1082
00:50:35,580 --> 00:50:39,779
eight zero so we could scroll back by up

1083
00:50:37,890 --> 00:50:42,060
to a hundred twenty bytes before this as

1084
00:50:39,780 --> 00:50:44,850
long as we could coerce a size field to

1085
00:50:42,060 --> 00:50:47,100
anchor this fake chunk in we can

1086
00:50:44,850 --> 00:50:50,220
manipulate potentially data up to a

1087
00:50:47,100 --> 00:50:52,140
hundred twenty bytes after that so now

1088
00:50:50,220 --> 00:50:54,660
we should be able to manually continue

1089
00:50:52,140 --> 00:50:56,460
all tab back to the binary and this time

1090
00:50:54,660 --> 00:50:59,370
request a minimum size chunk and we

1091
00:50:56,460 --> 00:51:05,510
don't get a crash and any day to you

1092
00:50:59,370 --> 00:51:05,509
right in here should override the target

1093
00:51:07,550 --> 00:51:14,190
and if we want we can make that last

1094
00:51:12,000 --> 00:51:16,350
request to malloc in the script as well

1095
00:51:14,190 --> 00:51:27,320
I apologize if this is getting close to

1096
00:51:16,350 --> 00:51:29,279
the bottom of the screen incidentally so

1097
00:51:27,320 --> 00:51:30,330
once you've made that last adjustment

1098
00:51:29,280 --> 00:51:32,040
you can run the script without there

1099
00:51:30,330 --> 00:51:33,360
know ASL our stuff and without you you

1100
00:51:32,040 --> 00:51:35,400
need to make sure we legitimately

1101
00:51:33,360 --> 00:51:36,930
nailing this down and then option three

1102
00:51:35,400 --> 00:51:38,780
print the target should just print

1103
00:51:36,930 --> 00:51:42,450
whatever text you decide it right there

1104
00:51:38,780 --> 00:51:44,910
awesome so that's all there is to the

1105
00:51:42,450 --> 00:51:46,439
fast Bindu once again if you guys had an

1106
00:51:44,910 --> 00:51:48,690
exploit that didn't work there there is

1107
00:51:46,440 --> 00:51:50,130
another dot file type home from solution

1108
00:51:48,690 --> 00:51:51,930
target that would do exactly what we've

1109
00:51:50,130 --> 00:51:53,910
just done again with a load of comments

1110
00:51:51,930 --> 00:51:58,319
on it how we doing for time to thirty

1111
00:51:53,910 --> 00:52:00,290
three thirty fantastic alright so before

1112
00:51:58,320 --> 00:52:02,610
we move on and start dropping shells

1113
00:52:00,290 --> 00:52:06,050
does anybody have any questions on the

1114
00:52:02,610 --> 00:52:06,050
fast Bindu p-- technique

1115
00:52:10,070 --> 00:52:20,330
all right how you guys coping I'm too

1116
00:52:13,940 --> 00:52:22,910
tired yes ah so that's the length of

1117
00:52:20,330 --> 00:52:24,950
that much win string in this case as I

1118
00:52:22,910 --> 00:52:26,480
mentioned earlier you have to request

1119
00:52:24,950 --> 00:52:28,279
what you want to write if I wrote a 1

1120
00:52:26,480 --> 00:52:30,050
there it would receive the M and then it

1121
00:52:28,280 --> 00:52:32,120
would send you to the menu and season

1122
00:52:30,050 --> 00:52:34,190
menu etc so yeah in this case we have to

1123
00:52:32,120 --> 00:52:35,900
specifically request that amount so I

1124
00:52:34,190 --> 00:52:42,200
just requested 9 bytes I could requested

1125
00:52:35,900 --> 00:52:44,690
more than written less as well all right

1126
00:52:42,200 --> 00:52:48,859
so let's revisit the house of force and

1127
00:52:44,690 --> 00:52:50,180
this time we're going to drop a shell so

1128
00:52:48,860 --> 00:52:54,650
navigate back to the house of force

1129
00:52:50,180 --> 00:52:56,660
directory and I suggest make it a copy

1130
00:52:54,650 --> 00:52:58,280
of your exploit script as I mentioned if

1131
00:52:56,660 --> 00:52:59,990
your exploit script didn't work there's

1132
00:52:58,280 --> 00:53:01,700
a bone tool solution target scripts that

1133
00:52:59,990 --> 00:53:04,729
you can use instead it should be almost

1134
00:53:01,700 --> 00:53:08,419
identical to what we've done I'm going

1135
00:53:04,730 --> 00:53:11,510
to copy my expiode up PI script and just

1136
00:53:08,420 --> 00:53:14,180
make a backup of it and then once again

1137
00:53:11,510 --> 00:53:21,350
open your exploit script in your editor

1138
00:53:14,180 --> 00:53:23,480
of choice and we're going to delete

1139
00:53:21,350 --> 00:53:24,980
everything after that first request to

1140
00:53:23,480 --> 00:53:26,750
malloc now that first request to malloc

1141
00:53:24,980 --> 00:53:29,930
we're going to keep because that's what

1142
00:53:26,750 --> 00:53:32,630
setup off our house of force primitive

1143
00:53:29,930 --> 00:53:34,399
so we use that to request a minimum size

1144
00:53:32,630 --> 00:53:36,260
chunk we filled up that minimum sized

1145
00:53:34,400 --> 00:53:37,700
chunks user data with garbage and then

1146
00:53:36,260 --> 00:53:44,090
we overrode the top chunk size filled

1147
00:53:37,700 --> 00:53:45,649
with a large value so now the next

1148
00:53:44,090 --> 00:53:46,760
request we make can be really large and

1149
00:53:45,650 --> 00:53:48,770
we can use it to catch it up to

1150
00:53:46,760 --> 00:53:50,480
something useful in memory that's going

1151
00:53:48,770 --> 00:53:53,390
to allow us to hijack the flow of

1152
00:53:50,480 --> 00:53:55,610
execution any suggestions as to what

1153
00:53:53,390 --> 00:53:58,670
that might be anywhere in this binary in

1154
00:53:55,610 --> 00:54:00,230
this processes VA space anything that

1155
00:53:58,670 --> 00:54:04,480
overwriting it will allow us to hijack

1156
00:54:00,230 --> 00:54:04,480
the flow of execution any suggestions

1157
00:54:07,420 --> 00:54:14,830
copy ot engine ease yeah anything else

1158
00:54:11,980 --> 00:54:17,810
all right well let's think this through

1159
00:54:14,830 --> 00:54:20,660
we could clobber return addresses on the

1160
00:54:17,810 --> 00:54:22,279
stack for example but in this case the

1161
00:54:20,660 --> 00:54:23,460
stack is subject to err SLR and we

1162
00:54:22,280 --> 00:54:25,710
haven't leaked it so

1163
00:54:23,460 --> 00:54:27,420
that's out of the question we could

1164
00:54:25,710 --> 00:54:28,740
attack the binary we know it's not pick

1165
00:54:27,420 --> 00:54:30,480
so we know it's a dress

1166
00:54:28,740 --> 00:54:32,330
and we've already managed to overwrite a

1167
00:54:30,480 --> 00:54:35,610
target chord weren't there already

1168
00:54:32,330 --> 00:54:37,410
however this binary was compiled with

1169
00:54:35,610 --> 00:54:40,320
full railro which we can check with

1170
00:54:37,410 --> 00:54:45,180
check SEC and then the name of the

1171
00:54:40,320 --> 00:54:46,710
binary he shows us that it was indeed

1172
00:54:45,180 --> 00:54:48,660
you can part with compiled with full

1173
00:54:46,710 --> 00:54:59,910
railroad meaning that got P ot entries

1174
00:54:48,660 --> 00:55:01,710
and not exit funks yeah essentially

1175
00:54:59,910 --> 00:55:03,779
detours list that I'm forgetting for

1176
00:55:01,710 --> 00:55:06,420
some reason both of those are compiled

1177
00:55:03,780 --> 00:55:08,970
compiled with both of those will be

1178
00:55:06,420 --> 00:55:10,260
marked read-only by the time that the

1179
00:55:08,970 --> 00:55:11,970
program is initialized so unfortunately

1180
00:55:10,260 --> 00:55:15,300
the binary is out of the question as

1181
00:55:11,970 --> 00:55:17,339
well finis array that's what I was

1182
00:55:15,300 --> 00:55:19,530
thinking of got people to Infinia are

1183
00:55:17,340 --> 00:55:21,240
out but we've legally BC in this case

1184
00:55:19,530 --> 00:55:25,820
and there's plenty in the Lib C Lib C

1185
00:55:21,240 --> 00:55:30,080
has it got PLT there our exit functioned

1186
00:55:25,820 --> 00:55:32,640
TLS detours as well to target however

1187
00:55:30,080 --> 00:55:34,560
ellipses got P ot doesn't have anything

1188
00:55:32,640 --> 00:55:36,270
that we can reliably invoke with this

1189
00:55:34,560 --> 00:55:38,460
binary and unfortunately exit function

1190
00:55:36,270 --> 00:55:40,620
TLS detours are protected by point of

1191
00:55:38,460 --> 00:55:44,370
mango which means that unless we had an

1192
00:55:40,620 --> 00:55:47,430
arbitrary reads we couldn't reliably

1193
00:55:44,370 --> 00:55:49,529
tamper those values but it turns out

1194
00:55:47,430 --> 00:55:51,390
there is a malloc specific way of

1195
00:55:49,530 --> 00:55:54,450
hijacking the flow of execution I'm

1196
00:55:51,390 --> 00:55:58,370
talking about malloc hooks every one of

1197
00:55:54,450 --> 00:56:01,680
Malik's core functions so malloc free

1198
00:55:58,370 --> 00:56:08,520
realloc and more core etc have an

1199
00:56:01,680 --> 00:56:11,700
associated hook and they're typically

1200
00:56:08,520 --> 00:56:13,350
for the purpose of developers hooking

1201
00:56:11,700 --> 00:56:16,680
the malloc function and creating their

1202
00:56:13,350 --> 00:56:19,650
own memory allocators or trying to

1203
00:56:16,680 --> 00:56:21,740
collect statistics on Malan we're gonna

1204
00:56:19,650 --> 00:56:24,420
use them to hijack the flow of execution

1205
00:56:21,740 --> 00:56:27,180
and I'll explain how the malloc how old

1206
00:56:24,420 --> 00:56:29,610
Malick's hooks work momentarily but if

1207
00:56:27,180 --> 00:56:31,470
you go back to your editor we're going

1208
00:56:29,610 --> 00:56:33,090
to use the mallet wrapper function to

1209
00:56:31,470 --> 00:56:35,370
request the large chunk so leverage our

1210
00:56:33,090 --> 00:56:36,900
house of force primitive and this time

1211
00:56:35,370 --> 00:56:38,790
we don't need Delta because we're not

1212
00:56:36,900 --> 00:56:42,480
wrapping around the VA space so we want

1213
00:56:38,790 --> 00:56:46,080
the distance between Lib C sim dot and

1214
00:56:42,480 --> 00:56:48,090
then the Malik hooks the Malik hooks

1215
00:56:46,080 --> 00:56:51,090
symbol is underscore underscore Malik

1216
00:56:48,090 --> 00:56:53,130
underscore hook and the reason we're

1217
00:56:51,090 --> 00:56:54,510
using the Malik hook is because Malik's

1218
00:56:53,130 --> 00:56:56,700
the only function that we can reliably

1219
00:56:54,510 --> 00:56:58,890
call how the Liberty's call funcles

1220
00:56:56,700 --> 00:57:00,779
Malik's core functions in this binary we

1221
00:56:58,890 --> 00:57:01,980
can do Malik and that's it no free or no

1222
00:57:00,780 --> 00:57:04,020
realloc or any of that good stuff

1223
00:57:01,980 --> 00:57:07,590
and of course just like before we want

1224
00:57:04,020 --> 00:57:09,300
to stop hex to zero bytes just shy that

1225
00:57:07,590 --> 00:57:12,690
Malik cooks say the next chunk of e

1226
00:57:09,300 --> 00:57:14,010
request is going to overlap it and we

1227
00:57:12,690 --> 00:57:17,910
want the Delta or the distance between

1228
00:57:14,010 --> 00:57:20,340
that value and the heat plus hex to zero

1229
00:57:17,910 --> 00:57:22,770
just like we did last time and we're

1230
00:57:20,340 --> 00:57:23,880
gonna send a bi of garbage just to

1231
00:57:22,770 --> 00:57:27,090
satisfy the Malik wrapper function

1232
00:57:23,880 --> 00:57:28,410
signature so we're gonna make that large

1233
00:57:27,090 --> 00:57:31,640
request which is going to cover the

1234
00:57:28,410 --> 00:57:35,640
space between the heaps top chunk and

1235
00:57:31,640 --> 00:57:39,810
the Malik hook once you guys will got

1236
00:57:35,640 --> 00:57:43,230
that down once again run this script

1237
00:57:39,810 --> 00:57:47,150
with a gbbr and if you want GDP and no

1238
00:57:43,230 --> 00:57:47,150
ASLR options

1239
00:57:47,270 --> 00:57:52,650
all right well we didn't get a crash

1240
00:57:50,460 --> 00:57:58,920
which is a good start ctrl C to break in

1241
00:57:52,650 --> 00:58:00,840
gdb and what we want to do is dump quad

1242
00:57:58,920 --> 00:58:04,230
ampersand underscore underscore mark

1243
00:58:00,840 --> 00:58:07,110
underscore hook and the Malik hook

1244
00:58:04,230 --> 00:58:08,700
resides at this Charlie 1 0 address here

1245
00:58:07,110 --> 00:58:10,290
and it's currently null

1246
00:58:08,700 --> 00:58:12,000
so once Malik's done with its

1247
00:58:10,290 --> 00:58:14,580
initialization routines the Malik hook

1248
00:58:12,000 --> 00:58:15,870
is going to be null and the way these

1249
00:58:14,580 --> 00:58:17,400
hooks work is that when they know

1250
00:58:15,870 --> 00:58:19,859
they're in a benign State their unused

1251
00:58:17,400 --> 00:58:22,680
any call to malloc will be forwarded to

1252
00:58:19,860 --> 00:58:26,310
the malloc function but as soon as we

1253
00:58:22,680 --> 00:58:28,770
write a value to the malloc hook then

1254
00:58:26,310 --> 00:58:31,230
any address that we write there will be

1255
00:58:28,770 --> 00:58:36,150
executed instead when malloc is called

1256
00:58:31,230 --> 00:58:41,010
and if we append a minus 2 to that Malik

1257
00:58:36,150 --> 00:58:42,720
hook command we see a suspect value here

1258
00:58:41,010 --> 00:58:47,670
I think another call to print main

1259
00:58:42,720 --> 00:58:49,890
underscore arena arena dot top

1260
00:58:47,670 --> 00:58:51,660
shows us that this eight Charlie zero

1261
00:58:49,890 --> 00:58:54,390
zero address is where Malik thinks the

1262
00:58:51,660 --> 00:58:56,490
top chunk is making this the top chunk

1263
00:58:54,390 --> 00:58:58,950
size field so we're ready to overwrite

1264
00:58:56,490 --> 00:59:01,830
the Malik hook with an address of our

1265
00:58:58,950 --> 00:59:04,020
choosing so once you guys have done

1266
00:59:01,830 --> 00:59:06,660
looking at that we know that the next

1267
00:59:04,020 --> 00:59:10,620
request we want to make might as well

1268
00:59:06,660 --> 00:59:14,029
make it for a minimum sized chunk so any

1269
00:59:10,620 --> 00:59:16,290
value between zero and twenty four and

1270
00:59:14,030 --> 00:59:17,880
what we're gonna do is just test this

1271
00:59:16,290 --> 00:59:22,080
theory so we're gonna pack sixty four

1272
00:59:17,880 --> 00:59:24,180
hex dead beef which should be unmapped

1273
00:59:22,080 --> 00:59:25,910
address in pretty much all scenarios so

1274
00:59:24,180 --> 00:59:28,169
we're gonna use this house of force

1275
00:59:25,910 --> 00:59:30,330
primitive to override the Malik hook

1276
00:59:28,170 --> 00:59:34,860
with the address dead beef now when we

1277
00:59:30,330 --> 00:59:38,779
request any Malik calls after that we

1278
00:59:34,860 --> 00:59:43,680
should bang into this unmapped address

1279
00:59:38,780 --> 00:59:45,930
so run that with the gdb option and just

1280
00:59:43,680 --> 00:59:48,120
straight away alt tab to your binary and

1281
00:59:45,930 --> 00:59:49,529
then make a request to Malaga it looks

1282
00:59:48,120 --> 00:59:53,400
like the binary is hanged and we can see

1283
00:59:49,530 --> 00:59:55,680
if we control tab back to gdb we've got

1284
00:59:53,400 --> 00:59:57,240
Fault address at dead beef and we can

1285
00:59:55,680 --> 00:59:59,790
see that the instruction pointer holds

1286
00:59:57,240 --> 01:00:02,129
the value dead beef which means we've

1287
00:59:59,790 --> 01:00:03,660
hijacked the flow of execution so now

1288
01:00:02,130 --> 01:00:07,320
all course tomorrow will be proxy it out

1289
01:00:03,660 --> 01:00:08,879
to whatever we want it to be so does

1290
01:00:07,320 --> 01:00:12,570
anybody have any suggestions where we go

1291
01:00:08,880 --> 01:00:14,160
from here what do we want to execute we

1292
01:00:12,570 --> 01:00:17,270
can go anywhere in Lib C anywhere the

1293
01:00:14,160 --> 01:00:22,350
binary name we want

1294
01:00:17,270 --> 01:00:23,700
well good option is always system for

1295
01:00:22,350 --> 01:00:25,740
those of you unfamiliar with it ellipses

1296
01:00:23,700 --> 01:00:28,770
system function takes a pointer to a

1297
01:00:25,740 --> 01:00:32,729
string and that string is treated as a

1298
01:00:28,770 --> 01:00:36,000
shell command so we can run a shell we

1299
01:00:32,730 --> 01:00:37,950
could run netcat reverse shell whenever

1300
01:00:36,000 --> 01:00:40,290
we wanted been cut flag if we were doing

1301
01:00:37,950 --> 01:00:42,560
a CTF so system is a really good option

1302
01:00:40,290 --> 01:00:45,870
this is it's kind of a CTF e choice but

1303
01:00:42,560 --> 01:00:48,240
that's what we're going to do so close

1304
01:00:45,870 --> 01:00:50,130
your gdb session and head back to your

1305
01:00:48,240 --> 01:00:55,979
script and replace hex dead beef with

1306
01:00:50,130 --> 01:00:58,350
Lib C sim dot system now when we run

1307
01:00:55,980 --> 01:01:00,690
this on the gdb Lib C dot sim lock

1308
01:00:58,350 --> 01:01:03,700
system

1309
01:01:00,690 --> 01:01:05,260
breaking in gdb with ctrl C and then

1310
01:01:03,700 --> 01:01:09,310
print underscore underscore mark

1311
01:01:05,260 --> 01:01:11,290
underscore hook shows us that now the

1312
01:01:09,310 --> 01:01:13,360
Malik hook holds the address of ellipses

1313
01:01:11,290 --> 01:01:14,770
system function so every quarter Malik

1314
01:01:13,360 --> 01:01:18,040
will be the equivalent of a call to

1315
01:01:14,770 --> 01:01:20,020
system which is great because system

1316
01:01:18,040 --> 01:01:22,540
takes a single argument and Malik takes

1317
01:01:20,020 --> 01:01:24,670
a single argument so we have to do now

1318
01:01:22,540 --> 01:01:26,350
is somehow pass the string we want to

1319
01:01:24,670 --> 01:01:27,970
execute or the string we want treat it

1320
01:01:26,350 --> 01:01:29,650
as a shell command which in our case we

1321
01:01:27,970 --> 01:01:35,620
want to drop a shell so slash bin slash

1322
01:01:29,650 --> 01:01:40,270
sure to Malik and it's just misses to

1323
01:01:35,620 --> 01:01:42,460
how we're gonna do that well there's a

1324
01:01:40,270 --> 01:01:44,890
couple of ways I'm a fan of using the

1325
01:01:42,460 --> 01:01:46,900
bin shoestrings already available in Lib

1326
01:01:44,890 --> 01:01:48,790
C well I didn't mention was how system

1327
01:01:46,900 --> 01:01:50,740
actually works is it Forks the process

1328
01:01:48,790 --> 01:01:53,470
and then executes the equivalent of xfv

1329
01:01:50,740 --> 01:01:55,689
bin sure to run us to run a sub shell

1330
01:01:53,470 --> 01:01:57,790
and then your command is executed within

1331
01:01:55,690 --> 01:02:01,240
that which means the string finisher

1332
01:01:57,790 --> 01:02:05,190
resides somewhere within Lib C so if we

1333
01:02:01,240 --> 01:02:08,080
send the address of that bin sure string

1334
01:02:05,190 --> 01:02:10,450
masquerading as a size field to Milaap

1335
01:02:08,080 --> 01:02:12,970
it will become the equivalent of instead

1336
01:02:10,450 --> 01:02:15,970
of malloc large size system pointer to

1337
01:02:12,970 --> 01:02:18,129
the string bin sure hopefully we'll get

1338
01:02:15,970 --> 01:02:20,410
a shell so if you head back to your

1339
01:02:18,130 --> 01:02:23,470
editor we're gonna make one more request

1340
01:02:20,410 --> 01:02:33,759
to malloc and you can't do this one

1341
01:02:23,470 --> 01:02:35,410
manually and in fact I tell alive the

1342
01:02:33,760 --> 01:02:41,100
malloc function is going to do things

1343
01:02:35,410 --> 01:02:45,640
like expect the data prompt and the the

1344
01:02:41,100 --> 01:02:47,140
sort of new line prompt here so poem

1345
01:02:45,640 --> 01:02:48,790
tools does have timeout

1346
01:02:47,140 --> 01:02:49,930
options on those functions but we're

1347
01:02:48,790 --> 01:02:51,940
just gonna get this done as quickly as

1348
01:02:49,930 --> 01:02:53,770
possible so instead of making a call to

1349
01:02:51,940 --> 01:02:55,960
malloc which will hang we're gonna use

1350
01:02:53,770 --> 01:02:57,580
IO dot send which just means send the

1351
01:02:55,960 --> 01:02:58,900
following string to the binary we're

1352
01:02:57,580 --> 01:03:00,910
gonna send a one to pick the malloc

1353
01:02:58,900 --> 01:03:02,890
option and then we're gonna use my o dot

1354
01:03:00,910 --> 01:03:05,200
send after and the first argument of

1355
01:03:02,890 --> 01:03:10,600
that is going to be the size prompt so

1356
01:03:05,200 --> 01:03:11,980
quotes sighs : space comma send after it

1357
01:03:10,600 --> 01:03:12,910
will wait for the size prompt and then

1358
01:03:11,980 --> 01:03:14,980
send what we

1359
01:03:12,910 --> 01:03:16,600
to reason we're using send after instead

1360
01:03:14,980 --> 01:03:18,670
of just another IO dot senders because I

1361
01:03:16,600 --> 01:03:19,990
can get a little bit enthusiastic send

1362
01:03:18,670 --> 01:03:22,360
these two lines straight back to back

1363
01:03:19,990 --> 01:03:23,439
and then the binary is not gonna be able

1364
01:03:22,360 --> 01:03:25,000
to tell the difference between our

1365
01:03:23,440 --> 01:03:27,270
inputs it's gonna think we tried to send

1366
01:03:25,000 --> 01:03:31,060
a very large menu option

1367
01:03:27,270 --> 01:03:32,890
so once we've set our size field we want

1368
01:03:31,060 --> 01:03:36,430
to send and you can wrap this next bit

1369
01:03:32,890 --> 01:03:41,140
in strut if you like or you can use a

1370
01:03:36,430 --> 01:03:43,810
Python height and format string like

1371
01:03:41,140 --> 01:03:49,470
this by the way we're gonna use Lib C

1372
01:03:43,810 --> 01:03:49,470
dot search and then the string finisher

1373
01:03:49,740 --> 01:03:56,439
if I can type and then you can either

1374
01:03:54,340 --> 01:03:57,820
tack a call to next on the end of that

1375
01:03:56,440 --> 01:04:00,250
or you can just wrap the whole Lib C dot

1376
01:03:57,820 --> 01:04:03,220
search in a in a quarter next to get

1377
01:04:00,250 --> 01:04:05,440
that next iterator all that's doing is

1378
01:04:03,220 --> 01:04:06,819
searching Lib C using pone tools for

1379
01:04:05,440 --> 01:04:08,530
that string bin share which as I said

1380
01:04:06,820 --> 01:04:10,120
occurs a couple of times in the live

1381
01:04:08,530 --> 01:04:12,130
scene naturally and since we've leaked

1382
01:04:10,120 --> 01:04:16,000
it we know it's address and then we're

1383
01:04:12,130 --> 01:04:18,010
gonna send that as a size field to mark

1384
01:04:16,000 --> 01:04:19,720
and since we've overwritten the system

1385
01:04:18,010 --> 01:04:21,730
since we've overwritten the malloc hook

1386
01:04:19,720 --> 01:04:25,029
with the address of system who should be

1387
01:04:21,730 --> 01:04:26,890
it should become system bin sure drop a

1388
01:04:25,030 --> 01:04:28,990
shell so let's cross our fingers and

1389
01:04:26,890 --> 01:04:34,450
we'll run this just on its own without

1390
01:04:28,990 --> 01:04:37,479
the gdb or no SLR options and it looks

1391
01:04:34,450 --> 01:04:50,620
like the Pinery is hanged but we have a

1392
01:04:37,480 --> 01:04:51,790
show easy we have another option any

1393
01:04:50,620 --> 01:04:54,009
other suggestions as to how we could

1394
01:04:51,790 --> 01:04:54,490
drop a shell will run a command that we

1395
01:04:54,010 --> 01:04:57,370
want

1396
01:04:54,490 --> 01:04:59,169
well we've leaped the heap and we can

1397
01:04:57,370 --> 01:05:01,060
write any data we want to the heap so

1398
01:04:59,170 --> 01:05:05,320
instead of finding that bin sure string

1399
01:05:01,060 --> 01:05:06,970
in Lib C we could instead of 24 bytes of

1400
01:05:05,320 --> 01:05:08,500
garbage when we make that first

1401
01:05:06,970 --> 01:05:10,419
requesting malloc we could write the

1402
01:05:08,500 --> 01:05:13,210
string bin sure there with a null

1403
01:05:10,420 --> 01:05:18,250
terminator and then instead of 24 bytes

1404
01:05:13,210 --> 01:05:22,200
just write 16 bytes of garbage and then

1405
01:05:18,250 --> 01:05:22,200
we can use my own ops send after

1406
01:05:22,539 --> 01:05:33,890
whoops to send the address of the heap

1407
01:05:29,229 --> 01:05:36,169
plus x10 which is you've dresses the

1408
01:05:33,890 --> 01:05:37,609
first quadword of user data of the chunk

1409
01:05:36,170 --> 01:05:40,099
that we requested at the very beginning

1410
01:05:37,609 --> 01:05:42,049
which has aa string bin sure and that

1411
01:05:40,099 --> 01:05:48,410
should also be an alternative way of

1412
01:05:42,049 --> 01:05:49,309
dropping a shell there we go and that's

1413
01:05:48,410 --> 01:05:52,399
all there is the drop in the show

1414
01:05:49,309 --> 01:05:54,559
without a force so to summarize we set

1415
01:05:52,400 --> 01:05:56,269
up our house 1/4 primitive and then this

1416
01:05:54,559 --> 01:05:57,920
time we used it to override the malloc

1417
01:05:56,269 --> 01:06:00,200
hook which allows us to redirect

1418
01:05:57,920 --> 01:06:01,849
execution every time malloc is called we

1419
01:06:00,200 --> 01:06:04,220
pointed the malloc hook at system so all

1420
01:06:01,849 --> 01:06:07,609
future calls to malloc became called the

1421
01:06:04,220 --> 01:06:10,488
system and then grab the address of the

1422
01:06:07,609 --> 01:06:13,819
string slash bin slash sure which

1423
01:06:10,489 --> 01:06:15,589
arrived which exists naturally in Lib C

1424
01:06:13,819 --> 01:06:17,660
or we could have written our own you

1425
01:06:15,589 --> 01:06:20,569
know neck hat reverse shell or pink a

1426
01:06:17,660 --> 01:06:22,489
flag etc command onto the heap and then

1427
01:06:20,569 --> 01:06:25,460
sent the address of one of those strings

1428
01:06:22,489 --> 01:06:29,450
to malloc masquerading as a size field

1429
01:06:25,460 --> 01:06:31,489
and that executed our command before we

1430
01:06:29,450 --> 01:06:33,410
wrap this up with our last shell are

1431
01:06:31,489 --> 01:06:46,279
there any questions on dropping a show

1432
01:06:33,410 --> 01:06:49,009
with a house of force all right again if

1433
01:06:46,279 --> 01:06:52,009
I'm moving too fast there is a dot pone

1434
01:06:49,009 --> 01:06:53,989
tool solution shell script in that

1435
01:06:52,009 --> 01:06:55,609
directory that will do exactly what we

1436
01:06:53,989 --> 01:06:57,200
just did with a bunch of comments so if

1437
01:06:55,609 --> 01:06:59,900
you want to revisit it later it should

1438
01:06:57,200 --> 01:07:03,410
be reasonably clear what's going on okay

1439
01:06:59,900 --> 01:07:05,660
last one navigate back to the fast bin

1440
01:07:03,410 --> 01:07:07,308
dupe directory and this time we're going

1441
01:07:05,660 --> 01:07:09,440
to drop a shell using that fast Bindu

1442
01:07:07,309 --> 01:07:11,950
technique once more make a copy of your

1443
01:07:09,440 --> 01:07:11,950
exploit

1444
01:07:14,110 --> 01:07:17,420
again if you weren't able to get that

1445
01:07:16,370 --> 01:07:19,750
work and you've got your pone to a

1446
01:07:17,420 --> 01:07:22,140
solution target script to use instead

1447
01:07:19,750 --> 01:07:25,219
open your copy in your editor of choice

1448
01:07:22,140 --> 01:07:25,219
[Applause]

1449
01:07:25,240 --> 01:07:29,029
this time we're going to delete

1450
01:07:26,900 --> 01:07:32,810
everything after those three calls to

1451
01:07:29,030 --> 01:07:34,880
free the script is still going to deal

1452
01:07:32,810 --> 01:07:37,190
with our username field it's going to

1453
01:07:34,880 --> 01:07:38,450
request to minimum size chunks the same

1454
01:07:37,190 --> 01:07:39,560
size and then it's going to free them

1455
01:07:38,450 --> 01:07:42,649
alternately so we've already got our

1456
01:07:39,560 --> 01:07:44,420
fast Bindu primitive set up and again

1457
01:07:42,650 --> 01:07:47,300
the question becomes what are we going

1458
01:07:44,420 --> 01:07:49,340
to overwrite with it so this time you

1459
01:07:47,300 --> 01:07:50,840
might as well try the free hook since

1460
01:07:49,340 --> 01:07:53,000
this is a full railroad binary as well

1461
01:07:50,840 --> 01:07:54,680
free hook if you can get to it or you

1462
01:07:53,000 --> 01:07:56,840
can use it is a much better option than

1463
01:07:54,680 --> 01:07:58,940
the Mallicoat typically because if you

1464
01:07:56,840 --> 01:08:01,160
overwriting the system freeing a chunk

1465
01:07:58,940 --> 01:08:03,140
is the equivalent of calling system with

1466
01:08:01,160 --> 01:08:05,509
a pointer when implicit pointer to your

1467
01:08:03,140 --> 01:08:06,980
user data so you can do just like we did

1468
01:08:05,510 --> 01:08:08,660
a moment ago with the with the house of

1469
01:08:06,980 --> 01:08:10,250
force technique but you don't need to

1470
01:08:08,660 --> 01:08:11,960
leave the heap because freeing that

1471
01:08:10,250 --> 01:08:16,609
chunk would have implicitly been a call

1472
01:08:11,960 --> 01:08:18,560
to system bin sure so how we did this

1473
01:08:16,609 --> 01:08:21,080
last time was we use the mallet wrapper

1474
01:08:18,560 --> 01:08:22,970
function to request eight bytes and this

1475
01:08:21,080 --> 01:08:25,939
was going to request our double freed

1476
01:08:22,970 --> 01:08:28,280
chunk back from the 2-0 fast bin and it

1477
01:08:25,939 --> 01:08:30,379
was going to overwrite its FD so that we

1478
01:08:28,279 --> 01:08:33,849
could link a fake chunk into the 2-0

1479
01:08:30,380 --> 01:08:36,200
fast bin and we want to link back 64

1480
01:08:33,850 --> 01:08:38,390
just like we did before Lib C dot sim

1481
01:08:36,200 --> 01:08:42,200
dot underscore underscore free

1482
01:08:38,390 --> 01:08:44,420
underscore hook and we want - hex one

1483
01:08:42,200 --> 01:08:45,979
zero on the end of that because in the

1484
01:08:44,420 --> 01:08:48,560
fast bin do we need to use Malik's

1485
01:08:45,979 --> 01:08:49,939
addresses so this way free hook will

1486
01:08:48,560 --> 01:08:56,360
become the first quad word of user data

1487
01:08:49,939 --> 01:08:58,009
of our fake chunk once you've got that

1488
01:08:56,359 --> 01:09:02,080
run this with gdb

1489
01:08:58,010 --> 01:09:02,080
with the gdb and know aslr options

1490
01:09:03,100 --> 01:09:15,020
control C whoops and we are going to use

1491
01:09:12,500 --> 01:09:17,750
the fast business command and as we've

1492
01:09:15,020 --> 01:09:20,810
expected we've linked some sort of Lib C

1493
01:09:17,750 --> 01:09:22,490
address into the 2-0 fast bin we can use

1494
01:09:20,810 --> 01:09:24,839
dump quod ampersand underscore

1495
01:09:22,490 --> 01:09:26,189
underscore free underscore hook too

1496
01:09:24,839 --> 01:09:28,680
a free hook which is this five eight

1497
01:09:26,189 --> 01:09:34,019
eight address here this quadword which

1498
01:09:28,680 --> 01:09:35,850
is null as we expect and again we can

1499
01:09:34,020 --> 01:09:38,819
append a minus two to that to introspect

1500
01:09:35,850 --> 01:09:40,080
a memory around the free hook and you

1501
01:09:38,819 --> 01:09:43,080
can see that we've linked in this five

1502
01:09:40,080 --> 01:09:46,519
hex five seven eight address to the to

1503
01:09:43,080 --> 01:09:51,000
zero fast bin does anybody see a problem

1504
01:09:46,520 --> 01:09:53,730
with this technique burn in mind what we

1505
01:09:51,000 --> 01:09:56,610
had to do to actually allow malloc to

1506
01:09:53,729 --> 01:10:03,089
allocate a chunk here what's missing

1507
01:09:56,610 --> 01:10:06,120
from this cord words yeah like the size

1508
01:10:03,090 --> 01:10:08,010
field we need to coerce a size field

1509
01:10:06,120 --> 01:10:10,470
into this value here now last time we

1510
01:10:08,010 --> 01:10:13,140
did that by having the fortunate having

1511
01:10:10,470 --> 01:10:15,270
the luck to have control over that data

1512
01:10:13,140 --> 01:10:18,570
right before the target data we wanted

1513
01:10:15,270 --> 01:10:21,240
to control but in this case this or this

1514
01:10:18,570 --> 01:10:24,420
data resides in Lipsey's data section

1515
01:10:21,240 --> 01:10:27,480
which means we can control little to

1516
01:10:24,420 --> 01:10:29,490
none of it but remember that we can

1517
01:10:27,480 --> 01:10:31,769
allocate fake chunks up to hex eight

1518
01:10:29,490 --> 01:10:34,170
zero size in this binary so if you

1519
01:10:31,770 --> 01:10:37,080
scroll back sixteen bytes and then print

1520
01:10:34,170 --> 01:10:40,140
18 sorry 16 quadwords and then print 18

1521
01:10:37,080 --> 01:10:44,430
of them that five eight eight address is

1522
01:10:40,140 --> 01:10:47,160
where the free hook resides down here

1523
01:10:44,430 --> 01:10:50,400
and this is as far back as we can get an

1524
01:10:47,160 --> 01:10:52,500
eight zero chunk sized and it's nulls

1525
01:10:50,400 --> 01:10:54,179
all the way down unfortunately and

1526
01:10:52,500 --> 01:10:56,790
there's nothing we can do about this at

1527
01:10:54,180 --> 01:10:58,560
least not right now so let's have a look

1528
01:10:56,790 --> 01:11:02,250
at the malloc hook if you do that same

1529
01:10:58,560 --> 01:11:04,080
command let's swap out free with malloc

1530
01:11:02,250 --> 01:11:07,080
so malloc let's go hook minus sixteen

1531
01:11:04,080 --> 01:11:08,760
eighty like that the Mallicoat resides

1532
01:11:07,080 --> 01:11:10,110
here at this Charlie one zero address

1533
01:11:08,760 --> 01:11:12,390
and we can see that there's a little

1534
01:11:10,110 --> 01:11:15,000
more to it this time but nothing is

1535
01:11:12,390 --> 01:11:17,850
useful as a naturally occurring perfect

1536
01:11:15,000 --> 01:11:21,120
8-0 size field up here or like a 4 0

1537
01:11:17,850 --> 01:11:23,130
here anything like that sadly but there

1538
01:11:21,120 --> 01:11:25,860
are some more values and these are

1539
01:11:23,130 --> 01:11:28,770
reasonably consistent values this value

1540
01:11:25,860 --> 01:11:33,349
right here this value here is the

1541
01:11:28,770 --> 01:11:36,270
standard in Io wide data V table pointer

1542
01:11:33,350 --> 01:11:37,440
and standard in is really hard to get

1543
01:11:36,270 --> 01:11:38,550
read on even if the first thing with

1544
01:11:37,440 --> 01:11:40,889
this binary did

1545
01:11:38,550 --> 01:11:42,870
was closed standard in and there was

1546
01:11:40,890 --> 01:11:44,340
never any data read on standard in it

1547
01:11:42,870 --> 01:11:46,320
never anything printed out and standard

1548
01:11:44,340 --> 01:11:48,180
out all the standard ins all standard

1549
01:11:46,320 --> 01:11:51,240
i/o infrastructure still exists very

1550
01:11:48,180 --> 01:11:54,930
reliable things have this quad word here

1551
01:11:51,240 --> 01:11:56,639
is a padding quad word and these I

1552
01:11:54,930 --> 01:11:59,610
believe are the memo line hook and the

1553
01:11:56,640 --> 01:12:03,650
realloc hook so they may or may not be

1554
01:11:59,610 --> 01:12:03,650
the values that we see here now

1555
01:12:04,280 --> 01:12:08,040
unfortunately there's no naturally

1556
01:12:06,240 --> 01:12:10,110
occurring size fields but it turns out

1557
01:12:08,040 --> 01:12:12,030
malloc make some assumptions about the

1558
01:12:10,110 --> 01:12:15,089
chunks it's allocating at least from the

1559
01:12:12,030 --> 01:12:17,219
fast bins the free function will ensure

1560
01:12:15,090 --> 01:12:19,800
that any any chunk that you pass to it

1561
01:12:17,220 --> 01:12:22,410
is 16 by aligned and therefore malloc

1562
01:12:19,800 --> 01:12:25,500
has no reason to check the alignment of

1563
01:12:22,410 --> 01:12:27,750
chunks that it's allocating so that

1564
01:12:25,500 --> 01:12:30,600
gives us a kind of scrolling window into

1565
01:12:27,750 --> 01:12:33,600
this data here that we might be able to

1566
01:12:30,600 --> 01:12:36,690
coerce a chunk size field out of now

1567
01:12:33,600 --> 01:12:38,970
these are all subject to a SLR but a SLR

1568
01:12:36,690 --> 01:12:43,139
doesn't affect every single bit of every

1569
01:12:38,970 --> 01:12:45,570
address for example the low order 12

1570
01:12:43,140 --> 01:12:47,040
bits of every address won't be subject

1571
01:12:45,570 --> 01:12:50,429
to a SLR because their salat only works

1572
01:12:47,040 --> 01:12:53,070
at a page granularity also on x86 and

1573
01:12:50,430 --> 01:12:55,770
Linux in most UNIX systems the top they

1574
01:12:53,070 --> 01:12:57,210
the three most significant bytes will be

1575
01:12:55,770 --> 01:12:59,550
0 0 0 0

1576
01:12:57,210 --> 01:13:01,410
7f if you have a MacBook you can open a

1577
01:12:59,550 --> 01:13:03,780
terminal and type VM map dollar sign

1578
01:13:01,410 --> 01:13:05,220
dollar sign and that will print out the

1579
01:13:03,780 --> 01:13:07,290
virtual memory map of the process you're

1580
01:13:05,220 --> 01:13:08,880
using right now and you'll see under all

1581
01:13:07,290 --> 01:13:10,590
of the lock or all the libraries are

1582
01:13:08,880 --> 01:13:13,890
loaded at the 0 0 0 0

1583
01:13:10,590 --> 01:13:17,640
7f addresses so these bytes are

1584
01:13:13,890 --> 01:13:21,110
constants in Linux at least so if we

1585
01:13:17,640 --> 01:13:24,420
scrolled back from the Mallo cook here

1586
01:13:21,110 --> 01:13:28,259
hex to 0 bytes to here and then another

1587
01:13:24,420 --> 01:13:36,200
3 bytes would capture the three most

1588
01:13:28,260 --> 01:13:40,050
significant bytes of this value here

1589
01:13:36,200 --> 01:13:42,870
followed by the 5 least significant

1590
01:13:40,050 --> 01:13:44,820
bytes of that standard in vtable points

1591
01:13:42,870 --> 01:13:47,390
which as I said will almost certainly

1592
01:13:44,820 --> 01:13:49,950
occur in your C program or C++ program

1593
01:13:47,390 --> 01:13:52,020
then the next chord word that forms the

1594
01:13:49,950 --> 01:13:54,980
size field or that forms

1595
01:13:52,020 --> 01:13:59,570
I filled in this alignment we'll have

1596
01:13:54,980 --> 01:14:04,769
five nulls from the low water bytes here

1597
01:13:59,570 --> 01:14:05,969
followed by nominal 7f so we can test

1598
01:14:04,770 --> 01:14:08,220
that we can dump quads

1599
01:14:05,970 --> 01:14:10,410
Amsterdam Suns Malik hook in fact I tell

1600
01:14:08,220 --> 01:14:14,040
you what it's easier to do dump quad 0x

1601
01:14:10,410 --> 01:14:15,420
and then use the Malik Malik hook

1602
01:14:14,040 --> 01:14:18,269
address we don't have to cast it as a

1603
01:14:15,420 --> 01:14:21,540
car or anything mad like that - hex -

1604
01:14:18,270 --> 01:14:23,880
three and we can see that because the

1605
01:14:21,540 --> 01:14:27,330
little endian nature the system we can

1606
01:14:23,880 --> 01:14:30,180
coerce a reliable 7f size field out of

1607
01:14:27,330 --> 01:14:31,230
this now we haven't seen 7f as a size

1608
01:14:30,180 --> 01:14:33,480
field and that's because it will never

1609
01:14:31,230 --> 01:14:35,070
naturally or occur that forth that

1610
01:14:33,480 --> 01:14:37,500
fourthly significant bit isn't used for

1611
01:14:35,070 --> 01:14:39,660
anything and those flags don't make any

1612
01:14:37,500 --> 01:14:41,160
sense but again Malik make some

1613
01:14:39,660 --> 01:14:43,590
assumptions about the state of the

1614
01:14:41,160 --> 01:14:44,910
chunks that it's allocating and we can

1615
01:14:43,590 --> 01:14:46,770
mess with these flags quite a lot

1616
01:14:44,910 --> 01:14:50,010
because they ain't gonna checkin we can

1617
01:14:46,770 --> 01:14:52,560
have seven zero seven one seven two the

1618
01:14:50,010 --> 01:14:54,510
only thing we can't have is the third

1619
01:14:52,560 --> 01:14:57,780
least significant bit which represents

1620
01:14:54,510 --> 01:15:00,450
the non main arena chunk or non main

1621
01:14:57,780 --> 01:15:02,700
arena flag without the second least

1622
01:15:00,450 --> 01:15:05,309
significant bit which represents the is

1623
01:15:02,700 --> 01:15:07,230
then mapped it without thinking too much

1624
01:15:05,310 --> 01:15:09,360
into what they are basically if you have

1625
01:15:07,230 --> 01:15:11,250
the non main arena flag set on a chunk

1626
01:15:09,360 --> 01:15:14,339
Malik will go looking for a non-existent

1627
01:15:11,250 --> 01:15:16,260
arena and your segfault unless you have

1628
01:15:14,340 --> 01:15:17,760
that is m mapped flag set in which case

1629
01:15:16,260 --> 01:15:20,010
it'll ignore it and it won't go looking

1630
01:15:17,760 --> 01:15:21,870
for it so you can't have five for

1631
01:15:20,010 --> 01:15:25,020
example but you can have six and seven

1632
01:15:21,870 --> 01:15:30,120
and seven F it turns out works just fine

1633
01:15:25,020 --> 01:15:32,340
as a 7-0 chunk size so if we go back to

1634
01:15:30,120 --> 01:15:34,050
our script and instead of minimum size

1635
01:15:32,340 --> 01:15:36,480
chunks we're gonna start requesting

1636
01:15:34,050 --> 01:15:37,740
seven zero size chunks easiest way to do

1637
01:15:36,480 --> 01:15:39,480
that is to get the chunk size you want

1638
01:15:37,740 --> 01:15:43,110
and take eight off of it so hex six

1639
01:15:39,480 --> 01:15:46,379
eight it's going to give us the maximum

1640
01:15:43,110 --> 01:15:48,089
user data for a seven zero size chunk so

1641
01:15:46,380 --> 01:15:50,580
change those first two request to malloc

1642
01:15:48,090 --> 01:15:51,780
to request hex six eight bytes you can

1643
01:15:50,580 --> 01:15:55,769
share you can keep the data that you've

1644
01:15:51,780 --> 01:15:58,290
sent and then once it's freed make sure

1645
01:15:55,770 --> 01:16:00,390
that the chunk that we request to

1646
01:15:58,290 --> 01:16:02,670
overwrite the free hook with is also a

1647
01:16:00,390 --> 01:16:04,940
hex six eight or hex seven zero size

1648
01:16:02,670 --> 01:16:04,940
chunk

1649
01:16:13,140 --> 01:16:16,270
[Music]

1650
01:16:17,470 --> 01:16:27,800
once you've done that we're now under

1651
01:16:20,900 --> 01:16:29,750
gdb control-c to break and the fast bins

1652
01:16:27,800 --> 01:16:34,250
command it's going to show us what we've

1653
01:16:29,750 --> 01:16:37,250
linked in and what I've forgotten to do

1654
01:16:34,250 --> 01:16:41,090
is change this value here we want Lib C

1655
01:16:37,250 --> 01:16:43,520
we want Lib C dot sim dot malloc hook

1656
01:16:41,090 --> 01:16:46,940
sorry because we want to change that out

1657
01:16:43,520 --> 01:16:49,820
from the free hook and we want - hex to

1658
01:16:46,940 --> 01:16:51,950
3 this time so we're gonna write the

1659
01:16:49,820 --> 01:16:56,150
address of mullah kook - hex - 3 and

1660
01:16:51,950 --> 01:16:59,179
I've got break there as well once you've

1661
01:16:56,150 --> 01:17:08,330
made that adjustment run it with gdb

1662
01:16:59,180 --> 01:17:10,700
control C and now if you capture their

1663
01:17:08,330 --> 01:17:13,370
address that we've linked in to the 7 0

1664
01:17:10,700 --> 01:17:17,330
fast bin now and use that dump quad

1665
01:17:13,370 --> 01:17:19,519
command we can see that that's set off a

1666
01:17:17,330 --> 01:17:21,410
7 F size for your des nice sleeve you

1667
01:17:19,520 --> 01:17:23,090
can take off the no ASLR option and run

1668
01:17:21,410 --> 01:17:26,570
this all you want and that 7 F size for

1669
01:17:23,090 --> 01:17:29,030
you will stay constant so now what we

1670
01:17:26,570 --> 01:17:31,910
want to do is simply allocate out those

1671
01:17:29,030 --> 01:17:33,889
two other chunks that we had so chunk 0

1672
01:17:31,910 --> 01:17:38,599
and 1 and chug 0 as we called them

1673
01:17:33,890 --> 01:17:43,850
earlier on little bit like this so 2

1674
01:17:38,600 --> 01:17:50,840
more requests and then the next chunk we

1675
01:17:43,850 --> 01:17:52,700
request and you can copy did the request

1676
01:17:50,840 --> 01:18:00,080
for hex six eight stars bytes from

1677
01:17:52,700 --> 01:18:02,540
earlier now sets us up so that the next

1678
01:18:00,080 --> 01:18:08,100
7 0 size chunk we request is going to

1679
01:18:02,540 --> 01:18:11,320
overlap the malloc hook so

1680
01:18:08,100 --> 01:18:14,170
let's make that overlap work for us

1681
01:18:11,320 --> 01:18:17,139
we're gonna request another six eight

1682
01:18:14,170 --> 01:18:22,810
bytes of user data and do just like we

1683
01:18:17,140 --> 01:18:28,720
did before pack 64 Lib C dot sim dot

1684
01:18:22,810 --> 01:18:30,280
system I'm gonna remove the new SLR

1685
01:18:28,720 --> 01:18:33,780
option from my command line to make sure

1686
01:18:30,280 --> 01:18:36,460
this works in a production environment

1687
01:18:33,780 --> 01:18:39,280
once you've written the address of

1688
01:18:36,460 --> 01:18:44,290
system over the model cook and that

1689
01:18:39,280 --> 01:18:50,740
isn't gonna work is it need to write hex

1690
01:18:44,290 --> 01:18:53,560
1 3 bytes of garbage to catch up to the

1691
01:18:50,740 --> 01:18:55,240
malloc hook only mind that those 1 3

1692
01:18:53,560 --> 01:18:57,910
bytes of garbage are going to overwrite

1693
01:18:55,240 --> 01:18:59,769
the memo line and the realloc hook that

1694
01:18:57,910 --> 01:19:01,000
we saw earlier on so you've got to start

1695
01:18:59,770 --> 01:19:02,200
being careful at this stage of the game

1696
01:19:01,000 --> 01:19:05,470
we're not going to trigger either of

1697
01:19:02,200 --> 01:19:07,389
those but functions like printf can end

1698
01:19:05,470 --> 01:19:10,360
up triggering realloc when they resize

1699
01:19:07,390 --> 01:19:11,980
buffers so once you've done this either

1700
01:19:10,360 --> 01:19:14,230
you managed to write nulls to those

1701
01:19:11,980 --> 01:19:15,610
addresses or you start being very

1702
01:19:14,230 --> 01:19:17,769
careful as to what kind of functions you

1703
01:19:15,610 --> 01:19:23,769
call once you've done that run it with

1704
01:19:17,770 --> 01:19:28,570
the GDP option break and we're just

1705
01:19:23,770 --> 01:19:31,300
gonna print underscore underscore mark

1706
01:19:28,570 --> 01:19:33,280
underscore hook and now we can see that

1707
01:19:31,300 --> 01:19:34,630
we've once again managed to write over

1708
01:19:33,280 --> 01:19:38,889
at the malloc hook with the address of

1709
01:19:34,630 --> 01:19:40,720
system unfortunately we can't do what we

1710
01:19:38,890 --> 01:19:43,450
did last time we were able to were able

1711
01:19:40,720 --> 01:19:45,220
to send arbitrarily large requests to

1712
01:19:43,450 --> 01:19:47,320
malloc before but if you recall this

1713
01:19:45,220 --> 01:19:48,970
time we're limited to 120 bytes and

1714
01:19:47,320 --> 01:19:52,299
that's not a useable address that we can

1715
01:19:48,970 --> 01:19:54,430
stick in there so does anybody have any

1716
01:19:52,300 --> 01:20:03,370
suggestions as to how we're gonna crack

1717
01:19:54,430 --> 01:20:06,760
this final step and drop a shell what we

1718
01:20:03,370 --> 01:20:08,380
could use or one gadget for those of you

1719
01:20:06,760 --> 01:20:10,480
unfamiliar with one gadgets they're just

1720
01:20:08,380 --> 01:20:13,090
pieces of code that exists in Lib C

1721
01:20:10,480 --> 01:20:15,849
naturally they do the equivalent of XXV

1722
01:20:13,090 --> 01:20:19,520
bin sure I mentioned that what system

1723
01:20:15,850 --> 01:20:23,950
did was fork run exag ve bin sure

1724
01:20:19,520 --> 01:20:28,250
but and then in that subshell run your

1725
01:20:23,950 --> 01:20:30,740
command so the string X so the the code

1726
01:20:28,250 --> 01:20:34,640
sorry exactly you've been sure exists in

1727
01:20:30,740 --> 01:20:36,320
Lib C and a chap called David 942 J

1728
01:20:34,640 --> 01:20:39,710
who's written a really good one gadget

1729
01:20:36,320 --> 01:20:41,929
finder it's called one underscore

1730
01:20:39,710 --> 01:20:43,100
gadgets the Ruby finder there is a

1731
01:20:41,930 --> 01:20:44,960
Python version out there that wasn't

1732
01:20:43,100 --> 01:20:48,050
written by him it ain't very good use

1733
01:20:44,960 --> 01:20:49,700
David 940 to J's Ruby one gadget find

1734
01:20:48,050 --> 01:20:51,020
out what we have to do is and you guys

1735
01:20:49,700 --> 01:20:52,340
don't need to copy this but if you don't

1736
01:20:51,020 --> 01:20:57,530
want to because this path is a little

1737
01:20:52,340 --> 01:20:59,420
bit obscure but we're gonna point the

1738
01:20:57,530 --> 01:21:02,150
one gadget finder at the version of Lib

1739
01:20:59,420 --> 01:21:04,280
C that we're using for this example and

1740
01:21:02,150 --> 01:21:07,250
what it will do is print out the offset

1741
01:21:04,280 --> 01:21:10,580
of every equivalent of exit ve been sure

1742
01:21:07,250 --> 01:21:14,270
it finds in Lib C and then it will print

1743
01:21:10,580 --> 01:21:15,860
the constraints as well and what you can

1744
01:21:14,270 --> 01:21:18,290
do is tell this tell the one gadget

1745
01:21:15,860 --> 01:21:21,469
finder to run your script and try every

1746
01:21:18,290 --> 01:21:22,880
single one of these offsets one by one

1747
01:21:21,470 --> 01:21:24,920
until it finds one that works

1748
01:21:22,880 --> 01:21:27,530
save us doing that I can tell you that

1749
01:21:24,920 --> 01:21:29,690
this last one at the bottom here hex III

1750
01:21:27,530 --> 01:21:31,250
AAA B is the offset of a function of one

1751
01:21:29,690 --> 01:21:32,690
gadget that's going to work with the

1752
01:21:31,250 --> 01:21:34,760
constraints that we have that the stack

1753
01:21:32,690 --> 01:21:36,379
pointer plus hex five-o will be null

1754
01:21:34,760 --> 01:21:39,560
which it always will be by the time we

1755
01:21:36,380 --> 01:21:41,930
get to hittin this gadget so if you go

1756
01:21:39,560 --> 01:21:49,880
back to your editors and instead of Lib

1757
01:21:41,930 --> 01:21:56,720
C dot symbol system we want Lib C dot

1758
01:21:49,880 --> 01:22:05,510
address plus hex III a a B should be the

1759
01:21:56,720 --> 01:22:07,310
address of the one gadget so now we set

1760
01:22:05,510 --> 01:22:09,770
up to proxy or future course of malloc

1761
01:22:07,310 --> 01:22:14,240
to piece of code in Lib C that should

1762
01:22:09,770 --> 01:22:15,920
run the equivalent of XXV bin sure so if

1763
01:22:14,240 --> 01:22:19,670
you run this script again without gdb

1764
01:22:15,920 --> 01:22:21,320
this time so we've got SLR the binary

1765
01:22:19,670 --> 01:22:23,300
should just work as none but the malloc

1766
01:22:21,320 --> 01:22:26,150
hooks been overwritten so if we request

1767
01:22:23,300 --> 01:22:29,660
a chunk of any size it looks like the

1768
01:22:26,150 --> 01:22:31,099
binary is hanged but once again we get a

1769
01:22:29,660 --> 01:22:33,849
shell out of it is that one gadget

1770
01:22:31,100 --> 01:22:33,850
execute

1771
01:22:34,110 --> 01:22:38,620
and that's all there is to drop in

1772
01:22:36,330 --> 01:22:42,490
dropping a shell with the fast Bindu

1773
01:22:38,620 --> 01:22:45,280
technique in summary we double free to

1774
01:22:42,490 --> 01:22:48,010
hex seven zero so I chunk this time by

1775
01:22:45,280 --> 01:22:50,370
dodging the fast bins double free check

1776
01:22:48,010 --> 01:22:52,840
my friend another chunk in between and

1777
01:22:50,370 --> 01:22:54,430
then we over out the FD of one of those

1778
01:22:52,840 --> 01:22:55,720
chunks by requesting it back to us so we

1779
01:22:54,430 --> 01:22:57,700
could legitimately override its user

1780
01:22:55,720 --> 01:23:00,490
data we override the FD of that chunk

1781
01:22:57,700 --> 01:23:02,760
with a pointer to an address just below

1782
01:23:00,490 --> 01:23:05,800
the Mallik hook where we can coerce by

1783
01:23:02,760 --> 01:23:08,500
slightly misaligning our chunk which

1784
01:23:05,800 --> 01:23:10,690
Malik's gonna let us do a reliable 7 F

1785
01:23:08,500 --> 01:23:11,920
size field because malloc has a bit

1786
01:23:10,690 --> 01:23:14,410
slopping the numbers that it allows us

1787
01:23:11,920 --> 01:23:16,540
size fields we can allocate another

1788
01:23:14,410 --> 01:23:18,220
seven zero size chunk there and use that

1789
01:23:16,540 --> 01:23:20,410
to override the malloc hook with the

1790
01:23:18,220 --> 01:23:21,520
address of a one gadget and then every

1791
01:23:20,410 --> 01:23:23,080
call we made to malloc was the

1792
01:23:21,520 --> 01:23:27,550
equivalent of x8v

1793
01:23:23,080 --> 01:23:28,870
bin sure before we wrap things up are

1794
01:23:27,550 --> 01:23:45,010
there any questions on dropping the show

1795
01:23:28,870 --> 01:23:46,390
with the fast Bindu technique yeah

1796
01:23:45,010 --> 01:23:47,830
essentially you want speed write this in

1797
01:23:46,390 --> 01:23:50,860
memory allocator and as I said it's used

1798
01:23:47,830 --> 01:23:52,180
with everything so a lot of what a lot

1799
01:23:50,860 --> 01:23:53,830
of the malloc maintenance stuff there's

1800
01:23:52,180 --> 01:23:57,400
essentially Florian Verma who helps

1801
01:23:53,830 --> 01:23:59,019
maintain malach in glib c he does the

1802
01:23:57,400 --> 01:24:01,299
security stuff everyone have tries to

1803
01:23:59,020 --> 01:24:03,430
make it faster and yeah you so you could

1804
01:24:01,300 --> 01:24:05,590
hide it's the classic security speed

1805
01:24:03,430 --> 01:24:07,240
trade-off essentially so yeah they the

1806
01:24:05,590 --> 01:24:09,520
assumption is that for example the

1807
01:24:07,240 --> 01:24:11,320
alignment has been done by free there

1808
01:24:09,520 --> 01:24:12,940
should never be a scenario whereby a

1809
01:24:11,320 --> 01:24:15,070
chunk has gotten into the fast bins

1810
01:24:12,940 --> 01:24:17,259
without it being free legitimately by

1811
01:24:15,070 --> 01:24:18,849
the free function and therefore having a

1812
01:24:17,260 --> 01:24:21,010
sensible size field because the free

1813
01:24:18,850 --> 01:24:26,830
checks are much more fast idiots than

1814
01:24:21,010 --> 01:24:30,510
the malloc checks so now this is just C

1815
01:24:26,830 --> 01:24:32,980
code right so yeah the the one gadget is

1816
01:24:30,510 --> 01:24:35,530
live C dependent and everything else

1817
01:24:32,980 --> 01:24:37,809
we've done is manipulating a higher

1818
01:24:35,530 --> 01:24:39,519
level concept of how how the malloc

1819
01:24:37,810 --> 01:24:41,630
engine works essentially yes so this is

1820
01:24:39,520 --> 01:24:45,050
all just just C code

1821
01:24:41,630 --> 01:24:47,120
essentially all right well I've just got

1822
01:24:45,050 --> 01:24:48,710
a couple of words on like relevance and

1823
01:24:47,120 --> 01:24:50,840
then I suppose we can wrap it up we are

1824
01:24:48,710 --> 01:24:54,260
a little bit early but it's also very

1825
01:24:50,840 --> 01:24:55,520
warm in here so if you weren't able to

1826
01:24:54,260 --> 01:24:57,230
get that working because I went a little

1827
01:24:55,520 --> 01:25:00,260
bit fast again there is a dot poem to a

1828
01:24:57,230 --> 01:25:02,120
solution shell script there so that you

1829
01:25:00,260 --> 01:25:03,620
can check that out later whether it does

1830
01:25:02,120 --> 01:25:07,849
exactly what we did again but with a

1831
01:25:03,620 --> 01:25:09,019
bunch of comments and yeah the

1832
01:25:07,850 --> 01:25:11,540
eagle-eyed of you will have noticed that

1833
01:25:09,020 --> 01:25:14,090
the versions of clip see that we were

1834
01:25:11,540 --> 01:25:16,910
using today were 2.28 and 2.29 which is

1835
01:25:14,090 --> 01:25:19,010
the two latest versions 2.2 2.3 oh

1836
01:25:16,910 --> 01:25:22,700
dropped last month but it's not in

1837
01:25:19,010 --> 01:25:24,830
circulation yet we've run to 1804 uses

1838
01:25:22,700 --> 01:25:28,610
Ubuntu 1804 long term support is using

1839
01:25:24,830 --> 01:25:31,430
2.27 most stuff is behind that I think

1840
01:25:28,610 --> 01:25:33,500
1904 is using 2.29 we were using 2.28

1841
01:25:31,430 --> 01:25:35,060
and 2.29 they had a small modification

1842
01:25:33,500 --> 01:25:38,510
which removed something called the T

1843
01:25:35,060 --> 01:25:40,730
cash from malloc and the T cash is an

1844
01:25:38,510 --> 01:25:43,360
attempt at the groups by the Glebe see

1845
01:25:40,730 --> 01:25:46,910
maintain is to catch malloc up too fast

1846
01:25:43,360 --> 01:25:49,040
implementations like J mark and it is

1847
01:25:46,910 --> 01:25:50,809
essentially the fast bins but without

1848
01:25:49,040 --> 01:25:52,490
any protections the reason I remove the

1849
01:25:50,810 --> 01:25:54,080
T cache from these versions ellipses

1850
01:25:52,490 --> 01:25:55,219
because it would be pointless teaching

1851
01:25:54,080 --> 01:25:57,380
it because it's so easy

1852
01:25:55,220 --> 01:26:00,020
keep exploitation now is easier than

1853
01:25:57,380 --> 01:26:02,930
what I'm teaching here but like I said T

1854
01:26:00,020 --> 01:26:05,270
cache bins are you can double free @ e

1855
01:26:02,930 --> 01:26:07,970
cache bin without the double free check

1856
01:26:05,270 --> 01:26:10,220
and without the size check even in 2.29

1857
01:26:07,970 --> 01:26:12,140
that implemented a site a double free

1858
01:26:10,220 --> 01:26:15,860
check for the T cache it's still just as

1859
01:26:12,140 --> 01:26:17,750
easily bypassed here clip c2 locks u9

1860
01:26:15,860 --> 01:26:19,940
implemented a check that does mitigate

1861
01:26:17,750 --> 01:26:22,580
our first technique the house of force

1862
01:26:19,940 --> 01:26:24,440
239 was released late last year like I

1863
01:26:22,580 --> 01:26:26,510
said it's not really in circulation on

1864
01:26:24,440 --> 01:26:28,059
many of the common distros yet certainly

1865
01:26:26,510 --> 01:26:30,140
none the long-term support distros and

1866
01:26:28,060 --> 01:26:32,210
the house of force was original point

1867
01:26:30,140 --> 01:26:34,340
about 15 years ago so has only taken

1868
01:26:32,210 --> 01:26:36,410
them 15 years to fix that little bug and

1869
01:26:34,340 --> 01:26:39,260
do a one-line check against how much

1870
01:26:36,410 --> 01:26:40,880
memory the top chunk should have so

1871
01:26:39,260 --> 01:26:43,820
there's all kinds of mess going on clip

1872
01:26:40,880 --> 01:26:45,620
see even though compared to other Lib C

1873
01:26:43,820 --> 01:26:47,450
implement other malloc implementations

1874
01:26:45,620 --> 01:26:50,510
like Bionic from Android and Lib

1875
01:26:47,450 --> 01:26:52,170
standard for are for OSX it's the best

1876
01:26:50,510 --> 01:26:54,630
protected one

1877
01:26:52,170 --> 01:26:56,910
I think muscle is the least protected

1878
01:26:54,630 --> 01:26:58,440
like it's a very simple version but even

1879
01:26:56,910 --> 01:27:01,800
even with glitzy being generally like

1880
01:26:58,440 --> 01:27:04,830
one of the more protected heap

1881
01:27:01,800 --> 01:27:13,590
implementations it's still vulnerable in

1882
01:27:04,830 --> 01:27:17,130
its latest versions yes sorry I have no

1883
01:27:13,590 --> 01:27:22,650
thoughts on you seal obscene that's

1884
01:27:17,130 --> 01:27:24,300
something I need to check out but who'd

1885
01:27:22,650 --> 01:27:30,719
be like muscle okay yeah is it is one

1886
01:27:24,300 --> 01:27:34,410
like the fast sort of yeah I need to

1887
01:27:30,720 --> 01:27:36,810
look into that yeah I think lastly the

1888
01:27:34,410 --> 01:27:38,910
reason it's it's easy to think that we

1889
01:27:36,810 --> 01:27:40,350
see less heap exploitation than we do

1890
01:27:38,910 --> 01:27:43,920
other memory corruption exploitation

1891
01:27:40,350 --> 01:27:45,120
like stack exploitation for example and

1892
01:27:43,920 --> 01:27:47,010
I think the reason for that is twofold

1893
01:27:45,120 --> 01:27:48,000
if your starts today we've seen that we

1894
01:27:47,010 --> 01:27:49,620
can corrupt the heap in at least a

1895
01:27:48,000 --> 01:27:52,170
couple of ways overflows just like the

1896
01:27:49,620 --> 01:27:53,780
stack but we also have double freeze and

1897
01:27:52,170 --> 01:27:56,100
use after freeze which we didn't cover

1898
01:27:53,780 --> 01:27:58,950
so there are more ways to corrupt the

1899
01:27:56,100 --> 01:28:00,960
heap then there are the stack and the

1900
01:27:58,950 --> 01:28:04,889
heap is just as widely used as the stack

1901
01:28:00,960 --> 01:28:06,690
and I think the reason that so there's

1902
01:28:04,890 --> 01:28:09,140
no reason for there to be any less heat

1903
01:28:06,690 --> 01:28:10,919
bugs out there then say stack bugs I

1904
01:28:09,140 --> 01:28:12,510
think the reason we see less

1905
01:28:10,920 --> 01:28:13,740
exploitation is twofold the first is

1906
01:28:12,510 --> 01:28:18,060
that heat bugs are a little more

1907
01:28:13,740 --> 01:28:21,420
insidious than stack bugs so corrupting

1908
01:28:18,060 --> 01:28:25,290
stack metadata like save return pointers

1909
01:28:21,420 --> 01:28:27,570
or Canaries will almost certainly get

1910
01:28:25,290 --> 01:28:30,870
you a segfault honorable or an abort but

1911
01:28:27,570 --> 01:28:33,000
you can corrupt Lib C malloc metadata

1912
01:28:30,870 --> 01:28:34,650
for a free chunk unless that Chum gets

1913
01:28:33,000 --> 01:28:37,200
allocated back by the end of the program

1914
01:28:34,650 --> 01:28:39,570
you won't see a crash you won't see in a

1915
01:28:37,200 --> 01:28:42,059
ball so unless you are using like the

1916
01:28:39,570 --> 01:28:43,920
debug key for example heat bugs can be a

1917
01:28:42,060 --> 01:28:45,720
lot harder to find even if you're

1918
01:28:43,920 --> 01:28:49,170
fuzzing because you might just not

1919
01:28:45,720 --> 01:28:50,490
allocate a corrupted chunk of back so I

1920
01:28:49,170 --> 01:28:51,990
think they're just a little harder to

1921
01:28:50,490 --> 01:28:53,910
find this in the stack corruption stuff

1922
01:28:51,990 --> 01:28:55,620
and also I just think heap exploitation

1923
01:28:53,910 --> 01:28:57,389
isn't as well understood in the

1924
01:28:55,620 --> 01:28:59,160
community that's why I like to do this

1925
01:28:57,390 --> 01:29:00,420
stuff I think we've got a conference

1926
01:28:59,160 --> 01:29:02,670
with people who could probably talk to

1927
01:29:00,420 --> 01:29:04,860
you about how to have leveraged stack

1928
01:29:02,670 --> 01:29:05,709
corruption for exploitation and about

1929
01:29:04,860 --> 01:29:07,299
Rob

1930
01:29:05,709 --> 01:29:09,729
perhaps a few less people who will be

1931
01:29:07,300 --> 01:29:11,139
happy to talk about the more involved

1932
01:29:09,729 --> 01:29:14,530
Heep exploitation techniques that go

1933
01:29:11,139 --> 01:29:16,360
from nothing to a shell with just heap

1934
01:29:14,530 --> 01:29:18,159
internals like the House of Orange or

1935
01:29:16,360 --> 01:29:19,598
the house of corrosion and there are

1936
01:29:18,159 --> 01:29:22,478
about 12 other techniques that we

1937
01:29:19,599 --> 01:29:23,889
haven't covered today but that's what I

1938
01:29:22,479 --> 01:29:25,420
got for you guys thank you very much for

1939
01:29:23,889 --> 01:29:26,769
coming I hope you learned something and

1940
01:29:25,420 --> 01:29:28,290
please enjoy the rest of the conference

1941
01:29:26,769 --> 01:29:31,760
thank you

1942
01:29:28,290 --> 01:29:31,760
[Applause]

