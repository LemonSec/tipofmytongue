1
00:00:02,670 --> 00:00:09,969
hello everyone good evening my name's

2
00:00:08,290 --> 00:00:11,950
Chris fate instantly talking about how

3
00:00:09,970 --> 00:00:13,929
you turn electronics into other

4
00:00:11,950 --> 00:00:16,450
electronics in order to make them do

5
00:00:13,929 --> 00:00:18,010
something nefarious so a lot of us know

6
00:00:16,450 --> 00:00:20,230
about these particular devices we have

7
00:00:18,010 --> 00:00:22,930
the kel-tec I am me a device that was

8
00:00:20,230 --> 00:00:25,570
converted into a spectrum analyzer using

9
00:00:22,930 --> 00:00:27,009
the RF chip inside the tight area md380

10
00:00:25,570 --> 00:00:28,510
which had their firmware modified to get

11
00:00:27,010 --> 00:00:31,390
a promiscuous mode on the frequencies

12
00:00:28,510 --> 00:00:33,730
and the isil SDR which used a debug mode

13
00:00:31,390 --> 00:00:35,649
on it in order to get full access to the

14
00:00:33,730 --> 00:00:37,449
frequency range that could support and

15
00:00:35,649 --> 00:00:38,769
all of these things have different cool

16
00:00:37,449 --> 00:00:41,530
features that are put in by somewhere

17
00:00:38,769 --> 00:00:42,730
else via reverse engineering but for my

18
00:00:41,530 --> 00:00:44,499
project I decided to do something

19
00:00:42,730 --> 00:00:45,909
different I decided to decide on the

20
00:00:44,499 --> 00:00:47,620
features I wanted in the first place and

21
00:00:45,909 --> 00:00:49,210
then build a device based on something

22
00:00:47,620 --> 00:00:50,550
that I found arbitrarily in order to do

23
00:00:49,210 --> 00:00:52,899
it

24
00:00:50,550 --> 00:00:54,459
so why first it was just to hide all a

25
00:00:52,899 --> 00:00:56,140
desired functionality assess the

26
00:00:54,460 --> 00:00:57,519
available features I wanted and identify

27
00:00:56,140 --> 00:00:59,670
if I could find something that could be

28
00:00:57,519 --> 00:01:02,469
debugged and developed for this purpose

29
00:00:59,670 --> 00:01:05,379
what I want it was an eldest LCD screen

30
00:01:02,469 --> 00:01:06,850
a menu button USB device communication

31
00:01:05,379 --> 00:01:09,189
and onboard storage so I could make a

32
00:01:06,850 --> 00:01:11,408
device capable of emulating USB devices

33
00:01:09,189 --> 00:01:13,360
such as USB disks yes Vicky Ward's or

34
00:01:11,409 --> 00:01:14,469
anything else I wanted and I ended up

35
00:01:13,360 --> 00:01:17,500
looking around and finding this

36
00:01:14,469 --> 00:01:18,788
particular device now this is an obd2

37
00:01:17,500 --> 00:01:21,909
reader that's their on-board diagnostics

38
00:01:18,789 --> 00:01:25,119
tool for debugging as cam systems in

39
00:01:21,909 --> 00:01:26,439
cast which I found had just quite good

40
00:01:25,119 --> 00:01:28,180
form factor for exactly what I want to

41
00:01:26,439 --> 00:01:28,869
add a nice screen some buttons on USB

42
00:01:28,180 --> 00:01:32,380
connectivity

43
00:01:28,869 --> 00:01:34,060
it flies as an FM 52 fy3 MCU it's a very

44
00:01:32,380 --> 00:01:36,130
common microcontroller which has 64

45
00:01:34,060 --> 00:01:38,109
kilobytes of flash and 20 kilobytes of

46
00:01:36,130 --> 00:01:40,119
RAM which is plenty for want to stir as

47
00:01:38,109 --> 00:01:42,280
well it's capable of going up to 72

48
00:01:40,119 --> 00:01:44,710
megahertz in maximum clock speed and had

49
00:01:42,280 --> 00:01:46,719
an LCD screen nice USB interface can

50
00:01:44,710 --> 00:01:48,100
interface and many buttons as well as 8

51
00:01:46,719 --> 00:01:50,288
megabytes of additional storage on the

52
00:01:48,100 --> 00:01:51,850
board

53
00:01:50,289 --> 00:01:53,469
I don't first thing I want to do is make

54
00:01:51,850 --> 00:01:54,880
sure that had proper USB functionality

55
00:01:53,469 --> 00:01:55,899
now we'll come into this later but one

56
00:01:54,880 --> 00:01:58,600
of the big problems you have what you

57
00:01:55,899 --> 00:02:00,460
work CSV is people putting serial USB on

58
00:01:58,600 --> 00:02:02,499
their board rather than letting native

59
00:02:00,460 --> 00:02:03,669
USB be used so I ended up doing was

60
00:02:02,499 --> 00:02:05,619
downloading the farmer update tool

61
00:02:03,670 --> 00:02:08,140
specifically for the device go through

62
00:02:05,619 --> 00:02:10,199
the EM dll's and finding the sales which

63
00:02:08,139 --> 00:02:13,390
basically year it directly related to

64
00:02:10,199 --> 00:02:15,700
stm32 cdc communication or any stm32

65
00:02:13,390 --> 00:02:16,839
communication it could fire USB

66
00:02:15,700 --> 00:02:18,700
this would basically let me know that

67
00:02:16,840 --> 00:02:20,200
it's using true yes B rather than using

68
00:02:18,700 --> 00:02:23,980
just a serial check where you something

69
00:02:20,200 --> 00:02:26,140
like comm zero content etc first thing

70
00:02:23,980 --> 00:02:27,850
we want to do is see if I could find an

71
00:02:26,140 --> 00:02:29,470
SWT hub header on the board this will

72
00:02:27,850 --> 00:02:30,760
add with him easily delete the code off

73
00:02:29,470 --> 00:02:32,859
the device and debug it

74
00:02:30,760 --> 00:02:34,450
I found that SWT was disabled even

75
00:02:32,860 --> 00:02:35,890
though a header was there and it had

76
00:02:34,450 --> 00:02:37,839
read a protection enabled which then

77
00:02:35,890 --> 00:02:38,890
even if I'd got a speedy access I would

78
00:02:37,840 --> 00:02:40,300
not have been able to read the flash

79
00:02:38,890 --> 00:02:42,250
offer

80
00:02:40,300 --> 00:02:43,540
I also found after downloading the

81
00:02:42,250 --> 00:02:45,430
firmware payload using the firmware

82
00:02:43,540 --> 00:02:46,239
update tool that it was encrypted so

83
00:02:45,430 --> 00:02:49,060
they're all so much I could do with

84
00:02:46,239 --> 00:02:50,830
their at that point so I had two options

85
00:02:49,060 --> 00:02:52,360
I could either build the firmware from

86
00:02:50,830 --> 00:02:53,890
scratch by deleting anything everything

87
00:02:52,360 --> 00:02:55,810
off the device or breaking the read out

88
00:02:53,890 --> 00:02:57,790
protection in the end I decide to do

89
00:02:55,810 --> 00:03:00,640
both but I decide to go for the first

90
00:02:57,790 --> 00:03:03,160
one first so building it from scratch

91
00:03:00,640 --> 00:03:05,079
for me I wouldn't have to adhere to

92
00:03:03,160 --> 00:03:06,160
their firmware update utilities wouldn't

93
00:03:05,080 --> 00:03:09,040
have to be limited by the amount of

94
00:03:06,160 --> 00:03:10,390
flash access they had and I would have

95
00:03:09,040 --> 00:03:11,739
to do a bit more Hardware reverse

96
00:03:10,390 --> 00:03:13,720
engineering and I would have to do if I

97
00:03:11,739 --> 00:03:14,980
had the firmware in the first place but

98
00:03:13,720 --> 00:03:16,840
having the firmware would allow me to

99
00:03:14,980 --> 00:03:19,359
modify existing software on it to make

100
00:03:16,840 --> 00:03:20,920
it do something else but would require

101
00:03:19,360 --> 00:03:21,940
me to find some exploitable weaknesses

102
00:03:20,920 --> 00:03:25,750
that allow me to break that encryption

103
00:03:21,940 --> 00:03:28,209
on the device so most of them say to

104
00:03:25,750 --> 00:03:29,650
switch have read read out protection

105
00:03:28,209 --> 00:03:31,209
enabled can just have their phone

106
00:03:29,650 --> 00:03:33,220
metalita this this thing for most chips

107
00:03:31,209 --> 00:03:35,230
that you work with if it says that the

108
00:03:33,220 --> 00:03:36,489
flash is locked you can tell it to

109
00:03:35,230 --> 00:03:37,630
delete all the flash off it because

110
00:03:36,489 --> 00:03:39,760
there's nothing on there you want any

111
00:03:37,630 --> 00:03:41,109
more logic analysis of all the

112
00:03:39,760 --> 00:03:42,489
peripherals on the device can let you

113
00:03:41,110 --> 00:03:43,690
know what the protocols are doing on any

114
00:03:42,489 --> 00:03:45,459
devices you don't understand

115
00:03:43,690 --> 00:03:47,620
in this case it was the LCD screen and

116
00:03:45,459 --> 00:03:49,840
you can trace every single pin in order

117
00:03:47,620 --> 00:03:51,700
to find out what it does I decide to

118
00:03:49,840 --> 00:03:53,140
just at solder in an SWT header out the

119
00:03:51,700 --> 00:03:56,170
side of the board just to make it easier

120
00:03:53,140 --> 00:03:59,290
for me to program so on the board we

121
00:03:56,170 --> 00:04:01,450
have several chips and ICS etc to work

122
00:03:59,290 --> 00:04:02,950
with first is STM say to know this is a

123
00:04:01,450 --> 00:04:04,660
core of advice it's the microcontroller

124
00:04:02,950 --> 00:04:06,730
does everything has the firmware and

125
00:04:04,660 --> 00:04:09,340
everything we then have the SPI flash

126
00:04:06,730 --> 00:04:14,078
with an 8 megabyte flash chip which had

127
00:04:09,340 --> 00:04:16,238
all the data for the ODBC Diagnostics we

128
00:04:14,079 --> 00:04:18,489
had a ribbon connector for the LCD

129
00:04:16,238 --> 00:04:20,858
screen on the board we had a bunch of

130
00:04:18,488 --> 00:04:23,289
regulators and cannon faces for the

131
00:04:20,858 --> 00:04:25,630
communication and a connector for the

132
00:04:23,289 --> 00:04:26,830
campus which I ended up taking off cuz I

133
00:04:25,630 --> 00:04:28,780
didn't either

134
00:04:26,830 --> 00:04:32,770
we also had some buttons which were

135
00:04:28,780 --> 00:04:34,809
obviously simple I ended up tracing out

136
00:04:32,770 --> 00:04:37,539
every pin and a function and mapping out

137
00:04:34,810 --> 00:04:39,430
on the stm32 hue is piece of software

138
00:04:37,539 --> 00:04:41,139
which lets you define peripherals and

139
00:04:39,430 --> 00:04:42,340
libraries for every pin on a device in

140
00:04:41,139 --> 00:04:44,139
order to bility build a piece of

141
00:04:42,340 --> 00:04:46,568
software without anything to know too

142
00:04:44,139 --> 00:04:49,330
much about registers or how things work

143
00:04:46,569 --> 00:04:50,710
from this I could get basically

144
00:04:49,330 --> 00:04:52,449
interrupts for buttons

145
00:04:50,710 --> 00:04:55,359
USB communication esto muni

146
00:04:52,449 --> 00:04:57,520
communication SPI communication and the

147
00:04:55,360 --> 00:04:58,650
data bus for the LCD which came to play

148
00:04:57,520 --> 00:05:01,990
later

149
00:04:58,650 --> 00:05:04,508
so let's propose a bit first spi flash

150
00:05:01,990 --> 00:05:06,729
now all SPI flash uses a very common

151
00:05:04,509 --> 00:05:08,650
command set with lesion reading etc

152
00:05:06,729 --> 00:05:11,380
which I use to basically read a write

153
00:05:08,650 --> 00:05:13,719
data from the device list in fade few

154
00:05:11,380 --> 00:05:15,699
had built in USB libraries basically for

155
00:05:13,720 --> 00:05:18,099
the mass storage and keyboard interface

156
00:05:15,699 --> 00:05:20,080
I wanted a third device and the LCD

157
00:05:18,099 --> 00:05:21,750
screen had a part number but no defeats

158
00:05:20,080 --> 00:05:24,190
whatsoever which wasn't too helpful

159
00:05:21,750 --> 00:05:26,409
there also pin outs for the cell data

160
00:05:24,190 --> 00:05:28,330
the LCD screen in sales documents and

161
00:05:26,409 --> 00:05:29,740
things which came into play later but

162
00:05:28,330 --> 00:05:33,099
didn't give much insight on the exact

163
00:05:29,740 --> 00:05:34,419
protocol so we'll start with LCD screen

164
00:05:33,099 --> 00:05:36,400
this is the pin out I found which

165
00:05:34,419 --> 00:05:38,409
basically defined what certain pins do

166
00:05:36,400 --> 00:05:39,669
and they're high and low which basically

167
00:05:38,409 --> 00:05:41,590
let me know that the thing was running

168
00:05:39,669 --> 00:05:43,049
in a parallel mode with a very specific

169
00:05:41,590 --> 00:05:45,099
command sir

170
00:05:43,050 --> 00:05:46,840
because of this I could trace all the

171
00:05:45,099 --> 00:05:48,849
pins and set them to inputs and outputs

172
00:05:46,840 --> 00:05:50,229
as needed in order to start fuzzing on

173
00:05:48,849 --> 00:05:53,080
my interface so I realized that it was

174
00:05:50,229 --> 00:05:55,210
using 85 pins and also read my data from

175
00:05:53,080 --> 00:05:57,310
the memory of the chip in the LCD

176
00:05:55,210 --> 00:05:58,989
controller and from that I could start

177
00:05:57,310 --> 00:06:00,340
following different standards of

178
00:05:58,990 --> 00:06:02,830
controls in order to get where I want to

179
00:06:00,340 --> 00:06:04,150
go and by doing this I've actually got

180
00:06:02,830 --> 00:06:06,940
things to turn on which basically meant

181
00:06:04,150 --> 00:06:09,039
that I could see snow on the screen

182
00:06:06,940 --> 00:06:11,050
because it had no memory that been

183
00:06:09,039 --> 00:06:12,849
initialized yet but eventually allowed

184
00:06:11,050 --> 00:06:14,770
me to start printing out ASCII bitmaps

185
00:06:12,849 --> 00:06:17,620
onto the screen using the row and column

186
00:06:14,770 --> 00:06:18,880
interface that I had I then eventually

187
00:06:17,620 --> 00:06:20,740
made to have a scale on the screen

188
00:06:18,880 --> 00:06:22,659
because it looks cool which was an

189
00:06:20,740 --> 00:06:24,610
extremely difficult thing to do because

190
00:06:22,659 --> 00:06:26,710
these kinds of screens have basically

191
00:06:24,610 --> 00:06:28,150
rows and columns as you finance X

192
00:06:26,710 --> 00:06:29,919
terminal it can be difficult to draw

193
00:06:28,150 --> 00:06:31,840
graphics on but if you put enough time

194
00:06:29,919 --> 00:06:34,680
in and you can do which obviously was

195
00:06:31,840 --> 00:06:34,679
totally worth it

196
00:06:34,900 --> 00:06:39,520
USB device is a much simpler SMT tube

197
00:06:38,080 --> 00:06:41,260
now this is a huge stack to work with

198
00:06:39,520 --> 00:06:43,419
usually but if you use the libraries

199
00:06:41,260 --> 00:06:44,980
they have built-in and spoilers every

200
00:06:43,420 --> 00:06:47,950
single developer who uses these chips

201
00:06:44,980 --> 00:06:49,510
uses these libraries for us you can

202
00:06:47,950 --> 00:06:51,099
basically make any standard of I see one

203
00:06:49,510 --> 00:06:53,110
it has one for hit which would be mouse

204
00:06:51,100 --> 00:06:56,530
and keyboard mass storage or anything

205
00:06:53,110 --> 00:06:58,210
else I use these libraries which I have

206
00:06:56,530 --> 00:06:59,500
special functionality to let you read

207
00:06:58,210 --> 00:07:01,570
and write to different peripherals and

208
00:06:59,500 --> 00:07:02,830
paired it with the SPI flash basically

209
00:07:01,570 --> 00:07:04,719
taking the read and write function to

210
00:07:02,830 --> 00:07:06,250
the flash in order to match them

211
00:07:04,720 --> 00:07:08,590
together allow me to basically use the

212
00:07:06,250 --> 00:07:10,990
device as an eight megabyte USB hard

213
00:07:08,590 --> 00:07:13,150
disk I then added the LCD screen to let

214
00:07:10,990 --> 00:07:16,450
the files let you select files from it

215
00:07:13,150 --> 00:07:18,159
in order to run certain payloads so this

216
00:07:16,450 --> 00:07:19,930
flash has enough room for a normal fat

217
00:07:18,160 --> 00:07:22,030
fatty filesystem because I had eight

218
00:07:19,930 --> 00:07:23,560
megabytes of storage which is almost as

219
00:07:22,030 --> 00:07:26,020
much the floppy disk or just a bit more

220
00:07:23,560 --> 00:07:27,610
I think I implement the read and write

221
00:07:26,020 --> 00:07:29,549
commands from the USB and map them to

222
00:07:27,610 --> 00:07:32,050
flash read erase and right commands and

223
00:07:29,550 --> 00:07:33,730
modify the USB maximum block sizes to

224
00:07:32,050 --> 00:07:38,110
match those minimum block sizes of spi

225
00:07:33,730 --> 00:07:40,600
flash which is a minimum 4k I then

226
00:07:38,110 --> 00:07:43,720
utilize the fat FS library system which

227
00:07:40,600 --> 00:07:45,400
lets um handle or fat32 storage on an

228
00:07:43,720 --> 00:07:47,260
embedded device together in order to

229
00:07:45,400 --> 00:07:51,010
read and write scpi commands when it was

230
00:07:47,260 --> 00:07:52,690
in keyboard mode so I must there's a

231
00:07:51,010 --> 00:07:55,300
flash store at my storage device added

232
00:07:52,690 --> 00:07:56,860
some text files to it and let them print

233
00:07:55,300 --> 00:07:58,810
out on the screen depending on what mode

234
00:07:56,860 --> 00:08:03,070
it was on and what this allowed me to do

235
00:07:58,810 --> 00:08:04,600
was step through and run payloads that

236
00:08:03,070 --> 00:08:06,520
are embedded in these text files so I

237
00:08:04,600 --> 00:08:08,650
made the thing mount as a USB keyboard

238
00:08:06,520 --> 00:08:10,750
by setting up the USB HID descriptors

239
00:08:08,650 --> 00:08:13,270
and made it read through the text files

240
00:08:10,750 --> 00:08:15,160
by conveying the ASCII text in there to

241
00:08:13,270 --> 00:08:17,140
USB scan codes which used by Kia was

242
00:08:15,160 --> 00:08:19,360
able to define which curtains are

243
00:08:17,140 --> 00:08:22,090
depressed it's allowed me to allow for

244
00:08:19,360 --> 00:08:24,010
automatically testing automatic typing

245
00:08:22,090 --> 00:08:28,060
of the text file much like a bash bunny

246
00:08:24,010 --> 00:08:29,380
or a USB rubber ducky I've made a few

247
00:08:28,060 --> 00:08:32,380
shortcuts on this nor to get the thing

248
00:08:29,380 --> 00:08:34,360
working before this conference I made

249
00:08:32,380 --> 00:08:36,400
sure that when I put the thing in it was

250
00:08:34,360 --> 00:08:38,110
either a USB disk or USB mass-storage

251
00:08:36,400 --> 00:08:39,549
because making a knobby anything when

252
00:08:38,110 --> 00:08:41,650
you plug it in is quite a complex task

253
00:08:39,549 --> 00:08:45,069
and can crash you USB control as I found

254
00:08:41,650 --> 00:08:47,180
during testing actually has been for us

255
00:08:45,070 --> 00:08:48,650
FS were all meeting

256
00:08:47,180 --> 00:08:50,959
so right block sizes so they all work

257
00:08:48,650 --> 00:08:52,310
together very succinctly and I made it

258
00:08:50,960 --> 00:08:55,670
so you'd only select text files on a

259
00:08:52,310 --> 00:08:59,689
desk now there's a quick demo of me

260
00:08:55,670 --> 00:09:01,510
plugging this device in so obviously in

261
00:08:59,690 --> 00:09:03,800
this mode comes up with the skull and

262
00:09:01,510 --> 00:09:05,689
then plug it in again and you have a

263
00:09:03,800 --> 00:09:06,949
list of the files that are in there now

264
00:09:05,690 --> 00:09:08,300
you can select these files and now you

265
00:09:06,950 --> 00:09:10,520
would type on the screen so you could

266
00:09:08,300 --> 00:09:13,550
add in reverse shells or usual payloads

267
00:09:10,520 --> 00:09:14,630
or anything you like now I talked about

268
00:09:13,550 --> 00:09:16,189
breaking the firmware earlier and we're

269
00:09:14,630 --> 00:09:17,900
going to go through that now the

270
00:09:16,190 --> 00:09:19,070
firmware plate was encrypted

271
00:09:17,900 --> 00:09:20,480
now it wasn't signed or anything

272
00:09:19,070 --> 00:09:22,700
complicated it was just encrypted which

273
00:09:20,480 --> 00:09:23,990
is a difficult task and because the code

274
00:09:22,700 --> 00:09:25,550
reader prefix was enabled I just

275
00:09:23,990 --> 00:09:27,740
couldn't read it from the disk virus W

276
00:09:25,550 --> 00:09:29,240
date and no known generic attacks after

277
00:09:27,740 --> 00:09:30,680
cold boot stepping were viable in this

278
00:09:29,240 --> 00:09:33,220
case because it didn't read the firmware

279
00:09:30,680 --> 00:09:35,810
when I was executing it after deployment

280
00:09:33,220 --> 00:09:37,340
so a few fuse we had with the fact that

281
00:09:35,810 --> 00:09:39,439
this particular chip was vulnerable to

282
00:09:37,340 --> 00:09:40,790
glitching attacks but I decided not to

283
00:09:39,440 --> 00:09:44,300
go down that route it's slightly too

284
00:09:40,790 --> 00:09:46,130
frustrating to do but estimate is

285
00:09:44,300 --> 00:09:48,140
enabled in Furman Triggs mode which when

286
00:09:46,130 --> 00:09:49,220
I could read the RAM when the thing was

287
00:09:48,140 --> 00:09:50,780
doing a firmware update mean you had

288
00:09:49,220 --> 00:09:52,340
read exactly what's going on and crashed

289
00:09:50,780 --> 00:09:54,680
the device as I was deploying firmware

290
00:09:52,340 --> 00:09:56,930
to it the update tool functions over USB

291
00:09:54,680 --> 00:09:57,979
which is easy to emulate using the PSP

292
00:09:56,930 --> 00:09:59,930
and different tools like that and

293
00:09:57,980 --> 00:10:02,330
updates that were decrypted and flashed

294
00:09:59,930 --> 00:10:03,920
at leadership with no signing or CRC so

295
00:10:02,330 --> 00:10:05,630
I could upload a corrupted so much

296
00:10:03,920 --> 00:10:09,800
device without crashing it or causing

297
00:10:05,630 --> 00:10:10,820
any problems so I use the USB foxy tools

298
00:10:09,800 --> 00:10:12,770
the BeagleBone black which is an

299
00:10:10,820 --> 00:10:14,020
extremely effective USB proxying

300
00:10:12,770 --> 00:10:15,860
mechanism which allows you to basically

301
00:10:14,020 --> 00:10:16,970
actively man in the middle USB

302
00:10:15,860 --> 00:10:18,830
connections for you know hosting a

303
00:10:16,970 --> 00:10:21,020
device even without control of the host

304
00:10:18,830 --> 00:10:23,720
and identified the CDC communication

305
00:10:21,020 --> 00:10:24,980
with a CRC 16 going on now I could then

306
00:10:23,720 --> 00:10:29,150
just replay these requests as a

307
00:10:24,980 --> 00:10:30,590
neither's I took the payloads I had and

308
00:10:29,150 --> 00:10:32,290
wrote at all in Lybia speech when you're

309
00:10:30,590 --> 00:10:34,730
late exactly what the host was doing I

310
00:10:32,290 --> 00:10:36,530
replayed each individual packet that was

311
00:10:34,730 --> 00:10:37,910
used to the firmware updates and assess

312
00:10:36,530 --> 00:10:39,439
where I needed to the bits I needed to

313
00:10:37,910 --> 00:10:41,449
modify in order to start uploading

314
00:10:39,440 --> 00:10:43,670
malicious firm where I found the thermo

315
00:10:41,450 --> 00:10:47,150
I was saying the 512 byte blocks which

316
00:10:43,670 --> 00:10:48,620
was very important later so it's more my

317
00:10:47,150 --> 00:10:50,329
code I know it's amazingly well written

318
00:10:48,620 --> 00:10:52,070
but what I tend to do when it comes to

319
00:10:50,330 --> 00:10:53,840
these sorts of deployments is copy and

320
00:10:52,070 --> 00:10:55,970
paste large buffers from the model in

321
00:10:53,840 --> 00:10:57,410
the middle sections and just dump them

322
00:10:55,970 --> 00:10:59,930
in because they're exactly as effective

323
00:10:57,410 --> 00:11:01,459
as mutate spending way too much time

324
00:10:59,930 --> 00:11:03,739
working out what each of these parts - I

325
00:11:01,460 --> 00:11:05,890
only SMO defy the parts which necessary

326
00:11:03,740 --> 00:11:11,089
for what the exploitation I want to do

327
00:11:05,890 --> 00:11:12,949
so I basically took the part where it

328
00:11:11,089 --> 00:11:14,660
was a-bleeding firmware put in my own

329
00:11:12,950 --> 00:11:16,850
part by reading it from my manipulated

330
00:11:14,660 --> 00:11:18,980
file and made sure the CSE's matched I

331
00:11:16,850 --> 00:11:20,089
was using a very standard x.25 CRC which

332
00:11:18,980 --> 00:11:21,830
is using all sorts of networking

333
00:11:20,089 --> 00:11:24,950
protocols and because it allowed me to

334
00:11:21,830 --> 00:11:26,300
upload the firmware this would be

335
00:11:24,950 --> 00:11:27,830
corrupted firmware because it was still

336
00:11:26,300 --> 00:11:30,920
encrypted in ways that I didn't

337
00:11:27,830 --> 00:11:32,660
understand but because I could read ram

338
00:11:30,920 --> 00:11:36,829
off the device as I was going along I

339
00:11:32,660 --> 00:11:38,240
could find 512 bytes of the firmware ask

340
00:11:36,830 --> 00:11:39,529
time and read it from the device thought

341
00:11:38,240 --> 00:11:41,390
it was very very slowly read the

342
00:11:39,529 --> 00:11:44,000
firmware from it this would let me know

343
00:11:41,390 --> 00:11:46,069
where the payload was in RAM allowed me

344
00:11:44,000 --> 00:11:47,180
to do some fair attacks later but it

345
00:11:46,070 --> 00:11:48,560
wouldn't really help me work out how the

346
00:11:47,180 --> 00:11:52,250
encryption works so it wouldn't be

347
00:11:48,560 --> 00:11:53,510
stored in the main firmware basically I

348
00:11:52,250 --> 00:11:57,890
didn't know what the keys were or what

349
00:11:53,510 --> 00:11:58,970
the encryption was yet I knew all the

350
00:11:57,890 --> 00:12:01,250
plain text looked like though which is

351
00:11:58,970 --> 00:12:04,060
very helpful but if I didn't because its

352
00:12:01,250 --> 00:12:06,200
nest m32 MCU there are a few standard

353
00:12:04,060 --> 00:12:08,569
parts of memory which we can use as

354
00:12:06,200 --> 00:12:11,000
signatures to check where we are so bike

355
00:12:08,570 --> 00:12:13,910
3 in a firmware will usually be a hex 20

356
00:12:11,000 --> 00:12:15,620
cuz that's a pointer into RAM a bike 7

357
00:12:13,910 --> 00:12:18,319
or will usually be 0 weight as a pointer

358
00:12:15,620 --> 00:12:19,580
into flash other bikes can be assumed as

359
00:12:18,320 --> 00:12:21,020
well there's some that will go to flash

360
00:12:19,580 --> 00:12:22,610
simulator Ram you could work with that

361
00:12:21,020 --> 00:12:24,800
but those in E 2 you'd really need this

362
00:12:22,610 --> 00:12:26,300
purpose if I could work out what the

363
00:12:24,800 --> 00:12:28,040
encryption album was I'd be able to use

364
00:12:26,300 --> 00:12:32,839
this basically as a comparison or to use

365
00:12:28,040 --> 00:12:33,620
a plain known plaintext attack so I

366
00:12:32,839 --> 00:12:35,390
decided to go through different

367
00:12:33,620 --> 00:12:37,459
encryption algorithms on this and upload

368
00:12:35,390 --> 00:12:39,260
the firmware to slight modifications so

369
00:12:37,459 --> 00:12:41,239
if it was a stream cipher as we know if

370
00:12:39,260 --> 00:12:43,550
I change one byte only that bite in the

371
00:12:41,240 --> 00:12:46,540
deployed file I would change but it

372
00:12:43,550 --> 00:12:49,250
wasn't if I changed one byte in the

373
00:12:46,540 --> 00:12:51,469
firmware and the first 16 or 32 bytes

374
00:12:49,250 --> 00:12:53,750
were different then I'd know that it was

375
00:12:51,470 --> 00:12:56,420
an ECB mode block cipher probably a yes

376
00:12:53,750 --> 00:12:58,610
but again it wasn't if I change the

377
00:12:56,420 --> 00:13:00,589
second block and the first block stayed

378
00:12:58,610 --> 00:13:03,410
the same but the support of subsequent

379
00:13:00,589 --> 00:13:05,029
ones didn't then they would all change

380
00:13:03,410 --> 00:13:07,100
afterwards the first one will say the

381
00:13:05,029 --> 00:13:08,270
same now this is a local interesting

382
00:13:07,100 --> 00:13:10,370
because none of these seem to be the

383
00:13:08,270 --> 00:13:13,550
case so it wasn't a standard encryption

384
00:13:10,370 --> 00:13:15,260
algorithm it was actually using xxe

385
00:13:13,550 --> 00:13:17,180
which some of you may have heard of but

386
00:13:15,260 --> 00:13:19,069
it's a very relatively unknown

387
00:13:17,180 --> 00:13:22,579
encryption algorithm what this storm

388
00:13:19,070 --> 00:13:24,410
does is you basically give it a huge

389
00:13:22,579 --> 00:13:26,180
block and the block cipher will modify

390
00:13:24,410 --> 00:13:28,069
itself depending on how big the block is

391
00:13:26,180 --> 00:13:29,719
so I gave it 5 around 12 bytes and if I

392
00:13:28,070 --> 00:13:32,860
change one bit in that the whole

393
00:13:29,720 --> 00:13:35,540
firmware payload would change I

394
00:13:32,860 --> 00:13:37,070
basically took that knowledge and the

395
00:13:35,540 --> 00:13:39,260
assumption that it was definitely xxt

396
00:13:37,070 --> 00:13:41,360
encryption and went through that entire

397
00:13:39,260 --> 00:13:43,400
random I got from the start and trying

398
00:13:41,360 --> 00:13:46,550
to find any headers that look similar to

399
00:13:43,400 --> 00:13:49,180
what I wanted for a firmware as I found

400
00:13:46,550 --> 00:13:51,349
the first hit I got was the correct one

401
00:13:49,180 --> 00:13:55,370
provided me with the encryption keys I

402
00:13:51,350 --> 00:13:58,010
needed I then could use that to encrypt

403
00:13:55,370 --> 00:13:59,839
the entire firmware dump as needed with

404
00:13:58,010 --> 00:14:02,029
these keys and that's exactly one use

405
00:13:59,839 --> 00:14:03,800
for 32-bit values where the key for this

406
00:14:02,029 --> 00:14:06,290
device allow me to decrypt and encrypt

407
00:14:03,800 --> 00:14:07,609
any firmware now one of the things that

408
00:14:06,290 --> 00:14:08,959
you'd want to do with this is dump the

409
00:14:07,610 --> 00:14:10,579
bootloader from the device now this

410
00:14:08,959 --> 00:14:12,260
would be important for if I bricked it

411
00:14:10,579 --> 00:14:14,420
during development if I were to return

412
00:14:12,260 --> 00:14:16,699
it back to something normal afterwards

413
00:14:14,420 --> 00:14:18,260
or if I just want to see if I had any

414
00:14:16,699 --> 00:14:20,479
other interesting features that I didn't

415
00:14:18,260 --> 00:14:22,160
have I could basically modify the

416
00:14:20,480 --> 00:14:23,420
firmware I had in order to add extra

417
00:14:22,160 --> 00:14:25,339
functionality in order to modify this

418
00:14:23,420 --> 00:14:28,250
and overwrite the firmest reset factor

419
00:14:25,339 --> 00:14:30,920
in order to make it run my shellcode

420
00:14:28,250 --> 00:14:32,510
right at the start so here's my

421
00:14:30,920 --> 00:14:35,959
shellcode nice and simple first thing it

422
00:14:32,510 --> 00:14:37,640
does is load AABB into this start of RAM

423
00:14:35,959 --> 00:14:38,750
on the chip now this makes it very

424
00:14:37,640 --> 00:14:39,949
simple for me to know that the code

425
00:14:38,750 --> 00:14:42,410
actually ran what I had to pull the

426
00:14:39,949 --> 00:14:44,750
firmware and nice and simple I then made

427
00:14:42,410 --> 00:14:46,880
it loop through the entire first hex

428
00:14:44,750 --> 00:14:49,459
four thousand bytes of the flash and

429
00:14:46,880 --> 00:14:50,870
dump it into Ram and this basically just

430
00:14:49,459 --> 00:14:52,729
dumped the entire bootloader for me to

431
00:14:50,870 --> 00:14:54,199
mess with and they're made infinite loop

432
00:14:52,730 --> 00:14:59,720
so didn't do anything weird with the RAM

433
00:14:54,199 --> 00:15:01,400
afterwards this provided me with this is

434
00:14:59,720 --> 00:15:04,940
a decrypted firmware I got from the

435
00:15:01,400 --> 00:15:06,920
encrypted version and I found that the

436
00:15:04,940 --> 00:15:08,209
reset vector was a hex 100 exists

437
00:15:06,920 --> 00:15:10,520
defined at the top of the firmware in

438
00:15:08,209 --> 00:15:12,109
the reset vector and I just over wrote

439
00:15:10,520 --> 00:15:15,020
that with my own shell code nor to make

440
00:15:12,110 --> 00:15:17,900
it do why I wanted from that I got the

441
00:15:15,020 --> 00:15:19,400
BBA I expected and the entire contents

442
00:15:17,900 --> 00:15:20,930
of the bootloader giving me access to

443
00:15:19,400 --> 00:15:23,300
all the encryption key throws thing I

444
00:15:20,930 --> 00:15:25,099
would allow me to basically deploy in a

445
00:15:23,300 --> 00:15:27,030
similar to the device or delete it if I

446
00:15:25,100 --> 00:15:28,990
wanted to

447
00:15:27,030 --> 00:15:30,850
basically from knowledge with a firmware

448
00:15:28,990 --> 00:15:32,350
update can let you deploy a family

449
00:15:30,850 --> 00:15:34,450
without hardware modification I wouldn't

450
00:15:32,350 --> 00:15:37,210
need to use mswd anymore I could deploy

451
00:15:34,450 --> 00:15:38,440
firmware to it if and provided to people

452
00:15:37,210 --> 00:15:40,300
who bought this device in order to

453
00:15:38,440 --> 00:15:41,620
upload malicious firmware tell them how

454
00:15:40,300 --> 00:15:44,260
to do anything except plug this thing

455
00:15:41,620 --> 00:15:46,570
into the USB I also found more

456
00:15:44,260 --> 00:15:48,370
encryption keys the spy flash and I

457
00:15:46,570 --> 00:15:49,900
could modify existing parts of the

458
00:15:48,370 --> 00:15:51,790
original firmware as in order to things

459
00:15:49,900 --> 00:15:53,980
I wanted like if I want to make it act

460
00:15:51,790 --> 00:15:57,120
like a can interface until I want to do

461
00:15:53,980 --> 00:15:59,260
something nefarious I could now do this

462
00:15:57,120 --> 00:16:00,430
this was an unsuitable device which

463
00:15:59,260 --> 00:16:01,510
looked similar obviously it's got

464
00:16:00,430 --> 00:16:03,430
similar functionality it's with some

465
00:16:01,510 --> 00:16:05,200
butter in them screen and this is the a

466
00:16:03,430 --> 00:16:07,959
satellite finder device I also found

467
00:16:05,200 --> 00:16:09,520
online had a color LCD a USB port and

468
00:16:07,960 --> 00:16:12,010
firmware update tools I could use to

469
00:16:09,520 --> 00:16:14,260
assess what was going on but the

470
00:16:12,010 --> 00:16:15,580
hardware would just wasn't mine so as

471
00:16:14,260 --> 00:16:17,290
you can see the chips look fairly

472
00:16:15,580 --> 00:16:20,080
similar to what we saw before in the

473
00:16:17,290 --> 00:16:22,300
Canon face but then weren't quite

474
00:16:20,080 --> 00:16:24,520
because of this particular chip now this

475
00:16:22,300 --> 00:16:27,099
is a USB to UART adapter basically this

476
00:16:24,520 --> 00:16:28,630
is I'm lazy icon bubala to implement usb

477
00:16:27,100 --> 00:16:30,850
on a device source like a chip on there

478
00:16:28,630 --> 00:16:33,010
instead making it cost more but have

479
00:16:30,850 --> 00:16:35,140
less development time what this means is

480
00:16:33,010 --> 00:16:37,140
that it can only emulate a serial device

481
00:16:35,140 --> 00:16:39,340
now and nothing else

482
00:16:37,140 --> 00:16:40,630
from the generic tools were used and the

483
00:16:39,340 --> 00:16:42,580
firmware updates were unencrypted

484
00:16:40,630 --> 00:16:44,650
because even those using similar

485
00:16:42,580 --> 00:16:45,700
chipsets to the originals which just

486
00:16:44,650 --> 00:16:47,380
meant it wasn't as fun to work with

487
00:16:45,700 --> 00:16:48,730
either it also meant that it was using

488
00:16:47,380 --> 00:16:51,130
the standard bootloader of the device

489
00:16:48,730 --> 00:16:52,840
meaning it wouldn't have anything for me

490
00:16:51,130 --> 00:16:55,900
to exfiltrate even if the ship was

491
00:16:52,840 --> 00:16:58,270
locked which it wasn't it was using the

492
00:16:55,900 --> 00:17:01,180
GD 32 MCU chipset which is a claim as

493
00:16:58,270 --> 00:17:03,189
stm32 it had USB connectivity but only

494
00:17:01,180 --> 00:17:04,300
on a serial chip and have some LCD

495
00:17:03,190 --> 00:17:05,920
screen drivers but they would have taken

496
00:17:04,300 --> 00:17:07,180
up a lot of space if I wanted to apply

497
00:17:05,920 --> 00:17:09,550
anything to it and add my own

498
00:17:07,180 --> 00:17:11,170
functionality and it ran on 9 volts

499
00:17:09,550 --> 00:17:13,750
which was annoying for if I want to run

500
00:17:11,170 --> 00:17:15,579
it directly off USB also there was no

501
00:17:13,750 --> 00:17:19,089
SWT header on it which made it not fun

502
00:17:15,579 --> 00:17:21,369
at all this device is somewhat similar

503
00:17:19,089 --> 00:17:23,819
this is an STM 32 you chip again this is

504
00:17:21,369 --> 00:17:26,379
a 2.4 gigahertz multi adapter for

505
00:17:23,819 --> 00:17:28,629
quadcopters helicopters for you know RF

506
00:17:26,380 --> 00:17:30,400
and C's yes it has USB connectivity

507
00:17:28,630 --> 00:17:32,770
built onto the board has some switches

508
00:17:30,400 --> 00:17:36,280
and it's quite a neat little device for

509
00:17:32,770 --> 00:17:38,200
working with it's got 4 2.4 gigahertz

510
00:17:36,280 --> 00:17:39,129
radios and including one Chinese or on a

511
00:17:38,200 --> 00:17:41,080
Texas Instruments and

512
00:17:39,130 --> 00:17:42,550
couple of others now being able to act

513
00:17:41,080 --> 00:17:43,960
for Caesar by the SPI interface on the

514
00:17:42,550 --> 00:17:46,629
device will give you quite strong

515
00:17:43,960 --> 00:17:48,400
functionality to a monitor and transmit

516
00:17:46,630 --> 00:17:51,070
on lots of different 2.4 gigahertz

517
00:17:48,400 --> 00:17:52,750
frequencies even at the same time now

518
00:17:51,070 --> 00:17:54,550
the internals are quite interesting it

519
00:17:52,750 --> 00:17:56,740
was very very similar before except a

520
00:17:54,550 --> 00:17:58,360
few more switches and LEDs had a you are

521
00:17:56,740 --> 00:18:01,660
header instead of an SWT header and no

522
00:17:58,360 --> 00:18:03,310
facilities for swd it did have a

523
00:18:01,660 --> 00:18:04,630
bootloader interface and an SPI

524
00:18:03,310 --> 00:18:07,600
interface which I could work with to do

525
00:18:04,630 --> 00:18:09,760
some debugging and what that meant was

526
00:18:07,600 --> 00:18:12,520
instead of basically going through the

527
00:18:09,760 --> 00:18:14,110
URS the video I could debug if I UART

528
00:18:12,520 --> 00:18:15,910
means I would be able to step through

529
00:18:14,110 --> 00:18:17,949
code or do any proper debugging but I

530
00:18:15,910 --> 00:18:21,310
could print out exactly what I needed to

531
00:18:17,950 --> 00:18:24,250
I could deploy any firm as I had to it

532
00:18:21,310 --> 00:18:26,379
and restore firm as I had already but it

533
00:18:24,250 --> 00:18:27,520
wouldn't really be useful for proper

534
00:18:26,380 --> 00:18:28,810
debugging stepping or anything else

535
00:18:27,520 --> 00:18:30,760
would have to be very clever about how I

536
00:18:28,810 --> 00:18:32,320
did any transmission I could transmit

537
00:18:30,760 --> 00:18:35,500
debugging information over you are but

538
00:18:32,320 --> 00:18:36,820
that's about em so those are some

539
00:18:35,500 --> 00:18:38,290
unsuitable devices let's talk about a

540
00:18:36,820 --> 00:18:40,510
different project now so I'm gonna talk

541
00:18:38,290 --> 00:18:42,280
to about CV first now it's not mine but

542
00:18:40,510 --> 00:18:44,800
it's quite an exciting one it's Seaview

543
00:18:42,280 --> 00:18:45,879
2017 one eight three four seven this is

544
00:18:44,800 --> 00:18:47,740
a vulnerability in the readout

545
00:18:45,880 --> 00:18:49,330
protection of stm32 as a road chips

546
00:18:47,740 --> 00:18:51,160
which the different chipset do which I

547
00:18:49,330 --> 00:18:53,500
had originally but it is a race

548
00:18:51,160 --> 00:18:55,840
condition on the chip itself which

549
00:18:53,500 --> 00:18:57,190
basically when it starts up when you

550
00:18:55,840 --> 00:18:58,659
request firmware from it if that's

551
00:18:57,190 --> 00:19:01,990
quickly enough it will give you the

552
00:18:58,660 --> 00:19:03,490
firmware so I wanted to make a device to

553
00:19:01,990 --> 00:19:06,190
do that automatically it's quite a

554
00:19:03,490 --> 00:19:07,660
complex thing to pull off the reason no

555
00:19:06,190 --> 00:19:09,700
one found it for a number of years is

556
00:19:07,660 --> 00:19:11,620
because swd debug is usually go through

557
00:19:09,700 --> 00:19:13,810
a whole process of reading IDs saying

558
00:19:11,620 --> 00:19:15,429
objecting registers before starting what

559
00:19:13,810 --> 00:19:18,190
you need to do is implement sou D and

560
00:19:15,430 --> 00:19:20,860
basically get an ID and that reads data

561
00:19:18,190 --> 00:19:22,810
very very quickly from the device so I'd

562
00:19:20,860 --> 00:19:24,340
say it's okay cheap third party s 3 D

563
00:19:22,810 --> 00:19:25,470
program perhaps just as important

564
00:19:24,340 --> 00:19:27,760
st-link

565
00:19:25,470 --> 00:19:30,970
from wingin air who have not heard of

566
00:19:27,760 --> 00:19:33,730
before and delete all the firmware from

567
00:19:30,970 --> 00:19:37,660
it and basically turn it from SW d

568
00:19:33,730 --> 00:19:40,120
debugger into and SW d attack tool so I

569
00:19:37,660 --> 00:19:43,140
found another FWC header as I always do

570
00:19:40,120 --> 00:19:45,699
and deleted all the flash from it and

571
00:19:43,140 --> 00:19:47,290
trace through the resistor ladders I saw

572
00:19:45,700 --> 00:19:48,610
on there to find what each pin on the

573
00:19:47,290 --> 00:19:50,460
output was doing allowing it to

574
00:19:48,610 --> 00:19:52,840
basically set up GFO on the device and

575
00:19:50,460 --> 00:19:53,290
then I implemented s the beauty from

576
00:19:52,840 --> 00:19:54,490
scratch

577
00:19:53,290 --> 00:19:57,430
which is a much simpler task than you

578
00:19:54,490 --> 00:19:59,020
think it is so it's a two while protocol

579
00:19:57,430 --> 00:20:01,360
usefully it has a clock and a data line

580
00:19:59,020 --> 00:20:02,800
you request data from it and it gives

581
00:20:01,360 --> 00:20:04,540
you it you write two registers you read

582
00:20:02,800 --> 00:20:06,100
from registers and that's all you

583
00:20:04,540 --> 00:20:08,740
require for communication some things

584
00:20:06,100 --> 00:20:10,120
have reset pin some have other weird

585
00:20:08,740 --> 00:20:12,250
things they'll have like other clocks

586
00:20:10,120 --> 00:20:13,899
inputs outputs but not much but the

587
00:20:12,250 --> 00:20:16,210
protocol itself can be big bang's using

588
00:20:13,900 --> 00:20:19,060
just Shuji pyo's on pen you send us the

589
00:20:16,210 --> 00:20:21,910
messages by setting their i/o to an

590
00:20:19,060 --> 00:20:23,290
output send the message turnaround on a

591
00:20:21,910 --> 00:20:25,210
clock cycle in order to make the input

592
00:20:23,290 --> 00:20:26,350
output and input and I've read the data

593
00:20:25,210 --> 00:20:28,030
from it or write the data to it

594
00:20:26,350 --> 00:20:29,469
depending on what's going on this will

595
00:20:28,030 --> 00:20:30,970
allow you to read ID codes write memory

596
00:20:29,470 --> 00:20:35,590
and basically do everything you needed

597
00:20:30,970 --> 00:20:37,690
basically four or s3d access I then

598
00:20:35,590 --> 00:20:40,030
implemented USB serial device which was

599
00:20:37,690 --> 00:20:41,530
very simple literally just copy and

600
00:20:40,030 --> 00:20:43,180
pasting it from the libraries and

601
00:20:41,530 --> 00:20:45,460
linking up as I needed and I did two

602
00:20:43,180 --> 00:20:46,960
commands to the first being I which

603
00:20:45,460 --> 00:20:48,850
constantly pulled for ID code from the

604
00:20:46,960 --> 00:20:50,620
chip basically identifies that I was

605
00:20:48,850 --> 00:20:52,510
actually speaking something and D which

606
00:20:50,620 --> 00:20:54,550
dumped firmware from the chip using this

607
00:20:52,510 --> 00:20:55,780
exploit basically powering the thing on

608
00:20:54,550 --> 00:20:56,919
and off constantly going please give

609
00:20:55,780 --> 00:20:59,080
info I please giving their farewell

610
00:20:56,920 --> 00:21:00,130
address often getting a little bit now

611
00:20:59,080 --> 00:21:03,460
this would allow you to eventually get

612
00:21:00,130 --> 00:21:05,320
the firmware after a number of hours so

613
00:21:03,460 --> 00:21:06,340
you get the ID codes and then you can

614
00:21:05,320 --> 00:21:08,470
dump the firmware and this can be a

615
00:21:06,340 --> 00:21:10,990
quick demo now so this is a device

616
00:21:08,470 --> 00:21:13,120
plugged into just a raw chip on a board

617
00:21:10,990 --> 00:21:15,190
because I couldn't find a bit of demo to

618
00:21:13,120 --> 00:21:18,129
use but this is a chip that i've lops

619
00:21:15,190 --> 00:21:19,630
the flash on and i'll show you this is

620
00:21:18,130 --> 00:21:20,770
the thing being powered on the LED is

621
00:21:19,630 --> 00:21:23,140
literally connected to the power and

622
00:21:20,770 --> 00:21:24,760
ground pins the thing found an ID code

623
00:21:23,140 --> 00:21:31,300
and stopped and then it started dumping

624
00:21:24,760 --> 00:21:34,300
the firmware and then on the computer

625
00:21:31,300 --> 00:21:36,790
side I typed in I to start dumping IDs

626
00:21:34,300 --> 00:21:44,649
I'm finding none until I connected up

627
00:21:36,790 --> 00:21:46,600
the pin got an ID code and then started

628
00:21:44,650 --> 00:21:51,790
dumping flash off the chip bypassing the

629
00:21:46,600 --> 00:21:53,409
read out protection completely so that's

630
00:21:51,790 --> 00:21:56,050
quite fun but I want to go back to the

631
00:21:53,410 --> 00:21:58,180
ODB T reader now so obviously we turned

632
00:21:56,050 --> 00:21:59,560
it into a USB hacking device now when I

633
00:21:58,180 --> 00:22:00,730
talk about Hardware modifications that

634
00:21:59,560 --> 00:22:02,379
could be made to it in order to make it

635
00:22:00,730 --> 00:22:03,850
do completely different things that was

636
00:22:02,380 --> 00:22:05,560
intended to I mean things that the

637
00:22:03,850 --> 00:22:07,209
hardware just doesn't support

638
00:22:05,560 --> 00:22:08,290
they're a bunch of pins on here which I

639
00:22:07,210 --> 00:22:10,870
didn't need so I didn't wanna work with

640
00:22:08,290 --> 00:22:12,639
can at all so I'd want I decided that I

641
00:22:10,870 --> 00:22:13,449
could take some of the pins off this you

642
00:22:12,640 --> 00:22:16,840
know what's make them do something

643
00:22:13,450 --> 00:22:19,360
different I had a look at where the pins

644
00:22:16,840 --> 00:22:22,449
were located got the interrupts and the

645
00:22:19,360 --> 00:22:26,020
timers and replace the Campins with

646
00:22:22,450 --> 00:22:28,480
these pin setups and this is enough as I

647
00:22:26,020 --> 00:22:29,830
found out recently to communicate on NFC

648
00:22:28,480 --> 00:22:32,800
as long as we had a small amount of

649
00:22:29,830 --> 00:22:34,330
extra hardware so at Def Con this year

650
00:22:32,800 --> 00:22:36,250
on the main stage I did a talk about

651
00:22:34,330 --> 00:22:38,530
making homemade NFC devices everything

652
00:22:36,250 --> 00:22:40,420
here you can see is basically capable of

653
00:22:38,530 --> 00:22:42,490
emulating Mifare classic tag in its

654
00:22:40,420 --> 00:22:44,920
entirety with extremely simple

655
00:22:42,490 --> 00:22:46,990
components so we have 280 tiny versions

656
00:22:44,920 --> 00:22:48,220
and stm32 version and of course the

657
00:22:46,990 --> 00:22:52,980
sonic screwdrivers version

658
00:22:48,220 --> 00:22:52,980
I know brilliant at least you guys laugh

659
00:22:53,460 --> 00:23:00,580
so why did it was I removed the can

660
00:22:57,280 --> 00:23:02,620
chips and some of the resistors from the

661
00:23:00,580 --> 00:23:04,179
board and it said soldered whites in

662
00:23:02,620 --> 00:23:05,979
their places very carefully in order to

663
00:23:04,180 --> 00:23:09,400
basically give me access these pins to

664
00:23:05,980 --> 00:23:11,470
make hardware modifications I create a

665
00:23:09,400 --> 00:23:12,850
small dotter board which is about four

666
00:23:11,470 --> 00:23:14,800
or five components which basically is

667
00:23:12,850 --> 00:23:16,929
all you need to convert NFC

668
00:23:14,800 --> 00:23:20,260
communication into digital communication

669
00:23:16,930 --> 00:23:26,070
and then sold it onto the board very

670
00:23:20,260 --> 00:23:27,970
simply and carefully on top of this I

671
00:23:26,070 --> 00:23:29,889
basically copied and pasted the code

672
00:23:27,970 --> 00:23:31,180
over because it was using a 72 megahertz

673
00:23:29,890 --> 00:23:33,010
clock speed and all my other devices

674
00:23:31,180 --> 00:23:34,570
using the same clock speed a lot of the

675
00:23:33,010 --> 00:23:38,800
code was very much interchangeable I

676
00:23:34,570 --> 00:23:40,720
could add the LCD screen to leverage

677
00:23:38,800 --> 00:23:43,270
menu options the device basically tag

678
00:23:40,720 --> 00:23:45,940
mode this mode NFC mode as needed which

679
00:23:43,270 --> 00:23:47,590
would give me these options and I

680
00:23:45,940 --> 00:23:50,260
implemented math storage so I could put

681
00:23:47,590 --> 00:23:54,879
NFC tag data on the device via USB and

682
00:23:50,260 --> 00:23:57,520
then use it as an NFC tag I basically

683
00:23:54,880 --> 00:23:59,710
set the options as before taped a

684
00:23:57,520 --> 00:24:02,440
massive battery store back and a coil of

685
00:23:59,710 --> 00:24:05,050
wire and then had a fully working NFC

686
00:24:02,440 --> 00:24:06,640
emulation device based on a handful of

687
00:24:05,050 --> 00:24:09,309
components

688
00:24:06,640 --> 00:24:11,110
now one of the problems I had was

689
00:24:09,309 --> 00:24:12,670
disable against him thirty twos USB

690
00:24:11,110 --> 00:24:14,620
stack after it started is a very

691
00:24:12,670 --> 00:24:16,390
dangerous thing it can crash the device

692
00:24:14,620 --> 00:24:19,600
so I decide to crash it myself instead

693
00:24:16,390 --> 00:24:20,950
just to Cal the middleman there was very

694
00:24:19,600 --> 00:24:24,459
little memory left on the thing it uses

695
00:24:20,950 --> 00:24:26,200
20 K of memory but the NFC stack my

696
00:24:24,460 --> 00:24:27,850
storage stack and the FATF a few file

697
00:24:26,200 --> 00:24:29,799
system stacks use huge amounts of data

698
00:24:27,850 --> 00:24:32,199
so I had to put the fat32 filesystem

699
00:24:29,799 --> 00:24:34,330
libraries a hat into tiny mode which is

700
00:24:32,200 --> 00:24:36,460
usually for much much much taller tips

701
00:24:34,330 --> 00:24:37,809
but for this it was absolutely perfect

702
00:24:36,460 --> 00:24:40,240
to fill in exactly what I needed and

703
00:24:37,809 --> 00:24:44,049
didn't really have any problems didn't

704
00:24:40,240 --> 00:24:46,240
cause me any issues this is my final

705
00:24:44,049 --> 00:24:48,160
demonstration of me emulating an NFC tag

706
00:24:46,240 --> 00:24:50,110
using my NFC reader and hopefully you

707
00:24:48,160 --> 00:24:59,470
can spot a red LED flashing to say this

708
00:24:50,110 --> 00:25:09,729
communicating and at the end thank you

709
00:24:59,470 --> 00:25:12,010
very much I think we have time for

710
00:25:09,730 --> 00:25:19,419
questions do me perfect if anyone has

711
00:25:12,010 --> 00:25:21,290
any questions that means I covered

712
00:25:19,419 --> 00:25:21,540
everything brilliant thank you very much

713
00:25:21,290 --> 00:25:25,979
[Applause]

714
00:25:21,540 --> 00:25:25,979
[Music]

