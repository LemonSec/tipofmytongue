1
00:00:00,240 --> 00:00:03,179
so I'm I'm Kev I'm going to talk about

2
00:00:03,179 --> 00:00:05,339
ebpf

3
00:00:05,339 --> 00:00:07,080
but first

4
00:00:07,080 --> 00:00:08,760
Isn't it nice to be like at a conference

5
00:00:08,760 --> 00:00:10,440
after the lockdown and I don't know

6
00:00:10,440 --> 00:00:11,880
about you but I really enjoyed the

7
00:00:11,880 --> 00:00:13,200
lockdown because it meant I got to stay

8
00:00:13,200 --> 00:00:14,099
at home

9
00:00:14,099 --> 00:00:16,920
and I did some crazy things so I built a

10
00:00:16,920 --> 00:00:19,320
bookshelf door for my spare room because

11
00:00:19,320 --> 00:00:21,960
what else do you do

12
00:00:21,960 --> 00:00:23,580
um I bought some incredibly expensive

13
00:00:23,580 --> 00:00:26,039
art which was basic riot shield that

14
00:00:26,039 --> 00:00:27,660
Jimmy Carter has acquired from the

15
00:00:27,660 --> 00:00:30,240
police and then painted up Jimmy Carter

16
00:00:30,240 --> 00:00:32,040
being you know of the klf who once

17
00:00:32,040 --> 00:00:34,020
burned a million quid and they were

18
00:00:34,020 --> 00:00:35,880
selling these at banksy's dismal land

19
00:00:35,880 --> 00:00:38,399
originally so I kind of hope it's a

20
00:00:38,399 --> 00:00:40,440
Banksy but you never know

21
00:00:40,440 --> 00:00:42,780
um and I also took advantage of the

22
00:00:42,780 --> 00:00:43,920
lockdown where like all University

23
00:00:43,920 --> 00:00:47,340
teaching went online to convince my hero

24
00:00:47,340 --> 00:00:49,079
zombies

25
00:00:49,079 --> 00:00:50,520
um to take me on as a student in a

26
00:00:50,520 --> 00:00:52,700
master's degree in psychological Methods

27
00:00:52,700 --> 00:00:56,219
at University of Sussex

28
00:00:56,219 --> 00:00:58,020
and so I'm doing that part-time I'm

29
00:00:58,020 --> 00:00:59,520
halfway through a masters which is quite

30
00:00:59,520 --> 00:01:01,739
nice I also got married

31
00:01:01,739 --> 00:01:03,660
and uh I'm with my

32
00:01:03,660 --> 00:01:06,500
thank you very much

33
00:01:06,840 --> 00:01:09,420
and uh and with my wife we uh we started

34
00:01:09,420 --> 00:01:12,060
a Blog called Cosmic pancakes the url's

35
00:01:12,060 --> 00:01:14,939
cosmic hyphen pancakes.com and it's all

36
00:01:14,939 --> 00:01:17,580
about hypnosis so come for the sarcastic

37
00:01:17,580 --> 00:01:20,400
book reviews and stay for the science or

38
00:01:20,400 --> 00:01:22,560
come for the science stay for the song

39
00:01:22,560 --> 00:01:25,439
for the sarcastic book reviews

40
00:01:25,439 --> 00:01:26,640
but anyway

41
00:01:26,640 --> 00:01:28,080
um

42
00:01:28,080 --> 00:01:32,460
you can find me on Twitter uh if the cab

43
00:01:32,460 --> 00:01:34,080
security handle is the one where I talk

44
00:01:34,080 --> 00:01:35,880
about ebpf

45
00:01:35,880 --> 00:01:38,340
um the the other one is where I rant

46
00:01:38,340 --> 00:01:39,720
about politics

47
00:01:39,720 --> 00:01:41,640
um and talk about hypnosis so feel free

48
00:01:41,640 --> 00:01:43,200
to follow whichever is is most

49
00:01:43,200 --> 00:01:45,619
applicable

50
00:01:45,960 --> 00:01:48,659
um right so I'm going to talk

51
00:01:48,659 --> 00:01:51,060
I say about ebpf mostly it'll be about

52
00:01:51,060 --> 00:01:55,200
how it works and uh and why it's a bit

53
00:01:55,200 --> 00:01:56,820
difficult to use but why it's really

54
00:01:56,820 --> 00:01:58,140
incredibly useful

55
00:01:58,140 --> 00:01:59,820
and a little bit about how it's

56
00:01:59,820 --> 00:02:03,299
vulnerable but um we'll come to that so

57
00:02:03,299 --> 00:02:07,140
if you're if you've used t-sharp or why

58
00:02:07,140 --> 00:02:09,660
a shark or any lip peacap based thing

59
00:02:09,660 --> 00:02:11,879
you've used BPF

60
00:02:11,879 --> 00:02:14,280
um Barclay packet filter

61
00:02:14,280 --> 00:02:17,220
um because that's how you know caption

62
00:02:17,220 --> 00:02:19,440
package works on Linux

63
00:02:19,440 --> 00:02:20,760
um you know if you were designing a

64
00:02:20,760 --> 00:02:23,160
packet capture thing uh you know where

65
00:02:23,160 --> 00:02:25,319
the kernels got to do with capturing you

66
00:02:25,319 --> 00:02:26,220
could

67
00:02:26,220 --> 00:02:29,700
build a configuration language and build

68
00:02:29,700 --> 00:02:31,140
that into the kernel and you could send

69
00:02:31,140 --> 00:02:32,700
a configuration into the kernel right

70
00:02:32,700 --> 00:02:35,459
but you'd only be able to capture things

71
00:02:35,459 --> 00:02:38,400
that the configuration language knows

72
00:02:38,400 --> 00:02:39,480
about

73
00:02:39,480 --> 00:02:42,420
so um you know if you wanted to add like

74
00:02:42,420 --> 00:02:44,459
the ability to capture something new or

75
00:02:44,459 --> 00:02:46,140
different way of filtering stuff you'd

76
00:02:46,140 --> 00:02:47,760
have to modify the kernel and of course

77
00:02:47,760 --> 00:02:49,800
that takes time and then it's only

78
00:02:49,800 --> 00:02:51,360
available on the new kernels it's not

79
00:02:51,360 --> 00:02:52,560
necessarily available on the Kernel that

80
00:02:52,560 --> 00:02:54,480
you're you're trying to capture on so

81
00:02:54,480 --> 00:02:56,519
instead what they did was they built a

82
00:02:56,519 --> 00:02:58,800
virtual machine inside the kernel which

83
00:02:58,800 --> 00:03:02,040
runs BPF machine language it's like

84
00:03:02,040 --> 00:03:03,300
bytecode

85
00:03:03,300 --> 00:03:05,940
and uh and what so when you

86
00:03:05,940 --> 00:03:08,160
put in your filter you know t-shock once

87
00:03:08,160 --> 00:03:11,640
I any not Port 22. it compiles that as a

88
00:03:11,640 --> 00:03:13,680
BPF program and inserts that into the

89
00:03:13,680 --> 00:03:15,480
kernel and then every packet that comes

90
00:03:15,480 --> 00:03:18,000
by gets shown to that program that

91
00:03:18,000 --> 00:03:20,159
program just says yes send it to user

92
00:03:20,159 --> 00:03:22,200
space or no don't send it to user space

93
00:03:22,200 --> 00:03:23,819
and that's how the packets come out of

94
00:03:23,819 --> 00:03:26,400
the kernel via libp and end up in your

95
00:03:26,400 --> 00:03:28,319
in your tool

96
00:03:28,319 --> 00:03:31,099
so um

97
00:03:31,099 --> 00:03:34,920
evpf originally was called extended BPF

98
00:03:34,920 --> 00:03:37,739
and the idea that you could take that

99
00:03:37,739 --> 00:03:40,260
idea and use it in other places but it

100
00:03:40,260 --> 00:03:42,060
no longer stands for anything it's just

101
00:03:42,060 --> 00:03:44,940
a term and it's got a nice a nice logo

102
00:03:44,940 --> 00:03:46,860
which we'll see everywhere

103
00:03:46,860 --> 00:03:52,220
but I'll talk about what that is uh now

104
00:03:52,260 --> 00:03:54,360
it's the same concept of running code

105
00:03:54,360 --> 00:03:55,739
aside a virtual machine inside the

106
00:03:55,739 --> 00:03:57,599
kernel a bytecode basic virtual machine

107
00:03:57,599 --> 00:03:59,480
it's just that instead of

108
00:03:59,480 --> 00:04:03,120
attaching that just to the network stack

109
00:04:03,120 --> 00:04:05,940
where it can see packets you can now

110
00:04:05,940 --> 00:04:08,159
attach your programs to anywhere in the

111
00:04:08,159 --> 00:04:09,379
kernel

112
00:04:09,379 --> 00:04:13,439
so practically any function call I mean

113
00:04:13,439 --> 00:04:16,380
inlined ones obviously not but you but

114
00:04:16,380 --> 00:04:18,899
you know there are there are still ways

115
00:04:18,899 --> 00:04:20,760
um practically any part of the network

116
00:04:20,760 --> 00:04:24,660
stack uh any Cisco any Trace point of

117
00:04:24,660 --> 00:04:26,699
which there's loads

118
00:04:26,699 --> 00:04:27,360
um

119
00:04:27,360 --> 00:04:28,979
and you can essentially instrument

120
00:04:28,979 --> 00:04:31,020
what's going on so you can write code

121
00:04:31,020 --> 00:04:33,660
that

122
00:04:33,660 --> 00:04:36,479
gets fired when a certain action occurs

123
00:04:36,479 --> 00:04:39,240
in the kernel and you can see the

124
00:04:39,240 --> 00:04:41,460
parameters that available at that point

125
00:04:41,460 --> 00:04:44,040
you can reach into data structures you

126
00:04:44,040 --> 00:04:45,120
can put all sorts of information about

127
00:04:45,120 --> 00:04:48,360
the process and other processes

128
00:04:48,360 --> 00:04:50,520
um and then so so why would you want to

129
00:04:50,520 --> 00:04:52,919
do that well

130
00:04:52,919 --> 00:04:55,400
you fully used s Trace you know that

131
00:04:55,400 --> 00:04:58,680
trace's system calls a program uses and

132
00:04:58,680 --> 00:05:00,419
which is kind of useful if you're trying

133
00:05:00,419 --> 00:05:01,620
to debug something or you're trying to

134
00:05:01,620 --> 00:05:03,540
work out the flow of something and and

135
00:05:03,540 --> 00:05:04,979
how it's interaction with the kernel

136
00:05:04,979 --> 00:05:06,540
well

137
00:05:06,540 --> 00:05:09,360
you get a lot of data back right and

138
00:05:09,360 --> 00:05:10,979
sometimes a lot of that data is not very

139
00:05:10,979 --> 00:05:13,500
useful but it also also doesn't get

140
00:05:13,500 --> 00:05:15,120
viewed back any more data than the

141
00:05:15,120 --> 00:05:17,040
program you know knows about it it's

142
00:05:17,040 --> 00:05:19,560
basically just arguments to ciscals so

143
00:05:19,560 --> 00:05:22,800
instead what you can do is use BPF to

144
00:05:22,800 --> 00:05:24,780
write a better S trace a less Trace

145
00:05:24,780 --> 00:05:26,100
that's targeted at what you're trying to

146
00:05:26,100 --> 00:05:30,660
achieve it could ignore a whole load of

147
00:05:30,660 --> 00:05:32,520
ciscalls until something specific

148
00:05:32,520 --> 00:05:34,259
happens at which point it could then

149
00:05:34,259 --> 00:05:37,080
start reporting data the data reports it

150
00:05:37,080 --> 00:05:38,699
could reach from inside the kernel and

151
00:05:38,699 --> 00:05:40,919
pull back it can get stuff from the task

152
00:05:40,919 --> 00:05:42,419
trucks

153
00:05:42,419 --> 00:05:45,720
um memory maps all sorts of things

154
00:05:45,720 --> 00:05:48,180
um using new probes you can snoop on

155
00:05:48,180 --> 00:05:51,060
user land stuff so you can snoop on read

156
00:05:51,060 --> 00:05:52,440
line and get back every command line

157
00:05:52,440 --> 00:05:55,259
typed in bash including passwords

158
00:05:55,259 --> 00:05:57,060
um you could Snoop on open SL read and

159
00:05:57,060 --> 00:05:58,440
write if you if you're attached to a

160
00:05:58,440 --> 00:06:00,479
program that's going for SSL in it

161
00:06:00,479 --> 00:06:03,539
so if you've used P Trace to build

162
00:06:03,539 --> 00:06:06,240
debuggers or you've used GDB

163
00:06:06,240 --> 00:06:07,820
um to attach to things

164
00:06:07,820 --> 00:06:10,620
you can do those kind of things but

165
00:06:10,620 --> 00:06:13,620
without the hassle of using p-trace it's

166
00:06:13,620 --> 00:06:16,199
not detectable in the same way it's

167
00:06:16,199 --> 00:06:17,580
probably detected in other ways but it's

168
00:06:17,580 --> 00:06:18,840
not detectable in the same way which is

169
00:06:18,840 --> 00:06:20,580
which is always good it's but it's a lot

170
00:06:20,580 --> 00:06:22,259
less clunky like the program doesn't

171
00:06:22,259 --> 00:06:23,699
necessarily need to know that it's being

172
00:06:23,699 --> 00:06:26,400
P traced

173
00:06:26,400 --> 00:06:27,900
um Beyond those kind of things which are

174
00:06:27,900 --> 00:06:30,720
kind of cool you can also do container

175
00:06:30,720 --> 00:06:32,100
networking so I work for a company

176
00:06:32,100 --> 00:06:33,660
called ice surveillance and we make

177
00:06:33,660 --> 00:06:35,880
psyllium which is an open source project

178
00:06:35,880 --> 00:06:39,720
at the cncf uh if you use kubernetes

179
00:06:39,720 --> 00:06:41,699
you you might want your networking to be

180
00:06:41,699 --> 00:06:43,979
quite quick well psyllium is dedicated

181
00:06:43,979 --> 00:06:45,660
to that so firewall and load balancing

182
00:06:45,660 --> 00:06:47,340
and routing of packets and things like

183
00:06:47,340 --> 00:06:48,360
that

184
00:06:48,360 --> 00:06:49,919
we also make technical on another

185
00:06:49,919 --> 00:06:52,380
another open source product again in the

186
00:06:52,380 --> 00:06:55,860
cncf which is a way of logging data and

187
00:06:55,860 --> 00:06:58,080
It ultimately one day that will replace

188
00:06:58,080 --> 00:07:00,840
audit D if you believe me but you should

189
00:07:00,840 --> 00:07:02,880
believe me because I'm going to make

190
00:07:02,880 --> 00:07:04,620
sure that happens

191
00:07:04,620 --> 00:07:05,160
um

192
00:07:05,160 --> 00:07:07,740
and and I'll but I'm not really going to

193
00:07:07,740 --> 00:07:09,660
talk about those products as they are

194
00:07:09,660 --> 00:07:11,639
you can go and get them from GitHub and

195
00:07:11,639 --> 00:07:12,720
I'm going to talk about like the

196
00:07:12,720 --> 00:07:14,699
technology underneath them

197
00:07:14,699 --> 00:07:15,840
um

198
00:07:15,840 --> 00:07:17,520
system for Linux I used to work for CIS

199
00:07:17,520 --> 00:07:18,539
internals before I worked for

200
00:07:18,539 --> 00:07:21,120
surveillance and uh I ported sysmon from

201
00:07:21,120 --> 00:07:23,400
Windows to Linux and if you don't know

202
00:07:23,400 --> 00:07:25,259
sys minus the tool for monitoring stuff

203
00:07:25,259 --> 00:07:27,479
on Windows it's got two components like

204
00:07:27,479 --> 00:07:30,599
a service and a driver that runs in the

205
00:07:30,599 --> 00:07:33,180
kernel so I ported the service from

206
00:07:33,180 --> 00:07:35,039
win32 to

207
00:07:35,039 --> 00:07:38,759
uh you know um see on Linux which you

208
00:07:38,759 --> 00:07:41,460
know has its own challenges but what was

209
00:07:41,460 --> 00:07:43,620
interesting was instead of using the

210
00:07:43,620 --> 00:07:46,259
Windows driver I built a replacement for

211
00:07:46,259 --> 00:07:48,180
that using ebpf so it picks up the same

212
00:07:48,180 --> 00:07:50,639
kind of data and sends it it as I say it

213
00:07:50,639 --> 00:07:52,500
it needs developing further because I

214
00:07:52,500 --> 00:07:55,139
then left Microsoft and joined ice

215
00:07:55,139 --> 00:07:56,400
surveillance

216
00:07:56,400 --> 00:07:57,960
um so but it is open source product it's

217
00:07:57,960 --> 00:08:00,180
out there on GitHub if you use it or you

218
00:08:00,180 --> 00:08:01,740
like it please feel free to extend it

219
00:08:01,740 --> 00:08:05,460
Michael sunovich would love you to do so

220
00:08:05,460 --> 00:08:08,520
um and finally uh root kits building and

221
00:08:08,520 --> 00:08:09,900
detecting them uh there's a guy called

222
00:08:09,900 --> 00:08:13,979
Linux store uh I've seen him speak and

223
00:08:13,979 --> 00:08:15,479
uh and his stuff is quite interesting so

224
00:08:15,479 --> 00:08:17,699
I I suggest you have a look

225
00:08:17,699 --> 00:08:19,500
so I won't say I'm not going to talk

226
00:08:19,500 --> 00:08:21,539
about synonym and tacticon in two great

227
00:08:21,539 --> 00:08:22,740
detail I just want to like give you some

228
00:08:22,740 --> 00:08:25,139
idea of what BPF is capable of what the

229
00:08:25,139 --> 00:08:28,020
power is of using it

230
00:08:28,020 --> 00:08:30,240
um so if you're using like you know

231
00:08:30,240 --> 00:08:31,740
kubernetes in your routing packets

232
00:08:31,740 --> 00:08:35,219
you're usually using say IP tables

233
00:08:35,219 --> 00:08:38,640
um or something like that if as you as

234
00:08:38,640 --> 00:08:40,760
you increase in the number of nodes

235
00:08:40,760 --> 00:08:44,459
there's overheads that that mounts up if

236
00:08:44,459 --> 00:08:46,020
you're using BPF to do your routing

237
00:08:46,020 --> 00:08:47,880
inside the kernel so it doesn't have to

238
00:08:47,880 --> 00:08:49,440
come out of the kernel to user space and

239
00:08:49,440 --> 00:08:51,600
task switch and everything else then you

240
00:08:51,600 --> 00:08:52,920
don't get that building up you pretty

241
00:08:52,920 --> 00:08:54,779
much have a constant

242
00:08:54,779 --> 00:08:55,560
um

243
00:08:55,560 --> 00:08:58,320
you know a constant overhead

244
00:08:58,320 --> 00:09:00,060
to put down to a different type of graph

245
00:09:00,060 --> 00:09:03,660
if you use an ipvs ipvs for example

246
00:09:03,660 --> 00:09:06,300
um we get more packets throughput by

247
00:09:06,300 --> 00:09:09,420
staying in the kernel and we use a lot

248
00:09:09,420 --> 00:09:12,300
less CPU so it's just to give you an

249
00:09:12,300 --> 00:09:16,500
idea that ebpf is is it's more than what

250
00:09:16,500 --> 00:09:18,000
it lets you do it lets you do things

251
00:09:18,000 --> 00:09:21,959
fast which is like really useful

252
00:09:21,959 --> 00:09:24,959
and uh Tech's gone to put into context

253
00:09:24,959 --> 00:09:26,339
of the thing that I work on which is the

254
00:09:26,339 --> 00:09:28,440
observability part it can attach to all

255
00:09:28,440 --> 00:09:31,200
sorts of things if you want to do the

256
00:09:31,200 --> 00:09:32,880
BPF type things I'm going to talk about

257
00:09:32,880 --> 00:09:35,519
in this talk but you don't want to write

258
00:09:35,519 --> 00:09:38,459
code you can get tetragon configure it

259
00:09:38,459 --> 00:09:41,760
with a yaml file and it will connect to

260
00:09:41,760 --> 00:09:43,560
the functions in the kernel for you and

261
00:09:43,560 --> 00:09:45,300
Report the information you ask it to

262
00:09:45,300 --> 00:09:47,339
report based on it matching certain

263
00:09:47,339 --> 00:09:48,779
parameters that you've told it to match

264
00:09:48,779 --> 00:09:51,300
on so you can get the power of BPF

265
00:09:51,300 --> 00:09:53,760
observability but without having the

266
00:09:53,760 --> 00:09:55,200
hassle of writing the code and trying to

267
00:09:55,200 --> 00:09:57,839
get it to run because we've done that

268
00:09:57,839 --> 00:10:00,740
hard bit for you and and

269
00:10:00,740 --> 00:10:03,060
providing it as a way that makes it a

270
00:10:03,060 --> 00:10:04,740
lot easier to use

271
00:10:04,740 --> 00:10:06,800
um

272
00:10:07,500 --> 00:10:10,620
if you

273
00:10:10,620 --> 00:10:13,080
want to play with any of these things we

274
00:10:13,080 --> 00:10:14,820
have free labs

275
00:10:14,820 --> 00:10:17,339
it costs you an email address basically

276
00:10:17,339 --> 00:10:18,779
but

277
00:10:18,779 --> 00:10:21,360
come come see our labs and and get hold

278
00:10:21,360 --> 00:10:23,580
of technology and see how it works where

279
00:10:23,580 --> 00:10:25,260
someone's already set it up for you

280
00:10:25,260 --> 00:10:28,620
right let's talk about technology so BPF

281
00:10:28,620 --> 00:10:32,640
is basically a risk language it's got a

282
00:10:32,640 --> 00:10:35,120
stack of registers and it's got basic

283
00:10:35,120 --> 00:10:38,519
operations and that as I say runs in a

284
00:10:38,519 --> 00:10:40,880
virtual machine

285
00:10:41,519 --> 00:10:43,680
the memory model however is quite

286
00:10:43,680 --> 00:10:47,339
interesting there is 500 512 bytes of

287
00:10:47,339 --> 00:10:49,200
Stack which isn't a lot

288
00:10:49,200 --> 00:10:50,579
but then we're not really doing function

289
00:10:50,579 --> 00:10:52,200
calls so that's kind of the stack for

290
00:10:52,200 --> 00:10:54,959
your local variables pretty much

291
00:10:54,959 --> 00:10:56,760
um there are no globals and there's no

292
00:10:56,760 --> 00:10:58,920
Heap which sounds like a really

293
00:10:58,920 --> 00:11:00,660
difficult thing to program and and it

294
00:11:00,660 --> 00:11:04,560
can be but what we have are BPF maps and

295
00:11:04,560 --> 00:11:06,360
maps are places to store data and

296
00:11:06,360 --> 00:11:07,680
there's lots of different types but the

297
00:11:07,680 --> 00:11:09,720
most common ones are like an array and a

298
00:11:09,720 --> 00:11:10,980
hash

299
00:11:10,980 --> 00:11:11,940
um

300
00:11:11,940 --> 00:11:13,980
so if you

301
00:11:13,980 --> 00:11:16,200
all you have to do is Define maps and

302
00:11:16,200 --> 00:11:17,760
then you're essentially defining memory

303
00:11:17,760 --> 00:11:19,620
and then you can access that memory and

304
00:11:19,620 --> 00:11:21,660
you can play with it so if you need a

305
00:11:21,660 --> 00:11:24,120
load of Heap you just create an array

306
00:11:24,120 --> 00:11:26,100
that's got one element in it and that's

307
00:11:26,100 --> 00:11:27,600
the size of the amount of memory that

308
00:11:27,600 --> 00:11:29,640
you need and then you do then you ask it

309
00:11:29,640 --> 00:11:32,820
for that entry of that array and it'll

310
00:11:32,820 --> 00:11:34,260
give you a pointer to a chunk of memory

311
00:11:34,260 --> 00:11:36,540
that's essentially your HEAP so you can

312
00:11:36,540 --> 00:11:39,779
then play with that memory as you like

313
00:11:39,779 --> 00:11:40,560
um

314
00:11:40,560 --> 00:11:42,920
these maps are shared between programs

315
00:11:42,920 --> 00:11:45,480
and they're shared if you want them to

316
00:11:45,480 --> 00:11:47,820
be and they're shared between kernel and

317
00:11:47,820 --> 00:11:50,160
user space so you can stick stuff into a

318
00:11:50,160 --> 00:11:51,240
map

319
00:11:51,240 --> 00:11:52,980
because you've observed something and

320
00:11:52,980 --> 00:11:54,300
use the space can read that out like

321
00:11:54,300 --> 00:11:55,980
pull it periodically

322
00:11:55,980 --> 00:11:57,899
if you wanted to there's also a ring

323
00:11:57,899 --> 00:11:59,459
buffer map so you can stick stuff into a

324
00:11:59,459 --> 00:12:00,899
ring buffer and it will pop out in user

325
00:12:00,899 --> 00:12:02,640
space where you can all pop out in a

326
00:12:02,640 --> 00:12:04,380
different program so so there's some

327
00:12:04,380 --> 00:12:05,820
interesting things you go to get your

328
00:12:05,820 --> 00:12:07,500
head around

329
00:12:07,500 --> 00:12:08,279
um

330
00:12:08,279 --> 00:12:12,120
I talked about uh Trace points so if you

331
00:12:12,120 --> 00:12:15,420
don't know if you go to um Cisco debug

332
00:12:15,420 --> 00:12:17,820
tracing events then there's a whole load

333
00:12:17,820 --> 00:12:19,740
of directory pseudo directories which

334
00:12:19,740 --> 00:12:22,140
represent classes of face points and

335
00:12:22,140 --> 00:12:23,279
there's some quite interesting ones

336
00:12:23,279 --> 00:12:25,560
there as you can probably see that you

337
00:12:25,560 --> 00:12:28,019
might want to attach to like raw ciscals

338
00:12:28,019 --> 00:12:30,660
is at the start and end of the Cisco

339
00:12:30,660 --> 00:12:31,860
architecture

340
00:12:31,860 --> 00:12:33,720
every time a Cisco is made from user

341
00:12:33,720 --> 00:12:36,720
space you'll hit these Trace points

342
00:12:36,720 --> 00:12:40,079
um each Sysco has its own face points uh

343
00:12:40,079 --> 00:12:42,540
in the Cisco's directory shed is about

344
00:12:42,540 --> 00:12:44,940
you know starting up processes start

345
00:12:44,940 --> 00:12:47,160
switching signals sending of receiving

346
00:12:47,160 --> 00:12:48,839
signals except for net for the network

347
00:12:48,839 --> 00:12:51,120
there's a whole load of Trace points

348
00:12:51,120 --> 00:12:53,040
littered across the kernel and they're

349
00:12:53,040 --> 00:12:54,779
really easy to attach to

350
00:12:54,779 --> 00:12:57,360
so if you wanted to attach to for

351
00:12:57,360 --> 00:13:00,779
example this is sys Center exec V exact

352
00:13:00,779 --> 00:13:02,779
V is the Cisco for starting a program

353
00:13:02,779 --> 00:13:05,639
the enter part means

354
00:13:05,639 --> 00:13:07,800
just before it happens like so at the

355
00:13:07,800 --> 00:13:09,360
point they've called The Cisco there's

356
00:13:09,360 --> 00:13:11,339
also an exit one for after it's done its

357
00:13:11,339 --> 00:13:12,600
work

358
00:13:12,600 --> 00:13:15,240
um so in you go you go into a pseudo

359
00:13:15,240 --> 00:13:16,800
directory and there's a file called

360
00:13:16,800 --> 00:13:18,959
format and if you cat that

361
00:13:18,959 --> 00:13:20,760
you'll get this data

362
00:13:20,760 --> 00:13:25,980
and um the first chunk uh which makes up

363
00:13:25,980 --> 00:13:29,100
64 bits is opaque inaccessible you can't

364
00:13:29,100 --> 00:13:32,399
touch but it so you just have to know

365
00:13:32,399 --> 00:13:34,440
that it's there but the rest of it are

366
00:13:34,440 --> 00:13:36,240
the arguments to the Cisco the arguments

367
00:13:36,240 --> 00:13:38,279
that the user space program called it

368
00:13:38,279 --> 00:13:40,800
with so in I mean there's also a Cisco

369
00:13:40,800 --> 00:13:42,720
number which is handy because you might

370
00:13:42,720 --> 00:13:44,220
want to attach the same program to lots

371
00:13:44,220 --> 00:13:46,019
of different ciscals so you could check

372
00:13:46,019 --> 00:13:48,180
the number to see which one you've been

373
00:13:48,180 --> 00:13:50,160
fired off right but but apart from that

374
00:13:50,160 --> 00:13:51,720
it's just the parameters there's a file

375
00:13:51,720 --> 00:13:53,880
name to run there's a ARG V and there's

376
00:13:53,880 --> 00:13:55,079
an NP

377
00:13:55,079 --> 00:13:56,760
so um

378
00:13:56,760 --> 00:13:58,560
what you could do is smash together a

379
00:13:58,560 --> 00:14:01,160
struct that follows that format

380
00:14:01,160 --> 00:14:04,320
literally sort of copied across and I've

381
00:14:04,320 --> 00:14:07,260
actually added a pad two in there but

382
00:14:07,260 --> 00:14:09,000
you wouldn't really that's just to force

383
00:14:09,000 --> 00:14:10,200
the alignment but you wouldn't really

384
00:14:10,200 --> 00:14:12,480
need to do that and then when you're

385
00:14:12,480 --> 00:14:14,339
programmed that you've attached to this

386
00:14:14,339 --> 00:14:16,560
Trace Point gets fired it will get an

387
00:14:16,560 --> 00:14:18,120
argument and that will be appointed to

388
00:14:18,120 --> 00:14:19,740
the struct and you can just reach into

389
00:14:19,740 --> 00:14:23,120
that struct and get those parameters

390
00:14:23,519 --> 00:14:26,459
um if you look at a non-ciscal trace

391
00:14:26,459 --> 00:14:27,779
point it's exactly the same kind of

392
00:14:27,779 --> 00:14:29,399
thing same kind of layout

393
00:14:29,399 --> 00:14:32,220
um this is in shed process exec so this

394
00:14:32,220 --> 00:14:33,540
is a trace point that gets hit when a

395
00:14:33,540 --> 00:14:37,740
process is executed by like exactly for

396
00:14:37,740 --> 00:14:40,620
example and you can see that the

397
00:14:40,620 --> 00:14:43,980
promises there are a file name

398
00:14:43,980 --> 00:14:45,959
um the process ID and the old process ID

399
00:14:45,959 --> 00:14:48,120
except you'll notice that the file name

400
00:14:48,120 --> 00:14:51,420
is only four bytes this is too small to

401
00:14:51,420 --> 00:14:52,500
be a pointer

402
00:14:52,500 --> 00:14:56,540
but it's a data lock so

403
00:14:57,000 --> 00:15:00,420
basically the data lock tells you where

404
00:15:00,420 --> 00:15:04,560
to find the file name and it's kind of

405
00:15:04,560 --> 00:15:06,660
like a 30-bit number the first 16 bits

406
00:15:06,660 --> 00:15:09,060
or the lower 16 bits of the offset the

407
00:15:09,060 --> 00:15:11,279
up 16 bits is the length right and it's

408
00:15:11,279 --> 00:15:13,079
the offset from the start of that struct

409
00:15:13,079 --> 00:15:15,360
now you'll notice I've put in an

410
00:15:15,360 --> 00:15:18,360
unsigned Char raw you know 4K chunk at

411
00:15:18,360 --> 00:15:20,940
the end if you don't have that

412
00:15:20,940 --> 00:15:23,040
you get the data lock you work out the

413
00:15:23,040 --> 00:15:24,480
offset from the start of the struct it's

414
00:15:24,480 --> 00:15:26,820
pretty much going to be like the offset

415
00:15:26,820 --> 00:15:28,260
is going to be to the end of that struct

416
00:15:28,260 --> 00:15:30,060
and then you start trying to read that

417
00:15:30,060 --> 00:15:32,399
memory and ebpf tells you you don't own

418
00:15:32,399 --> 00:15:34,079
that memory because it's clever enough

419
00:15:34,079 --> 00:15:37,199
to know that the struct size prohibits

420
00:15:37,199 --> 00:15:38,519
you to reach that point so you have to

421
00:15:38,519 --> 00:15:40,800
stick in some dummy like buffer at the

422
00:15:40,800 --> 00:15:43,740
end so that ebpf knows that you own the

423
00:15:43,740 --> 00:15:45,839
memory so you can actually access it so

424
00:15:45,839 --> 00:15:48,720
it's a little bit of a trick but I

425
00:15:48,720 --> 00:15:49,980
wanted to like sort of mention that so

426
00:15:49,980 --> 00:15:52,260
but again you can pull out these

427
00:15:52,260 --> 00:15:53,399
parameters

428
00:15:53,399 --> 00:15:55,800
the difference here of course is we're

429
00:15:55,800 --> 00:15:58,699
in a trace point

430
00:15:58,740 --> 00:16:00,300
um

431
00:16:00,300 --> 00:16:03,360
after the Cisco was being called so

432
00:16:03,360 --> 00:16:04,560
there's a good chance you'd have to set

433
00:16:04,560 --> 00:16:05,639
the source actually there's a good

434
00:16:05,639 --> 00:16:07,079
chance that the file name at this point

435
00:16:07,079 --> 00:16:09,060
is after the kernel has copied it so you

436
00:16:09,060 --> 00:16:10,320
could trust that buffer as being a

437
00:16:10,320 --> 00:16:12,420
kernel buffer as opposed to a user space

438
00:16:12,420 --> 00:16:14,880
buffer which might change between the

439
00:16:14,880 --> 00:16:16,860
Cisco being called and your program

440
00:16:16,860 --> 00:16:18,839
looking into that buffer if you're

441
00:16:18,839 --> 00:16:20,699
interested in that it's called Phantom

442
00:16:20,699 --> 00:16:22,980
attack and it was in Defcon 29 it's

443
00:16:22,980 --> 00:16:24,839
worth looking at because changing

444
00:16:24,839 --> 00:16:27,959
buffers from user space before the ebpf

445
00:16:27,959 --> 00:16:31,500
Tracer sees what's in the buffer and

446
00:16:31,500 --> 00:16:33,540
changing it back so for when the kernel

447
00:16:33,540 --> 00:16:35,399
gets to see it is quite a neat trick and

448
00:16:35,399 --> 00:16:37,079
the and the guys managed to make that

449
00:16:37,079 --> 00:16:39,600
quite reliable

450
00:16:39,600 --> 00:16:42,000
um if you want to connect to an

451
00:16:42,000 --> 00:16:44,100
arbitrary kernel function you can use a

452
00:16:44,100 --> 00:16:47,220
k-frobe kernel probe and um in this case

453
00:16:47,220 --> 00:16:48,540
we want to connect to like underscore

454
00:16:48,540 --> 00:16:50,100
underscore shed Fork which happens

455
00:16:50,100 --> 00:16:52,380
obviously as part of forking

456
00:16:52,380 --> 00:16:54,839
um you can see that it's got parameters

457
00:16:54,839 --> 00:16:56,519
of um

458
00:16:56,519 --> 00:16:58,920
clone flags and a pointed to a task

459
00:16:58,920 --> 00:16:59,940
struct

460
00:16:59,940 --> 00:17:01,500
now

461
00:17:01,500 --> 00:17:05,099
it's not quite as uh straightforward

462
00:17:05,099 --> 00:17:07,199
basically your k-pro will get a pointer

463
00:17:07,199 --> 00:17:09,119
to a struct which basically contains the

464
00:17:09,119 --> 00:17:10,619
registers

465
00:17:10,619 --> 00:17:12,480
that the machine has at that particular

466
00:17:12,480 --> 00:17:14,160
point in time so imagine the machine has

467
00:17:14,160 --> 00:17:16,140
stopped and you've now got access to its

468
00:17:16,140 --> 00:17:17,819
registers

469
00:17:17,819 --> 00:17:21,119
um but we know you know the calling API

470
00:17:21,119 --> 00:17:23,819
in Linux like the first register is RDI

471
00:17:23,819 --> 00:17:27,119
yeah the front is Idi the second was RSI

472
00:17:27,119 --> 00:17:30,960
Etc so you can pull your parameters out

473
00:17:30,960 --> 00:17:33,679
of those registers

474
00:17:34,440 --> 00:17:36,559
um

475
00:17:36,960 --> 00:17:39,419
so how did you go about inserting code

476
00:17:39,419 --> 00:17:43,020
well you write programs C pretty much

477
00:17:43,020 --> 00:17:45,059
you could write it in BPF assembler if

478
00:17:45,059 --> 00:17:47,059
you want but most people write it in C

479
00:17:47,059 --> 00:17:49,380
compile it with clang with the BPF

480
00:17:49,380 --> 00:17:51,960
Target that gives you an elf object and

481
00:17:51,960 --> 00:17:53,280
then load that using a load Library

482
00:17:53,280 --> 00:17:55,679
which and attach it to a point in the

483
00:17:55,679 --> 00:17:58,080
kernel and there are choices overload

484
00:17:58,080 --> 00:18:01,320
Library so lib BPF is the common one

485
00:18:01,320 --> 00:18:03,780
excuse me ice surveillance we make one

486
00:18:03,780 --> 00:18:05,640
called Celia me BPF which you can get

487
00:18:05,640 --> 00:18:08,039
from github's free which is already in

488
00:18:08,039 --> 00:18:09,299
go

489
00:18:09,299 --> 00:18:11,280
um or where I've made one of CIS

490
00:18:11,280 --> 00:18:13,620
internals which is based on lib BPF

491
00:18:13,620 --> 00:18:15,660
and once it's loaded into the kernel you

492
00:18:15,660 --> 00:18:18,059
can get it will run your code will run

493
00:18:18,059 --> 00:18:20,880
every time that attachment point is hit

494
00:18:20,880 --> 00:18:22,559
so if it's a kernel function every time

495
00:18:22,559 --> 00:18:23,820
that kernel function is set your code

496
00:18:23,820 --> 00:18:25,500
will run if there's a trace point every

497
00:18:25,500 --> 00:18:26,820
time that Trace pointer set your code

498
00:18:26,820 --> 00:18:30,600
will run and then to get data back out

499
00:18:30,600 --> 00:18:33,360
you can sling it into a ring buffer and

500
00:18:33,360 --> 00:18:34,799
it'll pop out in user space and your

501
00:18:34,799 --> 00:18:36,720
controller that loaded it can get access

502
00:18:36,720 --> 00:18:39,000
to that data or for debugging purposes

503
00:18:39,000 --> 00:18:40,500
there's a trace pipe where you can just

504
00:18:40,500 --> 00:18:43,500
print K stuff straight into and you can

505
00:18:43,500 --> 00:18:45,059
and you can just like cap this Trace

506
00:18:45,059 --> 00:18:48,480
pipe from user space which is great for

507
00:18:48,480 --> 00:18:51,240
debugging not very good for production

508
00:18:51,240 --> 00:18:53,280
because it's one pipe that everything

509
00:18:53,280 --> 00:18:55,679
kind of basically uses

510
00:18:55,679 --> 00:18:57,480
but if you just want to you know do some

511
00:18:57,480 --> 00:18:59,880
printf style debugging it's it which is

512
00:18:59,880 --> 00:19:01,980
the only way to debug BPF on my ad then

513
00:19:01,980 --> 00:19:04,980
then it's it's kind of Handy

514
00:19:04,980 --> 00:19:07,380
um now you can't run kernel functions

515
00:19:07,380 --> 00:19:09,960
from within BPF so it's not like a

516
00:19:09,960 --> 00:19:11,520
kernel module in that sense if you wrote

517
00:19:11,520 --> 00:19:12,960
a kernel module you can pretty much run

518
00:19:12,960 --> 00:19:14,820
any function in the kernel but the

519
00:19:14,820 --> 00:19:16,440
problem you've got running a kernel

520
00:19:16,440 --> 00:19:18,299
module is that if you make a mistake

521
00:19:18,299 --> 00:19:21,840
your kernel crashes uh well with BPF

522
00:19:21,840 --> 00:19:23,820
that shouldn't be the case if you make a

523
00:19:23,820 --> 00:19:25,020
mistake

524
00:19:25,020 --> 00:19:26,760
um your program should never get into

525
00:19:26,760 --> 00:19:28,380
the kernel in the first place

526
00:19:28,380 --> 00:19:31,520
I'll talk about verification in a minute

527
00:19:31,520 --> 00:19:34,740
but you can't run kernel functions but

528
00:19:34,740 --> 00:19:37,440
what you do get is BPF helpers of

529
00:19:37,440 --> 00:19:39,960
whichever loads right

530
00:19:39,960 --> 00:19:41,580
um but some useful ones is like again

531
00:19:41,580 --> 00:19:43,620
data in and out and deleting it from

532
00:19:43,620 --> 00:19:44,820
Maps

533
00:19:44,820 --> 00:19:46,919
um accessing memory so you can safely

534
00:19:46,919 --> 00:19:48,900
Access Memory that you're allowed to

535
00:19:48,900 --> 00:19:50,340
access perhaps

536
00:19:50,340 --> 00:19:52,799
and uh and then and dump your stuff out

537
00:19:52,799 --> 00:19:55,440
as I said before

538
00:19:55,440 --> 00:19:56,880
um you can get interesting information

539
00:19:56,880 --> 00:19:58,559
about the process that you're running on

540
00:19:58,559 --> 00:20:00,120
you can get information about the task

541
00:20:00,120 --> 00:20:02,460
that has been stopped

542
00:20:02,460 --> 00:20:04,919
including its task struct and if you

543
00:20:04,919 --> 00:20:06,480
don't know about the task Direct

544
00:20:06,480 --> 00:20:07,700
you go to

545
00:20:07,700 --> 00:20:10,320
bootland.elixir elixir.booting.com and

546
00:20:10,320 --> 00:20:12,419
you can look at the task direct and find

547
00:20:12,419 --> 00:20:14,160
that it can change everything a process

548
00:20:14,160 --> 00:20:15,900
needs to know about itself all its

549
00:20:15,900 --> 00:20:18,179
metadata with links off to its file

550
00:20:18,179 --> 00:20:20,760
descriptor table links to the file

551
00:20:20,760 --> 00:20:24,900
system that's mounted on memory creds to

552
00:20:24,900 --> 00:20:27,360
work so if you can get appointed to the

553
00:20:27,360 --> 00:20:29,220
task for actually using BPF get current

554
00:20:29,220 --> 00:20:32,520
task you can manipulate it manipulate

555
00:20:32,520 --> 00:20:35,460
that task to get useful information

556
00:20:35,460 --> 00:20:38,520
so um you can get information on the

557
00:20:38,520 --> 00:20:40,320
helpers

558
00:20:40,320 --> 00:20:43,380
by uh you know demand BPF helpers you

559
00:20:43,380 --> 00:20:45,900
know and look it up and then there's a

560
00:20:45,900 --> 00:20:48,059
there's a lot of links there for to kind

561
00:20:48,059 --> 00:20:50,100
of projects I've mentioned

562
00:20:50,100 --> 00:20:50,880
um

563
00:20:50,880 --> 00:20:52,860
right let's talk about what's difficult

564
00:20:52,860 --> 00:20:55,440
because it makes it sound so easy

565
00:20:55,440 --> 00:20:57,960
when you load your program it goes

566
00:20:57,960 --> 00:21:00,419
through a verification process a verify

567
00:21:00,419 --> 00:21:03,000
in the kernel and it verifies that your

568
00:21:03,000 --> 00:21:05,520
program will stop and it will stop

569
00:21:05,520 --> 00:21:07,620
within a million instructions on older

570
00:21:07,620 --> 00:21:10,799
kernels 4096 instructions

571
00:21:10,799 --> 00:21:12,419
um so it will

572
00:21:12,419 --> 00:21:15,660
try all the different branches of the

573
00:21:15,660 --> 00:21:18,780
program and check that you're not doing

574
00:21:18,780 --> 00:21:20,940
anything dangerous like access and

575
00:21:20,940 --> 00:21:23,340
memory you shouldn't be able to access

576
00:21:23,340 --> 00:21:25,559
um I mean in some of these cases looping

577
00:21:25,559 --> 00:21:27,240
when you shouldn't be allowed to Loop

578
00:21:27,240 --> 00:21:28,559
before

579
00:21:28,559 --> 00:21:31,740
kernel 5.3 you weren't allowed to Loop

580
00:21:31,740 --> 00:21:32,720
um

581
00:21:32,720 --> 00:21:35,039
you couldn't mix function calls or Tel

582
00:21:35,039 --> 00:21:37,919
calls you know on certain versions and

583
00:21:37,919 --> 00:21:40,380
you can sleep which I'll talk about in a

584
00:21:40,380 --> 00:21:41,700
moment

585
00:21:41,700 --> 00:21:43,200
um because that's that's interesting

586
00:21:43,200 --> 00:21:44,880
it's in its own right

587
00:21:44,880 --> 00:21:47,580
if your program passes verification then

588
00:21:47,580 --> 00:21:48,780
it gets attached to the point you want

589
00:21:48,780 --> 00:21:51,059
to attach it to the kernel then it runs

590
00:21:51,059 --> 00:21:53,820
most of your time is spent trying to

591
00:21:53,820 --> 00:21:56,640
make your program satisfy the verifier

592
00:21:56,640 --> 00:21:58,020
to make sure the verifier is happy with

593
00:21:58,020 --> 00:21:59,880
it which can be a

594
00:21:59,880 --> 00:22:02,100
not very enjoyable process some of the

595
00:22:02,100 --> 00:22:03,179
times but you know the more you do it

596
00:22:03,179 --> 00:22:04,500
the better you get so

597
00:22:04,500 --> 00:22:07,100
fair enough

598
00:22:07,380 --> 00:22:08,640
um

599
00:22:08,640 --> 00:22:11,580
sort of things as I say you can't access

600
00:22:11,580 --> 00:22:13,260
memory directly like you would if you're

601
00:22:13,260 --> 00:22:15,659
a Kona module you have to use these

602
00:22:15,659 --> 00:22:18,120
helpers BPF probe reading BPF Pro Brite

603
00:22:18,120 --> 00:22:20,100
not every

604
00:22:20,100 --> 00:22:22,980
BPF program type of which there are many

605
00:22:22,980 --> 00:22:25,380
different program types can access every

606
00:22:25,380 --> 00:22:27,780
kind of helper so depending on where you

607
00:22:27,780 --> 00:22:29,580
attacked and what kind of attachment you

608
00:22:29,580 --> 00:22:32,340
want will constrain you as to what you

609
00:22:32,340 --> 00:22:34,500
can actually do so choosing the program

610
00:22:34,500 --> 00:22:37,200
type is is kind of key

611
00:22:37,200 --> 00:22:38,460
um if you if you know if you want to

612
00:22:38,460 --> 00:22:41,460
look at packets then there are SKB you

613
00:22:41,460 --> 00:22:45,500
know socket buff type programs which get

614
00:22:45,500 --> 00:22:48,120
better helpers for reading out packet

615
00:22:48,120 --> 00:22:50,640
data that SKB load bytes will read bikes

616
00:22:50,640 --> 00:22:53,280
from a packet if you're attaching as a

617
00:22:53,280 --> 00:22:55,440
k-probe for example you can still get

618
00:22:55,440 --> 00:22:57,900
access to that socket buff but you're

619
00:22:57,900 --> 00:22:59,820
Now using BPF Pro breed to read the

620
00:22:59,820 --> 00:23:02,640
memory and the packet will be aligned

621
00:23:02,640 --> 00:23:05,280
and laid out however the SK buff is laid

622
00:23:05,280 --> 00:23:07,860
out not linear as it would be if you're

623
00:23:07,860 --> 00:23:10,980
using like SKB load bytes so

624
00:23:10,980 --> 00:23:12,539
you get more flexibility with the

625
00:23:12,539 --> 00:23:15,360
k-probe but you lose some of their

626
00:23:15,360 --> 00:23:17,159
useful helpers so there's a there's

627
00:23:17,159 --> 00:23:20,039
trade-offs and choices to be made there

628
00:23:20,039 --> 00:23:21,900
um but basically if you try and do

629
00:23:21,900 --> 00:23:23,640
anything the verifier doesn't like it

630
00:23:23,640 --> 00:23:25,440
just bans your program tells you no you

631
00:23:25,440 --> 00:23:27,419
can't have it and that's mainly there to

632
00:23:27,419 --> 00:23:30,059
make it safe the idea is it's not really

633
00:23:30,059 --> 00:23:31,679
a security boundary it's more of a

634
00:23:31,679 --> 00:23:33,419
safety boundary the idea is to try and

635
00:23:33,419 --> 00:23:35,580
stop you doing something silly rather

636
00:23:35,580 --> 00:23:37,620
than trying to prevent you to do doing

637
00:23:37,620 --> 00:23:40,919
something that could compromise a

638
00:23:40,919 --> 00:23:42,299
process

639
00:23:42,299 --> 00:23:45,179
or compromise the kernel

640
00:23:45,179 --> 00:23:46,140
um

641
00:23:46,140 --> 00:23:47,460
so

642
00:23:47,460 --> 00:23:48,840
um memory access one of the things it

643
00:23:48,840 --> 00:23:50,940
does is it checks what you can read so

644
00:23:50,940 --> 00:23:53,220
if you if you have an array like an

645
00:23:53,220 --> 00:23:55,919
example here an array of six elements

646
00:23:55,919 --> 00:23:59,280
and your index is you know just an

647
00:23:59,280 --> 00:24:01,380
integer well theoretically that index

648
00:24:01,380 --> 00:24:03,000
could be any number you like it could be

649
00:24:03,000 --> 00:24:05,940
27 it could be 200 million right

650
00:24:05,940 --> 00:24:08,700
um so theoretically you could access

651
00:24:08,700 --> 00:24:10,020
memory that you're not allowed to access

652
00:24:10,020 --> 00:24:12,419
so the verifier doesn't know how you're

653
00:24:12,419 --> 00:24:14,280
using that index

654
00:24:14,280 --> 00:24:17,400
very much it just it just knows there's

655
00:24:17,400 --> 00:24:19,679
an index so it wants you to constrain

656
00:24:19,679 --> 00:24:22,679
that like forcibly and one way to do

657
00:24:22,679 --> 00:24:24,840
that is to make your array a power of

658
00:24:24,840 --> 00:24:28,080
two in size and then just mask off that

659
00:24:28,080 --> 00:24:31,140
index immediately before you use it now

660
00:24:31,140 --> 00:24:33,480
in some situations

661
00:24:33,480 --> 00:24:35,580
uh you get you'll you'll run out of

662
00:24:35,580 --> 00:24:37,860
registers especially you're compiling C

663
00:24:37,860 --> 00:24:39,539
right you'll run out of registers and

664
00:24:39,539 --> 00:24:43,740
what will happen is um is clang will put

665
00:24:43,740 --> 00:24:46,500
your index on the stack and then go off

666
00:24:46,500 --> 00:24:47,940
and do other things and then retrieve it

667
00:24:47,940 --> 00:24:50,039
from the stack and in certain versions

668
00:24:50,039 --> 00:24:54,120
of the kernel the verifier didn't follow

669
00:24:54,120 --> 00:24:56,520
those elements after they've gone to the

670
00:24:56,520 --> 00:24:58,559
stack and come back so you can strain

671
00:24:58,559 --> 00:25:01,740
your index like here we you know and

672
00:25:01,740 --> 00:25:03,600
seven we bound it to it's got only

673
00:25:03,600 --> 00:25:06,000
values between naught and seven and then

674
00:25:06,000 --> 00:25:08,159
clang sticks it onto the stack and then

675
00:25:08,159 --> 00:25:09,600
when the verify when it comes back off

676
00:25:09,600 --> 00:25:11,340
the site the very things well that's a

677
00:25:11,340 --> 00:25:13,500
completely unbounded index that could be

678
00:25:13,500 --> 00:25:15,240
any number you like

679
00:25:15,240 --> 00:25:19,320
um so sometimes you will find clang's

680
00:25:19,320 --> 00:25:21,179
done something stupid and even though

681
00:25:21,179 --> 00:25:24,360
your C code is right you can't get clang

682
00:25:24,360 --> 00:25:25,980
to make code that the verifier is happy

683
00:25:25,980 --> 00:25:27,360
with

684
00:25:27,360 --> 00:25:28,980
um the solution

685
00:25:28,980 --> 00:25:33,120
is inline assembly so not only are you

686
00:25:33,120 --> 00:25:35,279
fighting with a verifier and trying to

687
00:25:35,279 --> 00:25:37,580
do difficult things you also now

688
00:25:37,580 --> 00:25:40,860
rewriting your c as assembler in line in

689
00:25:40,860 --> 00:25:44,039
your program in order to force clang to

690
00:25:44,039 --> 00:25:45,840
do the right thing at the right point

691
00:25:45,840 --> 00:25:49,200
and not spill the registers so it can I

692
00:25:49,200 --> 00:25:52,559
say it can get a bit tricky

693
00:25:52,559 --> 00:25:53,700
um

694
00:25:53,700 --> 00:25:56,340
I mean Loops so before 5.3 you weren't

695
00:25:56,340 --> 00:25:57,960
allowed any loops and so all you do is

696
00:25:57,960 --> 00:25:59,640
just unroll them in clang and clang will

697
00:25:59,640 --> 00:26:01,020
just like unroll the loops for you make

698
00:26:01,020 --> 00:26:02,340
it big and clang is quite good at

699
00:26:02,340 --> 00:26:04,500
unrolling loops

700
00:26:04,500 --> 00:26:07,380
um but once you get to version 5.3 of

701
00:26:07,380 --> 00:26:08,700
the kernel right you can have loops so

702
00:26:08,700 --> 00:26:11,520
why don't you use them well you do but

703
00:26:11,520 --> 00:26:12,720
you have to be careful because the

704
00:26:12,720 --> 00:26:14,640
verifier is not that smart about leaps

705
00:26:14,640 --> 00:26:16,980
so it likes ones that are simple for

706
00:26:16,980 --> 00:26:19,679
Loops like following an index but if you

707
00:26:19,679 --> 00:26:22,380
start sticking complex terms in the in

708
00:26:22,380 --> 00:26:24,960
the test for the loop it can't

709
00:26:24,960 --> 00:26:26,700
rationalize what you're trying to do

710
00:26:26,700 --> 00:26:28,799
there are too many paths appear it

711
00:26:28,799 --> 00:26:30,600
becomes too complicated for it and it

712
00:26:30,600 --> 00:26:33,480
basically gives up so instead um you

713
00:26:33,480 --> 00:26:36,000
need to make your Loop simple and break

714
00:26:36,000 --> 00:26:38,880
out of your Loops using break statements

715
00:26:38,880 --> 00:26:40,140
um

716
00:26:40,140 --> 00:26:42,539
it makes you right

717
00:26:42,539 --> 00:26:45,779
more bulletproof code and easier to if

718
00:26:45,779 --> 00:26:47,340
it's easier for the verifier to

719
00:26:47,340 --> 00:26:49,679
rationalize what's happening and and

720
00:26:49,679 --> 00:26:52,080
reason about what could go wrong or what

721
00:26:52,080 --> 00:26:54,779
or what could happen then it's going to

722
00:26:54,779 --> 00:26:56,940
be easier for you to do the same so you

723
00:26:56,940 --> 00:26:59,279
essentially write code that probably has

724
00:26:59,279 --> 00:27:01,500
fewer bugs because you can actually see

725
00:27:01,500 --> 00:27:03,179
what's going on you're either trying to

726
00:27:03,179 --> 00:27:04,980
write Fancy clever stuff that takes up

727
00:27:04,980 --> 00:27:07,400
less space

728
00:27:07,980 --> 00:27:10,620
um oh I've talked about sleeping so I

729
00:27:10,620 --> 00:27:11,640
didn't know anything about sleeping

730
00:27:11,640 --> 00:27:14,940
until I got to uh to BPF but what

731
00:27:14,940 --> 00:27:16,620
normally happens when your program tries

732
00:27:16,620 --> 00:27:18,059
to access some memory and that memory is

733
00:27:18,059 --> 00:27:20,400
not paged in is it tries to access a

734
00:27:20,400 --> 00:27:24,179
memory location and interrupt fires the

735
00:27:24,179 --> 00:27:26,159
control gets passed over to the kernel

736
00:27:26,159 --> 00:27:27,779
the kernel sees that you're trying to

737
00:27:27,779 --> 00:27:29,100
access a particular memory location and

738
00:27:29,100 --> 00:27:31,200
it's not paged in Pages the memory in

739
00:27:31,200 --> 00:27:32,820
for you and then returns from the

740
00:27:32,820 --> 00:27:34,440
interrupt where the instruction that

741
00:27:34,440 --> 00:27:36,960
you've just run runs again and then but

742
00:27:36,960 --> 00:27:38,520
this time the memory is there and it

743
00:27:38,520 --> 00:27:40,860
gets the piece remember it wanted so the

744
00:27:40,860 --> 00:27:43,799
program is completely unaware that this

745
00:27:43,799 --> 00:27:46,200
has happened if you run if you've timed

746
00:27:46,200 --> 00:27:48,539
things you could spot when it happens

747
00:27:48,539 --> 00:27:49,500
and when it doesn't happen because

748
00:27:49,500 --> 00:27:50,820
obviously there's a there's a time

749
00:27:50,820 --> 00:27:52,559
element it's very small but there's a

750
00:27:52,559 --> 00:27:54,480
time element

751
00:27:54,480 --> 00:27:57,000
um before 5.10 when they introduced

752
00:27:57,000 --> 00:27:59,820
sleeping programs it basically you tried

753
00:27:59,820 --> 00:28:01,919
to access the memory like BPF probe read

754
00:28:01,919 --> 00:28:04,799
and you just went no no you can't after

755
00:28:04,799 --> 00:28:07,200
that uh give me back another message and

756
00:28:07,200 --> 00:28:09,059
uh and the member you've asked for is

757
00:28:09,059 --> 00:28:11,400
all zeros so

758
00:28:11,400 --> 00:28:14,039
this is a problem

759
00:28:14,039 --> 00:28:16,020
um usually when you're trying to read

760
00:28:16,020 --> 00:28:19,620
user space memory so for example if

761
00:28:19,620 --> 00:28:21,900
someone is if you're attached to the

762
00:28:21,900 --> 00:28:24,240
open Cisco which is the sort of thing

763
00:28:24,240 --> 00:28:26,340
like a normal tracing program the audit

764
00:28:26,340 --> 00:28:28,320
D yeah okay audit does it

765
00:28:28,320 --> 00:28:29,039
um

766
00:28:29,039 --> 00:28:31,440
the the other tracing programs like

767
00:28:31,440 --> 00:28:34,500
Tracy and um Falco and things like that

768
00:28:34,500 --> 00:28:36,419
um if you're attach to ciscals which is

769
00:28:36,419 --> 00:28:37,620
the normal thing to do like there's an

770
00:28:37,620 --> 00:28:39,779
open Cisco for opening files there's a

771
00:28:39,779 --> 00:28:42,900
you know write reads things like that

772
00:28:42,900 --> 00:28:44,640
um in that open Cisco one of the

773
00:28:44,640 --> 00:28:45,900
parameters is the file name you're

774
00:28:45,900 --> 00:28:46,860
trying to open

775
00:28:46,860 --> 00:28:49,080
so it would be logical for your BPF

776
00:28:49,080 --> 00:28:51,720
program to read that and report it

777
00:28:51,720 --> 00:28:53,520
I mean as I say it's a user space buffer

778
00:28:53,520 --> 00:28:56,340
so because of the Phantom attack it what

779
00:28:56,340 --> 00:28:58,020
use what your program sees and what the

780
00:28:58,020 --> 00:29:00,900
kernel sees might be different due to

781
00:29:00,900 --> 00:29:02,820
timing and stuff but assuming it's

782
00:29:02,820 --> 00:29:05,400
correct

783
00:29:05,400 --> 00:29:07,440
um you try and read that buffer it might

784
00:29:07,440 --> 00:29:09,480
be paged out by the time your BPF

785
00:29:09,480 --> 00:29:11,100
program runs because the kernel might

786
00:29:11,100 --> 00:29:12,900
need that you know they might your your

787
00:29:12,900 --> 00:29:14,940
process your your

788
00:29:14,940 --> 00:29:17,640
um other processes might be busy using

789
00:29:17,640 --> 00:29:19,980
all sorts of other memory

790
00:29:19,980 --> 00:29:24,240
um so the trick I found if you happen to

791
00:29:24,240 --> 00:29:28,380
want to do that is on the entry point to

792
00:29:28,380 --> 00:29:31,440
the syscall so sys Center open app for

793
00:29:31,440 --> 00:29:33,840
example store the pointer to that user

794
00:29:33,840 --> 00:29:36,120
space buffer in a map and then on the

795
00:29:36,120 --> 00:29:37,620
exit that CIS called have another

796
00:29:37,620 --> 00:29:39,659
program that runs which retrieves from

797
00:29:39,659 --> 00:29:42,299
the map that uh that pointer and then

798
00:29:42,299 --> 00:29:44,640
reads the memory on the basis that if

799
00:29:44,640 --> 00:29:46,740
the kernel has just read that memory in

800
00:29:46,740 --> 00:29:48,659
order to open the file it's probably

801
00:29:48,659 --> 00:29:50,340
still paged in

802
00:29:50,340 --> 00:29:53,039
not you know foolproof but is better

803
00:29:53,039 --> 00:29:55,860
than nothing what's a better solution of

804
00:29:55,860 --> 00:29:58,620
course is sit on the exit of open where

805
00:29:58,620 --> 00:30:00,299
you get where the return value is a file

806
00:30:00,299 --> 00:30:01,679
descriptor

807
00:30:01,679 --> 00:30:03,840
um for the file and then instead go into

808
00:30:03,840 --> 00:30:05,700
the task find the file descriptor table

809
00:30:05,700 --> 00:30:07,799
and then find the file description in

810
00:30:07,799 --> 00:30:09,000
the file description table and that will

811
00:30:09,000 --> 00:30:11,220
point you at an inode and that I node

812
00:30:11,220 --> 00:30:12,840
will have a directory entry and that

813
00:30:12,840 --> 00:30:14,159
directory entry will have the name of

814
00:30:14,159 --> 00:30:15,000
the file

815
00:30:15,000 --> 00:30:17,520
obviously it'll only be the

816
00:30:17,520 --> 00:30:19,799
the actual name of the file not the

817
00:30:19,799 --> 00:30:21,240
directory it's in for that you'd have to

818
00:30:21,240 --> 00:30:23,340
look at the parent entry and get the

819
00:30:23,340 --> 00:30:24,720
name of the parent you know the

820
00:30:24,720 --> 00:30:26,700
directory it's in but of course that's

821
00:30:26,700 --> 00:30:27,600
just

822
00:30:27,600 --> 00:30:29,820
that part of the follow-up path so you'd

823
00:30:29,820 --> 00:30:32,159
have to map you'd have to like recurse

824
00:30:32,159 --> 00:30:35,159
continually in order to get the full

825
00:30:35,159 --> 00:30:36,840
path like directory by directory and of

826
00:30:36,840 --> 00:30:37,980
course once you get back to the root

827
00:30:37,980 --> 00:30:39,779
directory you might not be at the root

828
00:30:39,779 --> 00:30:40,980
you might be an amount points and then

829
00:30:40,980 --> 00:30:42,600
you have to look at the mount points and

830
00:30:42,600 --> 00:30:44,520
see um see where that's mounted and then

831
00:30:44,520 --> 00:30:46,500
do the same process again to map all the

832
00:30:46,500 --> 00:30:48,120
way back until you get a full path and

833
00:30:48,120 --> 00:30:49,919
of course the path could have 2048

834
00:30:49,919 --> 00:30:52,020
directories in it technically on Linux

835
00:30:52,020 --> 00:30:54,360
because the path name could be 4096

836
00:30:54,360 --> 00:30:58,140
characters long so um how are you doing

837
00:30:58,140 --> 00:30:59,720
that without loops

838
00:30:59,720 --> 00:31:02,700
uh or even with loops it's it's quite a

839
00:31:02,700 --> 00:31:04,799
it's quite a tricky thing to do it uses

840
00:31:04,799 --> 00:31:06,600
a lot of instructions and you hit that

841
00:31:06,600 --> 00:31:08,279
million instruction count really quickly

842
00:31:08,279 --> 00:31:12,000
so there are some difficult things but

843
00:31:12,000 --> 00:31:15,500
it swings around about us you know

844
00:31:15,539 --> 00:31:18,899
um in 5.7 they added some new helpers uh

845
00:31:18,899 --> 00:31:21,059
which make life a bit easier

846
00:31:21,059 --> 00:31:23,520
um so if you're running code on 5.7 or

847
00:31:23,520 --> 00:31:24,360
later

848
00:31:24,360 --> 00:31:25,919
brilliant use the helpers that are

849
00:31:25,919 --> 00:31:28,320
available but it's one of those things

850
00:31:28,320 --> 00:31:30,720
you know what are you if you're building

851
00:31:30,720 --> 00:31:33,299
an observability program what what are

852
00:31:33,299 --> 00:31:34,500
you running on well you're running on

853
00:31:34,500 --> 00:31:37,200
whatever the user is running on and

854
00:31:37,200 --> 00:31:38,700
there and and that's basically what it

855
00:31:38,700 --> 00:31:40,799
was deployed and people are running some

856
00:31:40,799 --> 00:31:43,440
old kernels out there in the wild

857
00:31:43,440 --> 00:31:45,659
um I mean technogon we support back to

858
00:31:45,659 --> 00:31:47,940
4.19 I think psyllium Sports backed them

859
00:31:47,940 --> 00:31:49,740
much earlier kind of like four or four

860
00:31:49,740 --> 00:31:51,179
or something

861
00:31:51,179 --> 00:31:52,799
um because that's what people are

862
00:31:52,799 --> 00:31:56,340
running so it's nice that new helpers

863
00:31:56,340 --> 00:31:58,820
appear and give you more functionality

864
00:31:58,820 --> 00:32:01,559
and you could have versions of your

865
00:32:01,559 --> 00:32:04,140
programs that use those when they detect

866
00:32:04,140 --> 00:32:05,940
a kernel that's got them

867
00:32:05,940 --> 00:32:07,919
but you still have to work for the

868
00:32:07,919 --> 00:32:09,840
lowest common denominator which uh the

869
00:32:09,840 --> 00:32:11,700
smaller set of helpers the more

870
00:32:11,700 --> 00:32:13,679
difficult kind of set

871
00:32:13,679 --> 00:32:16,380
so so that that in itself is a bit

872
00:32:16,380 --> 00:32:18,720
tricky

873
00:32:18,720 --> 00:32:19,500
um

874
00:32:19,500 --> 00:32:21,720
I mean you know this is just something I

875
00:32:21,720 --> 00:32:22,980
discovered

876
00:32:22,980 --> 00:32:24,840
um I mean I probably wasn't the only one

877
00:32:24,840 --> 00:32:26,760
to discover it it's it's it's just

878
00:32:26,760 --> 00:32:29,880
amused to me that when you send data

879
00:32:29,880 --> 00:32:32,220
into the ring buffer it's using a u64 to

880
00:32:32,220 --> 00:32:34,919
specify its size which is huge huger

881
00:32:34,919 --> 00:32:37,020
than anything you could possibly imagine

882
00:32:37,020 --> 00:32:39,840
um but otherwise it was a u32 and the

883
00:32:39,840 --> 00:32:42,539
u32 is like four gig in size yeah okay

884
00:32:42,539 --> 00:32:44,100
fair enough that's that's really big

885
00:32:44,100 --> 00:32:44,940
still

886
00:32:44,940 --> 00:32:46,740
but um it goes through the perf

887
00:32:46,740 --> 00:32:48,299
subsystem and in the perf subsystem

888
00:32:48,299 --> 00:32:50,820
that's a u16

889
00:32:50,820 --> 00:32:52,980
um so if you try and send in more than

890
00:32:52,980 --> 00:32:55,440
64k of data

891
00:32:55,440 --> 00:32:59,220
um what actually happens is it sends all

892
00:32:59,220 --> 00:33:02,039
of the data that you have put in

893
00:33:02,039 --> 00:33:04,380
but the points are in the ring buffer is

894
00:33:04,380 --> 00:33:08,700
only Advanced by less than 64k like

895
00:33:08,700 --> 00:33:10,380
whatever it is after it's been masked

896
00:33:10,380 --> 00:33:12,600
off so if you sent in

897
00:33:12,600 --> 00:33:16,860
um six 4K and eight bytes the pointer

898
00:33:16,860 --> 00:33:18,419
would Advanced by eight bytes even

899
00:33:18,419 --> 00:33:20,159
though this whole 64k and eight bytes is

900
00:33:20,159 --> 00:33:22,080
in the ring buffer and therefore the

901
00:33:22,080 --> 00:33:23,640
next sample that arrives in the ring

902
00:33:23,640 --> 00:33:26,279
buffer will overwrite so unless you get

903
00:33:26,279 --> 00:33:28,260
it out fast enough it or it constantly

904
00:33:28,260 --> 00:33:30,360
gets overwritten and corrupted which is

905
00:33:30,360 --> 00:33:32,159
just hilarious

906
00:33:32,159 --> 00:33:34,919
um on top of that it's not exactly 64k

907
00:33:34,919 --> 00:33:36,480
because there's headers in there as well

908
00:33:36,480 --> 00:33:38,640
which you aren't aware of and you can't

909
00:33:38,640 --> 00:33:40,919
easily find programmatically which

910
00:33:40,919 --> 00:33:42,240
headers will be in there and how big

911
00:33:42,240 --> 00:33:44,360
they are but they're about you know

912
00:33:44,360 --> 00:33:48,000
eight between eight and 48 bytes in size

913
00:33:48,000 --> 00:33:52,080
um I mean I usually assume say 64 bytes

914
00:33:52,080 --> 00:33:55,799
uh so you think 64k is a lot of space

915
00:33:55,799 --> 00:33:59,760
it's not if a command line can be 128k

916
00:33:59,760 --> 00:34:02,279
so what you need to do is chunk up your

917
00:34:02,279 --> 00:34:04,559
data um send it in send it in packets

918
00:34:04,559 --> 00:34:06,960
and to be honest there's really good

919
00:34:06,960 --> 00:34:08,639
reasons for chunking it up anyway

920
00:34:08,639 --> 00:34:10,560
because

921
00:34:10,560 --> 00:34:12,719
the ring buffer can get saturated and

922
00:34:12,719 --> 00:34:14,460
when it gets saturated it will just drop

923
00:34:14,460 --> 00:34:17,159
those samples so those events

924
00:34:17,159 --> 00:34:19,139
which obviously you care about those

925
00:34:19,139 --> 00:34:20,339
events you've sent them for user space

926
00:34:20,339 --> 00:34:21,480
you want to you want to read them right

927
00:34:21,480 --> 00:34:23,399
but if too much is happening and you're

928
00:34:23,399 --> 00:34:24,839
not reading it out fast enough or the

929
00:34:24,839 --> 00:34:26,820
ring Buffer's not big enough you'll you

930
00:34:26,820 --> 00:34:30,239
lose events so if you Chunk Up Your

931
00:34:30,239 --> 00:34:33,239
events into smaller packets one it makes

932
00:34:33,239 --> 00:34:35,339
it much more efficient anyway and

933
00:34:35,339 --> 00:34:37,320
therefore it's quicker to read stuff out

934
00:34:37,320 --> 00:34:40,800
but two imagine if your event instead of

935
00:34:40,800 --> 00:34:42,179
being one big

936
00:34:42,179 --> 00:34:44,820
so I say pack it but I want one big

937
00:34:44,820 --> 00:34:47,040
struct instead it which could get lost

938
00:34:47,040 --> 00:34:49,139
it's eight smaller ones which are

939
00:34:49,139 --> 00:34:50,760
numbered and could be reconstructing the

940
00:34:50,760 --> 00:34:52,440
user space well if one of those eight

941
00:34:52,440 --> 00:34:55,080
doesn't arrive you know it's not arrived

942
00:34:55,080 --> 00:34:56,820
but you you still have some information

943
00:34:56,820 --> 00:34:58,500
about the event you still know the event

944
00:34:58,500 --> 00:35:00,960
happened like a process was executed uh

945
00:35:00,960 --> 00:35:03,780
a process Forks or whatever you just

946
00:35:03,780 --> 00:35:06,119
might be missing some of the data if you

947
00:35:06,119 --> 00:35:08,160
missed the entire event you don't even

948
00:35:08,160 --> 00:35:09,780
know what happened right all you know is

949
00:35:09,780 --> 00:35:13,380
that you've lost packets that's it

950
00:35:13,380 --> 00:35:14,579
um

951
00:35:14,579 --> 00:35:16,619
other interesting things the kernel

952
00:35:16,619 --> 00:35:18,000
Strokes which you really want to get

953
00:35:18,000 --> 00:35:20,540
access to and read stuff out of change

954
00:35:20,540 --> 00:35:23,520
kernel by kernel right and they also

955
00:35:23,520 --> 00:35:25,440
change configuration by configuration so

956
00:35:25,440 --> 00:35:26,760
depending on how someone's compiled

957
00:35:26,760 --> 00:35:28,320
their kernel the structs will be

958
00:35:28,320 --> 00:35:30,660
different layouts to what you're

959
00:35:30,660 --> 00:35:32,220
expecting

960
00:35:32,220 --> 00:35:33,660
um and the way to get around that is a

961
00:35:33,660 --> 00:35:36,420
single BPF type format which describes

962
00:35:36,420 --> 00:35:38,040
the kernel

963
00:35:38,040 --> 00:35:38,640
um

964
00:35:38,640 --> 00:35:41,640
it technically arrives in Ford 18 but it

965
00:35:41,640 --> 00:35:44,400
wasn't enabled in any distribution by

966
00:35:44,400 --> 00:35:46,859
default until Ubuntu 2010 now it's

967
00:35:46,859 --> 00:35:48,480
becoming quite common to be enabled

968
00:35:48,480 --> 00:35:50,400
because it's it's really useful it tells

969
00:35:50,400 --> 00:35:51,960
you about the size and shapes of Strokes

970
00:35:51,960 --> 00:35:53,099
so you can so you can learn about them

971
00:35:53,099 --> 00:35:55,200
so you can access them

972
00:35:55,200 --> 00:35:57,660
um but there are so there are other ways

973
00:35:57,660 --> 00:35:59,880
of acquiring that data

974
00:35:59,880 --> 00:36:02,579
um we have a incident evpf we have a

975
00:36:02,579 --> 00:36:05,400
means of of getting that BTF data

976
00:36:05,400 --> 00:36:10,140
um Aqua BTF Hub which has databases of

977
00:36:10,140 --> 00:36:13,140
those layouts available on their website

978
00:36:13,140 --> 00:36:14,700
and your program can go and get that

979
00:36:14,700 --> 00:36:16,619
programmatically based on the Kernel

980
00:36:16,619 --> 00:36:18,900
version assuming it's an off-the-shelf

981
00:36:18,900 --> 00:36:20,880
distro

982
00:36:20,880 --> 00:36:24,180
um and uh in one of the assist internals

983
00:36:24,180 --> 00:36:25,740
I built one into the system Turner's

984
00:36:25,740 --> 00:36:27,000
ebpf Library

985
00:36:27,000 --> 00:36:28,859
so that tries a few different ways of

986
00:36:28,859 --> 00:36:30,780
getting that data

987
00:36:30,780 --> 00:36:32,820
um it doesn't get the whole BTF it only

988
00:36:32,820 --> 00:36:34,920
gets the data that I cared about so you

989
00:36:34,920 --> 00:36:36,780
have to manually extend it but one of

990
00:36:36,780 --> 00:36:39,660
the ways it did it was um like with BPF

991
00:36:39,660 --> 00:36:41,339
you can read memory from the task direct

992
00:36:41,339 --> 00:36:43,740
so what I did was I dumped the task

993
00:36:43,740 --> 00:36:47,220
trucks from from like a BPF program and

994
00:36:47,220 --> 00:36:49,200
then into user space and then I'll hunt

995
00:36:49,200 --> 00:36:50,880
through that for information I know so I

996
00:36:50,880 --> 00:36:53,220
know the patented because they're my pit

997
00:36:53,220 --> 00:36:54,660
and tip right so I can hunt for that in

998
00:36:54,660 --> 00:36:56,579
that space when I find it I now know the

999
00:36:56,579 --> 00:36:59,160
offset to the pin tid I know roughly

1000
00:36:59,160 --> 00:37:02,220
what comes before and after I can detect

1001
00:37:02,220 --> 00:37:04,859
a pointer if I detector Point uh I can

1002
00:37:04,859 --> 00:37:06,660
ask my BPF program to dump memory from

1003
00:37:06,660 --> 00:37:09,720
that pointer I know why credentials so I

1004
00:37:09,720 --> 00:37:11,520
can so I can hunt for the credentials in

1005
00:37:11,520 --> 00:37:13,380
it and so basically I did memory

1006
00:37:13,380 --> 00:37:15,480
forensics using BPF in order to

1007
00:37:15,480 --> 00:37:17,280
understand the layout of structs in

1008
00:37:17,280 --> 00:37:19,380
order to make my BPF programs know where

1009
00:37:19,380 --> 00:37:21,180
to find stuff

1010
00:37:21,180 --> 00:37:23,160
I mean it's a bit Cavalier and when I

1011
00:37:23,160 --> 00:37:25,920
told Mark personovich he said that's how

1012
00:37:25,920 --> 00:37:27,900
I do it in programs on Windows anyway so

1013
00:37:27,900 --> 00:37:29,520
that's a perfectly reasonable way of

1014
00:37:29,520 --> 00:37:32,280
doing things so it's it's not as mad as

1015
00:37:32,280 --> 00:37:34,500
it sounds but um but when you look at it

1016
00:37:34,500 --> 00:37:35,820
you'll think

1017
00:37:35,820 --> 00:37:38,520
how could how could that ever work

1018
00:37:38,520 --> 00:37:39,780
um

1019
00:37:39,780 --> 00:37:41,520
licensing is something that you'll

1020
00:37:41,520 --> 00:37:43,140
probably need to come overcome if you

1021
00:37:43,140 --> 00:37:45,540
are going to use BPF so the helpers that

1022
00:37:45,540 --> 00:37:49,380
you want to use are gpl2 licensed now

1023
00:37:49,380 --> 00:37:51,300
so there's this thing I've never seen

1024
00:37:51,300 --> 00:37:53,820
before in the world of Licensing every

1025
00:37:53,820 --> 00:37:56,160
BPF program has to specify its license

1026
00:37:56,160 --> 00:37:59,280
in the code in a section in the elf

1027
00:37:59,280 --> 00:38:00,540
right

1028
00:38:00,540 --> 00:38:02,400
I've never seen that before

1029
00:38:02,400 --> 00:38:03,900
and what happens when you load your

1030
00:38:03,900 --> 00:38:06,780
program in is it takes that license and

1031
00:38:06,780 --> 00:38:09,060
then it decides which BPF helpers you

1032
00:38:09,060 --> 00:38:10,619
can have based on what license your

1033
00:38:10,619 --> 00:38:12,839
program is running so if you say I'm MIT

1034
00:38:12,839 --> 00:38:14,820
it's like great of course you can run

1035
00:38:14,820 --> 00:38:16,560
but you can't have BPF probe read

1036
00:38:16,560 --> 00:38:19,920
because that's a gpl2 helper so you

1037
00:38:19,920 --> 00:38:21,839
basically have to license your program

1038
00:38:21,839 --> 00:38:24,300
as gpl2 and specify in the code that

1039
00:38:24,300 --> 00:38:25,980
it's GPL to not even in the

1040
00:38:25,980 --> 00:38:27,480
documentation

1041
00:38:27,480 --> 00:38:28,920
um so as a result your code will

1042
00:38:28,920 --> 00:38:30,780
probably use GPL to

1043
00:38:30,780 --> 00:38:31,500
um

1044
00:38:31,500 --> 00:38:35,460
uh Liberty BPF for both old GPO 2.1

1045
00:38:35,460 --> 00:38:37,859
which are allowed to load be GPL 2

1046
00:38:37,859 --> 00:38:40,560
phones into the kernel and uh you can

1047
00:38:40,560 --> 00:38:43,859
attach you can you can dynamically link

1048
00:38:43,859 --> 00:38:46,079
to that from any license or program so

1049
00:38:46,079 --> 00:38:47,400
you can write something that's MRT or

1050
00:38:47,400 --> 00:38:51,180
Apache and you can or or bespoke

1051
00:38:51,180 --> 00:38:53,220
proprietary licensing and you can

1052
00:38:53,220 --> 00:38:55,339
dynamically link to lgpl

1053
00:38:55,339 --> 00:38:57,660
libraries that can then load GPL

1054
00:38:57,660 --> 00:38:59,400
programs

1055
00:38:59,400 --> 00:39:01,320
oh yeah I know this because I asked a

1056
00:39:01,320 --> 00:39:02,640
lawyer when I worked at Microsoft and

1057
00:39:02,640 --> 00:39:05,339
this is the advice that um that I

1058
00:39:05,339 --> 00:39:07,619
understood them to have said obviously I

1059
00:39:07,619 --> 00:39:09,420
can't say that in any more strong terms

1060
00:39:09,420 --> 00:39:11,160
than that but this is what I this was my

1061
00:39:11,160 --> 00:39:13,020
understanding of what they said and I'm

1062
00:39:13,020 --> 00:39:15,119
not a lawyer so um do get your own

1063
00:39:15,119 --> 00:39:16,859
advice but if you're a releasing code

1064
00:39:16,859 --> 00:39:19,380
you might want to think rather than you

1065
00:39:19,380 --> 00:39:21,300
could just GPL to everything and then

1066
00:39:21,300 --> 00:39:23,339
you're definitely safe right but if you

1067
00:39:23,339 --> 00:39:25,140
don't want to do that for reasons

1068
00:39:25,140 --> 00:39:26,880
you might want to think about this

1069
00:39:26,880 --> 00:39:28,380
because obviously if you if your code's

1070
00:39:28,380 --> 00:39:29,640
gpl2

1071
00:39:29,640 --> 00:39:31,880
and you're delivering it as a binary

1072
00:39:31,880 --> 00:39:35,220
anyone could ask you for the source of

1073
00:39:35,220 --> 00:39:36,660
that program

1074
00:39:36,660 --> 00:39:37,980
um which which could have some

1075
00:39:37,980 --> 00:39:39,660
ramifications or impact on your

1076
00:39:39,660 --> 00:39:40,859
commercial

1077
00:39:40,859 --> 00:39:43,380
future I guess

1078
00:39:43,380 --> 00:39:44,400
um

1079
00:39:44,400 --> 00:39:47,220
so vulnerable stuff

1080
00:39:47,220 --> 00:39:49,160
um I'm not going to go into

1081
00:39:49,160 --> 00:39:52,260
vulnerabilities per se

1082
00:39:52,260 --> 00:39:55,200
but if you look up on um you know on the

1083
00:39:55,200 --> 00:39:56,760
CV databases you'll find there's quite a

1084
00:39:56,760 --> 00:39:59,760
few vulnerabilities related to BPF and

1085
00:39:59,760 --> 00:40:02,760
most of them are related to live BPF

1086
00:40:02,760 --> 00:40:05,160
like the loader library and it's just

1087
00:40:05,160 --> 00:40:08,099
the normal everyday bugs no one really

1088
00:40:08,099 --> 00:40:10,140
cares like you're probably root anyway

1089
00:40:10,140 --> 00:40:12,000
before you load it so like you know if

1090
00:40:12,000 --> 00:40:13,800
you compromise a library in your routes

1091
00:40:13,800 --> 00:40:16,680
you're still root it's not really that

1092
00:40:16,680 --> 00:40:19,560
sort of horrible or damaging the more

1093
00:40:19,560 --> 00:40:21,240
interesting bugs and the ones that I

1094
00:40:21,240 --> 00:40:23,160
think are worth reading about even if

1095
00:40:23,160 --> 00:40:25,079
you don't care about BPF but you just

1096
00:40:25,079 --> 00:40:28,500
want to read about a really cool bug

1097
00:40:28,500 --> 00:40:30,839
um a really cool vulnerability are some

1098
00:40:30,839 --> 00:40:32,460
of the more recent ones to do with the

1099
00:40:32,460 --> 00:40:33,660
verifier

1100
00:40:33,660 --> 00:40:34,920
so

1101
00:40:34,920 --> 00:40:36,960
the verifier

1102
00:40:36,960 --> 00:40:40,619
checks all of the code before it loads

1103
00:40:40,619 --> 00:40:42,420
it into the kernel that's that's what we

1104
00:40:42,420 --> 00:40:44,520
understand however

1105
00:40:44,520 --> 00:40:46,800
it also tracks the state of variables

1106
00:40:46,800 --> 00:40:49,619
and if you

1107
00:40:49,619 --> 00:40:53,640
if it thinks a variable can only be zero

1108
00:40:53,640 --> 00:40:56,400
and you have a if statement based on

1109
00:40:56,400 --> 00:40:59,520
that variable it will only verify the

1110
00:40:59,520 --> 00:41:00,359
path

1111
00:41:00,359 --> 00:41:02,880
of where obviously of the side of the if

1112
00:41:02,880 --> 00:41:05,280
statement which which for when it's zero

1113
00:41:05,280 --> 00:41:07,260
right you know so you know if if a

1114
00:41:07,260 --> 00:41:10,200
equals zero do x y z it'll verify that

1115
00:41:10,200 --> 00:41:12,000
but it won't verify the else Clause

1116
00:41:12,000 --> 00:41:13,920
because as far as it's concerned that

1117
00:41:13,920 --> 00:41:15,480
variable can only be zero so it's never

1118
00:41:15,480 --> 00:41:16,680
going to look at the rest of that code

1119
00:41:16,680 --> 00:41:18,300
and it needs to do that for practical

1120
00:41:18,300 --> 00:41:19,740
pragmatic reasons because it needs to

1121
00:41:19,740 --> 00:41:21,480
reduce the amount of work it's doing so

1122
00:41:21,480 --> 00:41:23,220
that happens quickly

1123
00:41:23,220 --> 00:41:26,640
Etc well what some very clever people

1124
00:41:26,640 --> 00:41:29,880
discovered was that because of bugs in

1125
00:41:29,880 --> 00:41:33,240
the verifier you could get a one into a

1126
00:41:33,240 --> 00:41:35,460
variable when the verifier thinks it's a

1127
00:41:35,460 --> 00:41:38,579
zero now what it means is it's not it it

1128
00:41:38,579 --> 00:41:41,579
verifies the part where it thinks the

1129
00:41:41,579 --> 00:41:43,320
you know the path based on the variable

1130
00:41:43,320 --> 00:41:44,880
being zero and ignores the other path

1131
00:41:44,880 --> 00:41:47,640
which can do horrible damaging crazy

1132
00:41:47,640 --> 00:41:49,859
things and then when your program runs

1133
00:41:49,859 --> 00:41:51,839
actually that variable is a one and you

1134
00:41:51,839 --> 00:41:53,520
go into the unverified path where you

1135
00:41:53,520 --> 00:41:54,960
can do what you like read any memory you

1136
00:41:54,960 --> 00:41:55,619
like

1137
00:41:55,619 --> 00:41:56,520
Etc

1138
00:41:56,520 --> 00:41:58,140
it's um

1139
00:41:58,140 --> 00:42:02,280
it's a logic driven bug or logic driven

1140
00:42:02,280 --> 00:42:05,280
exploit and it's not like anything I've

1141
00:42:05,280 --> 00:42:07,859
read before so I think I found that

1142
00:42:07,859 --> 00:42:09,180
interesting to read even if you're not

1143
00:42:09,180 --> 00:42:10,680
interested in BPF it's worth it's worth

1144
00:42:10,680 --> 00:42:12,180
a read so that's the reason why I wanted

1145
00:42:12,180 --> 00:42:13,740
to briefly talk about vulnerabilities

1146
00:42:13,740 --> 00:42:14,880
the other thing to say about

1147
00:42:14,880 --> 00:42:16,320
vulnerabilities is

1148
00:42:16,320 --> 00:42:18,119
um you'll hear you know people say oh

1149
00:42:18,119 --> 00:42:20,760
you know the fundraising BPF

1150
00:42:20,760 --> 00:42:23,940
there are right but running BPF programs

1151
00:42:23,940 --> 00:42:25,079
doesn't make you any more vulnerable

1152
00:42:25,079 --> 00:42:27,900
like the vulnerability is in the kernel

1153
00:42:27,900 --> 00:42:29,700
um it's if your attacker is on your

1154
00:42:29,700 --> 00:42:31,619
machine as roots and they run a BPF

1155
00:42:31,619 --> 00:42:32,700
program they might be able to conference

1156
00:42:32,700 --> 00:42:35,160
the kernel that's the vulnerability so

1157
00:42:35,160 --> 00:42:39,599
don't not run BPF programs because

1158
00:42:39,599 --> 00:42:41,040
um because there's a vulnerability

1159
00:42:41,040 --> 00:42:42,359
because it doesn't make you any more

1160
00:42:42,359 --> 00:42:43,980
vulnerable what makes you vulnerable is

1161
00:42:43,980 --> 00:42:45,660
having BPF turned on in the first place

1162
00:42:45,660 --> 00:42:48,000
but if you want to do packet capturing

1163
00:42:48,000 --> 00:42:49,500
and you want to run any of the cool

1164
00:42:49,500 --> 00:42:51,720
stuff that's coming out today you kind

1165
00:42:51,720 --> 00:42:53,880
of need BPF turned on and you will find

1166
00:42:53,880 --> 00:42:56,520
BPF is on by default in all the major

1167
00:42:56,520 --> 00:42:59,520
distributions and has been for years so

1168
00:42:59,520 --> 00:43:00,839
um so those vulnerabilities already

1169
00:43:00,839 --> 00:43:02,700
exist so the only thing you can do is

1170
00:43:02,700 --> 00:43:04,560
patch your kernels

1171
00:43:04,560 --> 00:43:06,240
um you know apply the patches upgrade

1172
00:43:06,240 --> 00:43:08,280
your kernels uh use more recent kernels

1173
00:43:08,280 --> 00:43:11,880
use less buggy kernels

1174
00:43:11,880 --> 00:43:12,480
um

1175
00:43:12,480 --> 00:43:14,160
so that's basically what I was going to

1176
00:43:14,160 --> 00:43:15,300
say

1177
00:43:15,300 --> 00:43:15,900
um

1178
00:43:15,900 --> 00:43:18,599
it's an amazing technology it lets you

1179
00:43:18,599 --> 00:43:20,520
run code in a place where you unless

1180
00:43:20,520 --> 00:43:21,720
you're writing kernel modules you'll

1181
00:43:21,720 --> 00:43:22,800
probably never had the opportunity to

1182
00:43:22,800 --> 00:43:24,119
run code before

1183
00:43:24,119 --> 00:43:27,720
and with that code you can reach

1184
00:43:27,720 --> 00:43:29,700
parts of the system that you probably

1185
00:43:29,700 --> 00:43:31,980
could never observe before and you can

1186
00:43:31,980 --> 00:43:34,920
do that lightningly fast

1187
00:43:34,920 --> 00:43:36,599
um you know in a way that we've never

1188
00:43:36,599 --> 00:43:39,119
seen before on Linux it's regarded as

1189
00:43:39,119 --> 00:43:41,880
the biggest change to an operating

1190
00:43:41,880 --> 00:43:44,220
system kernel for 50 years it's massive

1191
00:43:44,220 --> 00:43:46,140
and we're just going to see more and

1192
00:43:46,140 --> 00:43:47,460
more of this and you're going to hear

1193
00:43:47,460 --> 00:43:50,160
more and more about BPF and BPF based

1194
00:43:50,160 --> 00:43:52,319
tools so um

1195
00:43:52,319 --> 00:43:54,000
with that

1196
00:43:54,000 --> 00:43:56,099
uh I know the first question is always

1197
00:43:56,099 --> 00:43:58,619
can you give me those links again so I

1198
00:43:58,619 --> 00:44:01,760
will say any questions

1199
00:44:02,460 --> 00:44:04,940
huh

1200
00:44:06,980 --> 00:44:11,000
can we have a hands up for questions

1201
00:44:13,200 --> 00:44:15,000
I'll be around I'll probably be in the

1202
00:44:15,000 --> 00:44:18,900
bar feel free to come and hassle me oh

1203
00:44:18,900 --> 00:44:20,760
there's a couple of probe vendors out

1204
00:44:20,760 --> 00:44:21,660
there you're going to be having a

1205
00:44:21,660 --> 00:44:24,540
conversation with them is it who a

1206
00:44:24,540 --> 00:44:27,119
couple of probe vendors out there oh are

1207
00:44:27,119 --> 00:44:30,119
you going to be having a conversation I

1208
00:44:30,119 --> 00:44:31,560
might go and ask them what they're up to

1209
00:44:31,560 --> 00:44:33,540
yeah um I might sell them something the

1210
00:44:33,540 --> 00:44:35,779
other day

1211
00:44:36,480 --> 00:44:38,880
nobody else then I must have done a

1212
00:44:38,880 --> 00:44:41,060
fantastic job thank you

1213
00:44:41,060 --> 00:44:45,179
[Applause]

