1
00:00:04,549 --> 00:00:09,840
awesome ok everybody welcome to my talk

2
00:00:07,529 --> 00:00:12,870
this year waiter there's a compiler in

3
00:00:09,840 --> 00:00:15,899
my shellcode I think this is my fourth

4
00:00:12,870 --> 00:00:17,160
time speaking at NOLA con so I missed a

5
00:00:15,900 --> 00:00:18,690
couple years our house flooded and

6
00:00:17,160 --> 00:00:20,970
everything was crazy life went on hold

7
00:00:18,690 --> 00:00:22,350
but I'm back and this is a project I've

8
00:00:20,970 --> 00:00:24,090
been working on for a few years this is

9
00:00:22,350 --> 00:00:25,140
actually not connected to what I do for

10
00:00:24,090 --> 00:00:27,029
work at all

11
00:00:25,140 --> 00:00:28,590
so something that I'm particularly

12
00:00:27,029 --> 00:00:29,279
passionate about looking forward to

13
00:00:28,590 --> 00:00:32,308
sharing it

14
00:00:29,279 --> 00:00:36,000
I'm Josh stone I've been this year I've

15
00:00:32,308 --> 00:00:36,750
been programming for 30 years I started

16
00:00:36,000 --> 00:00:39,660
when I was 8

17
00:00:36,750 --> 00:00:41,850
with a 286 and been working

18
00:00:39,660 --> 00:00:44,218
professionally in InfoSec for 19 years I

19
00:00:41,850 --> 00:00:47,190
also have a real life's I married I have

20
00:00:44,219 --> 00:00:48,539
kids had cancer 14 years ago if you're

21
00:00:47,190 --> 00:00:50,280
interested in talking about personal

22
00:00:48,539 --> 00:00:51,989
stuff let me know a few years ago I

23
00:00:50,280 --> 00:00:54,059
realized that being a nerd is unhealthy

24
00:00:51,989 --> 00:00:54,510
and so to stay alive I started Brazilian

25
00:00:54,059 --> 00:00:56,788
Jujitsu

26
00:00:54,510 --> 00:00:58,829
and I'm a blue belt now and if you can't

27
00:00:56,789 --> 00:01:01,890
tell yet by looking at the slides I love

28
00:00:58,829 --> 00:01:04,229
the color graphics array currently I

29
00:01:01,890 --> 00:01:05,880
work at fusion X on the research and

30
00:01:04,229 --> 00:01:09,090
development team they're part of

31
00:01:05,880 --> 00:01:11,699
Accenture however like I said this

32
00:01:09,090 --> 00:01:13,470
project is about evil VM is something

33
00:01:11,700 --> 00:01:16,229
that predates my coming to Accenture and

34
00:01:13,470 --> 00:01:19,340
any similarity between my opinions and

35
00:01:16,229 --> 00:01:23,780
my employers opinions is coincidental

36
00:01:19,340 --> 00:01:26,250
today I'm talking about a sort of core

37
00:01:23,780 --> 00:01:28,710
discontinuity in the way we deploy

38
00:01:26,250 --> 00:01:31,770
malicious code so as an offensive hacker

39
00:01:28,710 --> 00:01:34,110
as a pen tester working with red teamers

40
00:01:31,770 --> 00:01:36,570
and so forth we find ourselves in the

41
00:01:34,110 --> 00:01:38,009
position of writing malicious code but

42
00:01:36,570 --> 00:01:39,570
most programming languages and most

43
00:01:38,009 --> 00:01:42,810
development environments are not

44
00:01:39,570 --> 00:01:45,929
designed with this use case in mind so

45
00:01:42,810 --> 00:01:48,180
it's maybe tautological but programming

46
00:01:45,930 --> 00:01:49,950
languages as you they know enable you to

47
00:01:48,180 --> 00:01:51,570
write programs so you can run them on

48
00:01:49,950 --> 00:01:52,950
your computer maybe you don't run them

49
00:01:51,570 --> 00:01:54,658
on your computer maybe you give them to

50
00:01:52,950 --> 00:01:56,369
somebody else and they run it on their

51
00:01:54,659 --> 00:01:58,380
computer but nevertheless there's

52
00:01:56,369 --> 00:02:00,000
something really wrong with this as far

53
00:01:58,380 --> 00:02:03,149
as the core use case when you're writing

54
00:02:00,000 --> 00:02:04,680
malware and that is that a hacker is not

55
00:02:03,149 --> 00:02:07,110
writing software to run on his own

56
00:02:04,680 --> 00:02:09,780
computer he's writing something to run

57
00:02:07,110 --> 00:02:12,239
on someone else's computer and it has a

58
00:02:09,780 --> 00:02:12,580
number of profound implications on how

59
00:02:12,239 --> 00:02:14,140
you

60
00:02:12,580 --> 00:02:16,720
design your programming language and how

61
00:02:14,140 --> 00:02:19,329
you develop your code I'd love to go

62
00:02:16,720 --> 00:02:20,740
into more detail on this stuff but I

63
00:02:19,330 --> 00:02:22,570
don't have a lot of time for the talk

64
00:02:20,740 --> 00:02:24,460
and I'll kind of gloss over this just a

65
00:02:22,570 --> 00:02:26,350
bit it's just important to note that a

66
00:02:24,460 --> 00:02:28,630
lot of programming languages make

67
00:02:26,350 --> 00:02:30,190
certain assumptions about how code is

68
00:02:28,630 --> 00:02:32,440
going to be written and how it will be

69
00:02:30,190 --> 00:02:34,060
deployed with most programming

70
00:02:32,440 --> 00:02:37,600
environments if you're thinking about C

71
00:02:34,060 --> 00:02:40,270
or C sharp or C++ or Python Ruby Lisp

72
00:02:37,600 --> 00:02:41,620
whatever you usually have the assumption

73
00:02:40,270 --> 00:02:43,300
that you're going to use the computer's

74
00:02:41,620 --> 00:02:44,560
resources you're going to write files to

75
00:02:43,300 --> 00:02:46,900
the disk the user can install

76
00:02:44,560 --> 00:02:48,940
dependencies and they're allowed to run

77
00:02:46,900 --> 00:02:51,340
it and none of these are true when

78
00:02:48,940 --> 00:02:53,859
you're writing malware so when we try to

79
00:02:51,340 --> 00:02:55,690
use a lot of the common or very popular

80
00:02:53,860 --> 00:02:57,850
programming languages to write hacking

81
00:02:55,690 --> 00:02:59,500
tools we're coming up against some

82
00:02:57,850 --> 00:03:01,690
design decisions that are working

83
00:02:59,500 --> 00:03:04,690
against us we make it work we get it

84
00:03:01,690 --> 00:03:06,790
done but it's not necessarily easy so I

85
00:03:04,690 --> 00:03:09,040
set out a few years ago after writing

86
00:03:06,790 --> 00:03:11,280
post exploitation tools in all of those

87
00:03:09,040 --> 00:03:14,200
languages C and Python and Ruby c-sharp

88
00:03:11,280 --> 00:03:15,850
PowerShell and anything you can think of

89
00:03:14,200 --> 00:03:16,988
and some weird ones like Haskell that

90
00:03:15,850 --> 00:03:18,760
most people have never heard of unless

91
00:03:16,989 --> 00:03:21,340
you're a real program programming

92
00:03:18,760 --> 00:03:22,840
language nerd and I found that I'm

93
00:03:21,340 --> 00:03:24,880
always running into issues

94
00:03:22,840 --> 00:03:28,060
what would an ideal malicious

95
00:03:24,880 --> 00:03:30,280
programming language look like so first

96
00:03:28,060 --> 00:03:32,500
of all a good malicious programming

97
00:03:30,280 --> 00:03:34,480
environment would make small programs

98
00:03:32,500 --> 00:03:36,670
and this has become more of an issue in

99
00:03:34,480 --> 00:03:39,280
the recent developments because we've

100
00:03:36,670 --> 00:03:41,559
got things like golang which is very

101
00:03:39,280 --> 00:03:43,660
popular but produces a 3 megabyte hello

102
00:03:41,560 --> 00:03:45,489
world and this is because they have

103
00:03:43,660 --> 00:03:47,170
highly abstracted languages that just

104
00:03:45,489 --> 00:03:48,700
pack a ton of stuff into the runtime

105
00:03:47,170 --> 00:03:50,619
environment and even when they do

106
00:03:48,700 --> 00:03:52,660
pruning you still end up with a gigantic

107
00:03:50,620 --> 00:03:54,430
thing and you might not think this is

108
00:03:52,660 --> 00:03:56,010
too big of a deal except that I've

109
00:03:54,430 --> 00:03:59,709
occasionally been in situations where

110
00:03:56,010 --> 00:04:01,540
for example I want to deliver my malware

111
00:03:59,709 --> 00:04:04,239
to a system through which I can only

112
00:04:01,540 --> 00:04:06,640
access it with a KVM so what are my

113
00:04:04,239 --> 00:04:08,290
options it's on an air-gapped Network I

114
00:04:06,640 --> 00:04:10,690
have a KTM that means I have a keyboard

115
00:04:08,290 --> 00:04:12,730
so I'm going to type my program in I

116
00:04:10,690 --> 00:04:14,320
might hex encode it and type it in or

117
00:04:12,730 --> 00:04:16,060
base64 encode it type it in and then

118
00:04:14,320 --> 00:04:18,579
upload a decoder and decode it so I can

119
00:04:16,060 --> 00:04:20,858
run my my tool on that box but you don't

120
00:04:18,579 --> 00:04:22,630
want to do that if it's three megabytes

121
00:04:20,858 --> 00:04:24,638
protip if you're ever in that situation

122
00:04:22,630 --> 00:04:25,990
you want it less than 100k

123
00:04:24,639 --> 00:04:27,520
because otherwise you're going to be

124
00:04:25,990 --> 00:04:31,509
there for a long time at 62 and a half

125
00:04:27,520 --> 00:04:33,250
characters per second next an ideal

126
00:04:31,509 --> 00:04:34,780
malicious programming environment would

127
00:04:33,250 --> 00:04:36,879
give me a lot of flexibility in how I

128
00:04:34,780 --> 00:04:38,979
execute my code most programming

129
00:04:36,879 --> 00:04:41,409
languages are designed to give you an

130
00:04:38,979 --> 00:04:44,409
executable or maybe you have a program

131
00:04:41,409 --> 00:04:45,699
that is a text file that's going to be

132
00:04:44,409 --> 00:04:47,560
executed by an interpreter or something

133
00:04:45,699 --> 00:04:49,449
like that there's usually a dead code

134
00:04:47,560 --> 00:04:50,830
version of your program and that means

135
00:04:49,449 --> 00:04:54,580
it gets written to disk and we hate that

136
00:04:50,830 --> 00:04:56,438
because that leaves IOC s so ideally I'd

137
00:04:54,580 --> 00:04:58,389
be able to package the programs that my

138
00:04:56,439 --> 00:05:01,060
environment creates in any different way

139
00:04:58,389 --> 00:05:02,710
that I want and ideally over here on the

140
00:05:01,060 --> 00:05:04,240
right don't worry about trying to read

141
00:05:02,710 --> 00:05:06,818
it it's just shell code all right this

142
00:05:04,240 --> 00:05:09,129
is just a hex literal string in a C

143
00:05:06,819 --> 00:05:10,509
header that that would be my dream is

144
00:05:09,129 --> 00:05:13,300
every program that comes out of this

145
00:05:10,509 --> 00:05:15,039
language its shell code another

146
00:05:13,300 --> 00:05:18,370
interesting thing about malicious code

147
00:05:15,039 --> 00:05:20,378
is that I'm not just writing and using a

148
00:05:18,370 --> 00:05:22,449
program I have to interact with it in a

149
00:05:20,379 --> 00:05:23,979
subversive way I'm not sitting at the

150
00:05:22,449 --> 00:05:25,810
monitor I don't have the keyboard I

151
00:05:23,979 --> 00:05:28,150
can't use the GUI I need to get

152
00:05:25,810 --> 00:05:30,039
information in and out now a lot of

153
00:05:28,150 --> 00:05:33,719
programming languages don't really give

154
00:05:30,039 --> 00:05:36,279
you any sort of built-in remote i/o

155
00:05:33,719 --> 00:05:37,839
capabilities now we do it because we

156
00:05:36,279 --> 00:05:40,479
implement our own we write our own

157
00:05:37,839 --> 00:05:42,639
protocols and communicate with our tools

158
00:05:40,479 --> 00:05:44,229
but it would be really nice if my

159
00:05:42,639 --> 00:05:46,810
malicious programming language did that

160
00:05:44,229 --> 00:05:48,419
for me I could write one payload and

161
00:05:46,810 --> 00:05:50,710
then use it with any different

162
00:05:48,419 --> 00:05:54,159
communication scheme that I need to and

163
00:05:50,710 --> 00:05:55,870
not have to change my program next a

164
00:05:54,159 --> 00:05:58,870
good malicious programming language

165
00:05:55,870 --> 00:06:00,520
would give me a high ceiling and a low

166
00:05:58,870 --> 00:06:02,319
floor this is something programming

167
00:06:00,520 --> 00:06:03,818
language theorists talk about a low

168
00:06:02,319 --> 00:06:05,860
floor means I can get as close to the

169
00:06:03,819 --> 00:06:08,050
metal as I can I can get down to machine

170
00:06:05,860 --> 00:06:09,939
code and talk to the CPU I can work

171
00:06:08,050 --> 00:06:12,550
directly with memory I need things like

172
00:06:09,939 --> 00:06:14,379
pointers but then if I want to be very

173
00:06:12,550 --> 00:06:16,029
productive I want what's called a high

174
00:06:14,379 --> 00:06:19,539
ceiling I want to be able to interact

175
00:06:16,029 --> 00:06:21,189
with my problem domain with high level

176
00:06:19,539 --> 00:06:24,490
language abstractions I don't want to

177
00:06:21,189 --> 00:06:26,439
have to get too too busy with all of the

178
00:06:24,490 --> 00:06:28,479
details underneath and I'd like to write

179
00:06:26,439 --> 00:06:30,669
my code quickly and run it when I'm

180
00:06:28,479 --> 00:06:32,680
presenting today it definitely has a

181
00:06:30,669 --> 00:06:34,149
very low floor and I have the beginnings

182
00:06:32,680 --> 00:06:36,310
of the high ceiling I haven't completely

183
00:06:34,149 --> 00:06:38,490
achieved all of my goals here

184
00:06:36,310 --> 00:06:40,660
but we'll get there at some point

185
00:06:38,490 --> 00:06:42,460
another thing about an ideal malicious

186
00:06:40,660 --> 00:06:44,440
language would be now that it would take

187
00:06:42,460 --> 00:06:46,630
into account the fact that the runtime

188
00:06:44,440 --> 00:06:48,639
use case for malicious code is very

189
00:06:46,630 --> 00:06:51,669
different from the runtime use case for

190
00:06:48,639 --> 00:06:53,710
regular code usually if you go to create

191
00:06:51,669 --> 00:06:55,510
a software product you'll produce it

192
00:06:53,710 --> 00:06:57,340
with some use case in mind it

193
00:06:55,510 --> 00:06:59,039
accomplishes that use you give it to the

194
00:06:57,340 --> 00:07:01,690
user they run it and it does the thing

195
00:06:59,040 --> 00:07:03,400
when you're using a hacking tool though

196
00:07:01,690 --> 00:07:05,440
a lot of times you don't even know what

197
00:07:03,400 --> 00:07:07,539
you want your program to do until it's

198
00:07:05,440 --> 00:07:10,690
already running because you may get a

199
00:07:07,540 --> 00:07:12,940
beachhead on another system and collect

200
00:07:10,690 --> 00:07:14,410
information about that host you know

201
00:07:12,940 --> 00:07:15,940
what user context it is what it's

202
00:07:14,410 --> 00:07:18,490
connected to what rights it has and that

203
00:07:15,940 --> 00:07:20,919
will inform what choices you make about

204
00:07:18,490 --> 00:07:22,480
what you do next so it would be nice if

205
00:07:20,919 --> 00:07:24,400
the programming language did this for me

206
00:07:22,480 --> 00:07:27,370
too and made it very easy for me to

207
00:07:24,400 --> 00:07:30,070
dynamically load new behavior and change

208
00:07:27,370 --> 00:07:31,990
its functionality interactively over

209
00:07:30,070 --> 00:07:33,340
time and now this is something we do

210
00:07:31,990 --> 00:07:35,200
actually accomplish with a lot of tools

211
00:07:33,340 --> 00:07:37,750
if you look at a lot of the post

212
00:07:35,200 --> 00:07:39,760
exploitation frameworks out there they

213
00:07:37,750 --> 00:07:41,620
can dynamically load code but a lot of

214
00:07:39,760 --> 00:07:43,360
times what they're doing is they're

215
00:07:41,620 --> 00:07:45,580
working against the machinery of the

216
00:07:43,360 --> 00:07:47,770
programming language so for example if

217
00:07:45,580 --> 00:07:50,469
you write your tool in c and you want to

218
00:07:47,770 --> 00:07:53,409
send new code down you're going to write

219
00:07:50,470 --> 00:07:56,590
some more code in C compile it and build

220
00:07:53,410 --> 00:07:58,539
it into maybe reflective DLL and that

221
00:07:56,590 --> 00:08:00,099
works but it's also a pain in the butt

222
00:07:58,539 --> 00:08:01,510
and it's not really the way you're

223
00:08:00,100 --> 00:08:04,180
supposed to do it and what we're really

224
00:08:01,510 --> 00:08:07,060
doing is just making lemonade if you

225
00:08:04,180 --> 00:08:09,010
will so my first thought after looking

226
00:08:07,060 --> 00:08:11,289
around at a bunch of things was to

227
00:08:09,010 --> 00:08:15,219
achieve a lot of these goals it would be

228
00:08:11,289 --> 00:08:17,320
nice if I could make my tool as like a

229
00:08:15,220 --> 00:08:19,000
little VM it would be a shell code that

230
00:08:17,320 --> 00:08:21,400
bootstraps a little a little VM that

231
00:08:19,000 --> 00:08:23,350
gives me some abstractions system access

232
00:08:21,400 --> 00:08:26,140
that I need and then I would connect to

233
00:08:23,350 --> 00:08:28,600
it remotely and have some sort of

234
00:08:26,140 --> 00:08:30,460
compiler or something on my side that

235
00:08:28,600 --> 00:08:32,349
would compile code modules to byte code

236
00:08:30,460 --> 00:08:35,140
send it down to the VM and run it so

237
00:08:32,349 --> 00:08:38,229
imagine like a super tiny JVM that runs

238
00:08:35,140 --> 00:08:40,750
as a shell code but as I played around

239
00:08:38,229 --> 00:08:42,580
with a bunch of different prototypes and

240
00:08:40,750 --> 00:08:45,370
I tried different ideas and what I ended

241
00:08:42,580 --> 00:08:47,680
up finding is that I don't really need

242
00:08:45,370 --> 00:08:48,970
to do that I can go so much further and

243
00:08:47,680 --> 00:08:49,689
I decided that I've either gone

244
00:08:48,970 --> 00:08:51,190
completely

245
00:08:49,690 --> 00:08:54,190
saying or this is actually pretty cool

246
00:08:51,190 --> 00:08:55,780
so after the talk you tell me so this is

247
00:08:54,190 --> 00:08:58,000
still a viable idea I still have a few

248
00:08:55,780 --> 00:08:59,829
ideas on the VM side but what I ended up

249
00:08:58,000 --> 00:09:01,480
deciding was that I was just going to

250
00:08:59,830 --> 00:09:03,760
put the entire language in the shell

251
00:09:01,480 --> 00:09:04,990
code so compiler and all as you already

252
00:09:03,760 --> 00:09:07,450
know from the title so it's not like I'm

253
00:09:04,990 --> 00:09:09,310
keeping a secret and he's you see on the

254
00:09:07,450 --> 00:09:11,080
bottom here I had already called the

255
00:09:09,310 --> 00:09:13,390
project evil VM and blogged about it a

256
00:09:11,080 --> 00:09:15,040
bit and I didn't want to take the VM off

257
00:09:13,390 --> 00:09:17,350
because who wants to Google for evil and

258
00:09:15,040 --> 00:09:19,120
hope you find a programming language so

259
00:09:17,350 --> 00:09:22,120
anyway it's a misnomer at birth

260
00:09:19,120 --> 00:09:24,850
my apologies so what I'm presenting

261
00:09:22,120 --> 00:09:28,090
today and publishing today's here is

262
00:09:24,850 --> 00:09:29,530
evil VM it is a client-server model so

263
00:09:28,090 --> 00:09:31,630
you run a server console on your own

264
00:09:29,530 --> 00:09:33,280
system and you deploy the agent agent

265
00:09:31,630 --> 00:09:36,400
runs on that host connects back to you

266
00:09:33,280 --> 00:09:38,020
and it is itself a compiler in fact it's

267
00:09:36,400 --> 00:09:40,660
a native code compiler even with a

268
00:09:38,020 --> 00:09:42,010
little optimization so if I if I pretend

269
00:09:40,660 --> 00:09:44,589
a little bit I can even say it's an

270
00:09:42,010 --> 00:09:46,150
optimizing native code compiler in this

271
00:09:44,590 --> 00:09:47,380
example and you don't really have to

272
00:09:46,150 --> 00:09:50,380
read it so much I'm just going to

273
00:09:47,380 --> 00:09:52,570
describe the shape of it I send the

274
00:09:50,380 --> 00:09:53,890
source code for a function that given a

275
00:09:52,570 --> 00:09:56,140
number tells you if it's an even number

276
00:09:53,890 --> 00:09:57,910
or an odd number and then within the

277
00:09:56,140 --> 00:10:00,100
system I can inspect it and this is all

278
00:09:57,910 --> 00:10:01,630
running on the other box I can see the

279
00:10:00,100 --> 00:10:03,100
machine code that it generates and I

280
00:10:01,630 --> 00:10:06,070
toss it over into binary ninja and you

281
00:10:03,100 --> 00:10:09,010
can see the control flow graph so to me

282
00:10:06,070 --> 00:10:12,280
nothing says low-floor quite like native

283
00:10:09,010 --> 00:10:13,900
code compiler as far as communicating

284
00:10:12,280 --> 00:10:16,120
with it there's another really

285
00:10:13,900 --> 00:10:19,360
interesting consequence of the design

286
00:10:16,120 --> 00:10:22,720
that I stumbled into and that is that IO

287
00:10:19,360 --> 00:10:25,360
becomes very simple in a lot of remote

288
00:10:22,720 --> 00:10:26,950
execution frameworks communication can

289
00:10:25,360 --> 00:10:29,020
be kind of challenging you end up with

290
00:10:26,950 --> 00:10:30,300
this intermediate layer in your code on

291
00:10:29,020 --> 00:10:32,470
the one hand you've got your

292
00:10:30,300 --> 00:10:34,510
functionality it's got a key logger it's

293
00:10:32,470 --> 00:10:36,430
got a ram scraper it runs you know

294
00:10:34,510 --> 00:10:38,410
commands whatever and then you've got

295
00:10:36,430 --> 00:10:39,699
some sort of transport layer so you're

296
00:10:38,410 --> 00:10:41,199
communicating information across the

297
00:10:39,700 --> 00:10:43,960
network and a lot of times there's this

298
00:10:41,200 --> 00:10:46,540
middle layer which is all about defining

299
00:10:43,960 --> 00:10:48,310
some protocol for representing the data

300
00:10:46,540 --> 00:10:50,290
that goes back and forth so you might

301
00:10:48,310 --> 00:10:51,790
wrap it up in JSON you might wrap it up

302
00:10:50,290 --> 00:10:53,790
in XML you might have some binary

303
00:10:51,790 --> 00:10:56,280
protocol that packs and unpacks messages

304
00:10:53,790 --> 00:10:59,560
but a lot of times that actually

305
00:10:56,280 --> 00:11:02,800
introduces extra complexity in this case

306
00:10:59,560 --> 00:11:03,459
because the agent is itself a compiler

307
00:11:02,800 --> 00:11:05,769
for a program

308
00:11:03,459 --> 00:11:07,748
language the syntax of that language

309
00:11:05,769 --> 00:11:09,100
actually governs the structure of the

310
00:11:07,749 --> 00:11:11,709
data that goes back and forth

311
00:11:09,100 --> 00:11:13,929
so my IO layer is literally just as

312
00:11:11,709 --> 00:11:15,518
stream bytes in invites out you send a

313
00:11:13,929 --> 00:11:18,189
bite to it that gets consumed by the

314
00:11:15,519 --> 00:11:18,879
compiler anytime your program prints

315
00:11:18,189 --> 00:11:20,649
data out

316
00:11:18,879 --> 00:11:23,769
that's just bytes coming back to your

317
00:11:20,649 --> 00:11:26,429
box so to add an additional IO transport

318
00:11:23,769 --> 00:11:29,050
to this is very very easy

319
00:11:26,429 --> 00:11:33,579
you basically implement three functions

320
00:11:29,050 --> 00:11:36,939
start the IO layer send a byte and read

321
00:11:33,579 --> 00:11:38,709
a byte yeah so you get those three and

322
00:11:36,939 --> 00:11:40,509
then BAM everything works and the way

323
00:11:38,709 --> 00:11:43,268
it's architected it's designed so that

324
00:11:40,509 --> 00:11:45,129
you don't really have to change anything

325
00:11:43,269 --> 00:11:47,800
in your program when you change IO

326
00:11:45,129 --> 00:11:49,869
layers because the programming language

327
00:11:47,800 --> 00:11:53,290
is just a ripple with bytes and invites

328
00:11:49,869 --> 00:11:55,860
out evil VM is small so right here

329
00:11:53,290 --> 00:11:58,748
here's an example a typical just TCP

330
00:11:55,860 --> 00:12:01,809
transport IO layer it comes out to six

331
00:11:58,749 --> 00:12:04,119
thousand two bytes this is pretty nice

332
00:12:01,809 --> 00:12:05,439
if you take had I didn't check I

333
00:12:04,119 --> 00:12:07,029
probably should have so that someone

334
00:12:05,439 --> 00:12:08,980
won't catch me getting the number wrong

335
00:12:07,029 --> 00:12:11,350
but I think if you take mingw and

336
00:12:08,980 --> 00:12:13,209
compile a basic hello world this is

337
00:12:11,350 --> 00:12:15,490
written in C which is a compact language

338
00:12:13,209 --> 00:12:18,069
you'll probably end up with an exe that

339
00:12:15,490 --> 00:12:19,660
is about that same size so I'm able to

340
00:12:18,069 --> 00:12:22,449
pack a compiler for a programming

341
00:12:19,660 --> 00:12:23,829
language and swappable IO layers and all

342
00:12:22,449 --> 00:12:25,899
this other stuff into something that's

343
00:12:23,829 --> 00:12:28,899
smaller than hello world even written in

344
00:12:25,899 --> 00:12:30,220
C compiled with most compilers I'm not

345
00:12:28,899 --> 00:12:33,129
gonna say you can't get it a little

346
00:12:30,220 --> 00:12:36,910
smaller but you get the point and it is

347
00:12:33,129 --> 00:12:38,889
a completely independent shell code the

348
00:12:36,910 --> 00:12:40,959
only requirement for the shell code to

349
00:12:38,889 --> 00:12:43,389
run to boot the compiler is to have

350
00:12:40,959 --> 00:12:45,099
kernel32 and if you don't have kernel32

351
00:12:43,389 --> 00:12:48,220
then it's not Windows and it's not a

352
00:12:45,100 --> 00:12:49,480
supported system this means you can

353
00:12:48,220 --> 00:12:51,189
package it any way you like if you have

354
00:12:49,480 --> 00:12:54,009
a way to run code then you can run the

355
00:12:51,189 --> 00:12:55,149
evil VM agent you could use a stager

356
00:12:54,009 --> 00:12:57,189
that you're already using you could pack

357
00:12:55,149 --> 00:12:59,049
it into some existing framework you

358
00:12:57,189 --> 00:13:02,589
could package it as executable whatever

359
00:12:59,049 --> 00:13:04,929
you like so I was really really pleased

360
00:13:02,589 --> 00:13:06,790
with what came about as I got this thing

361
00:13:04,929 --> 00:13:07,990
working especially once you bootstrap

362
00:13:06,790 --> 00:13:09,879
the language and you first start using

363
00:13:07,990 --> 00:13:12,220
it you're like wow this is really

364
00:13:09,879 --> 00:13:15,639
powerful I can't believe it actually

365
00:13:12,220 --> 00:13:16,960
works you might wonder and so how do I

366
00:13:15,639 --> 00:13:19,540
get all of this stuff in there

367
00:13:16,960 --> 00:13:22,000
yeah it's a small shellcode I could make

368
00:13:19,540 --> 00:13:22,990
it smaller sometimes I bump something

369
00:13:22,000 --> 00:13:24,430
out and make it a little smaller and

370
00:13:22,990 --> 00:13:26,140
then sometimes I think oh now I need to

371
00:13:24,430 --> 00:13:27,790
put this in for like better error

372
00:13:26,140 --> 00:13:29,290
messages I have to put something back in

373
00:13:27,790 --> 00:13:31,719
and make it bigger if it's been hovering

374
00:13:29,290 --> 00:13:34,360
around six or seven K now for about a

375
00:13:31,720 --> 00:13:38,200
year so how do I get this all in there

376
00:13:34,360 --> 00:13:40,480
as we know compilers are very big if you

377
00:13:38,200 --> 00:13:42,160
used GCC you're sitting on top of a

378
00:13:40,480 --> 00:13:44,890
stack of two almost two and a half

379
00:13:42,160 --> 00:13:46,930
million lines of code and in fact in

380
00:13:44,890 --> 00:13:50,529
this in this chart there a couple things

381
00:13:46,930 --> 00:13:52,089
to realize like clang uses LLVM so you

382
00:13:50,529 --> 00:13:55,300
might think well clang is a small one at

383
00:13:52,089 --> 00:13:57,490
800,000 lines but it's actually sitting

384
00:13:55,300 --> 00:13:58,959
on top of 1.2 million lines of LLVM it's

385
00:13:57,490 --> 00:14:01,779
a two million line compiler just like

386
00:13:58,959 --> 00:14:05,020
GCC and and for reference in case you

387
00:14:01,779 --> 00:14:08,709
are as old as me or older turbo Pascal

388
00:14:05,020 --> 00:14:10,740
down here at 14,000 lines of assembly is

389
00:14:08,709 --> 00:14:14,319
about the smallest compiler I could find

390
00:14:10,740 --> 00:14:17,470
without being just a a trivially toi

391
00:14:14,320 --> 00:14:19,690
compiler so that's pretty tiny and

392
00:14:17,470 --> 00:14:22,060
that's roughly in the ballpark of evil

393
00:14:19,690 --> 00:14:24,070
VMs compiler but you see we have to go

394
00:14:22,060 --> 00:14:26,619
back like 30 or 40 years before anybody

395
00:14:24,070 --> 00:14:28,260
cared how big these things were so how

396
00:14:26,620 --> 00:14:31,510
do I get this in there the main

397
00:14:28,260 --> 00:14:33,220
observation is that we can stand on the

398
00:14:31,510 --> 00:14:35,740
shoulders of giants we can see farther

399
00:14:33,220 --> 00:14:37,870
if we look back at the way computing was

400
00:14:35,740 --> 00:14:40,779
it was a memory constrained environment

401
00:14:37,870 --> 00:14:42,120
very light on resources and everyone had

402
00:14:40,779 --> 00:14:44,589
to think about how big their code was

403
00:14:42,120 --> 00:14:46,660
these days it doesn't matter because

404
00:14:44,589 --> 00:14:48,520
drives are gigantic and everybody has

405
00:14:46,660 --> 00:14:50,920
lots of memory so programming language

406
00:14:48,520 --> 00:14:52,810
designers simply don't care about it now

407
00:14:50,920 --> 00:14:54,910
so I think that there must be some law

408
00:14:52,810 --> 00:14:57,489
of nature that compilers will expand to

409
00:14:54,910 --> 00:14:59,980
fill the container available to them so

410
00:14:57,490 --> 00:15:02,560
I found a lot of inspiration in reading

411
00:14:59,980 --> 00:15:05,200
old dr. Dobbs journals and other things

412
00:15:02,560 --> 00:15:06,579
from the early 80s to see how how people

413
00:15:05,200 --> 00:15:07,900
were putting programming languages

414
00:15:06,579 --> 00:15:10,239
together on computers that had less than

415
00:15:07,900 --> 00:15:11,730
64 K a gram and there and we had

416
00:15:10,240 --> 00:15:13,839
compilers so it's definitely possible

417
00:15:11,730 --> 00:15:15,850
what I ended up settling on is

418
00:15:13,839 --> 00:15:18,670
inspiration from Chuck Moore who

419
00:15:15,850 --> 00:15:23,680
invented fourth in 1970 has anybody ever

420
00:15:18,670 --> 00:15:25,300
written a fourth program yes awesome so

421
00:15:23,680 --> 00:15:27,339
forth is ideally suited we'll get into

422
00:15:25,300 --> 00:15:28,990
some of the details about that one of

423
00:15:27,339 --> 00:15:29,350
the reasons is because Chuck Moore was

424
00:15:28,990 --> 00:15:30,700
not a

425
00:15:29,350 --> 00:15:31,960
computer scientists so he didn't know

426
00:15:30,700 --> 00:15:35,080
how you're supposed to write a compiler

427
00:15:31,960 --> 00:15:36,370
and he found a better well better maybe

428
00:15:35,080 --> 00:15:39,010
some people would get upset about that

429
00:15:36,370 --> 00:15:41,950
he found a different way to do it and in

430
00:15:39,010 --> 00:15:44,110
this case it's ideal for my scenario so

431
00:15:41,950 --> 00:15:45,820
let's look briefly at how compilers work

432
00:15:44,110 --> 00:15:47,110
you could argue with any computer

433
00:15:45,820 --> 00:15:48,640
science professor about whether these

434
00:15:47,110 --> 00:15:50,680
are the right names for the right number

435
00:15:48,640 --> 00:15:52,960
of phases but we're hand waving a

436
00:15:50,680 --> 00:15:55,120
layman's compiler course right here

437
00:15:52,960 --> 00:15:56,950
compilers go through some number of

438
00:15:55,120 --> 00:16:00,640
phases turning your source code into a

439
00:15:56,950 --> 00:16:02,650
program and some of these are like a

440
00:16:00,640 --> 00:16:04,090
focal point for some of the hardest

441
00:16:02,650 --> 00:16:06,160
problems in computer science so

442
00:16:04,090 --> 00:16:08,100
compilers are cool and a lot of stuff

443
00:16:06,160 --> 00:16:10,300
goes into them the first piece is lexing

444
00:16:08,100 --> 00:16:11,770
usually you take your program source

445
00:16:10,300 --> 00:16:14,229
code you have to break it up into pieces

446
00:16:11,770 --> 00:16:16,540
so you can see like here you know main

447
00:16:14,230 --> 00:16:18,550
with the parentheses next to it those

448
00:16:16,540 --> 00:16:21,270
are two different pieces right one is an

449
00:16:18,550 --> 00:16:23,560
empty argument string or argument

450
00:16:21,270 --> 00:16:25,630
specifier descriptor and then the other

451
00:16:23,560 --> 00:16:26,199
is the name of a function so the lexer

452
00:16:25,630 --> 00:16:27,670
breaks that up

453
00:16:26,200 --> 00:16:29,170
some languages are easier to Lex than

454
00:16:27,670 --> 00:16:30,849
others but lexing isn't really that hard

455
00:16:29,170 --> 00:16:33,040
of a problem you just have to do it

456
00:16:30,850 --> 00:16:35,020
up next is a much harder problem that's

457
00:16:33,040 --> 00:16:36,579
parsing so we have to take that list of

458
00:16:35,020 --> 00:16:39,189
lexemes that came out of the lexer and

459
00:16:36,580 --> 00:16:41,200
we arrange our program into this

460
00:16:39,190 --> 00:16:43,420
hierarchical structure the abstract

461
00:16:41,200 --> 00:16:45,640
syntax tree so this lets us do a couple

462
00:16:43,420 --> 00:16:47,650
things one the compiler can tell by

463
00:16:45,640 --> 00:16:49,480
analyzing this what order things have to

464
00:16:47,650 --> 00:16:51,280
happen so if you look at this one we

465
00:16:49,480 --> 00:16:54,670
have to add three and four before we can

466
00:16:51,280 --> 00:16:56,560
call printf right so of course a real

467
00:16:54,670 --> 00:16:58,110
compiler will realize those are

468
00:16:56,560 --> 00:17:00,839
constants and optimize it out there

469
00:16:58,110 --> 00:17:04,780
that's beyond the scope of this talk

470
00:17:00,840 --> 00:17:06,640
once we have this arranged we now go

471
00:17:04,780 --> 00:17:08,230
through several rounds of transformation

472
00:17:06,640 --> 00:17:10,180
most compilers do their optimization

473
00:17:08,230 --> 00:17:12,160
here then actually translate the program

474
00:17:10,180 --> 00:17:14,650
into different languages intermediary

475
00:17:12,160 --> 00:17:16,780
representations and some of what's going

476
00:17:14,650 --> 00:17:19,240
on here might be optimization also might

477
00:17:16,780 --> 00:17:21,010
be proving things like type safety

478
00:17:19,240 --> 00:17:22,660
proving that the program is correct or

479
00:17:21,010 --> 00:17:24,670
conforms to the semantics of the

480
00:17:22,660 --> 00:17:27,100
language this is probably the biggest

481
00:17:24,670 --> 00:17:29,710
and hardest problem in a compiler and if

482
00:17:27,099 --> 00:17:31,780
you look at GCC I pet like the vast

483
00:17:29,710 --> 00:17:34,600
majority of that two million lines of

484
00:17:31,780 --> 00:17:35,950
code is probably devoted to this once

485
00:17:34,600 --> 00:17:39,510
you know how the code needs to be

486
00:17:35,950 --> 00:17:42,190
organized and what order needs to be

487
00:17:39,510 --> 00:17:43,750
executed etc we go into code generation

488
00:17:42,190 --> 00:17:46,150
or you turn this into a

489
00:17:43,750 --> 00:17:47,200
or machine code and this can possibly be

490
00:17:46,150 --> 00:17:49,330
a hard problem because you might have to

491
00:17:47,200 --> 00:17:50,920
do a lot of register allocation there's

492
00:17:49,330 --> 00:17:53,199
some neat algorithms in there for for

493
00:17:50,920 --> 00:17:55,450
making good machine code better than

494
00:17:53,200 --> 00:17:57,070
humans can make anyway mostly and then

495
00:17:55,450 --> 00:17:58,990
finally once you have a bunch of machine

496
00:17:57,070 --> 00:18:00,850
code you go to linking so your program

497
00:17:58,990 --> 00:18:02,110
uses a library it needs to know where

498
00:18:00,850 --> 00:18:04,149
that's going to be in memory and be able

499
00:18:02,110 --> 00:18:05,620
to call it everything needs to find out

500
00:18:04,150 --> 00:18:08,440
where everything else is in order for it

501
00:18:05,620 --> 00:18:09,760
to run so forth works in a fundamentally

502
00:18:08,440 --> 00:18:12,400
different way like I said Chuck Moore

503
00:18:09,760 --> 00:18:14,830
was a physicist I believe and not a

504
00:18:12,400 --> 00:18:16,090
computer scientist originally so he had

505
00:18:14,830 --> 00:18:17,260
never read a book on compilers and

506
00:18:16,090 --> 00:18:20,559
didn't know that this is what you're

507
00:18:17,260 --> 00:18:23,140
supposed to do so in Forth lexing is

508
00:18:20,559 --> 00:18:25,660
blindingly simple is identical to

509
00:18:23,140 --> 00:18:27,160
splitting a string on white space any

510
00:18:25,660 --> 00:18:28,660
any two things that are separate from

511
00:18:27,160 --> 00:18:31,510
each other have to have white space in

512
00:18:28,660 --> 00:18:35,200
between so lexing is easy parsing

513
00:18:31,510 --> 00:18:37,240
doesn't exist in forth usually and the

514
00:18:35,200 --> 00:18:39,280
reason is because forth is designed so

515
00:18:37,240 --> 00:18:41,410
that you can compile it in one pass you

516
00:18:39,280 --> 00:18:43,059
read in a word you compile it you read

517
00:18:41,410 --> 00:18:44,800
the next one you compile it you don't

518
00:18:43,059 --> 00:18:46,960
have to arrange it and figure out the

519
00:18:44,800 --> 00:18:49,149
order of operations this comes from

520
00:18:46,960 --> 00:18:51,840
things like reverse polish notation and

521
00:18:49,150 --> 00:18:54,280
the stack structure of the language

522
00:18:51,840 --> 00:18:55,770
since there's no parse tree there's no

523
00:18:54,280 --> 00:18:58,059
transformation so that goes away

524
00:18:55,770 --> 00:18:59,920
cogeneration boils down to two things

525
00:18:58,059 --> 00:19:02,320
you have to be able to compile a

526
00:18:59,920 --> 00:19:04,240
function call which means you find where

527
00:19:02,320 --> 00:19:06,610
the function is and then write like an e

528
00:19:04,240 --> 00:19:08,740
8 and then the distance to the function

529
00:19:06,610 --> 00:19:10,570
and then the other thing is to put

530
00:19:08,740 --> 00:19:12,970
constants on the stack so the code that

531
00:19:10,570 --> 00:19:14,649
says if my program needs to put 3 and 4

532
00:19:12,970 --> 00:19:16,660
on the stack and add them there needs to

533
00:19:14,650 --> 00:19:18,429
be some code that that puts 3 on the

534
00:19:16,660 --> 00:19:20,920
stack some code that puts 4 on the stack

535
00:19:18,429 --> 00:19:22,450
so those are really really easy much

536
00:19:20,920 --> 00:19:25,030
simpler than all the register allocation

537
00:19:22,450 --> 00:19:26,350
and assigning two places in memory and

538
00:19:25,030 --> 00:19:29,410
everything that other compilers have to

539
00:19:26,350 --> 00:19:31,510
do and then fourth is usually a live

540
00:19:29,410 --> 00:19:33,130
coding environment there's usually not

541
00:19:31,510 --> 00:19:35,320
really a dead version of your program

542
00:19:33,130 --> 00:19:37,780
that needs to be run later in fact a lot

543
00:19:35,320 --> 00:19:39,399
of fourth compilers have no facility for

544
00:19:37,780 --> 00:19:41,020
creating and executable you just can't

545
00:19:39,400 --> 00:19:43,540
do it every time you run your program

546
00:19:41,020 --> 00:19:44,740
you compile it it happens in one pass

547
00:19:43,540 --> 00:19:46,928
and it's really fast so you'd ever

548
00:19:44,740 --> 00:19:49,210
notice but that means that linking

549
00:19:46,929 --> 00:19:51,490
doesn't really exist so you can see

550
00:19:49,210 --> 00:19:54,580
forth compilers can obviously be made

551
00:19:51,490 --> 00:19:56,650
much simpler and much smaller than other

552
00:19:54,580 --> 00:19:57,220
languages but it is a fully functional

553
00:19:56,650 --> 00:20:00,640
language

554
00:19:57,220 --> 00:20:02,530
it looks a little bit like this so over

555
00:20:00,640 --> 00:20:04,540
on the Left we have the way you do a

556
00:20:02,530 --> 00:20:06,879
math expression in a typical language

557
00:20:04,540 --> 00:20:08,168
and this has to be parsed because you

558
00:20:06,880 --> 00:20:09,669
have to figure out what order this goes

559
00:20:08,169 --> 00:20:11,530
in their parentheses there's order of

560
00:20:09,669 --> 00:20:14,140
operations now this cannot be

561
00:20:11,530 --> 00:20:17,559
necessarily compiled in a single pass or

562
00:20:14,140 --> 00:20:19,450
if it can it's hard in fourth it works

563
00:20:17,559 --> 00:20:21,340
differently you put the arguments to a

564
00:20:19,450 --> 00:20:22,929
function on the stack and then you call

565
00:20:21,340 --> 00:20:24,909
the function it pulls the data off the

566
00:20:22,929 --> 00:20:26,740
stack does something to it and puts it

567
00:20:24,910 --> 00:20:28,510
back you might think that sounds

568
00:20:26,740 --> 00:20:30,220
low-level and archaic but it's exactly

569
00:20:28,510 --> 00:20:33,220
the same way that the JVM works it's the

570
00:20:30,220 --> 00:20:35,950
same way the CLR works there are a lot

571
00:20:33,220 --> 00:20:37,450
of stack based VMs that you probably use

572
00:20:35,950 --> 00:20:39,429
and don't realize it

573
00:20:37,450 --> 00:20:42,190
same thing for syntax like conditionals

574
00:20:39,429 --> 00:20:44,860
instead of having this structured syntax

575
00:20:42,190 --> 00:20:47,410
on the left on the right we put we put

576
00:20:44,860 --> 00:20:48,668
the two things we're going to test you

577
00:20:47,410 --> 00:20:50,799
know we have some operation on them

578
00:20:48,669 --> 00:20:52,270
we're doing a bitwise and here and then

579
00:20:50,799 --> 00:20:53,980
if just takes the thing on top of the

580
00:20:52,270 --> 00:20:55,720
stack if it's true it does one thing if

581
00:20:53,980 --> 00:20:57,640
it's false it does another thing and

582
00:20:55,720 --> 00:20:59,290
then function calls work the same way

583
00:20:57,640 --> 00:21:01,510
you put the arguments on the stack first

584
00:20:59,290 --> 00:21:03,399
and call it I would absolutely love to

585
00:21:01,510 --> 00:21:05,320
get into the formal type theory of

586
00:21:03,400 --> 00:21:07,510
concatenative languages I just don't

587
00:21:05,320 --> 00:21:10,149
have the time about half the slides in

588
00:21:07,510 --> 00:21:14,620
this PowerPoint deck sorry LibreOffice

589
00:21:10,150 --> 00:21:16,600
deck are hidden hidden slides because I

590
00:21:14,620 --> 00:21:17,678
just can't get to everything now the

591
00:21:16,600 --> 00:21:19,659
other thing you need to know about forth

592
00:21:17,679 --> 00:21:21,460
is that everything is built around the

593
00:21:19,660 --> 00:21:23,110
dictionary this is a central data

594
00:21:21,460 --> 00:21:25,059
structure it's kind of like a Python

595
00:21:23,110 --> 00:21:27,699
dictionary if you're familiar with that

596
00:21:25,059 --> 00:21:30,700
this is a data structure that maps names

597
00:21:27,700 --> 00:21:32,980
to addresses in memory so imagine every

598
00:21:30,700 --> 00:21:35,200
function you define has to exist in the

599
00:21:32,980 --> 00:21:36,730
the dictionary and then every variable

600
00:21:35,200 --> 00:21:38,980
that you use is probably in there too

601
00:21:36,730 --> 00:21:41,620
and some other stuff that we can

602
00:21:38,980 --> 00:21:43,929
hand-wave around for now all right so

603
00:21:41,620 --> 00:21:46,389
the next slide don't try to read it too

604
00:21:43,929 --> 00:21:49,059
hard what I want to point out here is

605
00:21:46,390 --> 00:21:50,590
that this is a pseudo Python for the

606
00:21:49,059 --> 00:21:52,360
compiler this is actually the whole

607
00:21:50,590 --> 00:21:54,100
compiler the hardest thing in the

608
00:21:52,360 --> 00:21:56,649
compiler is converting strings to

609
00:21:54,100 --> 00:21:59,379
numbers that actually takes longer than

610
00:21:56,650 --> 00:22:01,270
any one of these phases in here now so

611
00:21:59,380 --> 00:22:03,190
the compiler really does a very simple

612
00:22:01,270 --> 00:22:04,750
thing it reads a word and it compiles it

613
00:22:03,190 --> 00:22:07,000
there a couple cases for how it compiles

614
00:22:04,750 --> 00:22:10,590
it like I said before and that's it so

615
00:22:07,000 --> 00:22:13,140
the compiler for a a simple fourth

616
00:22:10,590 --> 00:22:15,810
boils down to about one to two pages of

617
00:22:13,140 --> 00:22:19,820
assembly so that's I fit it in a shell

618
00:22:15,810 --> 00:22:22,560
code so when the evil VM agent starts up

619
00:22:19,820 --> 00:22:24,750
the the shell code itself has a very

620
00:22:22,560 --> 00:22:26,490
small dictionary yeah this is everything

621
00:22:24,750 --> 00:22:29,130
you can do in the language remember you

622
00:22:26,490 --> 00:22:31,410
can't do something unless you send that

623
00:22:29,130 --> 00:22:33,270
word to the compiler right so I can't I

624
00:22:31,410 --> 00:22:34,800
can't run code without submitting code

625
00:22:33,270 --> 00:22:37,889
and these are all the things that can be

626
00:22:34,800 --> 00:22:41,070
code except for numbers obviously I'm

627
00:22:37,890 --> 00:22:42,270
not going to list all the numbers if you

628
00:22:41,070 --> 00:22:44,879
look through here you'll see things like

629
00:22:42,270 --> 00:22:46,560
others some math there's some some words

630
00:22:44,880 --> 00:22:49,080
in here for manipulating the dictionary

631
00:22:46,560 --> 00:22:51,870
creating entries in it it's not too

632
00:22:49,080 --> 00:22:53,699
important that you understand by looking

633
00:22:51,870 --> 00:22:55,350
at them what each of these do this is

634
00:22:53,700 --> 00:22:57,270
the minimum that's required for the

635
00:22:55,350 --> 00:22:59,600
compiler to work when the shell code

636
00:22:57,270 --> 00:23:01,980
runs it is a fully functioning compiler

637
00:22:59,600 --> 00:23:03,629
however it doesn't have some things like

638
00:23:01,980 --> 00:23:06,570
you'll notice that the only control flow

639
00:23:03,630 --> 00:23:08,880
in the core dictionary here is tail

640
00:23:06,570 --> 00:23:10,560
recursion and there are no conditionals

641
00:23:08,880 --> 00:23:11,970
there are no ifs there are no loops and

642
00:23:10,560 --> 00:23:14,520
you might think well what good is a

643
00:23:11,970 --> 00:23:17,700
compiler that can't do loops and can't

644
00:23:14,520 --> 00:23:20,190
do ifs and it turns out that most of

645
00:23:17,700 --> 00:23:22,470
forth is written in Forth and once you

646
00:23:20,190 --> 00:23:24,930
have a technically barely functioning

647
00:23:22,470 --> 00:23:27,270
compiler it can compile the rest of the

648
00:23:24,930 --> 00:23:29,520
language so this is the source code for

649
00:23:27,270 --> 00:23:30,990
if you can tell that these are special

650
00:23:29,520 --> 00:23:33,060
because they have this little IMM at the

651
00:23:30,990 --> 00:23:36,150
end these are immediate words so instead

652
00:23:33,060 --> 00:23:37,950
of compiling them the compiler runs them

653
00:23:36,150 --> 00:23:40,470
and that means when you define an

654
00:23:37,950 --> 00:23:42,900
immediate word you are extending the

655
00:23:40,470 --> 00:23:45,090
compiler and you can add syntax to the

656
00:23:42,900 --> 00:23:46,770
language so it's a programmable compiler

657
00:23:45,090 --> 00:23:48,060
and that's that's another reason this is

658
00:23:46,770 --> 00:23:49,800
beautiful I don't have to put the whole

659
00:23:48,060 --> 00:23:52,200
language in the shell code you just have

660
00:23:49,800 --> 00:23:55,350
enough this is an example this is how

661
00:23:52,200 --> 00:23:56,760
loops work if you're interested in what

662
00:23:55,350 --> 00:23:58,500
some of these primitives do and exactly

663
00:23:56,760 --> 00:23:59,629
how this works get me afterwards I don't

664
00:23:58,500 --> 00:24:03,210
mind talking about it

665
00:23:59,630 --> 00:24:05,070
but I'm sitting at 27 and a half minutes

666
00:24:03,210 --> 00:24:08,370
and I wanted to make sure I had time for

667
00:24:05,070 --> 00:24:11,700
some demos because it's fun as compiler

668
00:24:08,370 --> 00:24:14,340
theory is I think everybody gets some

669
00:24:11,700 --> 00:24:15,600
fun especially if you're like I mean you

670
00:24:14,340 --> 00:24:17,820
know I like programming but I'm not

671
00:24:15,600 --> 00:24:19,679
really a programming language nerd but I

672
00:24:17,820 --> 00:24:21,540
like hacking and I know what hacking

673
00:24:19,680 --> 00:24:24,000
looks like so let's do some stuff that

674
00:24:21,540 --> 00:24:26,460
looks like hacking

675
00:24:24,000 --> 00:24:31,190
and for that I'm gonna threaten the

676
00:24:26,460 --> 00:24:32,940
video recording here by switching to

677
00:24:31,190 --> 00:24:36,980
which one is it

678
00:24:32,940 --> 00:24:43,310
no I'm on join displays here here we go

679
00:24:36,980 --> 00:24:45,810
alright don't look ahead so evil VM

680
00:24:43,310 --> 00:24:47,580
exists you can you can check it out a

681
00:24:45,810 --> 00:24:49,830
github now I'll have the link up later

682
00:24:47,580 --> 00:24:51,240
but evil VM is a number of different

683
00:24:49,830 --> 00:24:55,830
components is this readable should I

684
00:24:51,240 --> 00:24:59,540
make it bigger how's that

685
00:24:55,830 --> 00:25:02,490
alright oh no make sure that this is

686
00:24:59,540 --> 00:25:06,840
consumable by everybody so the shell

687
00:25:02,490 --> 00:25:11,160
code is fairly customizable and here's

688
00:25:06,840 --> 00:25:13,169
why big font sizes alright just for a

689
00:25:11,160 --> 00:25:17,550
sec here I'll make it bigger again in a

690
00:25:13,170 --> 00:25:19,020
sec so when you when you mint a copy of

691
00:25:17,550 --> 00:25:21,330
the shell code you choose your transport

692
00:25:19,020 --> 00:25:23,490
layer and currently there are these ones

693
00:25:21,330 --> 00:25:25,169
I have half the code written for ICMP if

694
00:25:23,490 --> 00:25:27,390
you have other ideas for cool ones let

695
00:25:25,170 --> 00:25:30,390
me know the one caveat is they have to

696
00:25:27,390 --> 00:25:32,760
be written in assembly and you'd think

697
00:25:30,390 --> 00:25:33,960
HTTP is hard but it turned out to be way

698
00:25:32,760 --> 00:25:36,240
easier than I thought it would be

699
00:25:33,960 --> 00:25:37,530
you can configure some things with your

700
00:25:36,240 --> 00:25:39,270
transport layers then there are some

701
00:25:37,530 --> 00:25:43,139
options for encapsulating it will just

702
00:25:39,270 --> 00:25:44,670
make a basic agent for now so we'll

703
00:25:43,140 --> 00:25:47,820
choose the the network transport with

704
00:25:44,670 --> 00:25:51,510
TCP session you tell it where it goes so

705
00:25:47,820 --> 00:25:52,980
here's the IP oh I'm sorry yeah all

706
00:25:51,510 --> 00:25:54,870
right so I tell it where I want it to

707
00:25:52,980 --> 00:25:56,550
connect and what port we will just

708
00:25:54,870 --> 00:25:58,620
generate raw shellcode and I won't do

709
00:25:56,550 --> 00:26:02,220
any fun encapsulation or encoding for

710
00:25:58,620 --> 00:26:04,469
now we'll write this out alright so here

711
00:26:02,220 --> 00:26:06,810
we go there's my screenshot from before

712
00:26:04,470 --> 00:26:13,080
six thousand two bytes if we look at

713
00:26:06,810 --> 00:26:14,730
this guy of course here we go so you can

714
00:26:13,080 --> 00:26:16,110
see some some evidence that this looks

715
00:26:14,730 --> 00:26:19,380
kind of like shellcode you can see our

716
00:26:16,110 --> 00:26:23,459
imports from kernel32 and so forth in

717
00:26:19,380 --> 00:26:27,530
here and and this is runnable let's go

718
00:26:23,460 --> 00:26:30,290
ahead and start the server alright I

719
00:26:27,530 --> 00:26:32,310
should have another Inc there we go

720
00:26:30,290 --> 00:26:33,420
pay no attention to the man behind the

721
00:26:32,310 --> 00:26:36,809
curtain if you want to see what I'm

722
00:26:33,420 --> 00:26:38,999
doing so I have I have a square

723
00:26:36,809 --> 00:26:40,980
- what this does is it creates a task

724
00:26:38,999 --> 00:26:42,419
with the task scheduler that runs a

725
00:26:40,980 --> 00:26:44,429
PowerShell snippet that downloads a

726
00:26:42,419 --> 00:26:49,639
shellcode over HTTP it runs it so this

727
00:26:44,429 --> 00:26:51,600
is a essentially file list ich baby

728
00:26:49,639 --> 00:26:52,918
alright and hopefully this will work if

729
00:26:51,600 --> 00:26:56,549
it doesn't I'll go click on it because I

730
00:26:52,919 --> 00:27:00,210
don't want to take too much time here we

731
00:26:56,549 --> 00:27:02,610
go so we get we get a session in so each

732
00:27:00,210 --> 00:27:05,070
session and in fact let me go ahead and

733
00:27:02,610 --> 00:27:08,149
I'll run one manually just for kicks

734
00:27:05,070 --> 00:27:10,080
here so you can see oh there we go

735
00:27:08,149 --> 00:27:16,289
don't look that's perfect that's for

736
00:27:10,080 --> 00:27:17,999
later we'll run so here we got two

737
00:27:16,289 --> 00:27:19,440
channels I can interact with these

738
00:27:17,999 --> 00:27:20,940
channels so we can listen we see we got

739
00:27:19,440 --> 00:27:23,159
two channels each channel gets assigned

740
00:27:20,940 --> 00:27:24,659
a Crayola crayon color because this is

741
00:27:23,159 --> 00:27:29,070
my own project and I can do whatever I

742
00:27:24,659 --> 00:27:31,159
want it's basically a hashed value based

743
00:27:29,070 --> 00:27:34,320
on the user name and the Machine grid

744
00:27:31,159 --> 00:27:37,200
so one of these if we right now we're

745
00:27:34,320 --> 00:27:39,689
talking with session one I can run just

746
00:27:37,200 --> 00:27:41,970
a regular command with the bangbang word

747
00:27:39,690 --> 00:27:48,179
here so let's do Who am I so I'm running

748
00:27:41,970 --> 00:27:50,580
is system here and if I switch this guy

749
00:27:48,179 --> 00:27:53,789
is running is someone much less

750
00:27:50,580 --> 00:27:56,249
interesting just a regular user so this

751
00:27:53,789 --> 00:27:58,200
is this is a service agent working there

752
00:27:56,249 --> 00:27:59,789
there is a basic network payload that

753
00:27:58,200 --> 00:28:01,740
includes a bunch of useful functions

754
00:27:59,789 --> 00:28:02,908
alright so we can we can look at the

755
00:28:01,740 --> 00:28:04,740
file systems and this is all done

756
00:28:02,909 --> 00:28:07,409
without process execution I'm just using

757
00:28:04,740 --> 00:28:09,539
with 32 API calls to do all of these

758
00:28:07,409 --> 00:28:11,369
things and then the server can send new

759
00:28:09,539 --> 00:28:13,110
code down to the system so the compiler

760
00:28:11,369 --> 00:28:21,869
is just sitting there it's got its body

761
00:28:13,110 --> 00:28:24,719
of defined words or is a cliff yeah now

762
00:28:21,869 --> 00:28:26,428
it's a little bigger now so right now

763
00:28:24,720 --> 00:28:28,200
I'm using 79 thousand bytes in the

764
00:28:26,429 --> 00:28:31,249
dictionary because I've consumed and

765
00:28:28,200 --> 00:28:33,450
compiled some code yep

766
00:28:31,249 --> 00:28:35,669
yes who's the connexxus server the

767
00:28:33,450 --> 00:28:39,509
server shoves down the rest of the core

768
00:28:35,669 --> 00:28:44,249
API it's optional and you can act you

769
00:28:39,509 --> 00:28:47,070
can use it just fine but it yeah it if

770
00:28:44,249 --> 00:28:49,139
they're nice they come in handy and then

771
00:28:47,070 --> 00:28:50,000
we can send more code if we want so say

772
00:28:49,139 --> 00:28:51,560
Sam

773
00:28:50,000 --> 00:28:53,450
environment where I want to get some net

774
00:28:51,560 --> 00:28:55,639
stats but I don't want to run net stat

775
00:28:53,450 --> 00:28:58,400
because I know that they're running some

776
00:28:55,640 --> 00:28:59,960
EDR that says you know nobody should run

777
00:28:58,400 --> 00:29:01,850
that stat and it's going to get bubbled

778
00:28:59,960 --> 00:29:03,920
up to incident responders or something

779
00:29:01,850 --> 00:29:07,370
so I'd rather not go out of my process

780
00:29:03,920 --> 00:29:11,330
I'll just use some some win32 api stuff

781
00:29:07,370 --> 00:29:14,030
so I have a module I'll load that net

782
00:29:11,330 --> 00:29:15,409
stat fth most of the modules I have a

783
00:29:14,030 --> 00:29:17,240
little bit of help here so it tells you

784
00:29:15,410 --> 00:29:20,000
what it defined if we look we can see

785
00:29:17,240 --> 00:29:22,850
that the words that exist in the system

786
00:29:20,000 --> 00:29:25,100
now include routes and net stat and

787
00:29:22,850 --> 00:29:28,879
stuff like that so we can run the net

788
00:29:25,100 --> 00:29:32,659
stat I thought this was was clever it

789
00:29:28,880 --> 00:29:34,820
even tells you which one is its own so

790
00:29:32,660 --> 00:29:37,820
this give you an idea yeah working with

791
00:29:34,820 --> 00:29:39,560
it it works kind of like a shell and you

792
00:29:37,820 --> 00:29:41,629
can you can add whatever functionality

793
00:29:39,560 --> 00:29:44,000
you need to it you know whatever's handy

794
00:29:41,630 --> 00:29:46,130
just by adding words that that do what

795
00:29:44,000 --> 00:29:48,170
you need at anytime your program can

796
00:29:46,130 --> 00:29:51,170
take control of the input stream and

797
00:29:48,170 --> 00:29:53,960
then do stuff with it so it turns out to

798
00:29:51,170 --> 00:29:55,880
be a very very exploratory style of

799
00:29:53,960 --> 00:29:58,190
programming it feels a little bit more

800
00:29:55,880 --> 00:30:01,070
like a shell except that you know if I

801
00:29:58,190 --> 00:30:04,460
if I take one of these words like a net

802
00:30:01,070 --> 00:30:06,950
stat I can see it and here's the machine

803
00:30:04,460 --> 00:30:08,600
code for net stat now this calls to some

804
00:30:06,950 --> 00:30:11,180
other functions it takes more than that

805
00:30:08,600 --> 00:30:12,409
much machine code to do a net stat but

806
00:30:11,180 --> 00:30:15,920
you can always see what's going on

807
00:30:12,410 --> 00:30:16,850
underneath all right now let's see what

808
00:30:15,920 --> 00:30:26,990
I'm supposed to do next

809
00:30:16,850 --> 00:30:28,010
oh all the way at the beginning oh those

810
00:30:26,990 --> 00:30:31,700
are hidden ones you're not supposed to

811
00:30:28,010 --> 00:30:35,440
see all right ah yes

812
00:30:31,700 --> 00:30:35,440
key logger actually let's go ahead and

813
00:30:37,930 --> 00:30:42,260
whoops all right so I want to show you a

814
00:30:41,390 --> 00:30:44,480
little bit about what the code looks

815
00:30:42,260 --> 00:30:46,400
like I showed you snippets before that

816
00:30:44,480 --> 00:30:49,060
we're probably not particularly

817
00:30:46,400 --> 00:30:53,180
interesting good I'm doing fine for time

818
00:30:49,060 --> 00:30:54,620
so a key logger might look something

819
00:30:53,180 --> 00:30:56,180
like this this is a functional key

820
00:30:54,620 --> 00:30:57,560
logger it's a pedagogical examples

821
00:30:56,180 --> 00:30:59,390
there's some extra things you'd want it

822
00:30:57,560 --> 00:31:01,100
to do but this is just an example of

823
00:30:59,390 --> 00:31:03,299
what forth code looks like and how I'm

824
00:31:01,100 --> 00:31:06,059
using it to do something malicious

825
00:31:03,299 --> 00:31:07,889
so usually you read forth programs from

826
00:31:06,059 --> 00:31:10,440
the bottom up because you can't call

827
00:31:07,890 --> 00:31:11,850
something that isn't already defined so

828
00:31:10,440 --> 00:31:14,850
we start at the end and we see that two

829
00:31:11,850 --> 00:31:17,250
key log means we go into a loop now this

830
00:31:14,850 --> 00:31:19,350
key question until that just means what

831
00:31:17,250 --> 00:31:21,690
we exit the loop if the user ever sends

832
00:31:19,350 --> 00:31:24,059
input so I can get out of it if I want

833
00:31:21,690 --> 00:31:25,980
to interact with the compiler again so

834
00:31:24,059 --> 00:31:27,570
in this loop we test the keys and then

835
00:31:25,980 --> 00:31:29,340
we wait 8 milliseconds and we just do

836
00:31:27,570 --> 00:31:31,850
that forever so you might say how do we

837
00:31:29,340 --> 00:31:35,010
test the keys that's up here they're

838
00:31:31,850 --> 00:31:37,289
possibly 256 scan codes that we might

839
00:31:35,010 --> 00:31:39,149
reasonably check it's actually if you

840
00:31:37,289 --> 00:31:40,408
keep it under I think about 220 you'll

841
00:31:39,149 --> 00:31:43,020
get most of the keys on a normal

842
00:31:40,409 --> 00:31:45,120
keyboard but it's a pedagogical so we do

843
00:31:43,020 --> 00:31:46,889
them all now so this is this is like a

844
00:31:45,120 --> 00:31:49,739
for loop now give it the bounds I'm

845
00:31:46,890 --> 00:31:51,390
gonna go from 0 to 255 and then between

846
00:31:49,740 --> 00:31:54,179
do and loop that's what happens in the

847
00:31:51,390 --> 00:31:56,010
loop I is always the loop counter and so

848
00:31:54,179 --> 00:31:57,630
what I'm doing is I put I on the stack

849
00:31:56,010 --> 00:32:00,240
so we're going to test key 0 we're going

850
00:31:57,630 --> 00:32:01,399
to test key one test key 2 and then I'm

851
00:32:00,240 --> 00:32:04,710
going to call the test key function

852
00:32:01,399 --> 00:32:08,189
which looks something like this so test

853
00:32:04,710 --> 00:32:09,950
key what we do is we check is it down so

854
00:32:08,190 --> 00:32:13,169
that is down is a function that calls a

855
00:32:09,950 --> 00:32:16,710
win32 API call that says is this key

856
00:32:13,169 --> 00:32:18,750
pressed right now so if if it is pressed

857
00:32:16,710 --> 00:32:20,730
then there's some stuff we want to do so

858
00:32:18,750 --> 00:32:22,679
that calls the function do down if it

859
00:32:20,730 --> 00:32:24,330
was not pressed we just want to make

860
00:32:22,679 --> 00:32:26,070
sure that in our our little data

861
00:32:24,330 --> 00:32:28,949
structure we keep track of all the keys

862
00:32:26,070 --> 00:32:31,860
that we've marked it as not pressed

863
00:32:28,950 --> 00:32:35,520
so we've unset that key in our key state

864
00:32:31,860 --> 00:32:37,918
makes sense do down we check if it was

865
00:32:35,520 --> 00:32:40,049
down already right if it was down then a

866
00:32:37,919 --> 00:32:41,640
keystroke has not happened so we do

867
00:32:40,049 --> 00:32:44,129
nothing we just drop it off the stack

868
00:32:41,640 --> 00:32:46,200
and and we're done but if it wasn't down

869
00:32:44,130 --> 00:32:48,630
before and it is down now then we've

870
00:32:46,200 --> 00:32:50,570
detected a keystroke so we set the key

871
00:32:48,630 --> 00:32:52,770
state and then we report the keystroke

872
00:32:50,570 --> 00:32:54,600
now there's more to it than that I don't

873
00:32:52,770 --> 00:32:57,360
want to be labor it too much but I just

874
00:32:54,600 --> 00:32:57,899
want you to see a sample of code I can

875
00:32:57,360 --> 00:33:02,760
show you

876
00:32:57,899 --> 00:33:07,770
oops if I can't remember um X all right

877
00:33:02,760 --> 00:33:10,260
so maybe all right so this is the whole

878
00:33:07,770 --> 00:33:11,820
thing from from soup to nuts this is the

879
00:33:10,260 --> 00:33:14,100
whole key logger that I'm showing today

880
00:33:11,820 --> 00:33:16,570
at the top you can see I'm importing

881
00:33:14,100 --> 00:33:17,980
user 32 DLL and I'm using the

882
00:33:16,570 --> 00:33:21,129
foreign function interface which comes

883
00:33:17,980 --> 00:33:22,690
with the basic payload to import these

884
00:33:21,130 --> 00:33:24,130
functions they get wrapped up with forth

885
00:33:22,690 --> 00:33:25,539
functions you can call them just like

886
00:33:24,130 --> 00:33:27,820
anything else they take their arguments

887
00:33:25,539 --> 00:33:29,470
off the stack like any forth function so

888
00:33:27,820 --> 00:33:31,000
you read it from the bottom up this is

889
00:33:29,470 --> 00:33:32,200
the same code I just didn't space it out

890
00:33:31,000 --> 00:33:34,210
the same way this is more of a

891
00:33:32,200 --> 00:33:36,130
traditional way to structured fourth

892
00:33:34,210 --> 00:33:38,230
code but this is the whole thing so

893
00:33:36,130 --> 00:33:41,649
let's go ahead and run that and see if

894
00:33:38,230 --> 00:33:47,049
we can log us some keys so we'll load

895
00:33:41,649 --> 00:33:51,100
the key log to that fth so it's loaded

896
00:33:47,049 --> 00:33:54,789
if we check our dictionary we have key

897
00:33:51,100 --> 00:33:56,918
log which is the magic function so we'll

898
00:33:54,789 --> 00:33:58,570
start key logging and this is on Jaz

899
00:33:56,919 --> 00:34:01,450
berry jam very intentionally because

900
00:33:58,570 --> 00:34:03,158
system is running in not the same

901
00:34:01,450 --> 00:34:06,759
desktop as the user so I wanna make sure

902
00:34:03,159 --> 00:34:10,859
I get some keystrokes for my demo so

903
00:34:06,759 --> 00:34:10,859
let's grab something here

904
00:34:11,129 --> 00:34:18,089
do you this is for the next demo so here

905
00:34:16,119 --> 00:34:23,470
you L keystrokes are coming in hello

906
00:34:18,089 --> 00:34:27,429
NOLA con alright SSH router root

907
00:34:23,469 --> 00:34:28,989
password one two three all right because

908
00:34:27,429 --> 00:34:32,379
that's how everybody logs into their

909
00:34:28,989 --> 00:34:33,879
router anyway so you see key logs coming

910
00:34:32,379 --> 00:34:35,259
in yeah I remember we exit the loop by

911
00:34:33,879 --> 00:34:36,609
submitting something so I just press

912
00:34:35,260 --> 00:34:40,060
ENTER a couple times and we hop out of

913
00:34:36,609 --> 00:34:41,770
that so what I've found is theorized

914
00:34:40,060 --> 00:34:43,869
that this would be a nice way to develop

915
00:34:41,770 --> 00:34:45,699
malicious tooling but it turns out in

916
00:34:43,869 --> 00:34:47,619
practice it's actually really fun you

917
00:34:45,699 --> 00:34:49,388
can write this interactively I can write

918
00:34:47,619 --> 00:34:51,429
a function in fact I've even found when

919
00:34:49,389 --> 00:34:53,470
I'm exploring the win32 API and I've

920
00:34:51,429 --> 00:34:56,079
never called a function before why would

921
00:34:53,469 --> 00:34:57,578
I write a harness in C that does all of

922
00:34:56,079 --> 00:35:00,310
this stuff when I can just import it

923
00:34:57,579 --> 00:35:02,369
wrap it and call the blasted thing so

924
00:35:00,310 --> 00:35:05,950
this turns out to be a very very quick

925
00:35:02,369 --> 00:35:07,599
cyclical development process now the

926
00:35:05,950 --> 00:35:10,598
next thing I want to show is the

927
00:35:07,599 --> 00:35:11,890
low-floor I said native code compile we

928
00:35:10,599 --> 00:35:14,619
want to get down to the machine

929
00:35:11,890 --> 00:35:16,328
I have an example a situation I ran into

930
00:35:14,619 --> 00:35:18,220
in real life I was trying to understand

931
00:35:16,329 --> 00:35:20,290
the way some other tools the security

932
00:35:18,220 --> 00:35:22,419
tool how it worked and it was doing

933
00:35:20,290 --> 00:35:25,060
something with threads

934
00:35:22,420 --> 00:35:26,950
yeah thread-local storage and we're

935
00:35:25,060 --> 00:35:28,000
looking at that and I thought I want to

936
00:35:26,950 --> 00:35:29,560
know

937
00:35:28,000 --> 00:35:31,330
some of the fields are in this

938
00:35:29,560 --> 00:35:33,910
particular data structure if you're not

939
00:35:31,330 --> 00:35:36,730
familiar with Windows internals there's

940
00:35:33,910 --> 00:35:39,490
this thing called the the TI B so this

941
00:35:36,730 --> 00:35:41,380
is the thread information block it has a

942
00:35:39,490 --> 00:35:42,910
bunch of useful stuff windows puts

943
00:35:41,380 --> 00:35:44,140
things all over the place in memory and

944
00:35:42,910 --> 00:35:46,359
there are some things that your program

945
00:35:44,140 --> 00:35:49,779
has to be able to find so a lot of that

946
00:35:46,360 --> 00:35:52,120
stuff goes here and in modern windows

947
00:35:49,780 --> 00:35:53,920
and 64-bit windows it's indexed off the

948
00:35:52,120 --> 00:35:56,020
GS register and most programming

949
00:35:53,920 --> 00:35:58,210
languages don't give you a way to index

950
00:35:56,020 --> 00:35:59,650
something off the GS register there are

951
00:35:58,210 --> 00:36:02,130
actually some C function calls to do

952
00:35:59,650 --> 00:36:05,290
this but it's a pedagogical example

953
00:36:02,130 --> 00:36:07,330
we'll go with that so the first thing I

954
00:36:05,290 --> 00:36:10,180
need to do is I want a function that

955
00:36:07,330 --> 00:36:12,430
lets me pull data out of memory index

956
00:36:10,180 --> 00:36:13,990
off that GS segment register so I know

957
00:36:12,430 --> 00:36:18,009
what that looks like in assembly it

958
00:36:13,990 --> 00:36:20,649
looks something like this GS RDI why am

959
00:36:18,010 --> 00:36:22,060
i looking over there it's mirrored so

960
00:36:20,650 --> 00:36:24,120
this is what I would want my function to

961
00:36:22,060 --> 00:36:26,290
do so let's just put this in a function

962
00:36:24,120 --> 00:36:28,990
so I'll take this machine code you do it

963
00:36:26,290 --> 00:36:30,250
with longer shell code if you want to so

964
00:36:28,990 --> 00:36:33,609
let's define a new function we'll call

965
00:36:30,250 --> 00:36:36,850
it at g sx at is forth nomenclature for

966
00:36:33,610 --> 00:36:39,370
read something from memory usually and I

967
00:36:36,850 --> 00:36:42,400
want to index things one quad word at a

968
00:36:39,370 --> 00:36:45,130
time one eight byte register size value

969
00:36:42,400 --> 00:36:46,540
so we're gonna we're going to take it

970
00:36:45,130 --> 00:36:49,330
index we're going to treat the GS

971
00:36:46,540 --> 00:36:51,940
segment register as if it's an array so

972
00:36:49,330 --> 00:36:53,380
I'm going to take and an index in that

973
00:36:51,940 --> 00:36:55,060
array I'm going to multiply it to find

974
00:36:53,380 --> 00:36:56,770
the byte offset if that makes sense if

975
00:36:55,060 --> 00:36:58,210
you're keeping up with it and then we're

976
00:36:56,770 --> 00:37:01,120
just gonna have some in-line machine

977
00:36:58,210 --> 00:37:03,040
code here yeah

978
00:37:01,120 --> 00:37:05,290
so right there so now I've made this

979
00:37:03,040 --> 00:37:07,450
function we can look at it if you look

980
00:37:05,290 --> 00:37:09,240
real closely quickly enough you'll see

981
00:37:07,450 --> 00:37:10,390
that code that I just put in there

982
00:37:09,240 --> 00:37:14,589
somewhere

983
00:37:10,390 --> 00:37:17,740
should be 6 5 I already see there is ban

984
00:37:14,590 --> 00:37:19,870
right there so now let's let's do some

985
00:37:17,740 --> 00:37:22,540
inspection let's take a look at the the

986
00:37:19,870 --> 00:37:23,799
ti be now I can use braces through an

987
00:37:22,540 --> 00:37:25,720
anonymous function because I don't need

988
00:37:23,800 --> 00:37:28,240
to fill up the dictionary with useless

989
00:37:25,720 --> 00:37:29,379
stuff dot pre just means I'll make it

990
00:37:28,240 --> 00:37:34,000
look pretty you'll see you in a sec

991
00:37:29,380 --> 00:37:37,210
let's look at the first 12 quad words in

992
00:37:34,000 --> 00:37:40,210
that read that region in memory I'll go

993
00:37:37,210 --> 00:37:41,180
do loop will print the index of it we'll

994
00:37:40,210 --> 00:37:43,099
grab that

995
00:37:41,180 --> 00:37:46,640
value will print it make a new line

996
00:37:43,099 --> 00:37:50,180
finish our loop make it pretty and then

997
00:37:46,640 --> 00:37:52,578
we'll execute this anonymous function so

998
00:37:50,180 --> 00:37:54,859
now I've run this machine code from

999
00:37:52,579 --> 00:37:56,329
scratch in my function wrapped it up and

1000
00:37:54,859 --> 00:37:58,009
you can see some interesting things in

1001
00:37:56,329 --> 00:38:00,260
here now one of these I forget which one

1002
00:37:58,010 --> 00:38:03,470
it is now I think it's seven zero three

1003
00:38:00,260 --> 00:38:06,559
two might very well be my process ID

1004
00:38:03,470 --> 00:38:08,779
let's see yeah seven oh three two

1005
00:38:06,559 --> 00:38:10,700
so for example if you want a quick way

1006
00:38:08,780 --> 00:38:13,250
to get your process ID just grab it from

1007
00:38:10,700 --> 00:38:16,430
there and don't call the win32 api call

1008
00:38:13,250 --> 00:38:18,440
that probably grabs it from there but

1009
00:38:16,430 --> 00:38:20,328
this I hope shows at least a little

1010
00:38:18,440 --> 00:38:22,880
glimpse into the low-floor you can go as

1011
00:38:20,329 --> 00:38:25,339
nerd as you want with this type of

1012
00:38:22,880 --> 00:38:27,020
environment and now I want to show the

1013
00:38:25,339 --> 00:38:30,259
highest ceiling do I have time please

1014
00:38:27,020 --> 00:38:36,710
yes I have time all right so let's get

1015
00:38:30,260 --> 00:38:39,109
back to you max all right yes I'm a

1016
00:38:36,710 --> 00:38:42,950
unapologetic Emacs nerd Emacs is life

1017
00:38:39,109 --> 00:38:44,660
all right so just showing machine code

1018
00:38:42,950 --> 00:38:46,250
I'm gonna show something that's much

1019
00:38:44,660 --> 00:38:51,640
higher level wow that's still pretty

1020
00:38:46,250 --> 00:38:56,680
small isn't it yeah yeah yeah I hear you

1021
00:38:51,640 --> 00:38:59,450
all right I know that joke all right so

1022
00:38:56,680 --> 00:39:01,640
anybody seen context-free grammars

1023
00:38:59,450 --> 00:39:03,259
before you've ever done compiler stuff

1024
00:39:01,640 --> 00:39:05,270
I'm sure you have seen them does this

1025
00:39:03,260 --> 00:39:08,240
look vaguely like a context-free grammar

1026
00:39:05,270 --> 00:39:10,880
what I'm doing is I'm defining a matcher

1027
00:39:08,240 --> 00:39:13,129
for a credit card number so in this case

1028
00:39:10,880 --> 00:39:15,829
the credit card number is a is matched

1029
00:39:13,130 --> 00:39:17,599
by a parser and it's either an ASCII

1030
00:39:15,829 --> 00:39:19,730
credit card number or it's a Unicode

1031
00:39:17,599 --> 00:39:21,950
credit card number make sense so the

1032
00:39:19,730 --> 00:39:24,470
vertical bar is an or in this parser

1033
00:39:21,950 --> 00:39:26,618
framework now let's go up to the next

1034
00:39:24,470 --> 00:39:26,618
one

1035
00:39:26,809 --> 00:39:30,980
we called CC number Lang from there so

1036
00:39:29,119 --> 00:39:33,260
here's the other instance of it the CC

1037
00:39:30,980 --> 00:39:35,480
number Lang is a parser and it will

1038
00:39:33,260 --> 00:39:36,980
match either a separated credit card

1039
00:39:35,480 --> 00:39:38,420
number right so that's four digits for

1040
00:39:36,980 --> 00:39:41,750
the separator four digit separator

1041
00:39:38,420 --> 00:39:42,980
followed by something that that signals

1042
00:39:41,750 --> 00:39:44,119
the end of the numbers so something

1043
00:39:42,980 --> 00:39:45,890
that's not a number could be the end of

1044
00:39:44,119 --> 00:39:48,079
the string could be punctuation just

1045
00:39:45,890 --> 00:39:50,058
something not a number or if it's not

1046
00:39:48,079 --> 00:39:52,460
that it's 16 digits followed by the

1047
00:39:50,059 --> 00:39:53,900
termination and then this is this

1048
00:39:52,460 --> 00:39:54,770
technically has a bug but we'll hand

1049
00:39:53,900 --> 00:39:57,710
wave over it because I want

1050
00:39:54,770 --> 00:39:59,630
show recursion and/or it's a sentinel

1051
00:39:57,710 --> 00:40:02,120
value which for credit card stripe data

1052
00:39:59,630 --> 00:40:04,100
is a semicolon usually followed by a

1053
00:40:02,120 --> 00:40:07,549
digit and a digit and then a credit card

1054
00:40:04,100 --> 00:40:09,290
number makes sense and then if we go a

1055
00:40:07,550 --> 00:40:11,240
little farther we'll see that a

1056
00:40:09,290 --> 00:40:13,310
separated credit card number is four

1057
00:40:11,240 --> 00:40:15,439
digits followed by a separator and then

1058
00:40:13,310 --> 00:40:16,850
four digits a separator etc and this

1059
00:40:15,440 --> 00:40:18,350
will actually match the separator so if

1060
00:40:16,850 --> 00:40:19,940
you have a - for your first separator

1061
00:40:18,350 --> 00:40:21,049
and a space for your second separator it

1062
00:40:19,940 --> 00:40:23,120
will say now that doesn't look like a

1063
00:40:21,050 --> 00:40:25,340
credit card number usually people keep

1064
00:40:23,120 --> 00:40:27,650
them the same as we work our way up this

1065
00:40:25,340 --> 00:40:30,590
parser stack we get to things like you

1066
00:40:27,650 --> 00:40:32,390
know a digit we grab we grab a bite from

1067
00:40:30,590 --> 00:40:34,550
what we're inspecting and see if it's

1068
00:40:32,390 --> 00:40:37,700
within this range it's from you know 30

1069
00:40:34,550 --> 00:40:40,550
X to 39 hex etc so this is high-level

1070
00:40:37,700 --> 00:40:42,980
and what you may not realize just by

1071
00:40:40,550 --> 00:40:45,050
looking at it is that these are done

1072
00:40:42,980 --> 00:40:45,290
with those immediate words I was talking

1073
00:40:45,050 --> 00:40:49,010
about

1074
00:40:45,290 --> 00:40:51,200
so parser ampersand and pipe these are

1075
00:40:49,010 --> 00:40:53,390
little compilers and they and they

1076
00:40:51,200 --> 00:40:55,339
extend the fourth compiler so when you

1077
00:40:53,390 --> 00:40:57,620
define one of these parsers it compiles

1078
00:40:55,340 --> 00:41:00,770
it to machine code so this is actually a

1079
00:40:57,620 --> 00:41:04,730
native code parser after it's done so

1080
00:41:00,770 --> 00:41:06,620
this isn't like a parser interpreter or

1081
00:41:04,730 --> 00:41:08,180
something that it just has some

1082
00:41:06,620 --> 00:41:11,509
specification of a parser and it

1083
00:41:08,180 --> 00:41:14,480
processes it this actually uses a CPU to

1084
00:41:11,510 --> 00:41:20,840
to parse I'll show an example of this

1085
00:41:14,480 --> 00:41:24,620
running maybe all right let's see so we

1086
00:41:20,840 --> 00:41:26,300
had that notepad process right paid 4356

1087
00:41:24,620 --> 00:41:28,130
and I happen to know that at this

1088
00:41:26,300 --> 00:41:29,960
particular Network they called their

1089
00:41:28,130 --> 00:41:31,400
payment processing application that

1090
00:41:29,960 --> 00:41:35,390
sends the card data to the Gateway

1091
00:41:31,400 --> 00:41:39,800
notepad so we want to we want to see if

1092
00:41:35,390 --> 00:41:42,140
it has any credit card numbers in it all

1093
00:41:39,800 --> 00:41:44,210
right so be prepared so Prochnow this is

1094
00:41:42,140 --> 00:41:46,400
a module that brings in a lot of stuff a

1095
00:41:44,210 --> 00:41:48,260
lot of these are syntax extensions so

1096
00:41:46,400 --> 00:41:49,400
structures I want to now and a have

1097
00:41:48,260 --> 00:41:50,960
structures because I need to use some

1098
00:41:49,400 --> 00:41:53,060
win32 structures in here so you can

1099
00:41:50,960 --> 00:41:55,040
define those that's actually a bolt-on

1100
00:41:53,060 --> 00:41:56,509
named locals I have some functions where

1101
00:41:55,040 --> 00:41:58,040
I don't want to just keep track of stuff

1102
00:41:56,510 --> 00:41:59,930
on the stacks that are named locals in

1103
00:41:58,040 --> 00:42:01,910
here and parsers and strings and there's

1104
00:41:59,930 --> 00:42:03,140
the Lund algorithm so I can check the

1105
00:42:01,910 --> 00:42:05,330
checksum and everything if you're

1106
00:42:03,140 --> 00:42:07,629
interested you can pull the code out and

1107
00:42:05,330 --> 00:42:09,279
look at how these work but

1108
00:42:07,630 --> 00:42:11,650
this gives me a sort of functional

1109
00:42:09,280 --> 00:42:14,920
programming interface for scanning

1110
00:42:11,650 --> 00:42:16,300
memory what I do is I look like right

1111
00:42:14,920 --> 00:42:20,520
here this example is pretty much what

1112
00:42:16,300 --> 00:42:24,100
I'm gonna run let's find that again so

1113
00:42:20,520 --> 00:42:26,020
process 4 3 5 6 and then I'm going to

1114
00:42:24,100 --> 00:42:27,790
quote a function it's going to be the

1115
00:42:26,020 --> 00:42:30,190
scan pants function which uses that

1116
00:42:27,790 --> 00:42:32,980
parser code I was just showing you and

1117
00:42:30,190 --> 00:42:36,340
then I'm going to have the each region

1118
00:42:32,980 --> 00:42:38,890
function map the memory from that other

1119
00:42:36,340 --> 00:42:41,050
process pull it into my process and then

1120
00:42:38,890 --> 00:42:42,100
run scan pans on it so you could use

1121
00:42:41,050 --> 00:42:44,110
this like you could make another

1122
00:42:42,100 --> 00:42:45,700
function that searches for sub strings

1123
00:42:44,110 --> 00:42:47,500
or another one that looks for ntlmssp

1124
00:42:45,700 --> 00:42:49,990
because that's pretty useful sometimes

1125
00:42:47,500 --> 00:42:52,240
you can use the same same line just with

1126
00:42:49,990 --> 00:42:53,740
a different function in here and in

1127
00:42:52,240 --> 00:42:56,379
theory when we run this we should be

1128
00:42:53,740 --> 00:43:00,069
regaled with a variety of seemingly

1129
00:42:56,380 --> 00:43:02,770
correct pan data and remember this does

1130
00:43:00,070 --> 00:43:04,900
the one check it does you know all the

1131
00:43:02,770 --> 00:43:06,730
stuff you'd want to and it tells us the

1132
00:43:04,900 --> 00:43:08,260
address of memory in that other process

1133
00:43:06,730 --> 00:43:10,210
where it is so if I'm like hey that

1134
00:43:08,260 --> 00:43:12,250
looks like the segment of interest I

1135
00:43:10,210 --> 00:43:13,690
don't want to dump the whole gig of

1136
00:43:12,250 --> 00:43:14,790
memory that it's got I just want this

1137
00:43:13,690 --> 00:43:17,020
piece

1138
00:43:14,790 --> 00:43:19,480
so hopefully this this shows you a

1139
00:43:17,020 --> 00:43:21,490
little example of the high ceiling that

1140
00:43:19,480 --> 00:43:23,650
is possible it's not perfect I'm still

1141
00:43:21,490 --> 00:43:25,540
working on some ideas for making a

1142
00:43:23,650 --> 00:43:27,910
little bit easier to program at a higher

1143
00:43:25,540 --> 00:43:30,310
level but to be able to extend this if

1144
00:43:27,910 --> 00:43:31,720
you imagine writing this code with all

1145
00:43:30,310 --> 00:43:33,490
of your ifs and loops and other things

1146
00:43:31,720 --> 00:43:35,169
it gets really hairy it suddenly gets

1147
00:43:33,490 --> 00:43:38,580
very pretty when you can just say here's

1148
00:43:35,170 --> 00:43:38,580
a grammar for credit card numbers

1149
00:43:40,140 --> 00:43:47,350
alright where are we yeah alright so

1150
00:43:45,130 --> 00:43:50,830
that's that's it for demos I hope that

1151
00:43:47,350 --> 00:43:52,960
went ok you can get hold of evil VM and

1152
00:43:50,830 --> 00:43:55,480
you can run it it's very very alpha I

1153
00:43:52,960 --> 00:43:57,370
change it a lot everything in the core

1154
00:43:55,480 --> 00:43:58,660
API is pretty static but every once

1155
00:43:57,370 --> 00:44:00,549
while I change things just a few weeks

1156
00:43:58,660 --> 00:44:01,899
ago I thought you know if I'm going to

1157
00:44:00,550 --> 00:44:03,280
release this thing would be nice when

1158
00:44:01,900 --> 00:44:05,020
there's an error if it told you what

1159
00:44:03,280 --> 00:44:06,700
function it was calling when it had an

1160
00:44:05,020 --> 00:44:09,100
error it's like I added that a few weeks

1161
00:44:06,700 --> 00:44:10,870
ago so yeah it's that stuff changes but

1162
00:44:09,100 --> 00:44:13,839
if you're if you're bold of heart

1163
00:44:10,870 --> 00:44:15,250
willing to try something that that

1164
00:44:13,840 --> 00:44:16,810
probably has bugs that I've never found

1165
00:44:15,250 --> 00:44:18,490
because I know what not to do now go

1166
00:44:16,810 --> 00:44:20,080
ahead and pull it down I'm releasing an

1167
00:44:18,490 --> 00:44:21,129
under MIT license so that nobody will

1168
00:44:20,080 --> 00:44:22,990
fuss at me

1169
00:44:21,130 --> 00:44:25,840
maybe the they're really really Libre

1170
00:44:22,990 --> 00:44:27,069
people and you can find there's a little

1171
00:44:25,840 --> 00:44:28,570
documentation I'm still flushing that

1172
00:44:27,070 --> 00:44:30,160
out but there's a little intro shows you

1173
00:44:28,570 --> 00:44:32,200
how to set it up and then walks you

1174
00:44:30,160 --> 00:44:34,600
through a couple use cases on the dock

1175
00:44:32,200 --> 00:44:37,649
site evil TM ninja and then you get the

1176
00:44:34,600 --> 00:44:41,560
code on github I believe I think I

1177
00:44:37,650 --> 00:44:44,890
successfully unprofitably PO early this

1178
00:44:41,560 --> 00:44:47,890
morning so it did work awesome cool and

1179
00:44:44,890 --> 00:44:49,540
I'm more than happy to entertain either

1180
00:44:47,890 --> 00:44:50,620
suggestions from people or if anyone

1181
00:44:49,540 --> 00:44:52,480
wants to play around with it I'll be

1182
00:44:50,620 --> 00:44:53,859
deeply honored this has been a labor of

1183
00:44:52,480 --> 00:44:56,560
love for a couple years now playing

1184
00:44:53,860 --> 00:44:57,700
around with all kinds of ideas and so if

1185
00:44:56,560 --> 00:44:59,410
you're interested in using it and

1186
00:44:57,700 --> 00:45:01,210
especially if anyone's interested in

1187
00:44:59,410 --> 00:45:05,020
contributing I'll probably accept just

1188
00:45:01,210 --> 00:45:08,920
about anything so there are things I

1189
00:45:05,020 --> 00:45:10,600
want to do how are we for time all right

1190
00:45:08,920 --> 00:45:12,570
the the biggest thing I want to improve

1191
00:45:10,600 --> 00:45:14,799
is resilience so when you're running

1192
00:45:12,570 --> 00:45:16,750
when you're running native code you can

1193
00:45:14,800 --> 00:45:18,850
crash your process and I want to make it

1194
00:45:16,750 --> 00:45:21,790
as crash proof as possible so my biggest

1195
00:45:18,850 --> 00:45:23,290
idea is to copy an idea from Erlang so

1196
00:45:21,790 --> 00:45:25,090
you get your initial agent and it

1197
00:45:23,290 --> 00:45:26,890
becomes like a little hypervisor for

1198
00:45:25,090 --> 00:45:28,840
running other instances of the agent

1199
00:45:26,890 --> 00:45:30,910
beneath it and it proxies communication

1200
00:45:28,840 --> 00:45:33,310
to them so if one of those goes haywire

1201
00:45:30,910 --> 00:45:36,160
well you've always got the hypervisor so

1202
00:45:33,310 --> 00:45:38,830
I'm working on some ideas for sort of H

1203
00:45:36,160 --> 00:45:41,290
a self-healing kind of stuff I also want

1204
00:45:38,830 --> 00:45:43,600
to make it a little bit more user

1205
00:45:41,290 --> 00:45:45,580
friendly I understand that as beautiful

1206
00:45:43,600 --> 00:45:47,140
as forth is conceptually it's kind of an

1207
00:45:45,580 --> 00:45:48,430
odd language so I've been thinking about

1208
00:45:47,140 --> 00:45:50,560
trying to come up with something that's

1209
00:45:48,430 --> 00:45:54,129
sort of in the you know the basic Lua

1210
00:45:50,560 --> 00:45:55,630
Python continuum as far as another level

1211
00:45:54,130 --> 00:45:57,760
of language that you can use to interact

1212
00:45:55,630 --> 00:46:00,250
with it it won't be too hard I think

1213
00:45:57,760 --> 00:46:01,480
I've already got parsers and I should be

1214
00:46:00,250 --> 00:46:02,950
able to write this in fourth and if you

1215
00:46:01,480 --> 00:46:04,840
wanted to use that you just send that

1216
00:46:02,950 --> 00:46:06,640
module down yeah fill up your dictionary

1217
00:46:04,840 --> 00:46:08,050
with a lot of new stuff one of the most

1218
00:46:06,640 --> 00:46:10,420
fascinating articles I've ever read in

1219
00:46:08,050 --> 00:46:12,880
my life is it an issue of fourth

1220
00:46:10,420 --> 00:46:14,560
dimensions magazines which is a the

1221
00:46:12,880 --> 00:46:18,940
trade journal for fourth back in the 80s

1222
00:46:14,560 --> 00:46:21,009
it's a guy who writes a fourth program

1223
00:46:18,940 --> 00:46:23,440
that extends the syntax of the forth

1224
00:46:21,010 --> 00:46:26,470
until it accepts the syntax and

1225
00:46:23,440 --> 00:46:28,030
semantics of tiny Pascal so you take a

1226
00:46:26,470 --> 00:46:30,250
few things out of Pascal just to make

1227
00:46:28,030 --> 00:46:33,880
the grammar a little easier and then it

1228
00:46:30,250 --> 00:46:35,180
begins to consume Pascal programs as an

1229
00:46:33,880 --> 00:46:38,640
interpreter this

1230
00:46:35,180 --> 00:46:40,618
disturbingly beautiful things more

1231
00:46:38,640 --> 00:46:42,000
transport layers got a couple in mind

1232
00:46:40,619 --> 00:46:44,280
ICMP is almost there I've got the

1233
00:46:42,000 --> 00:46:45,420
scaffold I just need to finish it and

1234
00:46:44,280 --> 00:46:47,549
then I want to put up some videos and

1235
00:46:45,420 --> 00:46:50,180
suffer for demo because in the forth

1236
00:46:47,549 --> 00:46:54,299
community it's not the most active

1237
00:46:50,180 --> 00:46:55,680
community in the world and and there

1238
00:46:54,299 --> 00:46:56,430
need to be some more videos so I'm going

1239
00:46:55,680 --> 00:46:59,040
to do my part

1240
00:46:56,430 --> 00:47:03,089
and of course document stuff you can

1241
00:46:59,040 --> 00:47:04,558
find me online I tweet about five times

1242
00:47:03,089 --> 00:47:06,420
a year and I try to make sure it's

1243
00:47:04,559 --> 00:47:08,700
substantial so it might be better than

1244
00:47:06,420 --> 00:47:11,640
all the other people you're following so

1245
00:47:08,700 --> 00:47:16,020
feel free grab you on Twitter email me

1246
00:47:11,640 --> 00:47:17,759
feel free and I was really proud of my

1247
00:47:16,020 --> 00:47:22,049
slides I don't know if you know this in

1248
00:47:17,760 --> 00:47:24,000
CGA the magenta is not red and blue it's

1249
00:47:22,049 --> 00:47:26,700
actually red and blue and one-third

1250
00:47:24,000 --> 00:47:28,410
green and the cyan is the same way just

1251
00:47:26,700 --> 00:47:32,160
different color channels so this is

1252
00:47:28,410 --> 00:47:35,220
legit CGA alright anybody got questions

1253
00:47:32,160 --> 00:47:37,230
and if if you want to talk about stuff

1254
00:47:35,220 --> 00:47:38,220
it'd be longer than like a question in

1255
00:47:37,230 --> 00:47:40,049
the last five minutes

1256
00:47:38,220 --> 00:47:47,578
grab me afterwards I'll talk forever

1257
00:47:40,049 --> 00:47:51,270
about this topic you can actually so

1258
00:47:47,579 --> 00:47:52,950
there's a function called forget so when

1259
00:47:51,270 --> 00:47:54,329
it starts it sets a point in the

1260
00:47:52,950 --> 00:47:55,848
dictionary and you can run forget and

1261
00:47:54,329 --> 00:47:58,559
it'll forget everything up to that point

1262
00:47:55,849 --> 00:47:59,910
and you can reset the forget point I do

1263
00:47:58,559 --> 00:48:01,799
this for incremental development all the

1264
00:47:59,910 --> 00:48:03,509
time I get something working and I set

1265
00:48:01,799 --> 00:48:05,309
the mark and then I try something else

1266
00:48:03,510 --> 00:48:16,319
which Bork's forever and I always forget

1267
00:48:05,309 --> 00:48:17,700
back to that spot yeah right yeah

1268
00:48:16,319 --> 00:48:20,790
they're also potentially all

1269
00:48:17,700 --> 00:48:22,740
interrelated absolute worst case there's

1270
00:48:20,790 --> 00:48:24,029
a function that puts the entry point on

1271
00:48:22,740 --> 00:48:25,770
the stack and there's a function that

1272
00:48:24,030 --> 00:48:27,359
starts a thread at some location in

1273
00:48:25,770 --> 00:48:35,670
memory and you can always just start

1274
00:48:27,359 --> 00:48:36,910
another one going going gone all right

1275
00:48:35,670 --> 00:48:42,920
thank you

1276
00:48:36,910 --> 00:48:42,920
[Applause]

