1
00:00:01,150 --> 00:00:05,840
[Music]

2
00:00:06,240 --> 00:00:08,160
practical web application firewall

3
00:00:08,160 --> 00:00:09,599
bypasses

4
00:00:09,599 --> 00:00:11,040
just a quick preface to this

5
00:00:11,040 --> 00:00:13,519
presentation all the techniques we're

6
00:00:13,519 --> 00:00:14,480
presenting

7
00:00:14,480 --> 00:00:18,160
have been used to bypass some laugh

8
00:00:18,160 --> 00:00:21,359
at some point in time of course not

9
00:00:21,359 --> 00:00:22,720
every laugh is the same

10
00:00:22,720 --> 00:00:24,640
but hopefully you'll find some of these

11
00:00:24,640 --> 00:00:28,640
techniques useful in the future

12
00:00:28,640 --> 00:00:31,439
first a brief introduction my name is

13
00:00:31,439 --> 00:00:32,238
robert

14
00:00:32,238 --> 00:00:33,840
i'm also known as not the ghost on

15
00:00:33,840 --> 00:00:36,719
hacker one i'm a 17 year old high

16
00:00:36,719 --> 00:00:38,320
schooler at interlake high school in

17
00:00:38,320 --> 00:00:40,000
washington state

18
00:00:40,000 --> 00:00:42,800
in my spare time i enjoy doing ctfs with

19
00:00:42,800 --> 00:00:45,280
the red pen hunting for bugs and hacker

20
00:00:45,280 --> 00:00:45,840
one

21
00:00:45,840 --> 00:00:47,840
and just messing around with random

22
00:00:47,840 --> 00:00:49,600
projects

23
00:00:49,600 --> 00:00:51,680
i'm philip and i'm known as kingcoid on

24
00:00:51,680 --> 00:00:54,239
hacker1 i'm a 16 year old highschooler

25
00:00:54,239 --> 00:00:56,399
who does ctfs with the redpone and hunts

26
00:00:56,399 --> 00:00:58,480
for bugs on hacker one let's look at

27
00:00:58,480 --> 00:01:00,480
some background information

28
00:01:00,480 --> 00:01:03,199
for those who are unfamiliar a web

29
00:01:03,199 --> 00:01:04,799
application firewall

30
00:01:04,799 --> 00:01:07,439
also known as off is an external

31
00:01:07,439 --> 00:01:08,240
application

32
00:01:08,240 --> 00:01:11,439
designed to filter out attacks these

33
00:01:11,439 --> 00:01:14,880
generally operate on layer 7

34
00:01:14,880 --> 00:01:18,240
over http traffic hence the

35
00:01:18,240 --> 00:01:20,799
web application part of web application

36
00:01:20,799 --> 00:01:22,640
firewall

37
00:01:22,640 --> 00:01:24,720
these tend to be more common when pin

38
00:01:24,720 --> 00:01:26,640
testing larger companies

39
00:01:26,640 --> 00:01:29,439
for example some dod websites are

40
00:01:29,439 --> 00:01:32,479
protected by a generic graph

41
00:01:32,479 --> 00:01:34,159
at the same time it's important to keep

42
00:01:34,159 --> 00:01:35,840
in mind that there's

43
00:01:35,840 --> 00:01:38,880
a security usability trade-off

44
00:01:38,880 --> 00:01:42,159
so what that means is watch that stop

45
00:01:42,159 --> 00:01:45,200
more attacks also tend to generate more

46
00:01:45,200 --> 00:01:47,360
false positives

47
00:01:47,360 --> 00:01:49,759
for example here we have a proprietary

48
00:01:49,759 --> 00:01:50,399
raf

49
00:01:50,399 --> 00:01:54,320
which manages to stop 100 of attacks

50
00:01:54,320 --> 00:01:57,520
unfortunately it also has a 100 false

51
00:01:57,520 --> 00:01:59,520
positive rate

52
00:01:59,520 --> 00:02:02,560
um but on a more serious note this

53
00:02:02,560 --> 00:02:04,960
security usability trade-off is

54
00:02:04,960 --> 00:02:06,799
generally beneficial

55
00:02:06,799 --> 00:02:10,239
for pen testers because companies

56
00:02:10,239 --> 00:02:12,640
tend to earn the site of usability when

57
00:02:12,640 --> 00:02:14,239
designing wafts

58
00:02:14,239 --> 00:02:17,120
these wafts can be designed to prevent a

59
00:02:17,120 --> 00:02:19,200
wide variety of attacks

60
00:02:19,200 --> 00:02:21,680
oftentimes this could include sql

61
00:02:21,680 --> 00:02:22,400
injection

62
00:02:22,400 --> 00:02:25,200
cross-site scripting and local file

63
00:02:25,200 --> 00:02:28,080
inclusion just to name a few

64
00:02:28,080 --> 00:02:30,879
in this presentation we'll be focusing

65
00:02:30,879 --> 00:02:31,280
on

66
00:02:31,280 --> 00:02:33,200
xss or cross-site scripting

67
00:02:33,200 --> 00:02:35,360
vulnerabilities specifically

68
00:02:35,360 --> 00:02:38,879
for a couple reasons for one javascript

69
00:02:38,879 --> 00:02:40,239
and html syntax

70
00:02:40,239 --> 00:02:43,680
is a lot more fluid comparison

71
00:02:43,680 --> 00:02:46,879
sql has a lot less statements

72
00:02:46,879 --> 00:02:50,160
and is a lot more rigid also

73
00:02:50,160 --> 00:02:52,640
html and javascript have a lot of stuff

74
00:02:52,640 --> 00:02:53,519
to exploit

75
00:02:53,519 --> 00:02:56,239
there's tons of random global variables

76
00:02:56,239 --> 00:02:56,800
some

77
00:02:56,800 --> 00:02:59,920
not very well known behavior and random

78
00:02:59,920 --> 00:03:02,879
undocumented features also xss is

79
00:03:02,879 --> 00:03:05,840
arguably more relevant

80
00:03:05,840 --> 00:03:08,239
you'll probably find more reflected xss

81
00:03:08,239 --> 00:03:09,519
vulnerabilities

82
00:03:09,519 --> 00:03:13,040
than sql injections in general

83
00:03:13,040 --> 00:03:15,280
most companies use a very small number

84
00:03:15,280 --> 00:03:17,280
of common maps such as imperva

85
00:03:17,280 --> 00:03:20,239
f5 cloudflare and akamai most of these

86
00:03:20,239 --> 00:03:22,400
webs can be easily bypassed to achieve

87
00:03:22,400 --> 00:03:24,720
xss using some common strategies which

88
00:03:24,720 --> 00:03:26,879
we will explore today

89
00:03:26,879 --> 00:03:29,840
at its core most if not all wafts use

90
00:03:29,840 --> 00:03:31,760
regular expressions to filter out

91
00:03:31,760 --> 00:03:33,280
malicious payloads

92
00:03:33,280 --> 00:03:35,680
for example this regular expression

93
00:03:35,680 --> 00:03:37,519
taken from the cloudflare blog

94
00:03:37,519 --> 00:03:39,840
provides some insight into how wafts

95
00:03:39,840 --> 00:03:40,959
operate

96
00:03:40,959 --> 00:03:42,959
this has the advantage of providing a

97
00:03:42,959 --> 00:03:45,280
very fast and simple mechanism to filter

98
00:03:45,280 --> 00:03:46,560
out requests

99
00:03:46,560 --> 00:03:48,799
keep in mind that wafts operate over

100
00:03:48,799 --> 00:03:51,200
every single piece of network traffic

101
00:03:51,200 --> 00:03:53,599
any latency in the wef would be felt

102
00:03:53,599 --> 00:03:55,280
across every endpoint

103
00:03:55,280 --> 00:03:58,319
wafts need to optimize for performance

104
00:03:58,319 --> 00:04:00,319
they need to decide whether to block a

105
00:04:00,319 --> 00:04:02,080
request very quickly

106
00:04:02,080 --> 00:04:04,560
while javascript execution might allow

107
00:04:04,560 --> 00:04:06,799
for a more comprehensive solution

108
00:04:06,799 --> 00:04:09,599
most wafts can't afford the overhead

109
00:04:09,599 --> 00:04:10,480
some of the more

110
00:04:10,480 --> 00:04:12,560
common filters we've encountered include

111
00:04:12,560 --> 00:04:14,159
blocking function calls

112
00:04:14,159 --> 00:04:16,399
blocking keywords like onload and

113
00:04:16,399 --> 00:04:17,600
innerhtml

114
00:04:17,600 --> 00:04:19,918
and blocking special characters such as

115
00:04:19,918 --> 00:04:22,079
array index operations

116
00:04:22,079 --> 00:04:24,800
in general highly complex operations

117
00:04:24,800 --> 00:04:26,800
like creating objects and function calls

118
00:04:26,800 --> 00:04:28,000
tend to have a higher

119
00:04:28,000 --> 00:04:31,680
chance of being blocked another useful

120
00:04:31,680 --> 00:04:33,680
strategy that wifes employ

121
00:04:33,680 --> 00:04:36,720
is the execution context so

122
00:04:36,720 --> 00:04:38,479
this looks at where the payload is

123
00:04:38,479 --> 00:04:40,000
actually running

124
00:04:40,000 --> 00:04:42,960
for example an injection that is inside

125
00:04:42,960 --> 00:04:43,919
js code

126
00:04:43,919 --> 00:04:45,600
could probably be handled very

127
00:04:45,600 --> 00:04:47,199
differently from

128
00:04:47,199 --> 00:04:51,120
a plane html ejection similarly if we're

129
00:04:51,120 --> 00:04:52,400
injecting inside

130
00:04:52,400 --> 00:04:54,880
an attribute for example of an input

131
00:04:54,880 --> 00:04:55,840
element

132
00:04:55,840 --> 00:04:57,840
that would also require a different

133
00:04:57,840 --> 00:04:59,600
payload to escape

134
00:04:59,600 --> 00:05:02,479
uh by taking into account the execution

135
00:05:02,479 --> 00:05:03,919
context

136
00:05:03,919 --> 00:05:05,919
we can greatly reduce the number of

137
00:05:05,919 --> 00:05:08,320
false positives

138
00:05:08,320 --> 00:05:11,600
at the same time this also increases the

139
00:05:11,600 --> 00:05:12,880
complexity of the waff

140
00:05:12,880 --> 00:05:15,600
because it requires it to have some

141
00:05:15,600 --> 00:05:17,600
understanding of where the payload is

142
00:05:17,600 --> 00:05:19,759
being executed

143
00:05:19,759 --> 00:05:22,800
such a feature tends to appear more

144
00:05:22,800 --> 00:05:24,800
commonly in reflected excess

145
00:05:24,800 --> 00:05:28,560
scenarios but overall this isn't too

146
00:05:28,560 --> 00:05:31,600
common at least from our experience one

147
00:05:31,600 --> 00:05:33,280
crucial part of exploitation

148
00:05:33,280 --> 00:05:35,919
is payload construction so this attempts

149
00:05:35,919 --> 00:05:37,600
to answer the question

150
00:05:37,600 --> 00:05:40,479
how can i get an arbitrary value into a

151
00:05:40,479 --> 00:05:42,639
js variable

152
00:05:42,639 --> 00:05:45,120
one thing to note is that payload

153
00:05:45,120 --> 00:05:46,160
construction in

154
00:05:46,160 --> 00:05:50,479
and of itself isn't a bypass necessarily

155
00:05:50,479 --> 00:05:53,600
but it is a crucial part of later

156
00:05:53,600 --> 00:05:54,960
execution

157
00:05:54,960 --> 00:05:58,160
for example often times we'll want to

158
00:05:58,160 --> 00:05:58,880
construct an

159
00:05:58,880 --> 00:06:01,919
excess payload but the raffle filter for

160
00:06:01,919 --> 00:06:05,440
the svg onload stream literal

161
00:06:05,440 --> 00:06:07,680
there's two general categories of

162
00:06:07,680 --> 00:06:09,440
payload construction

163
00:06:09,440 --> 00:06:12,319
first is string construction and this

164
00:06:12,319 --> 00:06:13,600
relies on the idea

165
00:06:13,600 --> 00:06:15,520
that wafts operate on the literal

166
00:06:15,520 --> 00:06:17,840
character content of payloads

167
00:06:17,840 --> 00:06:20,720
luckily js code is quite complex so

168
00:06:20,720 --> 00:06:22,479
instead of embedding our payload string

169
00:06:22,479 --> 00:06:23,840
directly into code

170
00:06:23,840 --> 00:06:26,319
we can construct it gradually through js

171
00:06:26,319 --> 00:06:27,440
code

172
00:06:27,440 --> 00:06:30,240
it would be infeasible for a waff to

173
00:06:30,240 --> 00:06:32,639
fully parse and execute the javascript

174
00:06:32,639 --> 00:06:33,440
code

175
00:06:33,440 --> 00:06:36,240
allowing us to bypass the waf hiding our

176
00:06:36,240 --> 00:06:38,160
payload

177
00:06:38,160 --> 00:06:40,880
another more arguably gimmicky technique

178
00:06:40,880 --> 00:06:42,400
involves string hiding

179
00:06:42,400 --> 00:06:44,560
which exploits browser features to hide

180
00:06:44,560 --> 00:06:46,960
payloads in weird places

181
00:06:46,960 --> 00:06:49,759
the crucial idea here is that js or

182
00:06:49,759 --> 00:06:51,440
javascript has access to a

183
00:06:51,440 --> 00:06:54,080
wide range of data much of which isn't

184
00:06:54,080 --> 00:06:56,400
actually sent to the web server

185
00:06:56,400 --> 00:06:57,759
and we'll go over this more in depth

186
00:06:57,759 --> 00:07:00,400
later perhaps the most

187
00:07:00,400 --> 00:07:03,599
basic example of string construction is

188
00:07:03,599 --> 00:07:05,680
javascript parameter splitting

189
00:07:05,680 --> 00:07:07,520
the idea is we can split a payload

190
00:07:07,520 --> 00:07:09,360
across multiple variables

191
00:07:09,360 --> 00:07:12,319
and iteratively construct it one

192
00:07:12,319 --> 00:07:13,840
interesting thing to note here is that

193
00:07:13,840 --> 00:07:15,199
the bottom example

194
00:07:15,199 --> 00:07:17,039
actually involves constructing the

195
00:07:17,039 --> 00:07:18,960
payload from right to left

196
00:07:18,960 --> 00:07:22,160
so some laps will filter out sequences

197
00:07:22,160 --> 00:07:25,199
for example they'll block parentheses

198
00:07:25,199 --> 00:07:25,599
after

199
00:07:25,599 --> 00:07:28,560
svg unload appears constructing the

200
00:07:28,560 --> 00:07:29,280
payload

201
00:07:29,280 --> 00:07:32,800
from right to left can bypass these uh

202
00:07:32,800 --> 00:07:36,000
regex filters uh another

203
00:07:36,000 --> 00:07:39,039
example is dom parameter splitting

204
00:07:39,039 --> 00:07:40,560
where we split the payload across

205
00:07:40,560 --> 00:07:42,160
multiple html elements

206
00:07:42,160 --> 00:07:45,280
and then reconstruct it in

207
00:07:45,280 --> 00:07:49,120
one final step this particular scenario

208
00:07:49,120 --> 00:07:51,039
assumes an html injection but it can

209
00:07:51,039 --> 00:07:53,280
also work with say an attribute

210
00:07:53,280 --> 00:07:56,720
injection after we escape the attribute

211
00:07:56,720 --> 00:07:59,039
one useful trick that we use in this

212
00:07:59,039 --> 00:08:00,639
technique and also

213
00:08:00,639 --> 00:08:03,280
later techniques is referencing elements

214
00:08:03,280 --> 00:08:04,720
by their id

215
00:08:04,720 --> 00:08:07,039
uh this allows us to avoid more

216
00:08:07,039 --> 00:08:08,479
complicated functions

217
00:08:08,479 --> 00:08:12,080
like say document.getelementbyid and

218
00:08:12,080 --> 00:08:14,800
gives us an easy way to access

219
00:08:14,800 --> 00:08:17,520
our injected html elements data set

220
00:08:17,520 --> 00:08:18,720
parameter splitting is

221
00:08:18,720 --> 00:08:20,879
very similar to dom parameter splitting

222
00:08:20,879 --> 00:08:22,240
except for it only involves

223
00:08:22,240 --> 00:08:25,280
one element which can be more useful in

224
00:08:25,280 --> 00:08:26,720
certain scenarios where

225
00:08:26,720 --> 00:08:29,919
wipes will filter out multiple html

226
00:08:29,919 --> 00:08:30,879
elements

227
00:08:30,879 --> 00:08:33,200
in this case we split the payload across

228
00:08:33,200 --> 00:08:35,039
multiple data set properties

229
00:08:35,039 --> 00:08:36,880
and we combine them at the very end in

230
00:08:36,880 --> 00:08:38,320
the on load

231
00:08:38,320 --> 00:08:41,279
we can also abuse the fact that the

232
00:08:41,279 --> 00:08:42,399
inner text property

233
00:08:42,399 --> 00:08:44,560
only looks at the text content of the

234
00:08:44,560 --> 00:08:45,519
element

235
00:08:45,519 --> 00:08:47,920
so by interspersing arbitrary html

236
00:08:47,920 --> 00:08:49,360
elements we can actually split the

237
00:08:49,360 --> 00:08:50,640
payload

238
00:08:50,640 --> 00:08:53,839
we can also html encode entities to

239
00:08:53,839 --> 00:08:55,279
further obfuscate

240
00:08:55,279 --> 00:08:58,720
our payload window.name payload storage

241
00:08:58,720 --> 00:09:00,399
is pretty interesting

242
00:09:00,399 --> 00:09:03,600
it abuses the fact that window.name

243
00:09:03,600 --> 00:09:06,240
is preserved across redirects in other

244
00:09:06,240 --> 00:09:07,120
words

245
00:09:07,120 --> 00:09:09,519
if we assign to the value of window.name

246
00:09:09,519 --> 00:09:11,680
and then trigger a navigation

247
00:09:11,680 --> 00:09:14,320
even if it's to a cross-origin domain

248
00:09:14,320 --> 00:09:17,200
window.name stays the same

249
00:09:17,200 --> 00:09:19,040
which means that we can use this to

250
00:09:19,040 --> 00:09:21,360
store arbitrary contents including

251
00:09:21,360 --> 00:09:24,640
for example an xss payload after

252
00:09:24,640 --> 00:09:25,680
constructing or

253
00:09:25,680 --> 00:09:27,519
hiding the payload somewhere we need to

254
00:09:27,519 --> 00:09:28,959
use a browser api

255
00:09:28,959 --> 00:09:31,600
in order to execute it somehow there's

256
00:09:31,600 --> 00:09:32,000
two

257
00:09:32,000 --> 00:09:34,640
general paths we go about for payload

258
00:09:34,640 --> 00:09:35,519
execution

259
00:09:35,519 --> 00:09:37,200
eventually allowing us to perform

260
00:09:37,200 --> 00:09:38,720
something interesting

261
00:09:38,720 --> 00:09:41,519
first we can execute user visible code

262
00:09:41,519 --> 00:09:43,920
the end goal is usually to create some

263
00:09:43,920 --> 00:09:45,680
sort of visual indicator

264
00:09:45,680 --> 00:09:47,920
for example an alert box which is enough

265
00:09:47,920 --> 00:09:51,600
to demonstrate access to a triage team

266
00:09:51,600 --> 00:09:53,760
alternatively we can attempt session

267
00:09:53,760 --> 00:09:54,880
exfiltration

268
00:09:54,880 --> 00:09:57,680
generally by extracting a session cookie

269
00:09:57,680 --> 00:09:59,680
note that this is somewhat limited

270
00:09:59,680 --> 00:10:02,079
failing against targets which have http

271
00:10:02,079 --> 00:10:03,839
only session cookies

272
00:10:03,839 --> 00:10:05,839
in order to exfiltrate data we need to

273
00:10:05,839 --> 00:10:07,920
somehow make a network request

274
00:10:07,920 --> 00:10:10,720
to do that we can redirect the user back

275
00:10:10,720 --> 00:10:12,160
to an attacker-owned

276
00:10:12,160 --> 00:10:15,360
server the easiest way to achieve

277
00:10:15,360 --> 00:10:18,320
code execution is by simply assigning to

278
00:10:18,320 --> 00:10:20,959
inner html and outer html

279
00:10:20,959 --> 00:10:23,839
if the strings inner html and outer html

280
00:10:23,839 --> 00:10:24,720
are blocked

281
00:10:24,720 --> 00:10:27,120
we can construct the string by appending

282
00:10:27,120 --> 00:10:28,800
other strings either in line

283
00:10:28,800 --> 00:10:31,200
as shown here or as previously

284
00:10:31,200 --> 00:10:33,519
documented in the payload construction

285
00:10:33,519 --> 00:10:36,320
section the easiest way to exfiltrate

286
00:10:36,320 --> 00:10:38,320
data is through location setting

287
00:10:38,320 --> 00:10:40,480
redirecting the user to an attacker

288
00:10:40,480 --> 00:10:42,000
controlled server

289
00:10:42,000 --> 00:10:44,560
by appending document.cookie to the end

290
00:10:44,560 --> 00:10:45,680
of our url

291
00:10:45,680 --> 00:10:47,680
we are able to exfiltrate the session

292
00:10:47,680 --> 00:10:50,480
cookie in an actual attack scenario the

293
00:10:50,480 --> 00:10:52,480
attacker could then redirect back to the

294
00:10:52,480 --> 00:10:54,399
vulnerable site to avoid arousing

295
00:10:54,399 --> 00:10:55,360
suspicions

296
00:10:55,360 --> 00:10:57,680
one very big advantage of this method is

297
00:10:57,680 --> 00:11:00,000
that it avoids the need for any function

298
00:11:00,000 --> 00:11:02,000
calls which tend to get processed more

299
00:11:02,000 --> 00:11:03,040
strictly

300
00:11:03,040 --> 00:11:05,440
in general location assignment can often

301
00:11:05,440 --> 00:11:07,519
be the sync for other methods

302
00:11:07,519 --> 00:11:10,399
this method also works regardless of csp

303
00:11:10,399 --> 00:11:12,000
as long as you can achieve code

304
00:11:12,000 --> 00:11:12,880
execution

305
00:11:12,880 --> 00:11:14,959
which isn't necessarily true for some of

306
00:11:14,959 --> 00:11:16,640
the later methods

307
00:11:16,640 --> 00:11:19,040
the primary disadvantage is that this

308
00:11:19,040 --> 00:11:21,680
won't work for applications with http

309
00:11:21,680 --> 00:11:23,360
only session cookies

310
00:11:23,360 --> 00:11:26,000
regardless cookie exfiltration is

311
00:11:26,000 --> 00:11:27,920
usually good enough to demonstrate

312
00:11:27,920 --> 00:11:31,440
impact certain waffs will block direct

313
00:11:31,440 --> 00:11:33,440
assignment to special variables like

314
00:11:33,440 --> 00:11:34,480
location

315
00:11:34,480 --> 00:11:36,560
however there are some pretty clever

316
00:11:36,560 --> 00:11:38,399
ways to bypass this filter

317
00:11:38,399 --> 00:11:40,800
for one you can insert arbitrary

318
00:11:40,800 --> 00:11:42,640
comments between location and the

319
00:11:42,640 --> 00:11:43,920
assignment operator

320
00:11:43,920 --> 00:11:46,480
alternatively you can abuse a lack of

321
00:11:46,480 --> 00:11:48,399
semicolons to place the rest of an

322
00:11:48,399 --> 00:11:49,040
assignment

323
00:11:49,040 --> 00:11:52,000
expression after a new line another way

324
00:11:52,000 --> 00:11:52,720
is by using

325
00:11:52,720 --> 00:11:55,839
the plus equals operator to do this we

326
00:11:55,839 --> 00:11:57,920
first use the plus equals operator to

327
00:11:57,920 --> 00:12:00,240
assign to the hash

328
00:12:00,240 --> 00:12:02,399
this doesn't trigger a redirect which

329
00:12:02,399 --> 00:12:04,240
allows us to safely store our

330
00:12:04,240 --> 00:12:07,120
exfiltrated data note the hash defaults

331
00:12:07,120 --> 00:12:08,560
to an empty string

332
00:12:08,560 --> 00:12:11,200
so on a page with no hash the hash just

333
00:12:11,200 --> 00:12:13,200
becomes the user's cookies

334
00:12:13,200 --> 00:12:15,680
next we can use the plus equals operator

335
00:12:15,680 --> 00:12:17,680
to assign to location.host

336
00:12:17,680 --> 00:12:20,160
to actually trigger the redirect the

337
00:12:20,160 --> 00:12:22,800
attacker could use wildcard dns or

338
00:12:22,800 --> 00:12:25,200
register the specific subdomain to then

339
00:12:25,200 --> 00:12:27,839
host a page which steals cookies

340
00:12:27,839 --> 00:12:30,000
this exploit is a bit more involved so

341
00:12:30,000 --> 00:12:33,360
we'll be doing a brief demo

342
00:12:33,360 --> 00:12:35,920
on the right here we have a webpage that

343
00:12:35,920 --> 00:12:38,720
is vulnerable to xss a simulated web

344
00:12:38,720 --> 00:12:40,880
page the payload parameter here

345
00:12:40,880 --> 00:12:42,560
as you can see we've injected an h1

346
00:12:42,560 --> 00:12:45,200
element with injection

347
00:12:45,200 --> 00:12:48,240
and on the left here we have a request

348
00:12:48,240 --> 00:12:50,240
bin which allows us to easily see

349
00:12:50,240 --> 00:12:53,040
and log any requests that hit it so for

350
00:12:53,040 --> 00:12:55,360
example if we take this end point

351
00:12:55,360 --> 00:12:57,600
and we open it up we'll see that there

352
00:12:57,600 --> 00:12:58,560
have been the requests

353
00:12:58,560 --> 00:12:59,760
and they get logged on the side here

354
00:12:59,760 --> 00:13:02,079
which is very useful for testing

355
00:13:02,079 --> 00:13:05,200
uh information exfiltration

356
00:13:05,200 --> 00:13:09,040
so if we go over here we can create

357
00:13:09,040 --> 00:13:11,839
a few cookies

358
00:13:17,519 --> 00:13:20,240
now we can see that the document.cookie

359
00:13:20,240 --> 00:13:21,839
value gets populated so

360
00:13:21,839 --> 00:13:23,839
now we're going to try to exfiltrate

361
00:13:23,839 --> 00:13:25,040
this cookie

362
00:13:25,040 --> 00:13:26,800
which could be for example a session

363
00:13:26,800 --> 00:13:29,120
cookie or any other useful information

364
00:13:29,120 --> 00:13:30,320
that an attacker

365
00:13:30,320 --> 00:13:32,720
would want to steal so the easiest way

366
00:13:32,720 --> 00:13:33,440
would be

367
00:13:33,440 --> 00:13:36,240
just assignment to location so we can do

368
00:13:36,240 --> 00:13:38,480
that by

369
00:13:38,480 --> 00:13:41,600
assigning the location

370
00:13:42,240 --> 00:13:44,000
and then concatenating with the value of

371
00:13:44,000 --> 00:13:45,760
document.cookie and if you see we do

372
00:13:45,760 --> 00:13:46,560
this and we press

373
00:13:46,560 --> 00:13:48,959
enter and we'll see that the value of

374
00:13:48,959 --> 00:13:50,880
document.cookie

375
00:13:50,880 --> 00:13:53,440
gets logged here on the side because it

376
00:13:53,440 --> 00:13:54,639
gets

377
00:13:54,639 --> 00:13:57,839
concatenated into the path

378
00:13:57,839 --> 00:14:00,399
that's one way to do it unfortunately

379
00:14:00,399 --> 00:14:02,639
many rafts actually block direct

380
00:14:02,639 --> 00:14:05,440
direct assignment to location it's a

381
00:14:05,440 --> 00:14:07,839
pretty well known trick at this point

382
00:14:07,839 --> 00:14:09,760
to get around this there's a variety of

383
00:14:09,760 --> 00:14:11,680
ways we can there's a variety of

384
00:14:11,680 --> 00:14:15,600
tricks for one we can try inserting

385
00:14:15,600 --> 00:14:18,639
junk between the location and the equal

386
00:14:18,639 --> 00:14:21,440
sign so for example if we have a cookie

387
00:14:21,440 --> 00:14:22,160
here

388
00:14:22,160 --> 00:14:25,600
i mean if you have a comment here

389
00:14:25,920 --> 00:14:28,320
the this is still valid javascript code

390
00:14:28,320 --> 00:14:30,160
and running it would still trigger the

391
00:14:30,160 --> 00:14:30,880
redirect

392
00:14:30,880 --> 00:14:32,959
but it looks a bit different to the

393
00:14:32,959 --> 00:14:34,000
laughs so it might

394
00:14:34,000 --> 00:14:36,720
confuse it we could also do this with

395
00:14:36,720 --> 00:14:38,240
say for example

396
00:14:38,240 --> 00:14:41,760
a line comment so two slashes

397
00:14:41,760 --> 00:14:44,880
and again this would work uh one

398
00:14:44,880 --> 00:14:46,560
interesting thing is html comments

399
00:14:46,560 --> 00:14:48,480
actually also work in javascript so if

400
00:14:48,480 --> 00:14:49,440
we do

401
00:14:49,440 --> 00:14:52,959
less than exclamation in two dashes

402
00:14:52,959 --> 00:14:55,360
this operates the same way as a double

403
00:14:55,360 --> 00:14:57,279
slash comment

404
00:14:57,279 --> 00:14:59,839
but some maps don't properly parse this

405
00:14:59,839 --> 00:15:00,399
so

406
00:15:00,399 --> 00:15:04,399
this would be a bypass um for some

407
00:15:04,399 --> 00:15:07,279
web application firewalls uh a slightly

408
00:15:07,279 --> 00:15:08,720
more complicated technique

409
00:15:08,720 --> 00:15:10,959
involves using the plus equals operator

410
00:15:10,959 --> 00:15:12,079
so

411
00:15:12,079 --> 00:15:15,360
to do this we first use the plus equals

412
00:15:15,360 --> 00:15:16,079
operator

413
00:15:16,079 --> 00:15:19,440
with location.hash and

414
00:15:19,440 --> 00:15:21,360
we do this because we want a place to

415
00:15:21,360 --> 00:15:22,959
put document.cookie

416
00:15:22,959 --> 00:15:25,519
which does not trigger a redirect if you

417
00:15:25,519 --> 00:15:26,000
see if

418
00:15:26,000 --> 00:15:28,639
we evaluate this statement the

419
00:15:28,639 --> 00:15:30,720
document.hash gets populated but since

420
00:15:30,720 --> 00:15:32,079
it's a hash change

421
00:15:32,079 --> 00:15:35,360
the uh the document doesn't the page

422
00:15:35,360 --> 00:15:38,320
doesn't redirect to anything else

423
00:15:38,320 --> 00:15:39,680
in essence what this is doing is

424
00:15:39,680 --> 00:15:41,880
location.hash is equal to

425
00:15:41,880 --> 00:15:44,800
location.plus document.cookie

426
00:15:44,800 --> 00:15:47,120
but initiallylocation.hash when there's

427
00:15:47,120 --> 00:15:49,680
no hash is equal to an empty string so

428
00:15:49,680 --> 00:15:52,839
for example if i just open up a random

429
00:15:52,839 --> 00:15:54,800
page

430
00:15:54,800 --> 00:15:57,759
and then i type in location.hash we'll

431
00:15:57,759 --> 00:15:59,680
see that it's an empty string so

432
00:15:59,680 --> 00:16:02,480
when we use the plus equals operator uh

433
00:16:02,480 --> 00:16:03,440
in essence it's just

434
00:16:03,440 --> 00:16:07,519
assignment to location.hash

435
00:16:07,519 --> 00:16:11,279
but it's like a bit obfuscated

436
00:16:11,279 --> 00:16:13,040
um and then in order to actually trigger

437
00:16:13,040 --> 00:16:15,639
a redirect we can use

438
00:16:15,639 --> 00:16:18,320
location.origin plus equals

439
00:16:18,320 --> 00:16:22,399
and then we do dot attacker

440
00:16:22,399 --> 00:16:24,639
dot com so what this does is it changes

441
00:16:24,639 --> 00:16:26,160
the origin

442
00:16:26,160 --> 00:16:29,759
uh wait no location.

443
00:16:29,759 --> 00:16:33,279
sorry yeah location.org

444
00:16:33,279 --> 00:16:34,880
for some reason doesn't work even though

445
00:16:34,880 --> 00:16:36,880
it looks very similar

446
00:16:36,880 --> 00:16:39,440
a location not arguing and looking out

447
00:16:39,440 --> 00:16:41,279
uh hosts look very similar but

448
00:16:41,279 --> 00:16:43,759
we need to do its location.host so what

449
00:16:43,759 --> 00:16:44,480
this does

450
00:16:44,480 --> 00:16:47,600
is it redirects the page to uh the

451
00:16:47,600 --> 00:16:48,079
current

452
00:16:48,079 --> 00:16:51,079
document origin which was

453
00:16:51,079 --> 00:16:52,800
xss.get.workers.dev

454
00:16:52,800 --> 00:16:55,440
and then we append.attacker.com to this

455
00:16:55,440 --> 00:16:56,480
origin

456
00:16:56,480 --> 00:16:59,440
um but since this top part is controlled

457
00:16:59,440 --> 00:17:00,720
this attacker.com

458
00:17:00,720 --> 00:17:02,639
is controlled by an attacker you just

459
00:17:02,639 --> 00:17:03,759
easily register

460
00:17:03,759 --> 00:17:06,799
this exercise.get.workers.dev as a

461
00:17:06,799 --> 00:17:08,319
subdomain or we can use a

462
00:17:08,319 --> 00:17:11,199
wildcard subdomain here and then we can

463
00:17:11,199 --> 00:17:12,240
serve a page

464
00:17:12,240 --> 00:17:14,720
which would then read the location.hash

465
00:17:14,720 --> 00:17:15,760
because

466
00:17:15,760 --> 00:17:18,160
i don't think we can read it here but if

467
00:17:18,160 --> 00:17:18,959
this was a

468
00:17:18,959 --> 00:17:20,880
valid page we would be able to read

469
00:17:20,880 --> 00:17:22,959
location.hash

470
00:17:22,959 --> 00:17:24,319
and then it could like send off the

471
00:17:24,319 --> 00:17:27,119
cookie to an attacker controlled server

472
00:17:27,119 --> 00:17:29,760
if assignment to location is blocked

473
00:17:29,760 --> 00:17:31,120
images can also make

474
00:17:31,120 --> 00:17:34,480
requests to external servers one caveat

475
00:17:34,480 --> 00:17:36,400
here is that these requests might be

476
00:17:36,400 --> 00:17:39,520
blocked by the content security policy

477
00:17:39,520 --> 00:17:41,520
there are a couple of ways to go around

478
00:17:41,520 --> 00:17:43,840
doing this the simplest way would be to

479
00:17:43,840 --> 00:17:46,080
create a new dom image object and assign

480
00:17:46,080 --> 00:17:47,600
a source attribute to it

481
00:17:47,600 --> 00:17:49,919
unfortunately assignment to source tends

482
00:17:49,919 --> 00:17:51,039
to get blocked

483
00:17:51,039 --> 00:17:53,600
one bypass is by using the source set

484
00:17:53,600 --> 00:17:54,400
property

485
00:17:54,400 --> 00:17:56,480
unfortunately due to how source that is

486
00:17:56,480 --> 00:17:58,720
parsed spaces have special semantic

487
00:17:58,720 --> 00:17:59,440
meaning

488
00:17:59,440 --> 00:18:01,400
this means that assigning directly from

489
00:18:01,400 --> 00:18:02,559
document.cookie

490
00:18:02,559 --> 00:18:04,640
which normally contains spaces in it

491
00:18:04,640 --> 00:18:06,320
won't work

492
00:18:06,320 --> 00:18:08,080
in order to get around this we first

493
00:18:08,080 --> 00:18:09,919
assign to low source

494
00:18:09,919 --> 00:18:12,000
although this property is deprecated it

495
00:18:12,000 --> 00:18:14,000
still functions similar to source in

496
00:18:14,000 --> 00:18:15,440
that it will automatically

497
00:18:15,440 --> 00:18:18,320
uri encode its contents assignment to

498
00:18:18,320 --> 00:18:20,880
low source thus allows us to mutate

499
00:18:20,880 --> 00:18:23,440
the string representation of the cookie

500
00:18:23,440 --> 00:18:25,919
uri encoding it without any function

501
00:18:25,919 --> 00:18:26,400
calls

502
00:18:26,400 --> 00:18:28,559
we can then extract it normally with

503
00:18:28,559 --> 00:18:30,559
assignment to source set

504
00:18:30,559 --> 00:18:32,559
we'll also be doing a brief demo for

505
00:18:32,559 --> 00:18:33,840
this exploit

506
00:18:33,840 --> 00:18:37,280
so first let's modify

507
00:18:37,280 --> 00:18:39,360
our payload here to create a generic

508
00:18:39,360 --> 00:18:40,840
image element with

509
00:18:40,840 --> 00:18:44,400
ida and you can see if we go into

510
00:18:44,400 --> 00:18:46,160
inspect element here that the image

511
00:18:46,160 --> 00:18:47,919
element does get created

512
00:18:47,919 --> 00:18:50,160
now we can simulate the addition of

513
00:18:50,160 --> 00:18:52,640
cookies

514
00:18:52,880 --> 00:18:57,840
by setting a few uh cookies

515
00:19:01,360 --> 00:19:03,280
and we can see that document.cookie gets

516
00:19:03,280 --> 00:19:05,039
populated now let's

517
00:19:05,039 --> 00:19:08,720
try to exfiltrate these values

518
00:19:08,720 --> 00:19:10,559
first the most generic way would be

519
00:19:10,559 --> 00:19:12,559
through src so if we just do

520
00:19:12,559 --> 00:19:15,440
a ssc

521
00:19:17,760 --> 00:19:20,000
and then we assign to the value of our

522
00:19:20,000 --> 00:19:21,120
endpoint

523
00:19:21,120 --> 00:19:24,000
and concatenate it with document.cookie

524
00:19:24,000 --> 00:19:25,280
we can see that

525
00:19:25,280 --> 00:19:27,760
we log a request with the two cookies

526
00:19:27,760 --> 00:19:30,480
exfoliated

527
00:19:31,600 --> 00:19:34,880
however if we try and refresh the page

528
00:19:34,880 --> 00:19:36,720
and we try to do the same thing with src

529
00:19:36,720 --> 00:19:38,000
set we'll note that

530
00:19:38,000 --> 00:19:40,400
it actually doesn't work the same and it

531
00:19:40,400 --> 00:19:42,400
will fail

532
00:19:42,400 --> 00:19:45,280
so if we do it this time the only

533
00:19:45,280 --> 00:19:46,799
difference here is we're using src

534
00:19:46,799 --> 00:19:48,799
sentence of src

535
00:19:48,799 --> 00:19:52,480
uh that's because src set works

536
00:19:52,480 --> 00:19:55,760
by having an image candidate string

537
00:19:55,760 --> 00:19:58,960
and then a pixel size so uh it

538
00:19:58,960 --> 00:20:01,200
has two values actually which are space

539
00:20:01,200 --> 00:20:02,640
separated

540
00:20:02,640 --> 00:20:04,559
um so what it's trying to do is is

541
00:20:04,559 --> 00:20:05,679
trying to parse

542
00:20:05,679 --> 00:20:08,799
the first cookie as the image url

543
00:20:08,799 --> 00:20:10,400
but then it's trying to parse the second

544
00:20:10,400 --> 00:20:12,320
value or the second cookie

545
00:20:12,320 --> 00:20:15,120
as a candidate size but obviously b

546
00:20:15,120 --> 00:20:16,799
equals two isn't a valid um

547
00:20:16,799 --> 00:20:18,960
attribute so it says it errors with the

548
00:20:18,960 --> 00:20:20,960
unknown descriptor

549
00:20:20,960 --> 00:20:22,480
so in order to get around this we have

550
00:20:22,480 --> 00:20:24,640
to first encode the value

551
00:20:24,640 --> 00:20:26,400
encode the entire cookie to get rid of

552
00:20:26,400 --> 00:20:28,960
the space here which is causing errors

553
00:20:28,960 --> 00:20:32,840
so to do that we can assign to low ssd

554
00:20:32,840 --> 00:20:35,600
first

555
00:20:35,600 --> 00:20:37,840
and this is pretty interesting after we

556
00:20:37,840 --> 00:20:39,200
assign to low src

557
00:20:39,200 --> 00:20:41,360
if we look at the value of low fsd in

558
00:20:41,360 --> 00:20:42,480
the console we'll find that it's

559
00:20:42,480 --> 00:20:44,000
actually mutated so

560
00:20:44,000 --> 00:20:47,360
it became uri encoded and it has the

561
00:20:47,360 --> 00:20:50,720
current location appended to it uh

562
00:20:50,720 --> 00:20:56,960
so if we were to assign to ssc set now

563
00:20:58,559 --> 00:21:00,320
and this time instead of concatenating

564
00:21:00,320 --> 00:21:02,240
with document.cookie

565
00:21:02,240 --> 00:21:05,280
we want to concatenate with low src and

566
00:21:05,280 --> 00:21:07,600
if we do that

567
00:21:07,600 --> 00:21:09,919
we'll see that we do get a result and

568
00:21:09,919 --> 00:21:13,280
looking at the logs here

569
00:21:14,880 --> 00:21:18,000
we see that the path uh has the two

570
00:21:18,000 --> 00:21:19,520
cookies we want to exfiltrate

571
00:21:19,520 --> 00:21:23,200
appended to the end so this demonstrates

572
00:21:23,200 --> 00:21:25,120
uh it's a slightly more complicated

573
00:21:25,120 --> 00:21:26,559
exploit but

574
00:21:26,559 --> 00:21:28,640
it's pretty cool how we can use low src

575
00:21:28,640 --> 00:21:30,080
to mutate the value

576
00:21:30,080 --> 00:21:33,200
of document.cookie uri encoding it which

577
00:21:33,200 --> 00:21:35,360
then makes it a valid

578
00:21:35,360 --> 00:21:37,360
attribute to concatenate with our

579
00:21:37,360 --> 00:21:40,159
endpoint for src set

580
00:21:40,159 --> 00:21:42,640
we previously mentioned that wafts tend

581
00:21:42,640 --> 00:21:45,679
to use regex to filter out payloads

582
00:21:45,679 --> 00:21:47,600
this means their filters will block

583
00:21:47,600 --> 00:21:49,840
payloads or become more suspicious if

584
00:21:49,840 --> 00:21:52,320
certain payloads are contained in order

585
00:21:52,320 --> 00:21:54,400
however payloads are traditionally

586
00:21:54,400 --> 00:21:56,240
constructed from left to right

587
00:21:56,240 --> 00:21:58,159
we can violate this assumption through

588
00:21:58,159 --> 00:21:59,760
right to left execution

589
00:21:59,760 --> 00:22:01,760
to bypass many waves and achieve

590
00:22:01,760 --> 00:22:03,679
javascript execution

591
00:22:03,679 --> 00:22:05,679
one way to do this is with nested

592
00:22:05,679 --> 00:22:07,360
elements such as the svg

593
00:22:07,360 --> 00:22:10,400
shown here for nested html elements the

594
00:22:10,400 --> 00:22:12,480
children's load handlers are executed

595
00:22:12,480 --> 00:22:13,039
first

596
00:22:13,039 --> 00:22:14,960
and the event bubbles up to parent

597
00:22:14,960 --> 00:22:16,240
elements thus

598
00:22:16,240 --> 00:22:18,960
in the example of nested svg elements

599
00:22:18,960 --> 00:22:21,120
the innermost load handler at the right

600
00:22:21,120 --> 00:22:22,559
is executed first

601
00:22:22,559 --> 00:22:24,880
and the outermost handler at the left is

602
00:22:24,880 --> 00:22:26,799
executed last

603
00:22:26,799 --> 00:22:28,640
another way to achieve right to left

604
00:22:28,640 --> 00:22:30,480
execution is with loops

605
00:22:30,480 --> 00:22:32,960
the while loop above uses the ternary

606
00:22:32,960 --> 00:22:34,799
operator to execute different code on

607
00:22:34,799 --> 00:22:36,640
subsequent loop iterations

608
00:22:36,640 --> 00:22:38,799
executing the right part first and then

609
00:22:38,799 --> 00:22:41,600
the left

610
00:22:41,600 --> 00:22:43,840
here again we have a generic exercise

611
00:22:43,840 --> 00:22:45,280
vulnerability where the

612
00:22:45,280 --> 00:22:48,080
hello parameter gets reflected into the

613
00:22:48,080 --> 00:22:49,360
body of the response

614
00:22:49,360 --> 00:22:53,200
so here if we

615
00:22:53,200 --> 00:22:56,559
insert a svg element ida

616
00:22:56,559 --> 00:22:59,120
we'll see that it does indeed uh get

617
00:22:59,120 --> 00:23:01,200
written into the body here

618
00:23:01,200 --> 00:23:03,360
and what happens if we have two svg

619
00:23:03,360 --> 00:23:05,840
elements

620
00:23:05,840 --> 00:23:09,280
we'll see that the the rightmost one

621
00:23:09,280 --> 00:23:12,799
over here actually gets nested inside

622
00:23:12,799 --> 00:23:16,159
the other our first svg element

623
00:23:16,159 --> 00:23:18,080
that's because we don't have a closing

624
00:23:18,080 --> 00:23:19,919
tag for this svg

625
00:23:19,919 --> 00:23:23,760
so it assumes that the

626
00:23:23,760 --> 00:23:27,120
next element is just a child

627
00:23:27,120 --> 00:23:29,120
it becomes more interesting when we try

628
00:23:29,120 --> 00:23:31,600
to assign unload handlers

629
00:23:31,600 --> 00:23:35,280
because in html the innermost or

630
00:23:35,280 --> 00:23:38,320
the child the child's

631
00:23:38,320 --> 00:23:40,080
unload handler actually gets executed

632
00:23:40,080 --> 00:23:42,240
first so if we

633
00:23:42,240 --> 00:23:45,120
have two different alert values here on

634
00:23:45,120 --> 00:23:48,479
the child we're going to alert b

635
00:23:48,799 --> 00:23:51,679
and on the parent we're going to alert a

636
00:23:51,679 --> 00:23:52,799
we'll see that the

637
00:23:52,799 --> 00:23:56,320
b actually gets alerted first and then a

638
00:23:56,320 --> 00:23:59,919
um in other words the code on the

639
00:23:59,919 --> 00:24:03,200
the right hand side gets executed before

640
00:24:03,200 --> 00:24:04,000
the code on the

641
00:24:04,000 --> 00:24:06,720
left hand side and we can do this to

642
00:24:06,720 --> 00:24:07,760
bypass

643
00:24:07,760 --> 00:24:10,000
some of the assumptions wafts make about

644
00:24:10,000 --> 00:24:11,279
code execution

645
00:24:11,279 --> 00:24:13,679
because usually they parse the code from

646
00:24:13,679 --> 00:24:15,600
left to right so for example

647
00:24:15,600 --> 00:24:19,200
if we assign some variable to document

648
00:24:19,200 --> 00:24:21,679
on the left hand side here then we can

649
00:24:21,679 --> 00:24:22,640
use this

650
00:24:22,640 --> 00:24:27,200
variable however we want

651
00:24:28,000 --> 00:24:29,679
and usually this would bypass the filter

652
00:24:29,679 --> 00:24:32,400
because it would for example

653
00:24:32,400 --> 00:24:35,279
check for strict it would check for some

654
00:24:35,279 --> 00:24:36,320
keywords after

655
00:24:36,320 --> 00:24:39,039
the document keyword appears uh but only

656
00:24:39,039 --> 00:24:40,640
to the right not to the left

657
00:24:40,640 --> 00:24:42,960
here are a few key takeaways from this

658
00:24:42,960 --> 00:24:44,159
presentation

659
00:24:44,159 --> 00:24:46,720
in general waves can never be perfect

660
00:24:46,720 --> 00:24:48,320
because of the large number of

661
00:24:48,320 --> 00:24:50,080
applications they protect and their

662
00:24:50,080 --> 00:24:52,400
ability to easily harm the user

663
00:24:52,400 --> 00:24:53,120
experience

664
00:24:53,120 --> 00:24:56,240
by blocking non-malicious payloads

665
00:24:56,240 --> 00:24:58,400
as a result the developers of waps will

666
00:24:58,400 --> 00:25:01,200
often allow limited javascript syntax

667
00:25:01,200 --> 00:25:03,200
allowing them to be bypassed easily

668
00:25:03,200 --> 00:25:05,919
especially by using obscure web platform

669
00:25:05,919 --> 00:25:06,880
functionality

670
00:25:06,880 --> 00:25:09,120
which bypasses waft developer

671
00:25:09,120 --> 00:25:11,440
expectations

672
00:25:11,440 --> 00:25:13,200
thanks for listening to our presentation

673
00:25:13,200 --> 00:25:14,720
if you have any questions we'll be in

674
00:25:14,720 --> 00:25:16,240
the hackerone discord

675
00:25:16,240 --> 00:25:18,159
alternatively you can contact us with

676
00:25:18,159 --> 00:25:19,520
the emails on screen

677
00:25:19,520 --> 00:25:21,200
our presentation slides are also

678
00:25:21,200 --> 00:25:22,720
available at g n

679
00:25:22,720 --> 00:25:29,840
k dot io activity con 20 20.

680
00:25:33,679 --> 00:25:35,760
you

