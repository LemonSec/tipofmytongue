1
00:00:06,160 --> 00:00:09,309
[Music]

2
00:00:10,800 --> 00:00:12,960
hi everyone thank you for coming to my

3
00:00:12,960 --> 00:00:15,839
talk today i'm eugene lim also known as

4
00:00:15,839 --> 00:00:18,320
space raccoon online and today's talk is

5
00:00:18,320 --> 00:00:20,800
titled all your databases are belong to

6
00:00:20,800 --> 00:00:23,359
us getting started in vanuatu research

7
00:00:23,359 --> 00:00:25,199
with code execution bugs in office

8
00:00:25,199 --> 00:00:27,119
applications

9
00:00:27,119 --> 00:00:28,960
in the past week you might have heard

10
00:00:28,960 --> 00:00:32,439
about cve202140444

11
00:00:32,558 --> 00:00:34,640
a microsoft office remote code execution

12
00:00:34,640 --> 00:00:37,440
vulnerability via the ms html browser

13
00:00:37,440 --> 00:00:39,120
rendering engine

14
00:00:39,120 --> 00:00:40,879
this is one example of how office

15
00:00:40,879 --> 00:00:42,719
applications can be a potent source of

16
00:00:42,719 --> 00:00:46,239
vulnerabilities due to your wide usage

17
00:00:46,239 --> 00:00:48,559
for this talk i will share a small slice

18
00:00:48,559 --> 00:00:50,079
of how my team got started in

19
00:00:50,079 --> 00:00:52,079
vulnerability research and hopefully

20
00:00:52,079 --> 00:00:54,079
help some newcomers in starting their

21
00:00:54,079 --> 00:00:57,640
own vr journey

22
00:01:00,320 --> 00:01:02,399
so first who am i

23
00:01:02,399 --> 00:01:04,559
i'm a cyber security specialist focusing

24
00:01:04,559 --> 00:01:06,000
on vulnerability research and

25
00:01:06,000 --> 00:01:07,840
application security at gov tech

26
00:01:07,840 --> 00:01:10,000
singapore's cyber security group which

27
00:01:10,000 --> 00:01:12,080
helps sit protect citizen data and

28
00:01:12,080 --> 00:01:14,880
secure government digital assets

29
00:01:14,880 --> 00:01:16,479
online i go by the handover space

30
00:01:16,479 --> 00:01:19,439
raccoon and i blog at spaceracoon.dev as

31
00:01:19,439 --> 00:01:22,640
well as tweet on space recruit and sec

32
00:01:22,640 --> 00:01:24,240
i've been on hacker 1 for about more

33
00:01:24,240 --> 00:01:25,600
than 2 years now

34
00:01:25,600 --> 00:01:27,360
and i've hacked on a variety of programs

35
00:01:27,360 --> 00:01:31,759
from mobile to web to even some native

36
00:01:31,840 --> 00:01:33,200
however i've never really touched

37
00:01:33,200 --> 00:01:34,640
boundary research and i've always been

38
00:01:34,640 --> 00:01:36,960
curious about this field so i decided to

39
00:01:36,960 --> 00:01:38,720
get started sometime in the middle of

40
00:01:38,720 --> 00:01:41,840
this year

41
00:01:42,960 --> 00:01:45,280
so why do vulnerability research

42
00:01:45,280 --> 00:01:47,439
in fact the term vulnerability research

43
00:01:47,439 --> 00:01:49,200
is quite wide and there are a lot of

44
00:01:49,200 --> 00:01:50,560
different interpretations of what it

45
00:01:50,560 --> 00:01:51,759
means

46
00:01:51,759 --> 00:01:53,840
our resident meme lord on twitter pom

47
00:01:53,840 --> 00:01:55,840
actually has a pretty good analogy where

48
00:01:55,840 --> 00:01:57,520
bug hunters are cooks and security

49
00:01:57,520 --> 00:01:59,200
researchers are chefs

50
00:01:59,200 --> 00:02:00,640
so you know a cook is someone who has a

51
00:02:00,640 --> 00:02:02,960
good mastery of basic techniques follows

52
00:02:02,960 --> 00:02:05,280
the recipes but a chef takes cooking to

53
00:02:05,280 --> 00:02:07,439
a new level by finding new ideas

54
00:02:07,439 --> 00:02:09,598
creating new combinations and in much

55
00:02:09,598 --> 00:02:10,720
the same way

56
00:02:10,720 --> 00:02:12,400
value researchers actually focus on

57
00:02:12,400 --> 00:02:15,120
products and find zero days or new

58
00:02:15,120 --> 00:02:18,319
vulnerability techniques among them

59
00:02:18,319 --> 00:02:20,000
so this actually takes you to the next

60
00:02:20,000 --> 00:02:22,160
level and adds a big punch to your

61
00:02:22,160 --> 00:02:24,239
current arsenal of offensive security

62
00:02:24,239 --> 00:02:26,640
techniques

63
00:02:28,000 --> 00:02:30,319
so vulnerability research or vr for

64
00:02:30,319 --> 00:02:32,400
short is the process of discovering and

65
00:02:32,400 --> 00:02:33,920
exploiting new vulnerabilities in

66
00:02:33,920 --> 00:02:34,879
products

67
00:02:34,879 --> 00:02:36,640
and it covers many different domains

68
00:02:36,640 --> 00:02:39,519
such as reverse engineering code review

69
00:02:39,519 --> 00:02:42,239
dynamic and static analysis and fuzzing

70
00:02:42,239 --> 00:02:44,000
and it combines all of these so that

71
00:02:44,000 --> 00:02:46,080
researchers are able to discover novel

72
00:02:46,080 --> 00:02:48,800
bugs in both white box or black box

73
00:02:48,800 --> 00:02:52,080
products that they are looking at

74
00:02:53,840 --> 00:02:55,440
so while there's some overlap with

75
00:02:55,440 --> 00:02:58,319
typical pen testing vr actually requires

76
00:02:58,319 --> 00:03:00,560
new skills some that you saw earlier

77
00:03:00,560 --> 00:03:02,640
such as reverse engineering but also

78
00:03:02,640 --> 00:03:04,239
some that i haven't mentioned before

79
00:03:04,239 --> 00:03:06,239
such as memory corruption exploit

80
00:03:06,239 --> 00:03:08,400
development and debugging

81
00:03:08,400 --> 00:03:10,959
and coming from a web security or

82
00:03:10,959 --> 00:03:12,720
application security background like me

83
00:03:12,720 --> 00:03:14,640
this was actually pretty daunting but it

84
00:03:14,640 --> 00:03:17,519
was also a new opportunity to learn

85
00:03:17,519 --> 00:03:19,440
additional skills in cyber security i

86
00:03:19,440 --> 00:03:21,440
might never know where i might use them

87
00:03:21,440 --> 00:03:24,239
and also is actually crucial to doing

88
00:03:24,239 --> 00:03:26,319
well in vr you can't just use the same

89
00:03:26,319 --> 00:03:28,159
old techniques that you have from appsec

90
00:03:28,159 --> 00:03:30,159
or website you do have to pick up some

91
00:03:30,159 --> 00:03:32,480
of these very critical skills in order

92
00:03:32,480 --> 00:03:35,599
to do well in vr

93
00:03:36,319 --> 00:03:37,920
as i mentioned it can actually be pretty

94
00:03:37,920 --> 00:03:40,319
scary to get started in vr because at

95
00:03:40,319 --> 00:03:42,799
least from an outsider's perspective vr

96
00:03:42,799 --> 00:03:45,120
looks extremely impressive but also very

97
00:03:45,120 --> 00:03:47,200
complex especially with the kind of high

98
00:03:47,200 --> 00:03:50,000
profile targets that vr researchers will

99
00:03:50,000 --> 00:03:52,560
kind of target such as microsoft office

100
00:03:52,560 --> 00:03:55,760
or adobe reader so a lot of these

101
00:03:55,760 --> 00:03:57,680
products are used by many people all

102
00:03:57,680 --> 00:03:59,519
over the world and actually require a

103
00:03:59,519 --> 00:04:00,879
bit more

104
00:04:00,879 --> 00:04:01,920
in-depth

105
00:04:01,920 --> 00:04:04,640
research in order to exploit

106
00:04:04,640 --> 00:04:06,319
and one of the pieces of advice i got

107
00:04:06,319 --> 00:04:08,720
early on was to get started by focusing

108
00:04:08,720 --> 00:04:10,879
on a specific file format

109
00:04:10,879 --> 00:04:12,879
for example they're pretty good examples

110
00:04:12,879 --> 00:04:14,959
such as the ace file format that allowed

111
00:04:14,959 --> 00:04:16,880
checkpoint research to find a code

112
00:04:16,880 --> 00:04:19,358
execution part in winrar or maybe even

113
00:04:19,358 --> 00:04:20,880
the mdb format which is a kind of

114
00:04:20,880 --> 00:04:23,199
database format through the microsoft

115
00:04:23,199 --> 00:04:24,479
jet engine which is a very well

116
00:04:24,479 --> 00:04:25,600
researched

117
00:04:25,600 --> 00:04:27,440
piece of software

118
00:04:27,440 --> 00:04:28,800
and of course you know you might have

119
00:04:28,800 --> 00:04:31,360
more client-side facing stuff like

120
00:04:31,360 --> 00:04:33,360
font file formats that was done by

121
00:04:33,360 --> 00:04:34,479
starlabs

122
00:04:34,479 --> 00:04:36,240
and the reason for this

123
00:04:36,240 --> 00:04:38,000
is that file formats is one of the most

124
00:04:38,000 --> 00:04:39,120
common

125
00:04:39,120 --> 00:04:40,800
entry points into applications most

126
00:04:40,800 --> 00:04:42,400
applications have

127
00:04:42,400 --> 00:04:44,400
file processing or file passing

128
00:04:44,400 --> 00:04:46,400
functionality and this allows you to

129
00:04:46,400 --> 00:04:48,960
cast your network rather than focusing

130
00:04:48,960 --> 00:04:50,560
on a specific application and what the

131
00:04:50,560 --> 00:04:53,199
application might do you can really just

132
00:04:53,199 --> 00:04:54,960
test this out across many different

133
00:04:54,960 --> 00:04:56,560
applications

134
00:04:56,560 --> 00:04:59,040
and not get stuck on one because if you

135
00:04:59,040 --> 00:05:00,160
get stuck on an application that's

136
00:05:00,160 --> 00:05:02,080
really well secured that might be very

137
00:05:02,080 --> 00:05:03,840
discouraging for you as

138
00:05:03,840 --> 00:05:07,199
a beginner foundry researcher

139
00:05:07,199 --> 00:05:09,840
so this also has an advantage because it

140
00:05:09,840 --> 00:05:11,919
helps you get started with fuzzing as

141
00:05:11,919 --> 00:05:14,000
well you know fuzzing uh tends to be

142
00:05:14,000 --> 00:05:16,960
based on file formats and this is i

143
00:05:16,960 --> 00:05:18,960
think a better way or faster way of

144
00:05:18,960 --> 00:05:21,120
doing things rather than maybe doing

145
00:05:21,120 --> 00:05:23,280
pure reverse engineering or you know if

146
00:05:23,280 --> 00:05:25,199
you're not the kind of person who likes

147
00:05:25,199 --> 00:05:27,600
code review then you don't really have

148
00:05:27,600 --> 00:05:29,919
to get that deep into it you can really

149
00:05:29,919 --> 00:05:31,919
start with fuzzing or gain a broad

150
00:05:31,919 --> 00:05:33,520
spectrum of skills to get started as

151
00:05:33,520 --> 00:05:35,758
well

152
00:05:36,400 --> 00:05:38,960
based on this strategy i found the dbase

153
00:05:38,960 --> 00:05:41,600
database file format a legacy format

154
00:05:41,600 --> 00:05:45,039
still in use by many applications today

155
00:05:45,039 --> 00:05:47,360
dbase has a pretty interesting history

156
00:05:47,360 --> 00:05:50,000
it first started out as a kind of ide

157
00:05:50,000 --> 00:05:51,440
for developers to build their own

158
00:05:51,440 --> 00:05:54,160
programs and thus use a dbase database

159
00:05:54,160 --> 00:05:56,479
file format for data storage

160
00:05:56,479 --> 00:05:58,880
however the dbf file format has gone on

161
00:05:58,880 --> 00:06:00,560
to many different users from

162
00:06:00,560 --> 00:06:02,639
spreadsheets in microsoft office excel

163
00:06:02,639 --> 00:06:05,280
and apache openoffice to the shape file

164
00:06:05,280 --> 00:06:06,880
format which is actually a collection of

165
00:06:06,880 --> 00:06:08,800
three different file formats including

166
00:06:08,800 --> 00:06:11,840
dbf that is used in geospatial data

167
00:06:11,840 --> 00:06:14,400
applications such as arcgis

168
00:06:14,400 --> 00:06:15,919
it's also of course used in different

169
00:06:15,919 --> 00:06:18,479
databases as a form of a on file

170
00:06:18,479 --> 00:06:20,880
database and is accessible by different

171
00:06:20,880 --> 00:06:23,759
database engines such as mariadb and

172
00:06:23,759 --> 00:06:25,919
microsoft jet engine

173
00:06:25,919 --> 00:06:28,080
so dbf is actually used by a variety of

174
00:06:28,080 --> 00:06:30,319
applications and does have this legacy

175
00:06:30,319 --> 00:06:33,120
file format history which makes it a bit

176
00:06:33,120 --> 00:06:35,280
more interesting especially for

177
00:06:35,280 --> 00:06:36,639
vulnerability researchers who might be

178
00:06:36,639 --> 00:06:39,120
looking for lack of security or

179
00:06:39,120 --> 00:06:40,960
considerations of memory corruption

180
00:06:40,960 --> 00:06:44,719
issues in these file formats

181
00:06:45,520 --> 00:06:48,800
dbf came out in the 1980s in 1983 to be

182
00:06:48,800 --> 00:06:51,039
exact and it's almost 30 years old and

183
00:06:51,039 --> 00:06:52,319
it first started out as a kind of a

184
00:06:52,319 --> 00:06:54,880
proprietary format without rfc or

185
00:06:54,880 --> 00:06:56,880
request for comment document

186
00:06:56,880 --> 00:06:58,400
which kind of lays out a lot of these

187
00:06:58,400 --> 00:07:00,240
specifications from different file

188
00:07:00,240 --> 00:07:01,440
formats

189
00:07:01,440 --> 00:07:03,440
however even without the rfc it is still

190
00:07:03,440 --> 00:07:05,919
well documented especially by

191
00:07:05,919 --> 00:07:08,000
dbase itself which is a successor to the

192
00:07:08,000 --> 00:07:10,160
dbase company as well as other

193
00:07:10,160 --> 00:07:12,240
independent websites such as independent

194
00:07:12,240 --> 00:07:14,160
software.com as well as the library of

195
00:07:14,160 --> 00:07:15,919
congress which does very well to

196
00:07:15,919 --> 00:07:17,840
document the various versions and

197
00:07:17,840 --> 00:07:20,400
extensions to the dbf file format

198
00:07:20,400 --> 00:07:22,160
so what we see here is kind of the

199
00:07:22,160 --> 00:07:24,560
header of the dbf file format and it

200
00:07:24,560 --> 00:07:26,400
starts of course with the version byte

201
00:07:26,400 --> 00:07:28,880
so the different versions of dbf

202
00:07:28,880 --> 00:07:31,199
actually exists with different support

203
00:07:31,199 --> 00:07:33,039
for data types and then you have the

204
00:07:33,039 --> 00:07:35,280
date of the last update for the database

205
00:07:35,280 --> 00:07:36,880
the number of records in a table the

206
00:07:36,880 --> 00:07:38,560
number of bytes in the header and the

207
00:07:38,560 --> 00:07:40,639
number of bytes in a record itself

208
00:07:40,639 --> 00:07:41,840
and then there are a few more reserved

209
00:07:41,840 --> 00:07:43,759
bytes that have various users depending

210
00:07:43,759 --> 00:07:44,879
on the version

211
00:07:44,879 --> 00:07:46,800
and then there are few descriptors and

212
00:07:46,800 --> 00:07:49,360
this is kind of the most important part

213
00:07:49,360 --> 00:07:51,599
of the format because it describes the

214
00:07:51,599 --> 00:07:53,440
different fields in each record or you

215
00:07:53,440 --> 00:07:54,960
can think of them as kind of the columns

216
00:07:54,960 --> 00:07:56,400
in a spreadsheet

217
00:07:56,400 --> 00:07:58,720
it defines them in the

218
00:07:58,720 --> 00:08:00,560
data type such as it could be a

219
00:08:00,560 --> 00:08:03,360
character uh it could be a long it could

220
00:08:03,360 --> 00:08:05,919
be an integer it could be a date

221
00:08:05,919 --> 00:08:07,520
different file formats

222
00:08:07,520 --> 00:08:09,919
data types and also the kind of the

223
00:08:09,919 --> 00:08:12,479
field length of each field so how many

224
00:08:12,479 --> 00:08:15,360
bytes you can expect in each field so

225
00:08:15,360 --> 00:08:17,680
this has various implications on how the

226
00:08:17,680 --> 00:08:19,840
data is structured and how programs are

227
00:08:19,840 --> 00:08:22,720
going to pass a dbf file which gives us

228
00:08:22,720 --> 00:08:25,360
kind of a ripe environment for frozen

229
00:08:25,360 --> 00:08:28,240
for vulnerabilities

230
00:08:29,360 --> 00:08:31,280
based on these various documentation i

231
00:08:31,280 --> 00:08:32,958
could construct a fuzzing template for

232
00:08:32,958 --> 00:08:35,120
gitlab's peach fuzzer and i've written

233
00:08:35,120 --> 00:08:36,399
about this before on my blog you can

234
00:08:36,399 --> 00:08:38,799
refer to the link for more information

235
00:08:38,799 --> 00:08:40,719
but peach fuzzer is basically a

236
00:08:40,719 --> 00:08:43,279
format-based fuzzer that takes in these

237
00:08:43,279 --> 00:08:45,040
templates that define

238
00:08:45,040 --> 00:08:46,959
the kind of data structure that they're

239
00:08:46,959 --> 00:08:49,120
going to be fuzzing and it does various

240
00:08:49,120 --> 00:08:51,200
mutations based on the data types and

241
00:08:51,200 --> 00:08:52,959
the structure of the data that you feed

242
00:08:52,959 --> 00:08:53,600
it

243
00:08:53,600 --> 00:08:56,320
so i built this fuzzing template wrote

244
00:08:56,320 --> 00:08:58,959
it for the dbf file format and then used

245
00:08:58,959 --> 00:09:02,560
it to first various dbf file small file

246
00:09:02,560 --> 00:09:03,680
applications

247
00:09:03,680 --> 00:09:07,120
such as you know a dbf viewer a dbf view

248
00:09:07,120 --> 00:09:08,399
there are many of these tiny

249
00:09:08,399 --> 00:09:10,160
applications just scattered across the

250
00:09:10,160 --> 00:09:12,399
web written by different developers

251
00:09:12,399 --> 00:09:14,000
whose only purpose is really just to

252
00:09:14,000 --> 00:09:16,240
open a dbf file so i don't start at the

253
00:09:16,240 --> 00:09:18,080
most complex applications i start at

254
00:09:18,080 --> 00:09:20,160
really simple small applications that

255
00:09:20,160 --> 00:09:22,160
are easy to fuss especially by peach

256
00:09:22,160 --> 00:09:25,279
fuzzer which is what someone considers a

257
00:09:25,279 --> 00:09:27,279
dumb fuzzer it opens the entire

258
00:09:27,279 --> 00:09:29,200
executable it doesn't really use a

259
00:09:29,200 --> 00:09:30,880
harness it doesn't really do coverage

260
00:09:30,880 --> 00:09:32,959
guided fuzzing it just uses the

261
00:09:32,959 --> 00:09:35,040
application opens the file based on what

262
00:09:35,040 --> 00:09:37,360
your mutations you've created and hope

263
00:09:37,360 --> 00:09:38,640
it crashes

264
00:09:38,640 --> 00:09:40,240
and as you can see in the screenshot on

265
00:09:40,240 --> 00:09:41,839
the right we were actually pretty

266
00:09:41,839 --> 00:09:43,920
successful at getting a lot of pressures

267
00:09:43,920 --> 00:09:45,680
because many of these applications were

268
00:09:45,680 --> 00:09:47,519
written years ago or they might not be

269
00:09:47,519 --> 00:09:49,760
well maintained and does they have a lot

270
00:09:49,760 --> 00:09:51,680
of these vulnerabilities so this gives

271
00:09:51,680 --> 00:09:53,440
us kind of an insight

272
00:09:53,440 --> 00:09:55,040
into some of the common weaknesses that

273
00:09:55,040 --> 00:09:57,360
programs that open dbf files might have

274
00:09:57,360 --> 00:09:59,120
which will be a clue for us later on

275
00:09:59,120 --> 00:10:01,040
when we go deeper with more complex

276
00:10:01,040 --> 00:10:04,040
applications

277
00:10:04,640 --> 00:10:06,240
now when you get all these crashes with

278
00:10:06,240 --> 00:10:07,519
peach fuzzer

279
00:10:07,519 --> 00:10:09,040
it's not actually a

280
00:10:09,040 --> 00:10:11,600
100 positive sign that it is an

281
00:10:11,600 --> 00:10:13,200
expectable crash so it's really

282
00:10:13,200 --> 00:10:14,720
important to have some kind of triage

283
00:10:14,720 --> 00:10:16,480
mechanism on the back end to make it

284
00:10:16,480 --> 00:10:17,920
easier for you to find out whether

285
00:10:17,920 --> 00:10:19,600
something is exploitable or not and one

286
00:10:19,600 --> 00:10:21,680
of the useful features of peach fuzzer

287
00:10:21,680 --> 00:10:24,000
is that it automatically runs the wind

288
00:10:24,000 --> 00:10:26,480
dbg bank exploitable extension in order

289
00:10:26,480 --> 00:10:28,480
to triage these crashes

290
00:10:28,480 --> 00:10:30,640
so what we see here on the right

291
00:10:30,640 --> 00:10:31,440
is

292
00:10:31,440 --> 00:10:33,040
what is found is that at the time of the

293
00:10:33,040 --> 00:10:35,440
crash based on the stack uh there was an

294
00:10:35,440 --> 00:10:37,519
exception handler chain corruption and

295
00:10:37,519 --> 00:10:39,360
this is uh if you are kind of familiar

296
00:10:39,360 --> 00:10:40,800
with the basics of memory corruption

297
00:10:40,800 --> 00:10:42,480
this is one of the most

298
00:10:42,480 --> 00:10:45,519
common uh commonly exploitable

299
00:10:45,519 --> 00:10:46,880
vulnerabilities it's really easy to

300
00:10:46,880 --> 00:10:48,959
exploit it and it's also one of the most

301
00:10:48,959 --> 00:10:50,720
obvious signs that the stack has truly

302
00:10:50,720 --> 00:10:52,959
been corrupted so it's rightly triaged

303
00:10:52,959 --> 00:10:55,120
as exploitable which allows me to

304
00:10:55,120 --> 00:10:56,720
quickly just zoom into these kinds of

305
00:10:56,720 --> 00:10:59,040
crashes and analyze them instead of

306
00:10:59,040 --> 00:11:00,880
wasting my time with less exploitable

307
00:11:00,880 --> 00:11:03,600
vulnerabilities

308
00:11:03,920 --> 00:11:05,440
once i've selected the crash that i'm

309
00:11:05,440 --> 00:11:07,440
interested in i can actually refer to

310
00:11:07,440 --> 00:11:09,519
more peach fuzz's logs which tells you

311
00:11:09,519 --> 00:11:11,120
what kind of mutations it carried out on

312
00:11:11,120 --> 00:11:12,640
the original file to create that

313
00:11:12,640 --> 00:11:15,440
crashing file and based on that i open

314
00:11:15,440 --> 00:11:17,440
it up in a software called zero one zero

315
00:11:17,440 --> 00:11:20,000
editor it's a hex editor with a special

316
00:11:20,000 --> 00:11:21,279
function that allows you to use

317
00:11:21,279 --> 00:11:23,760
templates that kind of tells you exactly

318
00:11:23,760 --> 00:11:25,920
which bytes in the file correspond to

319
00:11:25,920 --> 00:11:28,720
which fields and file format structure

320
00:11:28,720 --> 00:11:30,720
so that's kind of the bottom half of the

321
00:11:30,720 --> 00:11:31,839
screen you see here it's telling you

322
00:11:31,839 --> 00:11:34,320
which fields are being

323
00:11:34,320 --> 00:11:36,480
highlighted in the top half which is the

324
00:11:36,480 --> 00:11:38,480
actual file itself

325
00:11:38,480 --> 00:11:40,880
and based on this i slowly start

326
00:11:40,880 --> 00:11:43,600
removing big chunks of bytes from the

327
00:11:43,600 --> 00:11:44,959
original file

328
00:11:44,959 --> 00:11:46,560
while ensuring that it continues to

329
00:11:46,560 --> 00:11:48,320
cause the same crash

330
00:11:48,320 --> 00:11:50,079
this allows me to quickly kind of

331
00:11:50,079 --> 00:11:51,760
whittle down the bytes that are not

332
00:11:51,760 --> 00:11:53,920
relevant to the crash at all slowly move

333
00:11:53,920 --> 00:11:55,760
it down into something called a minimal

334
00:11:55,760 --> 00:11:58,320
viable crash and that's the file on the

335
00:11:58,320 --> 00:11:59,920
right that you see here

336
00:11:59,920 --> 00:12:01,600
and you know i've cut it down you know

337
00:12:01,600 --> 00:12:03,760
from more than maybe like 18 000 bytes

338
00:12:03,760 --> 00:12:05,279
to just you know

339
00:12:05,279 --> 00:12:07,040
less than 200

340
00:12:07,040 --> 00:12:08,639
and the important thing here is that

341
00:12:08,639 --> 00:12:10,320
this allows me to perform really

342
00:12:10,320 --> 00:12:13,040
pinpoint the root cause analysis

343
00:12:13,040 --> 00:12:15,760
the exact bite that caused the crash

344
00:12:15,760 --> 00:12:17,200
and we're going to talk about this in

345
00:12:17,200 --> 00:12:19,760
the next slide

346
00:12:20,480 --> 00:12:22,320
now that i've created the minimal viable

347
00:12:22,320 --> 00:12:25,200
crash i could inspect the byte that was

348
00:12:25,200 --> 00:12:27,440
changed by peach fuzzer that caused the

349
00:12:27,440 --> 00:12:29,440
crash and based on the template that i

350
00:12:29,440 --> 00:12:31,600
used in zero one zero editor i found

351
00:12:31,600 --> 00:12:34,240
that this was actually the field type

352
00:12:34,240 --> 00:12:36,959
byte that determines the data type of a

353
00:12:36,959 --> 00:12:38,959
certain field in each row

354
00:12:38,959 --> 00:12:41,279
and this time the field type had been

355
00:12:41,279 --> 00:12:43,279
changed from an integer which is marked

356
00:12:43,279 --> 00:12:45,040
by the i character

357
00:12:45,040 --> 00:12:47,120
into a short integer type column which

358
00:12:47,120 --> 00:12:49,279
is marked by the two character

359
00:12:49,279 --> 00:12:50,959
ascii character

360
00:12:50,959 --> 00:12:53,040
and what this means from my reasoning

361
00:12:53,040 --> 00:12:55,440
was that this told the software to

362
00:12:55,440 --> 00:12:58,000
allocate a two-byte buffer to support

363
00:12:58,000 --> 00:13:00,000
the short integer type

364
00:13:00,000 --> 00:13:01,040
and

365
00:13:01,040 --> 00:13:03,200
at the same time it was also copying for

366
00:13:03,200 --> 00:13:06,160
each row the number of bytes into that

367
00:13:06,160 --> 00:13:09,120
two byte buffer but instead of using uh

368
00:13:09,120 --> 00:13:11,200
the file type which data type which was

369
00:13:11,200 --> 00:13:13,279
two bytes it actually trusted another

370
00:13:13,279 --> 00:13:15,760
field in the dbf file format which is

371
00:13:15,760 --> 00:13:18,320
called field length and this also tells

372
00:13:18,320 --> 00:13:20,560
the program how long they should expect

373
00:13:20,560 --> 00:13:22,399
that data type to be

374
00:13:22,399 --> 00:13:25,440
but even though the data type is two

375
00:13:25,440 --> 00:13:26,480
bytes

376
00:13:26,480 --> 00:13:28,399
the field length itself was much larger

377
00:13:28,399 --> 00:13:30,720
than two bytes and this caused a mem

378
00:13:30,720 --> 00:13:31,920
copy

379
00:13:31,920 --> 00:13:34,639
of a buffer for size field length into

380
00:13:34,639 --> 00:13:36,720
the two byte buffer so now if you think

381
00:13:36,720 --> 00:13:38,880
about it if fuel length is you know

382
00:13:38,880 --> 00:13:41,360
maybe like a hundred instead of two

383
00:13:41,360 --> 00:13:43,360
the program is going to try to copy

384
00:13:43,360 --> 00:13:46,480
memory uh of hundred bytes into a two

385
00:13:46,480 --> 00:13:48,240
byte buffer and this is not going to be

386
00:13:48,240 --> 00:13:49,680
enough it's going to cause a buffer

387
00:13:49,680 --> 00:13:53,599
overflow which leads to our crash

388
00:13:54,720 --> 00:13:56,959
using this buffer overflow i could then

389
00:13:56,959 --> 00:13:58,480
overwrite the structure exception

390
00:13:58,480 --> 00:14:01,440
handler and thus jump to my own code and

391
00:14:01,440 --> 00:14:03,760
execute my own arbitrary commands so

392
00:14:03,760 --> 00:14:05,120
what you see here is an example of this

393
00:14:05,120 --> 00:14:07,279
type of exploit on scalabium dbase

394
00:14:07,279 --> 00:14:11,079
viewer version 2.6

395
00:14:17,199 --> 00:14:19,440
so first using this application i'm

396
00:14:19,440 --> 00:14:22,160
going to actually open my payload dbf

397
00:14:22,160 --> 00:14:24,160
file which has been

398
00:14:24,160 --> 00:14:26,399
adjusted to run the memory corruption

399
00:14:26,399 --> 00:14:28,720
and after corrupting the memory is going

400
00:14:28,720 --> 00:14:30,160
to jump to its own shell code which

401
00:14:30,160 --> 00:14:32,880
actually just pops calculator

402
00:14:32,880 --> 00:14:34,639
so this is a very simple straightforward

403
00:14:34,639 --> 00:14:36,639
exploit and the reason for this is that

404
00:14:36,639 --> 00:14:37,839
a lot of these

405
00:14:37,839 --> 00:14:40,880
smaller dbf file for map passes are

406
00:14:40,880 --> 00:14:42,320
actually not compiled with any kind of

407
00:14:42,320 --> 00:14:45,120
memory protections and thus you know is

408
00:14:45,120 --> 00:14:48,480
pretty straightforward exploit

409
00:14:49,360 --> 00:14:50,720
now that i was able to exploit pretty

410
00:14:50,720 --> 00:14:53,120
basic passes it was time to try harder

411
00:14:53,120 --> 00:14:55,600
and aim for a bigger game

412
00:14:55,600 --> 00:14:57,279
the fourth floor i used here is to use

413
00:14:57,279 --> 00:14:59,120
dumb fuzzing to find crashes in these

414
00:14:59,120 --> 00:15:01,440
smaller easy to exploit

415
00:15:01,440 --> 00:15:04,160
applications do some root cause analysis

416
00:15:04,160 --> 00:15:05,680
to figure out what kind of coding

417
00:15:05,680 --> 00:15:07,440
mistakes the programmers did

418
00:15:07,440 --> 00:15:09,600
and and inherent weaknesses in the file

419
00:15:09,600 --> 00:15:11,760
format itself and then look for similar

420
00:15:11,760 --> 00:15:13,839
mistakes to a code review

421
00:15:13,839 --> 00:15:16,000
so right here what we have seen is the

422
00:15:16,000 --> 00:15:18,480
mistake where the coder actually trusted

423
00:15:18,480 --> 00:15:21,199
the field type

424
00:15:21,199 --> 00:15:24,240
byte inside the dbf file and then use

425
00:15:24,240 --> 00:15:26,399
that to allocate a buffer and copy into

426
00:15:26,399 --> 00:15:29,120
the buffer a buffer of size field length

427
00:15:29,120 --> 00:15:31,120
which is also within the dbf file and

428
00:15:31,120 --> 00:15:32,800
this is the mistake i'm going to look at

429
00:15:32,800 --> 00:15:36,560
in different source code online

430
00:15:37,360 --> 00:15:38,959
trawling through the various open source

431
00:15:38,959 --> 00:15:41,440
office applications i came across apache

432
00:15:41,440 --> 00:15:42,560
open office

433
00:15:42,560 --> 00:15:44,160
which is older than two to twenty years

434
00:15:44,160 --> 00:15:45,759
and has been downloaded more than 300

435
00:15:45,759 --> 00:15:47,600
million times

436
00:15:47,600 --> 00:15:50,720
now in the dtable.cxx source code file i

437
00:15:50,720 --> 00:15:52,880
spotted something familiar

438
00:15:52,880 --> 00:15:55,839
here we see the data type integer

439
00:15:55,839 --> 00:15:56,800
switch

440
00:15:56,800 --> 00:15:59,759
where it instantiates a buffer of size

441
00:15:59,759 --> 00:16:03,920
in 32 but it copies a value of size n

442
00:16:03,920 --> 00:16:04,880
length

443
00:16:04,880 --> 00:16:07,199
so this seemed like a variation of what

444
00:16:07,199 --> 00:16:09,839
i've done in the previous vulnerability

445
00:16:09,839 --> 00:16:12,079
where it truds the user provided field

446
00:16:12,079 --> 00:16:15,680
length but also copies it into a buffer

447
00:16:15,680 --> 00:16:18,480
of size field type so even though it's

448
00:16:18,480 --> 00:16:20,720
not the exact same bug the coding error

449
00:16:20,720 --> 00:16:22,800
has the same faulty logic that might

450
00:16:22,800 --> 00:16:26,000
lead to a buffer overflow

451
00:16:27,360 --> 00:16:28,800
using my proof of concept from the

452
00:16:28,800 --> 00:16:31,199
previous boundary i quickly generated a

453
00:16:31,199 --> 00:16:33,680
new file and opened it in apache open

454
00:16:33,680 --> 00:16:35,759
office spreadsheet application and

455
00:16:35,759 --> 00:16:37,600
indeed i got a crash

456
00:16:37,600 --> 00:16:40,079
however this time even though i did

457
00:16:40,079 --> 00:16:42,399
override the seh it was not able to

458
00:16:42,399 --> 00:16:44,480
execute any code due to a protection

459
00:16:44,480 --> 00:16:46,399
called safe exception handlers which

460
00:16:46,399 --> 00:16:48,079
prevents this kind of thing

461
00:16:48,079 --> 00:16:49,680
there are also other various memory

462
00:16:49,680 --> 00:16:51,199
character actions that will compile with

463
00:16:51,199 --> 00:16:53,279
the binary such as address-based layout

464
00:16:53,279 --> 00:16:55,360
randomization and data execution

465
00:16:55,360 --> 00:16:56,480
prevention

466
00:16:56,480 --> 00:16:58,320
so these protections would have to be

467
00:16:58,320 --> 00:17:01,600
bypassed by my exploit

468
00:17:02,800 --> 00:17:04,559
additionally i had to pass an inline

469
00:17:04,559 --> 00:17:06,400
validation check in order to reach the

470
00:17:06,400 --> 00:17:09,039
vulnerable code so what you see here on

471
00:17:09,039 --> 00:17:11,280
the left is some of the assembly code

472
00:17:11,280 --> 00:17:14,880
and the compare edi eax instruction is

473
00:17:14,880 --> 00:17:16,319
the comparison check

474
00:17:16,319 --> 00:17:18,000
if it fails this check it would actually

475
00:17:18,000 --> 00:17:20,000
trigger the exception and the exploit

476
00:17:20,000 --> 00:17:22,720
will fail because of the safe sdh

477
00:17:22,720 --> 00:17:24,160
protections that i mentioned earlier

478
00:17:24,160 --> 00:17:26,480
even though i've overwritten it

479
00:17:26,480 --> 00:17:28,720
so i resolve this by ensuring that the

480
00:17:28,720 --> 00:17:30,640
corresponding bytes in my payload using

481
00:17:30,640 --> 00:17:33,200
dynamic analysis and wind dpg was set to

482
00:17:33,200 --> 00:17:35,840
the expected value which is one

483
00:17:35,840 --> 00:17:38,000
and i got this offset you know just by

484
00:17:38,000 --> 00:17:40,400
checking and comparing the various bytes

485
00:17:40,400 --> 00:17:42,240
with the memory at that time in this

486
00:17:42,240 --> 00:17:46,520
case edi and eax

487
00:17:47,840 --> 00:17:49,840
after passing the inline check it was

488
00:17:49,840 --> 00:17:52,240
time to try to bypass the dep and asr

489
00:17:52,240 --> 00:17:53,679
memory protections

490
00:17:53,679 --> 00:17:55,600
and one of the easiest way to do this is

491
00:17:55,600 --> 00:17:57,360
actually just to latch on to any of the

492
00:17:57,360 --> 00:18:00,000
imported modules by the binary and used

493
00:18:00,000 --> 00:18:01,440
one of them that is not compiled with

494
00:18:01,440 --> 00:18:03,120
any of these protections

495
00:18:03,120 --> 00:18:05,360
in this case i enumerated all of them

496
00:18:05,360 --> 00:18:08,160
using the gnarly windwpg extension and

497
00:18:08,160 --> 00:18:10,720
this pointed me to libxml2 which was

498
00:18:10,720 --> 00:18:13,840
indeed not compiled with aslr or dep

499
00:18:13,840 --> 00:18:15,039
protections

500
00:18:15,039 --> 00:18:16,720
so i could use this library as a

501
00:18:16,720 --> 00:18:18,480
starting point for a return oriented

502
00:18:18,480 --> 00:18:20,720
programming chain or rob chain in order

503
00:18:20,720 --> 00:18:24,480
to bypass dep eventually

504
00:18:25,760 --> 00:18:27,200
so if you're not familiar with rob

505
00:18:27,200 --> 00:18:29,039
chains i'm not going to go into too much

506
00:18:29,039 --> 00:18:31,280
detail here but essentially is a

507
00:18:31,280 --> 00:18:33,360
technique that uses gadgets from a

508
00:18:33,360 --> 00:18:34,960
different library or another part of the

509
00:18:34,960 --> 00:18:38,080
code and it calls those instructions and

510
00:18:38,080 --> 00:18:39,760
keeps returning to itself and calling

511
00:18:39,760 --> 00:18:42,080
more of those gadgets again again until

512
00:18:42,080 --> 00:18:44,320
you finally do what you need to do in

513
00:18:44,320 --> 00:18:46,240
memory in this case

514
00:18:46,240 --> 00:18:48,240
uh you might want to pop a calculator

515
00:18:48,240 --> 00:18:49,840
you might want to load another library

516
00:18:49,840 --> 00:18:51,520
you might call a function from those

517
00:18:51,520 --> 00:18:53,520
libraries and so on depending on what

518
00:18:53,520 --> 00:18:55,200
you want to do

519
00:18:55,200 --> 00:18:57,679
so what i had based on my override was

520
00:18:57,679 --> 00:18:59,600
an overwritten return pointer which is a

521
00:18:59,600 --> 00:19:02,080
starting point for any blockchain

522
00:19:02,080 --> 00:19:04,559
but i soon realized i had a big problem

523
00:19:04,559 --> 00:19:08,480
it was limited to 256 bytes so no matter

524
00:19:08,480 --> 00:19:10,559
how much i set field length 2

525
00:19:10,559 --> 00:19:12,880
the program would only copy about 256

526
00:19:12,880 --> 00:19:15,360
bytes at a time this limited the amount

527
00:19:15,360 --> 00:19:16,240
of

528
00:19:16,240 --> 00:19:17,760
chains i could use the amount of gadgets

529
00:19:17,760 --> 00:19:20,080
i could use and this actually kind of

530
00:19:20,080 --> 00:19:22,160
discounts a lot of the traditional rock

531
00:19:22,160 --> 00:19:24,240
chains and in this case my plan was to

532
00:19:24,240 --> 00:19:25,039
use

533
00:19:25,039 --> 00:19:27,120
get module handle get proc address and

534
00:19:27,120 --> 00:19:29,280
find a virtual protect to remove the

535
00:19:29,280 --> 00:19:31,200
memory protections but this is not

536
00:19:31,200 --> 00:19:32,720
possible if you only have a certain

537
00:19:32,720 --> 00:19:34,720
number of bytes

538
00:19:34,720 --> 00:19:36,960
so my next option

539
00:19:36,960 --> 00:19:38,880
after trying different optimizations in

540
00:19:38,880 --> 00:19:41,200
the rock chain was to simply run get

541
00:19:41,200 --> 00:19:43,919
module handle get proc address and then

542
00:19:43,919 --> 00:19:46,160
locate the win exact function which

543
00:19:46,160 --> 00:19:48,640
takes in a shell command argument and

544
00:19:48,640 --> 00:19:50,240
which will then execute

545
00:19:50,240 --> 00:19:54,559
as per normal so i did do this uh

546
00:19:54,559 --> 00:19:56,400
and and was able to actually just pop my

547
00:19:56,400 --> 00:19:58,640
own calculator using this chain and for

548
00:19:58,640 --> 00:20:01,600
simplicity i built the poc and x86 but

549
00:20:01,600 --> 00:20:03,440
it's also obviously exportable and

550
00:20:03,440 --> 00:20:07,640
execute for as well at that time

551
00:20:08,720 --> 00:20:12,520
there we have it cve202133035

552
00:20:12,799 --> 00:20:15,120
which is a buffer overflow via a dbf

553
00:20:15,120 --> 00:20:17,120
file which overrides a return pointer

554
00:20:17,120 --> 00:20:19,919
with a dep and aslr bypass to finally

555
00:20:19,919 --> 00:20:22,559
execute rpg commands by the attacker

556
00:20:22,559 --> 00:20:24,159
so i'm gonna

557
00:20:24,159 --> 00:20:26,320
play the poc right now

558
00:20:26,320 --> 00:20:28,559
and this is just to prove that it's on

559
00:20:28,559 --> 00:20:30,880
windows the latest most updated windows

560
00:20:30,880 --> 00:20:34,880
the most updated apache open office and

561
00:20:34,880 --> 00:20:36,799
we're checking the

562
00:20:36,799 --> 00:20:39,360
version here

563
00:20:40,559 --> 00:20:42,320
i'm now going to open

564
00:20:42,320 --> 00:20:44,960
the payload

565
00:20:45,440 --> 00:20:48,159
and this is going to cause a crash after

566
00:20:48,159 --> 00:20:50,080
opening it with the

567
00:20:50,080 --> 00:20:51,679
the dialog and it's going to pop

568
00:20:51,679 --> 00:20:53,840
calculator

569
00:20:53,840 --> 00:20:56,080
so what i'm showing here is also to

570
00:20:56,080 --> 00:20:57,679
prove that

571
00:20:57,679 --> 00:21:00,400
calculator was coming from the open

572
00:21:00,400 --> 00:21:02,799
office process itself proving that it

573
00:21:02,799 --> 00:21:06,799
was indeed an arbitrary code execution

574
00:21:08,640 --> 00:21:10,960
so this is kind of the proof of concept

575
00:21:10,960 --> 00:21:12,559
that we have for apache open office

576
00:21:12,559 --> 00:21:15,720
right now

577
00:21:28,400 --> 00:21:29,840
after the exciting part of finding

578
00:21:29,840 --> 00:21:32,000
exporting vulnerabilities you get to the

579
00:21:32,000 --> 00:21:35,440
slower pace of foundry research which is

580
00:21:35,440 --> 00:21:37,600
disclosure and this can take months

581
00:21:37,600 --> 00:21:39,120
instead of these especially if you're

582
00:21:39,120 --> 00:21:40,640
trying to be more responsible with your

583
00:21:40,640 --> 00:21:42,559
disclosure because in bug bounty they

584
00:21:42,559 --> 00:21:43,760
have something called service level

585
00:21:43,760 --> 00:21:46,080
agreements which specify how long maybe

586
00:21:46,080 --> 00:21:47,760
the triager or the vendor are supposed

587
00:21:47,760 --> 00:21:49,840
to get back to you but in the boundary

588
00:21:49,840 --> 00:21:51,840
research space this can vary greatly

589
00:21:51,840 --> 00:21:53,919
between different vendors they have a

590
00:21:53,919 --> 00:21:55,520
different timeline they have to review

591
00:21:55,520 --> 00:21:58,000
the patch prepare release and then you

592
00:21:58,000 --> 00:21:59,679
know release it in stages if it's really

593
00:21:59,679 --> 00:22:01,679
popular program such as apache open

594
00:22:01,679 --> 00:22:02,559
office

595
00:22:02,559 --> 00:22:04,720
so for apache open office this took

596
00:22:04,720 --> 00:22:05,919
several months

597
00:22:05,919 --> 00:22:07,679
and you can see the different timelines

598
00:22:07,679 --> 00:22:09,679
here what i had to do in order to get

599
00:22:09,679 --> 00:22:12,840
the patch

600
00:22:13,600 --> 00:22:15,520
at the time of recording apache open

601
00:22:15,520 --> 00:22:17,520
office has released a patch test

602
00:22:17,520 --> 00:22:19,440
installer as well as patch the source

603
00:22:19,440 --> 00:22:21,280
code on github so you can see on the

604
00:22:21,280 --> 00:22:22,960
left the kind of changes they have made

605
00:22:22,960 --> 00:22:25,679
and essentially it does a

606
00:22:25,679 --> 00:22:27,520
memory length check this time in order

607
00:22:27,520 --> 00:22:31,120
to prevent the same buffer overflow

608
00:22:32,799 --> 00:22:35,200
after finding initial success with down

609
00:22:35,200 --> 00:22:37,360
fusing and code review it was time to

610
00:22:37,360 --> 00:22:39,200
move on to more advanced techniques such

611
00:22:39,200 --> 00:22:41,120
as coverage guided fuzzing as well as

612
00:22:41,120 --> 00:22:43,200
in-depth reverse engineering

613
00:22:43,200 --> 00:22:45,280
so what we've covered today is really

614
00:22:45,280 --> 00:22:47,919
two aspects of vanap research which is

615
00:22:47,919 --> 00:22:50,480
dumb fuzzing as well as code review

616
00:22:50,480 --> 00:22:52,559
however if you want to move on i'm going

617
00:22:52,559 --> 00:22:54,240
to post more about that in our medium

618
00:22:54,240 --> 00:22:57,120
blog at csg.gov tech which i do

619
00:22:57,120 --> 00:22:58,799
recommend for you to learn more about

620
00:22:58,799 --> 00:23:00,880
latest disclosures as well as in-depth

621
00:23:00,880 --> 00:23:04,000
blog posts in the future

622
00:23:05,120 --> 00:23:07,200
today i will publish the first of a

623
00:23:07,200 --> 00:23:09,440
two-part series covering dbf related

624
00:23:09,440 --> 00:23:11,039
vulnerabilities

625
00:23:11,039 --> 00:23:12,880
the first part goes into more technical

626
00:23:12,880 --> 00:23:15,039
detail behind this talk including root

627
00:23:15,039 --> 00:23:16,720
cause analysis

628
00:23:16,720 --> 00:23:18,320
the second part will be published in a

629
00:23:18,320 --> 00:23:20,480
week or two and discuss how i used

630
00:23:20,480 --> 00:23:22,400
coverage-based fuzzing to discover a

631
00:23:22,400 --> 00:23:24,799
remote code execution bug in microsoft

632
00:23:24,799 --> 00:23:25,919
office

633
00:23:25,919 --> 00:23:27,280
i hope they will be useful to those

634
00:23:27,280 --> 00:23:28,559
interested in starting out

635
00:23:28,559 --> 00:23:30,559
environmentally research so do check

636
00:23:30,559 --> 00:23:32,960
them out

637
00:23:33,039 --> 00:23:34,880
now before rounding off today's talk i'd

638
00:23:34,880 --> 00:23:36,240
like to give a shout out to govtech's

639
00:23:36,240 --> 00:23:38,240
new vulnerability rewards program on

640
00:23:38,240 --> 00:23:40,480
hackerone it's a year-round program that

641
00:23:40,480 --> 00:23:43,120
offers up to 5000 in its typical bounty

642
00:23:43,120 --> 00:23:45,200
table but also offers a special bounty

643
00:23:45,200 --> 00:23:47,039
of up to 150 000

644
00:23:47,039 --> 00:23:49,200
for extremely critical vulnerabilities

645
00:23:49,200 --> 00:23:50,720
so do check it out on hacker one if you

646
00:23:50,720 --> 00:23:53,120
have time

647
00:23:54,640 --> 00:23:55,919
so there are a few requirements and

648
00:23:55,919 --> 00:23:57,120
steps you have to take to join the

649
00:23:57,120 --> 00:23:59,039
program as you can see here and you can

650
00:23:59,039 --> 00:24:00,960
just check it out on the hacker one page

651
00:24:00,960 --> 00:24:03,200
as well so i don't work on the program

652
00:24:03,200 --> 00:24:04,799
myself but i do look forward to more

653
00:24:04,799 --> 00:24:06,640
hackers joining in and contributing

654
00:24:06,640 --> 00:24:10,559
vulnerabilities to the gov tech vrp

655
00:24:10,960 --> 00:24:12,960
and that's it for today's talk thank you

656
00:24:12,960 --> 00:24:14,640
so much for your time if you have any

657
00:24:14,640 --> 00:24:16,559
questions there's going to be a q a on

658
00:24:16,559 --> 00:24:18,559
discord later i have the same username

659
00:24:18,559 --> 00:24:20,320
as space raccoon and i look forward to

660
00:24:20,320 --> 00:24:24,520
your questions have a great day

