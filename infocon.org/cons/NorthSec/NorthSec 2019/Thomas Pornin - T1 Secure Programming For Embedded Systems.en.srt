1
00:00:02,810 --> 00:00:12,499
all right we're ready to start we will

2
00:00:08,750 --> 00:00:16,939
have tama rapper working on there so

3
00:00:12,499 --> 00:00:18,650
amongst other things and ncc group doing

4
00:00:16,940 --> 00:00:26,120
its presentation now so please join me

5
00:00:18,650 --> 00:00:29,689
in welcoming Tama hello

6
00:00:26,120 --> 00:00:37,699
so this is something that I've been

7
00:00:29,690 --> 00:00:40,339
thinking about for 12 years also and no

8
00:00:37,699 --> 00:00:42,829
time to show it so it's about other

9
00:00:40,339 --> 00:00:44,440
styles a secure programming for embedded

10
00:00:42,829 --> 00:00:49,010
systems

11
00:00:44,440 --> 00:00:51,620
so this first requires a good definition

12
00:00:49,010 --> 00:00:55,608
of what I mean by embedded system so I

13
00:00:51,620 --> 00:00:57,739
have pictures on the Left embedded

14
00:00:55,609 --> 00:01:01,489
systems on the right not embedded

15
00:00:57,739 --> 00:01:03,559
systems so on the right you will notice

16
00:01:01,489 --> 00:01:05,899
that there is a smartphone or a home

17
00:01:03,559 --> 00:01:09,380
water and for the purposes of this talk

18
00:01:05,900 --> 00:01:11,149
these are big large not embedded systems

19
00:01:09,380 --> 00:01:17,658
I'm not going to talk about these ones

20
00:01:11,149 --> 00:01:19,700
on the left you will recognize an ESP 32

21
00:01:17,659 --> 00:01:22,610
module so it's a small microcontroller

22
00:01:19,700 --> 00:01:26,299
with someone some flash and Wi-Fi

23
00:01:22,610 --> 00:01:28,969
capabilities there is an actual smart

24
00:01:26,299 --> 00:01:31,189
toaster real one I mean it really

25
00:01:28,969 --> 00:01:32,689
connected toaster which can send

26
00:01:31,189 --> 00:01:37,639
notifications to your phone over

27
00:01:32,689 --> 00:01:40,939
Bluetooth for some reason and ok the

28
00:01:37,640 --> 00:01:44,420
kitten is not embedded but there the

29
00:01:40,939 --> 00:01:46,939
caller is a GPS tracker that it receives

30
00:01:44,420 --> 00:01:50,689
GPS signals to know where it is and it

31
00:01:46,939 --> 00:01:53,869
broadcast radio signal to inform the

32
00:01:50,689 --> 00:01:59,359
owner or master of poverty of the kitten

33
00:01:53,869 --> 00:02:01,670
where the cat actually is so that's also

34
00:01:59,359 --> 00:02:05,990
the same kind of system is small it

35
00:02:01,670 --> 00:02:10,580
constrain in our electrical power

36
00:02:05,990 --> 00:02:12,980
computing power memory and so on so in

37
00:02:10,580 --> 00:02:13,540
practice what I mean by an embedded

38
00:02:12,980 --> 00:02:16,988
system

39
00:02:13,540 --> 00:02:22,030
is a small microcontroller tip typically

40
00:02:16,989 --> 00:02:24,790
an arm cortex-m line or equivalent not a

41
00:02:22,030 --> 00:02:27,970
lot of Guam we're talking 64 kilobytes

42
00:02:24,790 --> 00:02:31,540
or less than that not a lot of warm

43
00:02:27,970 --> 00:02:34,840
which is usually flash and it has some

44
00:02:31,540 --> 00:02:37,090
network connectivity and does not have

45
00:02:34,840 --> 00:02:40,209
an operating system it runs on so-called

46
00:02:37,090 --> 00:02:42,310
bare metal and there are very strong

47
00:02:40,209 --> 00:02:46,180
constraints on everything for instance

48
00:02:42,310 --> 00:02:49,480
the computing power or the size of

49
00:02:46,180 --> 00:02:51,790
physical size of the device or how much

50
00:02:49,480 --> 00:02:56,349
its thermal dissipation because you

51
00:02:51,790 --> 00:02:58,870
don't want to cook your cut in all of

52
00:02:56,349 --> 00:03:02,170
the the CPU constrained are actually not

53
00:02:58,870 --> 00:03:06,129
that important in a type of a typical

54
00:03:02,170 --> 00:03:09,099
application for that kind of device it's

55
00:03:06,129 --> 00:03:12,129
not fast it's ro but that's not the

56
00:03:09,099 --> 00:03:15,358
issue for the large majority of the code

57
00:03:12,129 --> 00:03:17,828
and the one constraints are more problem

58
00:03:15,359 --> 00:03:21,190
another example of a MIDI systems is

59
00:03:17,829 --> 00:03:26,349
this budget it's typically that class of

60
00:03:21,190 --> 00:03:29,280
hardware I'm talking about so these

61
00:03:26,349 --> 00:03:33,250
constraints have a lot of consequence on

62
00:03:29,280 --> 00:03:34,690
bootys core software security and first

63
00:03:33,250 --> 00:03:36,569
one is that you don't have a memory

64
00:03:34,690 --> 00:03:39,639
management you need so there are no

65
00:03:36,569 --> 00:03:42,429
protection on pages of RAM in fact I'll

66
00:03:39,639 --> 00:03:46,030
not enough page enough RAM to have page

67
00:03:42,430 --> 00:03:48,940
Lisa the older one can be read by the

68
00:03:46,030 --> 00:03:51,549
card or the RAM is accessible can be

69
00:03:48,940 --> 00:03:55,030
read and written there's no isolation

70
00:03:51,549 --> 00:03:57,159
and it has some consequences such as for

71
00:03:55,030 --> 00:04:01,120
instance if you have a null pointer

72
00:03:57,159 --> 00:04:03,190
dereference it will work on no more

73
00:04:01,120 --> 00:04:06,069
computer or smartphone if you try to

74
00:04:03,190 --> 00:04:09,459
dereference new you get some sort of

75
00:04:06,069 --> 00:04:13,328
exception segmentation for general

76
00:04:09,459 --> 00:04:15,340
protection foot something in that kind

77
00:04:13,329 --> 00:04:18,639
of hardware you just accessed one at

78
00:04:15,340 --> 00:04:21,969
address 0 and it just works if just one

79
00:04:18,639 --> 00:04:25,210
or if there's not one the right goes

80
00:04:21,969 --> 00:04:28,139
nowhere but it still does nothing else

81
00:04:25,210 --> 00:04:30,549
it does not interrupt

82
00:04:28,139 --> 00:04:33,220
you don't have address space layout

83
00:04:30,550 --> 00:04:36,009
randomization because there's no mm you

84
00:04:33,220 --> 00:04:39,669
to actually bundle my things you don't

85
00:04:36,009 --> 00:04:42,430
have quad pages on stack overflows in

86
00:04:39,669 --> 00:04:45,580
normally with C code on big computers if

87
00:04:42,430 --> 00:04:47,680
you allocate too much on the stack you

88
00:04:45,580 --> 00:04:51,669
get the general protection forth and so

89
00:04:47,680 --> 00:04:54,250
on no such thing here so this implies

90
00:04:51,669 --> 00:04:58,690
that if you want to develop code for

91
00:04:54,250 --> 00:05:01,960
that you have to abandon hope of using

92
00:04:58,690 --> 00:05:04,810
general recursive algorithms where a

93
00:05:01,960 --> 00:05:07,780
function calls itself every whenever

94
00:05:04,810 --> 00:05:08,319
because these allocates cases on the

95
00:05:07,780 --> 00:05:12,369
stack

96
00:05:08,319 --> 00:05:15,580
it's very hard to limit a few how much

97
00:05:12,370 --> 00:05:19,120
space it will consume depending on input

98
00:05:15,580 --> 00:05:20,440
data from the outside so this means that

99
00:05:19,120 --> 00:05:22,629
if you have a recursive algorithm

100
00:05:20,440 --> 00:05:25,629
usually you have a possible stack

101
00:05:22,629 --> 00:05:30,419
overflow which is a general overflow of

102
00:05:25,629 --> 00:05:30,419
one so it's good attack opportunity

103
00:05:31,259 --> 00:05:36,789
another consequence is that you really

104
00:05:34,300 --> 00:05:39,190
do not have room and don't have room for

105
00:05:36,789 --> 00:05:41,469
large start so for multiple stacks and

106
00:05:39,190 --> 00:05:43,539
if you have a device that must do

107
00:05:41,469 --> 00:05:46,360
several things in parallel you cannot

108
00:05:43,539 --> 00:05:48,580
just run threads because do not have an

109
00:05:46,360 --> 00:05:50,680
operating system to schedule sweat but

110
00:05:48,580 --> 00:05:54,180
even if you white one you don't have the

111
00:05:50,680 --> 00:05:57,069
run to run several concurrent threads

112
00:05:54,180 --> 00:05:59,050
realistically if you doing some C code

113
00:05:57,069 --> 00:06:01,500
for small microcontrollers unique

114
00:05:59,050 --> 00:06:04,930
something like four kilobytes pair

115
00:06:01,500 --> 00:06:07,750
threaded plastic and if you have 32

116
00:06:04,930 --> 00:06:12,490
kilobytes of guam in total you cannot

117
00:06:07,750 --> 00:06:14,680
afford a lot of these it turns out that

118
00:06:12,490 --> 00:06:18,129
the C language which is the usual

119
00:06:14,680 --> 00:06:21,039
language for that kind of interval has a

120
00:06:18,129 --> 00:06:23,740
tendency to consume ball stack space

121
00:06:21,039 --> 00:06:27,190
that you would like and it does not tell

122
00:06:23,740 --> 00:06:31,509
you so I've got an example this specific

123
00:06:27,190 --> 00:06:34,599
function if from the source code of last

124
00:06:31,509 --> 00:06:36,789
year badge for notic so it's an embedded

125
00:06:34,599 --> 00:06:40,229
system and this specific function

126
00:06:36,789 --> 00:06:40,229
allocates on the stack

127
00:06:40,339 --> 00:06:50,969
256-byte way which is used later on to

128
00:06:46,619 --> 00:06:53,459
assemble a message so these there are

129
00:06:50,969 --> 00:06:56,849
two things I want to point out here one

130
00:06:53,459 --> 00:07:00,179
is that the 256 bytes are located when

131
00:06:56,849 --> 00:07:04,080
the function is entered but they're not

132
00:07:00,179 --> 00:07:07,080
used while the three first function

133
00:07:04,080 --> 00:07:11,219
course GFX field whacks at casa said

134
00:07:07,080 --> 00:07:16,198
text begun color occurred and yet they

135
00:07:11,219 --> 00:07:19,998
are allocated so this common idiom in c

136
00:07:16,199 --> 00:07:23,580
programming of simply allocating library

137
00:07:19,999 --> 00:07:26,729
variables a to start implies some

138
00:07:23,580 --> 00:07:29,729
unnecessary memory consumption when

139
00:07:26,729 --> 00:07:34,050
calling these shape functions for the

140
00:07:29,729 --> 00:07:36,110
other one I want let's have a look at

141
00:07:34,050 --> 00:07:38,519
the rest on the output which is here so

142
00:07:36,110 --> 00:07:41,219
I've got I've compared it then

143
00:07:38,519 --> 00:07:44,969
disassemble it and that's arm code in

144
00:07:41,219 --> 00:07:49,139
thermode so at the start in red are the

145
00:07:44,969 --> 00:07:51,869
two allocations of the stack and the

146
00:07:49,139 --> 00:07:53,759
first one saves a bunch of registers

147
00:07:51,869 --> 00:07:55,860
because the calling convention said that

148
00:07:53,759 --> 00:07:59,909
this register should be saved by the

149
00:07:55,860 --> 00:08:02,550
curly not by the color and that means 24

150
00:07:59,909 --> 00:08:04,740
bytes just for the six registers which

151
00:08:02,550 --> 00:08:08,189
are stored and then there is a next to a

152
00:08:04,740 --> 00:08:11,490
location for the 256 byte array which

153
00:08:08,189 --> 00:08:13,559
turns out to be true not 64 why 264

154
00:08:11,490 --> 00:08:15,809
because when it's going to call the s

155
00:08:13,559 --> 00:08:17,479
printf function it will pass six

156
00:08:15,809 --> 00:08:20,129
parameters for that function and

157
00:08:17,479 --> 00:08:22,829
possibly the first four in dedicated

158
00:08:20,129 --> 00:08:25,439
registered but next to on the stack so

159
00:08:22,829 --> 00:08:28,139
the C compiler not only the rocket

160
00:08:25,439 --> 00:08:29,759
League the ROM white from start even

161
00:08:28,139 --> 00:08:32,099
though the comparin know that it won't

162
00:08:29,759 --> 00:08:35,370
be used at the status as a function an

163
00:08:32,099 --> 00:08:38,189
electron but also it has located more

164
00:08:35,370 --> 00:08:40,560
than us for now that's the kind of

165
00:08:38,188 --> 00:08:43,889
treatment that the compiler does because

166
00:08:40,559 --> 00:08:47,130
it's usually a good idea on big machines

167
00:08:43,889 --> 00:08:50,089
but on smaller microcontrollers it's

168
00:08:47,130 --> 00:08:50,089
more of a program

169
00:08:50,410 --> 00:08:56,110
so there are civil languages for

170
00:08:53,410 --> 00:08:58,920
embedded development usually it c YC

171
00:08:56,110 --> 00:09:03,760
because it works everywhere every

172
00:08:58,920 --> 00:09:06,250
provider for microcontroller also give

173
00:09:03,760 --> 00:09:08,710
the development kit which is a stick

174
00:09:06,250 --> 00:09:13,060
comparable usually GCC or something

175
00:09:08,710 --> 00:09:15,970
better LLVM I think I have seen things

176
00:09:13,060 --> 00:09:20,109
based on other compilers but even Visual

177
00:09:15,970 --> 00:09:23,290
Studio C works everywhere but it has

178
00:09:20,110 --> 00:09:25,840
some hidden automatic cuts that are to

179
00:09:23,290 --> 00:09:28,329
control in fact it's out in your source

180
00:09:25,840 --> 00:09:32,080
code to have a strict control of how

181
00:09:28,330 --> 00:09:33,820
much space is allocated on stacks it's

182
00:09:32,080 --> 00:09:35,980
well-known that it's not memory safe at

183
00:09:33,820 --> 00:09:38,980
all there's no check on the works he

184
00:09:35,980 --> 00:09:40,780
sees the darnell pointer there is the

185
00:09:38,980 --> 00:09:42,670
manual a location and the location when

186
00:09:40,780 --> 00:09:45,240
you lose maroc so you have to double

187
00:09:42,670 --> 00:09:48,459
three users or three you can leak memory

188
00:09:45,240 --> 00:09:50,410
there is a type system but it's not a

189
00:09:48,460 --> 00:09:53,110
strongly on thought so you can do type

190
00:09:50,410 --> 00:09:54,459
opening you take an object in RAM and

191
00:09:53,110 --> 00:09:57,070
you will interpret the bytes as

192
00:09:54,460 --> 00:10:00,040
something else and then you have a whole

193
00:09:57,070 --> 00:10:01,930
lot of hiding issues which means that

194
00:10:00,040 --> 00:10:04,959
some code which works may cease to work

195
00:10:01,930 --> 00:10:08,589
when you optimize more aggressively over

196
00:10:04,960 --> 00:10:12,220
you change compiler version and it's a

197
00:10:08,590 --> 00:10:14,470
real mess and still you have to support

198
00:10:12,220 --> 00:10:17,680
some sort of C because it was C world

199
00:10:14,470 --> 00:10:19,510
and the SDK you have which provides the

200
00:10:17,680 --> 00:10:22,689
necessary code for accessing the

201
00:10:19,510 --> 00:10:25,090
hardware is usually about usually with C

202
00:10:22,690 --> 00:10:26,740
API so you have to whatever you do you

203
00:10:25,090 --> 00:10:32,170
have to interoperate with C

204
00:10:26,740 --> 00:10:33,370
Oh another candidate is called it's Java

205
00:10:32,170 --> 00:10:35,920
micro edition

206
00:10:33,370 --> 00:10:39,280
it's an odd thing which were working on

207
00:10:35,920 --> 00:10:41,339
phones when phones were not smart I mean

208
00:10:39,280 --> 00:10:44,110
that like 20 years ago

209
00:10:41,340 --> 00:10:46,230
the Tartu garbage collector last one

210
00:10:44,110 --> 00:10:49,120
typed it is known to be memory safe and

211
00:10:46,230 --> 00:10:52,270
right now on the right is something it's

212
00:10:49,120 --> 00:10:55,600
a screenshot from Oracle side because we

213
00:10:52,270 --> 00:10:57,910
call on Java now and it means that if

214
00:10:55,600 --> 00:11:00,970
you want to use Java ME these days you

215
00:10:57,910 --> 00:11:02,579
need at least 128 kilobyte of one one

216
00:11:00,970 --> 00:11:04,829
megabyte of warm and

217
00:11:02,579 --> 00:11:07,888
it's and you need to provide an

218
00:11:04,829 --> 00:11:10,319
operating system on top of that and it's

219
00:11:07,889 --> 00:11:13,319
still very constrained there is or not

220
00:11:10,319 --> 00:11:16,259
that says actual footprint will vary

221
00:11:13,319 --> 00:11:18,719
there's an target device and use case so

222
00:11:16,259 --> 00:11:22,529
it's like the millage on your car it may

223
00:11:18,720 --> 00:11:25,639
change so these usually you cannot use

224
00:11:22,529 --> 00:11:27,739
that and the smaller microcontrollers

225
00:11:25,639 --> 00:11:30,989
just too big

226
00:11:27,739 --> 00:11:35,220
another example is fashionable language

227
00:11:30,989 --> 00:11:37,709
known as go and go if you try to make an

228
00:11:35,220 --> 00:11:39,809
a low word for go a new computer you'll

229
00:11:37,709 --> 00:11:41,248
get something like three megabytes

230
00:11:39,809 --> 00:11:43,920
Beanery

231
00:11:41,249 --> 00:11:46,410
for some reason it turns out to be large

232
00:11:43,920 --> 00:11:48,420
but there are people who are working on

233
00:11:46,410 --> 00:11:52,079
something called tango which pretends to

234
00:11:48,420 --> 00:11:54,738
be go but for microcontrollers and it

235
00:11:52,079 --> 00:11:57,179
all right now some limitations

236
00:11:54,739 --> 00:12:00,329
officially the support for Google things

237
00:11:57,179 --> 00:12:03,779
which are the threads in the Google is

238
00:12:00,329 --> 00:12:09,269
weak which is an aluminium to say that

239
00:12:03,779 --> 00:12:11,160
it does not work you can have maps I

240
00:12:09,269 --> 00:12:13,709
meaning if you could do some good

241
00:12:11,160 --> 00:12:18,179
development you have a lot of maps it's

242
00:12:13,709 --> 00:12:20,939
a very basic memory construction just to

243
00:12:18,179 --> 00:12:24,179
organize things and in general you can

244
00:12:20,939 --> 00:12:27,299
have up to eight entries in maps in tiny

245
00:12:24,179 --> 00:12:30,360
go no more so it's kind of restrictive I

246
00:12:27,299 --> 00:12:32,249
mean I don't want to blame the people

247
00:12:30,360 --> 00:12:34,199
who are waiting tiny goals are trying to

248
00:12:32,249 --> 00:12:37,439
do something which is not really

249
00:12:34,199 --> 00:12:39,269
feasible so they do their best but it's

250
00:12:37,439 --> 00:12:44,759
not because it's good that it's magical

251
00:12:39,269 --> 00:12:47,819
the one constraints are still there even

252
00:12:44,759 --> 00:12:49,709
they have a garbage collector which

253
00:12:47,819 --> 00:12:52,769
works from arm and from other platform

254
00:12:49,709 --> 00:12:56,849
it our case but it does not collect so

255
00:12:52,769 --> 00:12:59,459
memory just accumulates okay that it's

256
00:12:56,850 --> 00:13:03,509
not easy to write a portable code which

257
00:12:59,459 --> 00:13:06,059
does garbage collection but starting

258
00:13:03,509 --> 00:13:07,709
with God would not make things easier in

259
00:13:06,059 --> 00:13:10,259
fact it's a language which has been

260
00:13:07,709 --> 00:13:14,310
designed for larger systems and which

261
00:13:10,259 --> 00:13:18,949
tends to assume that there is space

262
00:13:14,310 --> 00:13:21,420
and this these hardware there's no space

263
00:13:18,949 --> 00:13:24,930
another fashionable language worst

264
00:13:21,420 --> 00:13:27,300
embedded so they really intended I mean

265
00:13:24,930 --> 00:13:30,180
there's dedicated website a lot of

266
00:13:27,300 --> 00:13:33,269
documentation and they're making

267
00:13:30,180 --> 00:13:36,138
specialized conference and so on so it's

268
00:13:33,269 --> 00:13:40,350
supposed to be as memory safe and as

269
00:13:36,139 --> 00:13:42,480
safe for everything like worst so you

270
00:13:40,350 --> 00:13:47,069
can aviary but you can work with outer

271
00:13:42,480 --> 00:13:49,319
hip but then it still have some second

272
00:13:47,069 --> 00:13:51,599
greenness like see and even more so

273
00:13:49,319 --> 00:13:57,059
because it wants to do a lot of magic

274
00:13:51,600 --> 00:13:59,279
things and the magic is the selling

275
00:13:57,059 --> 00:14:03,420
point of worst and it's exactly what I

276
00:13:59,279 --> 00:14:06,329
do not want it's I want to have some

277
00:14:03,420 --> 00:14:11,160
good nations when I develop of where my

278
00:14:06,329 --> 00:14:14,219
stuff is my data sometimes cryptographic

279
00:14:11,160 --> 00:14:16,980
keys I don't want data to be

280
00:14:14,220 --> 00:14:19,379
automatically compiled because the

281
00:14:16,980 --> 00:14:22,439
compiler decided that it was necessary

282
00:14:19,379 --> 00:14:26,519
to make a copy just to maintain the

283
00:14:22,439 --> 00:14:30,269
strict semantics of sharing but not know

284
00:14:26,519 --> 00:14:32,309
concurrent modification of words or to

285
00:14:30,269 --> 00:14:34,740
enroll sometimes the compiler will

286
00:14:32,309 --> 00:14:37,529
unroll loops because unrolling groups

287
00:14:34,740 --> 00:14:40,559
give speed and speed is good but it uses

288
00:14:37,529 --> 00:14:44,399
a lot of more code space and it can

289
00:14:40,559 --> 00:14:48,139
imply wrote more stack allocation so

290
00:14:44,399 --> 00:14:52,250
it's a good effort but then again

291
00:14:48,139 --> 00:14:56,339
starting with worst we not magically

292
00:14:52,250 --> 00:14:58,980
provide a better match with the combine

293
00:14:56,339 --> 00:15:00,689
constraints it provides the memory

294
00:14:58,980 --> 00:15:05,029
safety of the language but it does not

295
00:15:00,689 --> 00:15:05,029
solve the issue with the memory usage

296
00:15:06,769 --> 00:15:13,829
now that one is very old it's from the

297
00:15:10,319 --> 00:15:18,269
early 1970s it's older than me which is

298
00:15:13,829 --> 00:15:20,579
already some feet and it's more fill

299
00:15:18,269 --> 00:15:22,439
surface and a long wage and if you talk

300
00:15:20,579 --> 00:15:24,120
to people who are doing something with

301
00:15:22,439 --> 00:15:25,589
forth they tell you that you are not

302
00:15:24,120 --> 00:15:28,620
supposed to use the wrong wage we are

303
00:15:25,589 --> 00:15:32,470
supposed to we implement it

304
00:15:28,620 --> 00:15:34,510
it actually works that it's you end up

305
00:15:32,470 --> 00:15:40,510
with something which is very close to

306
00:15:34,510 --> 00:15:43,090
the hardware very non portable and you

307
00:15:40,510 --> 00:15:45,910
have absolute control of everything that

308
00:15:43,090 --> 00:15:49,780
happens in your arm and you can save a

309
00:15:45,910 --> 00:15:53,350
lot here as far as safety concern is

310
00:15:49,780 --> 00:15:58,240
less safe than C which is again quite a

311
00:15:53,350 --> 00:16:00,100
feat so I take it as an inspiration for

312
00:15:58,240 --> 00:16:04,300
a lot of concept but certainly not a

313
00:16:00,100 --> 00:16:06,730
thing to do like that right away so

314
00:16:04,300 --> 00:16:10,060
given the state of existing programming

315
00:16:06,730 --> 00:16:12,430
languages I just told myself okay the

316
00:16:10,060 --> 00:16:14,560
whole turkey I want to be so also I'm

317
00:16:12,430 --> 00:16:17,770
going to design my own programming

318
00:16:14,560 --> 00:16:22,239
language with my own compiler just to do

319
00:16:17,770 --> 00:16:30,220
better than the world world if it works

320
00:16:22,240 --> 00:16:34,110
oh and the language I need must are in

321
00:16:30,220 --> 00:16:38,650
fact it must be able to interpret we see

322
00:16:34,110 --> 00:16:40,990
it must be I must be able to compile it

323
00:16:38,650 --> 00:16:44,170
to some sort of C code so that it could

324
00:16:40,990 --> 00:16:47,260
be possible right away it must be

325
00:16:44,170 --> 00:16:51,459
non-magic will be like force and very

326
00:16:47,260 --> 00:16:56,100
unlike rust but I want it to be memory

327
00:16:51,460 --> 00:16:59,290
safe like words but very like force and

328
00:16:56,100 --> 00:17:01,390
it needs to do something differently

329
00:16:59,290 --> 00:17:05,399
than other languages because I want to

330
00:17:01,390 --> 00:17:07,780
solve the huge one constraints and

331
00:17:05,400 --> 00:17:11,260
existing languages are just not designed

332
00:17:07,780 --> 00:17:13,960
for that so I've got a success story

333
00:17:11,260 --> 00:17:18,220
from something which I call T zero which

334
00:17:13,960 --> 00:17:20,560
is the predecessor of t1 and you may

335
00:17:18,220 --> 00:17:22,150
have heard that I've written an SSL

336
00:17:20,560 --> 00:17:28,690
library called bare SSL which is

337
00:17:22,150 --> 00:17:32,430
optimized for embedded systems it does

338
00:17:28,690 --> 00:17:37,150
SSL TLS with a lot of features suppose

339
00:17:32,430 --> 00:17:39,740
45 stifles it it is very small but in

340
00:17:37,150 --> 00:17:43,100
Iran and in warm but it's super

341
00:17:39,740 --> 00:17:44,690
the world protocol it's supposed to be

342
00:17:43,100 --> 00:17:48,139
uncompromising with regard to security

343
00:17:44,690 --> 00:17:52,640
and so on so it's something that works

344
00:17:48,140 --> 00:17:54,799
so far it has no dynamic memory location

345
00:17:52,640 --> 00:17:57,020
there's no molecule in fact there are

346
00:17:54,799 --> 00:17:59,539
only three external function course

347
00:17:57,020 --> 00:18:02,750
which are mem copy may move and

348
00:17:59,539 --> 00:18:04,940
esterline it requires nothing else it

349
00:18:02,750 --> 00:18:07,870
does not know what an operating system

350
00:18:04,940 --> 00:18:10,159
is and it's in fact a computational

351
00:18:07,870 --> 00:18:15,168
library that it does not know what

352
00:18:10,159 --> 00:18:17,179
network socket is it expects you to do

353
00:18:15,169 --> 00:18:18,919
to provide the bytes which have been

354
00:18:17,179 --> 00:18:21,350
received from the network and then it

355
00:18:18,919 --> 00:18:28,309
will do the rest SL magic and tell you

356
00:18:21,350 --> 00:18:33,379
what was in that and it runs as a

357
00:18:28,309 --> 00:18:36,350
coating the kubu teen is a cyclist read

358
00:18:33,380 --> 00:18:40,730
except that it does not concurrently it

359
00:18:36,350 --> 00:18:44,080
is another state in which it knows where

360
00:18:40,730 --> 00:18:46,940
it is within a complete and shake or

361
00:18:44,080 --> 00:18:49,370
inside the run shake off SSL where it is

362
00:18:46,940 --> 00:18:52,270
within the validation of the x.509

363
00:18:49,370 --> 00:18:56,809
certificate change and budget server and

364
00:18:52,270 --> 00:19:00,889
it's when it expects incoming bytes it

365
00:18:56,809 --> 00:19:03,740
can be interrupted and then you can jump

366
00:19:00,890 --> 00:19:06,970
again into it just where it was when the

367
00:19:03,740 --> 00:19:09,230
new bars are available so I've got

368
00:19:06,970 --> 00:19:14,390
somatic here Oh

369
00:19:09,230 --> 00:19:15,799
on the left is what your application is

370
00:19:14,390 --> 00:19:19,549
supposed to do the application is

371
00:19:15,799 --> 00:19:22,370
supposed to do all the Wi-Fi the IP

372
00:19:19,549 --> 00:19:24,350
staff and also provide the application

373
00:19:22,370 --> 00:19:26,870
data which is to be sent for the Jenelle

374
00:19:24,350 --> 00:19:29,139
and retrieve and do something with the

375
00:19:26,870 --> 00:19:33,289
application that had been obtained and

376
00:19:29,140 --> 00:19:36,110
then the rule of barrister cellphones as

377
00:19:33,289 --> 00:19:38,149
a sort of state engine in which you

378
00:19:36,110 --> 00:19:40,908
input bytes it gives bites back

379
00:19:38,149 --> 00:19:43,309
it does not perform network course does

380
00:19:40,909 --> 00:19:45,320
not block it just tells you okay at that

381
00:19:43,309 --> 00:19:45,918
point I have some bytes to send up here

382
00:19:45,320 --> 00:19:49,450
they are

383
00:19:45,919 --> 00:19:52,580
call me back when the bytes aghanim and

384
00:19:49,450 --> 00:19:56,029
internally to this other

385
00:19:52,580 --> 00:19:58,840
one for passing all the room check

386
00:19:56,029 --> 00:20:01,700
messages of TLS which are complicated

387
00:19:58,840 --> 00:20:04,549
that one will accept use another Kovu

388
00:20:01,700 --> 00:20:06,710
teen which passes the certificate chain

389
00:20:04,549 --> 00:20:09,950
from the peer from the server typically

390
00:20:06,710 --> 00:20:12,799
if user client and the certificate chain

391
00:20:09,950 --> 00:20:16,399
can be up to 16 megabytes as per the

392
00:20:12,799 --> 00:20:18,980
standards it's uncommon but even open

393
00:20:16,399 --> 00:20:20,809
SSL for instance and locates up to 100

394
00:20:18,980 --> 00:20:23,000
kilo bytes and I don't want to allocate

395
00:20:20,809 --> 00:20:27,049
100 kilobytes I don't have one on what

396
00:20:23,000 --> 00:20:29,750
kilobyte so I must pass everything in a

397
00:20:27,049 --> 00:20:33,260
streaming fashion and so this required

398
00:20:29,750 --> 00:20:36,799
the x.509 passer to be able to absorb

399
00:20:33,260 --> 00:20:40,399
bytes as a comma and to give me back the

400
00:20:36,799 --> 00:20:45,019
control of the CPU when the next bytes

401
00:20:40,399 --> 00:20:46,489
are not that yet so I need to have in

402
00:20:45,019 --> 00:20:48,529
fact several co-routines

403
00:20:46,490 --> 00:20:50,539
and each convert in being like a thread

404
00:20:48,529 --> 00:20:52,850
would need it one stack and I don't have

405
00:20:50,539 --> 00:20:57,889
the one for the stack so here comes the

406
00:20:52,850 --> 00:21:00,139
magic so the magic is to write my own

407
00:20:57,889 --> 00:21:04,399
fast way to do that I don't want to do

408
00:21:00,139 --> 00:21:05,539
that and yet I did that I change a few

409
00:21:04,399 --> 00:21:09,739
things for for instance

410
00:21:05,539 --> 00:21:11,929
everything in force is about doing your

411
00:21:09,740 --> 00:21:14,450
development of the target systems I mean

412
00:21:11,929 --> 00:21:16,340
it was designed by an astronomer we

413
00:21:14,450 --> 00:21:19,820
wanted to be able to patch his code at

414
00:21:16,340 --> 00:21:21,830
night on his telescope and 1970s

415
00:21:19,820 --> 00:21:26,600
telescope so that was not a powerful

416
00:21:21,830 --> 00:21:28,879
machine I don't do that in fact I have a

417
00:21:26,600 --> 00:21:30,678
separate compiler which one which is

418
00:21:28,880 --> 00:21:33,710
implemented in c-sharp and which runs on

419
00:21:30,679 --> 00:21:36,200
big systems where I have one I have a

420
00:21:33,710 --> 00:21:38,769
lot of computing power I can do a lot of

421
00:21:36,200 --> 00:21:43,549
optimizations and it's a separate

422
00:21:38,769 --> 00:21:45,110
computation step then as force it

423
00:21:43,549 --> 00:21:47,299
compares to something which is called to

424
00:21:45,110 --> 00:21:48,709
edit code it's not native code and it's

425
00:21:47,299 --> 00:21:52,549
something which I've been going to

426
00:21:48,710 --> 00:21:55,250
detail and it's if you remember only one

427
00:21:52,549 --> 00:21:56,418
thing from this Tokyo how to white

428
00:21:55,250 --> 00:22:00,940
threaded code

429
00:21:56,419 --> 00:22:05,010
it's a very nice way to generate some

430
00:22:00,940 --> 00:22:06,960
virtual machine interpreted code

431
00:22:05,010 --> 00:22:09,960
which is relatively efficient and which

432
00:22:06,960 --> 00:22:12,720
is extremely compact syndrome and in

433
00:22:09,960 --> 00:22:16,770
that virtual machine there are two

434
00:22:12,720 --> 00:22:19,380
stacks one more on link function

435
00:22:16,770 --> 00:22:23,700
parameters and the other for link local

436
00:22:19,380 --> 00:22:28,350
variable for functions and instruction

437
00:22:23,700 --> 00:22:32,820
pointers so and these tags are very

438
00:22:28,350 --> 00:22:36,240
small and in fact right now I limit the

439
00:22:32,820 --> 00:22:39,689
stack size to one other 28 bytes each so

440
00:22:36,240 --> 00:22:42,110
that's more and actually I can guarantee

441
00:22:39,690 --> 00:22:46,410
with the comparators they are not used

442
00:22:42,110 --> 00:22:51,270
not fully used the total I have figures

443
00:22:46,410 --> 00:22:54,870
afterwards but I use 168 bytes of state

444
00:22:51,270 --> 00:23:00,270
and 168 bytes I can allocate that means

445
00:22:54,870 --> 00:23:03,929
that I cannot for that so here are

446
00:23:00,270 --> 00:23:06,360
something this is T 0 code so it looks

447
00:23:03,930 --> 00:23:08,610
like force and if the first time you see

448
00:23:06,360 --> 00:23:13,790
that you should be slightly disgusted

449
00:23:08,610 --> 00:23:16,830
and confused but it actually makes sense

450
00:23:13,790 --> 00:23:20,370
it's a Pacific's notation which means

451
00:23:16,830 --> 00:23:22,530
that when you are doing the operations

452
00:23:20,370 --> 00:23:26,729
you put the appearance first and then

453
00:23:22,530 --> 00:23:29,790
the operation that acts on them so you

454
00:23:26,730 --> 00:23:32,640
don't compute one plus two you push one

455
00:23:29,790 --> 00:23:36,120
then you push true then you do a plus on

456
00:23:32,640 --> 00:23:39,180
boss and everything happens from left to

457
00:23:36,120 --> 00:23:42,510
right so it's very clear the order of

458
00:23:39,180 --> 00:23:47,340
operations and that's part of the no

459
00:23:42,510 --> 00:23:50,220
magic here you have three functions in

460
00:23:47,340 --> 00:23:52,620
gray are commands the one in counties

461
00:23:50,220 --> 00:23:55,890
are not at all command there are also a

462
00:23:52,620 --> 00:23:58,699
bit of type systems which have

463
00:23:55,890 --> 00:24:03,030
implemented in T zero this one said that

464
00:23:58,700 --> 00:24:05,220
the function with AIDS it expects one

465
00:24:03,030 --> 00:24:07,920
value on the stack on entry and returns

466
00:24:05,220 --> 00:24:11,310
two values all values are 32-bit words

467
00:24:07,920 --> 00:24:13,410
the names are you that just commands but

468
00:24:11,310 --> 00:24:16,800
the compiler know that this function

469
00:24:13,410 --> 00:24:18,620
should return one more value than it odd

470
00:24:16,800 --> 00:24:22,760
at the start and it very

471
00:24:18,620 --> 00:24:25,280
find that so here the read ate what it

472
00:24:22,760 --> 00:24:31,700
does is that it's trying to read one

473
00:24:25,280 --> 00:24:33,830
byte but the value it has on input is

474
00:24:31,700 --> 00:24:36,610
the maximum number of bytes it can still

475
00:24:33,830 --> 00:24:40,850
read is for passing nested structure in

476
00:24:36,610 --> 00:24:45,320
certificates where each team element has

477
00:24:40,850 --> 00:24:47,449
a specific length so that and you're not

478
00:24:45,320 --> 00:24:50,240
supposed to even if there are more bias

479
00:24:47,450 --> 00:24:52,160
in the certificate after that you must

480
00:24:50,240 --> 00:24:57,230
own for that you're not reading bytes

481
00:24:52,160 --> 00:24:59,660
beyond that limit so here it the dupe

482
00:24:57,230 --> 00:25:02,750
duplicates the limit if not compare it

483
00:24:59,660 --> 00:25:09,910
with the row so it consumes the

484
00:25:02,750 --> 00:25:13,580
duplicate if the limit is 0 then this

485
00:25:09,910 --> 00:25:16,400
code will be executed otherwise it will

486
00:25:13,580 --> 00:25:19,428
jump out just after the 10 and this code

487
00:25:16,400 --> 00:25:23,420
is basically - no problem does not work

488
00:25:19,429 --> 00:25:26,780
it's an error code which values 36 and

489
00:25:23,420 --> 00:25:31,280
it just stops everything everything in

490
00:25:26,780 --> 00:25:34,850
that Cove 18 and otherwise what is that

491
00:25:31,280 --> 00:25:36,710
it's subtract 1 from the current limit

492
00:25:34,850 --> 00:25:38,750
and then it calls another function which

493
00:25:36,710 --> 00:25:42,020
is not shown here which does direct rule

494
00:25:38,750 --> 00:25:46,190
by trading underneath two functions

495
00:25:42,020 --> 00:25:49,190
which uses read AIDS and want to with

496
00:25:46,190 --> 00:25:51,650
two bytes and interpret that as a 16-bit

497
00:25:49,190 --> 00:25:54,170
value in began John Oh in little-endian

498
00:25:51,650 --> 00:25:56,900
because of course both are used in

499
00:25:54,170 --> 00:26:00,020
certificates and in TLS so you have to

500
00:25:56,900 --> 00:26:03,670
have boss and what you must remember

501
00:26:00,020 --> 00:26:05,990
from here is that in that kind of code

502
00:26:03,670 --> 00:26:07,880
executable code is most clear seconds of

503
00:26:05,990 --> 00:26:10,700
function course sometimes you push a

504
00:26:07,880 --> 00:26:13,750
value just a through eight it pushes a

505
00:26:10,700 --> 00:26:17,360
value but about everything else is

506
00:26:13,750 --> 00:26:18,920
Kalinga shape function so the threaded

507
00:26:17,360 --> 00:26:21,770
code is about representing each

508
00:26:18,920 --> 00:26:25,070
interpreting function as a sequence of

509
00:26:21,770 --> 00:26:29,450
pointers to the structure that

510
00:26:25,070 --> 00:26:31,500
represents the call function so with the

511
00:26:29,450 --> 00:26:34,140
West Shima uvula

512
00:26:31,500 --> 00:26:39,090
you'll see today and everything is in

513
00:26:34,140 --> 00:26:40,680
there so first I have the two two

514
00:26:39,090 --> 00:26:43,080
functions which I just shown which has

515
00:26:40,680 --> 00:26:46,830
read 8 and with 16 B and I'm

516
00:26:43,080 --> 00:26:50,129
concentrating of the second one on the

517
00:26:46,830 --> 00:26:51,899
Left I've represented what it does it

518
00:26:50,130 --> 00:26:55,650
just a symbolic representation that is

519
00:26:51,900 --> 00:26:58,650
basically course order function with 8

520
00:26:55,650 --> 00:27:00,990
left shift swap with eight again what

521
00:26:58,650 --> 00:27:03,540
which is something that rotates value

522
00:27:00,990 --> 00:27:06,540
the suite of values on the start Plus

523
00:27:03,540 --> 00:27:09,770
which adds two values and it has to

524
00:27:06,540 --> 00:27:12,780
special order one comes which just

525
00:27:09,770 --> 00:27:17,460
pushes a constant value and weight which

526
00:27:12,780 --> 00:27:20,220
exists the current function then here on

527
00:27:17,460 --> 00:27:22,650
the left is the representation in memory

528
00:27:20,220 --> 00:27:25,800
of that function

529
00:27:22,650 --> 00:27:30,510
it's each box is a pointer or pointer

530
00:27:25,800 --> 00:27:34,460
sized world and each call is actually a

531
00:27:30,510 --> 00:27:37,440
pointer to another structure in Wham

532
00:27:34,460 --> 00:27:40,380
which is again a sequence of pointers

533
00:27:37,440 --> 00:27:43,590
and the first one is a pointer to a

534
00:27:40,380 --> 00:27:47,580
native code and vacci code assembly

535
00:27:43,590 --> 00:27:50,449
whatever that executes the function so

536
00:27:47,580 --> 00:27:55,409
let's first see for instance constant

537
00:27:50,450 --> 00:27:57,830
here are the read 16b function add a

538
00:27:55,410 --> 00:28:00,240
pointer to cone so when the

539
00:27:57,830 --> 00:28:01,679
interpretation arrived at that point and

540
00:28:00,240 --> 00:28:04,260
the interpolation is running the

541
00:28:01,680 --> 00:28:11,190
Viator's a period it's just a loop that

542
00:28:04,260 --> 00:28:13,290
reads the it other IP it's instruction

543
00:28:11,190 --> 00:28:16,050
pointer you can imagine it as a

544
00:28:13,290 --> 00:28:18,570
dedicated register or a variable in one

545
00:28:16,050 --> 00:28:20,159
it's something which is simply there

546
00:28:18,570 --> 00:28:23,790
it's a pointer to the next instruction

547
00:28:20,160 --> 00:28:27,150
to execute so it reads in another search

548
00:28:23,790 --> 00:28:30,060
variable called W it reads here as the

549
00:28:27,150 --> 00:28:34,130
pointer comes and then it will follow

550
00:28:30,060 --> 00:28:37,169
that pointers and eita at the first

551
00:28:34,130 --> 00:28:39,210
throat at the pointy structure it

552
00:28:37,170 --> 00:28:43,650
expects a pointer to some native code

553
00:28:39,210 --> 00:28:45,050
which is one so here it will just run

554
00:28:43,650 --> 00:28:47,640
cons which we

555
00:28:45,050 --> 00:28:50,070
use the instruction pointer to read the

556
00:28:47,640 --> 00:28:53,280
next slot which contains the eight and

557
00:28:50,070 --> 00:28:56,240
push it on the data stack afterwards it

558
00:28:53,280 --> 00:29:00,360
just loops so from the C point of view

559
00:28:56,240 --> 00:29:03,090
you're not accumulating function calls

560
00:29:00,360 --> 00:29:07,889
it's flat it does not allocate stack

561
00:29:03,090 --> 00:29:10,770
space now for no more function which is

562
00:29:07,890 --> 00:29:13,580
itself interpreted it does the exact

563
00:29:10,770 --> 00:29:15,960
same things when it which is with AIDS

564
00:29:13,580 --> 00:29:18,899
it's either pointers with a structure

565
00:29:15,960 --> 00:29:22,890
and the first field of that structure is

566
00:29:18,900 --> 00:29:24,780
a pointer to God which and what it does

567
00:29:22,890 --> 00:29:29,220
here is the magic of the threaded code

568
00:29:24,780 --> 00:29:30,660
it's saved on the system stack it saves

569
00:29:29,220 --> 00:29:34,350
the current expansion pointer and then

570
00:29:30,660 --> 00:29:36,840
change it to just the next slot so it's

571
00:29:34,350 --> 00:29:39,590
calling a function remembering on that

572
00:29:36,840 --> 00:29:42,300
star on the system sack where it was and

573
00:29:39,590 --> 00:29:45,240
modifying the instruction pointer to

574
00:29:42,300 --> 00:29:48,000
point to the code of the code function

575
00:29:45,240 --> 00:29:51,240
which is here we date which does it

576
00:29:48,000 --> 00:29:52,260
stuff and at the end we date when it

577
00:29:51,240 --> 00:29:54,690
which is the web's

578
00:29:52,260 --> 00:29:57,390
weight will just point to the same place

579
00:29:54,690 --> 00:30:00,290
as you which just restore their

580
00:29:57,390 --> 00:30:04,530
instruction pointers so when you run

581
00:30:00,290 --> 00:30:06,990
that small loop which is basically your

582
00:30:04,530 --> 00:30:09,270
virtual CPU from the C point of view

583
00:30:06,990 --> 00:30:12,390
just a single loop that would cut

584
00:30:09,270 --> 00:30:13,650
everything but by virtue of reading the

585
00:30:12,390 --> 00:30:15,300
rest functions and following the

586
00:30:13,650 --> 00:30:18,150
pointers and executing the thing is

587
00:30:15,300 --> 00:30:20,280
really running the code and the function

588
00:30:18,150 --> 00:30:23,520
calls and functions at that function

589
00:30:20,280 --> 00:30:26,430
cores and so on so this is called

590
00:30:23,520 --> 00:30:28,440
indirect valid code because there are

591
00:30:26,430 --> 00:30:30,960
two in directions for each instruction

592
00:30:28,440 --> 00:30:34,920
so it's not especially fast but it's

593
00:30:30,960 --> 00:30:37,980
very simple with that kind of technique

594
00:30:34,920 --> 00:30:41,430
you can have complex code which does

595
00:30:37,980 --> 00:30:44,700
locates very little space on your stack

596
00:30:41,430 --> 00:30:46,650
here there are two stocks which are

597
00:30:44,700 --> 00:30:50,400
manually implemented they are not the

598
00:30:46,650 --> 00:30:52,440
system tax the one where you put the

599
00:30:50,400 --> 00:30:54,870
instruction pointer and it just four

600
00:30:52,440 --> 00:30:56,700
bytes you know exactly how much space

601
00:30:54,870 --> 00:30:58,268
you consume on it there is no automatic

602
00:30:56,700 --> 00:31:00,909
compiler which

603
00:30:58,269 --> 00:31:03,669
we'll say oh I need a few extra space

604
00:31:00,909 --> 00:31:05,830
just to put some parameters for function

605
00:31:03,669 --> 00:31:08,349
and so on and I look at more this does

606
00:31:05,830 --> 00:31:13,478
not happen and the data stack is where

607
00:31:08,349 --> 00:31:15,339
all our values such as 8 and this one

608
00:31:13,479 --> 00:31:18,580
again is something where you know

609
00:31:15,339 --> 00:31:21,879
exactly how many there is you push on

610
00:31:18,580 --> 00:31:29,529
that because that's where everything

611
00:31:21,879 --> 00:31:34,269
goes so there is an extra trick that you

612
00:31:29,529 --> 00:31:36,879
can do about that this one I just

613
00:31:34,269 --> 00:31:38,979
explained it it's token threaded code

614
00:31:36,879 --> 00:31:42,579
tokens ready code is the same thing as

615
00:31:38,979 --> 00:31:45,099
that but you had a function which was a

616
00:31:42,579 --> 00:31:48,309
sequence of pointers and we are talking

617
00:31:45,099 --> 00:31:51,279
about 32 bits 4 bytes for each pointer

618
00:31:48,309 --> 00:31:55,059
that's a lot we want it to be more

619
00:31:51,279 --> 00:31:57,159
compact so in practice when you have a

620
00:31:55,059 --> 00:31:59,289
number of functions that call each other

621
00:31:57,159 --> 00:32:01,719
you don't have 4 billion such functions

622
00:31:59,289 --> 00:32:07,149
you have relatively limited set of

623
00:32:01,719 --> 00:32:10,629
function in my x.509 decoder I have 200

624
00:32:07,149 --> 00:32:14,349
something and 200 of something is in

625
00:32:10,629 --> 00:32:16,958
fact less than 256 so I could fit each

626
00:32:14,349 --> 00:32:21,299
pointers on one byte with the next one

627
00:32:16,959 --> 00:32:24,249
direction that is instead of having your

628
00:32:21,299 --> 00:32:26,739
pointers I have just single bytes and

629
00:32:24,249 --> 00:32:31,359
each byte is an index in a table which

630
00:32:26,739 --> 00:32:33,609
contains the actual pointers so at that

631
00:32:31,359 --> 00:32:36,820
point I revive where each instruction is

632
00:32:33,609 --> 00:32:39,820
basically one byte and that saves a lot

633
00:32:36,820 --> 00:32:43,599
of code space at the expense of a bit

634
00:32:39,820 --> 00:32:50,739
more CPU but as I said is not really an

635
00:32:43,599 --> 00:32:53,708
issue so when I compile my code so I've

636
00:32:50,739 --> 00:32:56,559
got the compiler is written in C sharp I

637
00:32:53,709 --> 00:33:00,999
ran that on Linux with mono it works it

638
00:32:56,559 --> 00:33:04,899
just works and then here I give it to t0

639
00:33:00,999 --> 00:33:08,799
files to do process and it takes me okay

640
00:33:04,899 --> 00:33:12,540
the maximum stack usage here is 17 words

641
00:33:08,799 --> 00:33:15,720
for the data stack and 25 words

642
00:33:12,540 --> 00:33:18,780
for the region's taxi we contact where

643
00:33:15,720 --> 00:33:23,820
are the instruction pointers so a total

644
00:33:18,780 --> 00:33:25,590
of 42 words which is 168 diets it also

645
00:33:23,820 --> 00:33:28,649
tells me that all the code that

646
00:33:25,590 --> 00:33:31,230
implements all the x.509 certificate

647
00:33:28,650 --> 00:33:35,940
validation with the decoding of the

648
00:33:31,230 --> 00:33:38,430
names and which are doubly nested

649
00:33:35,940 --> 00:33:42,300
structure and the decoding of public

650
00:33:38,430 --> 00:33:44,640
keys and it decode the validity - it

651
00:33:42,300 --> 00:33:47,070
increments all the words of a political

652
00:33:44,640 --> 00:33:47,670
and calendar and you don't want to know

653
00:33:47,070 --> 00:33:50,730
what that means

654
00:33:47,670 --> 00:33:53,520
and it does all the transcoding it can

655
00:33:50,730 --> 00:33:56,280
extract names which I knew GF 16 or it

656
00:33:53,520 --> 00:33:58,350
is 8 or Latin 1 and so on and it

657
00:33:56,280 --> 00:34:01,620
transcode everything to achieve 8 and

658
00:33:58,350 --> 00:34:03,840
verifying that it's really valid and it

659
00:34:01,620 --> 00:34:05,580
explored the subject item extension is

660
00:34:03,840 --> 00:34:08,009
exposed to basic constraints it does a

661
00:34:05,580 --> 00:34:10,319
lot of stuff and it does all that in two

662
00:34:08,010 --> 00:34:13,770
thousand eight hundred eight hundred

663
00:34:10,320 --> 00:34:16,410
thirty six bytes there's a bit of extra

664
00:34:13,770 --> 00:34:22,980
C code but the complete compiled one

665
00:34:16,409 --> 00:34:26,279
fittings about six kilobytes so to show

666
00:34:22,980 --> 00:34:35,190
you how it looks so where did I put that

667
00:34:26,280 --> 00:34:39,179
and okay this is the code which has been

668
00:34:35,190 --> 00:34:43,740
automatically generated it contains a

669
00:34:39,179 --> 00:34:46,830
lot of C code the basically interfaces

670
00:34:43,739 --> 00:34:52,529
between the TC ward the C word so this I

671
00:34:46,830 --> 00:34:55,918
would manually and then here these are

672
00:34:52,530 --> 00:35:00,080
the instruction so the actual code

673
00:34:55,918 --> 00:35:02,910
written in t0 is there this has been

674
00:35:00,080 --> 00:35:06,090
computed by the compiler so it's

675
00:35:02,910 --> 00:35:09,960
basically bytes there are some symbolic

676
00:35:06,090 --> 00:35:12,210
values but this with the macro that says

677
00:35:09,960 --> 00:35:16,650
that for instance this one is just a

678
00:35:12,210 --> 00:35:19,140
single byte so this is a single byte so

679
00:35:16,650 --> 00:35:22,680
there's these are the two thousand eight

680
00:35:19,140 --> 00:35:25,140
hundred thirty six bytes then this is an

681
00:35:22,680 --> 00:35:26,520
indirection for the token

682
00:35:25,140 --> 00:35:29,339
let's say when it's

683
00:35:26,520 --> 00:35:32,340
the token zeroes in the function at

684
00:35:29,340 --> 00:35:34,890
address 0 address 5 addressed and these

685
00:35:32,340 --> 00:35:37,800
are the addresses the offset within the

686
00:35:34,890 --> 00:35:41,960
other table of where the function code

687
00:35:37,800 --> 00:35:49,130
starts so you've got all of them here

688
00:35:41,960 --> 00:35:52,470
and I am skipping them echo here are the

689
00:35:49,130 --> 00:35:55,170
here is the instruction pointer it's

690
00:35:52,470 --> 00:35:58,140
just a local variable and the vehicle CP

691
00:35:55,170 --> 00:36:01,980
CPU here just a for loop and what it

692
00:35:58,140 --> 00:36:05,580
does it read the next token if the token

693
00:36:01,980 --> 00:36:08,369
is below a computed value it's a call to

694
00:36:05,580 --> 00:36:12,390
a primitive native function and then

695
00:36:08,369 --> 00:36:17,670
it's a switch is where I put all the

696
00:36:12,390 --> 00:36:21,868
small code which goes to the C world and

697
00:36:17,670 --> 00:36:26,700
I've got 63 of them async here ya know

698
00:36:21,869 --> 00:36:28,440
61 it goes to 60 after all the Y's this

699
00:36:26,700 --> 00:36:30,899
one turn it means okay it's an

700
00:36:28,440 --> 00:36:32,910
interpreted function so it does what was

701
00:36:30,900 --> 00:36:36,240
shown in a previous slide as enter it

702
00:36:32,910 --> 00:36:38,520
just under the next function and the

703
00:36:36,240 --> 00:36:40,618
data stuff so there's a new single

704
00:36:38,520 --> 00:36:47,790
function which really interprets also

705
00:36:40,619 --> 00:36:51,020
code and and thus what that means is

706
00:36:47,790 --> 00:36:53,820
that I can do some complicated treatment

707
00:36:51,020 --> 00:36:56,160
while saving a lot of warm space I know

708
00:36:53,820 --> 00:36:57,720
exactly how much one I'm using and it's

709
00:36:56,160 --> 00:37:00,060
not a lot and they have strong

710
00:36:57,720 --> 00:37:02,970
warranties I have some grantees which

711
00:37:00,060 --> 00:37:06,840
are compiled and verified and stack

712
00:37:02,970 --> 00:37:09,089
usage distance no my local I know that I

713
00:37:06,840 --> 00:37:14,700
won't leak memory and I know it won't

714
00:37:09,090 --> 00:37:18,450
overflow it's stuck so it's as some sort

715
00:37:14,700 --> 00:37:20,669
of memory safety but not everything not

716
00:37:18,450 --> 00:37:22,819
everything because it works but it's not

717
00:37:20,670 --> 00:37:24,780
actually memory safe and in fact

718
00:37:22,820 --> 00:37:27,060
two-and-a-half years ago there was an

719
00:37:24,780 --> 00:37:28,470
actual buffer overflow in that code in

720
00:37:27,060 --> 00:37:30,210
the experiment certificate which was

721
00:37:28,470 --> 00:37:32,669
formed with a father which was

722
00:37:30,210 --> 00:37:36,030
relatively impressive because that means

723
00:37:32,670 --> 00:37:40,790
that a father can actually follow that

724
00:37:36,030 --> 00:37:40,790
kind of code just automatically

725
00:37:41,660 --> 00:37:46,259
there was a type confusion I was

726
00:37:44,400 --> 00:37:49,829
decoding evaluate the 32-bit unsigned

727
00:37:46,260 --> 00:37:52,740
integer and then interpreting it as a

728
00:37:49,829 --> 00:37:56,069
sign integer to see if it was not larger

729
00:37:52,740 --> 00:37:59,310
than a buffer size and of course three

730
00:37:56,069 --> 00:38:01,200
billion and so on was negative as a sign

731
00:37:59,310 --> 00:38:03,930
32-bit so it was not larger than the

732
00:38:01,200 --> 00:38:06,480
buffer but when trying to read three

733
00:38:03,930 --> 00:38:11,520
billion and so bytes into a buffer

734
00:38:06,480 --> 00:38:13,530
whether it was a bit large so at that

735
00:38:11,520 --> 00:38:15,450
point I thought okay it works but I need

736
00:38:13,530 --> 00:38:17,550
something better all wide whining

737
00:38:15,450 --> 00:38:20,640
something better for a number of reason

738
00:38:17,550 --> 00:38:23,339
which is that one and also that I want

739
00:38:20,640 --> 00:38:27,089
to implement a list 1.3 Angeles 1.3 has

740
00:38:23,339 --> 00:38:29,490
a few each some characteristics one of

741
00:38:27,089 --> 00:38:31,290
them is that there is no longer a

742
00:38:29,490 --> 00:38:34,020
guarantee that the server will send a

743
00:38:31,290 --> 00:38:36,990
certificate chain in the right order

744
00:38:34,020 --> 00:38:39,690
in fact explicitly it may send extra

745
00:38:36,990 --> 00:38:44,098
certificates and do that in any order so

746
00:38:39,690 --> 00:38:46,740
now I cannot really process and to Telus

747
00:38:44,099 --> 00:38:49,410
1.3 if I just process the certificates

748
00:38:46,740 --> 00:38:51,990
as they come I have to buffer them so I

749
00:38:49,410 --> 00:38:55,890
need some memory allocation which I want

750
00:38:51,990 --> 00:38:59,000
to control I want to be memory safes why

751
00:38:55,890 --> 00:39:02,848
we need a garbage collector so and

752
00:38:59,000 --> 00:39:06,270
because of the initial issue I had with

753
00:39:02,849 --> 00:39:10,109
the oil so one to type system so when I

754
00:39:06,270 --> 00:39:10,950
had chosen the name t0 children it for

755
00:39:10,109 --> 00:39:14,009
three reasons

756
00:39:10,950 --> 00:39:14,970
one it was free there was no longer

757
00:39:14,010 --> 00:39:18,210
called tseebo

758
00:39:14,970 --> 00:39:19,560
as far as google knows the second is

759
00:39:18,210 --> 00:39:22,440
that the first letter is the first rate

760
00:39:19,560 --> 00:39:24,240
of my name so that's good and the third

761
00:39:22,440 --> 00:39:26,400
one is that if I didn't deem something T

762
00:39:24,240 --> 00:39:31,169
0 I have room for will tell of reference

763
00:39:26,400 --> 00:39:36,089
to one T 2 and so on so here is T 1 T 1

764
00:39:31,170 --> 00:39:38,819
is a work in progress it's not completed

765
00:39:36,089 --> 00:39:43,500
yet but they also sufficient stuff that

766
00:39:38,819 --> 00:39:46,670
I can show you without shame so what is

767
00:39:43,500 --> 00:39:50,520
that it's like T 0 so it keeps the

768
00:39:46,670 --> 00:39:52,650
beautiful false likes engines which are

769
00:39:50,520 --> 00:39:53,400
that called some advantage actually some

770
00:39:52,650 --> 00:39:55,890
advantage

771
00:39:53,400 --> 00:39:58,530
so you can do generic metaprogramming

772
00:39:55,890 --> 00:40:02,129
with it it's something which comes from

773
00:39:58,530 --> 00:40:05,340
the fourth word when you processing soos

774
00:40:02,130 --> 00:40:08,220
code the source code can just hijack the

775
00:40:05,340 --> 00:40:09,780
process right away that is you can

776
00:40:08,220 --> 00:40:12,629
define a function which is invoked as

777
00:40:09,780 --> 00:40:14,670
the compiler runs and then can take over

778
00:40:12,630 --> 00:40:17,310
the syntax for the remaining of the

779
00:40:14,670 --> 00:40:19,140
source code or give it back so any

780
00:40:17,310 --> 00:40:21,210
domain-specific language you want to

781
00:40:19,140 --> 00:40:23,040
implement any syntax you want to

782
00:40:21,210 --> 00:40:25,950
implement can be known from the language

783
00:40:23,040 --> 00:40:28,860
itself and in fact the loop construction

784
00:40:25,950 --> 00:40:32,939
equivalent of the switch of c of a for

785
00:40:28,860 --> 00:40:34,320
aldohn in the language itself just by

786
00:40:32,940 --> 00:40:36,870
dragging the source code and

787
00:40:34,320 --> 00:40:38,520
reinterpreting it so it's something

788
00:40:36,870 --> 00:40:43,080
where you can define your own syntax

789
00:40:38,520 --> 00:40:44,550
undergo which is abominable when you

790
00:40:43,080 --> 00:40:46,440
want to work with coworkers

791
00:40:44,550 --> 00:40:51,480
but extremely people were fooled when

792
00:40:46,440 --> 00:40:53,930
you alone so I want something like that

793
00:40:51,480 --> 00:40:58,650
but also memory safe so it should check

794
00:40:53,930 --> 00:41:02,100
relaxed it should also have controlled

795
00:40:58,650 --> 00:41:03,780
memory allocation with an automatic

796
00:41:02,100 --> 00:41:05,339
memory management that protects against

797
00:41:03,780 --> 00:41:07,260
double three or use after three and

798
00:41:05,340 --> 00:41:08,790
there should be no explicit free and

799
00:41:07,260 --> 00:41:11,280
that means that there should be a

800
00:41:08,790 --> 00:41:13,500
garbage collector and it can work

801
00:41:11,280 --> 00:41:16,320
because the garbage collector can in

802
00:41:13,500 --> 00:41:19,470
fact be very compact in one it can even

803
00:41:16,320 --> 00:41:23,510
help because if you have a language with

804
00:41:19,470 --> 00:41:28,020
a rich strong type system then it's

805
00:41:23,510 --> 00:41:29,880
unambiguous whether each word in RAM is

806
00:41:28,020 --> 00:41:31,950
a point or not on pointer which allows

807
00:41:29,880 --> 00:41:34,920
the garbage collector to move objects in

808
00:41:31,950 --> 00:41:37,950
one which means that it does not suffer

809
00:41:34,920 --> 00:41:42,390
from fragmentation and if you try to do

810
00:41:37,950 --> 00:41:44,310
just C type malloc and free as it go in

811
00:41:42,390 --> 00:41:46,799
a small amount of one fragmentation is

812
00:41:44,310 --> 00:41:49,799
going to kill you fragmentation is where

813
00:41:46,800 --> 00:41:53,970
your memory becomes Swiss cheese

814
00:41:49,800 --> 00:41:56,550
it has also a lot of small holes but no

815
00:41:53,970 --> 00:42:00,779
big enough all for the new location you

816
00:41:56,550 --> 00:42:03,000
want to do if you can just squeeze the

817
00:42:00,780 --> 00:42:06,450
words out by just moving the object and

818
00:42:03,000 --> 00:42:07,200
compacting them then you can defeat

819
00:42:06,450 --> 00:42:08,879
fragmentation

820
00:42:07,200 --> 00:42:12,598
and yeah bitch character can give you

821
00:42:08,880 --> 00:42:14,490
that so I want that so I want a rich

822
00:42:12,599 --> 00:42:18,030
type system to avoid all the type

823
00:42:14,490 --> 00:42:19,828
printing which was an issue also want

824
00:42:18,030 --> 00:42:23,099
some sort of object-oriented support

825
00:42:19,829 --> 00:42:26,599
object-oriented programming and not

826
00:42:23,099 --> 00:42:28,980
really a language feature it's

827
00:42:26,599 --> 00:42:31,260
development philosophy it's a way of

828
00:42:28,980 --> 00:42:33,690
designing our audio white your code and

829
00:42:31,260 --> 00:42:36,000
the language can provide of two

830
00:42:33,690 --> 00:42:37,589
primitives which helps with that if you

831
00:42:36,000 --> 00:42:40,520
are trying to do object-oriented warming

832
00:42:37,589 --> 00:42:43,230
in C you end up with function pointers

833
00:42:40,520 --> 00:42:45,859
which works but which is absolutely not

834
00:42:43,230 --> 00:42:50,180
comfortable so I wanted something a bit

835
00:42:45,859 --> 00:42:53,328
easier to manage I also wanted some

836
00:42:50,180 --> 00:42:56,460
extra features to make it a really good

837
00:42:53,329 --> 00:42:58,490
general-purpose programming languages so

838
00:42:56,460 --> 00:43:00,869
some sort of namespaces and

839
00:42:58,490 --> 00:43:02,910
possibilities of splitting an

840
00:43:00,869 --> 00:43:08,869
application into several modules that

841
00:43:02,910 --> 00:43:11,339
talk to each other memory safety I've

842
00:43:08,869 --> 00:43:14,099
talked about it already several time

843
00:43:11,339 --> 00:43:16,710
I've not told you what it means and it

844
00:43:14,099 --> 00:43:20,849
means a lot of things and you never get

845
00:43:16,710 --> 00:43:23,760
all of them so for instance you want no

846
00:43:20,849 --> 00:43:26,369
uncontrolled opening you won't know

847
00:43:23,760 --> 00:43:28,470
buffer overflow of course you won't in

848
00:43:26,369 --> 00:43:30,930
the context of dynamic memory allocation

849
00:43:28,470 --> 00:43:35,459
you don't want the use of Trofeo double

850
00:43:30,930 --> 00:43:38,279
three another facet of memory safety is

851
00:43:35,460 --> 00:43:41,609
that you want grunty's again stack

852
00:43:38,280 --> 00:43:43,680
overflow since you cannot unload where

853
00:43:41,609 --> 00:43:45,450
you cannot detect it with an MMU you

854
00:43:43,680 --> 00:43:49,470
don't have the I mean you can't and you

855
00:43:45,450 --> 00:43:52,109
can't have the word page so you want

856
00:43:49,470 --> 00:43:55,529
some guarantee from the compilation

857
00:43:52,109 --> 00:43:57,810
system you would like some grunty

858
00:43:55,530 --> 00:44:03,000
against over-allocation because you

859
00:43:57,810 --> 00:44:07,230
really don't have an infinite heap you

860
00:44:03,000 --> 00:44:09,420
don't want memory leaks some parts of

861
00:44:07,230 --> 00:44:14,010
memory safety that you may want to

862
00:44:09,420 --> 00:44:17,190
prevent concurrent whiting worst as that

863
00:44:14,010 --> 00:44:19,810
worst if you try to why trust god you'll

864
00:44:17,190 --> 00:44:25,120
meet their friends of bore

865
00:44:19,810 --> 00:44:27,070
the Boober is the enemy at the start I

866
00:44:25,120 --> 00:44:30,160
mean you really fight the board that's

867
00:44:27,070 --> 00:44:32,740
how they presented and the documentation

868
00:44:30,160 --> 00:44:34,930
of first said that in the end at some

869
00:44:32,740 --> 00:44:37,990
point you just give up you cease to

870
00:44:34,930 --> 00:44:40,180
fight you embrace the ball which means

871
00:44:37,990 --> 00:44:44,200
that it's still your son but somehow you

872
00:44:40,180 --> 00:44:46,660
have admitted that it's normal and it's

873
00:44:44,200 --> 00:44:48,669
part of the memory safety of worst but

874
00:44:46,660 --> 00:44:51,190
constant it's not part of the memory

875
00:44:48,670 --> 00:44:53,320
safety of goo or Java which do not have

876
00:44:51,190 --> 00:44:56,620
this feature and which are still said to

877
00:44:53,320 --> 00:44:58,480
be memory safe languages so memory

878
00:44:56,620 --> 00:45:01,839
safety is an aggregate term for a lot of

879
00:44:58,480 --> 00:45:04,900
properties and you will get some of them

880
00:45:01,840 --> 00:45:06,970
in any given language and if you get

881
00:45:04,900 --> 00:45:11,200
enough you can pretend that it's memory

882
00:45:06,970 --> 00:45:16,770
safe it's never absolutely safe but you

883
00:45:11,200 --> 00:45:20,890
want some of these so in Tiwana

884
00:45:16,770 --> 00:45:23,350
memory safety twice to be I try to

885
00:45:20,890 --> 00:45:26,259
achieve it with the maximum of compile

886
00:45:23,350 --> 00:45:28,930
time checks become competent checks upon

887
00:45:26,260 --> 00:45:31,120
on my machine where I can change the

888
00:45:28,930 --> 00:45:34,210
code if there's a problem I can fix it

889
00:45:31,120 --> 00:45:37,240
and it's a powerful machine I want to

890
00:45:34,210 --> 00:45:40,270
have the least possible runtime checks

891
00:45:37,240 --> 00:45:42,729
because one time checks when they fail

892
00:45:40,270 --> 00:45:45,700
upon on the device which is deployed so

893
00:45:42,730 --> 00:45:50,140
it's too late to fix things which can

894
00:45:45,700 --> 00:45:51,460
just throw up our hands and give up so

895
00:45:50,140 --> 00:45:53,109
the one time checked which are

896
00:45:51,460 --> 00:45:56,160
unavailable are the checks on the web

897
00:45:53,110 --> 00:46:00,580
owns in a full generality you cannot

898
00:45:56,160 --> 00:46:03,279
prove arbitrary code the tablet to a

899
00:46:00,580 --> 00:46:05,140
code will not try to access any web

900
00:46:03,280 --> 00:46:09,220
beyond its boundaries sometimes you can

901
00:46:05,140 --> 00:46:12,660
but you still need some dynamic checks

902
00:46:09,220 --> 00:46:16,270
and all the automatic memory management

903
00:46:12,660 --> 00:46:20,410
is also very dynamic system because you

904
00:46:16,270 --> 00:46:23,320
cannot in or generality compute all the

905
00:46:20,410 --> 00:46:26,740
allocation and dislocation which should

906
00:46:23,320 --> 00:46:27,970
happen at exactly the right time if you

907
00:46:26,740 --> 00:46:30,040
can do that you've just solved the

908
00:46:27,970 --> 00:46:33,160
ulting problem and writing problem is

909
00:46:30,040 --> 00:46:35,109
unsolvable so instead you need some

910
00:46:33,160 --> 00:46:38,020
one time you will stick which is called

911
00:46:35,109 --> 00:46:39,759
a garbage collector and it may fail with

912
00:46:38,020 --> 00:46:43,059
the out of my movie exception or

913
00:46:39,760 --> 00:46:46,119
equivalent when it just cannot but

914
00:46:43,059 --> 00:46:48,460
usually it works well as compile-time

915
00:46:46,119 --> 00:46:50,289
checks I want the maximum stack size I

916
00:46:48,460 --> 00:46:52,920
want some sort of escape analysis

917
00:46:50,289 --> 00:46:58,000
because I want to be able to allocate

918
00:46:52,920 --> 00:47:01,710
full objects on one of my stacks to be

919
00:46:58,000 --> 00:47:04,450
sure that it won't be accessed after the

920
00:47:01,710 --> 00:47:06,849
space has been released and this is

921
00:47:04,450 --> 00:47:09,520
called escape analysis and it's

922
00:47:06,849 --> 00:47:12,039
important for safety but it requires

923
00:47:09,520 --> 00:47:16,839
some sort of smartness from the compiler

924
00:47:12,039 --> 00:47:19,390
I want all method lookups to be solvable

925
00:47:16,839 --> 00:47:22,808
because all my function calls are

926
00:47:19,390 --> 00:47:25,868
becoming method calls which depend on

927
00:47:22,809 --> 00:47:29,079
the runtime types of what the object and

928
00:47:25,869 --> 00:47:30,910
the values I'm hunting so I want the

929
00:47:29,079 --> 00:47:33,369
compiler to make sure that I will not

930
00:47:30,910 --> 00:47:35,288
fail with an exception that says no for

931
00:47:33,369 --> 00:47:38,859
these objects there is no curly board

932
00:47:35,289 --> 00:47:41,020
method I don't want the time predict and

933
00:47:38,859 --> 00:47:42,910
I want to have also some statically

934
00:47:41,020 --> 00:47:45,279
allocated constant object we should go

935
00:47:42,910 --> 00:47:47,020
in flash and so the compiler should make

936
00:47:45,279 --> 00:47:49,329
sure that at no point I am trying to

937
00:47:47,020 --> 00:47:53,079
wide that up in flash because it won't

938
00:47:49,329 --> 00:47:56,039
actually white it and so this this

939
00:47:53,079 --> 00:47:58,599
should be prevented and I can't have a

940
00:47:56,039 --> 00:48:05,289
dynamic check for that because I don't

941
00:47:58,599 --> 00:48:08,140
have a MMU so here is an example of Java

942
00:48:05,289 --> 00:48:11,500
code to explain what I mean about

943
00:48:08,140 --> 00:48:16,390
object-oriented programming and why in

944
00:48:11,500 --> 00:48:19,000
that aspect ER Java technically sucks so

945
00:48:16,390 --> 00:48:21,879
on the left is Java code you've got two

946
00:48:19,000 --> 00:48:24,010
classes called a and B externally and

947
00:48:21,880 --> 00:48:27,059
each of them defines two method called

948
00:48:24,010 --> 00:48:30,190
foo which takes on a or b parameter and

949
00:48:27,059 --> 00:48:33,039
the each has a print statement that says

950
00:48:30,190 --> 00:48:36,010
exactly which one you've caught and then

951
00:48:33,039 --> 00:48:39,369
on the bottom you've got something which

952
00:48:36,010 --> 00:48:41,650
has two local variable of that a but

953
00:48:39,369 --> 00:48:45,010
filled with reference to object of type

954
00:48:41,650 --> 00:48:46,400
B it's quite because the X turns a so

955
00:48:45,010 --> 00:48:48,200
you can write an reference

956
00:48:46,400 --> 00:48:52,160
objective they'd be into a variable of

957
00:48:48,200 --> 00:48:54,649
type A and then it's calling on one of

958
00:48:52,160 --> 00:48:58,399
them the method foo with the other as

959
00:48:54,650 --> 00:49:02,109
parameter and this will call will print

960
00:48:58,400 --> 00:49:06,859
to be a because it will call that one

961
00:49:02,109 --> 00:49:09,319
that is to decide which of the four full

962
00:49:06,859 --> 00:49:12,078
function is called it will use the one

963
00:49:09,319 --> 00:49:14,180
time type of what is in X it's a

964
00:49:12,079 --> 00:49:15,890
variable of type a but it's really an

965
00:49:14,180 --> 00:49:20,808
object of type B so it's calling a

966
00:49:15,890 --> 00:49:23,150
method of B but to decide which of both

967
00:49:20,809 --> 00:49:26,690
methods in B it's cooling is using this

968
00:49:23,150 --> 00:49:28,490
time the static type which is the type

969
00:49:26,690 --> 00:49:31,490
of the variable and not the type of the

970
00:49:28,490 --> 00:49:34,879
object which is in it and you have that

971
00:49:31,490 --> 00:49:37,399
in Java you have to type systems from

972
00:49:34,880 --> 00:49:41,150
it'll lookups and one uses the runtime

973
00:49:37,400 --> 00:49:46,160
type and the other use the static type

974
00:49:41,150 --> 00:49:48,650
conferencing from the expressions and if

975
00:49:46,160 --> 00:49:50,930
mixes them and when you white code you

976
00:49:48,650 --> 00:49:52,339
have to live with that and I don't want

977
00:49:50,930 --> 00:49:57,200
to live with that I want something

978
00:49:52,339 --> 00:50:01,099
better so here is the equivalence in T

979
00:49:57,200 --> 00:50:03,649
zero so I'm defining structure a and B

980
00:50:01,099 --> 00:50:05,660
which extends the structure be in fact

981
00:50:03,650 --> 00:50:09,200
which is a ship type of be there so

982
00:50:05,660 --> 00:50:12,379
subtly but anyway I defined the four

983
00:50:09,200 --> 00:50:17,029
methods and they are defined outside

984
00:50:12,380 --> 00:50:19,369
this one says okay foo is called if at

985
00:50:17,029 --> 00:50:22,339
that time the stack contains two object

986
00:50:19,369 --> 00:50:26,020
of type s and it should this one should

987
00:50:22,339 --> 00:50:29,328
be good with and do that printer string

988
00:50:26,020 --> 00:50:33,500
then the three other methods for all

989
00:50:29,329 --> 00:50:36,710
combination of a and B and when here I'm

990
00:50:33,500 --> 00:50:39,230
trying to I'm calling new to create a

991
00:50:36,710 --> 00:50:41,779
subject of type B I'm writing them in

992
00:50:39,230 --> 00:50:45,200
local variables just to mimic what

993
00:50:41,779 --> 00:50:47,089
happens with the Java code and the local

994
00:50:45,200 --> 00:50:49,368
variable don't have a type associated

995
00:50:47,089 --> 00:50:51,109
with them because there is no static

996
00:50:49,369 --> 00:50:53,930
type analysis with the expression

997
00:50:51,109 --> 00:50:57,319
there's no notion of this variable as

998
00:50:53,930 --> 00:50:59,690
type a now it's a local variable which

999
00:50:57,319 --> 00:51:00,200
at this point will contain a be of type

1000
00:50:59,690 --> 00:51:02,599
B

1001
00:51:00,200 --> 00:51:04,009
and then when the Fumito discouraged we

1002
00:51:02,599 --> 00:51:06,530
lose the one time type for both

1003
00:51:04,010 --> 00:51:09,260
parameters there's nothing special about

1004
00:51:06,530 --> 00:51:11,420
the first parameter so it's more generic

1005
00:51:09,260 --> 00:51:14,630
object-oriented programming than Java or

1006
00:51:11,420 --> 00:51:17,960
C shop or about almost any other

1007
00:51:14,630 --> 00:51:20,570
programming language Java so I mean it's

1008
00:51:17,960 --> 00:51:21,670
like a decided to be more rapid than

1009
00:51:20,570 --> 00:51:25,730
Java

1010
00:51:21,670 --> 00:51:28,790
and here I say there is no expensive

1011
00:51:25,730 --> 00:51:30,650
static type analysis however I want the

1012
00:51:28,790 --> 00:51:32,329
compiler to do everything at compile

1013
00:51:30,650 --> 00:51:33,980
time so in fact there is a lot of

1014
00:51:32,329 --> 00:51:34,790
setting type energies but it's not

1015
00:51:33,980 --> 00:51:37,700
explicit

1016
00:51:34,790 --> 00:51:41,089
I want the compiler to be able to work

1017
00:51:37,700 --> 00:51:44,240
out when it sees that code that when

1018
00:51:41,089 --> 00:51:47,420
it's calling foo there will be the to

1019
00:51:44,240 --> 00:51:49,640
object will have type B and there is a

1020
00:51:47,420 --> 00:51:52,430
matching method which will be called and

1021
00:51:49,640 --> 00:51:55,430
preferably even to work out at compile

1022
00:51:52,430 --> 00:51:57,919
time that this will be that force method

1023
00:51:55,430 --> 00:52:00,348
only so that will be a direct call and

1024
00:51:57,920 --> 00:52:02,599
the three other methods won't even be

1025
00:52:00,349 --> 00:52:08,480
included in the generated code because

1026
00:52:02,599 --> 00:52:11,810
they are not called so I had to define

1027
00:52:08,480 --> 00:52:15,380
sometimes you have seen some structure

1028
00:52:11,810 --> 00:52:18,259
so I want to have decided that every

1029
00:52:15,380 --> 00:52:21,589
value was a pointer I mean even a plain

1030
00:52:18,260 --> 00:52:24,560
integer is a pointer it's just a format

1031
00:52:21,589 --> 00:52:27,950
is trick I mean I say that when you have

1032
00:52:24,560 --> 00:52:29,720
a values 5 it's not 5 it's a pointer to

1033
00:52:27,950 --> 00:52:32,210
a virtual instance which in carnate so

1034
00:52:29,720 --> 00:52:34,939
value 5 which allows me to say that

1035
00:52:32,210 --> 00:52:37,339
everything is a pointer and it contrasts

1036
00:52:34,940 --> 00:52:40,760
with go where usually you have value

1037
00:52:37,339 --> 00:52:43,009
types if you define the stroke in go and

1038
00:52:40,760 --> 00:52:46,339
you have a value of that structure it

1039
00:52:43,010 --> 00:52:48,770
goes would say on your stack if you pass

1040
00:52:46,339 --> 00:52:51,140
it to a sub function it will copy it so

1041
00:52:48,770 --> 00:52:54,530
it's more space on the stack so instead

1042
00:52:51,140 --> 00:52:57,410
in t1 everything is a pointer so if you

1043
00:52:54,530 --> 00:53:00,020
want to have a copy you have to call for

1044
00:52:57,410 --> 00:53:02,060
it and this is part of the process of

1045
00:53:00,020 --> 00:53:04,670
keeping the developer which is myself

1046
00:53:02,060 --> 00:53:08,900
aware of all the memory which is

1047
00:53:04,670 --> 00:53:11,150
allocated so I've got a number of types

1048
00:53:08,900 --> 00:53:12,200
and green plain integers and modular

1049
00:53:11,150 --> 00:53:15,530
integers

1050
00:53:12,200 --> 00:53:19,250
integer Madeira integers are usually 16

1051
00:53:15,530 --> 00:53:25,490
32 bits 64 bits integers you know them

1052
00:53:19,250 --> 00:53:27,440
and there's no new pointer I just don't

1053
00:53:25,490 --> 00:53:29,660
want new pointers I mean everything

1054
00:53:27,440 --> 00:53:31,640
about job I just don't know just like it

1055
00:53:29,660 --> 00:53:37,129
so if justno no justno nil pointer

1056
00:53:31,640 --> 00:53:39,980
dereference this should fit and there's

1057
00:53:37,130 --> 00:53:41,930
no new pointer difference so you start

1058
00:53:39,980 --> 00:53:44,830
to prime but of course you can have some

1059
00:53:41,930 --> 00:53:47,690
structures with uninitialized fields and

1060
00:53:44,830 --> 00:53:49,819
then the idea is not to return a new

1061
00:53:47,690 --> 00:53:52,790
link that case is to trigger an

1062
00:53:49,820 --> 00:53:54,950
exception raise an arrow in fact kids or

1063
00:53:52,790 --> 00:53:57,380
complete coding so it's a way of

1064
00:53:54,950 --> 00:54:00,649
avoiding the null values to spread

1065
00:53:57,380 --> 00:54:02,570
everywhere this is not completely novel

1066
00:54:00,650 --> 00:54:04,670
things I mean there are other languages

1067
00:54:02,570 --> 00:54:10,460
which is new one of them is objective

1068
00:54:04,670 --> 00:54:15,260
camel for the plain integers have

1069
00:54:10,460 --> 00:54:18,260
decided to go as other I mean if you

1070
00:54:15,260 --> 00:54:20,330
have some integers and you do an

1071
00:54:18,260 --> 00:54:22,640
operation which goes out of range of

1072
00:54:20,330 --> 00:54:26,810
representable values integers you've got

1073
00:54:22,640 --> 00:54:29,420
basically six ways to unroll that in

1074
00:54:26,810 --> 00:54:32,000
c-sharp Java go it's gone T to use

1075
00:54:29,420 --> 00:54:35,780
modular arithmetic truncated to 32-bit

1076
00:54:32,000 --> 00:54:38,990
and that's it in other a new language

1077
00:54:35,780 --> 00:54:42,950
its ways it was an exception if you make

1078
00:54:38,990 --> 00:54:45,979
an overflow this has destroyed the iron

1079
00:54:42,950 --> 00:54:49,870
five first flight the expensive rocket

1080
00:54:45,980 --> 00:54:49,870
but usually it's still a good idea

1081
00:54:50,050 --> 00:54:54,800
inverse you can have both it depends on

1082
00:54:53,210 --> 00:55:01,850
whether you compile with or without

1083
00:54:54,800 --> 00:55:04,700
debug so so much for safety and in

1084
00:55:01,850 --> 00:55:07,069
Python or scheme most scheme

1085
00:55:04,700 --> 00:55:08,859
implementations when you go out of trans

1086
00:55:07,070 --> 00:55:11,240
we don't go out of French it just

1087
00:55:08,860 --> 00:55:14,030
automatically switches to big integrals

1088
00:55:11,240 --> 00:55:16,279
with dynamic memory allocation which is

1089
00:55:14,030 --> 00:55:20,150
nice but it widgets requires dynamic

1090
00:55:16,280 --> 00:55:22,340
memory allocation in JavaScript is doing

1091
00:55:20,150 --> 00:55:24,140
something real weird which is to use

1092
00:55:22,340 --> 00:55:25,400
floating point instead of integers so

1093
00:55:24,140 --> 00:55:27,440
when they go

1094
00:55:25,400 --> 00:55:30,110
ah French they become approximate and at

1095
00:55:27,440 --> 00:55:33,200
some point they become infinite which

1096
00:55:30,110 --> 00:55:36,110
does not make for really strong code and

1097
00:55:33,200 --> 00:55:38,870
in C or C++ if you go to France it's an

1098
00:55:36,110 --> 00:55:42,350
undefined behavior so anything goes so

1099
00:55:38,870 --> 00:55:46,279
I've chosen to use the other way because

1100
00:55:42,350 --> 00:55:48,170
it seems to be the safest among these

1101
00:55:46,280 --> 00:55:53,780
that don't not require dynamic memory

1102
00:55:48,170 --> 00:55:56,440
allocation okay this one I've got two

1103
00:55:53,780 --> 00:55:59,450
minutes okay

1104
00:55:56,440 --> 00:56:03,890
he's the secret weapon to make the world

1105
00:55:59,450 --> 00:56:05,960
thing work it means that all the type

1106
00:56:03,890 --> 00:56:08,839
analysis which is performed by the t1

1107
00:56:05,960 --> 00:56:12,530
compiler is not on a per function

1108
00:56:08,840 --> 00:56:15,290
positions on a world program the idea is

1109
00:56:12,530 --> 00:56:17,750
that here you've got a function called

1110
00:56:15,290 --> 00:56:19,700
ripple which is defined to be invoked on

1111
00:56:17,750 --> 00:56:22,220
any object and what it does is that

1112
00:56:19,700 --> 00:56:24,529
duplicates twice the values and calls

1113
00:56:22,220 --> 00:56:28,279
why the plus function was supposed to

1114
00:56:24,530 --> 00:56:31,280
add it to itself if it's an integer if

1115
00:56:28,280 --> 00:56:37,160
it's a string it will just concatenate

1116
00:56:31,280 --> 00:56:39,830
it so triple can work with integers

1117
00:56:37,160 --> 00:56:41,990
modulo integers with drinks but not with

1118
00:56:39,830 --> 00:56:44,690
everything not everything can be added

1119
00:56:41,990 --> 00:56:47,089
and the compare does not mind that I

1120
00:56:44,690 --> 00:56:50,780
said it can be called with any object

1121
00:56:47,090 --> 00:56:53,450
because it does not try to imagine what

1122
00:56:50,780 --> 00:56:55,850
it would happen with any matching

1123
00:56:53,450 --> 00:56:57,649
possible type you just want to make sure

1124
00:56:55,850 --> 00:57:01,339
that I'm not calling it with the type

1125
00:56:57,650 --> 00:57:04,190
for which it would not work so here when

1126
00:57:01,340 --> 00:57:07,250
it sees the main function it follows

1127
00:57:04,190 --> 00:57:09,710
what the main function does see that it

1128
00:57:07,250 --> 00:57:13,010
called triples and at that point there

1129
00:57:09,710 --> 00:57:16,010
will be a module 32-bit integer and so

1130
00:57:13,010 --> 00:57:18,650
it analyzes the triple function with a

1131
00:57:16,010 --> 00:57:21,500
stack that contains 32-bit integer and

1132
00:57:18,650 --> 00:57:23,930
it works and then in the second line of

1133
00:57:21,500 --> 00:57:25,700
men it will see that it calls triple

1134
00:57:23,930 --> 00:57:28,160
again but this time it's a string so it

1135
00:57:25,700 --> 00:57:31,819
does the analysis again this time with a

1136
00:57:28,160 --> 00:57:34,520
string and it still works and crucially

1137
00:57:31,820 --> 00:57:36,230
it does not try to merge both it

1138
00:57:34,520 --> 00:57:38,540
considers the two triple code to be

1139
00:57:36,230 --> 00:57:38,930
independent of each other so it does not

1140
00:57:38,540 --> 00:57:41,089
try

1141
00:57:38,930 --> 00:57:44,899
- imagine a triple function which would

1142
00:57:41,089 --> 00:57:48,380
have stuck with three values which can

1143
00:57:44,900 --> 00:57:50,809
be each of them an integral or string so

1144
00:57:48,380 --> 00:57:53,569
it does never ask itself what would

1145
00:57:50,809 --> 00:57:56,119
happen if it tries to add a string with

1146
00:57:53,569 --> 00:57:58,460
an integer because it does not happen

1147
00:57:56,119 --> 00:58:00,079
and the compiler works that works out

1148
00:57:58,460 --> 00:58:03,230
that it does not happen so everything is

1149
00:58:00,079 --> 00:58:06,079
fine and when generating code it will

1150
00:58:03,230 --> 00:58:07,880
know for each of this code which plus

1151
00:58:06,079 --> 00:58:09,920
function is to be code and it won't even

1152
00:58:07,880 --> 00:58:12,200
have to look at the one-time time of

1153
00:58:09,920 --> 00:58:16,010
objects because the compiler will have

1154
00:58:12,200 --> 00:58:17,839
known at which at each point where what

1155
00:58:16,010 --> 00:58:24,290
is really the type of things on the

1156
00:58:17,839 --> 00:58:26,569
stack so this implies wand each other

1157
00:58:24,290 --> 00:58:28,880
but it's in the code as generics in fact

1158
00:58:26,569 --> 00:58:30,410
every function is generate so you can

1159
00:58:28,880 --> 00:58:32,210
tell that to go programmers where they

1160
00:58:30,410 --> 00:58:33,950
don't have generics in T 1 there are

1161
00:58:32,210 --> 00:58:35,180
generics I mean you you can't do

1162
00:58:33,950 --> 00:58:37,939
anything without generics

1163
00:58:35,180 --> 00:58:39,558
it's all day it also means that we

1164
00:58:37,940 --> 00:58:42,140
really can't tell about recursion

1165
00:58:39,559 --> 00:58:44,720
because that would mean an infinite tree

1166
00:58:42,140 --> 00:58:49,670
and an entry takes an infinite amount of

1167
00:58:44,720 --> 00:58:52,970
time to compile so nope there's a lot of

1168
00:58:49,670 --> 00:58:55,510
this also allows escape analysis and

1169
00:58:52,970 --> 00:58:57,770
detection of wise to constant instances

1170
00:58:55,510 --> 00:59:01,730
so the current status that's my last

1171
00:58:57,770 --> 00:59:05,150
slide so I've put it two days ago on

1172
00:59:01,730 --> 00:59:09,079
github this one just put the stuff and

1173
00:59:05,150 --> 00:59:11,480
what you will find there is 55 docu page

1174
00:59:09,079 --> 00:59:13,190
document which is a specification of the

1175
00:59:11,480 --> 00:59:16,210
language with a rational and a lot of

1176
00:59:13,190 --> 00:59:20,200
explanations of why is designed that way

1177
00:59:16,210 --> 00:59:22,790
there is a incomplete bootstrap

1178
00:59:20,200 --> 00:59:26,839
interpreter compiler so first compiler

1179
00:59:22,790 --> 00:59:29,930
which with destinies to be trashed at

1180
00:59:26,839 --> 00:59:31,880
some point it just to be able to write a

1181
00:59:29,930 --> 00:59:34,520
second compiler which would be the final

1182
00:59:31,880 --> 00:59:37,280
one with a 91 itself so I need a

1183
00:59:34,520 --> 00:59:40,160
bootstrap for that and that first

1184
00:59:37,280 --> 00:59:42,109
bootstrap other working interpreter it

1185
00:59:40,160 --> 00:59:45,500
works it does the world program analysis

1186
00:59:42,109 --> 00:59:48,529
but the code generator is not finished

1187
00:59:45,500 --> 00:59:50,210
so I have to finish that to add some

1188
00:59:48,530 --> 00:59:51,130
sort of standard library which for

1189
00:59:50,210 --> 00:59:54,760
instantly stand

1190
00:59:51,130 --> 00:59:57,010
sorted maps with the numeric memory a

1191
00:59:54,760 --> 00:59:58,480
location and a small garbage collector

1192
00:59:57,010 --> 01:00:00,910
which I already have but it's not

1193
00:59:58,480 --> 01:00:02,980
integrated and then I will have to

1194
01:00:00,910 --> 01:00:05,770
rewire the t1 compiler in t1 because

1195
01:00:02,980 --> 01:00:07,060
that's the tradition when you design

1196
01:00:05,770 --> 01:00:10,270
your language you do that

1197
01:00:07,060 --> 01:00:12,910
I mean it's unavoidable and it's a very

1198
01:00:10,270 --> 01:00:14,920
good test bed and if it works if the

1199
01:00:12,910 --> 01:00:16,450
compiler can compile itself then you

1200
01:00:14,920 --> 01:00:20,140
know that a lot of things that you

1201
01:00:16,450 --> 01:00:23,230
implemented actually work so you're

1202
01:00:20,140 --> 01:00:27,250
welcome to follow that URL and try to

1203
01:00:23,230 --> 01:00:28,120
read my pause and be overboard or

1204
01:00:27,250 --> 01:00:31,560
disgusted

1205
01:00:28,120 --> 01:00:31,560
depending on your test

1206
01:00:33,070 --> 01:00:43,090
[Applause]

1207
01:00:40,920 --> 01:00:48,550
we're almost out of time but we might

1208
01:00:43,090 --> 01:00:50,410
have time for one or two questions why

1209
01:00:48,550 --> 01:00:54,120
do you want to rewrite your t1 compiler

1210
01:00:50,410 --> 01:00:58,210
in t1 mmm why do you want to rewrite it

1211
01:00:54,120 --> 01:01:00,250
ok first because it's very traditional

1212
01:00:58,210 --> 01:01:02,290
to write a compare language in itself

1213
01:01:00,250 --> 01:01:06,810
it's a way to demonstrate that the

1214
01:01:02,290 --> 01:01:09,490
language works to all the developers I

1215
01:01:06,810 --> 01:01:13,390
want to test that the compiler works and

1216
01:01:09,490 --> 01:01:14,890
having the world code base complicated

1217
01:01:13,390 --> 01:01:18,310
code base written in that language is a

1218
01:01:14,890 --> 01:01:21,549
very good test bed it's all we also

1219
01:01:18,310 --> 01:01:23,410
helped me to validate that I'm not did

1220
01:01:21,550 --> 01:01:25,120
not got it wrong with the design I mean

1221
01:01:23,410 --> 01:01:27,549
I'm trying to design the language

1222
01:01:25,120 --> 01:01:30,490
feature so that they work well for the

1223
01:01:27,550 --> 01:01:33,430
developer so it's a good way to verify

1224
01:01:30,490 --> 01:01:36,580
that it actually allows to write code

1225
01:01:33,430 --> 01:01:38,470
efficiently and for that I am the

1226
01:01:36,580 --> 01:01:39,700
measure of all things I mean I'm

1227
01:01:38,470 --> 01:01:41,529
watching that for me

1228
01:01:39,700 --> 01:01:44,319
you're welcome to participate to

1229
01:01:41,530 --> 01:01:47,170
participate but for all aesthetics

1230
01:01:44,320 --> 01:01:50,560
question where there's no really good

1231
01:01:47,170 --> 01:01:54,820
rational answer I make things as I

1232
01:01:50,560 --> 01:02:00,279
please and I want to know if I will be

1233
01:01:54,820 --> 01:02:02,610
pleased with it all right well thank you

1234
01:02:00,280 --> 01:02:02,610
very much

1235
01:02:03,690 --> 01:02:09,059
[Applause]

