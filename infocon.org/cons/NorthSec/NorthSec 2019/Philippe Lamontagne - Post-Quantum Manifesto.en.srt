1
00:00:02,610 --> 00:00:08,700
hello and welcome back and please join

2
00:00:06,420 --> 00:00:11,400
me in welcoming Philipp Lahm oh dang who

3
00:00:08,700 --> 00:00:17,250
is a researcher at the Canada's national

4
00:00:11,400 --> 00:00:19,619
research concerns oh he's going to be

5
00:00:17,250 --> 00:00:22,698
presenting on quantum cryptography right

6
00:00:19,619 --> 00:00:22,698
implies for a society

7
00:00:26,350 --> 00:00:30,939
thank you and thank you all for coming

8
00:00:28,330 --> 00:00:32,589
to my talk fair warning it's probably

9
00:00:30,939 --> 00:00:34,809
gonna be the most theoretical talk of

10
00:00:32,590 --> 00:00:36,989
the conference and there might be one

11
00:00:34,809 --> 00:00:40,089
other talk that competes me in terms of

12
00:00:36,989 --> 00:00:44,080
theoretical Ness and it's the 130 talk

13
00:00:40,090 --> 00:00:47,680
on elliptic elect an elliptic curve

14
00:00:44,080 --> 00:00:49,720
cryptography so I'm gonna present post

15
00:00:47,680 --> 00:00:52,360
quantum cryptography my goal here today

16
00:00:49,720 --> 00:00:54,040
is that you get all the we get out of

17
00:00:52,360 --> 00:01:04,330
this talk a high-level understanding of

18
00:00:54,040 --> 00:01:13,600
what's post partum cryptic is better and

19
00:01:04,330 --> 00:01:16,240
it's an echo hello hello so so yeah so

20
00:01:13,600 --> 00:01:19,360
my goal is that you get out of this talk

21
00:01:16,240 --> 00:01:21,130
a high-level understanding of what is

22
00:01:19,360 --> 00:01:23,770
post quantum crypto what are the types

23
00:01:21,130 --> 00:01:25,960
of problem that were interesting to

24
00:01:23,770 --> 00:01:27,850
solve with post come to Uncle Joe so

25
00:01:25,960 --> 00:01:30,639
without further ado let's jump right in

26
00:01:27,850 --> 00:01:33,189
and before going into post quantum

27
00:01:30,640 --> 00:01:36,250
crypto one a lot at three quantum

28
00:01:33,189 --> 00:01:40,089
cryptography basically the Golden Age of

29
00:01:36,250 --> 00:01:41,829
cryptography uses the 1970s with these

30
00:01:40,090 --> 00:01:44,470
two guys Whitfield Diffie and Martin

31
00:01:41,829 --> 00:01:46,899
Hellman that introduced New Directions

32
00:01:44,470 --> 00:01:48,670
in cryptography and for those of you who

33
00:01:46,900 --> 00:01:50,890
know this paper these new directions are

34
00:01:48,670 --> 00:01:54,070
essentially public key cryptography or

35
00:01:50,890 --> 00:01:56,890
as symmetric cryptography and the

36
00:01:54,070 --> 00:01:59,048
problem is the introduce is basically

37
00:01:56,890 --> 00:02:00,450
digital signature and public key

38
00:01:59,049 --> 00:02:04,869
encryption

39
00:02:00,450 --> 00:02:06,220
they didn't propose a real scheme that

40
00:02:04,869 --> 00:02:08,199
implements those ideas they just

41
00:02:06,220 --> 00:02:09,820
proposed the ideas and so that this was

42
00:02:08,199 --> 00:02:13,298
something interesting to do in crypto

43
00:02:09,820 --> 00:02:17,049
but it's those three guys in which I

44
00:02:13,299 --> 00:02:20,440
made an atom and that first proposed the

45
00:02:17,049 --> 00:02:22,290
first real scheme for public key

46
00:02:20,440 --> 00:02:25,359
cryptography cryptography and we know

47
00:02:22,290 --> 00:02:27,670
this scheme RSA is based on the hardest

48
00:02:25,360 --> 00:02:32,200
a factoring hard numbers and it's one of

49
00:02:27,670 --> 00:02:34,640
the most used today and we've come a

50
00:02:32,200 --> 00:02:36,109
long way since then so there's

51
00:02:34,640 --> 00:02:37,880
this whole field of public key

52
00:02:36,110 --> 00:02:41,050
cryptography that allows us to do plenty

53
00:02:37,880 --> 00:02:43,730
of things like online shopping or just

54
00:02:41,050 --> 00:02:45,370
allow us to to have a trust

55
00:02:43,730 --> 00:02:48,319
infrastructure on the Internet

56
00:02:45,370 --> 00:02:51,080
so the things we can do is a basically

57
00:02:48,319 --> 00:02:53,630
exchange public encryption digital

58
00:02:51,080 --> 00:02:56,270
signature is certificates you know who

59
00:02:53,630 --> 00:02:58,459
you're talking to over the web and it's

60
00:02:56,270 --> 00:03:00,610
based on very simple ideas is that you

61
00:02:58,459 --> 00:03:02,780
have some problems that are harder to

62
00:03:00,610 --> 00:03:04,910
that are easy to compute in one

63
00:03:02,780 --> 00:03:07,610
direction but that are hard to inverse

64
00:03:04,910 --> 00:03:09,489
so for example this is the example that

65
00:03:07,610 --> 00:03:12,020
you take on on the Wikipedia page for

66
00:03:09,489 --> 00:03:15,530
for diffie-hellman key exchange

67
00:03:12,020 --> 00:03:19,900
you have a listen Bob that want to share

68
00:03:15,530 --> 00:03:23,030
a common seek secret but they only know

69
00:03:19,900 --> 00:03:26,720
there's a public paint color yellow and

70
00:03:23,030 --> 00:03:30,080
they each have their their secret colors

71
00:03:26,720 --> 00:03:32,390
which is a blue so let's say red and

72
00:03:30,080 --> 00:03:34,670
blue and by mixing those colors together

73
00:03:32,390 --> 00:03:36,320
it it first makes the yellow and their

74
00:03:34,670 --> 00:03:38,750
secret color then they exchange the

75
00:03:36,320 --> 00:03:41,840
resulting colors and then they mix them

76
00:03:38,750 --> 00:03:44,000
again and now at the end they get the

77
00:03:41,840 --> 00:03:47,079
same color which is a common secret and

78
00:03:44,000 --> 00:03:51,350
the assumption is that is hard given

79
00:03:47,079 --> 00:03:54,620
this shade of blue to recover the two

80
00:03:51,350 --> 00:03:59,090
colors that we use to obtain that shade

81
00:03:54,620 --> 00:04:03,280
of blue and so there are many ways of

82
00:03:59,090 --> 00:04:05,860
mixed mixing paint that we can think of

83
00:04:03,280 --> 00:04:07,940
the most popular is our factoring and

84
00:04:05,860 --> 00:04:10,040
discrete log the speed log is what's

85
00:04:07,940 --> 00:04:13,040
used basically in a elliptic curve

86
00:04:10,040 --> 00:04:15,530
cryptography and really any so-called

87
00:04:13,040 --> 00:04:17,630
trapdoor permutation allows us to do

88
00:04:15,530 --> 00:04:20,029
this kind of cryptography these kind of

89
00:04:17,630 --> 00:04:21,769
tasks and I'm gonna talk a bit more

90
00:04:20,029 --> 00:04:24,190
about what what I mean by a trapdoor

91
00:04:21,769 --> 00:04:27,140
permutation later in the talk

92
00:04:24,190 --> 00:04:29,090
so now fast forward today we have plenty

93
00:04:27,140 --> 00:04:33,650
of devices all connected to the internet

94
00:04:29,090 --> 00:04:35,419
and these devices all use cryptography

95
00:04:33,650 --> 00:04:38,690
in some way or any other if I have a

96
00:04:35,419 --> 00:04:40,760
SmartWatch that's receiving updates from

97
00:04:38,690 --> 00:04:45,110
software updates from let's say the

98
00:04:40,760 --> 00:04:45,900
Apple server then Happel has to the code

99
00:04:45,110 --> 00:04:48,780
that's updated

100
00:04:45,900 --> 00:04:52,198
- this watches is authenticated you said

101
00:04:48,780 --> 00:04:53,698
a public key certificate and even the

102
00:04:52,199 --> 00:04:56,789
server that pushes the update is

103
00:04:53,699 --> 00:05:00,900
authenticated using public key

104
00:04:56,789 --> 00:05:03,270
cryptography so what we have essentially

105
00:05:00,900 --> 00:05:06,388
is a chain of trust where we have this

106
00:05:03,270 --> 00:05:10,650
certificate emitting authority that that

107
00:05:06,389 --> 00:05:15,780
we all know and entrust and which was

108
00:05:10,650 --> 00:05:17,940
this certificate authority to to verify

109
00:05:15,780 --> 00:05:19,859
the identity of Apple before issuing a

110
00:05:17,940 --> 00:05:22,620
certificate for apple and then i po can

111
00:05:19,860 --> 00:05:24,300
each verify the identity of Facebook

112
00:05:22,620 --> 00:05:26,820
before issuing a certificate to Facebook

113
00:05:24,300 --> 00:05:31,919
and Facebook and then sign its binaries

114
00:05:26,820 --> 00:05:34,169
using its certificate but then what

115
00:05:31,919 --> 00:05:37,698
happens is that if you have really

116
00:05:34,169 --> 00:05:41,580
powerful factors that are capable of

117
00:05:37,699 --> 00:05:43,889
breaking the root of this of this chain

118
00:05:41,580 --> 00:05:46,198
then everything collapses and that's one

119
00:05:43,889 --> 00:05:51,720
of the threats of quantum computing it

120
00:05:46,199 --> 00:05:54,599
allows you to it would allow you to emit

121
00:05:51,720 --> 00:05:58,830
fake certificates and just fake any

122
00:05:54,599 --> 00:06:01,050
essentially any identity on the web so

123
00:05:58,830 --> 00:06:04,050
now a bit more about come to keep

124
00:06:01,050 --> 00:06:06,120
computing of course I'm referring to

125
00:06:04,050 --> 00:06:09,330
Shor's algorithm which we'll come to in

126
00:06:06,120 --> 00:06:11,729
a few slides but beforehand I'd like to

127
00:06:09,330 --> 00:06:13,440
give you really brief overview of what

128
00:06:11,729 --> 00:06:17,010
kind of quantum computing is about and

129
00:06:13,440 --> 00:06:20,460
what it can and cannot do so quantum

130
00:06:17,010 --> 00:06:22,680
computing the really the most important

131
00:06:20,460 --> 00:06:25,349
aspect is that you can have a

132
00:06:22,680 --> 00:06:27,530
superposition of a lot of states of

133
00:06:25,349 --> 00:06:30,810
quantum states so let's say I take a

134
00:06:27,530 --> 00:06:33,719
photon I make it go through some kind of

135
00:06:30,810 --> 00:06:36,120
semi reflective mirror and then that

136
00:06:33,720 --> 00:06:42,020
that mirror lets the photon through on

137
00:06:36,120 --> 00:06:42,020
one side if it's let's in horizontal

138
00:06:42,110 --> 00:06:47,330
polarization and it goes to the other

139
00:06:45,000 --> 00:06:51,210
side to the bottom side if it's in

140
00:06:47,330 --> 00:06:54,029
vertical polarization and of course I'm

141
00:06:51,210 --> 00:06:57,210
not a physicist so I only catch this in

142
00:06:54,029 --> 00:06:59,229
a very high overview but what the thing

143
00:06:57,210 --> 00:07:02,789
is about quantum cryptography about it

144
00:06:59,229 --> 00:07:05,498
about quantum mechanics is that this

145
00:07:02,789 --> 00:07:07,389
photon can be not in either of those

146
00:07:05,499 --> 00:07:11,229
places but either to two places at the

147
00:07:07,389 --> 00:07:14,949
same time but another very important

148
00:07:11,229 --> 00:07:17,199
aspect is that you cannot see the photon

149
00:07:14,949 --> 00:07:20,050
at both places at the same time you have

150
00:07:17,199 --> 00:07:25,240
to as soon as you look at it it

151
00:07:20,050 --> 00:07:28,779
materializes either in a right eye or in

152
00:07:25,240 --> 00:07:31,419
the left eye but not in not involve why

153
00:07:28,779 --> 00:07:34,479
is this useful for computing well you

154
00:07:31,419 --> 00:07:37,240
can think of those two positions as if

155
00:07:34,479 --> 00:07:40,240
the photon is on the upper upper row it

156
00:07:37,240 --> 00:07:44,710
even codes zero if it's at the bottom I

157
00:07:40,240 --> 00:07:47,289
mean it it encodes the one and I can put

158
00:07:44,710 --> 00:07:52,989
those true okay quantum computer do some

159
00:07:47,289 --> 00:07:55,479
very in intensive compute function so a

160
00:07:52,990 --> 00:07:58,199
function f that's very intensive to

161
00:07:55,479 --> 00:08:01,360
compute an input zero and even port one

162
00:07:58,199 --> 00:08:04,689
so now because I have those two pads

163
00:08:01,360 --> 00:08:07,960
that are computing in parallel I get a

164
00:08:04,689 --> 00:08:10,330
superposition of the two outcomes but

165
00:08:07,960 --> 00:08:13,659
then again I can only look I can only

166
00:08:10,330 --> 00:08:16,750
get one of the two outcomes because as

167
00:08:13,659 --> 00:08:18,849
soon as I try to look at those photons

168
00:08:16,750 --> 00:08:21,659
one is one is going to disappear it's

169
00:08:18,849 --> 00:08:24,759
gonna collapse on one of the footpaths

170
00:08:21,659 --> 00:08:27,250
but it's still useful to compute some

171
00:08:24,759 --> 00:08:29,520
functions in superposition one of the

172
00:08:27,250 --> 00:08:31,629
things that you can do and that's use

173
00:08:29,520 --> 00:08:35,049
that the main tool behind Shor's

174
00:08:31,629 --> 00:08:36,909
algorithm is that you can have this kind

175
00:08:35,049 --> 00:08:39,010
of State this is a notation for for

176
00:08:36,909 --> 00:08:41,588
saying that it's a superposition over

177
00:08:39,010 --> 00:08:45,069
all input A's and here my function is

178
00:08:41,589 --> 00:08:48,220
just the modular exponent modulo n right

179
00:08:45,069 --> 00:08:50,199
for some basis X and I can put that

180
00:08:48,220 --> 00:08:53,170
through a procedure that's called

181
00:08:50,199 --> 00:08:55,750
quantum Fourier transform and then I get

182
00:08:53,170 --> 00:08:58,089
some output those are probabilities of

183
00:08:55,750 --> 00:09:00,760
observing those value so here you can

184
00:08:58,089 --> 00:09:03,190
think of it as I have a probability 1/2

185
00:09:00,760 --> 00:09:04,750
of seeing the photon here and 1/2 of

186
00:09:03,190 --> 00:09:06,490
seeing the photon here but now I have

187
00:09:04,750 --> 00:09:09,920
many values and I have some

188
00:09:06,490 --> 00:09:12,920
probabilities of observing some values

189
00:09:09,920 --> 00:09:16,010
and so what UFT tells me is that these

190
00:09:12,920 --> 00:09:17,930
peaks in probabilities are going to be

191
00:09:16,010 --> 00:09:19,430
related to the structure of the function

192
00:09:17,930 --> 00:09:21,620
in this case it's going to be the period

193
00:09:19,430 --> 00:09:24,019
of the function so this is a function

194
00:09:21,620 --> 00:09:29,480
but since it's modern it repeats itself

195
00:09:24,019 --> 00:09:31,639
every so often and so the the amount of

196
00:09:29,480 --> 00:09:38,360
steps after which it repeats itself is

197
00:09:31,639 --> 00:09:40,399
given by one of those Peaks and each of

198
00:09:38,360 --> 00:09:45,769
those basically is a multiple of that

199
00:09:40,399 --> 00:09:48,380
value right so now that we have QFT we

200
00:09:45,769 --> 00:09:51,820
can introduce Shor's factoring algorithm

201
00:09:48,380 --> 00:09:54,740
which is conceptually really simple so

202
00:09:51,820 --> 00:09:58,790
the algorithm in a nutshell is you just

203
00:09:54,740 --> 00:10:00,350
pick a random value lower than the one

204
00:09:58,790 --> 00:10:05,630
you try to factorize over here you want

205
00:10:00,350 --> 00:10:07,760
to factorize n and classically like

206
00:10:05,630 --> 00:10:11,300
without the company quantum computer you

207
00:10:07,760 --> 00:10:13,910
know how to factor n if you know a value

208
00:10:11,300 --> 00:10:17,899
are such that you take X to the exponent

209
00:10:13,910 --> 00:10:20,839
R and it it's congruent to one modulo n

210
00:10:17,899 --> 00:10:22,310
so this is using a classical algorithm

211
00:10:20,839 --> 00:10:27,350
if you know this R then you can factor

212
00:10:22,310 --> 00:10:29,180
you can factor n efficiently so I've

213
00:10:27,350 --> 00:10:31,339
already briefly mentioned that that this

214
00:10:29,180 --> 00:10:33,019
function f is a periodic function and

215
00:10:31,339 --> 00:10:34,970
the quantum Fourier transform gives you

216
00:10:33,019 --> 00:10:37,699
essentially the period of this function

217
00:10:34,970 --> 00:10:40,070
so you just apply quantum Fourier

218
00:10:37,699 --> 00:10:42,709
transform it gives you the R with good

219
00:10:40,070 --> 00:10:46,279
probability and then you can factor

220
00:10:42,709 --> 00:10:47,869
using the classical algorithm and so we

221
00:10:46,279 --> 00:10:49,760
saw in the last slide that we have we

222
00:10:47,870 --> 00:10:51,709
had many peaks and some of them are good

223
00:10:49,760 --> 00:10:54,529
values for R some of them are bad values

224
00:10:51,709 --> 00:10:56,119
but the essence is that you have a good

225
00:10:54,529 --> 00:10:58,600
enough probability and you can just

226
00:10:56,120 --> 00:11:01,100
repeat that process enough time and

227
00:10:58,600 --> 00:11:04,220
you're gonna find this R eventually and

228
00:11:01,100 --> 00:11:05,949
the time the the the amount of times

229
00:11:04,220 --> 00:11:08,810
that you have to repeat this process is

230
00:11:05,949 --> 00:11:11,319
polynomial in the number of bits of n so

231
00:11:08,810 --> 00:11:14,888
it's a polynomial algorithm to factor

232
00:11:11,319 --> 00:11:17,149
large numbers I so this breaks

233
00:11:14,889 --> 00:11:19,610
cryptography essentially once we have a

234
00:11:17,149 --> 00:11:21,410
computer on computer everything that we

235
00:11:19,610 --> 00:11:24,769
use as photography on the Internet

236
00:11:21,410 --> 00:11:27,740
is threatened so the aftermath of this

237
00:11:24,769 --> 00:11:30,019
is that factoring discrete logarithm so

238
00:11:27,740 --> 00:11:31,910
I I just showed you the algorithm for

239
00:11:30,019 --> 00:11:34,310
factoring but it's the same essentially

240
00:11:31,910 --> 00:11:36,199
for discrete log except it's a bit more

241
00:11:34,310 --> 00:11:38,089
conflict actually it's a lot more

242
00:11:36,199 --> 00:11:41,810
complicated so I didn't have time to

243
00:11:38,089 --> 00:11:44,029
present it so those tasks are easy for

244
00:11:41,810 --> 00:11:45,258
quantum computer and we rely on the

245
00:11:44,029 --> 00:11:47,420
hardness of those tasks to do

246
00:11:45,259 --> 00:11:50,870
cryptography so public encryption and

247
00:11:47,420 --> 00:11:52,729
digital signatures are broken in a world

248
00:11:50,870 --> 00:11:56,870
where a quantum a scalable quantum

249
00:11:52,730 --> 00:11:59,930
computer exists so this includes RSA de

250
00:11:56,870 --> 00:12:03,199
feel men a digital signature is anything

251
00:11:59,930 --> 00:12:05,959
basically on elliptic curves symmetric

252
00:12:03,199 --> 00:12:07,639
cryptography is okay so Shor's algorithm

253
00:12:05,959 --> 00:12:10,279
doesn't tell us anything about symmetric

254
00:12:07,639 --> 00:12:12,250
key crypto and there is another

255
00:12:10,279 --> 00:12:16,430
algorithm that has an impact on those

256
00:12:12,250 --> 00:12:18,019
namely shores Grover's algorithm but you

257
00:12:16,430 --> 00:12:20,589
can basically ignore it by just doubling

258
00:12:18,019 --> 00:12:24,769
the key size so those are arc okay and

259
00:12:20,589 --> 00:12:27,350
hash functions also are not threatened

260
00:12:24,769 --> 00:12:30,500
by Shor's algorithm a bit back over but

261
00:12:27,350 --> 00:12:32,889
it it's at the same time so you just

262
00:12:30,500 --> 00:12:38,000
have to increase the security parameter

263
00:12:32,889 --> 00:12:40,399
so now we're ready to look at what what

264
00:12:38,000 --> 00:12:44,329
we do when we can't do factoring we

265
00:12:40,399 --> 00:12:46,370
can't do diffie-hellman discrete log we

266
00:12:44,329 --> 00:12:49,189
have to propose new problems that are

267
00:12:46,370 --> 00:12:52,970
hard and this is what post quantum

268
00:12:49,189 --> 00:12:56,000
crypto is about so I mentioned briefly

269
00:12:52,970 --> 00:12:58,579
trapdoor permutations at the beginning a

270
00:12:56,000 --> 00:13:00,769
shorter permutation essentially is

271
00:12:58,579 --> 00:13:02,719
essentially a function that's easy to

272
00:13:00,769 --> 00:13:04,880
compute in one direction so if I if I

273
00:13:02,720 --> 00:13:08,630
have X I can compute f of X very easily

274
00:13:04,880 --> 00:13:11,420
but it's hard to invert so if I have an

275
00:13:08,630 --> 00:13:14,240
output Y and I want to know which which

276
00:13:11,420 --> 00:13:17,120
X produced this output Y this should be

277
00:13:14,240 --> 00:13:21,439
hard to compute on a classical and a

278
00:13:17,120 --> 00:13:23,750
quantum computer but what a trapdoor

279
00:13:21,439 --> 00:13:26,480
function means is that if you know some

280
00:13:23,750 --> 00:13:31,430
other input which we named a trapdoor

281
00:13:26,480 --> 00:13:33,079
then this is easy to invert and so one

282
00:13:31,430 --> 00:13:35,449
way to think of this would be if you

283
00:13:33,079 --> 00:13:37,670
have a Lego set it's very easy to base

284
00:13:35,450 --> 00:13:40,100
ambolyn lego set to obtain the pieces

285
00:13:37,670 --> 00:13:44,329
but if i have the pieces it's very hard

286
00:13:40,100 --> 00:13:46,190
to to reassemble that set unless I have

287
00:13:44,330 --> 00:13:48,200
the the instructions that tell me

288
00:13:46,190 --> 00:13:51,920
step-by-step how to reconstruct it and

289
00:13:48,200 --> 00:13:53,540
not all of the functions that not all of

290
00:13:51,920 --> 00:13:56,209
the problems that are used for post

291
00:13:53,540 --> 00:13:58,520
Compton crypto are of this form but if

292
00:13:56,210 --> 00:14:01,070
if you have a function of this form then

293
00:13:58,520 --> 00:14:02,780
it's it's easy to do public key crypto

294
00:14:01,070 --> 00:14:07,520
because your public key is this function

295
00:14:02,780 --> 00:14:08,260
and I encrypt this way too to obtain a

296
00:14:07,520 --> 00:14:11,810
ciphertext

297
00:14:08,260 --> 00:14:14,540
decrypting is hard unless I know the

298
00:14:11,810 --> 00:14:16,520
secret key which is the trapdoor to my

299
00:14:14,540 --> 00:14:18,469
function right so this is give this

300
00:14:16,520 --> 00:14:23,270
gives you essentially this is

301
00:14:18,470 --> 00:14:25,790
essentially a abstraction of what we

302
00:14:23,270 --> 00:14:30,050
want to look for to do public key

303
00:14:25,790 --> 00:14:32,930
cryptography so now the problems on

304
00:14:30,050 --> 00:14:35,089
which post quantum cryptography reside

305
00:14:32,930 --> 00:14:37,550
so the first one is lattice based

306
00:14:35,090 --> 00:14:41,870
cryptography Zoar a lattice is basically

307
00:14:37,550 --> 00:14:44,930
a set of point in vector in a vector

308
00:14:41,870 --> 00:14:47,900
space and those points so are specified

309
00:14:44,930 --> 00:14:50,420
by a basis B 1 and B 2 so the points are

310
00:14:47,900 --> 00:14:52,189
all the linear combinations of B 1 and B

311
00:14:50,420 --> 00:14:54,319
2 and they span the whole space so now

312
00:14:52,190 --> 00:14:57,530
you can you can think of those points as

313
00:14:54,320 --> 00:15:00,350
going in continuing to infinity in each

314
00:14:57,530 --> 00:15:03,980
direction and of course so this is an

315
00:15:00,350 --> 00:15:07,160
example in 2d but in practice you want

316
00:15:03,980 --> 00:15:12,080
to have many dimensions so that the

317
00:15:07,160 --> 00:15:13,010
problems become becomes big right so

318
00:15:12,080 --> 00:15:16,070
there are two problems that are

319
00:15:13,010 --> 00:15:17,960
conjectured to be hard for lattices the

320
00:15:16,070 --> 00:15:20,420
first one is to find the shortest vector

321
00:15:17,960 --> 00:15:22,910
in the lattice so in this case the

322
00:15:20,420 --> 00:15:25,459
Shorter's vector of Miletus starting

323
00:15:22,910 --> 00:15:28,069
from the origin it's just this this

324
00:15:25,460 --> 00:15:34,160
vector at this point and this is B 1

325
00:15:28,070 --> 00:15:35,690
minus 2 B 2 and the other problem is to

326
00:15:34,160 --> 00:15:37,430
find the closest vector problem so I

327
00:15:35,690 --> 00:15:39,400
have a point that's not on the lattice

328
00:15:37,430 --> 00:15:41,900
but that's between points of the lattice

329
00:15:39,400 --> 00:15:43,400
let's say this green point and I want to

330
00:15:41,900 --> 00:15:44,220
find the closest point which is the red

331
00:15:43,400 --> 00:15:46,110
one

332
00:15:44,220 --> 00:15:49,980
so those are the problems that are

333
00:15:46,110 --> 00:15:51,750
conjecture to be hard but they are

334
00:15:49,980 --> 00:15:54,090
problems that are easy to solve if you

335
00:15:51,750 --> 00:15:57,420
have a good basis so so a good basis

336
00:15:54,090 --> 00:16:00,900
would be like the rectilinear basis that

337
00:15:57,420 --> 00:16:02,640
we all know like vectors that are

338
00:16:00,900 --> 00:16:05,939
essentially orthogonal to each other and

339
00:16:02,640 --> 00:16:07,770
that are pretty pretty short and a bad

340
00:16:05,940 --> 00:16:10,170
basis would be vectors that are very

341
00:16:07,770 --> 00:16:11,189
long and very close to each other so if

342
00:16:10,170 --> 00:16:13,920
they all point in the same direction

343
00:16:11,190 --> 00:16:16,260
then it's hard to know how to combine

344
00:16:13,920 --> 00:16:20,729
them to obtain the shortest vector in

345
00:16:16,260 --> 00:16:22,020
the lattice so how do you do encryption

346
00:16:20,730 --> 00:16:23,910
with that well actually you can do

347
00:16:22,020 --> 00:16:27,000
signature also but I'm just gonna show

348
00:16:23,910 --> 00:16:27,680
you how to encrypt so the encourage the

349
00:16:27,000 --> 00:16:30,150
idea

350
00:16:27,680 --> 00:16:31,709
there are many schemes also proposed for

351
00:16:30,150 --> 00:16:34,980
this problem but I'm I'm just gonna

352
00:16:31,710 --> 00:16:38,010
prepare a present one to get the

353
00:16:34,980 --> 00:16:39,690
intuition so the idea is you pop your

354
00:16:38,010 --> 00:16:41,970
private key is a good lattice and you

355
00:16:39,690 --> 00:16:45,090
probably kiss a bad lattice for for that

356
00:16:41,970 --> 00:16:47,640
for the closest vector problem your

357
00:16:45,090 --> 00:16:48,720
message is a point on the lattice so you

358
00:16:47,640 --> 00:16:50,370
have to find a way to encode the

359
00:16:48,720 --> 00:16:53,940
specific message as a point on the

360
00:16:50,370 --> 00:16:55,680
lattice to encrypt you take that point

361
00:16:53,940 --> 00:16:57,900
let's say the red point is my message so

362
00:16:55,680 --> 00:16:59,370
to encrypt I'm gonna add a random noise

363
00:16:57,900 --> 00:17:01,740
vector that's gonna push it in a

364
00:16:59,370 --> 00:17:02,690
direction so now here the green point is

365
00:17:01,740 --> 00:17:04,950
my cypher text

366
00:17:02,690 --> 00:17:07,260
so my cypher text I send it over a

367
00:17:04,950 --> 00:17:09,569
public channel with the public key is

368
00:17:07,260 --> 00:17:11,760
hard to decrypt because I have to find

369
00:17:09,569 --> 00:17:13,829
the closest point but with the private

370
00:17:11,760 --> 00:17:16,050
key which is the good basis this problem

371
00:17:13,829 --> 00:17:18,540
becomes easy I can find the red point

372
00:17:16,050 --> 00:17:23,069
that's closest to my cypher text and I

373
00:17:18,540 --> 00:17:25,649
can decrypt the message right so this is

374
00:17:23,069 --> 00:17:27,359
lattice based cryptography the next one

375
00:17:25,650 --> 00:17:29,760
we're going to look at is hash based

376
00:17:27,359 --> 00:17:33,510
crypto hash risk you've toad is only

377
00:17:29,760 --> 00:17:36,540
signatures for it and it's based on a

378
00:17:33,510 --> 00:17:40,230
scheme that's called Lamport one time

379
00:17:36,540 --> 00:17:41,790
signatures I'm sorry I have to go a bit

380
00:17:40,230 --> 00:17:44,360
quicker because I'm running out of time

381
00:17:41,790 --> 00:17:47,430
so Lamport one time signatures are

382
00:17:44,360 --> 00:17:49,409
signatures that that are only secured

383
00:17:47,430 --> 00:17:52,530
for one instantiation of the other

384
00:17:49,410 --> 00:17:54,690
signature the work as follows so let's

385
00:17:52,530 --> 00:17:57,149
say I want to assign a message as three

386
00:17:54,690 --> 00:17:58,410
bits then my private key is going to be

387
00:17:57,150 --> 00:18:02,460
three pair

388
00:17:58,410 --> 00:18:03,990
of values and which value I choose for

389
00:18:02,460 --> 00:18:06,090
the signature is gonna depend on those

390
00:18:03,990 --> 00:18:08,130
bits so the first bit is one so I kept

391
00:18:06,090 --> 00:18:09,959
to think it the second value here the

392
00:18:08,130 --> 00:18:11,940
first value here because the second bit

393
00:18:09,960 --> 00:18:13,820
is 0 and the third value because it will

394
00:18:11,940 --> 00:18:16,920
read the second value of the third pair

395
00:18:13,820 --> 00:18:19,500
because the third bit is 1 and this is

396
00:18:16,920 --> 00:18:21,120
my signature so we can already see what

397
00:18:19,500 --> 00:18:23,520
it's called one time signature because I

398
00:18:21,120 --> 00:18:27,479
leaked essentially half of my key by

399
00:18:23,520 --> 00:18:30,060
signing by signing a message and to

400
00:18:27,480 --> 00:18:32,970
verify well I'm gonna use the following

401
00:18:30,060 --> 00:18:35,790
public key which in which each of those

402
00:18:32,970 --> 00:18:39,660
wise is a hash function applied to that

403
00:18:35,790 --> 00:18:42,860
X so like this and I'm gonna take the

404
00:18:39,660 --> 00:18:45,750
corresponding wise and check if the X

405
00:18:42,860 --> 00:18:48,360
hash to the same way that's in my public

406
00:18:45,750 --> 00:18:52,590
key so I can verify using that public

407
00:18:48,360 --> 00:18:54,540
key signatures because those X's are

408
00:18:52,590 --> 00:18:56,459
part of the the signature but can I

409
00:18:54,540 --> 00:18:59,040
cannot Forge a signature because I don't

410
00:18:56,460 --> 00:19:01,290
know this this other X why I couldn't

411
00:18:59,040 --> 00:19:03,090
sign a 0 0 1 for example because I don't

412
00:19:01,290 --> 00:19:06,030
know this X unless I know the private

413
00:19:03,090 --> 00:19:07,770
key and to know this X without the

414
00:19:06,030 --> 00:19:11,870
private key I'll have I'd have to find a

415
00:19:07,770 --> 00:19:15,300
pre-image to this y 0 1 and this is a

416
00:19:11,870 --> 00:19:18,629
this is a problem that's hard if you

417
00:19:15,300 --> 00:19:20,430
have good as functions of course you get

418
00:19:18,630 --> 00:19:23,610
the problem that you can only sign once

419
00:19:20,430 --> 00:19:26,400
with a given key so you have any keys

420
00:19:23,610 --> 00:19:30,320
that you need to take care of if you out

421
00:19:26,400 --> 00:19:32,400
put some thousands of ash per seconds

422
00:19:30,320 --> 00:19:34,649
thousands of signatures per second is

423
00:19:32,400 --> 00:19:39,030
gonna be a problem there are some

424
00:19:34,650 --> 00:19:41,730
solutions to that which is to use a tree

425
00:19:39,030 --> 00:19:44,070
Merkle tree structure to generate many

426
00:19:41,730 --> 00:19:45,540
keys from a given key but the problem is

427
00:19:44,070 --> 00:19:48,540
that those schemes are stateful so you

428
00:19:45,540 --> 00:19:51,149
have to remember what's so yeah you have

429
00:19:48,540 --> 00:19:53,280
proceeded to generate many keys and you

430
00:19:51,150 --> 00:19:55,380
have to remember what's the key that

431
00:19:53,280 --> 00:19:59,420
you're gonna do you're gonna use next

432
00:19:55,380 --> 00:20:02,910
and there's also a scheme that uses

433
00:19:59,420 --> 00:20:06,300
pseudo-random number generator for for

434
00:20:02,910 --> 00:20:10,410
those key generations so this is hash

435
00:20:06,300 --> 00:20:11,740
based signatures the next one again

436
00:20:10,410 --> 00:20:13,980
sorry I have to go quickly to

437
00:20:11,740 --> 00:20:16,380
those I didn't leave myself enough time

438
00:20:13,980 --> 00:20:21,030
there's the other one are based on

439
00:20:16,380 --> 00:20:23,620
multi-view multivariate polynomials so

440
00:20:21,030 --> 00:20:26,590
the problem is the following I have this

441
00:20:23,620 --> 00:20:28,928
polynomial so it's multivariate Croat

442
00:20:26,590 --> 00:20:31,090
rhetoric polynomial so multivariate

443
00:20:28,929 --> 00:20:34,090
because I have many variables quadratic

444
00:20:31,090 --> 00:20:38,860
because I have at most two variables per

445
00:20:34,090 --> 00:20:41,709
term to my power is at most two and the

446
00:20:38,860 --> 00:20:44,199
the assumption is that it's hard in

447
00:20:41,710 --> 00:20:46,840
general to inverse those polynomials so

448
00:20:44,200 --> 00:20:49,480
I have a given output it's hard to find

449
00:20:46,840 --> 00:20:54,399
an expert and input X 1 X 2 that's going

450
00:20:49,480 --> 00:20:55,809
to give the specific output and how do

451
00:20:54,400 --> 00:20:58,210
you base encryption on that what are you

452
00:20:55,809 --> 00:21:00,520
going to choose a function that's

453
00:20:58,210 --> 00:21:04,050
basically a collection of polynomials

454
00:21:00,520 --> 00:21:06,910
and I'm gonna encrypt the message by

455
00:21:04,050 --> 00:21:09,010
well I know I'm going too fast so those

456
00:21:06,910 --> 00:21:11,530
are all polynomials that are that are

457
00:21:09,010 --> 00:21:15,429
supposed to be hard to invert in general

458
00:21:11,530 --> 00:21:16,928
but I choose them so that I know how to

459
00:21:15,429 --> 00:21:19,059
invert them I choose them with a

460
00:21:16,929 --> 00:21:22,210
specific structure that tells me how to

461
00:21:19,059 --> 00:21:26,170
invert them so I take a collection of

462
00:21:22,210 --> 00:21:28,960
those and then to hide this structure

463
00:21:26,170 --> 00:21:31,990
that gives me how to efficiently invert

464
00:21:28,960 --> 00:21:33,910
them I'm gonna hide it with two other

465
00:21:31,990 --> 00:21:36,880
polynomials that are also easy to invert

466
00:21:33,910 --> 00:21:38,530
and gangam I'm going to a sandwich that

467
00:21:36,880 --> 00:21:43,510
function between those two other

468
00:21:38,530 --> 00:21:46,210
functions so this is my public key the

469
00:21:43,510 --> 00:21:48,070
sandwiched function and so this is a

470
00:21:46,210 --> 00:21:51,250
general instance of a problem so this is

471
00:21:48,070 --> 00:21:52,899
just from the from the attackers point

472
00:21:51,250 --> 00:21:54,940
of view this is a random polynomial and

473
00:21:52,900 --> 00:21:59,590
the goal is to invert that polynomial

474
00:21:54,940 --> 00:22:03,429
but from the from the harness from the

475
00:21:59,590 --> 00:22:05,500
person that has the the the private key

476
00:22:03,429 --> 00:22:07,960
which is those the description of those

477
00:22:05,500 --> 00:22:11,410
three functions then it's easy to to

478
00:22:07,960 --> 00:22:14,380
involve so how do you do encryption with

479
00:22:11,410 --> 00:22:18,420
that well to encrypt you apply P on in

480
00:22:14,380 --> 00:22:21,280
input so the input is a as let's say

481
00:22:18,420 --> 00:22:22,870
your message is a bunch of variables

482
00:22:21,280 --> 00:22:26,080
with some given values

483
00:22:22,870 --> 00:22:28,600
to encrypt you just apply P and not to

484
00:22:26,080 --> 00:22:31,840
decrypt given this private key which is

485
00:22:28,600 --> 00:22:35,730
s F and T you just invert those three

486
00:22:31,840 --> 00:22:35,730
polynomials and you get the clear text

487
00:22:35,790 --> 00:22:41,800
from that procedure so it with the

488
00:22:38,620 --> 00:22:45,189
private key you can invert efficiently

489
00:22:41,800 --> 00:22:49,090
but without it you cannot and finally

490
00:22:45,190 --> 00:22:50,950
the last problem post quantum problem

491
00:22:49,090 --> 00:22:53,230
that I'm going to show you is code base

492
00:22:50,950 --> 00:22:55,540
cryptography code base cryptography is

493
00:22:53,230 --> 00:22:56,950
based on a error correcting code and

494
00:22:55,540 --> 00:22:59,680
it's based more specifically on the

495
00:22:56,950 --> 00:23:03,370
harness the hardness of the coding of

496
00:22:59,680 --> 00:23:06,700
random linear code so I can specify a

497
00:23:03,370 --> 00:23:08,860
code base by by a matrix G so this is an

498
00:23:06,700 --> 00:23:10,030
example of the Hamming code for those of

499
00:23:08,860 --> 00:23:12,070
you who don't know much about a

500
00:23:10,030 --> 00:23:15,730
recreating code so this is the Hamming

501
00:23:12,070 --> 00:23:19,179
code and to encode it for this word 0 1

502
00:23:15,730 --> 00:23:22,060
1 I multiply the world times the matrix

503
00:23:19,180 --> 00:23:27,220
G so the first part is the identity so I

504
00:23:22,060 --> 00:23:29,590
recover my word 0 1 1 but then the

505
00:23:27,220 --> 00:23:34,330
second part is what we call parity bits

506
00:23:29,590 --> 00:23:37,090
so here I have 1 1 0 so I'm gonna have 1

507
00:23:34,330 --> 00:23:40,149
+ 0 1 times 0 plus 1 times 1 plus 1

508
00:23:37,090 --> 00:23:43,929
times 0 times 1 so I'm gonna get 1 and

509
00:23:40,150 --> 00:23:47,830
for the other part it's 0 1 1 so I'm get

510
00:23:43,930 --> 00:23:51,190
0 times 0 plus 1 times 1 plus 1 times 1

511
00:23:47,830 --> 00:23:53,470
but it's it's an it's an XOR the

512
00:23:51,190 --> 00:23:56,200
addition so I'm gonna get 0 and these

513
00:23:53,470 --> 00:23:58,840
are my parity bits that that can tell me

514
00:23:56,200 --> 00:24:00,520
how to detect an error but I don't know

515
00:23:58,840 --> 00:24:03,189
with this code I cannot correct an error

516
00:24:00,520 --> 00:24:06,160
I can only detect one but in general you

517
00:24:03,190 --> 00:24:11,800
know you have this code space and those

518
00:24:06,160 --> 00:24:13,960
green dots are my code words and I

519
00:24:11,800 --> 00:24:16,180
encrypt I take this one anchor if it's

520
00:24:13,960 --> 00:24:18,490
not the right word I take this word I

521
00:24:16,180 --> 00:24:22,330
send it in the code space to add some

522
00:24:18,490 --> 00:24:25,690
redundancy to it and then I sent it over

523
00:24:22,330 --> 00:24:29,020
a noisy channel which is gonna introduce

524
00:24:25,690 --> 00:24:32,809
some noise which is my red dot and to

525
00:24:29,020 --> 00:24:36,799
recover the original message I have to

526
00:24:32,809 --> 00:24:38,529
decode so sense and the noisy message to

527
00:24:36,799 --> 00:24:40,789
the the green dot which is a code word

528
00:24:38,529 --> 00:24:43,399
and then I can recover the original

529
00:24:40,789 --> 00:24:46,039
message so this is not an encoding that

530
00:24:43,399 --> 00:24:47,629
that's secure this is not encryption

531
00:24:46,039 --> 00:24:51,740
this is I think we done didn't see to

532
00:24:47,629 --> 00:24:53,990
correct errors but you can build a

533
00:24:51,740 --> 00:24:55,789
crypto system on that your private key

534
00:24:53,990 --> 00:25:00,259
is an efficient decoder for for let's

535
00:24:55,789 --> 00:25:02,360
say this a recollecting code and the

536
00:25:00,259 --> 00:25:04,850
public key is a random generator matrix

537
00:25:02,360 --> 00:25:09,678
or random matrix of this form for the

538
00:25:04,850 --> 00:25:11,869
same code space so the the hypothesis is

539
00:25:09,679 --> 00:25:14,360
that that is hard in general to recover

540
00:25:11,869 --> 00:25:16,189
the green dot from the red dot if you

541
00:25:14,360 --> 00:25:20,449
don't know if you don't have an

542
00:25:16,190 --> 00:25:23,269
efficient decoder already so to do to

543
00:25:20,450 --> 00:25:25,490
build a public key cryptosystem from

544
00:25:23,269 --> 00:25:29,720
that you take the clear text you send it

545
00:25:25,490 --> 00:25:32,179
as a codeword so you you take your W you

546
00:25:29,720 --> 00:25:34,639
you encode it as C and then you add

547
00:25:32,179 --> 00:25:37,549
errors so adding a rose is encrypting

548
00:25:34,639 --> 00:25:39,678
anybody can generate code words with the

549
00:25:37,549 --> 00:25:42,559
random generator the generator matrix

550
00:25:39,679 --> 00:25:46,639
the public key anybody can add noise so

551
00:25:42,559 --> 00:25:48,799
anybody can encrypt but only only with

552
00:25:46,639 --> 00:25:52,549
the efficient decoder can I remove the

553
00:25:48,799 --> 00:25:55,940
errors and recover the original field

554
00:25:52,549 --> 00:25:59,269
text so this is the idea behind code

555
00:25:55,940 --> 00:26:01,820
based cryptography so the main takeaways

556
00:25:59,269 --> 00:26:03,169
of a talk is that public key the public

557
00:26:01,820 --> 00:26:05,240
infrastructure that we know and love

558
00:26:03,169 --> 00:26:08,570
today on the Internet is threatened by

559
00:26:05,240 --> 00:26:09,740
quantum computing there are alternatives

560
00:26:08,570 --> 00:26:13,340
for the problems that are breaking

561
00:26:09,740 --> 00:26:17,539
broken so RSA fokin discrete log is

562
00:26:13,340 --> 00:26:19,639
broken but you can replace them by some

563
00:26:17,539 --> 00:26:21,879
of the problems that represented such as

564
00:26:19,639 --> 00:26:23,830
the lattice based crypto which is

565
00:26:21,879 --> 00:26:26,799
currently one of the most flexible

566
00:26:23,830 --> 00:26:28,999
alternatives hash based crypto so I

567
00:26:26,799 --> 00:26:30,470
indicated in parenthesis that it sold

568
00:26:28,999 --> 00:26:32,480
well all these a good thing in

569
00:26:30,470 --> 00:26:35,619
cryptography it means that it hasn't

570
00:26:32,480 --> 00:26:37,850
been broken since its invention in 70s

571
00:26:35,619 --> 00:26:40,428
multivariate cryptography is pretty fast

572
00:26:37,850 --> 00:26:43,090
it's useful for embedded devices

573
00:26:40,429 --> 00:26:45,560
code base crypto also it's pretty old

574
00:26:43,090 --> 00:26:49,070
there's been schemes that have been

575
00:26:45,560 --> 00:26:53,929
proposed a long time ago and there are

576
00:26:49,070 --> 00:26:55,909
other more recent proposals well recent

577
00:26:53,930 --> 00:26:59,810
and some other roles that I didn't have

578
00:26:55,910 --> 00:27:01,490
time to talk about your to take away is

579
00:26:59,810 --> 00:27:05,179
that we have to act now to implement

580
00:27:01,490 --> 00:27:07,850
post Compton crypto to standardize it

581
00:27:05,180 --> 00:27:12,020
and Christian is going to talk a bit

582
00:27:07,850 --> 00:27:14,870
about that in the next talk and also I'd

583
00:27:12,020 --> 00:27:17,389
like to finish by citing miquellee Mosca

584
00:27:14,870 --> 00:27:20,209
from the University of Waterloo and he

585
00:27:17,390 --> 00:27:22,820
uses this this equation a lot of time it

586
00:27:20,210 --> 00:27:24,350
says if X is if X plus y is greater than

587
00:27:22,820 --> 00:27:26,210
said then then we're in trouble

588
00:27:24,350 --> 00:27:29,389
and what is what are those variables

589
00:27:26,210 --> 00:27:30,490
well X is the time that your data needs

590
00:27:29,390 --> 00:27:35,600
to stay secure

591
00:27:30,490 --> 00:27:40,250
y is the time that it takes to implement

592
00:27:35,600 --> 00:27:42,830
post quantum crypto and Z is the time

593
00:27:40,250 --> 00:27:46,250
that it takes until we have a quantum

594
00:27:42,830 --> 00:27:49,460
computer capable of breaking RSA so if

595
00:27:46,250 --> 00:27:52,880
it takes more time to replace the

596
00:27:49,460 --> 00:27:55,610
infrastructure and keep the data secure

597
00:27:52,880 --> 00:27:58,070
X years then it takes time to build a

598
00:27:55,610 --> 00:28:00,199
quantum computer then the data that

599
00:27:58,070 --> 00:28:03,620
that's protected by this system is going

600
00:28:00,200 --> 00:28:05,630
to be it's going to be compromised all

601
00:28:03,620 --> 00:28:12,728
right so this is it thank you

602
00:28:05,630 --> 00:28:12,729
[Applause]

