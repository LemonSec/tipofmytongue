1
00:00:00,030 --> 00:00:05,490
all right so let's get started it's my

2
00:00:02,340 --> 00:00:11,580
pleasure to present John Carver go for

3
00:00:05,490 --> 00:00:13,290
it and so good morning everyone so my

4
00:00:11,580 --> 00:00:15,360
name is John Calvi and this talk is

5
00:00:13,290 --> 00:00:17,130
about how to build multi architecture

6
00:00:15,360 --> 00:00:19,710
desert summer and this is a team work

7
00:00:17,130 --> 00:00:21,960
with my colleagues Nicola and Cedric so

8
00:00:19,710 --> 00:00:23,730
first thing first were we we are

9
00:00:21,960 --> 00:00:26,609
software developers working for a small

10
00:00:23,730 --> 00:00:28,470
company called PNF software and our main

11
00:00:26,609 --> 00:00:30,539
activities to develop jab which is a

12
00:00:28,470 --> 00:00:33,420
reverse engineering tool so to give you

13
00:00:30,539 --> 00:00:35,700
an idea in 2012 we released a version

14
00:00:33,420 --> 00:00:37,530
one the major version one of jab at the

15
00:00:35,700 --> 00:00:39,180
time it was only the compiler for

16
00:00:37,530 --> 00:00:42,030
Android application so it translates

17
00:00:39,180 --> 00:00:43,860
Android application back to Java code it

18
00:00:42,030 --> 00:00:45,870
comes with an attractive UI scripting

19
00:00:43,860 --> 00:00:47,820
engine so that the user can analyze the

20
00:00:45,870 --> 00:00:49,980
application and when a few years later

21
00:00:47,820 --> 00:00:52,320
we were this version 2 with the ability

22
00:00:49,980 --> 00:00:54,300
to decompile windows linux executables

23
00:00:52,320 --> 00:00:56,520
back to see code for bunch of

24
00:00:54,300 --> 00:00:59,280
architectures including x86 our MIPS and

25
00:00:56,520 --> 00:01:02,370
our 64 bits violence and when a few

26
00:00:59,280 --> 00:01:04,680
years just recently in 2018 we released

27
00:01:02,370 --> 00:01:06,990
version 3 which is also able to

28
00:01:04,680 --> 00:01:08,790
decompile non-native platforms for

29
00:01:06,990 --> 00:01:11,610
example ETA on contracts or webassembly

30
00:01:08,790 --> 00:01:13,350
modules so we really see Jeb as a tool

31
00:01:11,610 --> 00:01:16,979
but shooter or a user to analyze many

32
00:01:13,350 --> 00:01:18,539
different types of files and in this

33
00:01:16,979 --> 00:01:21,210
presentation I want to focus on one

34
00:01:18,540 --> 00:01:23,700
specific part of jab namely its native

35
00:01:21,210 --> 00:01:25,470
disassembler so the war disassembler can

36
00:01:23,700 --> 00:01:28,259
mean a few different things so what I'm

37
00:01:25,470 --> 00:01:29,970
talking about here is these awesome lot

38
00:01:28,259 --> 00:01:32,850
takes in input an executable file

39
00:01:29,970 --> 00:01:34,679
compiled by a compiler so air is a x86

40
00:01:32,850 --> 00:01:37,020
executable file a Roxxon type just by

41
00:01:34,680 --> 00:01:38,729
its road amp an extract of its Rotem and

42
00:01:37,020 --> 00:01:41,220
so with these assembler text with

43
00:01:38,729 --> 00:01:43,259
executable file input and it will tell

44
00:01:41,220 --> 00:01:46,590
you that this read bytes here these are

45
00:01:43,259 --> 00:01:48,329
executable code and this code constitute

46
00:01:46,590 --> 00:01:50,189
a routine routine is way equivalent of

47
00:01:48,329 --> 00:01:51,869
function in higher-level languages and

48
00:01:50,189 --> 00:01:54,809
the routine will be represented as a

49
00:01:51,869 --> 00:01:56,460
control flow graph so which is a graph

50
00:01:54,810 --> 00:01:58,350
aware of a nodes are called basic blocks

51
00:01:56,460 --> 00:02:01,079
and each basic block contains a series

52
00:01:58,350 --> 00:02:02,548
of machine instructions translated to

53
00:02:01,079 --> 00:02:04,350
assembly language and so named is

54
00:02:02,549 --> 00:02:06,240
assembler and then there are some edges

55
00:02:04,350 --> 00:02:08,128
between the nodes to represent the

56
00:02:06,240 --> 00:02:09,419
possible control flow graph so that is a

57
00:02:08,128 --> 00:02:11,640
somewhat area but this red bars

58
00:02:09,419 --> 00:02:13,470
correspond to this routine a while with

59
00:02:11,640 --> 00:02:15,239
green bytes here correspond to this

60
00:02:13,470 --> 00:02:17,070
routines so that's what kind of

61
00:02:15,240 --> 00:02:19,320
disassembler we are talking about here

62
00:02:17,070 --> 00:02:21,950
they produce a global disassemble view

63
00:02:19,320 --> 00:02:24,030
of a program with all routines that are

64
00:02:21,950 --> 00:02:26,040
present in the executable and the

65
00:02:24,030 --> 00:02:27,780
purpose of this view is to represent the

66
00:02:26,040 --> 00:02:30,690
possible ways the program could execute

67
00:02:27,780 --> 00:02:32,760
at run time and not that while it is an

68
00:02:30,690 --> 00:02:34,829
assembly based view so it was a semi

69
00:02:32,760 --> 00:02:36,600
language the translation of individual

70
00:02:34,830 --> 00:02:38,400
machine instruction to assembly language

71
00:02:36,600 --> 00:02:40,260
is just one of a feature there are many

72
00:02:38,400 --> 00:02:42,570
things needed by this assembler in order

73
00:02:40,260 --> 00:02:45,179
to produce with global view and speaking

74
00:02:42,570 --> 00:02:46,320
on that why do we need this assembler so

75
00:02:45,180 --> 00:02:48,270
first they are useful because they

76
00:02:46,320 --> 00:02:50,130
provide a foundation for automatic

77
00:02:48,270 --> 00:02:52,970
advanced analysis like the compilation

78
00:02:50,130 --> 00:02:54,900
to a level language like C or Java

79
00:02:52,970 --> 00:02:56,850
disassembler can also can answer

80
00:02:54,900 --> 00:02:59,220
questions like where is the code where

81
00:02:56,850 --> 00:03:01,590
are the data in an executable in which

82
00:02:59,220 --> 00:03:03,840
order instruction got executed that's a

83
00:03:01,590 --> 00:03:05,160
control flow over data are manipulated

84
00:03:03,840 --> 00:03:06,990
the data flow they also build

85
00:03:05,160 --> 00:03:08,940
abstractions useful for advanced

86
00:03:06,990 --> 00:03:10,440
analysis so by group instructions within

87
00:03:08,940 --> 00:03:12,840
routines within control flow graphs

88
00:03:10,440 --> 00:03:14,430
within basic blocks and I can also tell

89
00:03:12,840 --> 00:03:16,050
you that a certain series of bytes the

90
00:03:14,430 --> 00:03:18,840
string anniversaries of byte is viable

91
00:03:16,050 --> 00:03:21,510
so all this is needed for automatic

92
00:03:18,840 --> 00:03:23,400
advanced analysis but this assembler are

93
00:03:21,510 --> 00:03:25,170
also useful for manual analysis because

94
00:03:23,400 --> 00:03:26,850
the output can be directly understood by

95
00:03:25,170 --> 00:03:29,160
humans and in particular when the

96
00:03:26,850 --> 00:03:30,720
automatic advanced analysis fail but

97
00:03:29,160 --> 00:03:32,579
these assemblers are usually seen as

98
00:03:30,720 --> 00:03:35,130
providing the ground truth because they

99
00:03:32,580 --> 00:03:38,070
remain close to the machine so you might

100
00:03:35,130 --> 00:03:40,470
know as disassembler Ida Pro Deidre

101
00:03:38,070 --> 00:03:41,940
Vanowen in Jihad have to so all these

102
00:03:40,470 --> 00:03:44,160
tools they got their own disassembler

103
00:03:41,940 --> 00:03:46,290
engine within and in jab at the same

104
00:03:44,160 --> 00:03:47,970
thing we got our own disassemble engine

105
00:03:46,290 --> 00:03:50,400
that's the foundation for the

106
00:03:47,970 --> 00:03:52,620
computation we do so to give you an idea

107
00:03:50,400 --> 00:03:55,620
when we open a binary in shape we got a

108
00:03:52,620 --> 00:03:57,900
routine list that's the red red box

109
00:03:55,620 --> 00:03:59,580
you see all routine and for each routine

110
00:03:57,900 --> 00:04:01,650
varies its control flow graph in the

111
00:03:59,580 --> 00:04:03,000
orange block so that's the output of

112
00:04:01,650 --> 00:04:04,709
edges assembler the control flow graph

113
00:04:03,000 --> 00:04:06,660
and when the control flow graph is given

114
00:04:04,709 --> 00:04:08,280
to add a compiler pipeline which

115
00:04:06,660 --> 00:04:10,590
produced the C code but you can see at

116
00:04:08,280 --> 00:04:12,269
the bottom in blue but so in the

117
00:04:10,590 --> 00:04:14,549
translation in this plantation we focus

118
00:04:12,269 --> 00:04:16,709
on the DS assembler and so most of the

119
00:04:14,549 --> 00:04:18,418
logic of a DS assembler is architecture

120
00:04:16,709 --> 00:04:21,019
and opponent that is this exactly the

121
00:04:18,418 --> 00:04:23,580
same code for x86 of arm for example

122
00:04:21,019 --> 00:04:25,799
except for instruction passing and fury

123
00:04:23,580 --> 00:04:27,210
sticks are we described later and as I

124
00:04:25,800 --> 00:04:30,690
said before it can also power

125
00:04:27,210 --> 00:04:32,520
non-native God so in this in this

126
00:04:30,690 --> 00:04:34,259
plantation my intent is ready to first

127
00:04:32,520 --> 00:04:36,690
talk about the problem what makes this

128
00:04:34,259 --> 00:04:39,060
assembly are on several architectures

129
00:04:36,690 --> 00:04:40,139
and then describe the way we deal with

130
00:04:39,060 --> 00:04:41,099
those problems in Jeff

131
00:04:40,139 --> 00:04:42,810
so hopefully you don't need to be a

132
00:04:41,099 --> 00:04:45,000
reverse engineer to understand what I'm

133
00:04:42,810 --> 00:04:46,289
going to show you and hopefully will

134
00:04:45,000 --> 00:04:47,819
show you what what it looks like to

135
00:04:46,289 --> 00:04:49,680
develop a disassembler and why

136
00:04:47,819 --> 00:04:52,470
disassembling remains actually quite a

137
00:04:49,680 --> 00:04:53,970
complex problem and as a small

138
00:04:52,470 --> 00:04:55,889
disclaimer this isn't a night to be a

139
00:04:53,970 --> 00:04:57,870
research toward not a sales talk so I

140
00:04:55,889 --> 00:05:00,090
will show what what is the current

141
00:04:57,870 --> 00:05:01,740
working progress in Jeb and it's not

142
00:05:00,090 --> 00:05:05,789
intended to be a final best solution to

143
00:05:01,740 --> 00:05:08,039
this assembly so first things first I'm

144
00:05:05,789 --> 00:05:10,050
going to introduce a toy example but we

145
00:05:08,039 --> 00:05:12,630
are trying we will try to disassemble

146
00:05:10,050 --> 00:05:15,210
step by step in order to build some kind

147
00:05:12,630 --> 00:05:18,150
of intuition about what is disassembly

148
00:05:15,210 --> 00:05:20,280
and what makes it hard so we will start

149
00:05:18,150 --> 00:05:22,979
with this simple C code it's called

150
00:05:20,280 --> 00:05:24,780
secret see here is the main routine it

151
00:05:22,979 --> 00:05:26,340
checks if one argument was provided and

152
00:05:24,780 --> 00:05:28,409
if it's the case it calls another

153
00:05:26,340 --> 00:05:30,690
routine called secret our go with the

154
00:05:28,409 --> 00:05:33,030
argument pass in input as a string as so

155
00:05:30,690 --> 00:05:34,860
secret I'll go is here it computes to

156
00:05:33,030 --> 00:05:37,080
absorb between its argument string

157
00:05:34,860 --> 00:05:39,690
argument translated to an integer thanks

158
00:05:37,080 --> 00:05:41,609
to the a2i library routine and a

159
00:05:39,690 --> 00:05:44,130
constant name secret key that is the fan

160
00:05:41,610 --> 00:05:45,509
at the top so evolve illogical program

161
00:05:44,130 --> 00:05:47,490
is just to return the door of its

162
00:05:45,509 --> 00:05:51,330
argument with the constant if one

163
00:05:47,490 --> 00:05:53,280
augment was provided or 0 elsewhere now

164
00:05:51,330 --> 00:05:55,080
if we take this C code and compile it

165
00:05:53,280 --> 00:05:57,539
with Microsoft with just to do x86

166
00:05:55,080 --> 00:05:59,400
compiler without any optimization so we

167
00:05:57,539 --> 00:06:01,469
end up with a Windows executable we can

168
00:05:59,400 --> 00:06:03,330
execute it on a Windows machine and as

169
00:06:01,469 --> 00:06:05,340
well where no optimization this

170
00:06:03,330 --> 00:06:07,530
executable will be a literal translation

171
00:06:05,340 --> 00:06:09,090
of the C code and in particular the

172
00:06:07,530 --> 00:06:10,109
structure would be exactly the same as

173
00:06:09,090 --> 00:06:13,138
in the C code

174
00:06:10,110 --> 00:06:13,949
so now if we were to give this binary to

175
00:06:13,139 --> 00:06:15,419
a disassembler

176
00:06:13,949 --> 00:06:17,460
we expect that the output should be

177
00:06:15,419 --> 00:06:19,320
something like this there should be at

178
00:06:17,460 --> 00:06:21,479
least two routines one for main let's

179
00:06:19,320 --> 00:06:22,979
say routine one is main as in Maine

180
00:06:21,479 --> 00:06:24,570
there is a test on the number of

181
00:06:22,979 --> 00:06:26,219
arguments there should be two possible

182
00:06:24,570 --> 00:06:28,770
execution paths so the graph should have

183
00:06:26,219 --> 00:06:30,270
two paths for routine one and in one of

184
00:06:28,770 --> 00:06:32,849
his path there is a call to the so gone

185
00:06:30,270 --> 00:06:34,740
routine which is secret our go and so

186
00:06:32,849 --> 00:06:36,449
willing to we'll have a very simple

187
00:06:34,740 --> 00:06:38,370
graph with a call to a third routine

188
00:06:36,449 --> 00:06:39,880
eight why we don't know where hy is

189
00:06:38,370 --> 00:06:41,620
going to be to library routine

190
00:06:39,880 --> 00:06:43,840
might be an in an external file or in

191
00:06:41,620 --> 00:06:45,610
the same executable and then there would

192
00:06:43,840 --> 00:06:47,590
be exhort with our magic constant so

193
00:06:45,610 --> 00:06:49,900
that's a sketch of what we expect the

194
00:06:47,590 --> 00:06:52,150
output to look like if the input is an

195
00:06:49,900 --> 00:06:55,900
non-optimized executable coming from

196
00:06:52,150 --> 00:06:57,130
this C code so now the question is how

197
00:06:55,900 --> 00:06:59,049
do we get there Auto but I would

198
00:06:57,130 --> 00:07:00,909
transform the Windows executable into

199
00:06:59,050 --> 00:07:02,830
this global disassemble view with these

200
00:07:00,910 --> 00:07:04,570
two routines how do we build the box in

201
00:07:02,830 --> 00:07:06,940
the middle so first there are a few

202
00:07:04,570 --> 00:07:09,460
things that we need to clarify but we

203
00:07:06,940 --> 00:07:12,100
need to have actually to disassemble the

204
00:07:09,460 --> 00:07:14,080
first one is that we need a executables

205
00:07:12,100 --> 00:07:16,030
usually comes within executable file

206
00:07:14,080 --> 00:07:18,849
formats if you are Windows it's a P file

207
00:07:16,030 --> 00:07:21,309
link on Linux would be elf macro on Mac

208
00:07:18,850 --> 00:07:23,200
so this executable files formats they

209
00:07:21,310 --> 00:07:25,960
provide necessary information for the

210
00:07:23,200 --> 00:07:28,300
disassembler and for example if we give

211
00:07:25,960 --> 00:07:30,700
our Windows executable to a pea pastor

212
00:07:28,300 --> 00:07:33,640
the P power will decompose the structure

213
00:07:30,700 --> 00:07:35,229
of a file and provide an output first a

214
00:07:33,640 --> 00:07:36,849
memory mapping that is it will tell you

215
00:07:35,230 --> 00:07:39,100
where the bytes in the file are located

216
00:07:36,850 --> 00:07:41,020
in memory this mapping is usually

217
00:07:39,100 --> 00:07:42,760
divided into sections or segments and

218
00:07:41,020 --> 00:07:44,169
also it will provide us the entry point

219
00:07:42,760 --> 00:07:46,900
that is the address of a very first

220
00:07:44,170 --> 00:07:48,940
instruction executed at runtime and also

221
00:07:46,900 --> 00:07:50,530
some information on the architecture for

222
00:07:48,940 --> 00:07:52,480
which we file was compiled for in our

223
00:07:50,530 --> 00:07:54,789
case it for x86 it's a little endian

224
00:07:52,480 --> 00:07:57,400
architecture so all this is going to be

225
00:07:54,790 --> 00:08:01,690
the input of a disassembler and not

226
00:07:57,400 --> 00:08:02,919
verified itself when the unearthing that

227
00:08:01,690 --> 00:08:04,570
we need we need the ability to

228
00:08:02,920 --> 00:08:06,010
disassemble individual machine

229
00:08:04,570 --> 00:08:07,930
instruction so let's call this

230
00:08:06,010 --> 00:08:09,250
instruction these assemblers so

231
00:08:07,930 --> 00:08:11,380
instruction is a some loss taking input

232
00:08:09,250 --> 00:08:13,360
a binary blob and they produce an output

233
00:08:11,380 --> 00:08:15,100
or passed instruction and this passed

234
00:08:13,360 --> 00:08:16,900
instruction usually contains the memory

235
00:08:15,100 --> 00:08:19,270
which is the assembly representation of

236
00:08:16,900 --> 00:08:20,979
the operation the operands register

237
00:08:19,270 --> 00:08:23,500
memory addresses used by the instruction

238
00:08:20,980 --> 00:08:26,140
and then some of information like for

239
00:08:23,500 --> 00:08:30,040
example what are the next instruction to

240
00:08:26,140 --> 00:08:32,590
execute so for example if we take 53 g55

241
00:08:30,040 --> 00:08:34,210
in exodus email to x86 instruction

242
00:08:32,590 --> 00:08:37,450
disassembler it will tell us that it's a

243
00:08:34,210 --> 00:08:39,250
push and but it uses the EBP register as

244
00:08:37,450 --> 00:08:41,500
an operand and that the next instruction

245
00:08:39,250 --> 00:08:43,270
to execute is before true but is the

246
00:08:41,500 --> 00:08:47,020
instruction just following this one in

247
00:08:43,270 --> 00:08:49,030
memory then if we give our four bytes to

248
00:08:47,020 --> 00:08:50,680
these four bytes to our instruction to

249
00:08:49,030 --> 00:08:53,189
the sampler it tell us that it's a sub

250
00:08:50,680 --> 00:08:54,870
if not equal with two operands

251
00:08:53,190 --> 00:08:56,670
as you will register PC register and the

252
00:08:54,870 --> 00:08:58,560
next instruction is with also a file for

253
00:08:56,670 --> 00:08:59,910
when if we take the same 4 bytes and

254
00:08:58,560 --> 00:09:03,029
give them to a MIPS instruction

255
00:08:59,910 --> 00:09:05,069
disassembler it's an ogre instruction so

256
00:09:03,029 --> 00:09:06,810
it's branch if equal to 0 and there are

257
00:09:05,069 --> 00:09:08,490
two operands a register and an offset

258
00:09:06,810 --> 00:09:10,319
and as it is the conditional branch

259
00:09:08,490 --> 00:09:12,000
there are two possible next instruction

260
00:09:10,319 --> 00:09:13,920
before true if the condition is false

261
00:09:12,000 --> 00:09:17,129
over branch target if the condition is

262
00:09:13,920 --> 00:09:18,540
true so we are going to need

263
00:09:17,129 --> 00:09:19,980
instructions assembler for all the

264
00:09:18,540 --> 00:09:22,079
architectures we want to disassembly of

265
00:09:19,980 --> 00:09:23,639
course and not that the instruction is

266
00:09:22,079 --> 00:09:25,529
assembler to not tell us anything about

267
00:09:23,639 --> 00:09:27,420
what the instruction is doing it's just

268
00:09:25,529 --> 00:09:32,160
providing a past representation that is

269
00:09:27,420 --> 00:09:34,229
human readable a kind of so but for folk

270
00:09:32,160 --> 00:09:35,639
for the sake of the argument in this toy

271
00:09:34,230 --> 00:09:37,110
example we are going to assume that we

272
00:09:35,639 --> 00:09:39,209
have a P parser and we have an

273
00:09:37,110 --> 00:09:41,040
instruction in hand an x86 instruction

274
00:09:39,209 --> 00:09:42,719
is assembler and now we come back to the

275
00:09:41,040 --> 00:09:46,319
question or we get from the windows

276
00:09:42,720 --> 00:09:48,689
binary to the disassembled view so first

277
00:09:46,319 --> 00:09:50,579
intuitive strategy but you might think

278
00:09:48,689 --> 00:09:52,110
of is that we could start from the entry

279
00:09:50,579 --> 00:09:54,209
point because it is provided to us by

280
00:09:52,110 --> 00:09:55,709
the capacitor and just try to follow the

281
00:09:54,209 --> 00:09:57,899
code try to follow the control flow

282
00:09:55,709 --> 00:10:02,040
discovery routines and build the graph

283
00:09:57,899 --> 00:10:04,170
as we go so let's try this so here on

284
00:10:02,040 --> 00:10:05,939
the Left I represented the input memory

285
00:10:04,170 --> 00:10:07,680
mapping so that's the secret exit mapped

286
00:10:05,939 --> 00:10:09,449
in memory the first column is the

287
00:10:07,680 --> 00:10:12,120
address in memory when there are the

288
00:10:09,449 --> 00:10:13,949
bytes located at this memory we have an

289
00:10:12,120 --> 00:10:16,019
arrow on the next instruction to

290
00:10:13,949 --> 00:10:17,370
disassemble a pointer to an extension to

291
00:10:16,019 --> 00:10:19,019
the next instruction to disassemble

292
00:10:17,370 --> 00:10:21,269
represented by the arrow and it's

293
00:10:19,019 --> 00:10:23,639
initially set at the entry point of a

294
00:10:21,269 --> 00:10:25,110
program so we start from there and we

295
00:10:23,639 --> 00:10:27,120
give a first few bytes to the x86

296
00:10:25,110 --> 00:10:28,050
instruction disassemble it tell us that

297
00:10:27,120 --> 00:10:30,660
it's a push EBP

298
00:10:28,050 --> 00:10:33,329
so we add this new instruction to a new

299
00:10:30,660 --> 00:10:35,009
graph into a new block and but the

300
00:10:33,329 --> 00:10:37,319
instruction is a Samra also tell us that

301
00:10:35,009 --> 00:10:39,269
the next instruction to execute should

302
00:10:37,319 --> 00:10:41,250
be before true one following this one so

303
00:10:39,269 --> 00:10:43,439
we just increment the pointer and we go

304
00:10:41,250 --> 00:10:45,660
on we do it again another instruction we

305
00:10:43,439 --> 00:10:47,160
add it to back run block before 2 is the

306
00:10:45,660 --> 00:10:49,469
next instruction we do it again and

307
00:10:47,160 --> 00:10:51,779
again and we end up disassembling a

308
00:10:49,470 --> 00:10:54,089
conditional branch so GN sets and for

309
00:10:51,779 --> 00:10:56,399
jump if not 0 so that's a branch so we

310
00:10:54,089 --> 00:10:57,930
end the current block it's a conditional

311
00:10:56,399 --> 00:11:00,000
branch of I will be to put to possible

312
00:10:57,930 --> 00:11:00,628
execution paths at this point so we have

313
00:11:00,000 --> 00:11:02,430
a choice to make

314
00:11:00,629 --> 00:11:04,319
we have 2 possible addresses to analyze

315
00:11:02,430 --> 00:11:06,479
next before true if the condition is

316
00:11:04,319 --> 00:11:08,069
false over branch target so

317
00:11:06,480 --> 00:11:10,050
here I decided to continue analyzing

318
00:11:08,070 --> 00:11:12,180
before true so we store the target

319
00:11:10,050 --> 00:11:13,979
address for later analysis in a bucket

320
00:11:12,180 --> 00:11:15,660
at the bottom right so that's an address

321
00:11:13,980 --> 00:11:16,940
within this routine that we store to

322
00:11:15,660 --> 00:11:19,680
come back later

323
00:11:16,940 --> 00:11:21,540
fast forward we analyze the fault rule

324
00:11:19,680 --> 00:11:24,120
which is a sum all instruction and at

325
00:11:21,540 --> 00:11:25,829
some point we end up is assembling x86

326
00:11:24,120 --> 00:11:27,930
called instruction so this instruction

327
00:11:25,829 --> 00:11:30,930
is usually used to implement routine

328
00:11:27,930 --> 00:11:32,339
calls so we have a same situation here

329
00:11:30,930 --> 00:11:34,229
there are two possible addresses to

330
00:11:32,339 --> 00:11:36,029
analyze there is a call target it's an

331
00:11:34,230 --> 00:11:37,620
over routine and there is a fall true

332
00:11:36,029 --> 00:11:39,870
when we will eventually come back from

333
00:11:37,620 --> 00:11:41,550
the call so we do the same thing we

334
00:11:39,870 --> 00:11:44,220
continue analyzing before true and we

335
00:11:41,550 --> 00:11:45,329
stop call target for later analysis but

336
00:11:44,220 --> 00:11:46,769
we store it in a different bucket

337
00:11:45,329 --> 00:11:48,449
because it's not the same type of

338
00:11:46,769 --> 00:11:52,139
address it's another routine it's not an

339
00:11:48,449 --> 00:11:53,790
address within this routine we do we do

340
00:11:52,139 --> 00:11:55,589
what is assembly again and then we end

341
00:11:53,790 --> 00:11:57,959
up disassembling a read instruction so

342
00:11:55,589 --> 00:11:59,760
read stamps in x86 for return and so

343
00:11:57,959 --> 00:12:02,550
return to the color routine so at the

344
00:11:59,760 --> 00:12:03,930
end of the current block so we have an

345
00:12:02,550 --> 00:12:05,639
over address to analyze within this

346
00:12:03,930 --> 00:12:07,109
routine so we go on we continue this as

347
00:12:05,639 --> 00:12:09,060
something on the next address that was

348
00:12:07,110 --> 00:12:12,480
previously stored at the bottom right

349
00:12:09,060 --> 00:12:14,609
and finally we have no more addresses to

350
00:12:12,480 --> 00:12:16,199
analyze we have a complete CFG so the

351
00:12:14,610 --> 00:12:17,940
grunt graph is finished background

352
00:12:16,199 --> 00:12:19,949
control flow graph is terminated and we

353
00:12:17,940 --> 00:12:22,589
can't go on analyzing the next routine

354
00:12:19,949 --> 00:12:24,630
that was previously stored so fast

355
00:12:22,589 --> 00:12:27,209
forward we do it all again and then we

356
00:12:24,630 --> 00:12:29,160
end up with these two routines so

357
00:12:27,209 --> 00:12:31,380
routine one which is which this domain

358
00:12:29,160 --> 00:12:33,719
actually at as two possible execution

359
00:12:31,380 --> 00:12:37,050
paths one is calling the routine two and

360
00:12:33,720 --> 00:12:40,050
routine two as a one graph and there is

361
00:12:37,050 --> 00:12:41,819
a call and when there is XOR so I've

362
00:12:40,050 --> 00:12:43,889
left a few details out but you got vit

363
00:12:41,819 --> 00:12:47,130
what we have here is exactly what we

364
00:12:43,889 --> 00:12:49,230
expected so we produce what we expected

365
00:12:47,130 --> 00:12:51,000
with a simple recursive algorithm just

366
00:12:49,230 --> 00:12:53,550
by following the code and it seems that

367
00:12:51,000 --> 00:12:55,319
all the magic was in the instruction

368
00:12:53,550 --> 00:12:57,000
this assembler which was providing us in

369
00:12:55,319 --> 00:12:59,010
particular we control flow information

370
00:12:57,000 --> 00:13:00,600
for each instruction so it seems that if

371
00:12:59,010 --> 00:13:02,880
you want to be the disassembler all you

372
00:13:00,600 --> 00:13:04,589
need to do have is an instruction these

373
00:13:02,880 --> 00:13:07,740
assembler for a particular architectures

374
00:13:04,589 --> 00:13:09,269
you are targeting actually during this

375
00:13:07,740 --> 00:13:11,250
step by step disassembly we made a

376
00:13:09,269 --> 00:13:15,540
series of questionable assumptions and I

377
00:13:11,250 --> 00:13:17,189
will now describe some of them so the

378
00:13:15,540 --> 00:13:19,439
first assumption we made and you

379
00:13:17,189 --> 00:13:20,430
probably notice it is that when we were

380
00:13:19,439 --> 00:13:23,040
analyzing the corners

381
00:13:20,430 --> 00:13:24,870
action we assume that the call always

382
00:13:23,040 --> 00:13:26,880
returned to color we continue analyzing

383
00:13:24,870 --> 00:13:28,620
before true when we are not in routine

384
00:13:26,880 --> 00:13:30,630
one we continue now seeing before true

385
00:13:28,620 --> 00:13:33,000
as if a call would eventually return to

386
00:13:30,630 --> 00:13:35,339
the color but in reality there are a non

387
00:13:33,000 --> 00:13:37,410
returning call and there is no need to

388
00:13:35,339 --> 00:13:39,209
go far to find an example of that just

389
00:13:37,410 --> 00:13:40,890
looking at a Visual Studio C runtime

390
00:13:39,209 --> 00:13:42,930
code which is statically linked in our

391
00:13:40,890 --> 00:13:45,390
Windows executable there are calls to

392
00:13:42,930 --> 00:13:47,250
API is terminating the application so

393
00:13:45,390 --> 00:13:49,410
this call never returned to the caller

394
00:13:47,250 --> 00:13:51,000
and the compiler knows it so what he

395
00:13:49,410 --> 00:13:52,649
does it but invalid code just have to

396
00:13:51,000 --> 00:13:54,360
have a call in before true so here we

397
00:13:52,649 --> 00:13:56,040
can see an entry it's a software

398
00:13:54,360 --> 00:13:58,350
interrupt it should never get executed

399
00:13:56,040 --> 00:13:59,969
and the compiler knows it so for us as

400
00:13:58,350 --> 00:14:02,220
disassembler writer how do we know that

401
00:13:59,970 --> 00:14:03,930
exit process is never returning it's

402
00:14:02,220 --> 00:14:05,310
actually in the info prototype of a

403
00:14:03,930 --> 00:14:07,229
routine so if you look in the full at a

404
00:14:05,310 --> 00:14:08,969
full prototype in the error file there

405
00:14:07,230 --> 00:14:10,560
is an attribute before the class the

406
00:14:08,970 --> 00:14:13,620
prototype that tell us that this API

407
00:14:10,560 --> 00:14:15,300
never returns and not that returning

408
00:14:13,620 --> 00:14:17,089
void and being non returning up two

409
00:14:15,300 --> 00:14:19,620
different things

410
00:14:17,089 --> 00:14:21,600
another example are infinitely looping

411
00:14:19,620 --> 00:14:23,520
routines and once again it is an example

412
00:14:21,600 --> 00:14:25,650
coming from a classic compiler code this

413
00:14:23,520 --> 00:14:28,770
time GCC so this routine has no way to

414
00:14:25,650 --> 00:14:29,819
come back to a color because no way to

415
00:14:28,770 --> 00:14:31,800
come back to the color is just

416
00:14:29,820 --> 00:14:35,160
infinitely looping so it's non returning

417
00:14:31,800 --> 00:14:36,959
as well now if we think a bit about this

418
00:14:35,160 --> 00:14:38,910
so we need to identify this non

419
00:14:36,959 --> 00:14:40,469
returning course otherwise the CFG would

420
00:14:38,910 --> 00:14:43,410
be incorrect we need to cut the blocks

421
00:14:40,470 --> 00:14:45,870
just after the call for the non

422
00:14:43,410 --> 00:14:48,120
returning external API is for like exit

423
00:14:45,870 --> 00:14:49,800
process we can identify them from their

424
00:14:48,120 --> 00:14:51,630
names if we have access to a full

425
00:14:49,800 --> 00:14:54,660
prototype somewhere with a non returning

426
00:14:51,630 --> 00:14:56,459
attribute for VAR na no tuning internal

427
00:14:54,660 --> 00:14:58,199
routines for example imagine a small

428
00:14:56,459 --> 00:15:00,719
routine a wrapper just calling a non

429
00:14:58,200 --> 00:15:02,370
returning API we can identify them by

430
00:15:00,720 --> 00:15:04,230
analyzing the graph and if the graph has

431
00:15:02,370 --> 00:15:06,720
no returning blocks when it is no

432
00:15:04,230 --> 00:15:09,570
returning routine and this last bit

433
00:15:06,720 --> 00:15:11,190
brings an interesting situation we can

434
00:15:09,570 --> 00:15:13,470
only know an internal routing is non

435
00:15:11,190 --> 00:15:14,640
returning after having analyzed it but

436
00:15:13,470 --> 00:15:16,529
what if we are on the call instruction

437
00:15:14,640 --> 00:15:18,480
and we do not have analyze the target

438
00:15:16,529 --> 00:15:20,490
yet so we do not we do not know at this

439
00:15:18,480 --> 00:15:22,649
point if a target is warning or not no

440
00:15:20,490 --> 00:15:24,510
no Tony so we could stop analyzing the

441
00:15:22,649 --> 00:15:26,670
color just here and go analyzing the

442
00:15:24,510 --> 00:15:27,839
curry first but that could be tricky

443
00:15:26,670 --> 00:15:30,060
because we would have to maintain the

444
00:15:27,839 --> 00:15:31,709
color state and well it can be difficult

445
00:15:30,060 --> 00:15:32,760
it varies especially if there is a chain

446
00:15:31,709 --> 00:15:33,709
of course in the quarry

447
00:15:32,760 --> 00:15:35,270
possibly

448
00:15:33,710 --> 00:15:37,880
back to the color so that might be

449
00:15:35,270 --> 00:15:39,199
difficult to do and often we do not even

450
00:15:37,880 --> 00:15:40,939
know where the collie is they are

451
00:15:39,200 --> 00:15:42,530
non-trivial qahal well you don't move a

452
00:15:40,940 --> 00:15:45,260
target and I will show you example of

453
00:15:42,530 --> 00:15:47,660
that later so the way we deal with a

454
00:15:45,260 --> 00:15:49,730
tinge AB is about for the external ad is

455
00:15:47,660 --> 00:15:51,949
we have our own and C passer and we

456
00:15:49,730 --> 00:15:54,290
build what we call type libraries from

457
00:15:51,950 --> 00:15:55,940
compiler and SDK error files so these

458
00:15:54,290 --> 00:15:58,339
type libraries they provide for all the

459
00:15:55,940 --> 00:15:59,930
declared function in the error file they

460
00:15:58,340 --> 00:16:01,340
provide their full prototypes with the

461
00:15:59,930 --> 00:16:03,290
non returning attribute so we can just

462
00:16:01,340 --> 00:16:05,030
check for a name within the type library

463
00:16:03,290 --> 00:16:08,120
and we got type libraries for many major

464
00:16:05,030 --> 00:16:09,770
compilers and SDK for the internal

465
00:16:08,120 --> 00:16:11,660
routines so we try to identify the

466
00:16:09,770 --> 00:16:13,220
simple cases at the time there is a core

467
00:16:11,660 --> 00:16:15,310
instruction so for example we have a

468
00:16:13,220 --> 00:16:17,690
very simple banner we check to see if

469
00:16:15,310 --> 00:16:20,150
routine is just a trampoline so a small

470
00:16:17,690 --> 00:16:22,130
routine going to an API so it won't fall

471
00:16:20,150 --> 00:16:24,290
into a non returning API and if it's the

472
00:16:22,130 --> 00:16:26,390
case we stop analyzing at the core we

473
00:16:24,290 --> 00:16:29,000
don't go analyzing before true otherwise

474
00:16:26,390 --> 00:16:30,770
if it's more complex internal routine we

475
00:16:29,000 --> 00:16:32,720
terminate the color analysis first

476
00:16:30,770 --> 00:16:35,150
assuming the core will eventually return

477
00:16:32,720 --> 00:16:36,740
exactly like we did but then we analyze

478
00:16:35,150 --> 00:16:38,120
the Cawley and if you found out that the

479
00:16:36,740 --> 00:16:40,040
kollywood team the col routine is

480
00:16:38,120 --> 00:16:41,600
actually non returning we go back at the

481
00:16:40,040 --> 00:16:43,610
entry point of the color and we're

482
00:16:41,600 --> 00:16:45,020
analyze the color once again so it can

483
00:16:43,610 --> 00:16:46,700
be tricky because the first time we

484
00:16:45,020 --> 00:16:48,620
analyze the color we were missing some

485
00:16:46,700 --> 00:16:51,260
information we analyze a call as being

486
00:16:48,620 --> 00:16:54,890
returning and actually wasn't so it can

487
00:16:51,260 --> 00:16:56,900
be out to undo so what's it for non

488
00:16:54,890 --> 00:16:59,180
returning call another assumption we

489
00:16:56,900 --> 00:17:00,500
made during the step by step disassembly

490
00:16:59,180 --> 00:17:02,420
is that we assume that the routine

491
00:17:00,500 --> 00:17:05,060
control flow graphs are distinct and

492
00:17:02,420 --> 00:17:06,589
when we were done analyzing routine one

493
00:17:05,060 --> 00:17:07,819
when we are no more addresses to analyze

494
00:17:06,589 --> 00:17:09,829
we consider it done

495
00:17:07,819 --> 00:17:14,208
like if a CFG of routine one was

496
00:17:09,829 --> 00:17:16,339
terminated actually in reality there are

497
00:17:14,209 --> 00:17:18,410
examples of routine sharing code and

498
00:17:16,339 --> 00:17:20,780
once again just in Visual Studio C

499
00:17:18,410 --> 00:17:22,910
runtime where is this these two routines

500
00:17:20,780 --> 00:17:25,579
here so notice over routine on the left

501
00:17:22,910 --> 00:17:28,010
is directly branching within the routine

502
00:17:25,579 --> 00:17:29,810
on the right so why is it a problem

503
00:17:28,010 --> 00:17:31,370
let's say we pass routine on the right

504
00:17:29,810 --> 00:17:34,190
first so we build control flow graph

505
00:17:31,370 --> 00:17:35,870
it's basic blocks and then we discover

506
00:17:34,190 --> 00:17:37,610
routine - we pass it and we found out

507
00:17:35,870 --> 00:17:39,860
the razor branch within an existing

508
00:17:37,610 --> 00:17:41,540
basic block so the instruction in red

509
00:17:39,860 --> 00:17:43,820
here they are shared between the two

510
00:17:41,540 --> 00:17:46,000
routines so now the question is do a

511
00:17:43,820 --> 00:17:47,620
split

512
00:17:46,000 --> 00:17:49,210
duplicate this instruction into a new

513
00:17:47,620 --> 00:17:51,309
block and we build a separate control

514
00:17:49,210 --> 00:17:53,110
flow graph for within two or do we split

515
00:17:51,309 --> 00:17:55,710
the block and have a new basic block

516
00:17:53,110 --> 00:17:58,090
that we share between the two routines

517
00:17:55,710 --> 00:17:59,620
so first to think about this we have to

518
00:17:58,090 --> 00:18:00,970
remember that a basic block visual

519
00:17:59,620 --> 00:18:03,610
definition is that it is a series of

520
00:18:00,970 --> 00:18:05,679
instruction executed successively and as

521
00:18:03,610 --> 00:18:07,120
such it is a super useful abstraction

522
00:18:05,679 --> 00:18:08,620
for later analysis because we can

523
00:18:07,120 --> 00:18:10,330
process basic blocks without dealing

524
00:18:08,620 --> 00:18:12,340
with control flow changes there are no

525
00:18:10,330 --> 00:18:14,110
control flow changes within blocks there

526
00:18:12,340 --> 00:18:15,970
is an exception exceptions when we are

527
00:18:14,110 --> 00:18:18,280
exceptions but it breaks the flow within

528
00:18:15,970 --> 00:18:21,250
a block but let's forget about exception

529
00:18:18,280 --> 00:18:22,539
for now and so if we were to duplicate

530
00:18:21,250 --> 00:18:24,610
the instruction that means we will

531
00:18:22,539 --> 00:18:26,770
duplicate the instruction for a separate

532
00:18:24,610 --> 00:18:28,240
graph that means at at one address we

533
00:18:26,770 --> 00:18:29,710
will have different possible basic

534
00:18:28,240 --> 00:18:32,110
blocks and that would make the writing

535
00:18:29,710 --> 00:18:33,460
of later analysis error because we need

536
00:18:32,110 --> 00:18:35,439
to check all these blocks at the same

537
00:18:33,460 --> 00:18:37,690
time when we analyze when we are at a

538
00:18:35,440 --> 00:18:39,580
specific address so it's likely not a

539
00:18:37,690 --> 00:18:41,559
good idea to duplicate instructions if

540
00:18:39,580 --> 00:18:44,889
you want to keep the powerfulness of

541
00:18:41,559 --> 00:18:46,510
basic block as an abstraction so what we

542
00:18:44,890 --> 00:18:48,309
do in Jeb is that during that is

543
00:18:46,510 --> 00:18:50,260
assembling we build what we call

544
00:18:48,309 --> 00:18:52,090
skeletons basic blocks so these are just

545
00:18:50,260 --> 00:18:53,830
containers for instruction and they can

546
00:18:52,090 --> 00:18:56,020
be easily modified splited when we need

547
00:18:53,830 --> 00:18:58,090
and then once we all this assembly is

548
00:18:56,020 --> 00:18:59,860
finished we build the final control flow

549
00:18:58,090 --> 00:19:01,720
graphs with proper basic blocks and much

550
00:18:59,860 --> 00:19:03,280
more information inside so that means

551
00:19:01,720 --> 00:19:05,380
that in Jeb and address belongs to at

552
00:19:03,280 --> 00:19:07,210
most one basic block and basic basic

553
00:19:05,380 --> 00:19:08,559
blocks can be shared between routines so

554
00:19:07,210 --> 00:19:10,299
if we come back to the previous example

555
00:19:08,559 --> 00:19:11,918
in jabber control flow graph looks like

556
00:19:10,299 --> 00:19:14,470
this for these two routines there is a

557
00:19:11,919 --> 00:19:19,000
block that is shared between the two the

558
00:19:14,470 --> 00:19:22,000
two of them now another assumption that

559
00:19:19,000 --> 00:19:24,340
we made that is that branch instruction

560
00:19:22,000 --> 00:19:25,870
immediately immediately and basic blocks

561
00:19:24,340 --> 00:19:28,449
so when we were analyzing the

562
00:19:25,870 --> 00:19:30,729
conditional branch we ended our block at

563
00:19:28,450 --> 00:19:32,710
this conditional branch because that's

564
00:19:30,730 --> 00:19:34,270
the usual way we dissolve the thing to

565
00:19:32,710 --> 00:19:36,880
do with basic blocks but when there is a

566
00:19:34,270 --> 00:19:38,408
branch we are possible a control flow so

567
00:19:36,880 --> 00:19:41,289
you cut the block at this particular

568
00:19:38,409 --> 00:19:43,030
location there is one iconic cutter

569
00:19:41,289 --> 00:19:45,490
example of that if we look at over

570
00:19:43,030 --> 00:19:47,230
architectures on x86 and remember we

571
00:19:45,490 --> 00:19:49,570
went on to build a multi architecture

572
00:19:47,230 --> 00:19:51,789
this assembler so there is some MIPS

573
00:19:49,570 --> 00:19:53,799
code so don't need to understand the

574
00:19:51,789 --> 00:19:56,140
vast nib it I just want to focus on

575
00:19:53,799 --> 00:19:58,059
these two particular branches so these

576
00:19:56,140 --> 00:19:59,440
are conditional branches by branch if a

577
00:19:58,059 --> 00:20:02,168
certain condition is true

578
00:19:59,440 --> 00:20:04,840
otherwise they'd go to a fault room now

579
00:20:02,169 --> 00:20:07,809
the tricky part and MIPS is that this

580
00:20:04,840 --> 00:20:10,120
red instruction here they will always be

581
00:20:07,809 --> 00:20:12,070
executed whenever branch the previous

582
00:20:10,120 --> 00:20:13,928
branch is executed so even if a

583
00:20:12,070 --> 00:20:15,668
conditional branch is taken and go

584
00:20:13,929 --> 00:20:17,889
elsewhere the fall true instruction is

585
00:20:15,669 --> 00:20:19,720
executed so that's called branch delay

586
00:20:17,889 --> 00:20:23,229
slot it's actually a feature of MIPS but

587
00:20:19,720 --> 00:20:25,600
also on SPARC CPU and some DSP CPU also

588
00:20:23,230 --> 00:20:27,730
so the story beyond this video is quite

589
00:20:25,600 --> 00:20:29,408
interesting as you might know modern

590
00:20:27,730 --> 00:20:31,240
CPUs they execute instruction within a

591
00:20:29,409 --> 00:20:32,799
pipeline so that means that when they

592
00:20:31,240 --> 00:20:34,210
execute one instruction valid at the

593
00:20:32,799 --> 00:20:35,710
same time another instruction from

594
00:20:34,210 --> 00:20:37,750
memory so there is a problem with

595
00:20:35,710 --> 00:20:38,710
conditional branches because the CPU

596
00:20:37,750 --> 00:20:40,419
doesn't know yet

597
00:20:38,710 --> 00:20:42,220
if a condition is true or not so he has

598
00:20:40,419 --> 00:20:43,779
to make a guess to load every have a

599
00:20:42,220 --> 00:20:46,000
fall true instruction of a branch target

600
00:20:43,779 --> 00:20:48,070
instruction so if any focus is wrong

601
00:20:46,000 --> 00:20:49,389
there is a bubble and years to empty the

602
00:20:48,070 --> 00:20:52,000
pipeline basically and there is a loss

603
00:20:49,389 --> 00:20:53,500
of performance so to solve that in MIPS

604
00:20:52,000 --> 00:20:55,120
varies with daily spot the for

605
00:20:53,500 --> 00:20:57,129
instruction just after a branch is

606
00:20:55,120 --> 00:20:59,018
always executed so I don't if I don't

607
00:20:57,129 --> 00:21:00,699
have any guess to make and so it's the

608
00:20:59,019 --> 00:21:02,049
job of a compiler to actually use this

609
00:21:00,700 --> 00:21:03,970
data slot and put some useful

610
00:21:02,049 --> 00:21:05,620
instruction with inside so sometimes the

611
00:21:03,970 --> 00:21:07,779
compiler has no use of address code it

612
00:21:05,620 --> 00:21:09,219
just button up sometimes actually as a

613
00:21:07,779 --> 00:21:12,100
use for a distorted but a valid

614
00:21:09,220 --> 00:21:14,440
instruction within with the red spot so

615
00:21:12,100 --> 00:21:16,418
for us from the decimal perspective what

616
00:21:14,440 --> 00:21:18,279
doesn't mean let's focus on this

617
00:21:16,419 --> 00:21:20,049
particular block here so where is the

618
00:21:18,279 --> 00:21:21,549
conditional branch here so we have to

619
00:21:20,049 --> 00:21:23,350
cut somewhere a basic block because

620
00:21:21,549 --> 00:21:27,158
there are two possible control flow

621
00:21:23,350 --> 00:21:28,719
paths remember that a basic block is a

622
00:21:27,159 --> 00:21:30,549
series of instruction executed

623
00:21:28,720 --> 00:21:32,110
successively so that means that the

624
00:21:30,549 --> 00:21:33,759
daily spot belongs to the same block as

625
00:21:32,110 --> 00:21:36,039
we branch because he is executed with a

626
00:21:33,759 --> 00:21:37,870
branch but if we cut just after the

627
00:21:36,039 --> 00:21:39,850
daily slot that means but we have now

628
00:21:37,870 --> 00:21:41,258
branch instruction in the middle of

629
00:21:39,850 --> 00:21:42,399
basic blocks and that's basically

630
00:21:41,259 --> 00:21:43,990
breaking one of the most common

631
00:21:42,399 --> 00:21:46,360
assumption on control flow graph and

632
00:21:43,990 --> 00:21:48,789
basic blocks that mean about his way end

633
00:21:46,360 --> 00:21:50,918
on branches so our first idea would be

634
00:21:48,789 --> 00:21:53,590
to try to avoid what to avoid that

635
00:21:50,919 --> 00:21:55,600
situation a funny way to to still have

636
00:21:53,590 --> 00:21:58,418
the branches in last position in blocks

637
00:21:55,600 --> 00:22:00,668
so first might think that a CFG is just

638
00:21:58,419 --> 00:22:02,590
a representation so we might we can play

639
00:22:00,669 --> 00:22:05,590
with it what if we simply revert the

640
00:22:02,590 --> 00:22:07,178
instruction order if we do that we

641
00:22:05,590 --> 00:22:09,070
actually break the order of expression

642
00:22:07,179 --> 00:22:11,860
evaluation because the branch condition

643
00:22:09,070 --> 00:22:13,139
should must be evaluated first so in

644
00:22:11,860 --> 00:22:15,389
this example here

645
00:22:13,140 --> 00:22:16,770
to a graph of a visible register which

646
00:22:15,390 --> 00:22:18,690
is you that the condition in your branch

647
00:22:16,770 --> 00:22:20,940
is now set to 2 1

648
00:22:18,690 --> 00:22:22,950
thanks to the Li which is the delay slot

649
00:22:20,940 --> 00:22:25,830
so it's no more a conditional branch if

650
00:22:22,950 --> 00:22:26,280
we revert vv2 instructions so that's not

651
00:22:25,830 --> 00:22:28,560
working

652
00:22:26,280 --> 00:22:30,420
another idea will be ok let's create

653
00:22:28,560 --> 00:22:31,919
some kind of artificial instruction but

654
00:22:30,420 --> 00:22:34,440
groups together the branch and the delay

655
00:22:31,920 --> 00:22:37,440
slot so we still have a branch in last

656
00:22:34,440 --> 00:22:39,600
position it's actually legal to have a

657
00:22:37,440 --> 00:22:41,340
branch directly coming from elsewhere on

658
00:22:39,600 --> 00:22:42,929
the daily slot instruction so with

659
00:22:41,340 --> 00:22:45,959
visual plantation we cannot represent

660
00:22:42,930 --> 00:22:47,730
that so it's not working as well so as

661
00:22:45,960 --> 00:22:49,950
far as I know there are no shortcuts so

662
00:22:47,730 --> 00:22:51,540
aim at what we do in jab we we we allow

663
00:22:49,950 --> 00:22:53,670
branch instruction to me in the middle

664
00:22:51,540 --> 00:22:55,230
of basic box and that's the job of job

665
00:22:53,670 --> 00:22:57,060
instruction these assemblers to provide

666
00:22:55,230 --> 00:22:58,590
a number of delays lot for each branch

667
00:22:57,060 --> 00:23:00,600
instruction because actually that could

668
00:22:58,590 --> 00:23:02,939
be more than one having just one little

669
00:23:00,600 --> 00:23:04,350
slot instruction is just one feature of

670
00:23:02,940 --> 00:23:08,850
the architecture that's the depth of a

671
00:23:04,350 --> 00:23:10,770
pipeline so to give you an idea there is

672
00:23:08,850 --> 00:23:12,300
a snippet of meat assembly and the

673
00:23:10,770 --> 00:23:14,700
corresponding control flow graph so you

674
00:23:12,300 --> 00:23:16,350
can see all the branches are now in the

675
00:23:14,700 --> 00:23:20,850
middle of blocks or not in the last

676
00:23:16,350 --> 00:23:22,679
position of a block another very strong

677
00:23:20,850 --> 00:23:24,870
assumption that we made during this step

678
00:23:22,680 --> 00:23:26,910
by step disassembly was that we can

679
00:23:24,870 --> 00:23:28,409
always follow the control flow and in

680
00:23:26,910 --> 00:23:30,120
particular when we were analyzing the

681
00:23:28,410 --> 00:23:31,950
hood in call from routine one to routine

682
00:23:30,120 --> 00:23:33,750
two we store the target for later

683
00:23:31,950 --> 00:23:36,330
analysis assuming that the target was

684
00:23:33,750 --> 00:23:38,340
known to us in reality as I said before

685
00:23:36,330 --> 00:23:40,139
it's not always the case and to

686
00:23:38,340 --> 00:23:42,600
illustrate that let's come back to a

687
00:23:40,140 --> 00:23:44,550
secret see example with a slight

688
00:23:42,600 --> 00:23:46,770
modification so I introduced a function

689
00:23:44,550 --> 00:23:48,419
pointer at the top so it's a pointer to

690
00:23:46,770 --> 00:23:50,460
a function with the same prototype and

691
00:23:48,420 --> 00:23:51,810
secret I'll go and you can see in main

692
00:23:50,460 --> 00:23:53,370
the function pointer is set to the

693
00:23:51,810 --> 00:23:54,870
address of secret I'll go and when we

694
00:23:53,370 --> 00:23:56,639
call secret I'll go using the function

695
00:23:54,870 --> 00:23:58,260
pointer so it does exactly the same

696
00:23:56,640 --> 00:24:00,480
thing as before except that it uses a

697
00:23:58,260 --> 00:24:02,040
function pointer for a routine call so

698
00:24:00,480 --> 00:24:03,720
if we take this C code and compile it

699
00:24:02,040 --> 00:24:05,520
with visual studio without optimization

700
00:24:03,720 --> 00:24:07,830
like before and we disassemble it with

701
00:24:05,520 --> 00:24:10,560
our simple algorithm but we shall have a

702
00:24:07,830 --> 00:24:12,540
beginning we end up with only one graph

703
00:24:10,560 --> 00:24:14,040
so one routine has bidden cover only and

704
00:24:12,540 --> 00:24:16,860
there is the graph so that's the main

705
00:24:14,040 --> 00:24:19,170
routine and notice of a call to secret

706
00:24:16,860 --> 00:24:20,790
algo is now an indirect call so it is

707
00:24:19,170 --> 00:24:22,440
they're referencing a memory address and

708
00:24:20,790 --> 00:24:24,840
calling what is tall are these address

709
00:24:22,440 --> 00:24:26,610
what is taller this address is actually

710
00:24:24,840 --> 00:24:28,199
written at the top here

711
00:24:26,610 --> 00:24:30,570
so that's the address of secret algo and

712
00:24:28,200 --> 00:24:32,760
so the problem for our simple recursive

713
00:24:30,570 --> 00:24:34,620
disassembler is that it cannot follow

714
00:24:32,760 --> 00:24:36,210
the indirect curve because the

715
00:24:34,620 --> 00:24:37,709
instruction disassembler cannot find the

716
00:24:36,210 --> 00:24:39,269
target of the and direct call it's not

717
00:24:37,710 --> 00:24:40,710
in the instruction itself it's in the

718
00:24:39,269 --> 00:24:43,559
state of the machine the state of a

719
00:24:40,710 --> 00:24:45,600
memory so we need the value stored at

720
00:24:43,559 --> 00:24:48,840
the reference address at the time the

721
00:24:45,600 --> 00:24:50,279
call would be executed and in this

722
00:24:48,840 --> 00:24:52,529
particular case we can find this via

723
00:24:50,279 --> 00:24:54,570
loop this value pretty easily just by

724
00:24:52,529 --> 00:24:56,730
looking at the previous instructions and

725
00:24:54,570 --> 00:24:58,918
we will find out that there is a move

726
00:24:56,730 --> 00:25:00,510
writing at this particular address so if

727
00:24:58,919 --> 00:25:02,039
we assume that no overt read is going to

728
00:25:00,510 --> 00:25:04,080
modify the memory between the move and

729
00:25:02,039 --> 00:25:06,779
the call we got the final target we got

730
00:25:04,080 --> 00:25:08,370
the entire core target is it always that

731
00:25:06,779 --> 00:25:11,429
easy of course not

732
00:25:08,370 --> 00:25:13,289
so for less artificial example of our to

733
00:25:11,429 --> 00:25:15,179
compute control flow let's use jump

734
00:25:13,289 --> 00:25:17,549
tables so jump tables are used by

735
00:25:15,179 --> 00:25:19,740
compilers to to implement switch

736
00:25:17,549 --> 00:25:21,418
statement from eye level language when

737
00:25:19,740 --> 00:25:23,460
the case value are close to each other

738
00:25:21,419 --> 00:25:26,309
when there are few gaps between the case

739
00:25:23,460 --> 00:25:28,830
value so for example here is a switch

740
00:25:26,309 --> 00:25:31,408
statement with all case value from 1 4

741
00:25:28,830 --> 00:25:33,000
to 400 if we compile it with visual

742
00:25:31,409 --> 00:25:35,269
studio once again and we want our

743
00:25:33,000 --> 00:25:37,860
disassembler we end up with with graph

744
00:25:35,269 --> 00:25:41,010
so we are obviously missing a lot of

745
00:25:37,860 --> 00:25:42,570
code here or the case code actually so

746
00:25:41,010 --> 00:25:44,669
what happens is that there is a branch

747
00:25:42,570 --> 00:25:46,500
an indirect branch using a register in

748
00:25:44,669 --> 00:25:49,110
the computation of the address the ECX

749
00:25:46,500 --> 00:25:51,210
register and so this address here is a

750
00:25:49,110 --> 00:25:53,219
base address to an array of 4 byte

751
00:25:51,210 --> 00:25:55,559
addresses and the ECX register is an

752
00:25:53,220 --> 00:25:57,120
index into this array so the area of

753
00:25:55,559 --> 00:26:00,510
addresses Vasavi addresses of the

754
00:25:57,120 --> 00:26:01,918
avocado element in each case so it means

755
00:26:00,510 --> 00:26:04,350
but if we want to compute the control

756
00:26:01,919 --> 00:26:06,840
flow for this particular routine we have

757
00:26:04,350 --> 00:26:09,120
to find what have the possible values

758
00:26:06,840 --> 00:26:10,889
for the ECX register in particular what

759
00:26:09,120 --> 00:26:13,110
we need is the maximum value such that

760
00:26:10,889 --> 00:26:14,879
then we can read the memory the address

761
00:26:13,110 --> 00:26:17,279
of the case anglers and make the

762
00:26:14,880 --> 00:26:19,409
connection in the graph and it's doable

763
00:26:17,279 --> 00:26:21,059
because there is a check on ECX just

764
00:26:19,409 --> 00:26:22,980
before and the block before but actually

765
00:26:21,059 --> 00:26:24,629
setting a maximum value so that's just

766
00:26:22,980 --> 00:26:25,889
another example of our to compute

767
00:26:24,630 --> 00:26:29,130
control flow there are many many cases

768
00:26:25,889 --> 00:26:31,709
of crashing but you got V ID so that

769
00:26:29,130 --> 00:26:33,630
brings us to a more general question how

770
00:26:31,710 --> 00:26:36,149
can we find the possible values for n

771
00:26:33,630 --> 00:26:38,190
direct operands that is V operands using

772
00:26:36,149 --> 00:26:39,239
register or memory address was value is

773
00:26:38,190 --> 00:26:41,549
not in V instruction

774
00:26:39,240 --> 00:26:43,950
but in the state of a machine and we

775
00:26:41,549 --> 00:26:45,750
need it in particular for indirect

776
00:26:43,950 --> 00:26:47,070
branches to have a better control flow

777
00:26:45,750 --> 00:26:50,279
but it's to have a better control flow

778
00:26:47,070 --> 00:26:52,080
we need a better data flow we could do

779
00:26:50,279 --> 00:26:54,480
some pattern matching to serve specific

780
00:26:52,080 --> 00:26:56,010
cases so for example one given compiler

781
00:26:54,480 --> 00:26:58,529
will always use the same machine

782
00:26:56,010 --> 00:26:59,940
instruction to implement gem tables so

783
00:26:58,529 --> 00:27:02,309
we could identify that particular

784
00:26:59,940 --> 00:27:03,600
situation and process it with some

785
00:27:02,309 --> 00:27:05,730
specific processing to compute to

786
00:27:03,600 --> 00:27:07,110
control flow of course it will not scale

787
00:27:05,730 --> 00:27:09,090
because we would have to deal with all

788
00:27:07,110 --> 00:27:11,668
compiler or compiler optimization level

789
00:27:09,090 --> 00:27:13,639
or architectures so in the search for a

790
00:27:11,669 --> 00:27:16,500
more generic solution to that problem

791
00:27:13,640 --> 00:27:18,570
what if we could simulate the execution

792
00:27:16,500 --> 00:27:20,039
of routines such that we would build the

793
00:27:18,570 --> 00:27:22,500
Machine state register and memory

794
00:27:20,039 --> 00:27:23,908
between each instruction so then we

795
00:27:22,500 --> 00:27:25,470
could solve the and director parents

796
00:27:23,909 --> 00:27:27,779
just by looking at the Machine state

797
00:27:25,470 --> 00:27:29,580
that we have built as forward to be

798
00:27:27,779 --> 00:27:31,500
possible for the simulation of God to be

799
00:27:29,580 --> 00:27:33,210
possible what we need is the semantics

800
00:27:31,500 --> 00:27:35,429
of this instruction we need to know what

801
00:27:33,210 --> 00:27:37,620
each instruction is doing so that we can

802
00:27:35,429 --> 00:27:38,789
update the Machine State as you might

803
00:27:37,620 --> 00:27:40,289
guess it's not always doable

804
00:27:38,789 --> 00:27:41,908
I will come back on this later but

805
00:27:40,289 --> 00:27:43,770
relieve our part for this to be even

806
00:27:41,909 --> 00:27:44,909
possible is to have the semantics of the

807
00:27:43,770 --> 00:27:46,799
instruction what each machine

808
00:27:44,909 --> 00:27:48,659
instruction is doing and weakly enough

809
00:27:46,799 --> 00:27:51,120
we already have it in jab because we

810
00:27:48,659 --> 00:27:52,409
need it for the D compilation so let me

811
00:27:51,120 --> 00:27:55,139
introduce the jab intermediate language

812
00:27:52,409 --> 00:27:56,789
it's basically a custom language so it

813
00:27:55,140 --> 00:27:59,279
can be seen as a low-level imperative

814
00:27:56,789 --> 00:28:01,110
assembly like language so program in G

815
00:27:59,279 --> 00:28:03,360
by L is a series of assignments made of

816
00:28:01,110 --> 00:28:05,899
expressions and there are only 16

817
00:28:03,360 --> 00:28:08,760
different elements in the language and

818
00:28:05,899 --> 00:28:10,529
we use this language mainly as a way to

819
00:28:08,760 --> 00:28:12,390
express the semantics of a native

820
00:28:10,529 --> 00:28:14,730
instruction to give you an ID there is a

821
00:28:12,390 --> 00:28:16,770
x86 instruction it's XOR between a

822
00:28:14,730 --> 00:28:18,539
register and memory slot event varies

823
00:28:16,770 --> 00:28:20,340
its translation that's the semantic

824
00:28:18,539 --> 00:28:22,379
representation in the jab and simulate

825
00:28:20,340 --> 00:28:24,570
language so all the side effects of this

826
00:28:22,380 --> 00:28:26,340
instruction are explicit in this

827
00:28:24,570 --> 00:28:29,070
representation so but what the

828
00:28:26,340 --> 00:28:30,480
instruction is doing and this aisle will

829
00:28:29,070 --> 00:28:32,370
be used during the compilation it will

830
00:28:30,480 --> 00:28:33,750
be optimized and most of the assignment

831
00:28:32,370 --> 00:28:36,270
will be removed because we are not used

832
00:28:33,750 --> 00:28:37,980
but let's stick with AB so we have the

833
00:28:36,270 --> 00:28:40,200
semantic representation here as I said

834
00:28:37,980 --> 00:28:42,659
is a foundation for veggetti compilation

835
00:28:40,200 --> 00:28:44,730
pipeline because our optimization they

836
00:28:42,659 --> 00:28:46,470
work on the intermediate language and so

837
00:28:44,730 --> 00:28:48,299
back up they can be applied on our

838
00:28:46,470 --> 00:28:51,179
architectures that we want to decompile

839
00:28:48,299 --> 00:28:52,160
the fvv our part is to implement the

840
00:28:51,179 --> 00:28:54,140
native to our ell

841
00:28:52,160 --> 00:28:56,270
converter and so we have one of them for

842
00:28:54,140 --> 00:28:57,710
each architecture with a compiled so

843
00:28:56,270 --> 00:28:59,330
it's really a similar idea to compiler

844
00:28:57,710 --> 00:29:00,950
and Tammi that representation as you

845
00:28:59,330 --> 00:29:02,600
might know compiler of a apply the

846
00:29:00,950 --> 00:29:03,890
optimization on intermediate

847
00:29:02,600 --> 00:29:05,689
representation such that the same

848
00:29:03,890 --> 00:29:09,440
optimization can be applied for all high

849
00:29:05,690 --> 00:29:11,780
level languages so but a similar ID so

850
00:29:09,440 --> 00:29:13,310
we can we can reuse this intermediate

851
00:29:11,780 --> 00:29:15,110
language and the semantic representation

852
00:29:13,310 --> 00:29:16,700
we have for our current disassembly

853
00:29:15,110 --> 00:29:19,100
control flow problem we could simulate

854
00:29:16,700 --> 00:29:21,710
the Japan tomato presentation to enrich

855
00:29:19,100 --> 00:29:23,810
the routine control flow and that's what

856
00:29:21,710 --> 00:29:27,680
we do so we take each native routine and

857
00:29:23,810 --> 00:29:30,320
we convert it into G by L so but that

858
00:29:27,680 --> 00:29:31,880
gives us a CFG of Al statements with not

859
00:29:30,320 --> 00:29:33,649
we do not optimize it at this point

860
00:29:31,880 --> 00:29:35,360
because we want to be very fast and so

861
00:29:33,650 --> 00:29:37,790
for example is the first basic block in

862
00:29:35,360 --> 00:29:40,070
the CFG il of a main routine in secret

863
00:29:37,790 --> 00:29:42,530
exit so you see all the side effects

864
00:29:40,070 --> 00:29:44,330
here and then we simulate with il

865
00:29:42,530 --> 00:29:45,800
routine to build the Machine State at

866
00:29:44,330 --> 00:29:47,629
each instruction so we start from a

867
00:29:45,800 --> 00:29:49,370
clean state with pseudo realistic values

868
00:29:47,630 --> 00:29:51,200
in register we allocate stack memory and

869
00:29:49,370 --> 00:29:53,060
then the virtual simulator of the

870
00:29:51,200 --> 00:29:54,500
implementation of a simulator is not so

871
00:29:53,060 --> 00:29:57,980
hard because we have only two under the

872
00:29:54,500 --> 00:30:00,110
16 different il elements and when we use

873
00:29:57,980 --> 00:30:02,720
this computed machine States to solve

874
00:30:00,110 --> 00:30:05,360
the an direct operands and enrich but is

875
00:30:02,720 --> 00:30:07,910
a zombie so to give you an idea in jab

876
00:30:05,360 --> 00:30:10,000
if we disassemble this secret see with

877
00:30:07,910 --> 00:30:12,710
function pointer of a previous example

878
00:30:10,000 --> 00:30:14,330
jab jab is able to tell us that the

879
00:30:12,710 --> 00:30:16,100
entire goal is going to a specific

880
00:30:14,330 --> 00:30:17,810
address so rewrite it as a comment with

881
00:30:16,100 --> 00:30:19,490
the arrow and so that's an over routine

882
00:30:17,810 --> 00:30:21,200
that would be disassembled by jab and so

883
00:30:19,490 --> 00:30:22,820
the reason we solve this and erect goal

884
00:30:21,200 --> 00:30:24,200
is because we can find out during the

885
00:30:22,820 --> 00:30:27,290
simulation but where is the right to

886
00:30:24,200 --> 00:30:29,330
this particular address just before so

887
00:30:27,290 --> 00:30:31,190
it might seem magic but let's not get

888
00:30:29,330 --> 00:30:33,590
our hopes to I this kind of simulation

889
00:30:31,190 --> 00:30:35,750
cannot always work and because we enter

890
00:30:33,590 --> 00:30:37,580
the simulation has to be safe it can

891
00:30:35,750 --> 00:30:38,900
only provide reliable values to the

892
00:30:37,580 --> 00:30:41,030
disassembly engine because otherwise

893
00:30:38,900 --> 00:30:43,130
would be too risky to use so to give you

894
00:30:41,030 --> 00:30:45,889
an idea if we take this free IL routine

895
00:30:43,130 --> 00:30:48,080
instruction where to register a set to

896
00:30:45,890 --> 00:30:50,180
constant a member with ECX register set

897
00:30:48,080 --> 00:30:52,429
to the sum of a to previous register so

898
00:30:50,180 --> 00:30:54,410
the simulation works on this case it can

899
00:30:52,430 --> 00:30:57,200
provide us the final value for ECX

900
00:30:54,410 --> 00:30:59,930
register but now if we see if we switch

901
00:30:57,200 --> 00:31:02,180
EAX to be a value coming from memory so

902
00:30:59,930 --> 00:31:04,760
that's the syntax for to read into

903
00:31:02,180 --> 00:31:05,960
memory here we the simulation cannot

904
00:31:04,760 --> 00:31:07,970
provide us for sure

905
00:31:05,960 --> 00:31:09,769
the value of ECX register because it

906
00:31:07,970 --> 00:31:13,789
cannot it cannot know what is in memory

907
00:31:09,769 --> 00:31:15,379
at the time e^x was rate was a set so it

908
00:31:13,789 --> 00:31:18,320
has to be a safe analysis that means we

909
00:31:15,379 --> 00:31:20,389
provide values for for for case where

910
00:31:18,320 --> 00:31:22,249
there are no unknown inputs so it can

911
00:31:20,389 --> 00:31:23,959
only solve simple cases but in a generic

912
00:31:22,249 --> 00:31:25,940
way in the sense that it works exactly

913
00:31:23,960 --> 00:31:28,309
the same for all the architectures for

914
00:31:25,940 --> 00:31:29,899
which we have native 2il converters so

915
00:31:28,309 --> 00:31:32,869
now we cannot always follow the control

916
00:31:29,899 --> 00:31:34,939
flow so do we have another way to find

917
00:31:32,869 --> 00:31:37,189
this secret algo routine that is

918
00:31:34,940 --> 00:31:39,590
somewhere in memory without any cross

919
00:31:37,190 --> 00:31:41,090
reference on it and that bring us back

920
00:31:39,590 --> 00:31:43,009
to a very old question in program

921
00:31:41,090 --> 00:31:44,899
analysis how to distinguish code from

922
00:31:43,009 --> 00:31:46,909
data in a program just by looking at it

923
00:31:44,899 --> 00:31:48,529
in theory that's a well-known

924
00:31:46,909 --> 00:31:50,119
intractable problem like any interesting

925
00:31:48,529 --> 00:31:52,820
problem so that's not really helping in

926
00:31:50,119 --> 00:31:55,668
practice what makes it a problem on most

927
00:31:52,820 --> 00:31:57,710
architectures is that current data or

928
00:31:55,669 --> 00:31:59,830
modern architectures usually share the

929
00:31:57,710 --> 00:32:02,240
same memory space

930
00:31:59,830 --> 00:32:04,158
moreover almost any series of bytes

931
00:32:02,240 --> 00:32:05,480
correspond to a machine instruction due

932
00:32:04,159 --> 00:32:07,519
to a fact but the instruction set

933
00:32:05,480 --> 00:32:09,499
encoding usually very dense very compact

934
00:32:07,519 --> 00:32:10,940
so they use all by the value so just by

935
00:32:09,499 --> 00:32:14,210
looking at a few bytes you cannot tell

936
00:32:10,940 --> 00:32:15,889
for sure if it's code or data but in

937
00:32:14,210 --> 00:32:20,749
specific contexts we can devise specific

938
00:32:15,889 --> 00:32:23,418
solutions and to illustrate that if I

939
00:32:20,749 --> 00:32:25,850
show you this road amp of x86 executable

940
00:32:23,419 --> 00:32:28,730
compiled by visual studio and if I ask

941
00:32:25,850 --> 00:32:30,199
you is it code or data if you are used

942
00:32:28,730 --> 00:32:32,419
to reverse on Windows you might notice

943
00:32:30,200 --> 00:32:34,789
but we service varies 3 bytes at the

944
00:32:32,419 --> 00:32:37,399
beginning and just after so this

945
00:32:34,789 --> 00:32:39,740
provides stands in x86 for push EBP move

946
00:32:37,399 --> 00:32:41,059
EBP ESP buts the classic visual studio

947
00:32:39,740 --> 00:32:43,340
routine prologue the first two

948
00:32:41,059 --> 00:32:45,559
instructions of all many routines

949
00:32:43,340 --> 00:32:47,689
compiled by visual studio when there are

950
00:32:45,559 --> 00:32:49,428
two bytes here a stunning for pop EBP

951
00:32:47,690 --> 00:32:49,999
wet that's the classic we just to do

952
00:32:49,429 --> 00:32:52,399
routine

953
00:32:49,999 --> 00:32:54,730
epilogue and then between these two

954
00:32:52,399 --> 00:32:57,258
prologues there is a sled of CC byte

955
00:32:54,730 --> 00:32:58,399
summing for in free so that's the

956
00:32:57,259 --> 00:33:01,279
classic we just to do

957
00:32:58,399 --> 00:33:03,379
padding within code so if you know the

958
00:33:01,279 --> 00:33:05,840
compiler you can say that it's very

959
00:33:03,379 --> 00:33:07,820
likely but this Rotom here is code with

960
00:33:05,840 --> 00:33:09,529
two routines because it follows the

961
00:33:07,820 --> 00:33:11,689
patterns and the structures of code

962
00:33:09,529 --> 00:33:14,179
compiled by visitors to do so what the

963
00:33:11,690 --> 00:33:15,649
basic ID and our example from a

964
00:33:14,179 --> 00:33:18,320
different perspective here is the memory

965
00:33:15,649 --> 00:33:19,969
view of x86 executable compiled by GCC

966
00:33:18,320 --> 00:33:21,679
so we already identify

967
00:33:19,970 --> 00:33:24,170
memory some areas we've got some areas

968
00:33:21,680 --> 00:33:26,750
with data and when we ask do this gray

969
00:33:24,170 --> 00:33:29,150
area not analyze area our code or data

970
00:33:26,750 --> 00:33:31,310
once again if you know the compiler it

971
00:33:29,150 --> 00:33:33,830
can actual service question because GCC

972
00:33:31,310 --> 00:33:35,750
for x86 usually does not mix code end

973
00:33:33,830 --> 00:33:37,730
data so it means that the top gray area

974
00:33:35,750 --> 00:33:39,160
is very likely code and the bottom area

975
00:33:37,730 --> 00:33:42,230
is likely data

976
00:33:39,160 --> 00:33:44,240
you got the ID so that's what we do in

977
00:33:42,230 --> 00:33:45,770
jab we try to identify the compiler but

978
00:33:44,240 --> 00:33:47,600
serve to create the target and then we

979
00:33:45,770 --> 00:33:49,460
apply specific eristic for this compiler

980
00:33:47,600 --> 00:33:51,199
in particular to solve the code versus

981
00:33:49,460 --> 00:33:54,560
data question so we have a bunch of

982
00:33:51,200 --> 00:33:56,210
compiler identification walls and there

983
00:33:54,560 --> 00:33:58,460
is an example of an aristocrat we apply

984
00:33:56,210 --> 00:34:00,830
a non analyzed address a will be

985
00:33:58,460 --> 00:34:03,290
considered to be likely cold if all this

986
00:34:00,830 --> 00:34:05,270
is true the compiler is GCC or clunk the

987
00:34:03,290 --> 00:34:07,280
architecture is x86 there are no

988
00:34:05,270 --> 00:34:08,960
obfuscation malformation so but also a

989
00:34:07,280 --> 00:34:10,400
bunch of heuristics here but we have to

990
00:34:08,960 --> 00:34:13,730
check if there is something wrong with

991
00:34:10,400 --> 00:34:15,920
with a file if a is within the core area

992
00:34:13,730 --> 00:34:17,330
circle area is defined as the merge of

993
00:34:15,920 --> 00:34:19,520
all code section or called segments

994
00:34:17,330 --> 00:34:21,080
depending on the file format and if all

995
00:34:19,520 --> 00:34:23,270
the bytes that a do not look like code

996
00:34:21,080 --> 00:34:26,719
padding if all this is true it's likely

997
00:34:23,270 --> 00:34:28,280
that a lease code now there is an

998
00:34:26,719 --> 00:34:30,169
interesting design question if we use

999
00:34:28,280 --> 00:34:32,690
this kind of strategy are we entering a

1000
00:34:30,170 --> 00:34:33,889
integrate such compiler or specific

1001
00:34:32,690 --> 00:34:35,720
logic into a generic

1002
00:34:33,889 --> 00:34:37,549
disassembler so what we do in jab is

1003
00:34:35,719 --> 00:34:40,609
that for each compiler we load different

1004
00:34:37,550 --> 00:34:42,920
extension and this extension wave will

1005
00:34:40,610 --> 00:34:45,140
feed what this assembler with the arrest

1006
00:34:42,920 --> 00:34:47,570
express alt so for example there are a

1007
00:34:45,139 --> 00:34:50,330
few of your sticks we have these are

1008
00:34:47,570 --> 00:34:52,340
methods in one interface so there is one

1009
00:34:50,330 --> 00:34:53,929
method to check if memory address looks

1010
00:34:52,340 --> 00:34:55,580
like pairing and where looks like a

1011
00:34:53,929 --> 00:34:57,200
routine prologue of if a specific

1012
00:34:55,580 --> 00:35:00,590
instruction looks like a switch

1013
00:34:57,200 --> 00:35:02,870
dispatcher so the branch instruction use

1014
00:35:00,590 --> 00:35:04,940
by a switch statement and so what is

1015
00:35:02,870 --> 00:35:06,830
assembler doesn't know which extensions

1016
00:35:04,940 --> 00:35:08,660
are loaded in memory so that's the job

1017
00:35:06,830 --> 00:35:10,279
of an over a component to load the

1018
00:35:08,660 --> 00:35:13,549
suitable extension for this particular

1019
00:35:10,280 --> 00:35:15,440
file of course if we will not always

1020
00:35:13,550 --> 00:35:17,090
work our sticks are going to be wrong it

1021
00:35:15,440 --> 00:35:19,220
can happen because we misidentified the

1022
00:35:17,090 --> 00:35:22,840
compiler because it's a new all version

1023
00:35:19,220 --> 00:35:26,470
of a compiler for which the early 1600s

1024
00:35:22,840 --> 00:35:28,610
Kishin or manual checks do not catch it

1025
00:35:26,470 --> 00:35:30,950
so what we have is some kind of feedback

1026
00:35:28,610 --> 00:35:31,640
loop we lock the error we do during

1027
00:35:30,950 --> 00:35:33,080
disassembly

1028
00:35:31,640 --> 00:35:33,650
so for example if you try to disassemble

1029
00:35:33,080 --> 00:35:35,089
service

1030
00:35:33,650 --> 00:35:37,339
bite and it's actually not a valid

1031
00:35:35,089 --> 00:35:39,170
machine instruction we log it if there

1032
00:35:37,339 --> 00:35:41,180
is a routine but we try to build and the

1033
00:35:39,170 --> 00:35:43,009
graph is incorrect or weird-looking so

1034
00:35:41,180 --> 00:35:44,558
we log it and we count all these errors

1035
00:35:43,009 --> 00:35:46,730
and when a certain threshold is reached

1036
00:35:44,559 --> 00:35:48,769
but these are some real switch back to a

1037
00:35:46,730 --> 00:35:51,769
safe mode when we apply only very

1038
00:35:48,769 --> 00:35:53,660
conservative eristic s-- and Jeb is also

1039
00:35:51,769 --> 00:35:55,700
an answer active tool so in last resort

1040
00:35:53,660 --> 00:36:00,259
the user can treat tweak that these are

1041
00:35:55,700 --> 00:36:01,249
some load decisions another assumption

1042
00:36:00,259 --> 00:36:03,470
we made during the step-by-step

1043
00:36:01,249 --> 00:36:05,480
disassembly is that the instruction set

1044
00:36:03,470 --> 00:36:07,730
remains always the same during the all

1045
00:36:05,480 --> 00:36:09,890
execution so the instruction set

1046
00:36:07,730 --> 00:36:12,289
represents which instructions are

1047
00:36:09,890 --> 00:36:13,549
available and what is the uncoding on

1048
00:36:12,289 --> 00:36:15,079
this instruction so I never said

1049
00:36:13,549 --> 00:36:15,700
anything about that but that was taken

1050
00:36:15,079 --> 00:36:18,410
for granted

1051
00:36:15,700 --> 00:36:19,819
there is one iconic again control

1052
00:36:18,410 --> 00:36:21,890
example of that if we look at an over

1053
00:36:19,819 --> 00:36:24,308
architecture of an x86 or MIPS its own

1054
00:36:21,890 --> 00:36:26,150
arm so here is a snippet of arm assembly

1055
00:36:24,309 --> 00:36:27,890
once again no need to understand my

1056
00:36:26,150 --> 00:36:30,859
snippet there is a there is a branch

1057
00:36:27,890 --> 00:36:32,660
here going to another routine a free

1058
00:36:30,859 --> 00:36:34,400
instruction routine and so notice all

1059
00:36:32,660 --> 00:36:36,259
the bytes of a routine on the left

1060
00:36:34,400 --> 00:36:38,029
follow a different patterns that the

1061
00:36:36,259 --> 00:36:39,410
bytes of routine on the right so on the

1062
00:36:38,029 --> 00:36:41,180
Left we got two bytes machine

1063
00:36:39,410 --> 00:36:43,249
instruction mixed with four bytes

1064
00:36:41,180 --> 00:36:45,169
machine instruction and then in the over

1065
00:36:43,249 --> 00:36:47,328
routine we got only four bytes machine

1066
00:36:45,170 --> 00:36:49,099
instruction because actually these two

1067
00:36:47,329 --> 00:36:52,009
are different instruction set the first

1068
00:36:49,099 --> 00:36:53,930
one is called term and its origin it was

1069
00:36:52,009 --> 00:36:55,489
originally designed to be a compact

1070
00:36:53,930 --> 00:36:57,950
version of the second one which is the

1071
00:36:55,489 --> 00:37:00,170
arm original instruction set and so

1072
00:36:57,950 --> 00:37:01,970
these are different as estrogen set

1073
00:37:00,170 --> 00:37:03,319
sharing the same encoding space so that

1074
00:37:01,970 --> 00:37:04,609
means that the same bytes will be

1075
00:37:03,319 --> 00:37:07,069
declared in two different instructions

1076
00:37:04,609 --> 00:37:08,869
now the tricky part is that they can be

1077
00:37:07,069 --> 00:37:11,210
both at the same time in the same exact

1078
00:37:08,869 --> 00:37:13,160
way table and so out as the CPU knows

1079
00:37:11,210 --> 00:37:15,019
which instruction set to use in this

1080
00:37:13,160 --> 00:37:17,239
case it will switch from term to arm

1081
00:37:15,019 --> 00:37:18,799
thanks to a BLX instruction which stands

1082
00:37:17,239 --> 00:37:22,339
for branch with link and exchange

1083
00:37:18,799 --> 00:37:24,049
instruction set so for us what does it

1084
00:37:22,339 --> 00:37:25,700
mean it means that we the instruction

1085
00:37:24,049 --> 00:37:27,288
disassembler must under all possible

1086
00:37:25,700 --> 00:37:29,660
instruction set for given architecture

1087
00:37:27,289 --> 00:37:31,430
it also mean that when we know an

1088
00:37:29,660 --> 00:37:33,230
address is called a no data it's not

1089
00:37:31,430 --> 00:37:35,029
enough we need to know the actual

1090
00:37:33,230 --> 00:37:37,160
instruction set to use to disarm at this

1091
00:37:35,029 --> 00:37:39,289
particular address a misinformation can

1092
00:37:37,160 --> 00:37:40,970
come from bio sources it can be from the

1093
00:37:39,289 --> 00:37:43,009
way the address is called for example

1094
00:37:40,970 --> 00:37:45,439
the empirics with an offset the way the

1095
00:37:43,009 --> 00:37:47,360
address is reference for example in elf

1096
00:37:45,440 --> 00:37:49,400
file if the symbol as we list

1097
00:37:47,360 --> 00:37:52,300
we convinced that one its term and not

1098
00:37:49,400 --> 00:37:55,250
arm if he addressed a specific alingment

1099
00:37:52,300 --> 00:37:58,400
etc the multiple ins to solve this

1100
00:37:55,250 --> 00:38:00,080
question so in jab what we do is that we

1101
00:37:58,400 --> 00:38:01,940
allow our institution is assembler to

1102
00:38:00,080 --> 00:38:04,190
annul different instruction set and the

1103
00:38:01,940 --> 00:38:06,020
generators are some neurologic update

1104
00:38:04,190 --> 00:38:08,090
the instruction set to use in the

1105
00:38:06,020 --> 00:38:09,770
instruction is a summary and when we

1106
00:38:08,090 --> 00:38:11,090
have an unknown code address so we know

1107
00:38:09,770 --> 00:38:12,860
it's code but we don't know which

1108
00:38:11,090 --> 00:38:14,840
instruction set to use which why all of

1109
00:38:12,860 --> 00:38:17,540
them so we do some with all instruction

1110
00:38:14,840 --> 00:38:20,300
set at the same in parallel and we keep

1111
00:38:17,540 --> 00:38:21,440
the best result so the best result is

1112
00:38:20,300 --> 00:38:23,330
basically the instruction set that

1113
00:38:21,440 --> 00:38:25,130
provides us a correct looking control

1114
00:38:23,330 --> 00:38:28,970
flow graph so once again that's a bunch

1115
00:38:25,130 --> 00:38:31,820
of heuristics a final assumption we made

1116
00:38:28,970 --> 00:38:33,080
and is that all code matters and this

1117
00:38:31,820 --> 00:38:35,120
assumption was not it's not really the

1118
00:38:33,080 --> 00:38:37,400
same kind of assumption but basically we

1119
00:38:35,120 --> 00:38:40,730
are missing something in our simplistic

1120
00:38:37,400 --> 00:38:42,920
disassembler if you remember in the

1121
00:38:40,730 --> 00:38:44,960
secret algo routine varies with a - i as

1122
00:38:42,920 --> 00:38:47,450
library routine but is called in the

1123
00:38:44,960 --> 00:38:49,160
graph so we are in the corresponding CFG

1124
00:38:47,450 --> 00:38:50,960
we have a call for this routine it's

1125
00:38:49,160 --> 00:38:52,819
going in the same exact table because of

1126
00:38:50,960 --> 00:38:54,620
this routine this library routine has

1127
00:38:52,820 --> 00:38:56,810
been statically linked in our executable

1128
00:38:54,620 --> 00:38:59,120
so there is an over call at the end

1129
00:38:56,810 --> 00:39:01,370
so actually 8y is pretty complex as a

1130
00:38:59,120 --> 00:39:03,890
routine but it's just boost and our a2i

1131
00:39:01,370 --> 00:39:05,480
routine so that brings us to a very old

1132
00:39:03,890 --> 00:39:09,020
problem in reverse engineering how do we

1133
00:39:05,480 --> 00:39:10,610
identify library routines such

1134
00:39:09,020 --> 00:39:11,990
identification is first is useful

1135
00:39:10,610 --> 00:39:13,220
because it allows the user to read

1136
00:39:11,990 --> 00:39:15,229
documentation of course rather than

1137
00:39:13,220 --> 00:39:17,120
analyzing the code in the case of 8yv

1138
00:39:15,230 --> 00:39:20,450
documentation is quite straightforward

1139
00:39:17,120 --> 00:39:22,160
then it also adds the automatic analysis

1140
00:39:20,450 --> 00:39:23,990
like the compilation by providing

1141
00:39:22,160 --> 00:39:25,730
precise information on a routine and

1142
00:39:23,990 --> 00:39:30,500
particular a prototype which can be hard

1143
00:39:25,730 --> 00:39:32,330
to guess sometimes so the compilers when

1144
00:39:30,500 --> 00:39:34,040
they provide these library routines they

1145
00:39:32,330 --> 00:39:35,960
provide them in their already compiled

1146
00:39:34,040 --> 00:39:37,880
form with in object files and this

1147
00:39:35,960 --> 00:39:40,730
object files are statically linked by

1148
00:39:37,880 --> 00:39:42,770
the linker in the executables and this

1149
00:39:40,730 --> 00:39:44,150
object files they come with symbols at

1150
00:39:42,770 --> 00:39:46,070
least for routine names because the

1151
00:39:44,150 --> 00:39:47,420
linker needs the routine names to do the

1152
00:39:46,070 --> 00:39:49,040
linking and to know in which object

1153
00:39:47,420 --> 00:39:50,960
which object file should be linked into

1154
00:39:49,040 --> 00:39:52,550
an executable so that means that the

1155
00:39:50,960 --> 00:39:53,990
usual strategy to solve this problem is

1156
00:39:52,550 --> 00:39:56,630
to take the library object files coming

1157
00:39:53,990 --> 00:39:59,149
with a compiler to generate signatures

1158
00:39:56,630 --> 00:40:00,180
and then use with signatures at runtime

1159
00:39:59,150 --> 00:40:04,230
in the diesel

1160
00:40:00,180 --> 00:40:06,240
family to identify library routines but

1161
00:40:04,230 --> 00:40:08,099
what we do in jab so our signatures they

1162
00:40:06,240 --> 00:40:09,808
are composed of features on one side

1163
00:40:08,099 --> 00:40:11,490
with our characteristics of a routine

1164
00:40:09,809 --> 00:40:13,230
that we use to identify them and then

1165
00:40:11,490 --> 00:40:14,520
there are some attributes that to the

1166
00:40:13,230 --> 00:40:16,200
knowledge we have on the routine the

1167
00:40:14,520 --> 00:40:19,319
name internal labels sometimes comments

1168
00:40:16,200 --> 00:40:20,640
and then when we generate signatures for

1169
00:40:19,319 --> 00:40:22,558
stand our libraries we select the

1170
00:40:20,640 --> 00:40:24,598
features to be such that the signatures

1171
00:40:22,559 --> 00:40:26,940
will be false positively we only want to

1172
00:40:24,599 --> 00:40:29,160
identify this particular routine and we

1173
00:40:26,940 --> 00:40:30,869
don't allow any variation because we

1174
00:40:29,160 --> 00:40:33,509
want to trust the signatures very much

1175
00:40:30,869 --> 00:40:35,400
so we use as features a custom hash

1176
00:40:33,510 --> 00:40:37,200
computed from a routine assembly code so

1177
00:40:35,400 --> 00:40:38,550
using the assembly code revenue binary

1178
00:40:37,200 --> 00:40:40,710
code allows us to be independent from

1179
00:40:38,550 --> 00:40:42,180
the engine nest which can differ on some

1180
00:40:40,710 --> 00:40:44,490
on some be engine nest

1181
00:40:42,180 --> 00:40:46,049
architecture we use also the names of

1182
00:40:44,490 --> 00:40:48,209
the call routine so that allows us to

1183
00:40:46,050 --> 00:40:49,859
distinguish two Weber's so the two

1184
00:40:48,210 --> 00:40:52,530
routine having the same code but calling

1185
00:40:49,859 --> 00:40:54,839
a different routine so we use the name

1186
00:40:52,530 --> 00:40:56,130
of this call routine as a feature it can

1187
00:40:54,839 --> 00:40:57,750
also be a burden to use that feature

1188
00:40:56,130 --> 00:40:59,579
because it means that you have to match

1189
00:40:57,750 --> 00:41:02,130
the collie routine to match the color

1190
00:40:59,579 --> 00:41:03,480
and then we add some additional features

1191
00:41:02,130 --> 00:41:05,730
depending on the routine size and the

1192
00:41:03,480 --> 00:41:07,740
basic ideas but the smaller routine is

1193
00:41:05,730 --> 00:41:09,750
for more features we need to avoid false

1194
00:41:07,740 --> 00:41:11,910
positive in other words the bigger of a

1195
00:41:09,750 --> 00:41:15,240
routine the most chance the ash would be

1196
00:41:11,910 --> 00:41:17,098
enough to identify it and as a final not

1197
00:41:15,240 --> 00:41:18,299
what when I talk about false positive in

1198
00:41:17,099 --> 00:41:19,980
this context it means that the name

1199
00:41:18,299 --> 00:41:23,280
given to routine does not represent the

1200
00:41:19,980 --> 00:41:25,319
behavior so the dummy example is that we

1201
00:41:23,280 --> 00:41:27,000
can add an if we identify unlink

1202
00:41:25,319 --> 00:41:28,529
as remove it's not a for positive

1203
00:41:27,000 --> 00:41:30,299
because these two routines have a

1204
00:41:28,530 --> 00:41:31,920
similar behavior in similar circumstance

1205
00:41:30,299 --> 00:41:36,000
and the same prototype so that's not a

1206
00:41:31,920 --> 00:41:38,760
false positive so we got a bunch of

1207
00:41:36,000 --> 00:41:40,650
signature libraries for all our

1208
00:41:38,760 --> 00:41:45,480
architectures and several compilers

1209
00:41:40,650 --> 00:41:47,670
compiled optimization level so enough

1210
00:41:45,480 --> 00:41:50,910
with a broken assumption what's the

1211
00:41:47,670 --> 00:41:52,799
point I'm trying to make first if we sum

1212
00:41:50,910 --> 00:41:55,200
up what we did we successfully

1213
00:41:52,799 --> 00:41:57,660
disassembled a Windows executable secret

1214
00:41:55,200 --> 00:41:59,640
XE with a simplistic recursive algorithm

1215
00:41:57,660 --> 00:42:01,770
but we made a lot of assumption on the

1216
00:41:59,640 --> 00:42:03,509
way and when we showed that these

1217
00:42:01,770 --> 00:42:05,250
assumptions can be broken just by

1218
00:42:03,510 --> 00:42:06,210
looking at standard compiler code and

1219
00:42:05,250 --> 00:42:08,609
I've never said anything about

1220
00:42:06,210 --> 00:42:10,680
obfuscation protection Packers all the

1221
00:42:08,609 --> 00:42:12,720
examples I've shown came from a Class C

1222
00:42:10,680 --> 00:42:13,980
compiler code and if you are reverser

1223
00:42:12,720 --> 00:42:15,810
you probably have in mind

1224
00:42:13,980 --> 00:42:17,340
broken assumption we made during the

1225
00:42:15,810 --> 00:42:19,320
step-by-step disassembly like for

1226
00:42:17,340 --> 00:42:20,700
example instructions do not overlap code

1227
00:42:19,320 --> 00:42:22,590
does not modify itself so that's

1228
00:42:20,700 --> 00:42:24,450
actually the way many of fisken

1229
00:42:22,590 --> 00:42:28,050
techniques work they break the

1230
00:42:24,450 --> 00:42:29,549
assumptions made by analysis tools so a

1231
00:42:28,050 --> 00:42:31,170
first pessimistic conclusion would be

1232
00:42:29,550 --> 00:42:32,369
that there is no such thing as that

1233
00:42:31,170 --> 00:42:33,930
these assembler able to correctly

1234
00:42:32,369 --> 00:42:35,970
disassemble all programs for all

1235
00:42:33,930 --> 00:42:37,710
architectures and compilers and the

1236
00:42:35,970 --> 00:42:39,180
intuitive idea after I was trying to

1237
00:42:37,710 --> 00:42:41,820
show is that there are actually very few

1238
00:42:39,180 --> 00:42:43,890
assumptions but are holding true on so

1239
00:42:41,820 --> 00:42:45,510
many diverse programs and if you are an

1240
00:42:43,890 --> 00:42:47,339
academic you could make the connection

1241
00:42:45,510 --> 00:42:49,020
here with the ulting problem and it's

1242
00:42:47,340 --> 00:42:51,060
generalization where I see a ram which

1243
00:42:49,020 --> 00:42:52,410
basically says that there there is no

1244
00:42:51,060 --> 00:42:55,920
interesting properties on program

1245
00:42:52,410 --> 00:42:57,390
behavior but you can decide now we

1246
00:42:55,920 --> 00:42:59,250
cannot disassemble correctly all

1247
00:42:57,390 --> 00:43:00,868
programs but we might still be able to

1248
00:42:59,250 --> 00:43:02,850
do okay on a subset of them I thought

1249
00:43:00,869 --> 00:43:05,670
that was I was trying to show with the

1250
00:43:02,850 --> 00:43:07,049
compiler eristic s-- what we can do is

1251
00:43:05,670 --> 00:43:08,340
try to understand the universe of

1252
00:43:07,050 --> 00:43:10,380
program but we will try to disassemble

1253
00:43:08,340 --> 00:43:13,020
and we can do it by dividing this

1254
00:43:10,380 --> 00:43:15,030
universe into groups with the two

1255
00:43:13,020 --> 00:43:16,859
following properties varies there exist

1256
00:43:15,030 --> 00:43:18,930
reliable ways to check if a program

1257
00:43:16,859 --> 00:43:20,670
belong to a group and an interesting

1258
00:43:18,930 --> 00:43:23,279
group has non-trivial assumptions that

1259
00:43:20,670 --> 00:43:24,960
are true for all group but exactly the

1260
00:43:23,280 --> 00:43:27,000
idea of compiler specifically sticks but

1261
00:43:24,960 --> 00:43:28,950
you can be much more we can we find that

1262
00:43:27,000 --> 00:43:30,600
a specific compiler with a specific ID

1263
00:43:28,950 --> 00:43:31,980
of a language a specific runtime and

1264
00:43:30,600 --> 00:43:33,720
when there is a group with some

1265
00:43:31,980 --> 00:43:35,280
assumption that you know are true for

1266
00:43:33,720 --> 00:43:37,709
this group and when a program does not

1267
00:43:35,280 --> 00:43:41,790
belong to non group we just apply very

1268
00:43:37,710 --> 00:43:43,170
conservative assumptions and what we

1269
00:43:41,790 --> 00:43:44,700
want is ready to avoid the common

1270
00:43:43,170 --> 00:43:46,710
disassembler mistakes so what was

1271
00:43:44,700 --> 00:43:48,450
mistake well this assembler can do is to

1272
00:43:46,710 --> 00:43:50,070
disassemble data because there's some

1273
00:43:48,450 --> 00:43:51,750
kind of domino effect it can work as I

1274
00:43:50,070 --> 00:43:53,190
said before the encoding is built in

1275
00:43:51,750 --> 00:43:55,260
such a way but it can actually work and

1276
00:43:53,190 --> 00:43:57,180
it will have a domino effect by creating

1277
00:43:55,260 --> 00:44:00,420
one cross-references wrong branches and

1278
00:43:57,180 --> 00:44:02,279
it will be hard to undo then where our

1279
00:44:00,420 --> 00:44:03,840
code considered as data that's also a

1280
00:44:02,280 --> 00:44:05,550
mistake and it's misleading for the user

1281
00:44:03,840 --> 00:44:08,910
and finally we want to avoid missing

1282
00:44:05,550 --> 00:44:10,230
code and data so this process of

1283
00:44:08,910 --> 00:44:13,680
building knowledge of the program

1284
00:44:10,230 --> 00:44:15,480
universe will be easier if the diesel

1285
00:44:13,680 --> 00:44:17,580
Sam row is coded in an informative way

1286
00:44:15,480 --> 00:44:20,070
but is it explicitly reports when there

1287
00:44:17,580 --> 00:44:22,410
is an assumption but is broken so no no

1288
00:44:20,070 --> 00:44:24,210
silent fail no else missing and then the

1289
00:44:22,410 --> 00:44:26,250
disassembler can alt the developer map

1290
00:44:24,210 --> 00:44:27,400
the program universe by identifying as

1291
00:44:26,250 --> 00:44:28,809
we go new

1292
00:44:27,400 --> 00:44:32,319
honor Casey so every time we open a new

1293
00:44:28,809 --> 00:44:34,210
binary in Jeb we got we can have an

1294
00:44:32,319 --> 00:44:36,038
exception as developer saying telling us

1295
00:44:34,210 --> 00:44:37,630
but there is a corner case and as we

1296
00:44:36,039 --> 00:44:39,490
analyze new programs every day it's it's

1297
00:44:37,630 --> 00:44:41,710
kind of its kind of cool to have this

1298
00:44:39,490 --> 00:44:43,240
ability and then of course we have to

1299
00:44:41,710 --> 00:44:45,130
test your disassembler aggressively and

1300
00:44:43,240 --> 00:44:46,479
on diverse sample set so the diversity

1301
00:44:45,130 --> 00:44:47,980
of sample said is kind of tricky to

1302
00:44:46,480 --> 00:44:49,809
achieve because most available

1303
00:44:47,980 --> 00:44:51,010
executables will found on the internet

1304
00:44:49,809 --> 00:44:52,359
you don't know the exact compiler

1305
00:44:51,010 --> 00:44:53,950
version you don't know the optimization

1306
00:44:52,359 --> 00:44:55,808
level so it's out to classify in which

1307
00:44:53,950 --> 00:44:58,480
group I would belong so you have to do a

1308
00:44:55,809 --> 00:45:00,010
lot of computation by yourself and then

1309
00:44:58,480 --> 00:45:01,839
you so you can obtain the ground truth

1310
00:45:00,010 --> 00:45:03,789
to make the test from the symbols if you

1311
00:45:01,839 --> 00:45:06,038
compile by yourself also you can use

1312
00:45:03,789 --> 00:45:07,960
already compiled binaries and just do

1313
00:45:06,039 --> 00:45:09,849
some differential testing so you compare

1314
00:45:07,960 --> 00:45:11,770
the output of your tool with over tools

1315
00:45:09,849 --> 00:45:15,059
and we do it a lot in Jeb we compare

1316
00:45:11,770 --> 00:45:17,589
with over the summer or results and

1317
00:45:15,059 --> 00:45:20,049
finally something that is needed given

1318
00:45:17,589 --> 00:45:22,210
this context of not able to disarm or

1319
00:45:20,049 --> 00:45:23,859
program we have to empower the user to

1320
00:45:22,210 --> 00:45:24,910
provide them the ability to review and

1321
00:45:23,859 --> 00:45:26,920
tweak the assumptions made by

1322
00:45:24,910 --> 00:45:29,259
disassembler such that they can adapt

1323
00:45:26,920 --> 00:45:30,579
the assumption for particular cases so

1324
00:45:29,260 --> 00:45:32,650
that means that as developer you have to

1325
00:45:30,579 --> 00:45:34,480
explicitly says I made an assumption

1326
00:45:32,650 --> 00:45:37,480
here an erisa piece via assumption and

1327
00:45:34,480 --> 00:45:38,740
of course if there is a UI the user

1328
00:45:37,480 --> 00:45:40,660
should have the ability to fix the

1329
00:45:38,740 --> 00:45:44,500
mistake doing the analysis

1330
00:45:40,660 --> 00:45:46,000
Versalles so hopefully this plantation

1331
00:45:44,500 --> 00:45:47,589
convinced you if it was needed but

1332
00:45:46,000 --> 00:45:49,990
disassembly remains a complex problem

1333
00:45:47,589 --> 00:45:51,460
and you might think that as we're our

1334
00:45:49,990 --> 00:45:54,069
new compiler version coming out new

1335
00:45:51,460 --> 00:45:56,140
languages but the problem comes becomes

1336
00:45:54,069 --> 00:45:57,759
worse and worse actually there are many

1337
00:45:56,140 --> 00:45:59,200
novel and exploitation techniques that

1338
00:45:57,760 --> 00:46:01,270
done to make disassembly easier in

1339
00:45:59,200 --> 00:46:03,069
particular because they provide hints to

1340
00:46:01,270 --> 00:46:04,809
distinguish code versus data so for

1341
00:46:03,069 --> 00:46:06,369
example elf executable statements all

1342
00:46:04,809 --> 00:46:08,260
the code is but in this one specific

1343
00:46:06,369 --> 00:46:11,079
segment Microsoft control frog out

1344
00:46:08,260 --> 00:46:12,490
provides all routine entry points so in

1345
00:46:11,079 --> 00:46:13,869
the metadata of a file

1346
00:46:12,490 --> 00:46:16,538
intel control flow enforcement

1347
00:46:13,869 --> 00:46:18,640
technology but specific instruction at

1348
00:46:16,539 --> 00:46:21,369
authority nan 3 point so always provide

1349
00:46:18,640 --> 00:46:23,410
ins to elf these are some rows so that

1350
00:46:21,369 --> 00:46:25,630
could be so that's why this assembler

1351
00:46:23,410 --> 00:46:27,069
becomes easier and easier so thank you

1352
00:46:25,630 --> 00:46:29,710
very much for your attention if you have

1353
00:46:27,069 --> 00:46:35,099
any question of course I will try to

1354
00:46:29,710 --> 00:46:35,099
answer them thank you

