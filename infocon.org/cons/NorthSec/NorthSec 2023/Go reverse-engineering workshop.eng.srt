1
00:00:00,000 --> 00:00:02,760
is that Force for reverse Engineers

2
00:00:02,760 --> 00:00:05,700
they're kind of more annoying right well

3
00:00:05,700 --> 00:00:08,519
we'll see not so much but at least there

4
00:00:08,519 --> 00:00:09,599
are enough people that don't like

5
00:00:09,599 --> 00:00:13,080
University go programs that uh I think

6
00:00:13,080 --> 00:00:14,880
anyone writing malware in the language

7
00:00:14,880 --> 00:00:18,359
is going to probably uh you know go

8
00:00:18,359 --> 00:00:21,600
through the progress anyway

9
00:00:21,600 --> 00:00:23,640
um

10
00:00:23,640 --> 00:00:26,160
what else is there here to say

11
00:00:26,160 --> 00:00:28,340
okay

12
00:00:28,340 --> 00:00:32,520
Yeah so basically the main takeaway from

13
00:00:32,520 --> 00:00:35,040
this slide is that go binaries they're

14
00:00:35,040 --> 00:00:37,500
not that much more difficult as we will

15
00:00:37,500 --> 00:00:39,420
see than a two University here than

16
00:00:39,420 --> 00:00:41,280
other programs but

17
00:00:41,280 --> 00:00:43,020
they do require

18
00:00:43,020 --> 00:00:45,239
um this sort of different approach that

19
00:00:45,239 --> 00:00:49,500
uh not any not any not everyone knows

20
00:00:49,500 --> 00:00:52,559
off and so this is why I think a lot of

21
00:00:52,559 --> 00:00:53,879
people do not like reverse engineering

22
00:00:53,879 --> 00:00:55,680
go binaries but I mean thanks to this

23
00:00:55,680 --> 00:00:57,680
tutorial hopefully you will see that

24
00:00:57,680 --> 00:01:00,239
it's not that big of a deal at the end

25
00:01:00,239 --> 00:01:01,800
of the day so

26
00:01:01,800 --> 00:01:03,359
as for the moment that we will be

27
00:01:03,359 --> 00:01:04,739
analyzing in the course of the tutorial

28
00:01:04,739 --> 00:01:07,320
after the like introduction where I show

29
00:01:07,320 --> 00:01:08,640
you around the go language a little bit

30
00:01:08,640 --> 00:01:10,500
we will look at the sun shuttle Sun

31
00:01:10,500 --> 00:01:12,960
shuttle is a malware that was disclosed

32
00:01:12,960 --> 00:01:14,340
in the context of the solar winds

33
00:01:14,340 --> 00:01:16,380
incidents I'm pretty sure that all of

34
00:01:16,380 --> 00:01:18,180
you know about it it was disclosed by

35
00:01:18,180 --> 00:01:21,000
cisa and mandated March 2021

36
00:01:21,000 --> 00:01:23,640
and sunshinevel specifically is the full

37
00:01:23,640 --> 00:01:26,100
feature backdoor that was discovered in

38
00:01:26,100 --> 00:01:29,240
this supply chain attack

39
00:01:29,400 --> 00:01:32,280
so uh I mean I don't really want to go

40
00:01:32,280 --> 00:01:34,080
back to this slowly that's not in too

41
00:01:34,080 --> 00:01:36,000
much detail because I'm sure that uh

42
00:01:36,000 --> 00:01:38,040
most of you are familiar with it long

43
00:01:38,040 --> 00:01:39,780
story short this is a software company

44
00:01:39,780 --> 00:01:42,000
that provides I.T management software it

45
00:01:42,000 --> 00:01:44,700
was breached and then it was leveraged

46
00:01:44,700 --> 00:01:47,579
to infect very high profile targets so

47
00:01:47,579 --> 00:01:49,500
if you'd like to know more I mean there

48
00:01:49,500 --> 00:01:51,240
are so many blog posts out there I'm

49
00:01:51,240 --> 00:01:52,380
pretty sure you can find more

50
00:01:52,380 --> 00:01:54,659
information about it but at the end of

51
00:01:54,659 --> 00:01:56,520
the day after the victims was selected

52
00:01:56,520 --> 00:01:58,200
through the supply chain attack and a

53
00:01:58,200 --> 00:01:59,820
piece of malware was deployed to those

54
00:01:59,820 --> 00:02:03,060
victims and the final piece of malware

55
00:02:03,060 --> 00:02:06,360
that we wear uh is called Sun shuttle so

56
00:02:06,360 --> 00:02:07,439
this is what we will be looking at

57
00:02:07,439 --> 00:02:11,179
because it was written in Gold language

58
00:02:11,819 --> 00:02:14,760
so let's talk about how this uh

59
00:02:14,760 --> 00:02:16,680
tutorial is going to be structured so we

60
00:02:16,680 --> 00:02:19,500
will do a little bit of theory and it

61
00:02:19,500 --> 00:02:21,540
will be very short right I don't think

62
00:02:21,540 --> 00:02:24,300
that uh most I don't think any of you is

63
00:02:24,300 --> 00:02:26,700
really interested in learning about dual

64
00:02:26,700 --> 00:02:28,440
language in terms of the language itself

65
00:02:28,440 --> 00:02:30,540
I don't think you'd ever want or maybe

66
00:02:30,540 --> 00:02:33,120
you do but uh if you do want to learn

67
00:02:33,120 --> 00:02:35,580
how to write proper go like a programs

68
00:02:35,580 --> 00:02:36,720
that probably is about the right place

69
00:02:36,720 --> 00:02:39,060
we will only figure out the real the

70
00:02:39,060 --> 00:02:40,800
most basic things that we need in order

71
00:02:40,800 --> 00:02:42,720
to be able to find our way through

72
00:02:42,720 --> 00:02:45,060
programs we will talk about tooling a

73
00:02:45,060 --> 00:02:47,280
little bit uh especially when it comes

74
00:02:47,280 --> 00:02:49,500
to Ida and the useful plugins because

75
00:02:49,500 --> 00:02:51,540
there are some of them and finally we'll

76
00:02:51,540 --> 00:02:53,819
just dive into just the tutorial or the

77
00:02:53,819 --> 00:02:57,120
electrical practical work and we will

78
00:02:57,120 --> 00:02:58,980
first start with Hello World programs

79
00:02:58,980 --> 00:03:01,140
looking through those we will kind of

80
00:03:01,140 --> 00:03:03,780
get our first bearings into binaries

81
00:03:03,780 --> 00:03:06,239
compiled with uh with go Mac and then

82
00:03:06,239 --> 00:03:08,640
finally when we had figured out the

83
00:03:08,640 --> 00:03:10,680
basics then we can directly jump into an

84
00:03:10,680 --> 00:03:13,920
actual real life apt malware and then we

85
00:03:13,920 --> 00:03:16,680
will see how to tackle that and we'll

86
00:03:16,680 --> 00:03:18,659
probably won't definitely won't be able

87
00:03:18,659 --> 00:03:20,519
to look at the whole of the of the

88
00:03:20,519 --> 00:03:23,400
social malware in only two hours or two

89
00:03:23,400 --> 00:03:24,540
hours and a half

90
00:03:24,540 --> 00:03:26,700
but I'm confident that we will see

91
00:03:26,700 --> 00:03:29,099
enough that you will be able to finish

92
00:03:29,099 --> 00:03:31,860
this on your own and then maybe look at

93
00:03:31,860 --> 00:03:33,659
other build malware on your own later on

94
00:03:33,659 --> 00:03:35,340
as well

95
00:03:35,340 --> 00:03:38,280
so anyway let's talk a little bit about

96
00:03:38,280 --> 00:03:40,980
go the first thing that you have to know

97
00:03:40,980 --> 00:03:43,019
is that it generates executables that

98
00:03:43,019 --> 00:03:45,000
are statically built so what does this

99
00:03:45,000 --> 00:03:47,819
mean well it means that the whole go run

100
00:03:47,819 --> 00:03:49,200
time and all the necessary Library

101
00:03:49,200 --> 00:03:51,659
functions ship with every program you

102
00:03:51,659 --> 00:03:54,000
can find so we will see that a simple

103
00:03:54,000 --> 00:03:55,980
hello world program turns out to weigh

104
00:03:55,980 --> 00:03:58,620
something like two megabytes and in this

105
00:03:58,620 --> 00:04:00,180
sense this is really the reverse

106
00:04:00,180 --> 00:04:02,220
engineer's worst nightmare because

107
00:04:02,220 --> 00:04:05,879
well the proportion of useful code that

108
00:04:05,879 --> 00:04:07,680
was written by the malware author

109
00:04:07,680 --> 00:04:09,959
compared to the quantity of code

110
00:04:09,959 --> 00:04:12,659
presence and binary is really very very

111
00:04:12,659 --> 00:04:15,540
small it's a decimal even so it means

112
00:04:15,540 --> 00:04:17,160
that if there are I mean I don't know

113
00:04:17,160 --> 00:04:19,798
one if there's one kilobyte of malware

114
00:04:19,798 --> 00:04:23,520
code and you will get uh 1.9 gigabytes

115
00:04:23,520 --> 00:04:27,900
1.99 megabytes of Library code that is

116
00:04:27,900 --> 00:04:29,340
actually completely useless and

117
00:04:29,340 --> 00:04:30,900
documented somewhere

118
00:04:30,900 --> 00:04:32,580
so

119
00:04:32,580 --> 00:04:34,800
um it's not great but things used to be

120
00:04:34,800 --> 00:04:36,479
a lot worse That's the Silver Lining so

121
00:04:36,479 --> 00:04:39,300
Ida Pro since version I think 7.6 or

122
00:04:39,300 --> 00:04:40,800
something like this introduced a lot of

123
00:04:40,800 --> 00:04:42,000
improvements when it comes to go

124
00:04:42,000 --> 00:04:44,460
binaries uh because I'm pretty sure that

125
00:04:44,460 --> 00:04:45,960
their customers complained about it and

126
00:04:45,960 --> 00:04:48,120
so Ida has become very efficient at

127
00:04:48,120 --> 00:04:50,220
recognizing Library functions and that's

128
00:04:50,220 --> 00:04:53,880
really really a good thing because in

129
00:04:53,880 --> 00:04:56,699
the best you used to have to download

130
00:04:56,699 --> 00:05:00,240
weird uh projects from GitHub to maybe

131
00:05:00,240 --> 00:05:02,580
get this information so maybe you would

132
00:05:02,580 --> 00:05:04,919
have to create type libraries out of uh

133
00:05:04,919 --> 00:05:08,580
you know the source code of the the Go

134
00:05:08,580 --> 00:05:10,380
version that was used for mobile program

135
00:05:10,380 --> 00:05:12,540
and so on it was really a nightmare so

136
00:05:12,540 --> 00:05:15,479
now things are kind of good

137
00:05:15,479 --> 00:05:18,120
so yeah let's move on when it comes to

138
00:05:18,120 --> 00:05:21,120
writing go code go feels like a

139
00:05:21,120 --> 00:05:22,680
scripting language a little bit it

140
00:05:22,680 --> 00:05:25,139
doesn't have semicolons the syntax is

141
00:05:25,139 --> 00:05:26,699
very unflooded but it has very strong

142
00:05:26,699 --> 00:05:28,620
typing in the compiler turns out to be

143
00:05:28,620 --> 00:05:30,720
very very strict about lots of things so

144
00:05:30,720 --> 00:05:33,180
if you have an unused variable somewhere

145
00:05:33,180 --> 00:05:35,340
the code is not going to compiled if you

146
00:05:35,340 --> 00:05:37,199
haven't import that isn't needed the

147
00:05:37,199 --> 00:05:39,360
program compile if there is a return

148
00:05:39,360 --> 00:05:41,100
value that you're not using then it will

149
00:05:41,100 --> 00:05:42,900
won't compile either so

150
00:05:42,900 --> 00:05:45,600
it's really a strict language in that

151
00:05:45,600 --> 00:05:46,919
sense

152
00:05:46,919 --> 00:05:48,780
or as reverse engineering is concerned

153
00:05:48,780 --> 00:05:49,860
we don't care about that too much

154
00:05:49,860 --> 00:05:51,780
because we're not going to suffer

155
00:05:51,780 --> 00:05:54,780
through the compilers that whims but

156
00:05:54,780 --> 00:05:55,979
it's kind of a good thing because it

157
00:05:55,979 --> 00:05:58,160
means that the authors of the program

158
00:05:58,160 --> 00:06:01,199
will be forced or at least forced to

159
00:06:01,199 --> 00:06:03,360
some extent to write proper code and so

160
00:06:03,360 --> 00:06:05,580
it means that at least the code quality

161
00:06:05,580 --> 00:06:07,380
that we will be facing

162
00:06:07,380 --> 00:06:11,520
should be uh well it should be kind of

163
00:06:11,520 --> 00:06:13,020
okay right

164
00:06:13,020 --> 00:06:14,960
it means that

165
00:06:14,960 --> 00:06:17,699
well since the the compiler forces

166
00:06:17,699 --> 00:06:19,620
people to write sort of clean code it

167
00:06:19,620 --> 00:06:20,940
means that what we're going to have to

168
00:06:20,940 --> 00:06:23,520
look at is going to be well we will have

169
00:06:23,520 --> 00:06:25,740
to fight with the complexity of what the

170
00:06:25,740 --> 00:06:27,180
program is doing and so on but we won't

171
00:06:27,180 --> 00:06:28,800
have to fight with the added complexity

172
00:06:28,800 --> 00:06:30,840
of crappy software developers which is

173
00:06:30,840 --> 00:06:33,060
the case in so many malware strains that

174
00:06:33,060 --> 00:06:35,220
you see out there you know memory is not

175
00:06:35,220 --> 00:06:37,680
being released with uh variables that

176
00:06:37,680 --> 00:06:39,600
amount that are not used to anything Etc

177
00:06:39,600 --> 00:06:41,280
that doesn't happen in your language

178
00:06:41,280 --> 00:06:42,660
just because the compiler is not going

179
00:06:42,660 --> 00:06:44,699
to let you so this is kind of a plus for

180
00:06:44,699 --> 00:06:45,900
us

181
00:06:45,900 --> 00:06:48,479
and go another thing is that there is no

182
00:06:48,479 --> 00:06:50,400
exception mechanism like it just doesn't

183
00:06:50,400 --> 00:06:52,680
exist or as far as I know at least but

184
00:06:52,680 --> 00:06:56,759
one very important thing one key uh one

185
00:06:56,759 --> 00:06:59,000
key component of the language is that

186
00:06:59,000 --> 00:07:01,680
the program the functions can return

187
00:07:01,680 --> 00:07:04,319
multiple return values and that's the

188
00:07:04,319 --> 00:07:07,560
sort of a problem in the sense that when

189
00:07:07,560 --> 00:07:09,360
you look at either decompiler it tries

190
00:07:09,360 --> 00:07:12,000
to decompile programs to C or pseudocode

191
00:07:12,000 --> 00:07:14,460
that looks like C and in C there is just

192
00:07:14,460 --> 00:07:16,680
no way to represent multiple return

193
00:07:16,680 --> 00:07:20,340
values right and so the decompiler tends

194
00:07:20,340 --> 00:07:21,900
to be completely confused by everything

195
00:07:21,900 --> 00:07:23,940
that go is doing and so we will not be

196
00:07:23,940 --> 00:07:27,539
able to use it uh but anyway one thing

197
00:07:27,539 --> 00:07:29,520
that is important is that a very common

198
00:07:29,520 --> 00:07:31,979
pattern for those functions is that they

199
00:07:31,979 --> 00:07:34,259
will send out a result but they will

200
00:07:34,259 --> 00:07:37,500
also return a error object and this

201
00:07:37,500 --> 00:07:39,840
error object represents whether this uh

202
00:07:39,840 --> 00:07:42,300
function succeeded or not so in many

203
00:07:42,300 --> 00:07:44,580
languages you would add first I don't

204
00:07:44,580 --> 00:07:47,699
know in Java or python.net maybe even

205
00:07:47,699 --> 00:07:49,020
it's a plus plus if you like you would

206
00:07:49,020 --> 00:07:50,819
have a function that returns one value

207
00:07:50,819 --> 00:07:52,680
and then if something doesn't work as

208
00:07:52,680 --> 00:07:54,539
expected then it will throw an exception

209
00:07:54,539 --> 00:07:56,580
that will report and then you can react

210
00:07:56,580 --> 00:07:57,740
to this

211
00:07:57,740 --> 00:08:00,900
in in go the way that is that the way

212
00:08:00,900 --> 00:08:02,460
that it works even for the library

213
00:08:02,460 --> 00:08:05,340
function as always that the function

214
00:08:05,340 --> 00:08:07,380
will return both its return value maybe

215
00:08:07,380 --> 00:08:09,479
multiple term values and this error

216
00:08:09,479 --> 00:08:12,900
object that is hopefully null or nil

217
00:08:12,900 --> 00:08:15,258
input

218
00:08:15,360 --> 00:08:18,180
um one silver lining is that the

219
00:08:18,180 --> 00:08:19,979
standard Library provided by go is

220
00:08:19,979 --> 00:08:21,599
really really extensive it means that

221
00:08:21,599 --> 00:08:23,639
every time you want to be doing

222
00:08:23,639 --> 00:08:25,740
something a bit complex like opening

223
00:08:25,740 --> 00:08:27,240
files establishing it for connection

224
00:08:27,240 --> 00:08:30,840
photography uh whatever then you will

225
00:08:30,840 --> 00:08:32,940
not have to write the code on your own

226
00:08:32,940 --> 00:08:34,740
you will not have to develop this to

227
00:08:34,740 --> 00:08:35,880
write the functions you will just call

228
00:08:35,880 --> 00:08:37,740
some function from the go standard

229
00:08:37,740 --> 00:08:40,679
library and that's pretty cool because

230
00:08:40,679 --> 00:08:43,080
it means that most of the code that

231
00:08:43,080 --> 00:08:45,420
we'll be encountering from our authors

232
00:08:45,420 --> 00:08:47,519
is really some sort of Lego block

233
00:08:47,519 --> 00:08:49,440
assembly of function calls that come

234
00:08:49,440 --> 00:08:52,160
from the library right and it means that

235
00:08:52,160 --> 00:08:55,860
the complexity of the most complex

236
00:08:55,860 --> 00:08:58,440
operations will usually be offloaded to

237
00:08:58,440 --> 00:08:59,940
library functions and then if we are

238
00:08:59,940 --> 00:09:00,899
able to recognize those Library

239
00:09:00,899 --> 00:09:02,880
functions which we are because the tools

240
00:09:02,880 --> 00:09:05,279
now are kind of efficient then we won't

241
00:09:05,279 --> 00:09:08,399
have to suffer so much uh because we

242
00:09:08,399 --> 00:09:10,200
won't have to look into complex code and

243
00:09:10,200 --> 00:09:11,820
try to figure out that oh yeah this is

244
00:09:11,820 --> 00:09:14,220
day64 this is AES Etc this is just going

245
00:09:14,220 --> 00:09:15,540
to be provided to us and that's actually

246
00:09:15,540 --> 00:09:17,399
pretty cool

247
00:09:17,399 --> 00:09:21,120
so the way that I will approach go

248
00:09:21,120 --> 00:09:23,519
programs usually is that I will try to

249
00:09:23,519 --> 00:09:26,580
rewrite original scripts manually the

250
00:09:26,580 --> 00:09:28,500
way that I tend to do this is I try to

251
00:09:28,500 --> 00:09:30,779
look at all the calls to library

252
00:09:30,779 --> 00:09:32,880
functions I look at all the arguments

253
00:09:32,880 --> 00:09:35,640
and then based on this usually the whole

254
00:09:35,640 --> 00:09:37,160
structure of the program tends to

255
00:09:37,160 --> 00:09:40,080
surface up and it tends to become

256
00:09:40,080 --> 00:09:41,580
apparent if you look at all the

257
00:09:41,580 --> 00:09:43,019
functions of the library calls and all

258
00:09:43,019 --> 00:09:44,279
the arguments that are passed to it and

259
00:09:44,279 --> 00:09:45,540
the way that the original values will be

260
00:09:45,540 --> 00:09:46,740
used

261
00:09:46,740 --> 00:09:49,019
it turns out that the meaning of the

262
00:09:49,019 --> 00:09:53,339
program tends to be uh kind of apparent

263
00:09:53,339 --> 00:09:56,880
so I I gave you this image of Lego

264
00:09:56,880 --> 00:09:58,980
blocks that are assembled out of

265
00:09:58,980 --> 00:10:01,500
function calls to library functions it's

266
00:10:01,500 --> 00:10:02,700
really what we're going to be doing

267
00:10:02,700 --> 00:10:04,680
there so we will we know what the Lego

268
00:10:04,680 --> 00:10:07,200
blocks are and we'll just go into see at

269
00:10:07,200 --> 00:10:09,660
the the big structure the bigger shape

270
00:10:09,660 --> 00:10:11,100
that is constructed out of these blocks

271
00:10:11,100 --> 00:10:12,180
to figure out what the malware is doing

272
00:10:12,180 --> 00:10:14,399
but we won't really be diving into each

273
00:10:14,399 --> 00:10:16,980
and every function uh that might not be

274
00:10:16,980 --> 00:10:18,720
the most proper way to reverse engine

275
00:10:18,720 --> 00:10:20,519
your stuff but it's actually a way that

276
00:10:20,519 --> 00:10:22,500
works very quickly and this is in many

277
00:10:22,500 --> 00:10:24,360
cases what we are looking for

278
00:10:24,360 --> 00:10:25,440
anyway

279
00:10:25,440 --> 00:10:28,500
when we are looking for explanations

280
00:10:28,500 --> 00:10:31,440
about the library code uh it turns out

281
00:10:31,440 --> 00:10:33,180
that the go library is pretty well done

282
00:10:33,180 --> 00:10:35,660
so there is a website it's there

283
00:10:35,660 --> 00:10:38,640
golang.org oh I think it changed right

284
00:10:38,640 --> 00:10:42,720
now it's uh pkg.go.dev

285
00:10:42,720 --> 00:10:46,320
but probably the old URL still works

286
00:10:46,320 --> 00:10:48,420
in any case this documentation is pretty

287
00:10:48,420 --> 00:10:50,820
well done we'll be using it a lot and

288
00:10:50,820 --> 00:10:52,920
when we encounter a function we don't

289
00:10:52,920 --> 00:10:54,540
know we can look at the documentation

290
00:10:54,540 --> 00:10:57,720
and we will be able to find uh all the

291
00:10:57,720 --> 00:10:59,220
information about that function what it

292
00:10:59,220 --> 00:11:00,600
does but also what the arguments are

293
00:11:00,600 --> 00:11:02,279
what the original values are and so on

294
00:11:02,279 --> 00:11:06,120
and that's it so it's pretty useful

295
00:11:06,120 --> 00:11:08,160
and this is mostly what we need to know

296
00:11:08,160 --> 00:11:09,839
there another point of Interest I can

297
00:11:09,839 --> 00:11:12,300
maybe mention is that all the strings

298
00:11:12,300 --> 00:11:15,240
and all the global constants that are

299
00:11:15,240 --> 00:11:17,100
used in the program interestingly you

300
00:11:17,100 --> 00:11:19,200
can get all meshed together and uh

301
00:11:19,200 --> 00:11:20,700
support somewhere in the binary I'll

302
00:11:20,700 --> 00:11:23,640
show you that exactly in the uh with Ida

303
00:11:23,640 --> 00:11:24,660
later on

304
00:11:24,660 --> 00:11:27,060
uh but it's kind of confusing uh

305
00:11:27,060 --> 00:11:28,440
initially

306
00:11:28,440 --> 00:11:31,920
but it is the way it is right we best

307
00:11:31,920 --> 00:11:33,660
know about it because we can't change it

308
00:11:33,660 --> 00:11:35,579
anyway so I'll show you how exactly

309
00:11:35,579 --> 00:11:38,399
translates but be ready for but to be a

310
00:11:38,399 --> 00:11:41,300
bit surprised by this

311
00:11:42,780 --> 00:11:44,640
[Music]

312
00:11:44,640 --> 00:11:46,640
um

313
00:11:46,740 --> 00:11:50,300
very important very important thing is

314
00:11:50,300 --> 00:11:53,940
how function calls are being made

315
00:11:53,940 --> 00:11:55,560
no

316
00:11:55,560 --> 00:11:58,920
even though there are actually two apis

317
00:11:58,920 --> 00:12:02,579
uh one is the only one that was used

318
00:12:02,579 --> 00:12:05,579
before version 1.17 and 1.80 for other

319
00:12:05,579 --> 00:12:08,640
architectures and back then the

320
00:12:08,640 --> 00:12:11,640
arguments the function calls were

321
00:12:11,640 --> 00:12:13,920
um kind of it they looked a bit like C

322
00:12:13,920 --> 00:12:16,200
or C or C like languages in the sense

323
00:12:16,200 --> 00:12:19,260
that for every argument that was passed

324
00:12:19,260 --> 00:12:20,700
to a function they would be pushed in

325
00:12:20,700 --> 00:12:23,519
the stack and reverse ordered uh so you

326
00:12:23,519 --> 00:12:25,440
would see a push one push two push three

327
00:12:25,440 --> 00:12:27,839
whatever and then call to a given

328
00:12:27,839 --> 00:12:29,640
function

329
00:12:29,640 --> 00:12:30,420
um

330
00:12:30,420 --> 00:12:32,519
the return values are actually the same

331
00:12:32,519 --> 00:12:33,839
they would can they would come back

332
00:12:33,839 --> 00:12:36,180
through the stack as well but since

333
00:12:36,180 --> 00:12:39,540
version 1.17 the arguments are now

334
00:12:39,540 --> 00:12:42,000
passed via read registers so in the

335
00:12:42,000 --> 00:12:46,260
order Rax or the x or CX or di Etc

336
00:12:46,260 --> 00:12:47,040
um

337
00:12:47,040 --> 00:12:49,920
I I put the link there so you can see

338
00:12:49,920 --> 00:12:53,040
exactly where this is uh do you have all

339
00:12:53,040 --> 00:12:54,480
the documentation on the on the Go

340
00:12:54,480 --> 00:12:56,579
website it's very extensive I maybe

341
00:12:56,579 --> 00:12:58,260
don't recommend that you look through it

342
00:12:58,260 --> 00:13:01,040
but it's kind of useful to know right

343
00:13:01,040 --> 00:13:03,779
and this leads to a question which is

344
00:13:03,779 --> 00:13:05,579
how do we find the Go version used to

345
00:13:05,579 --> 00:13:08,279
come out of program now I think when you

346
00:13:08,279 --> 00:13:09,959
open any go program and you look at a

347
00:13:09,959 --> 00:13:11,579
function call it's going to be extremely

348
00:13:11,579 --> 00:13:14,459
obvious uh whether or not or which API

349
00:13:14,459 --> 00:13:16,079
is being used because if you see stuff

350
00:13:16,079 --> 00:13:17,820
moving move to registers then you know

351
00:13:17,820 --> 00:13:19,980
it's at least version one plus 17 and if

352
00:13:19,980 --> 00:13:21,300
you see just push push push and then

353
00:13:21,300 --> 00:13:23,160
function call and then you know it's

354
00:13:23,160 --> 00:13:26,519
earlier than this but still

355
00:13:26,519 --> 00:13:28,680
so uh this is something that is sort of

356
00:13:28,680 --> 00:13:30,480
important to know

357
00:13:30,480 --> 00:13:33,720
um but I think that as time passes in

358
00:13:33,720 --> 00:13:36,540
this old ABI is going to become more and

359
00:13:36,540 --> 00:13:39,180
more rare because uh of course now we've

360
00:13:39,180 --> 00:13:41,579
moved on to this register based thingy

361
00:13:41,579 --> 00:13:44,220
and this is going to be probably uh what

362
00:13:44,220 --> 00:13:46,620
they will use for I don't know the next

363
00:13:46,620 --> 00:13:49,200
10 years or maybe forever interestingly

364
00:13:49,200 --> 00:13:51,060
there is a blog post somewhere in

365
00:13:51,060 --> 00:13:53,760
Google's uh blog where they they explain

366
00:13:53,760 --> 00:13:55,920
that just doing this change allowed them

367
00:13:55,920 --> 00:13:58,680
to get something like 50 of performance

368
00:13:58,680 --> 00:14:01,680
increased throughout all the programs

369
00:14:01,680 --> 00:14:03,480
that they tested so just doing this

370
00:14:03,480 --> 00:14:05,639
simple change of uh passing arguments

371
00:14:05,639 --> 00:14:07,440
through registers instead of through the

372
00:14:07,440 --> 00:14:09,480
stack which is in the memory obviously

373
00:14:09,480 --> 00:14:11,519
it's going to be faster but having some

374
00:14:11,519 --> 00:14:13,260
metrics is pretty cool

375
00:14:13,260 --> 00:14:15,480
anyway

376
00:14:15,480 --> 00:14:17,100
let's talk a little bit about the

377
00:14:17,100 --> 00:14:19,860
tooling now in the in the course of this

378
00:14:19,860 --> 00:14:22,200
tutorial I will be talking about Ida Pro

379
00:14:22,200 --> 00:14:24,380
a lot so I apologize for this because

380
00:14:24,380 --> 00:14:26,820
I'm pretty sure that a lot of people out

381
00:14:26,820 --> 00:14:30,660
there do like uh better

382
00:14:30,660 --> 00:14:32,160
um that I had just haven't had the time

383
00:14:32,160 --> 00:14:35,160
to switch to a yet eventually I will but

384
00:14:35,160 --> 00:14:37,620
uh I haven't been able to at the moment

385
00:14:37,620 --> 00:14:40,440
so I will be talking about Ida if you

386
00:14:40,440 --> 00:14:42,660
want to follow this tutorial with gidra

387
00:14:42,660 --> 00:14:45,060
I'm pretty sure you can but I will not

388
00:14:45,060 --> 00:14:46,199
be able to provide a lot of support

389
00:14:46,199 --> 00:14:48,420
there right because I do not really know

390
00:14:48,420 --> 00:14:51,480
how this tool works and to support on my

391
00:14:51,480 --> 00:14:53,820
side I think to be very limited

392
00:14:53,820 --> 00:14:55,920
um but I am pretty sure that since

393
00:14:55,920 --> 00:14:58,560
ghidra has a strong Community all the

394
00:14:58,560 --> 00:15:01,260
plugins and all the features that I will

395
00:15:01,260 --> 00:15:02,820
be mentioning there have been ported one

396
00:15:02,820 --> 00:15:04,079
way or another

397
00:15:04,079 --> 00:15:06,240
at least when it comes to plugins and

398
00:15:06,240 --> 00:15:07,620
when it comes to recognizing those

399
00:15:07,620 --> 00:15:10,500
functions and the libraries Etc it feels

400
00:15:10,500 --> 00:15:13,199
to me like Ida is doing this manual like

401
00:15:13,199 --> 00:15:15,480
if you if you compile the program with

402
00:15:15,480 --> 00:15:18,420
the very last version of go and if you

403
00:15:18,420 --> 00:15:19,440
don't have the very last version of

404
00:15:19,440 --> 00:15:20,880
either usually iodized need to be a bit

405
00:15:20,880 --> 00:15:23,940
lost so it's kind of a problem there uh

406
00:15:23,940 --> 00:15:25,740
in my opinion so I don't know how they

407
00:15:25,740 --> 00:15:27,180
are doing this with key right they are

408
00:15:27,180 --> 00:15:29,519
more character if they follow up on this

409
00:15:29,519 --> 00:15:32,839
but well maybe you can tell me anyway

410
00:15:32,839 --> 00:15:36,120
there is first of all this repository

411
00:15:36,120 --> 00:15:39,000
which is called uh Alpha golang was

412
00:15:39,000 --> 00:15:42,260
developed by uh my good friend Juan

413
00:15:42,260 --> 00:15:46,740
he's a researcher from Central One

414
00:15:46,740 --> 00:15:49,199
yeah human thinks this repository I

415
00:15:49,199 --> 00:15:51,959
contributed one script to it

416
00:15:51,959 --> 00:15:54,240
I will show you what some of these

417
00:15:54,240 --> 00:15:58,380
plugins do the general idea is that

418
00:15:58,380 --> 00:16:01,139
some of the functions some of the

419
00:16:01,139 --> 00:16:03,300
features that used to be passed like

420
00:16:03,300 --> 00:16:05,639
this as either plugins have now been

421
00:16:05,639 --> 00:16:07,980
integrated directly into Ida so this

422
00:16:07,980 --> 00:16:09,959
repository is less crucial than it used

423
00:16:09,959 --> 00:16:12,899
to be but it still contains pretty uh

424
00:16:12,899 --> 00:16:15,000
useful stuff from time to time

425
00:16:15,000 --> 00:16:18,420
uh so I will walk you through this um uh

426
00:16:18,420 --> 00:16:20,459
those uh the various

427
00:16:20,459 --> 00:16:22,860
functions of the various scripts that

428
00:16:22,860 --> 00:16:26,279
are contained in this repository later

429
00:16:26,279 --> 00:16:29,339
and now let's talk a little bit about

430
00:16:29,339 --> 00:16:32,579
the samples so if you do have either Pro

431
00:16:32,579 --> 00:16:34,620
or gidra or if you have everything on

432
00:16:34,620 --> 00:16:37,440
your on your machine you will be able to

433
00:16:37,440 --> 00:16:39,839
do everything locally and this is going

434
00:16:39,839 --> 00:16:42,660
to be my recommended way of following

435
00:16:42,660 --> 00:16:45,420
this tutorial because the other is you

436
00:16:45,420 --> 00:16:48,000
can use one of our online VMS

437
00:16:48,000 --> 00:16:49,980
only 30 of them are available I think

438
00:16:49,980 --> 00:16:51,360
will be fine

439
00:16:51,360 --> 00:16:53,279
um based on the number of people in the

440
00:16:53,279 --> 00:16:56,880
room but the thing is those VMS they are

441
00:16:56,880 --> 00:16:59,579
in a data center in Amsterdam which is

442
00:16:59,579 --> 00:17:02,639
kind of far from here uh usually I tend

443
00:17:02,639 --> 00:17:06,660
to do trainings more in Europe so

444
00:17:06,660 --> 00:17:08,579
um I don't know exactly how the latency

445
00:17:08,579 --> 00:17:10,459
is going to work for you guys

446
00:17:10,459 --> 00:17:13,140
the access to these VMS it through is

447
00:17:13,140 --> 00:17:14,760
through remote desktop or something it's

448
00:17:14,760 --> 00:17:17,240
through the web

449
00:17:17,880 --> 00:17:20,520
browser deliver anything from there but

450
00:17:20,520 --> 00:17:23,220
if there might be a little bit of delay

451
00:17:23,220 --> 00:17:25,140
I don't know exactly how variable is

452
00:17:25,140 --> 00:17:27,179
going to be so uh if you can use your

453
00:17:27,179 --> 00:17:28,620
local machine if you'd have an either

454
00:17:28,620 --> 00:17:30,480
license and so on and I suggest you use

455
00:17:30,480 --> 00:17:32,820
that if this is not the case then you're

456
00:17:32,820 --> 00:17:35,520
welcome to try one of those VMS but

457
00:17:35,520 --> 00:17:39,000
right the connectivity might well I hope

458
00:17:39,000 --> 00:17:41,160
it will be comfortable but it might just

459
00:17:41,160 --> 00:17:42,360
not be

460
00:17:42,360 --> 00:17:46,080
if you do use those uh VMS

461
00:17:46,080 --> 00:17:48,840
the samples are going to be in a folder

462
00:17:48,840 --> 00:17:50,820
on the desktop they're going to be a

463
00:17:50,820 --> 00:17:53,700
folder desktop of samples or tracks or

464
00:17:53,700 --> 00:17:54,780
something like this and then you go to

465
00:17:54,780 --> 00:17:56,580
the very last folder which is go or

466
00:17:56,580 --> 00:17:58,320
sunshadow and then you will find

467
00:17:58,320 --> 00:17:59,640
everything in there

468
00:17:59,640 --> 00:18:01,380
otherwise if you don't want to work on

469
00:18:01,380 --> 00:18:03,780
everything locally you can find the

470
00:18:03,780 --> 00:18:05,580
archive that contains all the samples

471
00:18:05,580 --> 00:18:08,480
that we will be using today on this uh

472
00:18:08,480 --> 00:18:11,720
on the server P dot

473
00:18:11,720 --> 00:18:14,340
kwi.ski which is shorthand for for

474
00:18:14,340 --> 00:18:16,980
proxy.getcow.r

475
00:18:16,980 --> 00:18:19,260
and in there there should be if I

476
00:18:19,260 --> 00:18:20,880
remember to clean all my wires there

477
00:18:20,880 --> 00:18:24,120
should be only one archive and this will

478
00:18:24,120 --> 00:18:26,280
this is just a zip file containing the

479
00:18:26,280 --> 00:18:28,500
samples the password is infected as

480
00:18:28,500 --> 00:18:30,360
usual

481
00:18:30,360 --> 00:18:33,059
and yeah of course it contains a sample

482
00:18:33,059 --> 00:18:36,780
of some shuttle this sample is a light

483
00:18:36,780 --> 00:18:40,559
one a real one and so if you unzip it on

484
00:18:40,559 --> 00:18:42,299
your local machine then it's very likely

485
00:18:42,299 --> 00:18:44,100
then your that your AV is going to

486
00:18:44,100 --> 00:18:45,600
complain and delete it so be careful

487
00:18:45,600 --> 00:18:47,959
about that

488
00:18:49,380 --> 00:18:54,419
all right and this is it for the theory

489
00:18:54,419 --> 00:18:58,620
part of this uh tutorial this is

490
00:18:58,620 --> 00:19:00,299
basically all the theory that we are

491
00:19:00,299 --> 00:19:01,799
going to all this these are all the

492
00:19:01,799 --> 00:19:03,179
slides that we're going to have to

493
00:19:03,179 --> 00:19:04,919
suffer through together and right now

494
00:19:04,919 --> 00:19:07,140
I'm just going to switch to my my

495
00:19:07,140 --> 00:19:09,000
desktop and open either and then we're

496
00:19:09,000 --> 00:19:11,640
going to to get in there yes

497
00:19:11,640 --> 00:19:14,640
foreign

498
00:19:19,260 --> 00:19:22,200
oh yeah yeah so there is a password

499
00:19:22,200 --> 00:19:26,640
maybe uh I I put North SEC 2023 uh with

500
00:19:26,640 --> 00:19:28,980
capsule and capital S I'm not sure

501
00:19:28,980 --> 00:19:30,840
whether there is a space between North

502
00:19:30,840 --> 00:19:32,940
Tech and 2023 or not but this should be

503
00:19:32,940 --> 00:19:34,919
something either no second weekly or

504
00:19:34,919 --> 00:19:37,140
North Tech space 2025

505
00:19:37,140 --> 00:19:39,419
either of those work if it doesn't let

506
00:19:39,419 --> 00:19:42,720
me know and I will uh create a create a

507
00:19:42,720 --> 00:19:44,160
new URL something like this I'll figure

508
00:19:44,160 --> 00:19:45,539
out

509
00:19:45,539 --> 00:19:47,640
by the way if you have any questions at

510
00:19:47,640 --> 00:19:48,840
any time

511
00:19:48,840 --> 00:19:49,980
um I know if people can ask questions

512
00:19:49,980 --> 00:19:51,419
from the internet as well but feel free

513
00:19:51,419 --> 00:19:54,059
to just interrupt me raise your hands

514
00:19:54,059 --> 00:19:57,179
we are in a like this is a small enough

515
00:19:57,179 --> 00:19:58,980
class and I think we can have this uh

516
00:19:58,980 --> 00:20:02,520
sort of friendly discussion uh where you

517
00:20:02,520 --> 00:20:03,539
know I don't have to speak all the time

518
00:20:03,539 --> 00:20:06,059
and if you have if there's something

519
00:20:06,059 --> 00:20:07,860
that you are wondering about and feel

520
00:20:07,860 --> 00:20:09,539
free to just stop me there and I will

521
00:20:09,539 --> 00:20:10,440
try to explain

522
00:20:10,440 --> 00:20:12,860
oh

523
00:20:13,500 --> 00:20:17,160
yeah all right so let me just close down

524
00:20:17,160 --> 00:20:19,260
PowerPoints

525
00:20:19,260 --> 00:20:22,520
and now I will

526
00:20:23,280 --> 00:20:25,380
switch to Ida

527
00:20:25,380 --> 00:20:27,980
foreign

528
00:20:49,390 --> 00:20:52,439
[Music]

529
00:21:06,919 --> 00:21:09,440
you should have the source code as well

530
00:21:09,440 --> 00:21:14,039
it's really a super simple program to

531
00:21:14,039 --> 00:21:17,280
even if you don't speak go which is

532
00:21:17,280 --> 00:21:19,140
actually my case you should be able to

533
00:21:19,140 --> 00:21:21,720
figure out what this does

534
00:21:21,720 --> 00:21:24,059
this is the sort of program I like to

535
00:21:24,059 --> 00:21:25,679
create initially when I when I get into

536
00:21:25,679 --> 00:21:28,380
a new language because it well it

537
00:21:28,380 --> 00:21:29,940
evidence is one of the most important

538
00:21:29,940 --> 00:21:31,799
things which is how exactly function

539
00:21:31,799 --> 00:21:34,260
calls exactly work

540
00:21:34,260 --> 00:21:38,340
so in this case uh I just had a function

541
00:21:38,340 --> 00:21:40,860
in the main package which is the way

542
00:21:40,860 --> 00:21:43,140
that you define the entry points in go

543
00:21:43,140 --> 00:21:45,480
language as far as I know and what you

544
00:21:45,480 --> 00:21:48,960
do there is you have a sum function that

545
00:21:48,960 --> 00:21:51,659
receives three integers and that returns

546
00:21:51,659 --> 00:21:54,260
an integer

547
00:21:54,360 --> 00:21:56,220
and the only thing that this simple

548
00:21:56,220 --> 00:21:58,620
function does is we turn a plus b plus c

549
00:21:58,620 --> 00:22:01,140
and here our main function will call

550
00:22:01,140 --> 00:22:02,100
this

551
00:22:02,100 --> 00:22:04,620
sum function and then print the result

552
00:22:04,620 --> 00:22:08,299
and that's it so super simple go program

553
00:22:08,299 --> 00:22:12,299
I point out that it has to be compiled

554
00:22:12,299 --> 00:22:13,740
with disabled optimizations there

555
00:22:13,740 --> 00:22:15,539
because otherwise the compiler is smart

556
00:22:15,539 --> 00:22:17,340
enough to just inline everything and so

557
00:22:17,340 --> 00:22:19,679
you will too much

558
00:22:19,679 --> 00:22:20,460
um

559
00:22:20,460 --> 00:22:22,679
if if everything gets in line then of

560
00:22:22,679 --> 00:22:24,840
course then you won't see your function

561
00:22:24,840 --> 00:22:27,780
call and so that's not great but anyway

562
00:22:27,780 --> 00:22:30,000
let me start maybe with the very first

563
00:22:30,000 --> 00:22:32,280
thing I want to show you and which is

564
00:22:32,280 --> 00:22:35,400
how exactly do we know uh which version

565
00:22:35,400 --> 00:22:38,159
of go was used to combine the program

566
00:22:38,159 --> 00:22:41,460
and it turns out there is a simple trick

567
00:22:41,460 --> 00:22:44,039
to do this and let me show this to you

568
00:22:44,039 --> 00:22:45,780
right now I'm talking about this so what

569
00:22:45,780 --> 00:22:49,200
I do is I open the uh I open the program

570
00:22:49,200 --> 00:22:51,120
with the hex editor is this big enough

571
00:22:51,120 --> 00:22:52,559
for you guys to see on the screen or

572
00:22:52,559 --> 00:22:55,620
should I try to zoom a little bit

573
00:22:55,620 --> 00:22:59,479
okay I'll talk to you soon

574
00:23:35,580 --> 00:23:38,059
yes

575
00:23:50,640 --> 00:23:54,620
okay should be better now right

576
00:23:55,080 --> 00:23:57,360
okay so this is just a simple hex editor

577
00:23:57,360 --> 00:23:59,280
the one I like is called zero one zero

578
00:23:59,280 --> 00:24:01,679
editor there are many many different

579
00:24:01,679 --> 00:24:03,360
ones out there so you don't really you

580
00:24:03,360 --> 00:24:04,919
know you really don't have to use the

581
00:24:04,919 --> 00:24:07,679
same one as me the only thing I want to

582
00:24:07,679 --> 00:24:09,840
show you there is this super Advanced

583
00:24:09,840 --> 00:24:13,020
trick where uh all you have to look for

584
00:24:13,020 --> 00:24:16,020
in the program is

585
00:24:16,020 --> 00:24:18,240
go the

586
00:24:18,240 --> 00:24:21,620
one I think or

587
00:24:22,320 --> 00:24:25,260
like this or go one dot Maybe

588
00:24:25,260 --> 00:24:28,380
and you see if you do then you will find

589
00:24:28,380 --> 00:24:30,960
a string I think it's the only one there

590
00:24:30,960 --> 00:24:35,580
yeah and then you see go one dot 16.3

591
00:24:35,580 --> 00:24:38,340
and so it's it's just there and if you

592
00:24:38,340 --> 00:24:41,940
look at uh as far as I can tell all the

593
00:24:41,940 --> 00:24:44,159
go programs that I've analyzed so far if

594
00:24:44,159 --> 00:24:46,860
you just Ctrl F go one dot

595
00:24:46,860 --> 00:24:49,799
you will end up with a on a string that

596
00:24:49,799 --> 00:24:51,240
contains the version number of the

597
00:24:51,240 --> 00:24:54,419
program so it's sort of useful

598
00:24:54,419 --> 00:24:56,220
uh first of all to figure out if the

599
00:24:56,220 --> 00:24:58,200
program is written on in go or not

600
00:24:58,200 --> 00:24:59,880
although this is sort of very obvious

601
00:24:59,880 --> 00:25:02,100
when you open it with Ida but also if

602
00:25:02,100 --> 00:25:03,960
you want to know in advance what API is

603
00:25:03,960 --> 00:25:05,520
going to be used and this is a quick

604
00:25:05,520 --> 00:25:08,100
trick that you can

605
00:25:08,100 --> 00:25:11,880
use anyway so let me close this text

606
00:25:11,880 --> 00:25:16,280
editor because we're done with it

607
00:25:17,760 --> 00:25:22,760
I will just open either 64.

608
00:25:26,960 --> 00:25:31,980
a very I think

609
00:25:31,980 --> 00:25:34,080
a very Talent thing is you see you have

610
00:25:34,080 --> 00:25:36,659
gold written there and right next to it

611
00:25:36,659 --> 00:25:38,580
it's work on your own so basically your

612
00:25:38,580 --> 00:25:42,439
ideas are gonna help you much there

613
00:25:45,840 --> 00:25:48,539
so let me try and drop this here

614
00:25:48,539 --> 00:25:50,039
open this go program and then it will

615
00:25:50,039 --> 00:25:52,200
take a bit of time because uh those

616
00:25:52,200 --> 00:25:55,279
binaries are kind of big

617
00:25:55,620 --> 00:25:57,779
but as you see here in the function

618
00:25:57,779 --> 00:26:00,000
window already

619
00:26:00,000 --> 00:26:04,700
is able to figure out

620
00:26:04,799 --> 00:26:07,100
a lot of

621
00:26:07,100 --> 00:26:10,919
funds formats the PTR whatever actually

622
00:26:10,919 --> 00:26:12,900
it doesn't matter too much but as you

623
00:26:12,900 --> 00:26:15,779
can see I I recognizes the function

624
00:26:15,779 --> 00:26:17,400
names

625
00:26:17,400 --> 00:26:19,260
so I've been the best as I mentioned

626
00:26:19,260 --> 00:26:21,659
this is something that

627
00:26:21,659 --> 00:26:23,659
um

628
00:26:24,179 --> 00:26:25,679
I have

629
00:26:25,679 --> 00:26:28,740
um yeah I have been I have seen cases

630
00:26:28,740 --> 00:26:30,960
where Ida was not able to recognize this

631
00:26:30,960 --> 00:26:34,320
very well but usually if you update

632
00:26:34,320 --> 00:26:36,419
either to the latest version again it

633
00:26:36,419 --> 00:26:38,940
tends to fix things right so if you open

634
00:26:38,940 --> 00:26:41,520
a program and you don't see any function

635
00:26:41,520 --> 00:26:43,559
recognized like this just update either

636
00:26:43,559 --> 00:26:47,159
if it's possible and then things will be

637
00:26:47,159 --> 00:26:49,080
better for you uh one of the things I

638
00:26:49,080 --> 00:26:52,200
want to show is this you see this very

639
00:26:52,200 --> 00:26:54,960
simple program that I had there it looks

640
00:26:54,960 --> 00:26:59,279
like it's I don't know uh yeah 16 lines

641
00:26:59,279 --> 00:27:02,100
big not that much it ends up being

642
00:27:02,100 --> 00:27:04,380
compiled as a two megabytes binary so

643
00:27:04,380 --> 00:27:06,059
that's a lot

644
00:27:06,059 --> 00:27:08,340
and let's see exactly what's in there

645
00:27:08,340 --> 00:27:10,799
so you have many many functions all

646
00:27:10,799 --> 00:27:13,500
these functions come from the uh from

647
00:27:13,500 --> 00:27:17,120
the go runtime and we don't need them

648
00:27:17,120 --> 00:27:21,860
basically one thing I've

649
00:27:21,919 --> 00:27:25,980
uh is that the developer functions they

650
00:27:25,980 --> 00:27:28,860
tend to be put at the end of the list

651
00:27:28,860 --> 00:27:31,760
at the end of the binary so if you are

652
00:27:31,760 --> 00:27:34,200
opening a program at random and don't

653
00:27:34,200 --> 00:27:36,779
really know what to start from just take

654
00:27:36,779 --> 00:27:39,840
the slider all the way down

655
00:27:39,840 --> 00:27:41,820
and usually

656
00:27:41,820 --> 00:27:44,580
at the very end

657
00:27:44,580 --> 00:27:46,919
it turns out to be it tends to be the

658
00:27:46,919 --> 00:27:52,500
case also you will notice that the name

659
00:27:52,500 --> 00:27:54,659
that are given to the bank for instance

660
00:27:54,659 --> 00:27:56,460
we had this uh

661
00:27:56,460 --> 00:27:59,340
function sum there from the main package

662
00:27:59,340 --> 00:28:01,559
and if you go back to either there you

663
00:28:01,559 --> 00:28:06,260
will see that yeah and a function name

664
00:28:06,260 --> 00:28:10,440
and the story case this is a way in

665
00:28:10,440 --> 00:28:11,760
either to

666
00:28:11,760 --> 00:28:14,820
uh to see exactly where the functions

667
00:28:14,820 --> 00:28:16,640
are coming from

668
00:28:16,640 --> 00:28:19,380
so you do get the package name it sort

669
00:28:19,380 --> 00:28:25,020
of helps you figure out uh where the

670
00:28:25,020 --> 00:28:28,580
in which package

671
00:28:46,860 --> 00:28:49,620
I have to share again

672
00:28:49,620 --> 00:28:52,039
right

673
00:28:56,179 --> 00:28:59,100
are we back

674
00:28:59,100 --> 00:29:01,580
all right

675
00:29:03,539 --> 00:29:08,520
so let us start directly from this main

676
00:29:08,520 --> 00:29:11,340
dot main function usually

677
00:29:11,340 --> 00:29:11,940
um

678
00:29:11,940 --> 00:29:14,220
as far as I can tell the entry point of

679
00:29:14,220 --> 00:29:16,860
ego program is always this main menu so

680
00:29:16,860 --> 00:29:18,779
that's helpful

681
00:29:18,779 --> 00:29:24,020
and you know let's see here exactly

682
00:29:24,299 --> 00:29:26,760
in this function where is the code that

683
00:29:26,760 --> 00:29:28,679
we wrote right so we do recognize this

684
00:29:28,679 --> 00:29:32,279
result equal there so that that much we

685
00:29:32,279 --> 00:29:34,020
can recognize

686
00:29:34,020 --> 00:29:34,980
um

687
00:29:34,980 --> 00:29:37,799
but already you know it looks very

688
00:29:37,799 --> 00:29:40,260
different from the from the code that we

689
00:29:40,260 --> 00:29:43,140
had initial now your intuition might be

690
00:29:43,140 --> 00:29:47,700
to just press F5 and try to see like if

691
00:29:47,700 --> 00:29:50,100
maybe the decompiler can help you it's

692
00:29:50,100 --> 00:29:53,760
not too bad there but as we will see uh

693
00:29:53,760 --> 00:29:57,360
later on it's not usually uh that's

694
00:29:57,360 --> 00:29:59,719
helpful

695
00:30:01,320 --> 00:30:03,299
it turns out that yeah for this simple

696
00:30:03,299 --> 00:30:05,159
example the compiler is actually not

697
00:30:05,159 --> 00:30:07,080
doing too bad but as we will see in the

698
00:30:07,080 --> 00:30:09,299
next example of this not really usable

699
00:30:09,299 --> 00:30:10,980
at all so let's forget about the

700
00:30:10,980 --> 00:30:13,740
pseudocoups now and let's try to see

701
00:30:13,740 --> 00:30:16,200
exactly where the first line of our

702
00:30:16,200 --> 00:30:18,960
program was so the first line was a call

703
00:30:18,960 --> 00:30:21,740
to this some function there right

704
00:30:21,740 --> 00:30:25,140
and it turns out to be here so it means

705
00:30:25,140 --> 00:30:27,419
that probably

706
00:30:27,419 --> 00:30:29,220
um well these are the arguments being

707
00:30:29,220 --> 00:30:31,980
pushed or being given to the program but

708
00:30:31,980 --> 00:30:34,260
everything that came up above all that

709
00:30:34,260 --> 00:30:36,840
and also this is actually stuff that was

710
00:30:36,840 --> 00:30:38,940
added by the compiler right

711
00:30:38,940 --> 00:30:42,240
uh this structure there is uh or it's

712
00:30:42,240 --> 00:30:43,740
not really structured with this uh

713
00:30:43,740 --> 00:30:47,880
construct that we see move rcx gs28

714
00:30:47,880 --> 00:30:51,000
Etc plus uh going here is something we

715
00:30:51,000 --> 00:30:53,039
see very often in those programs uh it

716
00:30:53,039 --> 00:30:54,840
looks like they are I I think it's

717
00:30:54,840 --> 00:30:56,580
related to making sure that the the

718
00:30:56,580 --> 00:30:58,399
stack has enough space for everything

719
00:30:58,399 --> 00:31:01,980
basically we never ever have to worry

720
00:31:01,980 --> 00:31:05,640
about that so one thing I sometimes do

721
00:31:05,640 --> 00:31:08,760
is I just color the blocks like this

722
00:31:08,760 --> 00:31:11,340
just to materialize the fact that I

723
00:31:11,340 --> 00:31:15,360
don't care about them so everything here

724
00:31:15,360 --> 00:31:16,740
we don't care about much we don't even

725
00:31:16,740 --> 00:31:18,960
have to look at it it's just anybody

726
00:31:18,960 --> 00:31:20,880
compiler and we'll never have any impact

727
00:31:20,880 --> 00:31:24,120
on whatever we are doing in our analysis

728
00:31:24,120 --> 00:31:25,980
so let us see

729
00:31:25,980 --> 00:31:29,720
our function tool there so we have

730
00:31:29,720 --> 00:31:33,059
this placement of all our arguments one

731
00:31:33,059 --> 00:31:35,100
ten and a hundred see here we have the

732
00:31:35,100 --> 00:31:37,020
call to the sum function with arguments

733
00:31:37,020 --> 00:31:39,899
110 and then 100.

734
00:31:39,899 --> 00:31:43,260
and so here they are being passed onto

735
00:31:43,260 --> 00:31:46,020
the stack there now

736
00:31:46,020 --> 00:31:48,299
Ida is not doing super well already

737
00:31:48,299 --> 00:31:49,740
because you see that you have this

738
00:31:49,740 --> 00:31:53,820
offset uh related to the to RSP you

739
00:31:53,820 --> 00:31:56,580
don't really like to see this but okay

740
00:31:56,580 --> 00:31:58,679
one of the things I want to point out is

741
00:31:58,679 --> 00:32:00,059
that here

742
00:32:00,059 --> 00:32:03,240
you would be tempted to rename this VAR

743
00:32:03,240 --> 00:32:06,720
88 something like art

744
00:32:06,720 --> 00:32:08,520
one something like this right or are

745
00:32:08,520 --> 00:32:10,679
some one because when you're reverse

746
00:32:10,679 --> 00:32:12,120
engineering your program and what you

747
00:32:12,120 --> 00:32:13,559
want to do is you want to rename things

748
00:32:13,559 --> 00:32:15,120
right this is the way that it's supposed

749
00:32:15,120 --> 00:32:16,860
to work you recognize something you name

750
00:32:16,860 --> 00:32:18,480
it and then you move on and then when

751
00:32:18,480 --> 00:32:20,100
you have renamed everything then

752
00:32:20,100 --> 00:32:22,140
hopefully you will you understand what

753
00:32:22,140 --> 00:32:23,159
everything was and you understand what

754
00:32:23,159 --> 00:32:25,320
the program does now you will notice

755
00:32:25,320 --> 00:32:28,440
that unfortunately this variable there

756
00:32:28,440 --> 00:32:31,260
is actually being reviewed somewhere

757
00:32:31,260 --> 00:32:33,059
else

758
00:32:33,059 --> 00:32:37,500
and maybe somewhere there as well and it

759
00:32:37,500 --> 00:32:40,260
turns out that these future uses have

760
00:32:40,260 --> 00:32:42,120
actually nothing to do with this initial

761
00:32:42,120 --> 00:32:42,840
one

762
00:32:42,840 --> 00:32:44,880
uh it's another thing that's super

763
00:32:44,880 --> 00:32:46,860
annoying for us when we go language it's

764
00:32:46,860 --> 00:32:49,799
the fact that when there are spot when

765
00:32:49,799 --> 00:32:52,620
there are regions on the stack that are

766
00:32:52,620 --> 00:32:54,240
not used anymore by the program then the

767
00:32:54,240 --> 00:32:55,980
book of Valor is happy to reuse them

768
00:32:55,980 --> 00:32:57,779
again for other stuff and that means

769
00:32:57,779 --> 00:32:59,880
that if you rename a variable sometime

770
00:32:59,880 --> 00:33:01,860
at some point in the program then the

771
00:33:01,860 --> 00:33:03,779
next key might not be the same at all

772
00:33:03,779 --> 00:33:04,919
right it might be used for something

773
00:33:04,919 --> 00:33:06,899
different entirely because the compiler

774
00:33:06,899 --> 00:33:08,700
is being smart about it and so renaming

775
00:33:08,700 --> 00:33:10,020
things is actually going to be totally

776
00:33:10,020 --> 00:33:11,520
useless for you and it's very

777
00:33:11,520 --> 00:33:14,279
unfortunate but it is the case and this

778
00:33:14,279 --> 00:33:16,080
is a simple example there but you will

779
00:33:16,080 --> 00:33:18,240
see later on uh when the functions are

780
00:33:18,240 --> 00:33:20,519
bigger than this and you know any

781
00:33:20,519 --> 00:33:22,200
position on the stack may be used for

782
00:33:22,200 --> 00:33:23,820
three four even ten very ten different

783
00:33:23,820 --> 00:33:26,580
variables and so renaming them uh it's

784
00:33:26,580 --> 00:33:29,820
just not going to lead you anywhere so

785
00:33:29,820 --> 00:33:31,679
one of the things you can do instead of

786
00:33:31,679 --> 00:33:32,940
having those names that are just

787
00:33:32,940 --> 00:33:35,399
confusing and useless is right click I

788
00:33:35,399 --> 00:33:37,679
think I don't know if you can do it with

789
00:33:37,679 --> 00:33:38,720
uh

790
00:33:38,720 --> 00:33:42,120
yeah I think the hotkeys okay there or

791
00:33:42,120 --> 00:33:44,399
it's right there as well we can just

792
00:33:44,399 --> 00:33:46,740
delete the variable names and you have

793
00:33:46,740 --> 00:33:48,899
you can use just the offsets directly

794
00:33:48,899 --> 00:33:51,600
like you see RSP RSP plus eight RSP plus

795
00:33:51,600 --> 00:33:54,059
10. you don't have a variable anymore

796
00:33:54,059 --> 00:33:56,159
but it will make following things around

797
00:33:56,159 --> 00:33:58,980
a bit more easy

798
00:33:58,980 --> 00:34:01,080
because anyway renaming things is not

799
00:34:01,080 --> 00:34:03,960
going to be useful so like why bother I

800
00:34:03,960 --> 00:34:05,220
do not recommend that you go through

801
00:34:05,220 --> 00:34:06,600
every single variable and do this

802
00:34:06,600 --> 00:34:08,219
because it's going to be very time

803
00:34:08,219 --> 00:34:10,619
consuming but when you're beginning and

804
00:34:10,619 --> 00:34:12,239
when you are trying to figure out where

805
00:34:12,239 --> 00:34:14,219
things are in the program then at least

806
00:34:14,219 --> 00:34:16,500
you know it turns out that RSP plus 60

807
00:34:16,500 --> 00:34:18,540
or plus 70 is going to be more

808
00:34:18,540 --> 00:34:20,219
meaningful than any name that you can

809
00:34:20,219 --> 00:34:21,679
put there

810
00:34:21,679 --> 00:34:23,879
so anyway

811
00:34:23,879 --> 00:34:26,639
let's see exactly what happens so we

812
00:34:26,639 --> 00:34:27,540
have

813
00:34:27,540 --> 00:34:31,260
this argument number one pushed on RSP

814
00:34:31,260 --> 00:34:33,839
so on the stack or it's not a push there

815
00:34:33,839 --> 00:34:36,239
but they just move it directly at the

816
00:34:36,239 --> 00:34:38,339
correct offset RSP plus eight and three

817
00:34:38,339 --> 00:34:41,520
plus ten and so on of course this is a

818
00:34:41,520 --> 00:34:44,460
program compiled for x64 and this is the

819
00:34:44,460 --> 00:34:46,199
reason why all of our integers are the

820
00:34:46,199 --> 00:34:48,300
size of 8 bytes

821
00:34:48,300 --> 00:34:52,560
so let's get into our sum function

822
00:34:52,560 --> 00:34:53,760
so

823
00:34:53,760 --> 00:34:57,420
here sort of simple in this case Ida is

824
00:34:57,420 --> 00:35:00,720
able to recognize the arguments and you

825
00:35:00,720 --> 00:35:05,820
just put audio into RX add R8 add r10

826
00:35:05,820 --> 00:35:08,280
and then you notice that the return

827
00:35:08,280 --> 00:35:12,180
value is not being well it is in Rex but

828
00:35:12,180 --> 00:35:15,359
it's not being returned through Rex it

829
00:35:15,359 --> 00:35:17,579
is just pushed back on the stack

830
00:35:17,579 --> 00:35:21,540
uh to see RSP Plus 20.

831
00:35:21,540 --> 00:35:24,300
and then when you go back you see that

832
00:35:24,300 --> 00:35:28,079
RSP plus 18 is being moved back to Rex

833
00:35:28,079 --> 00:35:29,400
so maybe I should explain a little bit

834
00:35:29,400 --> 00:35:30,359
there

835
00:35:30,359 --> 00:35:32,520
so this is the return value

836
00:35:32,520 --> 00:35:36,060
but after you return from the function

837
00:35:36,060 --> 00:35:39,060
you know this return operand is actually

838
00:35:39,060 --> 00:35:40,800
going to pop a return address from the

839
00:35:40,800 --> 00:35:41,940
stack so this is why you have a

840
00:35:41,940 --> 00:35:43,619
difference in offset between the two uh

841
00:35:43,619 --> 00:35:45,119
functions is that is that okay with

842
00:35:45,119 --> 00:35:46,320
everyone

843
00:35:46,320 --> 00:35:49,380
it's sort of a not super important

844
00:35:49,380 --> 00:35:51,720
detail but it's kind of

845
00:35:51,720 --> 00:35:55,020
I just want to remind you that the

846
00:35:55,020 --> 00:35:57,240
offsets that you see in one function

847
00:35:57,240 --> 00:35:59,220
are not going to be the same as the one

848
00:35:59,220 --> 00:36:00,839
you see in the calling function because

849
00:36:00,839 --> 00:36:03,180
between the two due to the function pool

850
00:36:03,180 --> 00:36:05,460
due to the return operand that retrieves

851
00:36:05,460 --> 00:36:06,720
an address from the stack the return

852
00:36:06,720 --> 00:36:09,359
address then you will see an offset and

853
00:36:09,359 --> 00:36:11,880
so even then trying to recognize the

854
00:36:11,880 --> 00:36:13,619
numbers in London and work

855
00:36:13,619 --> 00:36:15,119
the good thing is we're not going to

856
00:36:15,119 --> 00:36:17,540
bother too much

857
00:36:17,640 --> 00:36:22,460
anyway so what happens next is

858
00:36:22,560 --> 00:36:25,800
kind of very difficult to decipher you

859
00:36:25,800 --> 00:36:28,560
see that like you start using the xmm

860
00:36:28,560 --> 00:36:31,320
registers there is this

861
00:36:31,320 --> 00:36:35,280
type being loaded into Rex it's a

862
00:36:35,280 --> 00:36:38,460
structure we won't bother about this one

863
00:36:38,460 --> 00:36:40,020
at the moment we do see our results

864
00:36:40,020 --> 00:36:43,260
string somewhere here

865
00:36:43,260 --> 00:36:46,740
yeah there it is and by the way one

866
00:36:46,740 --> 00:36:49,980
thing I can mention here is that

867
00:36:49,980 --> 00:36:53,460
strings in uh in Python sorry in in go

868
00:36:53,460 --> 00:36:55,680
language they have this structure where

869
00:36:55,680 --> 00:36:58,920
you have two two Fields the first one is

870
00:36:58,920 --> 00:37:03,180
a pointer to the um it's a pointer to

871
00:37:03,180 --> 00:37:06,180
the um actual byte data and it's

872
00:37:06,180 --> 00:37:08,520
followed by a site so you see here you

873
00:37:08,520 --> 00:37:10,920
have a pointer to some characters

874
00:37:10,920 --> 00:37:12,660
somewhere in memory and the size of nine

875
00:37:12,660 --> 00:37:15,540
which is one two three six seven eight

876
00:37:15,540 --> 00:37:19,320
nine to the side of the string yeah so

877
00:37:19,320 --> 00:37:21,839
go here

878
00:37:21,839 --> 00:37:23,520
there you will see all the strings of

879
00:37:23,520 --> 00:37:24,780
the program that are being grouped

880
00:37:24,780 --> 00:37:27,960
together one after the other

881
00:37:27,960 --> 00:37:29,339
okay

882
00:37:29,339 --> 00:37:31,200
sort of a detail so let's not worry

883
00:37:31,200 --> 00:37:33,480
about this too much but you will see

884
00:37:33,480 --> 00:37:37,020
that here already figuring out what is

885
00:37:37,020 --> 00:37:38,700
happening there

886
00:37:38,700 --> 00:37:41,640
is kind of difficult right

887
00:37:41,640 --> 00:37:45,540
oh where like the the line that we have

888
00:37:45,540 --> 00:37:47,099
is this

889
00:37:47,099 --> 00:37:49,800
format dot println result equal and then

890
00:37:49,800 --> 00:37:50,599
rest

891
00:37:50,599 --> 00:37:54,859
and it translates to this very complex

892
00:37:54,859 --> 00:37:58,500
series of calls there with the creation

893
00:37:58,500 --> 00:38:02,040
of a string type a conversion

894
00:38:02,040 --> 00:38:05,520
to maybe an integer type there you have

895
00:38:05,520 --> 00:38:08,520
this thing that was nowhere in our

896
00:38:08,520 --> 00:38:10,140
initial code see this runtime bright

897
00:38:10,140 --> 00:38:11,700
barrier we did not write that practice

898
00:38:11,700 --> 00:38:14,940
not in our initial program

899
00:38:14,940 --> 00:38:16,920
so this is more stuff that the compiler

900
00:38:16,920 --> 00:38:18,900
added I think it's related to garbage

901
00:38:18,900 --> 00:38:21,060
collection we don't have to worry about

902
00:38:21,060 --> 00:38:22,800
it too much because

903
00:38:22,800 --> 00:38:24,660
it doesn't like doesn't have any

904
00:38:24,660 --> 00:38:26,220
influence on what the program means but

905
00:38:26,220 --> 00:38:28,260
it's there it's sort of getting in the

906
00:38:28,260 --> 00:38:29,099
way

907
00:38:29,099 --> 00:38:31,380
and then you have all this

908
00:38:31,380 --> 00:38:36,359
very weird moving around stuff uh here

909
00:38:36,359 --> 00:38:38,400
on the stack in and out

910
00:38:38,400 --> 00:38:39,240
um

911
00:38:39,240 --> 00:38:41,339
and already uh we can see that we are

912
00:38:41,339 --> 00:38:42,720
reaching some sort of wall of complexity

913
00:38:42,720 --> 00:38:45,540
we're trying to track every single

914
00:38:45,540 --> 00:38:47,280
position on the stack is going to be

915
00:38:47,280 --> 00:38:49,500
extremely difficult so we need to we

916
00:38:49,500 --> 00:38:51,060
will have to find another way than just

917
00:38:51,060 --> 00:38:52,500
to try to understand any single

918
00:38:52,500 --> 00:38:54,839
instruction because I don't think

919
00:38:54,839 --> 00:38:57,060
there's any way that I don't think it's

920
00:38:57,060 --> 00:38:58,500
humanly possible at least it's not

921
00:38:58,500 --> 00:39:00,300
possible for me to track everything

922
00:39:00,300 --> 00:39:03,720
but we do at the end of the day see our

923
00:39:03,720 --> 00:39:06,000
format.print Ln

924
00:39:06,000 --> 00:39:10,160
um call which corresponded to this here

925
00:39:10,160 --> 00:39:12,720
all right

926
00:39:12,720 --> 00:39:16,260
so our first

927
00:39:16,260 --> 00:39:19,200
encounter with compilable programs was I

928
00:39:19,200 --> 00:39:21,060
would say a little bit frustrating in

929
00:39:21,060 --> 00:39:22,560
the sense that we were able to kind of

930
00:39:22,560 --> 00:39:24,780
see what we had written initially in the

931
00:39:24,780 --> 00:39:26,880
program but also there are so many there

932
00:39:26,880 --> 00:39:29,760
are so many things taking place that it

933
00:39:29,760 --> 00:39:32,339
feels like if we were looking at a known

934
00:39:32,339 --> 00:39:33,839
program then we would not be able to

935
00:39:33,839 --> 00:39:36,420
follow through right so let us look at

936
00:39:36,420 --> 00:39:39,300
another one and see this intuition this

937
00:39:39,300 --> 00:39:40,800
confirm itself

938
00:39:40,800 --> 00:39:44,040
so I'm going to show you example number

939
00:39:44,040 --> 00:39:46,320
two and you will see that this example

940
00:39:46,320 --> 00:39:49,140
number two is sort of the same thing

941
00:39:49,140 --> 00:39:53,640
right it starts with a main function but

942
00:39:53,640 --> 00:39:56,579
this time our sum function it doesn't

943
00:39:56,579 --> 00:39:58,740
just return an integer it returns an

944
00:39:58,740 --> 00:40:00,960
integer and then a string and then an

945
00:40:00,960 --> 00:40:03,180
error which is like returning an error

946
00:40:03,180 --> 00:40:05,280
as I mentioned is something that most go

947
00:40:05,280 --> 00:40:07,800
functions do this is the very

948
00:40:07,800 --> 00:40:11,220
go away of doing things

949
00:40:11,220 --> 00:40:13,320
so the sum function returns a plus b

950
00:40:13,320 --> 00:40:15,660
plus C like earlier it also returns

951
00:40:15,660 --> 00:40:18,900
hello and finally it returns a new error

952
00:40:18,900 --> 00:40:21,960
which is a whatever a fake error and now

953
00:40:21,960 --> 00:40:24,780
our main function is sort of the same as

954
00:40:24,780 --> 00:40:27,900
before uh we call this uh some function

955
00:40:27,900 --> 00:40:30,660
get and we collect all the return values

956
00:40:30,660 --> 00:40:33,180
and then if the error is not nil

957
00:40:33,180 --> 00:40:36,720
we do print the uh string and the uh and

958
00:40:36,720 --> 00:40:39,540
the result that's it

959
00:40:39,540 --> 00:40:42,780
so it's not that different from what we

960
00:40:42,780 --> 00:40:44,700
had earlier but you will see that in the

961
00:40:44,700 --> 00:40:47,640
assembly what was already pretty complex

962
00:40:47,640 --> 00:40:50,460
now becomes frankly impossible to read

963
00:40:50,460 --> 00:40:53,400
as far as it insert so let's check it

964
00:40:53,400 --> 00:40:55,520
out

965
00:41:03,640 --> 00:41:06,599
[Music]

966
00:41:06,599 --> 00:41:08,579
again I'm loading the program it's going

967
00:41:08,579 --> 00:41:11,700
to take a few seconds for idat to go

968
00:41:11,700 --> 00:41:14,180
through everything

969
00:41:14,280 --> 00:41:16,980
I guess I can already go in my main

970
00:41:16,980 --> 00:41:19,820
document function

971
00:41:23,099 --> 00:41:24,480
all right

972
00:41:24,480 --> 00:41:27,300
and here if you press F5 then you will

973
00:41:27,300 --> 00:41:30,200
see that you start having

974
00:41:30,200 --> 00:41:32,339
undefined values

975
00:41:32,339 --> 00:41:35,400
under different variables that do not

976
00:41:35,400 --> 00:41:37,020
appear to be created anywhere or

977
00:41:37,020 --> 00:41:39,599
initialized anywhere is because Ida

978
00:41:39,599 --> 00:41:41,099
doesn't really like having stuff coming

979
00:41:41,099 --> 00:41:42,900
from the stack like this

980
00:41:42,900 --> 00:41:45,420
as far as I can tell and of course I

981
00:41:45,420 --> 00:41:46,859
mean there's always going to be this

982
00:41:46,859 --> 00:41:49,500
sort of hard limits where you cannot

983
00:41:49,500 --> 00:41:52,560
represent a go program as a sort of

984
00:41:52,560 --> 00:41:55,980
pseudo C code at all because this

985
00:41:55,980 --> 00:41:58,440
context or this concept having you know

986
00:41:58,440 --> 00:41:59,760
multiple different values just does not

987
00:41:59,760 --> 00:42:01,320
work it doesn't translate in C so you

988
00:42:01,320 --> 00:42:04,280
see there you have this main dot sample

989
00:42:04,280 --> 00:42:07,020
it's supposed to get three written

990
00:42:07,020 --> 00:42:09,780
values and then you see that Ida is

991
00:42:09,780 --> 00:42:11,760
really not able to see that there are

992
00:42:11,760 --> 00:42:13,200
actually original that has been

993
00:42:13,200 --> 00:42:15,780
collected in some cases I even seen

994
00:42:15,780 --> 00:42:17,760
either missed out entire lines and

995
00:42:17,760 --> 00:42:20,180
anti-function codes so

996
00:42:20,180 --> 00:42:22,560
right honestly if you are going to work

997
00:42:22,560 --> 00:42:24,300
on those programs I will recommend that

998
00:42:24,300 --> 00:42:25,940
you do not ever

999
00:42:25,940 --> 00:42:29,099
rely on the pseudo code because it it

1000
00:42:29,099 --> 00:42:31,740
just doesn't work it really doesn't

1001
00:42:31,740 --> 00:42:35,540
so we will have to make do with our

1002
00:42:35,540 --> 00:42:39,540
disassembly there so we see at the

1003
00:42:39,540 --> 00:42:41,160
beginning of our main function the same

1004
00:42:41,160 --> 00:42:42,839
thing that we've seen before which is

1005
00:42:42,839 --> 00:42:45,960
first of all this sort of setup with uh

1006
00:42:45,960 --> 00:42:48,300
this uh function that supposedly

1007
00:42:48,300 --> 00:42:50,579
verifies that the stack is big enough

1008
00:42:50,579 --> 00:42:53,640
we do have the same thing that we had

1009
00:42:53,640 --> 00:42:54,839
before

1010
00:42:54,839 --> 00:42:57,240
it was the best thing of arguments or

1011
00:42:57,240 --> 00:42:59,940
main function but this time you see that

1012
00:42:59,940 --> 00:43:02,280
it's been passed through registers the

1013
00:43:02,280 --> 00:43:04,500
reason for this is that this time I

1014
00:43:04,500 --> 00:43:06,119
compiled this function with another

1015
00:43:06,119 --> 00:43:09,300
Google version let's check out which one

1016
00:43:09,300 --> 00:43:11,220
I'm just going to open my trusty hex

1017
00:43:11,220 --> 00:43:13,879
editor again

1018
00:43:17,920 --> 00:43:20,999
[Music]

1019
00:43:23,460 --> 00:43:26,000
all right

1020
00:43:29,480 --> 00:43:31,920
yeah and you see this one was compiled

1021
00:43:31,920 --> 00:43:35,819
with go 1.18 this is a more recent

1022
00:43:35,819 --> 00:43:38,280
version and so this is why this new

1023
00:43:38,280 --> 00:43:40,800
function that we have here this new

1024
00:43:40,800 --> 00:43:43,140
program actually uses the register-based

1025
00:43:43,140 --> 00:43:45,720
API so this way you can you can see both

1026
00:43:45,720 --> 00:43:47,880
of them you have seen both of them so

1027
00:43:47,880 --> 00:43:50,640
this time we move one and ax 10 in egx

1028
00:43:50,640 --> 00:43:52,859
and 100 in PCX

1029
00:43:52,859 --> 00:43:55,380
so again passing the arguments

1030
00:43:55,380 --> 00:43:57,540
that were here

1031
00:43:57,540 --> 00:43:59,819
then we call our sump function and

1032
00:43:59,819 --> 00:44:03,180
supposedly we're supposed to get three

1033
00:44:03,180 --> 00:44:05,400
return values collected from this

1034
00:44:05,400 --> 00:44:07,880
function pool

1035
00:44:09,180 --> 00:44:12,319
so web is called to the

1036
00:44:12,319 --> 00:44:14,400
main.sum function we will get in there

1037
00:44:14,400 --> 00:44:16,380
in a bit but then you will see that when

1038
00:44:16,380 --> 00:44:17,579
we come back

1039
00:44:17,579 --> 00:44:21,780
um then we have Rex RBX and rcx in which

1040
00:44:21,780 --> 00:44:23,339
the return values are being stored that

1041
00:44:23,339 --> 00:44:26,460
get moved back on the stack here

1042
00:44:26,460 --> 00:44:28,500
and again like you might be tempted to

1043
00:44:28,500 --> 00:44:30,720
rename this to

1044
00:44:30,720 --> 00:44:32,520
what was the

1045
00:44:32,520 --> 00:44:34,980
to rest but if we were to rename this to

1046
00:44:34,980 --> 00:44:36,720
rest

1047
00:44:36,720 --> 00:44:38,579
like that

1048
00:44:38,579 --> 00:44:41,640
and you will see that later on let me

1049
00:44:41,640 --> 00:44:44,359
highlighted

1050
00:44:46,079 --> 00:44:50,040
it doesn't get reused this time okay

1051
00:44:50,040 --> 00:44:52,260
but in any case

1052
00:44:52,260 --> 00:44:53,700
this has not been to help us too much

1053
00:44:53,700 --> 00:44:55,980
now

1054
00:44:55,980 --> 00:44:57,839
if you see here

1055
00:44:57,839 --> 00:45:01,020
already it feels like there's no way

1056
00:45:01,020 --> 00:45:02,160
we're ever going to be able to follow

1057
00:45:02,160 --> 00:45:06,119
that right we had a very simple

1058
00:45:06,119 --> 00:45:09,300
main function that was four lines I mean

1059
00:45:09,300 --> 00:45:10,859
four lines is not that big right

1060
00:45:10,859 --> 00:45:13,560
supposedly and it ends up being this

1061
00:45:13,560 --> 00:45:16,020
huge monster of values being moved

1062
00:45:16,020 --> 00:45:18,180
around being on the translated or

1063
00:45:18,180 --> 00:45:22,079
converted into various things and just

1064
00:45:22,079 --> 00:45:26,579
following this is a nightmare

1065
00:45:26,579 --> 00:45:31,319
personally I gave up a long time ago so

1066
00:45:31,319 --> 00:45:34,740
let's think of a way that we could do

1067
00:45:34,740 --> 00:45:37,079
this a little bit easier

1068
00:45:37,079 --> 00:45:39,420
and to do so we are actually going to

1069
00:45:39,420 --> 00:45:41,880
move on to our real life malware sample

1070
00:45:41,880 --> 00:45:44,460
which is sunshadow

1071
00:45:44,460 --> 00:45:46,380
just check out if there's something in

1072
00:45:46,380 --> 00:45:48,180
this uh

1073
00:45:48,180 --> 00:45:50,160
some function that is worth showing I

1074
00:45:50,160 --> 00:45:52,500
don't think it's the case but we do

1075
00:45:52,500 --> 00:45:55,140
recognize that some of the stuff that we

1076
00:45:55,140 --> 00:45:56,819
have written like this creation of a new

1077
00:45:56,819 --> 00:45:59,160
error object this creation of our hello

1078
00:45:59,160 --> 00:46:02,520
world string one way or another but

1079
00:46:02,520 --> 00:46:04,500
overall

1080
00:46:04,500 --> 00:46:08,040
overall things they this is the reason

1081
00:46:08,040 --> 00:46:10,380
why most people when they encounter go

1082
00:46:10,380 --> 00:46:11,880
for the first time they tend to give up

1083
00:46:11,880 --> 00:46:12,900
because

1084
00:46:12,900 --> 00:46:15,480
I mean it looks extremely complex and in

1085
00:46:15,480 --> 00:46:17,339
ways that are actually graduated right

1086
00:46:17,339 --> 00:46:19,819
why why does it need to do so many

1087
00:46:19,819 --> 00:46:22,680
operations what do I think why does it

1088
00:46:22,680 --> 00:46:24,420
need to move so many things around on

1089
00:46:24,420 --> 00:46:26,040
the stack just to do those simple things

1090
00:46:26,040 --> 00:46:28,680
we're asking right it's a good question

1091
00:46:28,680 --> 00:46:31,380
and my solution to this complexity is

1092
00:46:31,380 --> 00:46:32,880
that we're just going to ignore it

1093
00:46:32,880 --> 00:46:34,440
entirely

1094
00:46:34,440 --> 00:46:36,599
we will just not bother with all those

1095
00:46:36,599 --> 00:46:38,700
operations and try to figure things out

1096
00:46:38,700 --> 00:46:42,480
another way that so with that in mind

1097
00:46:42,480 --> 00:46:46,800
let's move on to our next sample which

1098
00:46:46,800 --> 00:46:49,520
is sunshadow

1099
00:46:56,720 --> 00:46:59,520
so here I already had an ID for some

1100
00:46:59,520 --> 00:47:02,940
shuttles so I hope I don't leave any

1101
00:47:02,940 --> 00:47:05,400
notes in there I don't think so

1102
00:47:05,400 --> 00:47:07,880
because again annotating

1103
00:47:07,880 --> 00:47:11,220
annotating idbs for go programs is not

1104
00:47:11,220 --> 00:47:13,079
going to be super helpful

1105
00:47:13,079 --> 00:47:17,660
so we do at the very end of this

1106
00:47:17,660 --> 00:47:20,579
function window and you see that there

1107
00:47:20,579 --> 00:47:24,119
are a number of functions there in the

1108
00:47:24,119 --> 00:47:27,359
main package and all the rest appears to

1109
00:47:27,359 --> 00:47:30,720
be stuff that comes out of the um

1110
00:47:30,720 --> 00:47:34,800
of the Google Live standard Library

1111
00:47:34,800 --> 00:47:36,300
um

1112
00:47:36,300 --> 00:47:38,119
let me actually show you something

1113
00:47:38,119 --> 00:47:40,980
that's pretty cool I mentioned earlier

1114
00:47:40,980 --> 00:47:43,260
that there was this uh collection of

1115
00:47:43,260 --> 00:47:46,260
plugins that were available on GitHub

1116
00:47:46,260 --> 00:47:50,400
from the sensible one researcher

1117
00:47:50,400 --> 00:47:52,740
um one of the various

1118
00:47:52,740 --> 00:47:54,900
scripts that is in this repository is

1119
00:47:54,900 --> 00:47:58,740
called well what it does is it uses this

1120
00:47:58,740 --> 00:48:00,900
feature of Ida where you can classify

1121
00:48:00,900 --> 00:48:03,420
functions into folders it's it was

1122
00:48:03,420 --> 00:48:05,700
introduced now some time ago uh it's not

1123
00:48:05,700 --> 00:48:07,160
used that much

1124
00:48:07,160 --> 00:48:09,839
as far as I can tell but it's really a

1125
00:48:09,839 --> 00:48:11,339
super useful feature so the way you

1126
00:48:11,339 --> 00:48:12,839
enable it is you can right click there

1127
00:48:12,839 --> 00:48:14,880
and click show folders

1128
00:48:14,880 --> 00:48:17,579
but initially of course you know you

1129
00:48:17,579 --> 00:48:19,920
have all you have only a single folder

1130
00:48:19,920 --> 00:48:21,900
everything is the same folder right

1131
00:48:21,900 --> 00:48:23,579
and if you want to you can then create

1132
00:48:23,579 --> 00:48:25,079
folders I don't know where it is exactly

1133
00:48:25,079 --> 00:48:27,359
you don't remember oh yeah create folder

1134
00:48:27,359 --> 00:48:29,220
with items and so on so you can create

1135
00:48:29,220 --> 00:48:30,900
folders move the functions in there it

1136
00:48:30,900 --> 00:48:33,240
allows you to sort things out and to

1137
00:48:33,240 --> 00:48:36,240
make them a bit easier to access

1138
00:48:36,240 --> 00:48:39,960
so what I what this uh script does is it

1139
00:48:39,960 --> 00:48:41,700
will create folders for all the packages

1140
00:48:41,700 --> 00:48:43,140
and sort everything in the correct

1141
00:48:43,140 --> 00:48:46,319
folder so I'm just going to I don't

1142
00:48:46,319 --> 00:48:48,119
think the script is present on your VMS

1143
00:48:48,119 --> 00:48:49,800
initially but I'm just going to run this

1144
00:48:49,800 --> 00:48:51,260
on my own

1145
00:48:51,260 --> 00:48:54,660
and this is a categorizable folders

1146
00:48:54,660 --> 00:48:56,160
there I'm just going to run it hopefully

1147
00:48:56,160 --> 00:48:58,560
it still works okay and you see here it

1148
00:48:58,560 --> 00:49:02,339
created all these folders and uh sort

1149
00:49:02,339 --> 00:49:06,859
everything according to the package so

1150
00:49:07,079 --> 00:49:09,720
I personally think it's super helpful

1151
00:49:09,720 --> 00:49:12,780
because what it does is it allows you to

1152
00:49:12,780 --> 00:49:15,960
take away all the various functions that

1153
00:49:15,960 --> 00:49:17,220
come from the standard Library

1154
00:49:17,220 --> 00:49:19,260
everything that comes from the OS

1155
00:49:19,260 --> 00:49:20,359
package

1156
00:49:20,359 --> 00:49:22,260
package or whatever

1157
00:49:22,260 --> 00:49:24,000
and puts them away so you don't really

1158
00:49:24,000 --> 00:49:25,800
have to look at them anymore and you see

1159
00:49:25,800 --> 00:49:28,619
here that the only package I'm left with

1160
00:49:28,619 --> 00:49:31,619
or there's this unnamed thing maybe we

1161
00:49:31,619 --> 00:49:33,000
can look at later but

1162
00:49:33,000 --> 00:49:36,420
even a real life malware like shuttle

1163
00:49:36,420 --> 00:49:39,060
you see that at the end of the day the

1164
00:49:39,060 --> 00:49:41,280
only functions that we care about are

1165
00:49:41,280 --> 00:49:43,319
those ones right they they appear to be

1166
00:49:43,319 --> 00:49:44,940
the only ones that we have written by

1167
00:49:44,940 --> 00:49:46,740
the malware developer so that's pretty

1168
00:49:46,740 --> 00:49:49,020
cool it means that although we have this

1169
00:49:49,020 --> 00:49:51,300
five megabyte binary

1170
00:49:51,300 --> 00:49:52,980
yeah exactly even though we have this

1171
00:49:52,980 --> 00:49:54,480
five megabyte binary we actually only

1172
00:49:54,480 --> 00:49:57,660
have something like

1173
00:49:57,660 --> 00:49:59,700
let's say 20 functions of those and

1174
00:49:59,700 --> 00:50:02,700
that's not that much now of course uh

1175
00:50:02,700 --> 00:50:03,900
the functions that we've seen before

1176
00:50:03,900 --> 00:50:06,540
with our valuable examples hinted that

1177
00:50:06,540 --> 00:50:08,819
it might still be a bit of work but

1178
00:50:08,819 --> 00:50:12,599
let's see how we can tackle this right

1179
00:50:12,599 --> 00:50:15,200
so we are here in our

1180
00:50:15,200 --> 00:50:17,940
main function you see it's quite big if

1181
00:50:17,940 --> 00:50:20,220
you look at the window down there uh the

1182
00:50:20,220 --> 00:50:21,839
graph overview you can see it's pretty

1183
00:50:21,839 --> 00:50:23,099
long so

1184
00:50:23,099 --> 00:50:27,480
not cool but let's see how we can uh

1185
00:50:27,480 --> 00:50:31,200
let's see how we can work through this

1186
00:50:31,200 --> 00:50:32,400
first

1187
00:50:32,400 --> 00:50:34,619
we encounter the same thing that we had

1188
00:50:34,619 --> 00:50:37,440
before uh which was this uh construct

1189
00:50:37,440 --> 00:50:40,079
and this uh call to runtime more stack

1190
00:50:40,079 --> 00:50:43,020
with no ctxt so let's just ignore this

1191
00:50:43,020 --> 00:50:45,240
because we don't care

1192
00:50:45,240 --> 00:50:47,579
the first thing that happens in the main

1193
00:50:47,579 --> 00:50:50,700
function is equal to net dot interfaces

1194
00:50:50,700 --> 00:50:51,960
so

1195
00:50:51,960 --> 00:50:53,880
it's just the same way that our main

1196
00:50:53,880 --> 00:50:56,220
function was we made main document or

1197
00:50:56,220 --> 00:50:58,200
main of the store Main we have this

1198
00:50:58,200 --> 00:50:59,400
function there that comes from the

1199
00:50:59,400 --> 00:51:01,020
standard library and which is the

1200
00:51:01,020 --> 00:51:03,000
interfaces function coming from the net

1201
00:51:03,000 --> 00:51:05,339
package so what is it exactly this is

1202
00:51:05,339 --> 00:51:07,020
not something that the developers wrote

1203
00:51:07,020 --> 00:51:08,280
it's something that comes from the

1204
00:51:08,280 --> 00:51:10,520
standard Library so let's go back here

1205
00:51:10,520 --> 00:51:12,440
you go to

1206
00:51:12,440 --> 00:51:14,940
pkg.go.dev or maybe the former URLs that

1207
00:51:14,940 --> 00:51:16,920
works you look for the next package

1208
00:51:16,920 --> 00:51:19,999
[Music]

1209
00:51:20,819 --> 00:51:22,619
all right

1210
00:51:22,619 --> 00:51:25,260
and then let's look for the interfaces

1211
00:51:25,260 --> 00:51:27,500
called

1212
00:51:30,059 --> 00:51:33,000
all right so there it is

1213
00:51:33,000 --> 00:51:35,640
lo and behold you get the description to

1214
00:51:35,640 --> 00:51:36,839
the function it's not that complex

1215
00:51:36,839 --> 00:51:40,440
really it's a function that returns a

1216
00:51:40,440 --> 00:51:42,540
list of the systems network interfaces

1217
00:51:42,540 --> 00:51:45,420
all right so pretty easy

1218
00:51:45,420 --> 00:51:47,940
and let's look at the arguments so no

1219
00:51:47,940 --> 00:51:49,559
arguments for this function as you can

1220
00:51:49,559 --> 00:51:53,339
see there but you do have here

1221
00:51:53,339 --> 00:51:55,260
a

1222
00:51:55,260 --> 00:51:59,400
the return values so it returns a array

1223
00:51:59,400 --> 00:52:01,559
of interface objects

1224
00:52:01,559 --> 00:52:04,140
and an error so what we are going to do

1225
00:52:04,140 --> 00:52:07,079
now is we are going to try to recreate

1226
00:52:07,079 --> 00:52:09,900
the go code that the developers might

1227
00:52:09,900 --> 00:52:12,480
have written to get to this combined

1228
00:52:12,480 --> 00:52:15,900
binary and this is actually

1229
00:52:15,900 --> 00:52:18,119
well this is actually easier than it

1230
00:52:18,119 --> 00:52:21,180
looks so let me just

1231
00:52:21,180 --> 00:52:23,579
create any program like this so I'm not

1232
00:52:23,579 --> 00:52:25,800
a good developer so if you are then you

1233
00:52:25,800 --> 00:52:28,800
will hopefully forgive my um no mistakes

1234
00:52:28,800 --> 00:52:30,540
but we'll do something that looks sort

1235
00:52:30,540 --> 00:52:33,180
of like let's call this ghost

1236
00:52:33,180 --> 00:52:35,760
so let's call this package

1237
00:52:35,760 --> 00:52:37,980
Main

1238
00:52:37,980 --> 00:52:40,079
and then funk

1239
00:52:40,079 --> 00:52:42,559
Main

1240
00:52:44,160 --> 00:52:46,380
and then

1241
00:52:46,380 --> 00:52:50,099
brackets and we start with equal to net

1242
00:52:50,099 --> 00:52:51,960
Dot

1243
00:52:51,960 --> 00:52:54,119
interface

1244
00:52:54,119 --> 00:52:55,800
like that

1245
00:52:55,800 --> 00:52:57,839
we know that the function takes zero

1246
00:52:57,839 --> 00:53:00,240
arguments from the documentation and we

1247
00:53:00,240 --> 00:53:03,920
also know that in go you are forced to

1248
00:53:03,920 --> 00:53:06,480
collect all the return values so it

1249
00:53:06,480 --> 00:53:09,800
means that we have to do something like

1250
00:53:09,800 --> 00:53:12,300
interface and error we have to collect

1251
00:53:12,300 --> 00:53:14,480
those two so let's write something like

1252
00:53:14,480 --> 00:53:17,839
interfaces or

1253
00:53:20,099 --> 00:53:22,079
and then air

1254
00:53:22,079 --> 00:53:24,420
and then the assignment operator and go

1255
00:53:24,420 --> 00:53:27,800
is a column equal

1256
00:53:29,819 --> 00:53:31,800
so when you see

1257
00:53:31,800 --> 00:53:35,400
here this call to net interfaces you can

1258
00:53:35,400 --> 00:53:37,200
see before that whatever Go version was

1259
00:53:37,200 --> 00:53:38,640
used there there doesn't seem to be any

1260
00:53:38,640 --> 00:53:40,440
arguments they move to the stack or the

1261
00:53:40,440 --> 00:53:41,760
invest around

1262
00:53:41,760 --> 00:53:44,240
so

1263
00:53:44,640 --> 00:53:47,220
this is probably the line the go the

1264
00:53:47,220 --> 00:53:49,740
goal line that was written to get to

1265
00:53:49,740 --> 00:53:51,480
this here

1266
00:53:51,480 --> 00:53:53,640
all right so next

1267
00:53:53,640 --> 00:53:55,920
stuff is happening so by now we know

1268
00:53:55,920 --> 00:53:57,900
that you know we just after the function

1269
00:53:57,900 --> 00:53:59,520
call

1270
00:53:59,520 --> 00:54:02,520
do you see the return values being moved

1271
00:54:02,520 --> 00:54:04,500
back from the stack to the registers

1272
00:54:04,500 --> 00:54:06,420
okay Okay so

1273
00:54:06,420 --> 00:54:08,640
what is going to be done with those we

1274
00:54:08,640 --> 00:54:11,460
don't really know but in any case

1275
00:54:11,460 --> 00:54:14,819
what we see a bit later is we have this

1276
00:54:14,819 --> 00:54:18,420
comparison between something and zero

1277
00:54:18,420 --> 00:54:20,339
and then depending on what happens we go

1278
00:54:20,339 --> 00:54:23,819
into this block or we skip it

1279
00:54:23,819 --> 00:54:25,500
so here

1280
00:54:25,500 --> 00:54:27,900
try to figure out exactly what is at

1281
00:54:27,900 --> 00:54:31,500
inside the VAR underscore dz0 and

1282
00:54:31,500 --> 00:54:34,200
probably if I were to open a whiteboard

1283
00:54:34,200 --> 00:54:35,940
somewhere and Draw Something to

1284
00:54:35,940 --> 00:54:37,200
represent the stack and we'll be able to

1285
00:54:37,200 --> 00:54:39,420
figure out things but I'm just going to

1286
00:54:39,420 --> 00:54:41,940
do a bit of guessing here and think

1287
00:54:41,940 --> 00:54:44,040
about as a go developer what would be

1288
00:54:44,040 --> 00:54:45,540
the natural thing to write there to

1289
00:54:45,540 --> 00:54:51,240
compare with zero well based on what we

1290
00:54:51,240 --> 00:54:53,400
get there I think the very natural thing

1291
00:54:53,400 --> 00:54:55,140
to be to do would be to do something

1292
00:54:55,140 --> 00:54:56,540
like if

1293
00:54:56,540 --> 00:55:00,780
error equals nil

1294
00:55:00,780 --> 00:55:03,800
then we do something

1295
00:55:04,200 --> 00:55:05,780
and otherwise

1296
00:55:05,780 --> 00:55:08,339
right this is

1297
00:55:08,339 --> 00:55:10,260
what the go language wants you to do

1298
00:55:10,260 --> 00:55:11,579
right you call a function you get an

1299
00:55:11,579 --> 00:55:13,260
error object and then you test this

1300
00:55:13,260 --> 00:55:16,559
error object against nil or against zero

1301
00:55:16,559 --> 00:55:19,859
right and so let's see what happens if

1302
00:55:19,859 --> 00:55:22,319
we go into this green

1303
00:55:22,319 --> 00:55:24,119
um into this you know Green branch and

1304
00:55:24,119 --> 00:55:26,760
so it means if this thing we tested was

1305
00:55:26,760 --> 00:55:28,079
indeed zero

1306
00:55:28,079 --> 00:55:32,520
then we just have this call to OS exit

1307
00:55:32,520 --> 00:55:35,280
and we put an argument which appears to

1308
00:55:35,280 --> 00:55:36,660
be zero

1309
00:55:36,660 --> 00:55:38,579
now one of the things I noticed with the

1310
00:55:38,579 --> 00:55:40,400
go language is that it really tends to

1311
00:55:40,400 --> 00:55:44,220
group all the uh arguments just before

1312
00:55:44,220 --> 00:55:46,260
the the call instruction

1313
00:55:46,260 --> 00:55:48,480
so when you have a function call like

1314
00:55:48,480 --> 00:55:50,760
this then immediately before you will

1315
00:55:50,760 --> 00:55:54,000
see move arguments the register remove

1316
00:55:54,000 --> 00:55:57,359
argument to the or the register of the

1317
00:55:57,359 --> 00:55:58,740
stack and whatever

1318
00:55:58,740 --> 00:56:00,839
so if you take

1319
00:56:00,839 --> 00:56:04,260
any call then the instructions this is

1320
00:56:04,260 --> 00:56:05,640
something that I've seen that I've seen

1321
00:56:05,640 --> 00:56:07,079
to be consistent across multiple

1322
00:56:07,079 --> 00:56:09,480
versions I've looked at so it's pretty

1323
00:56:09,480 --> 00:56:14,220
cool uh it means that well if you take a

1324
00:56:14,220 --> 00:56:16,020
language like C or C plus plus sometimes

1325
00:56:16,020 --> 00:56:17,760
the arguments can be moved on the stack

1326
00:56:17,760 --> 00:56:19,980
way before the actual function so even

1327
00:56:19,980 --> 00:56:21,300
though it doesn't happen at least as far

1328
00:56:21,300 --> 00:56:22,800
as I can tell so we should take any

1329
00:56:22,800 --> 00:56:25,380
function call there then immediately

1330
00:56:25,380 --> 00:56:27,900
above you will see the arguments so the

1331
00:56:27,900 --> 00:56:30,780
arguments of our OS dot exit function

1332
00:56:30,780 --> 00:56:33,900
call is going to be zero I could pull up

1333
00:56:33,900 --> 00:56:35,940
documentation there and go and see

1334
00:56:35,940 --> 00:56:39,420
exactly what this OS dot exit function

1335
00:56:39,420 --> 00:56:44,000
is I think it's obvious to everyone

1336
00:56:44,480 --> 00:56:47,400
let's check how many arguments it takes

1337
00:56:47,400 --> 00:56:49,200
anyone right

1338
00:56:49,200 --> 00:56:51,059
okay

1339
00:56:51,059 --> 00:56:54,300
so there it is so function exit it takes

1340
00:56:54,300 --> 00:56:56,400
one argument and then it exits the

1341
00:56:56,400 --> 00:56:57,960
program

1342
00:56:57,960 --> 00:57:01,619
so let's go back here so if our

1343
00:57:01,619 --> 00:57:04,020
object which I assume is error is

1344
00:57:04,020 --> 00:57:07,740
different or is uh is different from nil

1345
00:57:07,740 --> 00:57:09,079
check

1346
00:57:09,079 --> 00:57:11,940
yeah it's probably this then we go there

1347
00:57:11,940 --> 00:57:14,339
and we call Os Exit Zero so let me

1348
00:57:14,339 --> 00:57:17,480
update my code there

1349
00:57:18,660 --> 00:57:23,520
so if we have an error then OS Dot

1350
00:57:23,520 --> 00:57:26,420
capital e

1351
00:57:27,780 --> 00:57:29,700
and that's it so

1352
00:57:29,700 --> 00:57:32,160
as you see here like I'm not really

1353
00:57:32,160 --> 00:57:33,900
looking at the assembly too much but

1354
00:57:33,900 --> 00:57:36,000
just with educated guesses and just by

1355
00:57:36,000 --> 00:57:37,260
looking at the various function calls

1356
00:57:37,260 --> 00:57:39,180
that are performed by the program the

1357
00:57:39,180 --> 00:57:40,980
various Library calls that are

1358
00:57:40,980 --> 00:57:43,980
documented on the internet I am able to

1359
00:57:43,980 --> 00:57:45,900
sort of figure out what is going on in

1360
00:57:45,900 --> 00:57:47,579
the program and this is going to be my

1361
00:57:47,579 --> 00:57:50,099
Global approach right I don't want to

1362
00:57:50,099 --> 00:57:52,740
have to track all the values as they are

1363
00:57:52,740 --> 00:57:54,300
being moved around because this is going

1364
00:57:54,300 --> 00:57:55,680
to take me forever and I'm not sure I'm

1365
00:57:55,680 --> 00:57:57,200
ever going to be able to succeed anyway

1366
00:57:57,200 --> 00:58:01,260
but just looking at the API calls just

1367
00:58:01,260 --> 00:58:02,819
looking at the arguments that are being

1368
00:58:02,819 --> 00:58:04,800
used here and there I'm fairly confident

1369
00:58:04,800 --> 00:58:06,359
that I will be able to understand the

1370
00:58:06,359 --> 00:58:09,900
global ID of the program and if by some

1371
00:58:09,900 --> 00:58:12,059
uh if I encounter something that is a

1372
00:58:12,059 --> 00:58:13,559
bit more complex then I can just take

1373
00:58:13,559 --> 00:58:15,900
out a debugger which will layer and I

1374
00:58:15,900 --> 00:58:17,940
can just go and put breakpoints wherever

1375
00:58:17,940 --> 00:58:20,520
I want and check out the actual values

1376
00:58:20,520 --> 00:58:22,619
that are put into the stack and or into

1377
00:58:22,619 --> 00:58:25,020
the register depending on the API and I

1378
00:58:25,020 --> 00:58:27,000
will be able to see exactly what

1379
00:58:27,000 --> 00:58:30,359
arguments are being used to call

1380
00:58:30,359 --> 00:58:31,140
um

1381
00:58:31,140 --> 00:58:34,559
to Any Given API function from the

1382
00:58:34,559 --> 00:58:36,359
Google standard library and it turns out

1383
00:58:36,359 --> 00:58:38,220
that just by looking at the sequence of

1384
00:58:38,220 --> 00:58:40,619
all these calls I am able to reconstruct

1385
00:58:40,619 --> 00:58:43,799
this sort of flow of the program

1386
00:58:43,799 --> 00:58:46,319
so let us move on and see how far we can

1387
00:58:46,319 --> 00:58:48,920
build like this

1388
00:58:50,400 --> 00:58:54,180
so if we call Os Os exit I suppose that

1389
00:58:54,180 --> 00:58:55,619
it doesn't really matter too much what

1390
00:58:55,619 --> 00:58:57,180
happens after this because the program

1391
00:58:57,180 --> 00:58:59,220
terminates

1392
00:58:59,220 --> 00:59:02,400
um so let's just skip over everything

1393
00:59:02,400 --> 00:59:05,940
that is not a function goal

1394
00:59:05,940 --> 00:59:07,920
the next one

1395
00:59:07,920 --> 00:59:09,839
is here

1396
00:59:09,839 --> 00:59:11,520
and you will know

1397
00:59:11,520 --> 00:59:14,160
it seems to be a loop that is something

1398
00:59:14,160 --> 00:59:15,340
in either

1399
00:59:15,340 --> 00:59:17,599
[Music]

1400
00:59:17,599 --> 00:59:19,859
somewhere down here

1401
00:59:19,859 --> 00:59:24,599
and at the end we go all the way back up

1402
00:59:24,599 --> 00:59:26,940
so we have some sort of maybe it's the

1403
00:59:26,940 --> 00:59:30,599
four maybe it's a while right and try to

1404
00:59:30,599 --> 00:59:33,000
figure out what this Loop could be you

1405
00:59:33,000 --> 00:59:36,180
know based on what we know based on what

1406
00:59:36,180 --> 00:59:39,059
we have on the code so far I think there

1407
00:59:39,059 --> 00:59:40,559
aren't too many options there right

1408
00:59:40,559 --> 00:59:42,059
there is only one thing that we could

1409
00:59:42,059 --> 00:59:44,400
look out we could look on here right

1410
00:59:44,400 --> 00:59:46,319
what would that be it would be our

1411
00:59:46,319 --> 00:59:48,119
interfaces does this make sense to you

1412
00:59:48,119 --> 00:59:49,920
guys yeah

1413
00:59:49,920 --> 00:59:51,960
so let's try let's try writing some code

1414
00:59:51,960 --> 00:59:53,460
I don't know exactly how it would be

1415
00:59:53,460 --> 00:59:55,740
written and go let's let's assume it's

1416
00:59:55,740 --> 00:59:58,859
like this so for I

1417
00:59:58,859 --> 01:00:01,980
mean interfaces

1418
01:00:02,400 --> 01:00:06,260
and then we do something

1419
01:00:07,020 --> 01:00:09,299
is going to be

1420
01:00:09,299 --> 01:00:12,900
whatever happens in there

1421
01:00:12,900 --> 01:00:16,859
until we look all the way back up

1422
01:00:16,859 --> 01:00:20,160
now as I said as I promised we will

1423
01:00:20,160 --> 01:00:24,380
completely ignore all this sort of

1424
01:00:24,380 --> 01:00:28,319
nightmare or this horrible horrible uh

1425
01:00:28,319 --> 01:00:30,059
shuffling around of memory that is

1426
01:00:30,059 --> 01:00:32,160
taking place there now if you wanna if

1427
01:00:32,160 --> 01:00:34,260
you wanna track it and be my guest but

1428
01:00:34,260 --> 01:00:35,940
I'm just not going to bother right let's

1429
01:00:35,940 --> 01:00:37,559
just go directly to the next function

1430
01:00:37,559 --> 01:00:39,720
tool and check out where it is this one

1431
01:00:39,720 --> 01:00:43,319
is called net Hardware ADR string so

1432
01:00:43,319 --> 01:00:45,900
let's go back to documentation and see

1433
01:00:45,900 --> 01:00:48,599
what it is exactly

1434
01:00:48,599 --> 01:00:53,240
foreign go back to the net package

1435
01:01:02,339 --> 01:01:05,400
okay so Hardware addr appears to be a

1436
01:01:05,400 --> 01:01:07,140
type

1437
01:01:07,140 --> 01:01:08,940
a type that represents a physical

1438
01:01:08,940 --> 01:01:13,260
Hardware address all right why not

1439
01:01:13,260 --> 01:01:14,920
so maybe

1440
01:01:14,920 --> 01:01:16,799
[Music]

1441
01:01:16,799 --> 01:01:18,540
what is happening there is something

1442
01:01:18,540 --> 01:01:23,599
like this right something that I Dot

1443
01:01:24,540 --> 01:01:25,819
Hardware

1444
01:01:25,819 --> 01:01:27,420
addr

1445
01:01:27,420 --> 01:01:29,960
results

1446
01:01:30,660 --> 01:01:34,040
strings something like this right

1447
01:01:34,040 --> 01:01:35,700
it's

1448
01:01:35,700 --> 01:01:38,160
it's an assumption we'll see how it

1449
01:01:38,160 --> 01:01:40,440
turns out

1450
01:01:40,440 --> 01:01:42,859
okay

1451
01:01:42,900 --> 01:01:44,760
and so here

1452
01:01:44,760 --> 01:01:46,559
we do have

1453
01:01:46,559 --> 01:01:49,260
by the way if you look at

1454
01:01:49,260 --> 01:01:52,380
the presentation you will see

1455
01:01:52,380 --> 01:01:55,559
that's it returns a physical Hardware

1456
01:01:55,559 --> 01:01:57,420
address function here

1457
01:01:57,420 --> 01:02:00,200
sure it just returns a string

1458
01:02:00,200 --> 01:02:03,500
representation of

1459
01:02:03,960 --> 01:02:06,180
our Hardware address I would imagine I

1460
01:02:06,180 --> 01:02:07,859
don't know if we have a

1461
01:02:07,859 --> 01:02:09,960
an example somewhere it doesn't matter

1462
01:02:09,960 --> 01:02:11,400
too much

1463
01:02:11,400 --> 01:02:14,220
but anyway so we

1464
01:02:14,220 --> 01:02:16,980
go back to Ida here and the next thing

1465
01:02:16,980 --> 01:02:19,200
the next function call that we see is

1466
01:02:19,200 --> 01:02:22,680
this runtime man equal now I think it

1467
01:02:22,680 --> 01:02:25,619
doesn't require too much uh guessing to

1468
01:02:25,619 --> 01:02:26,940
figure out that this is going to be a

1469
01:02:26,940 --> 01:02:30,480
string comparison so let's see what what

1470
01:02:30,480 --> 01:02:32,339
are what we're comparing with

1471
01:02:32,339 --> 01:02:35,280
just looking a little bit above you see

1472
01:02:35,280 --> 01:02:36,839
that we have this

1473
01:02:36,839 --> 01:02:39,000
string that is in there

1474
01:02:39,000 --> 01:02:41,460
and you see that Ida is sort of not

1475
01:02:41,460 --> 01:02:44,339
super good at recognizing where the

1476
01:02:44,339 --> 01:02:46,260
string ends so let's just go in there

1477
01:02:46,260 --> 01:02:48,720
and see what happens now you mentioned

1478
01:02:48,720 --> 01:02:51,540
in the theory part I if you recall I

1479
01:02:51,540 --> 01:02:54,359
mentioned that all the strings ended up

1480
01:02:54,359 --> 01:02:55,859
being garbled all together in the

1481
01:02:55,859 --> 01:02:57,839
program right this is something that I I

1482
01:02:57,839 --> 01:02:59,700
hinted at and you see here exactly what

1483
01:02:59,700 --> 01:03:01,140
I meant you see that all the strings of

1484
01:03:01,140 --> 01:03:03,240
the program they are just

1485
01:03:03,240 --> 01:03:05,280
you know they're just there one after

1486
01:03:05,280 --> 01:03:08,099
the other and there is no real way of

1487
01:03:08,099 --> 01:03:10,260
figuring out where to start starts where

1488
01:03:10,260 --> 01:03:11,579
the string starts and where the string

1489
01:03:11,579 --> 01:03:14,460
ends this kind of annoying for us the

1490
01:03:14,460 --> 01:03:17,819
way that the program works is whenever a

1491
01:03:17,819 --> 01:03:20,339
string is needed you know the program

1492
01:03:20,339 --> 01:03:24,240
fit and forwards the um you get a direct

1493
01:03:24,240 --> 01:03:27,480
offset to the string inside this big

1494
01:03:27,480 --> 01:03:30,900
string ball uh I would say

1495
01:03:30,900 --> 01:03:34,500
and you have a site somewhere which here

1496
01:03:34,500 --> 01:03:39,680
is there the size is 11 age 17

1497
01:03:44,119 --> 01:03:47,640
and 17. so you get the pointer to the

1498
01:03:47,640 --> 01:03:50,040
string somewhere uh you get the size of

1499
01:03:50,040 --> 01:03:52,200
the string and this would be the string

1500
01:03:52,200 --> 01:03:53,760
that we are interested in and it makes

1501
01:03:53,760 --> 01:03:55,500
sense because then this decryption

1502
01:03:55,500 --> 01:03:57,900
failed to enter Etc it seems like it's

1503
01:03:57,900 --> 01:04:01,799
important some other string there right

1504
01:04:01,799 --> 01:04:03,960
so

1505
01:04:03,960 --> 01:04:07,339
there we have this call to hardware

1506
01:04:07,339 --> 01:04:09,240
ader.string and then we have the

1507
01:04:09,240 --> 01:04:11,579
comparison with this

1508
01:04:11,579 --> 01:04:14,700
so we can keep reconstructing our our

1509
01:04:14,700 --> 01:04:16,740
source code

1510
01:04:16,740 --> 01:04:17,960
um

1511
01:04:17,960 --> 01:04:21,059
and we can do something like this maybe

1512
01:04:21,059 --> 01:04:23,940
right and then probably

1513
01:04:23,940 --> 01:04:25,920
if you have that it means we are in the

1514
01:04:25,920 --> 01:04:28,520
if construct

1515
01:04:34,400 --> 01:04:38,700
okay so what is this Mac address exactly

1516
01:04:38,700 --> 01:04:40,260
this we can just do a quick Google

1517
01:04:40,260 --> 01:04:41,400
search

1518
01:04:41,400 --> 01:04:44,339
I'm pretty sure that we are going to end

1519
01:04:44,339 --> 01:04:45,780
up with uh

1520
01:04:45,780 --> 01:04:48,119
switch about this instrument because you

1521
01:04:48,119 --> 01:04:49,980
will see that this is actually the MAC

1522
01:04:49,980 --> 01:04:53,040
address for the hyper-v interface from

1523
01:04:53,040 --> 01:04:56,099
Microsoft so this is actually

1524
01:04:56,099 --> 01:04:57,599
this is actually some enter ID and

1525
01:04:57,599 --> 01:05:00,299
protection in there so the

1526
01:05:00,299 --> 01:05:02,760
the malware just checks if we have an

1527
01:05:02,760 --> 01:05:04,619
adapter that has this Mac address and if

1528
01:05:04,619 --> 01:05:07,700
so let's see

1529
01:05:09,000 --> 01:05:11,460
yeah we do have another call to OS dot

1530
01:05:11,460 --> 01:05:12,839
exit

1531
01:05:12,839 --> 01:05:16,319
right so let's go back and complete our

1532
01:05:16,319 --> 01:05:17,710
source code

1533
01:05:17,710 --> 01:05:20,889
[Music]

1534
01:05:21,260 --> 01:05:26,720
like this okay so we are making progress

1535
01:05:26,720 --> 01:05:30,319
let's go back there

1536
01:05:30,900 --> 01:05:33,720
and then you know we don't have any more

1537
01:05:33,720 --> 01:05:35,160
function code but just looking at the

1538
01:05:35,160 --> 01:05:37,859
graph it looks like we are just moving

1539
01:05:37,859 --> 01:05:40,559
on to the next uh iteration in the loop

1540
01:05:40,559 --> 01:05:42,839
this is probably a check on the size or

1541
01:05:42,839 --> 01:05:45,240
the number of uh iteration counts we

1542
01:05:45,240 --> 01:05:47,220
want to to go through

1543
01:05:47,220 --> 01:05:49,619
Etc and then when this is over we go to

1544
01:05:49,619 --> 01:05:51,740
this block there

1545
01:05:51,740 --> 01:05:53,660
okay so

1546
01:05:53,660 --> 01:05:55,920
let's keep going

1547
01:05:55,920 --> 01:05:58,920
so

1548
01:05:59,640 --> 01:06:02,280
just a quick check is it okay for

1549
01:06:02,280 --> 01:06:04,260
everyone so far do you are you following

1550
01:06:04,260 --> 01:06:06,839
uh the general approach yeah

1551
01:06:06,839 --> 01:06:08,280
okay

1552
01:06:08,280 --> 01:06:10,859
that's great so here we can get out of

1553
01:06:10,859 --> 01:06:13,020
this for loop I suppose and we have this

1554
01:06:13,020 --> 01:06:16,380
time now

1555
01:06:26,940 --> 01:06:30,480
so here you do have this um

1556
01:06:30,480 --> 01:06:32,400
weird value

1557
01:06:32,400 --> 01:06:35,760
as far as I remember this is actually a

1558
01:06:35,760 --> 01:06:37,500
sometimes term conversion that is taking

1559
01:06:37,500 --> 01:06:40,440
place so the way that time dot now I

1560
01:06:40,440 --> 01:06:42,660
think does not return a timestamp on the

1561
01:06:42,660 --> 01:06:44,039
layers format and this is just a

1562
01:06:44,039 --> 01:06:46,619
conversion here usually it's a good idea

1563
01:06:46,619 --> 01:06:49,440
if you do have this sort of constants in

1564
01:06:49,440 --> 01:06:50,940
a program you want to know what they are

1565
01:06:50,940 --> 01:06:52,559
you just Google them

1566
01:06:52,559 --> 01:06:56,460
it's a good way of figuring out exactly

1567
01:06:56,460 --> 01:06:59,280
what they are let's see if we

1568
01:06:59,280 --> 01:07:02,299
have the result there

1569
01:07:06,780 --> 01:07:08,599
so here we have it

1570
01:07:08,599 --> 01:07:12,380
we have a bit of code that is done from

1571
01:07:12,380 --> 01:07:14,700
whoever knows wherever let's try in

1572
01:07:14,700 --> 01:07:17,240
decimal form

1573
01:07:22,400 --> 01:07:24,059
okay

1574
01:07:24,059 --> 01:07:26,119
so I apologize for the results in French

1575
01:07:26,119 --> 01:07:29,520
but overall

1576
01:07:29,520 --> 01:07:33,180
what we see here is the pages related to

1577
01:07:33,180 --> 01:07:36,000
calendars so we can guess from there we

1578
01:07:36,000 --> 01:07:37,500
can infer that this is related to

1579
01:07:37,500 --> 01:07:40,260
whatever conversion taking place so

1580
01:07:40,260 --> 01:07:42,420
let's ignore that

1581
01:07:42,420 --> 01:07:45,780
that's what we don't really need to

1582
01:07:45,780 --> 01:07:48,960
worry about that we've just move to the

1583
01:07:48,960 --> 01:07:50,460
next

1584
01:07:50,460 --> 01:07:51,720
if we just move to the next function

1585
01:07:51,720 --> 01:07:55,079
call we see this matte brand PTR Rancid

1586
01:07:55,079 --> 01:07:56,819
if you have developed programs in your

1587
01:07:56,819 --> 01:07:58,260
past then it's going to look kind of

1588
01:07:58,260 --> 01:07:59,339
familiar it's something you probably

1589
01:07:59,339 --> 01:08:00,500
have done

1590
01:08:00,500 --> 01:08:03,359
whenever you were using cryptography or

1591
01:08:03,359 --> 01:08:06,119
whatever you wanted to use a randomness

1592
01:08:06,119 --> 01:08:10,559
and what they do there is uh initialize

1593
01:08:10,559 --> 01:08:13,380
the seed of the RNG

1594
01:08:13,380 --> 01:08:15,119
let me

1595
01:08:15,119 --> 01:08:17,040
update the code there

1596
01:08:17,040 --> 01:08:20,520
now we don't exactly see how this result

1597
01:08:20,520 --> 01:08:22,620
of time that now is being used but again

1598
01:08:22,620 --> 01:08:25,140
uh with a bit of educated guesswork we

1599
01:08:25,140 --> 01:08:26,880
can figure out that this is probably

1600
01:08:26,880 --> 01:08:28,920
being used to see that they're RNG

1601
01:08:28,920 --> 01:08:31,319
because this is the type of code we see

1602
01:08:31,319 --> 01:08:33,679
every time

1603
01:08:36,420 --> 01:08:37,620
not

1604
01:08:37,620 --> 01:08:40,278
seed

1605
01:08:41,460 --> 01:08:43,259
right looks like

1606
01:08:43,259 --> 01:08:45,000
something that makes sense

1607
01:08:45,000 --> 01:08:48,600
so let's keep going with this and see

1608
01:08:48,600 --> 01:08:49,939
what happens

1609
01:08:49,939 --> 01:08:52,500
now the next function tool is sort of

1610
01:08:52,500 --> 01:08:55,380
interesting for us right because this is

1611
01:08:55,380 --> 01:08:58,439
another function that comes from the

1612
01:08:58,439 --> 01:09:00,359
main package so this means that this is

1613
01:09:00,359 --> 01:09:01,738
not something we'll be able to look up

1614
01:09:01,738 --> 01:09:02,640
online

1615
01:09:02,640 --> 01:09:04,979
it means instead

1616
01:09:04,979 --> 01:09:08,000
that this is some code that comes from

1617
01:09:08,000 --> 01:09:12,000
the developer author written code it's

1618
01:09:12,000 --> 01:09:14,960
something we need to get into

1619
01:09:16,439 --> 01:09:19,738
we get in there but you know I think

1620
01:09:19,738 --> 01:09:22,380
this might be I don't know if we take

1621
01:09:22,380 --> 01:09:24,479
breaks in the in the workshop I think uh

1622
01:09:24,479 --> 01:09:26,698
having a 10 minute break uh would be

1623
01:09:26,698 --> 01:09:29,160
nice I suppose because it's sort of a

1624
01:09:29,160 --> 01:09:32,339
dry subject matter so if you guys want

1625
01:09:32,339 --> 01:09:34,439
to like uh walk up for five minutes and

1626
01:09:34,439 --> 01:09:38,160
walk around uh I find money right

1627
01:09:38,160 --> 01:09:41,880
so we take up again at uh 2 30 is that

1628
01:09:41,880 --> 01:09:45,120
is that okay with you all right so see

1629
01:09:45,120 --> 01:09:47,899
you in a few seconds

1630
01:09:52,920 --> 01:09:56,780
uh okay come here

1631
01:10:00,320 --> 01:10:04,020
no problem uh don't sweat it so there is

1632
01:10:04,020 --> 01:10:06,000
actually no VM but

1633
01:10:06,000 --> 01:10:08,880
there are two ways I will share this

1634
01:10:08,880 --> 01:10:12,179
activity with you uh he wants I started

1635
01:10:12,179 --> 01:10:14,580
with some general General

1636
01:10:14,580 --> 01:10:17,940
say uh information about the language

1637
01:10:17,940 --> 01:10:20,340
um when it comes to this tutorial so

1638
01:10:20,340 --> 01:10:21,540
there are two ways of doing this if you

1639
01:10:21,540 --> 01:10:23,460
do have either Pro or video whatever

1640
01:10:23,460 --> 01:10:25,020
you're comfortable with you can just

1641
01:10:25,020 --> 01:10:26,520
download the sample directly and work on

1642
01:10:26,520 --> 01:10:29,400
your own machine if you don't I do have

1643
01:10:29,400 --> 01:10:31,500
some online VMS that you can log into

1644
01:10:31,500 --> 01:10:34,640
through RDP so

1645
01:10:34,640 --> 01:10:38,340
manager probably it works too yeah so in

1646
01:10:38,340 --> 01:10:40,020
that case you can just go to P dot

1647
01:10:40,020 --> 01:10:43,400
Capital kwi.ski

1648
01:10:43,400 --> 01:10:46,020
there and there's going to be just an

1649
01:10:46,020 --> 01:10:48,000
archive there and you can just download

1650
01:10:48,000 --> 01:10:50,880
the sample and look at it

1651
01:10:50,880 --> 01:10:54,980
the password is infected yep

1652
01:10:58,340 --> 01:11:03,719
uh it's here A P Dot kwi.ski

1653
01:11:05,710 --> 01:11:08,920
[Music]

1654
01:11:10,159 --> 01:11:13,159
access

1655
01:11:14,239 --> 01:11:16,560
you don't need to run them oh no I know

1656
01:11:16,560 --> 01:11:19,520
I know I just normally always

1657
01:11:20,760 --> 01:11:23,280
yeah uh probably Essentials without

1658
01:11:23,280 --> 01:11:26,820
extension yeah

1659
01:11:29,000 --> 01:11:33,080
the password is infected

1660
01:11:49,739 --> 01:11:52,739
foreign

1661
01:12:25,260 --> 01:12:28,260
questions

1662
01:12:55,980 --> 01:12:58,519
thank you

1663
01:13:11,060 --> 01:13:14,060
thank you

1664
01:13:32,159 --> 01:13:35,120
thank you

1665
01:14:13,219 --> 01:14:16,219
all right

1666
01:14:27,260 --> 01:14:30,260
thank you

1667
01:14:54,300 --> 01:14:56,780
thank you

1668
01:15:31,140 --> 01:15:34,140
foreign

1669
01:16:08,159 --> 01:16:11,640
yeah so that's uh the script I think has

1670
01:16:11,640 --> 01:16:13,920
very likely worked but there is a one

1671
01:16:13,920 --> 01:16:16,140
more I'm sorry subtlety there is that by

1672
01:16:16,140 --> 01:16:18,060
default the folder view is not enabled

1673
01:16:18,060 --> 01:16:20,280
so you need to get right click there

1674
01:16:20,280 --> 01:16:23,780
and maybe show folders

1675
01:16:24,860 --> 01:16:28,380
it's working perfectly

1676
01:16:28,380 --> 01:16:31,860
yeah I think I think either should

1677
01:16:31,860 --> 01:16:34,800
enable this by default at least if you

1678
01:16:34,800 --> 01:16:36,060
use folders it should they should be

1679
01:16:36,060 --> 01:16:37,860
shown by default as well

1680
01:16:37,860 --> 01:16:39,659
in terms of uid have a bit of

1681
01:16:39,659 --> 01:16:41,880
improvements to make

1682
01:16:41,880 --> 01:16:45,620
yeah but in any case it works

1683
01:17:53,940 --> 01:17:56,480
foreign

1684
01:18:39,620 --> 01:18:42,620
thank you

1685
01:18:50,420 --> 01:18:52,860
let's have another question are you

1686
01:18:52,860 --> 01:18:54,360
standing at the end of this country like

1687
01:18:54,360 --> 01:18:55,340
you know

1688
01:18:55,340 --> 01:18:57,420
you're writing and then do like a side

1689
01:18:57,420 --> 01:19:00,540
by side I won't do it but this is what

1690
01:19:00,540 --> 01:19:03,060
when I was beginning with this I did I

1691
01:19:03,060 --> 01:19:05,100
would take the same Gold version combine

1692
01:19:05,100 --> 01:19:06,360
the code and then look side by side to

1693
01:19:06,360 --> 01:19:08,460
see if I was close with us and if you

1694
01:19:08,460 --> 01:19:09,960
take the same version of go it will

1695
01:19:09,960 --> 01:19:11,760
generate the same if you have the same

1696
01:19:11,760 --> 01:19:12,960
code you should generate the same binary

1697
01:19:12,960 --> 01:19:15,179
yeah or the same functions

1698
01:19:15,179 --> 01:19:17,580
so when you begin you start out and you

1699
01:19:17,580 --> 01:19:19,260
can compile the code that you write on

1700
01:19:19,260 --> 01:19:21,000
your own and then see if it's kind of

1701
01:19:21,000 --> 01:19:22,380
the same if it is then it means you're

1702
01:19:22,380 --> 01:19:23,880
on the right track if not then it is

1703
01:19:23,880 --> 01:19:25,320
some salty or something different that

1704
01:19:25,320 --> 01:19:28,159
you can take into account

1705
01:19:33,540 --> 01:19:35,659
thanks

1706
01:19:51,900 --> 01:19:54,900
is

1707
01:19:55,920 --> 01:19:58,920
especially

1708
01:20:22,620 --> 01:20:25,620
Aesthetics

1709
01:20:28,500 --> 01:20:31,500
questions

1710
01:20:48,679 --> 01:20:52,500
it's an old one it's natural look like

1711
01:20:52,500 --> 01:20:58,159
it was over 14. pretty possible

1712
01:20:58,710 --> 01:21:01,739
[Music]

1713
01:21:05,900 --> 01:21:09,780
there's a simpler fish way which is to

1714
01:21:09,780 --> 01:21:11,880
get the official to build go yourself

1715
01:21:11,880 --> 01:21:14,900
from the sources

1716
01:21:16,940 --> 01:21:20,100
they are I think if you go to the Go

1717
01:21:20,100 --> 01:21:22,620
website

1718
01:21:22,620 --> 01:21:25,679
you can probably download

1719
01:21:25,679 --> 01:21:27,420
so we can maybe download the old

1720
01:21:27,420 --> 01:21:28,380
versions

1721
01:21:28,380 --> 01:21:30,239
individually

1722
01:21:30,239 --> 01:21:32,460
if not you can get the source code

1723
01:21:32,460 --> 01:21:34,739
I would not recommend like deploying the

1724
01:21:34,739 --> 01:21:37,020
packages on the system because you've

1725
01:21:37,020 --> 01:21:38,820
got to end up with broken dependencies

1726
01:21:38,820 --> 01:21:40,920
possibly or with an old Go version

1727
01:21:40,920 --> 01:21:42,900
that's what you know what to do if you

1728
01:21:42,900 --> 01:21:44,100
just extract them through some

1729
01:21:44,100 --> 01:21:46,580
directories

1730
01:21:46,580 --> 01:21:50,280
but in any case the On The Go website

1731
01:21:50,280 --> 01:21:52,800
here you have old archived versions like

1732
01:21:52,800 --> 01:21:55,260
this and you can take any of them you

1733
01:21:55,260 --> 01:21:56,760
get the source code you go there you

1734
01:21:56,760 --> 01:22:00,860
compile it and you're good to go

1735
01:22:38,880 --> 01:22:42,440
let's go back all right

1736
01:22:43,739 --> 01:22:45,900
so I think we're probably almost ready

1737
01:22:45,900 --> 01:22:48,559
to be soon

1738
01:22:50,120 --> 01:22:53,100
are there any any questions about what

1739
01:22:53,100 --> 01:22:55,440
we've seen so far

1740
01:22:55,440 --> 01:22:57,659
I think this is not uh you can't feel

1741
01:22:57,659 --> 01:22:59,880
free to ask any questions during the the

1742
01:22:59,880 --> 01:23:01,620
course of the tutorial but if you have

1743
01:23:01,620 --> 01:23:06,440
some now I'm happy to take them right no

1744
01:23:07,020 --> 01:23:09,410
so let's just

1745
01:23:09,410 --> 01:23:10,679
[Music]

1746
01:23:10,679 --> 01:23:14,040
so before this break what we had done is

1747
01:23:14,040 --> 01:23:15,920
we had just reached this new function

1748
01:23:15,920 --> 01:23:19,260
that was also consecrated by the malware

1749
01:23:19,260 --> 01:23:21,000
developers this function is called

1750
01:23:21,000 --> 01:23:25,679
Define physical settings so script and

1751
01:23:25,679 --> 01:23:28,400
just read it as well

1752
01:23:36,540 --> 01:23:39,060
I don't think it takes any arguments

1753
01:23:39,060 --> 01:23:41,520
there is one way to find out which is to

1754
01:23:41,520 --> 01:23:43,860
go back one step and see if there are

1755
01:23:43,860 --> 01:23:45,300
any

1756
01:23:45,300 --> 01:23:47,760
arguments being passed to it

1757
01:23:47,760 --> 01:23:49,980
doesn't seem to be a case although here

1758
01:23:49,980 --> 01:23:51,540
I will draw your attention to the fact

1759
01:23:51,540 --> 01:23:52,980
that

1760
01:23:52,980 --> 01:23:54,560
with go

1761
01:23:54,560 --> 01:23:57,239
the way that arguments are being

1762
01:23:57,239 --> 01:23:58,620
returned

1763
01:23:58,620 --> 01:24:01,620
is a bit tricky in the sense that they

1764
01:24:01,620 --> 01:24:03,780
are placed exactly where they need to be

1765
01:24:03,780 --> 01:24:06,540
to be given or agree used as Arguments

1766
01:24:06,540 --> 01:24:09,000
for the next function so if you have

1767
01:24:09,000 --> 01:24:12,360
this call there from this uh seed

1768
01:24:12,360 --> 01:24:13,620
function

1769
01:24:13,620 --> 01:24:16,080
that whatever argument it returns is

1770
01:24:16,080 --> 01:24:17,460
already in the right place to be

1771
01:24:17,460 --> 01:24:19,980
whatever reason value it gives is

1772
01:24:19,980 --> 01:24:21,719
normally the right place to be used as

1773
01:24:21,719 --> 01:24:24,000
an argument

1774
01:24:24,000 --> 01:24:26,659
that's

1775
01:24:28,280 --> 01:24:29,940
there

1776
01:24:29,940 --> 01:24:31,620
the seed function does not reach on

1777
01:24:31,620 --> 01:24:34,500
anything but this is I think a smart way

1778
01:24:34,500 --> 01:24:36,659
that the go developers the go creators

1779
01:24:36,659 --> 01:24:39,060
devices so that function calls can be

1780
01:24:39,060 --> 01:24:42,380
changed in a very efficient fashion

1781
01:24:47,219 --> 01:24:49,679
there are arguments this function so all

1782
01:24:49,679 --> 01:24:51,260
right

1783
01:24:51,260 --> 01:24:54,860
at the brackets

1784
01:24:57,840 --> 01:25:00,239
so the first thing that we see here

1785
01:25:00,239 --> 01:25:02,880
again ignoring all the

1786
01:25:02,880 --> 01:25:06,420
crazy memory operations are

1787
01:25:06,420 --> 01:25:08,640
strings that appear there don't say that

1788
01:25:08,640 --> 01:25:12,000
and then.tmp and then this concat string

1789
01:25:12,000 --> 01:25:14,219
so this can't get streamed is stream

1790
01:25:14,219 --> 01:25:16,320
documentation yeah

1791
01:25:16,320 --> 01:25:19,280
Chinese

1792
01:25:19,560 --> 01:25:22,400
restaurants

1793
01:25:28,400 --> 01:25:32,280
you cannot know in the sense that the

1794
01:25:32,280 --> 01:25:34,020
stuff is placed in the right position

1795
01:25:34,020 --> 01:25:35,100
already

1796
01:25:35,100 --> 01:25:36,840
but then whether or not it will be used

1797
01:25:36,840 --> 01:25:38,880
really depends on the on the next

1798
01:25:38,880 --> 01:25:40,800
function right

1799
01:25:40,800 --> 01:25:43,920
so the only way you can know is if you

1800
01:25:43,920 --> 01:25:46,199
look at the documentation if you look at

1801
01:25:46,199 --> 01:25:48,120
documentation and see that the second

1802
01:25:48,120 --> 01:25:50,219
function for instance expects two

1803
01:25:50,219 --> 01:25:53,760
arguments then it means that probably

1804
01:25:53,760 --> 01:25:55,860
whatever comes from the previous one is

1805
01:25:55,860 --> 01:25:58,380
going to be reduced right

1806
01:25:58,380 --> 01:25:59,940
yeah

1807
01:25:59,940 --> 01:26:01,739
if it's a custom function it's going to

1808
01:26:01,739 --> 01:26:04,020
be uh

1809
01:26:04,020 --> 01:26:06,480
usually this this type of function dot

1810
01:26:06,480 --> 01:26:07,860
something does something really comes

1811
01:26:07,860 --> 01:26:09,540
from the same Library like the

1812
01:26:09,540 --> 01:26:10,920
developers they don't do that too much

1813
01:26:10,920 --> 01:26:13,860
as far as I've seen but it may happen

1814
01:26:13,860 --> 01:26:16,679
and if it does well you're on your own

1815
01:26:16,679 --> 01:26:18,960
maybe you can find one thing you can do

1816
01:26:18,960 --> 01:26:20,420
is maybe you know

1817
01:26:20,420 --> 01:26:22,620
you can press X find all the cross

1818
01:26:22,620 --> 01:26:24,540
references to the function to find

1819
01:26:24,540 --> 01:26:26,340
another use of that function where it's

1820
01:26:26,340 --> 01:26:28,739
not chained like this and then see that

1821
01:26:28,739 --> 01:26:30,420
instance if it's taking something from

1822
01:26:30,420 --> 01:26:32,159
the register or from the step I will be

1823
01:26:32,159 --> 01:26:34,139
my best guess

1824
01:26:34,139 --> 01:26:37,100
thank you

1825
01:26:37,500 --> 01:26:40,020
okay so here

1826
01:26:40,020 --> 01:26:42,360
the first meaningful things that appear

1827
01:26:42,360 --> 01:26:44,159
to you that appears to be done in this

1828
01:26:44,159 --> 01:26:47,699
function is don't get string of tnp and

1829
01:26:47,699 --> 01:26:51,179
conflict.text so sure why not let's do s

1830
01:26:51,179 --> 01:26:53,840
equals

1831
01:26:54,719 --> 01:26:56,520
that

1832
01:26:56,520 --> 01:26:59,179
was

1833
01:26:59,179 --> 01:27:01,679
tmb like of course we keep in mind this

1834
01:27:01,679 --> 01:27:05,480
operation because we know what it does

1835
01:27:08,540 --> 01:27:13,860
Dot dot read file okay so we can guess

1836
01:27:13,860 --> 01:27:16,739
very easily what this does but at the

1837
01:27:16,739 --> 01:27:17,780
same time

1838
01:27:17,780 --> 01:27:20,040
let's check out the documentation to see

1839
01:27:20,040 --> 01:27:22,380
what the arguments are and so on

1840
01:27:22,380 --> 01:27:26,060
so let's go to apply your package

1841
01:27:54,560 --> 01:27:56,460
thank you

1842
01:27:56,460 --> 01:27:59,760
okay so this function as the name

1843
01:27:59,760 --> 01:28:02,639
implies read the file and what it does

1844
01:28:02,639 --> 01:28:04,679
is you give it a file name it returns to

1845
01:28:04,679 --> 01:28:06,659
you all the bytes contained in this file

1846
01:28:06,659 --> 01:28:09,420
and then of course an error object as

1847
01:28:09,420 --> 01:28:10,720
his tradition would go

1848
01:28:10,720 --> 01:28:13,139
[Music]

1849
01:28:13,139 --> 01:28:15,360
I don't even have to either again I

1850
01:28:15,360 --> 01:28:16,800
think

1851
01:28:16,800 --> 01:28:18,840
I can just do

1852
01:28:18,840 --> 01:28:21,840
io.io

1853
01:28:22,860 --> 01:28:24,719
file

1854
01:28:24,719 --> 01:28:27,360
and it doesn't take too much guessing to

1855
01:28:27,360 --> 01:28:30,179
assume that what arguments what

1856
01:28:30,179 --> 01:28:32,040
arguments are the best there is going to

1857
01:28:32,040 --> 01:28:34,139
be this function name that was given to

1858
01:28:34,139 --> 01:28:39,120
us and also let's take the return values

1859
01:28:39,120 --> 01:28:43,620
attempts and also air equals

1860
01:28:43,800 --> 01:28:47,719
this all right

1861
01:28:48,139 --> 01:28:51,719
see the very traditional just after

1862
01:28:51,719 --> 01:28:54,420
function for the check between something

1863
01:28:54,420 --> 01:28:55,739
and zero

1864
01:28:55,739 --> 01:28:58,679
so again we can take a guess and assume

1865
01:28:58,679 --> 01:29:01,620
that it's our error being tested so

1866
01:29:01,620 --> 01:29:03,120
let's

1867
01:29:03,120 --> 01:29:05,400
I think that again if

1868
01:29:05,400 --> 01:29:07,500
there

1869
01:29:07,500 --> 01:29:09,300
are different from Neil and something

1870
01:29:09,300 --> 01:29:12,560
and otherwise

1871
01:29:13,860 --> 01:29:15,840
now

1872
01:29:15,840 --> 01:29:19,440
we do see that earlier one branch was

1873
01:29:19,440 --> 01:29:21,060
super easy because it was just OS dot

1874
01:29:21,060 --> 01:29:24,179
exit in this case uh it's not really

1875
01:29:24,179 --> 01:29:28,380
what happened so what we can do is let's

1876
01:29:28,380 --> 01:29:30,659
start by following the red arrow which

1877
01:29:30,659 --> 01:29:34,080
is going to be the one that is called or

1878
01:29:34,080 --> 01:29:36,420
the one that is followed if we do not

1879
01:29:36,420 --> 01:29:38,699
have the uh the fibers on our system

1880
01:29:38,699 --> 01:29:41,699
because at the moment this uh

1881
01:29:41,699 --> 01:29:45,360
file here from this platform something

1882
01:29:45,360 --> 01:29:47,460
that.tmp we don't have it right we don't

1883
01:29:47,460 --> 01:29:49,620
know what's in there so let's assume it

1884
01:29:49,620 --> 01:29:51,120
doesn't exist and see what happens with

1885
01:29:51,120 --> 01:29:53,840
the program when that is the case

1886
01:29:53,840 --> 01:29:57,360
so we go into this block

1887
01:29:57,360 --> 01:29:59,460
and then involve we have this support OS

1888
01:29:59,460 --> 01:30:02,300
dot open file

1889
01:30:12,060 --> 01:30:14,400
and here we are NCC to get to see the

1890
01:30:14,400 --> 01:30:17,000
arguments

1891
01:30:32,960 --> 01:30:37,880
all right so this function

1892
01:30:38,219 --> 01:30:40,980
s of course and then you have three

1893
01:30:40,980 --> 01:30:42,719
arguments

1894
01:30:42,719 --> 01:30:46,920
string an integer which is the

1895
01:30:46,920 --> 01:30:49,560
whether the file is created or read only

1896
01:30:49,560 --> 01:30:51,300
it again stuff

1897
01:30:51,300 --> 01:30:55,440
and then AE permission so let's see here

1898
01:30:55,440 --> 01:30:57,120
Ida

1899
01:30:57,120 --> 01:31:00,019
the file

1900
01:31:00,540 --> 01:31:03,300
uh defined name I assume is still going

1901
01:31:03,300 --> 01:31:06,060
to be our

1902
01:31:06,060 --> 01:31:09,540
our conflict.tmp being passed away uh

1903
01:31:09,540 --> 01:31:11,340
from above now this is something we can

1904
01:31:11,340 --> 01:31:12,360
show you this is something we'll check

1905
01:31:12,360 --> 01:31:13,679
in the debugger actually because it's

1906
01:31:13,679 --> 01:31:15,960
starting to be we're doing a lot of

1907
01:31:15,960 --> 01:31:17,760
guesswork so it's good to backtrack a

1908
01:31:17,760 --> 01:31:20,280
little bit and check if we are

1909
01:31:20,280 --> 01:31:23,820
and here if you change this to octo I

1910
01:31:23,820 --> 01:31:25,739
think yeah you see that this is the

1911
01:31:25,739 --> 01:31:30,080
tradition of a file with permissions 666

1912
01:31:30,300 --> 01:31:33,360
read write execute maybe a mature at

1913
01:31:33,360 --> 01:31:35,780
least with right

1914
01:31:35,880 --> 01:31:37,980
and the final one I'm not sure this

1915
01:31:37,980 --> 01:31:40,500
should be all create

1916
01:31:40,500 --> 01:31:42,659
you can check the the flag and try to

1917
01:31:42,659 --> 01:31:46,139
locate Wireless exactly Okay so

1918
01:31:46,139 --> 01:31:47,940
let us

1919
01:31:47,940 --> 01:31:49,980
let us open this program in the debugger

1920
01:31:49,980 --> 01:31:51,420
and check that we are still on the right

1921
01:31:51,420 --> 01:31:53,040
track so

1922
01:31:53,040 --> 01:31:55,440
so we have there is I have a VM

1923
01:31:55,440 --> 01:31:57,540
and in this VM I have my debugger which

1924
01:31:57,540 --> 01:31:59,580
is x64 DVD

1925
01:31:59,580 --> 01:32:02,580
here

1926
01:32:03,600 --> 01:32:07,139
and into my DM give it back to exe

1927
01:32:07,139 --> 01:32:09,500
extension

1928
01:32:11,639 --> 01:32:13,980
and they're uh they're going to before I

1929
01:32:13,980 --> 01:32:15,840
I even do this there are going to be a

1930
01:32:15,840 --> 01:32:17,159
few

1931
01:32:17,159 --> 01:32:19,560
tips and tricks I'm going to share with

1932
01:32:19,560 --> 01:32:20,280
you

1933
01:32:20,280 --> 01:32:22,500
the first of those tips and tricks is

1934
01:32:22,500 --> 01:32:24,900
that one thing I love when I'm debugging

1935
01:32:24,900 --> 01:32:27,540
is being able to copy addresses from Ida

1936
01:32:27,540 --> 01:32:29,699
and put breakpoint directly into the

1937
01:32:29,699 --> 01:32:31,080
debugger right because it simplifies

1938
01:32:31,080 --> 01:32:33,659
things a lot press space you have the

1939
01:32:33,659 --> 01:32:35,699
addresses here in the margin for since

1940
01:32:35,699 --> 01:32:37,440
let's say I want to put a breakpoint

1941
01:32:37,440 --> 01:32:39,960
there or just copy this address and pull

1942
01:32:39,960 --> 01:32:42,360
open this in the debugger paste the

1943
01:32:42,360 --> 01:32:44,219
address and put the breakdown there like

1944
01:32:44,219 --> 01:32:47,340
the issue is due to the aslr protection

1945
01:32:47,340 --> 01:32:49,440
that we had in binaries and my program

1946
01:32:49,440 --> 01:32:51,659
is liable to be loaded anywhere right

1947
01:32:51,659 --> 01:32:54,000
and that's super annoying for us so

1948
01:32:54,000 --> 01:32:56,820
there's actually a way to circumvent

1949
01:32:56,820 --> 01:32:58,800
this issue entirely and this is thanks

1950
01:32:58,800 --> 01:33:01,620
to a small utility from a guide to ddst

1951
01:33:01,620 --> 01:33:04,080
events it is called set yellow

1952
01:33:04,080 --> 01:33:05,820
characteristics you can find it online

1953
01:33:05,820 --> 01:33:07,720
for free let me show it to you

1954
01:33:07,720 --> 01:33:10,819
[Music]

1955
01:33:11,940 --> 01:33:14,820
so this is a small binary that you can

1956
01:33:14,820 --> 01:33:16,320
use to

1957
01:33:16,320 --> 01:33:18,780
edit the header of AP file so for

1958
01:33:18,780 --> 01:33:22,440
instance the uh the weather program is

1959
01:33:22,440 --> 01:33:26,820
compatible with aslr is shown inside the

1960
01:33:26,820 --> 01:33:29,280
Library by a flag somewhere and so if

1961
01:33:29,280 --> 01:33:31,020
you just change this flag into the key

1962
01:33:31,020 --> 01:33:33,060
header that the program is important it

1963
01:33:33,060 --> 01:33:36,120
has not been compatible with aslr loaded

1964
01:33:36,120 --> 01:33:37,980
exactly where you want it to be

1965
01:33:37,980 --> 01:33:41,100
so this is a pretty cool utility

1966
01:33:41,100 --> 01:33:43,020
I do recommend that you have it

1967
01:33:43,020 --> 01:33:44,940
somewhere because it's super useful and

1968
01:33:44,940 --> 01:33:47,580
the way it's being it's used is very

1969
01:33:47,580 --> 01:33:50,940
extremely simple in my VM and if you are

1970
01:33:50,940 --> 01:33:52,620
using my online games it will be in the

1971
01:33:52,620 --> 01:33:54,860
same place

1972
01:33:55,980 --> 01:33:58,320
and then set the yellow characteristic

1973
01:33:58,320 --> 01:33:59,900
and then it's

1974
01:33:59,900 --> 01:34:03,179
minus D in the program minus because you

1975
01:34:03,179 --> 01:34:04,920
want to remove it you can do plus d if

1976
01:34:04,920 --> 01:34:08,360
you want to enable it as well

1977
01:34:14,120 --> 01:34:17,820
disabled ASL so that's pretty unique

1978
01:34:17,820 --> 01:34:20,300
that's the previews so

1979
01:34:20,300 --> 01:34:23,520
this will allow me thanks to ASL being

1980
01:34:23,520 --> 01:34:25,560
disabled to copy addresses from Ida Pro

1981
01:34:25,560 --> 01:34:27,420
and then use them directly in my

1982
01:34:27,420 --> 01:34:29,940
debugger and send me of having to

1983
01:34:29,940 --> 01:34:31,920
convert them manually and to do this

1984
01:34:31,920 --> 01:34:33,780
translation and so on so that's

1985
01:34:33,780 --> 01:34:37,500
something I suggest you should do it's

1986
01:34:37,500 --> 01:34:38,820
not just for Good binaries by the way

1987
01:34:38,820 --> 01:34:40,380
whenever you have to debug a program I

1988
01:34:40,380 --> 01:34:41,580
go through the step because it's so

1989
01:34:41,580 --> 01:34:42,719
useful

1990
01:34:42,719 --> 01:34:46,739
so let us open this program with x64 gbg

1991
01:34:46,739 --> 01:34:50,219
and you will notice maybe I should zoom

1992
01:34:50,219 --> 01:34:54,500
in not there

1993
01:34:59,540 --> 01:35:02,100
yeah let me just increase the first step

1994
01:35:02,100 --> 01:35:04,820
a lot

1995
01:35:15,199 --> 01:35:19,080
okay so I will assume that all of you

1996
01:35:19,080 --> 01:35:21,540
are familiar with debuggers I don't know

1997
01:35:21,540 --> 01:35:23,400
if you use this one before if you do

1998
01:35:23,400 --> 01:35:26,659
have questions about it feel free to ask

1999
01:35:26,659 --> 01:35:29,639
one of the things that I want to show

2000
01:35:29,639 --> 01:35:32,460
you too is that well when you move

2001
01:35:32,460 --> 01:35:35,040
around in the program

2002
01:35:35,040 --> 01:35:37,320
you will see that

2003
01:35:37,320 --> 01:35:39,320
um

2004
01:35:40,440 --> 01:35:42,420
let me put a breakpoint exactly where I

2005
01:35:42,420 --> 01:35:43,440
wanted to go

2006
01:35:43,440 --> 01:35:47,639
just for this open file okay so copy

2007
01:35:47,639 --> 01:35:49,940
this address

2008
01:35:51,840 --> 01:35:53,280
there

2009
01:35:53,280 --> 01:35:55,020
and you see here there's one thing that

2010
01:35:55,020 --> 01:35:57,260
is actually a bit sad it's the fact that

2011
01:35:57,260 --> 01:36:01,100
this code there is a call to such a

2012
01:36:01,100 --> 01:36:04,139
row.4bt630 which is of course the

2013
01:36:04,139 --> 01:36:06,239
address of this function in my program

2014
01:36:06,239 --> 01:36:08,820
where Ida Pro was able to like through

2015
01:36:08,820 --> 01:36:11,100
x-rays dot dot magic to recognize that

2016
01:36:11,100 --> 01:36:13,820
this was the go function

2017
01:36:13,820 --> 01:36:16,340
detail.red file or open file or whatever

2018
01:36:16,340 --> 01:36:19,920
so debugger does not have this

2019
01:36:19,920 --> 01:36:21,840
intelligence programming it's not able

2020
01:36:21,840 --> 01:36:23,639
to parse the go program and to recognize

2021
01:36:23,639 --> 01:36:25,199
function names and so on

2022
01:36:25,199 --> 01:36:28,620
but as you can imagine it would be super

2023
01:36:28,620 --> 01:36:31,139
cool right if you would be able to if we

2024
01:36:31,139 --> 01:36:33,780
were able to import the names that come

2025
01:36:33,780 --> 01:36:35,520
from either and put them inside our

2026
01:36:35,520 --> 01:36:37,500
debugger turns out this is actually

2027
01:36:37,500 --> 01:36:39,120
possible

2028
01:36:39,120 --> 01:36:43,159
the way you do this is with a plugin

2029
01:36:43,159 --> 01:36:47,040
x64 tdg either

2030
01:36:47,040 --> 01:36:50,420
you can find this on GitHub

2031
01:36:50,880 --> 01:36:54,139
and there it is yes

2032
01:36:54,780 --> 01:36:56,580
sure

2033
01:36:56,580 --> 01:37:01,920
so let me just go back to the binders

2034
01:37:02,520 --> 01:37:05,960
this is the tool that you need

2035
01:37:06,179 --> 01:37:08,520
and well then it's super useful it

2036
01:37:08,520 --> 01:37:10,380
doesn't set the other characteristics

2037
01:37:10,380 --> 01:37:12,480
and then the file and then an option

2038
01:37:12,480 --> 01:37:15,540
like plus d activates aslr minus the

2039
01:37:15,540 --> 01:37:18,300
deactivate aslr plus n activate that

2040
01:37:18,300 --> 01:37:22,400
minus n deactivate depth and so on

2041
01:37:22,820 --> 01:37:25,699
exactly

2042
01:37:25,699 --> 01:37:27,719
maybe it's already opened in the

2043
01:37:27,719 --> 01:37:30,139
debugger

2044
01:37:37,880 --> 01:37:42,600
oh maybe it's possible yeah I I think I

2045
01:37:42,600 --> 01:37:44,699
disabled well on the on which game is it

2046
01:37:44,699 --> 01:37:47,360
on yours or

2047
01:37:47,639 --> 01:37:49,320
on the one online

2048
01:37:49,320 --> 01:37:52,620
of that normally normally inside this uh

2049
01:37:52,620 --> 01:37:56,100
it's supposed to be the folder where the

2050
01:37:56,100 --> 01:37:58,460
the AP doesn't go look

2051
01:37:58,460 --> 01:38:02,600
oh then then you will have problems

2052
01:38:02,880 --> 01:38:04,920
yeah no that that's not gonna work the

2053
01:38:04,920 --> 01:38:07,540
ads need to break things for you so

2054
01:38:07,540 --> 01:38:08,460
[Music]

2055
01:38:08,460 --> 01:38:09,659
um

2056
01:38:09,659 --> 01:38:11,820
yeah you have to either copy the same

2057
01:38:11,820 --> 01:38:12,840
folder or just work in the original

2058
01:38:12,840 --> 01:38:15,480
folder now the VMS that I shared with

2059
01:38:15,480 --> 01:38:17,639
you you can actually revert them on

2060
01:38:17,639 --> 01:38:19,500
remote you have this toolbar on the top

2061
01:38:19,500 --> 01:38:20,940
you can just restore them to the

2062
01:38:20,940 --> 01:38:24,060
original uh state so don't be afraid of

2063
01:38:24,060 --> 01:38:25,440
breaking them like it's going to take

2064
01:38:25,440 --> 01:38:27,719
some time to restore but at least like

2065
01:38:27,719 --> 01:38:31,520
you cannot cause any lasting damage

2066
01:38:32,040 --> 01:38:35,100
anyway going back to our debugger there

2067
01:38:35,100 --> 01:38:38,280
you notice that this call to some random

2068
01:38:38,280 --> 01:38:40,199
address is not really helpful to me and

2069
01:38:40,199 --> 01:38:42,659
I would like to import stuff I would

2070
01:38:42,659 --> 01:38:44,699
like to import my names from either into

2071
01:38:44,699 --> 01:38:46,320
my debugger which is something I can't

2072
01:38:46,320 --> 01:38:47,100
do

2073
01:38:47,100 --> 01:38:49,699
thanks to this repository there

2074
01:38:49,699 --> 01:38:52,380
so uh again if you're using like that

2075
01:38:52,380 --> 01:38:54,300
this is the plugin to use if you are

2076
01:38:54,300 --> 01:38:56,940
using visual or anything else uh you're

2077
01:38:56,940 --> 01:38:58,860
sort of possibly on your own sorry about

2078
01:38:58,860 --> 01:39:01,679
that I'm still going to show it to you

2079
01:39:01,679 --> 01:39:05,219
with Ida in your VMS you can either

2080
01:39:05,219 --> 01:39:07,940
import the script you can download

2081
01:39:07,940 --> 01:39:10,080
inside your machine score if you're

2082
01:39:10,080 --> 01:39:11,639
using my VMS online the plugin should

2083
01:39:11,639 --> 01:39:14,300
already be set up

2084
01:39:19,760 --> 01:39:23,940
and then export database and this is

2085
01:39:23,940 --> 01:39:25,560
going to create a big file actually let

2086
01:39:25,560 --> 01:39:26,880
me launch it right now because this

2087
01:39:26,880 --> 01:39:29,460
actually takes not super long so let me

2088
01:39:29,460 --> 01:39:32,360
put this on the desktop

2089
01:39:36,300 --> 01:39:39,900
and what it does is it creates this big

2090
01:39:39,900 --> 01:39:42,540
Json file that contains for every

2091
01:39:42,540 --> 01:39:45,420
address a corresponding label

2092
01:39:45,420 --> 01:39:48,120
so you can see there that uh takes a

2093
01:39:48,120 --> 01:39:49,620
heck for a while and this is because

2094
01:39:49,620 --> 01:39:50,880
because it's so big right there are

2095
01:39:50,880 --> 01:39:53,159
probably tens of thousands of names to

2096
01:39:53,159 --> 01:39:55,199
exporting so this will take probably

2097
01:39:55,199 --> 01:39:57,060
something like 30 seconds and it will be

2098
01:39:57,060 --> 01:39:58,440
exactly the same on the other end but we

2099
01:39:58,440 --> 01:40:01,620
import it back into X6 okay so there we

2100
01:40:01,620 --> 01:40:04,679
are hopefully

2101
01:40:04,679 --> 01:40:06,600
right so I do end up with this sun

2102
01:40:06,600 --> 01:40:09,060
shuttle the d64 you see that the file is

2103
01:40:09,060 --> 01:40:11,580
85 megabytes big so all the names have

2104
01:40:11,580 --> 01:40:15,060
been exported here it's super super huge

2105
01:40:15,060 --> 01:40:18,179
anyway I'll just put it in the VM

2106
01:40:18,179 --> 01:40:20,659
okay

2107
01:40:21,560 --> 01:40:24,600
there it is another thing that is a bit

2108
01:40:24,600 --> 01:40:27,480
annoying is the fact that

2109
01:40:27,480 --> 01:40:30,360
in order for this to work the program in

2110
01:40:30,360 --> 01:40:32,699
the VM needs to be exactly to have

2111
01:40:32,699 --> 01:40:34,620
exactly the same name as the program in

2112
01:40:34,620 --> 01:40:37,080
the host so it means that if the program

2113
01:40:37,080 --> 01:40:39,120
that Ida is advising is called Sun

2114
01:40:39,120 --> 01:40:40,620
shuttle

2115
01:40:40,620 --> 01:40:43,620
then the program in the VM has to be

2116
01:40:43,620 --> 01:40:44,940
named some trouble as well and this

2117
01:40:44,940 --> 01:40:46,920
video I have this exe extension that is

2118
01:40:46,920 --> 01:40:49,260
going to cause a problem so this is

2119
01:40:49,260 --> 01:40:50,460
something that happens a lot usually

2120
01:40:50,460 --> 01:40:51,659
when you work on a program on the host

2121
01:40:51,659 --> 01:40:53,040
machine you take away the extension you

2122
01:40:53,040 --> 01:40:55,500
don't know the exe extension to be there

2123
01:40:55,500 --> 01:40:57,179
in case you double click and expect

2124
01:40:57,179 --> 01:40:58,679
yourself

2125
01:40:58,679 --> 01:41:00,540
and what you want to run the program in

2126
01:41:00,540 --> 01:41:02,699
the VM the terminate into the e.exe so

2127
01:41:02,699 --> 01:41:04,199
how do you solve this well it's not easy

2128
01:41:04,199 --> 01:41:06,960
you just open the database there with a

2129
01:41:06,960 --> 01:41:09,120
notepad notepad doesn't really like

2130
01:41:09,120 --> 01:41:10,639
having it

2131
01:41:10,639 --> 01:41:14,159
those big files here

2132
01:41:14,159 --> 01:41:16,320
85 megabytes a little bit for it but you

2133
01:41:16,320 --> 01:41:18,960
can just rename this uh module name and

2134
01:41:18,960 --> 01:41:21,000
uh rename it to what you want so I'm

2135
01:41:21,000 --> 01:41:24,199
just going to replace this too

2136
01:41:30,260 --> 01:41:33,080
it's going to take a bit of time as well

2137
01:41:33,080 --> 01:41:35,460
the reason why we need to do this is

2138
01:41:35,460 --> 01:41:37,560
that if you don't when you import all

2139
01:41:37,560 --> 01:41:40,139
the database into x64 WG it will import

2140
01:41:40,139 --> 01:41:41,820
all the names properly but it won't be

2141
01:41:41,820 --> 01:41:43,739
able to recognize that the names match

2142
01:41:43,739 --> 01:41:45,300
you know are supposed to be associated

2143
01:41:45,300 --> 01:41:46,520
with the binary

2144
01:41:46,520 --> 01:41:51,739
so it's sort of annoying but uh yeah

2145
01:41:51,739 --> 01:41:53,520
to wait a little bit for this to

2146
01:41:53,520 --> 01:41:55,880
complete

2147
01:41:56,580 --> 01:41:59,040
yeah this is a very big file so the

2148
01:41:59,040 --> 01:42:02,960
replacement is going to take some time

2149
01:42:12,800 --> 01:42:15,060
and then when this is over I will go

2150
01:42:15,060 --> 01:42:17,239
there

2151
01:42:19,080 --> 01:42:21,540
where is it actually oh database and

2152
01:42:21,540 --> 01:42:24,080
then Imports

2153
01:42:39,659 --> 01:42:42,259
okay

2154
01:42:57,500 --> 01:42:59,760
in the meantime one thing we can do is

2155
01:42:59,760 --> 01:43:01,619
at least we know here that we have a

2156
01:43:01,619 --> 01:43:05,520
breakpoint on this open file

2157
01:43:05,520 --> 01:43:08,040
so we can look at the arguments and

2158
01:43:08,040 --> 01:43:09,780
check exactly what they are it was the

2159
01:43:09,780 --> 01:43:11,699
whole point right

2160
01:43:11,699 --> 01:43:15,000
so here this argument is 666

2161
01:43:15,000 --> 01:43:15,920
um

2162
01:43:15,920 --> 01:43:19,199
what we want is the file name so my name

2163
01:43:19,199 --> 01:43:24,019
is rcx you can just right click here

2164
01:43:34,500 --> 01:43:38,239
okay so here I have reached

2165
01:43:40,500 --> 01:43:44,400
I have reached my four to open file

2166
01:43:44,400 --> 01:43:47,000
this is

2167
01:43:47,880 --> 01:43:50,699
okay so here I put my the breakpoint on

2168
01:43:50,699 --> 01:43:52,800
my open file function

2169
01:43:52,800 --> 01:43:54,840
and it's very easy for me to go back up

2170
01:43:54,840 --> 01:43:56,460
and look at the orders

2171
01:43:56,460 --> 01:43:59,639
and the ornament number one yeah

2172
01:43:59,639 --> 01:44:03,380
go back to documentation here

2173
01:44:04,139 --> 01:44:06,780
there are other number one was the

2174
01:44:06,780 --> 01:44:10,020
strength and so if you recall I

2175
01:44:10,020 --> 01:44:11,580
mentioned that the string was a

2176
01:44:11,580 --> 01:44:14,400
Structure go in the Stream the structure

2177
01:44:14,400 --> 01:44:16,920
is going to be the pointer and the size

2178
01:44:16,920 --> 01:44:18,230
so let me

2179
01:44:18,230 --> 01:44:19,520
[Music]

2180
01:44:19,520 --> 01:44:22,679
rcx there is

2181
01:44:22,679 --> 01:44:25,679
0b

2182
01:44:32,119 --> 01:44:34,500
there is

2183
01:44:34,500 --> 01:44:37,500
conflict.net

2184
01:44:41,340 --> 01:44:44,659
okay right so you see that you have this

2185
01:44:44,659 --> 01:44:47,580
config.tmp we just put on the stack and

2186
01:44:47,580 --> 01:44:49,380
then the size of the string put on the

2187
01:44:49,380 --> 01:44:50,880
stack as well and then the other

2188
01:44:50,880 --> 01:44:52,080
argument

2189
01:44:52,080 --> 01:44:53,460
so

2190
01:44:53,460 --> 01:44:54,960
it's kind of difficult to try

2191
01:44:54,960 --> 01:44:56,460
to track but overall

2192
01:44:56,460 --> 01:44:59,000
that

2193
01:44:59,219 --> 01:45:03,000
when we reach this open file call this

2194
01:45:03,000 --> 01:45:05,699
conflict.tp

2195
01:45:05,699 --> 01:45:08,040
is still there somewhere

2196
01:45:08,040 --> 01:45:11,280
so let's update our code here

2197
01:45:11,280 --> 01:45:13,320
I suppose it was something like oh it

2198
01:45:13,320 --> 01:45:17,299
was or create or something

2199
01:45:17,520 --> 01:45:20,900
and then 666.

2200
01:45:20,940 --> 01:45:22,320
number one we're going to be using the

2201
01:45:22,320 --> 01:45:26,119
debugger a bit more and provide it okay

2202
01:45:26,179 --> 01:45:29,760
to save that and I'm going to import my

2203
01:45:29,760 --> 01:45:31,619
database there

2204
01:45:31,619 --> 01:45:33,980
so again you can click file

2205
01:45:33,980 --> 01:45:36,480
day-to-days and then you can import

2206
01:45:36,480 --> 01:45:39,480
whatever

2207
01:45:40,980 --> 01:45:42,960
you see this it's also going to take

2208
01:45:42,960 --> 01:45:44,820
some time because it has to force this

2209
01:45:44,820 --> 01:45:46,320
huge

2210
01:45:46,320 --> 01:45:48,900
file that is a HDM by today but

2211
01:45:48,900 --> 01:45:51,719
eventually there you go you see now in

2212
01:45:51,719 --> 01:45:54,360
the x64 dbg I do have the correct names

2213
01:45:54,360 --> 01:45:57,360
like searchable.os.open file Etc so it's

2214
01:45:57,360 --> 01:46:00,540
going to make my debug experience a bit

2215
01:46:00,540 --> 01:46:03,080
more enjoyable

2216
01:46:10,199 --> 01:46:13,199
here

2217
01:46:13,560 --> 01:46:16,639
so we know that open file returns

2218
01:46:16,639 --> 01:46:20,040
a file and an error so let's update our

2219
01:46:20,040 --> 01:46:22,199
code again

2220
01:46:22,199 --> 01:46:25,199
that

2221
01:46:27,840 --> 01:46:29,460
and you see that this time they don't

2222
01:46:29,460 --> 01:46:31,020
bother they don't seem to be checking

2223
01:46:31,020 --> 01:46:34,440
this error object which is bad practice

2224
01:46:34,440 --> 01:46:36,139
but it happens

2225
01:46:36,139 --> 01:46:38,520
the next thing they do is they do this

2226
01:46:38,520 --> 01:46:41,760
time but now and then time the time the

2227
01:46:41,760 --> 01:46:43,500
string and this is one of the examples

2228
01:46:43,500 --> 01:46:45,540
where it looks like this chaining of

2229
01:46:45,540 --> 01:46:47,219
functions is taking place without having

2230
01:46:47,219 --> 01:46:49,380
to move the arguments again

2231
01:46:49,380 --> 01:46:54,080
so we have this time of time and string

2232
01:47:04,639 --> 01:47:08,780
and it's being applied on time

2233
01:47:18,139 --> 01:47:22,580
okay so moving on

2234
01:47:25,500 --> 01:47:29,400
and then we have this call to get MP5

2235
01:47:29,400 --> 01:47:31,739
apps

2236
01:47:31,739 --> 01:47:33,900
well

2237
01:47:33,900 --> 01:47:36,000
the name is kind of transparent here

2238
01:47:36,000 --> 01:47:37,860
it's fairly easy to guess what is going

2239
01:47:37,860 --> 01:47:40,020
on we can go in there and check very

2240
01:47:40,020 --> 01:47:41,880
quickly

2241
01:47:41,880 --> 01:47:44,820
actually we will get back in here in a

2242
01:47:44,820 --> 01:47:45,600
second

2243
01:47:45,600 --> 01:47:48,500
let us just

2244
01:47:48,900 --> 01:47:50,719
let us just

2245
01:47:50,719 --> 01:47:53,699
hear uh look in the debugger what is

2246
01:47:53,699 --> 01:47:55,679
being passed as an argument just to make

2247
01:47:55,679 --> 01:47:57,000
sure

2248
01:47:57,000 --> 01:47:59,159
so let's put a new break point over

2249
01:47:59,159 --> 01:48:02,540
there move forward and here you see

2250
01:48:02,540 --> 01:48:04,920
whatever is the best as an argument

2251
01:48:04,920 --> 01:48:07,500
appears to be indeed

2252
01:48:07,500 --> 01:48:09,060
timestamp

2253
01:48:09,060 --> 01:48:11,820
of our of the current date

2254
01:48:11,820 --> 01:48:14,760
so we are we are doing still a little

2255
01:48:14,760 --> 01:48:16,739
bit of guessing but really a lot of

2256
01:48:16,739 --> 01:48:18,540
guessing but we're still on the right

2257
01:48:18,540 --> 01:48:20,699
track

2258
01:48:20,699 --> 01:48:23,040
and we can also

2259
01:48:23,040 --> 01:48:25,440
keep over this function and check out

2260
01:48:25,440 --> 01:48:28,519
what comes out of it

2261
01:48:30,540 --> 01:48:34,619
let me just follow this

2262
01:48:34,619 --> 01:48:37,759
up and copy everything

2263
01:48:49,860 --> 01:48:52,199
so I'm going to copy all this

2264
01:48:52,199 --> 01:48:55,860
and since I do believe that this get any

2265
01:48:55,860 --> 01:48:58,080
five hash function is going to calculate

2266
01:48:58,080 --> 01:49:00,300
maybe five hash I'm just going to verify

2267
01:49:00,300 --> 01:49:01,800
that this is true by calculating

2268
01:49:01,800 --> 01:49:05,239
calculating it myself let's go to

2269
01:49:05,239 --> 01:49:08,540
cyber chef

2270
01:49:11,400 --> 01:49:14,360
I don't know if you are aware

2271
01:49:14,360 --> 01:49:18,600
I assume you are it's a very useful tool

2272
01:49:18,600 --> 01:49:21,060
that you can use to convert by convert

2273
01:49:21,060 --> 01:49:23,820
strings and that encode them decode them

2274
01:49:23,820 --> 01:49:25,739
Etc it's really

2275
01:49:25,739 --> 01:49:28,139
some sort of Swiss army knife of

2276
01:49:28,139 --> 01:49:29,460
Oliver's encodings and their

2277
01:49:29,460 --> 01:49:30,900
Transformations you can think of so it's

2278
01:49:30,900 --> 01:49:33,679
super useful

2279
01:49:35,699 --> 01:49:39,678
I don't know wait so long to load but

2280
01:49:43,860 --> 01:49:46,020
I guess they want us to see their funny

2281
01:49:46,020 --> 01:49:48,440
messages

2282
01:49:54,139 --> 01:49:58,219
all right let's go back

2283
01:50:01,020 --> 01:50:05,540
so this is this is where we are

2284
01:50:05,540 --> 01:50:08,960
its main

2285
01:50:09,360 --> 01:50:11,219
yes MD

2286
01:50:11,219 --> 01:50:14,360
5 hash

2287
01:50:17,100 --> 01:50:19,940
like this

2288
01:50:23,400 --> 01:50:25,380
I'm just going to put

2289
01:50:25,380 --> 01:50:28,040
here

2290
01:50:34,159 --> 01:50:37,080
and then here I'm just going to press

2291
01:50:37,080 --> 01:50:41,280
F10 eight skip over and you can see the

2292
01:50:41,280 --> 01:50:44,540
return value right here

2293
01:50:46,159 --> 01:50:48,540
in one of the art in one of the return

2294
01:50:48,540 --> 01:50:50,699
values if you have 20 and the other one

2295
01:50:50,699 --> 01:50:52,260
you have

2296
01:50:52,260 --> 01:50:56,760
a hash 20 20x so there are 28 32 bytes

2297
01:50:56,760 --> 01:51:00,920
it's exactly the size of an md5 patch

2298
01:51:01,139 --> 01:51:04,500
so normally what we do there is I would

2299
01:51:04,500 --> 01:51:07,040
verify

2300
01:51:12,119 --> 01:51:13,380
that

2301
01:51:13,380 --> 01:51:17,340
this Dash value

2302
01:51:18,000 --> 01:51:19,860
I'm fairly sure this is the case so

2303
01:51:19,860 --> 01:51:22,080
we're not going to wait until cyber

2304
01:51:22,080 --> 01:51:23,820
shift loads

2305
01:51:23,820 --> 01:51:25,920
this would be a good way to not have to

2306
01:51:25,920 --> 01:51:28,320
reverse engineer this function that we

2307
01:51:28,320 --> 01:51:30,300
are looking at here we would have to go

2308
01:51:30,300 --> 01:51:31,380
over there we just know what comes in

2309
01:51:31,380 --> 01:51:32,820
what comes out and we should figure out

2310
01:51:32,820 --> 01:51:34,920
what it does

2311
01:51:34,920 --> 01:51:37,920
one thing I want to show you here is

2312
01:51:37,920 --> 01:51:40,320
that sometimes it's not very often but

2313
01:51:40,320 --> 01:51:42,719
sometimes you have this in go you have

2314
01:51:42,719 --> 01:51:45,179
this runtime new object and the call

2315
01:51:45,179 --> 01:51:47,219
taking place so it's whatever you do

2316
01:51:47,219 --> 01:51:50,580
have a classic sensation and go and it's

2317
01:51:50,580 --> 01:51:53,100
something that Ida is not able to handle

2318
01:51:53,100 --> 01:51:56,040
too well the way it works is we pass a

2319
01:51:56,040 --> 01:51:58,139
structure here which you cannot get into

2320
01:51:58,139 --> 01:52:00,480
because it's I'm not saying it's opaque

2321
01:52:00,480 --> 01:52:02,460
because it's documented but you can't

2322
01:52:02,460 --> 01:52:04,920
read it manually

2323
01:52:04,920 --> 01:52:06,360
and you pass the structure which

2324
01:52:06,360 --> 01:52:08,219
describes the class into runtime new

2325
01:52:08,219 --> 01:52:10,199
object and then in return you get an

2326
01:52:10,199 --> 01:52:13,679
instance of this class now I wrote a

2327
01:52:13,679 --> 01:52:16,920
script that resolves uh those types

2328
01:52:16,920 --> 01:52:18,239
because actually all the type

2329
01:52:18,239 --> 01:52:19,860
information is hidden somewhere in the

2330
01:52:19,860 --> 01:52:22,260
binary you can find it so I'm just going

2331
01:52:22,260 --> 01:52:23,940
to run that script it's also in the

2332
01:52:23,940 --> 01:52:25,440
repository I mentioned at the beginning

2333
01:52:25,440 --> 01:52:27,900
of this presentation and the white the

2334
01:52:27,900 --> 01:52:29,520
one called alpha build so you would get

2335
01:52:29,520 --> 01:52:31,920
script file here it's called the number

2336
01:52:31,920 --> 01:52:34,500
five extract types

2337
01:52:34,500 --> 01:52:38,100
products hopefully yeah there we are and

2338
01:52:38,100 --> 01:52:39,659
then you have a type which is the

2339
01:52:39,659 --> 01:52:42,420
pointer to an M5 Digest

2340
01:52:42,420 --> 01:52:45,420
so you get this type of passive super

2341
01:52:45,420 --> 01:52:47,639
timing object and then I guess you use

2342
01:52:47,639 --> 01:52:48,840
it

2343
01:52:48,840 --> 01:52:51,179
here I'm going to skip a little bit over

2344
01:52:51,179 --> 01:52:53,400
things you have this uh

2345
01:52:53,400 --> 01:52:56,699
stuff pushed into the Amplified digest

2346
01:52:56,699 --> 01:52:59,699
you can just see a digestive right and

2347
01:52:59,699 --> 01:53:04,040
then sum and then finally

2348
01:53:04,219 --> 01:53:06,540
so it really is something that looks

2349
01:53:06,540 --> 01:53:08,880
like a traditional creation of the in

2350
01:53:08,880 --> 01:53:10,139
the financial or computation of an

2351
01:53:10,139 --> 01:53:12,540
inside cache but that's the very cool

2352
01:53:12,540 --> 01:53:15,300
thing the very cool thing about you is

2353
01:53:15,300 --> 01:53:16,739
that if you were looking at a c program

2354
01:53:16,739 --> 01:53:18,960
then you have to recognize the constant

2355
01:53:18,960 --> 01:53:20,340
and try to see how the hash is

2356
01:53:20,340 --> 01:53:22,920
calculated and so on here video we just

2357
01:53:22,920 --> 01:53:24,420
have to look at the quotes to the real

2358
01:53:24,420 --> 01:53:26,040
step Library you can see that we have

2359
01:53:26,040 --> 01:53:28,980
close to well first an instantiation of

2360
01:53:28,980 --> 01:53:31,339
this

2361
01:53:36,380 --> 01:53:39,000
digest right digestion Etc and then

2362
01:53:39,000 --> 01:53:41,460
encode the result and that's it so this

2363
01:53:41,460 --> 01:53:44,820
is why I say very often that I think Go

2364
01:53:44,820 --> 01:53:46,980
reverse engineering is quite easier than

2365
01:53:46,980 --> 01:53:49,139
other languages it's just because you

2366
01:53:49,139 --> 01:53:50,520
don't have to recognize anything you

2367
01:53:50,520 --> 01:53:52,080
don't have to work with crypto you don't

2368
01:53:52,080 --> 01:53:54,239
have to get into complex functions you

2369
01:53:54,239 --> 01:53:55,920
just have to look at the codes and see

2370
01:53:55,920 --> 01:53:57,300
how they are trained together to see how

2371
01:53:57,300 --> 01:53:59,159
they relate to one another and from

2372
01:53:59,159 --> 01:54:01,320
there you can just reconstruct the

2373
01:54:01,320 --> 01:54:02,699
meaning of the program if we don't have

2374
01:54:02,699 --> 01:54:04,879
to

2375
01:54:05,540 --> 01:54:07,920
in recognizing what is happening in any

2376
01:54:07,920 --> 01:54:09,659
function really

2377
01:54:09,659 --> 01:54:11,400
maybe one thing

2378
01:54:11,400 --> 01:54:14,040
explained there as well is this string

2379
01:54:14,040 --> 01:54:15,840
to slice byte is a way to convert a

2380
01:54:15,840 --> 01:54:17,460
string to a byte array to byte rate

2381
01:54:17,460 --> 01:54:20,880
corresponding to the district bytes

2382
01:54:20,880 --> 01:54:23,400
and this one make slice is a function

2383
01:54:23,400 --> 01:54:27,360
that features a subdivision or slicing I

2384
01:54:27,360 --> 01:54:29,280
think it's called the the subdivision of

2385
01:54:29,280 --> 01:54:31,739
some array so this is what is used for

2386
01:54:31,739 --> 01:54:35,840
but I really haven't seen many cases

2387
01:54:35,840 --> 01:54:39,659
to figure out which slice needed to be

2388
01:54:39,659 --> 01:54:42,239
caught or exactly what part of the array

2389
01:54:42,239 --> 01:54:44,580
was being taken away so when you see

2390
01:54:44,580 --> 01:54:46,560
those strings slice by it and those

2391
01:54:46,560 --> 01:54:48,540
mixed slices Etc it's really usually

2392
01:54:48,540 --> 01:54:50,760
compiled making sure that the types can

2393
01:54:50,760 --> 01:54:53,239
get converted properly from one another

2394
01:54:53,239 --> 01:54:57,300
all right so let's go back here

2395
01:54:57,300 --> 01:54:59,780
the Cyber Chef hello yes it did

2396
01:54:59,780 --> 01:55:03,300
so let me just get this there and make

2397
01:55:03,300 --> 01:55:05,520
sure that everything works has attended

2398
01:55:05,520 --> 01:55:07,860
so this is my input

2399
01:55:07,860 --> 01:55:11,519
let's say 25.

2400
01:55:14,100 --> 01:55:17,420
come on how can you be that long

2401
01:55:17,460 --> 01:55:20,060
Jesus

2402
01:55:20,580 --> 01:55:22,560
oh well I guess uh we'll be back in a

2403
01:55:22,560 --> 01:55:24,679
bit

2404
01:55:26,300 --> 01:55:28,080
[Music]

2405
01:55:28,080 --> 01:55:30,300
anyway

2406
01:55:30,300 --> 01:55:33,619
which outside is

2407
01:55:34,320 --> 01:55:36,840
to have this runtime GC right barrier

2408
01:55:36,840 --> 01:55:39,239
something related to the double

2409
01:55:39,239 --> 01:55:42,619
collection we can skip over it

2410
01:55:42,780 --> 01:55:46,080
okay and then we have more stuff so this

2411
01:55:46,080 --> 01:55:46,980
string

2412
01:55:46,980 --> 01:55:50,340
which looks like a user agent

2413
01:55:50,340 --> 01:55:52,679
and then base64

2414
01:55:52,679 --> 01:55:56,119
and go to string

2415
01:55:56,119 --> 01:55:58,619
all right

2416
01:55:58,619 --> 01:56:00,659
so this is very likely going to be

2417
01:56:00,659 --> 01:56:02,639
encoded

2418
01:56:02,639 --> 01:56:05,940
Etc so let's think let the let's take

2419
01:56:05,940 --> 01:56:08,239
things

2420
01:56:08,460 --> 01:56:12,480
so let's go back to our debugger

2421
01:56:12,480 --> 01:56:15,179
so it's a break point there

2422
01:56:15,179 --> 01:56:18,380
is what happens exactly

2423
01:56:30,800 --> 01:56:34,080
right until my next record there I am

2424
01:56:34,080 --> 01:56:39,199
and so here you see that

2425
01:56:39,460 --> 01:56:42,199
[Music]

2426
01:56:42,199 --> 01:56:44,760
this user agent that we saw somewhere in

2427
01:56:44,760 --> 01:56:45,659
the code

2428
01:56:45,659 --> 01:56:47,900
all right

2429
01:56:47,900 --> 01:56:52,199
and then very likely if I press f8

2430
01:56:52,199 --> 01:56:55,159
what comes out

2431
01:57:01,800 --> 01:57:05,100
one thing I can put out there let's let

2432
01:57:05,100 --> 01:57:07,500
me show you the documentation for today

2433
01:57:07,500 --> 01:57:10,460
64.

2434
01:57:10,739 --> 01:57:12,540
there's

2435
01:57:12,540 --> 01:57:15,900
something interesting

2436
01:57:15,900 --> 01:57:18,900
correct

2437
01:57:25,920 --> 01:57:28,920
basics

2438
01:57:45,960 --> 01:57:48,000
is that unfortunately objective is

2439
01:57:48,000 --> 01:57:51,560
encoding and go to stream

2440
01:57:51,900 --> 01:57:55,080
now here there might be something you

2441
01:57:55,080 --> 01:57:57,360
would be wondering about is the fact

2442
01:57:57,360 --> 01:57:59,040
that okay we know that we have this

2443
01:57:59,040 --> 01:58:00,739
encode District function

2444
01:58:00,739 --> 01:58:05,959
this is the type of the arguments

2445
01:58:06,020 --> 01:58:07,560
so

2446
01:58:07,560 --> 01:58:10,440
what what is this right what is this

2447
01:58:10,440 --> 01:58:13,219
extra thing that we have there

2448
01:58:13,219 --> 01:58:14,490
this is

2449
01:58:14,490 --> 01:58:17,608
[Music]

2450
01:58:18,320 --> 01:58:20,940
an objects on which the function is

2451
01:58:20,940 --> 01:58:22,800
applied so

2452
01:58:22,800 --> 01:58:25,679
in the case of b64

2453
01:58:25,679 --> 01:58:28,619
there are actually different encodings

2454
01:58:28,619 --> 01:58:31,080
so you'll see here you have this for STD

2455
01:58:31,080 --> 01:58:32,699
encoding

2456
01:58:32,699 --> 01:58:35,580
the Stream and there's another one which

2457
01:58:35,580 --> 01:58:38,940
is a URL encoding so it's actually a

2458
01:58:38,940 --> 01:58:41,580
different alphabet there and so you

2459
01:58:41,580 --> 01:58:44,000
would have to

2460
01:58:44,040 --> 01:58:46,320
because normally this would never be an

2461
01:58:46,320 --> 01:58:47,820
issue because everyone uses a normal

2462
01:58:47,820 --> 01:58:51,840
encoding of base64 well in this specific

2463
01:58:51,840 --> 01:58:54,480
malware they actually use both encodings

2464
01:58:54,480 --> 01:58:58,380
so they use the uh they used to make the

2465
01:58:58,380 --> 01:59:02,300
your coding as well

2466
01:59:23,239 --> 01:59:25,739
if you try to decode it

2467
01:59:25,739 --> 01:59:29,760
you will see that well maybe for this

2468
01:59:29,760 --> 01:59:31,040
specific

2469
01:59:31,040 --> 01:59:33,540
string it works but for some strings

2470
01:59:33,540 --> 01:59:37,040
later on it would not work because

2471
01:59:40,040 --> 01:59:42,960
URL alphabets and not the standard

2472
01:59:42,960 --> 01:59:45,380
alphabet

2473
01:59:55,020 --> 01:59:58,739
format it which is a function that is

2474
01:59:58,739 --> 02:00:01,739
a way to convert an integer into a

2475
02:00:01,739 --> 02:00:03,239
string

2476
02:00:03,239 --> 02:00:08,820
and there you would see that this is the

2477
02:00:08,820 --> 02:00:12,060
this string there is going to be the uh

2478
02:00:12,060 --> 02:00:14,719
the integer has been converted so

2479
02:00:14,719 --> 02:00:18,239
integers five now normally I said it's

2480
02:00:18,239 --> 02:00:21,060
useless to rename things if you go well

2481
02:00:21,060 --> 02:00:22,500
for Global variables it's a bit

2482
02:00:22,500 --> 02:00:23,639
different because of course the global

2483
02:00:23,639 --> 02:00:27,060
variable is they tend not to be uh well

2484
02:00:27,060 --> 02:00:29,280
they do not get reused right so at the

2485
02:00:29,280 --> 02:00:30,719
moment we don't know what this is but

2486
02:00:30,719 --> 02:00:33,619
let's call This Global

2487
02:00:33,619 --> 02:00:37,280
ends right

2488
02:00:37,800 --> 02:00:41,280
and it gets converted into an integer

2489
02:00:41,280 --> 02:00:43,199
and you have a number of these taking

2490
02:00:43,199 --> 02:00:45,960
place right that you have this here

2491
02:00:45,960 --> 02:00:50,400
which is 0x f through 16. I don't rename

2492
02:00:50,400 --> 02:00:52,380
anything all of this I'm not going to do

2493
02:00:52,380 --> 02:00:53,760
it

2494
02:00:53,760 --> 02:00:56,510
you see that we have a number of them

2495
02:00:56,510 --> 02:00:57,900
[Music]

2496
02:00:57,900 --> 02:01:01,040
very like this okay

2497
02:01:04,020 --> 02:01:05,460
there

2498
02:01:05,460 --> 02:01:08,520
whatever was going on here that we just

2499
02:01:08,520 --> 02:01:11,340
skip through all those strings that were

2500
02:01:11,340 --> 02:01:13,099
being created they end up being

2501
02:01:13,099 --> 02:01:15,300
concatenated at the end so we are just

2502
02:01:15,300 --> 02:01:18,599
going to copy

2503
02:01:18,599 --> 02:01:20,580
yeah we're just going to copy the

2504
02:01:20,580 --> 02:01:21,900
address

2505
02:01:21,900 --> 02:01:23,639
and now

2506
02:01:23,639 --> 02:01:25,260
with the debugger we're just going to

2507
02:01:25,260 --> 02:01:26,880
look at the end result of this

2508
02:01:26,880 --> 02:01:29,880
information

2509
02:01:29,940 --> 02:01:33,500
I'll go back to inverter

2510
02:01:38,820 --> 02:01:41,599
and here

2511
02:01:41,760 --> 02:01:45,000
the end results is this huge string

2512
02:01:45,000 --> 02:01:48,139
there so I'm just going to see

2513
02:01:49,619 --> 02:01:52,580
copy everything

2514
02:01:59,190 --> 02:02:05,249
[Music]

2515
02:02:05,699 --> 02:02:08,480
so you see that one way or another

2516
02:02:08,480 --> 02:02:12,420
this huge string was has been created so

2517
02:02:12,420 --> 02:02:14,280
we have first

2518
02:02:14,280 --> 02:02:17,340
this which is a hash of the current date

2519
02:02:17,340 --> 02:02:19,020
that we know because we've seen in the

2520
02:02:19,020 --> 02:02:21,800
code and this 15

2521
02:02:21,800 --> 02:02:24,420
5-15 is something that was constructed

2522
02:02:24,420 --> 02:02:26,940
out of these hard-coded integers same

2523
02:02:26,940 --> 02:02:28,440
for zero zero

2524
02:02:28,440 --> 02:02:31,860
this is a user agent included in

2525
02:02:31,860 --> 02:02:36,659
page 64. and that's it so

2526
02:02:36,659 --> 02:02:40,098
let's go back here

2527
02:02:40,560 --> 02:02:42,840
strictest size bytes to just a version

2528
02:02:42,840 --> 02:02:44,179
of

2529
02:02:44,179 --> 02:02:47,099
main.trypt that's interesting let me

2530
02:02:47,099 --> 02:02:48,840
just skip over that for a second and

2531
02:02:48,840 --> 02:02:51,780
then right file

2532
02:02:51,780 --> 02:02:54,659
so let's recap a little bit what we've

2533
02:02:54,659 --> 02:02:57,320
seen so far

2534
02:02:57,500 --> 02:03:01,460
the code that we were fighting

2535
02:03:02,699 --> 02:03:05,340
I kind of gave up on doing this

2536
02:03:05,340 --> 02:03:07,260
reconstruction resource code I'll say a

2537
02:03:07,260 --> 02:03:08,880
few words about that later generally the

2538
02:03:08,880 --> 02:03:10,920
idea there was this we have this

2539
02:03:10,920 --> 02:03:12,900
function called define interval settings

2540
02:03:12,900 --> 02:03:17,340
there were two branches one of them was

2541
02:03:17,340 --> 02:03:20,880
if this conflict that that TM profile

2542
02:03:20,880 --> 02:03:23,219
exists then something don't know what

2543
02:03:23,219 --> 02:03:26,580
happens there or if it doesn't then the

2544
02:03:26,580 --> 02:03:30,179
file is created then it generates this

2545
02:03:30,179 --> 02:03:32,820
whole string there then we have a call

2546
02:03:32,820 --> 02:03:36,119
to make

2547
02:03:37,739 --> 02:03:40,739
sure

2548
02:03:48,560 --> 02:03:52,739
let's assume we end up with s

2549
02:03:52,739 --> 02:03:54,930
traffic

2550
02:03:54,930 --> 02:03:58,029
[Music]

2551
02:04:01,860 --> 02:04:04,699
something like that

2552
02:04:06,900 --> 02:04:09,900
this

2553
02:04:09,900 --> 02:04:15,199
and then we have main dot encrypt

2554
02:04:15,659 --> 02:04:19,638
off I assume conflict

2555
02:04:20,639 --> 02:04:24,080
probably we had a restaurant right right

2556
02:04:24,080 --> 02:04:28,139
file which I guess yeah open file

2557
02:04:28,139 --> 02:04:31,139
around

2558
02:04:33,840 --> 02:04:36,179
wrapping stuff right around writing

2559
02:04:36,179 --> 02:04:37,739
stuff into a file

2560
02:04:37,739 --> 02:04:40,339
this

2561
02:04:41,040 --> 02:04:43,139
and here I'm just going to go out on the

2562
02:04:43,139 --> 02:04:45,239
link and guess that arguments are F

2563
02:04:45,239 --> 02:04:48,179
which is the file we have there

2564
02:04:48,179 --> 02:04:50,520
and

2565
02:04:50,520 --> 02:04:53,760
config okay

2566
02:04:53,760 --> 02:04:55,800
so in essence

2567
02:04:55,800 --> 02:04:58,320
if we end up in our Branch where this

2568
02:04:58,320 --> 02:04:59,719
read file

2569
02:04:59,719 --> 02:05:03,920
string does not exist our file name

2570
02:05:03,920 --> 02:05:06,719
config.tmp does not exist then we just

2571
02:05:06,719 --> 02:05:09,420
enter this branch and then some sort of

2572
02:05:09,420 --> 02:05:11,940
default configuration is generated

2573
02:05:11,940 --> 02:05:14,099
from the program from the hot cool

2574
02:05:14,099 --> 02:05:15,179
Italian values present to the program

2575
02:05:15,179 --> 02:05:17,099
and we know that this is going to be

2576
02:05:17,099 --> 02:05:19,260
this is a timestamp

2577
02:05:19,260 --> 02:05:21,960
or the hash of the timestamp

2578
02:05:21,960 --> 02:05:24,060
these values we can maybe figure out

2579
02:05:24,060 --> 02:05:26,340
later on and this is an affiliate user

2580
02:05:26,340 --> 02:05:29,280
agent and that's it now

2581
02:05:29,280 --> 02:05:31,380
let's check out what is going on in this

2582
02:05:31,380 --> 02:05:33,480
entry function I guess right this is

2583
02:05:33,480 --> 02:05:36,500
going to be our next step

2584
02:05:36,780 --> 02:05:40,519
to go back up a bit

2585
02:05:41,099 --> 02:05:44,480
not too much

2586
02:05:47,480 --> 02:05:50,718
about this

2587
02:05:54,800 --> 02:05:58,020
so you see that now I'm starting to play

2588
02:05:58,020 --> 02:06:01,880
a bit loose with my reconstruction right

2589
02:06:01,880 --> 02:06:05,060
thank you

2590
02:06:05,820 --> 02:06:08,520
as much as a rigorous job as I used to

2591
02:06:08,520 --> 02:06:10,860
before is because when I actually work

2592
02:06:10,860 --> 02:06:12,719
on my go program that I'm not really

2593
02:06:12,719 --> 02:06:15,239
going to bother me all this all the time

2594
02:06:15,239 --> 02:06:18,239
the first time I worked on a program I

2595
02:06:18,239 --> 02:06:19,560
really reconstructed the whole thing

2596
02:06:19,560 --> 02:06:22,080
like that and I really encourage you to

2597
02:06:22,080 --> 02:06:24,480
do so when you are starting out and of

2598
02:06:24,480 --> 02:06:26,340
course as you move on then you're going

2599
02:06:26,340 --> 02:06:28,679
to start figuring out you don't have to

2600
02:06:28,679 --> 02:06:30,000
write everything the way that you're

2601
02:06:30,000 --> 02:06:31,440
using the best

2602
02:06:31,440 --> 02:06:32,639
yeah

2603
02:06:32,639 --> 02:06:36,000
but I I hope you will believe me when I

2604
02:06:36,000 --> 02:06:37,560
do say that when I started out this is

2605
02:06:37,560 --> 02:06:39,300
actually what I did and this is how I

2606
02:06:39,300 --> 02:06:41,580
really got into reversing window so it's

2607
02:06:41,580 --> 02:06:45,119
a method does work when you looked at me

2608
02:06:45,119 --> 02:06:47,400
doing this it's very I suppose that you

2609
02:06:47,400 --> 02:06:48,840
will be tempted to think that sort of

2610
02:06:48,840 --> 02:06:50,040
easy because I've looked at this program

2611
02:06:50,040 --> 02:06:52,199
before and so I know what is happening

2612
02:06:52,199 --> 02:06:53,940
and I know what the source but it's

2613
02:06:53,940 --> 02:06:55,500
supposed to look like but

2614
02:06:55,500 --> 02:06:57,360
actually like this is really the way

2615
02:06:57,360 --> 02:06:59,340
that I approach this program initially

2616
02:06:59,340 --> 02:07:02,840
when I first encountered it

2617
02:07:06,360 --> 02:07:08,960
Crypt

2618
02:07:11,300 --> 02:07:14,159
and there again we're going to move very

2619
02:07:14,159 --> 02:07:17,699
quickly a few things you have this refer

2620
02:07:17,699 --> 02:07:20,159
to AES new Cipher

2621
02:07:20,159 --> 02:07:23,280
version of an as Cipher

2622
02:07:23,280 --> 02:07:25,500
bytes repeats there and you just assume

2623
02:07:25,500 --> 02:07:29,420
this is maybe some bedding or something

2624
02:07:30,659 --> 02:07:33,420
okay runtime gross class we don't care

2625
02:07:33,420 --> 02:07:35,960
about that

2626
02:07:36,139 --> 02:07:39,540
not much is happening there are you read

2627
02:07:39,540 --> 02:07:41,040
at last

2628
02:07:41,040 --> 02:07:44,880
something interesting Cipher new CSV so

2629
02:07:44,880 --> 02:07:46,560
the cipher is going to be

2630
02:07:46,560 --> 02:07:50,960
AES like did I see AES before

2631
02:07:54,119 --> 02:07:57,420
okay yeah AES music so we have an AES

2632
02:07:57,420 --> 02:08:01,380
Cipher but we know it's in cfd mode to

2633
02:08:01,380 --> 02:08:04,860
skip over all this stuff yeah

2634
02:08:04,860 --> 02:08:07,460
and

2635
02:08:08,699 --> 02:08:11,880
he replaced and

2636
02:08:11,880 --> 02:08:15,719
yeah so what's going on there so you see

2637
02:08:15,719 --> 02:08:18,960
that we don't see exactly what is being

2638
02:08:18,960 --> 02:08:21,179
called right there's something missing

2639
02:08:21,179 --> 02:08:23,520
there we have a call to the creation of

2640
02:08:23,520 --> 02:08:26,159
our recycler with cfd mode and then we

2641
02:08:26,159 --> 02:08:28,440
have call Rex so here

2642
02:08:28,440 --> 02:08:30,420
it looks like for once you don't know

2643
02:08:30,420 --> 02:08:32,099
exactly what has been told to use a

2644
02:08:32,099 --> 02:08:34,520
debugger

2645
02:08:35,360 --> 02:08:37,320
so I'm just going to talk to your

2646
02:08:37,320 --> 02:08:38,880
address there and see exactly what's in

2647
02:08:38,880 --> 02:08:43,040
Rex when we reach this point

2648
02:08:48,739 --> 02:08:52,500
there okay and then you see when I read

2649
02:08:52,500 --> 02:08:55,280
this point we call

2650
02:08:55,280 --> 02:08:57,360
crypto.cipher.xor keystream so I suppose

2651
02:08:57,360 --> 02:08:59,639
this is going to be the sort of the

2652
02:08:59,639 --> 02:09:01,560
actual

2653
02:09:01,560 --> 02:09:04,320
computation of the actual encryption

2654
02:09:04,320 --> 02:09:06,860
taking place

2655
02:09:07,500 --> 02:09:09,540
and then until the string

2656
02:09:09,540 --> 02:09:13,199
Etc so one thing that is missing there

2657
02:09:13,199 --> 02:09:18,080
is going to be the AES key right

2658
02:09:23,159 --> 02:09:27,739
it's in the initialization Vector either

2659
02:09:28,940 --> 02:09:31,619
for you and they can put it at the

2660
02:09:31,619 --> 02:09:35,159
beginning of the of the encoded data so

2661
02:09:35,159 --> 02:09:37,020
the developer actually doesn't have to

2662
02:09:37,020 --> 02:09:40,260
think about it this too much

2663
02:09:40,260 --> 02:09:42,179
though is in that sense a language that

2664
02:09:42,179 --> 02:09:43,500
really does everything it gets to

2665
02:09:43,500 --> 02:09:44,880
prevent you from shooting yourself in

2666
02:09:44,880 --> 02:09:46,679
the foot

2667
02:09:46,679 --> 02:09:50,880
so we have this main.net function we did

2668
02:09:50,880 --> 02:09:52,260
not see anything that looked like key

2669
02:09:52,260 --> 02:09:53,940
material in there

2670
02:09:53,940 --> 02:09:55,920
so what we are going to do is we're

2671
02:09:55,920 --> 02:09:58,080
going to look around this function call

2672
02:09:58,080 --> 02:10:01,920
and see what could be the key the AES

2673
02:10:01,920 --> 02:10:04,619
key being used if we look around well

2674
02:10:04,619 --> 02:10:07,080
the only thing that we can see there is

2675
02:10:07,080 --> 02:10:09,900
this right we have this

2676
02:10:09,900 --> 02:10:13,020
what seems to be a global variable let's

2677
02:10:13,020 --> 02:10:15,300
go there

2678
02:10:15,300 --> 02:10:17,460
um well one of the

2679
02:10:17,460 --> 02:10:20,580
one of the values is 20 which to me

2680
02:10:20,580 --> 02:10:23,940
looks a bit like a size and the other

2681
02:10:23,940 --> 02:10:25,320
is

2682
02:10:25,320 --> 02:10:27,599
it looks like

2683
02:10:27,599 --> 02:10:29,699
some offset

2684
02:10:29,699 --> 02:10:32,760
so let us try again

2685
02:10:32,760 --> 02:10:37,139
let's look through the debugger exactly

2686
02:10:37,139 --> 02:10:41,040
what is in there so let me just put a

2687
02:10:41,040 --> 02:10:44,159
break point here

2688
02:10:44,159 --> 02:10:48,379
I'm going to relaunch the whole program

2689
02:10:50,940 --> 02:10:53,540
okay

2690
02:10:56,179 --> 02:11:00,800
let's break points

2691
02:11:06,980 --> 02:11:10,260
looks like my layout that kind of messed

2692
02:11:10,260 --> 02:11:12,380
up

2693
02:11:20,599 --> 02:11:23,820
it looks like my brake boards do not

2694
02:11:23,820 --> 02:11:26,239
work anymore

2695
02:11:26,300 --> 02:11:28,380
okay I don't know exactly what happened

2696
02:11:28,380 --> 02:11:30,000
there

2697
02:11:30,000 --> 02:11:33,560
it doesn't matter too much right

2698
02:11:47,179 --> 02:11:49,980
oh or maybe the reason why at my

2699
02:11:49,980 --> 02:11:52,750
breakpoint wasn't it is because

2700
02:11:52,750 --> 02:11:54,659
[Music]

2701
02:11:54,659 --> 02:11:56,760
now

2702
02:11:56,760 --> 02:12:00,080
the file has been created

2703
02:12:00,900 --> 02:12:02,820
yeah you see on my desktop I do have

2704
02:12:02,820 --> 02:12:05,400
this conflict.tv because my previous

2705
02:12:05,400 --> 02:12:06,719
debugging

2706
02:12:06,719 --> 02:12:09,480
and so now I enter the other branch and

2707
02:12:09,480 --> 02:12:11,040
this is why I could not reach this again

2708
02:12:11,040 --> 02:12:13,139
so I'm just going to delete this

2709
02:12:13,139 --> 02:12:16,260
and try again

2710
02:12:16,260 --> 02:12:19,560
okay so I get to the open file get any

2711
02:12:19,560 --> 02:12:20,760
five hash this is where my previous

2712
02:12:20,760 --> 02:12:23,360
breakpoints

2713
02:12:23,360 --> 02:12:24,900
okay

2714
02:12:24,900 --> 02:12:28,560
and there we are so let's follow this in

2715
02:12:28,560 --> 02:12:30,920
the term

2716
02:12:32,639 --> 02:12:34,920
this website

2717
02:12:34,920 --> 02:12:37,219
address

2718
02:12:37,500 --> 02:12:42,860
okay and you see now I have

2719
02:12:42,860 --> 02:12:45,960
somewhere I have ended up in the region

2720
02:12:45,960 --> 02:12:48,239
that contains random bytes

2721
02:12:48,239 --> 02:12:54,259
um I think those might keep 100 sure

2722
02:12:56,400 --> 02:12:58,879
this

2723
02:13:00,060 --> 02:13:02,940
oh maybe it's essential following them

2724
02:13:02,940 --> 02:13:06,420
yeah yeah that really looks like

2725
02:13:06,420 --> 02:13:10,139
some random data that could be so this

2726
02:13:10,139 --> 02:13:12,960
could be usability so to double check

2727
02:13:12,960 --> 02:13:15,900
this what I would have to do that is

2728
02:13:15,900 --> 02:13:18,780
store this somewhere and

2729
02:13:18,780 --> 02:13:20,880
try to see whatever data comes out of

2730
02:13:20,880 --> 02:13:23,820
this main input function put that back

2731
02:13:23,820 --> 02:13:25,739
into cyber chef and try to decrypt

2732
02:13:25,739 --> 02:13:27,780
everything with this key and the ID that

2733
02:13:27,780 --> 02:13:29,639
will be at the beginning of the of the

2734
02:13:29,639 --> 02:13:31,020
output data

2735
02:13:31,020 --> 02:13:33,300
um please believe me when I tell you

2736
02:13:33,300 --> 02:13:34,560
it's going to work

2737
02:13:34,560 --> 02:13:36,540
um I'm not going to do this here because

2738
02:13:36,540 --> 02:13:38,520
it's going to require me to like take

2739
02:13:38,520 --> 02:13:40,619
the 16 first bytes manually and then put

2740
02:13:40,619 --> 02:13:42,119
them back as a magnetization it's just

2741
02:13:42,119 --> 02:13:43,980
annoying

2742
02:13:43,980 --> 02:13:46,619
but it does work so

2743
02:13:46,619 --> 02:13:50,400
just doing this uh we were able to

2744
02:13:50,400 --> 02:13:52,320
get the AES key that is being used in

2745
02:13:52,320 --> 02:13:53,699
the program

2746
02:13:53,699 --> 02:13:57,379
and we're also able to

2747
02:13:57,840 --> 02:14:00,300
not figure out what was going on there

2748
02:14:00,300 --> 02:14:02,520
just go back here

2749
02:14:02,520 --> 02:14:04,500
one thing I want to point out at this

2750
02:14:04,500 --> 02:14:06,960
juncture is really that

2751
02:14:06,960 --> 02:14:09,300
in terms of reverse engineering we

2752
02:14:09,300 --> 02:14:11,280
haven't been doing much right we just

2753
02:14:11,280 --> 02:14:13,560
skip over every assembly instruction if

2754
02:14:13,560 --> 02:14:14,940
we look at the function calls and use

2755
02:14:14,940 --> 02:14:17,460
our debugger to just dump or sort of

2756
02:14:17,460 --> 02:14:18,900
dump all the arguments that are being

2757
02:14:18,900 --> 02:14:21,119
used and then from there we sort of

2758
02:14:21,119 --> 02:14:23,400
guessed slash figure out what is going

2759
02:14:23,400 --> 02:14:24,719
on in the program

2760
02:14:24,719 --> 02:14:26,219
so

2761
02:14:26,219 --> 02:14:27,780
um I do sometimes teach University

2762
02:14:27,780 --> 02:14:29,880
classes to heat reverse engineering and

2763
02:14:29,880 --> 02:14:31,020
I'm pretty sure that the first year

2764
02:14:31,020 --> 02:14:32,880
students who are very uncomfortable with

2765
02:14:32,880 --> 02:14:35,040
assembly would actually be pretty okay

2766
02:14:35,040 --> 02:14:36,900
with reversing when you go so this is

2767
02:14:36,900 --> 02:14:38,760
one of the main takeaways I wanted to

2768
02:14:38,760 --> 02:14:40,679
share with you is the fact that

2769
02:14:40,679 --> 02:14:42,179
if you try to follow all the

2770
02:14:42,179 --> 02:14:43,380
instructions in the go program and

2771
02:14:43,380 --> 02:14:44,940
you're going to have probably a very bad

2772
02:14:44,940 --> 02:14:45,840
day

2773
02:14:45,840 --> 02:14:48,119
but if you take the quick and easy

2774
02:14:48,119 --> 02:14:49,560
approach of looking at the various

2775
02:14:49,560 --> 02:14:51,119
function tools that we don't have to do

2776
02:14:51,119 --> 02:14:52,980
that much work to figure out that AES is

2777
02:14:52,980 --> 02:14:54,480
taking place we can figure out who the

2778
02:14:54,480 --> 02:14:56,520
key is we can see that files are being

2779
02:14:56,520 --> 02:14:58,079
created we can just use the debugger to

2780
02:14:58,079 --> 02:15:00,480
see which files can so on and it's

2781
02:15:00,480 --> 02:15:03,119
really some sort of easy win where we

2782
02:15:03,119 --> 02:15:04,980
just get our answers without having to

2783
02:15:04,980 --> 02:15:06,840
work too much for them so I think this

2784
02:15:06,840 --> 02:15:10,760
is really pretty cool foreign

2785
02:15:10,760 --> 02:15:14,159
let me go back to this main encrypt

2786
02:15:14,159 --> 02:15:16,440
function I think I was in there here so

2787
02:15:16,440 --> 02:15:18,960
I'm going to just do debug and then

2788
02:15:18,960 --> 02:15:22,040
executive return

2789
02:15:27,540 --> 02:15:30,420
okay so I'm just getting out of my main

2790
02:15:30,420 --> 02:15:32,400
dot encrypt

2791
02:15:32,400 --> 02:15:36,780
I'm going to move on and go up to this

2792
02:15:36,780 --> 02:15:39,599
main right file there

2793
02:15:39,599 --> 02:15:42,900
so at the moment if I go to my desktop

2794
02:15:42,900 --> 02:15:45,560
here I'm supposedly yeah I do have this

2795
02:15:45,560 --> 02:15:49,340
conflict.net.tp file here

2796
02:15:50,540 --> 02:15:53,880
somewhere at the end and if I press f8

2797
02:15:53,880 --> 02:15:56,159
here and skip over

2798
02:15:56,159 --> 02:15:57,840
then going back to my desktop you see

2799
02:15:57,840 --> 02:15:58,679
that

2800
02:15:58,679 --> 02:16:01,199
sorry wrong desktop you can see that now

2801
02:16:01,199 --> 02:16:03,119
my file contains

2802
02:16:03,119 --> 02:16:06,119
data now it's now one kilobyte big and

2803
02:16:06,119 --> 02:16:09,239
if I open it with my hex editor

2804
02:16:09,239 --> 02:16:13,320
yeah you see it is a mixture of it looks

2805
02:16:13,320 --> 02:16:17,000
like a base64 but you know with the

2806
02:16:17,000 --> 02:16:19,560
underscores and dashes so this is the

2807
02:16:19,560 --> 02:16:20,940
URL

2808
02:16:20,940 --> 02:16:23,880
basically anyway so

2809
02:16:23,880 --> 02:16:26,099
at this point what I would do here is I

2810
02:16:26,099 --> 02:16:27,300
would try to make sure that I didn't

2811
02:16:27,300 --> 02:16:28,920
make any mistakes I would decode

2812
02:16:28,920 --> 02:16:31,139
everything with cyber chef and verify

2813
02:16:31,139 --> 02:16:33,200
that I did get back this

2814
02:16:33,200 --> 02:16:35,700
string that we had initially which was

2815
02:16:35,700 --> 02:16:37,320
this one

2816
02:16:37,320 --> 02:16:40,200
and uh okay so here trust me but it's

2817
02:16:40,200 --> 02:16:43,160
going to be the case

2818
02:16:45,540 --> 02:16:48,718
well it looks like we're done right this

2819
02:16:48,718 --> 02:16:50,459
branch is over

2820
02:16:50,459 --> 02:16:53,179
so let us go back up a little bit

2821
02:16:53,179 --> 02:16:56,700
and look at what happens if the file

2822
02:16:56,700 --> 02:16:58,379
already exists right so I'm just going

2823
02:16:58,379 --> 02:17:01,439
to go all the way back up here and if

2824
02:17:01,439 --> 02:17:03,000
you recall this what the beginning of

2825
02:17:03,000 --> 02:17:04,859
this function where we started out by

2826
02:17:04,859 --> 02:17:06,740
checking if this

2827
02:17:06,740 --> 02:17:09,540
config.det.tmp file existed if it didn't

2828
02:17:09,540 --> 02:17:11,519
well now we know what happens we go into

2829
02:17:11,519 --> 02:17:14,218
this branch and we just create it with

2830
02:17:14,218 --> 02:17:16,340
some random some hard-coded values

2831
02:17:16,340 --> 02:17:20,240
otherwise we go in there

2832
02:17:20,820 --> 02:17:23,820
is

2833
02:17:28,218 --> 02:17:30,780
going to be useful when you figure out

2834
02:17:30,780 --> 02:17:32,760
where the AES keys were and so we should

2835
02:17:32,760 --> 02:17:36,478
probably rename them so let's do that we

2836
02:17:36,478 --> 02:17:41,398
would hear main encrypt and this was

2837
02:17:41,398 --> 02:17:44,700
this here was the key size so let me

2838
02:17:44,700 --> 02:17:47,960
make that AES

2839
02:17:58,398 --> 02:18:01,740
okay like this

2840
02:18:01,740 --> 02:18:03,959
I might as well do it because I'm pretty

2841
02:18:03,959 --> 02:18:05,760
sure that on the other Branch we are

2842
02:18:05,760 --> 02:18:08,700
going to have references to those key

2843
02:18:08,700 --> 02:18:11,040
okay so here we are back in the other

2844
02:18:11,040 --> 02:18:13,379
branch and so if the file does exist

2845
02:18:13,379 --> 02:18:15,120
then as you might expect

2846
02:18:15,120 --> 02:18:17,820
the keys get referred to you get

2847
02:18:17,820 --> 02:18:19,920
downloaded somewhere and then we have

2848
02:18:19,920 --> 02:18:22,978
this main dot decrypt function

2849
02:18:22,978 --> 02:18:26,160
which I assume

2850
02:18:26,160 --> 02:18:29,820
would be applied to this

2851
02:18:29,820 --> 02:18:32,519
contents value that we got from the read

2852
02:18:32,519 --> 02:18:35,179
file initial

2853
02:18:35,879 --> 02:18:37,978
and then

2854
02:18:37,978 --> 02:18:40,138
here

2855
02:18:40,138 --> 02:18:42,718
you have this gen split function uh

2856
02:18:42,718 --> 02:18:45,898
which works on the character

2857
02:18:45,898 --> 02:18:48,860
pipe sign like this

2858
02:18:48,860 --> 02:18:53,839
[Music]

2859
02:18:54,058 --> 02:18:56,580
so we just split whatever string was

2860
02:18:56,580 --> 02:18:57,780
returned after we decrypt the

2861
02:18:57,780 --> 02:19:01,019
configuration and split it with the

2862
02:19:01,019 --> 02:19:03,179
pipesign token so it makes sense because

2863
02:19:03,179 --> 02:19:04,558
this is

2864
02:19:04,558 --> 02:19:06,478
sort of uh

2865
02:19:06,478 --> 02:19:09,898
structure that we've seen so really

2866
02:19:09,898 --> 02:19:12,780
nothing really does nothing expected

2867
02:19:12,780 --> 02:19:16,820
and then the strings are split

2868
02:19:19,138 --> 02:19:21,420
because then we just involved

2869
02:19:21,420 --> 02:19:24,959
from sdrcom a to I so for based on the

2870
02:19:24,959 --> 02:19:26,580
tokens we convert them back from strings

2871
02:19:26,580 --> 02:19:28,859
to integers

2872
02:19:28,859 --> 02:19:31,080
and then in fact they will be stored

2873
02:19:31,080 --> 02:19:33,240
back into the doable variables that

2874
02:19:33,240 --> 02:19:35,840
we've seen before

2875
02:19:37,760 --> 02:19:39,299
so

2876
02:19:39,299 --> 02:19:42,898
this function uh really here of course

2877
02:19:42,898 --> 02:19:45,599
I'm just skipping over a lot

2878
02:19:45,599 --> 02:19:47,719
um

2879
02:19:48,720 --> 02:19:50,580
we've seen this already but what would

2880
02:19:50,580 --> 02:19:52,620
happen in this branch is the opposite of

2881
02:19:52,620 --> 02:19:54,240
the other one by which I mean that

2882
02:19:54,240 --> 02:19:56,160
instead of taking hard-coded values and

2883
02:19:56,160 --> 02:19:57,479
storing them in the configuration then

2884
02:19:57,479 --> 02:19:59,460
we would take configuration decrypt the

2885
02:19:59,460 --> 02:20:01,560
configuration and read the values back

2886
02:20:01,560 --> 02:20:03,720
into the memory of the programming into

2887
02:20:03,720 --> 02:20:07,740
the Global variables

2888
02:20:07,740 --> 02:20:09,899
so we now

2889
02:20:09,899 --> 02:20:12,240
sort of know what is taking place into

2890
02:20:12,240 --> 02:20:14,760
this big

2891
02:20:14,760 --> 02:20:16,620
it's probably the way up Define internal

2892
02:20:16,620 --> 02:20:18,600
settings function it's actually the

2893
02:20:18,600 --> 02:20:20,520
function that processes the

2894
02:20:20,520 --> 02:20:23,220
configuration of the program either the

2895
02:20:23,220 --> 02:20:24,780
configuration does not exist and we

2896
02:20:24,780 --> 02:20:26,939
create it or the configuration exist and

2897
02:20:26,939 --> 02:20:29,760
so we load it and put the values in the

2898
02:20:29,760 --> 02:20:31,020
global variables

2899
02:20:31,020 --> 02:20:33,200
so

2900
02:20:33,780 --> 02:20:37,340
back here

2901
02:20:39,060 --> 02:20:40,979
and then

2902
02:20:40,979 --> 02:20:43,200
we would be back there

2903
02:20:43,200 --> 02:20:45,120
I think

2904
02:20:45,120 --> 02:20:47,700
this is probably a good time to like put

2905
02:20:47,700 --> 02:20:49,680
a stop to this analysis of course there

2906
02:20:49,680 --> 02:20:52,260
is a lot going on in this program what

2907
02:20:52,260 --> 02:20:54,660
we saw there is just the very beginning

2908
02:20:54,660 --> 02:20:55,859
which is the logging of the

2909
02:20:55,859 --> 02:20:57,120
configuration

2910
02:20:57,120 --> 02:20:58,920
it took us something like two hours to

2911
02:20:58,920 --> 02:21:00,479
get there but of course we really took

2912
02:21:00,479 --> 02:21:01,979
our time we really wanted to make sure

2913
02:21:01,979 --> 02:21:03,420
that we had everything correct and we

2914
02:21:03,420 --> 02:21:06,660
wanted to check every argument under the

2915
02:21:06,660 --> 02:21:08,939
debugger Etc and also we reconstructed

2916
02:21:08,939 --> 02:21:10,920
part of the program so it was a

2917
02:21:10,920 --> 02:21:12,240
over here

2918
02:21:12,240 --> 02:21:17,040
time consuming effort but overall what

2919
02:21:17,040 --> 02:21:20,460
happens next is we enter the main Loop

2920
02:21:20,460 --> 02:21:22,979
of the program and we but now that we

2921
02:21:22,979 --> 02:21:24,060
have the configuration the program

2922
02:21:24,060 --> 02:21:25,859
starts doing stuff on the victim machine

2923
02:21:25,859 --> 02:21:27,479
so this is where he would connect to the

2924
02:21:27,479 --> 02:21:29,280
city server and start interacting with

2925
02:21:29,280 --> 02:21:32,520
the C2 in exactly the same way that we

2926
02:21:32,520 --> 02:21:33,780
were able to look at how the

2927
02:21:33,780 --> 02:21:36,720
configuration is loaded here and go we

2928
02:21:36,720 --> 02:21:38,399
would be able as well to look at the

2929
02:21:38,399 --> 02:21:40,020
protocol that is used to talk with this

2930
02:21:40,020 --> 02:21:42,960
to server look at the different uh

2931
02:21:42,960 --> 02:21:44,939
keywords that can be sent by the city to

2932
02:21:44,939 --> 02:21:46,920
trigger different actions of the system

2933
02:21:46,920 --> 02:21:48,840
Etc and just by doing this exact same

2934
02:21:48,840 --> 02:21:50,819
process but Computing it

2935
02:21:50,819 --> 02:21:52,859
on the whole the rest of the program

2936
02:21:52,859 --> 02:21:55,200
that we would be able to understand all

2937
02:21:55,200 --> 02:21:56,300
of it

2938
02:21:56,300 --> 02:21:59,280
the overall I think with something like

2939
02:21:59,280 --> 02:22:01,500
two to three days of work then you can

2940
02:22:01,500 --> 02:22:03,540
be sort of

2941
02:22:03,540 --> 02:22:05,040
um I would say confident that you would

2942
02:22:05,040 --> 02:22:07,760
be able to see everything

2943
02:22:07,760 --> 02:22:10,260
go program even though it is five

2944
02:22:10,260 --> 02:22:12,120
megabytes big and even though you might

2945
02:22:12,120 --> 02:22:13,439
not have to fix every single line of

2946
02:22:13,439 --> 02:22:15,479
Goku in your whole life

2947
02:22:15,479 --> 02:22:19,319
so uh I think we can probably stop it

2948
02:22:19,319 --> 02:22:20,640
somewhere around here if you do have

2949
02:22:20,640 --> 02:22:23,460
questions feel free to ask them if there

2950
02:22:23,460 --> 02:22:24,780
is something you want me to show again

2951
02:22:24,780 --> 02:22:27,300
that is the time you have a bit of like

2952
02:22:27,300 --> 02:22:28,560
would you have some time left if you

2953
02:22:28,560 --> 02:22:30,000
want to

2954
02:22:30,000 --> 02:22:32,880
um and otherwise yeah thank you so much

2955
02:22:32,880 --> 02:22:34,620
for listening to this tutorial I really

2956
02:22:34,620 --> 02:22:37,140
hope it was helpful to you and that's it

2957
02:22:37,140 --> 02:22:38,580
next time you do receive a malware

2958
02:22:38,580 --> 02:22:41,040
return and go and it won't see as

2959
02:22:41,040 --> 02:22:43,500
daunting as maybe it was in the past

2960
02:22:43,500 --> 02:22:46,140
and uh yeah so that's it

2961
02:22:46,140 --> 02:22:48,540
um I'm uh I will be there uh at least

2962
02:22:48,540 --> 02:22:49,800
until the end of the conference now

2963
02:22:49,800 --> 02:22:51,420
she's staying in Montreal for a while so

2964
02:22:51,420 --> 02:22:53,520
if you just want to do our drinks feel

2965
02:22:53,520 --> 02:22:54,780
free

2966
02:22:54,780 --> 02:22:57,180
uh thank you so much and I suppose

2967
02:22:57,180 --> 02:22:59,660
that's it

2968
02:23:04,640 --> 02:23:07,080
right if you want to slide I'm going to

2969
02:23:07,080 --> 02:23:09,359
upload them on the Internet

2970
02:23:09,359 --> 02:23:11,220
it will be

2971
02:23:11,220 --> 02:23:13,620
the easiest way for everyone

2972
02:23:13,620 --> 02:23:16,140
save this

2973
02:23:16,140 --> 02:23:18,979
this stop or something

2974
02:23:58,740 --> 02:24:01,399
foreign

2975
02:24:30,620 --> 02:24:35,220
should be in the same folder uh as the

2976
02:24:35,220 --> 02:24:37,080
one where I put the samples initially so

2977
02:24:37,080 --> 02:24:40,760
P dot kwi.ski or

2978
02:24:40,760 --> 02:24:42,840
proxy.jet.c.fr which is a

2979
02:24:42,840 --> 02:24:45,560
so the long form

2980
02:24:45,560 --> 02:24:49,380
dominator's domain so the PDF is there

2981
02:24:49,380 --> 02:24:52,319
it's the just the the slides that I

2982
02:24:52,319 --> 02:24:53,399
showed at the beginning of the

2983
02:24:53,399 --> 02:24:55,800
presentation much much going on there

2984
02:24:55,800 --> 02:24:59,540
but at least you will have all the names

2985
02:24:59,540 --> 02:25:03,140
that you um

2986
02:25:03,180 --> 02:25:06,780
if you have any interest in the way that

2987
02:25:06,780 --> 02:25:08,760
type information can be extracted from

2988
02:25:08,760 --> 02:25:10,859
the binaries this script that I showed

2989
02:25:10,859 --> 02:25:12,840
you as well I wrote a blog post so just

2990
02:25:12,840 --> 02:25:14,460
posted this website it's called

2991
02:25:14,460 --> 02:25:15,840
extracting type information from the

2992
02:25:15,840 --> 02:25:16,979
binary

2993
02:25:16,979 --> 02:25:19,800
so you do have the code on GitHub but if

2994
02:25:19,800 --> 02:25:21,780
you want to know exactly how this

2995
02:25:21,780 --> 02:25:23,040
information is being stored in no

2996
02:25:23,040 --> 02:25:24,660
binaries you can find that there as well

2997
02:25:24,660 --> 02:25:27,319
although it's

2998
02:25:28,800 --> 02:25:31,800
technical this is a very like technical

2999
02:25:31,800 --> 02:25:33,960
details that don't really like unless

3000
02:25:33,960 --> 02:25:34,920
you really need to retrieve this

3001
02:25:34,920 --> 02:25:36,300
information by hand like if you have the

3002
02:25:36,300 --> 02:25:37,439
script that does it take care of where

3003
02:25:37,439 --> 02:25:38,700
it is right

3004
02:25:38,700 --> 02:25:40,800
anyway

3005
02:25:40,800 --> 02:25:44,280
wow slides are online again if you have

3006
02:25:44,280 --> 02:25:47,540
other questions feel free to ask it

3007
02:25:50,880 --> 02:25:52,680
sorry

3008
02:25:52,680 --> 02:25:56,300
same URL as the um

3009
02:25:57,120 --> 02:26:01,520
here you should have the URL screen

3010
02:26:05,560 --> 02:26:06,800
[Music]

3011
02:26:06,800 --> 02:26:09,800
yeah

3012
02:26:11,899 --> 02:26:14,899
yeah

3013
02:26:14,899 --> 02:26:18,080
no problem

3014
02:26:26,730 --> 02:26:29,859
[Music]

3015
02:26:32,630 --> 02:26:35,720
[Music]

3016
02:26:35,720 --> 02:26:38,840
so much

3017
02:26:42,020 --> 02:26:44,830
yes not really

3018
02:26:44,830 --> 02:26:45,600
[Music]

3019
02:26:45,600 --> 02:26:47,600
um

3020
02:26:51,140 --> 02:26:53,880
for starters I don't really see that

3021
02:26:53,880 --> 02:26:55,680
much malware that uses a tight debugging

3022
02:26:55,680 --> 02:26:58,439
but usually they try to not use those

3023
02:26:58,439 --> 02:27:00,180
technically because it likes them stand

3024
02:27:00,180 --> 02:27:03,439
out so much so they try not to do this

3025
02:27:03,439 --> 02:27:06,540
otherwise go will make this hard

3026
02:27:06,540 --> 02:27:08,640
actually because everything in go comes

3027
02:27:08,640 --> 02:27:10,200
from the library and you have to work

3028
02:27:10,200 --> 02:27:12,060
with uh like you don't you don't get to

3029
02:27:12,060 --> 02:27:14,819
execute native stuff and go so you

3030
02:27:14,819 --> 02:27:17,220
cannot really start working with the

3031
02:27:17,220 --> 02:27:18,840
windows structures you cannot go into

3032
02:27:18,840 --> 02:27:22,640
the PD and that kind of stuff this is

3033
02:27:27,500 --> 02:27:31,819
I don't think so maybe

