1
00:00:01,140 --> 00:00:20,450
[Music]

2
00:00:18,010 --> 00:00:23,660
so welcome back everyone

3
00:00:20,450 --> 00:00:25,698
for the second talk of the day just

4
00:00:23,660 --> 00:00:28,160
before I make the introductions a few

5
00:00:25,699 --> 00:00:33,350
reminders if you have questions you can

6
00:00:28,160 --> 00:00:36,260
ask on at the SL I that do and the code

7
00:00:33,350 --> 00:00:38,539
is hashtag and SEC 20 questions can be

8
00:00:36,260 --> 00:00:41,120
uploaded so make sure to read the

9
00:00:38,539 --> 00:00:43,729
questions before you ask your own also

10
00:00:41,120 --> 00:00:47,659
make some noise on Twitter the handle is

11
00:00:43,729 --> 00:00:50,420
at and SEC underscore IO we always like

12
00:00:47,659 --> 00:00:52,638
to have the attendees make a little bit

13
00:00:50,420 --> 00:00:54,229
of noise for us and also make sure to

14
00:00:52,639 --> 00:00:55,699
take note of the code of conduct it's

15
00:00:54,229 --> 00:00:59,299
something really important for us that

16
00:00:55,699 --> 00:01:01,789
we in strict we enforce quite strictly

17
00:00:59,299 --> 00:01:04,010
and that we like people to read it

18
00:01:01,789 --> 00:01:06,049
because we spend a lot of time writing

19
00:01:04,010 --> 00:01:10,150
it so without further ado let me

20
00:01:06,049 --> 00:01:14,060
introduce our next speaker his name is

21
00:01:10,150 --> 00:01:16,160
hugger winter link and algún is working

22
00:01:14,060 --> 00:01:19,040
for cisco tell us the threat research

23
00:01:16,160 --> 00:01:20,810
organization of cisco their goal is to

24
00:01:19,040 --> 00:01:23,450
find and reverse-engineer new unknown

25
00:01:20,810 --> 00:01:25,580
malware campaigns and this team

26
00:01:23,450 --> 00:01:27,980
uncovered attacks like not PDA I want to

27
00:01:25,580 --> 00:01:31,310
cry DN espionage sea turtle and many

28
00:01:27,980 --> 00:01:34,280
more he is frequently presenting an

29
00:01:31,310 --> 00:01:36,020
intern international internal and

30
00:01:34,280 --> 00:01:37,790
external conferences for example

31
00:01:36,020 --> 00:01:39,979
Microsoft digital crime consortium

32
00:01:37,790 --> 00:01:43,820
Google annual reverse reverse

33
00:01:39,980 --> 00:01:45,500
engineering meeting first is C the

34
00:01:43,820 --> 00:01:47,960
fourth international conference on cyber

35
00:01:45,500 --> 00:01:50,780
security and privacy Balcon besides

36
00:01:47,960 --> 00:01:53,690
minik sekai t germany Cisco live and

37
00:01:50,780 --> 00:01:56,530
many more his talk is going to be

38
00:01:53,690 --> 00:02:00,950
dynamic that I resolver EDA plug-in

39
00:01:56,530 --> 00:02:05,350
extending either with dynamic data so

40
00:02:00,950 --> 00:02:05,350
thank you and please proceed

41
00:02:05,530 --> 00:02:11,750
hi and welcome to the live stream of my

42
00:02:08,538 --> 00:02:13,309
presentation dynamic data resolver my

43
00:02:11,750 --> 00:02:15,950
name is Varun Dhawan and I'm a security

44
00:02:13,310 --> 00:02:17,580
researcher at Cisco Talos mainly looking

45
00:02:15,950 --> 00:02:20,579
into Melbourne research

46
00:02:17,580 --> 00:02:22,260
hunting and to development I'm based in

47
00:02:20,580 --> 00:02:24,360
Germany and if you like to follow me on

48
00:02:22,260 --> 00:02:28,649
Twitter you can find me at H on Tybee

49
00:02:24,360 --> 00:02:30,980
are 172 today I would like to introduce

50
00:02:28,650 --> 00:02:33,660
you in the new tool which I have

51
00:02:30,980 --> 00:02:36,450
developed in the last month and which

52
00:02:33,660 --> 00:02:40,230
I'm releasing next week the dynamic data

53
00:02:36,450 --> 00:02:42,450
resolver dynamic data resolver is mainly

54
00:02:40,230 --> 00:02:44,940
an Ida plugin which goal it is to

55
00:02:42,450 --> 00:02:47,880
resolve dynamic values like registers

56
00:02:44,940 --> 00:02:51,180
for example or memory values at runtime

57
00:02:47,880 --> 00:02:53,609
by using instrumentation so if you're

58
00:02:51,180 --> 00:02:55,890
interested in yes I in something like

59
00:02:53,610 --> 00:02:59,490
call yes I and you want to know the

60
00:02:55,890 --> 00:03:02,730
value of ESI you can use ddr to resolve

61
00:02:59,490 --> 00:03:06,930
it and to get you through the main

62
00:03:02,730 --> 00:03:08,730
features of ddr let me proceed with the

63
00:03:06,930 --> 00:03:11,760
one which i've already mentioned

64
00:03:08,730 --> 00:03:14,130
so finding dynamic values you cannot

65
00:03:11,760 --> 00:03:16,470
only resolve these absolute values like

66
00:03:14,130 --> 00:03:18,540
you have seen before which are stored in

67
00:03:16,470 --> 00:03:21,900
a certain operand or in a certain

68
00:03:18,540 --> 00:03:24,060
register you can also resolve pointers

69
00:03:21,900 --> 00:03:26,430
and pointer pointers which are stored in

70
00:03:24,060 --> 00:03:29,970
these operands and you can get the

71
00:03:26,430 --> 00:03:32,070
memory they are pointing to so if you're

72
00:03:29,970 --> 00:03:36,030
analyzing an unpacking routine for

73
00:03:32,070 --> 00:03:40,440
example and you see that EDI is pointing

74
00:03:36,030 --> 00:03:43,230
to a buffer which is which has the MZ at

75
00:03:40,440 --> 00:03:46,260
the beginning then you might be lucky

76
00:03:43,230 --> 00:03:48,238
that you're found at the next stage of

77
00:03:46,260 --> 00:03:50,609
the unpacking routine which constructed

78
00:03:48,239 --> 00:03:54,269
the PE header and this is just one

79
00:03:50,610 --> 00:03:56,790
example where it can help you to to

80
00:03:54,269 --> 00:03:59,489
analyze and now they're simple

81
00:03:56,790 --> 00:04:02,010
aesthetically of course there are

82
00:03:59,489 --> 00:04:05,400
hundreds of others other things like

83
00:04:02,010 --> 00:04:07,829
crypto routines and many many other

84
00:04:05,400 --> 00:04:09,690
things where it is pretty handy to get

85
00:04:07,830 --> 00:04:16,530
these dynamic values inside of your

86
00:04:09,690 --> 00:04:19,079
static analyzers as far as DDR is almost

87
00:04:16,529 --> 00:04:22,530
instrumenting every single instruction

88
00:04:19,079 --> 00:04:25,260
of the executable depending on what you

89
00:04:22,530 --> 00:04:27,390
have watch command you have picked now

90
00:04:25,260 --> 00:04:30,750
you can also easily use it for code

91
00:04:27,390 --> 00:04:31,020
coverage and DDR is not only marking the

92
00:04:30,750 --> 00:04:33,539
ins

93
00:04:31,020 --> 00:04:35,190
actions which were executed it is also

94
00:04:33,539 --> 00:04:37,889
marking it with a certain color

95
00:04:35,190 --> 00:04:40,710
depending on how often the instruction

96
00:04:37,889 --> 00:04:43,470
was executed if you see an instruction

97
00:04:40,710 --> 00:04:46,770
which which is marked light green you

98
00:04:43,470 --> 00:04:50,909
know it was executed once if you see an

99
00:04:46,770 --> 00:04:53,370
instruction with let's say dark red now

100
00:04:50,909 --> 00:04:56,370
with a much warmer color then you know

101
00:04:53,370 --> 00:04:58,199
that it was executed many more times and

102
00:04:56,370 --> 00:04:59,940
with this it helps you to find for

103
00:04:58,199 --> 00:05:02,280
example crypto routines which are often

104
00:04:59,940 --> 00:05:07,560
looping through the same basic blocks

105
00:05:02,280 --> 00:05:10,440
etcetera etcetera it is also collecting

106
00:05:07,560 --> 00:05:13,500
all the jobs calls and similar

107
00:05:10,440 --> 00:05:16,860
instructions which are touching API

108
00:05:13,500 --> 00:05:19,530
calls so anytime one of these

109
00:05:16,860 --> 00:05:22,050
instructions tries to access an API call

110
00:05:19,530 --> 00:05:24,270
it is written into this table in the

111
00:05:22,050 --> 00:05:26,099
table of course is searchable so if

112
00:05:24,270 --> 00:05:29,280
you're looking for a certain API call

113
00:05:26,099 --> 00:05:32,909
like virtual or library you can just hit

114
00:05:29,280 --> 00:05:36,388
ctrl F and search for it if you then do

115
00:05:32,909 --> 00:05:40,289
a double click on the line it brings you

116
00:05:36,389 --> 00:05:43,590
directly to the to the program counter

117
00:05:40,289 --> 00:05:46,590
inside of your disassembly to the

118
00:05:43,590 --> 00:05:49,500
location where this API call was

119
00:05:46,590 --> 00:05:53,219
accessed so you can see exactly the

120
00:05:49,500 --> 00:05:57,330
instruction which try to access this API

121
00:05:53,219 --> 00:06:00,029
call in your disassembly pretty much the

122
00:05:57,330 --> 00:06:01,889
same applies for Strings DDR tries to

123
00:06:00,029 --> 00:06:05,370
collect interesting memory location

124
00:06:01,889 --> 00:06:07,830
which are looking like strings so it is

125
00:06:05,370 --> 00:06:09,569
putting all of them in this table which

126
00:06:07,830 --> 00:06:12,180
means you can search for certain strings

127
00:06:09,569 --> 00:06:14,580
like mzv or anything else you interested

128
00:06:12,180 --> 00:06:16,229
in and then again do a double click on

129
00:06:14,580 --> 00:06:19,859
the line and it brings you to the

130
00:06:16,229 --> 00:06:23,419
instruction which accessed this this

131
00:06:19,860 --> 00:06:23,419
string at runtime

132
00:06:24,500 --> 00:06:30,539
you can also dump buffers in a smart way

133
00:06:28,319 --> 00:06:34,380
you just have to hand over three

134
00:06:30,539 --> 00:06:38,340
parameters to a DDR the buffer size the

135
00:06:34,380 --> 00:06:40,020
buffer address and the actual location

136
00:06:38,340 --> 00:06:42,570
where you want to dump the buffer or

137
00:06:40,020 --> 00:06:44,330
when you want to dump the buffer you're

138
00:06:42,570 --> 00:06:48,090
doing that by

139
00:06:44,330 --> 00:06:50,370
marking the operand which stores the

140
00:06:48,090 --> 00:06:52,619
size for example and then you are

141
00:06:50,370 --> 00:06:55,980
selecting a use mark up front to get

142
00:06:52,620 --> 00:06:58,560
buffer size so at runtime DDR will read

143
00:06:55,980 --> 00:07:00,690
the value from this operand no matter if

144
00:06:58,560 --> 00:07:03,480
it is an absolute value like you can see

145
00:07:00,690 --> 00:07:06,660
here on the slide the c8 or if it is a

146
00:07:03,480 --> 00:07:08,220
register or something like that you're

147
00:07:06,660 --> 00:07:11,610
doing the same for the buffer address

148
00:07:08,220 --> 00:07:14,100
and for the location where you want to

149
00:07:11,610 --> 00:07:16,770
dump the buffer so if you have something

150
00:07:14,100 --> 00:07:19,770
like virtual a log you know that the

151
00:07:16,770 --> 00:07:22,260
function returns a pointer to the

152
00:07:19,770 --> 00:07:25,109
allocated buffer in array X so you would

153
00:07:22,260 --> 00:07:28,070
mark array X and pick the use marked

154
00:07:25,110 --> 00:07:31,080
operand to get buffer address menu point

155
00:07:28,070 --> 00:07:32,760
then you're looking in your disassembly

156
00:07:31,080 --> 00:07:35,099
where this buffer is filled with

157
00:07:32,760 --> 00:07:37,349
something you are interested in your

158
00:07:35,100 --> 00:07:40,320
marking the line and you pick the mark

159
00:07:37,350 --> 00:07:43,410
address to dump buffer to file menu

160
00:07:40,320 --> 00:07:45,120
point and you are done the only thing

161
00:07:43,410 --> 00:07:47,910
which is left is so you have to execute

162
00:07:45,120 --> 00:07:50,310
the sample and dump the buffer and of

163
00:07:47,910 --> 00:07:52,770
course you can do that multiple times in

164
00:07:50,310 --> 00:07:56,900
the executable so you can dump multiple

165
00:07:52,770 --> 00:07:56,900
buffer buffers in one step

166
00:07:56,990 --> 00:08:07,110
of course today malware comes often with

167
00:08:01,250 --> 00:08:09,210
checks and analysing checks you have

168
00:08:07,110 --> 00:08:12,600
three different options you can either

169
00:08:09,210 --> 00:08:15,479
use the knob out functionality by

170
00:08:12,600 --> 00:08:17,190
marking these instructions which you

171
00:08:15,479 --> 00:08:19,830
want to disable and then they are

172
00:08:17,190 --> 00:08:22,140
getting knocked out at run time or if

173
00:08:19,830 --> 00:08:24,990
you want to manipulate the control flow

174
00:08:22,140 --> 00:08:29,430
you can just patch certain flex in the e

175
00:08:24,990 --> 00:08:32,849
flag register for example something like

176
00:08:29,430 --> 00:08:35,280
jump not Siro you can mark the line you

177
00:08:32,849 --> 00:08:37,680
can click to relief luck at run time and

178
00:08:35,280 --> 00:08:40,110
he would manipulate the zero flag for

179
00:08:37,679 --> 00:08:42,718
example and toggle it which means that

180
00:08:40,110 --> 00:08:45,330
at run time it would get the exact

181
00:08:42,719 --> 00:08:47,370
opposite value which means the jump

182
00:08:45,330 --> 00:08:50,130
would do it the exact opposite opposite

183
00:08:47,370 --> 00:08:52,670
thing then it would do if you would

184
00:08:50,130 --> 00:08:55,290
execute the sample in the normal way and

185
00:08:52,670 --> 00:08:58,589
last but not least you can also

186
00:08:55,290 --> 00:09:00,150
completely skip functions if you like

187
00:08:58,590 --> 00:09:02,040
if you have a function let's say

188
00:09:00,150 --> 00:09:05,040
something which detects a virtual

189
00:09:02,040 --> 00:09:07,680
machine and you want to skip it you can

190
00:09:05,040 --> 00:09:12,390
completely skip it and a return effect

191
00:09:07,680 --> 00:09:14,880
return value which means that the the

192
00:09:12,390 --> 00:09:17,460
other parts of the sample getting effect

193
00:09:14,880 --> 00:09:20,220
return value which is telling the rest

194
00:09:17,460 --> 00:09:23,130
of the sample something like okay we

195
00:09:20,220 --> 00:09:25,170
didn't found we didn't found any virtual

196
00:09:23,130 --> 00:09:27,839
machine we can proceed we don't have to

197
00:09:25,170 --> 00:09:30,930
exit we haven't found any any analyzing

198
00:09:27,839 --> 00:09:33,570
stuff so no debugging or anything like

199
00:09:30,930 --> 00:09:36,930
that we can just execute all malicious

200
00:09:33,570 --> 00:09:40,200
functions so you can skip the function

201
00:09:36,930 --> 00:09:47,180
and fake any return value which you

202
00:09:40,200 --> 00:09:51,510
would like if all of that is not enough

203
00:09:47,180 --> 00:09:54,930
of the sample you can also create an X

204
00:09:51,510 --> 00:09:59,100
64 debug script and when you're creating

205
00:09:54,930 --> 00:10:02,370
the X 64 debug script it builds a script

206
00:09:59,100 --> 00:10:05,730
which is also applying all the patches

207
00:10:02,370 --> 00:10:07,740
which you have set up before now all the

208
00:10:05,730 --> 00:10:09,990
patch or the patches which I've talked

209
00:10:07,740 --> 00:10:13,080
about on the slide before and it is

210
00:10:09,990 --> 00:10:17,430
writing them into an X 64 debug script

211
00:10:13,080 --> 00:10:20,310
and using the X 64 debug script language

212
00:10:17,430 --> 00:10:23,609
to implement these these patches and

213
00:10:20,310 --> 00:10:26,579
then it is breaking at the address which

214
00:10:23,610 --> 00:10:29,400
you have highlighted in Ida so you can

215
00:10:26,580 --> 00:10:31,830
just execute this script inside of X 64

216
00:10:29,400 --> 00:10:33,390
debug and it will automatically break at

217
00:10:31,830 --> 00:10:36,540
the point which you have marked in Ida

218
00:10:33,390 --> 00:10:41,459
and then you can proceed working with X

219
00:10:36,540 --> 00:10:44,339
64 X 64 debugger like you always do if

220
00:10:41,459 --> 00:10:46,800
you don't like the book you can also

221
00:10:44,339 --> 00:10:49,770
create an executable with an endless

222
00:10:46,800 --> 00:10:56,490
loop at the marked address so you can

223
00:10:49,770 --> 00:11:01,220
mark and the original executable gets

224
00:10:56,490 --> 00:11:01,220
patched with an endless loop so it's

225
00:11:01,310 --> 00:11:09,239
writing two bytes so when you're

226
00:11:05,160 --> 00:11:11,730
executing the executable it is looping

227
00:11:09,240 --> 00:11:14,130
forever so you have time to

228
00:11:11,730 --> 00:11:17,519
attach a debugger to it your favorite

229
00:11:14,130 --> 00:11:19,889
debugger which you would like and then

230
00:11:17,519 --> 00:11:22,680
you just have to replace these patched

231
00:11:19,889 --> 00:11:25,290
bytes the two ones you can use the ddr

232
00:11:22,680 --> 00:11:29,880
output for that like you can see here on

233
00:11:25,290 --> 00:11:32,459
the bottom of the of the slide and then

234
00:11:29,880 --> 00:11:34,230
you're just replacing the original the

235
00:11:32,459 --> 00:11:35,819
original by its back and then you can

236
00:11:34,230 --> 00:11:41,610
just proceed debugging with your

237
00:11:35,820 --> 00:11:44,940
favorite debugger ok so this is what you

238
00:11:41,610 --> 00:11:49,649
can do with a little bit about the

239
00:11:44,940 --> 00:11:54,630
architecture of DDR it is highly

240
00:11:49,649 --> 00:12:00,269
recommended to use the plugin on one

241
00:11:54,630 --> 00:12:02,939
machine and the dannemora client on a

242
00:12:00,269 --> 00:12:04,470
separate machine keep in mind that we

243
00:12:02,940 --> 00:12:07,290
are doing instrumentation and we are

244
00:12:04,470 --> 00:12:08,820
really executing the malware and you

245
00:12:07,290 --> 00:12:11,550
probably don't want to execute the

246
00:12:08,820 --> 00:12:14,639
malware on the same machine where you're

247
00:12:11,550 --> 00:12:18,779
either in your other license is running

248
00:12:14,639 --> 00:12:20,880
on so we recommend to use two virtual

249
00:12:18,779 --> 00:12:24,060
machines for example one way you have

250
00:12:20,880 --> 00:12:26,279
running and another one where you run

251
00:12:24,060 --> 00:12:30,089
the server component and the actual

252
00:12:26,279 --> 00:12:32,970
instrumentation DLL of course you can

253
00:12:30,089 --> 00:12:36,300
run it on the same box but again it is

254
00:12:32,970 --> 00:12:38,760
not recommended the way it works is that

255
00:12:36,300 --> 00:12:44,189
the idle plugin is sending the commands

256
00:12:38,760 --> 00:12:46,519
to the ddr controlling a command-line

257
00:12:44,190 --> 00:12:49,620
tool the denim or i/o client

258
00:12:46,519 --> 00:12:51,990
this is inclined which you can also run

259
00:12:49,620 --> 00:12:54,000
stand-alone right for example if you

260
00:12:51,990 --> 00:12:57,630
want to analyze the sample on a

261
00:12:54,000 --> 00:13:01,500
completely gapped system and you don't

262
00:12:57,630 --> 00:13:05,160
want to access it why I know you can

263
00:13:01,500 --> 00:13:09,000
just install the client on that box

264
00:13:05,160 --> 00:13:10,860
which is pretty easy and you can put

265
00:13:09,000 --> 00:13:13,709
nothing else on this physical box it's

266
00:13:10,860 --> 00:13:15,990
completely I kept this man of a sample

267
00:13:13,709 --> 00:13:17,099
gets instrumented it is collecting all

268
00:13:15,990 --> 00:13:19,170
the interesting data

269
00:13:17,100 --> 00:13:21,810
it's writing this data to a JSON file

270
00:13:19,170 --> 00:13:24,810
and then later on you can copy the you

271
00:13:21,810 --> 00:13:25,529
can copy the JSON file to the analyst

272
00:13:24,810 --> 00:13:27,479
machine and

273
00:13:25,529 --> 00:13:30,060
read it into Ida if you like and then

274
00:13:27,480 --> 00:13:32,519
you can use the Ida plugin pretty much

275
00:13:30,060 --> 00:13:35,939
the same way like you would have used

276
00:13:32,519 --> 00:13:37,410
the plugin from the beginning on so

277
00:13:35,939 --> 00:13:39,180
these are the two options either you're

278
00:13:37,410 --> 00:13:42,089
running it manually on the command line

279
00:13:39,180 --> 00:13:45,019
or you're doing everything from the Ida

280
00:13:42,089 --> 00:13:50,970
plugin and the whole process is fully

281
00:13:45,019 --> 00:13:53,670
automatic as you have seen on the slide

282
00:13:50,970 --> 00:13:56,550
before I'm using the dynamo Rio

283
00:13:53,670 --> 00:13:59,459
instrumentation platform for doing all

284
00:13:56,550 --> 00:14:03,660
the instrumentation and the reason for

285
00:13:59,459 --> 00:14:07,229
that is that then MRI is an extremely

286
00:14:03,660 --> 00:14:10,800
rich API for instrumentation it comes

287
00:14:07,230 --> 00:14:12,689
with a lot of different tools it comes

288
00:14:10,800 --> 00:14:15,329
with a lot of different API functions

289
00:14:12,689 --> 00:14:16,980
which are helping you a lot when you are

290
00:14:15,329 --> 00:14:19,258
trying to implement something like that

291
00:14:16,980 --> 00:14:21,930
so you don't have to think you have to

292
00:14:19,259 --> 00:14:24,540
you don't have to think about about a

293
00:14:21,930 --> 00:14:26,279
lot of underlying issues for all the

294
00:14:24,540 --> 00:14:29,939
different architectures for example and

295
00:14:26,279 --> 00:14:33,240
so on no matter if it is X 64 bit or

296
00:14:29,939 --> 00:14:36,029
it's 32 bit then MRI is able to

297
00:14:33,240 --> 00:14:39,300
instrument the binary no matter what

298
00:14:36,029 --> 00:14:41,850
kind of sample you have then MRI also

299
00:14:39,300 --> 00:14:43,769
comes with an BSD license which is

300
00:14:41,850 --> 00:14:48,300
pretty nice so you can easily use it

301
00:14:43,769 --> 00:14:51,360
inside of your tools and another really

302
00:14:48,300 --> 00:14:53,939
important point is it is a supporting

303
00:14:51,360 --> 00:14:56,939
self-modifying code and it can also

304
00:14:53,939 --> 00:14:59,399
trace files which are starting threats

305
00:14:56,939 --> 00:15:02,730
it's multi-threaded capable and it can

306
00:14:59,399 --> 00:15:06,269
even trace new processes which your

307
00:15:02,730 --> 00:15:08,339
sample is executing and the probably

308
00:15:06,269 --> 00:15:11,009
most important thing is really well

309
00:15:08,339 --> 00:15:14,939
documented I don't really want to

310
00:15:11,009 --> 00:15:17,790
compare it to to Intel pin but it is

311
00:15:14,939 --> 00:15:21,089
doing a pretty similar thing except of

312
00:15:17,790 --> 00:15:24,149
that I like it a little bit more and it

313
00:15:21,089 --> 00:15:26,459
is at least in my from my point of view

314
00:15:24,149 --> 00:15:28,559
a little bit better documented the

315
00:15:26,459 --> 00:15:31,859
installation is also super super simple

316
00:15:28,559 --> 00:15:34,829
you just have to unpack and zip file and

317
00:15:31,860 --> 00:15:37,980
that's it so it has a lot of advantages

318
00:15:34,829 --> 00:15:39,310
and as far as we already have a pin

319
00:15:37,980 --> 00:15:41,260
trace inside of

320
00:15:39,310 --> 00:15:42,790
I don't want to invent the wheel again

321
00:15:41,260 --> 00:15:47,710
so I picked an MRI Oh

322
00:15:42,790 --> 00:15:50,620
for this implementation the new mariah

323
00:15:47,710 --> 00:15:54,520
is around for at least ten years I would

324
00:15:50,620 --> 00:15:56,440
say it's pretty stable and again coming

325
00:15:54,520 --> 00:15:59,110
with a lot of features and the main

326
00:15:56,440 --> 00:16:01,630
feature on the most important feature if

327
00:15:59,110 --> 00:16:04,120
you want to analyze a sample

328
00:16:01,630 --> 00:16:06,880
symbols is probably that it is built

329
00:16:04,120 --> 00:16:09,490
from scratch with the idea of being

330
00:16:06,880 --> 00:16:11,620
totally transparent to the instrumented

331
00:16:09,490 --> 00:16:16,600
malware sample or to the instrumented

332
00:16:11,620 --> 00:16:18,760
sample with this you can still detect

333
00:16:16,600 --> 00:16:21,880
Dynamo Rio if you are actively looking

334
00:16:18,760 --> 00:16:24,310
for it but so far I haven't seen much

335
00:16:21,880 --> 00:16:26,710
malware which is actually doing that and

336
00:16:24,310 --> 00:16:29,619
hopefully even after the presentation

337
00:16:26,710 --> 00:16:35,050
that doesn't change but I'm keeping my

338
00:16:29,620 --> 00:16:39,880
fingers crossed so the way it works is

339
00:16:35,050 --> 00:16:44,469
you are executing an Rio client by

340
00:16:39,880 --> 00:16:47,680
executing for example the DR on the run

341
00:16:44,470 --> 00:16:50,110
tool and you can use your own DLL which

342
00:16:47,680 --> 00:16:51,849
is the main engine of the

343
00:16:50,110 --> 00:16:53,820
instrumentation now the DLL is

344
00:16:51,850 --> 00:16:56,830
collecting all the data it is

345
00:16:53,820 --> 00:16:59,890
controlling the instrumentation and then

346
00:16:56,830 --> 00:17:04,180
also sending sending the data back to

347
00:16:59,890 --> 00:17:05,920
the JSON files and the way you would

348
00:17:04,180 --> 00:17:08,740
execute that on the command line it's

349
00:17:05,920 --> 00:17:16,199
just by the way you can see here on the

350
00:17:08,740 --> 00:17:20,439
slide on XEL the RTL and then the ddr dl

351
00:17:16,199 --> 00:17:22,449
config parameters and then the sample

352
00:17:20,439 --> 00:17:25,630
which you want to analyze and the result

353
00:17:22,449 --> 00:17:27,579
as i mentioned before is a json file and

354
00:17:25,630 --> 00:17:31,000
then you can either import the json file

355
00:17:27,579 --> 00:17:33,610
to either or you have done this whole

356
00:17:31,000 --> 00:17:37,360
process automatically by using the idle

357
00:17:33,610 --> 00:17:39,340
plugin this is how the json file looks

358
00:17:37,360 --> 00:17:41,229
like and you can see that it is

359
00:17:39,340 --> 00:17:45,070
collecting pretty much all the registers

360
00:17:41,230 --> 00:17:48,460
and all the interesting memory points or

361
00:17:45,070 --> 00:17:51,639
point us at more or less every single

362
00:17:48,460 --> 00:17:53,679
instruction and as far as this

363
00:17:51,640 --> 00:17:56,950
is of course generating a certain

364
00:17:53,679 --> 00:18:00,160
overhead you haven't you have several

365
00:17:56,950 --> 00:18:02,230
options inside of ddr2 only do the

366
00:18:00,160 --> 00:18:06,640
instrumentation for certain basic blocks

367
00:18:02,230 --> 00:18:08,830
for example or for certain ranges for

368
00:18:06,640 --> 00:18:11,980
certain instruction ranges inside of

369
00:18:08,830 --> 00:18:15,189
your executable and with this it's still

370
00:18:11,980 --> 00:18:19,570
extremely fast even that fast that even

371
00:18:15,190 --> 00:18:22,120
time measuring until analyzing routines

372
00:18:19,570 --> 00:18:26,320
are often not detecting that anything

373
00:18:22,120 --> 00:18:28,389
was instrumented the whole workflow

374
00:18:26,320 --> 00:18:30,668
works like you can see you're on the

375
00:18:28,390 --> 00:18:33,280
slide the first thing you have to do is

376
00:18:30,669 --> 00:18:37,419
if you want to use the plug-in you are

377
00:18:33,280 --> 00:18:40,090
executing the DDR server which is what

378
00:18:37,419 --> 00:18:42,370
you've seen before then you are

379
00:18:40,090 --> 00:18:46,059
launching either on a different machine

380
00:18:42,370 --> 00:18:49,080
and you're picking and command inside of

381
00:18:46,059 --> 00:18:52,059
DDR you just do a right mouse-click and

382
00:18:49,080 --> 00:18:55,899
execute for example a light race which

383
00:18:52,059 --> 00:18:58,559
is tracing through the whole segment the

384
00:18:55,900 --> 00:19:01,660
whole code segment for example and

385
00:18:58,559 --> 00:19:02,850
collecting a certain amount of data

386
00:19:01,660 --> 00:19:06,760
there

387
00:19:02,850 --> 00:19:09,219
this command is sent on an encrypted

388
00:19:06,760 --> 00:19:13,950
channel to the server the service and

389
00:19:09,220 --> 00:19:16,720
executing the command line and the DLL

390
00:19:13,950 --> 00:19:20,020
did the Alerus generating the json file

391
00:19:16,720 --> 00:19:24,640
and then finally the json file gets sent

392
00:19:20,020 --> 00:19:28,330
to the either plug-in with by the by the

393
00:19:24,640 --> 00:19:31,150
server and then you can use this data

394
00:19:28,330 --> 00:19:34,480
inside of your static analyzers by just

395
00:19:31,150 --> 00:19:37,419
right clicking on an operand or on an

396
00:19:34,480 --> 00:19:40,419
instruction line and picking some of

397
00:19:37,419 --> 00:19:42,850
these menus so get value for source

398
00:19:40,419 --> 00:19:44,799
operand for example or get the value of

399
00:19:42,850 --> 00:19:48,428
a certain register whatever you are

400
00:19:44,799 --> 00:19:50,350
interested in by the way you can see

401
00:19:48,429 --> 00:19:54,720
here on the right side of the screen

402
00:19:50,350 --> 00:19:57,490
shot something like X ax equal no data

403
00:19:54,720 --> 00:20:00,100
that doesn't mean that we haven't found

404
00:19:57,490 --> 00:20:01,900
any data that just means that the

405
00:20:00,100 --> 00:20:04,899
absolute value which was taught in

406
00:20:01,900 --> 00:20:08,470
ax is the two seven B's

407
00:20:04,900 --> 00:20:10,690
and this is just an absolute value which

408
00:20:08,470 --> 00:20:13,570
is not pointing to anything so you know

409
00:20:10,690 --> 00:20:16,659
that there was not a point or point a

410
00:20:13,570 --> 00:20:18,789
point of store inside of this register

411
00:20:16,659 --> 00:20:25,419
it is just an absolute value which was

412
00:20:18,789 --> 00:20:26,470
used in the instruction before we are

413
00:20:25,419 --> 00:20:29,350
moving to the demo

414
00:20:26,470 --> 00:20:32,890
let me quickly warn you about a pretty

415
00:20:29,350 --> 00:20:36,789
nasty behavior of Windows if it comes to

416
00:20:32,890 --> 00:20:39,640
executing executing Pyne scripts inside

417
00:20:36,789 --> 00:20:42,070
of a command window unfortunately if

418
00:20:39,640 --> 00:20:44,740
you're marking any text inside of the

419
00:20:42,070 --> 00:20:48,730
window inside of this command window

420
00:20:44,740 --> 00:20:51,309
windows will freeze these despite an

421
00:20:48,730 --> 00:20:55,929
application so it's not getting executed

422
00:20:51,309 --> 00:20:58,600
until you are hitting escape which means

423
00:20:55,929 --> 00:21:01,990
that your DDR server is pretty much

424
00:20:58,600 --> 00:21:06,039
frozen and of course it will not accept

425
00:21:01,990 --> 00:21:08,740
any commands from the plug-in anymore so

426
00:21:06,039 --> 00:21:10,870
if you are receiving an time-out arrow

427
00:21:08,740 --> 00:21:13,450
or something like that on the IDA

428
00:21:10,870 --> 00:21:16,239
plug-in side it is very likely that you

429
00:21:13,450 --> 00:21:19,000
acidentally marked or highlighted

430
00:21:16,240 --> 00:21:22,990
something here in the DDR server output

431
00:21:19,000 --> 00:21:25,120
and that has frozen the server so you

432
00:21:22,990 --> 00:21:29,409
can either hit escape a couple of times

433
00:21:25,120 --> 00:21:32,649
and the server gets executed again or if

434
00:21:29,409 --> 00:21:36,909
that doesn't help you just ctrl Z and

435
00:21:32,649 --> 00:21:39,850
restart the server both works and then

436
00:21:36,909 --> 00:21:41,559
you can proceed with the commands the

437
00:21:39,850 --> 00:21:44,590
right mouse click in Ida in the plug-in

438
00:21:41,559 --> 00:21:46,090
and everything works like before but

439
00:21:44,590 --> 00:21:48,220
just be warned about that one

440
00:21:46,090 --> 00:21:50,889
try not to mark anything or if you're

441
00:21:48,220 --> 00:21:52,840
marking text in the output window make

442
00:21:50,890 --> 00:21:55,480
sure that you hit escape a couple of

443
00:21:52,840 --> 00:21:57,970
times afterwards so a quick final

444
00:21:55,480 --> 00:21:59,679
disclaimer of course DVR is not

445
00:21:57,970 --> 00:22:01,690
replacing your brain of course you can

446
00:21:59,679 --> 00:22:04,840
do stupid things with it it is quite

447
00:22:01,690 --> 00:22:08,110
powerful so keep in mind that something

448
00:22:04,840 --> 00:22:11,799
like patching is might be dangerous and

449
00:22:08,110 --> 00:22:14,080
could crash the sample I've also seen

450
00:22:11,799 --> 00:22:15,960
malware which is for example killing the

451
00:22:14,080 --> 00:22:18,639
whole process chain until explorer.exe

452
00:22:15,960 --> 00:22:20,890
so that would also kill

453
00:22:18,640 --> 00:22:23,350
the PI server and the communication

454
00:22:20,890 --> 00:22:25,929
would obviously not work anymore but

455
00:22:23,350 --> 00:22:28,629
nevertheless like for any tool it

456
00:22:25,929 --> 00:22:31,510
doesn't fit it all but at least it will

457
00:22:28,630 --> 00:22:36,640
fit most of the samples and hopefully it

458
00:22:31,510 --> 00:22:39,370
will help you with your analyzing okay

459
00:22:36,640 --> 00:22:41,620
enough about that let's move to the demo

460
00:22:39,370 --> 00:22:46,809
and let me show you how the thing looks

461
00:22:41,620 --> 00:22:49,600
in real life actually before we are

462
00:22:46,809 --> 00:22:51,970
switching to either let me quickly show

463
00:22:49,600 --> 00:22:54,309
you the important parts of the source

464
00:22:51,970 --> 00:22:58,419
code of the sample which we are going to

465
00:22:54,309 --> 00:23:02,410
analyze the first thing is that the

466
00:22:58,419 --> 00:23:06,760
sample is comparing its processed name

467
00:23:02,410 --> 00:23:09,340
with evil Melba XE which means if it's

468
00:23:06,760 --> 00:23:12,010
processed name is not evil malvit XE it

469
00:23:09,340 --> 00:23:15,520
will copy an instance of itself to the

470
00:23:12,010 --> 00:23:19,540
temp folder and then it is executing

471
00:23:15,520 --> 00:23:23,260
this instance so the first instance is

472
00:23:19,540 --> 00:23:26,110
just leaving and the second one is

473
00:23:23,260 --> 00:23:28,600
recognizing that it is running and the

474
00:23:26,110 --> 00:23:32,168
process named evil Melford XE so the

475
00:23:28,600 --> 00:23:35,080
comparison is not true and it will just

476
00:23:32,169 --> 00:23:37,510
print out this message new instance

477
00:23:35,080 --> 00:23:41,168
running from temp folder and then

478
00:23:37,510 --> 00:23:42,820
proceed with the rest of the code again

479
00:23:41,169 --> 00:23:46,179
I don't want to go through all of the

480
00:23:42,820 --> 00:23:48,070
source code just the important parts for

481
00:23:46,179 --> 00:23:51,220
the demo and one thing you should

482
00:23:48,070 --> 00:23:54,700
recognize is that a can never be bigger

483
00:23:51,220 --> 00:23:57,940
than five we are doing a mod 5 here so

484
00:23:54,700 --> 00:24:00,460
there's no chance that a can never be

485
00:23:57,940 --> 00:24:04,120
bigger than 5 which means that the

486
00:24:00,460 --> 00:24:08,020
following comparison will always be not

487
00:24:04,120 --> 00:24:11,678
true and it will always print out the

488
00:24:08,020 --> 00:24:14,559
message a is not greater than 5 at least

489
00:24:11,679 --> 00:24:17,200
in theory because we will see later on

490
00:24:14,559 --> 00:24:21,820
during the demo that we can patch this

491
00:24:17,200 --> 00:24:23,620
behavior inside of DDR the last thing

492
00:24:21,820 --> 00:24:27,010
which you should keep in mind for the

493
00:24:23,620 --> 00:24:29,949
demo is that after this comparison we

494
00:24:27,010 --> 00:24:32,029
have an dialog box which is asking for a

495
00:24:29,950 --> 00:24:33,799
value this value is getting

496
00:24:32,029 --> 00:24:35,840
assigned to a but that's a really

497
00:24:33,799 --> 00:24:37,849
important the important part is that you

498
00:24:35,840 --> 00:24:41,090
remember that there's a dialog box which

499
00:24:37,849 --> 00:24:44,090
would stop the execution of the sample

500
00:24:41,090 --> 00:24:48,559
and of course we don't want that we want

501
00:24:44,090 --> 00:24:52,249
to get it executed in one step so we

502
00:24:48,559 --> 00:24:54,759
will also knock out later on this this

503
00:24:52,249 --> 00:24:58,519
dialog box and skip it

504
00:24:54,759 --> 00:25:00,969
okey-dokey with this let me switch over

505
00:24:58,519 --> 00:25:04,009
to Ida

506
00:25:00,969 --> 00:25:06,460
okay so we've loaded the sample into Ida

507
00:25:04,009 --> 00:25:09,080
and we moved to the location where it is

508
00:25:06,460 --> 00:25:11,719
comparing the process name with even

509
00:25:09,080 --> 00:25:13,609
Melba dot XE so usually the assembler

510
00:25:11,719 --> 00:25:16,309
would be executed with a different

511
00:25:13,609 --> 00:25:18,710
process name and it would go this path

512
00:25:16,309 --> 00:25:20,239
where it is just copying itself and

513
00:25:18,710 --> 00:25:22,219
launching a second instance of itself

514
00:25:20,239 --> 00:25:24,139
but of course we are not so much

515
00:25:22,219 --> 00:25:27,710
interested in this path we are more

516
00:25:24,139 --> 00:25:30,139
interested in the other path and the

517
00:25:27,710 --> 00:25:31,940
rest of the sample code so what we want

518
00:25:30,139 --> 00:25:35,689
to do is we want to patch this

519
00:25:31,940 --> 00:25:39,109
comparison and we can do that by

520
00:25:35,690 --> 00:25:41,839
toggling the zero flag for example it's

521
00:25:39,109 --> 00:25:44,359
a jump nonzero so in if we are inverting

522
00:25:41,839 --> 00:25:47,629
the zero flag it is doing the exact

523
00:25:44,359 --> 00:25:50,589
opposite of what it is supposed to do so

524
00:25:47,629 --> 00:25:53,658
we go and go to the DDR patch menu

525
00:25:50,589 --> 00:25:56,928
totally flag we are picking the zero

526
00:25:53,659 --> 00:26:00,229
flag as the F flag click OK and that's

527
00:25:56,929 --> 00:26:02,960
it the next thing which we want to do is

528
00:26:00,229 --> 00:26:05,330
we want to get rid of the dialog box as

529
00:26:02,960 --> 00:26:07,700
I mentioned before so we are moving over

530
00:26:05,330 --> 00:26:11,629
to that part of the code we are marking

531
00:26:07,700 --> 00:26:15,379
the code and we can just knock out all

532
00:26:11,629 --> 00:26:17,928
these instructions at runtime again we

533
00:26:15,379 --> 00:26:19,728
are moving to the touch menu and we are

534
00:26:17,929 --> 00:26:24,940
picking the na part marked instruction

535
00:26:19,729 --> 00:26:28,429
at runtime option so now we can execute

536
00:26:24,940 --> 00:26:31,099
another DDR command so for example we

537
00:26:28,429 --> 00:26:35,389
can run a trace if we want to get a code

538
00:26:31,099 --> 00:26:39,289
coverage for example we do that we have

539
00:26:35,389 --> 00:26:41,839
to wait a little bit and it has sent the

540
00:26:39,289 --> 00:26:44,629
command to the DDR server the video

541
00:26:41,839 --> 00:26:45,770
server has executed it and sent back the

542
00:26:44,629 --> 00:26:47,600
analyzers

543
00:26:45,770 --> 00:26:50,629
form of the Jason format so you can see

544
00:26:47,600 --> 00:26:54,760
here the light race is done if we are

545
00:26:50,630 --> 00:27:00,050
now moving back to the protest check and

546
00:26:54,760 --> 00:27:02,690
if we highlight all the instructions

547
00:27:00,050 --> 00:27:05,690
which were actually traced now we get a

548
00:27:02,690 --> 00:27:10,610
nice code coverage and we can also see

549
00:27:05,690 --> 00:27:13,190
that the other path was executed even if

550
00:27:10,610 --> 00:27:17,000
the protest name was not evil malware

551
00:27:13,190 --> 00:27:19,850
not EXCI it went this path and it has

552
00:27:17,000 --> 00:27:23,900
executed all these all these

553
00:27:19,850 --> 00:27:30,949
instructions here and it has also

554
00:27:23,900 --> 00:27:32,780
skipped that part at run time before I'm

555
00:27:30,950 --> 00:27:35,060
moving to the next feature I would like

556
00:27:32,780 --> 00:27:37,790
to come back to the warning which I have

557
00:27:35,060 --> 00:27:39,950
mentioned during the presentation that

558
00:27:37,790 --> 00:27:43,730
you should be very careful with marking

559
00:27:39,950 --> 00:27:46,520
the output text of the DDR server so for

560
00:27:43,730 --> 00:27:51,140
example if I'm moving over to the DDR

561
00:27:46,520 --> 00:27:53,570
server and if I'm marking something yeah

562
00:27:51,140 --> 00:27:55,880
it can even be just one character as

563
00:27:53,570 --> 00:27:59,570
long as something is marked in this

564
00:27:55,880 --> 00:28:02,750
window the process is frozen and if we

565
00:27:59,570 --> 00:28:06,590
now try to execute and trace like we did

566
00:28:02,750 --> 00:28:10,520
before for example then it will run into

567
00:28:06,590 --> 00:28:14,620
a timeout it takes a little bit and pop

568
00:28:10,520 --> 00:28:17,570
you see fail to run trace four segments

569
00:28:14,620 --> 00:28:19,580
if you are running into this and if you

570
00:28:17,570 --> 00:28:21,020
want to test if the communication is

571
00:28:19,580 --> 00:28:23,600
working between the server and the

572
00:28:21,020 --> 00:28:25,940
either side you can always test that

573
00:28:23,600 --> 00:28:29,209
with your browser now if you're going to

574
00:28:25,940 --> 00:28:33,560
the root directory of the server you can

575
00:28:29,210 --> 00:28:37,310
just do that in your browser and you see

576
00:28:33,560 --> 00:28:40,490
that it is timing out so if we are

577
00:28:37,310 --> 00:28:43,550
moving again over to the DDR server I

578
00:28:40,490 --> 00:28:46,250
can hit escape a couple of times and you

579
00:28:43,550 --> 00:28:49,310
see all the commands are coming back in

580
00:28:46,250 --> 00:28:53,390
and the application is now unfrozen

581
00:28:49,310 --> 00:28:56,750
again if we are doing the test again you

582
00:28:53,390 --> 00:28:59,690
see that this counter is now counting up

583
00:28:56,750 --> 00:29:03,260
and the communication is working again

584
00:28:59,690 --> 00:29:06,460
so I could no move back to Ida and run

585
00:29:03,260 --> 00:29:10,129
the trace again or whatever I want to do

586
00:29:06,460 --> 00:29:16,250
and all the trace will be executed as

587
00:29:10,130 --> 00:29:18,710
you have seen before done okay so after

588
00:29:16,250 --> 00:29:20,420
we have analyzed the sample and we found

589
00:29:18,710 --> 00:29:22,580
an interesting buffer which we want to

590
00:29:20,420 --> 00:29:23,810
dump to disk we can do that the way

591
00:29:22,580 --> 00:29:25,970
which I've mentioned during the

592
00:29:23,810 --> 00:29:28,250
presentation so we have for example

593
00:29:25,970 --> 00:29:31,250
virtual a lock and we know that this

594
00:29:28,250 --> 00:29:35,450
parameter is the buffer size so we can

595
00:29:31,250 --> 00:29:39,170
just go to the ddr mini dump and we

596
00:29:35,450 --> 00:29:41,810
choose that one as the buffer size then

597
00:29:39,170 --> 00:29:44,690
we are marking our ax because we know

598
00:29:41,810 --> 00:29:47,360
that this is including the pointer which

599
00:29:44,690 --> 00:29:51,830
is pointing to the buffer and we are

600
00:29:47,360 --> 00:29:56,389
heading that over to DDR get buffer

601
00:29:51,830 --> 00:29:59,270
address so now we need to find the

602
00:29:56,390 --> 00:30:00,790
location in the code where this buffer

603
00:29:59,270 --> 00:30:03,740
is filled with something interesting

604
00:30:00,790 --> 00:30:06,590
which is in this case here so we are

605
00:30:03,740 --> 00:30:09,850
just marking the line and we are handing

606
00:30:06,590 --> 00:30:13,669
over the third parameter to the dump and

607
00:30:09,850 --> 00:30:15,500
we are done now we can now see that DVR

608
00:30:13,670 --> 00:30:18,380
has all the parameters which are

609
00:30:15,500 --> 00:30:22,220
necessary to dump this buffer so now we

610
00:30:18,380 --> 00:30:25,970
can finally execute the sampler and what

611
00:30:22,220 --> 00:30:29,600
the buffer to disk so again the sample

612
00:30:25,970 --> 00:30:32,750
gets executed and the buffer gets dumped

613
00:30:29,600 --> 00:30:38,320
to disk so we can write it somewhere

614
00:30:32,750 --> 00:30:42,710
less up for example and you can see now

615
00:30:38,320 --> 00:30:45,080
it is the buffer which we have or it's a

616
00:30:42,710 --> 00:30:48,770
string which we have copied into the

617
00:30:45,080 --> 00:30:50,270
buffer so the last thing which I would

618
00:30:48,770 --> 00:30:54,290
like to show you is how you can generate

619
00:30:50,270 --> 00:30:56,300
x64 and debug scripts and as I mentioned

620
00:30:54,290 --> 00:30:58,210
before these scripts are including all

621
00:30:56,300 --> 00:31:00,260
the patches which you have done before

622
00:30:58,210 --> 00:31:03,230
to demonstrate that

623
00:31:00,260 --> 00:31:06,580
let me manipulate this comparison where

624
00:31:03,230 --> 00:31:09,710
we are checking if a is bigger than 5

625
00:31:06,580 --> 00:31:13,189
again we are going to the Flex menu and

626
00:31:09,710 --> 00:31:17,990
as far as it is this time and

627
00:31:13,190 --> 00:31:23,750
jump less equal we have to toggle the SF

628
00:31:17,990 --> 00:31:26,960
flag okay so now we are done and now we

629
00:31:23,750 --> 00:31:31,340
can generate the script and the x64

630
00:31:26,960 --> 00:31:34,669
debug script now it has generated this

631
00:31:31,340 --> 00:31:35,600
script and sent it over to the member

632
00:31:34,669 --> 00:31:39,230
site hand

633
00:31:35,600 --> 00:31:46,090
so whether server is running we can now

634
00:31:39,230 --> 00:31:50,690
load the x64 debugger go to script and

635
00:31:46,090 --> 00:31:53,899
load this file so now you can see that

636
00:31:50,690 --> 00:31:57,140
it is doing all these patch tricks which

637
00:31:53,900 --> 00:32:04,400
you have seen before and we can execute

638
00:31:57,140 --> 00:32:08,510
this script and now we can move to the

639
00:32:04,400 --> 00:32:14,470
different break points now so here we

640
00:32:08,510 --> 00:32:20,679
have break right before this compassion

641
00:32:14,470 --> 00:32:20,679
and you can see if I'm stepping over it

642
00:32:21,280 --> 00:32:28,580
that it has manipulated the SF flag and

643
00:32:26,030 --> 00:32:31,639
the comparison of things that is greater

644
00:32:28,580 --> 00:32:36,139
than 5 even if that is theoretically

645
00:32:31,640 --> 00:32:38,350
impossible ok that's it regarding the

646
00:32:36,140 --> 00:32:42,740
demo let me switch back to the

647
00:32:38,350 --> 00:32:44,449
PowerPoint presentation so I hope you

648
00:32:42,740 --> 00:32:46,820
liked the demo and if you want to see

649
00:32:44,450 --> 00:32:49,039
more features you can watch the YouTube

650
00:32:46,820 --> 00:32:52,220
video which I have here on the bottom of

651
00:32:49,039 --> 00:32:55,158
the slide as I mentioned before the plan

652
00:32:52,220 --> 00:32:57,049
is to release the tool next week and if

653
00:32:55,159 --> 00:33:00,740
you don't want to miss the release you

654
00:32:57,049 --> 00:33:04,370
can follow me on Twitter with this we

655
00:33:00,740 --> 00:33:11,090
have reached the Q&A section and I'm

656
00:33:04,370 --> 00:33:12,350
giving back to the north seg Forks well

657
00:33:11,090 --> 00:33:14,449
thank you very much

658
00:33:12,350 --> 00:33:17,809
Helga that was a very technical that

659
00:33:14,450 --> 00:33:19,820
in-depth talk maybe a bit too technical

660
00:33:17,809 --> 00:33:24,470
for me because I am not so knowledgeable

661
00:33:19,820 --> 00:33:26,270
in reverse engineering so we'll let a

662
00:33:24,470 --> 00:33:26,990
few seconds few minutes for people to

663
00:33:26,270 --> 00:33:29,120
ask questions

664
00:33:26,990 --> 00:33:35,179
the link has already been posted so it's

665
00:33:29,120 --> 00:33:37,309
a app that s Li that Bo just while

666
00:33:35,179 --> 00:33:39,470
waiting just a quick message if for

667
00:33:37,309 --> 00:33:41,720
whatever reason and not just for this

668
00:33:39,470 --> 00:33:44,690
talk about any talk you feel overwhelmed

669
00:33:41,720 --> 00:33:48,710
because it's it's too hard for you take

670
00:33:44,690 --> 00:33:50,870
it as an opportunity to rise curiosity

671
00:33:48,710 --> 00:33:53,300
and learn about these things because I

672
00:33:50,870 --> 00:33:55,520
know for a fact that you can quickly get

673
00:33:53,300 --> 00:33:57,800
overwhelmed and have a feeling that

674
00:33:55,520 --> 00:34:00,889
you're not wise enough for these things

675
00:33:57,800 --> 00:34:03,950
but as you dig and you try these things

676
00:34:00,890 --> 00:34:07,370
there is not a lot of feeling as great

677
00:34:03,950 --> 00:34:09,110
as popping your first buffer overflow

678
00:34:07,370 --> 00:34:12,409
and having a calculator at your on your

679
00:34:09,110 --> 00:34:15,619
screen so without further ado let's

680
00:34:12,409 --> 00:34:18,830
start with the first question so the

681
00:34:15,619 --> 00:34:21,560
first question from anonymous user is

682
00:34:18,830 --> 00:34:25,159
there any plan to make it work with

683
00:34:21,560 --> 00:34:27,679
guide read - not in the moment because

684
00:34:25,159 --> 00:34:30,710
my time is limited I wish I could do

685
00:34:27,679 --> 00:34:36,679
that but it's not too realistic in the

686
00:34:30,710 --> 00:34:39,260
moment to be honest okay thank you does

687
00:34:36,679 --> 00:34:41,840
it's also from an any news user does it

688
00:34:39,260 --> 00:34:44,859
also support processes which are

689
00:34:41,840 --> 00:34:48,590
launching other processors and thread

690
00:34:44,859 --> 00:34:52,040
yes or no so the command line tool is

691
00:34:48,590 --> 00:34:55,580
supporting that and the problem with

692
00:34:52,040 --> 00:34:58,220
that is that you can that you cannot

693
00:34:55,580 --> 00:35:01,279
lock all these files at the same time

694
00:34:58,220 --> 00:35:05,118
well you can but the Ida plugin can't

695
00:35:01,280 --> 00:35:07,070
consume them so now what you can do is

696
00:35:05,119 --> 00:35:10,460
you can run the command line tool and it

697
00:35:07,070 --> 00:35:12,770
will generate certain JSON files process

698
00:35:10,460 --> 00:35:15,890
and it will also track all the different

699
00:35:12,770 --> 00:35:18,740
threats of the processes so then you can

700
00:35:15,890 --> 00:35:24,049
later unload these JSON files manually

701
00:35:18,740 --> 00:35:26,569
into IRA okay thank you so I guess this

702
00:35:24,050 --> 00:35:28,880
brings to the next question what happens

703
00:35:26,570 --> 00:35:32,270
if I apply two different batch functions

704
00:35:28,880 --> 00:35:33,619
to the same instruction that is

705
00:35:32,270 --> 00:35:36,740
something you should usually not do

706
00:35:33,619 --> 00:35:40,730
because only one will win it will

707
00:35:36,740 --> 00:35:45,500
probably not crash the crash

708
00:35:40,730 --> 00:35:49,700
the ddr process but it has results which

709
00:35:45,500 --> 00:35:53,030
can't be foreseen so I would not

710
00:35:49,700 --> 00:35:56,779
recommend doing that oh well I guess

711
00:35:53,030 --> 00:35:59,390
it's good to know thank you so the next

712
00:35:56,780 --> 00:36:01,910
question from humble peon aren't you

713
00:35:59,390 --> 00:36:11,839
afraid that malware detector will now

714
00:36:01,910 --> 00:36:14,149
try to detect it if you want to release

715
00:36:11,839 --> 00:36:16,190
something in public or not of course if

716
00:36:14,150 --> 00:36:17,990
I would have kept it private

717
00:36:16,190 --> 00:36:20,480
it would be more comfortable for myself

718
00:36:17,990 --> 00:36:23,359
but I put a lot of time and effort into

719
00:36:20,480 --> 00:36:24,950
it and a lot of spare time so I thought

720
00:36:23,359 --> 00:36:29,240
it would be nice to share it with people

721
00:36:24,950 --> 00:36:31,669
even taking this risk yeah no that's

722
00:36:29,240 --> 00:36:34,328
very good thank you thanks to you so the

723
00:36:31,670 --> 00:36:37,210
I guess the next question is actually

724
00:36:34,329 --> 00:36:39,380
follows why don't you release it today

725
00:36:37,210 --> 00:36:42,050
why because there are some

726
00:36:39,380 --> 00:36:45,619
organizational issues which I still have

727
00:36:42,050 --> 00:36:49,220
to overcome like how can I release it on

728
00:36:45,619 --> 00:36:51,410
the Talos github and so on so it's more

729
00:36:49,220 --> 00:36:55,399
organizational stuff than technical

730
00:36:51,410 --> 00:36:58,368
stuff so I guess like would you really

731
00:36:55,400 --> 00:37:00,200
sit with the like open source free

732
00:36:58,369 --> 00:37:02,240
license yes yes absolutely I will

733
00:37:00,200 --> 00:37:04,419
release it as an open source tool and

734
00:37:02,240 --> 00:37:08,868
it's very likely that I will release it

735
00:37:04,420 --> 00:37:13,180
mid of next week ok so it's very it's

736
00:37:08,869 --> 00:37:15,410
not today but exactly shortly thank you

737
00:37:13,180 --> 00:37:18,529
so the next question from an anonymous

738
00:37:15,410 --> 00:37:22,069
user can I use dynamic Rio also for

739
00:37:18,530 --> 00:37:24,410
fuzzing yes absolutely absolutely for

740
00:37:22,069 --> 00:37:33,079
absolutely every instrumentation tasks

741
00:37:24,410 --> 00:37:33,700
it's a really recommended to use so I'm

742
00:37:33,079 --> 00:37:36,050
sorry

743
00:37:33,700 --> 00:37:38,720
they're telling me that my the time is

744
00:37:36,050 --> 00:37:41,270
over there is one other question I'm

745
00:37:38,720 --> 00:37:43,430
gonna ask it very quickly so is there a

746
00:37:41,270 --> 00:37:44,750
way to make it work with pact malware or

747
00:37:43,430 --> 00:37:47,779
would you need to unpack the malware

748
00:37:44,750 --> 00:37:51,940
first absolutely it's actually the main

749
00:37:47,780 --> 00:37:53,840
goal to use it for unpacking malware so

750
00:37:51,940 --> 00:37:56,600
what I'm using it you

751
00:37:53,840 --> 00:38:00,950
for is to correct the first stage of the

752
00:37:56,600 --> 00:38:02,960
unpacker of course if if you have code

753
00:38:00,950 --> 00:38:04,970
which is unpacking something and copying

754
00:38:02,960 --> 00:38:08,270
something to above buffer which you

755
00:38:04,970 --> 00:38:11,209
can't see in your disassembly then you

756
00:38:08,270 --> 00:38:13,640
probably can't use it for the second or

757
00:38:11,210 --> 00:38:15,590
third stage but that heavily depends on

758
00:38:13,640 --> 00:38:17,920
the case and how the malware has

759
00:38:15,590 --> 00:38:20,660
implemented the second and third stage

760
00:38:17,920 --> 00:38:23,090
so you can absolutely use it for

761
00:38:20,660 --> 00:38:25,490
everything and again this is definitely

762
00:38:23,090 --> 00:38:28,790
the goal of the tool to use it for

763
00:38:25,490 --> 00:38:31,490
unpacking malware perfect it makes it

764
00:38:28,790 --> 00:38:35,630
very powerful well thank you that all

765
00:38:31,490 --> 00:38:37,490
for the Q&A again a warm thank you for

766
00:38:35,630 --> 00:38:39,470
your participation in the online event

767
00:38:37,490 --> 00:38:40,640
and I wish you a great day and I hope

768
00:38:39,470 --> 00:38:41,149
that you can enjoy the rest of the

769
00:38:40,640 --> 00:38:43,310
conference

770
00:38:41,150 --> 00:38:46,430
thank you you too bye-bye thanks

771
00:38:43,310 --> 00:38:50,290
everyone we see you in in a few minutes

772
00:38:46,430 --> 00:38:50,290
or the next time bye BX

773
00:38:50,590 --> 00:39:08,949
[Music]

