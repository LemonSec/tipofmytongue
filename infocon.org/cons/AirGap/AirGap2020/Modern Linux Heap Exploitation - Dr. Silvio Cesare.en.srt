1
00:00:00,030 --> 00:00:05,970
thank you very much okay running this

2
00:00:03,659 --> 00:00:09,059
conference hopefully everyone's having a

3
00:00:05,970 --> 00:00:11,969
good time in this is crazy new virtual

4
00:00:09,059 --> 00:00:15,320
world that we live it this talk is about

5
00:00:11,969 --> 00:00:19,859
modern Linux deep exploitation and

6
00:00:15,320 --> 00:00:22,439
basically the idea is to give you this

7
00:00:19,859 --> 00:00:27,119
strategy on how to exploit a modern

8
00:00:22,439 --> 00:00:27,599
Linux system using the native people

9
00:00:27,119 --> 00:00:32,159
occator

10
00:00:27,599 --> 00:00:34,260
which is in GM CPT Mel look - and I'll

11
00:00:32,159 --> 00:00:36,059
divide it into three parts this talk

12
00:00:34,260 --> 00:00:38,070
I'll talk about debilitating internal

13
00:00:36,059 --> 00:00:40,828
specifically looking at PT mail up to

14
00:00:38,070 --> 00:00:42,660
I'll look at Linux exploitation in

15
00:00:40,829 --> 00:00:44,520
general or having gain code execution

16
00:00:42,660 --> 00:00:48,140
you know sort of a modern Linux system

17
00:00:44,520 --> 00:00:50,460
and a lot Linux system of course in

18
00:00:48,140 --> 00:00:53,520
default userland does not include

19
00:00:50,460 --> 00:00:55,949
control flow integrity so that's okay we

20
00:00:53,520 --> 00:00:57,570
can hijack control flow then I'll talk

21
00:00:55,949 --> 00:01:00,120
about how to combine that with our

22
00:00:57,570 --> 00:01:06,150
heap-allocated internals and a gain code

23
00:01:00,120 --> 00:01:07,798
execution using PT ml up to so we'll

24
00:01:06,150 --> 00:01:11,159
start off with the allocator internals

25
00:01:07,799 --> 00:01:13,200
and you know very sort of introductory

26
00:01:11,159 --> 00:01:14,760
slide what is virtual memory virtual

27
00:01:13,200 --> 00:01:17,400
memory is the thing that your user

28
00:01:14,760 --> 00:01:19,770
learning process sees and virtual memory

29
00:01:17,400 --> 00:01:22,560
is a linear or contiguous address space

30
00:01:19,770 --> 00:01:24,140
it's a very uniform address space which

31
00:01:22,560 --> 00:01:26,400
is much better than the underlying

32
00:01:24,140 --> 00:01:30,000
physical memory which is non contiguous

33
00:01:26,400 --> 00:01:32,130
and quite problematic but that's what

34
00:01:30,000 --> 00:01:34,049
the kernel works with but in userland

35
00:01:32,130 --> 00:01:36,449
from a process point of view all

36
00:01:34,049 --> 00:01:39,540
processes see memory effectively the

37
00:01:36,450 --> 00:01:42,750
same way as a very contiguous uniform

38
00:01:39,540 --> 00:01:45,149
look at memory in a modern sort of

39
00:01:42,750 --> 00:01:47,070
operating system in a file format we

40
00:01:45,149 --> 00:01:49,110
typically have executable code in our

41
00:01:47,070 --> 00:01:50,908
process image or a memory image

42
00:01:49,110 --> 00:01:54,030
sometimes this is called a text segment

43
00:01:50,909 --> 00:01:56,399
or text we typically have a heap for

44
00:01:54,030 --> 00:02:00,630
dynamic memory management as well and we

45
00:01:56,399 --> 00:02:02,700
have a stack for environment environment

46
00:02:00,630 --> 00:02:04,589
that's available things like environment

47
00:02:02,700 --> 00:02:06,270
variables go there in program arguments

48
00:02:04,590 --> 00:02:08,940
and so forth we have local variables

49
00:02:06,270 --> 00:02:11,400
within procedures and procedure metadata

50
00:02:08,940 --> 00:02:13,530
such as return addresses from procedures

51
00:02:11,400 --> 00:02:15,060
as well within that address

52
00:02:13,530 --> 00:02:16,770
space as well and on a multi-threaded

53
00:02:15,060 --> 00:02:20,520
system you might have multiple stacks as

54
00:02:16,770 --> 00:02:21,690
well you also have shared libraries and

55
00:02:20,520 --> 00:02:24,000
all of these shared libraries

56
00:02:21,690 --> 00:02:26,490
effectively have the same thing as well

57
00:02:24,000 --> 00:02:31,050
they have the executable code they might

58
00:02:26,490 --> 00:02:32,400
have their own cone and data as well and

59
00:02:31,050 --> 00:02:34,470
but that's all plug it into the address

60
00:02:32,400 --> 00:02:36,540
space and due to the magical sort of the

61
00:02:34,470 --> 00:02:38,670
underlying operating system kernel it

62
00:02:36,540 --> 00:02:41,370
has its own view or its own you get

63
00:02:38,670 --> 00:02:42,929
it's only copied physically when that

64
00:02:41,370 --> 00:02:45,750
memory is modified or witness who so

65
00:02:42,930 --> 00:02:47,880
it's called copy-on-write so this is

66
00:02:45,750 --> 00:02:50,220
sort of what you're you know a badly

67
00:02:47,880 --> 00:02:52,470
written program would look flat we've

68
00:02:50,220 --> 00:02:54,540
allocated 20 bytes using the heap

69
00:02:52,470 --> 00:02:58,170
allocator which in winix you would see

70
00:02:54,540 --> 00:03:00,750
is PT mel up to we've copied that first

71
00:02:58,170 --> 00:03:02,819
command-line argument into that buffer

72
00:03:00,750 --> 00:03:05,850
and then we freed that pointer and of

73
00:03:02,819 --> 00:03:07,950
course we have an unbounded shrink copy

74
00:03:05,850 --> 00:03:09,780
here as well which could cause a heap

75
00:03:07,950 --> 00:03:13,018
overflowing and these are the types of

76
00:03:09,780 --> 00:03:14,340
bugs that we're looking at now when we

77
00:03:13,019 --> 00:03:16,739
think about that buffer they've got

78
00:03:14,340 --> 00:03:20,370
allocated in the last swipe it allocated

79
00:03:16,739 --> 00:03:22,049
I suppose we'll call it a chunk and melt

80
00:03:20,370 --> 00:03:24,600
off chunks are really the basic data

81
00:03:22,049 --> 00:03:26,549
structure in PT Mela to the default she

82
00:03:24,600 --> 00:03:29,760
would see Linux user land allocator and

83
00:03:26,549 --> 00:03:32,100
melon chunks either contain allocated or

84
00:03:29,760 --> 00:03:34,200
unallocated memory station-keeping both

85
00:03:32,100 --> 00:03:36,600
of you free a chunk of memory becomes

86
00:03:34,200 --> 00:03:40,859
unallocated memory now surrounding this

87
00:03:36,600 --> 00:03:43,620
trunk is in one metadata and this is one

88
00:03:40,860 --> 00:03:46,170
of the features well one of the things

89
00:03:43,620 --> 00:03:49,739
about Peter Mellon T is that surrounds

90
00:03:46,170 --> 00:03:54,030
application donor within one metadata

91
00:03:49,739 --> 00:03:56,310
that is potentially corruptible now

92
00:03:54,030 --> 00:03:59,130
they're talking about it in you stroke

93
00:03:56,310 --> 00:04:01,019
or an allocated or an unallocated chunk

94
00:03:59,130 --> 00:04:03,570
of memory so an eaten use chunk of

95
00:04:01,019 --> 00:04:05,850
memory immediately preceding that chunk

96
00:04:03,570 --> 00:04:08,940
payload which is the buffer that got

97
00:04:05,850 --> 00:04:11,160
allocated is a size field it also

98
00:04:08,940 --> 00:04:13,500
contains a few bits for Flags such as

99
00:04:11,160 --> 00:04:15,269
whether it the previous trunk is in use

100
00:04:13,500 --> 00:04:17,519
whether it came from an arena and

101
00:04:15,269 --> 00:04:20,010
whether it's been in mapped as well so

102
00:04:17,519 --> 00:04:21,228
that's sort of an induced chunk now a

103
00:04:20,010 --> 00:04:24,450
free chunk

104
00:04:21,228 --> 00:04:27,060
also contains that size field preceding

105
00:04:24,450 --> 00:04:29,760
the chunk payload will the original

106
00:04:27,060 --> 00:04:31,889
payload and then after sort of at the

107
00:04:29,760 --> 00:04:33,990
end of the chunk is also the site and so

108
00:04:31,889 --> 00:04:36,300
another copy of the size which is sort

109
00:04:33,990 --> 00:04:40,139
of interesting but more importantly for

110
00:04:36,300 --> 00:04:43,200
us inside the old payload data it's been

111
00:04:40,139 --> 00:04:46,139
repurposed just to maintain pointers

112
00:04:43,200 --> 00:04:47,729
keeping them as part of linked lists so

113
00:04:46,139 --> 00:04:49,950
this forward and back and it's forward

114
00:04:47,730 --> 00:04:51,840
next slice and back next size a players

115
00:04:49,950 --> 00:04:53,909
that maintain these free chunks and

116
00:04:51,840 --> 00:04:55,619
memory in wing flicks and this is

117
00:04:53,910 --> 00:04:59,160
potentially corruptible if we have a use

118
00:04:55,620 --> 00:05:01,710
after free where we can write to that

119
00:04:59,160 --> 00:05:05,310
chunk then we might be able to corrupt

120
00:05:01,710 --> 00:05:09,210
those link looks and this is sort of you

121
00:05:05,310 --> 00:05:11,010
know one of the main points of peep peep

122
00:05:09,210 --> 00:05:12,620
exploitation I suppose is weak and

123
00:05:11,010 --> 00:05:14,630
corrupt these pointers and make them do

124
00:05:12,620 --> 00:05:19,860
interesting things

125
00:05:14,630 --> 00:05:22,320
so these pointers maintain them on less

126
00:05:19,860 --> 00:05:25,350
known as free lists so when the chunk is

127
00:05:22,320 --> 00:05:27,599
free it's given back to the allocator

128
00:05:25,350 --> 00:05:29,580
and the allocator instead of putting it

129
00:05:27,600 --> 00:05:32,310
back into system memory stores it as

130
00:05:29,580 --> 00:05:34,109
parts of these free lists so that a

131
00:05:32,310 --> 00:05:37,760
future allocation might be able to

132
00:05:34,110 --> 00:05:40,289
recycle these free chunks quite quickly

133
00:05:37,760 --> 00:05:42,270
okay so that's one of them the basic

134
00:05:40,289 --> 00:05:45,120
strategy there's a recycling strategy

135
00:05:42,270 --> 00:05:47,490
than a future allocation like recycle

136
00:05:45,120 --> 00:05:48,960
these free chunks of memory and so when

137
00:05:47,490 --> 00:05:50,789
you free a chunk bit sort of the first

138
00:05:48,960 --> 00:05:52,710
point of call is supplied trying to put

139
00:05:50,789 --> 00:05:54,659
it into one of these these free lists

140
00:05:52,710 --> 00:05:57,239
and give that malloc the chance to

141
00:05:54,660 --> 00:06:00,389
recycle them yeah the Linux allocator

142
00:05:57,240 --> 00:06:02,639
follows bidding strategy and bins are

143
00:06:00,389 --> 00:06:03,960
basically free lists as well and the

144
00:06:02,639 --> 00:06:06,870
reason that they're called Bennie is

145
00:06:03,960 --> 00:06:10,109
that instead of you know sort of having

146
00:06:06,870 --> 00:06:12,510
you know one single free list you have a

147
00:06:10,110 --> 00:06:13,470
bunch of free lists that each occupy a

148
00:06:12,510 --> 00:06:15,840
particular mark

149
00:06:13,470 --> 00:06:17,460
chunk size range and that's the bidding

150
00:06:15,840 --> 00:06:19,950
approach to take a very large number and

151
00:06:17,460 --> 00:06:21,810
to divide it into small ranges and

152
00:06:19,950 --> 00:06:24,479
associate each of these small ranges

153
00:06:21,810 --> 00:06:26,610
with a particular bin or a particular

154
00:06:24,479 --> 00:06:29,070
free lift so different chunks sizes

155
00:06:26,610 --> 00:06:31,200
going to different bins and bins can

156
00:06:29,070 --> 00:06:34,650
also be threads specific in fact there's

157
00:06:31,200 --> 00:06:37,680
a purse red cash or addy cash specific

158
00:06:34,650 --> 00:06:39,450
to the threads so we'll look at a

159
00:06:37,680 --> 00:06:40,620
simplified bin so this is sort of one on

160
00:06:39,450 --> 00:06:44,630
the main sort of things that we

161
00:06:40,620 --> 00:06:47,639
going to look at attacking or corrupting

162
00:06:44,630 --> 00:06:49,919
look at a simplified B so we allocate

163
00:06:47,639 --> 00:06:52,620
some memory you know a beanie currently

164
00:06:49,919 --> 00:06:56,400
is is free doesn't have any items in it

165
00:06:52,620 --> 00:06:58,080
sorry we allocate some more memory we

166
00:06:56,400 --> 00:07:02,429
still don't have anything out bins

167
00:06:58,080 --> 00:07:04,500
remember how bins recycle a placeholders

168
00:07:02,430 --> 00:07:07,380
so that we can later recycle free chunks

169
00:07:04,500 --> 00:07:10,680
so when we free something it goes into

170
00:07:07,380 --> 00:07:14,930
our bin so we free junk see it went into

171
00:07:10,680 --> 00:07:17,220
our bin we free another chunk we free B

172
00:07:14,930 --> 00:07:20,280
and this is one that we allocated

173
00:07:17,220 --> 00:07:25,139
earlier and our chunk now gets inserted

174
00:07:20,280 --> 00:07:26,969
at the head of this free list and we

175
00:07:25,139 --> 00:07:28,199
have two nodes now in our free list so

176
00:07:26,970 --> 00:07:30,479
it sort of it's a last scene for a

177
00:07:28,199 --> 00:07:32,970
structure or a stack so it added

178
00:07:30,479 --> 00:07:36,229
something to that we added something we

179
00:07:32,970 --> 00:07:39,830
added something to the head of the stack

180
00:07:36,229 --> 00:07:44,750
and now we're going to free a third

181
00:07:39,830 --> 00:07:47,310
chunk and again that goes to head about

182
00:07:44,750 --> 00:07:49,950
about list so we've got three chunks in

183
00:07:47,310 --> 00:07:51,990
our bit simplified bin but this is

184
00:07:49,950 --> 00:07:56,570
really how I've been working in the real

185
00:07:51,990 --> 00:07:59,550
world when we go to allocate something

186
00:07:56,570 --> 00:08:00,960
we've allocated you know ten bytes of

187
00:07:59,550 --> 00:08:03,389
memory again the reality is something

188
00:08:00,960 --> 00:08:05,549
like alligator before and in fact we're

189
00:08:03,389 --> 00:08:08,070
going to recycle our chunk from our free

190
00:08:05,550 --> 00:08:09,500
list and we popped off a and gave it

191
00:08:08,070 --> 00:08:13,260
back to the user and application

192
00:08:09,500 --> 00:08:15,120
requesting it we request another 10

193
00:08:13,260 --> 00:08:17,010
bytes of memory and we recycled this

194
00:08:15,120 --> 00:08:18,810
trunk again we've popped it off the head

195
00:08:17,010 --> 00:08:21,690
of those on the top of that free list

196
00:08:18,810 --> 00:08:23,760
and we've done it as well we still own

197
00:08:21,690 --> 00:08:25,469
one item in our friend list we're going

198
00:08:23,760 --> 00:08:28,560
to free another chunk now and again it

199
00:08:25,470 --> 00:08:30,539
goes back to the top of the free list or

200
00:08:28,560 --> 00:08:35,339
the head of the free list very much like

201
00:08:30,539 --> 00:08:37,289
a stack and that's basically what a free

202
00:08:35,339 --> 00:08:39,959
list is that's basically how most of the

203
00:08:37,289 --> 00:08:42,240
free lists work in general free lists

204
00:08:39,958 --> 00:08:44,459
are lastin first-out structures or Wi-Fi

205
00:08:42,240 --> 00:08:47,520
structures or sort of common language

206
00:08:44,459 --> 00:08:49,140
and we call the stack so there's

207
00:08:47,520 --> 00:08:52,949
actually a number of beans that have

208
00:08:49,140 --> 00:08:54,460
been to develop users you have the you

209
00:08:52,950 --> 00:08:57,070
have unsorted small

210
00:08:54,460 --> 00:08:59,530
large beans and so forth you know fast

211
00:08:57,070 --> 00:09:01,240
beans these are these are all different

212
00:08:59,530 --> 00:09:03,250
types of beans for different types of

213
00:09:01,240 --> 00:09:05,260
functionalities fast beans here are

214
00:09:03,250 --> 00:09:06,670
shown a singly linked list and then we

215
00:09:05,260 --> 00:09:09,970
have small and large beans in the

216
00:09:06,670 --> 00:09:11,770
unsorted beans which are much which are

217
00:09:09,970 --> 00:09:15,310
different types of intake doubly linked

218
00:09:11,770 --> 00:09:16,689
lists so those are sort of the main sort

219
00:09:15,310 --> 00:09:19,180
of data structures when we work with

220
00:09:16,690 --> 00:09:22,900
free lists and then singly worthless and

221
00:09:19,180 --> 00:09:25,469
doubly linked lists another concept that

222
00:09:22,900 --> 00:09:30,850
we have to understand is an arena in

223
00:09:25,470 --> 00:09:33,190
arena stores basically heaps entire

224
00:09:30,850 --> 00:09:35,080
heaps as an arena structure and the

225
00:09:33,190 --> 00:09:37,390
reason that there are multiple arenas in

226
00:09:35,080 --> 00:09:39,790
a application is it's basically to

227
00:09:37,390 --> 00:09:42,880
reduce threat condition contention if

228
00:09:39,790 --> 00:09:44,800
you have all applications from all your

229
00:09:42,880 --> 00:09:46,390
threads going into a single arena they

230
00:09:44,800 --> 00:09:49,270
all be contending for that you know

231
00:09:46,390 --> 00:09:51,160
global heap looking structures or

232
00:09:49,270 --> 00:09:54,790
synchronization primitives do you have

233
00:09:51,160 --> 00:09:58,000
separate heaps to separate arenas and it

234
00:09:54,790 --> 00:10:00,819
reduces three contention so where is the

235
00:09:58,000 --> 00:10:04,450
metadata what can we modify if we have a

236
00:10:00,820 --> 00:10:07,960
heap corruption so pitting them to users

237
00:10:04,450 --> 00:10:11,050
metadata before and after each allocated

238
00:10:07,960 --> 00:10:14,830
buffer as well as using before and after

239
00:10:11,050 --> 00:10:16,390
and inside unallocated buffers so what

240
00:10:14,830 --> 00:10:17,920
types of things can we corrupt from a

241
00:10:16,390 --> 00:10:20,460
heatwave the flow so the size

242
00:10:17,920 --> 00:10:23,050
information we could certainly corrupt

243
00:10:20,460 --> 00:10:25,630
anything what can he do by corrupting

244
00:10:23,050 --> 00:10:28,449
the slice field well when you free a

245
00:10:25,630 --> 00:10:31,830
chunk the memory the way that it knows

246
00:10:28,450 --> 00:10:34,450
the size of the trunk and therefore the

247
00:10:31,830 --> 00:10:37,420
associated been holding these free

248
00:10:34,450 --> 00:10:39,550
chunks is the size field the metadata

249
00:10:37,420 --> 00:10:43,030
before the paint load so if you modify

250
00:10:39,550 --> 00:10:44,949
the size field Manfredi chunk thinking

251
00:10:43,030 --> 00:10:46,900
that it's much larger it'll go into the

252
00:10:44,950 --> 00:10:48,130
wrong size bit and then when a future

253
00:10:46,900 --> 00:10:52,150
allocation occurs

254
00:10:48,130 --> 00:10:54,250
it'll reclaim that in correct size and

255
00:10:52,150 --> 00:10:56,110
maybe that Chuck now will overlap

256
00:10:54,250 --> 00:10:58,660
adjacent data so you might have

257
00:10:56,110 --> 00:11:00,970
overlapping chunks here also those free

258
00:10:58,660 --> 00:11:03,339
list pointers and I'll talk about this

259
00:11:00,970 --> 00:11:06,850
later on but these free list pointers if

260
00:11:03,340 --> 00:11:08,320
you corrupt a free list pointer you

261
00:11:06,850 --> 00:11:10,630
could make malloc return

262
00:11:08,320 --> 00:11:13,750
an arbitrary cleaner you could make

263
00:11:10,630 --> 00:11:15,730
Malik return that arbitrary point of

264
00:11:13,750 --> 00:11:20,110
that you corrupted this free list singly

265
00:11:15,730 --> 00:11:22,630
length this with now also what types of

266
00:11:20,110 --> 00:11:26,730
things can you reveal from a memory

267
00:11:22,630 --> 00:11:29,110
disclosure so pointers in free lists in

268
00:11:26,730 --> 00:11:32,200
these frameworks remember those the

269
00:11:29,110 --> 00:11:34,450
payload of an unallocated chunk pointers

270
00:11:32,200 --> 00:11:36,370
in those can point to global heap

271
00:11:34,450 --> 00:11:38,530
structures in standard C libraries or

272
00:11:36,370 --> 00:11:41,620
Lucy and so you might be able to reveal

273
00:11:38,530 --> 00:11:43,990
the lint see base address and to feed a

274
00:11:41,620 --> 00:11:47,280
SLR and you also might get pointers to

275
00:11:43,990 --> 00:11:50,740
dynamic keep data structures as well

276
00:11:47,280 --> 00:11:53,350
okay so we'll go on to sort of look at

277
00:11:50,740 --> 00:11:58,630
people okay take internals now let's

278
00:11:53,350 --> 00:12:00,610
talk about exploitation so pretty much

279
00:11:58,630 --> 00:12:02,500
when you're an attacker what do you do

280
00:12:00,610 --> 00:12:05,770
with the bug you know you've got a bug

281
00:12:02,500 --> 00:12:07,420
what's the purpose generally sort of the

282
00:12:05,770 --> 00:12:09,699
modern approach is to try to gain some

283
00:12:07,420 --> 00:12:12,010
sort of primitives that leverage that

284
00:12:09,700 --> 00:12:13,240
bug into arbitrary code execution and

285
00:12:12,010 --> 00:12:16,180
the types of primitives that you're

286
00:12:13,240 --> 00:12:18,220
after you want the ability to write to

287
00:12:16,180 --> 00:12:20,560
what you want anywhere in memory sort of

288
00:12:18,220 --> 00:12:22,210
a right what we're primitive may be a

289
00:12:20,560 --> 00:12:24,520
restricted ability to write to the

290
00:12:22,210 --> 00:12:26,950
memory the ability to read memory and

291
00:12:24,520 --> 00:12:28,840
arbitrary read/write primitive the

292
00:12:26,950 --> 00:12:30,700
disclosure of the memory life these are

293
00:12:28,840 --> 00:12:35,530
the types of primitives that enable you

294
00:12:30,700 --> 00:12:38,290
to gain code execution so let's assume

295
00:12:35,530 --> 00:12:40,270
that in this hacker has a read/write

296
00:12:38,290 --> 00:12:42,670
primitive this is sort of we'll assume

297
00:12:40,270 --> 00:12:44,740
that an attacker has reached this point

298
00:12:42,670 --> 00:12:48,010
where they leverage the bug and they

299
00:12:44,740 --> 00:12:50,380
gained a read/write primitive how do

300
00:12:48,010 --> 00:12:54,310
they turn that into code execution on a

301
00:12:50,380 --> 00:12:58,330
current Linux user land application you

302
00:12:54,310 --> 00:13:00,099
need to fixed you need to you need an

303
00:12:58,330 --> 00:13:03,700
information link so you need to be able

304
00:13:00,100 --> 00:13:06,000
to read you know from memory to gain an

305
00:13:03,700 --> 00:13:09,340
information leak that discloses the

306
00:13:06,000 --> 00:13:11,260
address of legacy in memory the sentence

307
00:13:09,340 --> 00:13:13,420
in one remembers that shared library in

308
00:13:11,260 --> 00:13:15,420
the address space and the reason you

309
00:13:13,420 --> 00:13:18,939
want to disclose the Lucie base address

310
00:13:15,420 --> 00:13:20,740
or the aslr Lair is that you want to

311
00:13:18,940 --> 00:13:22,360
hire eject control flow and overwrite

312
00:13:20,740 --> 00:13:25,810
any exist

313
00:13:22,360 --> 00:13:30,040
function pointer such as in Lipsy

314
00:13:25,810 --> 00:13:31,209
and overwrite that with the comb you

315
00:13:30,040 --> 00:13:32,439
know quick back to the code that you

316
00:13:31,209 --> 00:13:33,910
want to execute it then have the

317
00:13:32,440 --> 00:13:35,380
application call this function pointer

318
00:13:33,910 --> 00:13:37,149
so this is what you need for sort of

319
00:13:35,380 --> 00:13:38,920
modern linux exploitation you want an

320
00:13:37,149 --> 00:13:41,350
info link to disclose the Lib C base

321
00:13:38,920 --> 00:13:43,510
address and then that will let you know

322
00:13:41,350 --> 00:13:46,149
wearing lip C to overwrite a known

323
00:13:43,510 --> 00:13:48,010
function pointer to point to the code

324
00:13:46,149 --> 00:13:50,769
that you want to execute and you hijack

325
00:13:48,010 --> 00:13:53,680
control flow there is no control flow

326
00:13:50,769 --> 00:13:55,660
integrity in user land default at the

327
00:13:53,680 --> 00:13:59,380
moment so this is an entirely valid

328
00:13:55,660 --> 00:14:00,670
approach now where do you get function

329
00:13:59,380 --> 00:14:02,529
pointers from now this is the part of

330
00:14:00,670 --> 00:14:03,910
research I suppose we know the strategy

331
00:14:02,529 --> 00:14:05,890
we just want to override a function

332
00:14:03,910 --> 00:14:08,199
pointer well it to a beginning of a rock

333
00:14:05,890 --> 00:14:11,560
chain or a stack bit or something like

334
00:14:08,200 --> 00:14:13,990
that maybe point it to all one gadget to

335
00:14:11,560 --> 00:14:16,060
get a shell really quickly so you know

336
00:14:13,990 --> 00:14:19,180
what function pointers are available

337
00:14:16,060 --> 00:14:21,880
that we can overwrite to hijack control

338
00:14:19,180 --> 00:14:25,540
flow on a modern Linux system so

339
00:14:21,880 --> 00:14:27,490
historically the global off a table was

340
00:14:25,540 --> 00:14:29,439
a good place to find function pointers

341
00:14:27,490 --> 00:14:32,589
and the global offset table is basically

342
00:14:29,440 --> 00:14:35,050
a list a varietal function pointers

343
00:14:32,589 --> 00:14:37,360
present in almost all executables all

344
00:14:35,050 --> 00:14:38,979
dynamically linked executables have a

345
00:14:37,360 --> 00:14:40,899
global off their tables and these

346
00:14:38,980 --> 00:14:43,480
contain pointers to library functions

347
00:14:40,899 --> 00:14:45,519
such that when you call printf it will

348
00:14:43,480 --> 00:14:47,740
look up the global off the table via the

349
00:14:45,519 --> 00:14:49,540
procedure linkage table and the global

350
00:14:47,740 --> 00:14:52,149
offs that table will hold the resolve

351
00:14:49,540 --> 00:14:54,250
address of that princess in our shared

352
00:14:52,149 --> 00:14:56,709
library in the address space and so

353
00:14:54,250 --> 00:14:58,390
classic key of exploitation would

354
00:14:56,709 --> 00:15:00,099
overwrite the guy in free with the point

355
00:14:58,390 --> 00:15:01,660
of view of shell code you know the

356
00:15:00,100 --> 00:15:03,130
application calls the why we call

357
00:15:01,660 --> 00:15:05,050
associated with divide entry may be

358
00:15:03,130 --> 00:15:07,329
printf may be Mel walk something like

359
00:15:05,050 --> 00:15:09,010
that and the in fact is now hijacked

360
00:15:07,329 --> 00:15:12,189
control flow but that's sort of

361
00:15:09,010 --> 00:15:14,680
historical so the ght as a source of

362
00:15:12,190 --> 00:15:18,160
functional pointers no longer works on

363
00:15:14,680 --> 00:15:20,380
most systems there's a mitigation in

364
00:15:18,160 --> 00:15:22,689
fact call we'd only relocations that

365
00:15:20,380 --> 00:15:25,360
resolves all the YB symbols at program

366
00:15:22,690 --> 00:15:27,160
low type and read maps they've got as

367
00:15:25,360 --> 00:15:28,810
readable but not right

368
00:15:27,160 --> 00:15:31,959
so you can't project is at runtime

369
00:15:28,810 --> 00:15:33,880
because it's not writable anymore and

370
00:15:31,959 --> 00:15:35,410
even though I say that this no longer

371
00:15:33,880 --> 00:15:37,060
works on mostest

372
00:15:35,410 --> 00:15:39,129
today there are applications out there

373
00:15:37,060 --> 00:15:40,930
that have writable geo TS such as

374
00:15:39,129 --> 00:15:43,240
Firefox you can do this attack on

375
00:15:40,930 --> 00:15:45,128
Firefox today but this is really what we

376
00:15:43,240 --> 00:15:46,779
consider historical Firefox will fix

377
00:15:45,129 --> 00:15:50,709
this I'm sure at some point in the

378
00:15:46,779 --> 00:15:53,079
future so you know how do you exploit

379
00:15:50,709 --> 00:15:54,699
you know you know modern applications

380
00:15:53,079 --> 00:15:56,589
that have this reasonable mitigation

381
00:15:54,699 --> 00:16:00,219
that is pretty much present in every

382
00:15:56,589 --> 00:16:02,649
executable so you know can you do it yes

383
00:16:00,220 --> 00:16:06,189
one control flaw hijacking is still very

384
00:16:02,649 --> 00:16:08,259
impossible if you know where lipsi is

385
00:16:06,189 --> 00:16:10,360
loaded in memory because there are

386
00:16:08,259 --> 00:16:14,769
standard function pointers at fixed

387
00:16:10,360 --> 00:16:17,199
offsets in Lib C so the modern standard

388
00:16:14,769 --> 00:16:19,480
c library has a number of known function

389
00:16:17,199 --> 00:16:22,180
pointers as offsets from their lives any

390
00:16:19,480 --> 00:16:23,860
base address so the exit handlers are

391
00:16:22,180 --> 00:16:25,180
one example of function pointers this is

392
00:16:23,860 --> 00:16:27,339
a little bit harder because there's the

393
00:16:25,180 --> 00:16:30,550
mitigation owners point to guard that

394
00:16:27,339 --> 00:16:32,589
obfuscates those function pointers but

395
00:16:30,550 --> 00:16:34,779
to things that aren't obfuscated and you

396
00:16:32,589 --> 00:16:37,209
can overwrite directly are the runtime

397
00:16:34,779 --> 00:16:40,839
link unlocking functions this is part of

398
00:16:37,209 --> 00:16:42,579
sort of the runtime linker and probably

399
00:16:40,839 --> 00:16:44,860
the most well-known and common one

400
00:16:42,579 --> 00:16:47,769
Armel talks for every malloc and co-op

401
00:16:44,860 --> 00:16:50,439
good Ariella call is a function pointer

402
00:16:47,769 --> 00:16:54,130
associated with it that is for

403
00:16:50,439 --> 00:16:55,959
application specific melech api so if

404
00:16:54,130 --> 00:16:58,319
you want to have your own custom l-look

405
00:16:55,959 --> 00:17:01,119
you would overwrite the milk with your

406
00:16:58,319 --> 00:17:13,418
function pointer that you want and then

407
00:17:01,120 --> 00:17:17,079
you are a when malloc is called you're

408
00:17:13,419 --> 00:17:20,709
able to do that now you can actually

409
00:17:17,079 --> 00:17:22,240
defeat a SLR as well so you need to you

410
00:17:20,709 --> 00:17:24,130
need to know the Lipsy base to do that

411
00:17:22,240 --> 00:17:25,959
molecule hijacking it will be able to do

412
00:17:24,130 --> 00:17:28,750
that later on but if you don't want to

413
00:17:25,959 --> 00:17:30,940
defeat you know Lipsy base address there

414
00:17:28,750 --> 00:17:33,039
are other techniques as well yeah if the

415
00:17:30,940 --> 00:17:35,530
binary is not compiled position

416
00:17:33,039 --> 00:17:37,419
independent and one binary servant you

417
00:17:35,530 --> 00:17:40,870
know certainly some out there don't

418
00:17:37,419 --> 00:17:42,789
compile acquisition independent then the

419
00:17:40,870 --> 00:17:45,039
PLT in the GOG that I just talked about

420
00:17:42,789 --> 00:17:48,158
that global offset table is it a fixed

421
00:17:45,039 --> 00:17:48,990
address when the program works so clip

422
00:17:48,159 --> 00:17:52,050
see also

423
00:17:48,990 --> 00:17:55,140
ASLR but the PLT of the JIT is at a

424
00:17:52,050 --> 00:17:57,030
fixed address so how do you just how do

425
00:17:55,140 --> 00:18:00,120
you how can you get the Lipsey base

426
00:17:57,030 --> 00:18:01,889
address even that the PLT maturity is a

427
00:18:00,120 --> 00:18:03,689
fixed address now if you are able to

428
00:18:01,890 --> 00:18:05,280
hijack control flow from some sort of

429
00:18:03,690 --> 00:18:09,270
stack overflow or something like that

430
00:18:05,280 --> 00:18:13,200
then you can actually return control

431
00:18:09,270 --> 00:18:16,590
flow into the right system call which is

432
00:18:13,200 --> 00:18:18,179
in the gog in the peel team and what

433
00:18:16,590 --> 00:18:21,419
you're going to write to standard output

434
00:18:18,179 --> 00:18:23,910
are the contents over G ot entry for a

435
00:18:21,420 --> 00:18:26,010
resolved library call and this will

436
00:18:23,910 --> 00:18:28,770
actually print the address that it is

437
00:18:26,010 --> 00:18:30,900
enriched see in this particular fall and

438
00:18:28,770 --> 00:18:33,840
that's it a fixed offset from the loop C

439
00:18:30,900 --> 00:18:37,170
base and there you can actually know the

440
00:18:33,840 --> 00:18:39,240
base address of Lib C even though that

441
00:18:37,170 --> 00:18:42,480
live C wasn't a random address but the

442
00:18:39,240 --> 00:18:46,770
PLT majority wasn't so the basic idea is

443
00:18:42,480 --> 00:18:49,260
that if you have a non-random eyes peel

444
00:18:46,770 --> 00:18:51,600
to your G ot then you can disclose the

445
00:18:49,260 --> 00:18:53,460
Lindsey base address now this attack is

446
00:18:51,600 --> 00:18:55,709
mostly historical now the modern

447
00:18:53,460 --> 00:18:58,440
mitigation is to use a physician

448
00:18:55,710 --> 00:19:01,190
independent executable and this will

449
00:18:58,440 --> 00:19:03,540
remap the PLC in the G ot that

450
00:19:01,190 --> 00:19:06,300
randomized addresses on every execution

451
00:19:03,540 --> 00:19:08,970
you can't return into the PLT unless you

452
00:19:06,300 --> 00:19:12,750
get the address of that enough

453
00:19:08,970 --> 00:19:16,170
randomized text and data sticker now if

454
00:19:12,750 --> 00:19:19,830
you're on 32-bit and then Eve CGS all

455
00:19:16,170 --> 00:19:22,200
challenges left 32 bits all summer the

456
00:19:19,830 --> 00:19:24,240
entropy on a 32-bit system is actually

457
00:19:22,200 --> 00:19:26,790
very small so it's actually very easy to

458
00:19:24,240 --> 00:19:28,950
defeat a SLR on a 32-bit system you

459
00:19:26,790 --> 00:19:31,590
simply have to run your exploit 1,000

460
00:19:28,950 --> 00:19:34,160
times without changing any of your fixed

461
00:19:31,590 --> 00:19:37,379
addresses but you know for one run and

462
00:19:34,160 --> 00:19:39,150
you know by statistics you'll bring

463
00:19:37,380 --> 00:19:40,710
forward almost certainly in completely

464
00:19:39,150 --> 00:19:42,960
defeat a SLR and you'll probably get it

465
00:19:40,710 --> 00:19:44,670
you know somewhere between a hundred to

466
00:19:42,960 --> 00:19:47,940
and a thousand iterations you'll defeat

467
00:19:44,670 --> 00:19:50,280
a SLR on 32 bits because the entropy is

468
00:19:47,940 --> 00:19:51,929
so small now if you have multiple

469
00:19:50,280 --> 00:19:53,610
libraries that you're trying to bring

470
00:19:51,929 --> 00:19:55,620
force and they're all loaded

471
00:19:53,610 --> 00:19:58,110
independently with a sli then it takes

472
00:19:55,620 --> 00:19:59,850
much longer to defeat i'm saying at the

473
00:19:58,110 --> 00:20:01,649
time of one wire we multiplied by the

474
00:19:59,850 --> 00:20:02,759
time of the second library and so forth

475
00:20:01,650 --> 00:20:04,519
so

476
00:20:02,759 --> 00:20:08,669
you want to try to keep your exploits

477
00:20:04,519 --> 00:20:12,719
I'm only using one library ideally and

478
00:20:08,669 --> 00:20:14,369
then it's quite faster to fee you don't

479
00:20:12,719 --> 00:20:17,249
always need to defeat a Slifer and

480
00:20:14,369 --> 00:20:19,408
exploit to work what you can take

481
00:20:17,249 --> 00:20:21,209
advantage of as well is that if we're

482
00:20:19,409 --> 00:20:23,609
going to remember is Lipsy is just a

483
00:20:21,209 --> 00:20:26,399
small contiguous region of memory so if

484
00:20:23,609 --> 00:20:28,799
you have a function pointer in to

485
00:20:26,399 --> 00:20:31,198
somewhere in whimsy such as printf or so

486
00:20:28,799 --> 00:20:33,179
forth and you want to modify that

487
00:20:31,199 --> 00:20:36,329
function pointer to point somewhere else

488
00:20:33,179 --> 00:20:39,119
in Lipsy maybe to mallet or a one gadget

489
00:20:36,329 --> 00:20:41,579
that executes to shell you don't need to

490
00:20:39,119 --> 00:20:42,988
modify the entire eight bytes you know

491
00:20:41,579 --> 00:20:45,418
eight why don't you simply have to

492
00:20:42,989 --> 00:20:48,029
modify them load bytes of the pointer

493
00:20:45,419 --> 00:20:51,119
and then you can bypass a slot all to

494
00:20:48,029 --> 00:20:52,799
get even redirect an existing Lib C

495
00:20:51,119 --> 00:20:55,408
function point into another loop C

496
00:20:52,799 --> 00:20:58,109
function pointer by only modifying one

497
00:20:55,409 --> 00:21:02,039
or two bites yes what not might not be

498
00:20:58,109 --> 00:21:03,629
100% reliable but this is a pretty new

499
00:21:02,039 --> 00:21:05,579
reasonable technique if you want to

500
00:21:03,629 --> 00:21:09,418
redirect or change one function pointer

501
00:21:05,579 --> 00:21:12,329
to another function pointer now is it

502
00:21:09,419 --> 00:21:14,309
possible to write reliable exports with

503
00:21:12,329 --> 00:21:16,049
a seller on a 64-bit when it's that

504
00:21:14,309 --> 00:21:19,829
users position independent executables

505
00:21:16,049 --> 00:21:22,408
and all other mitigations absolutely you

506
00:21:19,829 --> 00:21:26,519
need in information disclosure on the

507
00:21:22,409 --> 00:21:28,199
Linux heap to disclose a pointer as part

508
00:21:26,519 --> 00:21:30,599
of those free lists which point to fixed

509
00:21:28,199 --> 00:21:33,569
structures in Lib C and that discloses

510
00:21:30,599 --> 00:21:36,389
the Lib C base address so all you need

511
00:21:33,569 --> 00:21:38,879
to do is have the ability to read bit of

512
00:21:36,389 --> 00:21:41,189
memory off the heap have a the he played

513
00:21:38,879 --> 00:21:43,198
out in a certain way that one gives you

514
00:21:41,190 --> 00:21:48,239
a point of that's useful and you've got

515
00:21:43,199 --> 00:21:51,419
the loop city-based the dress so the

516
00:21:48,239 --> 00:21:53,449
final part of our about about of the

517
00:21:51,419 --> 00:21:58,829
talk is looking at Linux heap

518
00:21:53,449 --> 00:22:01,859
exploitation yeah so historical heap

519
00:21:58,829 --> 00:22:04,259
exploitation on Linux was based around

520
00:22:01,859 --> 00:22:08,428
DLF there was the precursor to Petey

521
00:22:04,259 --> 00:22:10,799
Nowak the attack is effectively you

522
00:22:08,429 --> 00:22:14,789
overflow a heap allocated buffer and you

523
00:22:10,799 --> 00:22:16,440
overwrite those linkless pointers that

524
00:22:14,789 --> 00:22:18,750
we talked about earlier

525
00:22:16,440 --> 00:22:20,370
we effectively a note is unlinked from a

526
00:22:18,750 --> 00:22:22,470
linked list such as roomie removing it

527
00:22:20,370 --> 00:22:24,000
from a free list that point of

528
00:22:22,470 --> 00:22:25,560
manipulation through that unlinking

529
00:22:24,000 --> 00:22:27,060
process you've see an attack of the

530
00:22:25,560 --> 00:22:28,560
ability to write what they want and

531
00:22:27,060 --> 00:22:30,240
where they want you been require those

532
00:22:28,560 --> 00:22:32,970
pointer operations and this is known as

533
00:22:30,240 --> 00:22:34,590
the unlink attack it was developed by

534
00:22:32,970 --> 00:22:37,410
salih designer against Netscape

535
00:22:34,590 --> 00:22:38,730
Navigator and there's a lot of history

536
00:22:37,410 --> 00:22:40,710
about this he was the first guy to

537
00:22:38,730 --> 00:22:44,100
develop the first one executable sack

538
00:22:40,710 --> 00:22:45,450
Pacha linux he developed in the same

539
00:22:44,100 --> 00:22:47,939
person he talked about non-executable

540
00:22:45,450 --> 00:22:50,340
stacks he develop return to live scene

541
00:22:47,940 --> 00:22:53,060
which is the precursor to rob any now

542
00:22:50,340 --> 00:22:56,159
develops the open wall Linux

543
00:22:53,060 --> 00:22:58,590
distributions so he did this in the year

544
00:22:56,160 --> 00:23:01,170
2000 Derek this was really the

545
00:22:58,590 --> 00:23:04,409
birthplace of heap exploitation the

546
00:23:01,170 --> 00:23:06,390
first generic lead exploitation unlink

547
00:23:04,410 --> 00:23:09,960
has been dead for about 15 years hasn't

548
00:23:06,390 --> 00:23:11,730
worked for a long time you don't really

549
00:23:09,960 --> 00:23:14,640
see this too commonly today some

550
00:23:11,730 --> 00:23:16,980
embedded allocators this attack still

551
00:23:14,640 --> 00:23:18,690
works on so some you know embedded would

552
00:23:16,980 --> 00:23:21,120
see and I actually devices this attack

553
00:23:18,690 --> 00:23:24,180
still works but effectively only has

554
00:23:21,120 --> 00:23:27,120
been modified mitigated by checking that

555
00:23:24,180 --> 00:23:28,890
the linked list pointers look reasonable

556
00:23:27,120 --> 00:23:30,330
so if you started a node and you go

557
00:23:28,890 --> 00:23:34,710
forward and backwards you end up at the

558
00:23:30,330 --> 00:23:36,980
same place in this linked list so from

559
00:23:34,710 --> 00:23:40,110
about 2005 there's been an era of

560
00:23:36,980 --> 00:23:41,640
unpaused only keep exploitation and this

561
00:23:40,110 --> 00:23:45,060
is carried on through to today there's

562
00:23:41,640 --> 00:23:47,670
been about 15 years of research of of

563
00:23:45,060 --> 00:23:49,409
exploitation and there are many many

564
00:23:47,670 --> 00:23:51,810
techniques that work today is probably a

565
00:23:49,410 --> 00:23:56,610
dozen two dozen techniques on Linux tree

566
00:23:51,810 --> 00:23:59,190
we've seen that work to attack the Linux

567
00:23:56,610 --> 00:24:01,469
heap now modern keep

568
00:23:59,190 --> 00:24:05,150
metadata exploitation you're unlikely to

569
00:24:01,470 --> 00:24:08,880
get a right what we're primitive instead

570
00:24:05,150 --> 00:24:11,190
what the goal should be well you can do

571
00:24:08,880 --> 00:24:13,620
other things besides right where you can

572
00:24:11,190 --> 00:24:15,990
make melech return an arbitrary point

573
00:24:13,620 --> 00:24:17,729
and decided by the attacker you can have

574
00:24:15,990 --> 00:24:19,860
it a near arbitrary point you can make

575
00:24:17,730 --> 00:24:20,490
Mel opportunity all ready allocated heap

576
00:24:19,860 --> 00:24:22,530
buffer

577
00:24:20,490 --> 00:24:24,780
well you might make melech return above

578
00:24:22,530 --> 00:24:26,670
the overlaps another heap allocated

579
00:24:24,780 --> 00:24:29,610
buffer so these are the types of attacks

580
00:24:26,670 --> 00:24:30,310
you can do not only PT Mela to but a

581
00:24:29,610 --> 00:24:34,090
bunch of our

582
00:24:30,310 --> 00:24:37,179
Peters as well now if you make Melek

583
00:24:34,090 --> 00:24:40,870
return an arbitrary point O and an

584
00:24:37,180 --> 00:24:43,570
attacker can write to that what would be

585
00:24:40,870 --> 00:24:45,520
a legitimate buffer normally you know

586
00:24:43,570 --> 00:24:46,899
maybe it's using input attacker input or

587
00:24:45,520 --> 00:24:48,790
something like that if you if an

588
00:24:46,900 --> 00:24:51,370
attacker can do that that's application

589
00:24:48,790 --> 00:24:55,570
logic now then control flow hijacking is

590
00:24:51,370 --> 00:24:57,129
very likely so what you want to do is

591
00:24:55,570 --> 00:24:59,679
you want to make Melek return an

592
00:24:57,130 --> 00:25:01,900
arbitrary pointer and make it point to a

593
00:24:59,680 --> 00:25:06,640
function pointer for example the g OT

594
00:25:01,900 --> 00:25:08,110
all a multiple that's in Lib C we know

595
00:25:06,640 --> 00:25:10,180
the base address of the loop C because

596
00:25:08,110 --> 00:25:13,300
we did that information disclosure and

597
00:25:10,180 --> 00:25:16,210
if the attacker then rights to that

598
00:25:13,300 --> 00:25:18,850
buffer and basically substitute the

599
00:25:16,210 --> 00:25:21,130
beginning of their rock chain or they

600
00:25:18,850 --> 00:25:26,790
could substitute the point it to the one

601
00:25:21,130 --> 00:25:29,200
gadget then they can hijack control for

602
00:25:26,790 --> 00:25:31,330
now so that's that's the attack that's

603
00:25:29,200 --> 00:25:33,790
really how what an exploitation works in

604
00:25:31,330 --> 00:25:35,530
this context you make mellon pretend an

605
00:25:33,790 --> 00:25:37,600
arbitrary pointer you override a

606
00:25:35,530 --> 00:25:39,040
function pointer you know that loop C

607
00:25:37,600 --> 00:25:40,659
basic rest so you know where to write

608
00:25:39,040 --> 00:25:42,970
that function pointer to and you know

609
00:25:40,660 --> 00:25:45,310
where to get a one gadget rock chain and

610
00:25:42,970 --> 00:25:46,960
so forth and you can hijack control flow

611
00:25:45,310 --> 00:25:48,639
now you typically need to layout the

612
00:25:46,960 --> 00:25:51,670
heap so you'll hit corruptions corrupt

613
00:25:48,640 --> 00:25:53,620
the right chunks and generally need some

614
00:25:51,670 --> 00:25:56,920
level of interactivity with your

615
00:25:53,620 --> 00:26:00,070
application you know to to layout memory

616
00:25:56,920 --> 00:26:02,800
to get info leaks and so forth and it

617
00:26:00,070 --> 00:26:05,470
might not always be 100% reliable but

618
00:26:02,800 --> 00:26:07,720
other than that control flow hijacking

619
00:26:05,470 --> 00:26:10,330
is certainly possible on a current

620
00:26:07,720 --> 00:26:14,130
system with all mitigations providing

621
00:26:10,330 --> 00:26:18,120
the application is is reasonably

622
00:26:14,130 --> 00:26:21,130
suitable for this type of exploit and

623
00:26:18,120 --> 00:26:23,260
remember you know how do we get malloc

624
00:26:21,130 --> 00:26:24,880
pretend an arbitrary point you talked

625
00:26:23,260 --> 00:26:26,830
about getting milk fraternity true what

626
00:26:24,880 --> 00:26:31,210
are those free lists we simply have to

627
00:26:26,830 --> 00:26:33,520
corrupt a pointer in those free lists to

628
00:26:31,210 --> 00:26:35,620
point to our arbitrary address that's

629
00:26:33,520 --> 00:26:36,879
really all you have to do that's all we

630
00:26:35,620 --> 00:26:38,560
have to do with the heat corruption and

631
00:26:36,880 --> 00:26:40,120
melech will subsequently return our

632
00:26:38,560 --> 00:26:42,159
arbitrary address and with the

633
00:26:40,120 --> 00:26:44,100
appropriate application logic we can

634
00:26:42,160 --> 00:26:46,500
leverage that into our

635
00:26:44,100 --> 00:26:47,750
right what we want whenever we want in

636
00:26:46,500 --> 00:26:50,840
memory

637
00:26:47,750 --> 00:26:52,200
now Linux mitigations are generally not

638
00:26:50,840 --> 00:26:54,418
state-of-the-art

639
00:26:52,200 --> 00:26:57,390
mitigations compared to safe software on

640
00:26:54,419 --> 00:26:59,760
an iPhone and you know control flow

641
00:26:57,390 --> 00:27:02,030
hijacks which I've talked about here has

642
00:26:59,760 --> 00:27:04,770
been central to exploitation for decades

643
00:27:02,030 --> 00:27:06,660
patrol integrity quarter of dedication

644
00:27:04,770 --> 00:27:09,270
and other techniques of forcing

645
00:27:06,660 --> 00:27:11,429
exploitation techniques to continue and

646
00:27:09,270 --> 00:27:14,970
do things like data only attacks which

647
00:27:11,429 --> 00:27:16,830
is really where we are now and this of

648
00:27:14,970 --> 00:27:17,970
course raises the cost of attackers to

649
00:27:16,830 --> 00:27:22,500
succeed in memory corruption

650
00:27:17,970 --> 00:27:24,360
exploitation now the captain Mouse game

651
00:27:22,500 --> 00:27:27,840
of attack and defend has been active

652
00:27:24,360 --> 00:27:29,668
pretty much for my entire career but you

653
00:27:27,840 --> 00:27:31,918
know over that career I mean we

654
00:27:29,669 --> 00:27:33,809
certainly continue to have exploits our

655
00:27:31,919 --> 00:27:36,840
mitigations do raise the bar but

656
00:27:33,809 --> 00:27:39,418
exploitation is still very possible

657
00:27:36,840 --> 00:27:40,620
now heap exploitation is still an active

658
00:27:39,419 --> 00:27:43,590
area of research on all operating

659
00:27:40,620 --> 00:27:47,120
systems and all keep alligators still

660
00:27:43,590 --> 00:27:50,600
have weaknesses so thank you very much

661
00:27:47,120 --> 00:27:53,969
for for listening and I hope you

662
00:27:50,600 --> 00:27:56,039
everyone gain something from that and

663
00:27:53,970 --> 00:27:58,679
I'll go over the questions now but why

664
00:27:56,039 --> 00:28:01,980
headset has just my headphones have just

665
00:27:58,679 --> 00:28:08,250
ran out of charge so I might have to

666
00:28:01,980 --> 00:28:12,030
take them on the track perhaps oh that's

667
00:28:08,250 --> 00:28:21,120
uh I was awesome again like I mentioned

668
00:28:12,030 --> 00:28:24,870
before Sylvia Sylvia does do a lot of

669
00:28:21,120 --> 00:28:28,350
this stuff in his trainings as well also

670
00:28:24,870 --> 00:28:30,989
b-sides camera this weekend was supposed

671
00:28:28,350 --> 00:28:37,879
to be this weekend and so here his has

672
00:28:30,990 --> 00:28:37,880
come and joined us here to do this and

