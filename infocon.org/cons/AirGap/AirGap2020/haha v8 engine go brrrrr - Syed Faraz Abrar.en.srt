1
00:00:00,000 --> 00:00:06,109
cool so yeah this is gonna be a talk on

2
00:00:02,850 --> 00:00:08,429
v8 which is Chrome's JavaScript engine

3
00:00:06,109 --> 00:00:10,980
so yeah I guess I'll just start off with

4
00:00:08,429 --> 00:00:12,990
a little bit about myself first so yeah

5
00:00:10,980 --> 00:00:15,719
I am a cybersecurity undergraduate and

6
00:00:12,990 --> 00:00:23,910
Curtin University I work as a security

7
00:00:15,719 --> 00:00:25,740
researcher at Pun oh sorry wrong yeah no

8
00:00:23,910 --> 00:00:27,480
worries okay so yeah I work as a

9
00:00:25,740 --> 00:00:29,848
security researcher at Oulton which is

10
00:00:27,480 --> 00:00:32,369
an IT security firm based in Melbourne

11
00:00:29,849 --> 00:00:34,739
in Australia and my current research

12
00:00:32,369 --> 00:00:36,360
focuses are in Chrome

13
00:00:34,739 --> 00:00:40,260
specifically the JavaScript engine but

14
00:00:36,360 --> 00:00:42,329
hopefully more in the future yeah and my

15
00:00:40,260 --> 00:00:44,339
twitter is on the bottom left it's got

16
00:00:42,329 --> 00:00:46,680
that symbol like that still think I used

17
00:00:44,340 --> 00:00:48,539
everywhere but um yeah so I guess I'll

18
00:00:46,680 --> 00:00:51,660
get into a little bit of an overview on

19
00:00:48,539 --> 00:00:53,670
what the talk is gonna be about so it's

20
00:00:51,660 --> 00:00:55,769
up first thing I'm gonna cover is some

21
00:00:53,670 --> 00:00:57,870
background information on browsers and

22
00:00:55,770 --> 00:01:00,030
sandboxing in general specifically for

23
00:00:57,870 --> 00:01:01,739
modern browsers then I'm gonna get into

24
00:01:00,030 --> 00:01:03,809
some internals of a couple of v8

25
00:01:01,739 --> 00:01:05,640
components specifically I believe three

26
00:01:03,809 --> 00:01:07,890
components because I don't have like I

27
00:01:05,640 --> 00:01:10,080
can't cover every single component of v8

28
00:01:07,890 --> 00:01:12,510
there's just way too many it take days

29
00:01:10,080 --> 00:01:14,939
to cover all of them so yeah it's just a

30
00:01:12,510 --> 00:01:16,799
couple and hopefully it motivates all of

31
00:01:14,939 --> 00:01:18,149
you guys that are watching to continue

32
00:01:16,799 --> 00:01:20,570
on with research into more of the

33
00:01:18,150 --> 00:01:22,770
components um then I'm gonna move into

34
00:01:20,570 --> 00:01:24,720
analysis of a vulnerability for each of

35
00:01:22,770 --> 00:01:27,420
them I have two vulnerabilities because

36
00:01:24,720 --> 00:01:30,110
two of the components are sort of

37
00:01:27,420 --> 00:01:33,360
connected together but yeah these

38
00:01:30,110 --> 00:01:35,130
analysis analysis I guess will be

39
00:01:33,360 --> 00:01:38,400
focusing on the bug hunting aspect of it

40
00:01:35,130 --> 00:01:39,630
not exploitation because I just won't

41
00:01:38,400 --> 00:01:41,100
have enough time to get into the

42
00:01:39,630 --> 00:01:42,780
exploitation side of things because

43
00:01:41,100 --> 00:01:46,649
exploitation is just another whole

44
00:01:42,780 --> 00:01:48,899
another beast so yeah finally I'll end

45
00:01:46,649 --> 00:01:51,240
it off with some tips on approaching v8

46
00:01:48,899 --> 00:01:53,729
research yourself just you know is it

47
00:01:51,240 --> 00:01:55,339
getting started guide sort of this is

48
00:01:53,729 --> 00:01:58,619
this isn't gonna be perfect it's just

49
00:01:55,340 --> 00:02:00,390
the way I went about starting my

50
00:01:58,619 --> 00:02:03,810
research into v8 so yeah hopefully it

51
00:02:00,390 --> 00:02:06,719
helps people out yeah sure let just get

52
00:02:03,810 --> 00:02:10,199
right into it then starting off let's

53
00:02:06,719 --> 00:02:11,459
talk about how wait is this I'll just

54
00:02:10,199 --> 00:02:13,829
move this out of the way I'm not sure if

55
00:02:11,459 --> 00:02:17,970
that's visible yeah

56
00:02:13,830 --> 00:02:19,710
so sorry sir um let's let's talk about

57
00:02:17,970 --> 00:02:22,290
how modern browsers are composed stuff

58
00:02:19,710 --> 00:02:25,590
like in the in the modern day in age so

59
00:02:22,290 --> 00:02:28,079
Firefox Chrome Safari and Microsoft edge

60
00:02:25,590 --> 00:02:30,420
they're all made of of several processes

61
00:02:28,080 --> 00:02:32,460
right so initially you have what's known

62
00:02:30,420 --> 00:02:34,920
as the broker process and this process

63
00:02:32,460 --> 00:02:36,960
has the most privileges it's also called

64
00:02:34,920 --> 00:02:38,459
the browser process or the route process

65
00:02:36,960 --> 00:02:40,410
depending on which browser you're

66
00:02:38,460 --> 00:02:42,630
talking about and essentially this

67
00:02:40,410 --> 00:02:45,260
process creates all other target

68
00:02:42,630 --> 00:02:47,370
processes and it controls what

69
00:02:45,260 --> 00:02:49,700
privileges the other target processes

70
00:02:47,370 --> 00:02:51,930
get these target processes are

71
00:02:49,700 --> 00:02:55,709
considered untrusted by default because

72
00:02:51,930 --> 00:02:57,930
they handle on untrusted user input most

73
00:02:55,709 --> 00:03:00,720
of the time and these target processes

74
00:02:57,930 --> 00:03:02,370
can be anything the most common ones

75
00:03:00,720 --> 00:03:04,709
that you may have heard of are the

76
00:03:02,370 --> 00:03:06,840
renderer processes which run for each

77
00:03:04,709 --> 00:03:08,310
tab that you have open so for each tab

78
00:03:06,840 --> 00:03:10,680
you have open you have one renderer

79
00:03:08,310 --> 00:03:13,050
process rendering the screen GPU

80
00:03:10,680 --> 00:03:14,640
processes which the GPU and DRM

81
00:03:13,050 --> 00:03:17,130
processes both work with the renderer

82
00:03:14,640 --> 00:03:19,140
process together to output things to

83
00:03:17,130 --> 00:03:22,829
your screen and the renderer process

84
00:03:19,140 --> 00:03:24,750
specifically here deals with untrusted

85
00:03:22,830 --> 00:03:26,550
user input right so JavaScript code that

86
00:03:24,750 --> 00:03:29,070
runs on any arbitrary websites that you

87
00:03:26,550 --> 00:03:30,540
visit the same with HTML and CSS Dom

88
00:03:29,070 --> 00:03:35,250
elements things of that nature so

89
00:03:30,540 --> 00:03:37,230
because of their untrusted nature all of

90
00:03:35,250 --> 00:03:39,959
these target processes that get created

91
00:03:37,230 --> 00:03:42,450
renderer processes in this case are all

92
00:03:39,959 --> 00:03:45,209
sandbox right and all communication

93
00:03:42,450 --> 00:03:46,589
between processes and between mostly

94
00:03:45,209 --> 00:03:48,810
between the broker process and the

95
00:03:46,590 --> 00:03:52,410
target processes are done through IPC or

96
00:03:48,810 --> 00:03:55,110
inter inter process communication so IPC

97
00:03:52,410 --> 00:03:56,670
calls happen between the processes child

98
00:03:55,110 --> 00:03:59,340
courses are always sandbox as I

99
00:03:56,670 --> 00:04:02,130
explained so I'll just show an example

100
00:03:59,340 --> 00:04:04,860
of what it looks like so I just have on

101
00:04:02,130 --> 00:04:06,600
my machine I use Firefox so Firefox so

102
00:04:04,860 --> 00:04:08,850
you can see this multiple processes open

103
00:04:06,600 --> 00:04:11,430
the process at the top that says Firefox

104
00:04:08,850 --> 00:04:13,079
6 is the broker process and all the

105
00:04:11,430 --> 00:04:15,330
other sub processes that it is created

106
00:04:13,080 --> 00:04:18,180
are probably in a renderer processes GPU

107
00:04:15,330 --> 00:04:20,130
processes Network processes etc etc

108
00:04:18,180 --> 00:04:22,890
right so this is how the multi-process

109
00:04:20,130 --> 00:04:24,450
architecture looks like now I talked

110
00:04:22,890 --> 00:04:26,310
about sandboxing a little bit but what

111
00:04:24,450 --> 00:04:27,360
does it mean for a process to be sandbox

112
00:04:26,310 --> 00:04:29,430
right

113
00:04:27,360 --> 00:04:31,409
sandbox purchases have a number of

114
00:04:29,430 --> 00:04:32,970
different restrictions they cannot

115
00:04:31,409 --> 00:04:34,949
access the file system they cannot

116
00:04:32,970 --> 00:04:36,800
perform arbitrary system calls they

117
00:04:34,949 --> 00:04:38,789
cannot create more child processes and

118
00:04:36,800 --> 00:04:40,520
there's a bunch of other restrictions

119
00:04:38,789 --> 00:04:43,969
that they have but those are generally

120
00:04:40,520 --> 00:04:45,990
the common the most common ones

121
00:04:43,969 --> 00:04:48,150
sandboxing is implemented differently in

122
00:04:45,990 --> 00:04:50,460
Windows and Linux so on Windows you have

123
00:04:48,150 --> 00:04:52,258
what's known as restricted tokens job

124
00:04:50,460 --> 00:04:54,090
objects they stop objects and integrity

125
00:04:52,259 --> 00:04:56,310
levels and these are what the Windows

126
00:04:54,090 --> 00:04:58,318
chromium sandbox uses to sandbox its

127
00:04:56,310 --> 00:05:00,990
target processes whereas on Linux you

128
00:04:58,319 --> 00:05:02,340
have second PPF in the kernel namespaces

129
00:05:00,990 --> 00:05:06,449
set UID sandbox

130
00:05:02,340 --> 00:05:08,609
selinux and a Barmer so essentially what

131
00:05:06,449 --> 00:05:10,860
happens is the browser process

132
00:05:08,610 --> 00:05:13,620
intercepts all system calls and all

133
00:05:10,860 --> 00:05:15,539
requests made by the sandbox vs. and

134
00:05:13,620 --> 00:05:18,719
then handles them manually right so if

135
00:05:15,539 --> 00:05:20,789
sandbox versus makes a request or a

136
00:05:18,719 --> 00:05:22,889
system call that's banned or being

137
00:05:20,789 --> 00:05:25,139
blacklisted the browser process will

138
00:05:22,889 --> 00:05:27,090
just deny and either cause the target

139
00:05:25,139 --> 00:05:28,830
process to crash or just not do anything

140
00:05:27,090 --> 00:05:30,779
just let it know that nothing happened

141
00:05:28,830 --> 00:05:33,120
or the browser of course is gonna take

142
00:05:30,779 --> 00:05:34,949
over it's gonna do the system call or

143
00:05:33,120 --> 00:05:37,680
the request on behalf of the target

144
00:05:34,949 --> 00:05:39,000
process and then it'll move on and it

145
00:05:37,680 --> 00:05:41,069
will return the value to the target

146
00:05:39,000 --> 00:05:43,139
process or return whatever result it

147
00:05:41,069 --> 00:05:45,240
gets target process so the target

148
00:05:43,139 --> 00:05:47,339
process can then use it that's how the

149
00:05:45,240 --> 00:05:50,009
target process eve target processes even

150
00:05:47,339 --> 00:05:51,659
though their sandbox they can still do

151
00:05:50,009 --> 00:05:53,190
things otherwise you know they would

152
00:05:51,659 --> 00:05:55,020
just not be able to do anything if they

153
00:05:53,190 --> 00:05:58,440
can't you know do any sis calls or

154
00:05:55,020 --> 00:06:00,120
access the file system etc alright but

155
00:05:58,440 --> 00:06:02,580
you know that's that's as far as I'll

156
00:06:00,120 --> 00:06:04,979
get into sandboxing and chrome itself

157
00:06:02,580 --> 00:06:07,409
because this talk isn't about sandboxing

158
00:06:04,979 --> 00:06:10,560
or chrome it's more so about v8 all

159
00:06:07,409 --> 00:06:13,409
right so let's just look at why we want

160
00:06:10,560 --> 00:06:15,960
to attack v8 first the end goal is to

161
00:06:13,409 --> 00:06:17,400
always exploit the chrome Broker process

162
00:06:15,960 --> 00:06:20,339
right because as I said the broker

163
00:06:17,400 --> 00:06:22,529
process has the most privileges you can

164
00:06:20,339 --> 00:06:24,750
gain code execution in any target

165
00:06:22,529 --> 00:06:26,159
process but since they're sandbox you

166
00:06:24,750 --> 00:06:27,509
just you won't be able to get a shell

167
00:06:26,159 --> 00:06:30,330
you won't be able to access the file

168
00:06:27,509 --> 00:06:32,400
system it's just useless right but what

169
00:06:30,330 --> 00:06:35,099
we do know is that the target process

170
00:06:32,400 --> 00:06:37,709
can talk to the broker process through

171
00:06:35,099 --> 00:06:40,110
IPC the target process can also make

172
00:06:37,709 --> 00:06:40,910
some sis calls so to the kernel you can

173
00:06:40,110 --> 00:06:42,740
talk to the colonel

174
00:06:40,910 --> 00:06:44,180
in that way and if you can find a

175
00:06:42,740 --> 00:06:46,520
vulnerability in those syscalls

176
00:06:44,180 --> 00:06:50,120
you can also attack the kernel after you

177
00:06:46,520 --> 00:06:52,070
exploit a target process so the general

178
00:06:50,120 --> 00:06:54,860
gist of things here is that you need

179
00:06:52,070 --> 00:06:57,110
multiple vulnerabilities to actually

180
00:06:54,860 --> 00:06:58,580
gain code execution or gain enough code

181
00:06:57,110 --> 00:07:03,710
execution where you have a shell on

182
00:06:58,580 --> 00:07:05,659
another machine so usually the the the

183
00:07:03,710 --> 00:07:07,729
process or the target process that gets

184
00:07:05,660 --> 00:07:10,600
attacked first is the rendering process

185
00:07:07,730 --> 00:07:13,340
because of how exposed it is and how

186
00:07:10,600 --> 00:07:15,320
easy it is to gain primitives through

187
00:07:13,340 --> 00:07:17,929
JavaScript right because JavaScript is a

188
00:07:15,320 --> 00:07:19,670
it's it's a whole language by itself you

189
00:07:17,930 --> 00:07:23,300
can do heap sprays by creating new

190
00:07:19,670 --> 00:07:25,580
objects you can you can just read from

191
00:07:23,300 --> 00:07:26,900
memory right to memory if it's just with

192
00:07:25,580 --> 00:07:28,609
JavaScript you can do a lot of different

193
00:07:26,900 --> 00:07:30,109
things and the renderer process just

194
00:07:28,610 --> 00:07:31,880
happens to be one of the most exposed

195
00:07:30,110 --> 00:07:33,560
ones all you need to do is host your

196
00:07:31,880 --> 00:07:35,150
JavaScript code on the website and get

197
00:07:33,560 --> 00:07:36,830
your victim to visit your website and

198
00:07:35,150 --> 00:07:40,190
that's it you can hone them if you have

199
00:07:36,830 --> 00:07:41,780
a vulnerability so v8 is as I said

200
00:07:40,190 --> 00:07:44,510
Chrome's JavaScript engine and it runs

201
00:07:41,780 --> 00:07:46,609
within every single renderer process the

202
00:07:44,510 --> 00:07:48,110
enormous complexity of v8 means that it

203
00:07:46,610 --> 00:07:49,790
contains entirely new and unique

204
00:07:48,110 --> 00:07:51,230
vulnerability classes this is something

205
00:07:49,790 --> 00:07:54,500
that was put on the description of the

206
00:07:51,230 --> 00:07:56,120
talk before on air gaps website that

207
00:07:54,500 --> 00:07:58,370
you're generally speaking out you'll see

208
00:07:56,120 --> 00:08:00,200
one vulnerability that I'll analyze the

209
00:07:58,370 --> 00:08:02,840
second one more specifically that is

210
00:08:00,200 --> 00:08:04,700
hold phoner ability cost by itself and I

211
00:08:02,840 --> 00:08:06,760
think that's really cool so yeah well

212
00:08:04,700 --> 00:08:09,920
look at that when we get to it right

213
00:08:06,760 --> 00:08:13,430
before we get on to it though I have to

214
00:08:09,920 --> 00:08:16,910
explain some internals about the v8 heap

215
00:08:13,430 --> 00:08:20,120
and how v8 deals with objects and values

216
00:08:16,910 --> 00:08:23,900
within the heap right so the VI heap is

217
00:08:20,120 --> 00:08:25,070
a compressed heap in x86 64 I don't know

218
00:08:23,900 --> 00:08:27,320
about any of the other architectures

219
00:08:25,070 --> 00:08:29,599
because I've done my research on x86 64

220
00:08:27,320 --> 00:08:31,099
so I'm not going to comment on those but

221
00:08:29,600 --> 00:08:33,169
essentially what a compressed heat means

222
00:08:31,100 --> 00:08:35,599
is that all pointers are stored as

223
00:08:33,169 --> 00:08:37,280
32-bit addresses now you might be

224
00:08:35,599 --> 00:08:40,160
wondering how is that possible because

225
00:08:37,280 --> 00:08:42,199
in 64-bit architectures the address

226
00:08:40,159 --> 00:08:45,620
space is also going to be 64-bit right

227
00:08:42,200 --> 00:08:47,780
so v8 does this pretty well actually so

228
00:08:45,620 --> 00:08:49,940
the way they do it is they store the

229
00:08:47,780 --> 00:08:52,819
base address of the heap memory region

230
00:08:49,940 --> 00:08:54,050
within the r-13 register and they call

231
00:08:52,820 --> 00:08:56,240
this register the route

232
00:08:54,050 --> 00:09:00,019
right so it just stores the root address

233
00:08:56,240 --> 00:09:01,880
of the heat now anytime a pointer needs

234
00:09:00,019 --> 00:09:04,310
to be dereference since the point is uh

235
00:09:01,880 --> 00:09:05,750
pretty two-bit what they do is they get

236
00:09:04,310 --> 00:09:07,459
that base address out of the root

237
00:09:05,750 --> 00:09:10,310
register add it to the corner and then

238
00:09:07,459 --> 00:09:13,729
dereference it now this might seem like

239
00:09:10,310 --> 00:09:15,800
it's useless but it's actually not v8 or

240
00:09:13,730 --> 00:09:18,190
Google themselves have made a bunch of

241
00:09:15,800 --> 00:09:20,779
blog post actually two blog posts

242
00:09:18,190 --> 00:09:21,920
detailing how they've done this and how

243
00:09:20,779 --> 00:09:24,769
much performance improvement they've

244
00:09:21,920 --> 00:09:28,130
done so this is how the aiib actually

245
00:09:24,769 --> 00:09:29,899
works so let's look at how values and

246
00:09:28,130 --> 00:09:32,360
objects are represented within the heap

247
00:09:29,899 --> 00:09:34,130
right so VA uses a technique called

248
00:09:32,360 --> 00:09:36,680
pointer tagging to distinguish between

249
00:09:34,130 --> 00:09:38,510
heap pointers and small integers these

250
00:09:36,680 --> 00:09:40,819
are the only two types of values you'll

251
00:09:38,510 --> 00:09:44,510
see within the heap directly you might

252
00:09:40,820 --> 00:09:46,730
see floats like 64 bit doubles within

253
00:09:44,510 --> 00:09:48,380
race for example but within the heat

254
00:09:46,730 --> 00:09:52,579
directly you only ever have either

255
00:09:48,380 --> 00:09:54,079
pointers or small integers so these two

256
00:09:52,579 --> 00:09:55,880
types of these are the two types of

257
00:09:54,079 --> 00:09:58,819
representations so a small integer is

258
00:09:55,880 --> 00:10:00,439
called a semi in v8 terminology and the

259
00:09:58,820 --> 00:10:03,079
heat point is called a Hebe object right

260
00:10:00,440 --> 00:10:06,079
so what they look like in memory you can

261
00:10:03,079 --> 00:10:07,670
find this in the source objects object

262
00:10:06,079 --> 00:10:08,920
our header of just on H header file

263
00:10:07,670 --> 00:10:11,930
within in v8

264
00:10:08,920 --> 00:10:14,779
essentially as me is going to be a 31

265
00:10:11,930 --> 00:10:16,640
bit signed integer followed by a 0 and a

266
00:10:14,779 --> 00:10:18,680
heap object is going to be a 32 bit

267
00:10:16,640 --> 00:10:22,339
direct pointer which is for byte aligned

268
00:10:18,680 --> 00:10:24,109
so the last bit if a memory address is

269
00:10:22,339 --> 00:10:26,600
four by line the last bit will always be

270
00:10:24,110 --> 00:10:29,690
0 no matter what because of this a heap

271
00:10:26,600 --> 00:10:31,399
objects last bit is used to denote that

272
00:10:29,690 --> 00:10:33,290
it's heap object by setting it to one

273
00:10:31,399 --> 00:10:35,959
right so you can see in the in the

274
00:10:33,290 --> 00:10:37,459
comment there the bottom line it says

275
00:10:35,959 --> 00:10:40,459
you know it's a 32-bit direct pointer

276
00:10:37,459 --> 00:10:43,130
with the last bits set to one so yeah so

277
00:10:40,459 --> 00:10:44,839
just to clarify again to know the

278
00:10:43,130 --> 00:10:47,180
difference between us me and the heap

279
00:10:44,839 --> 00:10:49,399
object all you have to do is then look

280
00:10:47,180 --> 00:10:51,500
at the last bit of whatever value you

281
00:10:49,399 --> 00:10:53,899
find on the heap if it's a zero it's as

282
00:10:51,500 --> 00:10:56,360
me if it's a one it's a pointer so this

283
00:10:53,899 --> 00:10:57,320
is how v8 distinguishes between these

284
00:10:56,360 --> 00:11:02,240
two types of values

285
00:10:57,320 --> 00:11:05,000
now we'll get right into what a v8 sort

286
00:11:02,240 --> 00:11:07,490
of pipeline looks like I guess so the VA

287
00:11:05,000 --> 00:11:09,589
pipe I'm sort of works like this right

288
00:11:07,490 --> 00:11:11,779
we take your JavaScript you parse it

289
00:11:09,589 --> 00:11:14,270
turn it to an abstract syntax tree

290
00:11:11,779 --> 00:11:17,180
generate byte code for it and then it

291
00:11:14,270 --> 00:11:19,399
runs right and while it runs v8 or more

292
00:11:17,180 --> 00:11:22,069
specifically its optimizing JIT compiler

293
00:11:19,399 --> 00:11:24,200
gets type feedback for speculative

294
00:11:22,070 --> 00:11:25,640
optimizations so with type feedback what

295
00:11:24,200 --> 00:11:28,490
it does it makes assumptions regarding

296
00:11:25,640 --> 00:11:30,439
what types had seen and it has to do

297
00:11:28,490 --> 00:11:32,480
this because again JavaScript is not a

298
00:11:30,440 --> 00:11:33,950
typed language so there are no types in

299
00:11:32,480 --> 00:11:35,990
JavaScript well there are but

300
00:11:33,950 --> 00:11:38,089
technically there aren't right sir it

301
00:11:35,990 --> 00:11:40,760
gains this feedback from multiple

302
00:11:38,089 --> 00:11:42,890
executions of functions and then it uses

303
00:11:40,760 --> 00:11:44,959
the feedback to optimize or to produce

304
00:11:42,890 --> 00:11:47,510
optimized machine code which runs away

305
00:11:44,959 --> 00:11:50,449
faster right so that's how essentially

306
00:11:47,510 --> 00:11:53,029
the pipeline works and in this specific

307
00:11:50,450 --> 00:11:55,580
case or in this talk I guess I'm only

308
00:11:53,029 --> 00:11:56,839
going to cover the parser and actually

309
00:11:55,580 --> 00:11:58,250
gonna cover all of it anyway so yeah

310
00:11:56,839 --> 00:12:00,529
we'll just yeah we'll just get right

311
00:11:58,250 --> 00:12:03,589
into it so to start off with the parser

312
00:12:00,529 --> 00:12:05,540
right so the with the parser what

313
00:12:03,589 --> 00:12:07,550
happens is initially your JavaScript

314
00:12:05,540 --> 00:12:10,069
code comes in from the network as utf-8

315
00:12:07,550 --> 00:12:13,099
encoded text those parsers stream

316
00:12:10,070 --> 00:12:14,779
converts this to utf-16 encoded text and

317
00:12:13,100 --> 00:12:16,310
the reason it does this is because

318
00:12:14,779 --> 00:12:18,709
utf-16 is easier to deal with when

319
00:12:16,310 --> 00:12:21,199
tokenizing I don't know exactly why but

320
00:12:18,709 --> 00:12:25,219
that's what it does this utf-16 code

321
00:12:21,200 --> 00:12:27,079
text is then sent to the parser scanner

322
00:12:25,220 --> 00:12:30,470
and the scanner is going to tokenize

323
00:12:27,079 --> 00:12:32,750
this code right that the tokens that the

324
00:12:30,470 --> 00:12:34,910
scanner produces is initially sent to

325
00:12:32,750 --> 00:12:37,190
the pre parser and the pre parser does

326
00:12:34,910 --> 00:12:38,870
what's called lazy parsing so lazy

327
00:12:37,190 --> 00:12:41,810
parsing is essentially where the pre

328
00:12:38,870 --> 00:12:43,700
parser skips over all functions it will

329
00:12:41,810 --> 00:12:44,930
it skips over them but it does make sure

330
00:12:43,700 --> 00:12:47,209
that the functions themselves are

331
00:12:44,930 --> 00:12:49,760
syntactically valid and it stores some

332
00:12:47,209 --> 00:12:51,949
information for the parser later on to

333
00:12:49,760 --> 00:12:54,680
have an easier time parsing the function

334
00:12:51,950 --> 00:12:57,860
themselves the parser on the other hand

335
00:12:54,680 --> 00:12:59,930
will simply there's a typo in the slide

336
00:12:57,860 --> 00:13:02,149
will it'll convert this code into an

337
00:12:59,930 --> 00:13:03,349
abstract syntax tree the parser might

338
00:13:02,149 --> 00:13:05,510
also parse functions that were

339
00:13:03,350 --> 00:13:07,820
previously pre parse if they are now

340
00:13:05,510 --> 00:13:09,950
required to run so essentially what the

341
00:13:07,820 --> 00:13:13,399
pre parser is doing here is reducing the

342
00:13:09,950 --> 00:13:15,380
time between parsing to execution right

343
00:13:13,399 --> 00:13:17,540
so if a function is not immediately

344
00:13:15,380 --> 00:13:19,520
being run there's no reason to parse it

345
00:13:17,540 --> 00:13:21,050
right you can skip past it until it's

346
00:13:19,520 --> 00:13:23,510
actually meeting to run that

347
00:13:21,050 --> 00:13:25,550
when you can parse it so yeah this is

348
00:13:23,510 --> 00:13:29,510
this speeds up execution of the engine

349
00:13:25,550 --> 00:13:32,089
by a lot apparently sir next one would

350
00:13:29,510 --> 00:13:33,950
be abstract syntax tree created it gets

351
00:13:32,089 --> 00:13:36,470
passed into ignition which is v8

352
00:13:33,950 --> 00:13:38,149
bytecode compiler slash interpreter it's

353
00:13:36,470 --> 00:13:40,100
cold it's a little confusing

354
00:13:38,149 --> 00:13:42,440
because it has the same name but either

355
00:13:40,100 --> 00:13:45,800
way the ignition compiler first compiles

356
00:13:42,440 --> 00:13:47,720
this ast into bytecode and the ignition

357
00:13:45,800 --> 00:13:50,180
interpreter then executes this bytecode

358
00:13:47,720 --> 00:13:52,670
and before we move on to how the

359
00:13:50,180 --> 00:13:54,019
ignition interpreter slash compiler work

360
00:13:52,670 --> 00:13:55,699
I'm gonna actually look at a

361
00:13:54,019 --> 00:13:57,680
vulnerability that was found within the

362
00:13:55,700 --> 00:14:00,470
parser itself and I think this is

363
00:13:57,680 --> 00:14:03,199
important because parser is again it's

364
00:14:00,470 --> 00:14:05,329
it's the first line of defense if you

365
00:14:03,200 --> 00:14:08,510
will within the engine it's the first

366
00:14:05,329 --> 00:14:10,459
place any code goes and because of this

367
00:14:08,510 --> 00:14:12,470
a lot of people think well parser bugs

368
00:14:10,459 --> 00:14:13,729
have been found already this gonna be

369
00:14:12,470 --> 00:14:15,920
it's gonna be hard to find any new

370
00:14:13,730 --> 00:14:17,329
partial bugs and so no one looks at it

371
00:14:15,920 --> 00:14:19,069
right it's just the classic you know

372
00:14:17,329 --> 00:14:21,170
everyone's supposed to be looking at it

373
00:14:19,070 --> 00:14:23,570
therefore almost looking at it so this

374
00:14:21,170 --> 00:14:26,569
isn't this is a vulnerability from late

375
00:14:23,570 --> 00:14:28,700
to 2019 found by Dimitri Forney of Blue

376
00:14:26,570 --> 00:14:30,170
Cross security it's just a simple did

377
00:14:28,700 --> 00:14:31,850
your overflow this isn't that unique

378
00:14:30,170 --> 00:14:33,709
vulnerability class that's for the next

379
00:14:31,850 --> 00:14:36,050
vulnerability but I just wanted to show

380
00:14:33,709 --> 00:14:37,699
this just you know showcase that even

381
00:14:36,050 --> 00:14:40,130
though this is a parser it's the first

382
00:14:37,700 --> 00:14:41,120
thing that anyone might look at no one

383
00:14:40,130 --> 00:14:44,209
actually looks at it because this

384
00:14:41,120 --> 00:14:45,980
vulnerability is very easy to spot so at

385
00:14:44,209 --> 00:14:48,500
the beginning what happens is the

386
00:14:45,980 --> 00:14:50,959
scanner scan method starts off by

387
00:14:48,500 --> 00:14:52,730
calling scanner scan single token to

388
00:14:50,959 --> 00:14:54,770
read in a single token from whatever

389
00:14:52,730 --> 00:14:57,380
JavaScript code you have from the sorry

390
00:14:54,770 --> 00:15:01,069
the utf-16 encoded text code that you

391
00:14:57,380 --> 00:15:03,050
have this scan single token has a lot of

392
00:15:01,070 --> 00:15:05,630
different cases that has to handle

393
00:15:03,050 --> 00:15:07,069
so in this vulnerability skates the

394
00:15:05,630 --> 00:15:09,110
vulnerability lies in the case that

395
00:15:07,070 --> 00:15:11,930
handled strings so with a string for

396
00:15:09,110 --> 00:15:14,029
example it might read a starting double

397
00:15:11,930 --> 00:15:16,550
quote or a single code and what it would

398
00:15:14,029 --> 00:15:20,120
do is it would continuously you know

399
00:15:16,550 --> 00:15:21,979
read text until it finds an ending

400
00:15:20,120 --> 00:15:23,810
double quote a single quote right so

401
00:15:21,980 --> 00:15:25,790
taking the string as an example we get

402
00:15:23,810 --> 00:15:27,680
the following sort of call stack so scan

403
00:15:25,790 --> 00:15:30,410
call scan single token which called scan

404
00:15:27,680 --> 00:15:33,079
string which ends up calling add literal

405
00:15:30,410 --> 00:15:34,400
char so each character of the string in

406
00:15:33,079 --> 00:15:35,839
a loop right so

407
00:15:34,400 --> 00:15:38,630
dysfunctional loop and this function

408
00:15:35,840 --> 00:15:40,760
calls literal buffers at char which in

409
00:15:38,630 --> 00:15:42,439
turn calls little buffers at two bytes

410
00:15:40,760 --> 00:15:44,060
sharp this isn't important that this

411
00:15:42,440 --> 00:15:45,380
call stack isn't important but add two

412
00:15:44,060 --> 00:15:47,719
by char is important

413
00:15:45,380 --> 00:15:52,610
so within add to my chart we have this

414
00:15:47,720 --> 00:15:55,760
set of code and this code is basically

415
00:15:52,610 --> 00:15:57,410
reading each byte or every two bytes

416
00:15:55,760 --> 00:15:59,660
from the utf-16 encoded code which

417
00:15:57,410 --> 00:16:03,230
translates the one character and it

418
00:15:59,660 --> 00:16:05,270
stores this the this these two bytes

419
00:16:03,230 --> 00:16:07,400
within a backing store right so the the

420
00:16:05,270 --> 00:16:09,740
errors point to the line where the

421
00:16:07,400 --> 00:16:12,140
backing store is being expanded when it

422
00:16:09,740 --> 00:16:14,690
doesn't have enough space to store more

423
00:16:12,140 --> 00:16:15,920
characters right so when the backing

424
00:16:14,690 --> 00:16:19,790
store needs to be expanded for more

425
00:16:15,920 --> 00:16:21,620
characters because again the the the

426
00:16:19,790 --> 00:16:22,939
string can have an arbitrary length

427
00:16:21,620 --> 00:16:24,680
right it can have an arbitrary number of

428
00:16:22,940 --> 00:16:26,150
characters if the backing store needs to

429
00:16:24,680 --> 00:16:27,890
be expanded it makes a call to this

430
00:16:26,150 --> 00:16:30,490
function called expand buffer

431
00:16:27,890 --> 00:16:33,530
now what expand buffer does is it

432
00:16:30,490 --> 00:16:35,540
initially creates a new vector and this

433
00:16:33,530 --> 00:16:37,790
vector isn't actually C++ a standard

434
00:16:35,540 --> 00:16:40,640
library vector it's a vector created

435
00:16:37,790 --> 00:16:43,520
specifically for v8 this vector is going

436
00:16:40,640 --> 00:16:46,520
to or this new vector is going to have a

437
00:16:43,520 --> 00:16:48,170
capacity equal to a function called new

438
00:16:46,520 --> 00:16:50,270
capacity or the return value of a

439
00:16:48,170 --> 00:16:52,880
function called new capacity with its

440
00:16:50,270 --> 00:16:56,240
arguments at the K initial capacity now

441
00:16:52,880 --> 00:16:59,240
K initial capacity is equal to 16 so

442
00:16:56,240 --> 00:17:00,890
when new capacity is called what's gonna

443
00:16:59,240 --> 00:17:03,560
happen is within new capacity you can

444
00:17:00,890 --> 00:17:07,280
see when it's trying to calculate new

445
00:17:03,560 --> 00:17:09,379
capacity it's going to either it's going

446
00:17:07,280 --> 00:17:11,300
to pick the minimum between the left

447
00:17:09,380 --> 00:17:13,400
which is capacity multiplied by K growth

448
00:17:11,300 --> 00:17:16,310
factor or the right which is capacity

449
00:17:13,400 --> 00:17:17,990
plus max K max growth now capacity

450
00:17:16,310 --> 00:17:20,300
before this the in the second line is

451
00:17:17,990 --> 00:17:21,650
set to either min capacity or the length

452
00:17:20,300 --> 00:17:24,530
of the backing store whichever is

453
00:17:21,650 --> 00:17:25,910
greater now in our case we let's just

454
00:17:24,530 --> 00:17:29,030
say that the string is greater than

455
00:17:25,910 --> 00:17:31,280
length 16 right what if the string is

456
00:17:29,030 --> 00:17:34,160
later greater than Len 16 it means we

457
00:17:31,280 --> 00:17:36,410
have control over the capacity variable

458
00:17:34,160 --> 00:17:38,360
and because we know that capacity is an

459
00:17:36,410 --> 00:17:40,490
integer it's a sign integer so its

460
00:17:38,360 --> 00:17:43,729
maximum value can be 2 to the power 31

461
00:17:40,490 --> 00:17:45,980
take 1 we can cause this to overflow and

462
00:17:43,730 --> 00:17:47,990
when it over or this multiplication is

463
00:17:45,980 --> 00:17:50,750
more specifically to overflow and

464
00:17:47,990 --> 00:17:53,710
be even though it would be greater than

465
00:17:50,750 --> 00:17:56,270
capacity plus K max growth in this case

466
00:17:53,710 --> 00:17:58,970
the overflow would make it so that it's

467
00:17:56,270 --> 00:18:01,158
less right and so what would happen so

468
00:17:58,970 --> 00:18:03,200
what happens if capacity multiplied by K

469
00:18:01,159 --> 00:18:05,510
growth factor overflows and becomes less

470
00:18:03,200 --> 00:18:07,970
than K max capacity plus K max growth

471
00:18:05,510 --> 00:18:10,640
well in order to understand this we have

472
00:18:07,970 --> 00:18:12,500
to look at how this vector gets created

473
00:18:10,640 --> 00:18:14,419
and without going into too much detail

474
00:18:12,500 --> 00:18:16,610
I'm just going to show you the length

475
00:18:14,419 --> 00:18:18,649
function of the vector within the Len

476
00:18:16,610 --> 00:18:20,750
function it does a max length check and

477
00:18:18,649 --> 00:18:22,340
in the max length check it makes sure

478
00:18:20,750 --> 00:18:25,220
that the length of the vector cannot

479
00:18:22,340 --> 00:18:27,408
exceed the maximum limit of a signed

480
00:18:25,220 --> 00:18:28,190
integer which again is 2 to the power 31

481
00:18:27,409 --> 00:18:31,820
take 1

482
00:18:28,190 --> 00:18:35,390
so if for example in in our previous

483
00:18:31,820 --> 00:18:37,340
code if the value overflows and new

484
00:18:35,390 --> 00:18:39,020
capacity becomes a negative number the

485
00:18:37,340 --> 00:18:41,658
negative number would still be

486
00:18:39,020 --> 00:18:45,470
technically greater than an unsigned

487
00:18:41,659 --> 00:18:46,940
integer that is that whose max value is

488
00:18:45,470 --> 00:18:49,580
2 to the power that you won't take 1

489
00:18:46,940 --> 00:18:53,149
right so that is why when you do this

490
00:18:49,580 --> 00:18:55,010
what might happen is well get into proof

491
00:18:53,149 --> 00:18:56,168
of concept right now actually that

492
00:18:55,010 --> 00:18:58,309
explains it

493
00:18:56,169 --> 00:19:00,440
so but in the proof of concept

494
00:18:58,309 --> 00:19:03,408
essentially what happens is s is a

495
00:19:00,440 --> 00:19:06,350
string that gets created from a 2 byte

496
00:19:03,409 --> 00:19:09,770
string of two A's or X 4141 which is two

497
00:19:06,350 --> 00:19:13,399
ways repeated X whatever that many times

498
00:19:09,770 --> 00:19:16,070
right when that happens you can see if

499
00:19:13,399 --> 00:19:18,049
capacity is going to equal two x

500
00:19:16,070 --> 00:19:20,510
whatever that number is which gives you

501
00:19:18,049 --> 00:19:23,840
whatever that number is there hex 2 0 0

502
00:19:20,510 --> 00:19:25,730
0 2 so when this happens capacity

503
00:19:23,840 --> 00:19:28,279
multiplied by K growth factor is going

504
00:19:25,730 --> 00:19:30,980
to be X 2 0 0 2 multiplied by 4 which

505
00:19:28,279 --> 00:19:33,620
gives you hex 8 0 0 8

506
00:19:30,980 --> 00:19:36,470
well capacity plus K max growth is going

507
00:19:33,620 --> 00:19:38,989
to be hex 2 as user 0 2 plus 1024 x 1024

508
00:19:36,470 --> 00:19:41,029
which equals a value much less than

509
00:19:38,990 --> 00:19:44,630
capacity multiplied by K growth factor

510
00:19:41,029 --> 00:19:46,549
but the max value of a 32-bit signed

511
00:19:44,630 --> 00:19:49,010
integer is to the part that you won't

512
00:19:46,549 --> 00:19:52,850
take one which is hex 7 f-f-f-f-f-f-f

513
00:19:49,010 --> 00:19:54,500
now hex 8 0 0 0 0 0 8 is obviously

514
00:19:52,850 --> 00:19:56,658
greater than that so it's gonna overflow

515
00:19:54,500 --> 00:19:59,450
and become a number that's smaller when

516
00:19:56,659 --> 00:20:01,490
this happens it heals a smaller value

517
00:19:59,450 --> 00:20:03,260
than the original cap capacity and

518
00:20:01,490 --> 00:20:04,970
what this is going to do in the previous

519
00:20:03,260 --> 00:20:06,770
code when the picked the new vector is

520
00:20:04,970 --> 00:20:08,390
created the new vectors capacity is

521
00:20:06,770 --> 00:20:10,820
going to be smaller than the old vectors

522
00:20:08,390 --> 00:20:13,100
capacity when this happens the mem copy

523
00:20:10,820 --> 00:20:15,559
in the second line or the third line of

524
00:20:13,100 --> 00:20:17,899
the top code block is going to copy more

525
00:20:15,559 --> 00:20:19,580
bytes into the new buffer and then it

526
00:20:17,900 --> 00:20:21,650
can store which leads into a heap

527
00:20:19,580 --> 00:20:23,990
overflow and these heap overflow is

528
00:20:21,650 --> 00:20:25,640
again it's very I'm not gonna say it's

529
00:20:23,990 --> 00:20:27,620
easy to exploit because you still have

530
00:20:25,640 --> 00:20:29,630
to find the primitives but luckily

531
00:20:27,620 --> 00:20:32,149
because it's v8 and it's complex is

532
00:20:29,630 --> 00:20:33,410
there's a lot of different objects that

533
00:20:32,150 --> 00:20:34,850
you can allocate there's a lot of

534
00:20:33,410 --> 00:20:36,050
different there's a lot of different

535
00:20:34,850 --> 00:20:38,090
things you can allocate on the heap and

536
00:20:36,050 --> 00:20:40,159
that gives you access to function

537
00:20:38,090 --> 00:20:42,139
pointers variables or just normal

538
00:20:40,160 --> 00:20:43,700
pointers to leak memory through it's

539
00:20:42,140 --> 00:20:45,260
just you can do a lot of different

540
00:20:43,700 --> 00:20:47,390
things in this specific case

541
00:20:45,260 --> 00:20:49,780
so yeah this boner ability would easily

542
00:20:47,390 --> 00:20:52,340
be exploitable you can easily just gain

543
00:20:49,780 --> 00:20:54,500
execution or code execution within the

544
00:20:52,340 --> 00:20:56,330
browser process sorry the target process

545
00:20:54,500 --> 00:20:58,970
which is the renderer process although

546
00:20:56,330 --> 00:21:00,230
it's sandbox right well yeah I just

547
00:20:58,970 --> 00:21:03,530
wanted to show cases vulnerability

548
00:21:00,230 --> 00:21:05,300
because as you can see the the integer

549
00:21:03,530 --> 00:21:06,920
overflow here is very easy to spot it's

550
00:21:05,300 --> 00:21:09,169
just capacity which is a controlled

551
00:21:06,920 --> 00:21:10,880
variable being multiplied and compared

552
00:21:09,170 --> 00:21:12,920
with capacity added with another

553
00:21:10,880 --> 00:21:14,150
variable like it's just it's just right

554
00:21:12,920 --> 00:21:15,950
there anyone could have read this code

555
00:21:14,150 --> 00:21:18,080
and spotted it but you know no one does

556
00:21:15,950 --> 00:21:20,990
except apparently this guy from blue

557
00:21:18,080 --> 00:21:23,990
from security we found it so yeah that's

558
00:21:20,990 --> 00:21:26,179
that's the vulnerability I'll just move

559
00:21:23,990 --> 00:21:28,880
on from this now and we'll have a look

560
00:21:26,179 --> 00:21:31,700
at how ignition executes the bytecode

561
00:21:28,880 --> 00:21:34,160
that it generates right so ignition is

562
00:21:31,700 --> 00:21:36,470
v8 fast low-level register base

563
00:21:34,160 --> 00:21:38,300
interpreter it takes the abstract

564
00:21:36,470 --> 00:21:40,580
abstract syntax tree generated by the

565
00:21:38,300 --> 00:21:42,470
parser and compiles it into v8 unique

566
00:21:40,580 --> 00:21:44,149
bytecode ignition has a number of

567
00:21:42,470 --> 00:21:45,950
different registers that all byte codes

568
00:21:44,150 --> 00:21:47,420
will explicitly use as inputs and

569
00:21:45,950 --> 00:21:50,660
outputs and you'll see what this means

570
00:21:47,420 --> 00:21:52,070
in the next set of slides a special

571
00:21:50,660 --> 00:21:53,900
register known as the accumulator

572
00:21:52,070 --> 00:21:55,790
register is used for calculations and

573
00:21:53,900 --> 00:22:00,200
return values and this is similar to our

574
00:21:55,790 --> 00:22:02,809
ax in x86 64 mr. 64 there but yeah

575
00:22:00,200 --> 00:22:04,850
so this is yeah this is how ignition my

576
00:22:02,809 --> 00:22:07,340
code generally works so let's have a

577
00:22:04,850 --> 00:22:10,129
look at an example of how byte code

578
00:22:07,340 --> 00:22:12,050
execution looks like so on the top left

579
00:22:10,130 --> 00:22:14,390
we have a function it's a in JavaScript

580
00:22:12,050 --> 00:22:15,389
it just it's an ad function it has two

581
00:22:14,390 --> 00:22:18,209
parameters X and

582
00:22:15,389 --> 00:22:20,099
and it just adds them together and

583
00:22:18,209 --> 00:22:21,329
returns the value right and at the end

584
00:22:20,099 --> 00:22:23,249
we have to make a call to the function

585
00:22:21,329 --> 00:22:25,469
because of the lazy parsing thing that I

586
00:22:23,249 --> 00:22:28,469
explained we don't make a call to it

587
00:22:25,469 --> 00:22:32,609
no byte code gets generated so yeah so

588
00:22:28,469 --> 00:22:36,659
we have this on the right we call d8

589
00:22:32,609 --> 00:22:41,279
which is V Yates repple I guess with the

590
00:22:36,659 --> 00:22:44,009
- - print - byte code flag right and

591
00:22:41,279 --> 00:22:46,799
when this happens we see that the byte

592
00:22:44,009 --> 00:22:49,320
code that's generated by BA is it's just

593
00:22:46,799 --> 00:22:53,039
four separate byte codes so let's get

594
00:22:49,320 --> 00:22:55,109
straight into it Wow okay my slides are

595
00:22:53,039 --> 00:22:57,599
stuffed a little bit those I'll just

596
00:22:55,109 --> 00:23:00,658
explain it without the red boxes so the

597
00:22:57,599 --> 00:23:03,749
stack took at the beginning we'll check

598
00:23:00,659 --> 00:23:05,459
the stack pointer against a upper limit

599
00:23:03,749 --> 00:23:07,289
it's going to make sure that the stack

600
00:23:05,459 --> 00:23:09,719
pointer is less than an upper limit to

601
00:23:07,289 --> 00:23:11,669
prevent stack overflows from occurring

602
00:23:09,719 --> 00:23:14,149
from you know reaching the max recursion

603
00:23:11,669 --> 00:23:16,889
depth or things like things like that

604
00:23:14,149 --> 00:23:19,139
next I'll just use these just so you

605
00:23:16,889 --> 00:23:21,119
know where it's pointing yes the next

606
00:23:19,139 --> 00:23:24,208
instruction LD a are 8-1

607
00:23:21,119 --> 00:23:26,218
the a 1 in this case refers to argument

608
00:23:24,209 --> 00:23:28,200
1 so in our functions case we have

609
00:23:26,219 --> 00:23:30,839
argument 0 and argument 1 where as

610
00:23:28,200 --> 00:23:33,839
arguments here is X and argument 1 is y

611
00:23:30,839 --> 00:23:36,329
so this will load the value of argument

612
00:23:33,839 --> 00:23:38,428
1 into the accumulator register right so

613
00:23:36,329 --> 00:23:40,769
that's what l da r stands for so in this

614
00:23:38,429 --> 00:23:42,299
in our example function calls case this

615
00:23:40,769 --> 00:23:45,329
will load the value 2 into the

616
00:23:42,299 --> 00:23:48,269
accumulator register the next thing add

617
00:23:45,329 --> 00:23:51,359
a 0 the next byte code add a 0 square

618
00:23:48,269 --> 00:23:53,729
bracket 0 is going to initially just

619
00:23:51,359 --> 00:23:56,999
with add a 0 it's going to add the value

620
00:23:53,729 --> 00:23:58,889
of a 0 to the value of whatever's in the

621
00:23:56,999 --> 00:23:59,999
accumulator register and then store the

622
00:23:58,889 --> 00:24:01,949
result back into the accumulator

623
00:23:59,999 --> 00:24:04,499
register right so in our case it's gonna

624
00:24:01,950 --> 00:24:05,789
take the value 1 for X it's going to add

625
00:24:04,499 --> 00:24:07,799
it to whatever is in the action

626
00:24:05,789 --> 00:24:09,809
accumulator register which is 2 from Y

627
00:24:07,799 --> 00:24:11,519
and then I stored the result 3 back into

628
00:24:09,809 --> 00:24:13,369
the accumulator register the square

629
00:24:11,519 --> 00:24:17,579
bracket 0 square bracket here is

630
00:24:13,369 --> 00:24:19,589
interesting this is a slot into these

631
00:24:17,579 --> 00:24:21,450
specific functions in line cache which

632
00:24:19,589 --> 00:24:24,059
we're going to look into in the next

633
00:24:21,450 --> 00:24:26,039
section so the in line case essentially

634
00:24:24,059 --> 00:24:27,959
stores information regarding what this

635
00:24:26,039 --> 00:24:28,269
function is doing right now which is

636
00:24:27,959 --> 00:24:30,219
going to

637
00:24:28,269 --> 00:24:32,259
used for further optimizations later on

638
00:24:30,219 --> 00:24:33,999
and I'll just skip explaining this right

639
00:24:32,259 --> 00:24:36,639
now because I'll explain this in a

640
00:24:33,999 --> 00:24:38,709
little bit finally the return statement

641
00:24:36,639 --> 00:24:42,218
just returns whatever value is within

642
00:24:38,709 --> 00:24:44,859
the accumulator register at that point

643
00:24:42,219 --> 00:24:48,039
in time it would be the value three so

644
00:24:44,859 --> 00:24:49,958
yeah I would explain or I would go

645
00:24:48,039 --> 00:24:52,690
through a vulnerability for ignition

646
00:24:49,959 --> 00:24:56,019
specifically but I can't because

647
00:24:52,690 --> 00:24:59,320
ignition is very closely related to its

648
00:24:56,019 --> 00:25:01,509
cousin I guess which is turbofan and

649
00:24:59,320 --> 00:25:02,950
they essentially run together right so

650
00:25:01,509 --> 00:25:05,279
you can see on the diagram on the right

651
00:25:02,950 --> 00:25:09,639
I'll explain what bad it's doing but

652
00:25:05,279 --> 00:25:11,979
essentially turbofan is v8 optimizing

653
00:25:09,639 --> 00:25:13,748
JIT compiler right so when a function is

654
00:25:11,979 --> 00:25:16,570
ran several times it becomes hot

655
00:25:13,749 --> 00:25:19,869
according to gh I'm sorry v8 terminology

656
00:25:16,570 --> 00:25:21,789
so what happens is on the right you can

657
00:25:19,869 --> 00:25:24,728
see the interpreter creates bytecode and

658
00:25:21,789 --> 00:25:27,459
it you can see an arrow going through

659
00:25:24,729 --> 00:25:29,409
the middle and it goes Plus profiling

660
00:25:27,459 --> 00:25:31,809
data to the optimizing compiler so what

661
00:25:29,409 --> 00:25:34,499
profiling data is is when the function

662
00:25:31,809 --> 00:25:37,570
or when any function runs several times

663
00:25:34,499 --> 00:25:39,999
the profiling data essentially says ok

664
00:25:37,570 --> 00:25:42,428
this function is being ran with this

665
00:25:39,999 --> 00:25:45,849
specific type of variable or these sets

666
00:25:42,429 --> 00:25:47,759
of types of variables so the optimizing

667
00:25:45,849 --> 00:25:50,559
compiler can then use this data to

668
00:25:47,759 --> 00:25:52,419
speculate that this function only deals

669
00:25:50,559 --> 00:25:54,279
with that certain type of value right it

670
00:25:52,419 --> 00:25:56,320
uses this profiling information and type

671
00:25:54,279 --> 00:25:58,239
feedback whatever you want to call it to

672
00:25:56,320 --> 00:25:59,708
just make an assumption that okay this

673
00:25:58,239 --> 00:26:01,599
function is being called with this

674
00:25:59,709 --> 00:26:04,059
specific type and nothing else therefore

675
00:26:01,599 --> 00:26:06,279
I will produce highly optimized machine

676
00:26:04,059 --> 00:26:08,619
code that deals with this specific type

677
00:26:06,279 --> 00:26:10,749
right and again this is important

678
00:26:08,619 --> 00:26:12,279
because in JavaScript if you just have a

679
00:26:10,749 --> 00:26:14,409
look at that add function that I was

680
00:26:12,279 --> 00:26:16,239
talking about x and y x and y in that

681
00:26:14,409 --> 00:26:18,820
case was just one and two which are

682
00:26:16,239 --> 00:26:21,129
Smith's right small integers however in

683
00:26:18,820 --> 00:26:22,809
JavaScript x and y's can be strings they

684
00:26:21,129 --> 00:26:26,049
can be objects they can be erased they

685
00:26:22,809 --> 00:26:27,879
can be floats value floating point

686
00:26:26,049 --> 00:26:29,499
values which are different to small

687
00:26:27,879 --> 00:26:32,320
integers so they can be a lot of

688
00:26:29,499 --> 00:26:34,899
different things so javascript by

689
00:26:32,320 --> 00:26:36,700
default would have to check against all

690
00:26:34,899 --> 00:26:38,559
of those types before adding them

691
00:26:36,700 --> 00:26:41,159
together right because adding between

692
00:26:38,559 --> 00:26:44,340
different types wouldn't work and

693
00:26:41,159 --> 00:26:45,720
the addition between strings for example

694
00:26:44,340 --> 00:26:50,939
different to the addition between

695
00:26:45,720 --> 00:26:52,799
integers so sorry yeah I just lost

696
00:26:50,940 --> 00:26:54,649
myself a little bit but yeah so this is

697
00:26:52,799 --> 00:26:56,999
how it would make an assumption that

698
00:26:54,649 --> 00:26:58,559
this function is dealing with a specific

699
00:26:56,999 --> 00:27:00,570
type and it would generate highly

700
00:26:58,559 --> 00:27:00,989
optimized machine code for that specific

701
00:27:00,570 --> 00:27:03,989
type

702
00:27:00,989 --> 00:27:06,479
however it also inserts checks right sir

703
00:27:03,989 --> 00:27:08,580
if at any time these assumptions fail to

704
00:27:06,479 --> 00:27:11,389
hold true the code is the optimized and

705
00:27:08,580 --> 00:27:13,439
execution goes back straight to the

706
00:27:11,389 --> 00:27:14,849
interpreter so you can see that on the

707
00:27:13,440 --> 00:27:17,549
right side of the diagram it optimized

708
00:27:14,849 --> 00:27:19,619
code gets the optimized and transformed

709
00:27:17,549 --> 00:27:21,929
back to bytecode and the bytecode again

710
00:27:19,619 --> 00:27:24,029
runs that's the sort of slow path that

711
00:27:21,929 --> 00:27:27,269
has to go through if it gets stuck

712
00:27:24,029 --> 00:27:29,549
I guess not not stuck if it you know if

713
00:27:27,269 --> 00:27:30,929
the assumptions fail to have all true so

714
00:27:29,549 --> 00:27:32,759
let's have a look at what speculative

715
00:27:30,929 --> 00:27:36,330
optimization looks like in terms of our

716
00:27:32,759 --> 00:27:38,489
add function right so add function same

717
00:27:36,330 --> 00:27:41,428
function we call it in a loop 10000

718
00:27:38,489 --> 00:27:42,989
times with the same argument I should

719
00:27:41,429 --> 00:27:44,489
point out one thing the the arguments

720
00:27:42,989 --> 00:27:46,200
don't have to be just one and two they

721
00:27:44,489 --> 00:27:48,210
can be any small integer right as long

722
00:27:46,200 --> 00:27:50,460
as they're a small integer it's going to

723
00:27:48,210 --> 00:27:52,409
be optimized for small integers so the

724
00:27:50,460 --> 00:27:53,789
first time or the second couple times

725
00:27:52,409 --> 00:27:56,249
you call this function with small

726
00:27:53,789 --> 00:27:58,289
integers within the feedbag vector or

727
00:27:56,249 --> 00:27:59,849
the feedback vector is another name for

728
00:27:58,289 --> 00:28:01,950
the inline case that I was talking about

729
00:27:59,849 --> 00:28:03,689
for this specific function it's going to

730
00:28:01,950 --> 00:28:05,729
store information about what this

731
00:28:03,690 --> 00:28:08,039
function is doing and in this case it

732
00:28:05,729 --> 00:28:09,869
says that there is a binary operation ie

733
00:28:08,039 --> 00:28:13,349
an operation between two variables of

734
00:28:09,869 --> 00:28:15,238
sign small sort just sign small integers

735
00:28:13,349 --> 00:28:17,399
in our case one and two just small

736
00:28:15,239 --> 00:28:18,509
integers that are sign it's going to

737
00:28:17,399 --> 00:28:21,508
store this information within that

738
00:28:18,509 --> 00:28:24,109
inline case and over time when it gets

739
00:28:21,509 --> 00:28:26,279
called multiple times it becomes hot the

740
00:28:24,109 --> 00:28:28,408
function is going to get optimized by

741
00:28:26,279 --> 00:28:30,509
turbofan and it's going to be optimized

742
00:28:28,409 --> 00:28:32,580
specifically for small integers if at a

743
00:28:30,509 --> 00:28:34,379
later point we call it with say floats

744
00:28:32,580 --> 00:28:35,580
it's going to immediately be optimized

745
00:28:34,379 --> 00:28:37,109
back to the interpreter and the

746
00:28:35,580 --> 00:28:39,960
interpreter is going to have to deal

747
00:28:37,109 --> 00:28:42,029
with gaining new type feedback and new

748
00:28:39,960 --> 00:28:44,309
profiling information for a function

749
00:28:42,029 --> 00:28:46,619
that needs to deal with both small

750
00:28:44,309 --> 00:28:48,389
integers and floating point values right

751
00:28:46,619 --> 00:28:51,059
so that's essentially how this

752
00:28:48,389 --> 00:28:52,978
speculative optimization works now this

753
00:28:51,059 --> 00:28:54,629
is a very simple function turbofan

754
00:28:52,979 --> 00:28:55,050
actually does eight a lot of different

755
00:28:54,629 --> 00:28:58,620
optimized

756
00:28:55,050 --> 00:29:00,149
right sir this is an example diagram you

757
00:28:58,620 --> 00:29:02,580
just need to look at the second layer of

758
00:29:00,150 --> 00:29:03,960
this so you can see that there's this

759
00:29:02,580 --> 00:29:05,909
type optimization there's redundancy

760
00:29:03,960 --> 00:29:07,650
elimination there's escape analysis

761
00:29:05,910 --> 00:29:09,750
representation selection there's a

762
00:29:07,650 --> 00:29:12,480
there's like 20 other optimizations and

763
00:29:09,750 --> 00:29:14,700
these are all just your generic compiler

764
00:29:12,480 --> 00:29:18,150
optimizations so you know if you guys

765
00:29:14,700 --> 00:29:20,100
know it have any background knowledge

766
00:29:18,150 --> 00:29:22,440
regarding compilers if you if you can

767
00:29:20,100 --> 00:29:24,780
name one compiler optimization turbofan

768
00:29:22,440 --> 00:29:26,190
probably does it all right so again this

769
00:29:24,780 --> 00:29:28,920
diagram doesn't list all of them but

770
00:29:26,190 --> 00:29:31,080
essentially a turbofan would perform as

771
00:29:28,920 --> 00:29:33,240
many optimizations as it can it just

772
00:29:31,080 --> 00:29:35,040
won't on a function that is this simple

773
00:29:33,240 --> 00:29:39,630
right it just returns the addition of

774
00:29:35,040 --> 00:29:41,940
two important arguments so that's it

775
00:29:39,630 --> 00:29:43,320
with turbofan but before we look at the

776
00:29:41,940 --> 00:29:44,760
vulnerability that I wanted to look at

777
00:29:43,320 --> 00:29:47,490
with turbofan we have to look at a

778
00:29:44,760 --> 00:29:50,400
little bit more a couple of different

779
00:29:47,490 --> 00:29:52,710
things the first being shapes right so

780
00:29:50,400 --> 00:29:55,140
shapes or hidden classes or maps

781
00:29:52,710 --> 00:29:57,000
whatever you want to call them in in v8

782
00:29:55,140 --> 00:29:59,670
they're called either hidden classes or

783
00:29:57,000 --> 00:30:02,100
maps these are used to store information

784
00:29:59,670 --> 00:30:04,560
regarding objects and more specifically

785
00:30:02,100 --> 00:30:06,959
specifically how their properties are to

786
00:30:04,560 --> 00:30:08,580
be accessed right they also track

787
00:30:06,960 --> 00:30:11,310
elements kinds for a race which I'll

788
00:30:08,580 --> 00:30:13,399
explain in a little bit it's a little

789
00:30:11,310 --> 00:30:17,399
harder to explain without visual visual

790
00:30:13,400 --> 00:30:19,290
pictures right so anyway so shapes are

791
00:30:17,400 --> 00:30:21,330
created on demand it's needed and shared

792
00:30:19,290 --> 00:30:23,670
between objects as much as possible to

793
00:30:21,330 --> 00:30:25,919
show you what shapes do I'll show you

794
00:30:23,670 --> 00:30:28,530
what JavaScript or what v8 would look

795
00:30:25,920 --> 00:30:30,780
like without shapes right sir without

796
00:30:28,530 --> 00:30:33,540
shapes if you have an object say an

797
00:30:30,780 --> 00:30:35,610
object that has an x and y value like

798
00:30:33,540 --> 00:30:38,550
coordinates for example without shapes

799
00:30:35,610 --> 00:30:40,919
the object could store the property

800
00:30:38,550 --> 00:30:43,440
names within the object so x and y and

801
00:30:40,920 --> 00:30:46,080
the property names could then point to

802
00:30:43,440 --> 00:30:48,000
these other objects called property

803
00:30:46,080 --> 00:30:49,740
attributes and the property attributes

804
00:30:48,000 --> 00:30:51,240
would store you know the values and

805
00:30:49,740 --> 00:30:53,670
other attributes such as writable

806
00:30:51,240 --> 00:30:56,400
innumerable look favorable etc now

807
00:30:53,670 --> 00:30:57,930
imagine you're creating a 2-d game in

808
00:30:56,400 --> 00:30:59,610
JavaScript I don't know why you would

809
00:30:57,930 --> 00:31:01,110
but let's just imagine you are you're

810
00:30:59,610 --> 00:31:03,330
gonna have thousands and thousands of

811
00:31:01,110 --> 00:31:05,189
objects within your 2d world and all of

812
00:31:03,330 --> 00:31:07,860
these objects are going to have an x and

813
00:31:05,190 --> 00:31:08,860
y coordinate right now obviously this is

814
00:31:07,860 --> 00:31:10,629
a waste of memory

815
00:31:08,860 --> 00:31:12,850
face if all of the objects have X&Y

816
00:31:10,630 --> 00:31:16,450
memory spaces you would be better off

817
00:31:12,850 --> 00:31:19,600
just somehow storing the fact that the

818
00:31:16,450 --> 00:31:21,190
X&Y not a memory P space or X and my

819
00:31:19,600 --> 00:31:25,030
properties you would be better off

820
00:31:21,190 --> 00:31:28,660
storing the idea that the X and y

821
00:31:25,030 --> 00:31:30,250
properties can be the I'm not even gonna

822
00:31:28,660 --> 00:31:32,350
try to explain that I'll just go to the

823
00:31:30,250 --> 00:31:35,410
next slide so in the next slide is how

824
00:31:32,350 --> 00:31:38,290
shapes are used so in this case for

825
00:31:35,410 --> 00:31:40,210
example the values that the 5 and 6 are

826
00:31:38,290 --> 00:31:41,710
sold within the object whereas the

827
00:31:40,210 --> 00:31:43,780
information about the properties are

828
00:31:41,710 --> 00:31:45,190
stored within the shapes alright so this

829
00:31:43,780 --> 00:31:47,410
is what I was trying to explain it's

830
00:31:45,190 --> 00:31:49,390
better to just store the repeatable

831
00:31:47,410 --> 00:31:51,400
information within a separate data

832
00:31:49,390 --> 00:31:54,370
structure just the shape or map or

833
00:31:51,400 --> 00:31:56,650
hidden cost in this case and what we can

834
00:31:54,370 --> 00:31:58,659
then do is have multiple objects share

835
00:31:56,650 --> 00:32:00,429
that same shape so you're thousands and

836
00:31:58,660 --> 00:32:02,650
thousands of objects can all point to

837
00:32:00,429 --> 00:32:04,990
this specific shape that has information

838
00:32:02,650 --> 00:32:06,850
about the x and y properties the shape

839
00:32:04,990 --> 00:32:08,110
simply says okay if you have an X

840
00:32:06,850 --> 00:32:09,790
property it's gonna be found at office

841
00:32:08,110 --> 00:32:11,799
it's your issue about Y property it's

842
00:32:09,790 --> 00:32:14,830
gonna be found at offset one so when you

843
00:32:11,799 --> 00:32:16,570
try to access say object a is X property

844
00:32:14,830 --> 00:32:18,428
it's going to first look at the shape

845
00:32:16,570 --> 00:32:19,720
it's going to try to find property X

846
00:32:18,429 --> 00:32:21,549
it's going to look at the property

847
00:32:19,720 --> 00:32:23,919
information it'll see that it's at

848
00:32:21,549 --> 00:32:29,410
offset zero and then it'll access the

849
00:32:23,919 --> 00:32:31,660
value at object s offset zero sir shapes

850
00:32:29,410 --> 00:32:33,669
are pretty complicated I'm not going to

851
00:32:31,660 --> 00:32:35,380
cover or like all the internal details

852
00:32:33,669 --> 00:32:37,540
about shapes it will take too long but

853
00:32:35,380 --> 00:32:40,000
let's have a look at what shape

854
00:32:37,540 --> 00:32:42,549
transitions are so shape transitions

855
00:32:40,000 --> 00:32:44,890
just mean that shapes can be connected

856
00:32:42,549 --> 00:32:47,020
to one another in specific scenarios so

857
00:32:44,890 --> 00:32:49,090
for example in this case we first create

858
00:32:47,020 --> 00:32:51,010
an empty object then we add a property X

859
00:32:49,090 --> 00:32:53,500
and then we add a property Y what

860
00:32:51,010 --> 00:32:55,240
happens is the empty object first points

861
00:32:53,500 --> 00:32:57,130
to the empty shape then when you create

862
00:32:55,240 --> 00:32:59,290
when you add a new property X to it a

863
00:32:57,130 --> 00:33:02,200
new shape is created with just property

864
00:32:59,290 --> 00:33:05,379
X and the empty object is already empty

865
00:33:02,200 --> 00:33:07,570
shape is then connected to this a new

866
00:33:05,380 --> 00:33:10,480
shape that has the X property in it and

867
00:33:07,570 --> 00:33:12,700
this this creates a sort of transition

868
00:33:10,480 --> 00:33:14,799
chain is what it's called again when you

869
00:33:12,700 --> 00:33:17,200
add a new property Y afterwards again

870
00:33:14,799 --> 00:33:19,540
the shape X I'm sorry be a shape X in

871
00:33:17,200 --> 00:33:22,820
shape Y are connected together with a

872
00:33:19,540 --> 00:33:25,610
transition chain so again what happens

873
00:33:22,820 --> 00:33:26,990
now for example if your object Oh now

874
00:33:25,610 --> 00:33:28,668
points to the final shape in that

875
00:33:26,990 --> 00:33:30,950
transition chain and you try to access

876
00:33:28,669 --> 00:33:32,630
property X it's going to check the final

877
00:33:30,950 --> 00:33:34,220
shape for property X again it's not

878
00:33:32,630 --> 00:33:36,320
going to find it because the final shape

879
00:33:34,220 --> 00:33:37,460
when we have property Y and it what it's

880
00:33:36,320 --> 00:33:39,769
going to do is it's going to look

881
00:33:37,460 --> 00:33:41,929
upwards or backwards through this

882
00:33:39,769 --> 00:33:44,090
transition chain until we find the shape

883
00:33:41,929 --> 00:33:46,039
that has property X right and if it

884
00:33:44,090 --> 00:33:48,439
finds it then it just but records it

885
00:33:46,039 --> 00:33:49,820
some records it's offset right and then

886
00:33:48,440 --> 00:33:52,639
it just uses the offset to find the

887
00:33:49,820 --> 00:33:55,279
value of x in the object if for example

888
00:33:52,639 --> 00:33:57,529
you try to access property said right it

889
00:33:55,279 --> 00:33:59,600
doesn't exist it's going to traverse

890
00:33:57,529 --> 00:34:01,669
this whole transition chain completely

891
00:33:59,600 --> 00:34:02,959
it's not going to find anything or it's

892
00:34:01,669 --> 00:34:04,370
not going to find a property and said

893
00:34:02,960 --> 00:34:05,870
because it doesn't exist and it will

894
00:34:04,370 --> 00:34:10,449
just return undefined as JavaScript

895
00:34:05,870 --> 00:34:14,509
generally does with most most operations

896
00:34:10,449 --> 00:34:18,109
sir shapes can also create what's known

897
00:34:14,510 --> 00:34:20,149
as transition trees and this is where

898
00:34:18,109 --> 00:34:22,578
things can get really complicated say

899
00:34:20,149 --> 00:34:24,230
you have two objects or say you have an

900
00:34:22,579 --> 00:34:25,879
object a that starts off as an empty

901
00:34:24,230 --> 00:34:27,918
object and an object B that starts off

902
00:34:25,879 --> 00:34:30,710
at the named object they both point to

903
00:34:27,918 --> 00:34:33,109
the same empty shape obviously now say

904
00:34:30,710 --> 00:34:36,409
you add a property X to object a but are

905
00:34:33,109 --> 00:34:38,119
probably white object B now what would

906
00:34:36,409 --> 00:34:40,159
happen is from the empty object you'd

907
00:34:38,119 --> 00:34:42,589
have like a binary tree that this isn't

908
00:34:40,159 --> 00:34:44,569
a binary this this tree can be any any

909
00:34:42,589 --> 00:34:47,000
level any level tree I guess it doesn't

910
00:34:44,569 --> 00:34:49,668
have to be binary but you would have it

911
00:34:47,000 --> 00:34:51,800
branch out into a shape X and a shape Y

912
00:34:49,668 --> 00:34:54,500
and you know the objects would get their

913
00:34:51,800 --> 00:34:56,720
own shapes and again this you can you

914
00:34:54,500 --> 00:34:59,240
sort of see how complex this can get and

915
00:34:56,719 --> 00:35:01,129
because of this this is why I say you

916
00:34:59,240 --> 00:35:03,649
know this is where vulnerabilities can

917
00:35:01,130 --> 00:35:05,869
lie if for you know for some reason the

918
00:35:03,650 --> 00:35:07,940
shape transition trees aren't like

919
00:35:05,869 --> 00:35:09,470
calculated or set out correctly you can

920
00:35:07,940 --> 00:35:12,140
probably find an exportable primitive

921
00:35:09,470 --> 00:35:14,660
somewhere right so that's how shapes

922
00:35:12,140 --> 00:35:16,190
work and I also mentioned elements kinds

923
00:35:14,660 --> 00:35:18,379
which are specifically used for a race

924
00:35:16,190 --> 00:35:21,170
so what elements kinds are this is a

925
00:35:18,380 --> 00:35:23,480
trend elements kind of transition tree

926
00:35:21,170 --> 00:35:26,140
sort of that's on the point really but

927
00:35:23,480 --> 00:35:28,490
let's look at there so look at the left

928
00:35:26,140 --> 00:35:30,980
elements clients or you have what's

929
00:35:28,490 --> 00:35:33,410
known as packed Smee elements or holy

930
00:35:30,980 --> 00:35:35,660
Smee elements so these elements kind are

931
00:35:33,410 --> 00:35:36,770
reserved for arrays that only store

932
00:35:35,660 --> 00:35:38,600
small

933
00:35:36,770 --> 00:35:40,130
right sir for the top one for example

934
00:35:38,600 --> 00:35:41,990
you only have one two three and four and

935
00:35:40,130 --> 00:35:43,880
they're all packed together right there

936
00:35:41,990 --> 00:35:46,100
are no holes in this array whereas for

937
00:35:43,880 --> 00:35:47,750
the holy variant of it you have holes in

938
00:35:46,100 --> 00:35:49,490
the area you have one and there's holes

939
00:35:47,750 --> 00:35:52,550
in between and then you look for so

940
00:35:49,490 --> 00:35:54,709
these are elements kinds they tell the

941
00:35:52,550 --> 00:35:57,140
engine that this array specifically and

942
00:35:54,710 --> 00:35:59,510
only stores small integers and remember

943
00:35:57,140 --> 00:36:02,359
small integers are 32 bits in size

944
00:35:59,510 --> 00:36:06,170
well 31 bits with the last bits at 0 but

945
00:36:02,360 --> 00:36:08,570
near 30 cubits total and the engine can

946
00:36:06,170 --> 00:36:10,550
then use this fact that ok I know that

947
00:36:08,570 --> 00:36:13,340
this array only store small integers so

948
00:36:10,550 --> 00:36:14,780
I can optimize accesses to indices so

949
00:36:13,340 --> 00:36:17,630
you know I add that the engine would

950
00:36:14,780 --> 00:36:20,570
know that to access element at index 2

951
00:36:17,630 --> 00:36:23,420
it can just start from index 0 and add

952
00:36:20,570 --> 00:36:25,580
in 32 times 2 right 64 and then just get

953
00:36:23,420 --> 00:36:27,500
to element next to it which would be 3

954
00:36:25,580 --> 00:36:29,690
in this case the same applies to floats

955
00:36:27,500 --> 00:36:32,750
or doubles in this case except double to

956
00:36:29,690 --> 00:36:35,300
64 bits so again in the same way it will

957
00:36:32,750 --> 00:36:37,910
just optimize the array axises but

958
00:36:35,300 --> 00:36:40,160
instead new 64 bits this time and

959
00:36:37,910 --> 00:36:42,319
finally you have packed elements so pack

960
00:36:40,160 --> 00:36:44,390
elements are any arrays that don't only

961
00:36:42,320 --> 00:36:46,610
contain numbers so in my example here I

962
00:36:44,390 --> 00:36:49,279
just use 1 point 1 with an empty object

963
00:36:46,610 --> 00:36:51,470
so in this case the 1 point 1 itself

964
00:36:49,280 --> 00:36:53,810
would also be stored as a pointer to a

965
00:36:51,470 --> 00:36:55,549
number object in the heap so essentially

966
00:36:53,810 --> 00:36:57,350
this sort of type of array only contains

967
00:36:55,550 --> 00:36:59,290
pointers right 32 bit compressed

968
00:36:57,350 --> 00:37:03,049
pointers within the compressed heap and

969
00:36:59,290 --> 00:37:04,670
this array cannot be or this year this

970
00:37:03,050 --> 00:37:06,740
array cannot be optimized before

971
00:37:04,670 --> 00:37:08,930
accesses essentially so this is like the

972
00:37:06,740 --> 00:37:10,640
slow type of array if you're if you're a

973
00:37:08,930 --> 00:37:12,200
JavaScript developer you try not to

974
00:37:10,640 --> 00:37:13,759
create arrays like this as best as you

975
00:37:12,200 --> 00:37:14,960
can because it slows down the engine and

976
00:37:13,760 --> 00:37:17,330
it's going to slow down your programs

977
00:37:14,960 --> 00:37:19,340
performance so yeah this is what

978
00:37:17,330 --> 00:37:23,870
elements kind is it just determines or

979
00:37:19,340 --> 00:37:25,400
defines what values the an array might

980
00:37:23,870 --> 00:37:28,910
be storing and the engine uses it for

981
00:37:25,400 --> 00:37:30,530
optimizations finally we have what's

982
00:37:28,910 --> 00:37:33,440
called inline cases I mentioned this

983
00:37:30,530 --> 00:37:34,850
before so inline cases are on a function

984
00:37:33,440 --> 00:37:36,740
level essentially they're stored on

985
00:37:34,850 --> 00:37:38,390
functions so inline case you store

986
00:37:36,740 --> 00:37:40,009
information regarding property loads and

987
00:37:38,390 --> 00:37:42,259
stores anytime an object's properties

988
00:37:40,010 --> 00:37:43,580
access within a function the information

989
00:37:42,260 --> 00:37:46,070
regarding this access stored within

990
00:37:43,580 --> 00:37:48,410
functions inline case and this inline

991
00:37:46,070 --> 00:37:50,250
caches then later on used by turbofan to

992
00:37:48,410 --> 00:37:52,049
generate optimized machine code and

993
00:37:50,250 --> 00:37:53,850
see an example of this in the next set

994
00:37:52,050 --> 00:37:55,980
of slides but there's a comic here on

995
00:37:53,850 --> 00:37:58,560
the right I forgot to put a link to the

996
00:37:55,980 --> 00:38:00,330
person blog that I got it from but

997
00:37:58,560 --> 00:38:02,940
essentially you can see on the left the

998
00:38:00,330 --> 00:38:04,830
object is trying to access property X it

999
00:38:02,940 --> 00:38:07,830
cannot find it it doesn't know where X

1000
00:38:04,830 --> 00:38:10,290
is so it talks to the shape itself the

1001
00:38:07,830 --> 00:38:12,210
shape knows where the property X is so

1002
00:38:10,290 --> 00:38:15,000
it tells the object hey look

1003
00:38:12,210 --> 00:38:17,250
X is right here so the object now knows

1004
00:38:15,000 --> 00:38:19,590
that okay oh that X is 1 because I'd be

1005
00:38:17,250 --> 00:38:22,730
the shaped hole that where to find X in

1006
00:38:19,590 --> 00:38:25,980
this when when this happens there the

1007
00:38:22,730 --> 00:38:29,010
fact that property X of this object is

1008
00:38:25,980 --> 00:38:31,950
in that specific position or that index

1009
00:38:29,010 --> 00:38:33,960
or you know that offset is stored in a

1010
00:38:31,950 --> 00:38:37,230
functions inline case if the function

1011
00:38:33,960 --> 00:38:39,300
does does this axis so when this when

1012
00:38:37,230 --> 00:38:41,340
it's stored in this inline case if this

1013
00:38:39,300 --> 00:38:43,170
function is called again with the same

1014
00:38:41,340 --> 00:38:45,090
object the objects is going to remember

1015
00:38:43,170 --> 00:38:46,620
weight or well not the object function

1016
00:38:45,090 --> 00:38:48,450
is going to remember weight I've done

1017
00:38:46,620 --> 00:38:50,490
this before it's not going to go through

1018
00:38:48,450 --> 00:38:51,899
that expensive lookup process where it

1019
00:38:50,490 --> 00:38:54,029
has to talk to the shape the shape has

1020
00:38:51,900 --> 00:38:55,530
to figure out where the property is etc

1021
00:38:54,030 --> 00:38:56,730
etc it's just going to look at the

1022
00:38:55,530 --> 00:38:58,410
inline case which is you know

1023
00:38:56,730 --> 00:39:00,330
immediately there with the function

1024
00:38:58,410 --> 00:39:01,890
it'll tell the object ok this is where

1025
00:39:00,330 --> 00:39:03,900
the property is this is how you access

1026
00:39:01,890 --> 00:39:08,129
it so that's how the object does it in a

1027
00:39:03,900 --> 00:39:10,890
much faster rate now here's a more a

1028
00:39:08,130 --> 00:39:12,510
better example of how inline cases work

1029
00:39:10,890 --> 00:39:14,580
so you have a function called get X

1030
00:39:12,510 --> 00:39:17,550
imports an object and it just returns Oh

1031
00:39:14,580 --> 00:39:19,620
X right the objects X property so when

1032
00:39:17,550 --> 00:39:22,080
you call get X with an object that has

1033
00:39:19,620 --> 00:39:25,109
any X property set to a it has that

1034
00:39:22,080 --> 00:39:26,759
shape the shape tells it the object that

1035
00:39:25,110 --> 00:39:31,050
the property X can be found it officer 0

1036
00:39:26,760 --> 00:39:32,040
for the function specifically though the

1037
00:39:31,050 --> 00:39:34,080
bytecode here might look different

1038
00:39:32,040 --> 00:39:37,050
because this screenshot is specifically

1039
00:39:34,080 --> 00:39:38,910
for JSC just safaris JavaScript engine

1040
00:39:37,050 --> 00:39:42,570
but I'll explain what it's doing so get

1041
00:39:38,910 --> 00:39:44,549
by ID Mach 0 R 1 X is essentially going

1042
00:39:42,570 --> 00:39:46,470
to take argument 1 which in this case is

1043
00:39:44,550 --> 00:39:48,930
object or it's going to access the

1044
00:39:46,470 --> 00:39:51,299
property X and it's going to set

1045
00:39:48,930 --> 00:39:53,640
whatever value the property X contains

1046
00:39:51,300 --> 00:39:55,830
into location 0 which is just a like a

1047
00:39:53,640 --> 00:39:57,270
temporary stack variable and then

1048
00:39:55,830 --> 00:40:00,120
finally it's going to return LOC 0

1049
00:39:57,270 --> 00:40:03,120
however on the right you can see two red

1050
00:40:00,120 --> 00:40:04,710
boxes that just say na this is the in

1051
00:40:03,120 --> 00:40:06,720
case right in this case the inline case

1052
00:40:04,710 --> 00:40:08,160
has two slots it probably has more the

1053
00:40:06,720 --> 00:40:10,020
switcher just shows two slots because

1054
00:40:08,160 --> 00:40:12,180
that's what it's what's important if you

1055
00:40:10,020 --> 00:40:14,759
call this function once the inline case

1056
00:40:12,180 --> 00:40:16,620
is going to first store the shape of

1057
00:40:14,760 --> 00:40:19,260
this object and secondly it's going to

1058
00:40:16,620 --> 00:40:21,029
store the offset at which this specific

1059
00:40:19,260 --> 00:40:24,350
property that was accessed can be found

1060
00:40:21,030 --> 00:40:26,460
that right so if when this with this

1061
00:40:24,350 --> 00:40:30,089
what's gonna happen is if you call this

1062
00:40:26,460 --> 00:40:31,530
function again the object instead of

1063
00:40:30,090 --> 00:40:33,420
having to go through the shape and

1064
00:40:31,530 --> 00:40:34,800
having to look everything up what it's

1065
00:40:33,420 --> 00:40:36,570
going to do or what the function is

1066
00:40:34,800 --> 00:40:38,250
going to do is first it's going to take

1067
00:40:36,570 --> 00:40:40,530
that shape out of the inline case and

1068
00:40:38,250 --> 00:40:41,970
it's going to check if this object shape

1069
00:40:40,530 --> 00:40:44,100
is the same as the shape that it has

1070
00:40:41,970 --> 00:40:45,540
stored within the inline case if this

1071
00:40:44,100 --> 00:40:47,910
holds true then it's just going to

1072
00:40:45,540 --> 00:40:50,670
return zero to the object and the object

1073
00:40:47,910 --> 00:40:52,200
just knows hey I can just get the value

1074
00:40:50,670 --> 00:40:53,700
at all since here and return it because

1075
00:40:52,200 --> 00:40:56,250
that's what the function is doing and

1076
00:40:53,700 --> 00:40:57,569
that's what a case if firm for so you

1077
00:40:56,250 --> 00:40:59,610
know there's just improves performance

1078
00:40:57,570 --> 00:41:01,200
by by a large amount because you don't

1079
00:40:59,610 --> 00:41:04,530
have to go through that expensive map

1080
00:41:01,200 --> 00:41:06,419
look up through the shape so yeah that

1081
00:41:04,530 --> 00:41:08,160
that's just that's how inline cases are

1082
00:41:06,420 --> 00:41:09,930
used within functions to optimize

1083
00:41:08,160 --> 00:41:12,720
property access property loads and

1084
00:41:09,930 --> 00:41:14,399
stores within objects so that's enough

1085
00:41:12,720 --> 00:41:16,770
information about turbo pending ignition

1086
00:41:14,400 --> 00:41:18,270
we can finally look at a vulnerability

1087
00:41:16,770 --> 00:41:20,400
and this is one of my favorite

1088
00:41:18,270 --> 00:41:23,250
vulnerabilities actually because this

1089
00:41:20,400 --> 00:41:25,620
really showcases how unique

1090
00:41:23,250 --> 00:41:27,900
vulnerability classes can get within p8

1091
00:41:25,620 --> 00:41:29,100
because of its complexity so this

1092
00:41:27,900 --> 00:41:30,630
vulnerability doesn't have a CV

1093
00:41:29,100 --> 00:41:34,170
unfortunately because it was found

1094
00:41:30,630 --> 00:41:36,630
internally by Stephen Roark sure I

1095
00:41:34,170 --> 00:41:38,550
believe through manual code review and

1096
00:41:36,630 --> 00:41:40,680
by Samuel browse through fuzzing they're

1097
00:41:38,550 --> 00:41:42,630
both amazing security researchers that

1098
00:41:40,680 --> 00:41:43,890
work for Google projects here they're

1099
00:41:42,630 --> 00:41:45,540
just amazing just go follow them on

1100
00:41:43,890 --> 00:41:47,520
Twitter read their blog post on the

1101
00:41:45,540 --> 00:41:51,390
projects your blog they were amazing

1102
00:41:47,520 --> 00:41:54,450
right so um so yeah this is a chromium

1103
00:41:51,390 --> 00:41:56,640
issue nine four four zero six two it's

1104
00:41:54,450 --> 00:41:59,310
just uh the description is that it fails

1105
00:41:56,640 --> 00:42:00,930
to insert map checks in a radon index of

1106
00:41:59,310 --> 00:42:03,299
an array dot includes and I'll explain

1107
00:42:00,930 --> 00:42:05,700
what that means shortly there is a great

1108
00:42:03,300 --> 00:42:07,860
write-up by Stephen himself Stefan

1109
00:42:05,700 --> 00:42:10,200
himself called trashing the flow of data

1110
00:42:07,860 --> 00:42:12,300
I'll release these slides after this

1111
00:42:10,200 --> 00:42:14,970
talk I'll just link them on the discord

1112
00:42:12,300 --> 00:42:16,200
and you can grab them and you can go to

1113
00:42:14,970 --> 00:42:16,890
the links yourself but um yeah this

1114
00:42:16,200 --> 00:42:18,450
write-up

1115
00:42:16,890 --> 00:42:20,190
essentially goes through what the

1116
00:42:18,450 --> 00:42:21,328
vulnerability is and how to exploit it

1117
00:42:20,190 --> 00:42:22,769
I'll just go through what the

1118
00:42:21,329 --> 00:42:25,709
vulnerability is because I won't have

1119
00:42:22,769 --> 00:42:27,538
time to get to how to exploit it but

1120
00:42:25,709 --> 00:42:28,919
yeah sir before we get into it though

1121
00:42:27,539 --> 00:42:30,779
the more background information

1122
00:42:28,920 --> 00:42:32,130
regarding turbofan is required otherwise

1123
00:42:30,779 --> 00:42:35,489
it's hard to understand the

1124
00:42:32,130 --> 00:42:37,259
vulnerability so sir turbofan what

1125
00:42:35,489 --> 00:42:39,509
initially it just takes the bytecode

1126
00:42:37,259 --> 00:42:41,789
generated by ignition and transforms it

1127
00:42:39,509 --> 00:42:43,170
into what's called a sea of nodes graph

1128
00:42:41,789 --> 00:42:45,630
I'll show you an example and what that

1129
00:42:43,170 --> 00:42:47,609
looks like in the next slide but the

1130
00:42:45,630 --> 00:42:50,130
optimizations that turbofan tries to

1131
00:42:47,609 --> 00:42:51,180
perform are more easily done on sea of

1132
00:42:50,130 --> 00:42:53,369
nodes graph than on the original

1133
00:42:51,180 --> 00:42:56,879
abstract syntax tree generated by the

1134
00:42:53,369 --> 00:42:58,440
parser at the end this sea of notes

1135
00:42:56,880 --> 00:43:00,180
graph after it's been optimized and

1136
00:42:58,440 --> 00:43:02,130
whatnot it gets lowered down into

1137
00:43:00,180 --> 00:43:03,690
machine code for whatever specific

1138
00:43:02,130 --> 00:43:06,509
architecture the browser is currently

1139
00:43:03,690 --> 00:43:08,309
running on that point in time so yeah

1140
00:43:06,509 --> 00:43:09,989
this is how turbofan optimizes this code

1141
00:43:08,309 --> 00:43:12,180
let's have a look at what this year of

1142
00:43:09,989 --> 00:43:14,640
notes graph looks like they even have to

1143
00:43:12,180 --> 00:43:16,019
understand any of the nodes here but

1144
00:43:14,640 --> 00:43:18,629
essentially you can see the nodes are

1145
00:43:16,019 --> 00:43:20,999
connected with lines there are three

1146
00:43:18,630 --> 00:43:23,640
types of edges but not important but

1147
00:43:20,999 --> 00:43:25,709
what is important there is one node and

1148
00:43:23,640 --> 00:43:28,078
this node is called the check map's node

1149
00:43:25,709 --> 00:43:30,930
right and this node can exist on the

1150
00:43:28,079 --> 00:43:34,199
graph for any function so again I'll

1151
00:43:30,930 --> 00:43:36,058
actually go back this whole the graph

1152
00:43:34,199 --> 00:43:38,940
itself is shown for one specific

1153
00:43:36,059 --> 00:43:41,339
function right so this terrible this sea

1154
00:43:38,940 --> 00:43:42,809
of nodes graph is a singular sea of noes

1155
00:43:41,339 --> 00:43:45,690
graph is generated for each function

1156
00:43:42,809 --> 00:43:47,400
within your code so a check map's node

1157
00:43:45,690 --> 00:43:50,519
can exist on this graph what the check

1158
00:43:47,400 --> 00:43:52,619
map node does is it implies that object

1159
00:43:50,519 --> 00:43:54,930
maps are what they are or what they

1160
00:43:52,619 --> 00:43:56,880
should be before property accessor says

1161
00:43:54,930 --> 00:43:59,219
are done so if you remember from before

1162
00:43:56,880 --> 00:44:01,949
within the in line case diagrams

1163
00:43:59,219 --> 00:44:05,670
remember I said that the function will

1164
00:44:01,949 --> 00:44:07,289
first check that the objects map matches

1165
00:44:05,670 --> 00:44:08,849
what it has sold with the mean line case

1166
00:44:07,289 --> 00:44:10,739
before it does anything else right so

1167
00:44:08,849 --> 00:44:13,199
the check maps node within the turbo

1168
00:44:10,739 --> 00:44:16,799
fancy of knows graph would tell the

1169
00:44:13,199 --> 00:44:19,799
engine yeah I'll just yeah I get to the

1170
00:44:16,799 --> 00:44:21,180
end but it would tell the engine to when

1171
00:44:19,799 --> 00:44:23,130
it generates optimized machine code

1172
00:44:21,180 --> 00:44:24,598
it'll tell the engine that at the

1173
00:44:23,130 --> 00:44:26,130
beginning of the optimized machine code

1174
00:44:24,599 --> 00:44:29,450
before any property accesses

1175
00:44:26,130 --> 00:44:33,140
it needs to check that the map of the

1176
00:44:29,450 --> 00:44:35,328
whatever the function is map whatever

1177
00:44:33,140 --> 00:44:37,549
the function is is matches whatever is

1178
00:44:35,329 --> 00:44:39,890
stored within the in line patient that

1179
00:44:37,550 --> 00:44:42,290
function or so a map of what if the

1180
00:44:39,890 --> 00:44:43,430
object is matches the map of whatever

1181
00:44:42,290 --> 00:44:46,750
sold in the in line case on that

1182
00:44:43,430 --> 00:44:49,759
function if the map is not what the

1183
00:44:46,750 --> 00:44:52,280
compiler expects this causes the code to

1184
00:44:49,760 --> 00:44:53,900
bail out back to the interpreter and the

1185
00:44:52,280 --> 00:44:55,400
interpreter just handles whatever case

1186
00:44:53,900 --> 00:44:57,290
it gets the interpreter works with

1187
00:44:55,400 --> 00:44:59,900
anything right the optimized code just

1188
00:44:57,290 --> 00:45:02,089
bails out and the important thing to

1189
00:44:59,900 --> 00:45:03,890
note here though is turbofan like I said

1190
00:45:02,089 --> 00:45:06,440
there's a lot of optimizations and one

1191
00:45:03,890 --> 00:45:08,960
of his optimizations is that it uses any

1192
00:45:06,440 --> 00:45:11,089
speculations that it might make to

1193
00:45:08,960 --> 00:45:11,570
eliminate as many check maps nodes as

1194
00:45:11,089 --> 00:45:14,420
possible

1195
00:45:11,570 --> 00:45:17,359
because remember I said if you if you do

1196
00:45:14,420 --> 00:45:19,670
have check maps now okay I did say that

1197
00:45:17,359 --> 00:45:22,190
having to do map lookups through shapes

1198
00:45:19,670 --> 00:45:24,260
are more expensive than map lookups to

1199
00:45:22,190 --> 00:45:26,270
inline caches well map broke up through

1200
00:45:24,260 --> 00:45:28,369
inline cases are also expensive just not

1201
00:45:26,270 --> 00:45:30,140
as expensive as a math look up through

1202
00:45:28,369 --> 00:45:32,270
the shape like the true the shape chain

1203
00:45:30,140 --> 00:45:33,950
so in a lot of cases turbofan will

1204
00:45:32,270 --> 00:45:37,040
eliminate check maps nodes where it

1205
00:45:33,950 --> 00:45:38,750
knows that not no other operation might

1206
00:45:37,040 --> 00:45:40,880
have a side effect where it might have

1207
00:45:38,750 --> 00:45:44,569
changed this object specific shape or

1208
00:45:40,880 --> 00:45:46,400
map when turbofan does this it will

1209
00:45:44,569 --> 00:45:48,290
improve performance immensely because

1210
00:45:46,400 --> 00:45:50,060
you know checking the map is an

1211
00:45:48,290 --> 00:45:53,089
expensive operation that has to do

1212
00:45:50,060 --> 00:45:54,619
however if it does this incorrectly what

1213
00:45:53,089 --> 00:45:56,690
might happen is the objects map is

1214
00:45:54,619 --> 00:45:58,579
changed but there is no check map's node

1215
00:45:56,690 --> 00:46:00,650
therefore turbofan just thinks that the

1216
00:45:58,579 --> 00:46:02,329
map is different to what it might or

1217
00:46:00,650 --> 00:46:04,400
what it should be right or what it is

1218
00:46:02,329 --> 00:46:06,170
sorry it's different to what it is and

1219
00:46:04,400 --> 00:46:08,150
this results in a type confusion between

1220
00:46:06,170 --> 00:46:09,829
two objects that have different Maps

1221
00:46:08,150 --> 00:46:12,050
right so turbofan thinks this object has

1222
00:46:09,829 --> 00:46:14,300
map eight where in reality it has mapped

1223
00:46:12,050 --> 00:46:17,780
be an even map a and map beam I have

1224
00:46:14,300 --> 00:46:20,329
different ways of accessing say an array

1225
00:46:17,780 --> 00:46:23,329
right it really is index to right for

1226
00:46:20,329 --> 00:46:24,800
example so this might cause type

1227
00:46:23,329 --> 00:46:27,980
confusions which are very easily

1228
00:46:24,800 --> 00:46:30,230
exportable with in v8 sure yeah let's

1229
00:46:27,980 --> 00:46:32,839
just go next and let's have a look at

1230
00:46:30,230 --> 00:46:34,520
what the vulnerability itself is this is

1231
00:46:32,839 --> 00:46:36,740
a lot of code I'll explain what it is so

1232
00:46:34,520 --> 00:46:39,530
the vulnerable code is found in J's call

1233
00:46:36,740 --> 00:46:42,020
reducer reduce array index of includes

1234
00:46:39,530 --> 00:46:44,290
so this function essentially takes the

1235
00:46:42,020 --> 00:46:46,520
code that exists for

1236
00:46:44,290 --> 00:46:50,390
array.prototype of index of and radar

1237
00:46:46,520 --> 00:46:52,730
protocol includes and it replaces this

1238
00:46:50,390 --> 00:46:54,500
code with optimized machine code when it

1239
00:46:52,730 --> 00:46:58,250
knows for a fact that the elements kind

1240
00:46:54,500 --> 00:46:59,900
of the array that the functions or the

1241
00:46:58,250 --> 00:47:01,700
methods index oven includes is being

1242
00:46:59,900 --> 00:47:03,650
called on when it knows that the

1243
00:47:01,700 --> 00:47:06,620
elements kind of that specific array is

1244
00:47:03,650 --> 00:47:08,600
a fast elements kind so fast here

1245
00:47:06,620 --> 00:47:10,759
meaning that the array only stores small

1246
00:47:08,600 --> 00:47:12,650
integers or floating-point values when

1247
00:47:10,760 --> 00:47:16,070
it knows this it can you know replace

1248
00:47:12,650 --> 00:47:17,540
the replace the code with optimized

1249
00:47:16,070 --> 00:47:19,940
machine code because it knows exactly

1250
00:47:17,540 --> 00:47:20,450
how to access each index as I explained

1251
00:47:19,940 --> 00:47:23,750
before

1252
00:47:20,450 --> 00:47:26,540
so initially the function note

1253
00:47:23,750 --> 00:47:29,540
properties in for receiver maps is used

1254
00:47:26,540 --> 00:47:31,400
to infer the map for the array so when

1255
00:47:29,540 --> 00:47:33,110
it when I mean infer what's going to do

1256
00:47:31,400 --> 00:47:34,790
is it's going to if you remember from

1257
00:47:33,110 --> 00:47:36,470
the sea of notes graph every node is

1258
00:47:34,790 --> 00:47:39,230
connected with a line it's going to

1259
00:47:36,470 --> 00:47:40,850
traverse up this line called the effect

1260
00:47:39,230 --> 00:47:42,980
chain it's going to traverse up all

1261
00:47:40,850 --> 00:47:45,140
nodes and it's going to try to gather as

1262
00:47:42,980 --> 00:47:48,530
much information as it can from every

1263
00:47:45,140 --> 00:47:50,270
node to figure out if the map of this

1264
00:47:48,530 --> 00:47:52,810
specific array can be inferred or

1265
00:47:50,270 --> 00:47:56,060
guessed or assume right from from other

1266
00:47:52,810 --> 00:47:58,880
other nodes in the effect chain so to

1267
00:47:56,060 --> 00:48:00,440
say now at the end the function is going

1268
00:47:58,880 --> 00:48:02,330
to bail out back to the interpreter if

1269
00:48:00,440 --> 00:48:04,370
the map if it cannot find any

1270
00:48:02,330 --> 00:48:06,170
information about this map in any of the

1271
00:48:04,370 --> 00:48:08,210
other nodes right and when it bails out

1272
00:48:06,170 --> 00:48:09,980
and no optimized machine code is

1273
00:48:08,210 --> 00:48:11,270
generated and you know it just it just

1274
00:48:09,980 --> 00:48:14,030
bails out to be interpreter into the

1275
00:48:11,270 --> 00:48:15,800
slow path if however a map is found it's

1276
00:48:14,030 --> 00:48:18,410
going to continue with optimized or not

1277
00:48:15,800 --> 00:48:20,270
a map is found if a map is found with a

1278
00:48:18,410 --> 00:48:21,620
fast elements kind specifically it's

1279
00:48:20,270 --> 00:48:24,770
just going to continue to continue with

1280
00:48:21,620 --> 00:48:28,100
optimizing the function right now this

1281
00:48:24,770 --> 00:48:29,180
initially looks fine right like if you

1282
00:48:28,100 --> 00:48:30,830
if you look at this code here it just

1283
00:48:29,180 --> 00:48:32,779
looks fine it's gonna check the map if

1284
00:48:30,830 --> 00:48:34,520
it doesn't if it can't infer about it's

1285
00:48:32,780 --> 00:48:37,580
going to just bail out if it can infer a

1286
00:48:34,520 --> 00:48:39,080
map it's going to create our generate

1287
00:48:37,580 --> 00:48:42,230
optimized machine code for that specific

1288
00:48:39,080 --> 00:48:44,840
map this looks right until you look at

1289
00:48:42,230 --> 00:48:47,570
the return value of infrared receiver

1290
00:48:44,840 --> 00:48:49,640
maps which is the enum info receiver

1291
00:48:47,570 --> 00:48:51,110
Maps result and you can see the return

1292
00:48:49,640 --> 00:48:53,270
value actually has three possible

1293
00:48:51,110 --> 00:48:54,950
returns or if the EP the return value of

1294
00:48:53,270 --> 00:48:57,560
the function can be three possible

1295
00:48:54,950 --> 00:48:59,299
values and the first one is all

1296
00:48:57,560 --> 00:49:00,830
the cane or receiver maths which means

1297
00:48:59,300 --> 00:49:02,870
no receiver maps were inferred the

1298
00:49:00,830 --> 00:49:04,490
second one is K reliable receiver maps

1299
00:49:02,870 --> 00:49:06,830
which means receiver maps that were

1300
00:49:04,490 --> 00:49:08,870
inferred can be trusted the third one is

1301
00:49:06,830 --> 00:49:11,299
K unreliable receiver maps meaning

1302
00:49:08,870 --> 00:49:13,790
receiver maps have been inferred but

1303
00:49:11,300 --> 00:49:15,980
they might have changed because some of

1304
00:49:13,790 --> 00:49:19,190
the notes from before in the graph that

1305
00:49:15,980 --> 00:49:21,260
the infer receiver Maps function uses to

1306
00:49:19,190 --> 00:49:23,390
traverse up the graph some of the other

1307
00:49:21,260 --> 00:49:26,800
notes might have side effects which

1308
00:49:23,390 --> 00:49:29,629
could have possibly changed this race um

1309
00:49:26,800 --> 00:49:32,350
elements kind or this yeah arrays

1310
00:49:29,630 --> 00:49:35,060
elements time in this specific case sir

1311
00:49:32,350 --> 00:49:36,170
yeah so there UK unreliable receiver

1312
00:49:35,060 --> 00:49:38,299
maps tells the compiler that although

1313
00:49:36,170 --> 00:49:40,640
the map has been in firm it is inferred

1314
00:49:38,300 --> 00:49:41,810
it is unreliable and can could have been

1315
00:49:40,640 --> 00:49:45,710
changed by scientific some other

1316
00:49:41,810 --> 00:49:48,170
operations if this happens the caller in

1317
00:49:45,710 --> 00:49:49,790
this case I'm the color the caller

1318
00:49:48,170 --> 00:49:52,370
function whatever whatever the function

1319
00:49:49,790 --> 00:49:55,130
is in which you're calling arrayed on

1320
00:49:52,370 --> 00:49:56,990
index of or radar includes the color

1321
00:49:55,130 --> 00:49:59,360
must guard against possible map changes

1322
00:49:56,990 --> 00:50:01,700
with a runtime check and one way to do

1323
00:49:59,360 --> 00:50:03,320
this is by inserting a check Maps node

1324
00:50:01,700 --> 00:50:04,939
into the graph when you insert a check

1325
00:50:03,320 --> 00:50:07,100
map zone into the graph it's going to

1326
00:50:04,940 --> 00:50:09,890
check to make sure that this arrays map

1327
00:50:07,100 --> 00:50:12,140
matches what it has inferred right

1328
00:50:09,890 --> 00:50:14,779
if the inferred map doesn't match the

1329
00:50:12,140 --> 00:50:16,580
map that it should write if the maps are

1330
00:50:14,780 --> 00:50:18,230
different it's gonna bail out and

1331
00:50:16,580 --> 00:50:19,490
immediately it's gonna bail out and

1332
00:50:18,230 --> 00:50:22,030
immediately go back to the interpreter

1333
00:50:19,490 --> 00:50:24,439
otherwise it's going to continue

1334
00:50:22,030 --> 00:50:26,000
optimizing the function right the

1335
00:50:24,440 --> 00:50:27,410
vulnerability occurs because the

1336
00:50:26,000 --> 00:50:29,180
function fails to account for the case

1337
00:50:27,410 --> 00:50:31,160
where the map is on that map that is

1338
00:50:29,180 --> 00:50:31,879
inferred is unreliable so I'll just go

1339
00:50:31,160 --> 00:50:34,129
back again

1340
00:50:31,880 --> 00:50:36,110
so yeah you can see on the right here on

1341
00:50:34,130 --> 00:50:37,790
the right top right if result equals

1342
00:50:36,110 --> 00:50:39,740
equals null properties cane or receiver

1343
00:50:37,790 --> 00:50:42,590
Maps return no change that's all fine

1344
00:50:39,740 --> 00:50:44,120
however it needs to also check to make

1345
00:50:42,590 --> 00:50:45,950
sure that the result that's return is

1346
00:50:44,120 --> 00:50:47,839
not unreliable right so that's the

1347
00:50:45,950 --> 00:50:50,930
vulnerability the proof of concept is

1348
00:50:47,840 --> 00:50:53,780
pretty short it's pretty simple I'll get

1349
00:50:50,930 --> 00:50:56,569
into what's going on here so initially

1350
00:50:53,780 --> 00:50:58,520
the function is called twice with that

1351
00:50:56,570 --> 00:51:01,040
function f sorry I'll just explain what

1352
00:50:58,520 --> 00:51:04,190
function f so doing actually the

1353
00:51:01,040 --> 00:51:06,529
function f imports an index in an array

1354
00:51:04,190 --> 00:51:07,820
what's happening is ray dot underscore

1355
00:51:06,530 --> 00:51:09,740
underscore defines setter our scorer

1356
00:51:07,820 --> 00:51:11,300
score is being called on one of on

1357
00:51:09,740 --> 00:51:13,069
whatever the indexes

1358
00:51:11,300 --> 00:51:15,650
and when this gets called on a valid

1359
00:51:13,070 --> 00:51:19,280
index of array it'll immediately cause

1360
00:51:15,650 --> 00:51:21,740
this arrays elements time to be changed

1361
00:51:19,280 --> 00:51:24,020
or transformed into a dictionary mode

1362
00:51:21,740 --> 00:51:25,459
elements time right that elements kind

1363
00:51:24,020 --> 00:51:28,009
of wasn't shown in that diagram that I

1364
00:51:25,460 --> 00:51:29,360
showed before but it says on the bottom

1365
00:51:28,010 --> 00:51:30,920
there it'll immediately change the

1366
00:51:29,360 --> 00:51:33,830
arrays elements kind to dictionary

1367
00:51:30,920 --> 00:51:37,640
elements and yeah so that's what that's

1368
00:51:33,830 --> 00:51:39,410
doing and after that uh it says it's

1369
00:51:37,640 --> 00:51:41,120
gonna read out of bounds but array that

1370
00:51:39,410 --> 00:51:43,460
includes one two three four would then

1371
00:51:41,120 --> 00:51:45,350
read through every index of the array in

1372
00:51:43,460 --> 00:51:45,650
order to find the value one two three

1373
00:51:45,350 --> 00:51:48,860
four

1374
00:51:45,650 --> 00:51:51,620
right sir initially the function is

1375
00:51:48,860 --> 00:51:53,660
called twice with an empty string to

1376
00:51:51,620 --> 00:51:55,910
denote an invalid index right so array

1377
00:51:53,660 --> 00:51:58,339
dot on this one when the find setter is

1378
00:51:55,910 --> 00:52:00,259
never called in this case and the second

1379
00:51:58,340 --> 00:52:01,910
argument is just an empty array right an

1380
00:52:00,260 --> 00:52:04,940
empty array is by default have a

1381
00:52:01,910 --> 00:52:06,470
elements kind of packs me elements so in

1382
00:52:04,940 --> 00:52:09,950
empty areas are assumed to only store

1383
00:52:06,470 --> 00:52:12,259
small integers the percentage optimized

1384
00:52:09,950 --> 00:52:13,790
function on next call is a v8 specific

1385
00:52:12,260 --> 00:52:17,120
built-in it doesn't exist in a browser

1386
00:52:13,790 --> 00:52:19,759
what it does in this case is it tells

1387
00:52:17,120 --> 00:52:21,440
the compiler that whatever function is

1388
00:52:19,760 --> 00:52:23,660
being called next needs to be optimized

1389
00:52:21,440 --> 00:52:25,940
okay and the compiler is just gonna

1390
00:52:23,660 --> 00:52:28,399
optimize it the next time when it's

1391
00:52:25,940 --> 00:52:30,650
called so the next and final time it's

1392
00:52:28,400 --> 00:52:31,910
called it's called with a string it

1393
00:52:30,650 --> 00:52:33,290
doesn't have to be a string it just

1394
00:52:31,910 --> 00:52:36,170
called with a string in this case with a

1395
00:52:33,290 --> 00:52:39,980
very large index value and still with an

1396
00:52:36,170 --> 00:52:41,540
empty MPA right so again if you go back

1397
00:52:39,980 --> 00:52:43,460
up to the function when it's being

1398
00:52:41,540 --> 00:52:44,600
called with that empty initially when

1399
00:52:43,460 --> 00:52:46,640
it's being called with the empty string

1400
00:52:44,600 --> 00:52:48,200
array dot underscore is going to find

1401
00:52:46,640 --> 00:52:49,759
setter or a squatter score it's not

1402
00:52:48,200 --> 00:52:51,410
going to do anything right because index

1403
00:52:49,760 --> 00:52:54,380
is invalid so it's not going to

1404
00:52:51,410 --> 00:52:56,600
transition the array stick elements kind

1405
00:52:54,380 --> 00:52:57,140
to dictionary mode because the index is

1406
00:52:56,600 --> 00:52:58,850
invalid

1407
00:52:57,140 --> 00:53:01,310
however at the end when the array is

1408
00:52:58,850 --> 00:53:01,759
optimized and called with index whatever

1409
00:53:01,310 --> 00:53:05,360
that is

1410
00:53:01,760 --> 00:53:07,490
it's going to convert the arrays arrays

1411
00:53:05,360 --> 00:53:09,950
element kind elements client to

1412
00:53:07,490 --> 00:53:11,720
dictionary mode however if you remember

1413
00:53:09,950 --> 00:53:14,180
when the arrays elements kind of

1414
00:53:11,720 --> 00:53:16,339
transform the dictionary mode the the

1415
00:53:14,180 --> 00:53:18,470
map that is inferred will still be

1416
00:53:16,340 --> 00:53:21,110
whatever the map was before because it

1417
00:53:18,470 --> 00:53:23,149
doesn't check for that it doesn't insert

1418
00:53:21,110 --> 00:53:25,140
a check map's node when this happens

1419
00:53:23,150 --> 00:53:27,630
it's going to call an element

1420
00:53:25,140 --> 00:53:29,220
kind confusion between packs new

1421
00:53:27,630 --> 00:53:31,890
elements so an array that only stores

1422
00:53:29,220 --> 00:53:33,990
small integers and an array that only

1423
00:53:31,890 --> 00:53:36,118
stores dictionary elements and the

1424
00:53:33,990 --> 00:53:39,000
problem here is that an array that only

1425
00:53:36,119 --> 00:53:40,559
stores small integers is it takes up

1426
00:53:39,000 --> 00:53:43,529
more space than an array that only

1427
00:53:40,559 --> 00:53:45,599
stores dictionary elements right sir I'm

1428
00:53:43,529 --> 00:53:49,079
calling a raid on includes or a raid on

1429
00:53:45,599 --> 00:53:52,109
index of on this like vulnerable or a

1430
00:53:49,079 --> 00:53:54,539
young and old this array next will cause

1431
00:53:52,109 --> 00:53:57,509
and out of bounds read because index off

1432
00:53:54,539 --> 00:53:58,589
takes up more space or less space sorry

1433
00:53:57,510 --> 00:54:01,230
it takes up less space than the

1434
00:53:58,589 --> 00:54:03,538
dictionary elements would so yeah so

1435
00:54:01,230 --> 00:54:05,670
that's just how you can get an out of

1436
00:54:03,539 --> 00:54:07,410
bounds read and write from this specific

1437
00:54:05,670 --> 00:54:09,210
vulnerability again I'm not going to go

1438
00:54:07,410 --> 00:54:11,490
into the details of how to exploit it if

1439
00:54:09,210 --> 00:54:13,980
you want to know how to exploit it just

1440
00:54:11,490 --> 00:54:15,868
read a Stephens blog post it's very good

1441
00:54:13,980 --> 00:54:19,019
goes into a lot of detail about it but

1442
00:54:15,869 --> 00:54:21,180
essentially this lets you get a relative

1443
00:54:19,019 --> 00:54:26,879
or out of bounds read and out of bounds

1444
00:54:21,180 --> 00:54:28,649
right out of this primitive sir okay so

1445
00:54:26,880 --> 00:54:31,650
yeah the patch essentially was just to

1446
00:54:28,650 --> 00:54:33,660
add the unreliable map check I guess it

1447
00:54:31,650 --> 00:54:36,599
just checks if result equals equals K

1448
00:54:33,660 --> 00:54:38,460
unreliable receiver Maps just insert and

1449
00:54:36,599 --> 00:54:41,009
you know it into the graph that's a

1450
00:54:38,460 --> 00:54:42,900
check maps node that checks for the map

1451
00:54:41,009 --> 00:54:44,910
the receiver underscore maps argument

1452
00:54:42,900 --> 00:54:46,529
which is the inferred map right so I

1453
00:54:44,910 --> 00:54:47,759
mean it just insert the check map node

1454
00:54:46,529 --> 00:54:50,309
into the sea of notes graph and it's

1455
00:54:47,759 --> 00:54:52,500
just an easy fix it's like a eight line

1456
00:54:50,309 --> 00:54:54,900
nine line fix it's pretty simple but

1457
00:54:52,500 --> 00:54:57,329
again this this sort of like shows you

1458
00:54:54,900 --> 00:54:58,890
how unique vulnerability classes can be

1459
00:54:57,329 --> 00:55:00,420
like you're never going to find a

1460
00:54:58,890 --> 00:55:02,519
vulnerability like this in any other

1461
00:55:00,420 --> 00:55:07,019
application it only exists because of

1462
00:55:02,519 --> 00:55:09,000
how complex the v8 engine or how complex

1463
00:55:07,019 --> 00:55:11,069
the v8 engines turbofan optimizing

1464
00:55:09,000 --> 00:55:13,529
compiler is but it tries to make

1465
00:55:11,069 --> 00:55:15,509
assumptions it tries to optimize machine

1466
00:55:13,529 --> 00:55:17,609
code based on these assumptions the

1467
00:55:15,509 --> 00:55:19,829
assumptions are incorrect which they are

1468
00:55:17,609 --> 00:55:23,009
in this case you can get an exploitable

1469
00:55:19,829 --> 00:55:24,630
primitive out of it so that's it for

1470
00:55:23,009 --> 00:55:27,359
vulnerabilities are five minutes left so

1471
00:55:24,630 --> 00:55:28,680
I gotta go quick so how do you start on

1472
00:55:27,359 --> 00:55:30,839
v8 right

1473
00:55:28,680 --> 00:55:33,779
this is this is gonna be my opinion I

1474
00:55:30,839 --> 00:55:35,130
guess because I this is like an end-all

1475
00:55:33,779 --> 00:55:37,289
be-all the way I'm getting started on v8

1476
00:55:35,130 --> 00:55:38,700
it's just how I did it the first thing

1477
00:55:37,289 --> 00:55:38,850
you would start off with our you know

1478
00:55:38,700 --> 00:55:40,740
you

1479
00:55:38,850 --> 00:55:43,020
watch some talks like this one that

1480
00:55:40,740 --> 00:55:45,029
explains some of the internals of v8 you

1481
00:55:43,020 --> 00:55:47,280
can read some blog post about it as well

1482
00:55:45,030 --> 00:55:49,410
that's what I did in the beginning the

1483
00:55:47,280 --> 00:55:51,450
next thing I did was I tried to do an

1484
00:55:49,410 --> 00:55:53,279
easy browser exploitation CTF challenge

1485
00:55:51,450 --> 00:55:54,839
and I picked an easy one where it was

1486
00:55:53,280 --> 00:55:57,210
just it would just give you a relative

1487
00:55:54,840 --> 00:55:58,650
out of bounce read / write primitive

1488
00:55:57,210 --> 00:56:00,300
straight off the bat and you will need

1489
00:55:58,650 --> 00:56:02,400
to use it to gain code execution

1490
00:56:00,300 --> 00:56:05,700
I like those challenges because if they

1491
00:56:02,400 --> 00:56:06,930
force you to sort of fill in any gaps in

1492
00:56:05,700 --> 00:56:09,000
your knowledge that you might have

1493
00:56:06,930 --> 00:56:10,799
because you have to understand every

1494
00:56:09,000 --> 00:56:12,480
single bit of your exploit otherwise you

1495
00:56:10,800 --> 00:56:14,880
won't you know you won't get it you can

1496
00:56:12,480 --> 00:56:16,110
find a write-up of that challenge on my

1497
00:56:14,880 --> 00:56:18,840
Twitter it should be pinned on my

1498
00:56:16,110 --> 00:56:20,310
Twitter profile I think so yeah it's a

1499
00:56:18,840 --> 00:56:21,930
very detailed write-up I wrote it up as

1500
00:56:20,310 --> 00:56:23,850
best as I could so hopefully you know if

1501
00:56:21,930 --> 00:56:25,490
you want to get into v8 you might want

1502
00:56:23,850 --> 00:56:29,190
to give that CTF challenge a try as well

1503
00:56:25,490 --> 00:56:31,200
so next what I did was I picked a very

1504
00:56:29,190 --> 00:56:33,360
detailed write-up slash bug report and

1505
00:56:31,200 --> 00:56:35,339
decided to analyze it and when you do

1506
00:56:33,360 --> 00:56:37,440
this when I say analyze I mean you know

1507
00:56:35,340 --> 00:56:39,300
you try to look at the bug report you

1508
00:56:37,440 --> 00:56:41,130
look at the exploit you try to read the

1509
00:56:39,300 --> 00:56:42,750
code that you know where the

1510
00:56:41,130 --> 00:56:44,720
vulnerability is you try to understand

1511
00:56:42,750 --> 00:56:47,730
the code as fast as you can you

1512
00:56:44,720 --> 00:56:50,279
essentially try to place yourself in the

1513
00:56:47,730 --> 00:56:52,800
bug reporters feet and or bug reporters

1514
00:56:50,280 --> 00:56:54,660
shoes sorry and you try to you know you

1515
00:56:52,800 --> 00:56:56,970
try to understand what the vulnerability

1516
00:56:54,660 --> 00:56:58,379
is and when you do this you learn a lot

1517
00:56:56,970 --> 00:57:00,629
about the engine right you're reading

1518
00:56:58,380 --> 00:57:02,880
code you're just you're learning a lot

1519
00:57:00,630 --> 00:57:05,280
right and this helps you keep on like

1520
00:57:02,880 --> 00:57:07,740
becoming a better researcher in v8 or

1521
00:57:05,280 --> 00:57:09,240
within any target really so yeah that's

1522
00:57:07,740 --> 00:57:11,430
how I started I just picked a very

1523
00:57:09,240 --> 00:57:12,959
detailed bug report and just like went

1524
00:57:11,430 --> 00:57:15,930
ham with it I did this a couple times

1525
00:57:12,960 --> 00:57:17,490
but what you want to do is you want to

1526
00:57:15,930 --> 00:57:19,440
slowly move on to lesser and lesser

1527
00:57:17,490 --> 00:57:21,509
detailed bug reports right so bug report

1528
00:57:19,440 --> 00:57:23,510
that like say they only give you a proof

1529
00:57:21,510 --> 00:57:26,070
of concept or they only give you like

1530
00:57:23,510 --> 00:57:28,140
like you only have a patch right a patch

1531
00:57:26,070 --> 00:57:29,580
to the bug but no proof of concept when

1532
00:57:28,140 --> 00:57:31,560
you have this this is where you know

1533
00:57:29,580 --> 00:57:35,100
your knowledge is truly tested you have

1534
00:57:31,560 --> 00:57:36,870
to use just the code base essentially

1535
00:57:35,100 --> 00:57:38,430
and your knowledge of the engine to

1536
00:57:36,870 --> 00:57:40,589
figure out what the vulnerability is and

1537
00:57:38,430 --> 00:57:43,589
how to exploit it obviously when you do

1538
00:57:40,590 --> 00:57:45,210
your analysis of these bugs you want to

1539
00:57:43,590 --> 00:57:47,130
also write the expose at the same time

1540
00:57:45,210 --> 00:57:48,780
if they're exportable because writing

1541
00:57:47,130 --> 00:57:51,090
exports is one of the best way to learn

1542
00:57:48,780 --> 00:57:54,110
again how the engine works

1543
00:57:51,090 --> 00:57:56,580
yeah this is how I would go about it

1544
00:57:54,110 --> 00:57:58,770
after this after you've gone through

1545
00:57:56,580 --> 00:58:00,210
this sort of phase I guess if you want

1546
00:57:58,770 --> 00:58:02,550
to find your own vulnerabilities I would

1547
00:58:00,210 --> 00:58:04,530
say you take an older bug it doesn't

1548
00:58:02,550 --> 00:58:06,120
matter how old it is even very old bugs

1549
00:58:04,530 --> 00:58:07,560
can show up unless you know the

1550
00:58:06,120 --> 00:58:09,960
component that they're in has been

1551
00:58:07,560 --> 00:58:11,400
deprecated they will they can't show up

1552
00:58:09,960 --> 00:58:13,500
so what you want to do is you want to

1553
00:58:11,400 --> 00:58:15,270
take an older bug and you want to

1554
00:58:13,500 --> 00:58:17,400
generalize it as best as you can into a

1555
00:58:15,270 --> 00:58:19,530
buck cost and you want to look for

1556
00:58:17,400 --> 00:58:20,010
similar ones right so the example that I

1557
00:58:19,530 --> 00:58:23,030
just gave

1558
00:58:20,010 --> 00:58:26,880
with the chromium issue by Steven and

1559
00:58:23,030 --> 00:58:29,610
Samuel gross you the the buck class

1560
00:58:26,880 --> 00:58:31,440
itself is that there is in an

1561
00:58:29,610 --> 00:58:33,120
optimization done by the JIT compiler

1562
00:58:31,440 --> 00:58:35,340
where the compiler makes a wrongful

1563
00:58:33,120 --> 00:58:37,710
assumption and you would try to look for

1564
00:58:35,340 --> 00:58:39,870
these wrongful assumptions in the

1565
00:58:37,710 --> 00:58:41,550
codebase everywhere right and remember

1566
00:58:39,870 --> 00:58:44,460
new code is added every day so you are

1567
00:58:41,550 --> 00:58:47,010
likely to find a new vulnerability

1568
00:58:44,460 --> 00:58:49,530
somehow but through code review if you

1569
00:58:47,010 --> 00:58:51,480
if you put in enough time code review is

1570
00:58:49,530 --> 00:58:53,760
slower it takes a long time but if you

1571
00:58:51,480 --> 00:58:56,160
put in enough time you might work

1572
00:58:53,760 --> 00:58:58,050
the other alternative to this is to just

1573
00:58:56,160 --> 00:59:00,450
you know fuzz everything right in right

1574
00:58:58,050 --> 00:59:04,800
buzzes fuzzing is a big topic especially

1575
00:59:00,450 --> 00:59:06,450
within browser exploitation so yeah at

1576
00:59:04,800 --> 00:59:08,910
the end there are some useful things

1577
00:59:06,450 --> 00:59:10,649
here you can I'm running out of time

1578
00:59:08,910 --> 00:59:11,790
here I should probably stop so yeah

1579
00:59:10,650 --> 00:59:13,230
thanks to the up team for hosting

1580
00:59:11,790 --> 00:59:14,460
this event feel free to add me on the

1581
00:59:13,230 --> 00:59:16,490
discord ask me any questions you may

1582
00:59:14,460 --> 00:59:16,490
have

