1
00:00:03,050 --> 00:00:07,880
[Music]

2
00:00:07,880 --> 00:00:10,879
thank you

3
00:00:20,279 --> 00:00:21,900
this was a round of applause I guess

4
00:00:21,900 --> 00:00:25,279
right yeah let's continue

5
00:00:28,279 --> 00:00:34,260
happiness fresh air allergies foreign

6
00:00:41,760 --> 00:00:43,739
stretching his presentation as much as

7
00:00:43,739 --> 00:00:47,180
possible but we will see the guy

8
00:00:47,660 --> 00:00:52,459
the 40 minutes are yours

9
00:00:53,480 --> 00:00:56,460
yeah great to see so many people I

10
00:00:56,460 --> 00:00:58,379
approach the presentation from YouTube

11
00:00:58,379 --> 00:01:02,219
about the guts of python and not only

12
00:01:02,219 --> 00:01:04,099
pythons

13
00:01:04,099 --> 00:01:06,720
since we are have been talking about the

14
00:01:06,720 --> 00:01:08,180
compiler

15
00:01:08,180 --> 00:01:12,080
we need to introduce you

16
00:01:12,500 --> 00:01:16,020
believe that front is something visual

17
00:01:16,020 --> 00:01:17,960
backhand is

18
00:01:17,960 --> 00:01:21,600
not like that they have front and parser

19
00:01:21,600 --> 00:01:23,939
from the card into some kind of tree and

20
00:01:23,939 --> 00:01:25,920
back end is what's actually being

21
00:01:25,920 --> 00:01:29,100
executed on the actual CPU or GPU or

22
00:01:29,100 --> 00:01:32,820
special pu middle there's also Midland

23
00:01:32,820 --> 00:01:36,720
that is in charge of um I mean there are

24
00:01:36,720 --> 00:01:39,540
intermediary things in Midland and they

25
00:01:39,540 --> 00:01:42,240
are also in the back end but in Midland

26
00:01:42,240 --> 00:01:43,439
they're not related to the actual

27
00:01:43,439 --> 00:01:46,079
process sir but they are important in

28
00:01:46,079 --> 00:01:48,920
the back end that's the difference

29
00:01:48,920 --> 00:01:51,180
then we'll be talking in some more

30
00:01:51,180 --> 00:01:53,210
detail particularly about python

31
00:01:53,210 --> 00:01:53,939
[Music]

32
00:01:53,939 --> 00:01:55,939
um

33
00:01:57,079 --> 00:02:00,200
on this slide

34
00:02:00,200 --> 00:02:03,840
compiling conveyor on sea pipes it's

35
00:02:03,840 --> 00:02:05,219
pretty much it you can take a look and

36
00:02:05,219 --> 00:02:06,899
you can go and have a cup of coffee no

37
00:02:06,899 --> 00:02:07,940
uh

38
00:02:07,940 --> 00:02:11,580
front and if python is actually the

39
00:02:11,580 --> 00:02:15,420
so-called tokenizer also parser into a

40
00:02:15,420 --> 00:02:16,879
syntactic tree

41
00:02:16,879 --> 00:02:22,520
intermediary notion in Python is uh um

42
00:02:22,520 --> 00:02:25,500
backhand is the virtual machine that

43
00:02:25,500 --> 00:02:28,340
executes that one

44
00:02:29,300 --> 00:02:32,400
compared to other compiler in Python if

45
00:02:32,400 --> 00:02:34,020
they can actually drag it out of python

46
00:02:34,020 --> 00:02:36,420
if you want to all of the modules and

47
00:02:36,420 --> 00:02:39,540
built-in functions which actually do all

48
00:02:39,540 --> 00:02:43,200
of this it's called conveyor compiler

49
00:02:43,200 --> 00:02:47,000
and this is Christianity

50
00:02:47,000 --> 00:02:49,680
there are some abbreviations that you

51
00:02:49,680 --> 00:02:53,040
don't know here CFG control graph almost

52
00:02:53,040 --> 00:02:54,560
like byte code but there are some jumps

53
00:02:54,560 --> 00:02:57,560
uncalculated there

54
00:02:57,560 --> 00:03:00,239
and now we'll look into some more

55
00:03:00,239 --> 00:03:01,819
details

56
00:03:01,819 --> 00:03:05,340
a very simple thing roughly we have

57
00:03:05,340 --> 00:03:08,040
three tokens it's better to have five

58
00:03:08,040 --> 00:03:10,819
tokens as they say

59
00:03:10,819 --> 00:03:13,379
tokenizer does not know anything about

60
00:03:13,379 --> 00:03:16,440
what it is how it works that's kind of a

61
00:03:16,440 --> 00:03:21,200
sequence of symbols for chunks

62
00:03:23,060 --> 00:03:25,580
transmitted to the grammar

63
00:03:25,580 --> 00:03:29,159
and the tokenized module in Python it's

64
00:03:29,159 --> 00:03:32,760
not very useful you can import it from a

65
00:03:32,760 --> 00:03:35,780
file or you can put it apart

66
00:03:35,780 --> 00:03:38,879
frankly I have not encountered like real

67
00:03:38,879 --> 00:03:41,040
life tasks that could be solved with the

68
00:03:41,040 --> 00:03:43,099
tokenizer mostly

69
00:03:43,099 --> 00:03:45,180
it depends on

70
00:03:45,180 --> 00:03:47,920
foreign

71
00:03:47,920 --> 00:03:51,030
[Music]

72
00:04:07,340 --> 00:04:11,900
left one and right one and um

73
00:04:11,900 --> 00:04:14,220
there are some numbers to it nothing

74
00:04:14,220 --> 00:04:15,620
extremely complicated

75
00:04:15,620 --> 00:04:17,478
[Music]

76
00:04:17,478 --> 00:04:21,120
but there are more exciting things there

77
00:04:21,120 --> 00:04:22,940
than um

78
00:04:22,940 --> 00:04:26,160
you can use it as a script look at the

79
00:04:26,160 --> 00:04:27,620
help

80
00:04:27,620 --> 00:04:31,919
or you can unparse something and the

81
00:04:31,919 --> 00:04:34,680
most exciting thing is

82
00:04:34,680 --> 00:04:37,139
how can you actually look at what you've

83
00:04:37,139 --> 00:04:39,139
been unparsing

84
00:04:39,139 --> 00:04:41,720
is

85
00:04:41,720 --> 00:04:44,460
the so-called visitor pattern from

86
00:04:44,460 --> 00:04:47,220
pattern design that can allow you to

87
00:04:47,220 --> 00:04:49,080
kind of procedurally go through the

88
00:04:49,080 --> 00:04:54,080
syntactic tree at every knot we can um

89
00:05:12,860 --> 00:05:15,680
[Music]

90
00:05:15,680 --> 00:05:18,360
or we can just go down the generator

91
00:05:18,360 --> 00:05:20,100
with the for Loop and go through every

92
00:05:20,100 --> 00:05:21,479
nod

93
00:05:21,479 --> 00:05:23,539
um

94
00:05:27,320 --> 00:05:29,699
there's also the lightweight version of

95
00:05:29,699 --> 00:05:31,560
eval raise your hand if you know what

96
00:05:31,560 --> 00:05:32,960
eval is

97
00:05:32,960 --> 00:05:36,419
quite a few great there is a more

98
00:05:36,419 --> 00:05:41,359
lightweight version of it it's more safe

99
00:05:42,320 --> 00:05:44,400
very secure if you want to write a

100
00:05:44,400 --> 00:05:46,940
secure code

101
00:05:49,280 --> 00:05:52,560
just you know fail python interpret

102
00:05:52,560 --> 00:05:54,419
interpreter into the score dump if you

103
00:05:54,419 --> 00:05:56,699
want to foreign

104
00:05:56,699 --> 00:05:58,560
uh Beware

105
00:05:58,560 --> 00:06:01,460
and um

106
00:06:01,520 --> 00:06:04,639
there's also a cool thing

107
00:06:04,639 --> 00:06:07,080
that you can actually transfer it into

108
00:06:07,080 --> 00:06:09,800
the source code

109
00:06:11,240 --> 00:06:13,800
you can put it together not from the

110
00:06:13,800 --> 00:06:15,979
source code but

111
00:06:15,979 --> 00:06:19,080
based on your very own algorithm quick

112
00:06:19,080 --> 00:06:22,820
and create the tree yeah

113
00:06:23,300 --> 00:06:25,740
here you have the python code the source

114
00:06:25,740 --> 00:06:27,360
code congrats

115
00:06:27,360 --> 00:06:30,360
foreign

116
00:06:36,180 --> 00:06:39,419
it was introduced with python 3.9 before

117
00:06:39,419 --> 00:06:42,300
that they had a parser based on ll1

118
00:06:42,300 --> 00:06:44,759
grammar probably don't know what this is

119
00:06:44,759 --> 00:06:46,020
about but

120
00:06:46,020 --> 00:06:49,500
the major reason why it was slow and not

121
00:06:49,500 --> 00:06:51,780
so great because in addition to abstract

122
00:06:51,780 --> 00:06:53,160
synthetic tree they also had

123
00:06:53,160 --> 00:06:54,380
intermediary

124
00:06:54,380 --> 00:06:57,060
that was kind of pushing the memory

125
00:06:57,060 --> 00:07:00,319
pretty well sometimes too well

126
00:07:00,860 --> 00:07:05,240
accordingly Guido came together once

127
00:07:05,240 --> 00:07:08,580
you're based PG grammar without

128
00:07:08,580 --> 00:07:10,740
intermediate tree it's more memory

129
00:07:10,740 --> 00:07:12,620
efficient than just faster Expedition

130
00:07:12,620 --> 00:07:16,940
and one of the reasons why yeah

131
00:07:17,000 --> 00:07:21,120
two to three another kind of um nail and

132
00:07:21,120 --> 00:07:23,580
a coffin of 2.7 is that the converter

133
00:07:23,580 --> 00:07:27,120
2.3 to two to three which dependent was

134
00:07:27,120 --> 00:07:29,340
dependent on the old parser and in 310

135
00:07:29,340 --> 00:07:31,860
it was completely removed I heard that

136
00:07:31,860 --> 00:07:35,099
there are some Forks to three library

137
00:07:35,099 --> 00:07:36,440
that can

138
00:07:36,440 --> 00:07:39,599
convert 2.7 code with a pack parser but

139
00:07:39,599 --> 00:07:42,840
that's extravagant

140
00:07:42,960 --> 00:07:44,960
um

141
00:07:46,280 --> 00:07:49,800
if we look at the images here's how it

142
00:07:49,800 --> 00:07:53,120
looks as a plot

143
00:07:53,960 --> 00:07:56,880
so at the output of the grammar we have

144
00:07:56,880 --> 00:07:58,380
some function generated automatically

145
00:07:58,380 --> 00:08:01,520
the C function

146
00:08:01,699 --> 00:08:05,220
which creates different types of ASD not

147
00:08:05,220 --> 00:08:06,840
for every node there is a function

148
00:08:06,840 --> 00:08:09,539
generated so this generator was the old

149
00:08:09,539 --> 00:08:11,580
parser and the new parser it's still

150
00:08:11,580 --> 00:08:14,160
there but the grammar has become a more

151
00:08:14,160 --> 00:08:17,400
gradual in the end there are more less

152
00:08:17,400 --> 00:08:19,818
crutches

153
00:08:22,220 --> 00:08:26,240
this is included right into the rules

154
00:08:26,720 --> 00:08:28,919
we will not be looking too much at the

155
00:08:28,919 --> 00:08:30,539
formal grammar we will just not have

156
00:08:30,539 --> 00:08:32,900
enough time

157
00:08:33,080 --> 00:08:37,219
another cool thing in Python is

158
00:08:37,339 --> 00:08:39,719
been generated we can generate it not

159
00:08:39,719 --> 00:08:42,659
only on C but all but in pure python as

160
00:08:42,659 --> 00:08:44,700
well for example if you don't know

161
00:08:44,700 --> 00:08:46,920
anything about grammar you want to add

162
00:08:46,920 --> 00:08:50,540
some keywords new keyword try it

163
00:08:50,640 --> 00:08:53,360
you did it

164
00:08:58,920 --> 00:09:02,079
[Music]

165
00:09:03,740 --> 00:09:06,360
whether it's correct and generated in C

166
00:09:06,360 --> 00:09:09,560
and make a pull request

167
00:09:10,399 --> 00:09:12,740
there are some drawbacks

168
00:09:12,740 --> 00:09:16,380
which are inherent to python parser it

169
00:09:16,380 --> 00:09:18,060
has cross dependencies to current

170
00:09:18,060 --> 00:09:23,240
virtual machine so we cannot just slice

171
00:09:23,240 --> 00:09:26,600
of the VM that's executing the byte code

172
00:09:26,600 --> 00:09:28,940
which would have been cool

173
00:09:28,940 --> 00:09:31,140
to make the distribution of code more

174
00:09:31,140 --> 00:09:33,060
compact for example but I believe that

175
00:09:33,060 --> 00:09:36,420
in the future sometimes someday they

176
00:09:36,420 --> 00:09:38,760
will slice it somehow maybe I will even

177
00:09:38,760 --> 00:09:39,860
help

178
00:09:39,860 --> 00:09:42,600
and another another point about

179
00:09:42,600 --> 00:09:44,060
applications

180
00:09:44,060 --> 00:09:47,240
I personally applied

181
00:09:47,240 --> 00:09:50,600
anti-plagiarism script

182
00:09:50,600 --> 00:09:52,800
you know that students often when they

183
00:09:52,800 --> 00:09:57,080
send you to an assignment hey

184
00:09:57,080 --> 00:09:59,820
that sometimes even not remain anything

185
00:09:59,820 --> 00:10:01,519
sometimes they remain stuff and even

186
00:10:01,519 --> 00:10:03,980
swap methods you know

187
00:10:03,980 --> 00:10:06,980
foreign

188
00:10:31,519 --> 00:10:33,720
it's a very useful thing to look into

189
00:10:33,720 --> 00:10:35,580
and see how it's working and in addition

190
00:10:35,580 --> 00:10:37,940
to that

191
00:10:56,580 --> 00:10:59,659
[Music]

192
00:11:05,000 --> 00:11:08,480
I didn't mean anything

193
00:11:29,480 --> 00:11:32,160
and according to the compiler Theory

194
00:11:32,160 --> 00:11:35,579
there are three shapes of ir and byte

195
00:11:35,579 --> 00:11:37,040
code is one of those

196
00:11:37,040 --> 00:11:40,500
that's when we have the sequence of

197
00:11:40,500 --> 00:11:42,620
bites

198
00:11:42,620 --> 00:11:45,060
but in reality it's much better to look

199
00:11:45,060 --> 00:11:47,479
at the lines

200
00:11:47,600 --> 00:11:51,680
the printout of interior representation

201
00:11:51,680 --> 00:11:53,640
which as a matter of fact is very

202
00:11:53,640 --> 00:11:55,800
readable and it's not really far from

203
00:11:55,800 --> 00:11:59,719
the source code it's not yet assembler

204
00:12:14,180 --> 00:12:16,519
[Music]

205
00:12:16,519 --> 00:12:19,920
and we see here that the coded function

206
00:12:19,920 --> 00:12:23,240
itself is the last four numbers

207
00:12:23,640 --> 00:12:27,600
uh the rest is kind of the uh

208
00:12:27,600 --> 00:12:29,760
declaration if you want to look at the

209
00:12:29,760 --> 00:12:32,240
function itself we can be easier we can

210
00:12:32,240 --> 00:12:34,560
never need to look at the disassembler

211
00:12:34,560 --> 00:12:36,180
and just shove their function as an

212
00:12:36,180 --> 00:12:38,959
object you don't need to compile when we

213
00:12:38,959 --> 00:12:42,500
declare the functions

214
00:12:44,120 --> 00:12:47,459
there is a byte code in lines there are

215
00:12:47,459 --> 00:12:50,000
two parameters in the memory and we

216
00:12:50,000 --> 00:12:52,320
disassemble it

217
00:12:52,320 --> 00:12:55,320
code

218
00:13:00,440 --> 00:13:03,060
there are certain optimizations that we

219
00:13:03,060 --> 00:13:06,060
observe python 311 for example there's

220
00:13:06,060 --> 00:13:08,880
this thing called specialization of the

221
00:13:08,880 --> 00:13:10,680
byte code meaning that certain

222
00:13:10,680 --> 00:13:12,600
operations in the bytecode are becoming

223
00:13:12,600 --> 00:13:15,680
specialized for a particular data type

224
00:13:15,680 --> 00:13:18,079
for example

225
00:13:18,079 --> 00:13:20,459
disassemblers can highlight that and if

226
00:13:20,459 --> 00:13:22,880
we tell him that adaptive is true

227
00:13:22,880 --> 00:13:26,519
we can actually heat that function up

228
00:13:26,519 --> 00:13:31,880
with the integers and we see that

229
00:13:31,880 --> 00:13:36,620
addition is geared up for integers

230
00:13:36,620 --> 00:13:37,760
[Music]

231
00:13:37,760 --> 00:13:43,040
and there is kind of a counter uh

232
00:13:43,100 --> 00:13:45,660
we gave ends ten times but the country

233
00:13:45,660 --> 00:13:48,260
says 53. I don't know why

234
00:13:48,260 --> 00:13:52,260
maybe there's some bit values in there

235
00:13:52,260 --> 00:13:54,380
um

236
00:13:56,279 --> 00:13:59,160
so the abstract instruction goes into

237
00:13:59,160 --> 00:14:02,420
this specialized more adapted to data

238
00:14:02,420 --> 00:14:07,279
and also we can make a step back

239
00:14:08,300 --> 00:14:12,500
just I mean we have optimized now

240
00:14:12,500 --> 00:14:15,380
we have lines

241
00:14:15,380 --> 00:14:19,339
or floats um

242
00:14:25,040 --> 00:14:27,240
we need to make a step back and then

243
00:14:27,240 --> 00:14:28,740
make a step forward but in a different

244
00:14:28,740 --> 00:14:32,459
direction so that's uh that's an

245
00:14:32,459 --> 00:14:34,639
acceleration definitely

246
00:14:34,639 --> 00:14:37,920
10 to 60 when we were doing that and in

247
00:14:37,920 --> 00:14:41,399
Python 312 that's been expanded there

248
00:14:41,399 --> 00:14:43,940
will be a couple of instructions

249
00:14:43,940 --> 00:14:46,220
and more things

250
00:14:46,220 --> 00:14:49,399
specialized more

251
00:15:25,040 --> 00:15:27,540
so it's returned to not what we used to

252
00:15:27,540 --> 00:15:30,360
have but something similar and

253
00:15:30,360 --> 00:15:33,060
um we need to continue continue pressing

254
00:15:33,060 --> 00:15:37,399
on and in the end says well you guys

255
00:15:37,399 --> 00:15:40,260
okay that will be

256
00:15:40,260 --> 00:15:42,660
um uh exciting kind of a Unicode lines

257
00:15:42,660 --> 00:15:45,079
Edition

258
00:15:46,760 --> 00:15:50,480
a bonus for attention

259
00:16:06,560 --> 00:16:10,518
there should be one double instruction

260
00:16:31,220 --> 00:16:33,899
by the way that's why F strings are so

261
00:16:33,899 --> 00:16:36,019
fast

262
00:16:49,339 --> 00:16:52,440
it's getting nasty stack machine a stack

263
00:16:52,440 --> 00:16:54,440
virtual machine

264
00:16:54,440 --> 00:16:56,759
they're uh not only stack virtual

265
00:16:56,759 --> 00:17:01,100
machine it's in the sea uh

266
00:17:01,100 --> 00:17:03,600
evaluation Loop in Python other

267
00:17:03,600 --> 00:17:05,760
compilers didn't have that that's

268
00:17:05,760 --> 00:17:08,339
actually cycle uh according to the

269
00:17:08,339 --> 00:17:11,418
instructions and um

270
00:17:15,559 --> 00:17:17,959
instruction works

271
00:17:17,959 --> 00:17:21,119
I decided to show the C code it's not so

272
00:17:21,119 --> 00:17:23,900
scary you can see here something

273
00:17:23,900 --> 00:17:27,319
reasonable yeah so there's this

274
00:17:27,319 --> 00:17:32,460
optimization if if we

275
00:17:33,179 --> 00:17:35,340
and are going to return to the abstract

276
00:17:35,340 --> 00:17:38,460
version of the instructions so there are

277
00:17:38,460 --> 00:17:40,080
there is a statistical counter that

278
00:17:40,080 --> 00:17:42,620
expands

279
00:17:43,740 --> 00:17:44,960
um

280
00:17:44,960 --> 00:17:48,260
there is addition

281
00:17:48,260 --> 00:17:51,059
wise we're doing the decrement counter

282
00:17:51,059 --> 00:17:52,640
so we

283
00:17:52,640 --> 00:17:56,760
decrement the counter of links so where

284
00:17:56,760 --> 00:18:00,080
do we increment it then

285
00:18:00,080 --> 00:18:02,700
I mean we're decrementing it how do we

286
00:18:02,700 --> 00:18:04,039
incrementing it

287
00:18:04,039 --> 00:18:07,640
it's a matter of fact

288
00:18:08,299 --> 00:18:09,960
it's happening in the previous

289
00:18:09,960 --> 00:18:12,179
instruction called load fast which is

290
00:18:12,179 --> 00:18:14,360
quite logical isn't it I just didn't

291
00:18:14,360 --> 00:18:17,640
that's right away and also we see that

292
00:18:17,640 --> 00:18:19,280
there is a certain step here

293
00:18:19,280 --> 00:18:22,760
which is a matter of fact

294
00:18:22,760 --> 00:18:26,340
that's a different entity but the stack

295
00:18:26,340 --> 00:18:28,559
on which virtual machine works that's a

296
00:18:28,559 --> 00:18:30,960
different kind of stuff

297
00:18:30,960 --> 00:18:32,460
and you don't have to know how many

298
00:18:32,460 --> 00:18:34,679
questions

299
00:18:34,679 --> 00:18:38,299
if you don't want to write another VM

300
00:18:38,400 --> 00:18:41,000
yes

301
00:18:42,799 --> 00:18:45,919
developers and from London there is

302
00:18:45,919 --> 00:18:49,679
and generally we could hope that to be

303
00:18:49,679 --> 00:18:54,780
faster than the stats so far though no

304
00:18:54,780 --> 00:18:57,980
and it will not get into 312.

305
00:18:57,980 --> 00:19:01,620
maybe not even 3 13. but there is a

306
00:19:01,620 --> 00:19:03,120
development like that

307
00:19:03,120 --> 00:19:05,120
um

308
00:19:06,860 --> 00:19:09,960
we've seen this function already there's

309
00:19:09,960 --> 00:19:12,900
internal API which replaces this

310
00:19:12,900 --> 00:19:15,630
function into a virtual machine

311
00:19:15,630 --> 00:19:19,620
[Music]

312
00:19:19,620 --> 00:19:23,479
I could wrap up here but no

313
00:19:23,880 --> 00:19:25,440
there's a good book

314
00:19:25,440 --> 00:19:28,100
s

315
00:19:28,220 --> 00:19:31,940
it's quite detailed right

316
00:19:31,940 --> 00:19:34,440
a more compact person is a developer

317
00:19:34,440 --> 00:19:35,419
guys

318
00:19:35,419 --> 00:19:38,179
where we see a lot of

319
00:19:38,179 --> 00:19:41,520
detail on the python interpreter in a

320
00:19:41,520 --> 00:19:44,539
more concise way

321
00:19:45,080 --> 00:19:47,400
I think we should even begin with the

322
00:19:47,400 --> 00:19:50,220
dev guide and then get deeper into the

323
00:19:50,220 --> 00:19:51,299
book

324
00:19:51,299 --> 00:19:54,299
absor

325
00:20:00,240 --> 00:20:02,419
foreign

326
00:20:24,320 --> 00:20:26,840
language ecosystem

327
00:20:26,840 --> 00:20:29,820
but that's a particularity it's not

328
00:20:29,820 --> 00:20:31,400
something negative right

329
00:20:31,400 --> 00:20:33,720
something that's not that great it's

330
00:20:33,720 --> 00:20:36,799
compatibility with C extensions

331
00:20:36,799 --> 00:20:40,220
everything that has wheels numpy pandas

332
00:20:40,220 --> 00:20:43,020
all of those things are not quite

333
00:20:43,020 --> 00:20:45,179
comfortable with bye bye let's just put

334
00:20:45,179 --> 00:20:49,520
it that way and if you have C extensions

335
00:20:52,280 --> 00:20:55,620
with the c types raise your hand if you

336
00:20:55,620 --> 00:20:57,360
know this module and why you'd be using

337
00:20:57,360 --> 00:21:00,959
it and

338
00:21:44,580 --> 00:21:47,619
[Music]

339
00:22:39,559 --> 00:22:43,100
will be gradually trans

340
00:22:45,620 --> 00:22:47,580
there are some more promising

341
00:22:47,580 --> 00:22:50,240
developments

342
00:22:51,080 --> 00:22:52,980
which has been developed by the

343
00:22:52,980 --> 00:22:56,059
engineers from Instagram

344
00:22:56,220 --> 00:23:01,500
uh Facebook and Facebook that's a fork a

345
00:23:01,500 --> 00:23:04,020
python purely with implementation but

346
00:23:04,020 --> 00:23:08,220
not of the VM but jit compilers I mean

347
00:23:08,220 --> 00:23:12,179
as a pie pie it's also on uh jet

348
00:23:12,179 --> 00:23:14,039
compiler it doesn't use any.net it has

349
00:23:14,039 --> 00:23:15,480
its very own implementation and it

350
00:23:15,480 --> 00:23:18,919
doesn't use a ldm

351
00:23:21,440 --> 00:23:24,740
representations high level ir and low

352
00:23:24,740 --> 00:23:26,720
levels

353
00:23:26,720 --> 00:23:31,260
high level IR similar to byte code

354
00:23:31,260 --> 00:23:32,240
um

355
00:23:32,240 --> 00:23:35,039
there is some different preference

356
00:23:35,039 --> 00:23:39,260
counting there and music

357
00:23:39,260 --> 00:23:41,400
but they have not been declaring that it

358
00:23:41,400 --> 00:23:44,000
will be fully comfortable to see python

359
00:23:44,000 --> 00:23:47,480
no probably

360
00:23:49,580 --> 00:23:52,320
the Facebook Engineers have been quite

361
00:23:52,320 --> 00:23:54,740
present

362
00:23:56,120 --> 00:24:00,360
we will go into detail on jit compiler

363
00:24:00,360 --> 00:24:02,460
which can minimize certain functions

364
00:24:02,460 --> 00:24:04,820
probably you heard about numbers

365
00:24:04,820 --> 00:24:07,860
and if you do have a certain function

366
00:24:07,860 --> 00:24:10,340
here's a random example

367
00:24:10,340 --> 00:24:12,679
it calculates whatever

368
00:24:12,679 --> 00:24:15,179
you drop a decorator in this one

369
00:24:15,179 --> 00:24:17,960
parameters

370
00:24:36,860 --> 00:24:39,900
not for any functions

371
00:24:39,900 --> 00:24:42,080
don't judge every single function please

372
00:24:42,080 --> 00:24:45,799
number is using it actually

373
00:24:45,799 --> 00:24:49,820
llvmo a well-known compiled ecosystem

374
00:24:49,820 --> 00:24:55,100
and lightweight python wrapper

375
00:24:55,100 --> 00:24:59,539
and it supports quite a few things

376
00:24:59,600 --> 00:25:02,640
including some parallel things and GPU

377
00:25:02,640 --> 00:25:05,000
based execution

378
00:25:05,000 --> 00:25:08,600
an issue here is that c extensions again

379
00:25:08,600 --> 00:25:11,400
may be quite unpredictable especially if

380
00:25:11,400 --> 00:25:13,559
you're using uh I mean it can be used

381
00:25:13,559 --> 00:25:16,020
with numpy but with pandas numpy doesn't

382
00:25:16,020 --> 00:25:18,320
understand it and therefore

383
00:25:18,320 --> 00:25:21,140
you will not get any acceleration

384
00:25:21,140 --> 00:25:24,120
even there will be overheads and things

385
00:25:24,120 --> 00:25:26,520
will be even slower so if you have a lot

386
00:25:26,520 --> 00:25:29,240
of numpy

387
00:25:32,240 --> 00:25:34,020
I will not be talking a lot about

388
00:25:34,020 --> 00:25:34,980
implementation there's a good

389
00:25:34,980 --> 00:25:38,360
presentation at the last icon

390
00:25:38,360 --> 00:25:40,500
describe in much detail in the

391
00:25:40,500 --> 00:25:42,360
presentation there is a link and you can

392
00:25:42,360 --> 00:25:44,340
find it easily

393
00:25:44,340 --> 00:25:45,140
uh

394
00:25:45,140 --> 00:25:49,400
now let's take a look inside of the gut

395
00:25:49,400 --> 00:25:52,400
well

396
00:25:53,539 --> 00:25:57,120
compiler compilation steps not for

397
00:25:57,120 --> 00:25:59,100
number only but also for other

398
00:25:59,100 --> 00:26:02,220
programming languages like there's Julia

399
00:26:02,220 --> 00:26:03,620
language

400
00:26:03,620 --> 00:26:05,880
anyone heard about Julia programming

401
00:26:05,880 --> 00:26:08,000
language

402
00:26:10,100 --> 00:26:14,279
foreign representations

403
00:26:17,570 --> 00:26:19,940
[Music]

404
00:26:19,940 --> 00:26:22,080
because that's kind of a dynamic

405
00:26:22,080 --> 00:26:24,740
compilers

406
00:26:27,200 --> 00:26:30,620
show types

407
00:26:31,159 --> 00:26:35,159
ecosystem has been geared up to static

408
00:26:35,159 --> 00:26:38,700
languages so you need to dynamically you

409
00:26:38,700 --> 00:26:40,919
need to make Dynamic types into static

410
00:26:40,919 --> 00:26:43,100
types

411
00:26:44,120 --> 00:26:45,720
intermediate representations

412
00:26:45,720 --> 00:26:47,880
environments

413
00:26:47,880 --> 00:26:50,880
uh

414
00:26:55,200 --> 00:26:58,860
type output can be something relatively

415
00:26:58,860 --> 00:27:01,620
complex there are some algorithms so

416
00:27:01,620 --> 00:27:03,600
let's use them however there are cases

417
00:27:03,600 --> 00:27:04,760
when um

418
00:27:04,760 --> 00:27:07,200
these algorithms

419
00:27:07,200 --> 00:27:10,400
no just don't stop

420
00:27:10,400 --> 00:27:12,600
we cannot even call them algorithms

421
00:27:12,600 --> 00:27:15,539
because

422
00:27:15,539 --> 00:27:18,059
algorithm wise it's just not solvable in

423
00:27:18,059 --> 00:27:19,100
any case

424
00:27:19,100 --> 00:27:22,320
some of you have long faces I see it

425
00:27:22,320 --> 00:27:25,279
might seem surprising

426
00:27:25,520 --> 00:27:28,159
article and many thanks

427
00:27:28,159 --> 00:27:30,900
there is an example when my pie just

428
00:27:30,900 --> 00:27:33,140
never stops

429
00:27:33,140 --> 00:27:36,779
you need to try hard for that you have

430
00:27:36,779 --> 00:27:38,520
to engineer that it's not an easy thing

431
00:27:38,520 --> 00:27:41,419
to achieve but still

432
00:27:41,419 --> 00:27:45,240
so questions you cannot make a compiler

433
00:27:45,240 --> 00:27:46,580
can you

434
00:27:46,580 --> 00:27:49,159
well you can

435
00:27:49,159 --> 00:27:51,480
I'll tell you more in a C plus plus

436
00:27:51,480 --> 00:27:53,840
language

437
00:27:54,140 --> 00:27:56,539
I also have types

438
00:27:56,539 --> 00:28:00,200
and also the system there is

439
00:28:00,200 --> 00:28:04,260
templates also is unsolvable algorithm

440
00:28:04,260 --> 00:28:07,140
wise and in certain cases the file is

441
00:28:07,140 --> 00:28:08,880
compiled for a long while and you can

442
00:28:08,880 --> 00:28:10,380
come up with a few examples when

443
00:28:10,380 --> 00:28:12,840
compiling will just never stop unless

444
00:28:12,840 --> 00:28:15,860
there is a timeout of course

445
00:28:17,720 --> 00:28:20,420
they simplified

446
00:28:20,420 --> 00:28:21,559
[Music]

447
00:28:21,559 --> 00:28:24,360
which is also simple logic but the

448
00:28:24,360 --> 00:28:27,000
system is even more simple that's why

449
00:28:27,000 --> 00:28:28,919
I'll watch it is just so fast and small

450
00:28:28,919 --> 00:28:30,419
but not everybody knows how to use it

451
00:28:30,419 --> 00:28:33,440
though it is

452
00:28:34,340 --> 00:28:36,980
let's return to

453
00:28:36,980 --> 00:28:40,400
to the numbers

454
00:28:47,900 --> 00:28:50,820
we wrote some function which is not even

455
00:28:50,820 --> 00:28:53,400
optimal intentionally how this thing can

456
00:28:53,400 --> 00:28:57,440
optimize it constants are not filled

457
00:28:57,440 --> 00:29:01,100
and we see the result

458
00:29:01,100 --> 00:29:05,000
a simple example right

459
00:29:06,360 --> 00:29:08,340
now

460
00:29:08,340 --> 00:29:11,720
it's quite self-evident

461
00:29:11,720 --> 00:29:14,700
it's a joke

462
00:29:14,700 --> 00:29:16,260
it's a closer look though you'll see

463
00:29:16,260 --> 00:29:18,720
some binary operations some kind of

464
00:29:18,720 --> 00:29:21,000
product sums but you need to really

465
00:29:21,000 --> 00:29:23,120
really dig into this one

466
00:29:23,120 --> 00:29:27,120
this code gives some intimidary scary

467
00:29:27,120 --> 00:29:31,940
image of the situation so um let's now

468
00:29:31,940 --> 00:29:36,140
simplify this example even more

469
00:30:01,700 --> 00:30:03,899
from time to time you know where to look

470
00:30:03,899 --> 00:30:05,580
for by the way and this is close to

471
00:30:05,580 --> 00:30:06,980
assembler by the way

472
00:30:06,980 --> 00:30:09,539
we promised you an assembler here it is

473
00:30:09,539 --> 00:30:13,020
but not not completely right now let's

474
00:30:13,020 --> 00:30:14,720
talk about

475
00:30:14,720 --> 00:30:18,380
the ecosystem

476
00:30:18,380 --> 00:30:21,500
now we're getting into the god of it

477
00:30:21,500 --> 00:30:23,899
ecosystem to create intermediary

478
00:30:23,899 --> 00:30:26,419
representation

479
00:30:26,419 --> 00:30:30,260
multi-level IRS

480
00:30:31,880 --> 00:30:33,960
machine learning because machine

481
00:30:33,960 --> 00:30:35,840
learning tools

482
00:30:35,840 --> 00:30:39,840
multi-level because there's kind of a

483
00:30:39,840 --> 00:30:41,580
low level and high level representation

484
00:30:41,580 --> 00:30:44,960
a dialect um

485
00:30:45,140 --> 00:30:47,279
we observe certain functions and

486
00:30:47,279 --> 00:30:49,760
operations

487
00:30:50,059 --> 00:30:55,399
for example linear algebra uh dialects

488
00:30:55,399 --> 00:30:57,559
it supports

489
00:30:57,559 --> 00:31:00,140
the product of Matrix

490
00:31:00,140 --> 00:31:04,260
can transpose matrices so you can do

491
00:31:04,260 --> 00:31:07,460
some high level operations there

492
00:31:07,460 --> 00:31:11,539
you can transpose the metrics

493
00:31:19,700 --> 00:31:22,620
kind of a zero down uh two operations

494
00:31:22,620 --> 00:31:25,820
into one and after that

495
00:31:25,820 --> 00:31:28,440
after this kind of um

496
00:31:28,440 --> 00:31:31,620
dwindling down we can lower this

497
00:31:31,620 --> 00:31:34,620
representation to a more low level a

498
00:31:34,620 --> 00:31:36,120
thin dialect for example is

499
00:31:36,120 --> 00:31:38,460
representation for four cycles and and

500
00:31:38,460 --> 00:31:40,500
other operations that only four cycles

501
00:31:40,500 --> 00:31:44,580
for which you can um make optimizations

502
00:31:44,580 --> 00:31:47,659
that are using some kind of maps

503
00:31:47,659 --> 00:31:50,880
so that's uh optimal math optimizations

504
00:31:50,880 --> 00:31:53,220
we will not delve too deep into that we

505
00:31:53,220 --> 00:31:55,020
just know that we can reuse them as a

506
00:31:55,020 --> 00:31:58,100
ready-made and after that

507
00:31:58,100 --> 00:32:00,600
we can make low-level representations

508
00:32:00,600 --> 00:32:03,440
and execute that on a backup

509
00:32:03,440 --> 00:32:06,480
there are also GPU dialects for NVIDIA

510
00:32:06,480 --> 00:32:08,360
for AMD

511
00:32:08,360 --> 00:32:10,880
which are also high levels

512
00:32:10,880 --> 00:32:13,200
and the most important feature-wise it's

513
00:32:13,200 --> 00:32:17,100
multi-level we can take different levels

514
00:32:17,100 --> 00:32:19,880
different dialects and put them together

515
00:32:19,880 --> 00:32:23,360
the meaning that they can be mixed down

516
00:32:23,360 --> 00:32:26,940
in one intermediary representation I

517
00:32:26,940 --> 00:32:28,020
think this is one of the coolest

518
00:32:28,020 --> 00:32:30,080
features of

519
00:32:30,080 --> 00:32:32,880
VM IR because this is heterogeneous

520
00:32:32,880 --> 00:32:35,960
computation naturally

521
00:32:36,320 --> 00:32:38,820
types and attributes by the way can be

522
00:32:38,820 --> 00:32:43,080
dynamic We Remember music that if python

523
00:32:43,080 --> 00:32:44,840
is a dynamic language

524
00:32:44,840 --> 00:32:50,059
we could have done a dialect for python

525
00:32:50,059 --> 00:32:52,620
we had a year ago maybe a year and a

526
00:32:52,620 --> 00:32:53,840
half ago

527
00:32:53,840 --> 00:32:56,419
and in dialogue

528
00:32:56,419 --> 00:33:00,419
there are ways to optimize current

529
00:33:00,419 --> 00:33:03,059
representation or lower it down to the

530
00:33:03,059 --> 00:33:05,480
next level

531
00:33:20,700 --> 00:33:23,759
[Music]

532
00:33:33,260 --> 00:33:36,480
space dialogues tensor linear linear

533
00:33:36,480 --> 00:33:40,580
algebra is something that they use a lot

534
00:33:40,580 --> 00:33:43,559
and optimizers for neural neural network

535
00:33:43,559 --> 00:33:45,960
models are also using compiler

536
00:33:45,960 --> 00:33:48,240
infrastructure and you just don't see

537
00:33:48,240 --> 00:33:50,480
that

538
00:33:51,179 --> 00:33:53,240
um

539
00:33:56,059 --> 00:33:58,860
gradually number is moving to this

540
00:33:58,860 --> 00:34:01,919
ecosystem and there are repos where that

541
00:34:01,919 --> 00:34:04,019
is being done and even a dialect that

542
00:34:04,019 --> 00:34:06,659
they have now but it's still static type

543
00:34:06,659 --> 00:34:09,239
at the moment Dynamic types are not

544
00:34:09,239 --> 00:34:12,599
there yet maybe they will have it but I

545
00:34:12,599 --> 00:34:15,679
don't know we'll see

546
00:34:17,060 --> 00:34:21,418
and as a matter of fact even clunk is

547
00:34:21,418 --> 00:34:23,580
very well known C plus plus compiler is

548
00:34:23,580 --> 00:34:26,599
also moving to mlir

549
00:34:26,599 --> 00:34:28,500
they're making intermediate

550
00:34:28,500 --> 00:34:31,080
representations on that in order to make

551
00:34:31,080 --> 00:34:33,960
code more maintainable so it will be

552
00:34:33,960 --> 00:34:36,540
easier to go into the guts of class but

553
00:34:36,540 --> 00:34:38,699
that's not something that's talking

554
00:34:38,699 --> 00:34:40,440
about I promise that there will be no

555
00:34:40,440 --> 00:34:43,280
blood only God

556
00:34:43,879 --> 00:34:46,918
ml IR has python biddings so you can use

557
00:34:46,918 --> 00:34:49,940
mlir from Pure python

558
00:34:49,940 --> 00:34:52,139
unfortunately we don't have that in

559
00:34:52,139 --> 00:34:55,080
pipes you cannot install it via pip but

560
00:34:55,080 --> 00:34:58,380
there are Americans there is this

561
00:34:58,380 --> 00:35:01,280
American dude

562
00:35:01,280 --> 00:35:04,740
if Julia is named in order of the wives

563
00:35:04,740 --> 00:35:07,920
of one of the developers uh Nelly is

564
00:35:07,920 --> 00:35:10,859
named in the owner of the mother and

565
00:35:10,859 --> 00:35:14,220
this thing can uh almost just take

566
00:35:14,220 --> 00:35:17,280
almost pure python code a bit you know

567
00:35:17,280 --> 00:35:19,920
muddled

568
00:35:19,920 --> 00:35:22,020
you need to do quite a few Imports for

569
00:35:22,020 --> 00:35:24,800
that that's the deal

570
00:35:24,980 --> 00:35:27,660
so that you take uh the pure python code

571
00:35:27,660 --> 00:35:29,760
and transfer that into the intermediary

572
00:35:29,760 --> 00:35:32,579
representation but the mix of existing

573
00:35:32,579 --> 00:35:35,240
dialects

574
00:35:36,500 --> 00:35:39,540
that you don't have to reassemble llvm

575
00:35:39,540 --> 00:35:44,480
that's quite a while and uh

576
00:36:04,880 --> 00:36:07,740
I mean it's a bit more comprehensible I

577
00:36:07,740 --> 00:36:09,720
hope so we have a for Loop

578
00:36:09,720 --> 00:36:12,720
foreign

579
00:37:00,859 --> 00:37:04,320
optimization command here and we can

580
00:37:04,320 --> 00:37:07,339
tell it dude squeeze

581
00:37:07,339 --> 00:37:10,020
lower our dialects convert into the

582
00:37:10,020 --> 00:37:12,660
lowest level dialect llvm and it

583
00:37:12,660 --> 00:37:15,420
responds nope

584
00:37:15,420 --> 00:37:16,760
um

585
00:37:16,760 --> 00:37:20,660
let's see what's wrong

586
00:37:20,900 --> 00:37:25,339
okay the percentage within the cycle

587
00:37:38,000 --> 00:37:41,520
is always there once if we look at the X

588
00:37:41,520 --> 00:37:43,140
variables the second time in the sign

589
00:37:43,140 --> 00:37:45,060
for a second time it's becoming X2 X3

590
00:37:45,060 --> 00:37:48,540
Etc so as a matter of fact it's a

591
00:37:48,540 --> 00:37:50,720
different kind of object already

592
00:37:50,720 --> 00:37:54,319
and we see that

593
00:37:56,180 --> 00:37:58,980
this variable percent four is within a

594
00:37:58,980 --> 00:38:00,840
loop but nobody took it outside

595
00:38:00,840 --> 00:38:03,440
[Applause]

596
00:38:03,440 --> 00:38:06,119
it will look further and look into the

597
00:38:06,119 --> 00:38:09,900
commentation to the dialogue then

598
00:38:09,900 --> 00:38:11,900
um

599
00:38:14,339 --> 00:38:17,099
here are a few lines

600
00:38:17,099 --> 00:38:19,820
this thing will even go down

601
00:38:19,820 --> 00:38:24,800
and we see something more low level

602
00:38:24,800 --> 00:38:28,020
we need to write down here what type

603
00:38:28,020 --> 00:38:31,560
conversions podcasts

604
00:38:37,880 --> 00:38:41,420
easier said than done then we can

605
00:38:41,420 --> 00:38:44,960
broadcast it to the lowest level and

606
00:38:44,960 --> 00:38:51,720
execute on The llvm Interpreter llvi I

607
00:38:51,720 --> 00:38:54,119
is for interpreters and if we take a

608
00:38:54,119 --> 00:38:56,000
look at the scheme

609
00:38:56,000 --> 00:38:58,500
then this dialogue at the lowest level

610
00:38:58,500 --> 00:39:01,940
dialogue dialogue is going down to

611
00:39:01,940 --> 00:39:05,160
llvmir and we execute it

612
00:39:05,160 --> 00:39:07,980
not

613
00:39:07,980 --> 00:39:10,800
I mean um

614
00:39:10,800 --> 00:39:13,280
it almost Works

615
00:39:13,280 --> 00:39:17,900
we're almost approaching the end yeah

616
00:39:22,040 --> 00:39:25,440
so python accelerates preserves

617
00:39:25,440 --> 00:39:26,720
introspection

618
00:39:26,720 --> 00:39:29,940
we can still see how the byte code is

619
00:39:29,940 --> 00:39:31,800
being optimized it's pretty cool you can

620
00:39:31,800 --> 00:39:34,020
actually see what's happening there well

621
00:39:34,020 --> 00:39:35,420
it's Midlands

622
00:39:35,420 --> 00:39:38,119
Midland tools are also getting better

623
00:39:38,119 --> 00:39:42,180
yes they have certain bugs but gradually

624
00:39:42,180 --> 00:39:43,579
it's getting better

625
00:39:43,579 --> 00:39:45,660
in a couple of years you'll be able to

626
00:39:45,660 --> 00:39:47,899
use it

627
00:39:53,900 --> 00:39:56,339
there's a number of them I cannot help

628
00:39:56,339 --> 00:39:57,780
but mention them

629
00:39:57,780 --> 00:40:01,680
there is a growl VM with the GPA

630
00:40:01,680 --> 00:40:03,300
licensing though there's also Arc

631
00:40:03,300 --> 00:40:06,720
compiler which also Dynamic type it

632
00:40:06,720 --> 00:40:08,359
supports Dynamic type languages

633
00:40:08,359 --> 00:40:12,420
both uh growl and Arc compiler they are

634
00:40:12,420 --> 00:40:17,119
supported by one company llbm

635
00:40:17,119 --> 00:40:19,380
except contribution from so many

636
00:40:19,380 --> 00:40:22,280
companies people universities

637
00:40:22,280 --> 00:40:26,900
that's why I prefer this one

638
00:40:31,640 --> 00:40:35,040
that's great thanks to the fact that

639
00:40:35,040 --> 00:40:37,260
the privilege you can add Dynamic types

640
00:40:37,260 --> 00:40:39,500
and operations

641
00:40:39,500 --> 00:40:42,839
and from Python and for Python and not

642
00:40:42,839 --> 00:40:48,920
only for Python and also which is

643
00:40:51,800 --> 00:40:55,859
mlr to create um you have very own

644
00:40:55,859 --> 00:40:58,520
coding languages

645
00:41:00,500 --> 00:41:02,579
and you don't want to replicate other

646
00:41:02,579 --> 00:41:05,480
features in the other languages

647
00:41:25,760 --> 00:41:28,619
just because it will be so much easier

648
00:41:28,619 --> 00:41:31,230
to make your very own

649
00:41:31,230 --> 00:41:39,240
[Applause]

650
00:41:39,240 --> 00:41:41,240
um

651
00:41:45,240 --> 00:41:48,979
maybe you will ask a few questions

652
00:41:50,520 --> 00:41:52,859
uh the delivery guys are running with

653
00:41:52,859 --> 00:41:54,260
the mics

654
00:41:54,260 --> 00:41:56,339
there's a reason why we use this

655
00:41:56,339 --> 00:41:58,880
delivery Club

656
00:41:58,980 --> 00:42:01,940
so let's run it

657
00:42:01,940 --> 00:42:04,880
thank you for the presentation

658
00:42:04,880 --> 00:42:06,680
here's the question

659
00:42:06,680 --> 00:42:09,619
we mentioned tensorflow

660
00:42:09,619 --> 00:42:13,320
tensorflow now allows to compile neural

661
00:42:13,320 --> 00:42:16,260
networks for microcontrollers right out

662
00:42:16,260 --> 00:42:18,980
of python codes

663
00:42:23,720 --> 00:42:26,220
going into an executable code for

664
00:42:26,220 --> 00:42:28,700
microcontroller how does that happening

665
00:42:28,700 --> 00:42:32,899
is it within some kind of um

666
00:42:33,140 --> 00:42:35,640
and there's another machine within that

667
00:42:35,640 --> 00:42:38,099
it actually puts together the code for

668
00:42:38,099 --> 00:42:39,720
microcontroller yeah that's a good

669
00:42:39,720 --> 00:42:40,579
question

670
00:42:40,579 --> 00:42:42,839
that's curious about microcontrollers as

671
00:42:42,839 --> 00:42:45,200
a matter of

672
00:42:46,579 --> 00:42:48,980
facts

673
00:42:48,980 --> 00:42:52,079
back end for like these very compact

674
00:42:52,079 --> 00:42:54,839
devices there's a micro python for that

675
00:42:54,839 --> 00:42:56,400
that's not related to what I was talking

676
00:42:56,400 --> 00:42:58,920
about so if we speak about micro

677
00:42:58,920 --> 00:43:01,319
controller is I believe that probably

678
00:43:01,319 --> 00:43:02,900
know

679
00:43:02,900 --> 00:43:05,760
there are other types of developers so

680
00:43:05,760 --> 00:43:08,400
how's it happening I know for sure that

681
00:43:08,400 --> 00:43:10,740
from python I can start some method from

682
00:43:10,740 --> 00:43:13,380
tensorflow from some class and put

683
00:43:13,380 --> 00:43:16,579
together a code that I can actually

684
00:43:16,579 --> 00:43:18,900
put into the microcontroller that should

685
00:43:18,900 --> 00:43:21,300
be somewhere within the python let's

686
00:43:21,300 --> 00:43:22,520
clarify that are you talking about

687
00:43:22,520 --> 00:43:25,520
microcontrollers

688
00:43:25,940 --> 00:43:29,540
tensorflow website there is

689
00:43:29,540 --> 00:43:33,540
a bit of a different thing yeah

690
00:43:33,540 --> 00:43:38,540
a microcontroller with a DSP cords

691
00:43:39,380 --> 00:43:42,920
there's a special kind of backhand

692
00:43:42,920 --> 00:43:45,839
it's not within llvm but in the

693
00:43:45,839 --> 00:43:49,920
tensorflow repo and maybe it can take

694
00:43:49,920 --> 00:43:52,920
its own backhand and move it to DSP

695
00:43:52,920 --> 00:43:54,660
processors which is a small question

696
00:43:54,660 --> 00:43:58,040
about lazy computations

697
00:44:00,680 --> 00:44:02,640
something right away but make certain

698
00:44:02,640 --> 00:44:05,280
methods and then in a while kind of get

699
00:44:05,280 --> 00:44:08,460
another method etc etc with how's with

700
00:44:08,460 --> 00:44:12,079
this lazy computations on python

701
00:44:13,220 --> 00:44:15,780
I cannot tell you about spark I don't

702
00:44:15,780 --> 00:44:17,760
know spark that well I don't know what's

703
00:44:17,760 --> 00:44:18,900
happening inside

704
00:44:18,900 --> 00:44:21,500
Ducks okay thank you

705
00:44:21,500 --> 00:44:24,900
football image

706
00:44:24,900 --> 00:44:26,900
um

707
00:44:29,780 --> 00:44:32,760
a very interesting presentation the core

708
00:44:32,760 --> 00:44:35,119
questions

709
00:44:35,480 --> 00:44:39,000
when you begin talking about heating

710
00:44:39,000 --> 00:44:41,359
functions

711
00:44:42,859 --> 00:44:46,079
because I've heard in runtime is not

712
00:44:46,079 --> 00:44:50,099
even participating much but when I get

713
00:44:50,099 --> 00:44:52,500
dirt a certain functional class I I saw

714
00:44:52,500 --> 00:44:55,680
those types does that make an impact on

715
00:44:55,680 --> 00:44:58,440
bytecode optimization no not really no

716
00:44:58,440 --> 00:45:00,960
I'm sure next question when you have

717
00:45:00,960 --> 00:45:03,380
four questions

718
00:45:06,800 --> 00:45:09,319
no problem by the way

719
00:45:09,319 --> 00:45:13,880
of course what the hardcore questions

720
00:45:22,220 --> 00:45:25,920
which as they say is very fast and

721
00:45:25,920 --> 00:45:28,400
really python-like all right

722
00:45:28,400 --> 00:45:32,060
I heard about it

723
00:45:32,300 --> 00:45:35,540
I said that it's probably gonna die

724
00:45:35,540 --> 00:45:38,960
in my opinion

725
00:45:41,420 --> 00:45:44,540
everybody's speaking about Mojo

726
00:45:44,540 --> 00:45:46,859
they're using molars somehow but it's

727
00:45:46,859 --> 00:45:48,240
not yet open source how they're doing

728
00:45:48,240 --> 00:45:50,000
this I don't know

729
00:45:50,000 --> 00:45:53,900
maybe there are issues on their measures

730
00:45:53,900 --> 00:45:56,640
maybe they have been adjusting their

731
00:45:56,640 --> 00:46:00,078
measurements for a certain example

732
00:46:00,500 --> 00:46:03,359
there are C python benchmarks which can

733
00:46:03,359 --> 00:46:05,099
measure different kind of things and you

734
00:46:05,099 --> 00:46:07,520
can get the average

735
00:46:07,520 --> 00:46:10,800
when they say that python 311 is 25

736
00:46:10,800 --> 00:46:13,980
faster than fighting three times on

737
00:46:13,980 --> 00:46:16,319
average faster for all of the sea python

738
00:46:16,319 --> 00:46:17,420
batteries

739
00:46:17,420 --> 00:46:19,680
so that you don't have to pay for the

740
00:46:19,680 --> 00:46:22,700
third question yeah

741
00:46:48,859 --> 00:46:51,859
foreign

742
00:47:03,440 --> 00:47:06,800
and that's it

743
00:47:06,859 --> 00:47:12,078
two questions in one actually foreign

744
00:47:12,290 --> 00:47:15,400
[Music]

745
00:47:53,000 --> 00:47:56,599
which you believe more

746
00:48:49,880 --> 00:48:53,040
if somebody can make that happen for

747
00:48:53,040 --> 00:48:55,200
processors that's great

748
00:48:55,200 --> 00:48:58,200
appreciates

749
00:49:47,060 --> 00:49:50,220
depending on their effort the effort

750
00:49:50,220 --> 00:49:52,440
they invest into it acceleration will be

751
00:49:52,440 --> 00:49:53,640
happening due to different things for

752
00:49:53,640 --> 00:49:56,220
example gradually the micro instructions

753
00:49:56,220 --> 00:49:58,859
are changing and they will be more

754
00:49:58,859 --> 00:50:02,160
Optimus somehow VM will be optimized as

755
00:50:02,160 --> 00:50:04,140
well

756
00:50:04,140 --> 00:50:07,140
man

757
00:50:23,000 --> 00:50:27,020
this dude who had many questions

758
00:50:27,079 --> 00:50:29,760
but I love the questions too

759
00:50:29,760 --> 00:50:31,820
just wave your hand okay

760
00:50:31,820 --> 00:50:32,220
[Applause]

761
00:50:32,220 --> 00:50:34,380
[Music]

762
00:50:34,380 --> 00:50:36,440
um

763
00:50:36,500 --> 00:50:38,839
thank you so much for the presentation

764
00:50:38,839 --> 00:50:42,060
thank you for the for the work for

765
00:50:42,060 --> 00:50:44,220
making this happen and for the answers

766
00:50:44,220 --> 00:50:46,939
the resistance

767
00:50:47,000 --> 00:50:50,520
sure 10 minutes great because usually in

768
00:50:50,520 --> 00:50:51,839
10 minutes we'll be talking about uh

769
00:50:51,839 --> 00:50:55,319
Statics analysis

770
00:50:56,099 --> 00:50:58,900
foreign

771
00:50:58,900 --> 00:51:01,939
[Music]

