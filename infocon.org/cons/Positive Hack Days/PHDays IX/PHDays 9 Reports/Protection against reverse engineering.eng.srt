1
00:00:01,340 --> 00:00:08,970
hello my name is michael mcauliffe I'm

2
00:00:04,680 --> 00:00:12,090
head of development department in the

3
00:00:08,970 --> 00:00:14,280
active companies a Russian developer of

4
00:00:12,090 --> 00:00:16,230
security tools the largest and Russia

5
00:00:14,280 --> 00:00:21,439
producer of electronic occurred on

6
00:00:16,230 --> 00:00:26,640
turkeys and through token our identifier

7
00:00:21,439 --> 00:00:28,740
so we celebrate 25 years this year and

8
00:00:26,640 --> 00:00:31,769
we keep introducing the licensing and

9
00:00:28,740 --> 00:00:34,320
protection systems for software and we

10
00:00:31,769 --> 00:00:36,780
produce electronic keys that can

11
00:00:34,320 --> 00:00:39,030
transparently encrypt the traffic

12
00:00:36,780 --> 00:00:42,590
between the application and the key we

13
00:00:39,030 --> 00:00:45,719
have the key that can download the

14
00:00:42,590 --> 00:00:47,640
arbitrary users code also to carry out

15
00:00:45,719 --> 00:00:50,039
the unique system of security and

16
00:00:47,640 --> 00:00:52,050
program licenses that you can activate

17
00:00:50,039 --> 00:00:55,890
by internet and linked to unique

18
00:00:52,050 --> 00:01:00,390
parameters of the computer and there

19
00:00:55,890 --> 00:01:03,629
very soon we shall launch the system of

20
00:01:00,390 --> 00:01:05,939
licensing for software licensing control

21
00:01:03,629 --> 00:01:08,360
that can be integrated with third party

22
00:01:05,939 --> 00:01:12,408
system in particular this system should

23
00:01:08,360 --> 00:01:16,110
simplify the delivery of upgrades which

24
00:01:12,409 --> 00:01:19,619
will enable our users to use a flexible

25
00:01:16,110 --> 00:01:24,900
licensing methods the system is designed

26
00:01:19,619 --> 00:01:27,180
in to enable the users to have it simple

27
00:01:24,900 --> 00:01:31,100
like license order customer issue

28
00:01:27,180 --> 00:01:36,479
upgrade license without the technical

29
00:01:31,100 --> 00:01:40,259
details of the system so our keys work

30
00:01:36,479 --> 00:01:42,630
through one garland API that may need to

31
00:01:40,259 --> 00:01:45,630
be integrated to protect application we

32
00:01:42,630 --> 00:01:47,850
recommend using static link but in a

33
00:01:45,630 --> 00:01:51,839
disassembler all they calls an API can

34
00:01:47,850 --> 00:01:54,750
be seen and tracked to prevent it you

35
00:01:51,840 --> 00:01:58,560
need to use a

36
00:01:54,750 --> 00:02:02,100
software security for cause tolls

37
00:01:58,560 --> 00:02:06,210
we started with the win32 files packages

38
00:02:02,100 --> 00:02:08,579
and took we now we use protectors for

39
00:02:06,210 --> 00:02:17,040
virtualization codes for executable

40
00:02:08,580 --> 00:02:20,819
files for dotnet applications our

41
00:02:17,040 --> 00:02:23,519
protectors addressed to goals they

42
00:02:20,819 --> 00:02:26,399
allowed to protect the source code of

43
00:02:23,519 --> 00:02:31,709
application of the reverse engineering

44
00:02:26,400 --> 00:02:40,530
and addresses a goal of protection

45
00:02:31,709 --> 00:02:42,630
against copying we all know that there

46
00:02:40,530 --> 00:02:48,720
are code packages and the windows called

47
00:02:42,630 --> 00:02:51,239
protectors based on the executable file

48
00:02:48,720 --> 00:02:53,790
a packaging in the encryption is so one

49
00:02:51,239 --> 00:02:55,920
of the layers of protection from reverse

50
00:02:53,790 --> 00:02:59,730
engineering and simple way to protect

51
00:02:55,920 --> 00:03:02,548
from copying but today new tip security

52
00:02:59,730 --> 00:03:05,429
technologies come device garden from

53
00:03:02,549 --> 00:03:07,700
Microsoft that actually dictate the new

54
00:03:05,430 --> 00:03:11,810
terms

55
00:03:07,700 --> 00:03:13,670
and protecting the worker and today I'm

56
00:03:11,810 --> 00:03:16,190
going to tell you briefly about our

57
00:03:13,670 --> 00:03:18,619
protector and share the knowledge about

58
00:03:16,190 --> 00:03:21,760
the new requirements of Windows driver

59
00:03:18,620 --> 00:03:25,660
so for compatibility with device but how

60
00:03:21,760 --> 00:03:28,549
it impacted our code protector and how

61
00:03:25,660 --> 00:03:30,890
code virtualization can be used for

62
00:03:28,550 --> 00:03:35,870
automatic protection from coping in

63
00:03:30,890 --> 00:03:40,208
trusted environment our protector isn't

64
00:03:35,870 --> 00:03:43,880
quite as you can do can protect

65
00:03:40,209 --> 00:03:46,970
functional mystically unfortunately in

66
00:03:43,880 --> 00:03:49,040
this case and only protects the basic

67
00:03:46,970 --> 00:03:58,640
block that are not critical in terms of

68
00:03:49,040 --> 00:04:01,000
our timing we can do some functions of

69
00:03:58,640 --> 00:04:04,720
their vacation and also have an envelope

70
00:04:01,000 --> 00:04:07,400
in charge of packaging of a section of a

71
00:04:04,720 --> 00:04:10,069
executive on file a protection of

72
00:04:07,400 --> 00:04:11,900
important along with executable file and

73
00:04:10,069 --> 00:04:14,660
dynamic libraries and drivers we can

74
00:04:11,900 --> 00:04:18,620
protect object files as most of our

75
00:04:14,660 --> 00:04:24,680
clients use some statically linking of

76
00:04:18,620 --> 00:04:26,210
torrent API virtualization is a method

77
00:04:24,680 --> 00:04:30,350
of protection against reverse

78
00:04:26,210 --> 00:04:33,020
engineering which uses a translation of

79
00:04:30,350 --> 00:04:36,490
the source code to instruction

80
00:04:33,020 --> 00:04:36,490
settlement or horrendous

81
00:04:38,070 --> 00:04:42,830
[Music]

82
00:04:39,850 --> 00:04:45,490
would be interpreted by the virtual

83
00:04:42,830 --> 00:04:48,550
machine in the process of application

84
00:04:45,490 --> 00:04:52,670
operation division and it was difficult

85
00:04:48,550 --> 00:04:56,210
it's difficult to write the develop high

86
00:04:52,670 --> 00:04:59,960
quality automatic disassemble it should

87
00:04:56,210 --> 00:05:02,840
be able to understand all functions in

88
00:04:59,960 --> 00:05:05,510
the application solution and everything

89
00:05:02,840 --> 00:05:07,580
that modern compilers compile it's

90
00:05:05,510 --> 00:05:11,780
important because it does have a chance

91
00:05:07,580 --> 00:05:29,180
to it has no chance for mistakes we need

92
00:05:11,780 --> 00:05:31,789
to protect ater and by code from some

93
00:05:29,180 --> 00:05:42,080
emulation as with many instructions and

94
00:05:31,790 --> 00:05:44,660
it allows us information and actually

95
00:05:42,080 --> 00:05:48,640
make the structure too complicated so

96
00:05:44,660 --> 00:05:48,640
that malicious software could not

97
00:05:58,030 --> 00:06:06,460
and so it's not today that we got this

98
00:06:00,640 --> 00:06:08,800
new method is quite a strong method of

99
00:06:06,460 --> 00:06:10,450
protection from reverse analysis but

100
00:06:08,800 --> 00:06:13,600
still virtualization does not address

101
00:06:10,450 --> 00:06:18,940
the problem of protection from copying

102
00:06:13,600 --> 00:06:21,340
and and the simple way to protect our

103
00:06:18,940 --> 00:06:26,230
automatically from copies equally is a

104
00:06:21,340 --> 00:06:30,580
to this tasks or the packager and the

105
00:06:26,230 --> 00:06:33,730
packager when the application is

106
00:06:30,580 --> 00:06:37,359
launched the will unpack and decode the

107
00:06:33,730 --> 00:06:41,500
files apart it has a deficiency of this

108
00:06:37,360 --> 00:06:43,660
approach because the application can be

109
00:06:41,500 --> 00:06:46,110
dumped because it turns it finds itself

110
00:06:43,660 --> 00:06:49,990
in the memory we protect from dumping

111
00:06:46,110 --> 00:06:55,980
differently we encrypt by code that

112
00:06:49,990 --> 00:07:13,330
generates our protector thus we protect

113
00:06:55,980 --> 00:07:15,669
from dump and from copying we turn to

114
00:07:13,330 --> 00:07:17,979
the block manager which will immerse the

115
00:07:15,669 --> 00:07:26,560
necessary as a necessary block until the

116
00:07:17,979 --> 00:07:28,659
dynamic memory and the algorithm are

117
00:07:26,560 --> 00:07:32,550
built in such a way that in remembering

118
00:07:28,660 --> 00:07:34,630
we always have a minimum number of

119
00:07:32,550 --> 00:07:36,850
entries decrypted called

120
00:07:34,630 --> 00:07:38,650
plots so in order to dump the

121
00:07:36,850 --> 00:07:40,750
application you do not now down

122
00:07:38,650 --> 00:07:44,760
replication because the sum of the

123
00:07:40,750 --> 00:07:44,760
Walsall mykos will be encrypted

124
00:07:46,510 --> 00:07:53,780
this type of protection allows you to

125
00:07:50,680 --> 00:07:58,040
protect from death from clothing and

126
00:07:53,780 --> 00:08:02,750
most interesting it will work in the

127
00:07:58,040 --> 00:08:04,460
trusted environment as a protector

128
00:08:02,750 --> 00:08:07,250
development is an ongoing process

129
00:08:04,460 --> 00:08:10,549
because new spreads appear new

130
00:08:07,250 --> 00:08:14,900
instructions appear and they need to

131
00:08:10,550 --> 00:08:18,680
support new compilers virtue and and

132
00:08:14,900 --> 00:08:21,380
race improve security so we keep

133
00:08:18,680 --> 00:08:23,870
changing we keep adding we cannot just

134
00:08:21,380 --> 00:08:26,360
stop and sometimes we even have to

135
00:08:23,870 --> 00:08:29,530
delete things like take a case of

136
00:08:26,360 --> 00:08:34,539
security technology of device guard of

137
00:08:29,530 --> 00:08:39,400
Microsoft over the last few years

138
00:08:34,539 --> 00:08:46,219
Microsoft raises security of Windows 10

139
00:08:39,400 --> 00:08:48,709
yes and so there's a new s mode which

140
00:08:46,220 --> 00:08:53,560
where you can launch only applications

141
00:08:48,710 --> 00:08:55,730
installed from windows to work and the

142
00:08:53,560 --> 00:08:59,180
security policy moves in the direction

143
00:08:55,730 --> 00:09:04,190
all were allowing only the launch of

144
00:08:59,180 --> 00:09:06,650
trusted applications Windows 10 has a

145
00:09:04,190 --> 00:09:09,970
set of security technology and

146
00:09:06,650 --> 00:09:09,970
virtualization based security

147
00:09:10,730 --> 00:09:19,930
and VSM is separated from hypervisor and

148
00:09:14,900 --> 00:09:19,930
hypervisor from Windows 10 and the core

149
00:09:22,660 --> 00:09:27,219
technologies that we are used to create

150
00:09:25,430 --> 00:09:29,839
the device Garlin credential card

151
00:09:27,220 --> 00:09:33,740
credential guard is in charge of fast

152
00:09:29,840 --> 00:09:36,410
for all passwords in the system they

153
00:09:33,740 --> 00:09:40,040
hash passwords would be kept just in the

154
00:09:36,410 --> 00:09:42,770
memory of the processor but now they'll

155
00:09:40,040 --> 00:09:44,810
say local security Authority interest

156
00:09:42,770 --> 00:09:48,170
was a protected component so called

157
00:09:44,810 --> 00:09:52,010
isolated processing that is in charge

158
00:09:48,170 --> 00:09:53,810
over all the passwords and processes in

159
00:09:52,010 --> 00:09:57,069
the system by the way are more

160
00:09:53,810 --> 00:09:59,900
interested in hypervisor code integrity

161
00:09:57,070 --> 00:10:03,530
that according to Microsoft were

162
00:09:59,900 --> 00:10:05,900
examined in with integrity kernel mode

163
00:10:03,530 --> 00:10:09,350
integrity component in charge of all

164
00:10:05,900 --> 00:10:13,400
windows drivers having signature digital

165
00:10:09,350 --> 00:10:16,070
signature you used to be able to bypass

166
00:10:13,400 --> 00:10:18,230
this chip but now the system uses high

167
00:10:16,070 --> 00:10:25,670
level of privileges of hypervisor to

168
00:10:18,230 --> 00:10:28,880
protect this component so device guard

169
00:10:25,670 --> 00:10:34,099
is a set of components to prevent the

170
00:10:28,880 --> 00:10:37,340
execution of malicious code and you

171
00:10:34,100 --> 00:10:41,510
permit only the trusted applications to

172
00:10:37,340 --> 00:10:43,460
execute and Windows 10 does it and

173
00:10:41,510 --> 00:10:46,189
guarantees that only the trusted code

174
00:10:43,460 --> 00:10:49,640
will be executed from the loader and

175
00:10:46,190 --> 00:10:53,270
then you need to use the platform that

176
00:10:49,640 --> 00:10:55,610
allows you to make sure that they

177
00:10:53,270 --> 00:10:57,560
everything is silent heaven has not been

178
00:10:55,610 --> 00:11:01,160
changed humorless castle provides

179
00:10:57,560 --> 00:11:02,719
garbage in with the wasn't protector so

180
00:11:01,160 --> 00:11:05,449
then we talked about the protectors

181
00:11:02,720 --> 00:11:09,020
right so for this device guard it

182
00:11:05,450 --> 00:11:13,850
actually dictates new new new new new

183
00:11:09,020 --> 00:11:17,860
rules of development it kernel mode so

184
00:11:13,850 --> 00:11:22,850
that there is the digital signature of

185
00:11:17,860 --> 00:11:25,430
loaded drivers and already sections that

186
00:11:22,850 --> 00:11:30,740
have the correct signature will be

187
00:11:25,430 --> 00:11:34,640
loaded in any attempt to transfer till

188
00:11:30,740 --> 00:11:38,690
they changed memory it will result in

189
00:11:34,640 --> 00:11:41,839
blue screen then they should not combine

190
00:11:38,690 --> 00:11:46,700
the writable plus executables not

191
00:11:41,839 --> 00:11:50,600
allowed or it's if it's smaller than the

192
00:11:46,700 --> 00:11:52,850
size so they memory page so then it's

193
00:11:50,600 --> 00:11:55,250
it's not allowed to modify the

194
00:11:52,850 --> 00:11:59,870
executable code in any form this driver

195
00:11:55,250 --> 00:12:02,560
won't loaders and then then it's not

196
00:11:59,870 --> 00:12:06,230
it's not allowed the D key and as our

197
00:12:02,560 --> 00:12:09,790
words so that managed the registers and

198
00:12:06,230 --> 00:12:12,290
the table registers and decrypt errs

199
00:12:09,790 --> 00:12:16,209
unauthorized modifications of byte

200
00:12:12,290 --> 00:12:20,680
fields of the management register CR for

201
00:12:16,209 --> 00:12:23,680
including the SM ap so is blocked

202
00:12:20,680 --> 00:12:23,680
immediately

203
00:12:29,470 --> 00:12:39,589
and so that in the user mode so then we

204
00:12:38,000 --> 00:12:45,440
have some novelties

205
00:12:39,589 --> 00:12:48,980
so the OS can can be can be adjusted for

206
00:12:45,440 --> 00:12:52,040
the security policies so that they could

207
00:12:48,980 --> 00:12:56,330
be executed only trusted executable

208
00:12:52,040 --> 00:12:58,719
files and the dynamic execution of the

209
00:12:56,330 --> 00:13:01,970
code may be launched so it will not be

210
00:12:58,720 --> 00:13:05,120
impossible to do therefore the VM that

211
00:13:01,970 --> 00:13:07,370
you cannot change it cannot isolate to

212
00:13:05,120 --> 00:13:10,240
the executive mer memory through a

213
00:13:07,370 --> 00:13:13,040
virtual lock and you cannot change our X

214
00:13:10,240 --> 00:13:15,020
code through virtual protect and only

215
00:13:13,040 --> 00:13:21,079
the pages that have specific information

216
00:13:15,020 --> 00:13:22,939
will be executed so actually in kernel

217
00:13:21,080 --> 00:13:27,080
in kernel mode the package cannot be

218
00:13:22,940 --> 00:13:29,870
used because it's a that is why we need

219
00:13:27,080 --> 00:13:32,839
just to disconnect the package and

220
00:13:29,870 --> 00:13:34,970
modify the executable code and now it is

221
00:13:32,839 --> 00:13:37,430
protected in any form so the

222
00:13:34,970 --> 00:13:41,029
virtualization of the comb saves us so

223
00:13:37,430 --> 00:13:44,979
then you can save many functions and so

224
00:13:41,029 --> 00:13:49,490
then the drivers they do not need to be

225
00:13:44,980 --> 00:13:51,650
protected from copying and that is my

226
00:13:49,490 --> 00:13:55,550
internal mode you cannot use the

227
00:13:51,650 --> 00:14:00,319
mechanism of repetitive implementation

228
00:13:55,550 --> 00:14:03,979
of the page in the user mode and and so

229
00:14:00,320 --> 00:14:06,050
then you cannot do that then the

230
00:14:03,980 --> 00:14:09,500
automatic protection of the applications

231
00:14:06,050 --> 00:14:12,260
from copying in trusted environment so

232
00:14:09,500 --> 00:14:14,660
they made so it's it's organized in a

233
00:14:12,260 --> 00:14:17,870
way that it's impossible to execute the

234
00:14:14,660 --> 00:14:23,630
automatic security from coughing ant on

235
00:14:17,870 --> 00:14:26,200
the basis of customized packaging so

236
00:14:23,630 --> 00:14:28,770
that is why instead of executable code

237
00:14:26,200 --> 00:14:32,160
we need to

238
00:14:28,770 --> 00:14:37,230
to digitize when we need to script to

239
00:14:32,160 --> 00:14:40,740
encrypt it the code all the functions to

240
00:14:37,230 --> 00:14:43,350
be protected because it should not be no

241
00:14:40,740 --> 00:14:46,620
one should be able to unpack it and lets

242
00:14:43,350 --> 00:14:48,390
me get the license physically and they

243
00:14:46,620 --> 00:14:51,000
load it to automatically protect the

244
00:14:48,390 --> 00:14:53,990
files where there is no chance to unpack

245
00:14:51,000 --> 00:14:57,750
the file so I can use the virtualization

246
00:14:53,990 --> 00:15:01,430
protector that can encrypt my code so I

247
00:14:57,750 --> 00:15:04,020
can review it require view the byte code

248
00:15:01,430 --> 00:15:10,609
that's created that encrypts the

249
00:15:04,020 --> 00:15:16,010
protector so that such files can be

250
00:15:10,610 --> 00:15:16,010
easily launched in a trusted environment

251
00:15:16,730 --> 00:15:38,790
questions thank you slowly she declares

252
00:15:36,029 --> 00:15:42,420
on a Santoni nicoleff propose a new

253
00:15:38,790 --> 00:15:46,290
purpose there are such a specificity

254
00:15:42,420 --> 00:15:49,229
Claude approach what Claude can see if

255
00:15:46,290 --> 00:15:51,810
the key was rainy and chemo frozen gos

256
00:15:49,230 --> 00:15:54,839
and appreciates of stuff could be so is

257
00:15:51,810 --> 00:15:56,209
it the inclusion into the printf what

258
00:15:54,839 --> 00:16:00,149
are we talking about

259
00:15:56,209 --> 00:16:02,489
we for example so there is a there is a

260
00:16:00,149 --> 00:16:06,300
there is a mistake right in the

261
00:16:02,490 --> 00:16:09,060
application man it falls in ordinary

262
00:16:06,300 --> 00:16:11,699
application we just three now we open it

263
00:16:09,060 --> 00:16:14,849
up we go step by step and we just and we

264
00:16:11,700 --> 00:16:18,060
see what happened so but here so we

265
00:16:14,850 --> 00:16:20,640
don't have dump we don't have so launch

266
00:16:18,060 --> 00:16:24,359
of the real application how do it the

267
00:16:20,640 --> 00:16:28,860
bar get our debug it

268
00:16:24,360 --> 00:16:32,699
as I can try to figure out like how the

269
00:16:28,860 --> 00:16:36,319
deal works and and debug it now I

270
00:16:32,699 --> 00:16:36,319
understand your question but that's

271
00:16:36,410 --> 00:16:41,219
that's a weakness but you need to decide

272
00:16:39,119 --> 00:16:43,739
so because you need to secure yourself

273
00:16:41,220 --> 00:16:46,350
protect yourself or if it's not

274
00:16:43,739 --> 00:16:47,910
important to protect yourself then you

275
00:16:46,350 --> 00:16:48,569
don't have to protect your functions

276
00:16:47,910 --> 00:16:50,699
that's it

277
00:16:48,569 --> 00:16:54,959
are there any mechanisms that protect

278
00:16:50,699 --> 00:16:57,929
and allow to debug submit you meant to

279
00:16:54,959 --> 00:17:02,549
walk around by code yeah just to go

280
00:16:57,929 --> 00:17:06,539
through the by code yeah we have not yet

281
00:17:02,549 --> 00:17:10,079
come to it so to to live to develop the

282
00:17:06,539 --> 00:17:13,049
debugger for our VMs we have not yet

283
00:17:10,079 --> 00:17:15,898
done it because to develop the protector

284
00:17:13,049 --> 00:17:18,539
was so important and so what so many

285
00:17:15,898 --> 00:17:22,760
hours have been put into it so it is

286
00:17:18,539 --> 00:17:27,119
there's a certain algorithm that can be

287
00:17:22,760 --> 00:17:30,779
can be applied yeah so I try to talk

288
00:17:27,119 --> 00:17:34,889
about virtualization it's mined way as

289
00:17:30,779 --> 00:17:38,100
when transferred the source code and so

290
00:17:34,889 --> 00:17:41,428
either by instructions or by basic

291
00:17:38,100 --> 00:17:45,809
blocks into some codes you decode and

292
00:17:41,429 --> 00:17:49,100
then they generate then generate the

293
00:17:45,809 --> 00:17:52,710
interpreter and the interpreter can be

294
00:17:49,100 --> 00:17:54,269
every time different and then he went by

295
00:17:52,710 --> 00:17:54,630
code bite cause may be different every

296
00:17:54,269 --> 00:17:59,210
time

297
00:17:54,630 --> 00:18:03,419
even the interpretate err can be a DVM

298
00:17:59,210 --> 00:18:05,100
then Dan can stack or register can be

299
00:18:03,419 --> 00:18:07,889
generated and every time it will be

300
00:18:05,100 --> 00:18:12,510
different that is why I just to develop

301
00:18:07,889 --> 00:18:16,010
the the debugger for this Unicode is

302
00:18:12,510 --> 00:18:16,010
possible but too difficult

303
00:18:20,620 --> 00:18:28,909
Thanks and what what about the speed of

304
00:18:25,490 --> 00:18:32,360
software how much does it reduce

305
00:18:28,910 --> 00:18:35,300
after the you apply a superimpose that's

306
00:18:32,360 --> 00:18:38,389
imposed at your protector yeah so then

307
00:18:35,300 --> 00:18:41,000
that ten seconds now it's going to be

308
00:18:38,390 --> 00:18:43,550
one thousandth right it's because they

309
00:18:41,000 --> 00:18:46,720
predict profiler so the efficiency goes

310
00:18:43,550 --> 00:18:48,919
down so three hundred percent and

311
00:18:46,720 --> 00:18:51,550
because it selects not the functions

312
00:18:48,920 --> 00:18:55,100
about basic blocks and the base blocks

313
00:18:51,550 --> 00:18:58,280
it's not the total function it's just

314
00:18:55,100 --> 00:19:01,189
the there's no assemble assembled part

315
00:18:58,280 --> 00:19:05,030
that does not content until until the

316
00:19:01,190 --> 00:19:07,640
next transfer a set of instructions and

317
00:19:05,030 --> 00:19:10,850
automatic for a father measures the

318
00:19:07,640 --> 00:19:13,700
speed of those base blocks if it comes

319
00:19:10,850 --> 00:19:17,270
across a cycle then base blocks are not

320
00:19:13,700 --> 00:19:20,180
offered for protection and if you use it

321
00:19:17,270 --> 00:19:23,389
this time if this way so even the heavy

322
00:19:20,180 --> 00:19:26,180
function so then it will not be covered

323
00:19:23,390 --> 00:19:28,490
but other other base blocks will be

324
00:19:26,180 --> 00:19:30,320
protected but big functions that that

325
00:19:28,490 --> 00:19:33,620
when they found themselves in heavy

326
00:19:30,320 --> 00:19:36,980
cycles but if you need to protect what

327
00:19:33,620 --> 00:19:39,770
you think you need to protect then you

328
00:19:36,980 --> 00:19:42,440
need to develop a function and then you

329
00:19:39,770 --> 00:19:46,100
need to protect it you mean the rim line

330
00:19:42,440 --> 00:19:49,130
right I realize because we have the base

331
00:19:46,100 --> 00:19:52,040
block functions that will be protected

332
00:19:49,130 --> 00:19:54,430
right which we open up and in line yeah

333
00:19:52,040 --> 00:19:54,430
right

334
00:19:55,240 --> 00:20:01,610
what they mean by in light will protect

335
00:19:58,250 --> 00:20:04,850
the function here some base base block

336
00:20:01,610 --> 00:20:09,139
and then it opens up in in line

337
00:20:04,850 --> 00:20:13,040
no no it's different so I can protect

338
00:20:09,140 --> 00:20:15,710
the functions C++ function or it can

339
00:20:13,040 --> 00:20:18,740
protect only the base blocks in this

340
00:20:15,710 --> 00:20:21,650
function and there's several parts of

341
00:20:18,740 --> 00:20:24,559
constructs and when the production

342
00:20:21,650 --> 00:20:29,270
protection is superimposed you protect

343
00:20:24,559 --> 00:20:32,178
the whole functions so then so then

344
00:20:29,270 --> 00:20:34,490
partly it will be protected but only in

345
00:20:32,179 --> 00:20:36,620
a patchwork fashion there so then the

346
00:20:34,490 --> 00:20:40,700
basis of old base blocks there will be

347
00:20:36,620 --> 00:20:44,090
transfers introduced so that's for the

348
00:20:40,700 --> 00:20:47,090
executable file where the VM will be

349
00:20:44,090 --> 00:20:51,110
recorded with bytecode and then the

350
00:20:47,090 --> 00:20:53,899
execution time so which applications

351
00:20:51,110 --> 00:20:58,370
were protected by your protector real

352
00:20:53,900 --> 00:21:01,720
time no so big operations that require a

353
00:20:58,370 --> 00:21:06,290
lot of execution time no what kind of

354
00:21:01,720 --> 00:21:10,070
applications license the limitations

355
00:21:06,290 --> 00:21:11,990
checking licenses so then the critical

356
00:21:10,070 --> 00:21:15,590
parts of the code that need to be

357
00:21:11,990 --> 00:21:20,210
protected so you protect only parts

358
00:21:15,590 --> 00:21:22,668
right yes only parts not all of it so if

359
00:21:20,210 --> 00:21:24,710
you if you you know the help of

360
00:21:22,669 --> 00:21:27,770
automatic profiler a certain number of

361
00:21:24,710 --> 00:21:30,590
base blocks and then inside the

362
00:21:27,770 --> 00:21:33,500
application so dances and the it takes

363
00:21:30,590 --> 00:21:37,250
only certain percentage of it and then

364
00:21:33,500 --> 00:21:40,640
when you launch you won't notice that

365
00:21:37,250 --> 00:21:45,020
the speed has gone down about this base

366
00:21:40,640 --> 00:21:48,410
block can malfunction any any moment and

367
00:21:45,020 --> 00:21:50,418
if at this moment is might call his

368
00:21:48,410 --> 00:21:51,370
encrypted and the electronic older

369
00:21:50,419 --> 00:21:55,930
license

370
00:21:51,370 --> 00:21:57,580
then that you immediately have the the

371
00:21:55,930 --> 00:21:58,270
message that the license has not been

372
00:21:57,580 --> 00:22:01,980
found

373
00:21:58,270 --> 00:22:05,590
yeah we'll have would say in this way

374
00:22:01,980 --> 00:22:08,140
that they protect small blocks is much

375
00:22:05,590 --> 00:22:10,449
easier to reverse small blocks and then

376
00:22:08,140 --> 00:22:13,270
then the protection makes the synthesis

377
00:22:10,450 --> 00:22:23,430
automatic protection when you don't have

378
00:22:13,270 --> 00:22:27,940
just to go into so this is what we have

379
00:22:23,430 --> 00:22:32,560
so for such methods we have the mode of

380
00:22:27,940 --> 00:22:35,290
protection polymorphism SOE morph the

381
00:22:32,560 --> 00:22:39,030
code without VM that we need to protect

382
00:22:35,290 --> 00:22:41,860
a certain cycle embedded without license

383
00:22:39,030 --> 00:22:45,490
he has a protective function you

384
00:22:41,860 --> 00:22:48,490
understand that it's cycle just it gets

385
00:22:45,490 --> 00:22:51,490
slower and you cannot have that we cover

386
00:22:48,490 --> 00:22:53,350
it with a mutation of physician and the

387
00:22:51,490 --> 00:22:56,350
different mechanism sir

388
00:22:53,350 --> 00:23:00,639
but if mutation occurs then the speed

389
00:22:56,350 --> 00:23:04,510
goes down considerably Nala know much

390
00:23:00,640 --> 00:23:07,570
much faster than that so then the order

391
00:23:04,510 --> 00:23:12,160
of one order of magnitude only one other

392
00:23:07,570 --> 00:23:14,669
languages thank you thank you thank you

393
00:23:12,160 --> 00:23:14,670
Michael

