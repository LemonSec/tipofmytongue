1
00:00:00,050 --> 00:00:05,430
pehota my report a minute just apricot

2
00:00:03,120 --> 00:00:08,910
systolic with bulimia I only program

3
00:00:05,430 --> 00:00:11,428
hypersonic needs acacia Marable towards

4
00:00:08,910 --> 00:00:14,429
collapse on your program reviewing you

5
00:00:11,429 --> 00:00:16,920
here Tito just of our image Eaton

6
00:00:14,429 --> 00:00:20,850
afforded Sasha pews we misty in a path

7
00:00:16,920 --> 00:00:22,529
laid new stroll cool items Piske the new

8
00:00:20,850 --> 00:00:26,369
mod with you mister strategy for

9
00:00:22,529 --> 00:00:28,560
mightier Anya she would know what he

10
00:00:26,369 --> 00:00:31,259
presented Samaras modem static weeow

11
00:00:28,560 --> 00:00:34,680
weeow mr. active so today we shall

12
00:00:31,260 --> 00:00:39,180
consider what is a formatting light of

13
00:00:34,680 --> 00:00:41,129
vulnerabilities and mitigation so what

14
00:00:39,180 --> 00:00:43,320
should be done with these

15
00:00:41,129 --> 00:00:46,379
vulnerabilities that formatting while

16
00:00:43,320 --> 00:00:49,050
vulnerabilities is a young rather a

17
00:00:46,379 --> 00:00:52,110
young vulnerability because they have

18
00:00:49,050 --> 00:00:56,129
been discovered in 2001 and this

19
00:00:52,110 --> 00:01:00,559
vulnerability consists well it means is

20
00:00:56,129 --> 00:01:05,759
that a certain number of functions

21
00:01:00,559 --> 00:01:08,789
attack okay it can fit this line that

22
00:01:05,760 --> 00:01:12,360
will force the software to program to do

23
00:01:08,790 --> 00:01:15,390
something that it shouldn't so what can

24
00:01:12,360 --> 00:01:20,729
it do first fall and we shall get DDoS

25
00:01:15,390 --> 00:01:22,770
then it may actually give provide access

26
00:01:20,729 --> 00:01:24,990
to the memory that shouldn't be provided

27
00:01:22,770 --> 00:01:30,030
so we shall get a memory leak and this

28
00:01:24,990 --> 00:01:32,970
vulnerability allow us to rewrite to

29
00:01:30,030 --> 00:01:36,540
modify our memories away the attacker

30
00:01:32,970 --> 00:01:41,090
once and the behavior will change in

31
00:01:36,540 --> 00:01:41,090
such case and most of the functions

32
00:01:42,460 --> 00:01:52,130
that use this vulnerability so-called a

33
00:01:45,159 --> 00:01:54,390
print family here we have more details

34
00:01:52,130 --> 00:01:58,658
[Music]

35
00:01:54,390 --> 00:02:01,570
about the specifiers that can change the

36
00:01:58,659 --> 00:02:10,500
program behavior the software behavior

37
00:02:01,570 --> 00:02:13,750
the first is we have many specifiers of

38
00:02:10,500 --> 00:02:17,170
the line sooner or later the program

39
00:02:13,750 --> 00:02:20,530
will turn to the memory that is

40
00:02:17,170 --> 00:02:22,799
forbidden for access or the memory has

41
00:02:20,530 --> 00:02:28,380
been removed and the program will fall

42
00:02:22,800 --> 00:02:32,410
if we use X specifier then some values

43
00:02:28,380 --> 00:02:35,350
will be we'll have 16 teachers if we use

44
00:02:32,410 --> 00:02:40,299
specifiers like n and will allow us to

45
00:02:35,350 --> 00:02:42,940
rewrite the memory and here at the slide

46
00:02:40,300 --> 00:02:46,560
we see the statistics of the nist

47
00:02:42,940 --> 00:02:50,440
institute the national mobility data

48
00:02:46,560 --> 00:02:52,329
national vulnerability database and we

49
00:02:50,440 --> 00:02:56,350
see the number of vulnerabilities of

50
00:02:52,329 --> 00:03:00,940
format line by years we can see

51
00:02:56,350 --> 00:03:03,790
immediately after tracking after finding

52
00:03:00,940 --> 00:03:10,200
out the number keeps growing and it will

53
00:03:03,790 --> 00:03:14,828
after 2010 it shrinks and primarily

54
00:03:10,200 --> 00:03:17,140
because of the languages this especially

55
00:03:14,829 --> 00:03:21,340
the sealant which are used less and less

56
00:03:17,140 --> 00:03:26,440
this vulnerability is a is also specific

57
00:03:21,340 --> 00:03:30,459
for fighting because this this c-sharp

58
00:03:26,440 --> 00:03:32,560
with java are not vulnerable and do not

59
00:03:30,459 --> 00:03:36,280
have this vulnerability if you use C++

60
00:03:32,560 --> 00:03:39,790
they are also they don't have this

61
00:03:36,280 --> 00:03:43,450
vulnerability either so and this is the

62
00:03:39,790 --> 00:03:45,880
percentage of a formatting line

63
00:03:43,450 --> 00:03:50,799
ability to other vulnerabilities and we

64
00:03:45,880 --> 00:03:53,079
see that in 2010 it's for the maximum

65
00:03:50,800 --> 00:03:57,310
and then it kept going down and later

66
00:03:53,080 --> 00:03:59,530
later it actually goes to zero because

67
00:03:57,310 --> 00:04:01,720
there are many other types of

68
00:03:59,530 --> 00:04:09,459
vulnerabilities that has never been have

69
00:04:01,720 --> 00:04:13,540
never been there before and let me tell

70
00:04:09,459 --> 00:04:38,680
you in more detail about the way it

71
00:04:13,540 --> 00:04:41,200
appears in C language there is a show on

72
00:04:38,680 --> 00:04:48,010
the screen printed the buffer and these

73
00:04:41,200 --> 00:04:50,969
functions others like that but at the

74
00:04:48,010 --> 00:04:55,300
same time there are functions that are

75
00:04:50,970 --> 00:04:58,060
specific for z/os for Linux said it is a

76
00:04:55,300 --> 00:05:02,760
syslog function and set prop title

77
00:04:58,060 --> 00:05:07,030
function I will have a question for you

78
00:05:02,760 --> 00:05:09,070
there is a function that accepts the

79
00:05:07,030 --> 00:05:11,349
formatting line but does not accept an

80
00:05:09,070 --> 00:05:22,060
old argument cell what does it do any

81
00:05:11,350 --> 00:05:30,190
ideas no I'll give you a cool it prints

82
00:05:22,060 --> 00:05:32,060
some system data no idea I'll tell you

83
00:05:30,190 --> 00:05:35,930
as to ref time

84
00:05:32,060 --> 00:05:40,610
except the format learn how to show that

85
00:05:35,930 --> 00:05:43,340
they masa it will take the argument from

86
00:05:40,610 --> 00:05:52,040
the system and print them to console or

87
00:05:43,340 --> 00:05:56,989
file or a buffer so far we are not aware

88
00:05:52,040 --> 00:06:00,140
of such a vulnerability but if someone

89
00:05:56,990 --> 00:06:01,700
is looking for new attack ways so they

90
00:06:00,140 --> 00:06:06,349
can turn to such functions there are

91
00:06:01,700 --> 00:06:09,740
many interesting things and here we have

92
00:06:06,350 --> 00:06:13,760
a simple function that takes the format

93
00:06:09,740 --> 00:06:16,880
line and on top we see the prototype

94
00:06:13,760 --> 00:06:20,360
first the star and the format and the

95
00:06:16,880 --> 00:06:24,050
arguments that should be shown in this

96
00:06:20,360 --> 00:06:26,780
format and the examples in this sample

97
00:06:24,050 --> 00:06:28,940
first the texture then specifier of the

98
00:06:26,780 --> 00:06:30,919
output and the symbol and then it means

99
00:06:28,940 --> 00:06:33,950
that intend the function should start

100
00:06:30,920 --> 00:06:35,780
reading the argument and then we'll

101
00:06:33,950 --> 00:06:38,630
write the time but other parameters that

102
00:06:35,780 --> 00:06:46,849
they all who argument 505 in this case

103
00:06:38,630 --> 00:06:48,440
it is an integer and we have say the

104
00:06:46,850 --> 00:06:54,340
most popular arguments that the

105
00:06:48,440 --> 00:06:58,880
functions I take the D integer as a char

106
00:06:54,340 --> 00:07:02,750
ASCII line ends with zeros and axel

107
00:06:58,880 --> 00:07:06,590
integer but we need to show within 16

108
00:07:02,750 --> 00:07:08,889
digits shape than address the pointer

109
00:07:06,590 --> 00:07:13,099
store and then

110
00:07:08,889 --> 00:07:18,590
some other things that means that you

111
00:07:13,100 --> 00:07:20,810
need to to print in a special shape it's

112
00:07:18,590 --> 00:07:24,229
an important parameter and the most

113
00:07:20,810 --> 00:07:27,620
interesting parameter is an N means that

114
00:07:24,229 --> 00:07:29,630
the data should not be not taken from

115
00:07:27,620 --> 00:07:33,770
the argument but you need to record data

116
00:07:29,630 --> 00:07:37,370
to the argument and a sprint a missus L

117
00:07:33,770 --> 00:07:42,650
it would write as a relevant argument

118
00:07:37,370 --> 00:07:44,930
and the number of bytes that was shown

119
00:07:42,650 --> 00:07:48,679
by this function before this argument

120
00:07:44,930 --> 00:07:51,860
and la last with the dollar so called

121
00:07:48,680 --> 00:07:53,720
positioning argument that means that you

122
00:07:51,860 --> 00:07:56,479
don't need to read all arguments but

123
00:07:53,720 --> 00:08:05,539
turn to the second one was the third or

124
00:07:56,479 --> 00:08:12,020
the fifth one I would like to specify

125
00:08:05,539 --> 00:08:15,039
that many actually consider the format

126
00:08:12,020 --> 00:08:18,740
line vulnerability as a buffer overflow

127
00:08:15,039 --> 00:08:21,469
as the buffer is a stack stack is one of

128
00:08:18,740 --> 00:08:24,020
the types of the memory and types of the

129
00:08:21,470 --> 00:08:28,130
memory we we shall consider memories

130
00:08:24,020 --> 00:08:30,109
later and the memory types if we have

131
00:08:28,130 --> 00:08:33,708
said the wrong argument for the print

132
00:08:30,110 --> 00:08:37,880
the function start writing outside of

133
00:08:33,708 --> 00:08:44,150
the buffer and in this case overflow

134
00:08:37,880 --> 00:08:51,160
happens as a step can be considered as

135
00:08:44,150 --> 00:08:51,160
buffer and the print function

136
00:08:51,880 --> 00:08:59,050
merit special attention they print the

137
00:08:56,050 --> 00:09:01,569
info to the buffer and past as a user so

138
00:08:59,050 --> 00:09:05,550
double overload as possible as we said

139
00:09:01,569 --> 00:09:10,810
before we can overflow the stack and

140
00:09:05,550 --> 00:09:15,099
special we can make it well the buffer

141
00:09:10,810 --> 00:09:17,290
to the user can be overloaded too so the

142
00:09:15,100 --> 00:09:20,290
user will get double overload in this

143
00:09:17,290 --> 00:09:26,319
case to avoid it it's recommended to use

144
00:09:20,290 --> 00:09:30,069
the function as a print with n was the

145
00:09:26,319 --> 00:09:32,769
difference in SF prints the length Tran

146
00:09:30,069 --> 00:09:35,199
transmits the length of the buffer and

147
00:09:32,769 --> 00:09:38,980
in this case the function will stop will

148
00:09:35,199 --> 00:09:41,889
not overload the buffer so it's

149
00:09:38,980 --> 00:09:44,139
difficult to make a mistake because most

150
00:09:41,889 --> 00:09:50,790
of the analyzers of the source called a

151
00:09:44,139 --> 00:09:53,529
Coverity will show you don't use unsafe

152
00:09:50,790 --> 00:09:57,459
notions of the stable standard library

153
00:09:53,529 --> 00:10:02,860
use the ones with n letter yes you need

154
00:09:57,459 --> 00:10:05,050
to to enter the argument is not

155
00:10:02,860 --> 00:10:14,290
convenient but it's secure much more

156
00:10:05,050 --> 00:10:17,410
secure here we print thousand sign

157
00:10:14,290 --> 00:10:20,589
digits and then L equals to zero and

158
00:10:17,410 --> 00:10:26,920
then it's zero the here is the position

159
00:10:20,589 --> 00:10:30,069
parameter and then it's only

160
00:10:26,920 --> 00:10:32,829
the second argument well seems good but

161
00:10:30,069 --> 00:10:40,358
this code that may cause problems if you

162
00:10:32,829 --> 00:10:42,758
use a 5-0 or higher release this GCC

163
00:10:40,359 --> 00:10:47,649
green I decided to protect their

164
00:10:42,759 --> 00:10:51,189
compiler and if you use only the second

165
00:10:47,649 --> 00:10:53,559
argument and don't use first answer it

166
00:10:51,189 --> 00:10:57,819
and a second and you get and valid

167
00:10:53,559 --> 00:11:00,639
percent and use so we saw that you use

168
00:10:57,819 --> 00:11:05,248
position parameter wrongly in the

169
00:11:00,639 --> 00:11:05,249
internet and sometimes saw that someone

170
00:11:07,559 --> 00:11:15,699
some someone works on a project and the

171
00:11:11,889 --> 00:11:18,160
project fails and the same people start

172
00:11:15,699 --> 00:11:20,858
thinking why did the project fail

173
00:11:18,160 --> 00:11:24,689
because the position parameters with a

174
00:11:20,859 --> 00:11:24,689
new project should not be used like that

175
00:11:27,059 --> 00:11:37,600
so obviously the argument 200 and it

176
00:11:35,110 --> 00:11:40,929
will be taken from the stack we shall

177
00:11:37,600 --> 00:11:43,869
consider how it works later how the n

178
00:11:40,929 --> 00:11:46,959
parameter works as a record that so we

179
00:11:43,869 --> 00:11:51,009
specify like that and percent and then

180
00:11:46,959 --> 00:11:53,859
we shall say variable and n means that

181
00:11:51,009 --> 00:11:58,299
you need to write is a four byte

182
00:11:53,860 --> 00:12:00,399
variable the size is four bytes as the

183
00:11:58,299 --> 00:12:02,980
print function has not identified any

184
00:12:00,399 --> 00:12:05,980
date of the variable will equal to zero

185
00:12:02,980 --> 00:12:09,730
and then we have specification for

186
00:12:05,980 --> 00:12:14,699
double by the number it's H n if we want

187
00:12:09,730 --> 00:12:14,699
a double byte variable we should use H n

188
00:12:20,770 --> 00:12:26,600
and one more case which is most

189
00:12:24,080 --> 00:12:30,980
difficult with will record 100 fight

190
00:12:26,600 --> 00:12:35,450
into two by the variable we first have

191
00:12:30,980 --> 00:12:37,400
100 spaces and % 100 and then turn to

192
00:12:35,450 --> 00:12:41,900
the second parameter to this dollar

193
00:12:37,400 --> 00:12:44,959
specifier and in this case we have a

194
00:12:41,900 --> 00:12:51,920
variable as a hundred because we had 100

195
00:12:44,960 --> 00:12:55,570
spaces now let me show you how easily

196
00:12:51,920 --> 00:12:58,880
this function may drop your application

197
00:12:55,570 --> 00:13:04,089
we take as a line and the string is a

198
00:12:58,880 --> 00:13:04,089
reads to 0 is good and it turns -

199
00:13:05,800 --> 00:13:13,339
usually you input several symbols if we

200
00:13:09,440 --> 00:13:16,520
outputs for integer and then we shall

201
00:13:13,339 --> 00:13:21,040
take for integers from stack that's how

202
00:13:16,520 --> 00:13:23,680
it looks if we show the 8 digit

203
00:13:21,040 --> 00:13:27,170
specifier it will look better

204
00:13:23,680 --> 00:13:30,829
we have 16 digits here because we have X

205
00:13:27,170 --> 00:13:32,329
here and here is a case an example for

206
00:13:30,830 --> 00:13:34,460
you I believe it's one of the most

207
00:13:32,330 --> 00:13:36,200
dangerous from everything you know from

208
00:13:34,460 --> 00:13:40,660
all because it doesn't look like

209
00:13:36,200 --> 00:13:43,160
dangerous it seems to write 100

210
00:13:40,660 --> 00:13:48,110
centimeters and and why is it dangerous

211
00:13:43,160 --> 00:13:50,300
it uses a very rare property of the

212
00:13:48,110 --> 00:13:54,320
print function ignoring all the spaces

213
00:13:50,300 --> 00:13:55,609
between the specifier and % and the type

214
00:13:54,320 --> 00:13:59,030
of specifier

215
00:13:55,610 --> 00:14:01,640
D letters D in this case the function

216
00:13:59,030 --> 00:14:03,589
will see I need to take hundredths and

217
00:14:01,640 --> 00:14:05,959
takes the stack and attend a and that's

218
00:14:03,589 --> 00:14:08,530
what going to happen we write 100 then

219
00:14:05,959 --> 00:14:12,209
we'll take the integer from stack and

220
00:14:08,530 --> 00:14:17,890
put out if if a user

221
00:14:12,209 --> 00:14:20,589
if an attacker asks a user to write the

222
00:14:17,890 --> 00:14:23,560
user will certainly no doubt input

223
00:14:20,589 --> 00:14:26,260
because it's not some kind of 16 digital

224
00:14:23,560 --> 00:14:32,219
show code it's a proper logical asking

225
00:14:26,260 --> 00:14:37,870
line and another dangerous case because

226
00:14:32,220 --> 00:14:40,209
it allows you not just to show data to

227
00:14:37,870 --> 00:14:43,360
take data from the state but record data

228
00:14:40,209 --> 00:14:47,140
into the memory and it uses the same way

229
00:14:43,360 --> 00:14:50,079
we write 100,000 printf ignores as a

230
00:14:47,140 --> 00:14:54,069
space between % n n and virtually what

231
00:14:50,079 --> 00:15:01,449
does it all will show a hundred then and

232
00:14:54,070 --> 00:15:07,450
doesn't use and 0 that's it and these

233
00:15:01,450 --> 00:15:10,360
are the dangerous of print function so

234
00:15:07,450 --> 00:15:12,370
several examples of printf function that

235
00:15:10,360 --> 00:15:14,470
can easily spoil your application if you

236
00:15:12,370 --> 00:15:17,230
write many many many percentage that

237
00:15:14,470 --> 00:15:20,170
will count to zero and on the fifth and

238
00:15:17,230 --> 00:15:23,519
sixth step I used to have a desert it

239
00:15:20,170 --> 00:15:27,189
will just fall because it will turn to

240
00:15:23,519 --> 00:15:30,730
the forbidden areas of the memory and

241
00:15:27,190 --> 00:15:34,120
how do you take data from the stack then

242
00:15:30,730 --> 00:15:36,279
again we input many specifiers of

243
00:15:34,120 --> 00:15:39,040
sixteen digit format and we get the data

244
00:15:36,279 --> 00:15:43,899
and the function allows to look into the

245
00:15:39,040 --> 00:15:48,760
memory of any address and write record

246
00:15:43,899 --> 00:15:51,250
why is it dangerous to look into the

247
00:15:48,760 --> 00:15:53,769
memory because it may keep Keys logins

248
00:15:51,250 --> 00:15:56,890
passwords and imagine a situation when

249
00:15:53,769 --> 00:16:01,360
you have a CGI script that would do

250
00:15:56,890 --> 00:16:04,720
something well if it has a vulnerability

251
00:16:01,360 --> 00:16:07,300
in the format in mind the attacker can

252
00:16:04,720 --> 00:16:11,290
turn consecutive little to all the

253
00:16:07,300 --> 00:16:14,729
memory parts get a binary image of the

254
00:16:11,290 --> 00:16:16,969
file without a here or whatever

255
00:16:14,730 --> 00:16:20,120
structures but

256
00:16:16,970 --> 00:16:23,120
it will be sufficient to load into the

257
00:16:20,120 --> 00:16:26,240
analyzer or to prove our and analyze of

258
00:16:23,120 --> 00:16:29,500
what exactly this script is doing and

259
00:16:26,240 --> 00:16:32,330
how it works and with all the relevant

260
00:16:29,500 --> 00:16:34,280
consequences so it there will be a leak

261
00:16:32,330 --> 00:16:38,240
of your application the whole

262
00:16:34,280 --> 00:16:40,640
application then let me tell you in more

263
00:16:38,240 --> 00:16:42,260
detail about the types of memory in the

264
00:16:40,640 --> 00:16:45,230
application there are also numerous

265
00:16:42,260 --> 00:16:49,610
first its text text is where you store

266
00:16:45,230 --> 00:16:52,340
the codes of the program then data that

267
00:16:49,610 --> 00:16:56,200
global variables that have initial value

268
00:16:52,340 --> 00:17:00,440
and not non idealized data global

269
00:16:56,200 --> 00:17:04,730
variables and the stack and it keeps

270
00:17:00,440 --> 00:17:07,430
information about the consequence of the

271
00:17:04,730 --> 00:17:12,920
function then about the arguments and

272
00:17:07,430 --> 00:17:15,920
other and the area of memory that is

273
00:17:12,920 --> 00:17:18,470
allocated dynamically and use the votes

274
00:17:15,920 --> 00:17:24,770
per person has to be called back to be

275
00:17:18,470 --> 00:17:27,770
reused those who are familiar will L

276
00:17:24,770 --> 00:17:29,990
file structure it must have noticed that

277
00:17:27,770 --> 00:17:33,320
many times actually repeats the

278
00:17:29,990 --> 00:17:36,320
interceptions of L file here Belova

279
00:17:33,320 --> 00:17:40,280
below when you look at the presentation

280
00:17:36,320 --> 00:17:46,070
you see over 30 files of that type text

281
00:17:40,280 --> 00:17:47,720
initialized data PSS and now let me tell

282
00:17:46,070 --> 00:17:50,240
you in more detail about the stack it

283
00:17:47,720 --> 00:17:53,930
keeps the information about the

284
00:17:50,240 --> 00:17:57,830
consequence and then local variables and

285
00:17:53,930 --> 00:18:03,380
the parameters and returnable address

286
00:17:57,830 --> 00:18:08,270
and it keeps also a return point and the

287
00:18:03,380 --> 00:18:10,440
pointer to SP register that stores the

288
00:18:08,270 --> 00:18:17,420
current value

289
00:18:10,440 --> 00:18:17,420
the pointer that's how it looks

290
00:18:17,720 --> 00:18:27,990
that's the memory of the application and

291
00:18:22,910 --> 00:18:32,040
the stack and the stack grows from top

292
00:18:27,990 --> 00:18:34,220
to bottom and culture grows from bottom

293
00:18:32,040 --> 00:18:39,840
to the top

294
00:18:34,220 --> 00:18:42,390
and recently in 2017 the new

295
00:18:39,840 --> 00:18:45,149
vulnerability was discovered it calls a

296
00:18:42,390 --> 00:18:49,560
stack smashing when the stack grows so

297
00:18:45,150 --> 00:18:53,520
strong that that replaces that damages

298
00:18:49,560 --> 00:18:56,760
culture and so very interesting effects

299
00:18:53,520 --> 00:18:58,620
may be found possible so but it's rather

300
00:18:56,760 --> 00:19:00,780
about the vulnerability of buffer

301
00:18:58,620 --> 00:19:03,239
overflow probably one day I'll tell you

302
00:19:00,780 --> 00:19:05,610
about it in more detail

303
00:19:03,240 --> 00:19:06,150
so we have a simple code how does it

304
00:19:05,610 --> 00:19:10,590
work

305
00:19:06,150 --> 00:19:13,820
so I attribute 10 then I call for a

306
00:19:10,590 --> 00:19:17,280
print function and what happens and the

307
00:19:13,820 --> 00:19:21,750
arguments are go from right to left then

308
00:19:17,280 --> 00:19:26,940
address value than a frontier fmt and

309
00:19:21,750 --> 00:19:30,180
the PIA instruction pointer EBP is P

310
00:19:26,940 --> 00:19:37,200
copy and that's how this tent will grow

311
00:19:30,180 --> 00:19:43,920
and it grows from top to bottom and what

312
00:19:37,200 --> 00:19:45,990
if we show X and percentage so in the

313
00:19:43,920 --> 00:19:48,810
same way we shall have arguments on the

314
00:19:45,990 --> 00:19:50,520
stack and the formatting function and

315
00:19:48,810 --> 00:19:52,230
then it will nothing it will be nothing

316
00:19:50,520 --> 00:19:54,960
and the function will think is that

317
00:19:52,230 --> 00:19:57,870
there will be T Alex but in France there

318
00:19:54,960 --> 00:20:00,860
are some other data and it will take

319
00:19:57,870 --> 00:20:00,860
that other data

320
00:20:02,600 --> 00:20:14,340
so let's consider a more complicated

321
00:20:05,400 --> 00:20:16,919
case we use it as a specifier would have

322
00:20:14,340 --> 00:20:24,620
a local variable how will this that look

323
00:20:16,919 --> 00:20:27,900
like first fmt and then welcome we

324
00:20:24,620 --> 00:20:30,600
argument so from right to left and then

325
00:20:27,900 --> 00:20:38,070
a return the value of the function is n

326
00:20:30,600 --> 00:20:45,539
DB P it depends on the compiler if you

327
00:20:38,070 --> 00:20:47,820
use that as a compilers and version

328
00:20:45,539 --> 00:20:50,129
proper also there may be other values

329
00:20:47,820 --> 00:20:56,428
but on the whole we can ignore it

330
00:20:50,130 --> 00:20:58,770
because they should be permanent for the

331
00:20:56,429 --> 00:21:02,429
same person than the variables and

332
00:20:58,770 --> 00:21:06,539
formatting line that uses print and then

333
00:21:02,429 --> 00:21:08,580
return address and that's how it look at

334
00:21:06,539 --> 00:21:16,010
the moment of loading what will happen

335
00:21:08,580 --> 00:21:20,399
if we attribute 4141 as address and the

336
00:21:16,010 --> 00:21:22,020
5a pointer and in this case print

337
00:21:20,399 --> 00:21:24,719
function well things that after

338
00:21:22,020 --> 00:21:28,740
formatting line we have five pointers

339
00:21:24,720 --> 00:21:31,770
that need to be shown and in fact we

340
00:21:28,740 --> 00:21:35,909
have local variables register return

341
00:21:31,770 --> 00:21:38,010
address address what we transferred to

342
00:21:35,909 --> 00:21:39,679
the function formatting lines so it will

343
00:21:38,010 --> 00:21:45,679
it will look like that

344
00:21:39,679 --> 00:21:45,679
0:41 information from this tag

345
00:21:46,170 --> 00:21:52,120
in order to modify the other parameter

346
00:21:49,960 --> 00:21:55,600
we can turn directly to the fourth

347
00:21:52,120 --> 00:22:00,310
argument in this case we modify the

348
00:21:55,600 --> 00:22:04,090
formatting light percent for dollar P it

349
00:22:00,310 --> 00:22:07,419
means that specifier is four and dollars

350
00:22:04,090 --> 00:22:09,070
P P is a type and in this case we shall

351
00:22:07,420 --> 00:22:15,880
have 41 41

352
00:22:09,070 --> 00:22:19,570
and then we shall show space 41 41 and

353
00:22:15,880 --> 00:22:21,820
now we are just showing them so it will

354
00:22:19,570 --> 00:22:26,830
be zero one hundred six percent for

355
00:22:21,820 --> 00:22:29,169
dollar P and now attention dollar we

356
00:22:26,830 --> 00:22:33,550
replace by dollar and it means is that

357
00:22:29,170 --> 00:22:36,070
instead of showing information we write

358
00:22:33,550 --> 00:22:41,590
report the information was going to

359
00:22:36,070 --> 00:22:45,429
happen 100 spaces and we record this

360
00:22:41,590 --> 00:22:47,139
number 102 41 41 so at this address we

361
00:22:45,430 --> 00:22:53,710
shall have a hundred that's how you

362
00:22:47,140 --> 00:22:57,340
rewrite the memory so that's in February

363
00:22:53,710 --> 00:22:59,710
2012 a vulnerability for format land

364
00:22:57,340 --> 00:23:03,699
volatility was discovered in the pseudo

365
00:22:59,710 --> 00:23:06,850
utility we know Linux that gives you

366
00:23:03,700 --> 00:23:09,760
super user access to a simple user it

367
00:23:06,850 --> 00:23:13,780
has special configuration options but it

368
00:23:09,760 --> 00:23:19,480
turned out that super user cool access

369
00:23:13,780 --> 00:23:22,330
can be it can be gotten very simply so

370
00:23:19,480 --> 00:23:24,700
most of the Fedora Bill and others were

371
00:23:22,330 --> 00:23:29,090
infected and

372
00:23:24,700 --> 00:23:33,140
the code that uses this you to acts on

373
00:23:29,090 --> 00:23:36,260
mouse-over PMS insert messager jabber

374
00:23:33,140 --> 00:23:39,740
server caps calm a unix persistent

375
00:23:36,260 --> 00:23:43,150
printed system here of UNIX and the

376
00:23:39,740 --> 00:23:45,260
impression is that that those who built

377
00:23:43,150 --> 00:23:47,750
this so dog

378
00:23:45,260 --> 00:23:51,950
Alina's distributive were either

379
00:23:47,750 --> 00:23:54,890
ignoring the compiler alarm or used old

380
00:23:51,950 --> 00:23:58,430
compiler what was the vulnerabilities

381
00:23:54,890 --> 00:24:02,050
this is the code that launches this one

382
00:23:58,430 --> 00:24:05,810
earth at uses exploit a vulnerability if

383
00:24:02,050 --> 00:24:11,899
you could exploit it if you debug the

384
00:24:05,810 --> 00:24:16,700
log what would happen to say format

385
00:24:11,900 --> 00:24:19,430
lines that uses es print function was

386
00:24:16,700 --> 00:24:22,070
available to the attacker line because

387
00:24:19,430 --> 00:24:24,290
the formatting line is this case is a

388
00:24:22,070 --> 00:24:29,240
get prom name what is probe name is an

389
00:24:24,290 --> 00:24:32,690
argument in our program how can you

390
00:24:29,240 --> 00:24:36,290
change in linux make a symbolic liquor

391
00:24:32,690 --> 00:24:38,750
to the katawaga to 10 percent 10 percent

392
00:24:36,290 --> 00:24:42,470
to 10 percent key whatever it is and

393
00:24:38,750 --> 00:24:45,770
launch and it will go if you're

394
00:24:42,470 --> 00:24:48,370
interested how you use this

395
00:24:45,770 --> 00:24:51,020
vulnerability there is a linker here

396
00:24:48,370 --> 00:24:54,669
after the presentation when you download

397
00:24:51,020 --> 00:24:59,870
look it's very simple today there's no a

398
00:24:54,670 --> 00:25:01,370
practical case usually at this step

399
00:24:59,870 --> 00:25:03,469
might print of my presentation I

400
00:25:01,370 --> 00:25:06,830
launched shell I show how it works but

401
00:25:03,470 --> 00:25:11,600
unfortunately I have no chance here and

402
00:25:06,830 --> 00:25:15,710
so I I'll show you our new screenshots

403
00:25:11,600 --> 00:25:19,100
we have two variables global no one come

404
00:25:15,710 --> 00:25:20,930
to we take address from the global we

405
00:25:19,100 --> 00:25:24,320
show it and then

406
00:25:20,930 --> 00:25:30,530
to check two conditions if no one is ABC

407
00:25:24,320 --> 00:25:34,760
we its first condition if to gef is that

408
00:25:30,530 --> 00:25:38,620
then its second condition then we I use

409
00:25:34,760 --> 00:25:43,040
here special option if not and protector

410
00:25:38,620 --> 00:25:48,169
for the reason that the linux version

411
00:25:43,040 --> 00:25:50,750
that i use by default at the step

412
00:25:48,170 --> 00:25:54,950
protector what is a step protector is a

413
00:25:50,750 --> 00:25:57,860
special value at the moment that you use

414
00:25:54,950 --> 00:26:03,230
at the moment of calling the function in

415
00:25:57,860 --> 00:26:05,360
Intel it is a double dot 28 and then it

416
00:26:03,230 --> 00:26:08,210
will be checked after the function and

417
00:26:05,360 --> 00:26:10,639
if those values are different it means

418
00:26:08,210 --> 00:26:12,820
that someone rewritten our stack it's

419
00:26:10,640 --> 00:26:16,040
also cause that canary

420
00:26:12,820 --> 00:26:18,320
Dunham's lucci demonstrates onyx telex

421
00:26:16,040 --> 00:26:22,520
taken area at crucial I can Assam

422
00:26:18,320 --> 00:26:25,220
deliver my Oh Boone and although it did

423
00:26:22,520 --> 00:26:28,940
not affect anything so as you see the

424
00:26:25,220 --> 00:26:33,140
compiler warns me that here we do the

425
00:26:28,940 --> 00:26:36,290
print so their formatting line the

426
00:26:33,140 --> 00:26:38,870
format like arc one a friend does not

427
00:26:36,290 --> 00:26:43,120
have format line format line is an

428
00:26:38,870 --> 00:26:43,120
argument from the user but we don't say

429
00:26:43,870 --> 00:26:51,919
format string so format string so we

430
00:26:48,650 --> 00:26:57,730
give lots of pppp right and then and

431
00:26:51,920 --> 00:27:01,520
then we see an option that the last v60

432
00:26:57,730 --> 00:27:04,040
3/8 so it's equal circle to the address

433
00:27:01,520 --> 00:27:06,560
of gnome one of our global variable it's

434
00:27:04,040 --> 00:27:08,389
in quoted what does it again what does

435
00:27:06,560 --> 00:27:11,000
it give us you will know the address of

436
00:27:08,390 --> 00:27:13,460
the variable we can rewrite it and do

437
00:27:11,000 --> 00:27:15,800
what we want it we'll look at the code

438
00:27:13,460 --> 00:27:18,560
there so then to to

439
00:27:15,800 --> 00:27:22,669
to launch the first so that no one

440
00:27:18,560 --> 00:27:26,389
variable so we get it in this fashion so

441
00:27:22,670 --> 00:27:30,530
to achieve that when they - at ABC or us

442
00:27:26,390 --> 00:27:33,110
and certain certain number so the simple

443
00:27:30,530 --> 00:27:38,210
is to do this way it's a very simple

444
00:27:33,110 --> 00:27:41,090
script a ABC or us I don't know just how

445
00:27:38,210 --> 00:27:44,330
many it will be started work and then we

446
00:27:41,090 --> 00:27:48,439
exploit the vulnerability so then we do

447
00:27:44,330 --> 00:27:51,139
the shelf covering how to 10%

448
00:27:48,440 --> 00:27:55,010
there's the specifier of the string line

449
00:27:51,140 --> 00:27:59,150
and then nine are the ninth argument and

450
00:27:55,010 --> 00:28:02,510
then the ninth argument and then and

451
00:27:59,150 --> 00:28:04,910
then we not to take it out but to write

452
00:28:02,510 --> 00:28:07,460
it down that there is slash so that it's

453
00:28:04,910 --> 00:28:11,150
this dollar symbol so would go through

454
00:28:07,460 --> 00:28:15,530
easily and into and get into the program

455
00:28:11,150 --> 00:28:18,590
and it leads to the row below global

456
00:28:15,530 --> 00:28:22,610
done and eventually you know we get the

457
00:28:18,590 --> 00:28:25,990
variable of a new is equal to ABC that's

458
00:28:22,610 --> 00:28:25,990
how it can be done in practice

459
00:28:27,410 --> 00:28:32,930
let me show this example I have a

460
00:28:30,080 --> 00:28:35,990
question for you so they spit that and

461
00:28:32,930 --> 00:28:40,430
then the hacking of constant if not one

462
00:28:35,990 --> 00:28:43,870
nom du is our constants can we exploit

463
00:28:40,430 --> 00:28:55,250
vulnerabilities not do heaven edges

464
00:28:43,870 --> 00:28:58,929
yes or no and explain why so for agency

465
00:28:55,250 --> 00:29:03,470
who develops us any ideas

466
00:28:58,930 --> 00:29:07,900
no one is a global variable I said

467
00:29:03,470 --> 00:29:07,900
became a constant so what can be done

468
00:29:07,990 --> 00:29:29,420
what ideas maybe you can be done or not

469
00:29:20,530 --> 00:29:33,250
yes anyone thinks no you know cuz it

470
00:29:29,420 --> 00:29:43,940
will be in the section of unchangeable

471
00:29:33,250 --> 00:29:51,320
correct correct answer yes new the price

472
00:29:43,940 --> 00:29:55,190
for courage use the previous slide told

473
00:29:51,320 --> 00:29:57,330
us that the type of memory they so they

474
00:29:55,190 --> 00:30:02,399
correspond

475
00:29:57,330 --> 00:30:05,639
- there are five sections initially an

476
00:30:02,399 --> 00:30:09,869
initiator of the data constant global

477
00:30:05,639 --> 00:30:13,529
variables will be in the raw data use

478
00:30:09,869 --> 00:30:16,019
only for eating money for eating that's

479
00:30:13,529 --> 00:30:32,609
mental gap segmentation fault we will

480
00:30:16,019 --> 00:30:35,070
try to exploit this dissection what do I

481
00:30:32,609 --> 00:30:38,428
know about the mitigations first thing

482
00:30:35,070 --> 00:30:45,509
we need to avoid vulnerabilities of

483
00:30:38,429 --> 00:30:48,179
format string isn't controlled by the

484
00:30:45,509 --> 00:30:52,169
user for my strength so the simplest

485
00:30:48,179 --> 00:30:56,580
percent s % yes all we specify format

486
00:30:52,169 --> 00:30:58,590
string is party program not most format

487
00:30:56,580 --> 00:31:02,279
strings from their abilities are sold by

488
00:30:58,590 --> 00:31:05,369
specified % SS format string and not

489
00:31:02,279 --> 00:31:07,710
using the data stream as format string a

490
00:31:05,369 --> 00:31:11,220
number of arguments should be the same

491
00:31:07,710 --> 00:31:14,609
as number of format specifiers then in

492
00:31:11,220 --> 00:31:19,129
his F stack protector Aloka and buffers

493
00:31:14,609 --> 00:31:22,168
8 bytes he has an abstract protector all

494
00:31:19,129 --> 00:31:27,299
and then if you use stack protector

495
00:31:22,169 --> 00:31:29,820
options it adds broken are Aloka this

496
00:31:27,299 --> 00:31:32,668
allocation memory on the stack or the

497
00:31:29,820 --> 00:31:35,879
buffer buffer bigger than eight bytes

498
00:31:32,669 --> 00:31:37,679
say protector all as to everyone there

499
00:31:35,879 --> 00:31:41,699
is a new step protector strong there is

500
00:31:37,679 --> 00:31:44,989
a new option appear somewhere else can

501
00:31:41,700 --> 00:31:48,629
be done so that this format guard

502
00:31:44,989 --> 00:31:52,140
automatic protection from from print

503
00:31:48,629 --> 00:31:54,178
formal string vulnerabilities

504
00:31:52,140 --> 00:31:56,460
for the for my strength so that they

505
00:31:54,179 --> 00:31:58,950
would for you at the stager compilation

506
00:31:56,460 --> 00:32:02,370
to show you that something went wrong

507
00:31:58,950 --> 00:32:06,120
and you need to fix it so there are lots

508
00:32:02,370 --> 00:32:09,389
of problems there if you use format

509
00:32:06,120 --> 00:32:15,059
guard someone to sprint and form a guard

510
00:32:09,390 --> 00:32:17,850
will not sit unfortunately

511
00:32:15,059 --> 00:32:21,510
so there are problems to adapt to this

512
00:32:17,850 --> 00:32:24,750
set for all compilers several types of

513
00:32:21,510 --> 00:32:28,470
compilers that you see over elevator Pro

514
00:32:24,750 --> 00:32:34,010
and others and unfortunately yes so this

515
00:32:28,470 --> 00:32:39,240
is not a comprehensive thing then

516
00:32:34,010 --> 00:32:41,280
randomization address randomization just

517
00:32:39,240 --> 00:32:43,040
like the countermeasures used to protect

518
00:32:41,280 --> 00:32:45,570
the gates buffer overflow attacks

519
00:32:43,040 --> 00:32:47,970
address randomization makes it difficult

520
00:32:45,570 --> 00:32:50,520
for the attackers to find out what

521
00:32:47,970 --> 00:32:54,540
address they want to read right it's not

522
00:32:50,520 --> 00:32:57,210
one represent protection it but it

523
00:32:54,540 --> 00:33:00,809
increases the cost of attack but it does

524
00:32:57,210 --> 00:33:03,290
not mitigate it because the attacker can

525
00:33:00,809 --> 00:33:07,620
show can try to figure out the address

526
00:33:03,290 --> 00:33:11,100
so cannot exploit the vulnerability

527
00:33:07,620 --> 00:33:13,020
first time but if if he runs it 100

528
00:33:11,100 --> 00:33:17,360
times this event on their ability will

529
00:33:13,020 --> 00:33:20,820
be exploited and a linux randomizes base

530
00:33:17,360 --> 00:33:23,699
3 3 variables disabled conservative

531
00:33:20,820 --> 00:33:27,530
randomization full randomization and

532
00:33:23,700 --> 00:33:30,799
your search so the compiler with GCC

533
00:33:27,530 --> 00:33:30,799
added to it

534
00:33:31,070 --> 00:33:36,990
fortify source route option which fire

535
00:33:34,710 --> 00:33:40,950
source is a kind of GCC feature

536
00:33:36,990 --> 00:33:44,600
test macro meant sound feature test

537
00:33:40,950 --> 00:33:47,389
macros so then compilation check

538
00:33:44,600 --> 00:33:50,899
in this mode some days you need to add

539
00:33:47,389 --> 00:33:54,519
strength to fortify source to also let's

540
00:33:50,899 --> 00:33:57,620
additional chips at at runtime but it

541
00:33:54,519 --> 00:34:00,049
forces the performance so these are the

542
00:33:57,620 --> 00:34:03,768
mistakes that can come up in case of

543
00:34:00,049 --> 00:34:07,279
using these options so for example that

544
00:34:03,769 --> 00:34:10,579
percent and and in a former strength is

545
00:34:07,279 --> 00:34:13,460
limited to read-only memory not stack on

546
00:34:10,579 --> 00:34:16,970
heap allocated strength and the four can

547
00:34:13,460 --> 00:34:21,800
format string you can look at we cannot

548
00:34:16,969 --> 00:34:23,658
apply to the memory stack only global if

549
00:34:21,800 --> 00:34:29,000
money can be applied on at the global

550
00:34:23,659 --> 00:34:31,460
variables invalid use detected so we

551
00:34:29,000 --> 00:34:34,040
want us to bring in that's the second

552
00:34:31,460 --> 00:34:37,399
parameter we don't know anything about

553
00:34:34,040 --> 00:34:42,409
the first parameter ain't byte and the

554
00:34:37,399 --> 00:34:45,980
same mistake will come up again a good

555
00:34:42,409 --> 00:34:50,619
mitigation is self language yes for the

556
00:34:45,980 --> 00:34:54,319
visual studio special language that

557
00:34:50,619 --> 00:34:56,899
determines tells the compiler what the

558
00:34:54,319 --> 00:34:59,599
function should do the developer tells

559
00:34:56,899 --> 00:35:03,609
the compiler in the compiler does more

560
00:34:59,599 --> 00:35:08,540
assumptions as to how the code works

561
00:35:03,609 --> 00:35:11,328
than preform a string this is you can

562
00:35:08,540 --> 00:35:14,569
define and print form a string and an

563
00:35:11,329 --> 00:35:17,500
external world log era as the tribute

564
00:35:14,569 --> 00:35:19,450
and it's an attribute that tell

565
00:35:17,500 --> 00:35:21,970
they come accompli higher what to do

566
00:35:19,450 --> 00:35:25,060
that tells the compiler what to expect

567
00:35:21,970 --> 00:35:27,819
from this what to expect from this

568
00:35:25,060 --> 00:35:31,810
function with variable types of types of

569
00:35:27,820 --> 00:35:34,540
particles in a format archetype string

570
00:35:31,810 --> 00:35:38,470
index first the check and first the

571
00:35:34,540 --> 00:35:41,980
check this is for the formatted

572
00:35:38,470 --> 00:35:44,230
functions were going to check so this

573
00:35:41,980 --> 00:35:53,020
second the second string and 2nd

574
00:35:44,230 --> 00:35:55,900
position format checks calls to print on

575
00:35:53,020 --> 00:35:58,630
skin etc to make sure that the arguments

576
00:35:55,900 --> 00:36:01,210
supplied have types appropriate to the

577
00:35:58,630 --> 00:36:03,460
format string specified and that the

578
00:36:01,210 --> 00:36:04,570
conversion specified in the format

579
00:36:03,460 --> 00:36:08,320
string makes sense

580
00:36:04,570 --> 00:36:10,750
and so it's formatted and not just set

581
00:36:08,320 --> 00:36:21,430
of variables so that can be controlled

582
00:36:10,750 --> 00:36:24,240
by the attacker some examples during the

583
00:36:21,430 --> 00:36:24,240
compilation

584
00:36:25,170 --> 00:36:31,839
so what warning so would have saw if the

585
00:36:29,020 --> 00:36:33,910
format string is set in parentheses and

586
00:36:31,839 --> 00:36:38,580
if it does not correspond to the

587
00:36:33,910 --> 00:36:42,490
parameters so like some percent has

588
00:36:38,580 --> 00:36:45,460
expects type charge historic and but

589
00:36:42,490 --> 00:36:47,379
argument three has type int so for

590
00:36:45,460 --> 00:36:59,470
packages that aren't already building

591
00:36:47,380 --> 00:37:02,890
with if you format not a string literal

592
00:36:59,470 --> 00:37:04,629
and no format arguments this warning so

593
00:37:02,890 --> 00:37:07,359
sometimes there's a purpose

594
00:37:04,630 --> 00:37:08,980
especially not called legacy code so the

595
00:37:07,360 --> 00:37:11,920
can be disconnected for the help

596
00:37:08,980 --> 00:37:16,960
especially flag which is called no

597
00:37:11,920 --> 00:37:22,530
format security cpp flag be flag if you

598
00:37:16,960 --> 00:37:22,530
if you put it in it won't be introduced

599
00:37:25,110 --> 00:37:31,480
automation calls can further adds the

600
00:37:29,410 --> 00:37:34,600
Iraq auditing tool for security it's

601
00:37:31,480 --> 00:37:38,170
free source code scanner buffalo finder

602
00:37:34,600 --> 00:37:40,990
opus or scanner that examines c c++ the

603
00:37:38,170 --> 00:37:43,570
code analyzer and very cold commercial

604
00:37:40,990 --> 00:37:50,350
code scanner that finds learner

605
00:37:43,570 --> 00:37:56,370
abilities on the c c++ and others if you

606
00:37:50,350 --> 00:38:00,730
are interested to exploit the string

607
00:37:56,370 --> 00:38:03,040
client so then I can refer you to this

608
00:38:00,730 --> 00:38:06,010
book and hacking the art of exploitation

609
00:38:03,040 --> 00:38:08,620
John Erickson I'm sure it tells the

610
00:38:06,010 --> 00:38:12,990
techniques and approaches congratulate

611
00:38:08,620 --> 00:38:16,089
at this point I will finish

612
00:38:12,990 --> 00:38:16,089
[Applause]

613
00:38:16,240 --> 00:38:20,069
thank you any questions

614
00:38:26,140 --> 00:38:32,990
thank you at the beginning you mentioned

615
00:38:28,990 --> 00:38:36,618
that print is vulnerable to such attacks

616
00:38:32,990 --> 00:38:41,750
- but it works along different

617
00:38:36,619 --> 00:38:44,990
principles Patania cheap print real man

618
00:38:41,750 --> 00:38:51,980
it uses the same format strings that's

619
00:38:44,990 --> 00:38:55,220
why it's vulnerable in Python Python or

620
00:38:51,980 --> 00:38:57,710
specifier of the string and you'll send

621
00:38:55,220 --> 00:38:58,640
int but expect int but your send

622
00:38:57,710 --> 00:39:01,550
strength

623
00:38:58,640 --> 00:39:07,609
so I've done it several times and then

624
00:39:01,550 --> 00:39:15,800
it all went as exceptional but we can

625
00:39:07,609 --> 00:39:19,098
change the flow as you see the subject

626
00:39:15,800 --> 00:39:22,160
is my presentation you see like the

627
00:39:19,099 --> 00:39:25,490
Python has a format string as well but

628
00:39:22,160 --> 00:39:27,410
if it's vulnerable a lot I can I can I

629
00:39:25,490 --> 00:39:30,430
can I can talk to you later of the

630
00:39:27,410 --> 00:39:30,430
presentation thank you

631
00:39:36,280 --> 00:39:42,790
thank you for the presentation great

632
00:39:39,670 --> 00:39:42,790
thank you

