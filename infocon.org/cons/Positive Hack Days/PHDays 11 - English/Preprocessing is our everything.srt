1
00:00:11,840 --> 00:00:13,120
and i will be talking about

2
00:00:13,120 --> 00:00:16,119
pre-processing

3
00:00:25,039 --> 00:00:27,359
primarily reverse engineering of various

4
00:00:27,359 --> 00:00:29,840
firmware

5
00:00:32,970 --> 00:00:36,049
[Music]

6
00:00:37,280 --> 00:00:39,600
of automation systems for reverse

7
00:00:39,600 --> 00:00:42,600
engineering

8
00:00:44,000 --> 00:00:45,920
i actually developed a

9
00:00:45,920 --> 00:00:48,320
process or a module for

10
00:00:48,320 --> 00:00:49,120
ida

11
00:00:49,120 --> 00:00:51,600
[Music]

12
00:00:51,600 --> 00:00:55,280
i've got a couple of cvs to my name

13
00:00:55,280 --> 00:00:58,480
particularly for industrial systems

14
00:00:58,480 --> 00:01:01,199
i have a phd in technology

15
00:01:01,199 --> 00:01:03,520
and i'm a lead expert in reverse

16
00:01:03,520 --> 00:01:07,760
engineering at positive technologies

17
00:01:11,360 --> 00:01:13,520
this is the structure of my presentation

18
00:01:13,520 --> 00:01:15,280
today

19
00:01:15,280 --> 00:01:17,200
we'll be talking about procedures and

20
00:01:17,200 --> 00:01:18,159
ways

21
00:01:18,159 --> 00:01:20,320
to

22
00:01:20,320 --> 00:01:22,560
improve them we'll talk about strings

23
00:01:22,560 --> 00:01:25,560
offsets

24
00:01:38,000 --> 00:01:41,200
what is reverse engineering

25
00:01:41,200 --> 00:01:44,960
let me give you this graphic analogy

26
00:01:45,280 --> 00:01:47,280
reverse engineering

27
00:01:47,280 --> 00:01:50,560
is like making a puzzle picture

28
00:01:50,560 --> 00:01:53,880
when you start

29
00:01:56,719 --> 00:01:58,960
it could be an executable file or it

30
00:01:58,960 --> 00:02:02,240
could be a piece of firmware

31
00:02:02,880 --> 00:02:05,840
and yeah trying to put it all together

32
00:02:05,840 --> 00:02:07,759
into the final puzzle

33
00:02:07,759 --> 00:02:09,280
the objectives

34
00:02:09,280 --> 00:02:11,520
for you to do that

35
00:02:11,520 --> 00:02:13,599
doesn't really matter you may be looking

36
00:02:13,599 --> 00:02:16,080
for a vulnerability or you may be trying

37
00:02:16,080 --> 00:02:19,040
to learn more about a given protocol

38
00:02:19,040 --> 00:02:21,520
there are several steps to this process

39
00:02:21,520 --> 00:02:25,840
some of the steps are preparatory

40
00:02:27,440 --> 00:02:29,920
so for example you will be looking for

41
00:02:29,920 --> 00:02:33,040
borderline pieces and you first make the

42
00:02:33,040 --> 00:02:36,720
frame and then you may want to put

43
00:02:36,720 --> 00:02:39,760
remaining puzzle pieces into groups by

44
00:02:39,760 --> 00:02:43,360
color to make the further process easier

45
00:02:43,360 --> 00:02:45,120
and faster and then you start you know

46
00:02:45,120 --> 00:02:48,160
putting it all together

47
00:02:49,360 --> 00:02:51,280
so what is pre-processing

48
00:02:51,280 --> 00:02:52,879
well pre-processing

49
00:02:52,879 --> 00:02:57,599
covers the initial or preparatory stages

50
00:02:57,599 --> 00:02:59,120
when you build a frame

51
00:02:59,120 --> 00:03:01,120
when you separate them by elements by

52
00:03:01,120 --> 00:03:02,840
colors i'm

53
00:03:02,840 --> 00:03:05,440
sorry maybe even the next step can also

54
00:03:05,440 --> 00:03:08,720
be considered pre-processing

55
00:03:10,720 --> 00:03:12,640
or rather the set of scripts i will be

56
00:03:12,640 --> 00:03:16,119
talking about

57
00:03:18,890 --> 00:03:21,970
[Music]

58
00:03:31,280 --> 00:03:33,440
it's just a natural evolution i was

59
00:03:33,440 --> 00:03:34,990
working on some projects

60
00:03:34,990 --> 00:03:37,680
[Music]

61
00:03:37,680 --> 00:03:40,400
and there was something unusual about it

62
00:03:40,400 --> 00:03:42,879
for example you know some strengths or

63
00:03:42,879 --> 00:03:47,399
functions could not be found easily

64
00:03:57,120 --> 00:04:01,840
so since 2014 or so i have been slowly

65
00:04:01,840 --> 00:04:04,159
developing this tool set

66
00:04:04,159 --> 00:04:06,319
without even conceiving of it as a tool

67
00:04:06,319 --> 00:04:07,360
set

68
00:04:07,360 --> 00:04:10,560
i spoke about it at several conferences

69
00:04:10,560 --> 00:04:12,400
listed here and this is like the

70
00:04:12,400 --> 00:04:14,239
pre-processing i'm talking about shown

71
00:04:14,239 --> 00:04:16,720
right here

72
00:04:21,040 --> 00:04:23,840
now let's briefly touch upon the issues

73
00:04:23,840 --> 00:04:25,759
you will be facing

74
00:04:25,759 --> 00:04:29,280
if you are a reverse engineer so if this

75
00:04:29,280 --> 00:04:31,120
is your first experience of reverse

76
00:04:31,120 --> 00:04:33,360
engineering and you want to have fun

77
00:04:33,360 --> 00:04:35,840
with a router firmware or some iot

78
00:04:35,840 --> 00:04:38,400
devices

79
00:04:38,639 --> 00:04:43,639
can i easily run into the following

80
00:04:49,759 --> 00:04:52,639
or options you can run into

81
00:04:52,639 --> 00:04:54,960
i've listed them here in the order of

82
00:04:54,960 --> 00:04:57,600
decreasing popularity and increasing

83
00:04:57,600 --> 00:05:00,320
complexity

84
00:05:01,580 --> 00:05:04,800
[Music]

85
00:05:04,800 --> 00:05:09,280
so x86 binaries have really been studied

86
00:05:09,280 --> 00:05:12,479
a lot by reverse engineers

87
00:05:12,479 --> 00:05:14,400
and then you see in descending order in

88
00:05:14,400 --> 00:05:18,160
order of like descending popularity

89
00:05:18,160 --> 00:05:20,320
lots of other options and there's even a

90
00:05:20,320 --> 00:05:22,639
huge section called other which covers

91
00:05:22,639 --> 00:05:25,639
like

92
00:05:49,520 --> 00:05:50,960
operating systems

93
00:05:50,960 --> 00:05:54,160
windows and linux will naturally be in

94
00:05:54,160 --> 00:05:55,199
the leads

95
00:05:55,199 --> 00:05:58,479
you will often see amazon as well

96
00:05:58,479 --> 00:06:00,960
some embedded operating systems and no

97
00:06:00,960 --> 00:06:02,639
operating systems

98
00:06:02,639 --> 00:06:03,919
instrument

99
00:06:03,919 --> 00:06:06,799
disassembly

100
00:06:18,880 --> 00:06:20,960
you know given the popularity of these

101
00:06:20,960 --> 00:06:23,520
options it is best

102
00:06:23,520 --> 00:06:26,160
seated to work with the top lines in

103
00:06:26,160 --> 00:06:27,520
every category

104
00:06:27,520 --> 00:06:28,880
which means that you know it doesn't

105
00:06:28,880 --> 00:06:30,720
really fit well

106
00:06:30,720 --> 00:06:35,039
the things you see in the bottom however

107
00:06:35,039 --> 00:06:36,960
people from my department

108
00:06:36,960 --> 00:06:39,120
and the clients who invite us to play

109
00:06:39,120 --> 00:06:42,960
say with their industrial plc's

110
00:06:43,199 --> 00:06:45,759
very often want to work on things that

111
00:06:45,759 --> 00:06:48,400
you know don't have an operating system

112
00:06:48,400 --> 00:06:50,880
you know that will have a cpu which is

113
00:06:50,880 --> 00:06:52,400
like the first time you see it in the

114
00:06:52,400 --> 00:06:53,520
world

115
00:06:53,520 --> 00:06:55,599
no real format

116
00:06:55,599 --> 00:06:58,319
pre-processing is effectively maintained

117
00:06:58,319 --> 00:07:01,440
inside id so the first time you upload a

118
00:07:01,440 --> 00:07:04,080
binary file into ide

119
00:07:04,080 --> 00:07:06,319
id will be quite good at doing something

120
00:07:06,319 --> 00:07:08,639
about it at least you know it will be

121
00:07:08,639 --> 00:07:11,199
able to tease apart you know the shifts

122
00:07:11,199 --> 00:07:14,319
so the offsets strings and codes it will

123
00:07:14,319 --> 00:07:16,479
upload this structure

124
00:07:16,479 --> 00:07:19,599
if the format is well known

125
00:07:19,599 --> 00:07:21,280
what is it based on

126
00:07:21,280 --> 00:07:23,440
processor

127
00:07:23,440 --> 00:07:26,479
it is based on a processor module or a

128
00:07:26,479 --> 00:07:29,280
cpu module i'm sorry this slide is a bit

129
00:07:29,280 --> 00:07:30,400
outdated

130
00:07:30,400 --> 00:07:35,039
so in this module there are two elements

131
00:07:36,720 --> 00:07:39,440
somehow my laser pointer isn't oh it is

132
00:07:39,440 --> 00:07:41,440
it actually is pointing i hope you can

133
00:07:41,440 --> 00:07:44,400
see it no you can't sorry about that

134
00:07:44,400 --> 00:07:46,980
i will be pointing the old-school way

135
00:07:46,980 --> 00:07:50,029
[Music]

136
00:07:50,319 --> 00:07:53,039
so this part will decode instructions

137
00:07:53,039 --> 00:07:56,560
and the other one will be emulating what

138
00:07:56,560 --> 00:07:59,360
they do you know it will look at you

139
00:07:59,360 --> 00:08:01,360
know the kind of pointers they have at

140
00:08:01,360 --> 00:08:02,400
each other

141
00:08:02,400 --> 00:08:04,879
like the kind of codes each function

142
00:08:04,879 --> 00:08:08,479
will invoke and inside isaia

143
00:08:08,479 --> 00:08:10,879
on top of all these cpu modules there

144
00:08:10,879 --> 00:08:13,199
will be a component

145
00:08:13,199 --> 00:08:16,720
that can be found in the menu over here

146
00:08:16,720 --> 00:08:18,000
you have to say if you press the button

147
00:08:18,000 --> 00:08:21,440
called reanalyze program

148
00:08:23,440 --> 00:08:25,759
it will follow a particular logic to

149
00:08:25,759 --> 00:08:29,360
compile procedures out of these commands

150
00:08:29,360 --> 00:08:31,199
it's actually an extremely dangerous

151
00:08:31,199 --> 00:08:33,520
button

152
00:08:34,958 --> 00:08:37,039
so you may be you know reverse

153
00:08:37,039 --> 00:08:39,440
engineering and studying something and

154
00:08:39,440 --> 00:08:41,120
correcting and then you press this

155
00:08:41,120 --> 00:08:42,719
button

156
00:08:42,719 --> 00:08:44,880
and you know it will overwrite all your

157
00:08:44,880 --> 00:08:48,399
improvements and all your edits

158
00:08:51,519 --> 00:08:52,839
after weight

159
00:08:52,839 --> 00:08:54,399
eliminate

160
00:08:54,399 --> 00:08:57,920
so we're looking here at weight and auto

161
00:08:57,920 --> 00:08:59,920
weight functions if you invoke them

162
00:08:59,920 --> 00:09:02,000
throughout a python

163
00:09:02,000 --> 00:09:06,240
now as regards differences in versions

164
00:09:06,240 --> 00:09:08,560
from experience that

165
00:09:08,560 --> 00:09:11,120
versions six and seven don't really

166
00:09:11,120 --> 00:09:13,040
differ in terms of ulti analysis i mean

167
00:09:13,040 --> 00:09:15,200
the difference is marginal

168
00:09:15,200 --> 00:09:18,399
and it is mostly related to the top

169
00:09:18,399 --> 00:09:21,519
lines in my classification i'm talking

170
00:09:21,519 --> 00:09:25,760
about architectures like arm and x86

171
00:09:25,760 --> 00:09:27,440
so for them

172
00:09:27,440 --> 00:09:31,120
id 7 mino is slightly better at finding

173
00:09:31,120 --> 00:09:33,920
procedures and finds more of them

174
00:09:33,920 --> 00:09:37,839
but it's emotional improvement really

175
00:09:41,680 --> 00:09:45,120
was in its embryo stage id 6 was only

176
00:09:45,120 --> 00:09:46,240
available

177
00:09:46,240 --> 00:09:48,720
when id 7 hit the market

178
00:09:48,720 --> 00:09:51,720
smoke

179
00:09:58,000 --> 00:10:00,560
you know he effectively enabled me to

180
00:10:00,560 --> 00:10:02,399
see if their pre-processing was

181
00:10:02,399 --> 00:10:03,440
different

182
00:10:03,440 --> 00:10:05,760
and since the difference was marginal i

183
00:10:05,760 --> 00:10:09,920
decided you know to stick to version six

184
00:10:10,160 --> 00:10:12,240
well actually you know you can

185
00:10:12,240 --> 00:10:15,200
do whatever you want to do in ide and

186
00:10:15,200 --> 00:10:18,880
you know then upload it to idea

187
00:10:29,680 --> 00:10:32,920
i'm sorry

188
00:10:44,959 --> 00:10:49,040
codes procedures strings and offsets

189
00:10:50,720 --> 00:10:53,680
there is another function here

190
00:10:53,680 --> 00:10:55,279
something that has been

191
00:10:55,279 --> 00:10:58,320
really very useful

192
00:11:11,279 --> 00:11:15,839
is true for a switch jump table

193
00:11:27,040 --> 00:11:29,920
address space

194
00:11:29,920 --> 00:11:32,240
so firmware has

195
00:11:32,240 --> 00:11:34,560
been already loaded but addresses are

196
00:11:34,560 --> 00:11:36,720
still beyond this reach so to speak and

197
00:11:36,720 --> 00:11:39,200
ida will not

198
00:11:39,200 --> 00:11:41,040
understand it

199
00:11:41,040 --> 00:11:42,720
i mean the segment where your code says

200
00:11:42,720 --> 00:11:45,839
has its boundaries and these shifts

201
00:11:45,839 --> 00:11:49,279
may be flagged as it does

202
00:11:50,399 --> 00:11:55,020
where can it be used and where was it

203
00:11:55,020 --> 00:11:58,090
[Music]

204
00:11:58,160 --> 00:12:01,519
i particularly care about analysis

205
00:12:01,519 --> 00:12:04,320
d in reconstruction of protocols

206
00:12:04,320 --> 00:12:06,639
well right now we have standoff running

207
00:12:06,639 --> 00:12:08,880
and at the standoff you'll find lots of

208
00:12:08,880 --> 00:12:10,480
plcs

209
00:12:10,480 --> 00:12:12,720
so i personally you know took these

210
00:12:12,720 --> 00:12:15,120
plc's apart and started them just like

211
00:12:15,120 --> 00:12:16,880
my colleagues did

212
00:12:16,880 --> 00:12:19,440
it can also be used for vulnerability

213
00:12:19,440 --> 00:12:21,839
funding

214
00:12:22,240 --> 00:12:24,720
pre-processing certainly helps a lot now

215
00:12:24,720 --> 00:12:27,279
if you want to analyze patches

216
00:12:27,279 --> 00:12:30,000
again it's very useful for us to know

217
00:12:30,000 --> 00:12:32,000
the procedures in both versions of the

218
00:12:32,000 --> 00:12:33,360
software

219
00:12:33,360 --> 00:12:35,600
in order to be able to compare them in a

220
00:12:35,600 --> 00:12:38,079
sensible way

221
00:12:38,079 --> 00:12:40,639
if for example we have developed you

222
00:12:40,639 --> 00:12:42,720
know our own

223
00:12:42,720 --> 00:12:45,200
improvements to a piece of software and

224
00:12:45,200 --> 00:12:47,360
then an update or a patch gets released

225
00:12:47,360 --> 00:12:49,200
well we want to make sure that you know

226
00:12:49,200 --> 00:12:52,680
with a new batch

227
00:12:56,240 --> 00:12:59,340
[Music]

228
00:13:06,160 --> 00:13:07,519
sometimes you know you may want to

229
00:13:07,519 --> 00:13:09,920
repatch a given system so that it does

230
00:13:09,920 --> 00:13:12,480
something that the initial developer

231
00:13:12,480 --> 00:13:15,519
didn't envisage

232
00:13:17,040 --> 00:13:20,279
no procedures

233
00:13:32,399 --> 00:13:35,680
and procedures are very much like this

234
00:13:35,680 --> 00:13:38,399
boundary puzzle basis because once

235
00:13:38,399 --> 00:13:40,000
you've analyzed the procedures you will

236
00:13:40,000 --> 00:13:41,760
be able to see where the code is where

237
00:13:41,760 --> 00:13:43,199
the deity is

238
00:13:43,199 --> 00:13:45,199
you know what kind of address points

239
00:13:45,199 --> 00:13:48,599
which you have

240
00:14:00,320 --> 00:14:03,320
six

241
00:14:05,440 --> 00:14:07,360
we are looking at a file that doesn't

242
00:14:07,360 --> 00:14:11,920
have format like it's rule data firmware

243
00:14:14,320 --> 00:14:17,199
it's a well-known architecture

244
00:14:17,199 --> 00:14:19,440
but some elements have not been marked

245
00:14:19,440 --> 00:14:21,519
have not been flagged as procedures by

246
00:14:21,519 --> 00:14:23,920
idea

247
00:14:23,920 --> 00:14:25,040
so here

248
00:14:25,040 --> 00:14:26,320
in

249
00:14:26,320 --> 00:14:28,320
the street there you will actually see

250
00:14:28,320 --> 00:14:31,839
the location of different elements

251
00:14:34,000 --> 00:14:37,120
you will be surprised potentially to see

252
00:14:37,120 --> 00:14:40,000
that this uh you know decoding

253
00:14:40,000 --> 00:14:42,399
is out of back with reality

254
00:14:42,399 --> 00:14:45,120
so blue shows it is data well in fact

255
00:14:45,120 --> 00:14:47,279
it's code so please don't trust it too

256
00:14:47,279 --> 00:14:49,519
much

257
00:14:52,480 --> 00:14:54,720
so you see an arrow pointing here and

258
00:14:54,720 --> 00:14:56,800
this is the code

259
00:14:56,800 --> 00:14:59,120
it looks like the start of a procedure

260
00:14:59,120 --> 00:15:02,160
but ida did not flag it as a procedure

261
00:15:02,160 --> 00:15:04,720
and you can have hundreds or even

262
00:15:04,720 --> 00:15:07,360
thousands of procedures like this

263
00:15:07,360 --> 00:15:09,839
actually it would be best to have them

264
00:15:09,839 --> 00:15:10,839
shown as

265
00:15:10,839 --> 00:15:12,800
procedures because otherwise we'll have

266
00:15:12,800 --> 00:15:15,680
to look for them manually

267
00:15:18,160 --> 00:15:21,519
so after i run one of my scripts

268
00:15:21,519 --> 00:15:24,399
i guess something like this

269
00:15:24,639 --> 00:15:26,560
here all the procedures have been

270
00:15:26,560 --> 00:15:28,320
identified

271
00:15:28,320 --> 00:15:31,600
and properly flagged

272
00:15:32,720 --> 00:15:33,960
let me give you another one

273
00:15:33,960 --> 00:15:37,109
[Music]

274
00:15:37,759 --> 00:15:38,839
this

275
00:15:38,839 --> 00:15:43,440
is more exotic cpu and here we see just

276
00:15:43,440 --> 00:15:47,279
you know a string of bytes

277
00:15:48,079 --> 00:15:51,439
not a single procedure

278
00:15:51,600 --> 00:15:54,720
again you know doing it manually may be

279
00:15:54,720 --> 00:15:56,880
quite challenging

280
00:15:56,880 --> 00:16:00,079
so i run my script

281
00:16:00,959 --> 00:16:03,519
and it shows the whole code section with

282
00:16:03,519 --> 00:16:06,320
all the procedures marked

283
00:16:06,320 --> 00:16:08,959
marginal bullet

284
00:16:20,839 --> 00:16:23,600
disassembler will find entry points to

285
00:16:23,600 --> 00:16:25,279
procedures you know it will parse the

286
00:16:25,279 --> 00:16:26,560
whole code

287
00:16:26,560 --> 00:16:28,000
checking you know

288
00:16:28,000 --> 00:16:30,480
which addresses individual procedures

289
00:16:30,480 --> 00:16:32,720
are pointing to and looks for all the

290
00:16:32,720 --> 00:16:36,000
exit points looks for loops

291
00:16:36,000 --> 00:16:38,800
and cycles and it also looks for switch

292
00:16:38,800 --> 00:16:41,040
commands

293
00:16:41,040 --> 00:16:45,040
on this basis you know it will

294
00:16:45,040 --> 00:16:46,480
demarcate

295
00:16:46,480 --> 00:16:50,279
delaney procedures

296
00:16:50,800 --> 00:16:53,440
interestingly this intelligent approach

297
00:16:53,440 --> 00:16:55,360
proved to be as reliable as it is for

298
00:16:55,360 --> 00:16:58,000
idea i mean sometimes it worked and at

299
00:16:58,000 --> 00:17:00,480
other times

300
00:17:02,720 --> 00:17:06,480
now the other approach

301
00:17:06,559 --> 00:17:08,480
is effectively brute force one where you

302
00:17:08,480 --> 00:17:11,439
mark everything up as procedure

303
00:17:11,439 --> 00:17:14,319
yes or as code and then you try tracing

304
00:17:14,319 --> 00:17:16,000
every string as procedure and you see if

305
00:17:16,000 --> 00:17:19,559
it works or it doesn't

306
00:17:32,240 --> 00:17:34,160
i chose an algorithm which is in fact a

307
00:17:34,160 --> 00:17:36,400
combination of the two

308
00:17:36,400 --> 00:17:40,240
so this part comes from id disassembly

309
00:17:40,240 --> 00:17:42,320
and this stuff

310
00:17:42,320 --> 00:17:47,080
myself with a script what do you say

311
00:17:59,440 --> 00:18:02,240
i look for ranges

312
00:18:06,640 --> 00:18:09,440
areas where code can be found but it's

313
00:18:09,440 --> 00:18:12,400
not marked up as procedures

314
00:18:12,400 --> 00:18:15,600
areas with data and undefined areas i

315
00:18:15,600 --> 00:18:17,360
mean we have bytes there but they've not

316
00:18:17,360 --> 00:18:19,760
been classified as code or data

317
00:18:19,760 --> 00:18:22,000
can we try transforming it into

318
00:18:22,000 --> 00:18:24,240
procedures

319
00:18:24,240 --> 00:18:28,760
now we give this information to ideas

320
00:18:28,799 --> 00:18:30,799
so that on the basis of this uh

321
00:18:30,799 --> 00:18:33,280
initially identified procedures

322
00:18:33,280 --> 00:18:36,960
it can look for more yes

323
00:18:37,200 --> 00:18:40,240
if that is not enough

324
00:18:52,000 --> 00:18:55,200
he has proved to be quite

325
00:18:55,440 --> 00:18:58,240
as efficient samples here show

326
00:18:58,240 --> 00:19:00,000
and again you know the bars suggest that

327
00:19:00,000 --> 00:19:01,280
everything has been properly

328
00:19:01,280 --> 00:19:04,240
demonstrated

329
00:19:09,120 --> 00:19:12,000
demonstration may be difficult

330
00:19:12,000 --> 00:19:14,640
so rather than having you know

331
00:19:14,640 --> 00:19:17,120
demos in uh short chunks i will show it

332
00:19:17,120 --> 00:19:19,039
in a single go at the end of my

333
00:19:19,039 --> 00:19:21,360
presentation

334
00:19:21,360 --> 00:19:23,280
yes

335
00:19:23,280 --> 00:19:25,679
so such a brute forcing approach

336
00:19:25,679 --> 00:19:29,679
has its disadvantages for example

337
00:19:29,679 --> 00:19:31,520
it will suggest

338
00:19:31,520 --> 00:19:34,080
loads of procedures

339
00:19:34,080 --> 00:19:36,160
tons of procedures

340
00:19:36,160 --> 00:19:39,200
which when properly analyzed

341
00:19:39,200 --> 00:19:41,039
will prove to be

342
00:19:41,039 --> 00:19:42,960
lousy

343
00:19:42,960 --> 00:19:45,600
bad procedures

344
00:19:45,600 --> 00:19:47,360
you know they are just sequences of

345
00:19:47,360 --> 00:19:48,320
bytes

346
00:19:48,320 --> 00:19:49,280
which

347
00:19:49,280 --> 00:19:53,039
you know happen to be like commands

348
00:19:53,039 --> 00:19:55,120
and you know they will be terminated you

349
00:19:55,120 --> 00:19:58,320
know with the exit

350
00:19:58,320 --> 00:20:00,720
exit points you know this is the problem

351
00:20:00,720 --> 00:20:03,679
with lots of vendors

352
00:20:04,080 --> 00:20:08,399
their code may often look like commands

353
00:20:09,760 --> 00:20:11,360
we should probably talk here about the

354
00:20:11,360 --> 00:20:13,679
usual structure

355
00:20:13,679 --> 00:20:16,400
of procedures

356
00:20:16,480 --> 00:20:17,440
in the most

357
00:20:17,440 --> 00:20:19,120
simple case

358
00:20:19,120 --> 00:20:22,000
we have an entry point in a procedure

359
00:20:22,000 --> 00:20:24,880
and they can be you know a call out or

360
00:20:24,880 --> 00:20:26,720
jump or a shift

361
00:20:26,720 --> 00:20:28,559
you know if it's an object method for

362
00:20:28,559 --> 00:20:30,960
example

363
00:20:33,840 --> 00:20:36,000
you will find well either the usual

364
00:20:36,000 --> 00:20:37,760
execution flow

365
00:20:37,760 --> 00:20:39,760
first switch and finally naturally there

366
00:20:39,760 --> 00:20:42,559
is an exit point

367
00:20:44,320 --> 00:20:46,880
in a more complex example

368
00:20:46,880 --> 00:20:50,559
you may have here for example

369
00:20:51,039 --> 00:20:52,559
another procedure

370
00:20:52,559 --> 00:20:55,520
and the exit points may differ from the

371
00:20:55,520 --> 00:20:57,679
physical boundaries of the procedure so

372
00:20:57,679 --> 00:20:59,440
there may be another exit here for

373
00:20:59,440 --> 00:21:00,480
example

374
00:21:00,480 --> 00:21:02,799
there may be jumps as well and there can

375
00:21:02,799 --> 00:21:06,000
be some local labels here and in the

376
00:21:06,000 --> 00:21:08,720
center again we are showing the regular

377
00:21:08,720 --> 00:21:11,760
execution flow

378
00:21:17,200 --> 00:21:20,400
so as a result of this

379
00:21:20,400 --> 00:21:22,000
multi-annual

380
00:21:22,000 --> 00:21:25,679
unintended piece of research

381
00:21:25,679 --> 00:21:28,320
i was able to identify various types of

382
00:21:28,320 --> 00:21:30,480
anomalous procedures

383
00:21:30,480 --> 00:21:33,919
in so many different projects

384
00:21:37,600 --> 00:21:40,000
i found them with my scripts

385
00:21:40,000 --> 00:21:41,120
and some of them

386
00:21:41,120 --> 00:21:42,640
[Music]

387
00:21:42,640 --> 00:21:46,000
were identified by ide you know the auto

388
00:21:46,000 --> 00:21:49,120
analysis component of ida

389
00:21:49,120 --> 00:21:51,120
actually produced a bunch of these bad

390
00:21:51,120 --> 00:21:53,678
procedures

391
00:21:55,520 --> 00:21:57,360
some of the simple examples here is when

392
00:21:57,360 --> 00:21:59,679
you have a call out or a jump to

393
00:21:59,679 --> 00:22:01,760
something other than the start of a

394
00:22:01,760 --> 00:22:04,000
procedure

395
00:22:04,000 --> 00:22:06,559
there are very rare procedures that are

396
00:22:06,559 --> 00:22:07,760
okay

397
00:22:07,760 --> 00:22:09,919
when they're like that for example some

398
00:22:09,919 --> 00:22:11,200
compilers

399
00:22:11,200 --> 00:22:13,679
may actually produce a you know a

400
00:22:13,679 --> 00:22:16,000
procedure that will start in normal way

401
00:22:16,000 --> 00:22:18,240
and that will jump into the middle of

402
00:22:18,240 --> 00:22:20,480
another procedure

403
00:22:20,480 --> 00:22:21,919
you know that procedure might actually

404
00:22:21,919 --> 00:22:23,200
do the same

405
00:22:23,200 --> 00:22:25,360
and sort of return you back to procedure

406
00:22:25,360 --> 00:22:29,439
one but that is rarely the case

407
00:22:38,000 --> 00:22:40,640
a call from this procedure

408
00:22:40,640 --> 00:22:42,640
may i the point that something that's

409
00:22:42,640 --> 00:22:45,280
not code

410
00:22:45,280 --> 00:22:50,158
which obviously would be a bad procedure

411
00:22:51,120 --> 00:22:53,520
it can be pointing at the middle of a

412
00:22:53,520 --> 00:22:55,280
command rather than the start of a

413
00:22:55,280 --> 00:22:58,000
command which for firmware

414
00:22:58,000 --> 00:23:01,200
is pretty much impossible

415
00:23:01,520 --> 00:23:03,840
i mean it could be okay for some

416
00:23:03,840 --> 00:23:06,559
obfuscated viral codes

417
00:23:06,559 --> 00:23:07,679
but even

418
00:23:07,679 --> 00:23:11,200
there you know it would be rare

419
00:23:11,200 --> 00:23:13,200
you know this is the kind of uh

420
00:23:13,200 --> 00:23:14,400
stuff

421
00:23:14,400 --> 00:23:16,880
you could expect to find back in those

422
00:23:16,880 --> 00:23:21,240
times you know code with ships

423
00:23:29,440 --> 00:23:31,679
by the way it may actually be pretty

424
00:23:31,679 --> 00:23:33,760
diff i'm sorry pretty

425
00:23:33,760 --> 00:23:35,039
weird

426
00:23:35,039 --> 00:23:37,919
if we find the execution flow from the

427
00:23:37,919 --> 00:23:40,400
previous procedure at the beginning of a

428
00:23:40,400 --> 00:23:43,200
new procedure that's really

429
00:23:43,200 --> 00:23:45,679
unusual

430
00:23:45,679 --> 00:23:48,840
if we see the execution flow

431
00:23:48,840 --> 00:23:52,159
continue although the procedure seems to

432
00:23:52,159 --> 00:23:54,320
end

433
00:23:56,320 --> 00:23:58,080
pretty much the same situation isn't it

434
00:23:58,080 --> 00:24:00,879
depending i mean

435
00:24:01,440 --> 00:24:03,120
from the viewpoint of which procedure

436
00:24:03,120 --> 00:24:05,678
you're looking at

437
00:24:06,240 --> 00:24:08,159
also it's pretty

438
00:24:08,159 --> 00:24:10,080
weird to find something that's not a

439
00:24:10,080 --> 00:24:13,039
command in the middle of a procedure

440
00:24:13,039 --> 00:24:15,440
two more cases

441
00:24:15,440 --> 00:24:17,200
lousy procedures

442
00:24:17,200 --> 00:24:22,000
one is a jump to start of a procedure

443
00:24:23,440 --> 00:24:26,400
and read write or shift

444
00:24:26,400 --> 00:24:29,120
inside it

445
00:24:29,279 --> 00:24:32,919
again that's unusual

446
00:24:42,159 --> 00:24:44,880
so when inside a procedure you find

447
00:24:44,880 --> 00:24:46,720
blocks of code

448
00:24:46,720 --> 00:24:49,279
which seem to be totally dead you know

449
00:24:49,279 --> 00:24:51,360
sometimes you know developers keep it

450
00:24:51,360 --> 00:24:53,440
there you know as that code and then it

451
00:24:53,440 --> 00:24:55,760
gets compiled and it starts there stays

452
00:24:55,760 --> 00:24:57,679
there like dead wood

453
00:24:57,679 --> 00:24:59,760
so it can be an anomaly

454
00:24:59,760 --> 00:25:02,159
or it can be a sign of improper

455
00:25:02,159 --> 00:25:04,720
calculation

456
00:25:06,720 --> 00:25:09,440
it's pretty easy now to identify all

457
00:25:09,440 --> 00:25:11,679
this stuff with the scripts it wasn't

458
00:25:11,679 --> 00:25:12,880
the case

459
00:25:12,880 --> 00:25:15,840
80 years ago though

460
00:25:17,200 --> 00:25:19,440
so then you know you can actually

461
00:25:19,440 --> 00:25:23,120
improve those procedures

462
00:25:26,480 --> 00:25:28,400
that actually takes care of most of

463
00:25:28,400 --> 00:25:30,480
these bad procedures is number one on

464
00:25:30,480 --> 00:25:32,880
the list

465
00:25:33,200 --> 00:25:35,200
so you may remember i previously talked

466
00:25:35,200 --> 00:25:38,159
about cyclic procedures

467
00:25:38,159 --> 00:25:41,640
this was this

468
00:25:42,000 --> 00:25:45,279
here we're trying to find him

469
00:25:45,279 --> 00:25:48,080
using ranges

470
00:25:51,200 --> 00:25:54,000
if at this

471
00:25:55,520 --> 00:25:57,760
we stage everything that idea has not

472
00:25:57,760 --> 00:26:00,000
transformed into procedures and we just

473
00:26:00,000 --> 00:26:03,440
you know remove this chunks of code

474
00:26:03,440 --> 00:26:06,559
most of this anomalous will go away

475
00:26:06,559 --> 00:26:09,279
because you know this dangling pieces of

476
00:26:09,279 --> 00:26:12,480
code could easily produce this anomalous

477
00:26:12,480 --> 00:26:14,799
you know for some cases we can merge

478
00:26:14,799 --> 00:26:17,760
procedures or split them

479
00:26:17,760 --> 00:26:21,679
we can change the beginning or the end

480
00:26:21,679 --> 00:26:25,120
we can try making codes from non-codes

481
00:26:25,120 --> 00:26:27,200
pieces or places

482
00:26:27,200 --> 00:26:29,360
or we can just you know delete procedure

483
00:26:29,360 --> 00:26:31,918
and code

484
00:26:37,039 --> 00:26:39,520
i'm not providing here a mapping to you

485
00:26:39,520 --> 00:26:40,240
know

486
00:26:40,240 --> 00:26:42,559
which technique is best for which kind

487
00:26:42,559 --> 00:26:44,640
of case but you know it's all maintained

488
00:26:44,640 --> 00:26:47,039
in the scripts which i think are quite

489
00:26:47,039 --> 00:26:48,240
effective

490
00:26:48,240 --> 00:26:51,440
let's talk strings now

491
00:26:59,039 --> 00:27:00,880
in reverse engineering so they can

492
00:27:00,880 --> 00:27:03,279
provide us with text commands for

493
00:27:03,279 --> 00:27:05,520
example they can also provide us with a

494
00:27:05,520 --> 00:27:06,799
lots of

495
00:27:06,799 --> 00:27:09,200
additional information such as debug

496
00:27:09,200 --> 00:27:12,720
messages error messages maybe file names

497
00:27:12,720 --> 00:27:16,159
or operating system commands

498
00:27:17,120 --> 00:27:21,080
we're in procedure names

499
00:27:23,279 --> 00:27:25,440
it's pretty rare to find them

500
00:27:25,440 --> 00:27:26,960
in the firmware

501
00:27:26,960 --> 00:27:29,039
you know sometimes in firmware you

502
00:27:29,039 --> 00:27:33,480
cannot find a single text string

503
00:27:42,240 --> 00:27:44,399
the same file i previously showed as an

504
00:27:44,399 --> 00:27:46,559
example of x86

505
00:27:46,559 --> 00:27:49,559
yesterday

506
00:27:55,440 --> 00:27:58,080
strings window so here it shows all

507
00:27:58,080 --> 00:28:00,240
string candidates

508
00:28:00,240 --> 00:28:02,799
so for example we have uh

509
00:28:02,799 --> 00:28:04,640
highlights it's two strings

510
00:28:04,640 --> 00:28:07,440
and they are like this

511
00:28:10,240 --> 00:28:12,559
so we can actually see where they are

512
00:28:12,559 --> 00:28:14,640
pointing and what's pointing at them

513
00:28:14,640 --> 00:28:17,039
if we

514
00:28:22,720 --> 00:28:23,840
internally

515
00:28:23,840 --> 00:28:26,159
but interestingly the string here is not

516
00:28:26,159 --> 00:28:27,520
highlighted

517
00:28:27,520 --> 00:28:30,240
so far it's just you know it as a

518
00:28:30,240 --> 00:28:31,679
sequence of bytes

519
00:28:31,679 --> 00:28:32,720
well

520
00:28:32,720 --> 00:28:36,640
we'll we will you know correct that

521
00:28:37,520 --> 00:28:41,039
this second candidate here

522
00:28:41,200 --> 00:28:44,200
is

523
00:28:46,159 --> 00:28:48,480
so the sequence of the bytes here is uh

524
00:28:48,480 --> 00:28:51,919
z tab tm and so on

525
00:28:51,919 --> 00:28:55,279
so if we try transforming it you know it

526
00:28:55,279 --> 00:28:58,320
will do that we'll add something at the

527
00:28:58,320 --> 00:28:59,919
end but you know

528
00:28:59,919 --> 00:29:02,080
zero there is missing

529
00:29:02,080 --> 00:29:04,399
it's logical to have zeros at the end of

530
00:29:04,399 --> 00:29:06,480
the string right

531
00:29:06,480 --> 00:29:07,919
and we could have actually told the

532
00:29:07,919 --> 00:29:10,840
algorithm that if there is a zero at the

533
00:29:10,840 --> 00:29:13,520
end how about he actually treat it as a

534
00:29:13,520 --> 00:29:16,000
string somehow you know idea doesn't

535
00:29:16,000 --> 00:29:18,640
know about that

536
00:29:24,000 --> 00:29:25,679
there have been some you know rare

537
00:29:25,679 --> 00:29:26,960
projects

538
00:29:26,960 --> 00:29:28,799
where there were not just strings but

539
00:29:28,799 --> 00:29:31,600
lots of strings like dozens of thousands

540
00:29:31,600 --> 00:29:32,960
of strings

541
00:29:32,960 --> 00:29:36,720
and i naturally wanted to automate and

542
00:29:36,720 --> 00:29:41,720
expedite the process of analyzing them

543
00:29:47,760 --> 00:29:50,320
distinguish strings well naturally the

544
00:29:50,320 --> 00:29:52,840
string should contain some printable

545
00:29:52,840 --> 00:29:55,279
symbols often you would expect some

546
00:29:55,279 --> 00:29:57,679
natural language words at least in some

547
00:29:57,679 --> 00:29:59,840
of the strings

548
00:29:59,840 --> 00:30:02,399
and again they should have

549
00:30:02,399 --> 00:30:05,200
something special about their size

550
00:30:05,200 --> 00:30:07,440
besides before string they can end in

551
00:30:07,440 --> 00:30:09,440
zeros

552
00:30:09,440 --> 00:30:11,520
where maybe all the strings would be the

553
00:30:11,520 --> 00:30:14,720
same in terms of size they may not be

554
00:30:14,720 --> 00:30:16,320
zero terminated

555
00:30:16,320 --> 00:30:20,439
so they will have the same size

556
00:30:23,120 --> 00:30:25,360
so here i'm going at length explaining

557
00:30:25,360 --> 00:30:27,200
how this

558
00:30:27,200 --> 00:30:29,440
techniques work so for example we're

559
00:30:29,440 --> 00:30:31,520
looking at

560
00:30:31,520 --> 00:30:33,440
presence of printable symbols this is

561
00:30:33,440 --> 00:30:35,600
actually how ide does it

562
00:30:35,600 --> 00:30:37,520
if the simplest printable

563
00:30:37,520 --> 00:30:39,440
we should be interested and we're also

564
00:30:39,440 --> 00:30:41,520
looking for a sequences of principle

565
00:30:41,520 --> 00:30:43,679
symbols that contain at least three of

566
00:30:43,679 --> 00:30:45,840
them

567
00:30:48,480 --> 00:30:50,000
and then we should be able to put them

568
00:30:50,000 --> 00:30:52,080
into strings

569
00:30:52,080 --> 00:30:55,199
then with these strings

570
00:30:55,840 --> 00:30:57,519
you may want to check if they're real

571
00:30:57,519 --> 00:30:59,600
strings or just you know a sequence of

572
00:30:59,600 --> 00:31:03,080
printable symbols

573
00:31:07,039 --> 00:31:09,039
a component was chosen which is often

574
00:31:09,039 --> 00:31:11,600
used for spell checking

575
00:31:11,600 --> 00:31:14,799
you know in various text editors

576
00:31:14,799 --> 00:31:16,640
by enchantment

577
00:31:16,640 --> 00:31:19,039
it's called

578
00:31:22,399 --> 00:31:24,320
so this is the one that's often used for

579
00:31:24,320 --> 00:31:26,720
spell checking

580
00:31:26,720 --> 00:31:28,960
it will either tell you

581
00:31:28,960 --> 00:31:30,799
that you know the spelling is correct or

582
00:31:30,799 --> 00:31:33,279
not

583
00:31:33,279 --> 00:31:35,279
actually quite good at even suggesting

584
00:31:35,279 --> 00:31:37,200
if the word is spelled correctly even if

585
00:31:37,200 --> 00:31:38,799
it doesn't have this word in this

586
00:31:38,799 --> 00:31:40,799
library

587
00:31:40,799 --> 00:31:44,000
and naturally it's got a bunch of

588
00:31:44,000 --> 00:31:47,640
languages supported

589
00:31:49,679 --> 00:31:51,679
we don't run too often into other

590
00:31:51,679 --> 00:31:53,840
languages but this still you know

591
00:31:53,840 --> 00:31:56,159
happens times you know i remember

592
00:31:56,159 --> 00:31:58,080
projects where i was able to find

593
00:31:58,080 --> 00:32:01,360
strings in german and italian

594
00:32:01,360 --> 00:32:04,240
so if we use it in its default mode

595
00:32:04,240 --> 00:32:06,240
it will work like this it will divide

596
00:32:06,240 --> 00:32:09,100
string into tokens

597
00:32:09,100 --> 00:32:12,209
[Music]

598
00:32:15,039 --> 00:32:17,519
it will identify its own dividers and

599
00:32:17,519 --> 00:32:19,200
everything between the dividers will

600
00:32:19,200 --> 00:32:21,440
translate into tokens so in a natural

601
00:32:21,440 --> 00:32:24,720
language it will do this

602
00:32:25,120 --> 00:32:26,840
i mean script on his

603
00:32:26,840 --> 00:32:30,640
basis will actually identify the valid

604
00:32:30,640 --> 00:32:33,519
words so we have two valid words here

605
00:32:33,519 --> 00:32:37,120
which makes the whole string valid

606
00:32:41,120 --> 00:32:43,440
some things will not be recognized as

607
00:32:43,440 --> 00:32:47,279
valid and it won't even care about the

608
00:32:47,279 --> 00:32:49,519
numbers and figures

609
00:32:49,519 --> 00:32:51,919
and dividers uh can be

610
00:32:51,919 --> 00:32:55,039
spaces but also slashes and so on and

611
00:32:55,039 --> 00:32:57,120
this word for example looks like a like

612
00:32:57,120 --> 00:32:59,279
a like a natural word but it didn't

613
00:32:59,279 --> 00:33:02,480
really recognize it

614
00:33:02,559 --> 00:33:04,799
yes

615
00:33:06,320 --> 00:33:08,880
now at this stage you can actually dis

616
00:33:08,880 --> 00:33:10,799
i'm sorry decide that if a string

617
00:33:10,799 --> 00:33:12,799
contains at least one valid word it

618
00:33:12,799 --> 00:33:16,480
should be considered a valid string

619
00:33:17,360 --> 00:33:20,320
what can happen however is that you have

620
00:33:20,320 --> 00:33:22,559
sequences like this which look like good

621
00:33:22,559 --> 00:33:23,600
ones

622
00:33:23,600 --> 00:33:25,760
but you know if all of them are

623
00:33:25,760 --> 00:33:27,760
not really valid words you know the

624
00:33:27,760 --> 00:33:29,519
whole string will not be considered

625
00:33:29,519 --> 00:33:31,840
valid

626
00:33:34,640 --> 00:33:37,360
through many projects and experiences

627
00:33:37,360 --> 00:33:39,360
with various binaries and text strings

628
00:33:39,360 --> 00:33:41,600
in them

629
00:33:41,679 --> 00:33:43,679
i decided to

630
00:33:43,679 --> 00:33:46,080
do a bit of abstraction there

631
00:33:46,080 --> 00:33:48,080
like i came up with this notion of

632
00:33:48,080 --> 00:33:50,159
embedded strings

633
00:33:50,159 --> 00:33:53,679
which helped me actually

634
00:33:53,679 --> 00:33:55,519
better describe strings i have at least

635
00:33:55,519 --> 00:33:57,360
some valid elements in them and there's

636
00:33:57,360 --> 00:34:00,480
a little tokens if i find the same token

637
00:34:00,480 --> 00:34:02,960
elsewhere

638
00:34:03,519 --> 00:34:05,120
it's not valid the first time if they

639
00:34:05,120 --> 00:34:06,640
see the same

640
00:34:06,640 --> 00:34:08,239
sequence elsewhere

641
00:34:08,239 --> 00:34:12,000
it may be considered something valid

642
00:34:12,000 --> 00:34:14,800
so it will at least be marked as a token

643
00:34:14,800 --> 00:34:16,879
there are also some you know

644
00:34:16,879 --> 00:34:19,760
commonly used abbreviations which the

645
00:34:19,760 --> 00:34:21,520
system should be able to spot as well

646
00:34:21,520 --> 00:34:23,679
for example each h here sits in the

647
00:34:23,679 --> 00:34:26,320
valid string

648
00:34:26,639 --> 00:34:29,040
and then a string like this eta h0

649
00:34:29,040 --> 00:34:32,480
should also be considered valid

650
00:34:32,800 --> 00:34:34,560
but at the same time you'll see that

651
00:34:34,560 --> 00:34:36,719
strings like this were still considered

652
00:34:36,719 --> 00:34:38,399
bad

653
00:34:38,399 --> 00:34:40,320
actually this is how it works to this

654
00:34:40,320 --> 00:34:42,720
very day

655
00:34:44,719 --> 00:34:47,199
actually in this abstraction i also

656
00:34:47,199 --> 00:34:48,719
highlighted

657
00:34:48,719 --> 00:34:50,960
numbers

658
00:34:50,960 --> 00:34:52,639
because they could be good for analysis

659
00:34:52,639 --> 00:34:54,079
as well

660
00:34:54,079 --> 00:34:55,280
again

661
00:34:55,280 --> 00:34:57,599
i will demo it later

662
00:34:57,599 --> 00:35:00,320
offsets now

663
00:35:00,320 --> 00:35:03,640
about it

664
00:35:08,640 --> 00:35:12,720
so we have this two strings for example

665
00:35:12,720 --> 00:35:14,000
we see

666
00:35:14,000 --> 00:35:17,160
there is

667
00:35:28,839 --> 00:35:32,720
references and we find the code here

668
00:35:32,720 --> 00:35:35,839
and we will see that register r1

669
00:35:35,839 --> 00:35:38,400
is written with the address of this text

670
00:35:38,400 --> 00:35:40,560
string

671
00:35:40,720 --> 00:35:42,800
now consider the

672
00:35:42,800 --> 00:35:44,880
adjacent space

673
00:35:44,880 --> 00:35:46,400
is this

674
00:35:46,400 --> 00:35:48,960
a json location

675
00:35:48,960 --> 00:35:51,520
so this is the link code

676
00:35:51,520 --> 00:35:54,400
bringing us to the first string and

677
00:35:54,400 --> 00:35:58,520
let's look at where it's pointing

678
00:36:14,560 --> 00:36:16,880
although there is a string here

679
00:36:16,880 --> 00:36:19,440
where the offset is leading and it even

680
00:36:19,440 --> 00:36:20,720
ends in zero

681
00:36:20,720 --> 00:36:23,599
id has failed to flag it

682
00:36:23,599 --> 00:36:25,920
its neighbor has been properly labeled

683
00:36:25,920 --> 00:36:27,839
but not this one and the code is

684
00:36:27,839 --> 00:36:29,599
identical

685
00:36:29,599 --> 00:36:31,040
the code that

686
00:36:31,040 --> 00:36:33,839
initiates it all

687
00:36:35,440 --> 00:36:37,760
so these were string offsets

688
00:36:37,760 --> 00:36:40,880
now let's look at code

689
00:36:45,760 --> 00:36:47,680
a similar situation here with two

690
00:36:47,680 --> 00:36:49,119
offsets

691
00:36:49,119 --> 00:36:52,000
this one is linking to a code chunk this

692
00:36:52,000 --> 00:36:55,599
must be procedure here

693
00:36:55,599 --> 00:36:57,760
what because we see here

694
00:36:57,760 --> 00:37:01,359
procedure return command

695
00:37:02,880 --> 00:37:05,359
and i see this code here that will write

696
00:37:05,359 --> 00:37:07,040
the address of this procedure to

697
00:37:07,040 --> 00:37:10,640
registry r12

698
00:37:10,640 --> 00:37:12,320
and this string

699
00:37:12,320 --> 00:37:16,000
doesn't point to a local label

700
00:37:17,760 --> 00:37:20,560
some undefined plate segments

701
00:37:20,560 --> 00:37:23,040
studio

702
00:37:25,520 --> 00:37:27,520
this particular shift is actually

703
00:37:27,520 --> 00:37:29,920
triggered by the same code chunk as in

704
00:37:29,920 --> 00:37:32,000
the previous example

705
00:37:32,000 --> 00:37:34,800
and it links to an undefined sequence of

706
00:37:34,800 --> 00:37:36,720
bytes

707
00:37:36,720 --> 00:37:39,440
now if we study closely

708
00:37:39,440 --> 00:37:42,720
i mean this particular command

709
00:37:42,720 --> 00:37:45,119
procedure exit

710
00:37:45,119 --> 00:37:46,160
1a

711
00:37:46,160 --> 00:37:49,359
ef 2fe1 i'm sorry something is wrong

712
00:37:49,359 --> 00:37:52,319
with my presentation

713
00:37:56,000 --> 00:37:59,119
that's a hacking event

714
00:37:59,200 --> 00:38:02,399
we must have been hacked

715
00:38:11,119 --> 00:38:14,320
you should probably avoid repeating it

716
00:38:14,320 --> 00:38:16,560
so that's the secrecy it's work you know

717
00:38:16,560 --> 00:38:19,640
he hasn't

718
00:38:37,440 --> 00:38:39,760
i wonder if it's going to work

719
00:38:39,760 --> 00:38:41,440
it seems to be

720
00:38:41,440 --> 00:38:44,240
no it isn't

721
00:38:44,640 --> 00:38:47,640
duck

722
00:38:50,640 --> 00:38:53,040
this has not been planned

723
00:38:53,040 --> 00:38:56,400
it's an improvisation for sure

724
00:38:56,400 --> 00:38:58,480
so having checked these offsets and how

725
00:38:58,480 --> 00:39:01,200
idea goes

726
00:39:12,800 --> 00:39:14,400
somewhere they can link you know they

727
00:39:14,400 --> 00:39:17,520
can link to code string undefined

728
00:39:17,520 --> 00:39:19,680
and data

729
00:39:19,680 --> 00:39:24,240
data that's you know marked as variables

730
00:39:24,480 --> 00:39:26,160
it's slightly different when it comes to

731
00:39:26,160 --> 00:39:28,160
scripts you know this classification has

732
00:39:28,160 --> 00:39:31,920
been expanded for scripts

733
00:39:33,440 --> 00:39:35,359
at previous stages we learned about all

734
00:39:35,359 --> 00:39:37,359
the procedures you know we identified

735
00:39:37,359 --> 00:39:39,359
them just like the strings

736
00:39:39,359 --> 00:39:41,920
so this script will simply check where

737
00:39:41,920 --> 00:39:43,280
they are

738
00:39:43,280 --> 00:39:45,839
pointing is the procedure starts or

739
00:39:45,839 --> 00:39:49,280
procedure middle or middle of the string

740
00:39:49,280 --> 00:39:51,839
and actually you know it can be

741
00:39:51,839 --> 00:39:54,160
it can be pointing at another offset and

742
00:39:54,160 --> 00:39:56,079
it would be interesting to see you know

743
00:39:56,079 --> 00:39:58,160
a recursive chain

744
00:39:58,160 --> 00:40:00,000
of objects

745
00:40:00,000 --> 00:40:02,880
pointing at each other

746
00:40:04,079 --> 00:40:06,800
now you all know which sequence of bytes

747
00:40:06,800 --> 00:40:08,880
should not be repeated and i'm not going

748
00:40:08,880 --> 00:40:10,960
to

749
00:40:21,839 --> 00:40:22,960
something you know i mentioned

750
00:40:22,960 --> 00:40:25,839
previously

751
00:40:28,240 --> 00:40:30,640
in the code you know there may be a link

752
00:40:30,640 --> 00:40:33,680
to an address but it may be flagged as

753
00:40:33,680 --> 00:40:35,680
red which means that i d believe

754
00:40:35,680 --> 00:40:39,280
something is wrong with it

755
00:40:39,280 --> 00:40:41,440
so we may want to collect them all sort

756
00:40:41,440 --> 00:40:42,720
of

757
00:40:42,720 --> 00:40:45,440
and identify the ranges where they may

758
00:40:45,440 --> 00:40:48,400
be pointing yes

759
00:40:50,640 --> 00:40:52,720
for example

760
00:40:52,720 --> 00:40:54,640
it's very close to the firmware which

761
00:40:54,640 --> 00:40:56,640
has been loaded well we can then expand

762
00:40:56,640 --> 00:40:57,839
the segment

763
00:40:57,839 --> 00:41:00,000
and then idea

764
00:41:00,000 --> 00:41:02,400
may be able to resolve them

765
00:41:02,400 --> 00:41:04,319
if it fails to do that the script will

766
00:41:04,319 --> 00:41:07,119
help

767
00:41:07,119 --> 00:41:08,960
and this way you know we will increase

768
00:41:08,960 --> 00:41:12,319
our certainty so to speak now as regards

769
00:41:12,319 --> 00:41:15,359
jump table switches

770
00:41:17,760 --> 00:41:20,480
you will often see this situation where

771
00:41:20,480 --> 00:41:21,680
an existing

772
00:41:21,680 --> 00:41:24,240
cpe module will not go processor module

773
00:41:24,240 --> 00:41:26,800
will not be able to recognize a switch

774
00:41:26,800 --> 00:41:29,200
well because the switch was designed in

775
00:41:29,200 --> 00:41:31,440
a manner different from that of the

776
00:41:31,440 --> 00:41:33,839
processor module we cannot get access to

777
00:41:33,839 --> 00:41:38,160
the processor module we cannot change it

778
00:41:38,240 --> 00:41:40,240
we can build you know a superstructure

779
00:41:40,240 --> 00:41:42,640
status

780
00:41:43,920 --> 00:41:46,319
i mean we will be first looking at the

781
00:41:46,319 --> 00:41:47,839
switch that has not been properly

782
00:41:47,839 --> 00:41:50,560
analyzed by ide

783
00:41:50,560 --> 00:41:52,400
you know then we'll look for its uh

784
00:41:52,400 --> 00:41:55,359
variants and options

785
00:41:56,560 --> 00:41:58,640
and i will be able to mark him up using

786
00:41:58,640 --> 00:42:01,799
the script

787
00:42:04,000 --> 00:42:06,400
you know one two five switches probably

788
00:42:06,400 --> 00:42:08,160
you don't need a whole script to do that

789
00:42:08,160 --> 00:42:10,800
but if you have like 20 or 100

790
00:42:10,800 --> 00:42:15,480
the script makes it so much easier

791
00:42:18,560 --> 00:42:20,079
i've given you the intro i told you

792
00:42:20,079 --> 00:42:22,000
about procedures

793
00:42:22,000 --> 00:42:24,400
about procedures

794
00:42:24,400 --> 00:42:26,640
anomalous strengths shifts

795
00:42:26,640 --> 00:42:28,640
and we also covered briefly some other

796
00:42:28,640 --> 00:42:29,599
elements

797
00:42:29,599 --> 00:42:32,319
now let me go and try doing the demo so

798
00:42:32,319 --> 00:42:36,279
that you see how it all works

799
00:42:54,319 --> 00:42:57,319
tuck

800
00:43:25,760 --> 00:43:28,079
we do remember the example where we have

801
00:43:28,079 --> 00:43:29,680
nothing you know just a sequence of

802
00:43:29,680 --> 00:43:31,440
boats like we've just opened the

803
00:43:31,440 --> 00:43:32,640
firmware

804
00:43:32,640 --> 00:43:34,640
nothing has been recognized not a single

805
00:43:34,640 --> 00:43:37,640
procedure

806
00:43:41,520 --> 00:43:43,200
this is how this script works we need to

807
00:43:43,200 --> 00:43:45,119
find at least one procedure manually

808
00:43:45,119 --> 00:43:46,960
we've done it

809
00:43:46,960 --> 00:43:49,920
so it has you know the start function

810
00:43:49,920 --> 00:43:52,319
preparer as the hints adjust

811
00:43:52,319 --> 00:43:54,880
and there is an end

812
00:43:54,880 --> 00:43:57,200
function

813
00:44:06,240 --> 00:44:08,480
we started brute forcing it

814
00:44:08,480 --> 00:44:11,599
well this is not the brutus brute force

815
00:44:11,599 --> 00:44:14,319
possible it is slightly intellectual

816
00:44:14,319 --> 00:44:16,000
in here

817
00:44:16,000 --> 00:44:18,240
you can consult the ball to see how the

818
00:44:18,240 --> 00:44:21,799
script is working

819
00:44:22,079 --> 00:44:25,040
so you will see here that id is starting

820
00:44:25,040 --> 00:44:25,780
to process

821
00:44:25,780 --> 00:44:27,680
[Music]

822
00:44:27,680 --> 00:44:29,280
from the script

823
00:44:29,280 --> 00:44:30,800
so it's actually a small piece of

824
00:44:30,800 --> 00:44:32,480
firmware

825
00:44:32,480 --> 00:44:34,319
and over a short period of time we've

826
00:44:34,319 --> 00:44:36,880
been able to collect nearly 7 000

827
00:44:36,880 --> 00:44:40,960
procedures most of them will be valid

828
00:44:41,920 --> 00:44:43,839
i think the stuff we are seeing here

829
00:44:43,839 --> 00:44:47,119
they are bad procedures

830
00:44:48,240 --> 00:44:51,359
i think that the code section ends here

831
00:44:51,359 --> 00:44:54,160
and everything that follows

832
00:44:54,160 --> 00:44:56,400
is not code really

833
00:44:56,400 --> 00:44:59,040
here we can also see chunks of codes

834
00:44:59,040 --> 00:45:02,720
which are not shown as procedures

835
00:45:02,960 --> 00:45:05,040
we can actually you know transform it

836
00:45:05,040 --> 00:45:07,599
back into data

837
00:45:07,599 --> 00:45:11,040
but we're not going to do it right now

838
00:45:12,000 --> 00:45:14,240
all right we can also try checking the

839
00:45:14,240 --> 00:45:17,799
strings out here

840
00:45:24,160 --> 00:45:26,480
which means that it's a typical firmware

841
00:45:26,480 --> 00:45:28,000
but no strings

842
00:45:28,000 --> 00:45:29,920
so we got two string candidates here but

843
00:45:29,920 --> 00:45:31,839
you know if we study them it turns out

844
00:45:31,839 --> 00:45:33,520
they are not really strings they're just

845
00:45:33,520 --> 00:45:36,319
bite sequences

846
00:45:37,680 --> 00:45:41,839
now let's uh consider strings

847
00:45:44,480 --> 00:45:46,720
yes

848
00:45:50,480 --> 00:45:52,880
uh you know procedure search

849
00:45:52,880 --> 00:45:55,119
on a larger binary file it will take a

850
00:45:55,119 --> 00:45:57,280
bit longer to complete

851
00:45:57,280 --> 00:45:58,560
shall we do that

852
00:45:58,560 --> 00:46:01,560
okay

853
00:46:09,440 --> 00:46:11,119
okay i'm told that i won't have enough

854
00:46:11,119 --> 00:46:13,440
time for a q a then probably i shouldn't

855
00:46:13,440 --> 00:46:16,079
do that let me show quickly how strings

856
00:46:16,079 --> 00:46:18,480
will what

857
00:46:18,480 --> 00:46:21,280
is kind of processed so these are three

858
00:46:21,280 --> 00:46:23,359
procedures and this block here it shows

859
00:46:23,359 --> 00:46:26,319
how much time it has spent

860
00:46:26,319 --> 00:46:28,800
see first the algorithm has been run and

861
00:46:28,800 --> 00:46:30,720
the initial number of procedures well

862
00:46:30,720 --> 00:46:34,319
was like this idea

863
00:46:36,880 --> 00:46:39,359
instead of seven thousand procedures

864
00:46:39,359 --> 00:46:43,799
we have 21 000 now

865
00:46:54,720 --> 00:46:57,040
for strings we'll need to first find

866
00:46:57,040 --> 00:47:00,160
some readable symbols

867
00:47:07,839 --> 00:47:11,480
the postcard script

868
00:47:17,280 --> 00:47:21,880
see it's looking for readable symbols

869
00:47:35,839 --> 00:47:39,839
that contain readable symbols

870
00:47:43,359 --> 00:47:44,640
stroke

871
00:47:44,640 --> 00:47:46,480
there is a certain clause

872
00:47:46,480 --> 00:47:48,880
for a string processing

873
00:47:48,880 --> 00:47:51,680
easy let me upload it

874
00:47:51,680 --> 00:47:53,680
now out of all this

875
00:47:53,680 --> 00:47:56,558
readable symbols

876
00:47:59,920 --> 00:48:02,240
i'm sorry we are going to transform this

877
00:48:02,240 --> 00:48:04,839
readable symbols into objects of this

878
00:48:04,839 --> 00:48:08,319
class so as we can try classifying each

879
00:48:08,319 --> 00:48:10,480
of the strings separately

880
00:48:10,480 --> 00:48:13,280
fortunately it's a relatively fast

881
00:48:13,280 --> 00:48:16,160
process 60 000 candidates and now the

882
00:48:16,160 --> 00:48:18,000
analysis starts

883
00:48:18,000 --> 00:48:21,280
so in chant we'll kick in now

884
00:48:21,280 --> 00:48:22,880
it will try

885
00:48:22,880 --> 00:48:26,400
breaking them down into tokens

886
00:48:30,079 --> 00:48:33,040
let me maximize the log window below

887
00:48:33,040 --> 00:48:35,920
so you may actually get to see something

888
00:48:35,920 --> 00:48:38,400
let's go

889
00:48:39,920 --> 00:48:42,319
okay say has done it

890
00:48:42,319 --> 00:48:43,280
he has

891
00:48:43,280 --> 00:48:46,000
grabbed english tokens and he's trying

892
00:48:46,000 --> 00:48:47,119
to

893
00:48:47,119 --> 00:48:50,079
find words there

894
00:48:53,599 --> 00:48:56,880
it will take some time to work

895
00:49:07,119 --> 00:49:08,880
it actually needs

896
00:49:08,880 --> 00:49:09,760
the

897
00:49:09,760 --> 00:49:13,119
term dictionary to

898
00:49:15,280 --> 00:49:17,839
bear with speak i'll copy it real quick

899
00:49:17,839 --> 00:49:20,799
i'll start it again

900
00:49:28,000 --> 00:49:29,599
everything i said about strings

901
00:49:29,599 --> 00:49:30,720
previously

902
00:49:30,720 --> 00:49:34,160
is happening under the hood now

903
00:49:34,960 --> 00:49:36,960
with this stroke

904
00:49:36,960 --> 00:49:38,720
uh let's see how many strings it

905
00:49:38,720 --> 00:49:41,920
suggests i mean string candidates

906
00:49:41,920 --> 00:49:43,119
yes

907
00:49:43,119 --> 00:49:45,280
doc how many of them will be able to see

908
00:49:45,280 --> 00:49:48,000
in the string window

909
00:49:52,640 --> 00:49:55,440
i'm going to display the number of valid

910
00:49:55,440 --> 00:49:58,440
finds

911
00:50:09,359 --> 00:50:12,359
right

912
00:50:12,370 --> 00:50:13,440
[Music]

913
00:50:13,440 --> 00:50:16,559
it has decreed 14 000 strings to be

914
00:50:16,559 --> 00:50:17,839
valid

915
00:50:17,839 --> 00:50:22,078
and we have 8 000 shown in the window

916
00:50:22,720 --> 00:50:27,040
although many of these strings are in

917
00:50:27,650 --> 00:50:30,719
[Music]

918
00:50:38,160 --> 00:50:41,520
so let me conclude it with a demo

919
00:50:41,520 --> 00:50:43,520
you know this project

920
00:50:43,520 --> 00:50:46,079
i've been working on for a long time

921
00:50:46,079 --> 00:50:47,920
it has been helping me a lot for many

922
00:50:47,920 --> 00:50:50,319
projects

923
00:50:51,599 --> 00:50:55,040
i made a demo controller

924
00:51:10,720 --> 00:51:14,319
and i'm showing here how you know i can

925
00:51:14,319 --> 00:51:16,720
make the diodes run in a funny sequence

926
00:51:16,720 --> 00:51:19,359
on this mitsubishi controller

927
00:51:19,359 --> 00:51:22,319
i think this is it for my demo

928
00:51:22,319 --> 00:51:25,119
do you have questions

929
00:51:29,920 --> 00:51:31,760
are there scripts publicly available

930
00:51:31,760 --> 00:51:34,400
it's a great question

931
00:51:34,400 --> 00:51:35,200
i

932
00:51:35,200 --> 00:51:37,359
was planning to make him publicly

933
00:51:37,359 --> 00:51:39,359
available for this conference

934
00:51:39,359 --> 00:51:41,599
but when i looked inside

935
00:51:41,599 --> 00:51:44,480
i realized i probably shouldn't at least

936
00:51:44,480 --> 00:51:46,960
not now

937
00:51:47,680 --> 00:51:50,079
i think at least some of them will be

938
00:51:50,079 --> 00:51:54,480
made public by late summer thank you

939
00:51:54,480 --> 00:51:56,640
uh

940
00:52:00,400 --> 00:52:01,599
thank you very much for your

941
00:52:01,599 --> 00:52:05,839
presentation so if we have a firmware

942
00:52:05,920 --> 00:52:08,000
and we probably don't know which

943
00:52:08,000 --> 00:52:12,319
segments it should uh break into

944
00:52:12,400 --> 00:52:15,119
how do you go about splitting it into

945
00:52:15,119 --> 00:52:17,400
you know locations and segments

946
00:52:17,400 --> 00:52:20,489
[Music]

947
00:52:27,359 --> 00:52:30,839
identifying segments is

948
00:52:30,839 --> 00:52:34,400
easy i remember this ms-dos

949
00:52:34,400 --> 00:52:36,559
project although he was running some

950
00:52:36,559 --> 00:52:39,040
pretty modern equipment

951
00:52:39,040 --> 00:52:43,359
it contained over 50 segments

952
00:52:45,119 --> 00:52:47,280
the script i have is not you know you're

953
00:52:47,280 --> 00:52:49,839
because this is not your versatile but

954
00:52:49,839 --> 00:52:52,000
so with korea i was able to see

955
00:52:52,000 --> 00:52:53,520
what goes where

956
00:52:53,520 --> 00:52:55,119
and then with the script you know i was

957
00:52:55,119 --> 00:52:57,040
able to do to finalize this mapping

958
00:52:57,040 --> 00:52:58,400
which means that

959
00:52:58,400 --> 00:53:02,079
you do segmentation sort of manually

960
00:53:02,079 --> 00:53:04,319
yes because you know segments are not

961
00:53:04,319 --> 00:53:06,960
that prevalent

962
00:53:20,060 --> 00:53:23,099
[Music]

963
00:53:25,760 --> 00:53:29,280
i had many situations where i would see

964
00:53:29,280 --> 00:53:30,960
lots of

965
00:53:30,960 --> 00:53:34,160
bogus procedures in the binary and then

966
00:53:34,160 --> 00:53:36,000
i realized you know with the offset

967
00:53:36,000 --> 00:53:38,240
everything is fine yeah

968
00:53:38,240 --> 00:53:42,040
so it's a broken link

969
00:53:42,079 --> 00:53:45,520
yeah i tried it in developing you know

970
00:53:45,520 --> 00:53:48,400
an image based order

971
00:53:48,400 --> 00:53:50,960
determiner so to speak of the loading

972
00:53:50,960 --> 00:53:52,559
address

973
00:53:52,559 --> 00:53:54,000
based on switches and stuff but i

974
00:53:54,000 --> 00:53:56,000
haven't completed it yet really you know

975
00:53:56,000 --> 00:53:58,640
it would work from time to time

976
00:53:58,640 --> 00:54:01,200
like this stuff it works in a

977
00:54:01,200 --> 00:54:06,279
guaranteed manner and that script didn't

978
00:54:17,359 --> 00:54:19,520
you know which files are trying you know

979
00:54:19,520 --> 00:54:22,160
to open it and uh which network location

980
00:54:22,160 --> 00:54:25,799
it's trying to address

981
00:54:33,720 --> 00:54:36,850
[Music]

982
00:54:45,760 --> 00:54:47,839
if it's a well-known api something that

983
00:54:47,839 --> 00:54:50,240
can be found quickly it can be checked

984
00:54:50,240 --> 00:54:53,558
for it quickly

985
00:54:58,720 --> 00:55:01,040
if you do a regular binary search for a

986
00:55:01,040 --> 00:55:02,880
sequence of bytes

987
00:55:02,880 --> 00:55:04,480
i think it will be great for finding

988
00:55:04,480 --> 00:55:07,200
those things like finding ibs

989
00:55:07,200 --> 00:55:09,440
so the short answer is yes you can do it

990
00:55:09,440 --> 00:55:12,440
quickly

991
00:55:27,119 --> 00:55:30,720
have you considered other analyzers

992
00:55:30,720 --> 00:55:34,359
hydra runners

993
00:55:45,760 --> 00:55:49,040
that it's indeed easier for me to update

994
00:55:49,040 --> 00:55:51,520
my tool set as opposed to you know

995
00:55:51,520 --> 00:55:53,599
starting something new

996
00:55:53,599 --> 00:55:57,920
i haven't really compared them to ide

997
00:56:00,079 --> 00:56:04,319
you know when hydra emerged

998
00:56:04,559 --> 00:56:05,920
i wasn't really interested in such a

999
00:56:05,920 --> 00:56:09,920
compass i haven't really compared it yet

1000
00:56:09,920 --> 00:56:11,760
that would require time

1001
00:56:11,760 --> 00:56:13,680
and time

1002
00:56:13,680 --> 00:56:17,160
i don't have

1003
00:56:25,920 --> 00:56:28,480
well thank you very much i hope you were

1004
00:56:28,480 --> 00:56:29,740
interested

1005
00:56:29,740 --> 00:56:32,790
[Applause]

