1
00:00:05,680 --> 00:00:06,480
well

2
00:00:06,480 --> 00:00:08,639
thank you very much for coming

3
00:00:08,639 --> 00:00:12,160
to hear about

4
00:00:12,160 --> 00:00:13,519
this topic

5
00:00:13,519 --> 00:00:15,360
well most of the speakers

6
00:00:15,360 --> 00:00:16,720
have

7
00:00:16,720 --> 00:00:19,359
slides about themselves but not me my

8
00:00:19,359 --> 00:00:21,680
name is timur cherniv

9
00:00:21,680 --> 00:00:24,800
now i work for group ib i'm a lead

10
00:00:24,800 --> 00:00:25,920
developer

11
00:00:25,920 --> 00:00:28,080
of linux for the end users

12
00:00:28,080 --> 00:00:31,199
i develop edr agents

13
00:00:31,199 --> 00:00:33,440
and today i will be talking about

14
00:00:33,440 --> 00:00:35,840
patching the kernel

15
00:00:35,840 --> 00:00:37,600
life patching

16
00:00:37,600 --> 00:00:39,760
my colleague is jirena

17
00:00:39,760 --> 00:00:42,239
bakarchenko she helped me to prepare

18
00:00:42,239 --> 00:00:43,760
this but she couldn't come today

19
00:00:43,760 --> 00:00:45,200
unfortunately

20
00:00:45,200 --> 00:00:47,280
so that's why i'll be the only speaker

21
00:00:47,280 --> 00:00:50,000
on this topic

22
00:00:51,760 --> 00:00:53,760
okay

23
00:00:53,760 --> 00:00:55,440
to begin with

24
00:00:55,440 --> 00:00:57,760
the overall goal

25
00:00:57,760 --> 00:00:59,199
is to have

26
00:00:59,199 --> 00:01:00,640
a kernel

27
00:01:00,640 --> 00:01:03,600
model to patch the system to do it in

28
00:01:03,600 --> 00:01:07,280
production and in a stable fashion

29
00:01:07,280 --> 00:01:09,439
and

30
00:01:09,439 --> 00:01:12,080
for as many operating systems and their

31
00:01:12,080 --> 00:01:15,600
versions as possible

32
00:01:16,320 --> 00:01:19,200
okay this is an edr agent what do we

33
00:01:19,200 --> 00:01:20,159
need

34
00:01:20,159 --> 00:01:22,720
we need to develop an event in the

35
00:01:22,720 --> 00:01:24,320
operating system

36
00:01:24,320 --> 00:01:25,200
so

37
00:01:25,200 --> 00:01:26,960
i'll tell you how we're going to do it

38
00:01:26,960 --> 00:01:29,200
so we need to generate

39
00:01:29,200 --> 00:01:32,079
the event to collect information to

40
00:01:32,079 --> 00:01:33,680
transfer it to the user's space it

41
00:01:33,680 --> 00:01:36,079
should be stable it shouldn't

42
00:01:36,079 --> 00:01:38,079
fail it shouldn't be

43
00:01:38,079 --> 00:01:41,520
very demanding of the

44
00:01:41,520 --> 00:01:44,560
kernel build process we do it locally it

45
00:01:44,560 --> 00:01:47,119
should load dynamically and

46
00:01:47,119 --> 00:01:49,360
unload dynamically this is really

47
00:01:49,360 --> 00:01:52,799
important it's important for the live

48
00:01:52,799 --> 00:01:54,799
updates and it should also control the

49
00:01:54,799 --> 00:01:56,000
system

50
00:01:56,000 --> 00:01:57,840
well i have three clarification

51
00:01:57,840 --> 00:01:59,200
questions

52
00:01:59,200 --> 00:02:00,320
to

53
00:02:00,320 --> 00:02:01,360
make

54
00:02:01,360 --> 00:02:05,200
our speech interactive who knows the c

55
00:02:05,200 --> 00:02:07,040
language who develops in this language

56
00:02:07,040 --> 00:02:08,720
okay and what about the assembler who

57
00:02:08,720 --> 00:02:10,080
knows the assembler

58
00:02:10,080 --> 00:02:14,319
and who knows the in kernel development

59
00:02:14,319 --> 00:02:16,239
this is great

60
00:02:16,239 --> 00:02:18,959
okay i'll share with you as many details

61
00:02:18,959 --> 00:02:21,040
as i can then

62
00:02:21,040 --> 00:02:24,079
the options we've had

63
00:02:24,160 --> 00:02:27,920
we have considered ebpf plus xdp and the

64
00:02:27,920 --> 00:02:29,520
lsm hooks

65
00:02:29,520 --> 00:02:30,879
well

66
00:02:30,879 --> 00:02:32,000
ebpf

67
00:02:32,000 --> 00:02:33,519
is the improved

68
00:02:33,519 --> 00:02:35,760
packet filter which was used for the

69
00:02:35,760 --> 00:02:37,760
previous operating systems to filter the

70
00:02:37,760 --> 00:02:39,519
network traffic

71
00:02:39,519 --> 00:02:41,519
with the extensions

72
00:02:41,519 --> 00:02:44,400
xdp which came up later and this became

73
00:02:44,400 --> 00:02:47,040
a virtual machine a full-fledged one

74
00:02:47,040 --> 00:02:49,120
working at the kernel

75
00:02:49,120 --> 00:02:51,440
level inside the kernel with its

76
00:02:51,440 --> 00:02:54,560
pseudo language which resembles

77
00:02:54,560 --> 00:02:55,519
c

78
00:02:55,519 --> 00:02:58,400
and lsm hooks are the security models of

79
00:02:58,400 --> 00:03:00,879
linux which let us have

80
00:03:00,879 --> 00:03:02,159
hooks

81
00:03:02,159 --> 00:03:03,360
catch a

82
00:03:03,360 --> 00:03:04,879
system

83
00:03:04,879 --> 00:03:07,360
calls and events brings their contacts

84
00:03:07,360 --> 00:03:09,200
and it's very secure

85
00:03:09,200 --> 00:03:13,119
but there are some tricks here

86
00:03:13,280 --> 00:03:16,640
ebpf plus xdt bdp is not good for us

87
00:03:16,640 --> 00:03:18,640
because it doesn't have enough

88
00:03:18,640 --> 00:03:19,920
functionality well we have enough

89
00:03:19,920 --> 00:03:21,440
functionality but we don't have control

90
00:03:21,440 --> 00:03:23,280
over the system

91
00:03:23,280 --> 00:03:24,640
and

92
00:03:24,640 --> 00:03:26,959
well the kernel

93
00:03:26,959 --> 00:03:29,599
should be built on ppf and we don't have

94
00:03:29,599 --> 00:03:32,799
a lot coded on bpf i mean the critical

95
00:03:32,799 --> 00:03:35,760
functions of the core

96
00:03:36,879 --> 00:03:39,920
lsm hooks with the senior versions of

97
00:03:39,920 --> 00:03:42,480
linux cannot be exported anymore

98
00:03:42,480 --> 00:03:43,519
so the

99
00:03:43,519 --> 00:03:46,799
kernel module developers cannot do it so

100
00:03:46,799 --> 00:03:48,159
if you

101
00:03:48,159 --> 00:03:50,080
develop the kernel please use some hooks

102
00:03:50,080 --> 00:03:52,560
if you don't code to the kernel please

103
00:03:52,560 --> 00:03:54,400
find a solution or record it all

104
00:03:54,400 --> 00:03:55,599
together

105
00:03:55,599 --> 00:03:57,920
okay what are the options left we can

106
00:03:57,920 --> 00:03:59,599
use

107
00:03:59,599 --> 00:04:00,640
trays

108
00:04:00,640 --> 00:04:01,599
and

109
00:04:01,599 --> 00:04:03,599
you can use

110
00:04:03,599 --> 00:04:05,040
also

111
00:04:05,040 --> 00:04:06,720
key probes

112
00:04:06,720 --> 00:04:08,560
well

113
00:04:08,560 --> 00:04:10,400
well this doesn't really work so we'll

114
00:04:10,400 --> 00:04:12,239
use patching

115
00:04:12,239 --> 00:04:16,320
kernel patching why so well it works in

116
00:04:16,320 --> 00:04:18,000
any case

117
00:04:18,000 --> 00:04:20,000
so if you properly code we'll be talking

118
00:04:20,000 --> 00:04:22,320
about it

119
00:04:23,040 --> 00:04:24,240
this is 100

120
00:04:24,240 --> 00:04:27,040
uh reliable and it gives us control over

121
00:04:27,040 --> 00:04:28,639
the system

122
00:04:28,639 --> 00:04:31,680
so if you heard about rootkits

123
00:04:31,680 --> 00:04:32,400
and

124
00:04:32,400 --> 00:04:36,000
how you get control over the system

125
00:04:36,000 --> 00:04:38,960
and how patient happens

126
00:04:38,960 --> 00:04:40,960
so the major source information will be

127
00:04:40,960 --> 00:04:43,280
the system calls

128
00:04:43,280 --> 00:04:46,239
i will start with them

129
00:04:47,759 --> 00:04:49,840
and we will see the requirements we need

130
00:04:49,840 --> 00:04:52,719
to start patching

131
00:04:52,960 --> 00:04:53,919
we need

132
00:04:53,919 --> 00:04:56,800
two conflicts call sims and

133
00:04:56,800 --> 00:04:58,320
k probes

134
00:04:58,320 --> 00:04:59,440
call

135
00:04:59,440 --> 00:05:01,840
sims gives us information

136
00:05:01,840 --> 00:05:04,400
on the kernel symbols

137
00:05:04,400 --> 00:05:06,960
just like in any binary you have symbols

138
00:05:06,960 --> 00:05:09,360
in the kernel you needed to find the

139
00:05:09,360 --> 00:05:10,400
addresses

140
00:05:10,400 --> 00:05:11,600
and like

141
00:05:11,600 --> 00:05:15,120
we will use calcium's lookup name which

142
00:05:15,120 --> 00:05:17,120
is not exported in the more senior

143
00:05:17,120 --> 00:05:18,320
versions

144
00:05:18,320 --> 00:05:20,479
or junior versions and we also need

145
00:05:20,479 --> 00:05:21,520
catholic

146
00:05:21,520 --> 00:05:23,440
k probes

147
00:05:23,440 --> 00:05:25,680
we needed

148
00:05:25,680 --> 00:05:27,759
to proceed

149
00:05:27,759 --> 00:05:29,280
in this process and i'll be talking

150
00:05:29,280 --> 00:05:31,919
about it now you can hardly make out the

151
00:05:31,919 --> 00:05:33,120
code here

152
00:05:33,120 --> 00:05:34,720
well key probes

153
00:05:34,720 --> 00:05:37,440
so to legitimately

154
00:05:37,440 --> 00:05:38,560
set

155
00:05:38,560 --> 00:05:40,000
the live patches

156
00:05:40,000 --> 00:05:42,560
it works

157
00:05:44,000 --> 00:05:46,479
this way that's an interruption

158
00:05:46,479 --> 00:05:47,280
with

159
00:05:47,280 --> 00:05:49,759
the log then when interruption

160
00:05:49,759 --> 00:05:52,479
comes so a handler will give us

161
00:05:52,479 --> 00:05:55,600
the control in our kernel module

162
00:05:55,600 --> 00:05:58,000
well this is an interruption and the

163
00:05:58,000 --> 00:05:59,919
kernel is in this

164
00:05:59,919 --> 00:06:01,360
environment

165
00:06:01,360 --> 00:06:03,840
but it will help us find the

166
00:06:03,840 --> 00:06:07,120
cosims lookup name to look for

167
00:06:07,120 --> 00:06:09,600
the addresses of functions inside the

168
00:06:09,600 --> 00:06:10,479
core

169
00:06:10,479 --> 00:06:12,960
how does it work so you

170
00:06:12,960 --> 00:06:16,000
set the k probe and the structure key

171
00:06:16,000 --> 00:06:18,000
probe with the hook will

172
00:06:18,000 --> 00:06:19,360
give us back

173
00:06:19,360 --> 00:06:21,280
the address

174
00:06:21,280 --> 00:06:23,120
of the function

175
00:06:23,120 --> 00:06:26,560
so we use keyprop to find the calcium's

176
00:06:26,560 --> 00:06:27,759
lookup name

177
00:06:27,759 --> 00:06:30,800
and so we use

178
00:06:30,800 --> 00:06:32,840
this to find the address and the

179
00:06:32,840 --> 00:06:36,560
attributes of the address

180
00:06:37,440 --> 00:06:39,600
you can hardly make out the code so let

181
00:06:39,600 --> 00:06:41,120
me explain it

182
00:06:41,120 --> 00:06:42,880
well i have shared with you the essence

183
00:06:42,880 --> 00:06:44,160
of it

184
00:06:44,160 --> 00:06:47,800
so let's proceed

185
00:06:53,440 --> 00:06:55,520
so we are starting with the system calls

186
00:06:55,520 --> 00:06:57,280
and science

187
00:06:57,280 --> 00:07:00,160
quite a lot of people know what c is so

188
00:07:00,160 --> 00:07:02,800
i'm not talking about signs here

189
00:07:02,800 --> 00:07:04,479
or indicators

190
00:07:04,479 --> 00:07:06,479
okay

191
00:07:06,479 --> 00:07:08,400
i'll ask you a question what's wrong

192
00:07:08,400 --> 00:07:09,280
here

193
00:07:09,280 --> 00:07:10,639
we find the

194
00:07:10,639 --> 00:07:13,280
system called table

195
00:07:13,280 --> 00:07:16,479
and this macros and our open

196
00:07:16,479 --> 00:07:19,520
will determine the system call number in

197
00:07:19,520 --> 00:07:20,960
the table

198
00:07:20,960 --> 00:07:24,160
this open handler is our function in the

199
00:07:24,160 --> 00:07:26,639
kernel we can do it this way but what

200
00:07:26,639 --> 00:07:31,319
will go wrong in this case any ideas

201
00:07:39,280 --> 00:07:43,080
here is a map for you

202
00:07:46,479 --> 00:07:47,599
okay

203
00:07:47,599 --> 00:07:49,520
you understood it

204
00:07:49,520 --> 00:07:52,800
okay the issue is in the cache of the

205
00:07:52,800 --> 00:07:54,479
processor

206
00:07:54,479 --> 00:07:56,639
so

207
00:07:56,800 --> 00:07:58,400
you know

208
00:07:58,400 --> 00:08:01,679
this stones which

209
00:08:01,840 --> 00:08:04,560
are used to process uh

210
00:08:04,560 --> 00:08:06,319
the information

211
00:08:06,319 --> 00:08:07,599
are not perfect just like the

212
00:08:07,599 --> 00:08:09,680
programmers and there are mistakes there

213
00:08:09,680 --> 00:08:11,520
that's why we need to

214
00:08:11,520 --> 00:08:13,680
optimize

215
00:08:13,680 --> 00:08:15,599
the code and we need to

216
00:08:15,599 --> 00:08:18,879
have access to the cache processes

217
00:08:18,879 --> 00:08:20,080
and to

218
00:08:20,080 --> 00:08:21,360
hot

219
00:08:21,360 --> 00:08:22,319
cache

220
00:08:22,319 --> 00:08:24,560
process and there are some issues you

221
00:08:24,560 --> 00:08:26,960
have all of load cache is very hot data

222
00:08:26,960 --> 00:08:28,879
is updated there all the time

223
00:08:28,879 --> 00:08:30,639
so

224
00:08:30,639 --> 00:08:33,599
l1 continuous reading data

225
00:08:33,599 --> 00:08:34,399
l

226
00:08:34,399 --> 00:08:36,640
one instructions

227
00:08:36,640 --> 00:08:39,360
and we have some issues in the cache

228
00:08:39,360 --> 00:08:41,599
where the processor detects that the

229
00:08:41,599 --> 00:08:44,720
data in the cache is not exactly

230
00:08:44,720 --> 00:08:47,120
right a lot of conflicts like cache

231
00:08:47,120 --> 00:08:50,320
messages let's talk about

232
00:08:50,320 --> 00:08:52,640
a straightforward example

233
00:08:52,640 --> 00:08:56,080
the whole process where the cash

234
00:08:56,080 --> 00:08:58,560
not is not associative the risk of

235
00:08:58,560 --> 00:09:01,279
mismatch is very high what will happen

236
00:09:01,279 --> 00:09:02,160
then

237
00:09:02,160 --> 00:09:03,260
so you can see

238
00:09:03,260 --> 00:09:05,519
[Music]

239
00:09:05,519 --> 00:09:07,120
the cash line

240
00:09:07,120 --> 00:09:10,160
with some data

241
00:09:10,160 --> 00:09:13,760
so we have the system calls is open

242
00:09:13,760 --> 00:09:16,000
so we are reading the table so this is a

243
00:09:16,000 --> 00:09:18,240
mismatch okay the address will not fit

244
00:09:18,240 --> 00:09:21,200
here okay what will the processor do it

245
00:09:21,200 --> 00:09:24,720
will read this to the end and if we

246
00:09:24,720 --> 00:09:26,000
change the

247
00:09:26,000 --> 00:09:29,279
indicator in the system call function in

248
00:09:29,279 --> 00:09:30,800
the system table

249
00:09:30,800 --> 00:09:33,360
this will be the result

250
00:09:33,360 --> 00:09:35,760
okay what will happen then

251
00:09:35,760 --> 00:09:38,080
this will be a page fault

252
00:09:38,080 --> 00:09:39,519
and the kernel

253
00:09:39,519 --> 00:09:42,399
will jump to a wrong address so we don't

254
00:09:42,399 --> 00:09:44,240
know where it's going to jump so it's

255
00:09:44,240 --> 00:09:46,320
going to collapse maybe not instantly

256
00:09:46,320 --> 00:09:48,720
but we'll see how we'll see

257
00:09:48,720 --> 00:09:51,760
the gradle stumbling

258
00:09:51,760 --> 00:09:53,920
of our machine

259
00:09:53,920 --> 00:09:56,800
okay what to do

260
00:09:58,800 --> 00:10:01,519
several options

261
00:10:01,920 --> 00:10:04,640
we need to bend well you know

262
00:10:04,640 --> 00:10:06,320
how we

263
00:10:06,320 --> 00:10:08,160
avoid race conditions

264
00:10:08,160 --> 00:10:10,800
so we use mutexes everywhere

265
00:10:10,800 --> 00:10:13,920
but we cannot use mutexes for some code

266
00:10:13,920 --> 00:10:15,680
we haven't authored

267
00:10:15,680 --> 00:10:17,040
so we

268
00:10:17,040 --> 00:10:19,360
can not use circulation primitives or

269
00:10:19,360 --> 00:10:22,000
mutaxes

270
00:10:22,160 --> 00:10:24,719
for the

271
00:10:26,240 --> 00:10:28,800
kernel which is compiled which is an

272
00:10:28,800 --> 00:10:31,600
array so we can mark

273
00:10:31,600 --> 00:10:35,200
this uh page with the memory as a

274
00:10:35,200 --> 00:10:37,120
no read but i don't know what's going to

275
00:10:37,120 --> 00:10:39,440
happen

276
00:10:40,800 --> 00:10:42,959
so the only solution we believe is to

277
00:10:42,959 --> 00:10:45,920
ask all the other process to wait and do

278
00:10:45,920 --> 00:10:47,120
nothing

279
00:10:47,120 --> 00:10:50,079
i mean nothing at all

280
00:10:50,079 --> 00:10:52,319
okay

281
00:10:52,800 --> 00:10:55,360
we have a good

282
00:10:55,360 --> 00:10:56,720
mechanism here asymmetric

283
00:10:56,720 --> 00:10:58,240
multi-processing

284
00:10:58,240 --> 00:11:01,839
so it lets us

285
00:11:02,000 --> 00:11:04,320
make all the process but one do

286
00:11:04,320 --> 00:11:07,360
something some kind of job one job okay

287
00:11:07,360 --> 00:11:11,440
we have four cpus virtual or non-virtual

288
00:11:11,440 --> 00:11:13,440
so they do their job

289
00:11:13,440 --> 00:11:16,880
so we have cpu 4 which wants to change

290
00:11:16,880 --> 00:11:19,200
the call

291
00:11:19,200 --> 00:11:20,160
table

292
00:11:20,160 --> 00:11:24,079
it will call the sap call for some

293
00:11:24,079 --> 00:11:26,240
routine so the other three process will

294
00:11:26,240 --> 00:11:29,279
be working there and wait for processor

295
00:11:29,279 --> 00:11:30,240
4

296
00:11:30,240 --> 00:11:33,680
for a sign that you can proceed

297
00:11:33,839 --> 00:11:37,040
the three processors including this one

298
00:11:37,040 --> 00:11:38,800
will

299
00:11:38,800 --> 00:11:43,240
switch on the preemption mechanism

300
00:11:43,360 --> 00:11:44,160
so

301
00:11:44,160 --> 00:11:46,240
when we have one core but two virtual

302
00:11:46,240 --> 00:11:47,120
cores

303
00:11:47,120 --> 00:11:50,240
i mean when uh the tasks uh go through

304
00:11:50,240 --> 00:11:52,079
the scheduler

305
00:11:52,079 --> 00:11:55,440
for one cpu we do this so that

306
00:11:55,440 --> 00:11:58,079
the three processes shouldn't uh

307
00:11:58,079 --> 00:11:59,760
do something apart from their waiting

308
00:11:59,760 --> 00:12:02,639
routine because otherwise it will cause

309
00:12:02,639 --> 00:12:06,079
the cpu failure okay and the four

310
00:12:06,079 --> 00:12:09,440
cpu will switch off preemption and

311
00:12:09,440 --> 00:12:11,920
all the interruptions the hardware the

312
00:12:11,920 --> 00:12:13,519
software ones

313
00:12:13,519 --> 00:12:17,120
so we replace the addresses say proceed

314
00:12:17,120 --> 00:12:19,920
okay good we have patched the system

315
00:12:19,920 --> 00:12:22,399
table the system calls table good good

316
00:12:22,399 --> 00:12:23,200
job

317
00:12:23,200 --> 00:12:25,040
the code looks like that hopefully you

318
00:12:25,040 --> 00:12:27,839
can make it out

319
00:12:33,920 --> 00:12:36,320
this is the waiting routine

320
00:12:36,320 --> 00:12:39,360
we send the structure

321
00:12:39,360 --> 00:12:41,600
with the timeout what is the timeout

322
00:12:41,600 --> 00:12:43,279
i'll tell you why

323
00:12:43,279 --> 00:12:45,680
later

324
00:12:46,480 --> 00:12:50,680
so we'll need it to offload

325
00:12:52,000 --> 00:12:54,720
or unload here we switch off all

326
00:12:54,720 --> 00:12:57,200
software interruptions

327
00:12:57,200 --> 00:12:59,680
we have the processor id

328
00:12:59,680 --> 00:13:01,839
so that we have smp for some other

329
00:13:01,839 --> 00:13:03,519
process or of course

330
00:13:03,519 --> 00:13:04,480
we

331
00:13:04,480 --> 00:13:06,880
don't have all the processes in this

332
00:13:06,880 --> 00:13:08,880
routine which will

333
00:13:08,880 --> 00:13:11,600
freeze the operating system so we are

334
00:13:11,600 --> 00:13:14,160
there in the while loop to

335
00:13:14,160 --> 00:13:16,800
kind of uh wait until we are told to

336
00:13:16,800 --> 00:13:19,200
continue then we have the preemption

337
00:13:19,200 --> 00:13:20,959
and

338
00:13:20,959 --> 00:13:24,079
reverse interruption

339
00:13:24,880 --> 00:13:27,440
so many of us are developers here

340
00:13:27,440 --> 00:13:30,800
we don't like making mistakes and we

341
00:13:30,800 --> 00:13:32,160
have mattresses

342
00:13:32,160 --> 00:13:33,519
so

343
00:13:33,519 --> 00:13:34,959
i would suggest

344
00:13:34,959 --> 00:13:36,639
enriching

345
00:13:36,639 --> 00:13:39,519
all that with the macros looking like

346
00:13:39,519 --> 00:13:41,360
that

347
00:13:41,360 --> 00:13:43,040
give or take

348
00:13:43,040 --> 00:13:45,440
so this way we'll remove the memory

349
00:13:45,440 --> 00:13:48,399
barriers so that we have a guarantee

350
00:13:48,399 --> 00:13:50,240
that the whole code

351
00:13:50,240 --> 00:13:52,560
will be a run

352
00:13:52,560 --> 00:13:54,079
before

353
00:13:54,079 --> 00:13:56,160
something goes wrong

354
00:13:56,160 --> 00:13:56,959
so

355
00:13:56,959 --> 00:13:58,880
the trap function

356
00:13:58,880 --> 00:14:01,920
so we can bring the data and some flags

357
00:14:01,920 --> 00:14:03,839
their waiting code

358
00:14:03,839 --> 00:14:04,720
and

359
00:14:04,720 --> 00:14:07,600
so on and so forth

360
00:14:09,120 --> 00:14:11,360
so we'll wait for all the

361
00:14:11,360 --> 00:14:12,800
processors to

362
00:14:12,800 --> 00:14:14,320
get out of the

363
00:14:14,320 --> 00:14:16,560
routine so then we call the cpu relax so

364
00:14:16,560 --> 00:14:19,600
that we don't overload the processor so

365
00:14:19,600 --> 00:14:23,760
we have a brief code to patch

366
00:14:23,760 --> 00:14:26,880
any sign and it looks like that

367
00:14:26,880 --> 00:14:28,839
so the pros and

368
00:14:28,839 --> 00:14:32,480
cons here they are

369
00:14:33,199 --> 00:14:36,240
okay the most important

370
00:14:36,240 --> 00:14:38,160
negative of this approach

371
00:14:38,160 --> 00:14:39,279
is that

372
00:14:39,279 --> 00:14:40,560
the machine

373
00:14:40,560 --> 00:14:42,880
will not work for some time

374
00:14:42,880 --> 00:14:46,160
all the things done by the stone will be

375
00:14:46,160 --> 00:14:47,760
re-recording

376
00:14:47,760 --> 00:14:50,000
some table of

377
00:14:50,000 --> 00:14:52,639
system calls while it is a high load

378
00:14:52,639 --> 00:14:53,600
server

379
00:14:53,600 --> 00:14:54,800
this can

380
00:14:54,800 --> 00:14:58,480
be bad because we have the database

381
00:14:58,480 --> 00:15:00,639
and

382
00:15:00,639 --> 00:15:03,040
we have this response per second and so

383
00:15:03,040 --> 00:15:04,480
on so forth

384
00:15:04,480 --> 00:15:07,199
but the advantages are there we don't

385
00:15:07,199 --> 00:15:10,320
fail we want the kernel model to be safe

386
00:15:10,320 --> 00:15:13,360
and this works for almost everything

387
00:15:13,360 --> 00:15:14,160
so

388
00:15:14,160 --> 00:15:16,000
when we cannot

389
00:15:16,000 --> 00:15:18,959
launch something and use mutexes

390
00:15:18,959 --> 00:15:21,199
we can

391
00:15:21,199 --> 00:15:24,240
use this mechanism

392
00:15:24,560 --> 00:15:25,440
and

393
00:15:25,440 --> 00:15:28,639
this module is uh usually loaded before

394
00:15:28,639 --> 00:15:30,240
the start of the

395
00:15:30,240 --> 00:15:32,000
user programs

396
00:15:32,000 --> 00:15:33,839
well this will not

397
00:15:33,839 --> 00:15:36,959
be seen with the call start of the

398
00:15:36,959 --> 00:15:38,839
system

399
00:15:38,839 --> 00:15:43,040
and the second issue the contacts uh so

400
00:15:43,040 --> 00:15:43,839
we

401
00:15:43,839 --> 00:15:46,480
have the patches of the system

402
00:15:46,480 --> 00:15:47,519
calls

403
00:15:47,519 --> 00:15:49,440
and uh

404
00:15:49,440 --> 00:15:51,279
so we need to

405
00:15:51,279 --> 00:15:54,320
find the information on what is going on

406
00:15:54,320 --> 00:15:55,279
well

407
00:15:55,279 --> 00:15:57,519
this is a very brief

408
00:15:57,519 --> 00:15:59,279
thing only one

409
00:15:59,279 --> 00:16:01,759
mem416

410
00:16:01,759 --> 00:16:03,279
this is the

411
00:16:03,279 --> 00:16:05,440
kernel version every signature of this

412
00:16:05,440 --> 00:16:07,040
is called there

413
00:16:07,040 --> 00:16:09,519
is just a function

414
00:16:09,519 --> 00:16:12,639
with a clear call convention

415
00:16:12,639 --> 00:16:15,680
in the registry rx will have the number

416
00:16:15,680 --> 00:16:19,120
of the system call and then i can't

417
00:16:19,120 --> 00:16:21,440
remember the arguments exactly

418
00:16:21,440 --> 00:16:23,440
how to split but though i have the

419
00:16:23,440 --> 00:16:25,120
arguments anyway

420
00:16:25,120 --> 00:16:27,920
so sometimes so the sign for the user

421
00:16:27,920 --> 00:16:29,440
space memory

422
00:16:29,440 --> 00:16:32,240
and so on and so forth this is not that

423
00:16:32,240 --> 00:16:34,399
important we need to have

424
00:16:34,399 --> 00:16:37,199
the same function signature and uh we

425
00:16:37,199 --> 00:16:39,120
want everything to work

426
00:16:39,120 --> 00:16:43,360
okay and this is the kernel 417.

427
00:16:43,360 --> 00:16:45,360
okay i'm showing this macrosis the

428
00:16:45,360 --> 00:16:47,040
previous one is not very informative and

429
00:16:47,040 --> 00:16:50,000
here only one line is informative here

430
00:16:50,000 --> 00:16:52,240
it is

431
00:16:52,240 --> 00:16:55,199
the latest versions of the kernel nss

432
00:16:55,199 --> 00:16:56,160
call

433
00:16:56,160 --> 00:16:58,240
doesn't have the arguments

434
00:16:58,240 --> 00:17:00,399
unlike it used to be done in the past

435
00:17:00,399 --> 00:17:02,880
well they are transmitted but

436
00:17:02,880 --> 00:17:04,400
it comes to the

437
00:17:04,400 --> 00:17:07,760
system called as a ptrx structure

438
00:17:07,760 --> 00:17:10,400
just imagine we have a lot of syscalls

439
00:17:10,400 --> 00:17:13,439
and we need to have this if kernel

440
00:17:13,439 --> 00:17:15,919
version 416

441
00:17:15,919 --> 00:17:17,039
then

442
00:17:17,039 --> 00:17:19,599
the signature otherwise that signature

443
00:17:19,599 --> 00:17:21,760
and so on so we'll get the arguments in

444
00:17:21,760 --> 00:17:23,119
different ways

445
00:17:23,119 --> 00:17:25,119
and

446
00:17:25,119 --> 00:17:27,199
so i can see you're frowning

447
00:17:27,199 --> 00:17:29,679
you're not happy

448
00:17:29,679 --> 00:17:31,760
so this is a straightforward solution we

449
00:17:31,760 --> 00:17:34,080
are using c as a language

450
00:17:34,080 --> 00:17:37,600
that's why we will cover it by macrosis

451
00:17:37,600 --> 00:17:40,240
but only once i'll be glad to share with

452
00:17:40,240 --> 00:17:42,160
you how it works i can i believe you can

453
00:17:42,160 --> 00:17:43,520
take a picture

454
00:17:43,520 --> 00:17:46,960
and then see the details it's a lot of

455
00:17:46,960 --> 00:17:49,200
code here and it's not all of it

456
00:17:49,200 --> 00:17:51,039
so i believe we should consider the way

457
00:17:51,039 --> 00:17:53,440
these macros are going to

458
00:17:53,440 --> 00:17:54,960
work so

459
00:17:54,960 --> 00:17:56,799
that we have

460
00:17:56,799 --> 00:17:58,799
this signature function once in the

461
00:17:58,799 --> 00:18:01,200
kernel econom

462
00:18:01,679 --> 00:18:04,160
signature so that we don't uh

463
00:18:04,160 --> 00:18:06,640
have to

464
00:18:07,760 --> 00:18:09,440
think about it anymore

465
00:18:09,440 --> 00:18:11,760
okay

466
00:18:11,840 --> 00:18:15,120
we are called a macros for the signature

467
00:18:15,120 --> 00:18:17,200
or the function where we describe the

468
00:18:17,200 --> 00:18:18,960
arguments

469
00:18:18,960 --> 00:18:20,400
it will be

470
00:18:20,400 --> 00:18:22,480
dependent on the

471
00:18:22,480 --> 00:18:23,600
kernel

472
00:18:23,600 --> 00:18:25,360
version so the two things just one will

473
00:18:25,360 --> 00:18:27,120
receive for ptrx the other one will

474
00:18:27,120 --> 00:18:28,880
receive arguments

475
00:18:28,880 --> 00:18:31,520
and we'll have similar mattresses

476
00:18:31,520 --> 00:18:34,000
here it is

477
00:18:34,720 --> 00:18:35,760
there

478
00:18:35,760 --> 00:18:37,600
we'll be

479
00:18:37,600 --> 00:18:38,960
sending

480
00:18:38,960 --> 00:18:42,160
the number of the argument and it's a

481
00:18:42,160 --> 00:18:44,000
title in the signature function

482
00:18:44,000 --> 00:18:46,160
signature this way we'll see the body of

483
00:18:46,160 --> 00:18:47,280
the function

484
00:18:47,280 --> 00:18:49,360
how it would

485
00:18:49,360 --> 00:18:51,840
look natively so

486
00:18:51,840 --> 00:18:53,520
here you can see

487
00:18:53,520 --> 00:18:56,559
the ud has happened and we just equalize

488
00:18:56,559 --> 00:19:00,000
it i mean we kind of double

489
00:19:00,000 --> 00:19:02,160
the

490
00:19:02,559 --> 00:19:05,039
variable and it will be optimized in

491
00:19:05,039 --> 00:19:06,880
some registry

492
00:19:06,880 --> 00:19:09,200
and with the versions

493
00:19:09,200 --> 00:19:11,919
17 plus so we'll have everything and

494
00:19:11,919 --> 00:19:13,520
we'll optimize this

495
00:19:13,520 --> 00:19:16,080
so it's nothing to be afraid of

496
00:19:16,080 --> 00:19:18,480
so this is a brief argument related

497
00:19:18,480 --> 00:19:21,480
remark

498
00:19:28,320 --> 00:19:30,640
okay everything is nice and fluffy we

499
00:19:30,640 --> 00:19:33,840
have patched uh all the syscalls

500
00:19:33,840 --> 00:19:35,679
so if we cannot see any process in the

501
00:19:35,679 --> 00:19:37,840
system

502
00:19:37,840 --> 00:19:39,520
how come this happens

503
00:19:39,520 --> 00:19:41,760
so we can see the processes but we

504
00:19:41,760 --> 00:19:43,840
cannot see them in the

505
00:19:43,840 --> 00:19:45,760
old cores

506
00:19:45,760 --> 00:19:48,720
or kernels so why so

507
00:19:48,720 --> 00:19:51,120
we have tried to address the

508
00:19:51,120 --> 00:19:53,679
issue for quite some time and here is

509
00:19:53,679 --> 00:19:55,919
why

510
00:19:57,679 --> 00:19:58,640
so

511
00:19:58,640 --> 00:20:00,320
the previous versions

512
00:20:00,320 --> 00:20:03,840
310 and some minor updates so there we

513
00:20:03,840 --> 00:20:06,799
don't have a single syscall which will

514
00:20:06,799 --> 00:20:10,000
generate a process which wouldn't be

515
00:20:10,000 --> 00:20:12,640
wrapped into stamps

516
00:20:12,640 --> 00:20:15,200
so you can see austin steps so you can

517
00:20:15,200 --> 00:20:17,200
see the redefined from the top so we

518
00:20:17,200 --> 00:20:18,960
read the source what we see this is

519
00:20:18,960 --> 00:20:21,520
clone and says exact well as a matter of

520
00:20:21,520 --> 00:20:24,080
fact they are stubs

521
00:20:24,080 --> 00:20:27,200
where you see them in the cisco table we

522
00:20:27,200 --> 00:20:29,840
can find them through this is called

523
00:20:29,840 --> 00:20:31,280
lookup name

524
00:20:31,280 --> 00:20:34,320
but we will find this gibberish in the

525
00:20:34,320 --> 00:20:36,240
cisco table

526
00:20:36,240 --> 00:20:37,600
well

527
00:20:37,600 --> 00:20:38,559
nice

528
00:20:38,559 --> 00:20:41,840
okay but if we use this tab

529
00:20:41,840 --> 00:20:43,440
then the

530
00:20:43,440 --> 00:20:46,640
kernel will fail why so

531
00:20:46,640 --> 00:20:48,960
well it's not really clear

532
00:20:48,960 --> 00:20:51,120
we have figured out it for

533
00:20:51,120 --> 00:20:54,000
some time

534
00:20:54,000 --> 00:20:55,440
and uh

535
00:20:55,440 --> 00:20:58,000
one might say that c5

536
00:20:58,000 --> 00:20:59,600
is the corporate

537
00:20:59,600 --> 00:21:02,640
but they are not implemented for x86 and

538
00:21:02,640 --> 00:21:05,200
they are not used for the

539
00:21:05,200 --> 00:21:06,799
linux

540
00:21:06,799 --> 00:21:07,840
kernel

541
00:21:07,840 --> 00:21:11,120
so that's why the major problem

542
00:21:11,120 --> 00:21:16,439
calling the failure is not now

543
00:21:19,280 --> 00:21:22,000
so maybe we have some work uh rounds

544
00:21:22,000 --> 00:21:22,799
there

545
00:21:22,799 --> 00:21:24,960
for the stat frame

546
00:21:24,960 --> 00:21:26,480
and

547
00:21:26,480 --> 00:21:27,360
so

548
00:21:27,360 --> 00:21:31,120
when you go to the process the generated

549
00:21:31,120 --> 00:21:33,280
process some frames are removed so if

550
00:21:33,280 --> 00:21:35,679
the hook is added then we have one more

551
00:21:35,679 --> 00:21:38,159
frame so it does not remove completely

552
00:21:38,159 --> 00:21:40,880
we have a data corruption somewhere and

553
00:21:40,880 --> 00:21:43,520
it all fails this problem has to be

554
00:21:43,520 --> 00:21:45,520
addressed we need to support all the

555
00:21:45,520 --> 00:21:49,280
versions of kernels okay what we'll do

556
00:21:49,280 --> 00:21:52,879
okay we'll patch the instructions

557
00:21:54,480 --> 00:21:57,520
yeah it's quite extreme

558
00:21:57,679 --> 00:22:01,039
doing the kernel development

559
00:22:01,120 --> 00:22:02,640
okay

560
00:22:02,640 --> 00:22:06,000
how am i going to do it okay

561
00:22:06,320 --> 00:22:07,520
well if it's

562
00:22:07,520 --> 00:22:09,360
ed 64 that's

563
00:22:09,360 --> 00:22:11,039
pretty straightforward to look at the

564
00:22:11,039 --> 00:22:13,440
listing of stops and in the middle we

565
00:22:13,440 --> 00:22:16,240
will see the jump or call instruction

566
00:22:16,240 --> 00:22:18,320
for x64

567
00:22:18,320 --> 00:22:21,440
we don't have an air jump far jump so

568
00:22:21,440 --> 00:22:24,400
the instructions will look the same and

569
00:22:24,400 --> 00:22:26,720
this will be five bytes and it's easy to

570
00:22:26,720 --> 00:22:29,840
find this so before that

571
00:22:29,840 --> 00:22:31,760
i talked about the

572
00:22:31,760 --> 00:22:33,280
call

573
00:22:33,280 --> 00:22:36,000
sys lookup name

574
00:22:36,000 --> 00:22:38,320
so button this way we'll find the size

575
00:22:38,320 --> 00:22:41,760
of the symbol so we'll find the exact e

576
00:22:41,760 --> 00:22:44,000
the size of it and go through this

577
00:22:44,000 --> 00:22:46,159
memory piece to find the instructions

578
00:22:46,159 --> 00:22:48,000
okay we have all the data

579
00:22:48,000 --> 00:22:52,000
we have the hook the address

580
00:22:53,440 --> 00:22:56,320
and we have the initial address of the

581
00:22:56,320 --> 00:22:59,600
initial syscall so we know

582
00:22:59,600 --> 00:23:00,480
where

583
00:23:00,480 --> 00:23:02,080
the call is going to

584
00:23:02,080 --> 00:23:03,120
jump

585
00:23:03,120 --> 00:23:06,080
now we know we can see the

586
00:23:06,080 --> 00:23:08,880
shift say plus bytes from the

587
00:23:08,880 --> 00:23:10,480
instruction

588
00:23:10,480 --> 00:23:13,039
so we just recode uh

589
00:23:13,039 --> 00:23:14,159
this uh

590
00:23:14,159 --> 00:23:15,840
shift we

591
00:23:15,840 --> 00:23:17,200
enumerated

592
00:23:17,200 --> 00:23:20,000
and this works

593
00:23:20,720 --> 00:23:23,720
enjoy

594
00:23:30,960 --> 00:23:32,240
okay

595
00:23:32,240 --> 00:23:34,000
the most difficult thing you remember

596
00:23:34,000 --> 00:23:36,159
climbing trees in your childhood you

597
00:23:36,159 --> 00:23:37,919
remember that going back from the tree

598
00:23:37,919 --> 00:23:39,919
is the trickiest thing to do

599
00:23:39,919 --> 00:23:41,200
so the

600
00:23:41,200 --> 00:23:43,120
in all this uh

601
00:23:43,120 --> 00:23:46,000
you know mass we have arranged in the

602
00:23:46,000 --> 00:23:47,039
kernel

603
00:23:47,039 --> 00:23:49,760
is to fix all of that you remember

604
00:23:49,760 --> 00:23:50,400
we

605
00:23:50,400 --> 00:23:53,200
had this requirement so this is uh live

606
00:23:53,200 --> 00:23:56,000
patching so we kind of uh

607
00:23:56,000 --> 00:23:58,640
replace the modules

608
00:23:58,640 --> 00:24:02,159
models as if nothing were happening okay

609
00:24:02,159 --> 00:24:03,760
the issue number one we don't know the

610
00:24:03,760 --> 00:24:05,200
context

611
00:24:05,200 --> 00:24:08,880
so when our hook is called it is found

612
00:24:08,880 --> 00:24:10,559
just like a syscall so we don't know who

613
00:24:10,559 --> 00:24:13,440
called it why they called it

614
00:24:13,440 --> 00:24:14,320
when

615
00:24:14,320 --> 00:24:15,840
they are going to call whether they are

616
00:24:15,840 --> 00:24:17,440
going to do it and whether they have

617
00:24:17,440 --> 00:24:18,799
really called it

618
00:24:18,799 --> 00:24:20,640
we will talk about it

619
00:24:20,640 --> 00:24:21,840
later

620
00:24:21,840 --> 00:24:24,240
it looks like that so this is

621
00:24:24,240 --> 00:24:27,720
a real frame

622
00:24:32,559 --> 00:24:35,120
okay

623
00:24:36,400 --> 00:24:38,720
we call the hook and then we call the

624
00:24:38,720 --> 00:24:40,640
original

625
00:24:40,640 --> 00:24:42,080
to maintain

626
00:24:42,080 --> 00:24:43,200
the kernel

627
00:24:43,200 --> 00:24:45,600
okay the process the

628
00:24:45,600 --> 00:24:47,200
the hook we call the original the

629
00:24:47,200 --> 00:24:49,120
original goes back to us and we return

630
00:24:49,120 --> 00:24:51,520
to the process

631
00:24:51,520 --> 00:24:53,600
okay what's wrong here

632
00:24:53,600 --> 00:24:55,520
what's going to happen if you want to

633
00:24:55,520 --> 00:24:57,360
update our account module

634
00:24:57,360 --> 00:24:58,400
to

635
00:24:58,400 --> 00:25:01,840
upload it

636
00:25:07,279 --> 00:25:11,559
part of the discussion is of the mic

637
00:25:21,520 --> 00:25:24,000
okay we have called the original the

638
00:25:24,000 --> 00:25:25,360
kernel module

639
00:25:25,360 --> 00:25:28,360
is

640
00:25:32,159 --> 00:25:34,240
our module is missing so the original

641
00:25:34,240 --> 00:25:36,880
will go to some trash memory it can be

642
00:25:36,880 --> 00:25:38,720
anything

643
00:25:38,720 --> 00:25:42,679
and this is pretty bad

644
00:25:43,120 --> 00:25:45,360
if you have face dishes like that

645
00:25:45,360 --> 00:25:47,679
there are some obvious things to mention

646
00:25:47,679 --> 00:25:48,960
so

647
00:25:48,960 --> 00:25:49,840
maybe

648
00:25:49,840 --> 00:25:52,000
we

649
00:25:52,000 --> 00:25:53,520
don't offload

650
00:25:53,520 --> 00:25:56,080
until the functions original functions

651
00:25:56,080 --> 00:25:56,799
are

652
00:25:56,799 --> 00:25:58,159
called

653
00:25:58,159 --> 00:26:00,159
so we just

654
00:26:00,159 --> 00:26:02,159
have

655
00:26:02,159 --> 00:26:05,279
the meters the meters

656
00:26:05,279 --> 00:26:07,120
are there to

657
00:26:07,120 --> 00:26:09,919
keep track of the calls and so on this

658
00:26:09,919 --> 00:26:11,039
is

659
00:26:11,039 --> 00:26:13,600
well kind of easy but there are some

660
00:26:13,600 --> 00:26:17,039
other issues any ideas

661
00:26:18,240 --> 00:26:20,080
for the high load service we want to be

662
00:26:20,080 --> 00:26:22,000
able to offload because we'll be called

663
00:26:22,000 --> 00:26:23,520
to offer

664
00:26:23,520 --> 00:26:25,840
and there are some other

665
00:26:25,840 --> 00:26:26,799
great

666
00:26:26,799 --> 00:26:27,600
but

667
00:26:27,600 --> 00:26:31,039
well things like accept and select read

668
00:26:31,039 --> 00:26:32,400
write

669
00:26:32,400 --> 00:26:34,559
for slow hdds

670
00:26:34,559 --> 00:26:39,279
so this is an issue we don't know

671
00:26:39,279 --> 00:26:41,279
the extent to which we've been called

672
00:26:41,279 --> 00:26:42,640
okay

673
00:26:42,640 --> 00:26:44,960
we have given

674
00:26:44,960 --> 00:26:47,919
the original function some control when

675
00:26:47,919 --> 00:26:49,520
will it go back

676
00:26:49,520 --> 00:26:51,840
maybe it will go to the task wait and

677
00:26:51,840 --> 00:26:54,640
then we'll be just waiting there but we

678
00:26:54,640 --> 00:26:55,919
need to offload

679
00:26:55,919 --> 00:26:57,120
okay

680
00:26:57,120 --> 00:26:59,600
we can wait

681
00:26:59,600 --> 00:27:00,640
and

682
00:27:00,640 --> 00:27:04,159
the call time problem is quite easy to

683
00:27:04,159 --> 00:27:07,520
be quickly solved

684
00:27:07,520 --> 00:27:09,520
but we can

685
00:27:09,520 --> 00:27:12,720
solve the problem with our continuous

686
00:27:12,720 --> 00:27:13,510
call

687
00:27:13,510 --> 00:27:14,799
[Music]

688
00:27:14,799 --> 00:27:18,799
okay we have some ideas

689
00:27:19,360 --> 00:27:22,479
well we can

690
00:27:23,360 --> 00:27:25,679
arrange it in such a way that the

691
00:27:25,679 --> 00:27:27,279
function we

692
00:27:27,279 --> 00:27:31,039
have offloaded shouldn't come to us

693
00:27:31,039 --> 00:27:32,480
but uh

694
00:27:32,480 --> 00:27:34,720
just go through us so i don't know

695
00:27:34,720 --> 00:27:37,360
whether you have

696
00:27:37,440 --> 00:27:40,399
solved these problems

697
00:27:42,240 --> 00:27:45,600
some theory how it works

698
00:27:46,720 --> 00:27:50,720
so we have this atomic meters and then

699
00:27:50,720 --> 00:27:52,799
when we are called we send the control

700
00:27:52,799 --> 00:27:54,480
to the original

701
00:27:54,480 --> 00:27:55,679
function but

702
00:27:55,679 --> 00:27:56,480
this

703
00:27:56,480 --> 00:27:57,679
meter is not

704
00:27:57,679 --> 00:27:59,279
adding up because we are not doing any

705
00:27:59,279 --> 00:28:00,960
job so the

706
00:28:00,960 --> 00:28:03,360
the function doesn't go to us it goes

707
00:28:03,360 --> 00:28:05,760
back so with the privacy code function

708
00:28:05,760 --> 00:28:07,760
this is not going to work but all the

709
00:28:07,760 --> 00:28:08,960
new calls

710
00:28:08,960 --> 00:28:12,240
will be properly proxied

711
00:28:12,240 --> 00:28:14,480
how

712
00:28:14,480 --> 00:28:16,960
this is

713
00:28:17,919 --> 00:28:20,960
this is all coded in c and in c we

714
00:28:20,960 --> 00:28:22,480
cannot do this

715
00:28:22,480 --> 00:28:24,080
okay then we should

716
00:28:24,080 --> 00:28:26,640
go to the assembler

717
00:28:26,640 --> 00:28:27,679
and

718
00:28:27,679 --> 00:28:29,760
work some tricks there

719
00:28:29,760 --> 00:28:32,080
okay

720
00:28:32,720 --> 00:28:35,760
every function has a stack frame

721
00:28:35,760 --> 00:28:38,480
this is a local warehouse with the

722
00:28:38,480 --> 00:28:39,760
classes

723
00:28:39,760 --> 00:28:42,720
and variables it's only for our function

724
00:28:42,720 --> 00:28:45,039
so

725
00:28:45,039 --> 00:28:48,960
there are the scope controls

726
00:28:51,279 --> 00:28:53,840
so what we need we need only the return

727
00:28:53,840 --> 00:28:56,799
address at the top of the stack

728
00:28:56,799 --> 00:28:58,880
so that's how they call us

729
00:28:58,880 --> 00:29:00,000
and uh

730
00:29:00,000 --> 00:29:01,360
this is the

731
00:29:01,360 --> 00:29:04,080
koli okay we take the previous stack

732
00:29:04,080 --> 00:29:05,279
pointer

733
00:29:05,279 --> 00:29:07,520
bring it to the waste point and push it

734
00:29:07,520 --> 00:29:10,918
to the stack

735
00:29:12,320 --> 00:29:13,120
so

736
00:29:13,120 --> 00:29:15,520
the call just brings the return address

737
00:29:15,520 --> 00:29:18,159
to the stack to the top of it and in the

738
00:29:18,159 --> 00:29:20,559
base pointer

739
00:29:20,559 --> 00:29:23,760
so we have

740
00:29:23,840 --> 00:29:24,640
this

741
00:29:24,640 --> 00:29:27,440
return address so rbp is the return base

742
00:29:27,440 --> 00:29:29,760
pointer and this is the foundation for

743
00:29:29,760 --> 00:29:31,360
our function stack

744
00:29:31,360 --> 00:29:32,640
so

745
00:29:32,640 --> 00:29:33,760
we

746
00:29:33,760 --> 00:29:35,200
kind of

747
00:29:35,200 --> 00:29:37,360
well we remove this frame

748
00:29:37,360 --> 00:29:38,960
so we don't have

749
00:29:38,960 --> 00:29:42,159
the return of the function so that

750
00:29:42,159 --> 00:29:43,760
when they return the function we called

751
00:29:43,760 --> 00:29:46,399
when the frame of the function is gone

752
00:29:46,399 --> 00:29:47,919
the return address

753
00:29:47,919 --> 00:29:50,960
should go to the process which called us

754
00:29:50,960 --> 00:29:53,760
is clear enough

755
00:29:53,840 --> 00:29:55,840
okay

756
00:29:55,840 --> 00:29:58,639
here is some

757
00:29:58,799 --> 00:30:00,559
illustration to help you

758
00:30:00,559 --> 00:30:03,360
how we can sort it out

759
00:30:03,360 --> 00:30:05,840
okay this is the invoke syscall so it's

760
00:30:05,840 --> 00:30:08,480
calling us we call something something

761
00:30:08,480 --> 00:30:11,520
cis so it goes back here because we

762
00:30:11,520 --> 00:30:13,120
destroy the stack

763
00:30:13,120 --> 00:30:15,120
how do we do it so if you don't know the

764
00:30:15,120 --> 00:30:16,720
assembler can tell you

765
00:30:16,720 --> 00:30:20,240
we just push for bytes

766
00:30:20,240 --> 00:30:23,679
this is the minimal so here it says 8

767
00:30:23,679 --> 00:30:25,919
but we can even

768
00:30:25,919 --> 00:30:28,640
take 8. so we remove the stack

769
00:30:28,640 --> 00:30:29,600
until

770
00:30:29,600 --> 00:30:30,960
we reach

771
00:30:30,960 --> 00:30:32,240
the base

772
00:30:32,240 --> 00:30:35,240
pointer

773
00:30:43,440 --> 00:30:46,640
okay we find the best pointer okay the

774
00:30:46,640 --> 00:30:50,640
frame is destroyed so this should work

775
00:30:50,640 --> 00:30:53,360
and this really works

776
00:30:53,360 --> 00:30:56,799
but not always and here is why

777
00:30:58,240 --> 00:31:00,880
when we build the kernel module we

778
00:31:00,880 --> 00:31:02,799
cannot always control

779
00:31:02,799 --> 00:31:03,600
the

780
00:31:03,600 --> 00:31:06,799
flag sometimes the compiler starts to

781
00:31:06,799 --> 00:31:10,240
over optimize our code like squeezing

782
00:31:10,240 --> 00:31:12,320
the variables sometimes they don't align

783
00:31:12,320 --> 00:31:14,159
them sometimes they align it

784
00:31:14,159 --> 00:31:16,399
in the wrong way and we can just miss it

785
00:31:16,399 --> 00:31:19,360
okay in rbp we will

786
00:31:19,360 --> 00:31:22,240
have the frame we need but we'll never

787
00:31:22,240 --> 00:31:25,360
find it with the stack and the small

788
00:31:25,360 --> 00:31:28,480
routine will destroy the whole kernel

789
00:31:28,480 --> 00:31:32,440
and we don't really want it

790
00:31:32,559 --> 00:31:35,200
okay how to solve the problem

791
00:31:35,200 --> 00:31:37,679
number one

792
00:31:37,679 --> 00:31:40,000
don't do it this way

793
00:31:40,000 --> 00:31:42,080
the shorter the code the better so this

794
00:31:42,080 --> 00:31:45,120
was a kind of a workaround method so

795
00:31:45,120 --> 00:31:46,960
let's uh remember

796
00:31:46,960 --> 00:31:49,039
the compiler doing it on compiling so

797
00:31:49,039 --> 00:31:50,480
they use this

798
00:31:50,480 --> 00:31:52,559
leaf instruction

799
00:31:52,559 --> 00:31:54,159
okay let's uh

800
00:31:54,159 --> 00:31:56,720
go to the gcc

801
00:31:56,720 --> 00:31:58,159
documents

802
00:31:58,159 --> 00:32:01,679
there we have a short routine describing

803
00:32:01,679 --> 00:32:04,240
the way the leaf instruction works so

804
00:32:04,240 --> 00:32:08,720
it's all pre-coded for us that's nice

805
00:32:08,799 --> 00:32:11,279
so we can

806
00:32:11,760 --> 00:32:14,399
entrust the compiler with doing it

807
00:32:14,399 --> 00:32:15,519
so

808
00:32:15,519 --> 00:32:18,000
pros all around and this is a working

809
00:32:18,000 --> 00:32:19,440
algorithm so

810
00:32:19,440 --> 00:32:21,279
the second version of the frame looks

811
00:32:21,279 --> 00:32:23,760
like that okay we call the leaf

812
00:32:23,760 --> 00:32:26,880
instruction we pop rbp

813
00:32:26,880 --> 00:32:28,880
we update ranks and we jump to the

814
00:32:28,880 --> 00:32:32,240
original function and our frame

815
00:32:32,240 --> 00:32:34,480
kind of disappears

816
00:32:34,480 --> 00:32:37,279
does it really work

817
00:32:38,799 --> 00:32:41,360
okay if we wanted this then it works

818
00:32:41,360 --> 00:32:45,120
so this is colonel painting by the way

819
00:32:45,360 --> 00:32:46,799
okay

820
00:32:46,799 --> 00:32:48,399
we can see the panic

821
00:32:48,399 --> 00:32:50,640
we can see the

822
00:32:50,640 --> 00:32:53,120
null point the reference well it's not

823
00:32:53,120 --> 00:32:55,440
truly that it's kind of written some

824
00:32:55,440 --> 00:32:56,399
wrong

825
00:32:56,399 --> 00:32:58,240
variable from somewhere okay we look at

826
00:32:58,240 --> 00:33:00,159
the register and we see that in the rp

827
00:33:00,159 --> 00:33:02,640
we have the

828
00:33:02,799 --> 00:33:03,760
non

829
00:33:03,760 --> 00:33:06,399
clinic address so the chronic addresses

830
00:33:06,399 --> 00:33:09,600
are always used by the kernel as

831
00:33:09,600 --> 00:33:12,559
segments of the text

832
00:33:13,360 --> 00:33:14,240
okay

833
00:33:14,240 --> 00:33:15,279
no

834
00:33:15,279 --> 00:33:17,919
extra detail here so we can see that the

835
00:33:17,919 --> 00:33:19,840
address

836
00:33:19,840 --> 00:33:22,080
is

837
00:33:22,240 --> 00:33:24,320
wrong it is not canonic it doesn't

838
00:33:24,320 --> 00:33:29,519
belong to our frame so why it's in rbp

839
00:33:32,720 --> 00:33:34,480
let's proceed

840
00:33:34,480 --> 00:33:37,960
this is an article

841
00:33:38,480 --> 00:33:41,360
okay shall we

842
00:33:41,360 --> 00:33:43,039
get discouraged

843
00:33:43,039 --> 00:33:45,600
okay that's kind of a man

844
00:33:45,600 --> 00:33:48,240
why does it happen

845
00:33:48,399 --> 00:33:51,120
we cannot completely control the

846
00:33:51,120 --> 00:33:53,519
compiling of flex sometimes the compiler

847
00:33:53,519 --> 00:33:55,440
overdoes it

848
00:33:55,440 --> 00:33:58,080
and in some functions we don't have the

849
00:33:58,080 --> 00:34:01,199
preface to

850
00:34:01,760 --> 00:34:04,080
keep our frame why

851
00:34:04,080 --> 00:34:04,840
the

852
00:34:04,840 --> 00:34:07,519
x64 architecture

853
00:34:07,519 --> 00:34:09,599
well does it really need this preface

854
00:34:09,599 --> 00:34:11,119
this is a kind of

855
00:34:11,119 --> 00:34:13,199
rudiment

856
00:34:13,199 --> 00:34:14,879
okay we have it for the old versions of

857
00:34:14,879 --> 00:34:16,879
the compilers and in the new ones if you

858
00:34:16,879 --> 00:34:18,480
are going to use them and we are most

859
00:34:18,480 --> 00:34:21,040
likely to do it because

860
00:34:21,040 --> 00:34:23,040
we know good customers keep track of the

861
00:34:23,040 --> 00:34:25,599
kernel versions we will not see any

862
00:34:25,599 --> 00:34:28,000
preface

863
00:34:28,000 --> 00:34:31,040
and the kernel can be

864
00:34:31,040 --> 00:34:32,159
built

865
00:34:32,159 --> 00:34:35,119
by the position independent uh code

866
00:34:35,119 --> 00:34:35,918
uh

867
00:34:35,918 --> 00:34:37,280
flags

868
00:34:37,280 --> 00:34:39,918
where area fifth uh instruction they

869
00:34:39,918 --> 00:34:41,520
will call themselves

870
00:34:41,520 --> 00:34:42,560
to

871
00:34:42,560 --> 00:34:44,159
maintain the

872
00:34:44,159 --> 00:34:45,520
position

873
00:34:45,520 --> 00:34:48,879
with the stack but we need the preface

874
00:34:48,879 --> 00:34:49,679
since

875
00:34:49,679 --> 00:34:51,040
all the

876
00:34:51,040 --> 00:34:52,159
algorithm

877
00:34:52,159 --> 00:34:54,000
of removing the frame

878
00:34:54,000 --> 00:34:55,440
is related

879
00:34:55,440 --> 00:34:57,680
to the fact that we want to have the

880
00:34:57,680 --> 00:35:00,480
address of the frame

881
00:35:00,480 --> 00:35:03,680
and now we are fighting with gcc

882
00:35:03,680 --> 00:35:06,160
i'd like to thank dcc

883
00:35:06,160 --> 00:35:08,800
for giving us weapons to find against

884
00:35:08,800 --> 00:35:09,839
them

885
00:35:09,839 --> 00:35:13,279
okay we want to

886
00:35:14,079 --> 00:35:17,040
leave no choice for the compiler

887
00:35:17,040 --> 00:35:17,839
but

888
00:35:17,839 --> 00:35:20,000
to

889
00:35:20,079 --> 00:35:22,320
build a preface for us

890
00:35:22,320 --> 00:35:24,800
okay when compiling we can make the

891
00:35:24,800 --> 00:35:26,240
compiler

892
00:35:26,240 --> 00:35:29,440
calculate the address of the frame

893
00:35:29,440 --> 00:35:32,640
okay this base pointer the base is not

894
00:35:32,640 --> 00:35:33,440
really

895
00:35:33,440 --> 00:35:36,079
always necessary but when we call this

896
00:35:36,079 --> 00:35:38,400
and this is uh

897
00:35:38,400 --> 00:35:40,800
done in the compilation process so when

898
00:35:40,800 --> 00:35:43,200
we call this function we force the

899
00:35:43,200 --> 00:35:45,839
compiler to calculate where the frame

900
00:35:45,839 --> 00:35:48,160
ends

901
00:35:48,480 --> 00:35:51,440
and we have a kind of warning there

902
00:35:51,440 --> 00:35:53,359
oh please don't do this

903
00:35:53,359 --> 00:35:55,119
but this is

904
00:35:55,119 --> 00:35:56,560
about

905
00:35:56,560 --> 00:35:58,800
our attempts to get the higher frames

906
00:35:58,800 --> 00:36:00,480
but we don't need any higher frames we

907
00:36:00,480 --> 00:36:02,400
need only our frame so

908
00:36:02,400 --> 00:36:03,839
it is seemingly

909
00:36:03,839 --> 00:36:06,640
secure okay this is the final version

910
00:36:06,640 --> 00:36:08,960
which really works

911
00:36:08,960 --> 00:36:12,320
well but it fails of course the journal

912
00:36:12,320 --> 00:36:14,640
failure

913
00:36:15,359 --> 00:36:18,079
okay the reason

914
00:36:18,079 --> 00:36:19,119
okay

915
00:36:19,119 --> 00:36:21,119
why

916
00:36:21,119 --> 00:36:23,359
why another failure

917
00:36:23,359 --> 00:36:24,839
here is where we

918
00:36:24,839 --> 00:36:27,839
store our data

919
00:36:27,839 --> 00:36:29,200
similarly

920
00:36:29,200 --> 00:36:32,640
these are some registries like r15

921
00:36:32,640 --> 00:36:35,440
and we have some base registers and we

922
00:36:35,440 --> 00:36:37,680
have these r registries

923
00:36:37,680 --> 00:36:41,839
so they are seemingly useless

924
00:36:42,480 --> 00:36:45,119
but that's only on the face of it

925
00:36:45,119 --> 00:36:48,079
they are really useful

926
00:36:50,720 --> 00:36:52,400
we have the caller

927
00:36:52,400 --> 00:36:56,240
safe concept which means that some

928
00:36:56,240 --> 00:36:58,079
registries

929
00:36:58,079 --> 00:37:00,480
for the callers and colleagues should be

930
00:37:00,480 --> 00:37:01,760
stored

931
00:37:01,760 --> 00:37:02,640
or

932
00:37:02,640 --> 00:37:04,960
recovered when you go back when you

933
00:37:04,960 --> 00:37:06,720
return from the function

934
00:37:06,720 --> 00:37:09,040
what does it mean we have abused this

935
00:37:09,040 --> 00:37:11,760
registers to save the data

936
00:37:11,760 --> 00:37:15,680
okay we can save some other registers

937
00:37:15,680 --> 00:37:17,040
or it shouldn't be

938
00:37:17,040 --> 00:37:19,119
saved in the call

939
00:37:19,119 --> 00:37:21,920
anyway it will be destroyed all of it

940
00:37:21,920 --> 00:37:23,680
okay we're not going to use them but

941
00:37:23,680 --> 00:37:26,240
they'll be used by the compiler anyway

942
00:37:26,240 --> 00:37:27,839
and we

943
00:37:27,839 --> 00:37:29,040
say

944
00:37:29,040 --> 00:37:30,560
why

945
00:37:30,560 --> 00:37:33,920
the compiler are you using the registers

946
00:37:33,920 --> 00:37:36,000
you shouldn't be using or you should be

947
00:37:36,000 --> 00:37:38,880
restoring them but it does restore them

948
00:37:38,880 --> 00:37:41,040
but it restores them

949
00:37:41,040 --> 00:37:44,320
at the normal return we are not using

950
00:37:44,320 --> 00:37:46,800
you remember

951
00:37:47,440 --> 00:37:49,040
to reduce this

952
00:37:49,040 --> 00:37:52,240
load on the atomic

953
00:37:52,240 --> 00:37:53,520
meters

954
00:37:53,520 --> 00:37:55,359
we destroy the frame completely and then

955
00:37:55,359 --> 00:37:57,359
we do the jump we don't have any return

956
00:37:57,359 --> 00:37:59,440
the compiler when compiling this

957
00:37:59,440 --> 00:38:02,000
uh just leaves the code as it is

958
00:38:02,000 --> 00:38:03,599
well

959
00:38:03,599 --> 00:38:06,320
restoring this registers manually well

960
00:38:06,320 --> 00:38:07,760
we don't know what the compiler is going

961
00:38:07,760 --> 00:38:10,240
to compile

962
00:38:11,680 --> 00:38:13,599
what can we do about it

963
00:38:13,599 --> 00:38:16,480
those who use c for coding what are the

964
00:38:16,480 --> 00:38:20,320
ideas to go around the problem

965
00:38:24,640 --> 00:38:26,480
part of the discussion is oh the mic

966
00:38:26,480 --> 00:38:28,480
well you know in hooks we usually have

967
00:38:28,480 --> 00:38:30,560
other things happening

968
00:38:30,560 --> 00:38:34,320
okay we can have the stub you can

969
00:38:34,320 --> 00:38:38,400
link it by c and call some other

970
00:38:38,400 --> 00:38:41,040
function but this is a lot of effort we

971
00:38:41,040 --> 00:38:44,079
want it to be uh faster

972
00:38:44,079 --> 00:38:45,200
and

973
00:38:45,200 --> 00:38:47,280
cheaper so we are

974
00:38:47,280 --> 00:38:51,079
talking about business here

975
00:39:03,839 --> 00:39:04,640
okay

976
00:39:04,640 --> 00:39:06,640
we

977
00:39:06,640 --> 00:39:09,119
wait okay

978
00:39:09,119 --> 00:39:11,680
we will not unload from the high load

979
00:39:11,680 --> 00:39:13,520
servers

980
00:39:13,520 --> 00:39:16,320
microphone please

981
00:39:17,599 --> 00:39:20,640
okay we will not load until we have

982
00:39:20,640 --> 00:39:22,480
unloaded

983
00:39:22,480 --> 00:39:24,720
linux will not let us do this

984
00:39:24,720 --> 00:39:28,040
patch yourself

985
00:39:28,880 --> 00:39:33,280
well patching yourself is a good idea

986
00:39:34,800 --> 00:39:37,200
until you start bringing packages which

987
00:39:37,200 --> 00:39:38,480
i came

988
00:39:38,480 --> 00:39:40,880
must build because you have the rotate

989
00:39:40,880 --> 00:39:43,359
of self rotating

990
00:39:43,359 --> 00:39:45,280
cycles of

991
00:39:45,280 --> 00:39:48,720
self patching and the

992
00:39:49,280 --> 00:39:50,720
cold table

993
00:39:50,720 --> 00:39:53,760
will be destroyed this way by this

994
00:39:53,760 --> 00:39:56,720
random addresses okay

995
00:39:56,720 --> 00:39:57,920
we have a good

996
00:39:57,920 --> 00:39:59,359
solution from

997
00:39:59,359 --> 00:40:00,160
c

998
00:40:00,160 --> 00:40:03,119
and it is volatile

999
00:40:03,119 --> 00:40:06,480
it tells the compiler

1000
00:40:07,359 --> 00:40:09,119
that this registers shouldn't be used

1001
00:40:09,119 --> 00:40:11,359
because if you use them

1002
00:40:11,359 --> 00:40:12,960
your hardware

1003
00:40:12,960 --> 00:40:15,839
will be damaged and this works all our

1004
00:40:15,839 --> 00:40:16,720
hooks

1005
00:40:16,720 --> 00:40:19,839
are in the c file

1006
00:40:20,480 --> 00:40:22,800
so when we have this variable so

1007
00:40:22,800 --> 00:40:25,040
this is not

1008
00:40:25,040 --> 00:40:26,160
seen

1009
00:40:26,160 --> 00:40:27,839
so we tell the compiler that for this

1010
00:40:27,839 --> 00:40:30,480
file you don't use these registers okay

1011
00:40:30,480 --> 00:40:32,880
this can

1012
00:40:33,040 --> 00:40:35,839
reduce the performance and it will give

1013
00:40:35,839 --> 00:40:38,160
us some stability so we can reduce the

1014
00:40:38,160 --> 00:40:40,720
performance in some small routine

1015
00:40:40,720 --> 00:40:42,319
of the hook

1016
00:40:42,319 --> 00:40:44,640
okay this works really well it looks

1017
00:40:44,640 --> 00:40:45,680
like that

1018
00:40:45,680 --> 00:40:47,520
so all these purchases are locked and

1019
00:40:47,520 --> 00:40:49,359
the compiler will try to do its best to

1020
00:40:49,359 --> 00:40:50,319
go

1021
00:40:50,319 --> 00:40:52,160
around them because

1022
00:40:52,160 --> 00:40:54,720
touching them is forbidden

1023
00:40:54,720 --> 00:40:57,040
well at this very point

1024
00:40:57,040 --> 00:40:58,880
i'm concluding

1025
00:40:58,880 --> 00:41:00,800
and i can tell you that this is the

1026
00:41:00,800 --> 00:41:03,359
latest hack which does

1027
00:41:03,359 --> 00:41:05,040
work

1028
00:41:05,040 --> 00:41:06,400
thank you for your attention

1029
00:41:06,400 --> 00:41:08,800
and you are welcome with your questions

1030
00:41:08,800 --> 00:41:12,349
[Applause]

1031
00:41:18,839 --> 00:41:21,040
hello thank you

1032
00:41:21,040 --> 00:41:23,359
you said that

1033
00:41:23,359 --> 00:41:25,760
you can pause

1034
00:41:25,760 --> 00:41:28,160
all the process and change

1035
00:41:28,160 --> 00:41:31,359
the target cpu right right

1036
00:41:31,359 --> 00:41:32,880
okay

1037
00:41:32,880 --> 00:41:35,599
maybe you stopped it at some bad time

1038
00:41:35,599 --> 00:41:38,079
maybe the cpu is uh kind of copying

1039
00:41:38,079 --> 00:41:40,079
something and you want to

1040
00:41:40,079 --> 00:41:42,640
change it so it's on pause you change it

1041
00:41:42,640 --> 00:41:48,118
and uh the cpu has the old

1042
00:41:50,960 --> 00:41:53,520
well we should clearly understand what

1043
00:41:53,520 --> 00:41:57,280
kind of pointer we are changing

1044
00:41:57,280 --> 00:41:59,200
okay

1045
00:41:59,200 --> 00:42:01,440
we are changing

1046
00:42:01,440 --> 00:42:03,119
the read once

1047
00:42:03,119 --> 00:42:06,640
cisco table so it will be read once and

1048
00:42:06,640 --> 00:42:08,480
it is not likely to be

1049
00:42:08,480 --> 00:42:10,720
reread

1050
00:42:10,720 --> 00:42:11,920
before

1051
00:42:11,920 --> 00:42:14,480
channeling their workflow okay the point

1052
00:42:14,480 --> 00:42:16,800
is to patch they're usually

1053
00:42:16,800 --> 00:42:19,760
the structures in vss and in networks in

1054
00:42:19,760 --> 00:42:22,079
the drivers i mean

1055
00:42:22,079 --> 00:42:25,920
mcs operations socket operations

1056
00:42:25,920 --> 00:42:29,040
skb operations they are also red ones

1057
00:42:29,040 --> 00:42:31,760
so they're red ones and have no further

1058
00:42:31,760 --> 00:42:33,359
impact so we don't have any conflicts

1059
00:42:33,359 --> 00:42:35,440
like that

1060
00:42:35,440 --> 00:42:37,040
anything else

1061
00:42:37,040 --> 00:42:39,440
thank you

1062
00:42:41,839 --> 00:42:43,760
you said that you want to destroy the

1063
00:42:43,760 --> 00:42:46,400
stack frame so you go up to the stack

1064
00:42:46,400 --> 00:42:48,960
until you reach the address

1065
00:42:48,960 --> 00:42:52,960
you know and if you find the eight bytes

1066
00:42:52,960 --> 00:42:54,720
matching the address

1067
00:42:54,720 --> 00:42:56,880
so will you recover the registers from

1068
00:42:56,880 --> 00:42:59,680
the previous function you jump back and

1069
00:42:59,680 --> 00:43:02,079
then you have a failure can it happen

1070
00:43:02,079 --> 00:43:04,000
that's a good example

1071
00:43:04,000 --> 00:43:05,680
and a good question

1072
00:43:05,680 --> 00:43:09,720
let me go back to this slide

1073
00:43:14,079 --> 00:43:17,520
assuming the issue might pop up here

1074
00:43:17,520 --> 00:43:19,200
and the same

1075
00:43:19,200 --> 00:43:21,520
value can be here

1076
00:43:21,520 --> 00:43:25,800
but the solution is different

1077
00:43:27,359 --> 00:43:29,760
with built in to the frame address so it

1078
00:43:29,760 --> 00:43:31,440
shouldn't be there but for the first

1079
00:43:31,440 --> 00:43:33,839
version indeed

1080
00:43:33,839 --> 00:43:35,599
it is not right

1081
00:43:35,599 --> 00:43:38,079
and it was discarded on day one

1082
00:43:38,079 --> 00:43:41,319
it is problematic

1083
00:44:00,000 --> 00:44:02,640
thank you really exciting

1084
00:44:02,640 --> 00:44:04,319
one of the most exciting speeches i

1085
00:44:04,319 --> 00:44:07,480
would say

1086
00:44:08,000 --> 00:44:12,480
have you tried to bring together icc

1087
00:44:12,480 --> 00:44:14,319
your dispatcher

1088
00:44:14,319 --> 00:44:17,119
needs a lot of performance

1089
00:44:17,119 --> 00:44:18,319
so

1090
00:44:18,319 --> 00:44:20,800
in uh c you cannot see this

1091
00:44:20,800 --> 00:44:23,599
great opportunities

1092
00:44:23,599 --> 00:44:24,720
thank you

1093
00:44:24,720 --> 00:44:27,200
thank you for the question

1094
00:44:27,200 --> 00:44:28,800
this is a great question

1095
00:44:28,800 --> 00:44:30,480
i believe that the kernel should be

1096
00:44:30,480 --> 00:44:33,200
rebuilt using clank but the longer you

1097
00:44:33,200 --> 00:44:34,720
dig into

1098
00:44:34,720 --> 00:44:36,880
the kernel you start understanding

1099
00:44:36,880 --> 00:44:38,319
it's a

1100
00:44:38,319 --> 00:44:41,119
gcc related to large extent this is

1101
00:44:41,119 --> 00:44:44,000
impossible so when we deliver the

1102
00:44:44,000 --> 00:44:46,640
rpn depth package or anything

1103
00:44:46,640 --> 00:44:48,720
when we send this package to the

1104
00:44:48,720 --> 00:44:51,280
customer and the package you'll have the

1105
00:44:51,280 --> 00:44:52,880
dependency on the

1106
00:44:52,880 --> 00:44:54,960
kms the package manager will quickly

1107
00:44:54,960 --> 00:44:56,560
understand

1108
00:44:56,560 --> 00:44:59,200
that we need a compiler to

1109
00:44:59,200 --> 00:45:01,200
download chrome develop and gcc will be

1110
00:45:01,200 --> 00:45:03,200
that okay we can try to use k-link and

1111
00:45:03,200 --> 00:45:04,319
we can say that this is better to

1112
00:45:04,319 --> 00:45:07,119
optimize the code

1113
00:45:07,119 --> 00:45:08,240
it is not

1114
00:45:08,240 --> 00:45:09,760
likely to happen

1115
00:45:09,760 --> 00:45:12,160
theoretically yes but we haven't

1116
00:45:12,160 --> 00:45:14,240
experimented there

1117
00:45:14,240 --> 00:45:15,520
since uh

1118
00:45:15,520 --> 00:45:16,960
we don't have any

1119
00:45:16,960 --> 00:45:19,200
business need in it so we'll be using

1120
00:45:19,200 --> 00:45:20,560
gcc

1121
00:45:20,560 --> 00:45:23,359
for build for the next 100 years before

1122
00:45:23,359 --> 00:45:25,359
the colonel moves to

1123
00:45:25,359 --> 00:45:27,280
k-lang

1124
00:45:27,280 --> 00:45:30,240
okay thank you

1125
00:45:30,640 --> 00:45:32,960
i believe clank is already used because

1126
00:45:32,960 --> 00:45:35,440
i believe clank is supporting all the

1127
00:45:35,440 --> 00:45:36,560
gcc

1128
00:45:36,560 --> 00:45:39,119
extensions well we do use it for builds

1129
00:45:39,119 --> 00:45:42,000
just like uh crust

1130
00:45:42,000 --> 00:45:42,960
in the

1131
00:45:42,960 --> 00:45:45,440
kernel okay and the kernel has a

1132
00:45:45,440 --> 00:45:48,960
mechanism for hot updates so have you

1133
00:45:48,960 --> 00:45:52,240
seen how they work have you tried to

1134
00:45:52,240 --> 00:45:55,839
do this rather than reinvent the wheel

1135
00:45:55,839 --> 00:45:57,520
another good question if you talk about

1136
00:45:57,520 --> 00:45:59,359
canonical live patch

1137
00:45:59,359 --> 00:46:01,520
yeah most likely okay

1138
00:46:01,520 --> 00:46:03,440
they have a different approach they

1139
00:46:03,440 --> 00:46:05,200
build their

1140
00:46:05,200 --> 00:46:07,599
objects and they re-link

1141
00:46:07,599 --> 00:46:08,480
the

1142
00:46:08,480 --> 00:46:09,680
kernel

1143
00:46:09,680 --> 00:46:12,079
in operation it's not

1144
00:46:12,079 --> 00:46:14,000
our approach when we load our kernel

1145
00:46:14,000 --> 00:46:15,359
model we

1146
00:46:15,359 --> 00:46:17,359
load our product we don't modify the

1147
00:46:17,359 --> 00:46:18,240
kernel

1148
00:46:18,240 --> 00:46:19,839
the goal is not

1149
00:46:19,839 --> 00:46:22,480
to patch a critical vulnerability the

1150
00:46:22,480 --> 00:46:26,319
goal is to upload a module to patch the

1151
00:46:26,319 --> 00:46:29,520
kernel and give us more information

1152
00:46:29,520 --> 00:46:31,680
that's why the way canonical live patch

1153
00:46:31,680 --> 00:46:33,920
works well this is a proprietary product

1154
00:46:33,920 --> 00:46:36,960
it's not available and the live patch

1155
00:46:36,960 --> 00:46:40,160
the kernel patch which is open source

1156
00:46:40,160 --> 00:46:41,520
then read me

1157
00:46:41,520 --> 00:46:42,720
me they say

1158
00:46:42,720 --> 00:46:45,280
you do it at apparel and it brings

1159
00:46:45,280 --> 00:46:47,040
together the objects based on the patch

1160
00:46:47,040 --> 00:46:49,440
so you download all the source code you

1161
00:46:49,440 --> 00:46:50,960
use the patch you

1162
00:46:50,960 --> 00:46:55,040
bring the objects and then you

1163
00:46:55,040 --> 00:46:58,240
try to fix the running

1164
00:46:58,240 --> 00:47:00,000
kernel but it is fixing the kernel but

1165
00:47:00,000 --> 00:47:03,599
we are fixing the product

1166
00:47:04,000 --> 00:47:06,800
okay so you bring together the objects

1167
00:47:06,800 --> 00:47:08,000
which

1168
00:47:08,000 --> 00:47:10,880
have the syscalls then you replace them

1169
00:47:10,880 --> 00:47:15,200
and then you unload and patch again

1170
00:47:15,359 --> 00:47:16,160
well

1171
00:47:16,160 --> 00:47:18,480
this is uh

1172
00:47:18,480 --> 00:47:21,920
you know over doing it uh it's much more

1173
00:47:21,920 --> 00:47:26,720
complicated than this approach okay

1174
00:47:27,359 --> 00:47:28,880
two questions

1175
00:47:28,880 --> 00:47:31,760
have you compared

1176
00:47:32,000 --> 00:47:33,839
your performance

1177
00:47:33,839 --> 00:47:35,119
with

1178
00:47:35,119 --> 00:47:38,480
the other hooks and uh their

1179
00:47:38,480 --> 00:47:40,000
instruction patching so you patch the

1180
00:47:40,000 --> 00:47:42,240
instruction if at this very time

1181
00:47:42,240 --> 00:47:44,480
we have a process in the same address

1182
00:47:44,480 --> 00:47:46,079
performing the same

1183
00:47:46,079 --> 00:47:47,119
function

1184
00:47:47,119 --> 00:47:50,559
okay i'll start with the latter question

1185
00:47:50,559 --> 00:47:54,640
i didn't mention that

1186
00:47:55,520 --> 00:47:58,000
the smp mechanism

1187
00:47:58,000 --> 00:48:01,920
we use for the cpus to wait

1188
00:48:01,920 --> 00:48:04,319
are used

1189
00:48:04,319 --> 00:48:06,400
for patching the instructions it works

1190
00:48:06,400 --> 00:48:08,400
the same way

1191
00:48:08,400 --> 00:48:10,640
so

1192
00:48:11,359 --> 00:48:12,559
we

1193
00:48:12,559 --> 00:48:14,720
don't see the change of address causing

1194
00:48:14,720 --> 00:48:17,760
the mismatch of cash okay so you change

1195
00:48:17,760 --> 00:48:21,839
the 4 bytes yes we change for bytes

1196
00:48:23,119 --> 00:48:25,040
anyway

1197
00:48:25,040 --> 00:48:28,240
i understand what you're driving at

1198
00:48:28,240 --> 00:48:30,640
if we change more for more tanks it'll

1199
00:48:30,640 --> 00:48:32,880
be an issue but we

1200
00:48:32,880 --> 00:48:34,880
need to jump to some other place

1201
00:48:34,880 --> 00:48:36,640
and please remind me of the first

1202
00:48:36,640 --> 00:48:38,960
question

1203
00:48:38,960 --> 00:48:42,800
well performance the hooks

1204
00:48:42,880 --> 00:48:44,079
the

1205
00:48:44,079 --> 00:48:46,480
springboards we have

1206
00:48:46,480 --> 00:48:49,480
they

1207
00:48:49,530 --> 00:48:52,579
[Music]

1208
00:48:55,280 --> 00:48:57,760
doing a lot of work

1209
00:48:57,760 --> 00:49:00,319
well we'll impact the performance

1210
00:49:00,319 --> 00:49:02,400
big stand

1211
00:49:02,400 --> 00:49:06,240
well i believe uh 10 percent

1212
00:49:07,440 --> 00:49:10,079
we are trying to address it

1213
00:49:10,079 --> 00:49:11,760
so that

1214
00:49:11,760 --> 00:49:14,319
as many heavy-duty tasks like

1215
00:49:14,319 --> 00:49:17,200
renumerating hashes

1216
00:49:17,200 --> 00:49:19,920
should go to some co-workers which are

1217
00:49:19,920 --> 00:49:21,520
not going to be

1218
00:49:21,520 --> 00:49:23,920
in between

1219
00:49:23,920 --> 00:49:25,440
hopefully i have answered your question

1220
00:49:25,440 --> 00:49:28,079
the performance goes down but we

1221
00:49:28,079 --> 00:49:32,480
optimize the kernel to avoid a big drop

1222
00:49:32,480 --> 00:49:34,000
in performance

1223
00:49:34,000 --> 00:49:35,920
time's up let's pick the most

1224
00:49:35,920 --> 00:49:38,720
interesting question

1225
00:49:41,599 --> 00:49:44,559
all the questions have been interesting

1226
00:49:44,559 --> 00:49:46,880
okay

1227
00:49:47,599 --> 00:49:49,760
i had to think

1228
00:49:49,760 --> 00:49:53,040
i liked this object files question

1229
00:49:53,040 --> 00:49:55,520
uh can i pick two or only one

1230
00:49:55,520 --> 00:49:58,839
only one

1231
00:50:03,119 --> 00:50:06,960
okay then the object files question

1232
00:50:09,359 --> 00:50:13,000
thank you very much for attention

1233
00:50:13,520 --> 00:50:15,119
i'll be there to answer any other

1234
00:50:15,119 --> 00:50:18,119
questions

