1
00:00:00,000 --> 00:00:08,160
so welcome to the stock on mining for
box with grafted of his Cleary's just

2
00:00:08,160 --> 00:00:14,910
for my information given a talk like
this before at last year CCC who's seen

3
00:00:14,910 --> 00:00:20,410
the talk with the same title nobody
great so could have just taken the

4
00:00:20,410 --> 00:00:27,400
slides are only had but ok I made some
new ones as well so hopefully it's even

5
00:00:27,400 --> 00:00:28,070
better

6
00:00:28,070 --> 00:00:34,200
ok so this talk is about vulnerability
discovery and if you have nothing to do

7
00:00:34,200 --> 00:00:37,480
with vulnerability discovery just to
give you a short working definition

8
00:00:37,480 --> 00:00:43,730
vulnerability discovery is the art of
navigating inside piles of junk the goal

9
00:00:43,730 --> 00:00:48,419
is to uncover small programs that we can
use to our advantage so I think this is

10
00:00:48,420 --> 00:00:53,500
the so I was searching for a picture for
a very long time which kind of gives you

11
00:00:53,500 --> 00:00:58,170
communicates the feeling that you have
when you first see a new code base and

12
00:00:58,170 --> 00:01:03,149
somebody tells you please find something
explainable in here I think this picture

13
00:01:03,149 --> 00:01:10,659
yeah it's a pretty well now the idea of
my work is to apply pattern recognition

14
00:01:10,659 --> 00:01:17,600
for vulnerability discovery and in
contrast to many approaches that you see

15
00:01:17,600 --> 00:01:23,720
particularly in academic work I don't
try to focus on exact methods where you

16
00:01:23,720 --> 00:01:28,429
reasonable like confined regions of
crowding great detail and you assume

17
00:01:28,430 --> 00:01:34,829
that you are you know exactly model of
the instructions of your copy of the

18
00:01:34,829 --> 00:01:40,320
language that you're looking at but
instead I'm I'm kicking in I'm taking a

19
00:01:40,320 --> 00:01:48,070
pattern recognition perspective where I
try to recognize as opposed to detect

20
00:01:48,070 --> 00:01:55,199
bugs so this is mostly inspired by the
books you see there below which is which

21
00:01:55,200 --> 00:01:59,390
is usually which is more from the
engineering field where you're kind of

22
00:01:59,390 --> 00:02:03,810
aware of the fact that all of the stuff
that you're dealing with this very

23
00:02:03,810 --> 00:02:09,479
imperfect so you're looking at it in
terms of the signal and noise and the

24
00:02:09,479 --> 00:02:11,560
question is whether we can use these
methods

25
00:02:11,560 --> 00:02:15,800
and kind of apply them to what
traditionally people have been doing

26
00:02:15,800 --> 00:02:21,110
with very exact methods are represented
by the books that you see on the time

27
00:02:21,110 --> 00:02:26,440
now an important theme to this is that
I'm not trying to build something that

28
00:02:26,440 --> 00:02:32,470
automatically detects bucks but instead
this is supposed to be told that helped

29
00:02:32,470 --> 00:02:40,410
auditors in day-to-day work so in a way
they they they enable people to autumn

30
00:02:40,410 --> 00:02:46,950
at what can be automatic but also make
use of their ideas and their knowledge

31
00:02:46,950 --> 00:02:52,869
of the codebase to spot for her buddies
now I've been doing this for quite a

32
00:02:52,870 --> 00:02:57,640
while now and recently I noticed it's
been three and a half years and

33
00:02:57,640 --> 00:03:02,329
fortunately I finally finished my thesis
on this and this is going to be coming

34
00:03:02,330 --> 00:03:09,840
out very soon so in love Emma 1550 stuff
seems interesting to you please take a

35
00:03:09,840 --> 00:03:14,709
look so you know if this is a document
that's you know you write it for very

36
00:03:14,709 --> 00:03:19,150
long but then nobody actually takes a
look at it you ever want to hide any

37
00:03:19,150 --> 00:03:25,810
secrets somewhere best do it in the
theses hopefully you know maybe one

38
00:03:25,810 --> 00:03:28,980
person or two in the room find this
interesting and actually check this out

39
00:03:28,980 --> 00:03:34,420
that will be very very cool ok so we're
going to be looking at two chapters

40
00:03:34,420 --> 00:03:39,720
essentially in this one of them that's
like the basis of all this work that's

41
00:03:39,720 --> 00:03:44,910
it's a graph mining platform for
vulnerability discovery and build on

42
00:03:44,910 --> 00:03:50,489
that graph mining platform I explore the
three main directions of machine

43
00:03:50,489 --> 00:03:56,489
learning unsupervised machine learning
and see whether those directions when

44
00:03:56,489 --> 00:04:03,239
those methods can be used to help us
find bugs and I can't tell you about all

45
00:04:03,239 --> 00:04:07,709
of these in the talk but I'm going to
talk about one of them which is how

46
00:04:07,709 --> 00:04:11,910
clustering can be used to help you
identify vulnerabilities and the nice

47
00:04:11,910 --> 00:04:17,798
part here is that actually this this
method will again generate queries for

48
00:04:17,798 --> 00:04:20,370
the grafted of his system so

49
00:04:20,370 --> 00:04:25,180
you actually see exactly what the system
has learned so this is something that is

50
00:04:25,180 --> 00:04:29,100
very often criticized about machine
learning that you know you can easily

51
00:04:29,100 --> 00:04:34,380
create a program that kind of classify
something but you don't really know what

52
00:04:34,380 --> 00:04:39,790
it does in the security context that's
not really good but you know if it

53
00:04:39,790 --> 00:04:44,240
actually outputs aquarian the end and
you can see what it has learnt and if

54
00:04:44,240 --> 00:04:50,760
it's rubbish then you will also see this
so let's get to the first part this is

55
00:04:50,760 --> 00:04:56,880
about the graph mining platform and this
combines two of two things which seem to

56
00:04:56,880 --> 00:05:02,219
have not so much to do one another when
you start off on the one hand we have a

57
00:05:02,220 --> 00:05:07,220
good old computer science compiler
construction so what compilers due to

58
00:05:07,220 --> 00:05:12,350
optimize your coat analyze your code you
know removed it for stuff like that and

59
00:05:12,350 --> 00:05:19,320
on the other hand you have the shiny new
graph databases and the question is how

60
00:05:19,320 --> 00:05:24,159
can we combine these two actually get a
good system for assisted horribly

61
00:05:24,160 --> 00:05:29,729
discovery and I want to start off with
an example this is an example

62
00:05:29,729 --> 00:05:37,789
back found by famous German hackers to
Vanessa it's a bug that he showed in his

63
00:05:37,789 --> 00:05:43,500
sis can 13 talk and he showed a lot of
really cool box and that talk and this

64
00:05:43,500 --> 00:05:49,020
was more of a more of a site finding you
could say but it's interesting because

65
00:05:49,020 --> 00:05:52,889
of the way he found it and it's also
interesting because it looks very much

66
00:05:52,889 --> 00:05:57,990
like a lot of other bugs that you'll see
all over the place so let's quickly go

67
00:05:57,990 --> 00:06:06,720
over this there is a rival colt named
Lynn and its 32 bit integer and

68
00:06:06,720 --> 00:06:11,650
apparently it comes from a network
because we're using a function called

69
00:06:11,650 --> 00:06:18,260
and to you and to hu so what kind of
quick converting it from network byte

70
00:06:18,260 --> 00:06:22,039
order order to force fed order so this
looks a lot like this might be from the

71
00:06:22,039 --> 00:06:29,719
network what then happens this we
allocated buffer and we add one

72
00:06:29,720 --> 00:06:37,250
you for a location and clearly if we
control the same Lindfield completely

73
00:06:37,250 --> 00:06:42,330
then if we use imax maximum integer then
what will happen is we get an overflow

74
00:06:42,330 --> 00:06:48,960
and actually locate 0 bytes and then it
copies named Lynn bites into the buffer

75
00:06:48,960 --> 00:06:54,130
so you get a hit baseball field before
so this is a very classic things all

76
00:06:54,130 --> 00:06:59,260
over the place and the question is how
did you find this bug and particularly

77
00:06:59,260 --> 00:07:03,280
when when you talk to academics they
will they will expect something really

78
00:07:03,280 --> 00:07:07,880
evolved right now so did you use the
white box father and hands for symbolic

79
00:07:07,880 --> 00:07:13,030
execution or some machine learning
powered animal detector or theorem

80
00:07:13,030 --> 00:07:20,549
proving on model checking but it turns
out he did was use grep right

81
00:07:20,550 --> 00:07:26,720
the regular expression that use to to
uncover the bugs and you can see these

82
00:07:26,720 --> 00:07:31,130
kind of looking for allocations and
inside those locations

83
00:07:31,130 --> 00:07:40,510
any any sort of arithmetic operation and
what do you think loading here is the

84
00:07:40,510 --> 00:07:44,550
fact that you know if people do
arithmetic inside the location then

85
00:07:44,550 --> 00:07:49,080
that's that's often a source for cheap
as possible flows triggered by

86
00:07:49,080 --> 00:07:56,780
introduced overflows because obviously
there's no Sora check after the after

87
00:07:56,780 --> 00:08:01,640
the summation or whatever it is so
they're gonna be a lot of cases with

88
00:08:01,640 --> 00:08:05,490
this is not problematic maybe the check
was done before or so but you know these

89
00:08:05,490 --> 00:08:13,680
are good points to start and yeah I
think we can learn a lot from this even

90
00:08:13,680 --> 00:08:19,400
if you take something as primitive as
grasp this can be a very powerful tool

91
00:08:19,400 --> 00:08:24,719
if you allow an analyst to actually
guide the analysis if you allow them to

92
00:08:24,720 --> 00:08:29,300
introduce some knowledge they have of
how things break in this particular

93
00:08:29,300 --> 00:08:34,370
language in this particular programming
environment another interesting part is

94
00:08:34,370 --> 00:08:40,049
when you when you think of the script
for it kind of it it encodes domain

95
00:08:40,049 --> 00:08:45,189
knowledge so if you can think of it as a
as a model of a bug and then finally

96
00:08:45,190 --> 00:08:51,460
high false-positive rates are not that
bad you know it's not like intrusion

97
00:08:51,460 --> 00:08:58,270
detection where one percent false
positives is you can't really use a

98
00:08:58,270 --> 00:09:02,680
system with 1% false positives because
it means the administrators going to be

99
00:09:02,680 --> 00:09:07,620
knocked out the bed like every few
minutes or so here you know if you have

100
00:09:07,620 --> 00:09:11,290
if you have like a hundred hits or so
and I don't know 10 of them are

101
00:09:11,290 --> 00:09:16,180
interesting so be it I mean that's
that's pretty good if ten of them are

102
00:09:16,180 --> 00:09:19,910
actually vulnerabilities wow that's not
a problem

103
00:09:19,910 --> 00:09:24,520
ok so here's the goal of we want to
build a we want to build a robust search

104
00:09:24,520 --> 00:09:29,180
engine for source code so there's going
to be a robust posture I'm not talking

105
00:09:29,180 --> 00:09:31,089
about what robustness means

106
00:09:31,089 --> 00:09:36,399
in this dark yeah there are a couple of
other talks around on this topic that

107
00:09:36,399 --> 00:09:39,879
after he done and I talked about this in
great detail what I figured out and

108
00:09:39,879 --> 00:09:45,509
nobody really cares so you know it's a
positive and used his partner to import

109
00:09:45,509 --> 00:09:50,069
the source code into this graph database
and in the back to have these pattern

110
00:09:50,069 --> 00:09:55,479
recognition algorithms that can be used
for most of all the analysts can query

111
00:09:55,480 --> 00:10:04,069
the system get responses adapt to
queries and query again the idea so

112
00:10:04,069 --> 00:10:08,579
first question we need to ask ourselves
is what we actually need to be able to

113
00:10:08,579 --> 00:10:12,628
model instead of queries so what other
things that the auditor might want to

114
00:10:12,629 --> 00:10:20,559
specify and I think the three things so
after analyzing lots of bugs we found it

115
00:10:20,559 --> 00:10:24,870
the three things that you want to
specifies what what are the statements

116
00:10:24,870 --> 00:10:30,499
look like when we get from one statement
to another and how do the statements

117
00:10:30,499 --> 00:10:34,829
affect each other and the next thing is
we don't have to come up with new ways

118
00:10:34,829 --> 00:10:39,508
of dealing with this because compilers
need to do with this all the time so

119
00:10:39,509 --> 00:10:45,050
let's see how compila steal his so in
compiler construction you have all sorts

120
00:10:45,050 --> 00:10:52,508
of graph representations of code so for
example there's the abstract syntax tree

121
00:10:52,509 --> 00:10:59,939
this tree essentially shows you exactly
how a language constructs have been

122
00:10:59,939 --> 00:11:04,910
message to create your program so you
can see for example there is an if here

123
00:11:04,910 --> 00:11:10,679
and there is a predicate of this if the
predicate X axis smaller than Macs and

124
00:11:10,679 --> 00:11:11,939
then there's a statement

125
00:11:11,939 --> 00:11:16,800
nested inside the if and so on now and
everything that you probably are

126
00:11:16,800 --> 00:11:21,309
enormous is the contras control flow
graph is what you get in either pro for

127
00:11:21,309 --> 00:11:28,649
example this tells you how statements
can be reached as in what conditions

128
00:11:28,649 --> 00:11:32,309
need to be true for me to reach a
statement for example here you see that

129
00:11:32,309 --> 00:11:40,230
needs to be smaller to max to reach this
statement why those two time to time sex

130
00:11:40,230 --> 00:11:41,680
and then years

131
00:11:41,680 --> 00:11:48,540
one not so many people know it's called
the program dependence graph and the

132
00:11:48,540 --> 00:11:52,930
program dependence graph data flow
information so you can see for example

133
00:11:52,930 --> 00:11:57,969
that there is a value called X and it's
produced at one statement here and it's

134
00:11:57,970 --> 00:12:02,930
being used by another statement here so
these are the three main data structures

135
00:12:02,930 --> 00:12:09,399
that can be used to analyze compilers
and the problem is you know you can't

136
00:12:09,399 --> 00:12:15,790
just choose one and do everything this
so none of these is perfect if you take

137
00:12:15,790 --> 00:12:21,800
a look at a typical query it's more like
you know finally threw in a statement

138
00:12:21,800 --> 00:12:26,959
where data flow exists to a statement
that contains a quarter bar so actually

139
00:12:26,959 --> 00:12:30,709
what you're doing is first you
describing syntax you're saying

140
00:12:30,709 --> 00:12:34,390
find a call to food that's something
some tactical then you're saying but now

141
00:12:34,390 --> 00:12:39,459
I want to reason about data flow now
wanna see with this data is propagated

142
00:12:39,459 --> 00:12:44,439
to and then again when you follow the
data flowing you want to go back into

143
00:12:44,440 --> 00:12:50,500
the syntax because you want to find
calls to borrow so there's this need to

144
00:12:50,500 --> 00:12:55,670
create transitions from the syntax tree
to the dependence graph and back to the

145
00:12:55,670 --> 00:13:03,339
syntax tree and the question is can we
get a representation that has it all the

146
00:13:03,339 --> 00:13:07,270
main observation to do this is that
actually in each of these graphic

147
00:13:07,270 --> 00:13:14,980
presentations there is a note for each
statement right so why not just merge

148
00:13:14,980 --> 00:13:22,990
them I mean the main trick here is that
we actually have labels on the edges to

149
00:13:22,990 --> 00:13:27,470
distinguish the different types of edges
that we have but you know now we have a

150
00:13:27,470 --> 00:13:32,400
data structure that represents all of
this in one and this is what we call the

151
00:13:32,400 --> 00:13:37,860
court property graph and now the
question is can we may be described

152
00:13:37,860 --> 00:13:44,510
vulnerabilities as subgraphs this
corporate now once we have this we

153
00:13:44,510 --> 00:13:50,790
wanted to see more store it to carry it
and we try to store it in relational

154
00:13:50,790 --> 00:13:53,230
database management systems because
there are a lot of

155
00:13:53,230 --> 00:13:56,530
good reversing tools that use relational
database management systems so we're

156
00:13:56,530 --> 00:14:01,500
thinking you know why not and we felt
completely writing a lot of course just

157
00:14:01,500 --> 00:14:09,890
map graphs two tables and failed then we
try to document databases for some

158
00:14:09,890 --> 00:14:13,130
reason I'm not sure why but of course
the fields as well because mapping

159
00:14:13,130 --> 00:14:20,790
documents to press its hard but actually
a graph succeeds immediately so we

160
00:14:20,790 --> 00:14:26,530
turned out using a grafted of it and
just a short note about the relational

161
00:14:26,530 --> 00:14:31,810
database management systems of course
you could just create tables for north

162
00:14:31,810 --> 00:14:37,709
and then create like a join table for
the edges but this doesn't scale so the

163
00:14:37,710 --> 00:14:43,710
lookup time that you get on the joint
force will become proportional to the

164
00:14:43,710 --> 00:14:48,870
size of the graph and this will become
very inefficient so this is like the

165
00:14:48,870 --> 00:14:52,480
this is one of the one of the main
things that graph databases give you

166
00:14:52,480 --> 00:14:57,560
need to fully support for these for
efficiently querying this graph

167
00:14:57,560 --> 00:15:04,339
structures graph databases they don't
use tables as their native storage

168
00:15:04,340 --> 00:15:08,970
format but instead they use what is
called a property crash and property

169
00:15:08,970 --> 00:15:15,040
graph is really just a graph where you
can attach like dictionaries to the

170
00:15:15,040 --> 00:15:21,120
notes patent expiries or hashes you like
and you can put labels on the edges

171
00:15:21,120 --> 00:15:22,290
that's it

172
00:15:22,290 --> 00:15:31,420
example so you have a name and an H
attached to each of the north and you

173
00:15:31,420 --> 00:15:40,040
have different kinds of edges so created
and nose and graphic hand the nice thing

174
00:15:40,040 --> 00:15:44,550
about the grafting of his already have
languages to query this and there were

175
00:15:44,550 --> 00:15:49,400
two very popular languages actually
there are a lot more about you know new

176
00:15:49,400 --> 00:15:54,560
4G the most popular graph database gives
you two one of them is the site for

177
00:15:54,560 --> 00:16:00,050
query language which is not so good for
what we want to do and the other is

178
00:16:00,050 --> 00:16:04,479
rambling and rambling is pretty basic

179
00:16:04,480 --> 00:16:09,500
you choose to start nodes that you
described how he want to walk the graph

180
00:16:09,500 --> 00:16:14,880
and if it's possible to work the graph
according to your description the notes

181
00:16:14,880 --> 00:16:20,120
that you reach they will be returned
that it that's it so for example return

182
00:16:20,120 --> 00:16:24,670
all objects created by people over the
age of 30 that will be the start notes

183
00:16:24,670 --> 00:16:29,990
all the people with Paige bigger than 30
and then follow outgoing created edges

184
00:16:29,990 --> 00:16:38,670
so this is what that would look like a
gremlin so Peter and Josh over 30 right

185
00:16:38,670 --> 00:16:48,010
and now we started those and we then
follow the created links we stopped at

186
00:16:48,010 --> 00:16:53,060
the things that they've created and this
will be returned that's it and the

187
00:16:53,060 --> 00:16:56,268
really nice thing is that you can get
something like stored procedures here

188
00:16:56,269 --> 00:17:01,510
once you've defiant you know something
that you commonly looked for you can

189
00:17:01,510 --> 00:17:05,490
give it a name so you can see all the
people who are over 30 who created

190
00:17:05,490 --> 00:17:08,720
something nice for us our people we can
fire now and then you can just see

191
00:17:08,720 --> 00:17:14,910
people we can fire now and you know you
don't have to rewrite this thing over

192
00:17:14,910 --> 00:17:20,429
and over again and you can create really
complex reversals their fault and you

193
00:17:20,429 --> 00:17:26,250
know save them in these pipes and then
reuse these pipes all over

194
00:17:26,250 --> 00:17:35,710
initially this was created mainly for
social networks right so graph databases

195
00:17:35,710 --> 00:17:41,350
I think one of the events where they
became publicly known was when Facebook

196
00:17:41,350 --> 00:17:45,199
introduced a graph search and they
allowed allowed you to look for all

197
00:17:45,200 --> 00:17:49,860
sorts of fun social things for example
you could look for people who like

198
00:17:49,860 --> 00:17:55,490
English Defence League and curry or you
could look for mothers of Catholics from

199
00:17:55,490 --> 00:17:58,700
Italy who like directs

200
00:17:58,700 --> 00:18:03,919
those were the kind of examples that you
know grotto broader attention all the

201
00:18:03,919 --> 00:18:08,179
nice thing is you don't have to store
useless crap in database graph databases

202
00:18:08,179 --> 00:18:13,260
you can also store for example the quote
property graph in the graph database is

203
00:18:13,260 --> 00:18:16,470
by definition of course that's how it
was supposed to be built

204
00:18:16,470 --> 00:18:23,380
it is a property graph and then once you
do that you can use this stored

205
00:18:23,380 --> 00:18:27,700
procedure trick to actually build a
domain-specific query language for

206
00:18:27,700 --> 00:18:31,950
vulnerability discovery will you when
called all of your ideas of what kind of

207
00:18:31,950 --> 00:18:38,360
things you would like to check for and
we did this and we build a platform and

208
00:18:38,360 --> 00:18:45,199
you can use this download it it's
everything is available the platform is

209
00:18:45,200 --> 00:18:48,100
called you and it

210
00:18:48,100 --> 00:18:55,280
process and you know parts of C++ and
Python scripting interface and some show

211
00:18:55,280 --> 00:19:00,100
utilities you can use and it's actually
been tested to work on other people's

212
00:19:00,100 --> 00:19:05,178
machines make me very happy that it
doesn't just run on my machine and

213
00:19:05,179 --> 00:19:12,860
probably the first of my projects with
this is true you can download it at el

214
00:19:12,860 --> 00:19:19,658
sector or cure so let's take a look at
what this system does and how we can use

215
00:19:19,659 --> 00:19:26,830
it so the first step is you imported
code and the code is written to disk and

216
00:19:26,830 --> 00:19:33,658
then we started and it accesses the disc
and this graph database server exposes a

217
00:19:33,659 --> 00:19:38,690
REST API so you can see this comes from
people and I tried to hide this little

218
00:19:38,690 --> 00:19:42,720
bit because you know I don't really
think the whole web stuff is necessary

219
00:19:42,720 --> 00:19:46,659
at this point so I wrote a little I
wrote a little library for you it's

220
00:19:46,659 --> 00:19:51,120
called person you are and you can just
use this database without knowing that

221
00:19:51,120 --> 00:19:56,860
there's this rests in between very
comfortable now you can you know just in

222
00:19:56,860 --> 00:19:57,658
imports

223
00:19:57,659 --> 00:20:04,350
your your library you specify a query
you connect to the database you run it

224
00:20:04,350 --> 00:20:09,010
you print the results that's it that's
that's fully functional script here

225
00:20:09,010 --> 00:20:15,809
except for the fact that I did not
include weary or if you like the shell

226
00:20:15,809 --> 00:20:21,210
you can use the show utilities so we we
did practical evaluation of what this

227
00:20:21,210 --> 00:20:26,940
tool can do to make this very short in
the original talk we talked about all

228
00:20:26,940 --> 00:20:29,250
the details of this but I was actually
not

229
00:20:29,250 --> 00:20:35,340
so interesting the point here is this is
not some this is not some purely

230
00:20:35,340 --> 00:20:40,379
academic thing that really doesn't
produce results but in fact we we used

231
00:20:40,380 --> 00:20:45,450
the Linux kernel as a case study and I
actually got somebody in the industry to

232
00:20:45,450 --> 00:20:51,340
to use this this is my good friend local
go to hear from him and he said that

233
00:20:51,340 --> 00:20:54,580
they found about a hundred issues in an
internal audit and I don't know what

234
00:20:54,580 --> 00:20:58,919
they qualify as issues and we were not
able to release he was not able to

235
00:20:58,920 --> 00:21:06,240
really give this out but then you know
we also did some did some open areas

236
00:21:06,240 --> 00:21:11,690
that we could share with everyone so we
did two words for buffer overflows 140

237
00:21:11,690 --> 00:21:16,540
by two locations one for memory mapping
books and one from memory disclosure

238
00:21:16,540 --> 00:21:23,399
books and this was the outcome we found
18 vulnerabilities acknowledged and

239
00:21:23,400 --> 00:21:27,710
fixed by the developers you can see we
also got see you identify yourself so

240
00:21:27,710 --> 00:21:31,790
these are just some problems that you
know security people like to think of

241
00:21:31,790 --> 00:21:39,950
his problems but also the developer said
okay yeah this is a long ago but now for

242
00:21:39,950 --> 00:21:46,450
a case study in I think this is the more
interesting case study via see so you

243
00:21:46,450 --> 00:21:51,380
see here's what you would do if you were
to run this on the air see the first

244
00:21:51,380 --> 00:22:00,010
year you run to import VLC and this
takes a while and then you start the new

245
00:22:00,010 --> 00:22:05,410
4G graph database server so that's the
craft and you can point your browser to

246
00:22:05,410 --> 00:22:10,160
this address here just for some
statistics so you can see that the DLC

247
00:22:10,160 --> 00:22:18,400
code produced two million notes about
and five million properties for million

248
00:22:18,400 --> 00:22:23,620
or almost five million relationships
these are the edges in there and it

249
00:22:23,620 --> 00:22:28,820
takes about seven hundred and five
megabytes now in those seven hundred

250
00:22:28,820 --> 00:22:31,539
five megabytes

251
00:22:31,539 --> 00:22:39,279
yeah it should be in those there's also
an integrated text search engine based

252
00:22:39,279 --> 00:22:43,749
on Apache Lucene and we're going to use
that for starting those elections so

253
00:22:43,749 --> 00:22:50,220
this is like an extra feature that that
new 4G he's so here's an example of a

254
00:22:50,220 --> 00:22:57,529
very simple very so this is just so
let's say we want to have all the files

255
00:22:57,529 --> 00:23:03,519
that have the name D marks inside them
so we can write this greed type of file

256
00:23:03,519 --> 00:23:08,179
on thursday marks and we can put this to
your look up and it will give us all of

257
00:23:08,179 --> 00:23:13,529
these paths and also the ideas for this
they are probably thinking okay so where

258
00:23:13,529 --> 00:23:19,470
do I need to suggest you find them now
comes the magic the magic is that once

259
00:23:19,470 --> 00:23:23,739
you know once you are at these files
nodes you can actually decent into the

260
00:23:23,739 --> 00:23:29,220
contents of these files right so the
entire code base is just one huge graph

261
00:23:29,220 --> 00:23:33,710
and you can transition from the
different representations from files to

262
00:23:33,710 --> 00:23:37,789
their content you can transition from
syntax trees to their control flow

263
00:23:37,789 --> 00:23:38,989
graphs and so on

264
00:23:38,989 --> 00:23:44,909
you can also transition from functions
to the functions that they call you know

265
00:23:44,909 --> 00:23:51,029
you have a call the call graph all this
possible so we put this type of file in

266
00:23:51,029 --> 00:23:54,889
Hyde Park do marks into one of these
custom steps that we defined which is

267
00:23:54,889 --> 00:24:01,719
corporate index which would just execute
the query and from there are we follow

268
00:24:01,720 --> 00:24:08,799
outgoing edges and take only those which
are labeled as functions so suddenly you

269
00:24:08,799 --> 00:24:12,200
have all the functions inside files
called

270
00:24:12,200 --> 00:24:20,299
ok so let's let's take this for a spin
to find vulnerabilities and let's take a

271
00:24:20,299 --> 00:24:23,649
look at the SSH back again

272
00:24:23,649 --> 00:24:29,369
Liversedge back again that we saw
different so one of formulate the

273
00:24:29,369 --> 00:24:35,418
following query you know I had before we
you know make code out of it so let's

274
00:24:35,419 --> 00:24:39,720
get calls to my luck with the first
argument contains an additive expression

275
00:24:39,720 --> 00:24:44,080
and a call to mem copy is reached by
data-flow where the third

276
00:24:44,080 --> 00:24:48,799
also contains an added to fix special
and the two additive expressions are not

277
00:24:48,799 --> 00:24:56,860
equal rights even formulate something
like this it's see ya what's what's the

278
00:24:56,860 --> 00:24:58,000
idea

279
00:24:58,000 --> 00:25:04,500
the ideas that the science that's being
calculated is unequal to the offer this

280
00:25:04,500 --> 00:25:08,710
being reached and it's pretty unsafe
because you doing the additions directly

281
00:25:08,710 --> 00:25:12,779
inside the location and in the car I
guess what that would look like as a

282
00:25:12,779 --> 00:25:18,250
query it cost to lock that's one of
those utilities and from there go to the

283
00:25:18,250 --> 00:25:29,600
its first argument which is the amount
to allocate and store that I now take

284
00:25:29,600 --> 00:25:34,100
only those which are additive
expressions and from those additive

285
00:25:34,100 --> 00:25:39,570
expressions in in the tree now you go up
to the in closing statement in now we

286
00:25:39,570 --> 00:25:44,480
can solve the dataflow links now you can
see follow all data flow links where we

287
00:25:44,480 --> 00:25:52,380
are now you go back into the St find
calls to member happy where the third

288
00:25:52,380 --> 00:26:00,029
argument is unequal to the stuff we
saved that's the the the first argument

289
00:26:00,029 --> 00:26:07,210
to my luck and this is also an additive
expression that's it you type that you

290
00:26:07,210 --> 00:26:13,440
type it into your lookup you sort it
unique you use your location to get the

291
00:26:13,440 --> 00:26:17,610
actual locations you private to full
right

292
00:26:17,610 --> 00:26:25,620
your file now you cat food and you get
four hits in the entire corpus and I

293
00:26:25,620 --> 00:26:32,010
really thought OMP before it's nice to
have something to force so grab food for

294
00:26:32,010 --> 00:26:39,269
mp4 and your own code which will up the
code and this is what it outputs and I

295
00:26:39,269 --> 00:26:44,889
would ask you how to trigger this bug
auditory says it so you see here is

296
00:26:44,889 --> 00:26:50,990
called to pass mp4 files and use your
mother and it hasn't had to fix person

297
00:26:50,990 --> 00:26:54,110
inside so lets you insert 7

298
00:26:54,110 --> 00:27:01,309
then we would allocate seven-plus 1980
and then use the MEM copy that's

299
00:27:01,309 --> 00:27:06,160
actually being reached faded flow and
the third argument here also contains an

300
00:27:06,160 --> 00:27:11,730
additive expression and this time it is
sized minus eight and if we insert seven

301
00:27:11,730 --> 00:27:16,760
and that's actually minus one so we have
a buffer that allocated to close to zero

302
00:27:16,760 --> 00:27:25,679
byte we copy minus one test to unsigned
integer which is next in into it and

303
00:27:25,679 --> 00:27:36,440
there we have over from the OC right now
that's a first example of course the

304
00:27:36,440 --> 00:27:45,950
question arises what do I search for and
well one of the things that I found very

305
00:27:45,950 --> 00:27:50,440
inspiring about this question is
something said in a book called the

306
00:27:50,440 --> 00:27:55,030
other software security assessment which
is really cool book if you're into court

307
00:27:55,030 --> 00:28:01,799
announces and in that book it says in
fact two of office typically start

308
00:28:01,799 --> 00:28:06,559
reviewing a new code base by finding the
equivalent of the util directory and

309
00:28:06,559 --> 00:28:13,730
reading the framework and glue code
line-by-line now what does it mean that

310
00:28:13,730 --> 00:28:18,190
means let's understand the language
first that is being spoken here and by

311
00:28:18,190 --> 00:28:22,330
that I don't just mean a programming
language but the abstractions that are

312
00:28:22,330 --> 00:28:26,530
being used and if we can find something
that's fundamentally hard to use about

313
00:28:26,530 --> 00:28:31,110
these abstractions then you know looking
for problems related to this is probably

314
00:28:31,110 --> 00:28:38,229
going to pay so in the OC I took a look
at the stream processing API and that's

315
00:28:38,230 --> 00:28:43,130
mainly located in VLC stream . H and
there's one interesting function that

316
00:28:43,130 --> 00:28:46,720
you can find here which is the function
called Stream size and as the name

317
00:28:46,720 --> 00:28:53,860
implies it returns the size of the
stream now clearly a stream you know

318
00:28:53,860 --> 00:28:58,000
this this could be some media file and
you would want your videos to be

319
00:28:58,000 --> 00:29:07,490
be larger than 4 gigabytes so you'd have
to return an n64 and not just in in 232

320
00:29:07,490 --> 00:29:14,660
so you want 64 right now the problem
courses if you have a 32 bit platform

321
00:29:14,660 --> 00:29:18,290
than all of the locations that you're
going to be doing with these are you

322
00:29:18,290 --> 00:29:22,050
gonna be happy you're gonna have to be
very very careful about these because

323
00:29:22,050 --> 00:29:28,950
they're probably going to overflow or be
truncated yeah so the idea was or is

324
00:29:28,950 --> 00:29:33,530
realistic for an attack because you know
video can be larger than 4 gigabytes and

325
00:29:33,530 --> 00:29:37,120
nobody would say oh wow this must be
malicious know it's just a video that's

326
00:29:37,120 --> 00:29:44,010
why is that right so let's look for
truncation sunset allocations related to

327
00:29:44,010 --> 00:29:45,320
this so

328
00:29:45,320 --> 00:29:50,260
statements containing costs Stream size
and the symbol in 64 where did the floor

329
00:29:50,260 --> 00:29:54,379
exists the statements containing the
simple model and is growing as much

330
00:29:54,380 --> 00:29:59,240
smaller right there's get cost to again
so get cost Stream size go to the in

331
00:29:59,240 --> 00:30:07,020
closing statement from there take only
those that contain in 64 and now full

332
00:30:07,020 --> 00:30:12,820
data flow and see what we can actually
reach and filter out only those where

333
00:30:12,820 --> 00:30:16,730
Mullick appears so these are all
locations connected to the stream says

334
00:30:16,730 --> 00:30:19,380
and this is what you get

335
00:30:19,380 --> 00:30:23,600
not very much they're not too
interesting except for this one because

336
00:30:23,600 --> 00:30:31,310
this one is in the automatic updater
record for this what you see is here

337
00:30:31,310 --> 00:30:37,850
Stream size is being called right and
there's this integer called I read and

338
00:30:37,850 --> 00:30:45,290
64 and it's being used inside the mall
up here and again we add one now what

339
00:30:45,290 --> 00:30:51,620
happens this on a 32 bit platform the
argument that expected by mala is

340
00:30:51,620 --> 00:30:57,179
actually 32 bit in size so it first
takes this I read it actually adds one

341
00:30:57,180 --> 00:31:01,160
and that's not problematic yet so you
still have a 64 bit integer but then

342
00:31:01,160 --> 00:31:06,920
when its past 2 mullah at that point it
needs to be truncated so again if you

343
00:31:06,920 --> 00:31:07,600
have

344
00:31:07,600 --> 00:31:12,469
if you choose this to be the maximum
size of a 32 bit integer when you add

345
00:31:12,470 --> 00:31:17,309
one what you actually get is zero and
then I'm here you have a stream read

346
00:31:17,309 --> 00:31:21,149
operation stream read it's pretty much
like member copy but much better as

347
00:31:21,150 --> 00:31:29,090
you'll see in a minute and it again
reads I read bite into this factor which

348
00:31:29,090 --> 00:31:34,230
is max into the there you go you have
your overflow again and the updater are

349
00:31:34,230 --> 00:31:37,039
you probably going to say okay the
updater there's probably going to be

350
00:31:37,039 --> 00:31:42,000
some sort of you know signatures
involved to verify the update is valid

351
00:31:42,000 --> 00:31:47,370
or not the nice thing is all of this
actually happens before signature

352
00:31:47,370 --> 00:31:54,780
validation and also using ATT's you know
it's it's just clear text that you need

353
00:31:54,780 --> 00:31:57,178
to hear

354
00:31:57,179 --> 00:32:03,169
executed before a vacation just said
that so I tried this out I edited EDC

355
00:32:03,169 --> 00:32:08,610
hosts to you know . update video land or
or to my personal web server and I

356
00:32:08,610 --> 00:32:15,979
created a file with Max incise
containing all A's I attach the debugger

357
00:32:15,980 --> 00:32:22,460
to VLC a check for updates and you see
what happens and that's very very

358
00:32:22,460 --> 00:32:26,840
convenient because typically you know
when you start to debug something like

359
00:32:26,840 --> 00:32:33,408
this you have to do a lot of work to get
to the instruction pointer 2.2 urs but

360
00:32:33,409 --> 00:32:36,450
in this case actually he would
immediately and we're gonna see in a

361
00:32:36,450 --> 00:32:42,549
minute why that is the case the nice
thing is arguing in favor of patching

362
00:32:42,549 --> 00:32:46,980
you know gets very very easy if you're
any control and Yeti know there's no

363
00:32:46,980 --> 00:32:51,450
question now this is the security bug
people can tell my program where to jump

364
00:32:51,450 --> 00:32:58,440
next so notes on exploitation and why
why this worked well for one thing and

365
00:32:58,440 --> 00:33:03,789
this is important you don't actually
have to transmit for gigabyte file that

366
00:33:03,789 --> 00:33:09,760
would just take too long and you know
that that will not be so instead it's

367
00:33:09,760 --> 00:33:15,309
perfectly fine to use the Content Length
field here and set it to that values so

368
00:33:15,309 --> 00:33:17,629
you actually telling it eventually

369
00:33:17,630 --> 00:33:22,470
you will receive four gigabytes and now
I'm just going to give you a few bites

370
00:33:22,470 --> 00:33:27,210
for now so the attacker also fully
controls the amount of data to actually

371
00:33:27,210 --> 00:33:36,640
copy because you can't you can choke the
HDT responses that you give and this is

372
00:33:36,640 --> 00:33:42,480
the important part stream read so this
version of mem copy actually copies in

373
00:33:42,480 --> 00:33:49,250
blocks and in between these copy
operations a few references a function

374
00:33:49,250 --> 00:33:54,010
pointer meaning that if you cannot
overwrite this function for dinner or if

375
00:33:54,010 --> 00:33:57,540
you accidentally overwrite that function
pointers I obviously did at that point

376
00:33:57,540 --> 00:34:02,430
then as it D references to function
pointer you are to control their chance

377
00:34:02,430 --> 00:34:10,440
next step is to be enabled but there's
position independent code that allows

378
00:34:10,440 --> 00:34:16,679
you to build a small chain the downside
this is multithreading so it's it's not

379
00:34:16,679 --> 00:34:25,668
so easy to exploit alright I have a demo
exploit I'm running out of time I'm

380
00:34:25,668 --> 00:34:35,899
gonna do it anyway I guess there's maybe
you'll see it's a bit unstable so it

381
00:34:35,899 --> 00:34:42,399
works every fifth time or so you know i
mean fired at five thousand host you get

382
00:34:42,399 --> 00:34:46,989
a thousand shells

383
00:34:46,989 --> 00:35:02,060
updates and it doesn't work and its

384
00:35:02,060 --> 00:35:09,509
my setup

385
00:35:09,510 --> 00:35:18,190
something is broken this is this the
thing of life demonstrably left him

386
00:35:18,190 --> 00:35:23,810
something very wrong and I think it lost
its connection actually to the to the

387
00:35:23,810 --> 00:35:28,040
host that's because this guy supposed to
send data and that it actually display

388
00:35:28,040 --> 00:35:32,960
something ok anyway I'm running out of
time you can see the working exploit if

389
00:35:32,960 --> 00:35:38,369
you really want to see it in the CCC
video it does work I promise answer okay

390
00:35:38,369 --> 00:35:47,520
so far too vulnerable discovery using
clustering so once you explore lots of

391
00:35:47,520 --> 00:35:52,589
folks who thiss you start to see that it
would be very nice to actually designed

392
00:35:52,589 --> 00:35:56,890
some templates that you could fill out
to find your bags so for example if you

393
00:35:56,890 --> 00:36:02,490
take heart bleeding heart bleeds
actually has the same structure as the

394
00:36:02,490 --> 00:36:07,078
bugs me looked at as well so you kind of
have this this attack a controlled

395
00:36:07,079 --> 00:36:12,319
payload field here and again there's
this network to host byte order

396
00:36:12,319 --> 00:36:17,630
conversion and in the original code this
check here was not in place and then it

397
00:36:17,630 --> 00:36:21,460
eventually reaches the first argument of
mem copy and since the Czechoslovak

398
00:36:21,460 --> 00:36:23,740
place you can copy more than you should

399
00:36:23,740 --> 00:36:29,479
and by that time the thing ok let's just
create a template for this you know get

400
00:36:29,480 --> 00:36:34,720
cost to some sync function and then you
wanna describe what the arguments to the

401
00:36:34,720 --> 00:36:39,250
function look like each of them and how
they should be checked and if that's not

402
00:36:39,250 --> 00:36:43,660
the case you know I'll put it so these
are the kind of players that I used

403
00:36:43,660 --> 00:36:47,578
these days not last long periods but
something like this and this gives you

404
00:36:47,579 --> 00:36:54,520
crap like functionality but wouldn't it
be much nicer if the system could also

405
00:36:54,520 --> 00:37:02,009
actually tell us what is inside the
codebase so could it maybe tell us the

406
00:37:02,010 --> 00:37:06,400
floors can we get a less like
functionally can it automatically fill

407
00:37:06,400 --> 00:37:11,589
out this template for us to show us the
most common data flows in the in the

408
00:37:11,589 --> 00:37:16,720
code base and the programming rules
attached to this things like there is

409
00:37:16,720 --> 00:37:19,509
always a check here

410
00:37:19,510 --> 00:37:25,319
a related question is if we have a
bugger ready can we maybe generate like

411
00:37:25,319 --> 00:37:28,710
a robust so

412
00:37:28,710 --> 00:37:34,070
yeah that's the scenario using template
we want to learn regular expressions for

413
00:37:34,070 --> 00:37:42,230
this and for the sanitizers this yeah
you can think of this as a little car

414
00:37:42,230 --> 00:37:47,030
and there's what you learn his the model
parameters that the driver of the car

415
00:37:47,030 --> 00:37:51,900
and once you have that car you put it
into the whole property graph drives

416
00:37:51,900 --> 00:37:55,670
down the court property graph and you
know as a side effect it gives you

417
00:37:55,670 --> 00:38:02,339
conceptually seen this is a machine
learning problem

418
00:38:02,339 --> 00:38:11,580
machine learning problems she was really
just means you take data you put data

419
00:38:11,580 --> 00:38:16,210
into your system and it creates this
model who are you so this driver and

420
00:38:16,210 --> 00:38:20,390
then use that model to instantiate a
predictor and the predictors of poor

421
00:38:20,390 --> 00:38:25,509
thing it gets more of this data and it
needs to somehow make sense of this data

422
00:38:25,510 --> 00:38:33,010
now known increases the same you have
the source code you put it into lovin it

423
00:38:33,010 --> 00:38:39,599
all puts those template parameters and
then the area that you get that's the

424
00:38:39,599 --> 00:38:44,530
predictor and you from Warsaw score at
it and it drives down the court properly

425
00:38:44,530 --> 00:38:51,680
graph and says vulnerable ok wonderful
ok that's the idea we can borrow from

426
00:38:51,680 --> 00:38:57,868
signature generation here so in
signature generation you take you take

427
00:38:57,869 --> 00:39:01,740
the data and you first extract objects
from it

428
00:39:01,740 --> 00:39:07,029
you map this to a vector space and in
there you can use classical clustering

429
00:39:07,030 --> 00:39:12,930
algorithms to find similar objects and
then for each group of similar objects

430
00:39:12,930 --> 00:39:17,250
you generate one of these queries now
I'm not going to bore you with the

431
00:39:17,250 --> 00:39:22,760
details we built this oven and if you're
into this kind of stuff you can read

432
00:39:22,760 --> 00:39:31,830
this up essentially the objects we
classify invocations as an cost to the

433
00:39:31,830 --> 00:39:35,049
functions and we then

434
00:39:35,050 --> 00:39:41,030
user representation where each dimension
of the vector space is actually actually

435
00:39:41,030 --> 00:39:44,940
associated with a regular expressions so
that's that's a nice trick if you like

436
00:39:44,940 --> 00:39:49,410
machine learning and we don't use those
regular expressions to instantiate the

437
00:39:49,410 --> 00:39:53,970
template if you're interested in the
details as I said jesus is coming up but

438
00:39:53,970 --> 00:39:58,509
also there's a paper available already
which is called automatic inference of

439
00:39:58,510 --> 00:40:02,820
search parents has changed our own
abilities and just to quickly get to the

440
00:40:02,820 --> 00:40:08,000
results this is the query that was
automatically generated for heart pleat

441
00:40:08,000 --> 00:40:15,820
heart debug so you can see it says that
the third argument that there's a common

442
00:40:15,820 --> 00:40:21,750
flow in the database which is the third
argument is initialized by into S and

443
00:40:21,750 --> 00:40:27,110
for the second argument it found ok I
don't really know how this is

444
00:40:27,110 --> 00:40:32,340
initialized but it's always checked
against not telling the programmer this

445
00:40:32,340 --> 00:40:36,810
is a partner and then for the third
argument I find that there's typically

446
00:40:36,810 --> 00:40:40,820
some sort of comparison with a number
this is what's automatically extracted

447
00:40:40,820 --> 00:40:44,820
and looks pretty close to what we wrote
manually and the nice thing is if you

448
00:40:44,820 --> 00:40:50,020
run this it doesn't just find the one
instance of the heart but also the other

449
00:40:50,020 --> 00:40:55,170
night so they are two instances of this
and he's a false positives yeah this is

450
00:40:55,170 --> 00:41:02,710
the most positive then we also used to
something else and just ask you know

451
00:41:02,710 --> 00:41:07,350
give us all the systems for mem copy and
two of these were interesting in their

452
00:41:07,350 --> 00:41:12,700
own right because the media looking at
these your PC ok this is dangerous so

453
00:41:12,700 --> 00:41:20,990
here you have a tougher on the stack
controlled by ever able to lend so and

454
00:41:20,990 --> 00:41:25,549
and there's some sort of edition in here
so this is essentially something like a

455
00:41:25,550 --> 00:41:33,000
locker you can you can do this in a safe
way this is too large then actually

456
00:41:33,000 --> 00:41:37,690
you have memory that's that's not
allocated they are actually talking to

457
00:41:37,690 --> 00:41:43,600
and this found parks and then the other
one is you have a get some sort of get

458
00:41:43,600 --> 00:41:49,330
that controls the third argument to mem
copy this found boxes well I'm wrapping

459
00:41:49,330 --> 00:41:54,460
up the series we got for these this is
pretty much just going over the the

460
00:41:54,460 --> 00:41:59,560
sixty systems and picking these two and
these immediately all these files right

461
00:41:59,560 --> 00:42:05,320
conclusion I introduce a system to mine
called basis for vulnerabilities and it

462
00:42:05,320 --> 00:42:11,810
builds a bridge between program
announces and graph databases and you

463
00:42:11,810 --> 00:42:19,640
saw that the you can't just specify
these reversals these search patterns by

464
00:42:19,640 --> 00:42:25,040
yourself but also get the system to
enumerate what's their learning

465
00:42:25,040 --> 00:42:30,390
techniques and this is something that on
the one hand tells you what you could

466
00:42:30,390 --> 00:42:35,379
look for on the other it gives you
robust signatures for known bugs that

467
00:42:35,380 --> 00:42:45,310
you have we found real box using this
kind of works that's all I can say thank

468
00:42:45,310 --> 00:42:45,370
you

