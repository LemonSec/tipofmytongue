1
00:00:12,540 --> 00:00:13,559
foreign

2
00:00:13,559 --> 00:00:16,139
good morning ladies and gentlemen

3
00:00:16,139 --> 00:00:18,000
um I'm your moderator James if you have

4
00:00:18,000 --> 00:00:19,320
any questions

5
00:00:19,320 --> 00:00:21,480
throughout the day please feel free to

6
00:00:21,480 --> 00:00:23,400
come and ask me and I'll point you in

7
00:00:23,400 --> 00:00:24,859
the right direction

8
00:00:24,859 --> 00:00:27,900
we're going to start the first

9
00:00:27,900 --> 00:00:31,260
presentation this morning and I will

10
00:00:31,260 --> 00:00:32,719
hand you over

11
00:00:32,719 --> 00:00:37,520
to Mr gergay Ravi

12
00:00:39,400 --> 00:00:45,350
[Applause]

13
00:00:48,539 --> 00:00:51,780
I try not to destroy the microphone

14
00:00:51,780 --> 00:00:54,620
so uh welcome to my talk about

15
00:00:54,620 --> 00:00:58,379
automating binary analysis with gidra's

16
00:00:58,379 --> 00:01:01,160
P code

17
00:01:01,260 --> 00:01:02,940
my name is Gary

18
00:01:02,940 --> 00:01:06,240
um you know this is the quick

19
00:01:06,240 --> 00:01:08,280
short bullet points of what I've did in

20
00:01:08,280 --> 00:01:10,619
my life uh but it's not so interesting

21
00:01:10,619 --> 00:01:12,479
the point is that I do now security

22
00:01:12,479 --> 00:01:16,040
research at fortinet's uh 40 guard labs

23
00:01:16,040 --> 00:01:18,900
I'm originally from Hungary I live now

24
00:01:18,900 --> 00:01:20,159
in Germany

25
00:01:20,159 --> 00:01:21,720
I'm on Twitter

26
00:01:21,720 --> 00:01:24,540
um and you know a little bit on YouTube

27
00:01:24,540 --> 00:01:28,340
um so you can find me there

28
00:01:29,040 --> 00:01:32,280
so the agenda

29
00:01:32,280 --> 00:01:34,080
so

30
00:01:34,080 --> 00:01:35,960
I'm going to talk about gidra

31
00:01:35,960 --> 00:01:38,939
specifically the intermediate

32
00:01:38,939 --> 00:01:42,420
representation in guidra called P code a

33
00:01:42,420 --> 00:01:44,700
quick disclaimer I'm not a guitar expert

34
00:01:44,700 --> 00:01:46,920
so I use it time to time whenever I need

35
00:01:46,920 --> 00:01:50,640
it I actually went down using vidra

36
00:01:50,640 --> 00:01:52,500
because of a specific project I'd worked

37
00:01:52,500 --> 00:01:55,920
on and I was positively surprised so I

38
00:01:55,920 --> 00:01:57,720
think it's a it's a really great tool

39
00:01:57,720 --> 00:01:59,460
and that's kind that's kind of what

40
00:01:59,460 --> 00:02:01,200
motivated me to create this presentation

41
00:02:01,200 --> 00:02:03,840
because I think it's worth to to talk

42
00:02:03,840 --> 00:02:06,479
about both uh ghidra and and gidra

43
00:02:06,479 --> 00:02:07,500
precode

44
00:02:07,500 --> 00:02:10,258
and so quickly we'll talk about Gidget

45
00:02:10,258 --> 00:02:13,440
itself then uh gidra scripting

46
00:02:13,440 --> 00:02:14,940
and then

47
00:02:14,940 --> 00:02:17,040
um and then we will spend most of the

48
00:02:17,040 --> 00:02:20,819
time talking about the B code and I will

49
00:02:20,819 --> 00:02:22,920
show some code as well so that we don't

50
00:02:22,920 --> 00:02:27,319
just look at slides the whole time

51
00:02:27,360 --> 00:02:30,720
all right so about gidra if you don't

52
00:02:30,720 --> 00:02:32,340
live under a rock you probably know

53
00:02:32,340 --> 00:02:34,500
gidra it's a reverse engineering

54
00:02:34,500 --> 00:02:38,160
framework tool from from NSA this is the

55
00:02:38,160 --> 00:02:39,780
tool that was everybody was very

56
00:02:39,780 --> 00:02:41,160
suspicious about when it came out

57
00:02:41,160 --> 00:02:43,620
because it was from NSA then NSC open

58
00:02:43,620 --> 00:02:45,360
sourced it and now you know we are kind

59
00:02:45,360 --> 00:02:48,239
of okay because we can look into the

60
00:02:48,239 --> 00:02:49,260
code

61
00:02:49,260 --> 00:02:51,420
but all in all it's it's a very powerful

62
00:02:51,420 --> 00:02:53,459
tool and it's a great competitor to to

63
00:02:53,459 --> 00:02:56,700
Ida Pro binary ninja and Reddit too and

64
00:02:56,700 --> 00:02:58,620
of course it's free and open sort so

65
00:02:58,620 --> 00:03:00,720
that's uh that's a good point you know

66
00:03:00,720 --> 00:03:05,180
against for instance uh um Ida Pro

67
00:03:06,300 --> 00:03:09,180
and if you have never seen a gitro this

68
00:03:09,180 --> 00:03:10,620
is how it looks like

69
00:03:10,620 --> 00:03:12,659
um obviously you cannot read it but I

70
00:03:12,659 --> 00:03:14,099
just wanted to give you a general feel

71
00:03:14,099 --> 00:03:16,560
if you have never opened the tool in

72
00:03:16,560 --> 00:03:18,840
structure it's very similar to to Ida

73
00:03:18,840 --> 00:03:20,760
Pro the main difference is that that

74
00:03:20,760 --> 00:03:23,340
gitra has the decompiler by built in by

75
00:03:23,340 --> 00:03:25,800
default so the default view is what you

76
00:03:25,800 --> 00:03:27,959
can see here is the decompite code on

77
00:03:27,959 --> 00:03:30,180
one side and then the assembly code on

78
00:03:30,180 --> 00:03:32,099
the on the other side you know great

79
00:03:32,099 --> 00:03:33,780
real thing that if you select something

80
00:03:33,780 --> 00:03:35,580
in a decompiled code it's going to

81
00:03:35,580 --> 00:03:37,980
highlight it for you in the um in the

82
00:03:37,980 --> 00:03:41,159
assembly code as well

83
00:03:41,159 --> 00:03:43,920
and

84
00:03:43,920 --> 00:03:46,159
get your scripts

85
00:03:46,159 --> 00:03:48,200
so

86
00:03:48,200 --> 00:03:50,819
gitre as all the other tools offers you

87
00:03:50,819 --> 00:03:54,000
some kind of possibility to extend the

88
00:03:54,000 --> 00:03:55,920
functionality of the tool itself in

89
00:03:55,920 --> 00:03:57,720
either python you have in either you

90
00:03:57,720 --> 00:04:00,420
have either python in ghidra you have

91
00:04:00,420 --> 00:04:02,220
gitro scripts

92
00:04:02,220 --> 00:04:04,620
um the only difference is what I feel is

93
00:04:04,620 --> 00:04:07,140
that guitar scripts are a little bit

94
00:04:07,140 --> 00:04:09,959
more integrated in gitre itself as for

95
00:04:09,959 --> 00:04:14,400
instance either python in in Ida and

96
00:04:14,400 --> 00:04:16,260
generally

97
00:04:16,260 --> 00:04:18,418
the two most important use cases to

98
00:04:18,418 --> 00:04:21,120
create a great guitar script is one to

99
00:04:21,120 --> 00:04:24,120
automate simple manual tasks so for

100
00:04:24,120 --> 00:04:26,520
instance if you are reversing a malware

101
00:04:26,520 --> 00:04:29,160
and there is some kind of custom string

102
00:04:29,160 --> 00:04:31,020
encoding then you can just write the

103
00:04:31,020 --> 00:04:32,940
guitar script and

104
00:04:32,940 --> 00:04:35,460
um and call it from the UI whenever you

105
00:04:35,460 --> 00:04:38,040
encounter an encoded string and that's

106
00:04:38,040 --> 00:04:40,860
going to decode it for you so this is

107
00:04:40,860 --> 00:04:42,780
one part and the other part is to create

108
00:04:42,780 --> 00:04:47,880
a fully automated Tools in that case you

109
00:04:47,880 --> 00:04:50,340
can use gitra as a kind of you know

110
00:04:50,340 --> 00:04:53,100
reversing engine or a reversing binary

111
00:04:53,100 --> 00:04:55,699
in in the in the tool that you are

112
00:04:55,699 --> 00:04:59,280
writing this is this was my case so I

113
00:04:59,280 --> 00:05:01,740
didn't want to use the UI so I run

114
00:05:01,740 --> 00:05:03,360
gitrine headless mode which I'm going to

115
00:05:03,360 --> 00:05:04,500
talk about later

116
00:05:04,500 --> 00:05:08,160
and um and and just use gitra to you

117
00:05:08,160 --> 00:05:10,919
know generate the decompiled code or or

118
00:05:10,919 --> 00:05:13,440
get the contourflow graph and and things

119
00:05:13,440 --> 00:05:15,800
like that

120
00:05:15,900 --> 00:05:16,740
um

121
00:05:16,740 --> 00:05:19,020
we'll talk a little bit about Java

122
00:05:19,020 --> 00:05:23,100
versus python um geyser supports both so

123
00:05:23,100 --> 00:05:24,419
um so you have the option to choose

124
00:05:24,419 --> 00:05:26,220
which language you use for writing liter

125
00:05:26,220 --> 00:05:28,020
scripts and we're going to talk about

126
00:05:28,020 --> 00:05:32,580
the flat API versus the SDK just quickly

127
00:05:32,580 --> 00:05:35,280
the flat API is a small set of functions

128
00:05:35,280 --> 00:05:36,900
that you can use directly in your script

129
00:05:36,900 --> 00:05:38,759
and the SDK is basically everything

130
00:05:38,759 --> 00:05:43,520
that's available in in gidra

131
00:05:43,919 --> 00:05:45,840
so um

132
00:05:45,840 --> 00:05:47,340
git already comes with a bunch of

133
00:05:47,340 --> 00:05:50,340
scripts this is the script manager in

134
00:05:50,340 --> 00:05:52,199
gitra so this is where you can search

135
00:05:52,199 --> 00:05:54,600
and and run your script

136
00:05:54,600 --> 00:05:57,180
um I think if you use redraw regularly

137
00:05:57,180 --> 00:05:59,820
then it's definitely worth to to Once go

138
00:05:59,820 --> 00:06:01,919
through this script just to you know

139
00:06:01,919 --> 00:06:03,600
have it in your mind what kind of

140
00:06:03,600 --> 00:06:05,639
scripts are available for you because

141
00:06:05,639 --> 00:06:07,380
some some things might be already

142
00:06:07,380 --> 00:06:10,199
implemented that you might need for uh

143
00:06:10,199 --> 00:06:11,520
for your work

144
00:06:11,520 --> 00:06:13,979
you can also create a guitar scripts

145
00:06:13,979 --> 00:06:16,740
directly here in the script manager if

146
00:06:16,740 --> 00:06:21,539
you don't need a fancy UI or anything

147
00:06:21,539 --> 00:06:23,479
um

148
00:06:23,479 --> 00:06:26,940
other than that then you can use gitra's

149
00:06:26,940 --> 00:06:29,220
development environment which I'm going

150
00:06:29,220 --> 00:06:32,419
to talk about a little bit

151
00:06:32,419 --> 00:06:36,539
so one short word about python versus

152
00:06:36,539 --> 00:06:37,800
Java

153
00:06:37,800 --> 00:06:41,039
so gitra is written in Java so that's

154
00:06:41,039 --> 00:06:43,620
the native language of the tool and also

155
00:06:43,620 --> 00:06:46,080
the kidra script but I think at some

156
00:06:46,080 --> 00:06:48,600
point people at NSA realize that not

157
00:06:48,600 --> 00:06:51,180
everybody likes to suffer so they

158
00:06:51,180 --> 00:06:54,240
created a python or you know provided

159
00:06:54,240 --> 00:06:56,780
python support in gitrescripts as well

160
00:06:56,780 --> 00:07:00,720
however that's using jython which is a

161
00:07:00,720 --> 00:07:04,139
kind of a weird thing so if you are just

162
00:07:04,139 --> 00:07:06,979
writing simple scripts that it's fine

163
00:07:06,979 --> 00:07:09,600
there is also a tool called gidra Bridge

164
00:07:09,600 --> 00:07:12,600
which is which actually helps you use

165
00:07:12,600 --> 00:07:15,780
Python 3 and basically breaches git

166
00:07:15,780 --> 00:07:17,699
rabbit Python 3 that's what it does and

167
00:07:17,699 --> 00:07:19,620
it works pretty well so I recommend to

168
00:07:19,620 --> 00:07:21,660
to use that if you if you don't like

169
00:07:21,660 --> 00:07:23,699
jiten and you you prefer to use python

170
00:07:23,699 --> 00:07:25,860
3.

171
00:07:25,860 --> 00:07:27,240
um now

172
00:07:27,240 --> 00:07:29,759
although I don't particularly like Java

173
00:07:29,759 --> 00:07:32,880
and the last time I used it was was

174
00:07:32,880 --> 00:07:36,720
during my my studies at the University

175
00:07:36,720 --> 00:07:38,460
um I had to come to terms with the fact

176
00:07:38,460 --> 00:07:42,120
that that Java is actually uh

177
00:07:42,120 --> 00:07:44,039
so ghidra provides such a great

178
00:07:44,039 --> 00:07:46,860
development environment in Java that

179
00:07:46,860 --> 00:07:49,259
that you know I I can't I can't skip

180
00:07:49,259 --> 00:07:51,660
that so ultimately I started with python

181
00:07:51,660 --> 00:07:54,419
but I ended up using Java and you know

182
00:07:54,419 --> 00:07:56,039
pretty much have to Google like every

183
00:07:56,039 --> 00:07:59,160
single line of things to do in Java but

184
00:07:59,160 --> 00:08:01,440
but it's still worth it because because

185
00:08:01,440 --> 00:08:03,780
the pain with python is that

186
00:08:03,780 --> 00:08:04,440
um

187
00:08:04,440 --> 00:08:08,099
there are a lot of classes and methods

188
00:08:08,099 --> 00:08:10,500
that you want to use uh from guidra

189
00:08:10,500 --> 00:08:12,780
which are of course ordering all in all

190
00:08:12,780 --> 00:08:15,780
in Java and you can use them in Python

191
00:08:15,780 --> 00:08:18,060
but to figure out how to exactly use

192
00:08:18,060 --> 00:08:20,340
them it's a pain so like you find

193
00:08:20,340 --> 00:08:22,199
something in the documentation and and

194
00:08:22,199 --> 00:08:24,660
you know you have to think about how to

195
00:08:24,660 --> 00:08:27,599
translate this function call and you

196
00:08:27,599 --> 00:08:30,479
know Class Type to however it should

197
00:08:30,479 --> 00:08:33,120
look like in Python so ultimately it can

198
00:08:33,120 --> 00:08:35,760
be done and you can even debug debug

199
00:08:35,760 --> 00:08:39,659
type typing things in in Python but but

200
00:08:39,659 --> 00:08:42,000
it's a pain and

201
00:08:42,000 --> 00:08:46,440
um and as I said uh NSA created a really

202
00:08:46,440 --> 00:08:48,899
great development environment so there

203
00:08:48,899 --> 00:08:52,620
is an eclipse plugin for uh origin for

204
00:08:52,620 --> 00:08:55,620
Eclipse which works great so you can

205
00:08:55,620 --> 00:08:57,480
write your code in Eclipse you can start

206
00:08:57,480 --> 00:09:00,839
gitre directly from eclipse and then and

207
00:09:00,839 --> 00:09:03,720
basically use the debugger in Eclipse

208
00:09:03,720 --> 00:09:06,360
while you draw while your script is

209
00:09:06,360 --> 00:09:08,940
running in in gidra so that's that's

210
00:09:08,940 --> 00:09:10,800
super convenient

211
00:09:10,800 --> 00:09:12,779
um so so it's very easy to use

212
00:09:12,779 --> 00:09:15,540
and ultimately I would say that if

213
00:09:15,540 --> 00:09:17,640
you're just writing a short script and

214
00:09:17,640 --> 00:09:19,920
you like python then you can try using

215
00:09:19,920 --> 00:09:22,080
python but if you want to do something

216
00:09:22,080 --> 00:09:24,600
more complex then probably you save

217
00:09:24,600 --> 00:09:26,940
yourself some time and and uh and go

218
00:09:26,940 --> 00:09:29,339
with Java even if you don't know the

219
00:09:29,339 --> 00:09:32,720
language uh too well

220
00:09:33,720 --> 00:09:35,519
headless mode

221
00:09:35,519 --> 00:09:38,040
um as I mentioned for instance in my

222
00:09:38,040 --> 00:09:40,380
case I didn't need didn't need the UI at

223
00:09:40,380 --> 00:09:42,300
all I just wanted to run my script

224
00:09:42,300 --> 00:09:45,480
directly on on binaries this is what

225
00:09:45,480 --> 00:09:48,600
headless mode lets you do what you can

226
00:09:48,600 --> 00:09:50,940
see there this is

227
00:09:50,940 --> 00:09:54,600
all right can I yeah so this is pretty

228
00:09:54,600 --> 00:09:56,940
much how you call uh how you start your

229
00:09:56,940 --> 00:09:59,100
gitrescript in headless mode it looks a

230
00:09:59,100 --> 00:10:00,540
little bit weird that's basically the

231
00:10:00,540 --> 00:10:01,920
only drawback

232
00:10:01,920 --> 00:10:03,420
um but you can you can kind of

233
00:10:03,420 --> 00:10:05,580
circumvent that by by writing a wrapper

234
00:10:05,580 --> 00:10:06,660
script

235
00:10:06,660 --> 00:10:08,100
um you know ultimately you are just

236
00:10:08,100 --> 00:10:12,060
calling ghidra on a particular binary

237
00:10:12,060 --> 00:10:16,200
um the hello.txe and then and then tell

238
00:10:16,200 --> 00:10:18,959
gidra to run your script on this on this

239
00:10:18,959 --> 00:10:21,240
binary

240
00:10:21,240 --> 00:10:24,000
so it's pretty easy and and works fine

241
00:10:24,000 --> 00:10:26,940
and as I said in this case gidra is just

242
00:10:26,940 --> 00:10:28,920
your reversing engine you can do

243
00:10:28,920 --> 00:10:31,500
whatever you want in your own Java code

244
00:10:31,500 --> 00:10:35,580
and just use uh use gitra for uh for

245
00:10:35,580 --> 00:10:38,220
whatever getter can do for for your your

246
00:10:38,220 --> 00:10:40,620
stuff

247
00:10:40,620 --> 00:10:44,100
now Gita comes with two different apis

248
00:10:44,100 --> 00:10:46,380
um one is called the flat API or

249
00:10:46,380 --> 00:10:49,519
actually it's called Flat program API

250
00:10:49,519 --> 00:10:53,459
this is basically a set of methods that

251
00:10:53,459 --> 00:10:55,260
are directly available in your

252
00:10:55,260 --> 00:10:58,200
gitruscript and it's like you know 100

253
00:10:58,200 --> 00:11:02,339
and around 150 methods and the

254
00:11:02,339 --> 00:11:04,940
the whole idea is to provide stability

255
00:11:04,940 --> 00:11:09,240
so the rule of thumb is that no function

256
00:11:09,240 --> 00:11:12,440
should be removed from the flat API ever

257
00:11:12,440 --> 00:11:15,300
and and function signature shouldn't be

258
00:11:15,300 --> 00:11:17,480
changed over time at all

259
00:11:17,480 --> 00:11:20,279
so if you use either Pro and you ever

260
00:11:20,279 --> 00:11:22,620
try to use an either python script from

261
00:11:22,620 --> 00:11:24,660
the internet you can you might know the

262
00:11:24,660 --> 00:11:26,700
pain that you download the script and

263
00:11:26,700 --> 00:11:30,180
then it was written in a either like two

264
00:11:30,180 --> 00:11:32,579
versions ago which was still in Python 2

265
00:11:32,579 --> 00:11:36,200
and use the different API so

266
00:11:36,200 --> 00:11:38,519
ultimately I think running random either

267
00:11:38,519 --> 00:11:40,140
Python scripts from the Internet is a

268
00:11:40,140 --> 00:11:41,940
pain in the ass so

269
00:11:41,940 --> 00:11:44,220
um you know that's how it is and um and

270
00:11:44,220 --> 00:11:47,820
that's what flat API tries to solve so

271
00:11:47,820 --> 00:11:50,880
ideally if I write a guitar script today

272
00:11:50,880 --> 00:11:53,399
which only uses the flat API that should

273
00:11:53,399 --> 00:11:56,279
be able to run in five years as well so

274
00:11:56,279 --> 00:11:57,959
I think I think that's great and it's

275
00:11:57,959 --> 00:12:00,720
going to save you a lot of time uh

276
00:12:00,720 --> 00:12:04,100
fighting compatibility

277
00:12:04,880 --> 00:12:08,940
the other API is is the program API

278
00:12:08,940 --> 00:12:13,079
which is kind of the whole SDK and

279
00:12:13,079 --> 00:12:15,540
and basically this is this is everything

280
00:12:15,540 --> 00:12:18,480
that gitre is so and this is this is

281
00:12:18,480 --> 00:12:20,220
what I meant that the guitar script is

282
00:12:20,220 --> 00:12:22,620
very powerful because practically you

283
00:12:22,620 --> 00:12:25,680
can use every class that is used to to

284
00:12:25,680 --> 00:12:28,019
build gidra so everything that's being

285
00:12:28,019 --> 00:12:30,540
used to develop gitra is available for

286
00:12:30,540 --> 00:12:32,880
you in your guitar script as well that's

287
00:12:32,880 --> 00:12:35,700
also you know it's a great power but but

288
00:12:35,700 --> 00:12:37,740
uh but it's also overwhelming at times

289
00:12:37,740 --> 00:12:40,860
so I spent a lot of time uh you know

290
00:12:40,860 --> 00:12:42,600
browsing a documentation trying to

291
00:12:42,600 --> 00:12:46,320
figure out what classes do etc etc but

292
00:12:46,320 --> 00:12:48,480
the documentation is pretty good and the

293
00:12:48,480 --> 00:12:50,399
source code is also there so if you find

294
00:12:50,399 --> 00:12:52,560
a class that you might think that it

295
00:12:52,560 --> 00:12:55,380
does something that you want to do then

296
00:12:55,380 --> 00:12:57,360
you can you can start to look at

297
00:12:57,360 --> 00:12:59,100
guitar's own source code to figure out

298
00:12:59,100 --> 00:13:01,620
how how that that particular class is

299
00:13:01,620 --> 00:13:02,820
used

300
00:13:02,820 --> 00:13:04,820
um just to kind of

301
00:13:04,820 --> 00:13:07,440
try to give an example of the complexity

302
00:13:07,440 --> 00:13:10,380
of using using idra is

303
00:13:10,380 --> 00:13:12,180
um like if you want to use a memory

304
00:13:12,180 --> 00:13:14,220
address that's not like just a hex

305
00:13:14,220 --> 00:13:15,720
number because that would be too easy

306
00:13:15,720 --> 00:13:18,180
because guidra has its own address class

307
00:13:18,180 --> 00:13:20,760
so first you need to instantiate an

308
00:13:20,760 --> 00:13:22,680
address class using your memory address

309
00:13:22,680 --> 00:13:25,260
and then you can use that address that

310
00:13:25,260 --> 00:13:28,519
address instance in all the other

311
00:13:28,519 --> 00:13:31,260
functions and methods that would require

312
00:13:31,260 --> 00:13:33,120
a memory address address

313
00:13:33,120 --> 00:13:35,339
but all in all you know it's a learning

314
00:13:35,339 --> 00:13:37,560
curve but but it's doable and again the

315
00:13:37,560 --> 00:13:41,719
documentation is is pretty good

316
00:13:42,480 --> 00:13:45,600
so um with that we arrived to our first

317
00:13:45,600 --> 00:13:46,920
example

318
00:13:46,920 --> 00:13:50,339
this is very simple I just wanted to uh

319
00:13:50,339 --> 00:13:53,399
to list all the important functions

320
00:13:53,399 --> 00:13:55,860
um because you know that's often the

321
00:13:55,860 --> 00:13:57,540
first thing when you start reversing

322
00:13:57,540 --> 00:13:58,459
something

323
00:13:58,459 --> 00:14:01,440
because looking at the important

324
00:14:01,440 --> 00:14:03,959
functions of binary can give you a good

325
00:14:03,959 --> 00:14:06,600
idea that what what the generally what

326
00:14:06,600 --> 00:14:09,120
the binary might do so for instance if

327
00:14:09,120 --> 00:14:11,880
it if it uses the windows apis for

328
00:14:11,880 --> 00:14:13,980
networking then probably the binary does

329
00:14:13,980 --> 00:14:16,620
some kind of networking so um this is

330
00:14:16,620 --> 00:14:18,839
why I thought we can list the important

331
00:14:18,839 --> 00:14:21,720
functions from from a script and this is

332
00:14:21,720 --> 00:14:23,339
all the script we need

333
00:14:23,339 --> 00:14:26,220
as you can see

334
00:14:26,220 --> 00:14:28,740
I hope you see it so one thing to point

335
00:14:28,740 --> 00:14:32,220
out that uh our Base Class is the clitor

336
00:14:32,220 --> 00:14:34,440
script class this this is what makes our

337
00:14:34,440 --> 00:14:37,440
our script a guitar script and we also

338
00:14:37,440 --> 00:14:40,380
need a run function a run method to be

339
00:14:40,380 --> 00:14:42,180
Java specific

340
00:14:42,180 --> 00:14:43,980
um and then and then basically we have a

341
00:14:43,980 --> 00:14:46,620
good Escape that will be that will run

342
00:14:46,620 --> 00:14:49,860
and in this particular case uh we take

343
00:14:49,860 --> 00:14:53,100
the current program field which comes

344
00:14:53,100 --> 00:14:55,440
directly from the flat API and it

345
00:14:55,440 --> 00:14:57,899
provides you all kinds of information of

346
00:14:57,899 --> 00:15:00,060
about the the particular binary that you

347
00:15:00,060 --> 00:15:01,980
are analyzing

348
00:15:01,980 --> 00:15:03,839
um and in this case we are just use the

349
00:15:03,839 --> 00:15:06,300
get symbol table function

350
00:15:06,300 --> 00:15:09,300
get symbol table function here to get

351
00:15:09,300 --> 00:15:13,139
the symbols and from that we create an

352
00:15:13,139 --> 00:15:16,079
iterator with the get external symbols

353
00:15:16,079 --> 00:15:19,260
so the external simple symbols are the

354
00:15:19,260 --> 00:15:20,760
imported functions

355
00:15:20,760 --> 00:15:24,660
and basically at the end we just iterate

356
00:15:24,660 --> 00:15:28,920
through all these symbols and print them

357
00:15:28,920 --> 00:15:31,019
okay so let's see

358
00:15:31,019 --> 00:15:35,060
that in practice

359
00:15:47,880 --> 00:15:51,660
oh so we lost that from the screen let

360
00:15:51,660 --> 00:15:53,279
me just try to

361
00:15:53,279 --> 00:15:55,139
put it somewhere

362
00:15:55,139 --> 00:15:58,459
yeah there it comes

363
00:16:05,699 --> 00:16:08,359
okay

364
00:16:08,820 --> 00:16:10,980
um yeah so this is the this is the first

365
00:16:10,980 --> 00:16:12,420
script but we already talked about that

366
00:16:12,420 --> 00:16:15,180
so I will just go to

367
00:16:15,180 --> 00:16:18,000
gidra I have a binary uh loaded here

368
00:16:18,000 --> 00:16:21,720
it's a it's a very simple uh thing and

369
00:16:21,720 --> 00:16:24,480
this is a script manager as I mentioned

370
00:16:24,480 --> 00:16:28,019
and you can see my activity scripts here

371
00:16:28,019 --> 00:16:31,079
so I will just choose the uh the first

372
00:16:31,079 --> 00:16:35,040
one and then I run and then some magic

373
00:16:35,040 --> 00:16:37,259
happened here

374
00:16:37,259 --> 00:16:39,600
and this is basically what we did if you

375
00:16:39,600 --> 00:16:41,759
see that I just listed

376
00:16:41,759 --> 00:16:44,100
all the important functions and printed

377
00:16:44,100 --> 00:16:47,339
the the dlls that they were important

378
00:16:47,339 --> 00:16:50,279
from so that's pretty much what this

379
00:16:50,279 --> 00:16:51,480
script does

380
00:16:51,480 --> 00:16:52,019
um

381
00:16:52,019 --> 00:16:55,620
but I hope it gave an idea of

382
00:16:55,620 --> 00:16:56,699
yeah

383
00:16:56,699 --> 00:17:01,279
of how a gitrescript looks like

384
00:17:06,480 --> 00:17:09,599
yes so now we have we we know what a

385
00:17:09,599 --> 00:17:12,720
gitruscript is so let's go into P code

386
00:17:12,720 --> 00:17:15,059
so P code is the intermediate

387
00:17:15,059 --> 00:17:16,559
representation

388
00:17:16,559 --> 00:17:18,599
um in in gidra

389
00:17:18,599 --> 00:17:20,579
it's it's a it's registered transfer

390
00:17:20,579 --> 00:17:23,040
language so basically what it does it

391
00:17:23,040 --> 00:17:25,319
translates every assembly instructions

392
00:17:25,319 --> 00:17:29,820
to a set of p-code instructions what you

393
00:17:29,820 --> 00:17:31,100
see here

394
00:17:31,100 --> 00:17:34,440
oh there's a laser pointer cool so what

395
00:17:34,440 --> 00:17:38,160
you see here you can enable showing the

396
00:17:38,160 --> 00:17:43,080
P code in in the gitra UI just

397
00:17:43,080 --> 00:17:45,419
not left click here because that would

398
00:17:45,419 --> 00:17:47,460
be too easy you need to right click and

399
00:17:47,460 --> 00:17:50,280
enable it's totally trivial but anyway

400
00:17:50,280 --> 00:17:52,200
so here you can see this is one this is

401
00:17:52,200 --> 00:17:55,080
one assembly instruction and this was

402
00:17:55,080 --> 00:17:58,260
then uh this this is the equivalent of

403
00:17:58,260 --> 00:17:59,580
these set of

404
00:17:59,580 --> 00:18:04,200
um this set of P code operations and the

405
00:18:04,200 --> 00:18:08,760
whole point of P code is that is that

406
00:18:08,760 --> 00:18:12,360
makes every instruction uh pretty

407
00:18:12,360 --> 00:18:14,940
specific so for instance

408
00:18:14,940 --> 00:18:16,740
um if you

409
00:18:16,740 --> 00:18:18,419
if you're looking at the jump

410
00:18:18,419 --> 00:18:21,539
instructions for instance a jump F0 then

411
00:18:21,539 --> 00:18:23,700
to figure out whether that jump is going

412
00:18:23,700 --> 00:18:25,620
to be taken or not you you have to

413
00:18:25,620 --> 00:18:28,799
figure out which instruction changes the

414
00:18:28,799 --> 00:18:31,440
zero flag uh the last time

415
00:18:31,440 --> 00:18:33,419
um to do that in assembly you need to

416
00:18:33,419 --> 00:18:35,280
know which instructions have the side

417
00:18:35,280 --> 00:18:37,200
effect of changing the changing the zero

418
00:18:37,200 --> 00:18:39,720
flag so you know it's not impossible but

419
00:18:39,720 --> 00:18:41,640
it's very it's very architecture

420
00:18:41,640 --> 00:18:43,080
dependent so it's going to be different

421
00:18:43,080 --> 00:18:45,419
in different architectures and you

422
00:18:45,419 --> 00:18:47,059
actually have to like literally know

423
00:18:47,059 --> 00:18:49,919
yourself you know which instructions

424
00:18:49,919 --> 00:18:51,840
might do that you know often this is

425
00:18:51,840 --> 00:18:53,640
done by test and compare instructions

426
00:18:53,640 --> 00:18:55,679
but it doesn't have to be it could be

427
00:18:55,679 --> 00:18:57,360
any any other instructions that might

428
00:18:57,360 --> 00:19:00,900
change this flag now in P code

429
00:19:00,900 --> 00:19:03,059
in P code this is going to be very clear

430
00:19:03,059 --> 00:19:06,059
as you can see here for instance this is

431
00:19:06,059 --> 00:19:08,940
where the ZF flag is set so

432
00:19:08,940 --> 00:19:10,740
um when you when you want to figure out

433
00:19:10,740 --> 00:19:12,240
the same thing in p-code instead of

434
00:19:12,240 --> 00:19:14,340
assembly then you can just drag back to

435
00:19:14,340 --> 00:19:16,260
the last P code operation that actually

436
00:19:16,260 --> 00:19:19,140
says the ZF flag so it's it becomes uh

437
00:19:19,140 --> 00:19:22,559
very clear General the idea of using an

438
00:19:22,559 --> 00:19:24,240
intermediate representation is not new

439
00:19:24,240 --> 00:19:27,840
it actually comes from compilers so they

440
00:19:27,840 --> 00:19:31,140
also first lift the the source code to

441
00:19:31,140 --> 00:19:33,419
an intermediate representation and then

442
00:19:33,419 --> 00:19:36,679
do the uh the the the the the

443
00:19:36,679 --> 00:19:38,940
transformation from intermediate

444
00:19:38,940 --> 00:19:41,460
representation to assembly code in a

445
00:19:41,460 --> 00:19:44,000
separate uh in a separate

446
00:19:44,000 --> 00:19:47,160
method because the point is that the

447
00:19:47,160 --> 00:19:49,280
first part when you lift from

448
00:19:49,280 --> 00:19:51,299
source code to intermediate

449
00:19:51,299 --> 00:19:53,520
representation that still architecture

450
00:19:53,520 --> 00:19:55,200
independent and only the part when you

451
00:19:55,200 --> 00:19:57,780
translate your I or so the intermediate

452
00:19:57,780 --> 00:20:00,000
representation to to assembly or or

453
00:20:00,000 --> 00:20:01,919
machine code that's the only part that's

454
00:20:01,919 --> 00:20:03,120
going to be

455
00:20:03,120 --> 00:20:04,740
um that's going to be architecture

456
00:20:04,740 --> 00:20:06,539
dependent and it's similar with the

457
00:20:06,539 --> 00:20:09,299
compilers as well so um all the

458
00:20:09,299 --> 00:20:11,220
compilers use some kind of intermediate

459
00:20:11,220 --> 00:20:14,100
representation to take the assembly code

460
00:20:14,100 --> 00:20:19,639
back to some kind of pseudo C code

461
00:20:20,460 --> 00:20:22,020
um yes

462
00:20:22,020 --> 00:20:25,380
and just to make it more complicated

463
00:20:25,380 --> 00:20:27,480
um there are two kinds of P code in

464
00:20:27,480 --> 00:20:31,020
gitra the one is called ropey code and

465
00:20:31,020 --> 00:20:34,440
the other is called a high P code now I

466
00:20:34,440 --> 00:20:35,880
haven't find any kind of clear

467
00:20:35,880 --> 00:20:39,419
definition uh from an essay to what

468
00:20:39,419 --> 00:20:42,059
these are so I will just explain what I

469
00:20:42,059 --> 00:20:43,559
think they are

470
00:20:43,559 --> 00:20:44,220
um

471
00:20:44,220 --> 00:20:47,340
basically row P code is is the first

472
00:20:47,340 --> 00:20:50,400
stage what you can see what you can see

473
00:20:50,400 --> 00:20:53,760
in gitro when you enable P code or what

474
00:20:53,760 --> 00:20:56,039
you see when you just list the picot for

475
00:20:56,039 --> 00:20:58,039
an instruction this is a clear

476
00:20:58,039 --> 00:21:00,720
translation of that of one particle

477
00:21:00,720 --> 00:21:03,919
instruction to these set of p-code

478
00:21:03,919 --> 00:21:07,080
operations in this case we already have

479
00:21:07,080 --> 00:21:08,880
a great you know standardized structure

480
00:21:08,880 --> 00:21:12,419
of the P code and as I said we have uh

481
00:21:12,419 --> 00:21:15,000
we it's pretty clear all the things that

482
00:21:15,000 --> 00:21:16,380
are done by by that particular

483
00:21:16,380 --> 00:21:19,200
instruction however we don't have higher

484
00:21:19,200 --> 00:21:22,200
level high level context to our code so

485
00:21:22,200 --> 00:21:24,120
we don't have like function arguments we

486
00:21:24,120 --> 00:21:26,280
don't have variables and all these kind

487
00:21:26,280 --> 00:21:28,500
of things but it's already it's already

488
00:21:28,500 --> 00:21:31,679
a great help when we uh when we work in

489
00:21:31,679 --> 00:21:33,659
row b code

490
00:21:33,659 --> 00:21:38,340
but then a high P code is gonna is gonna

491
00:21:38,340 --> 00:21:41,780
take us a step further to uh to the

492
00:21:41,780 --> 00:21:44,340
decompiled source code it basically the

493
00:21:44,340 --> 00:21:46,620
last step before before getting the the

494
00:21:46,620 --> 00:21:49,799
pseudo code uh this is as I said it's

495
00:21:49,799 --> 00:21:52,380
the it's the output of the decompiler

496
00:21:52,380 --> 00:21:54,840
so whenever you want to get the high P

497
00:21:54,840 --> 00:21:56,820
code of a particular function then we

498
00:21:56,820 --> 00:21:59,400
have to call the uh we have to call the

499
00:21:59,400 --> 00:22:00,900
high function method with that

500
00:22:00,900 --> 00:22:02,880
particular function which can run the

501
00:22:02,880 --> 00:22:05,760
decompiler on that function and then in

502
00:22:05,760 --> 00:22:07,640
the high function object that we receive

503
00:22:07,640 --> 00:22:10,919
we will have the uh the high P code

504
00:22:10,919 --> 00:22:13,260
available now and the great thing with

505
00:22:13,260 --> 00:22:16,320
high P code is this this already has the

506
00:22:16,320 --> 00:22:19,380
same kind of context that we have in in

507
00:22:19,380 --> 00:22:21,960
source code so we have things like

508
00:22:21,960 --> 00:22:24,240
function arguments so if there is if

509
00:22:24,240 --> 00:22:26,820
there is a call to another function then

510
00:22:26,820 --> 00:22:30,840
then we can ask that that that operation

511
00:22:30,840 --> 00:22:33,059
what your arguments are and then it's

512
00:22:33,059 --> 00:22:34,679
going to give us the argument so it's

513
00:22:34,679 --> 00:22:36,120
not like in assembly you have to know

514
00:22:36,120 --> 00:22:38,820
that you know the arguments are pushed

515
00:22:38,820 --> 00:22:40,559
on the stack or they are transferred to

516
00:22:40,559 --> 00:22:43,620
whichever registers you can just ask

517
00:22:43,620 --> 00:22:46,980
that particular IP code operation what's

518
00:22:46,980 --> 00:22:49,559
your arguments and similarly with with

519
00:22:49,559 --> 00:22:50,900
variables

520
00:22:50,900 --> 00:22:53,940
the war node is like the generalized

521
00:22:53,940 --> 00:22:57,480
data element in in P code and if you

522
00:22:57,480 --> 00:22:59,159
have a war node which is kind of a

523
00:22:59,159 --> 00:23:01,520
variable then you can ask things like

524
00:23:01,520 --> 00:23:04,380
where you were defined and then you get

525
00:23:04,380 --> 00:23:06,120
back the the address the instruction

526
00:23:06,120 --> 00:23:09,960
address where this variable was last uh

527
00:23:09,960 --> 00:23:13,200
last set or or Define

528
00:23:13,200 --> 00:23:16,320
so at this level we have we have already

529
00:23:16,320 --> 00:23:18,600
pretty sophisticated tools to to

530
00:23:18,600 --> 00:23:23,299
navigate around uh in in a binary

531
00:23:24,059 --> 00:23:27,960
so why to use P code because it's cool

532
00:23:27,960 --> 00:23:29,400
no probably not

533
00:23:29,400 --> 00:23:30,659
[Music]

534
00:23:30,659 --> 00:23:34,799
so mostly because the fact that it's

535
00:23:34,799 --> 00:23:38,039
used by decompilers and and um and

536
00:23:38,039 --> 00:23:41,280
compilers uh kind of shows that it's a

537
00:23:41,280 --> 00:23:44,460
useful thing to do analysis

538
00:23:44,460 --> 00:23:46,740
um one great thing is that you get a

539
00:23:46,740 --> 00:23:48,480
generalized structure that it's easier

540
00:23:48,480 --> 00:23:51,679
to navigate pragmatically than than

541
00:23:51,679 --> 00:23:55,380
source code or assembly code and you can

542
00:23:55,380 --> 00:23:57,179
also get the architecture Independence

543
00:23:57,179 --> 00:23:59,880
as I said which is I think really great

544
00:23:59,880 --> 00:24:02,520
in ghidra because what that means is

545
00:24:02,520 --> 00:24:04,860
that if you write a grid script and you

546
00:24:04,860 --> 00:24:07,500
only use P code and never touch assembly

547
00:24:07,500 --> 00:24:10,740
that means that your script is going to

548
00:24:10,740 --> 00:24:12,900
work on all the architectures that are

549
00:24:12,900 --> 00:24:15,659
supported by guidrest decompiler if you

550
00:24:15,659 --> 00:24:18,539
would use assembly then then you

551
00:24:18,539 --> 00:24:20,280
basically would have to write a

552
00:24:20,280 --> 00:24:22,200
different script for every architecture

553
00:24:22,200 --> 00:24:25,200
you want to to run it on so this is a

554
00:24:25,200 --> 00:24:26,640
huge thing I think

555
00:24:26,640 --> 00:24:28,799
um might not be easy to always just

556
00:24:28,799 --> 00:24:31,260
stick to to B code uh but it's

557
00:24:31,260 --> 00:24:35,960
definitely worth it in my opinion

558
00:24:36,539 --> 00:24:40,380
all right so everybody gets a demo

559
00:24:40,380 --> 00:24:44,820
and so the second example is we are

560
00:24:44,820 --> 00:24:46,440
going to look at the P code and we are

561
00:24:46,440 --> 00:24:47,659
going to

562
00:24:47,659 --> 00:24:52,559
look at com functions so the Microsoft

563
00:24:52,559 --> 00:24:55,740
component object model which is com is

564
00:24:55,740 --> 00:24:58,559
just a difficult way to interface with

565
00:24:58,559 --> 00:25:01,200
other stuff so if I had to do this as my

566
00:25:01,200 --> 00:25:03,539
day job to to work with com objects I

567
00:25:03,539 --> 00:25:05,120
would probably shoot myself in the foot

568
00:25:05,120 --> 00:25:07,740
but you know I guess it's everybody's

569
00:25:07,740 --> 00:25:11,039
taste but the point is that com objects

570
00:25:11,039 --> 00:25:12,480
are interesting because malware often

571
00:25:12,480 --> 00:25:14,280
uses com objects as kind of an

572
00:25:14,280 --> 00:25:15,919
obfuscation method

573
00:25:15,919 --> 00:25:19,740
because basically com objects allows you

574
00:25:19,740 --> 00:25:22,380
to to interface with other programs on

575
00:25:22,380 --> 00:25:24,659
on windows so for instance you can

576
00:25:24,659 --> 00:25:26,760
control an Internet Explorer instance

577
00:25:26,760 --> 00:25:29,159
using a com object so what what the

578
00:25:29,159 --> 00:25:31,740
malware would do instead of using the

579
00:25:31,740 --> 00:25:34,140
normal networking API to code to talk to

580
00:25:34,140 --> 00:25:36,539
the common and control server it would

581
00:25:36,539 --> 00:25:39,480
just use an Internet Explorer instance

582
00:25:39,480 --> 00:25:43,080
and then talk to its com object to do

583
00:25:43,080 --> 00:25:46,020
its C2 communication now the reason why

584
00:25:46,020 --> 00:25:48,380
this is good for the malware is because

585
00:25:48,380 --> 00:25:51,900
it's much more difficult to spot so as I

586
00:25:51,900 --> 00:25:53,520
said at the beginning usually if you

587
00:25:53,520 --> 00:25:55,919
just look through the the imported

588
00:25:55,919 --> 00:25:57,600
functions and there is no application

589
00:25:57,600 --> 00:26:00,779
then you will immediately spot that it

590
00:26:00,779 --> 00:26:02,880
uses some kind of networking and it can

591
00:26:02,880 --> 00:26:04,799
just navigate there in the code and then

592
00:26:04,799 --> 00:26:06,600
you can super easily reverse engineer

593
00:26:06,600 --> 00:26:08,640
what the city communication is and how

594
00:26:08,640 --> 00:26:11,460
it works when it's done by com object or

595
00:26:11,460 --> 00:26:14,520
using com objects then then it's a pain

596
00:26:14,520 --> 00:26:16,740
just because using com objects is a pain

597
00:26:16,740 --> 00:26:18,960
so you know it's not going to be it's

598
00:26:18,960 --> 00:26:21,059
not going to be that obvious by by

599
00:26:21,059 --> 00:26:22,799
looking at the code

600
00:26:22,799 --> 00:26:25,919
so um in this script what we are going

601
00:26:25,919 --> 00:26:29,520
to do is uh is just go through the the

602
00:26:29,520 --> 00:26:31,919
binary and try to find out whether it

603
00:26:31,919 --> 00:26:35,279
uses any kind of com objects it's it's

604
00:26:35,279 --> 00:26:37,260
kind of like a simple Recon script so

605
00:26:37,260 --> 00:26:38,940
you can run it on every binary you're

606
00:26:38,940 --> 00:26:41,039
loading in gitra and it tells you

607
00:26:41,039 --> 00:26:43,140
whether whether there are com functions

608
00:26:43,140 --> 00:26:45,779
used and if they are then you know that

609
00:26:45,779 --> 00:26:47,340
you probably have to investigate that

610
00:26:47,340 --> 00:26:49,260
later on

611
00:26:49,260 --> 00:26:52,260
so

612
00:26:53,580 --> 00:26:56,418
let's see

613
00:27:01,020 --> 00:27:03,020
um

614
00:27:05,100 --> 00:27:08,179
so this is the second script

615
00:27:08,179 --> 00:27:12,419
here you can see I I manually hard coded

616
00:27:12,419 --> 00:27:14,760
all the uh all the functions that could

617
00:27:14,760 --> 00:27:17,400
be used to inter interact with uh with

618
00:27:17,400 --> 00:27:19,200
com objects

619
00:27:19,200 --> 00:27:21,840
and then we do a very similar thing that

620
00:27:21,840 --> 00:27:23,700
we did in the previous script so we get

621
00:27:23,700 --> 00:27:25,500
the symbol table we get the external

622
00:27:25,500 --> 00:27:27,720
symbols and then we basically Italy

623
00:27:27,720 --> 00:27:30,240
iterate through them and then here it

624
00:27:30,240 --> 00:27:33,600
starts the difference then then first we

625
00:27:33,600 --> 00:27:35,940
see whether the symbol we are looking at

626
00:27:35,940 --> 00:27:37,500
right now whether it's in the list of

627
00:27:37,500 --> 00:27:39,440
our con related

628
00:27:39,440 --> 00:27:42,179
functions if so then we find that you

629
00:27:42,179 --> 00:27:45,059
who we we found the com function

630
00:27:45,059 --> 00:27:46,500
um

631
00:27:46,500 --> 00:27:49,679
we we put specific attention to a

632
00:27:49,679 --> 00:27:51,240
co-create instance

633
00:27:51,240 --> 00:27:52,620
um that's going to be more important in

634
00:27:52,620 --> 00:27:55,380
the next script but basically the we can

635
00:27:55,380 --> 00:27:57,120
figure out what com objectives used by

636
00:27:57,120 --> 00:27:58,620
looking at the function called to

637
00:27:58,620 --> 00:28:00,179
co-create instance

638
00:28:00,179 --> 00:28:02,840
and once we find the co-create instance

639
00:28:02,840 --> 00:28:06,419
we we will look at all the uh all the

640
00:28:06,419 --> 00:28:08,640
cross references so basically all the

641
00:28:08,640 --> 00:28:10,620
places where concrete instance is called

642
00:28:10,620 --> 00:28:14,279
from the binary to see every instance

643
00:28:14,279 --> 00:28:17,400
when when a com object is instantiated

644
00:28:17,400 --> 00:28:19,740
and then and then we are going to print

645
00:28:19,740 --> 00:28:22,080
the the call side so the place where

646
00:28:22,080 --> 00:28:24,539
this function call is made uh in P code

647
00:28:24,539 --> 00:28:27,120
so that uh so that we can have an easy

648
00:28:27,120 --> 00:28:29,880
look uh in the logs to uh what happens

649
00:28:29,880 --> 00:28:32,159
at that place

650
00:28:32,159 --> 00:28:34,260
um

651
00:28:34,260 --> 00:28:36,840
so for instance here this is this is how

652
00:28:36,840 --> 00:28:38,820
we look at the cross references so we

653
00:28:38,820 --> 00:28:41,580
load all the cross references and then

654
00:28:41,580 --> 00:28:44,340
we get the instruction at that at that

655
00:28:44,340 --> 00:28:45,900
point

656
00:28:45,900 --> 00:28:50,039
um and just to show you uh this is for

657
00:28:50,039 --> 00:28:52,200
instance this is where how we get the

658
00:28:52,200 --> 00:28:54,600
basic block model of that of the whole

659
00:28:54,600 --> 00:28:56,700
program and then get the basic block

660
00:28:56,700 --> 00:28:58,320
this is what we want to pin to hold the

661
00:28:58,320 --> 00:29:00,900
whole blazing block of that particular

662
00:29:00,900 --> 00:29:03,299
address uh that are that's interesting

663
00:29:03,299 --> 00:29:04,320
for us

664
00:29:04,320 --> 00:29:06,659
and then

665
00:29:06,659 --> 00:29:09,360
yeah this is where P code is created so

666
00:29:09,360 --> 00:29:10,980
this is we are talking about rope code

667
00:29:10,980 --> 00:29:13,380
now in that case we just have we just

668
00:29:13,380 --> 00:29:15,120
have an instruction and then we say get

669
00:29:15,120 --> 00:29:18,179
P code and then we get a we get a p code

670
00:29:18,179 --> 00:29:20,820
operations array and that's that's what

671
00:29:20,820 --> 00:29:23,480
we are going to print

672
00:29:27,419 --> 00:29:29,820
oh wait let's

673
00:29:29,820 --> 00:29:33,500
let's empty this

674
00:29:34,320 --> 00:29:39,360
and run this again bam

675
00:29:40,159 --> 00:29:42,960
so we have much more interesting fun

676
00:29:42,960 --> 00:29:43,860
here

677
00:29:43,860 --> 00:29:46,980
so here you can see that we printed that

678
00:29:46,980 --> 00:29:49,320
we found the Ola initialize

679
00:29:49,320 --> 00:29:51,360
um which which we always which we're

680
00:29:51,360 --> 00:29:52,980
always going to find if if com objects

681
00:29:52,980 --> 00:29:55,080
are used and then we found the co-create

682
00:29:55,080 --> 00:29:57,000
instance and in this case we are going

683
00:29:57,000 --> 00:29:59,460
to go deeper into investigating that

684
00:29:59,460 --> 00:30:01,440
so checking call sites and then we see

685
00:30:01,440 --> 00:30:03,179
that we find uh we found the cross

686
00:30:03,179 --> 00:30:04,440
reference

687
00:30:04,440 --> 00:30:07,140
I don't know if I can I can zoom in

688
00:30:07,140 --> 00:30:08,880
sorry

689
00:30:08,880 --> 00:30:11,340
um we found a cross reference from this

690
00:30:11,340 --> 00:30:13,679
address to co-create instance and then

691
00:30:13,679 --> 00:30:15,299
we are printing that basic block and

692
00:30:15,299 --> 00:30:17,520
this is where you see uh this is where

693
00:30:17,520 --> 00:30:20,820
you see the P code obviously it's not so

694
00:30:20,820 --> 00:30:22,559
easy so it's not human readable that's

695
00:30:22,559 --> 00:30:24,659
not the point it should be you know

696
00:30:24,659 --> 00:30:26,399
machine readable

697
00:30:26,399 --> 00:30:29,159
um so for human readable work you you

698
00:30:29,159 --> 00:30:31,140
just use the assembly

699
00:30:31,140 --> 00:30:31,940
um

700
00:30:31,940 --> 00:30:35,220
and this is where the actual call call

701
00:30:35,220 --> 00:30:37,919
uh is is done

702
00:30:37,919 --> 00:30:42,539
so uh this was our second example so now

703
00:30:42,539 --> 00:30:44,520
we know that our binary has

704
00:30:44,520 --> 00:30:45,240
um

705
00:30:45,240 --> 00:30:48,840
uses com objects and uh and we know that

706
00:30:48,840 --> 00:30:51,679
it calls a co-create instance

707
00:30:51,679 --> 00:30:53,520
so

708
00:30:53,520 --> 00:30:55,919
so in the third example we're gonna go a

709
00:30:55,919 --> 00:30:59,279
little bit more deeper to figure out uh

710
00:30:59,279 --> 00:31:01,880
what that com object might be

711
00:31:01,880 --> 00:31:05,220
the two um the two

712
00:31:05,220 --> 00:31:08,399
values that can help us in that are the

713
00:31:08,399 --> 00:31:11,179
CLS ID and the IID

714
00:31:11,179 --> 00:31:13,860
for instance in

715
00:31:13,860 --> 00:31:15,500
in Windows

716
00:31:15,500 --> 00:31:18,600
you can look so these are both uuids so

717
00:31:18,600 --> 00:31:20,340
just huge numbers

718
00:31:20,340 --> 00:31:23,279
um in in Windows you can look up the

719
00:31:23,279 --> 00:31:27,240
clsi oh sorry the CLS ID in in the

720
00:31:27,240 --> 00:31:29,159
registry so basically you find the CLS

721
00:31:29,159 --> 00:31:31,500
ID you go to the registry and you look

722
00:31:31,500 --> 00:31:33,179
it up look it up and then it will tell

723
00:31:33,179 --> 00:31:34,919
you what program that is so it's going

724
00:31:34,919 --> 00:31:37,200
to tell you that this CLS ID is going to

725
00:31:37,200 --> 00:31:38,820
call internet export or it's going to

726
00:31:38,820 --> 00:31:40,740
call whatever

727
00:31:40,740 --> 00:31:41,340
um

728
00:31:41,340 --> 00:31:44,039
so this is how you can figure out

729
00:31:44,039 --> 00:31:47,039
um what what com object is being

730
00:31:47,039 --> 00:31:48,720
instantiated in your in your target

731
00:31:48,720 --> 00:31:51,419
application the IID is a bit more tricky

732
00:31:51,419 --> 00:31:54,240
uh probably you will need uh some time

733
00:31:54,240 --> 00:31:56,520
in Google to to figure out what a

734
00:31:56,520 --> 00:31:59,220
particular IID uh refers to but it's

735
00:31:59,220 --> 00:32:03,620
still useful to to recover

736
00:32:04,140 --> 00:32:06,740
all right

737
00:32:07,980 --> 00:32:10,679
so the first thing you are gonna spot

738
00:32:10,679 --> 00:32:13,919
here is that it's already

739
00:32:13,919 --> 00:32:17,700
a more a lengthier script I would say so

740
00:32:17,700 --> 00:32:19,500
it now already feels like it's not a

741
00:32:19,500 --> 00:32:21,960
screen but a but a real program

742
00:32:21,960 --> 00:32:24,779
uh part partially because as you can see

743
00:32:24,779 --> 00:32:27,480
here we have to set up the decompiler at

744
00:32:27,480 --> 00:32:29,640
this point uh because we are going to

745
00:32:29,640 --> 00:32:31,980
use a high P code sync update the

746
00:32:31,980 --> 00:32:34,080
compiler is pretty much boilerplate so

747
00:32:34,080 --> 00:32:36,120
you can copy paste it from any other

748
00:32:36,120 --> 00:32:38,279
guitar script that uses

749
00:32:38,279 --> 00:32:41,240
um uh uses the compiler

750
00:32:41,240 --> 00:32:44,220
so it's not too difficult but it has to

751
00:32:44,220 --> 00:32:45,080
turn

752
00:32:45,080 --> 00:32:48,480
and for instance this is how this is

753
00:32:48,480 --> 00:32:52,140
this is how a function is decompiled uh

754
00:32:52,140 --> 00:32:54,659
or the decompiler is created and then we

755
00:32:54,659 --> 00:32:56,760
call get high function and then we are

756
00:32:56,760 --> 00:32:59,700
going to have the high P code

757
00:32:59,700 --> 00:33:01,020
um there are a couple of helper

758
00:33:01,020 --> 00:33:03,659
functions just to like get good from

759
00:33:03,659 --> 00:33:05,000
byte array

760
00:33:05,000 --> 00:33:09,179
just to help print the uuids in a human

761
00:33:09,179 --> 00:33:12,360
readable form not just as a as a byte

762
00:33:12,360 --> 00:33:13,460
array

763
00:33:13,460 --> 00:33:18,980
and if we scroll down to run

764
00:33:19,220 --> 00:33:22,100
yeah it's pretty much the same

765
00:33:22,100 --> 00:33:25,440
except that once we once we find

766
00:33:25,440 --> 00:33:28,679
cochcreate instance uh we go and call

767
00:33:28,679 --> 00:33:31,860
the fine CLS ID and IID function and

768
00:33:31,860 --> 00:33:34,459
that's gonna

769
00:33:34,620 --> 00:33:37,380
and that's going to do the uh it's going

770
00:33:37,380 --> 00:33:39,059
to look up the function then it's going

771
00:33:39,059 --> 00:33:41,640
to decompile that function and then we

772
00:33:41,640 --> 00:33:44,640
go we are going to iterate through the

773
00:33:44,640 --> 00:33:49,140
um the IP code elements and this is this

774
00:33:49,140 --> 00:33:51,600
is basically why we are using hyper code

775
00:33:51,600 --> 00:33:54,960
at this point because uh once we

776
00:33:54,960 --> 00:33:57,299
once we find the find the call

777
00:33:57,299 --> 00:33:58,380
instruction

778
00:33:58,380 --> 00:34:00,299
here so we figure out that this

779
00:34:00,299 --> 00:34:02,460
operation is a call then we can do

780
00:34:02,460 --> 00:34:04,679
things like get input and we tell that

781
00:34:04,679 --> 00:34:06,240
we want the first input to that function

782
00:34:06,240 --> 00:34:07,980
call which is

783
00:34:07,980 --> 00:34:10,739
um if you looked at the image on the

784
00:34:10,739 --> 00:34:13,219
slide that's going to be the CLS ID

785
00:34:13,219 --> 00:34:15,780
in the corporate instance function call

786
00:34:15,780 --> 00:34:18,060
and the fourth input is going to be the

787
00:34:18,060 --> 00:34:20,940
IID so this is this is why P code is

788
00:34:20,940 --> 00:34:22,800
cool because we don't have to do any

789
00:34:22,800 --> 00:34:24,839
kind of you know backtracking or

790
00:34:24,839 --> 00:34:27,179
anything to find the arguments of that

791
00:34:27,179 --> 00:34:30,599
function we can just we can just call

792
00:34:30,599 --> 00:34:32,159
the get input function and it's going to

793
00:34:32,159 --> 00:34:33,739
tell us

794
00:34:33,739 --> 00:34:37,320
and so let's go here

795
00:34:37,320 --> 00:34:40,320
and run the third script

796
00:34:40,320 --> 00:34:42,679
parallel

797
00:34:42,679 --> 00:34:46,080
and it's mostly the same except here at

798
00:34:46,080 --> 00:34:48,780
the end and here you can

799
00:34:48,780 --> 00:34:51,800
see that we have we printed the CLS ID

800
00:34:51,800 --> 00:34:56,540
and the IID so great we have some

801
00:34:56,540 --> 00:34:59,460
useless numbers here but they're not so

802
00:34:59,460 --> 00:35:02,040
useless as I said you can look it up on

803
00:35:02,040 --> 00:35:05,160
Windows for instance if you run gauge

804
00:35:05,160 --> 00:35:06,720
around windows you could even implement

805
00:35:06,720 --> 00:35:09,480
it in your own script to to look the CLS

806
00:35:09,480 --> 00:35:12,180
ID up from from registry or you can just

807
00:35:12,180 --> 00:35:15,000
start googling and and figure out what

808
00:35:15,000 --> 00:35:16,859
these IDs are and at that point you're

809
00:35:16,859 --> 00:35:19,140
going to know whether your binary talks

810
00:35:19,140 --> 00:35:21,119
to Internet Explorer or whether it tries

811
00:35:21,119 --> 00:35:23,220
to control the firewall or you know

812
00:35:23,220 --> 00:35:26,880
whatever it's it it does using the com

813
00:35:26,880 --> 00:35:29,359
object

814
00:35:30,119 --> 00:35:32,420
all right

815
00:35:32,420 --> 00:35:35,579
and we are pretty much at the end

816
00:35:35,579 --> 00:35:38,940
um so a quick uh recap uh so gitro is

817
00:35:38,940 --> 00:35:39,960
great

818
00:35:39,960 --> 00:35:41,099
um

819
00:35:41,099 --> 00:35:43,619
especially you know if you don't want to

820
00:35:43,619 --> 00:35:46,079
pay for commercial tools then I

821
00:35:46,079 --> 00:35:48,079
definitely recommend to check out gitra

822
00:35:48,079 --> 00:35:51,839
uh P code and the SDK are very powerful

823
00:35:51,839 --> 00:35:54,599
for for automation so

824
00:35:54,599 --> 00:35:56,640
um I definitely recommend trying that

825
00:35:56,640 --> 00:35:58,800
out and experimenting it a little bit

826
00:35:58,800 --> 00:36:01,380
it's very well documented uh I I

827
00:36:01,380 --> 00:36:03,240
actually much prefer the documentation

828
00:36:03,240 --> 00:36:07,560
of ghidra over Ida Pro's documentation

829
00:36:07,560 --> 00:36:08,280
um

830
00:36:08,280 --> 00:36:10,380
But ultimately

831
00:36:10,380 --> 00:36:13,740
um I'm not a fanboy I I prefer to choose

832
00:36:13,740 --> 00:36:16,500
the tool depending on the tasks so if

833
00:36:16,500 --> 00:36:18,540
your tasks require you to use gitra and

834
00:36:18,540 --> 00:36:20,280
picode then you said if you want to use

835
00:36:20,280 --> 00:36:23,760
binary ninja then or or Ida Pro uh then

836
00:36:23,760 --> 00:36:25,380
do that

837
00:36:25,380 --> 00:36:27,720
a few references

838
00:36:27,720 --> 00:36:31,079
um Alexa and Ralph they wrote A Few cool

839
00:36:31,079 --> 00:36:33,560
stuff about using p code

840
00:36:33,560 --> 00:36:36,660
and Carlos a friend of mine helped with

841
00:36:36,660 --> 00:36:39,060
a couple of ideas

842
00:36:39,060 --> 00:36:42,540
and that's me so um if you have any

843
00:36:42,540 --> 00:36:44,040
questions

844
00:36:44,040 --> 00:36:45,660
let's hear it

845
00:36:45,660 --> 00:36:47,460
um if not then you can find me later

846
00:36:47,460 --> 00:36:50,400
during the two days so come to me and we

847
00:36:50,400 --> 00:36:52,920
can talk or you can reach out to me over

848
00:36:52,920 --> 00:36:55,200
you know any of these channels

849
00:36:55,200 --> 00:36:59,240
so yeah there's a question great

850
00:37:00,000 --> 00:37:03,540
uh yeah I can I can I will push it to

851
00:37:03,540 --> 00:37:05,940
GitHub so I have an account on GitHub

852
00:37:05,940 --> 00:37:08,160
you can search for my name and then you

853
00:37:08,160 --> 00:37:09,780
will find it

854
00:37:09,780 --> 00:37:12,320
sure

855
00:37:13,619 --> 00:37:15,540
all right then if no questions then

856
00:37:15,540 --> 00:37:17,820
thanks very much and have a fun

857
00:37:17,820 --> 00:37:20,540
conference

858
00:37:20,760 --> 00:37:23,480
foreign

859
00:37:25,220 --> 00:37:29,700
for the um very professional informative

860
00:37:29,700 --> 00:37:31,800
presentation we'll just take a few

861
00:37:31,800 --> 00:37:34,200
minutes before we are ready to start the

862
00:37:34,200 --> 00:37:37,098
next one thank you

