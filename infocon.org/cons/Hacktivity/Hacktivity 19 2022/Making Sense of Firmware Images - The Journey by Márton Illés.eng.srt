1
00:00:00,000 --> 00:00:01,860
welcome back for those who joined us uh

2
00:00:01,860 --> 00:00:03,600
yesterday and welcome for those joining

3
00:00:03,600 --> 00:00:06,299
us for the uh first time today

4
00:00:06,299 --> 00:00:07,740
we have a great selection of our

5
00:00:07,740 --> 00:00:10,500
presentations yesterday and today is

6
00:00:10,500 --> 00:00:12,000
going to be the same

7
00:00:12,000 --> 00:00:14,639
from the market leading Professionals in

8
00:00:14,639 --> 00:00:16,619
your industry

9
00:00:16,619 --> 00:00:18,539
you can choose between the security Dome

10
00:00:18,539 --> 00:00:21,000
here or the main hall from the agenda

11
00:00:21,000 --> 00:00:22,439
you've been given

12
00:00:22,439 --> 00:00:25,019
and take the chance to network check out

13
00:00:25,019 --> 00:00:26,760
the stands in the common areas of the

14
00:00:26,760 --> 00:00:29,400
building and there may be some places in

15
00:00:29,400 --> 00:00:30,960
the workshops if you're interested in

16
00:00:30,960 --> 00:00:34,739
that sit back relax enjoy your day our

17
00:00:34,739 --> 00:00:36,899
first Speaker today welcome to the stand

18
00:00:36,899 --> 00:00:39,420
Mr Martin

19
00:00:39,420 --> 00:00:41,700
thanks very much thanks for having me uh

20
00:00:41,700 --> 00:00:43,219
and good morning everybody

21
00:00:43,219 --> 00:00:46,379
and welcome every early riser

22
00:00:46,379 --> 00:00:49,879
uh today I would like to talk about

23
00:00:49,879 --> 00:00:53,039
firmware's and basically talk about how

24
00:00:53,039 --> 00:00:55,440
we can extract firmers uh but before we

25
00:00:55,440 --> 00:00:58,100
begin I'm just curious is everybody ever

26
00:00:58,100 --> 00:01:00,539
worked with firmers like reverse

27
00:01:00,539 --> 00:01:03,300
engineering or or doing any security

28
00:01:03,300 --> 00:01:05,220
analysis

29
00:01:05,220 --> 00:01:07,500
all right it's good all right so then

30
00:01:07,500 --> 00:01:09,479
hopefully I can show you some

31
00:01:09,479 --> 00:01:13,560
interesting insights into that so um uh

32
00:01:13,560 --> 00:01:16,320
let me just quickly uh jump on it um I'm

33
00:01:16,320 --> 00:01:18,299
working for a company called wonky and

34
00:01:18,299 --> 00:01:20,040
basically what we are doing is automated

35
00:01:20,040 --> 00:01:23,460
firmware analysis and um what I would

36
00:01:23,460 --> 00:01:26,100
like to present uh to you today is a new

37
00:01:26,100 --> 00:01:27,600
open source tool which is called

38
00:01:27,600 --> 00:01:30,060
envelope which was basically born from

39
00:01:30,060 --> 00:01:31,860
the problem that we were facing by

40
00:01:31,860 --> 00:01:34,259
working with firmers in any firmware

41
00:01:34,259 --> 00:01:36,180
analysis or any any analysis the first

42
00:01:36,180 --> 00:01:38,100
step is always like I have a firmer

43
00:01:38,100 --> 00:01:40,259
image I don't really know what it is and

44
00:01:40,259 --> 00:01:42,600
I somehow need to unpack if it's a Linux

45
00:01:42,600 --> 00:01:44,820
system or maybe another system I need to

46
00:01:44,820 --> 00:01:47,220
somehow extract it and the problem we

47
00:01:47,220 --> 00:01:49,079
were facing that there are so many tools

48
00:01:49,079 --> 00:01:53,100
out there specific to one firmware or

49
00:01:53,100 --> 00:01:55,619
one format and we have to always like

50
00:01:55,619 --> 00:01:57,119
figure out like all right this firmware

51
00:01:57,119 --> 00:01:59,520
is by this vendor and I need to use this

52
00:01:59,520 --> 00:02:01,740
script and if it's another one I need to

53
00:02:01,740 --> 00:02:03,600
go to GitHub I need to pull another one

54
00:02:03,600 --> 00:02:05,640
and I need to figure out how to extract

55
00:02:05,640 --> 00:02:07,680
the firmware so basically what we were

56
00:02:07,680 --> 00:02:10,440
looking for uh as a tool that we can use

57
00:02:10,440 --> 00:02:12,780
in an automated way or a semi-automated

58
00:02:12,780 --> 00:02:15,420
way at least which will do all this work

59
00:02:15,420 --> 00:02:17,940
for us in an efficient way

60
00:02:17,940 --> 00:02:21,239
so basically uh we wanted to create a

61
00:02:21,239 --> 00:02:24,540
framework to extract firmware and we

62
00:02:24,540 --> 00:02:26,400
created envelope and open sourced it it

63
00:02:26,400 --> 00:02:29,099
currently has support for over 30

64
00:02:29,099 --> 00:02:32,099
formats built in it's counting and

65
00:02:32,099 --> 00:02:33,959
basically it can handle different

66
00:02:33,959 --> 00:02:36,660
archive formats like the traditional one

67
00:02:36,660 --> 00:02:39,840
starting from zip or tar files it can do

68
00:02:39,840 --> 00:02:42,780
different types of compressions as well

69
00:02:42,780 --> 00:02:45,720
and a bunch of file system format that

70
00:02:45,720 --> 00:02:49,019
you typically see in embedit or iot or

71
00:02:49,019 --> 00:02:51,120
OT or iiot or whatever buzzword you want

72
00:02:51,120 --> 00:02:54,060
to choose in in the live

73
00:02:54,060 --> 00:02:57,959
when we uh started to um to work on

74
00:02:57,959 --> 00:03:00,000
envelope we wanted to basically find

75
00:03:00,000 --> 00:03:01,739
something that can deal with arbitrary

76
00:03:01,739 --> 00:03:04,019
formats in many cases the difficulty is

77
00:03:04,019 --> 00:03:07,319
like figuring out like what the format

78
00:03:07,319 --> 00:03:09,180
itself is and dealing with a problem

79
00:03:09,180 --> 00:03:12,659
that uh many firmware images have uh

80
00:03:12,659 --> 00:03:14,519
what I would call like a Matryoshka

81
00:03:14,519 --> 00:03:16,739
format where there is different layers

82
00:03:16,739 --> 00:03:18,780
and layers and layers and you might

83
00:03:18,780 --> 00:03:21,540
unpack one and then you face another one

84
00:03:21,540 --> 00:03:24,120
and we wanted something that we can just

85
00:03:24,120 --> 00:03:28,080
work on it work on in with arbitrary

86
00:03:28,080 --> 00:03:30,300
formats and work also with untrusted

87
00:03:30,300 --> 00:03:33,000
format it's very bad and we have seen

88
00:03:33,000 --> 00:03:35,340
cases where there are some malicious

89
00:03:35,340 --> 00:03:37,739
thing in the in the uh in the packing

90
00:03:37,739 --> 00:03:39,780
just think about like Zip bombs and and

91
00:03:39,780 --> 00:03:41,819
stuff like that

92
00:03:41,819 --> 00:03:44,700
so basically uh when we set out on this

93
00:03:44,700 --> 00:03:47,280
journey and I will show you today in in

94
00:03:47,280 --> 00:03:49,739
details we defined few objectives we

95
00:03:49,739 --> 00:03:52,080
wanted to achieve so we wanted to have a

96
00:03:52,080 --> 00:03:54,420
tool that's very accurate uh in any

97
00:03:54,420 --> 00:03:56,220
analysis that you might have contacted

98
00:03:56,220 --> 00:03:58,620
or from our experiences that if we are

99
00:03:58,620 --> 00:04:00,060
not accurate then basically we are

100
00:04:00,060 --> 00:04:02,340
facing with this garbage in garbage out

101
00:04:02,340 --> 00:04:04,019
problem if you have a firmware we

102
00:04:04,019 --> 00:04:05,700
extract it and it produces a lot of

103
00:04:05,700 --> 00:04:08,340
garbage then any further analysis I do

104
00:04:08,340 --> 00:04:10,379
on top of that might it be some manual

105
00:04:10,379 --> 00:04:12,480
analysis some automated analysis or an

106
00:04:12,480 --> 00:04:15,360
emulation for that matter but uh if I

107
00:04:15,360 --> 00:04:18,238
get a lot of junk it makes my life very

108
00:04:18,238 --> 00:04:21,180
very uh hard the second objective

109
00:04:21,180 --> 00:04:23,040
obviously we are dealing in the field of

110
00:04:23,040 --> 00:04:25,560
security we wanted something that not

111
00:04:25,560 --> 00:04:27,000
introducing too much of an attack

112
00:04:27,000 --> 00:04:29,040
service so you want to make sure that

113
00:04:29,040 --> 00:04:32,460
the extraction process is as secure as

114
00:04:32,460 --> 00:04:35,040
possible against things like like Zip

115
00:04:35,040 --> 00:04:38,280
bombs or past traversal attacks

116
00:04:38,280 --> 00:04:41,639
also it's it was very important that we

117
00:04:41,639 --> 00:04:44,520
envisioned a tool that's very easy to

118
00:04:44,520 --> 00:04:45,840
extend

119
00:04:45,840 --> 00:04:48,360
um a lot of us in the in the reverse

120
00:04:48,360 --> 00:04:50,040
engineering or in the security Community

121
00:04:50,040 --> 00:04:52,380
when we Face a new format we just write

122
00:04:52,380 --> 00:04:55,080
quickly a script and then maybe push it

123
00:04:55,080 --> 00:04:57,780
on GitHub if they are cool or we just

124
00:04:57,780 --> 00:04:59,520
forget it somewhere around our hard

125
00:04:59,520 --> 00:05:02,520
drive or God knows where and then the

126
00:05:02,520 --> 00:05:04,860
next time we Face the same problem we

127
00:05:04,860 --> 00:05:06,240
might remember that oh I had a script

128
00:05:06,240 --> 00:05:08,820
maybe I just rewrite it but we wanted to

129
00:05:08,820 --> 00:05:11,400
create something that I can as a

130
00:05:11,400 --> 00:05:13,680
researcher very easily extend and add a

131
00:05:13,680 --> 00:05:15,960
new format so at the end of the day I

132
00:05:15,960 --> 00:05:17,820
will have a library of all the formats

133
00:05:17,820 --> 00:05:21,000
and in one tool which can unpack all

134
00:05:21,000 --> 00:05:23,160
this all this file and last but not

135
00:05:23,160 --> 00:05:25,020
least sometimes we have to deal with

136
00:05:25,020 --> 00:05:28,320
large server a lot of firmware so we

137
00:05:28,320 --> 00:05:29,759
wanted something that can actually

138
00:05:29,759 --> 00:05:32,880
perform well and not too slow at the end

139
00:05:32,880 --> 00:05:35,280
of the day it's not like we are talking

140
00:05:35,280 --> 00:05:37,320
about milliseconds or seconds but it's

141
00:05:37,320 --> 00:05:39,360
good if you can uh get results in

142
00:05:39,360 --> 00:05:41,220
minutes so these were basically our

143
00:05:41,220 --> 00:05:44,220
objective when we set out it was very

144
00:05:44,220 --> 00:05:46,800
funny when we announced that basically

145
00:05:46,800 --> 00:05:49,259
we get some some results we were using

146
00:05:49,259 --> 00:05:52,080
also bimbok and basically we wanted to

147
00:05:52,080 --> 00:05:55,020
something uh like this um like Dave

148
00:05:55,020 --> 00:05:57,479
mentioned it this is something like Bill

149
00:05:57,479 --> 00:05:59,340
mocked wants to be when it grows up so

150
00:05:59,340 --> 00:06:03,060
we it's also uh like a replacement for

151
00:06:03,060 --> 00:06:04,080
that

152
00:06:04,080 --> 00:06:06,240
with that said what I would like to talk

153
00:06:06,240 --> 00:06:08,460
about today is basically just give you a

154
00:06:08,460 --> 00:06:10,259
very quick introduction to the tool

155
00:06:10,259 --> 00:06:13,320
envelope getting started uh jump into

156
00:06:13,320 --> 00:06:15,180
some details and show you how the

157
00:06:15,180 --> 00:06:17,580
extraction and Analysis is done uh we

158
00:06:17,580 --> 00:06:19,199
have some cool reporting features built

159
00:06:19,199 --> 00:06:21,300
in I would like to Showcase to that and

160
00:06:21,300 --> 00:06:23,100
what I'm planning to do today to show

161
00:06:23,100 --> 00:06:25,199
the extensibility and also welcome

162
00:06:25,199 --> 00:06:27,300
everybody to contribute to the tool and

163
00:06:27,300 --> 00:06:29,039
show you how to create a new format

164
00:06:29,039 --> 00:06:31,259
Handler which can deal with a format

165
00:06:31,259 --> 00:06:33,539
that has not been supported before and

166
00:06:33,539 --> 00:06:35,759
also show you how that format can be

167
00:06:35,759 --> 00:06:38,160
extracted so that's the plan today I

168
00:06:38,160 --> 00:06:39,479
don't have too many slides and I will

169
00:06:39,479 --> 00:06:42,300
jump on the demos

170
00:06:42,300 --> 00:06:44,880
but uh first thing first let's see how

171
00:06:44,880 --> 00:06:47,400
to get started with envelope even before

172
00:06:47,400 --> 00:06:49,259
that a big kudos to the team who

173
00:06:49,259 --> 00:06:51,780
actually had to create it and again I

174
00:06:51,780 --> 00:06:53,520
would encourage everybody contribute I'm

175
00:06:53,520 --> 00:06:55,620
very happy to put any of you on the

176
00:06:55,620 --> 00:06:58,139
slides next year it would be so great

177
00:06:58,139 --> 00:07:00,419
all right so basically

178
00:07:00,419 --> 00:07:02,400
um there is three ways

179
00:07:02,400 --> 00:07:04,919
um to install envelope and we wanted to

180
00:07:04,919 --> 00:07:07,380
make it super simple one is that we

181
00:07:07,380 --> 00:07:09,900
created a pre-packaged Docker image that

182
00:07:09,900 --> 00:07:11,699
you can just pull it and use it so there

183
00:07:11,699 --> 00:07:13,259
is no need to install any dependencies

184
00:07:13,259 --> 00:07:15,720
and whatnot I think this is the easiest

185
00:07:15,720 --> 00:07:18,600
way to use the second one is to use NYX

186
00:07:18,600 --> 00:07:21,300
I'm just curious anybody's using NYX

187
00:07:21,300 --> 00:07:23,099
here

188
00:07:23,099 --> 00:07:26,639
okay anybody okay anybody knows Nicks so

189
00:07:26,639 --> 00:07:28,919
if you haven't used NYX check out it's

190
00:07:28,919 --> 00:07:31,440
an awesome cool uh dependency management

191
00:07:31,440 --> 00:07:35,099
system uh basically I would say on

192
00:07:35,099 --> 00:07:36,900
package management the best thing since

193
00:07:36,900 --> 00:07:39,419
sliced bread so it's really cool

194
00:07:39,419 --> 00:07:41,460
um uh it's it's a good thing and of

195
00:07:41,460 --> 00:07:43,919
course the third way uh to deal with

196
00:07:43,919 --> 00:07:46,139
um envelope or just to get it get the

197
00:07:46,139 --> 00:07:49,020
source it's on GitHub and just install

198
00:07:49,020 --> 00:07:51,479
all the dependencies yourself

199
00:07:51,479 --> 00:07:54,360
so um I said with Docker it's super

200
00:07:54,360 --> 00:07:55,680
simple

201
00:07:55,680 --> 00:07:58,500
um we are publishing basically always

202
00:07:58,500 --> 00:08:01,380
from the master Branch a latest Docker

203
00:08:01,380 --> 00:08:04,680
image on GitHub and all you need to do

204
00:08:04,680 --> 00:08:08,099
is just run it uh volume Mount uh the

205
00:08:08,099 --> 00:08:09,479
source directory the destination

206
00:08:09,479 --> 00:08:11,699
directory and everything else is taken

207
00:08:11,699 --> 00:08:12,419
care

208
00:08:12,419 --> 00:08:15,479
uh also if you are using NYX

209
00:08:15,479 --> 00:08:17,940
um you just need to install NYX and then

210
00:08:17,940 --> 00:08:19,979
all the dependencies are automatically

211
00:08:19,979 --> 00:08:22,319
installed and pulled in so you don't

212
00:08:22,319 --> 00:08:24,180
need to figure out one by one like oh

213
00:08:24,180 --> 00:08:27,479
how do I install my lzip compress the

214
00:08:27,479 --> 00:08:29,879
compressor or tar or whatever tools we

215
00:08:29,879 --> 00:08:33,659
are using uh to do the actual extraction

216
00:08:33,659 --> 00:08:35,520
and of course

217
00:08:35,520 --> 00:08:37,799
um if you want to go to the source just

218
00:08:37,799 --> 00:08:40,799
get clone it from GitHub we are using

219
00:08:40,799 --> 00:08:42,659
poetry for dependency management so

220
00:08:42,659 --> 00:08:44,219
basically all you need to do is just run

221
00:08:44,219 --> 00:08:46,800
poetry install you'll get the base but

222
00:08:46,800 --> 00:08:48,660
it also means that you need to manually

223
00:08:48,660 --> 00:08:51,720
install all the extraction

224
00:08:51,720 --> 00:08:52,980
so

225
00:08:52,980 --> 00:08:55,080
um with that said

226
00:08:55,080 --> 00:08:58,820
um let's extract some stuff

227
00:08:59,100 --> 00:09:00,839
so

228
00:09:00,839 --> 00:09:04,019
all right so um I would show you I'm

229
00:09:04,019 --> 00:09:05,660
obviously in my laptop I have everything

230
00:09:05,660 --> 00:09:08,100
installed I hope you can let me make it

231
00:09:08,100 --> 00:09:10,260
a bit bigger so everybody even in the

232
00:09:10,260 --> 00:09:13,140
last row can read it using it is very

233
00:09:13,140 --> 00:09:15,000
very simple

234
00:09:15,000 --> 00:09:15,600
um

235
00:09:15,600 --> 00:09:18,839
we have a extensive help page describing

236
00:09:18,839 --> 00:09:21,480
it you can read it if you get lost but

237
00:09:21,480 --> 00:09:23,399
nobody reads documentation as you know

238
00:09:23,399 --> 00:09:26,399
so running it is super simple you just

239
00:09:26,399 --> 00:09:28,080
need to Define what is the extraction

240
00:09:28,080 --> 00:09:31,200
directory I will just pick a directory

241
00:09:31,200 --> 00:09:34,320
and then you need to specify a firmware

242
00:09:34,320 --> 00:09:37,200
image so I prepared a few

243
00:09:37,200 --> 00:09:39,540
um image let's start with an open VRT

244
00:09:39,540 --> 00:09:42,420
one that's fairly simple

245
00:09:42,420 --> 00:09:45,839
and basically what it does it goes

246
00:09:45,839 --> 00:09:48,480
through the file and does the extraction

247
00:09:48,480 --> 00:09:52,200
and if I go I'm very old school so I

248
00:09:52,200 --> 00:09:54,420
would use midnight Commander

249
00:09:54,420 --> 00:09:57,180
um then all the files are extracted so

250
00:09:57,180 --> 00:09:58,980
basically you can see that here is the

251
00:09:58,980 --> 00:10:03,060
open VRT extract and it got extracted it

252
00:10:03,060 --> 00:10:05,399
basically tries to find some chunks in

253
00:10:05,399 --> 00:10:07,440
it and then goes through all the

254
00:10:07,440 --> 00:10:09,540
extraction process so first it detected

255
00:10:09,540 --> 00:10:12,720
that there is some gzip compression that

256
00:10:12,720 --> 00:10:15,560
it extracted it then it went forward

257
00:10:15,560 --> 00:10:19,680
with the content what's inside gzip and

258
00:10:19,680 --> 00:10:22,140
extracted it it detected some file

259
00:10:22,140 --> 00:10:24,660
system in this case some x file systems

260
00:10:24,660 --> 00:10:26,820
then I can go there and all the files

261
00:10:26,820 --> 00:10:29,940
are there and uh I can I can work with

262
00:10:29,940 --> 00:10:33,300
all the all the files I need so it's

263
00:10:33,300 --> 00:10:35,300
it's super super simple

264
00:10:35,300 --> 00:10:38,760
the power of of envelope that it's not

265
00:10:38,760 --> 00:10:41,399
just trying to blindly unpack everything

266
00:10:41,399 --> 00:10:43,860
and try to find everything there but it

267
00:10:43,860 --> 00:10:45,839
tries to be very very precise one of the

268
00:10:45,839 --> 00:10:48,000
gold as I stated in the beginning is

269
00:10:48,000 --> 00:10:51,180
accuracy which means also that there are

270
00:10:51,180 --> 00:10:53,339
certain cases in files where we

271
00:10:53,339 --> 00:10:56,640
encounter a unknown chunks sometimes we

272
00:10:56,640 --> 00:10:58,380
detect that hey here is a file system

273
00:10:58,380 --> 00:11:01,079
this is how long it is and there is some

274
00:11:01,079 --> 00:11:03,899
data after that so we are trying to also

275
00:11:03,899 --> 00:11:06,540
flag these unknown chunks and also carve

276
00:11:06,540 --> 00:11:08,880
out from the files so maybe it can be

277
00:11:08,880 --> 00:11:11,160
analyzed later it might be some padding

278
00:11:11,160 --> 00:11:13,320
it might be some digital signature in

279
00:11:13,320 --> 00:11:15,000
some cases or it might be just some

280
00:11:15,000 --> 00:11:16,920
format that envelope is currently not

281
00:11:16,920 --> 00:11:19,680
supporting so we give the chance and try

282
00:11:19,680 --> 00:11:21,720
to be very explicitly what we can deal

283
00:11:21,720 --> 00:11:23,820
with that we what we cannot deal with so

284
00:11:23,820 --> 00:11:26,700
if I just go there you can see it's

285
00:11:26,700 --> 00:11:29,640
actually a group boot record which we

286
00:11:29,640 --> 00:11:31,920
don't handle right now but you can also

287
00:11:31,920 --> 00:11:34,079
go to the end and see that it's probably

288
00:11:34,079 --> 00:11:37,920
some padding at the end we are planning

289
00:11:37,920 --> 00:11:39,839
to add obviously more support for these

290
00:11:39,839 --> 00:11:42,600
but we are trying to be very explicit on

291
00:11:42,600 --> 00:11:45,180
what can be extracted and what cannot be

292
00:11:45,180 --> 00:11:46,740
extracted

293
00:11:46,740 --> 00:11:49,620
another cool feature of envelope is not

294
00:11:49,620 --> 00:11:51,839
just that it can extract the data and

295
00:11:51,839 --> 00:11:54,300
extract the the files but it can also

296
00:11:54,300 --> 00:11:56,820
report on what it did find and what it

297
00:11:56,820 --> 00:11:57,899
did not find

298
00:11:57,899 --> 00:12:01,980
so let me just override a previous file

299
00:12:01,980 --> 00:12:04,560
and add a report to it

300
00:12:04,560 --> 00:12:06,959
so basically everything we detected can

301
00:12:06,959 --> 00:12:09,120
be written into a report so let me just

302
00:12:09,120 --> 00:12:12,019
quickly rerun it

303
00:12:13,500 --> 00:12:18,839
and then I have a Json report

304
00:12:18,839 --> 00:12:22,339
I'm very bad with

305
00:12:25,079 --> 00:12:27,800
report

306
00:12:27,839 --> 00:12:31,279
so basically I get a very detailed

307
00:12:31,279 --> 00:12:34,519
understanding of like what we uh

308
00:12:34,519 --> 00:12:38,100
extracted if there are any files that we

309
00:12:38,100 --> 00:12:40,800
identified we are also reporting on the

310
00:12:40,800 --> 00:12:43,740
size whether it's a file uh we are also

311
00:12:43,740 --> 00:12:45,420
reporting on every file if we detect

312
00:12:45,420 --> 00:12:48,139
that we detected the hash information

313
00:12:48,139 --> 00:12:50,940
and also we are reporting the unknown

314
00:12:50,940 --> 00:12:53,160
chunks stating what are the start offset

315
00:12:53,160 --> 00:12:56,160
and offset size so we try to give all

316
00:12:56,160 --> 00:12:58,920
the information we also created a very

317
00:12:58,920 --> 00:13:01,200
simple tool let me just quickly switch

318
00:13:01,200 --> 00:13:05,339
there oops I'm just using Jupiter

319
00:13:05,339 --> 00:13:09,440
where we can basically load this report

320
00:13:09,440 --> 00:13:12,839
and generate the chart which can

321
00:13:12,839 --> 00:13:15,000
visualize how the firmware is actually

322
00:13:15,000 --> 00:13:17,760
built so this stun burst is actually

323
00:13:17,760 --> 00:13:19,860
representing the different layers of the

324
00:13:19,860 --> 00:13:22,200
firmware if I move there I can read the

325
00:13:22,200 --> 00:13:24,320
details I can see what was the file size

326
00:13:24,320 --> 00:13:27,720
where the actual file is and I have the

327
00:13:27,720 --> 00:13:31,260
ability to zoom in so uh if I'm

328
00:13:31,260 --> 00:13:33,120
interested I can see different layers

329
00:13:33,120 --> 00:13:35,639
let's say I'm interested in the big one

330
00:13:35,639 --> 00:13:38,220
so I just double click on it and I can

331
00:13:38,220 --> 00:13:41,700
precisely see like what is included in

332
00:13:41,700 --> 00:13:44,820
the file so this is just a simple one to

333
00:13:44,820 --> 00:13:48,000
get me an overview of what we identified

334
00:13:48,000 --> 00:13:50,100
uh it's also very cool let me show you

335
00:13:50,100 --> 00:13:52,560
because some people might prefer other

336
00:13:52,560 --> 00:13:53,779
ways

337
00:13:53,779 --> 00:13:56,519
instead of a sunburst

338
00:13:56,519 --> 00:14:00,240
you can also get a tree map and see like

339
00:14:00,240 --> 00:14:02,519
what the what the contents are so it's

340
00:14:02,519 --> 00:14:04,560
very very easy to very quickly

341
00:14:04,560 --> 00:14:08,700
identified uh what's lurking within a

342
00:14:08,700 --> 00:14:11,279
firmware also you can very quickly see

343
00:14:11,279 --> 00:14:13,740
like if we identified a unknown chunk

344
00:14:13,740 --> 00:14:16,200
where it is located in the file what is

345
00:14:16,200 --> 00:14:18,959
the size uh I I did not put it here but

346
00:14:18,959 --> 00:14:21,000
you also calculate the entropy of it so

347
00:14:21,000 --> 00:14:22,139
you can get an understanding whether

348
00:14:22,139 --> 00:14:25,500
it's maybe compressed or encrypted

349
00:14:25,500 --> 00:14:28,620
um or maybe just a padding if the if the

350
00:14:28,620 --> 00:14:29,600
uh

351
00:14:29,600 --> 00:14:33,300
entropy is very very low so hopefully

352
00:14:33,300 --> 00:14:36,740
this gives you a tool that

353
00:14:36,740 --> 00:14:41,459
helps with the extraction process

354
00:14:41,459 --> 00:14:43,500
and that's it let me just jump back to

355
00:14:43,500 --> 00:14:46,139
the presentation and talk a bit about

356
00:14:46,139 --> 00:14:49,560
how unblock Works under the hood so

357
00:14:49,560 --> 00:14:51,720
basically the way how envelope is is

358
00:14:51,720 --> 00:14:53,639
constructed that it is scanning for

359
00:14:53,639 --> 00:14:56,339
certain format patterns every format

360
00:14:56,339 --> 00:14:57,959
Handler can define a pattern which is

361
00:14:57,959 --> 00:15:00,899
usually some some magic or some pattern

362
00:15:00,899 --> 00:15:02,699
that we can search for we are using

363
00:15:02,699 --> 00:15:04,500
hyperscan which is a very cool library

364
00:15:04,500 --> 00:15:07,079
from Intel which is a super fast uh reg

365
00:15:07,079 --> 00:15:10,380
X Factor so we are using it to find uh

366
00:15:10,380 --> 00:15:13,380
patterns within the file once you find a

367
00:15:13,380 --> 00:15:15,720
pattern then basically the handlers

368
00:15:15,720 --> 00:15:17,940
which are specific to a format

369
00:15:17,940 --> 00:15:20,100
they are calculating the size of the

370
00:15:20,100 --> 00:15:22,440
chunk so if I have one big binary files

371
00:15:22,440 --> 00:15:24,720
which might have let's say multiple file

372
00:15:24,720 --> 00:15:26,699
system packed in it may be packed after

373
00:15:26,699 --> 00:15:28,440
each other maybe there are some pannings

374
00:15:28,440 --> 00:15:30,839
between that then the handlers through

375
00:15:30,839 --> 00:15:34,380
the pattern can pick up those chunks and

376
00:15:34,380 --> 00:15:36,540
then based on the chunk content we can

377
00:15:36,540 --> 00:15:39,240
calculate how big the chunk is so we

378
00:15:39,240 --> 00:15:40,980
exactly know where the start of the

379
00:15:40,980 --> 00:15:42,959
chunk and the end of the chunk is so we

380
00:15:42,959 --> 00:15:44,880
can carve it out so we are basically

381
00:15:44,880 --> 00:15:46,320
carving out all the chunks that we

382
00:15:46,320 --> 00:15:48,660
identified and we are also carving out

383
00:15:48,660 --> 00:15:51,120
all the leftovers which are basically

384
00:15:51,120 --> 00:15:54,680
the unknown chunks uh in the game

385
00:15:54,680 --> 00:15:58,620
excuse me now one the once the extract

386
00:15:58,620 --> 00:16:01,019
once the carving gout is done we can use

387
00:16:01,019 --> 00:16:03,300
the extractor the reason why we do this

388
00:16:03,300 --> 00:16:05,339
carving out that we in some cases you

389
00:16:05,339 --> 00:16:07,620
are using some external uh extractor for

390
00:16:07,620 --> 00:16:09,300
example if it's a zip file that you're

391
00:16:09,300 --> 00:16:11,519
just using for example 7-Zip to do the

392
00:16:11,519 --> 00:16:14,220
actual extraction but seven zip does not

393
00:16:14,220 --> 00:16:18,060
know how to unzip from a file and an

394
00:16:18,060 --> 00:16:20,399
offset within a file so we need one file

395
00:16:20,399 --> 00:16:23,699
which is itself a zip file in this case

396
00:16:23,699 --> 00:16:26,459
so uh we have the carbs we are

397
00:16:26,459 --> 00:16:27,660
extracting it

398
00:16:27,660 --> 00:16:30,000
and we are calculating the entropy for

399
00:16:30,000 --> 00:16:32,279
the unknown chunks and then basically

400
00:16:32,279 --> 00:16:34,139
recursively iterates through all the

401
00:16:34,139 --> 00:16:36,480
extracted files to handle this material

402
00:16:36,480 --> 00:16:39,660
problem to deal with uh any embedded or

403
00:16:39,660 --> 00:16:42,420
other layer of operation so this is the

404
00:16:42,420 --> 00:16:43,980
the high level

405
00:16:43,980 --> 00:16:46,980
now the architecture of of um and just a

406
00:16:46,980 --> 00:16:49,380
few words on the architecture the

407
00:16:49,380 --> 00:16:51,420
architecture of fumble be super super

408
00:16:51,420 --> 00:16:53,579
simple we're basically providing you a

409
00:16:53,579 --> 00:16:54,660
core

410
00:16:54,660 --> 00:16:56,279
um again everything is open source here

411
00:16:56,279 --> 00:16:59,820
the core provided uh as a CLI so it's

412
00:16:59,820 --> 00:17:01,380
the command line tool which I just shown

413
00:17:01,380 --> 00:17:03,180
you but it's also available as a library

414
00:17:03,180 --> 00:17:04,919
so if you want to embed it into another

415
00:17:04,919 --> 00:17:06,720
python project because envelope is

416
00:17:06,720 --> 00:17:08,819
implemented in Python then you can do it

417
00:17:08,819 --> 00:17:11,339
as well also the core provides the

418
00:17:11,339 --> 00:17:13,199
pattern matching and the chunk carving

419
00:17:13,199 --> 00:17:14,459
functionality so you don't need to

420
00:17:14,459 --> 00:17:17,220
implement it and it also provides a

421
00:17:17,220 --> 00:17:19,439
plug-in management basically you have

422
00:17:19,439 --> 00:17:21,780
the option to Define plugins and plugin

423
00:17:21,780 --> 00:17:23,400
contains the Handler for different

424
00:17:23,400 --> 00:17:26,760
formats and if you are developing again

425
00:17:26,760 --> 00:17:29,580
just create your own repository put into

426
00:17:29,580 --> 00:17:32,880
a plugin say my handlers and then this

427
00:17:32,880 --> 00:17:35,179
plugin is automatically loaded all the

428
00:17:35,179 --> 00:17:38,160
handlers from the plugins are loaded and

429
00:17:38,160 --> 00:17:41,400
are used throughout the detection and

430
00:17:41,400 --> 00:17:42,960
the extraction process

431
00:17:42,960 --> 00:17:45,059
also the core provides logging and

432
00:17:45,059 --> 00:17:46,799
Reporting capabilities just to show you

433
00:17:46,799 --> 00:17:49,260
before and it provides a ton of useful

434
00:17:49,260 --> 00:17:51,000
utility functions so when you are

435
00:17:51,000 --> 00:17:52,980
dealing with different formats I will

436
00:17:52,980 --> 00:17:54,960
show you right away then we are trying

437
00:17:54,960 --> 00:17:56,940
to give you small tools to help you with

438
00:17:56,940 --> 00:17:59,280
the parsing or conversion and other

439
00:17:59,280 --> 00:18:01,500
utilities that might come handy which is

440
00:18:01,500 --> 00:18:04,140
usually re-implemented all the time if

441
00:18:04,140 --> 00:18:06,179
you are just writing your own script

442
00:18:06,179 --> 00:18:09,299
now the envelope handlers are I would

443
00:18:09,299 --> 00:18:11,760
say this is the core so amloop handlers

444
00:18:11,760 --> 00:18:14,700
are the brain of the core that makes

445
00:18:14,700 --> 00:18:17,039
envelope super powerful

446
00:18:17,039 --> 00:18:19,500
uh basically handlers can be defined as

447
00:18:19,500 --> 00:18:22,320
I said before in plugins so it makes it

448
00:18:22,320 --> 00:18:24,360
super super easy to extend it you don't

449
00:18:24,360 --> 00:18:26,880
necessarily need to open source it or

450
00:18:26,880 --> 00:18:28,500
you don't necessarily need to Upstream

451
00:18:28,500 --> 00:18:30,840
your handlers to keep it easily

452
00:18:30,840 --> 00:18:32,520
manageable of course you are very happy

453
00:18:32,520 --> 00:18:34,500
if you do so but you can keep them

454
00:18:34,500 --> 00:18:38,340
private if you want and the goal of the

455
00:18:38,340 --> 00:18:39,840
format handlers that they are

456
00:18:39,840 --> 00:18:42,059
responsible for the chunk calculation

457
00:18:42,059 --> 00:18:44,039
and the chunk detection and also the

458
00:18:44,039 --> 00:18:46,140
extraction so all the format specific

459
00:18:46,140 --> 00:18:50,220
log jig stays within the handlers so

460
00:18:50,220 --> 00:18:52,200
that's on the high level the

461
00:18:52,200 --> 00:18:54,840
architecture uh just a word on the extra

462
00:18:54,840 --> 00:18:56,580
core because that's also a very tricky

463
00:18:56,580 --> 00:18:58,380
thing from our experience it's usually

464
00:18:58,380 --> 00:19:01,080
easy to identify a certain chunk but

465
00:19:01,080 --> 00:19:02,940
extracting it is sometimes much more

466
00:19:02,940 --> 00:19:04,740
difficult just to give you an example

467
00:19:04,740 --> 00:19:06,179
for example

468
00:19:06,179 --> 00:19:08,340
um squasha Fest which is very commonly

469
00:19:08,340 --> 00:19:10,880
used in different firmers actually I'm

470
00:19:10,880 --> 00:19:13,740
finding a squacifist and understanding

471
00:19:13,740 --> 00:19:16,140
the lengths of it so the basic chunk is

472
00:19:16,140 --> 00:19:18,600
not super difficult but extracting it is

473
00:19:18,600 --> 00:19:20,520
not that trivial so for example we are

474
00:19:20,520 --> 00:19:23,760
using a Sasquatch to do the job now

475
00:19:23,760 --> 00:19:25,860
unfortunately Sasquatch was not very

476
00:19:25,860 --> 00:19:28,080
well maintained so we decided with a

477
00:19:28,080 --> 00:19:30,360
bunch of extractor to Fork them and

478
00:19:30,360 --> 00:19:32,160
actually start to improve on that so if

479
00:19:32,160 --> 00:19:34,440
we have a Sasquatch Fork we have a

480
00:19:34,440 --> 00:19:37,559
Jefferson for QB reader Jeff Chief uh

481
00:19:37,559 --> 00:19:40,440
fork and we are trying to also

482
00:19:40,440 --> 00:19:43,980
fix box and add support for other

483
00:19:43,980 --> 00:19:46,140
formats because some of the vendors get

484
00:19:46,140 --> 00:19:48,900
very creative on dealing with formats

485
00:19:48,900 --> 00:19:51,179
and they are extending in a way they

486
00:19:51,179 --> 00:19:54,299
want to deal with so uh I would also

487
00:19:54,299 --> 00:19:56,400
um recommend to check out some of the

488
00:19:56,400 --> 00:19:58,980
forks we try to maintain it if there are

489
00:19:58,980 --> 00:20:00,840
any problems try to fix it you're also

490
00:20:00,840 --> 00:20:04,020
heavy users of all these Forks

491
00:20:04,020 --> 00:20:06,960
in case of some easier format which is

492
00:20:06,960 --> 00:20:09,480
easy to implement or there is no tool

493
00:20:09,480 --> 00:20:12,240
available we just decide to build it as

494
00:20:12,240 --> 00:20:14,640
an extractor but it also means that you

495
00:20:14,640 --> 00:20:16,500
have the chance either to use some tools

496
00:20:16,500 --> 00:20:18,900
that readily available or you can create

497
00:20:18,900 --> 00:20:21,960
your own extractor as well

498
00:20:21,960 --> 00:20:25,260
so let's jump into that and let's try to

499
00:20:25,260 --> 00:20:28,140
create our first uh extractor

500
00:20:28,140 --> 00:20:31,799
before doing so I just picked up a

501
00:20:31,799 --> 00:20:34,400
firmware

502
00:20:34,400 --> 00:20:37,260
and I this time I decided to pick

503
00:20:37,260 --> 00:20:39,840
something simple so I just

504
00:20:39,840 --> 00:20:43,500
picked up a Netgear firmware and our

505
00:20:43,500 --> 00:20:46,679
7000 whatever I just downloaded from the

506
00:20:46,679 --> 00:20:48,179
internet

507
00:20:48,179 --> 00:20:52,940
and if I run an extraction on it

508
00:20:53,760 --> 00:20:58,320
then it does the extraction if I go to

509
00:20:58,320 --> 00:21:00,360
the results let me just quickly go there

510
00:21:00,360 --> 00:21:03,600
I can see that here is the result and

511
00:21:03,600 --> 00:21:06,000
generally it's not extracted I see there

512
00:21:06,000 --> 00:21:07,980
is some squash effects in it which we

513
00:21:07,980 --> 00:21:11,100
detected there is some lcma file I can

514
00:21:11,100 --> 00:21:14,160
go into the details see what it is uh oh

515
00:21:14,160 --> 00:21:16,320
it finds a Dev console root so it's

516
00:21:16,320 --> 00:21:20,100
probably a a Linux kernel that we

517
00:21:20,100 --> 00:21:22,260
detected here but generally there are a

518
00:21:22,260 --> 00:21:24,539
lot of unknowns and I just picked this

519
00:21:24,539 --> 00:21:27,080
very very simple one if I look at it

520
00:21:27,080 --> 00:21:31,320
you can see that it's actually a chk

521
00:21:31,320 --> 00:21:34,140
format which is specific to Netgear so

522
00:21:34,140 --> 00:21:36,360
for this purpose I just want to

523
00:21:36,360 --> 00:21:38,520
understand this Header information and

524
00:21:38,520 --> 00:21:41,460
see how we can deal with it

525
00:21:41,460 --> 00:21:44,159
so in order to conserve some time I

526
00:21:44,159 --> 00:21:47,360
actually pre-coded it yesterday

527
00:21:48,780 --> 00:21:50,460
and um

528
00:21:50,460 --> 00:21:53,100
I just created a

529
00:21:53,100 --> 00:21:56,159
Handler for it so here is envelope here

530
00:21:56,159 --> 00:21:58,620
you can see all the handlers

531
00:21:58,620 --> 00:22:01,620
and I created hopefully I will able to

532
00:22:01,620 --> 00:22:03,240
find it

533
00:22:03,240 --> 00:22:06,240
a Netgear Handler so this is basically

534
00:22:06,240 --> 00:22:08,760
how a x structure looks like let me try

535
00:22:08,760 --> 00:22:10,860
to zoom into it so you can actually see

536
00:22:10,860 --> 00:22:13,039
it

537
00:22:13,980 --> 00:22:15,980
um

538
00:22:16,740 --> 00:22:19,460
okay

539
00:22:19,860 --> 00:22:21,539
um okay let's go back to the command

540
00:22:21,539 --> 00:22:24,379
line it always better

541
00:22:33,780 --> 00:22:36,900
so this is how a let's use VI that maybe

542
00:22:36,900 --> 00:22:39,360
they'll do some color

543
00:22:39,360 --> 00:22:42,960
enhancement yes much better so

544
00:22:42,960 --> 00:22:46,080
um actually doing a a handle is super

545
00:22:46,080 --> 00:22:48,900
super simple this is basically how a

546
00:22:48,900 --> 00:22:51,299
Handler looks like one of the important

547
00:22:51,299 --> 00:22:53,159
thing that you need to Define is you can

548
00:22:53,159 --> 00:22:56,280
define a pattern that you want to search

549
00:22:56,280 --> 00:22:58,400
for so this is basically the pattern

550
00:22:58,400 --> 00:23:00,720
that will be searched this is the magic

551
00:23:00,720 --> 00:23:03,780
uh in at the beginning of the file if

552
00:23:03,780 --> 00:23:06,120
you recall this two eight two three two

553
00:23:06,120 --> 00:23:08,820
four five E this is basically the magic

554
00:23:08,820 --> 00:23:12,299
for this fire format so by defining the

555
00:23:12,299 --> 00:23:14,039
support for this format I just Define

556
00:23:14,039 --> 00:23:17,100
like what is the pattern I'm looking for

557
00:23:17,100 --> 00:23:18,780
and the other thing that I need to

558
00:23:18,780 --> 00:23:21,000
implement is basically the chunk

559
00:23:21,000 --> 00:23:24,000
calculation so that it's a callback once

560
00:23:24,000 --> 00:23:27,240
a pattern was identified then this

561
00:23:27,240 --> 00:23:29,340
callback is called and it's passed the

562
00:23:29,340 --> 00:23:31,740
file and the start offset and all it

563
00:23:31,740 --> 00:23:34,380
needs to return is basically a wallet

564
00:23:34,380 --> 00:23:36,840
chunk type where I need to specify like

565
00:23:36,840 --> 00:23:38,400
what is the start offset which is

566
00:23:38,400 --> 00:23:41,760
usually simple and also what is the end

567
00:23:41,760 --> 00:23:44,100
offset in order to do so what I need to

568
00:23:44,100 --> 00:23:47,280
do is actually parse the header and what

569
00:23:47,280 --> 00:23:50,700
we are using is also a struct a parsing

570
00:23:50,700 --> 00:23:52,860
it's very very common that some

571
00:23:52,860 --> 00:23:55,260
structures are available in the source

572
00:23:55,260 --> 00:23:57,539
code so in this case what I did I just

573
00:23:57,539 --> 00:24:00,120
copied a structure definition

574
00:24:00,120 --> 00:24:03,000
uh which basically Define this format as

575
00:24:03,000 --> 00:24:04,799
you can see there is some magic header

576
00:24:04,799 --> 00:24:06,960
length some reverse Earth sync which

577
00:24:06,960 --> 00:24:08,940
might make sense I don't care because

578
00:24:08,940 --> 00:24:11,760
it's not required for the unpacking and

579
00:24:11,760 --> 00:24:13,679
uh there is a kernel and the root file

580
00:24:13,679 --> 00:24:15,960
system lengths in it there are also some

581
00:24:15,960 --> 00:24:17,520
checks some so if you want to be super

582
00:24:17,520 --> 00:24:19,320
precise with the extraction you can also

583
00:24:19,320 --> 00:24:21,780
do some check some calculation

584
00:24:21,780 --> 00:24:23,940
and then basically I can Define that I'm

585
00:24:23,940 --> 00:24:26,700
using this uh as a definition

586
00:24:26,700 --> 00:24:29,400
and then I'm just parsing it so we are

587
00:24:29,400 --> 00:24:30,659
trying to provide all these utility

588
00:24:30,659 --> 00:24:32,400
functions so actually creating the

589
00:24:32,400 --> 00:24:34,740
handle is super super simple in this

590
00:24:34,740 --> 00:24:37,200
case I know it's a big engine we can

591
00:24:37,200 --> 00:24:39,480
also do and have some utility functions

592
00:24:39,480 --> 00:24:42,059
to do some Indian as detection based on

593
00:24:42,059 --> 00:24:45,179
some logic and then I do some

594
00:24:45,179 --> 00:24:47,640
calculation just to be sure I'm logging

595
00:24:47,640 --> 00:24:50,820
the header and then I'm returning the

596
00:24:50,820 --> 00:24:52,039
identified

597
00:24:52,039 --> 00:24:56,539
content so let's quickly run it again

598
00:24:56,640 --> 00:24:59,280
and I'm just adding that I don't want to

599
00:24:59,280 --> 00:25:02,059
go very deep

600
00:25:02,520 --> 00:25:06,440
maybe I want to go a bit more verbose

601
00:25:06,440 --> 00:25:10,440
so in this case I can see that on debug

602
00:25:10,440 --> 00:25:13,919
level we identified the header they also

603
00:25:13,919 --> 00:25:15,720
have some utility function to make it

604
00:25:15,720 --> 00:25:18,000
super nice color coded if he parser

605
00:25:18,000 --> 00:25:20,039
header so you can very quickly see if

606
00:25:20,039 --> 00:25:22,080
the header is correct like what are the

607
00:25:22,080 --> 00:25:24,539
details in the header so in this case I

608
00:25:24,539 --> 00:25:27,419
can see the board ID and all the other

609
00:25:27,419 --> 00:25:29,580
fields as well

610
00:25:29,580 --> 00:25:33,840
that's basically how I can identify the

611
00:25:33,840 --> 00:25:37,440
chunk there is also the log on like what

612
00:25:37,440 --> 00:25:40,500
the chunk that I identified we also have

613
00:25:40,500 --> 00:25:42,480
some speed improvements that for example

614
00:25:42,480 --> 00:25:44,400
if we identify that the chunk covers the

615
00:25:44,400 --> 00:25:46,140
whole files we start searching for other

616
00:25:46,140 --> 00:25:49,260
chunks so it's it's super super simple

617
00:25:49,260 --> 00:25:51,299
in that way now this is the first step

618
00:25:51,299 --> 00:25:52,919
the next step is that I need to actually

619
00:25:52,919 --> 00:25:55,559
extract it now in this particular case

620
00:25:55,559 --> 00:25:58,380
the format is very simple so let me jump

621
00:25:58,380 --> 00:26:01,440
to the next step

622
00:26:01,440 --> 00:26:02,880
um

623
00:26:02,880 --> 00:26:04,860
oh

624
00:26:04,860 --> 00:26:07,919
where I have added an extractor so

625
00:26:07,919 --> 00:26:09,900
basically every Handler I can Define

626
00:26:09,900 --> 00:26:12,059
like what the extractor is where the

627
00:26:12,059 --> 00:26:14,360
extractor is responsible for actually

628
00:26:14,360 --> 00:26:17,880
extracting the carved out uh chunk

629
00:26:17,880 --> 00:26:19,740
uh in this particular case there is no

630
00:26:19,740 --> 00:26:22,500
external tool so I just decided to write

631
00:26:22,500 --> 00:26:24,299
my own extractor

632
00:26:24,299 --> 00:26:26,400
so let's see how complicated the next

633
00:26:26,400 --> 00:26:27,900
structure is that's pretty much the

634
00:26:27,900 --> 00:26:29,659
extractor again

635
00:26:29,659 --> 00:26:32,820
logic is very very similar we are using

636
00:26:32,820 --> 00:26:35,159
this track processor we can use the same

637
00:26:35,159 --> 00:26:37,500
definition that we used before

638
00:26:37,500 --> 00:26:39,960
and basically the extractor gets the

639
00:26:39,960 --> 00:26:42,960
impulse the carved out chunk and gets a

640
00:26:42,960 --> 00:26:44,760
directory where the extraction should

641
00:26:44,760 --> 00:26:47,400
happen so all we need to do is just

642
00:26:47,400 --> 00:26:49,440
parse again the header

643
00:26:49,440 --> 00:26:52,860
um we wanted to separate the uh tongue

644
00:26:52,860 --> 00:26:54,659
detection and the extraction so we are

645
00:26:54,659 --> 00:26:56,820
trying not to pass information to keep

646
00:26:56,820 --> 00:27:01,559
the API Simple and Clean and all we need

647
00:27:01,559 --> 00:27:03,299
to do is just seek to the end of the

648
00:27:03,299 --> 00:27:05,100
header and we know that there is a

649
00:27:05,100 --> 00:27:07,620
kernel and a root of s i just created a

650
00:27:07,620 --> 00:27:09,200
super simple

651
00:27:09,200 --> 00:27:12,779
function which will dump it into a file

652
00:27:12,779 --> 00:27:15,659
we have this function readily available

653
00:27:15,659 --> 00:27:18,480
to carve a chunk to a file so I'm just

654
00:27:18,480 --> 00:27:20,880
defining that okay here is a chunk which

655
00:27:20,880 --> 00:27:24,000
in this case will be the kernel or the

656
00:27:24,000 --> 00:27:26,340
router fast with the defined lengths and

657
00:27:26,340 --> 00:27:29,640
then it will do all the extraction let's

658
00:27:29,640 --> 00:27:32,419
see how it works

659
00:27:33,840 --> 00:27:35,640
so in this case

660
00:27:35,640 --> 00:27:38,400
um also going forward this is where I

661
00:27:38,400 --> 00:27:40,860
can see that the charge was gone out and

662
00:27:40,860 --> 00:27:43,320
as I defined a maximum depth it does not

663
00:27:43,320 --> 00:27:46,260
go in uh deeper so it stops there so

664
00:27:46,260 --> 00:27:47,700
let's um

665
00:27:47,700 --> 00:27:49,919
let's quickly see in this particular

666
00:27:49,919 --> 00:27:52,020
case it identified only the kernel

667
00:27:52,020 --> 00:27:54,720
partition there and it extracted into a

668
00:27:54,720 --> 00:27:57,539
file called kernel because this is what

669
00:27:57,539 --> 00:28:00,360
I uh defined to be used as a file name

670
00:28:00,360 --> 00:28:02,580
obviously in a more complicated format

671
00:28:02,580 --> 00:28:04,260
you might dynamically create the file

672
00:28:04,260 --> 00:28:06,059
name you also have a bunch of utility

673
00:28:06,059 --> 00:28:07,559
function to make sure that there are no

674
00:28:07,559 --> 00:28:09,539
pass drivers also if you are using the

675
00:28:09,539 --> 00:28:12,779
carving out API then you don't need to

676
00:28:12,779 --> 00:28:15,480
take care of all those problems now

677
00:28:15,480 --> 00:28:18,299
let's um go a bit deeper I just remove

678
00:28:18,299 --> 00:28:21,440
these steps limit

679
00:28:24,659 --> 00:28:27,779
yeah I just left debugging on

680
00:28:27,779 --> 00:28:30,600
so in this part UPS in this particle

681
00:28:30,600 --> 00:28:33,480
case we picked up and we extracted the

682
00:28:33,480 --> 00:28:35,340
kernel and this finds all the other

683
00:28:35,340 --> 00:28:38,100
thing but there is still another header

684
00:28:38,100 --> 00:28:40,320
if you worked with Netgear then this

685
00:28:40,320 --> 00:28:43,080
hdr0 might be a tell this is another

686
00:28:43,080 --> 00:28:45,179
format that

687
00:28:45,179 --> 00:28:47,880
um Netgear is using so what we need to

688
00:28:47,880 --> 00:28:49,799
do is create another Handler if we want

689
00:28:49,799 --> 00:28:51,299
to be very precise

690
00:28:51,299 --> 00:28:56,220
so I just go to step three in my journey

691
00:28:56,220 --> 00:28:59,039
let's quickly check this out and in this

692
00:28:59,039 --> 00:29:03,059
particle case I also added a TRX header

693
00:29:03,059 --> 00:29:06,419
this is the format name for this hdr0

694
00:29:06,419 --> 00:29:10,260
and I added

695
00:29:10,260 --> 00:29:12,620
next to my

696
00:29:12,620 --> 00:29:16,500
chk enter the TRX Handler as you can see

697
00:29:16,500 --> 00:29:18,539
the logic is very much the same just

698
00:29:18,539 --> 00:29:21,720
Define the magic I'd already defined the

699
00:29:21,720 --> 00:29:25,080
headers I parse it and I just defined a

700
00:29:25,080 --> 00:29:27,000
chunk so obviously you can add a bit

701
00:29:27,000 --> 00:29:29,039
more checks to make sure checksums are

702
00:29:29,039 --> 00:29:32,220
correct or of those sizes make sense in

703
00:29:32,220 --> 00:29:33,840
order to avoid picking up some false

704
00:29:33,840 --> 00:29:34,860
positive

705
00:29:34,860 --> 00:29:40,020
and just to jump there I also created a

706
00:29:40,020 --> 00:29:42,840
an extractor for this format it's very

707
00:29:42,840 --> 00:29:44,880
similar the only difference that the

708
00:29:44,880 --> 00:29:46,919
format defines actually three partitions

709
00:29:46,919 --> 00:29:50,340
so what I'm doing I'm just uh

710
00:29:50,340 --> 00:29:51,179
um

711
00:29:51,179 --> 00:29:53,760
checking out part one A Part Zero part

712
00:29:53,760 --> 00:29:55,860
one and part two getting the offset from

713
00:29:55,860 --> 00:29:57,840
the header and then in this case

714
00:29:57,840 --> 00:30:00,299
basically dumping three files let's

715
00:30:00,299 --> 00:30:04,460
quickly see how it works

716
00:30:08,580 --> 00:30:10,740
so it does the extraction

717
00:30:10,740 --> 00:30:14,279
and if I look at the the results let me

718
00:30:14,279 --> 00:30:16,140
quickly go outside

719
00:30:16,140 --> 00:30:19,020
and then here I can see that even the

720
00:30:19,020 --> 00:30:21,720
partitions were identified correctly so

721
00:30:21,720 --> 00:30:23,399
again it helps me to have a better

722
00:30:23,399 --> 00:30:25,020
understanding not just finding some

723
00:30:25,020 --> 00:30:28,559
random uh squash a fash somewhere down

724
00:30:28,559 --> 00:30:30,140
the line

725
00:30:30,140 --> 00:30:34,080
but uh precisely identify uh what the

726
00:30:34,080 --> 00:30:36,840
files are also if I go back to the

727
00:30:36,840 --> 00:30:39,320
previous one

728
00:30:42,720 --> 00:30:45,120
oops

729
00:30:45,120 --> 00:30:47,820
let's go to the Sunburst maybe that's

730
00:30:47,820 --> 00:30:50,600
easier to see

731
00:30:55,140 --> 00:30:58,140
then I can see all the partitions and

732
00:30:58,140 --> 00:30:59,820
all the details so I can jump to a

733
00:30:59,820 --> 00:31:03,299
partition understand what's there so all

734
00:31:03,299 --> 00:31:05,700
the visualization just get more accurate

735
00:31:05,700 --> 00:31:08,580
I think with this uh obviously in this

736
00:31:08,580 --> 00:31:10,559
particle case like there is no super

737
00:31:10,559 --> 00:31:12,960
high need to actually understand these

738
00:31:12,960 --> 00:31:14,279
formats

739
00:31:14,279 --> 00:31:16,919
um as we could even without this format

740
00:31:16,919 --> 00:31:19,559
handlers identify the kernel or identify

741
00:31:19,559 --> 00:31:22,980
the file system but in some case uh it's

742
00:31:22,980 --> 00:31:24,480
good to know like how these are

743
00:31:24,480 --> 00:31:27,179
structured especially if there are some

744
00:31:27,179 --> 00:31:29,340
other things lurking there and obviously

745
00:31:29,340 --> 00:31:31,559
if it's something unsupported then the

746
00:31:31,559 --> 00:31:34,140
logic gets a bit more complicated I just

747
00:31:34,140 --> 00:31:38,159
choose this as an example uh sorry I

748
00:31:38,159 --> 00:31:40,320
just choose this because the file system

749
00:31:40,320 --> 00:31:42,419
format is fairly simple and I just

750
00:31:42,419 --> 00:31:45,240
wanted to Showcase how easy it is to

751
00:31:45,240 --> 00:31:48,799
actually create a format

752
00:31:49,380 --> 00:31:51,659
so we actually created our first Handler

753
00:31:51,659 --> 00:31:53,760
and first extractor

754
00:31:53,760 --> 00:31:56,399
so um just a few words on where we are

755
00:31:56,399 --> 00:31:57,960
heading we download

756
00:31:57,960 --> 00:31:59,640
um so envelope is being very very

757
00:31:59,640 --> 00:32:02,340
actively developed

758
00:32:02,340 --> 00:32:03,720
um one of the things that we are working

759
00:32:03,720 --> 00:32:06,000
on is creating an even cleaner uh

760
00:32:06,000 --> 00:32:08,340
reporting of the accession process and

761
00:32:08,340 --> 00:32:10,380
gather basically a result of a summary

762
00:32:10,380 --> 00:32:12,779
of like what type of file systems were

763
00:32:12,779 --> 00:32:15,419
identified what type of information what

764
00:32:15,419 --> 00:32:16,980
type of files what are the unknown

765
00:32:16,980 --> 00:32:20,100
chunks so we'd like to work on that also

766
00:32:20,100 --> 00:32:22,200
right now we do not extract too many

767
00:32:22,200 --> 00:32:24,600
metadata so for example we extract the

768
00:32:24,600 --> 00:32:26,460
files what we would like to also report

769
00:32:26,460 --> 00:32:28,919
on permissions which is sometimes lost

770
00:32:28,919 --> 00:32:30,960
during the extraction process file

771
00:32:30,960 --> 00:32:35,640
ownership stuff like that also we have

772
00:32:35,640 --> 00:32:37,460
some plan and we are working on

773
00:32:37,460 --> 00:32:40,440
extending the unknown chunks with some

774
00:32:40,440 --> 00:32:43,260
Auto identification so for example if

775
00:32:43,260 --> 00:32:45,600
it's a zero byte padding to pick it up

776
00:32:45,600 --> 00:32:47,279
as a zero pipe padding so it's not an

777
00:32:47,279 --> 00:32:49,500
unknown chunk if it's an FF padding pick

778
00:32:49,500 --> 00:32:52,320
it up as an FF padding we also see cases

779
00:32:52,320 --> 00:32:55,080
where there are some data data in it so

780
00:32:55,080 --> 00:32:57,960
if we can identify some strings in it or

781
00:32:57,960 --> 00:32:59,700
we can identify some logic to

782
00:32:59,700 --> 00:33:01,919
automatically pick those up and give you

783
00:33:01,919 --> 00:33:04,500
a hint so it's easier to deal with the

784
00:33:04,500 --> 00:33:06,720
unknown chunk maybe create a new format

785
00:33:06,720 --> 00:33:09,539
Handler as well and last but definitely

786
00:33:09,539 --> 00:33:11,100
not not least we are continuously

787
00:33:11,100 --> 00:33:14,159
working adding additional formats that

788
00:33:14,159 --> 00:33:16,740
we encounter and we also encourage

789
00:33:16,740 --> 00:33:19,620
everybody else to do so so basically

790
00:33:19,620 --> 00:33:21,960
feel free to contribute test your

791
00:33:21,960 --> 00:33:24,480
weirdest files report bugs everything is

792
00:33:24,480 --> 00:33:27,539
on on githrop if uh if you have any

793
00:33:27,539 --> 00:33:29,519
problem let us know we are super happy

794
00:33:29,519 --> 00:33:33,299
to help you and we would love to see a

795
00:33:33,299 --> 00:33:35,820
pull request coming from the community

796
00:33:35,820 --> 00:33:39,480
so if you find a bug or have a cool idea

797
00:33:39,480 --> 00:33:42,360
for a feature report it but even better

798
00:33:42,360 --> 00:33:43,799
if you just

799
00:33:43,799 --> 00:33:45,799
um

800
00:33:45,840 --> 00:33:46,860
um

801
00:33:46,860 --> 00:33:48,720
send a

802
00:33:48,720 --> 00:33:50,760
pull request for that

803
00:33:50,760 --> 00:33:52,500
so with that said

804
00:33:52,500 --> 00:33:54,659
um thank you very much for your

805
00:33:54,659 --> 00:33:56,760
attention and I believe we have a few

806
00:33:56,760 --> 00:33:59,760
minutes for questions or if you want me

807
00:33:59,760 --> 00:34:02,340
to double click into any of the details

808
00:34:02,340 --> 00:34:05,779
would be super happy to do so

809
00:34:06,539 --> 00:34:09,980
any questions from the audience

810
00:34:12,060 --> 00:34:14,540
good

811
00:34:17,339 --> 00:34:21,359
uh thank you do you somehow deal with

812
00:34:21,359 --> 00:34:23,760
encrypted firmware like obviously if you

813
00:34:23,760 --> 00:34:25,440
have credentials but you know can you

814
00:34:25,440 --> 00:34:27,540
can you deal with the encryption in some

815
00:34:27,540 --> 00:34:31,500
way so um yes and no I mean it very much

816
00:34:31,500 --> 00:34:34,619
depends on if that could be decrypted so

817
00:34:34,619 --> 00:34:37,560
um if if the uh for example if there is

818
00:34:37,560 --> 00:34:42,000
a a publicly known uh decryption key or

819
00:34:42,000 --> 00:34:44,219
a password then it's very simple to

820
00:34:44,219 --> 00:34:47,280
create a a Handler for that we are

821
00:34:47,280 --> 00:34:50,280
experimenting with some formats and

822
00:34:50,280 --> 00:34:54,619
building in some some

823
00:34:54,619 --> 00:34:57,480
encrypted format support it's a bit

824
00:34:57,480 --> 00:34:59,160
different we have some of those servers

825
00:34:59,160 --> 00:35:01,080
but we are not always in the position to

826
00:35:01,080 --> 00:35:02,820
actually open source it uh due to

827
00:35:02,820 --> 00:35:04,859
confidentiality agreements we're also

828
00:35:04,859 --> 00:35:06,720
toying with some ideas where we can do

829
00:35:06,720 --> 00:35:09,300
some simple brute forcing on on certain

830
00:35:09,300 --> 00:35:12,240
formats so for example uh we think cases

831
00:35:12,240 --> 00:35:14,700
where um it's just a zip file which is

832
00:35:14,700 --> 00:35:16,500
which is encrypted and in many cases

833
00:35:16,500 --> 00:35:18,780
it's just a very simple password so

834
00:35:18,780 --> 00:35:20,700
there is that it could be feasible to

835
00:35:20,700 --> 00:35:23,040
actually try to brute force it there are

836
00:35:23,040 --> 00:35:25,619
also many projects out on GitHub which

837
00:35:25,619 --> 00:35:27,359
is dealing with encrypted format where

838
00:35:27,359 --> 00:35:30,599
the decryption scheme is is well get

839
00:35:30,599 --> 00:35:32,400
public let's put it like that some

840
00:35:32,400 --> 00:35:34,980
reverse engineered it so one of our

841
00:35:34,980 --> 00:35:37,380
dream if I want to say so is actually

842
00:35:37,380 --> 00:35:39,720
get those scripts which is lurking

843
00:35:39,720 --> 00:35:41,700
around on GitHub and God knows which

844
00:35:41,700 --> 00:35:44,820
Repro and incorporate into uh and blob

845
00:35:44,820 --> 00:35:46,320
it would be really cool if all you need

846
00:35:46,320 --> 00:35:47,520
to do if you are dealing with the

847
00:35:47,520 --> 00:35:49,619
firmware just run on blob pull all those

848
00:35:49,619 --> 00:35:51,720
format support I would say right now we

849
00:35:51,720 --> 00:35:53,640
are much more limited by our time but I

850
00:35:53,640 --> 00:35:55,440
would say that if there is a particular

851
00:35:55,440 --> 00:35:57,599
format encrypted or not encrypted

852
00:35:57,599 --> 00:35:59,520
especially if there is a already

853
00:35:59,520 --> 00:36:01,800
available like open source or reverse

854
00:36:01,800 --> 00:36:04,800
engine or script it usually takes like a

855
00:36:04,800 --> 00:36:06,420
day or maybe half a day a couple of

856
00:36:06,420 --> 00:36:08,700
hours to actually Port it to envelope

857
00:36:08,700 --> 00:36:10,140
and then

858
00:36:10,140 --> 00:36:13,980
um really you can have uh sorry

859
00:36:13,980 --> 00:36:17,820
a unified Library uh to to deal with

860
00:36:17,820 --> 00:36:19,980
sorry I think the the power of fan blob

861
00:36:19,980 --> 00:36:21,720
is that you don't need to have many many

862
00:36:21,720 --> 00:36:23,940
scripts one script for this one script

863
00:36:23,940 --> 00:36:26,579
for that but you can unify them into one

864
00:36:26,579 --> 00:36:29,099
one tool and let it take care so we will

865
00:36:29,099 --> 00:36:30,660
just move it generally we are very open

866
00:36:30,660 --> 00:36:32,820
uh it's either limited with some

867
00:36:32,820 --> 00:36:35,099
confidentiality issue or our time but

868
00:36:35,099 --> 00:36:39,300
otherwise yes okay awesome thanks thanks

869
00:36:39,300 --> 00:36:42,200
anyone else

870
00:36:42,720 --> 00:36:45,490
thank you Martin thank you very much

871
00:36:45,490 --> 00:36:51,319
[Applause]

