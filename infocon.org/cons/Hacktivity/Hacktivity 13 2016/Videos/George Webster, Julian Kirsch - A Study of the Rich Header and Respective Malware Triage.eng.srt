1
00:00:00,000 --> 00:00:01,680
but we're gonna talk about revealing the

2
00:00:01,680 --> 00:00:03,389
machine and what that really comes down

3
00:00:03,389 --> 00:00:05,310
to it's a study of the rich header and

4
00:00:05,310 --> 00:00:07,950
we're gonna talk really and focus on the

5
00:00:07,950 --> 00:00:09,809
respective triage that you can do with

6
00:00:09,809 --> 00:00:13,590
it it was quite cool so yeah I'm George

7
00:00:13,590 --> 00:00:15,269
we're both PhD candidates at the

8
00:00:15,269 --> 00:00:16,859
Technical University of Munich I

9
00:00:16,859 --> 00:00:18,900
specialize in large-scale distributed

10
00:00:18,900 --> 00:00:20,609
systems and trying to figure out how to

11
00:00:20,609 --> 00:00:21,210
do

12
00:00:21,210 --> 00:00:23,519
Maur analysis at a very large scale

13
00:00:23,519 --> 00:00:26,250
realistically I focused more on dynamic

14
00:00:26,250 --> 00:00:27,840
and static analysis and all that fun

15
00:00:27,840 --> 00:00:30,960
stuff this is Julian he's pretty much

16
00:00:30,960 --> 00:00:32,940
your reverse engineering exploit

17
00:00:32,940 --> 00:00:35,340
development kind of extraordinaire

18
00:00:35,340 --> 00:00:37,110
he also dibbles and dowels with virtual

19
00:00:37,110 --> 00:00:39,300
machine introspection somebody started

20
00:00:39,300 --> 00:00:40,860
talking and getting into the weeds I'm

21
00:00:40,860 --> 00:00:42,690
just gonna hand it over to him and he'll

22
00:00:42,690 --> 00:00:47,460
entertain you guys so what we really

23
00:00:47,460 --> 00:00:49,230
want to talk about first is why are we

24
00:00:49,230 --> 00:00:50,460
actually here like why do we actually

25
00:00:50,460 --> 00:00:52,620
really care so to do that we're gonna

26
00:00:52,620 --> 00:00:56,760
explain the problem now the problem is

27
00:00:56,760 --> 00:00:59,969
data I mean I'm sure all of you as

28
00:00:59,969 --> 00:01:01,170
security engineers have faced this

29
00:01:01,170 --> 00:01:03,420
problem there's data upon data upon data

30
00:01:03,420 --> 00:01:06,450
so if we quickly look at this we see

31
00:01:06,450 --> 00:01:07,439
from virustotal

32
00:01:07,439 --> 00:01:09,869
we're seeing about 1 million samples a

33
00:01:09,869 --> 00:01:11,729
day that they actually have to process

34
00:01:11,729 --> 00:01:14,130
and that's a lot of data however that's

35
00:01:14,130 --> 00:01:15,600
kind of only part of the picture it's a

36
00:01:15,600 --> 00:01:17,970
little bit of a false hope because if

37
00:01:17,970 --> 00:01:19,890
you look from a historical context and

38
00:01:19,890 --> 00:01:22,590
say you go back you know 300 days that's

39
00:01:22,590 --> 00:01:24,360
300 million samples that you have to

40
00:01:24,360 --> 00:01:26,909
analyze and process and look into so

41
00:01:26,909 --> 00:01:29,400
that's a lot of data again however

42
00:01:29,400 --> 00:01:30,990
that's also another false positive

43
00:01:30,990 --> 00:01:32,100
because this stuff that's already

44
00:01:32,100 --> 00:01:34,110
suspected to be malicious what about the

45
00:01:34,110 --> 00:01:35,490
benign stuff what about the stuff we

46
00:01:35,490 --> 00:01:36,509
have no idea

47
00:01:36,509 --> 00:01:37,820
so if you're for a large organization

48
00:01:37,820 --> 00:01:40,470
you're kind of dealing with stuff you're

49
00:01:40,470 --> 00:01:41,759
dealing with a tremendous amount of

50
00:01:41,759 --> 00:01:44,490
stuff that pretty much kills most of our

51
00:01:44,490 --> 00:01:46,140
scripts most of our fun stuff we're

52
00:01:46,140 --> 00:01:48,960
working with and so the question really

53
00:01:48,960 --> 00:01:50,970
comes is when you see a sample and we

54
00:01:50,970 --> 00:01:52,409
start to dig into this like how do you

55
00:01:52,409 --> 00:01:54,180
triage it how do you figure out what's

56
00:01:54,180 --> 00:01:55,619
important how do you find out what's

57
00:01:55,619 --> 00:01:57,840
interesting how do you think stuff

58
00:01:57,840 --> 00:01:59,939
that's related and really it comes down

59
00:01:59,939 --> 00:02:01,500
to how do you make sense out of all this

60
00:02:01,500 --> 00:02:05,759
data so at the university we developed

61
00:02:05,759 --> 00:02:07,469
kind of our malware that really helps us

62
00:02:07,469 --> 00:02:09,508
with our research and figuring stuff out

63
00:02:09,508 --> 00:02:12,390
and we're working on one aspect of the

64
00:02:12,390 --> 00:02:13,750
PE 32 file and we can

65
00:02:13,750 --> 00:02:17,320
across this weird interesting that as we

66
00:02:17,320 --> 00:02:18,700
started to look at it we saw that the

67
00:02:18,700 --> 00:02:20,790
documentation was really non-existent

68
00:02:20,790 --> 00:02:23,500
microsoft says it doesn't exist so

69
00:02:23,500 --> 00:02:25,930
that's not cool we found a couple blog

70
00:02:25,930 --> 00:02:27,790
posts from reverse engineering stuff and

71
00:02:27,790 --> 00:02:30,970
that was interesting but again it wasn't

72
00:02:30,970 --> 00:02:33,490
really right great because they

73
00:02:33,490 --> 00:02:34,900
contradicted each other and there was

74
00:02:34,900 --> 00:02:36,970
errors in it and we looked in the

75
00:02:36,970 --> 00:02:38,890
security community or like well have you

76
00:02:38,890 --> 00:02:40,150
guys ever looked at it and the answer

77
00:02:40,150 --> 00:02:43,660
was no we couldn't find one record so

78
00:02:43,660 --> 00:02:45,820
what is this field this field is called

79
00:02:45,820 --> 00:02:49,090
the rich header from a you know it's

80
00:02:49,090 --> 00:02:50,860
pretty much overlooked it's a poorly

81
00:02:50,860 --> 00:02:53,080
understood aspect but it has three

82
00:02:53,080 --> 00:02:55,000
really awesome things in it the first is

83
00:02:55,000 --> 00:02:57,430
a product ID the product ID is a unique

84
00:02:57,430 --> 00:03:00,820
identifier and it usually goes to you

85
00:03:00,820 --> 00:03:04,450
know a major on a major object or a

86
00:03:04,450 --> 00:03:06,730
major corporation or it goes to a

87
00:03:06,730 --> 00:03:08,350
generic library and that's pretty

88
00:03:08,350 --> 00:03:10,840
informative for us the next is it has

89
00:03:10,840 --> 00:03:12,700
version information so I know exactly

90
00:03:12,700 --> 00:03:14,980
specifically what version was used in

91
00:03:14,980 --> 00:03:17,080
that it also has the compiler flags

92
00:03:17,080 --> 00:03:18,730
built into it too for when that object

93
00:03:18,730 --> 00:03:21,430
was created I got the version I got the

94
00:03:21,430 --> 00:03:24,100
compiler flags and the third aspect it

95
00:03:24,100 --> 00:03:26,920
has how many times the linker used that

96
00:03:26,920 --> 00:03:28,630
object in order to build and package

97
00:03:28,630 --> 00:03:31,959
everything together so that gives us an

98
00:03:31,959 --> 00:03:34,239
idea and the idea is can we actually use

99
00:03:34,239 --> 00:03:35,350
it because that's some really cool

100
00:03:35,350 --> 00:03:37,090
interesting information to kind of put

101
00:03:37,090 --> 00:03:38,350
something together and do some stuff

102
00:03:38,350 --> 00:03:42,370
with triage so in order to talk about

103
00:03:42,370 --> 00:03:43,989
that further we got to get into the

104
00:03:43,989 --> 00:03:46,090
weeds and I'm gonna hand it over to

105
00:03:46,090 --> 00:03:48,130
Julian because he's a reverse

106
00:03:48,130 --> 00:03:49,810
engineering guy and he's going to start

107
00:03:49,810 --> 00:03:52,840
explain it to you so Julian alright

108
00:03:52,840 --> 00:03:53,590
thank you

109
00:03:53,590 --> 00:03:56,350
so before we start talking about the

110
00:03:56,350 --> 00:03:56,799
rich header

111
00:03:56,799 --> 00:03:59,530
I would like to sync us up to get to

112
00:03:59,530 --> 00:04:01,750
kind of the same level of knowledge so I

113
00:04:01,750 --> 00:04:04,299
would briefly like to explain the PE

114
00:04:04,299 --> 00:04:06,579
three-to-five format and also how the

115
00:04:06,579 --> 00:04:08,530
typical Microsoft compiler toolchain

116
00:04:08,530 --> 00:04:13,420
looks like so this is what probably

117
00:04:13,420 --> 00:04:15,430
everybody in this room has seen at least

118
00:04:15,430 --> 00:04:17,890
once in his life so this is a

119
00:04:17,890 --> 00:04:20,738
conventional PE file starting with the

120
00:04:20,738 --> 00:04:23,200
DOS header that dates back to the early

121
00:04:23,200 --> 00:04:27,560
16-bit era era that nowadays does not

122
00:04:27,560 --> 00:04:30,590
much useful information anymore and it's

123
00:04:30,590 --> 00:04:32,569
just the header for a program that

124
00:04:32,569 --> 00:04:34,789
informs the user in case he should run

125
00:04:34,789 --> 00:04:38,060
this binary under dos that hey this is

126
00:04:38,060 --> 00:04:40,009
not a binary that is ms-dos compatible

127
00:04:40,009 --> 00:04:43,099
anymore the only interesting field in

128
00:04:43,099 --> 00:04:45,469
this das header nevertheless is the e

129
00:04:45,469 --> 00:04:47,750
head of a new field which is a direct

130
00:04:47,750 --> 00:04:49,370
reference to the beginning of the coffe

131
00:04:49,370 --> 00:04:51,500
header which then in turn contains all

132
00:04:51,500 --> 00:04:54,229
the information that modern 32 and 64

133
00:04:54,229 --> 00:04:56,870
Windows operating systems usually read

134
00:04:56,870 --> 00:04:59,330
and the interesting part we're going to

135
00:04:59,330 --> 00:05:01,879
talk about is now the rich header right

136
00:05:01,879 --> 00:05:03,680
in between the doors and the COFF header

137
00:05:03,680 --> 00:05:06,710
that is not officially documented and

138
00:05:06,710 --> 00:05:08,479
Microsoft even denied its existence

139
00:05:08,479 --> 00:05:15,500
several times now this is the microsoft

140
00:05:15,500 --> 00:05:18,889
visual studio compiler tool chain I want

141
00:05:18,889 --> 00:05:21,949
to briefly go over it such that we see

142
00:05:21,949 --> 00:05:23,539
what's going on here so on the left hand

143
00:05:23,539 --> 00:05:25,810
side of the slide you see visual studio

144
00:05:25,810 --> 00:05:30,439
with this famous green arrow start

145
00:05:30,439 --> 00:05:32,449
clicking button so if you click this

146
00:05:32,449 --> 00:05:34,250
button to compile your code and run it

147
00:05:34,250 --> 00:05:36,259
in visual studio then what what actually

148
00:05:36,259 --> 00:05:38,479
happens under the hood is that visual

149
00:05:38,479 --> 00:05:40,520
studio calls a command line interpreter

150
00:05:40,520 --> 00:05:43,550
called CL dot exa which according to

151
00:05:43,550 --> 00:05:45,469
what you fed the compiler with either C

152
00:05:45,469 --> 00:05:48,349
or C++ files invokes the correct

153
00:05:48,349 --> 00:05:51,770
Microsoft compiler front-end c1 dl l or

154
00:05:51,770 --> 00:05:55,250
c 1 x x d ll which then in turn create

155
00:05:55,250 --> 00:05:56,779
intermediate files which are then

156
00:05:56,779 --> 00:05:59,449
collected by the microsoft back-end

157
00:05:59,449 --> 00:06:03,020
compiler c 2 dl which in turn then turns

158
00:06:03,020 --> 00:06:04,939
them into object files that you could

159
00:06:04,939 --> 00:06:07,250
link together so the last step of

160
00:06:07,250 --> 00:06:09,680
computation is well nothing fancy here

161
00:06:09,680 --> 00:06:12,379
CL invokes the linker the linker puts

162
00:06:12,379 --> 00:06:13,550
together the object files and either

163
00:06:13,550 --> 00:06:16,250
produce a portable executable toward

164
00:06:16,250 --> 00:06:20,870
exit or a dynamic link library what is

165
00:06:20,870 --> 00:06:22,460
interesting to note here is that link X

166
00:06:22,460 --> 00:06:25,009
actually is a multi-purpose tool so if

167
00:06:25,009 --> 00:06:27,409
any of you ever touched stamp bin which

168
00:06:27,409 --> 00:06:29,589
is well the Linux Windows equivalent to

169
00:06:29,589 --> 00:06:32,479
object dump or also edit bin or lip X

170
00:06:32,479 --> 00:06:36,110
which are a binary itted editor and the

171
00:06:36,110 --> 00:06:39,529
library manager for Microsoft files

172
00:06:39,529 --> 00:06:40,909
then what actually happens under the

173
00:06:40,909 --> 00:06:42,289
hood there is that they are just tiny

174
00:06:42,289 --> 00:06:44,899
rappers are on linked Alexa so leaf dot

175
00:06:44,899 --> 00:06:47,269
XE actually is this or deny army knife

176
00:06:47,269 --> 00:06:52,039
at that point now let me know this we

177
00:06:52,039 --> 00:06:54,979
can talk privately about the rich header

178
00:06:54,979 --> 00:06:57,229
and we will actually be pretending to be

179
00:06:57,229 --> 00:07:01,069
a parser which is trying to get useful

180
00:07:01,069 --> 00:07:03,559
information from that rich header and we

181
00:07:03,559 --> 00:07:05,949
will see what it contains and watch

182
00:07:05,949 --> 00:07:09,379
these blocks that we named comp IDs are

183
00:07:09,379 --> 00:07:11,779
how it is created and also how we could

184
00:07:11,779 --> 00:07:16,749
extract all those information so as

185
00:07:16,749 --> 00:07:20,869
already mentioned the rich header is an

186
00:07:20,869 --> 00:07:22,909
obfuscated undocumented part of the PG

187
00:07:22,909 --> 00:07:26,119
header and one already very interesting

188
00:07:26,119 --> 00:07:28,579
part about a rich header is that it has

189
00:07:28,579 --> 00:07:31,699
been there for quite a long time so we

190
00:07:31,699 --> 00:07:33,469
know that it has been there since at

191
00:07:33,469 --> 00:07:35,839
least which was to year six which dates

192
00:07:35,839 --> 00:07:39,979
back to 1998 and was then well what

193
00:07:39,979 --> 00:07:41,869
could say almost forgotten until the mid

194
00:07:41,869 --> 00:07:44,419
or late 2000s where several blog posts

195
00:07:44,419 --> 00:07:47,360
appeared with information most notably

196
00:07:47,360 --> 00:07:50,119
by Daniel pastelly who provided valuable

197
00:07:50,119 --> 00:07:52,399
insights into the meaning of the rich

198
00:07:52,399 --> 00:07:54,949
header but they left the interpretation

199
00:07:54,949 --> 00:07:56,179
of the data you could find in their

200
00:07:56,179 --> 00:07:57,729
totally open

201
00:07:57,729 --> 00:08:01,399
so suppose we would like to find the

202
00:08:01,399 --> 00:08:04,189
information that the rich Eyler includes

203
00:08:04,189 --> 00:08:07,909
then remember that picture here if you

204
00:08:07,909 --> 00:08:10,729
turn this schematic overview into a hex

205
00:08:10,729 --> 00:08:13,489
dump then we have something like this so

206
00:08:13,489 --> 00:08:16,429
at the beginning marked in blue is the

207
00:08:16,429 --> 00:08:18,469
classical dose header that as you can

208
00:08:18,469 --> 00:08:20,719
see is almost everywhere there zero

209
00:08:20,719 --> 00:08:23,239
because it doesn't make sense to include

210
00:08:23,239 --> 00:08:25,699
any information in there anymore 16-bit

211
00:08:25,699 --> 00:08:28,819
arial era is long over except for that

212
00:08:28,819 --> 00:08:32,179
field at offset three C but I marked

213
00:08:32,179 --> 00:08:34,759
purple which is simply the forward

214
00:08:34,759 --> 00:08:36,620
reference to the PE error which you can

215
00:08:36,620 --> 00:08:40,729
see down slide in orange and right in

216
00:08:40,729 --> 00:08:43,009
between those two marked in green there

217
00:08:43,009 --> 00:08:44,809
is the switch header and one interesting

218
00:08:44,809 --> 00:08:47,480
part to note about this is already that

219
00:08:47,480 --> 00:08:49,459
we don't have a pointer to the beginning

220
00:08:49,459 --> 00:08:50,809
of the rich header but rather a pointer

221
00:08:50,809 --> 00:08:52,460
to the end of the day

222
00:08:52,460 --> 00:08:54,649
you're interested in so while parsing

223
00:08:54,649 --> 00:08:57,320
this we're actually going in reverse

224
00:08:57,320 --> 00:08:59,779
direction so what we can see there at

225
00:08:59,779 --> 00:09:01,940
the bottom of the hetero structure is in

226
00:09:01,940 --> 00:09:05,390
orange just some padding then we find a

227
00:09:05,390 --> 00:09:08,330
well magic value that will later turn

228
00:09:08,330 --> 00:09:11,060
out to be a checksum starting this one 3

229
00:09:11,060 --> 00:09:13,640
3 7 and by the way this is not a header

230
00:09:13,640 --> 00:09:15,830
I made up I directly obtained this file

231
00:09:15,830 --> 00:09:18,020
from Microsoft it's actually the linker

232
00:09:18,020 --> 00:09:20,570
of the Visual Studio 2013 edition so

233
00:09:20,570 --> 00:09:23,779
very leet here and we also find a

234
00:09:23,779 --> 00:09:27,200
hard-coded string in marked in red rich

235
00:09:27,200 --> 00:09:29,690
which indicates that this is indeed a

236
00:09:29,690 --> 00:09:33,399
rich header we're about to deal with now

237
00:09:33,399 --> 00:09:35,870
if you look at this data then you will

238
00:09:35,870 --> 00:09:39,110
see that its contents above the colors

239
00:09:39,110 --> 00:09:41,420
parts are quite entangled or obfuscated

240
00:09:41,420 --> 00:09:44,450
you could say and well some of you might

241
00:09:44,450 --> 00:09:46,010
already have guessed it if I take the

242
00:09:46,010 --> 00:09:48,310
magic value that I have in purple and

243
00:09:48,310 --> 00:09:50,870
use it to soar over the rest of the

244
00:09:50,870 --> 00:09:52,550
header then the value start to make

245
00:09:52,550 --> 00:09:55,490
sense again at the top you can see even

246
00:09:55,490 --> 00:09:57,709
more padding in orange and an automatic

247
00:09:57,709 --> 00:09:59,209
string magically appears

248
00:09:59,209 --> 00:10:02,270
reading Dan s and now the payload that

249
00:10:02,270 --> 00:10:04,790
the rich header actually contains is the

250
00:10:04,790 --> 00:10:07,040
blue part here where we can see what we

251
00:10:07,040 --> 00:10:10,100
named comp ID blocks one comp ID block

252
00:10:10,100 --> 00:10:14,029
consists of 64 bits and we see here 10

253
00:10:14,029 --> 00:10:16,910
comp ID blocks so let's try to interpret

254
00:10:16,910 --> 00:10:20,360
them we have 8 bytes per comp ID block

255
00:10:20,360 --> 00:10:22,790
and what they contain is usually the

256
00:10:22,790 --> 00:10:25,400
following so the first 16 bits are the

257
00:10:25,400 --> 00:10:27,650
miner compiler version that the compiler

258
00:10:27,650 --> 00:10:31,160
which created the object had the next 16

259
00:10:31,160 --> 00:10:34,190
bits are the product ID which identify

260
00:10:34,190 --> 00:10:36,350
not only the compiler version but also

261
00:10:36,350 --> 00:10:38,480
what the object that we're dealing with

262
00:10:38,480 --> 00:10:41,420
was before compilation which is quite

263
00:10:41,420 --> 00:10:43,880
interesting and then there is a 32-bit

264
00:10:43,880 --> 00:10:46,040
count field which indicates how many

265
00:10:46,040 --> 00:10:48,250
symbols within that object are

266
00:10:48,250 --> 00:10:52,570
referenced by the binary we are about to

267
00:10:52,570 --> 00:10:57,680
compile so this is quite abstract if you

268
00:10:57,680 --> 00:10:59,060
take some concrete examples for that

269
00:10:59,060 --> 00:11:02,120
prot ID then looking at this table for

270
00:11:02,120 --> 00:11:04,010
instance the current with Visual Studio

271
00:11:04,010 --> 00:11:05,810
release 2015

272
00:11:05,810 --> 00:11:07,970
you just compiled together a binary and

273
00:11:07,970 --> 00:11:09,620
look at what values you find in a rich

274
00:11:09,620 --> 00:11:11,330
header then they are typically currently

275
00:11:11,330 --> 00:11:15,800
around 256 so hex 105 is currently in

276
00:11:15,800 --> 00:11:18,320
the indicator that for that we are

277
00:11:18,320 --> 00:11:21,290
dealing with an object that was a C++

278
00:11:21,290 --> 00:11:23,660
source file before compilation and had

279
00:11:23,660 --> 00:11:27,410
me spit out by c2 DLL and one thing you

280
00:11:27,410 --> 00:11:30,050
could now do of course is asking hey hmm

281
00:11:30,050 --> 00:11:32,240
so we're currently the 105 what if we go

282
00:11:32,240 --> 00:11:35,839
back in time so this is Studio 2010 for

283
00:11:35,839 --> 00:11:38,930
instance I gave some exemplary values

284
00:11:38,930 --> 00:11:42,710
here has b4 for C++ files and if we go

285
00:11:42,710 --> 00:11:45,290
back even further for instance to visual

286
00:11:45,290 --> 00:11:47,330
studio.net so that's inefficiently

287
00:11:47,330 --> 00:11:50,510
version 71 then you find values in the

288
00:11:50,510 --> 00:11:53,210
range of 5 e for instance and the oldest

289
00:11:53,210 --> 00:11:54,830
one we were able to reproduce this

290
00:11:54,830 --> 00:11:57,050
actually hex 15 for visual studio

291
00:11:57,050 --> 00:11:59,839
release 6 so that was the one back to

292
00:11:59,839 --> 00:12:03,950
1998 some of you might remember relating

293
00:12:03,950 --> 00:12:07,850
to AC file so and if you look at this

294
00:12:07,850 --> 00:12:10,040
then you could try to build up a

295
00:12:10,040 --> 00:12:11,660
database and that's exactly what we

296
00:12:11,660 --> 00:12:14,390
tried to do but the ranges we obtained

297
00:12:14,390 --> 00:12:17,480
still have holes in them so this is

298
00:12:17,480 --> 00:12:19,370
actually a call for participation if any

299
00:12:19,370 --> 00:12:21,740
of you has some old visual studio

300
00:12:21,740 --> 00:12:23,540
releases lying around or even newer ones

301
00:12:23,540 --> 00:12:25,640
we would be very very interested to look

302
00:12:25,640 --> 00:12:27,920
at those files we named there and look

303
00:12:27,920 --> 00:12:29,690
what values they are able to produce for

304
00:12:29,690 --> 00:12:33,800
the rich header so this is one part

305
00:12:33,800 --> 00:12:34,339
about it

306
00:12:34,339 --> 00:12:37,640
the second part about it is that we

307
00:12:37,640 --> 00:12:41,240
sometimes also observe values that are

308
00:12:41,240 --> 00:12:44,380
completely out of that range outside so

309
00:12:44,380 --> 00:12:47,600
we have no real explanation on that it

310
00:12:47,600 --> 00:12:49,370
might be because somebody tried to forge

311
00:12:49,370 --> 00:12:51,680
the values in there but it's interesting

312
00:12:51,680 --> 00:12:53,780
to note that there seems to be a certain

313
00:12:53,780 --> 00:12:56,209
correlation to major companies that

314
00:12:56,209 --> 00:12:58,339
Microsoft partners with so there is a

315
00:12:58,339 --> 00:13:00,410
special prodigy for Adobe products for

316
00:13:00,410 --> 00:13:03,050
instance but everything beyond what we

317
00:13:03,050 --> 00:13:06,589
could say is just speculation ok now we

318
00:13:06,589 --> 00:13:09,500
know what the header includes do you

319
00:13:09,500 --> 00:13:11,380
still remember the ones for c7 checksum

320
00:13:11,380 --> 00:13:16,250
let's look at this limit so in order to

321
00:13:16,250 --> 00:13:18,260
explain how the checksum

322
00:13:18,260 --> 00:13:21,950
I brought a tiny Python snippet here and

323
00:13:21,950 --> 00:13:24,020
I will go through it one by one such

324
00:13:24,020 --> 00:13:26,390
that we get a understanding of what is

325
00:13:26,390 --> 00:13:27,110
going on here

326
00:13:27,110 --> 00:13:29,270
so the first three lines are basically

327
00:13:29,270 --> 00:13:31,340
just a library function you could say

328
00:13:31,340 --> 00:13:34,490
it's doing a bitwise rotate left

329
00:13:34,490 --> 00:13:38,420
operation on four bytes 32 bits so don't

330
00:13:38,420 --> 00:13:39,860
get the math behind it's just believe

331
00:13:39,860 --> 00:13:42,620
that's wrong 32 and then there's the

332
00:13:42,620 --> 00:13:44,360
actual checksum calculation function

333
00:13:44,360 --> 00:13:46,220
which gets three arguments that is the

334
00:13:46,220 --> 00:13:50,060
raw data of the PE file the net

335
00:13:50,060 --> 00:13:52,300
information of the comp IDs we just

336
00:13:52,300 --> 00:13:55,040
discussed and also that is very

337
00:13:55,040 --> 00:13:57,470
important the offset of the beginning of

338
00:13:57,470 --> 00:13:59,990
the Reg header which well some parts are

339
00:13:59,990 --> 00:14:02,570
tend to hard-code but actually is not a

340
00:14:02,570 --> 00:14:06,200
constant value so if you look at the

341
00:14:06,200 --> 00:14:08,420
first loop for instance then one thing

342
00:14:08,420 --> 00:14:10,040
that is interesting to note already is

343
00:14:10,040 --> 00:14:12,500
that the checksum calculation includes

344
00:14:12,500 --> 00:14:15,260
the values within the doors error right

345
00:14:15,260 --> 00:14:16,940
it simply takes the values that you can

346
00:14:16,940 --> 00:14:20,540
find the daus header rotates them by the

347
00:14:20,540 --> 00:14:22,310
offset you could found the value add and

348
00:14:22,310 --> 00:14:24,140
then sums them up that's what the code

349
00:14:24,140 --> 00:14:26,750
is doing and what is also another

350
00:14:26,750 --> 00:14:29,330
pitfall at this point is because the

351
00:14:29,330 --> 00:14:30,860
checksumming function resides in the

352
00:14:30,860 --> 00:14:33,589
linker it doesn't know the value of the

353
00:14:33,589 --> 00:14:35,990
e.l.f a new field remember that was the

354
00:14:35,990 --> 00:14:37,460
little iron arrow I showed you in the

355
00:14:37,460 --> 00:14:39,290
beginning so the arrow pointing to the

356
00:14:39,290 --> 00:14:41,000
COFF header and because the linker

357
00:14:41,000 --> 00:14:44,150
doesn't know yet how big the coffee rich

358
00:14:44,150 --> 00:14:46,670
header will be it simply fills in dummy

359
00:14:46,670 --> 00:14:48,920
values at this part and skips that in

360
00:14:48,920 --> 00:14:51,530
the calculation of the checksum so this

361
00:14:51,530 --> 00:14:53,750
is another pitfall that many parcels to

362
00:14:53,750 --> 00:14:57,170
wrong and well after check something in

363
00:14:57,170 --> 00:14:59,300
the header and we find that it actually

364
00:14:59,300 --> 00:15:00,710
checks Sam's the contents of the rich

365
00:15:00,710 --> 00:15:02,660
header which is just well putting

366
00:15:02,660 --> 00:15:04,190
together the product ID the miner

367
00:15:04,190 --> 00:15:06,350
compiler version and then rotates the

368
00:15:06,350 --> 00:15:08,600
combination of those two values by the

369
00:15:08,600 --> 00:15:10,339
number of times the product had been

370
00:15:10,339 --> 00:15:13,490
used well the result is truncated to

371
00:15:13,490 --> 00:15:15,860
32-bit and then used as the magic once

372
00:15:15,860 --> 00:15:18,580
we see seven value from the beginning of

373
00:15:18,580 --> 00:15:21,680
yeah now if we look at this and step

374
00:15:21,680 --> 00:15:24,230
back and think about it a second then we

375
00:15:24,230 --> 00:15:26,570
might find that this is actually a very

376
00:15:26,570 --> 00:15:29,240
poor choice for check sum function why

377
00:15:29,240 --> 00:15:30,670
is the so well

378
00:15:30,670 --> 00:15:34,570
the point is that rotating a four byte

379
00:15:34,570 --> 00:15:38,170
string by something that is bigger than

380
00:15:38,170 --> 00:15:42,310
32 bits or 32 is Viktor effectively a

381
00:15:42,310 --> 00:15:45,520
knob so rotating by 32 bits 32 bits is

382
00:15:45,520 --> 00:15:47,740
like rotating nothing right

383
00:15:47,740 --> 00:15:53,290
so all account values above 32 that's a

384
00:15:53,290 --> 00:15:55,420
5 bit value are actually completely

385
00:15:55,420 --> 00:16:00,580
congruent to anything below 32 so at

386
00:16:00,580 --> 00:16:02,680
this part you can see that out of the 32

387
00:16:02,680 --> 00:16:05,130
bits that are there in the count field

388
00:16:05,130 --> 00:16:08,500
only the lowest 5 are actually checked

389
00:16:08,500 --> 00:16:11,950
leaving 27 open so if you to do the math

390
00:16:11,950 --> 00:16:14,290
27 plus the other 32 bits then we see

391
00:16:14,290 --> 00:16:17,080
that only 37 out of 64 bits per Kampai

392
00:16:17,080 --> 00:16:19,120
d-struct are checked by the checksum

393
00:16:19,120 --> 00:16:21,760
function which is kind of strange if

394
00:16:21,760 --> 00:16:25,900
there should be a checksum alright so we

395
00:16:25,900 --> 00:16:27,610
now spoke a little bit about the

396
00:16:27,610 --> 00:16:29,650
contents of the Reg header I try to

397
00:16:29,650 --> 00:16:31,860
explain you how the checksum is built up

398
00:16:31,860 --> 00:16:33,970
the last question I would like to answer

399
00:16:33,970 --> 00:16:37,180
is who actually built up the rich header

400
00:16:37,180 --> 00:16:42,120
and this is also no black magic here the

401
00:16:42,120 --> 00:16:45,310
Microsoft back-end compiler puts a comp

402
00:16:45,310 --> 00:16:48,790
a decomp ID per object during

403
00:16:48,790 --> 00:16:51,070
compilation and linked out XE collects

404
00:16:51,070 --> 00:16:53,590
them together such that all objects that

405
00:16:53,590 --> 00:16:56,320
are contained in one executable well are

406
00:16:56,320 --> 00:16:59,230
then put into the Reg header one

407
00:16:59,230 --> 00:17:00,760
exception is there though these are

408
00:17:00,760 --> 00:17:02,680
statically linked libraries dot Lib if

409
00:17:02,680 --> 00:17:05,079
these can contain multiple objects they

410
00:17:05,079 --> 00:17:07,540
also contain multiple comp IDs but in

411
00:17:07,540 --> 00:17:09,160
practice that doesn't make much of a

412
00:17:09,160 --> 00:17:10,540
difference because link exhibit just

413
00:17:10,540 --> 00:17:12,819
well sort them out and add them to the

414
00:17:12,819 --> 00:17:15,490
header all right and that was a

415
00:17:15,490 --> 00:17:17,380
technical dive through rich header and

416
00:17:17,380 --> 00:17:19,089
now I hand it back to George with

417
00:17:19,089 --> 00:17:23,800
statistics all right so we kind of

418
00:17:23,800 --> 00:17:25,450
understand what the rich header does but

419
00:17:25,450 --> 00:17:27,220
that doesn't really help us for triage

420
00:17:27,220 --> 00:17:29,530
so what does this mean how do we start

421
00:17:29,530 --> 00:17:30,850
to put it together and how do we start

422
00:17:30,850 --> 00:17:32,770
to take advantage of it and that's what

423
00:17:32,770 --> 00:17:33,910
I'm going to kind of go into right now

424
00:17:33,910 --> 00:17:35,590
so the first thing is I'm gonna talk a

425
00:17:35,590 --> 00:17:38,890
little bit about statistics so the rich

426
00:17:38,890 --> 00:17:41,500
header is very specific to Microsoft and

427
00:17:41,500 --> 00:17:43,990
we know that by pretty much malicious

428
00:17:43,990 --> 00:17:44,590
file

429
00:17:44,590 --> 00:17:46,330
they love to try to off you skate

430
00:17:46,330 --> 00:17:48,549
themselves and hide themselves so how

431
00:17:48,549 --> 00:17:50,169
prevalent is this gonna be because that

432
00:17:50,169 --> 00:17:51,760
that is valuable so if they know about

433
00:17:51,760 --> 00:17:54,520
it they should hide it so we took about

434
00:17:54,520 --> 00:17:56,289
a million samples and we ran it through

435
00:17:56,289 --> 00:17:58,750
the parsers and we find that it's

436
00:17:58,750 --> 00:18:01,000
actually quite prevalent 71 percent of

437
00:18:01,000 --> 00:18:02,530
all of our samples actually did contain

438
00:18:02,530 --> 00:18:04,510
a rich header this was much higher than

439
00:18:04,510 --> 00:18:06,429
our assumption was initially so that was

440
00:18:06,429 --> 00:18:08,919
pretty fantastic way more prevalent than

441
00:18:08,919 --> 00:18:11,799
we thought our next assumption was well

442
00:18:11,799 --> 00:18:13,630
you know some of your more sophisticated

443
00:18:13,630 --> 00:18:15,490
actors they probably at least strip it

444
00:18:15,490 --> 00:18:18,520
out so we looked at apt one we had a

445
00:18:18,520 --> 00:18:20,590
couple thousand samples actually it's

446
00:18:20,590 --> 00:18:22,960
two hundred and ninety eight samples for

447
00:18:22,960 --> 00:18:25,809
apt one we said how often do they strip

448
00:18:25,809 --> 00:18:28,720
it out how much do they have and it's

449
00:18:28,720 --> 00:18:31,450
98% of all apt one samples that we have

450
00:18:31,450 --> 00:18:33,610
actually contain the rich header so

451
00:18:33,610 --> 00:18:34,809
that's pretty cool we know sophisticated

452
00:18:34,809 --> 00:18:37,419
actors aren't dealing with it so we said

453
00:18:37,419 --> 00:18:39,190
what about you know some more criminal

454
00:18:39,190 --> 00:18:42,010
stuff some common criminal stuff so we

455
00:18:42,010 --> 00:18:43,929
looked at Zeus Citadel we saw from

456
00:18:43,929 --> 00:18:46,780
bridge header it's 37 percent still a

457
00:18:46,780 --> 00:18:49,450
decent number especially for triage but

458
00:18:49,450 --> 00:18:51,190
we're starting to see that something's

459
00:18:51,190 --> 00:18:52,299
different something's weird

460
00:18:52,299 --> 00:18:54,159
but everything's not glorious in this

461
00:18:54,159 --> 00:18:56,409
case because we have 71% for random

462
00:18:56,409 --> 00:18:59,289
which is fantastic 98 for apt 1 which is

463
00:18:59,289 --> 00:19:02,440
fantastic but we got 37 for Zeus this

464
00:19:02,440 --> 00:19:04,840
brings us to the next point is that when

465
00:19:04,840 --> 00:19:06,340
we look at the Medi z' malware sample

466
00:19:06,340 --> 00:19:08,440
set we only had 2% had the rich header

467
00:19:08,440 --> 00:19:10,330
when I go in a little bit of the reasons

468
00:19:10,330 --> 00:19:14,559
why but 71% is pretty fantastic but this

469
00:19:14,559 --> 00:19:15,909
means that rich header is not a sure

470
00:19:15,909 --> 00:19:17,980
shot and I did want to caveat with that

471
00:19:17,980 --> 00:19:19,510
that while it is good it's gonna help

472
00:19:19,510 --> 00:19:21,130
you a lot with triage and we're gonna do

473
00:19:21,130 --> 00:19:23,200
some cool stuff with it you got to be

474
00:19:23,200 --> 00:19:24,490
really careful when you use it because

475
00:19:24,490 --> 00:19:26,400
not everything is going to contain it

476
00:19:26,400 --> 00:19:28,929
the reason it doesn't contain it really

477
00:19:28,929 --> 00:19:31,059
comes down to the Microsoft linker since

478
00:19:31,059 --> 00:19:32,950
the Microsoft linkers built it there's

479
00:19:32,950 --> 00:19:34,690
really no documentation for it there's

480
00:19:34,690 --> 00:19:36,429
no real expectation that other people

481
00:19:36,429 --> 00:19:38,200
are going to do it

482
00:19:38,200 --> 00:19:40,510
so one malware doesn't have the rich

483
00:19:40,510 --> 00:19:42,610
header you pretty much have a good

484
00:19:42,610 --> 00:19:44,620
assumption right now that it's using

485
00:19:44,620 --> 00:19:48,190
those basically built by dotnet Mini GW

486
00:19:48,190 --> 00:19:51,400
GCC or also a packer like D of that

487
00:19:51,400 --> 00:19:53,230
pretty much is going to be stripping out

488
00:19:53,230 --> 00:19:54,640
the rip cutter because it's not going to

489
00:19:54,640 --> 00:19:57,220
include it in the first place however if

490
00:19:57,220 --> 00:19:58,150
we look at what

491
00:19:58,150 --> 00:19:59,740
includes the red cheddar we see we got

492
00:19:59,740 --> 00:20:02,350
visual Studios you know what's

493
00:20:02,350 --> 00:20:03,610
interesting to some partners such as

494
00:20:03,610 --> 00:20:05,530
Intel's compiler actually does include

495
00:20:05,530 --> 00:20:07,030
the rich header as well we don't know if

496
00:20:07,030 --> 00:20:08,860
that includes the linker in it or if

497
00:20:08,860 --> 00:20:10,120
they just actually built it because

498
00:20:10,120 --> 00:20:12,550
their partners no idea but the three

499
00:20:12,550 --> 00:20:13,870
things that are really cool here is

500
00:20:13,870 --> 00:20:15,520
Packers like upx

501
00:20:15,520 --> 00:20:18,310
ass pack and also no soft they actually

502
00:20:18,310 --> 00:20:20,230
do and keep the rich header in there but

503
00:20:20,230 --> 00:20:21,880
they kind of distorted ever so slightly

504
00:20:21,880 --> 00:20:26,410
which really becomes quite fantastic so

505
00:20:26,410 --> 00:20:29,440
so what and once you have this

506
00:20:29,440 --> 00:20:30,610
information we know it's pretty

507
00:20:30,610 --> 00:20:32,860
prevalent it's got some interesting

508
00:20:32,860 --> 00:20:34,870
stuff let's actually see what we can do

509
00:20:34,870 --> 00:20:36,340
with it and how it can really help with

510
00:20:36,340 --> 00:20:39,880
the triage so the first is that the rich

511
00:20:39,880 --> 00:20:41,680
header is really really quite valuable

512
00:20:41,680 --> 00:20:44,320
in the sense that it's it's informative

513
00:20:44,320 --> 00:20:45,640
you can start to figure out how the

514
00:20:45,640 --> 00:20:47,560
binary is actually built and it's got

515
00:20:47,560 --> 00:20:49,750
tons of fun stuff we're gonna ignore

516
00:20:49,750 --> 00:20:51,700
that standpoint from now for the reverse

517
00:20:51,700 --> 00:20:53,170
engineering side but we're only going to

518
00:20:53,170 --> 00:20:56,530
talk about the triage so the first part

519
00:20:56,530 --> 00:20:57,820
is discrepancies are absolutely

520
00:20:57,820 --> 00:21:00,820
fantastic when we actually look at it if

521
00:21:00,820 --> 00:21:03,400
the checksum is corrupt that's pretty

522
00:21:03,400 --> 00:21:05,140
much a guarantee right now that the

523
00:21:05,140 --> 00:21:07,180
binary was post modified because people

524
00:21:07,180 --> 00:21:08,590
don't forget it like they just forget

525
00:21:08,590 --> 00:21:10,000
about the rich header so they're not

526
00:21:10,000 --> 00:21:11,920
trying to fix that checks up so if you

527
00:21:11,920 --> 00:21:14,050
see the checksum corrupt pretty much a

528
00:21:14,050 --> 00:21:17,260
guarantee the binaries post modified the

529
00:21:17,260 --> 00:21:19,960
second part is duplicate entries those

530
00:21:19,960 --> 00:21:21,610
three Packers I talked all of them do

531
00:21:21,610 --> 00:21:23,620
this when they actually packed the

532
00:21:23,620 --> 00:21:25,360
binaries pretty together you see a

533
00:21:25,360 --> 00:21:28,120
Product ID you see a version information

534
00:21:28,120 --> 00:21:29,980
and you see a count and you actually see

535
00:21:29,980 --> 00:21:31,810
duplicate entries in there there's no

536
00:21:31,810 --> 00:21:33,610
reason the Microsoft linker is gonna put

537
00:21:33,610 --> 00:21:35,530
duplicate entries in there so it's

538
00:21:35,530 --> 00:21:37,180
almost a guarantee that that binary was

539
00:21:37,180 --> 00:21:40,510
now packed and the next aspect is to

540
00:21:40,510 --> 00:21:42,340
check this rich setter to start parsing

541
00:21:42,340 --> 00:21:44,140
it and looking at together it's

542
00:21:44,140 --> 00:21:45,970
incredibly fast it's really inefficient

543
00:21:45,970 --> 00:21:48,070
it's really cheap it makes life pretty

544
00:21:48,070 --> 00:21:52,300
fun for us but can we do more there's a

545
00:21:52,300 --> 00:21:53,980
lot of information in there and that's

546
00:21:53,980 --> 00:21:55,770
what we're gonna start talking about now

547
00:21:55,770 --> 00:21:58,420
so when he looked at it we wanted to see

548
00:21:58,420 --> 00:21:59,440
if we could do some machine learning

549
00:21:59,440 --> 00:22:01,300
some deep learning fun stuff and

550
00:22:01,300 --> 00:22:03,190
actually create an algorithm that was

551
00:22:03,190 --> 00:22:05,200
incredibly fast see if we can do it in

552
00:22:05,200 --> 00:22:07,210
near real-time we wanted to do

553
00:22:07,210 --> 00:22:08,950
similarity matching upon millions and

554
00:22:08,950 --> 00:22:10,660
millions of binaries because we deal

555
00:22:10,660 --> 00:22:11,320
with millions of

556
00:22:11,320 --> 00:22:13,630
on a daily basis we also have

557
00:22:13,630 --> 00:22:15,040
interesting stuff with the version

558
00:22:15,040 --> 00:22:16,840
information and we wanted to see if that

559
00:22:16,840 --> 00:22:18,910
could fingerprint the actors and when I

560
00:22:18,910 --> 00:22:20,110
say actors I'm really talking about

561
00:22:20,110 --> 00:22:21,670
build environments there is a

562
00:22:21,670 --> 00:22:23,110
discrepancy it's not a direct

563
00:22:23,110 --> 00:22:24,310
correlation but there is some

564
00:22:24,310 --> 00:22:25,930
correlation there I can tell you what

565
00:22:25,930 --> 00:22:28,810
machine that Mauer was built on so could

566
00:22:28,810 --> 00:22:30,760
we actually do it the answer is yes and

567
00:22:30,760 --> 00:22:33,000
we're gonna go into how we did it now

568
00:22:33,000 --> 00:22:35,680
the first thing is the rich header data

569
00:22:35,680 --> 00:22:38,500
is incredibly sparse from a machine

570
00:22:38,500 --> 00:22:39,700
learning perspective that's not really

571
00:22:39,700 --> 00:22:42,220
great so we needed to fix that and what

572
00:22:42,220 --> 00:22:43,990
we did we used a deep learning technique

573
00:22:43,990 --> 00:22:47,170
call it a stacked auto and coder and I'm

574
00:22:47,170 --> 00:22:48,730
not gonna get into the math but we'll

575
00:22:48,730 --> 00:22:50,800
look at Mario if right now so all it

576
00:22:50,800 --> 00:22:52,120
really does is take this really cool

577
00:22:52,120 --> 00:22:54,010
picture of Mario and it puts it to a

578
00:22:54,010 --> 00:22:55,930
denser lower dimensional space and

579
00:22:55,930 --> 00:22:57,760
that's the two-dimensional picture of

580
00:22:57,760 --> 00:22:59,410
Mario and that's really all we need to

581
00:22:59,410 --> 00:23:02,470
know what benefits us is it gives us a

582
00:23:02,470 --> 00:23:04,240
little bit cleaner results and it's

583
00:23:04,240 --> 00:23:06,160
incredibly memory efficient so instead

584
00:23:06,160 --> 00:23:07,270
of dealing with millions upon millions

585
00:23:07,270 --> 00:23:09,520
of samples meaning gigs and gigs of RAM

586
00:23:09,520 --> 00:23:11,320
all sudden out need a server I can

587
00:23:11,320 --> 00:23:12,820
actually do this on our algorithm and

588
00:23:12,820 --> 00:23:13,720
when I do actually show the

589
00:23:13,720 --> 00:23:15,580
demonstration this was all recorded with

590
00:23:15,580 --> 00:23:20,140
an out just a silly laptop so the next

591
00:23:20,140 --> 00:23:21,490
part is once I have it now in a

592
00:23:21,490 --> 00:23:23,110
dimensional space I can really start to

593
00:23:23,110 --> 00:23:24,670
work with and start to take care of it

594
00:23:24,670 --> 00:23:26,470
we wanted to do actually two similarity

595
00:23:26,470 --> 00:23:29,230
match an aspect of it and we chose KNN

596
00:23:29,230 --> 00:23:32,770
let me chose ball tray and to talk about

597
00:23:32,770 --> 00:23:34,750
the kan km it's a great algorithm for

598
00:23:34,750 --> 00:23:36,550
similarity matching it doesn't really

599
00:23:36,550 --> 00:23:38,710
require much pre-processing it's pretty

600
00:23:38,710 --> 00:23:40,570
easy to work with but the really key

601
00:23:40,570 --> 00:23:43,150
aspect here is I don't need to predefine

602
00:23:43,150 --> 00:23:46,390
my but my buckets my grooves some of the

603
00:23:46,390 --> 00:23:48,000
other app matching algorithms out there

604
00:23:48,000 --> 00:23:50,350
you have to say okay I had a hundred

605
00:23:50,350 --> 00:23:52,750
buckets I got 200 buckets well I have no

606
00:23:52,750 --> 00:23:54,340
idea how many buckets I have a couple

607
00:23:54,340 --> 00:23:56,320
million malware samples KNM is gonna

608
00:23:56,320 --> 00:23:57,610
figure it out for me and that's really

609
00:23:57,610 --> 00:24:00,760
what I want the next is it with the ball

610
00:24:00,760 --> 00:24:02,950
trees allows really really rapid lookups

611
00:24:02,950 --> 00:24:04,930
so these numbers were all recorded on a

612
00:24:04,930 --> 00:24:08,320
laptop and we got six point seven three

613
00:24:08,320 --> 00:24:11,350
milliseconds so that's pretty good so on

614
00:24:11,350 --> 00:24:13,240
my silly laptop it's about three years

615
00:24:13,240 --> 00:24:15,850
old Mac it's not really great I can

616
00:24:15,850 --> 00:24:17,530
throw in a hash in there spit out

617
00:24:17,530 --> 00:24:19,420
results in about six point seven three

618
00:24:19,420 --> 00:24:21,100
milliseconds for all the similar malware

619
00:24:21,100 --> 00:24:21,830
I have

620
00:24:21,830 --> 00:24:24,019
what's also in this vowel tree we did a

621
00:24:24,019 --> 00:24:26,210
static poultry but ball trees great to

622
00:24:26,210 --> 00:24:27,529
work with it's pretty nice you could

623
00:24:27,529 --> 00:24:29,360
actually turn this into real up like a

624
00:24:29,360 --> 00:24:31,249
real-time system where you actually are

625
00:24:31,249 --> 00:24:34,970
doing it on the fly as well so to

626
00:24:34,970 --> 00:24:36,049
actually show you what the training

627
00:24:36,049 --> 00:24:37,789
thing is we have a quick little

628
00:24:37,789 --> 00:24:40,460
demonstration so you guys know this is

629
00:24:40,460 --> 00:24:41,659
going to be fully trained across a

630
00:24:41,659 --> 00:24:44,149
couple of million samples so the first

631
00:24:44,149 --> 00:24:46,159
is I'm going to take it and what's

632
00:24:46,159 --> 00:24:47,720
really going on here is I'm loading

633
00:24:47,720 --> 00:24:50,509
tensorflow all this happening wonderful

634
00:24:50,509 --> 00:24:53,029
thing tend to flow is loading up and

635
00:24:53,029 --> 00:24:59,210
it's a little bit slow lit so here's

636
00:24:59,210 --> 00:25:01,460
where the magic happens what's going on

637
00:25:01,460 --> 00:25:03,889
is it's taking all that data and it's

638
00:25:03,889 --> 00:25:05,359
going to start constructing into a lower

639
00:25:05,359 --> 00:25:07,279
dimensional space and this is real-time

640
00:25:07,279 --> 00:25:07,820
training

641
00:25:07,820 --> 00:25:09,619
I'm not speeding it up this is accurate

642
00:25:09,619 --> 00:25:11,690
on average it's about six seconds or so

643
00:25:11,690 --> 00:25:13,549
so I'm training all of my information

644
00:25:13,549 --> 00:25:15,590
putting into this space I want and kind

645
00:25:15,590 --> 00:25:18,559
of getting my ball tree in order so

646
00:25:18,559 --> 00:25:20,600
there it's done it's now too much a

647
00:25:20,600 --> 00:25:22,100
lower dimensional space I can actually

648
00:25:22,100 --> 00:25:23,809
start working with it I'm pretty happy

649
00:25:23,809 --> 00:25:26,690
and it's creating my ball tray so I

650
00:25:26,690 --> 00:25:28,070
think that was about a million samples

651
00:25:28,070 --> 00:25:29,239
might have been about 2 million

652
00:25:29,239 --> 00:25:33,950
everything's already trained so the next

653
00:25:33,950 --> 00:25:36,470
is we want to do a lookup so what I say

654
00:25:36,470 --> 00:25:38,570
it's really fast so I pretty much have

655
00:25:38,570 --> 00:25:39,409
everything ready to go

656
00:25:39,409 --> 00:25:43,840
it's got my saw pretty much press play

657
00:25:43,840 --> 00:25:47,899
and there we go I got my JSON output of

658
00:25:47,899 --> 00:25:49,700
all my similar samples and it makes no

659
00:25:49,700 --> 00:25:50,960
difference at this I'm telling it to

660
00:25:50,960 --> 00:25:52,879
spit out ten samples to--and spit out a

661
00:25:52,879 --> 00:25:54,350
hundred samples telling it to spit out

662
00:25:54,350 --> 00:25:56,389
200 samples it's pretty much about the

663
00:25:56,389 --> 00:25:58,369
same amount of time which is pretty

664
00:25:58,369 --> 00:26:01,129
fantastic in my opinion but we're

665
00:26:01,129 --> 00:26:04,129
dealing with JSON and JSON is great but

666
00:26:04,129 --> 00:26:05,419
I don't know about you guys I need

667
00:26:05,419 --> 00:26:09,919
pretty pictures so from the printers

668
00:26:09,919 --> 00:26:11,749
perspective we look at what that JSON is

669
00:26:11,749 --> 00:26:13,970
doing is I'm not really clustering

670
00:26:13,970 --> 00:26:14,960
because it's technically not a

671
00:26:14,960 --> 00:26:16,249
clustering but I'm putting them in

672
00:26:16,249 --> 00:26:18,499
little buckets here so we have nearest

673
00:26:18,499 --> 00:26:20,450
neighbor one and we go all the way to

674
00:26:20,450 --> 00:26:21,799
nearest neighbor town on this we have

675
00:26:21,799 --> 00:26:24,139
much more and within those buckets we

676
00:26:24,139 --> 00:26:26,590
have correlations of different samples

677
00:26:26,590 --> 00:26:29,059
from the distance metric we can see that

678
00:26:29,059 --> 00:26:30,529
all these samples in these different

679
00:26:30,529 --> 00:26:32,029
buckets are all actually really quite

680
00:26:32,029 --> 00:26:33,710
similar and we're going to start to dive

681
00:26:33,710 --> 00:26:34,730
into that and go into

682
00:26:34,730 --> 00:26:36,559
couple different case studies to explain

683
00:26:36,559 --> 00:26:38,240
what's actually in there and why this

684
00:26:38,240 --> 00:26:41,780
gets really really cool so the first

685
00:26:41,780 --> 00:26:44,470
case study we want to look at is apt one

686
00:26:44,470 --> 00:26:47,630
so we took a random sha and we said

687
00:26:47,630 --> 00:26:49,370
let's run this through the algorithm and

688
00:26:49,370 --> 00:26:52,460
see what I have what was interesting in

689
00:26:52,460 --> 00:26:54,410
all these results all the AV signatures

690
00:26:54,410 --> 00:26:55,760
were different they're all for the most

691
00:26:55,760 --> 00:26:57,140
part generic but they're all different

692
00:26:57,140 --> 00:27:00,860
generic signatures so the first one is

693
00:27:00,860 --> 00:27:02,900
we saw a direct correlation between

694
00:27:02,900 --> 00:27:05,090
another sample set that we had and this

695
00:27:05,090 --> 00:27:08,059
is only about 200 and I think was 290

696
00:27:08,059 --> 00:27:09,440
samples were looking at just in this

697
00:27:09,440 --> 00:27:12,620
group we found another sample the rich

698
00:27:12,620 --> 00:27:14,540
header was identical what this means

699
00:27:14,540 --> 00:27:16,190
when we started to reverse engineer and

700
00:27:16,190 --> 00:27:17,510
and look at it we found that the code

701
00:27:17,510 --> 00:27:20,330
actually was identical like identical

702
00:27:20,330 --> 00:27:22,730
code base of course that means we have

703
00:27:22,730 --> 00:27:24,830
identical functionality the difference

704
00:27:24,830 --> 00:27:26,360
in the SHA was actually just because of

705
00:27:26,360 --> 00:27:29,630
a compiler artifact so then we neck

706
00:27:29,630 --> 00:27:31,549
looked at our next bucket and we see

707
00:27:31,549 --> 00:27:33,740
three now those samples and the first is

708
00:27:33,740 --> 00:27:35,210
we're looking at basically a different

709
00:27:35,210 --> 00:27:39,200
version of apt one so the version

710
00:27:39,200 --> 00:27:40,610
information slightly off is a slightly

711
00:27:40,610 --> 00:27:42,890
different build environment we also see

712
00:27:42,890 --> 00:27:45,049
an introduction of a new function called

713
00:27:45,049 --> 00:27:47,870
flush file buffers what's happening is a

714
00:27:47,870 --> 00:27:50,059
pt.1 kind of had a little bit of bug not

715
00:27:50,059 --> 00:27:51,950
really bug is kind of a bad performance

716
00:27:51,950 --> 00:27:53,870
technique they're using where they're

717
00:27:53,870 --> 00:27:55,100
taking their information in there but

718
00:27:55,100 --> 00:27:57,470
buffer and they're writing it to disk

719
00:27:57,470 --> 00:27:59,690
when they wrote it to disk they then

720
00:27:59,690 --> 00:28:01,910
open that file again added their escape

721
00:28:01,910 --> 00:28:04,669
characters and then did another riot so

722
00:28:04,669 --> 00:28:06,440
while the introduction of this flush

723
00:28:06,440 --> 00:28:08,150
file buffers what it's really doing is

724
00:28:08,150 --> 00:28:09,500
it takes this information while it's

725
00:28:09,500 --> 00:28:12,490
still in the its buffer it adds the

726
00:28:12,490 --> 00:28:15,350
string cat function finishes everything

727
00:28:15,350 --> 00:28:17,450
and then writes it to DES so instead of

728
00:28:17,450 --> 00:28:19,700
two writes we got one which is kind of

729
00:28:19,700 --> 00:28:21,440
nice now I know that we have yeah

730
00:28:21,440 --> 00:28:22,640
everything was pretty much what we

731
00:28:22,640 --> 00:28:24,080
expected with a similarity matching

732
00:28:24,080 --> 00:28:26,330
algorithm we did actually have matches

733
00:28:26,330 --> 00:28:30,830
for apt one so then we looked at Zeus we

734
00:28:30,830 --> 00:28:32,840
took another random sample threw it in

735
00:28:32,840 --> 00:28:35,330
our system and he said ok let's see what

736
00:28:35,330 --> 00:28:38,750
it can do the first is we had another

737
00:28:38,750 --> 00:28:41,480
identical matching 23 samples that were

738
00:28:41,480 --> 00:28:44,480
identical rich header we started to

739
00:28:44,480 --> 00:28:45,980
reverse-engineer it I'm taking these all

740
00:28:45,980 --> 00:28:47,920
apart to see why is it like

741
00:28:47,920 --> 00:28:48,940
what's the difference of this why do

742
00:28:48,940 --> 00:28:51,490
they have different hashes and pretty

743
00:28:51,490 --> 00:28:54,070
much all the difference was was you see

744
00:28:54,070 --> 00:28:56,470
an optimization between a do-while and a

745
00:28:56,470 --> 00:28:58,600
for loop and we also see that code

746
00:28:58,600 --> 00:29:00,550
segments were reorganised so all

747
00:29:00,550 --> 00:29:02,320
practical purposes that's the exact same

748
00:29:02,320 --> 00:29:04,810
version of Zeus same our variant it's

749
00:29:04,810 --> 00:29:08,110
all the same we looked at the next

750
00:29:08,110 --> 00:29:11,010
bucket then and we detected four samples

751
00:29:11,010 --> 00:29:13,060
this is pretty much a different version

752
00:29:13,060 --> 00:29:14,620
which is exactly what we're expecting

753
00:29:14,620 --> 00:29:17,350
here is we're seeing an XOR algorithm

754
00:29:17,350 --> 00:29:19,090
kind of an improvement of Zeus where

755
00:29:19,090 --> 00:29:21,490
we're seeing the X logarithms looped 8

756
00:29:21,490 --> 00:29:25,510
times more but this is where it gets

757
00:29:25,510 --> 00:29:27,370
kind of fun because we then put back our

758
00:29:27,370 --> 00:29:29,650
1 million sample set we said how is this

759
00:29:29,650 --> 00:29:31,240
across a larger scale what can we

760
00:29:31,240 --> 00:29:34,930
actually see so in this we threw another

761
00:29:34,930 --> 00:29:38,950
sample Zeus and we detected 36,000 606

762
00:29:38,950 --> 00:29:41,380
samples we've started to

763
00:29:41,380 --> 00:29:42,880
reverse-engineer it we automated this

764
00:29:42,880 --> 00:29:44,950
process with IDA probe because no one's

765
00:29:44,950 --> 00:29:47,170
gonna reverse 36,000 samples if they are

766
00:29:47,170 --> 00:29:49,870
they need friends but we're seeing that

767
00:29:49,870 --> 00:29:50,790
there's pretty much identical

768
00:29:50,790 --> 00:29:53,590
functionality going on here the only

769
00:29:53,590 --> 00:29:55,120
difference that we could observe across

770
00:29:55,120 --> 00:29:56,770
these samples was different you know a

771
00:29:56,770 --> 00:29:59,530
constant values changing slightly now

772
00:29:59,530 --> 00:30:01,630
work gets really fun is we threw all

773
00:30:01,630 --> 00:30:05,350
these samples into virustotal and 16,000

774
00:30:05,350 --> 00:30:07,900
123 of these samples had no virus total

775
00:30:07,900 --> 00:30:09,970
signature whatsoever across any of them

776
00:30:09,970 --> 00:30:11,740
so virustotal is saying these are

777
00:30:11,740 --> 00:30:14,140
completely benign are similarly matching

778
00:30:14,140 --> 00:30:15,970
algorithm saying hey it's not benign

779
00:30:15,970 --> 00:30:17,830
it's got pretty much a direct one-to-one

780
00:30:17,830 --> 00:30:19,750
correlation to the sample you initially

781
00:30:19,750 --> 00:30:22,330
threw in of the ones that were detected

782
00:30:22,330 --> 00:30:23,950
they're usually generic they were

783
00:30:23,950 --> 00:30:26,140
mislabeled something was off about the

784
00:30:26,140 --> 00:30:27,850
signature so that's pretty cool I'm

785
00:30:27,850 --> 00:30:31,390
pretty happy the next is we went through

786
00:30:31,390 --> 00:30:34,860
our next bucket and we saw that we had

787
00:30:34,860 --> 00:30:39,370
1567 samples so that's pretty cool but

788
00:30:39,370 --> 00:30:41,200
something was slightly off so we looked

789
00:30:41,200 --> 00:30:44,350
into why was the rich header off and the

790
00:30:44,350 --> 00:30:45,580
answer here was actually a different

791
00:30:45,580 --> 00:30:47,770
build environment so all the samples

792
00:30:47,770 --> 00:30:49,000
were identical in the sense of

793
00:30:49,000 --> 00:30:51,700
functionality we just had to slip

794
00:30:51,700 --> 00:30:53,440
slightly different variations in the

795
00:30:53,440 --> 00:30:55,180
version information which tells us that

796
00:30:55,180 --> 00:30:57,250
machine was either upgraded they have

797
00:30:57,250 --> 00:30:58,720
created their libraries it was built on

798
00:30:58,720 --> 00:31:00,310
a different machine or someone in

799
00:31:00,310 --> 00:31:03,130
entirely actually built it furthermore

800
00:31:03,130 --> 00:31:06,190
511 of these samples again had no

801
00:31:06,190 --> 00:31:07,960
signature detection whatsoever in

802
00:31:07,960 --> 00:31:08,770
virustotal

803
00:31:08,770 --> 00:31:13,720
so that's pretty cool so we looked at

804
00:31:13,720 --> 00:31:16,330
the validation and whenever you try to

805
00:31:16,330 --> 00:31:18,370
validate anything on millions of samples

806
00:31:18,370 --> 00:31:20,380
it becomes a huge challenge especially

807
00:31:20,380 --> 00:31:22,150
when there's really nothing else to

808
00:31:22,150 --> 00:31:25,150
compare and contrast good to so we

809
00:31:25,150 --> 00:31:26,620
looked at this and we said alright let's

810
00:31:26,620 --> 00:31:29,770
correlate Ida ko Ida Pro generated code

811
00:31:29,770 --> 00:31:31,900
and so we ran that through it automated

812
00:31:31,900 --> 00:31:34,240
across a million samples and we wanted

813
00:31:34,240 --> 00:31:35,650
to get the entropy of the source code

814
00:31:35,650 --> 00:31:37,510
and the differentials along with their

815
00:31:37,510 --> 00:31:38,830
entropy of the source code and the

816
00:31:38,830 --> 00:31:41,530
differentials for the rich header well

817
00:31:41,530 --> 00:31:43,150
we see it's a pretty heat map which is

818
00:31:43,150 --> 00:31:44,320
why I selected this one for the

819
00:31:44,320 --> 00:31:46,360
validation but we see a tight little

820
00:31:46,360 --> 00:31:48,160
cluster in the bottom left that's

821
00:31:48,160 --> 00:31:49,690
exactly what we want to see from a

822
00:31:49,690 --> 00:31:51,310
machine learning perspective to say hey

823
00:31:51,310 --> 00:31:53,560
it actually is doing similarity matching

824
00:31:53,560 --> 00:31:55,420
there is a direct correlation if this

825
00:31:55,420 --> 00:31:56,980
was bad you'd see dots all over the

826
00:31:56,980 --> 00:31:58,630
place and I hate when I see dots all

827
00:31:58,630 --> 00:32:03,190
over the place this is good so in

828
00:32:03,190 --> 00:32:05,380
conclusion if you want to kind of wrap

829
00:32:05,380 --> 00:32:07,000
this up a little bit and explain stuff

830
00:32:07,000 --> 00:32:09,220
and then we love questions so please ask

831
00:32:09,220 --> 00:32:10,750
us questions on it we have tons of stuff

832
00:32:10,750 --> 00:32:13,450
we would like to talk about but yeah

833
00:32:13,450 --> 00:32:17,170
conclusion time the first we really

834
00:32:17,170 --> 00:32:18,820
wanted to emphasize here is the rich

835
00:32:18,820 --> 00:32:20,620
header is really valuable for triage and

836
00:32:20,620 --> 00:32:22,090
it's really important to look at this

837
00:32:22,090 --> 00:32:24,670
from a future work perspective and work

838
00:32:24,670 --> 00:32:27,550
really needs to me be hat on this the

839
00:32:27,550 --> 00:32:30,610
first is a product ID like what are

840
00:32:30,610 --> 00:32:32,920
these true mappings I mean I can tell

841
00:32:32,920 --> 00:32:35,080
you right now from a the Builder and the

842
00:32:35,080 --> 00:32:36,730
compiler ation standpoint of how these

843
00:32:36,730 --> 00:32:38,620
are created but we see tons of stuff

844
00:32:38,620 --> 00:32:40,660
that are unique they seem to be really

845
00:32:40,660 --> 00:32:42,430
really constant what is that mapping

846
00:32:42,430 --> 00:32:43,930
thing there's no way I can tell you

847
00:32:43,930 --> 00:32:45,880
because I'm not Microsoft but it does

848
00:32:45,880 --> 00:32:47,350
allow my similarity matching algorithm

849
00:32:47,350 --> 00:32:49,270
to work so I'm happy but I really want

850
00:32:49,270 --> 00:32:50,310
to know what that is

851
00:32:50,310 --> 00:32:53,140
the next is a checksum microsoft's not

852
00:32:53,140 --> 00:32:55,990
dumb why is it so poor i think that

853
00:32:55,990 --> 00:32:57,550
would be really nice to figure out what

854
00:32:57,550 --> 00:32:59,320
was the reason was it just done in 98

855
00:32:59,320 --> 00:33:01,690
and they just forgot about it possibly I

856
00:33:01,690 --> 00:33:02,320
don't know

857
00:33:02,320 --> 00:33:06,010
and the purpose Microsoft has been very

858
00:33:06,010 --> 00:33:07,630
very secretive about this every time

859
00:33:07,630 --> 00:33:08,800
we've talked to him even through him

860
00:33:08,800 --> 00:33:10,540
from our friends at Microsoft they'll

861
00:33:10,540 --> 00:33:12,640
get excited and talking to us and then

862
00:33:12,640 --> 00:33:14,140
immediately it's just radio silent

863
00:33:14,140 --> 00:33:15,610
and we don't hear from for like two

864
00:33:15,610 --> 00:33:17,380
months which is kind of interesting so

865
00:33:17,380 --> 00:33:19,420
why are they so psych secretive like

866
00:33:19,420 --> 00:33:21,430
what is the original purpose are they

867
00:33:21,430 --> 00:33:23,260
doing something fun with it or is it

868
00:33:23,260 --> 00:33:25,300
just basically they're saying hey we're

869
00:33:25,300 --> 00:33:27,520
using this basically to triage your bug

870
00:33:27,520 --> 00:33:29,230
fixes and putting it to our partners

871
00:33:29,230 --> 00:33:31,300
it's probably my assessment I have no

872
00:33:31,300 --> 00:33:34,990
idea I'd love to know the nests aspect

873
00:33:34,990 --> 00:33:37,690
is really from our similarity matching

874
00:33:37,690 --> 00:33:39,220
perspective we focused from an academic

875
00:33:39,220 --> 00:33:41,650
perspective on what is a similarity

876
00:33:41,650 --> 00:33:43,510
matching just for the rich header we

877
00:33:43,510 --> 00:33:45,160
only included that if you actually want

878
00:33:45,160 --> 00:33:46,180
to use this in practice you should

879
00:33:46,180 --> 00:33:48,160
include other features as well you

880
00:33:48,160 --> 00:33:49,060
probably are going to get something

881
00:33:49,060 --> 00:33:54,550
that's pretty nice so we also every

882
00:33:54,550 --> 00:33:55,840
single thing that we found on the rich

883
00:33:55,840 --> 00:33:58,120
header was there's discrepancies in

884
00:33:58,120 --> 00:33:59,800
there things were messed stuff wasn't

885
00:33:59,800 --> 00:34:02,080
really that good so what we decided to

886
00:34:02,080 --> 00:34:03,490
do was go ahead and give you guys our

887
00:34:03,490 --> 00:34:06,640
extractor we licensed it under Apache -

888
00:34:06,640 --> 00:34:08,830
we created a docker service for it and

889
00:34:08,830 --> 00:34:11,139
it's ready to use in our home system and

890
00:34:11,139 --> 00:34:13,389
homes if you're familiar with crits or

891
00:34:13,389 --> 00:34:15,070
Viper it's basically something that

892
00:34:15,070 --> 00:34:16,929
we've developed similar vein but we use

893
00:34:16,929 --> 00:34:19,000
it for millions upon millions of samples

894
00:34:19,000 --> 00:34:21,668
distributed large-scale stuff so you can

895
00:34:21,668 --> 00:34:24,250
access it from homes processing github

896
00:34:24,250 --> 00:34:26,500
do and I'll put that out probably

897
00:34:26,500 --> 00:34:28,120
sometime this weekend depending how good

898
00:34:28,120 --> 00:34:32,139
my internet connection is so the

899
00:34:32,139 --> 00:34:33,460
takeaways for this talk and what I

900
00:34:33,460 --> 00:34:35,020
really want to leave you guys with is

901
00:34:35,020 --> 00:34:37,000
the rich header isn't really really

902
00:34:37,000 --> 00:34:39,310
valuable for triage it allows you to do

903
00:34:39,310 --> 00:34:41,918
quick detection I can identify it packed

904
00:34:41,918 --> 00:34:43,840
and post modified binaries pretty much

905
00:34:43,840 --> 00:34:45,730
like instant real time and it's really

906
00:34:45,730 --> 00:34:48,340
cheap the nexus allows me to do

907
00:34:48,340 --> 00:34:50,139
similarity matching so if you give me

908
00:34:50,139 --> 00:34:51,969
one sample I can look across everything

909
00:34:51,969 --> 00:34:53,560
from a historic perspective and

910
00:34:53,560 --> 00:34:55,418
near-real-time and it's very efficient I

911
00:34:55,418 --> 00:34:58,270
can use my laptop to do it and the third

912
00:34:58,270 --> 00:35:00,400
is the build environment fingerprinting

913
00:35:00,400 --> 00:35:02,080
and this is pretty interesting aspect

914
00:35:02,080 --> 00:35:03,970
I'm not going to say it's going to tell

915
00:35:03,970 --> 00:35:06,010
you where like who the different actors

916
00:35:06,010 --> 00:35:07,840
are but it's giving you a data point

917
00:35:07,840 --> 00:35:09,310
that allows you to start putting out

918
00:35:09,310 --> 00:35:10,930
analysis together and start figuring

919
00:35:10,930 --> 00:35:11,730
that out

920
00:35:11,730 --> 00:35:14,620
additionally we like happy Julien and to

921
00:35:14,620 --> 00:35:17,170
get happy Julien if you guys have C to

922
00:35:17,170 --> 00:35:20,950
DLL CVTs link THC or Emily accedes

923
00:35:20,950 --> 00:35:22,960
please send them to Julian so we can

924
00:35:22,960 --> 00:35:24,370
start to map everything out because

925
00:35:24,370 --> 00:35:27,060
everyone wants a happy

926
00:35:27,060 --> 00:35:30,220
and the next is this was quite an

927
00:35:30,220 --> 00:35:31,869
endeavor to kind of put everything

928
00:35:31,869 --> 00:35:33,400
together so we wanted to give some

929
00:35:33,400 --> 00:35:35,260
shafts out to say thank you to the guys

930
00:35:35,260 --> 00:35:37,780
that assisted and I'm George Webster and

931
00:35:37,780 --> 00:35:39,730
this is Julian Kirsch and we're at the

932
00:35:39,730 --> 00:35:41,680
Technical University of Munich if you

933
00:35:41,680 --> 00:35:43,119
guys have any questions I think we have

934
00:35:43,119 --> 00:35:44,680
to go to the speaker area we'd love to

935
00:35:44,680 --> 00:35:48,569
talk to you more about it thank you

