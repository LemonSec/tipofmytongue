1
00:00:00,060 --> 00:00:04,859
hello so can I introduce to you ignite

2
00:00:02,190 --> 00:00:08,309
core chicken who will be speaking about

3
00:00:04,859 --> 00:00:12,389
live patching we crypto and OpenSSL

4
00:00:08,309 --> 00:00:16,230
engines hello

5
00:00:12,389 --> 00:00:24,060
everyone can hear me back then yeah so

6
00:00:16,230 --> 00:00:25,740
so what about now yeah okay so today we

7
00:00:24,060 --> 00:00:27,959
are going to talk about life patching we

8
00:00:25,740 --> 00:00:30,240
crypt always open and sell engines just

9
00:00:27,960 --> 00:00:32,790
a disclaimer most of the talk here I

10
00:00:30,240 --> 00:00:35,190
kinda what offensive so like how to

11
00:00:32,790 --> 00:00:37,769
crack things this one is not this is

12
00:00:35,190 --> 00:00:41,430
actually how to fix things so be

13
00:00:37,770 --> 00:00:44,129
prepared first a bit about myself my

14
00:00:41,430 --> 00:00:46,200
name is ignant I work for cloud 4 I'd

15
00:00:44,129 --> 00:00:49,379
currently do performance and security I

16
00:00:46,200 --> 00:00:52,469
do a lot of low-level things with Linux

17
00:00:49,379 --> 00:00:56,010
kernels boot loaders and I enjoy crypto

18
00:00:52,469 --> 00:00:59,760
so hence my talk here ok

19
00:00:56,010 --> 00:01:02,670
what does it mean we crypto ok sorry

20
00:00:59,760 --> 00:01:04,589
yeah what does it mean with crypto how

21
00:01:02,670 --> 00:01:07,159
do you define with crypto versus strong

22
00:01:04,589 --> 00:01:12,030
crypto it's actually very easy like we

23
00:01:07,159 --> 00:01:14,729
crypto is it creates a visible defense

24
00:01:12,030 --> 00:01:17,250
for you but actually the attacker puts

25
00:01:14,729 --> 00:01:20,670
enough effort they can actually blow

26
00:01:17,250 --> 00:01:23,640
away your defenses right vs. strong

27
00:01:20,670 --> 00:01:27,689
crypto is strong so no matter how hard

28
00:01:23,640 --> 00:01:30,600
the attacker tries they cannot break

29
00:01:27,689 --> 00:01:32,429
into your system so the question is like

30
00:01:30,600 --> 00:01:36,179
why people use weak Krypton in the first

31
00:01:32,430 --> 00:01:38,310
place right well most of the time I've

32
00:01:36,180 --> 00:01:41,369
seen is like Java developers just don't

33
00:01:38,310 --> 00:01:44,040
know what to use for example if you look

34
00:01:41,369 --> 00:01:48,000
with all the OpenSSL algorithms out

35
00:01:44,040 --> 00:01:50,670
there you just most new developers they

36
00:01:48,000 --> 00:01:54,060
just get confused and if you do snow

37
00:01:50,670 --> 00:01:55,680
that is is better than death then on top

38
00:01:54,060 --> 00:01:58,619
of that you have to select the cipher

39
00:01:55,680 --> 00:02:03,869
mode the initial vector your curve for

40
00:01:58,619 --> 00:02:06,479
sec and so on so and so on there is also

41
00:02:03,869 --> 00:02:10,679
like government regulations you remember

42
00:02:06,479 --> 00:02:12,180
the famous US export crypto in 90s where

43
00:02:10,679 --> 00:02:14,609
they allow to export

44
00:02:12,180 --> 00:02:17,189
Goethe's 40-bit keys which were

45
00:02:14,609 --> 00:02:21,510
crackable even then and definitely now

46
00:02:17,189 --> 00:02:25,469
and finally the strong crypto becomes

47
00:02:21,510 --> 00:02:28,200
weak over time actually so so the some

48
00:02:25,469 --> 00:02:30,780
advice you can take away from here is if

49
00:02:28,200 --> 00:02:32,939
you don't want to use first of all like

50
00:02:30,780 --> 00:02:35,909
never roll your own crypto never never

51
00:02:32,939 --> 00:02:39,409
do that don't copy paste from the

52
00:02:35,909 --> 00:02:42,179
internet Stack Overflow as well so

53
00:02:39,409 --> 00:02:44,819
because they might didn't know what to

54
00:02:42,180 --> 00:02:46,799
use as well and also crypto is very

55
00:02:44,819 --> 00:02:49,138
sensitive to the environment so they

56
00:02:46,799 --> 00:02:50,909
might have had a different use case so

57
00:02:49,139 --> 00:02:54,269
when you copy paste their code it will

58
00:02:50,909 --> 00:02:57,060
be weak in your scenario typical example

59
00:02:54,269 --> 00:03:01,189
any IOT device uses strong is with

60
00:02:57,060 --> 00:03:01,189
hard-coded T in the firmware image right

61
00:03:01,669 --> 00:03:07,439
also prefer to use high level

62
00:03:04,829 --> 00:03:09,450
cryptographic libraries don't focus on

63
00:03:07,439 --> 00:03:11,790
algorithms or initial vectors there are

64
00:03:09,450 --> 00:03:15,119
many out other libraries out there which

65
00:03:11,790 --> 00:03:16,978
give you like use case based

66
00:03:15,120 --> 00:03:18,780
cryptography like I want to encrypt a

67
00:03:16,979 --> 00:03:19,199
file I want to send a data over the

68
00:03:18,780 --> 00:03:21,150
network

69
00:03:19,199 --> 00:03:24,000
and they will likely choose all the

70
00:03:21,150 --> 00:03:25,889
algorithms and parameters for you you'd

71
00:03:24,000 --> 00:03:31,199
be safe defaults and they're maintained

72
00:03:25,889 --> 00:03:33,359
and and reviewed so why does strong

73
00:03:31,199 --> 00:03:36,030
crypto might become weak over time there

74
00:03:33,359 --> 00:03:37,889
is like mathematicians just get smarter

75
00:03:36,030 --> 00:03:40,409
right strong crypto is based on the fact

76
00:03:37,889 --> 00:03:43,530
that there is no efficient algorithms to

77
00:03:40,409 --> 00:03:48,388
break the dam but sometimes people come

78
00:03:43,530 --> 00:03:50,669
up with ideas and there succeed and also

79
00:03:48,389 --> 00:03:52,889
the rapid the technology advances as

80
00:03:50,669 --> 00:03:54,569
well so we are all scared about quantum

81
00:03:52,889 --> 00:03:56,609
computers which will probably be like

82
00:03:54,569 --> 00:03:59,069
everything we know today about crypto

83
00:03:56,609 --> 00:04:01,680
well most of the thing maybe even

84
00:03:59,069 --> 00:04:07,409
cryptocurrency I don't know so don't try

85
00:04:01,680 --> 00:04:10,859
it too often okay so like the nutshell

86
00:04:07,409 --> 00:04:13,429
is you can't just design a system with

87
00:04:10,859 --> 00:04:15,900
strong crypto and use it forever

88
00:04:13,430 --> 00:04:17,310
over time because crypto becomes weak

89
00:04:15,900 --> 00:04:19,139
over time you need to do crypto

90
00:04:17,310 --> 00:04:22,000
maintenance you have to throw away the

91
00:04:19,139 --> 00:04:26,590
old bad stuff and

92
00:04:22,000 --> 00:04:28,630
like put the new stuff and but it's so

93
00:04:26,590 --> 00:04:30,940
good when you maintain your own software

94
00:04:28,630 --> 00:04:33,400
but most of us have to deal with some

95
00:04:30,940 --> 00:04:36,100
kind of software vendors and sometimes

96
00:04:33,400 --> 00:04:38,380
when you see oh this probably this

97
00:04:36,100 --> 00:04:40,750
software is using obsolete cryptography

98
00:04:38,380 --> 00:04:43,300
or any other feature and you ask vendor

99
00:04:40,750 --> 00:04:45,820
to implement it usually hit with bump so

100
00:04:43,300 --> 00:04:48,760
you have the vendor slowness so they say

101
00:04:45,820 --> 00:04:51,490
yeah we'll replace the bad crypto in one

102
00:04:48,760 --> 00:04:53,560
year so and it's not good enough and you

103
00:04:51,490 --> 00:04:55,000
have also the abandoned software the

104
00:04:53,560 --> 00:04:57,540
tons of software out there where

105
00:04:55,000 --> 00:05:00,400
companies were acquired resold and like

106
00:04:57,540 --> 00:05:02,820
they just stopped supporting that but

107
00:05:00,400 --> 00:05:05,560
you still need it for some reason right

108
00:05:02,820 --> 00:05:07,360
most proprietary software you have no

109
00:05:05,560 --> 00:05:10,420
source code available to actually modify

110
00:05:07,360 --> 00:05:13,090
it there is also additional cost and

111
00:05:10,420 --> 00:05:16,000
vendor may try to charge your extra to

112
00:05:13,090 --> 00:05:18,729
get a stronger crypto so sometimes they

113
00:05:16,000 --> 00:05:22,150
try to sell it as a feature like like

114
00:05:18,730 --> 00:05:23,919
SSL companies sell super secure

115
00:05:22,150 --> 00:05:29,679
certificates which are more expensive

116
00:05:23,919 --> 00:05:33,099
than the regular ones right so sometimes

117
00:05:29,680 --> 00:05:36,190
you just can't easily patch your

118
00:05:33,100 --> 00:05:37,690
software but there is still hope so in

119
00:05:36,190 --> 00:05:40,270
this talk we'll just go through a

120
00:05:37,690 --> 00:05:43,900
hypothetical case study that we're

121
00:05:40,270 --> 00:05:46,690
fixing a bad crypto in and open SSL

122
00:05:43,900 --> 00:05:49,900
based proprietary software so imagine

123
00:05:46,690 --> 00:05:51,550
this scenario right you you bought some

124
00:05:49,900 --> 00:05:54,159
kind or your company bought some kind of

125
00:05:51,550 --> 00:05:56,229
proprietary storage solution it may be a

126
00:05:54,160 --> 00:06:00,460
relational database or or an object

127
00:05:56,229 --> 00:06:03,729
storage and the key part is here that it

128
00:06:00,460 --> 00:06:08,890
creates it index the stored objects wire

129
00:06:03,729 --> 00:06:11,320
their hash values and it uses open SSL

130
00:06:08,890 --> 00:06:13,870
as a cryptographic back-end why are we

131
00:06:11,320 --> 00:06:15,790
focusing so much in open SSL because

132
00:06:13,870 --> 00:06:18,490
it's kind of de facto crypto standards

133
00:06:15,790 --> 00:06:21,250
nowadays Aurel because of its permissive

134
00:06:18,490 --> 00:06:26,340
license and popularity almost of like

135
00:06:21,250 --> 00:06:29,380
both open source and proprietary tools

136
00:06:26,340 --> 00:06:32,549
90% of them are based on open SSL in one

137
00:06:29,380 --> 00:06:37,440
way or another even IOT Android and

138
00:06:32,550 --> 00:06:40,620
everything yeah so you have all this and

139
00:06:37,440 --> 00:06:45,480
at some point and you invite security

140
00:06:40,620 --> 00:06:49,830
audit and you like ah the auditor like

141
00:06:45,480 --> 00:06:54,360
ah that what's happened right this tool

142
00:06:49,830 --> 00:06:58,560
is using sha-1 and so what sha-1 there

143
00:06:54,360 --> 00:07:02,670
does anyone know what this is or doesn't

144
00:06:58,560 --> 00:07:05,070
know what this so sha-1 is broken now

145
00:07:02,670 --> 00:07:07,410
Juwan which was the founding building

146
00:07:05,070 --> 00:07:09,450
block on the internet on like roughly

147
00:07:07,410 --> 00:07:12,510
two years ago is completely broken and

148
00:07:09,450 --> 00:07:14,400
we shouldn't use that so yeah you go to

149
00:07:12,510 --> 00:07:17,280
your vendor which provided you this from

150
00:07:14,400 --> 00:07:18,239
database and well they usually say like

151
00:07:17,280 --> 00:07:20,669
it's fine

152
00:07:18,240 --> 00:07:23,100
so like that attack described it in that

153
00:07:20,670 --> 00:07:25,410
paper does not apply to our use case so

154
00:07:23,100 --> 00:07:27,090
you can freely use it and again it will

155
00:07:25,410 --> 00:07:29,640
take it will probably replace it in the

156
00:07:27,090 --> 00:07:37,950
future in two or five years relief cycle

157
00:07:29,640 --> 00:07:42,229
Sox who had that in real life okay so

158
00:07:37,950 --> 00:07:42,229
and in then you have to fix it yourself

159
00:07:43,910 --> 00:07:50,340
to do that let's step take a step back

160
00:07:47,520 --> 00:07:54,419
and like before diving in in immediately

161
00:07:50,340 --> 00:07:56,039
patching the assembly code we can try it

162
00:07:54,420 --> 00:07:59,820
on them can we do something better here

163
00:07:56,040 --> 00:08:01,560
right so and let's reintroduce the

164
00:07:59,820 --> 00:08:03,930
concept of shared libraries in the

165
00:08:01,560 --> 00:08:06,060
operating system so imagine you have a

166
00:08:03,930 --> 00:08:09,960
process let's say it's some kind of a

167
00:08:06,060 --> 00:08:13,080
privacy VPN client and you have another

168
00:08:09,960 --> 00:08:15,719
process which is a database by the way

169
00:08:13,080 --> 00:08:18,050
the mascots here are they appear

170
00:08:15,720 --> 00:08:21,180
accidential so they do not relate

171
00:08:18,050 --> 00:08:24,060
real-life software and they both need

172
00:08:21,180 --> 00:08:26,730
some crypto library right and there is a

173
00:08:24,060 --> 00:08:29,640
library which is usually open SSL and it

174
00:08:26,730 --> 00:08:31,680
says hey I have a library so and this

175
00:08:29,640 --> 00:08:33,780
library shared between this process so

176
00:08:31,680 --> 00:08:36,480
the nice thing about shared libraries

177
00:08:33,780 --> 00:08:38,549
they are dynamically rink at runtime so

178
00:08:36,480 --> 00:08:41,190
they're not actually their code is not

179
00:08:38,549 --> 00:08:43,859
actual actually part of your code

180
00:08:41,190 --> 00:08:46,000
they're like several entities and the

181
00:08:43,860 --> 00:08:49,779
operating system bundles there

182
00:08:46,000 --> 00:08:51,579
into your code at runtime and the code

183
00:08:49,779 --> 00:08:52,629
is shared between the program so we have

184
00:08:51,579 --> 00:08:55,660
only one library

185
00:08:52,629 --> 00:08:58,149
servicing many application nothing about

186
00:08:55,660 --> 00:09:00,519
it the code is loaded only once in

187
00:08:58,149 --> 00:09:02,649
memory so even though you have thousand

188
00:09:00,519 --> 00:09:06,910
processes using OpenSSL you have only

189
00:09:02,649 --> 00:09:09,120
one copy of OpenSSL in your ram and it's

190
00:09:06,910 --> 00:09:11,350
more manageable you can update your

191
00:09:09,120 --> 00:09:15,339
libraries independently because they're

192
00:09:11,350 --> 00:09:18,250
kind of separate entity so although like

193
00:09:15,339 --> 00:09:20,529
our proprietor our vendor tool is

194
00:09:18,250 --> 00:09:23,740
proprietary let's like try to speculate

195
00:09:20,529 --> 00:09:26,350
how could a vendor implement this tool

196
00:09:23,740 --> 00:09:28,569
and like to simplify it imagine there we

197
00:09:26,350 --> 00:09:32,470
have a custom tool from the vendor which

198
00:09:28,569 --> 00:09:34,959
calculates a sha-1 of a file and this is

199
00:09:32,470 --> 00:09:37,420
like a simple main function I will not

200
00:09:34,959 --> 00:09:39,399
repeat it again but the gist here is

201
00:09:37,420 --> 00:09:42,219
this they call this their own

202
00:09:39,399 --> 00:09:44,230
implementation of hash files so they get

203
00:09:42,220 --> 00:09:47,019
a file descriptor and partial positive

204
00:09:44,230 --> 00:09:50,680
function and the first iteration of the

205
00:09:47,019 --> 00:09:53,829
hash their hashing implementation might

206
00:09:50,680 --> 00:09:55,628
look like this so they have like they

207
00:09:53,829 --> 00:09:58,959
just read the whole file in a buffer

208
00:09:55,629 --> 00:10:01,600
which is allocated on a stack and then

209
00:09:58,959 --> 00:10:04,300
they calculate the hash of the bot for

210
00:10:01,600 --> 00:10:07,360
output the result simple right

211
00:10:04,300 --> 00:10:10,689
so we can even check if it works so we

212
00:10:07,360 --> 00:10:13,059
can take this tool send some data to it

213
00:10:10,689 --> 00:10:15,819
and get the sha-1 we can actually verify

214
00:10:13,059 --> 00:10:17,680
that it actually calculates shell 1 by

215
00:10:15,819 --> 00:10:22,360
comparing the result to a well-known

216
00:10:17,680 --> 00:10:24,250
sha-1 implementation we can also examine

217
00:10:22,360 --> 00:10:26,649
this tool we can also make sure because

218
00:10:24,250 --> 00:10:29,290
where we're trying to fix bad crypto is

219
00:10:26,649 --> 00:10:31,360
open SSL that it uses open SSL we can

220
00:10:29,290 --> 00:10:35,879
check that which libraries it requires

221
00:10:31,360 --> 00:10:40,990
and we see its link to open SSL now

222
00:10:35,879 --> 00:10:44,139
another nice aspect of shared libraries

223
00:10:40,990 --> 00:10:48,459
is called lazy binding to imagine you

224
00:10:44,139 --> 00:10:50,319
have a process and when the process

225
00:10:48,459 --> 00:10:53,109
starts it tells the operating system I

226
00:10:50,319 --> 00:10:55,360
need these two libraries so what the

227
00:10:53,110 --> 00:10:57,040
operating system does for you it finds

228
00:10:55,360 --> 00:10:58,990
these two libraries and Lourdes

229
00:10:57,040 --> 00:11:02,430
them into your process process address

230
00:10:58,990 --> 00:11:05,259
space but the process does not start

231
00:11:02,430 --> 00:11:07,180
using these libraries immediately it

232
00:11:05,259 --> 00:11:09,610
starts executing whatever it needs to do

233
00:11:07,180 --> 00:11:13,689
and at some point later it needs to

234
00:11:09,610 --> 00:11:15,579
calculate the sha-1 and it tells again

235
00:11:13,690 --> 00:11:18,970
to the operating system hey I have the

236
00:11:15,579 --> 00:11:22,239
sha-1 and then the operating system ask

237
00:11:18,970 --> 00:11:24,699
like hey who has sha-1 here and most

238
00:11:22,240 --> 00:11:26,709
likely the typical case one library has

239
00:11:24,699 --> 00:11:31,149
the sha-1 implementation and the process

240
00:11:26,709 --> 00:11:33,279
can use that code but the key point here

241
00:11:31,149 --> 00:11:35,740
to understand that the list of the

242
00:11:33,279 --> 00:11:37,480
libraries the process requires is kind

243
00:11:35,740 --> 00:11:40,959
of independent of the list of the

244
00:11:37,480 --> 00:11:44,410
functions the the process requires they

245
00:11:40,959 --> 00:11:46,329
come from the same place and usually one

246
00:11:44,410 --> 00:11:50,160
function is usually implemented by the

247
00:11:46,329 --> 00:11:53,019
wine library but that can be changed and

248
00:11:50,160 --> 00:11:55,810
to do that one of the ways to do that is

249
00:11:53,019 --> 00:11:57,910
use the preload environment variables

250
00:11:55,810 --> 00:12:01,829
who doesn't know what a preload

251
00:11:57,910 --> 00:12:04,810
environment variable is everyone knows

252
00:12:01,829 --> 00:12:07,209
yeah so it basically tells your dynamic

253
00:12:04,810 --> 00:12:11,018
linker to load additional libraries into

254
00:12:07,209 --> 00:12:12,579
your process address space and the pre

255
00:12:11,019 --> 00:12:14,920
part comes from the fact that this

256
00:12:12,579 --> 00:12:19,779
library is loaded before all all other

257
00:12:14,920 --> 00:12:21,849
libraries the process requires and the

258
00:12:19,779 --> 00:12:24,939
usual this is a typical approach we used

259
00:12:21,850 --> 00:12:27,639
to override modify tap or hook like some

260
00:12:24,940 --> 00:12:29,800
exported functions from the library so

261
00:12:27,639 --> 00:12:34,209
the way how here is some documentation

262
00:12:29,800 --> 00:12:35,979
about preload which is all so the way

263
00:12:34,209 --> 00:12:38,760
how it works so basically even before

264
00:12:35,980 --> 00:12:41,170
every if you have your preload

265
00:12:38,760 --> 00:12:43,449
environment one will define even before

266
00:12:41,170 --> 00:12:46,060
anything happens your operating system

267
00:12:43,449 --> 00:12:48,849
Lords your pre loaded library into the

268
00:12:46,060 --> 00:12:52,750
process address space and then the usual

269
00:12:48,850 --> 00:12:55,300
thing happens where you load the normal

270
00:12:52,750 --> 00:12:58,779
libraries but the interesting part

271
00:12:55,300 --> 00:13:02,050
happens when the process now requests an

272
00:12:58,779 --> 00:13:04,569
a function the operating system ask who

273
00:13:02,050 --> 00:13:06,829
had the function and now two libraries

274
00:13:04,569 --> 00:13:09,439
might have this function implement

275
00:13:06,830 --> 00:13:11,660
and the process we'll use the first one

276
00:13:09,440 --> 00:13:14,240
which is being loaded basically our

277
00:13:11,660 --> 00:13:16,819
preloaded variant because it was loaded

278
00:13:14,240 --> 00:13:20,750
before everything else so this way we

279
00:13:16,820 --> 00:13:23,420
can basically hook functions into the

280
00:13:20,750 --> 00:13:25,730
process to understand which file so

281
00:13:23,420 --> 00:13:27,979
we're focusing now how to fix bad crypto

282
00:13:25,730 --> 00:13:30,200
so to understand which functions we need

283
00:13:27,980 --> 00:13:33,529
to hook we can analyze our proprietary

284
00:13:30,200 --> 00:13:35,450
supposedly proprietary tool and see that

285
00:13:33,529 --> 00:13:40,040
it requires like two functions from the

286
00:13:35,450 --> 00:13:43,190
OpenSSL to do its job so we can write

287
00:13:40,040 --> 00:13:45,680
our hooking library in a way which

288
00:13:43,190 --> 00:13:48,740
basically hugs these functions and

289
00:13:45,680 --> 00:13:53,000
translates sha-1 calculations to shout

290
00:13:48,740 --> 00:13:55,310
256 calculations to make more secure so

291
00:13:53,000 --> 00:13:57,860
what we do but we will not reemployment

292
00:13:55,310 --> 00:14:00,140
the hash ourselves what we want is

293
00:13:57,860 --> 00:14:02,450
basically we want to reuse the sha-256

294
00:14:00,140 --> 00:14:05,390
implementation and open ssl so we

295
00:14:02,450 --> 00:14:07,610
probably need to resolve the addresses

296
00:14:05,390 --> 00:14:10,459
of the same function in the or like

297
00:14:07,610 --> 00:14:14,959
standard open SSL library this is where

298
00:14:10,459 --> 00:14:18,349
we do it then if somebody requested to

299
00:14:14,959 --> 00:14:20,660
calculate hash and it's a digest and

300
00:14:18,350 --> 00:14:22,670
open SSL terms which are one but

301
00:14:20,660 --> 00:14:27,020
basically replace it and then to fire we

302
00:14:22,670 --> 00:14:29,930
shout 256 we also in this case like we

303
00:14:27,020 --> 00:14:32,689
will add our own debugging output to see

304
00:14:29,930 --> 00:14:35,500
that like to observe that our hooking

305
00:14:32,690 --> 00:14:38,209
works and finally what we need to do

306
00:14:35,500 --> 00:14:42,320
because we do place in shut one with

307
00:14:38,209 --> 00:14:44,359
sha-256 sha-1 is 20 bytes sha-256 is 32

308
00:14:42,320 --> 00:14:46,730
bytes and probably the colon x

309
00:14:44,360 --> 00:14:49,610
application might not expect to get the

310
00:14:46,730 --> 00:14:52,940
32 rise back so we will actually cut the

311
00:14:49,610 --> 00:14:57,130
result of shout 256 to 20 bytes to

312
00:14:52,940 --> 00:15:03,920
comply with a potential interface right

313
00:14:57,130 --> 00:15:06,860
yeah we can compile this code and now we

314
00:15:03,920 --> 00:15:09,019
can call our proprietary tool and

315
00:15:06,860 --> 00:15:11,390
pre-loading our binary and we will see

316
00:15:09,019 --> 00:15:13,760
that we're actually replacing sha-1 we

317
00:15:11,390 --> 00:15:15,750
shout 256 you can also compare it to a

318
00:15:13,760 --> 00:15:18,319
well-known implementation in the Newell

319
00:15:15,750 --> 00:15:21,630
now that were actually compiled

320
00:15:18,320 --> 00:15:25,800
calculating chatter 56 but we'll cut it

321
00:15:21,630 --> 00:15:29,760
to 20 bytes as expected so what we did

322
00:15:25,800 --> 00:15:31,859
here is we have the proprietary tool we

323
00:15:29,760 --> 00:15:34,410
have open SSL the propriety tool use

324
00:15:31,860 --> 00:15:37,790
that function we broke this this

325
00:15:34,410 --> 00:15:40,829
connection and we rerouted it to a draw

326
00:15:37,790 --> 00:15:43,349
through our preloaded library which does

327
00:15:40,830 --> 00:15:46,140
two things it replaces the identifier

328
00:15:43,350 --> 00:15:48,750
for open SSL identifiers from sha-1 to

329
00:15:46,140 --> 00:15:54,030
sha-256 and it cuts the results of 20

330
00:15:48,750 --> 00:15:56,040
bytes all good but if you were attentive

331
00:15:54,030 --> 00:15:58,230
enough or you sitting in the front row

332
00:15:56,040 --> 00:16:02,099
because probably back rows do not see

333
00:15:58,230 --> 00:16:03,780
this right do you see the source code

334
00:16:02,100 --> 00:16:06,180
good yeah

335
00:16:03,780 --> 00:16:08,069
there will be linked in the end with all

336
00:16:06,180 --> 00:16:10,620
the source available so you can reassign

337
00:16:08,070 --> 00:16:12,870
them later so basically if you were

338
00:16:10,620 --> 00:16:14,850
tented enough you notice that the

339
00:16:12,870 --> 00:16:17,160
proprietary tools had a bug because it's

340
00:16:14,850 --> 00:16:19,050
allocated a static buffer a fork a

341
00:16:17,160 --> 00:16:22,290
buffer on the stack it cannot process

342
00:16:19,050 --> 00:16:24,540
files larger than 44 kilobytes so

343
00:16:22,290 --> 00:16:27,660
probably vendor might have noticed that

344
00:16:24,540 --> 00:16:30,750
and they need to fix that bug right so

345
00:16:27,660 --> 00:16:33,569
they without changing the interface they

346
00:16:30,750 --> 00:16:36,060
replaced their implementation not to use

347
00:16:33,570 --> 00:16:38,730
the static buffer but to basically use

348
00:16:36,060 --> 00:16:41,219
the iterate iterative hash calculation

349
00:16:38,730 --> 00:16:44,330
and open SSL API allows you to do that

350
00:16:41,220 --> 00:16:47,839
so you create like an open SSL context

351
00:16:44,330 --> 00:16:50,310
you read the file in chunks until you

352
00:16:47,839 --> 00:16:52,589
reach the end of the file and you send

353
00:16:50,310 --> 00:16:55,290
these chunks to the open SSL context and

354
00:16:52,589 --> 00:16:59,400
it will calculate the hash for you and

355
00:16:55,290 --> 00:17:02,219
then your output the result but for us

356
00:16:59,400 --> 00:17:04,589
it's a problem so if we try to run this

357
00:17:02,220 --> 00:17:07,560
new updated version with our hooking

358
00:17:04,589 --> 00:17:09,750
library it stops working right we still

359
00:17:07,560 --> 00:17:12,569
we don't see our debug output anymore

360
00:17:09,750 --> 00:17:15,630
and we see that it's now calculates it's

361
00:17:12,569 --> 00:17:19,139
back to calculating sha-1 if we examine

362
00:17:15,630 --> 00:17:21,329
the updated tool we see that it now uses

363
00:17:19,140 --> 00:17:23,970
different functions from open SSL than

364
00:17:21,329 --> 00:17:25,109
we are already hooked so we need to

365
00:17:23,970 --> 00:17:30,419
rewrite our hook

366
00:17:25,109 --> 00:17:32,668
so again we resolve the OpenSSL the

367
00:17:30,419 --> 00:17:36,529
addresses of the real OpenSSL functions

368
00:17:32,669 --> 00:17:37,710
we substitute the identifier of two

369
00:17:36,529 --> 00:17:40,679
sha-256

370
00:17:37,710 --> 00:17:45,659
we put our debugging output and we cut

371
00:17:40,679 --> 00:17:49,590
the result of 20 to 20 bytes compile it

372
00:17:45,659 --> 00:17:52,460
again now if we check it the new our new

373
00:17:49,590 --> 00:17:57,178
hooking library works with the updated

374
00:17:52,460 --> 00:17:58,710
with the updated vendor application and

375
00:17:57,179 --> 00:18:01,669
we can compare it to the well-known

376
00:17:58,710 --> 00:18:05,450
results yeah everything matches not good

377
00:18:01,669 --> 00:18:08,730
but the vendor decides to update again

378
00:18:05,450 --> 00:18:11,610
some probably you always hire some smart

379
00:18:08,730 --> 00:18:13,679
developers and the some smart developer

380
00:18:11,610 --> 00:18:16,080
notice that it's like it's kind of

381
00:18:13,679 --> 00:18:18,360
awkward to read from a file from OpenSSL

382
00:18:16,080 --> 00:18:20,789
than to send it to open ssl contacts and

383
00:18:18,360 --> 00:18:23,879
like open ssl itself has a nice

384
00:18:20,789 --> 00:18:26,158
abstraction layer called bio where can

385
00:18:23,880 --> 00:18:28,710
you immediately create like a bio stack

386
00:18:26,159 --> 00:18:33,000
and by reading the file you immediately

387
00:18:28,710 --> 00:18:35,610
calculates it hash so it's basically so

388
00:18:33,000 --> 00:18:37,769
you create your bio stack now you just

389
00:18:35,610 --> 00:18:40,439
read from that stack and it

390
00:18:37,769 --> 00:18:42,330
automatically calculates the hash for

391
00:18:40,440 --> 00:18:48,649
you you just get the result in the end

392
00:18:42,330 --> 00:18:51,658
and print it and our fix is broken again

393
00:18:48,649 --> 00:18:53,760
because if we analyze it now it use

394
00:18:51,659 --> 00:18:56,639
completely different set of functions

395
00:18:53,760 --> 00:19:00,029
right so we have to write the fix again

396
00:18:56,639 --> 00:19:03,689
we need to resolve the new functions we

397
00:19:00,029 --> 00:19:07,529
need to replace the identifiers put our

398
00:19:03,690 --> 00:19:13,490
debugging output and basically cut the

399
00:19:07,529 --> 00:19:15,840
result compiling checking works again

400
00:19:13,490 --> 00:19:19,919
compared to well-known implementation

401
00:19:15,840 --> 00:19:23,240
also works right but this is just a race

402
00:19:19,919 --> 00:19:27,690
right with ever if you go this approach

403
00:19:23,240 --> 00:19:30,360
with every change of the implementation

404
00:19:27,690 --> 00:19:32,010
of the proprietary vendor library you

405
00:19:30,360 --> 00:19:33,629
have to rewrite your hooks you might

406
00:19:32,010 --> 00:19:36,220
have to rewrite your hooks or it somehow

407
00:19:33,630 --> 00:19:38,919
breaks your hooks so

408
00:19:36,220 --> 00:19:40,629
the problem is the LD preload approach

409
00:19:38,919 --> 00:19:43,090
is very tightly bound to the

410
00:19:40,629 --> 00:19:48,580
implementation not to the interface of

411
00:19:43,090 --> 00:19:50,379
the proprietary software and generally

412
00:19:48,580 --> 00:19:53,710
it's the case but for open SSL

413
00:19:50,379 --> 00:19:56,649
specifically we can try to fix that so

414
00:19:53,710 --> 00:20:00,370
like introducing or reintroducing open

415
00:19:56,649 --> 00:20:09,158
SSL engines anyone ever worked with open

416
00:20:00,370 --> 00:20:11,229
SSL engines here so actual open SSL has

417
00:20:09,159 --> 00:20:13,990
extensible architecture called engines

418
00:20:11,230 --> 00:20:17,289
these are extensions modules to open SSL

419
00:20:13,990 --> 00:20:21,340
and they basically can be used to add

420
00:20:17,289 --> 00:20:23,440
replace cryptographic algorithms the you

421
00:20:21,340 --> 00:20:25,840
mostly work with them if you ever pair

422
00:20:23,440 --> 00:20:28,980
open SSL with some kind of hardware

423
00:20:25,840 --> 00:20:31,269
device like an HSM or or a crypto key

424
00:20:28,980 --> 00:20:33,549
usually vendors provide an engine

425
00:20:31,269 --> 00:20:35,679
compatible library that solves it for

426
00:20:33,549 --> 00:20:38,350
example you can hook your HSM to nginx

427
00:20:35,679 --> 00:20:42,610
and use it to protect your server TLS

428
00:20:38,350 --> 00:20:46,418
private key there is a nice tutorial how

429
00:20:42,610 --> 00:20:48,879
how to build your own engine so instead

430
00:20:46,419 --> 00:20:52,509
of actually hooking the calls between

431
00:20:48,879 --> 00:20:54,610
the proprietor application and open SSL

432
00:20:52,509 --> 00:20:57,519
we will implement a simple open SSL

433
00:20:54,610 --> 00:21:00,758
engines called sha-1 to sha-256 which

434
00:20:57,519 --> 00:21:03,399
will implement in a hash engine is quite

435
00:21:00,759 --> 00:21:06,610
easy you just implement three functions

436
00:21:03,399 --> 00:21:09,870
in each update and final and and our

437
00:21:06,610 --> 00:21:12,758
implementation will just call back to

438
00:21:09,870 --> 00:21:15,489
standard chapter 56 implementation of

439
00:21:12,759 --> 00:21:17,889
open SSL but it will declare itself as a

440
00:21:15,490 --> 00:21:23,740
sha-1 and as another sha-1

441
00:21:17,889 --> 00:21:28,570
implementation yeah so we basically

442
00:21:23,740 --> 00:21:30,220
implement in each update and final we

443
00:21:28,570 --> 00:21:32,980
add our debugging output for

444
00:21:30,220 --> 00:21:36,190
observability and we cut the result to

445
00:21:32,980 --> 00:21:39,909
20 bytes let's check if it works so you

446
00:21:36,190 --> 00:21:42,159
can compile this engine you can check it

447
00:21:39,909 --> 00:21:45,220
with the standard open SSL tall so here

448
00:21:42,159 --> 00:21:48,620
we're calculating the sha-1 the standard

449
00:21:45,220 --> 00:21:52,550
sha-1 was open SSL we get the real Shawa

450
00:21:48,620 --> 00:21:54,620
but now we can say to OpenSSL come

451
00:21:52,550 --> 00:21:56,899
online until hey can you use our engine

452
00:21:54,620 --> 00:21:59,840
for calculation and now we see that

453
00:21:56,900 --> 00:22:04,970
we're actually replacing Juwan without

454
00:21:59,840 --> 00:22:07,040
256 and calculating sha-256 however it

455
00:22:04,970 --> 00:22:09,430
still doesn't work with our custom

456
00:22:07,040 --> 00:22:11,899
proprietary tool because if you do the

457
00:22:09,430 --> 00:22:14,480
typical pretty low you provide your

458
00:22:11,900 --> 00:22:17,780
engine you won't get anything it will

459
00:22:14,480 --> 00:22:22,030
still calculate shell 1 the problem is

460
00:22:17,780 --> 00:22:22,030
here with this approach is because

461
00:22:22,179 --> 00:22:28,760
OpenSSL engines are in just an API and

462
00:22:25,550 --> 00:22:31,730
to utilize it calling application has to

463
00:22:28,760 --> 00:22:34,429
have to be aware of these API so some

464
00:22:31,730 --> 00:22:36,970
popular applications are worse we just

465
00:22:34,429 --> 00:22:40,640
saw the open SSL command-line utility

466
00:22:36,970 --> 00:22:43,610
the Open VPN you can set engines with

467
00:22:40,640 --> 00:22:45,740
nginx you can set open SSL engine but in

468
00:22:43,610 --> 00:22:47,840
general cases like most applications

469
00:22:45,740 --> 00:22:50,679
perceive as open SSL the crypto

470
00:22:47,840 --> 00:22:53,689
libraries they never care about

471
00:22:50,679 --> 00:22:55,580
replacing like implementations of crypto

472
00:22:53,690 --> 00:22:59,410
in runtime so they don't have any code

473
00:22:55,580 --> 00:23:02,809
to actually utilize open SSL engines

474
00:22:59,410 --> 00:23:05,360
this where we can use another

475
00:23:02,809 --> 00:23:09,678
interesting feature when we compile our

476
00:23:05,360 --> 00:23:12,020
code GCC a constructor attribute you can

477
00:23:09,679 --> 00:23:15,440
basically mark any function in your code

478
00:23:12,020 --> 00:23:17,179
as an init routine and when you link

479
00:23:15,440 --> 00:23:19,640
your code the linker will put this

480
00:23:17,179 --> 00:23:24,790
function into a special constructor

481
00:23:19,640 --> 00:23:28,429
released in the final binary and when

482
00:23:24,790 --> 00:23:31,970
this if it's an executive when the

483
00:23:28,429 --> 00:23:34,150
process starts or if it's a library when

484
00:23:31,970 --> 00:23:36,050
the library is being loaded into memory

485
00:23:34,150 --> 00:23:38,450
basically this code is being

486
00:23:36,050 --> 00:23:43,970
automatically executed by the operating

487
00:23:38,450 --> 00:23:46,580
system this is some documentation about

488
00:23:43,970 --> 00:23:49,580
the construction so we can add another

489
00:23:46,580 --> 00:23:53,980
function to our engine library called

490
00:23:49,580 --> 00:23:58,040
engine preload or I call it outlawed

491
00:23:53,980 --> 00:24:01,850
here you just add instructions to open

492
00:23:58,040 --> 00:24:04,310
SSL so whatever whatever process is

493
00:24:01,850 --> 00:24:07,820
running this code should basically use

494
00:24:04,310 --> 00:24:14,030
the implementation of sha-1 as a default

495
00:24:07,820 --> 00:24:15,950
for all calls to open SSL yeah and the

496
00:24:14,030 --> 00:24:18,200
key part here you just mark your

497
00:24:15,950 --> 00:24:20,870
function with the GCC constructor

498
00:24:18,200 --> 00:24:23,320
attribute it's actually not GCC specific

499
00:24:20,870 --> 00:24:27,199
other compilers have either the same

500
00:24:23,320 --> 00:24:28,580
attribute or vary attribute with similar

501
00:24:27,200 --> 00:24:31,690
functionality so it's quite

502
00:24:28,580 --> 00:24:35,540
cross-platform and that cross compiler

503
00:24:31,690 --> 00:24:37,250
thing yeah

504
00:24:35,540 --> 00:24:40,100
I've implemented this function in a

505
00:24:37,250 --> 00:24:42,590
separate C file so now I recompile my

506
00:24:40,100 --> 00:24:46,879
engine library with that function and

507
00:24:42,590 --> 00:24:49,580
now when I pre lord the code my function

508
00:24:46,880 --> 00:24:51,920
gets executed and it reconfigures they

509
00:24:49,580 --> 00:24:54,740
are underlined open SSL to use my engine

510
00:24:51,920 --> 00:24:57,740
as a sha-1 and even my proprietary tool

511
00:24:54,740 --> 00:25:01,280
which is not engine aware can benefit

512
00:24:57,740 --> 00:25:03,770
from this and it it works me and now

513
00:25:01,280 --> 00:25:06,220
because we're kind of decoupled hooking

514
00:25:03,770 --> 00:25:09,860
from the implementation we don't care

515
00:25:06,220 --> 00:25:13,070
how the our propriety to which API is

516
00:25:09,860 --> 00:25:15,649
are used from open SSL we can make sure

517
00:25:13,070 --> 00:25:19,220
that the same engine works for every

518
00:25:15,650 --> 00:25:21,740
version of of our proprietary tool so we

519
00:25:19,220 --> 00:25:25,400
kind of like we did it once and in the

520
00:25:21,740 --> 00:25:27,260
end we kind of say more or less safe

521
00:25:25,400 --> 00:25:28,760
from the potential update from the

522
00:25:27,260 --> 00:25:37,419
vendor which will break our hooking

523
00:25:28,760 --> 00:25:40,640
library but there is more probably it's

524
00:25:37,419 --> 00:25:43,780
very inconvenient not to forget to

525
00:25:40,640 --> 00:25:46,790
define the LD preload environment

526
00:25:43,780 --> 00:25:50,510
library and if you somehow miss it your

527
00:25:46,790 --> 00:25:52,970
risk of falling back to weak crypto and

528
00:25:50,510 --> 00:25:56,150
you probably never notice it because all

529
00:25:52,970 --> 00:25:58,790
critical looks random so actually you

530
00:25:56,150 --> 00:26:02,120
can put this approach further and get

531
00:25:58,790 --> 00:26:05,290
rid of LD preload variable so imagine

532
00:26:02,120 --> 00:26:05,290
you have our custom

533
00:26:05,320 --> 00:26:09,908
a custom hash vendor executive all all

534
00:26:07,749 --> 00:26:13,539
executive bills at least on unix-like

535
00:26:09,909 --> 00:26:16,749
system have have a special table called

536
00:26:13,539 --> 00:26:19,119
DT needed where it lists actually all

537
00:26:16,749 --> 00:26:22,570
the library it needs to successfully

538
00:26:19,119 --> 00:26:24,908
operate and we see our open SSL there so

539
00:26:22,570 --> 00:26:27,730
that's how the operating system knows

540
00:26:24,909 --> 00:26:29,470
which libraries to use to Lourdes when

541
00:26:27,730 --> 00:26:31,629
the process starts right so all we have

542
00:26:29,470 --> 00:26:33,820
to do is basically add our library to

543
00:26:31,629 --> 00:26:37,090
that list we don't need to recompile any

544
00:26:33,820 --> 00:26:40,389
code in unix there is a like a handy

545
00:26:37,090 --> 00:26:45,249
utility for that patch elf so basically

546
00:26:40,389 --> 00:26:48,729
we just add our library to that table to

547
00:26:45,249 --> 00:26:50,950
our proprietary custom vendor tool we

548
00:26:48,730 --> 00:26:54,970
can actually verify now the proprietary

549
00:26:50,950 --> 00:26:55,779
custom tool depends on our library yeah

550
00:26:54,970 --> 00:26:58,450
here it is

551
00:26:55,779 --> 00:27:00,999
and if we just run it without defining

552
00:26:58,450 --> 00:27:03,789
anything we can see we are successfully

553
00:27:00,999 --> 00:27:06,309
replacing the sha-1 implementation and

554
00:27:03,789 --> 00:27:08,789
we have to we don't have to define

555
00:27:06,309 --> 00:27:08,789
preloads

556
00:27:11,919 --> 00:27:18,860
so as a conclusion I have seen many

557
00:27:16,309 --> 00:27:20,600
times like when you need to do this sort

558
00:27:18,860 --> 00:27:23,240
of thing or even similar things to

559
00:27:20,600 --> 00:27:26,178
basically to change the behavior or some

560
00:27:23,240 --> 00:27:29,960
proprietary closed-source utility on

561
00:27:26,179 --> 00:27:31,970
your platform like people usually the

562
00:27:29,960 --> 00:27:34,460
first thing they think of we will just

563
00:27:31,970 --> 00:27:37,340
like decompile it well jet straight to

564
00:27:34,460 --> 00:27:40,520
assembly and many times you don't need

565
00:27:37,340 --> 00:27:42,590
it like your operating system provides

566
00:27:40,520 --> 00:27:44,510
you with a lot of features and tools to

567
00:27:42,590 --> 00:27:46,428
actually influence the behavior on your

568
00:27:44,510 --> 00:27:49,610
program so you're the master of your

569
00:27:46,429 --> 00:27:51,980
software so you can actually it to a

570
00:27:49,610 --> 00:27:54,049
very big extent shift and change the

571
00:27:51,980 --> 00:27:57,289
program to your needs without even

572
00:27:54,049 --> 00:27:58,700
touching the source code so these are

573
00:27:57,289 --> 00:28:01,158
all the links of all the Doc's I

574
00:27:58,700 --> 00:28:04,220
mentioned in these slides and the final

575
00:28:01,159 --> 00:28:06,740
link is basically the source code I

576
00:28:04,220 --> 00:28:08,720
presented here which is the it was

577
00:28:06,740 --> 00:28:11,330
stripped down to fit on the screen but

578
00:28:08,720 --> 00:28:13,630
this full source code is available you

579
00:28:11,330 --> 00:28:19,039
can download it play it yourself and

580
00:28:13,630 --> 00:28:26,049
replay the whole presentation that's it

581
00:28:19,039 --> 00:28:26,049
questions yes please

582
00:28:36,340 --> 00:28:42,800
so the question is although I said we

583
00:28:40,760 --> 00:28:45,560
shouldn't roll our own crypto is it safe

584
00:28:42,800 --> 00:28:48,919
to truncate the output of chateau 56 to

585
00:28:45,560 --> 00:28:51,169
20 bytes as in this example it's

586
00:28:48,920 --> 00:28:55,730
basically a necessary evil

587
00:28:51,170 --> 00:28:57,740
you can probably analyze the proprietary

588
00:28:55,730 --> 00:29:00,530
application and try to see if it

589
00:28:57,740 --> 00:29:03,920
actually can handle 32 bytes and if it

590
00:29:00,530 --> 00:29:07,520
does so you can live live it it's still

591
00:29:03,920 --> 00:29:10,580
safer to truncate shout 256 to 20 bytes

592
00:29:07,520 --> 00:29:13,460
than to yuusha wan because like in the

593
00:29:10,580 --> 00:29:15,889
perfect world which shower shut 256 is

594
00:29:13,460 --> 00:29:18,470
actually not a perfect hash function as

595
00:29:15,890 --> 00:29:20,860
well but ideally in a perfect hash

596
00:29:18,470 --> 00:29:24,680
function will produce a uniformly at

597
00:29:20,860 --> 00:29:27,590
distributed output so basically an

598
00:29:24,680 --> 00:29:31,780
attack if you use a full sized hash from

599
00:29:27,590 --> 00:29:36,310
shout 256 attacker has like 2 power 32

600
00:29:31,780 --> 00:29:38,810
has to make up to 2 power 32 guesses to

601
00:29:36,310 --> 00:29:41,120
to predict the hash right if you

602
00:29:38,810 --> 00:29:43,730
truncate it to 20 bytes and but assuming

603
00:29:41,120 --> 00:29:46,010
it's still good for hash functions are

604
00:29:43,730 --> 00:29:49,880
still uniformly distributed you

605
00:29:46,010 --> 00:29:52,790
basically reduce you increase the attack

606
00:29:49,880 --> 00:29:55,070
surface or reduce the security so the

607
00:29:52,790 --> 00:29:57,770
attacker now has to do only to point

608
00:29:55,070 --> 00:29:59,990
power twenty guesses right but it's

609
00:29:57,770 --> 00:30:02,060
still more secure than the broken sha-1

610
00:29:59,990 --> 00:30:06,550
function which has an efficient

611
00:30:02,060 --> 00:30:06,550
algorithm to calculate the pre-image

612
00:30:11,010 --> 00:30:17,460
anymore everyone wants to have lunch

613
00:30:14,560 --> 00:30:23,059
okay thank you

614
00:30:17,460 --> 00:30:23,059
[Applause]

