1
00:00:00,000 --> 00:00:05,879
hello everyone here I'm grateful to

2
00:00:03,240 --> 00:00:09,150
attend activity conference as a speaker

3
00:00:05,879 --> 00:00:12,300
for the second time in a row and this

4
00:00:09,150 --> 00:00:13,530
time I will talk about security of wet

5
00:00:12,300 --> 00:00:16,410
socket API

6
00:00:13,530 --> 00:00:19,919
I'll present you several interesting

7
00:00:16,410 --> 00:00:22,859
cases of vulnerabilities found in real

8
00:00:19,920 --> 00:00:25,500
web applications and I really hope my

9
00:00:22,859 --> 00:00:27,750
talk will give you more insight on how

10
00:00:25,500 --> 00:00:32,460
to test the security of web socket API

11
00:00:27,750 --> 00:00:34,829
is more efficiently but before we dive

12
00:00:32,460 --> 00:00:37,950
into the topic of the talk I'd like to

13
00:00:34,829 --> 00:00:41,270
shortly introduce myself my name is

14
00:00:37,950 --> 00:00:44,489
Mikhail Egorov I live in Moscow and I do

15
00:00:41,270 --> 00:00:49,020
full time bug hunting and security

16
00:00:44,489 --> 00:00:51,510
research as bug hunter I mostly work

17
00:00:49,020 --> 00:00:54,899
with back route and hakka want platforms

18
00:00:51,510 --> 00:00:57,420
I present my researches and share new

19
00:00:54,899 --> 00:01:01,020
techniques I have discovered by speaking

20
00:00:57,420 --> 00:01:02,989
on conferences you can find my past

21
00:01:01,020 --> 00:01:06,420
researches on speaker deck and

22
00:01:02,989 --> 00:01:10,439
SlideShare sites and recordings on

23
00:01:06,420 --> 00:01:14,159
YouTube as well as I've mentioned this

24
00:01:10,439 --> 00:01:16,350
activity second one for me a year ago I

25
00:01:14,159 --> 00:01:19,799
presented to talk about adobe experience

26
00:01:16,350 --> 00:01:21,600
manager hacking here you're welcome to

27
00:01:19,799 --> 00:01:27,930
follow me on the twitter my twitter

28
00:01:21,600 --> 00:01:30,899
handle is Oh angel on the slide I'd like

29
00:01:27,930 --> 00:01:33,240
to outline my favorite walks related to

30
00:01:30,900 --> 00:01:36,450
WebSocket security done previously by

31
00:01:33,240 --> 00:01:38,780
other researchers here you can find

32
00:01:36,450 --> 00:01:42,560
links to presentations and blog posts

33
00:01:38,780 --> 00:01:46,259
related to WebSocket security in general

34
00:01:42,560 --> 00:01:49,439
WebSocket fuzzing and details often are

35
00:01:46,259 --> 00:01:52,829
abilities related to implementing a

36
00:01:49,439 --> 00:01:55,079
WebSocket communications in the

37
00:01:52,829 --> 00:01:58,860
beginning of this talk I'll discuss

38
00:01:55,079 --> 00:02:02,339
known things like cross site of socket

39
00:01:58,860 --> 00:02:03,570
hijacking vulnerabilities of Education

40
00:02:02,340 --> 00:02:07,409
and I do

41
00:02:03,570 --> 00:02:10,949
gulnur abilities but from a prism of my

42
00:02:07,409 --> 00:02:14,190
bug hunters experience

43
00:02:10,949 --> 00:02:17,970
I call them known because you can find

44
00:02:14,190 --> 00:02:22,020
quite a lot of material blog posts and

45
00:02:17,970 --> 00:02:25,440
write-ups devoted to these things and in

46
00:02:22,020 --> 00:02:28,680
the second part of the talk I'll discuss

47
00:02:25,440 --> 00:02:31,910
issues that are new and I related to

48
00:02:28,680 --> 00:02:36,150
reverse proxy of WebSocket connections

49
00:02:31,910 --> 00:02:38,549
that allow requests smugglin I call them

50
00:02:36,150 --> 00:02:41,370
new because they have not been much

51
00:02:38,550 --> 00:02:45,120
discussed in the community and very

52
00:02:41,370 --> 00:02:48,320
often overlooked you might be aware that

53
00:02:45,120 --> 00:02:51,780
I've prepared two online CTF challenges

54
00:02:48,320 --> 00:02:54,750
about a WebSocket security and these

55
00:02:51,780 --> 00:03:00,270
challenges are indeed based on those new

56
00:02:54,750 --> 00:03:01,290
issues to be on the same page about

57
00:03:00,270 --> 00:03:04,890
WebSockets

58
00:03:01,290 --> 00:03:09,179
I'll make a brief overview of WebSocket

59
00:03:04,890 --> 00:03:12,720
protocol and how it's used WebSocket is

60
00:03:09,180 --> 00:03:15,570
high performance be directional protocol

61
00:03:12,720 --> 00:03:17,190
our protocol is stateful it means that

62
00:03:15,570 --> 00:03:20,480
firstly connection is established

63
00:03:17,190 --> 00:03:22,980
between client and the server and

64
00:03:20,480 --> 00:03:27,000
subsequent data is transferred back and

65
00:03:22,980 --> 00:03:30,060
forth between them in contrary for HTTP

66
00:03:27,000 --> 00:03:32,640
we establish TCP connection as an

67
00:03:30,060 --> 00:03:35,670
established TLS connection and finally

68
00:03:32,640 --> 00:03:38,458
transfer data and this happens for each

69
00:03:35,670 --> 00:03:41,760
communication between client and server

70
00:03:38,459 --> 00:03:44,519
and it's quite an effective compared to

71
00:03:41,760 --> 00:03:47,640
WebSocket where we establish TCP and TLS

72
00:03:44,519 --> 00:03:51,360
connection only once at the handshake

73
00:03:47,640 --> 00:03:54,690
part and after handshake both client and

74
00:03:51,360 --> 00:03:58,110
server can initiate data transfer or

75
00:03:54,690 --> 00:04:01,320
WebSocket connection for that very

76
00:03:58,110 --> 00:04:04,370
reason developers tend to implement web

77
00:04:01,320 --> 00:04:10,130
socket API eyes instead of REST API is

78
00:04:04,370 --> 00:04:10,130
based on HTTP aware it's possible to do

79
00:04:10,160 --> 00:04:17,130
WebSocket protocol supports say quack

80
00:04:13,920 --> 00:04:21,380
WebSocket protocol header in order to

81
00:04:17,130 --> 00:04:24,260
negotiate one of standardized protocols

82
00:04:21,380 --> 00:04:27,900
between client and

83
00:04:24,260 --> 00:04:31,320
those protocols are using a WebSocket as

84
00:04:27,900 --> 00:04:34,229
a transfer protocol you can get the full

85
00:04:31,320 --> 00:04:36,030
list of registered sub protocols by

86
00:04:34,230 --> 00:04:39,350
following the link presented on the

87
00:04:36,030 --> 00:04:45,210
slide for example of application

88
00:04:39,350 --> 00:04:48,420
messaging protocol or W a MP for short

89
00:04:45,210 --> 00:04:52,099
allows to do publish/subscribe and RPC

90
00:04:48,420 --> 00:04:56,580
over WebSocket connection and amusingly

91
00:04:52,100 --> 00:05:02,100
there is even soap sub protocol driven

92
00:04:56,580 --> 00:05:04,800
by Microsoft one more way to add

93
00:05:02,100 --> 00:05:09,420
functionality to WebSocket protocol is

94
00:05:04,800 --> 00:05:12,360
extensions the protocol supports sake

95
00:05:09,420 --> 00:05:15,570
WebSocket extensions had a for that

96
00:05:12,360 --> 00:05:19,230
purpose currently as we're are only two

97
00:05:15,570 --> 00:05:22,349
extensions are registered for instance

98
00:05:19,230 --> 00:05:25,170
per message deflate extension adds

99
00:05:22,350 --> 00:05:30,270
compression functionality to the socket

100
00:05:25,170 --> 00:05:33,920
protocol WebSocket connection could be

101
00:05:30,270 --> 00:05:36,840
initiated from a browser major browsers

102
00:05:33,920 --> 00:05:39,540
currently support as a protocol

103
00:05:36,840 --> 00:05:42,119
same origin policy mechanism is not

104
00:05:39,540 --> 00:05:45,240
applicable to absorbed connection

105
00:05:42,120 --> 00:05:47,970
established from a browser for such

106
00:05:45,240 --> 00:05:51,840
cases origin based security model is

107
00:05:47,970 --> 00:05:54,660
used also protocol does not offer any of

108
00:05:51,840 --> 00:05:56,789
education mechanisms developers should

109
00:05:54,660 --> 00:06:00,540
implement authentication on their own

110
00:05:56,790 --> 00:06:04,020
and one more often forgotten and all OOP

111
00:06:00,540 --> 00:06:07,680
think a client must do masking of data

112
00:06:04,020 --> 00:06:10,380
in protocol frames masking is necessary

113
00:06:07,680 --> 00:06:14,760
for protecting against a Koosh cache

114
00:06:10,380 --> 00:06:16,980
poisoning and smuggling attacks we will

115
00:06:14,760 --> 00:06:21,500
return to these things later when

116
00:06:16,980 --> 00:06:21,500
discussing vulnerabilities and attacks

117
00:06:21,800 --> 00:06:28,050
WebSockets support is huge nowadays as

118
00:06:25,530 --> 00:06:30,900
I've said major browsers support the

119
00:06:28,050 --> 00:06:34,650
protocol various web service and proxies

120
00:06:30,900 --> 00:06:36,359
understand WebSocket traffic major cloud

121
00:06:34,650 --> 00:06:39,060
providers on the level

122
00:06:36,360 --> 00:06:41,819
load balancers allowed to proxy

123
00:06:39,060 --> 00:06:45,960
WebSocket traffic to your servers in the

124
00:06:41,819 --> 00:06:48,990
cloud on the level of API get ways you

125
00:06:45,960 --> 00:06:55,739
can build WebSocket EPS for example in

126
00:06:48,990 --> 00:07:00,259
AWS you can use API gateway to build web

127
00:06:55,740 --> 00:07:03,990
socket API that calls your lambda

128
00:07:00,259 --> 00:07:08,789
function for example Bill based on data

129
00:07:03,990 --> 00:07:11,340
passed over socket connection to

130
00:07:08,789 --> 00:07:14,460
initiate WebSocket connection client

131
00:07:11,340 --> 00:07:17,750
sends HTTP request to web socket and

132
00:07:14,460 --> 00:07:21,409
pourraient with a set of special headers

133
00:07:17,750 --> 00:07:25,020
on the slide you can see highlighted

134
00:07:21,409 --> 00:07:27,810
mandatory headers this request is called

135
00:07:25,020 --> 00:07:32,188
upgrade request because client sends

136
00:07:27,810 --> 00:07:35,759
connection header with value upgrade in

137
00:07:32,189 --> 00:07:39,719
a great header value WebSocket is passed

138
00:07:35,759 --> 00:07:42,870
in a head SEC WebSocket version client

139
00:07:39,719 --> 00:07:47,909
passes protocol version and most of the

140
00:07:42,870 --> 00:07:51,870
times only Russian 13 is valid had a

141
00:07:47,909 --> 00:07:56,159
check WebSocket key contains base64

142
00:07:51,870 --> 00:07:59,339
encoded random nonce origin had isn't

143
00:07:56,159 --> 00:08:02,490
mandatory it might be used with web

144
00:07:59,339 --> 00:08:05,729
browsers for security reasons I'm not

145
00:08:02,490 --> 00:08:08,039
touching HTTP version 2 also WebSocket

146
00:08:05,729 --> 00:08:13,650
are great should be done using HTTP

147
00:08:08,039 --> 00:08:18,029
protocol of version 101 point 1 so we

148
00:08:13,650 --> 00:08:20,878
should respond with status code 101 to

149
00:08:18,029 --> 00:08:23,460
establish WebSocket connection and SEC

150
00:08:20,879 --> 00:08:26,490
WebSocket key sent by client must be

151
00:08:23,460 --> 00:08:29,430
acknowledged by the server it's done by

152
00:08:26,490 --> 00:08:31,800
calculating a sha-1 hash of SEC

153
00:08:29,430 --> 00:08:34,919
WebSocket key from client and some

154
00:08:31,800 --> 00:08:37,948
constant and afterward afterwards

155
00:08:34,919 --> 00:08:43,409
sending this value bill a base64 encoded

156
00:08:37,948 --> 00:08:46,529
inside SEC WebSocket accept header if

157
00:08:43,409 --> 00:08:48,990
handshake was successful data data is

158
00:08:46,529 --> 00:08:52,529
transferred between client and

159
00:08:48,990 --> 00:08:56,180
in the form of protocol frames using the

160
00:08:52,529 --> 00:09:00,689
same TCP connection or TLS connection

161
00:08:56,180 --> 00:09:04,410
that was used during handshake step and

162
00:09:00,690 --> 00:09:08,820
different types of frames exist field up

163
00:09:04,410 --> 00:09:11,459
code defines type of the frame one more

164
00:09:08,820 --> 00:09:16,470
important field in the frame is masking

165
00:09:11,459 --> 00:09:19,469
key client must generate 32-bit along

166
00:09:16,470 --> 00:09:23,990
key and mask data in protocol frames by

167
00:09:19,470 --> 00:09:27,990
exploring data with masking key so or

168
00:09:23,990 --> 00:09:33,630
intermediary like proxy should verify

169
00:09:27,990 --> 00:09:36,360
that client indeed masks frames this

170
00:09:33,630 --> 00:09:39,420
mechanism should protect against cache

171
00:09:36,360 --> 00:09:43,800
poisoning and smuggling attacks note

172
00:09:39,420 --> 00:09:46,589
that doesn't masks detain frames this is

173
00:09:43,800 --> 00:09:49,170
only a client respect responsibility and

174
00:09:46,589 --> 00:09:53,640
now we know enough to start exploring

175
00:09:49,170 --> 00:09:55,800
vulnerabilities and attacks and we are

176
00:09:53,640 --> 00:09:59,490
proceeding with vulnerability called

177
00:09:55,800 --> 00:10:01,920
cross-site WebSocket hijacking I should

178
00:09:59,490 --> 00:10:04,529
see it's quite widespread vulnerability

179
00:10:01,920 --> 00:10:07,589
in web applications that use web socket

180
00:10:04,529 --> 00:10:12,360
API is this one is the first thing you

181
00:10:07,589 --> 00:10:14,790
should test for as I've said same origin

182
00:10:12,360 --> 00:10:17,490
policy mechanism doesn't work for

183
00:10:14,790 --> 00:10:20,790
WebSocket connection established from a

184
00:10:17,490 --> 00:10:23,700
web browser this means that you can

185
00:10:20,790 --> 00:10:27,930
freely read or write to a WebSocket

186
00:10:23,700 --> 00:10:30,630
connection cross origin from any site to

187
00:10:27,930 --> 00:10:33,089
protect you from this WebSocket protocol

188
00:10:30,630 --> 00:10:37,110
of a so-called origin based security

189
00:10:33,089 --> 00:10:41,010
model it proceeds as follow as follows

190
00:10:37,110 --> 00:10:43,529
on suicide during hatch a handshake step

191
00:10:41,010 --> 00:10:47,610
origin header in upgrade request is

192
00:10:43,529 --> 00:10:49,439
checked against list of origins that are

193
00:10:47,610 --> 00:10:52,890
allowed to establish WebSocket

194
00:10:49,440 --> 00:10:55,680
connection browser automatically puts

195
00:10:52,890 --> 00:10:58,920
origin header in the upgrade request and

196
00:10:55,680 --> 00:10:59,519
there is no known ways to spoof origin

197
00:10:58,920 --> 00:11:02,529
head

198
00:10:59,519 --> 00:11:08,099
now if origin isn't allowed

199
00:11:02,529 --> 00:11:08,099
so immediately terminates TCP connection

200
00:11:08,249 --> 00:11:15,879
cross-site WebSocket hijacking attacks

201
00:11:12,089 --> 00:11:18,549
walk when cookie mechanism is used to

202
00:11:15,879 --> 00:11:21,549
authenticate a WebSocket upgrade request

203
00:11:18,549 --> 00:11:24,759
and had the origin isn't checked

204
00:11:21,549 --> 00:11:27,759
properly on the server side this

205
00:11:24,759 --> 00:11:31,689
includes both cases when origin isn't

206
00:11:27,759 --> 00:11:35,939
check at all so any origin is trusted or

207
00:11:31,689 --> 00:11:38,998
origin is checked by check poorly I

208
00:11:35,939 --> 00:11:42,549
guess you've heard about course

209
00:11:38,999 --> 00:11:46,359
exploitation research by James kettle

210
00:11:42,549 --> 00:11:49,478
from a ports leader I'll be NOx is his

211
00:11:46,359 --> 00:11:52,239
Twitter handle this research was

212
00:11:49,479 --> 00:11:54,909
presented several years ago and and is

213
00:11:52,239 --> 00:11:58,389
about bypassing origin checks when

214
00:11:54,909 --> 00:12:02,859
cross-origin resource sharing mechanism

215
00:11:58,389 --> 00:12:06,039
is used by application since both curves

216
00:12:02,859 --> 00:12:10,239
and WebSocket have origin based security

217
00:12:06,039 --> 00:12:13,389
model all course tricks applicable to

218
00:12:10,239 --> 00:12:18,869
WebSocket communication as well you can

219
00:12:13,389 --> 00:12:18,869
find all known course tricks by

220
00:12:19,949 --> 00:12:26,679
navigating to the following link

221
00:12:22,029 --> 00:12:30,850
presented on the slide here I present an

222
00:12:26,679 --> 00:12:33,699
example on how to make now origin for

223
00:12:30,850 --> 00:12:36,609
WebSocket upgrade request I took I took

224
00:12:33,699 --> 00:12:39,699
this trick from James Wolk presented on

225
00:12:36,609 --> 00:12:44,199
the previous slide you simply use a data

226
00:12:39,699 --> 00:12:47,319
URI for iframe and put all WebSocket

227
00:12:44,199 --> 00:12:48,549
related JavaScript inside a data URI I

228
00:12:47,319 --> 00:12:53,069
and that's it

229
00:12:48,549 --> 00:12:53,069
it works perfectly in latest browsers

230
00:12:53,639 --> 00:13:01,299
recently ports wigger released WebSocket

231
00:12:57,279 --> 00:13:04,509
flops on web security academia

232
00:13:01,299 --> 00:13:07,239
you can play with cross-site WebSocket

233
00:13:04,509 --> 00:13:11,409
hijacking in their labs link is

234
00:13:07,239 --> 00:13:14,369
presented on the slide I usually use

235
00:13:11,409 --> 00:13:17,319
following HTML page with attack template

236
00:13:14,369 --> 00:13:20,679
for cross-site WebSocket magic and

237
00:13:17,319 --> 00:13:23,439
vulnerabilities firstly it opens

238
00:13:20,679 --> 00:13:27,189
WebSockets connection then you have on

239
00:13:23,439 --> 00:13:29,469
open and own message handlers inside on

240
00:13:27,189 --> 00:13:33,248
open handler you can send something to

241
00:13:29,470 --> 00:13:35,859
the server over WebSocket connection and

242
00:13:33,249 --> 00:13:38,619
inside on message handler you receive

243
00:13:35,859 --> 00:13:44,909
data and show it on the page let's

244
00:13:38,619 --> 00:13:48,419
explore the attack flow you see here is

245
00:13:44,909 --> 00:13:51,100
challenge from a ports via web Academy

246
00:13:48,419 --> 00:13:54,459
for cross-site WebSocket hygiene

247
00:13:51,100 --> 00:14:00,459
vulnerability and we have a web

248
00:13:54,459 --> 00:14:04,319
application with chat here we can type

249
00:14:00,459 --> 00:14:04,319
in some messages

250
00:14:11,780 --> 00:14:21,880
and we see that our chat walks over

251
00:14:14,630 --> 00:14:26,689
WebSocket protocol and if we are sending

252
00:14:21,880 --> 00:14:35,540
world ready to the silver it returns the

253
00:14:26,690 --> 00:14:40,480
whole chat history back to us so here is

254
00:14:35,540 --> 00:14:43,849
our HTML page for that hijacking attack

255
00:14:40,480 --> 00:14:49,010
we are sending ready payload and prints

256
00:14:43,850 --> 00:14:54,740
out chat history on HTML page and when a

257
00:14:49,010 --> 00:14:59,300
victim visits our crafted HTML page we

258
00:14:54,740 --> 00:15:04,600
should see is that church history is

259
00:14:59,300 --> 00:15:07,219
leaked to the attacker let's switch to

260
00:15:04,600 --> 00:15:09,850
authentication related issues and

261
00:15:07,220 --> 00:15:13,760
insecure direct object reference

262
00:15:09,850 --> 00:15:16,160
vulnerabilities as we know WebSocket

263
00:15:13,760 --> 00:15:18,589
protocol does not offer any of education

264
00:15:16,160 --> 00:15:20,569
mechanisms and developers have to

265
00:15:18,589 --> 00:15:23,420
implement authentication on their own

266
00:15:20,570 --> 00:15:26,660
and sometimes they forgot to implement

267
00:15:23,420 --> 00:15:29,780
education at all or roll out broken

268
00:15:26,660 --> 00:15:34,670
implementations I want to point out that

269
00:15:29,780 --> 00:15:38,060
it's rather secure to check of Education

270
00:15:34,670 --> 00:15:41,990
all only during a handshake step because

271
00:15:38,060 --> 00:15:44,569
WebSocket protocol is stateful you don't

272
00:15:41,990 --> 00:15:47,660
need to include authentication tokens in

273
00:15:44,570 --> 00:15:50,510
each message client sends to the server

274
00:15:47,660 --> 00:15:53,180
and common secure variants of

275
00:15:50,510 --> 00:15:56,319
authentication are using session cookies

276
00:15:53,180 --> 00:15:59,510
or some form of authentication tokens

277
00:15:56,320 --> 00:16:02,180
now let's look at two cases of broken

278
00:15:59,510 --> 00:16:06,230
authentication I observe in bug bounty

279
00:16:02,180 --> 00:16:09,170
programs quite often the first case when

280
00:16:06,230 --> 00:16:13,130
some ID or global unique ID is required

281
00:16:09,170 --> 00:16:17,000
during a great request as an URL

282
00:16:13,130 --> 00:16:20,959
parameter or header this ID or geo ID

283
00:16:17,000 --> 00:16:23,810
represents user or tenant if you know

284
00:16:20,959 --> 00:16:24,449
that value for another user you can

285
00:16:23,810 --> 00:16:28,189
increase

286
00:16:24,450 --> 00:16:31,589
impersonate him for websocket api and

287
00:16:28,190 --> 00:16:34,800
sometimes you can guess as the ID or

288
00:16:31,589 --> 00:16:37,829
liquid somehow for example through minor

289
00:16:34,800 --> 00:16:42,990
unsecure direct object reference box

290
00:16:37,829 --> 00:16:45,540
somewhere in web application another

291
00:16:42,990 --> 00:16:48,690
case when there is no authentication at

292
00:16:45,540 --> 00:16:51,240
all during handshake but some ID or geo

293
00:16:48,690 --> 00:16:57,420
ID is required when you send web socket

294
00:16:51,240 --> 00:17:00,019
API messages as an example of such case

295
00:16:57,420 --> 00:17:03,269
let's look at graph QL subscriptions

296
00:17:00,019 --> 00:17:06,870
usually at pass are slash subscriptions

297
00:17:03,269 --> 00:17:10,290
there is an authenticated to associate

298
00:17:06,869 --> 00:17:12,510
API where you can connect to and quite

299
00:17:10,290 --> 00:17:18,990
often retrieve sensitive data belonging

300
00:17:12,510 --> 00:17:23,069
to other people there are other things

301
00:17:18,990 --> 00:17:25,770
you can find are unsecure direct object

302
00:17:23,069 --> 00:17:28,020
reference ulnar abilities there is a

303
00:17:25,770 --> 00:17:31,500
strong authentication during handshake

304
00:17:28,020 --> 00:17:36,150
step but API is designed in such ways it

305
00:17:31,500 --> 00:17:40,410
in a PI messages you observe IDs or geo

306
00:17:36,150 --> 00:17:43,230
IDs and manipulating with this IDs or

307
00:17:40,410 --> 00:17:46,440
geo ideas you can get or modify data

308
00:17:43,230 --> 00:17:53,190
belonging to other people and this is

309
00:17:46,440 --> 00:17:56,040
the same as I do use in REST API now

310
00:17:53,190 --> 00:17:59,250
let's explore issues with reverse proxy

311
00:17:56,040 --> 00:18:01,200
of WebSocket connections if you remember

312
00:17:59,250 --> 00:18:04,070
I have called them new at the beginning

313
00:18:01,200 --> 00:18:07,080
of the talk these issues allowed to

314
00:18:04,070 --> 00:18:10,200
smuggle HTTP requests through fake

315
00:18:07,080 --> 00:18:14,928
WebSocket connection and access internal

316
00:18:10,200 --> 00:18:17,940
stuff that is inaccessible otherwise

317
00:18:14,929 --> 00:18:21,630
let's start with observing how reverse

318
00:18:17,940 --> 00:18:25,860
proxy proxy info of socket is working in

319
00:18:21,630 --> 00:18:30,600
the ideal world we have back-end that

320
00:18:25,860 --> 00:18:35,219
exposes some web socket API on pass /

321
00:18:30,600 --> 00:18:36,240
socket IO and client client accesses API

322
00:18:35,220 --> 00:18:40,350
through

323
00:18:36,240 --> 00:18:45,360
proxy for example we use nginx as the

324
00:18:40,350 --> 00:18:48,689
front end and WebSocket proxy when

325
00:18:45,360 --> 00:18:51,840
initiating the connection a client sends

326
00:18:48,690 --> 00:18:55,050
some great request to reverse proxy for

327
00:18:51,840 --> 00:18:57,689
pass sake dot IO and reverse proxy

328
00:18:55,050 --> 00:19:01,379
discovers that income and get a request

329
00:18:57,690 --> 00:19:04,590
is up great request by inspection HTTP

330
00:19:01,380 --> 00:19:08,400
headers like connection upgrade or

331
00:19:04,590 --> 00:19:11,100
upgrade WebSocket if everything is

332
00:19:08,400 --> 00:19:15,510
correct it translates that upgrade

333
00:19:11,100 --> 00:19:19,110
request to the back end back end answers

334
00:19:15,510 --> 00:19:22,950
reverse proxy with HTTP response that

335
00:19:19,110 --> 00:19:26,040
has state of Scott 101 switching

336
00:19:22,950 --> 00:19:30,500
protocol reverse proxy checks that

337
00:19:26,040 --> 00:19:35,700
status of response in deities 101 and

338
00:19:30,500 --> 00:19:38,940
header SEC WebSocket accept has a

339
00:19:35,700 --> 00:19:42,270
correct acknowledgment if everything is

340
00:19:38,940 --> 00:19:44,670
valid proxy translate request to the

341
00:19:42,270 --> 00:19:47,100
client and what's important doesn't

342
00:19:44,670 --> 00:19:48,510
close TLS connection from client to

343
00:19:47,100 --> 00:19:50,939
back-end

344
00:19:48,510 --> 00:19:53,700
otherwise if response from back-end

345
00:19:50,940 --> 00:19:58,620
isn't correct reverse proxy immediately

346
00:19:53,700 --> 00:20:01,470
terminate that connection after a client

347
00:19:58,620 --> 00:20:05,060
receives response from back-end and

348
00:20:01,470 --> 00:20:07,380
verifies its correctness we have direct

349
00:20:05,060 --> 00:20:11,629
WebSocket connection from client to

350
00:20:07,380 --> 00:20:14,780
back-end client or back-end can now send

351
00:20:11,630 --> 00:20:19,530
WebSocket frames to each other over

352
00:20:14,780 --> 00:20:22,410
connection client masks data in frames

353
00:20:19,530 --> 00:20:25,260
and reverse proxy and back-end should

354
00:20:22,410 --> 00:20:29,490
verify that frames coming from client I

355
00:20:25,260 --> 00:20:31,730
indeed masked if they're not masked

356
00:20:29,490 --> 00:20:35,580
connection is immediately immediately

357
00:20:31,730 --> 00:20:39,450
terminated that's how it works in the

358
00:20:35,580 --> 00:20:42,710
real world but in reality reverse proxy

359
00:20:39,450 --> 00:20:44,250
proxies might behave slightly different

360
00:20:42,710 --> 00:20:46,890
from

361
00:20:44,250 --> 00:20:48,720
described scenario let's look at some

362
00:20:46,890 --> 00:20:52,000
real

363
00:20:48,720 --> 00:20:55,750
assume we have back-end with publicly

364
00:20:52,000 --> 00:20:59,220
exposed a web socket API on path socket

365
00:20:55,750 --> 00:21:02,350
dot IO and there is internal REST API

366
00:20:59,220 --> 00:21:05,950
used for administration's that's private

367
00:21:02,350 --> 00:21:08,350
and is not exposed outside now we have

368
00:21:05,950 --> 00:21:11,890
client that communicates with back-end

369
00:21:08,350 --> 00:21:14,889
why are vulnerable reverse proxy the

370
00:21:11,890 --> 00:21:19,210
purpose of malicious client is to access

371
00:21:14,890 --> 00:21:21,190
private API on the first step client

372
00:21:19,210 --> 00:21:25,390
sends some great request to reverse

373
00:21:21,190 --> 00:21:30,250
proxy with wrong abortion in check web

374
00:21:25,390 --> 00:21:34,270
socket version HTTP header currently

375
00:21:30,250 --> 00:21:37,510
only version 13 is supported most of the

376
00:21:34,270 --> 00:21:40,690
time and reverse proxy doesn't check

377
00:21:37,510 --> 00:21:43,720
version and passes request to back-end

378
00:21:40,690 --> 00:21:49,060
thinking that's that it's a good upgrade

379
00:21:43,720 --> 00:21:51,220
request but back-end declined some great

380
00:21:49,060 --> 00:21:54,190
requests because of wrong protocol

381
00:21:51,220 --> 00:21:59,310
version and since HTTP response with

382
00:21:54,190 --> 00:22:02,500
status 426 back to the proxy proxy

383
00:21:59,310 --> 00:22:05,649
doesn't verifies status code and other

384
00:22:02,500 --> 00:22:08,080
HTTP headers in the response and thinks

385
00:22:05,650 --> 00:22:11,430
that back-end is ready for WebSocket

386
00:22:08,080 --> 00:22:14,679
connection reverse proxy translate

387
00:22:11,430 --> 00:22:18,850
translates a HTTP response tool to the

388
00:22:14,680 --> 00:22:21,220
client with status 426 and keep still

389
00:22:18,850 --> 00:22:26,439
TLS connection between client and

390
00:22:21,220 --> 00:22:28,930
back-end in open state so there is no

391
00:22:26,440 --> 00:22:32,650
real WebSocket connection only TLS

392
00:22:28,930 --> 00:22:35,500
connection but reverse proxy thinks that

393
00:22:32,650 --> 00:22:38,890
WebSocket connection was established

394
00:22:35,500 --> 00:22:43,180
if client sends HTTP request to slash

395
00:22:38,890 --> 00:22:46,740
internal pass over that gos connection

396
00:22:43,180 --> 00:22:50,440
he can access private REST API awesome

397
00:22:46,740 --> 00:22:52,630
here additionally reverse proxy also

398
00:22:50,440 --> 00:22:55,740
doesn't check that client masks

399
00:22:52,630 --> 00:22:55,740
WebSocket frames

400
00:22:57,309 --> 00:23:03,660
I've created first challenge successful

401
00:22:59,950 --> 00:23:07,270
at URL presented on the slide and posted

402
00:23:03,660 --> 00:23:10,210
posted it online at the beginning of

403
00:23:07,270 --> 00:23:14,410
October the challenge is based on this

404
00:23:10,210 --> 00:23:19,480
idea the task is to access flag on

405
00:23:14,410 --> 00:23:23,340
localhost port 5000 centrally sadly but

406
00:23:19,480 --> 00:23:23,340
seems nobody solved this challenge

407
00:23:24,419 --> 00:23:30,250
sorry but currently I cannot disclose

408
00:23:27,940 --> 00:23:34,059
the name of WebSocket reverse proxy I

409
00:23:30,250 --> 00:23:38,289
used for this challenge on backend

410
00:23:34,059 --> 00:23:41,470
I used flask with flask socket IO module

411
00:23:38,289 --> 00:23:43,530
for WebSocket support and flask restful

412
00:23:41,470 --> 00:23:47,760
for building a REST API

413
00:23:43,530 --> 00:23:52,330
Beck a back-end walks on localhost port

414
00:23:47,760 --> 00:23:57,580
5000 and only web socket API on past

415
00:23:52,330 --> 00:24:00,668
socket dot IO is exposed publicly here

416
00:23:57,580 --> 00:24:04,658
is the intended intended solution for

417
00:24:00,669 --> 00:24:08,440
the challenge we open the CP port and

418
00:24:04,659 --> 00:24:11,140
send two HTTP requests in a row the

419
00:24:08,440 --> 00:24:13,840
first one contains upgrade WebSocket

420
00:24:11,140 --> 00:24:17,440
header and SEC WebSocket version header

421
00:24:13,840 --> 00:24:21,000
with a round protocol version the second

422
00:24:17,440 --> 00:24:24,400
get request retrieves the flag as its it

423
00:24:21,000 --> 00:24:30,030
let's look at in action that it's rarely

424
00:24:24,400 --> 00:24:34,659
working and I'm not kidding you here is

425
00:24:30,030 --> 00:24:38,110
our solution script and we see it has

426
00:24:34,659 --> 00:24:45,549
two requests the first one establishes

427
00:24:38,110 --> 00:24:49,289
fake WebSocket connection and the second

428
00:24:45,549 --> 00:24:49,289
one retrieves the flag

429
00:24:54,539 --> 00:24:58,999
here's the hostname with the challenge

430
00:25:00,229 --> 00:25:10,289
and when we launch it we get back the

431
00:25:08,609 --> 00:25:16,728
flag and so with Russia what could

432
00:25:10,289 --> 00:25:20,158
drinks you're written in leet speak so

433
00:25:16,729 --> 00:25:23,940
varnish of latest version and in what

434
00:25:20,159 --> 00:25:26,159
proxy of version one point eight four

435
00:25:23,940 --> 00:25:29,190
zero and below are vulnerable

436
00:25:26,159 --> 00:25:31,919
there are also some vulnerable reverse

437
00:25:29,190 --> 00:25:36,899
proxies which I can't name currently a

438
00:25:31,919 --> 00:25:42,779
good news that nginx is a proxy traffic

439
00:25:36,899 --> 00:25:45,238
are not affected by this thing varnish

440
00:25:42,779 --> 00:25:47,759
is not going to fix this I configured

441
00:25:45,239 --> 00:25:49,619
varnish as described in the

442
00:25:47,759 --> 00:25:53,899
documentation to check if it's

443
00:25:49,619 --> 00:25:57,958
vulnerable and it's indeed vulnerable

444
00:25:53,899 --> 00:26:00,238
reply from varnish to my report was they

445
00:25:57,959 --> 00:26:04,739
doesn't guarantee any security when

446
00:26:00,239 --> 00:26:05,809
proxxon WebSockets rule varnish so shame

447
00:26:04,739 --> 00:26:08,819
on them

448
00:26:05,809 --> 00:26:11,399
therefore you should consider such

449
00:26:08,819 --> 00:26:16,678
attacks if you are using varnish as

450
00:26:11,399 --> 00:26:20,539
their worst proxy for WebSockets there

451
00:26:16,679 --> 00:26:23,579
are many ROS proxies like nginx that

452
00:26:20,539 --> 00:26:26,759
chicken a response for upgrade requests

453
00:26:23,579 --> 00:26:29,418
they receive from the back end for such

454
00:26:26,759 --> 00:26:33,119
proxies a previous attack does not work

455
00:26:29,419 --> 00:26:35,999
so let's look at another scenario we

456
00:26:33,119 --> 00:26:39,389
have private REST API inaccessible from

457
00:26:35,999 --> 00:26:43,440
outside and now we have a public web

458
00:26:39,389 --> 00:26:48,029
socket API and a public rest api client

459
00:26:43,440 --> 00:26:52,379
invokes public api biogenics that's used

460
00:26:48,029 --> 00:26:56,159
as a reverse proxy let's assume that

461
00:26:52,379 --> 00:26:59,158
expose expose publicly arrestee api

462
00:26:56,159 --> 00:27:01,739
allows to check health of some website

463
00:26:59,159 --> 00:27:04,889
by making it request to that external

464
00:27:01,739 --> 00:27:06,660
site and return in status code to the

465
00:27:04,889 --> 00:27:09,610
client

466
00:27:06,660 --> 00:27:12,370
malicious client want to get access to

467
00:27:09,610 --> 00:27:15,610
internal API on the first step he made

468
00:27:12,370 --> 00:27:18,790
he makes post request to invoke public

469
00:27:15,610 --> 00:27:21,010
REST API and additionally a places a

470
00:27:18,790 --> 00:27:25,240
great WebSocket HTTP header to the

471
00:27:21,010 --> 00:27:27,790
request engine eeks observes HTTP header

472
00:27:25,240 --> 00:27:31,210
upgrade WebSocket and things that he

473
00:27:27,790 --> 00:27:33,700
received upgrade request from client he

474
00:27:31,210 --> 00:27:36,970
doesn't check the request method method

475
00:27:33,700 --> 00:27:42,040
all other headers on the upgrade web web

476
00:27:36,970 --> 00:27:44,620
socket as an indicator and later nginx

477
00:27:42,040 --> 00:27:49,060
will transfer a quest request to the

478
00:27:44,620 --> 00:27:51,969
backend back-end will invoke public REST

479
00:27:49,060 --> 00:27:55,990
API and reach external resource while

480
00:27:51,970 --> 00:28:00,550
URL that was supplied in parameter with

481
00:27:55,990 --> 00:28:03,970
name you since the client fully controls

482
00:28:00,550 --> 00:28:08,970
that parameter he can query his resource

483
00:28:03,970 --> 00:28:12,490
that will return in a 101 status code

484
00:28:08,970 --> 00:28:17,470
back-end will return HTTP response with

485
00:28:12,490 --> 00:28:20,020
status code 101 to nginx and Ingenix

486
00:28:17,470 --> 00:28:22,210
will check on resist status code and

487
00:28:20,020 --> 00:28:23,970
will decide that back-end established

488
00:28:22,210 --> 00:28:28,870
WebSocket connection

489
00:28:23,970 --> 00:28:31,720
afterwards Ingenix transfers this

490
00:28:28,870 --> 00:28:33,580
response to the client and keeps open

491
00:28:31,720 --> 00:28:38,920
TLS connection we're waiting for

492
00:28:33,580 --> 00:28:41,409
WebSocket frames so we have TLS

493
00:28:38,920 --> 00:28:44,830
connection open between client and

494
00:28:41,410 --> 00:28:48,040
back-end in reality nginx

495
00:28:44,830 --> 00:28:51,639
thinks it's a socket connection it does

496
00:28:48,040 --> 00:28:54,580
not check anything or alter data it just

497
00:28:51,640 --> 00:28:58,150
passes DT between client and the server

498
00:28:54,580 --> 00:29:01,449
and now client can access private REST

499
00:28:58,150 --> 00:29:03,990
API by sending get request to pass /

500
00:29:01,450 --> 00:29:03,990
internal

501
00:29:05,040 --> 00:29:10,770
I created second online challenge for

502
00:29:07,620 --> 00:29:13,850
that scenario again to solve the

503
00:29:10,770 --> 00:29:18,059
challenge you need to access flag on

504
00:29:13,850 --> 00:29:20,159
localhost port 5000 and again nobody

505
00:29:18,059 --> 00:29:26,129
solve this challenge unfortunately

506
00:29:20,160 --> 00:29:31,230
unfortunately we have nginx as reverse

507
00:29:26,130 --> 00:29:36,120
proxy flask back end and back end is 7

508
00:29:31,230 --> 00:29:40,559
on localhost port 5000 you see here

509
00:29:36,120 --> 00:29:44,820
snippet from nginx config we are reverse

510
00:29:40,559 --> 00:29:47,970
protein public API for pass slash API

511
00:29:44,820 --> 00:29:53,850
slash public and WebSocket connection

512
00:29:47,970 --> 00:29:57,390
proxy is enabled for that pass we have

513
00:29:53,850 --> 00:30:01,168
health check public REST API to invoke

514
00:29:57,390 --> 00:30:04,580
it we make post request and specify URL

515
00:30:01,169 --> 00:30:08,549
parameter in the body of the request

516
00:30:04,580 --> 00:30:12,149
back and reaches external resource for

517
00:30:08,549 --> 00:30:18,120
example google.com and returns status

518
00:30:12,150 --> 00:30:20,610
code back to the client and how now we

519
00:30:18,120 --> 00:30:23,520
have everything to build final solution

520
00:30:20,610 --> 00:30:26,340
for the challenge we open a TCP

521
00:30:23,520 --> 00:30:29,879
connection and send to HTTP request in a

522
00:30:26,340 --> 00:30:33,270
row first one is post request to invoke

523
00:30:29,880 --> 00:30:37,530
health check arrest API but with

524
00:30:33,270 --> 00:30:40,740
additional header upgrade WebSocket as a

525
00:30:37,530 --> 00:30:43,350
parameter we pass URL that we control

526
00:30:40,740 --> 00:30:47,100
and that returns a response with status

527
00:30:43,350 --> 00:30:49,590
code 101 and the second request

528
00:30:47,100 --> 00:30:57,230
retrieves their flag let's see how it

529
00:30:49,590 --> 00:30:57,230
works here is our solution script

530
00:31:01,960 --> 00:31:10,820
again it has two requests the first one

531
00:31:06,470 --> 00:31:16,250
establishes fake WebSocket connection to

532
00:31:10,820 --> 00:31:26,120
the backend and the second one retreats

533
00:31:16,250 --> 00:31:29,410
the flag by accessing internal API and

534
00:31:26,120 --> 00:31:38,870
when we launch it we should get the flag

535
00:31:29,410 --> 00:31:42,290
yes but things that almost all proxies I

536
00:31:38,870 --> 00:31:45,169
affected by this thing and good things

537
00:31:42,290 --> 00:31:47,389
that exploitation is limited since you

538
00:31:45,170 --> 00:31:50,600
need some minor vulnerability on the

539
00:31:47,390 --> 00:31:52,850
backend for example externals suicide

540
00:31:50,600 --> 00:31:55,969
request forgery

541
00:31:52,850 --> 00:31:59,330
however external serifs are quite

542
00:31:55,970 --> 00:32:02,140
widespread and they are considered low

543
00:31:59,330 --> 00:32:08,360
severity issues and are rarely fixed

544
00:32:02,140 --> 00:32:10,390
resume it and before wrapping up let's

545
00:32:08,360 --> 00:32:14,060
drop some words about discovering

546
00:32:10,390 --> 00:32:18,590
WebSocket ApS during we are testing web

547
00:32:14,060 --> 00:32:22,340
applications obviously we can monitor

548
00:32:18,590 --> 00:32:25,550
HTTP traffic for upgrade requests oh

549
00:32:22,340 --> 00:32:29,270
when we can grab through javascript

550
00:32:25,550 --> 00:32:32,780
files for patterns that reveal a

551
00:32:29,270 --> 00:32:34,970
presence of web socket API and we can

552
00:32:32,780 --> 00:32:38,360
even try to establish WebSocket

553
00:32:34,970 --> 00:32:40,970
connection to each URL we observe it

554
00:32:38,360 --> 00:32:43,669
sounds not sensible but believe me you

555
00:32:40,970 --> 00:32:49,040
can sometimes find hidden WebSocket

556
00:32:43,670 --> 00:32:51,620
api's using this method in conclusion I

557
00:32:49,040 --> 00:32:56,030
want to share my ideas regarding further

558
00:32:51,620 --> 00:32:58,310
research on that topic in my opinion

559
00:32:56,030 --> 00:33:01,460
it's interesting to look into security

560
00:32:58,310 --> 00:33:03,740
of WebSockets our protocols another

561
00:33:01,460 --> 00:33:06,410
interesting topic is to discover most

562
00:33:03,740 --> 00:33:09,560
Moglen techniques I've demonstrated you

563
00:33:06,410 --> 00:33:12,380
two techniques maybe there are more for

564
00:33:09,560 --> 00:33:14,629
example I have not yet touched how a

565
00:33:12,380 --> 00:33:15,170
WebSocket is working over HTTP version

566
00:33:14,630 --> 00:33:20,360
two

567
00:33:15,170 --> 00:33:23,000
it's interesting I think and the soulful

568
00:33:20,360 --> 00:33:26,469
for the stock if we have some time for

569
00:33:23,000 --> 00:33:26,470
questions I'll be happy to answer

570
00:33:29,860 --> 00:33:35,719
[Applause]

571
00:33:44,350 --> 00:33:47,520
[Music]

572
00:33:48,740 --> 00:33:58,080
yes yes there are some companies that

573
00:33:54,379 --> 00:34:09,629
pays for fudge box I have already sent

574
00:33:58,080 --> 00:34:13,319
some reports for others no yes I'm going

575
00:34:09,629 --> 00:34:18,049
to make a github page with describing

576
00:34:13,319 --> 00:34:18,050
this attack yes

577
00:34:42,639 --> 00:34:50,830
yes you're right that there is there is

578
00:34:48,130 --> 00:34:53,860
an opinion that there is no security

579
00:34:50,830 --> 00:34:58,930
perimeter or everything is accessible

580
00:34:53,860 --> 00:35:04,840
but in reality there are some some

581
00:34:58,930 --> 00:35:08,279
products for example it's used for by

582
00:35:04,840 --> 00:35:11,710
divorce for example that has some

583
00:35:08,280 --> 00:35:15,390
private api's that listening on

584
00:35:11,710 --> 00:35:18,430
localhost for example and gives you some

585
00:35:15,390 --> 00:35:31,180
privileged access to Salah to some

586
00:35:18,430 --> 00:35:38,770
functionality yes this is a big problem

587
00:35:31,180 --> 00:35:40,799
but now I think yes it will remain the

588
00:35:38,770 --> 00:35:40,800
same

589
00:35:50,570 --> 00:35:53,260
yes

590
00:35:58,200 --> 00:36:04,379
okay for example you can bypass about

591
00:36:01,690 --> 00:36:11,170
application firewalls with this

592
00:36:04,380 --> 00:36:13,930
completely bypass because replication

593
00:36:11,170 --> 00:36:18,480
firewalls usually denote X inspect

594
00:36:13,930 --> 00:36:20,950
WebSocket traffic so you can access

595
00:36:18,480 --> 00:36:24,660
service bak you can access vulnerable

596
00:36:20,950 --> 00:36:24,660
and point and exploit vulnerabilities

597
00:36:39,850 --> 00:36:48,339
okay thank you very much

598
00:36:42,680 --> 00:36:48,339
[Applause]

