1
00:00:00,030 --> 00:00:03,240
thank you everyone for coming thank you

2
00:00:03,240 --> 00:00:04,950
for finding the strength to come to my

3
00:00:04,950 --> 00:00:07,440
final talk I understand not only talks

4
00:00:07,440 --> 00:00:08,820
make a good conference but the

5
00:00:08,820 --> 00:00:10,620
activities afterward and I'm standing

6
00:00:10,620 --> 00:00:13,860
between you and those activities so but

7
00:00:13,860 --> 00:00:15,750
hopefully today I will tell you about an

8
00:00:15,750 --> 00:00:17,820
interesting piece of a technology which

9
00:00:17,820 --> 00:00:22,769
exists and rather like rare used which

10
00:00:22,769 --> 00:00:25,140
is called USB IP and we talked about we

11
00:00:25,140 --> 00:00:26,580
will talk about how to exploit it in

12
00:00:26,580 --> 00:00:31,260
Linux okay first of all Who am I I work

13
00:00:31,260 --> 00:00:35,600
at flower who heard about closer okay

14
00:00:35,600 --> 00:00:39,210
yeah I'm working platform operations

15
00:00:39,210 --> 00:00:42,000
currently and my main interests are

16
00:00:42,000 --> 00:00:44,670
security and crypto I also enjoy

17
00:00:44,670 --> 00:00:47,010
low-level stuff so usually working Linux

18
00:00:47,010 --> 00:00:50,430
kernels low-level C code biases from

19
00:00:50,430 --> 00:00:53,239
where and other interesting nasty things

20
00:00:53,239 --> 00:00:57,780
but I'm not like a professional InfoSec

21
00:00:57,780 --> 00:01:01,500
person so I'm not as fantastic I'm more

22
00:01:01,500 --> 00:01:03,570
a builder than a breaker but you may ask

23
00:01:03,570 --> 00:01:05,339
me why I'm standing here and presenting

24
00:01:05,339 --> 00:01:07,830
a vulnerability because when I use some

25
00:01:07,830 --> 00:01:10,710
system I'll try to analyze it and see if

26
00:01:10,710 --> 00:01:13,290
it's a implemented saying which is not

27
00:01:13,290 --> 00:01:17,850
what happened with USB IP okay so what

28
00:01:17,850 --> 00:01:20,790
are we going to talk about today first

29
00:01:20,790 --> 00:01:24,180
of all I will introduce you to the USB

30
00:01:24,180 --> 00:01:26,729
IP framework we will see how it's

31
00:01:26,729 --> 00:01:30,270
implemented in Linux I will briefly show

32
00:01:30,270 --> 00:01:32,880
you how to how you can share a USB

33
00:01:32,880 --> 00:01:35,520
device over IP network bandwidth will

34
00:01:35,520 --> 00:01:39,619
jump the vulnerable USB IP code and

35
00:01:39,619 --> 00:01:42,560
discuss potential exploit impact and

36
00:01:42,560 --> 00:01:44,670
finally I will try to give you some

37
00:01:44,670 --> 00:01:46,590
advices that if you want to use this

38
00:01:46,590 --> 00:01:49,350
technology what should you do okay but

39
00:01:49,350 --> 00:01:54,060
first this is a vulnerability so are you

40
00:01:54,060 --> 00:01:57,210
vulnerable okay how many of you have

41
00:01:57,210 --> 00:02:03,450
heard about USB IP before 1 ok and how

42
00:02:03,450 --> 00:02:08,008
many of you all have used it no one okay

43
00:02:08,008 --> 00:02:11,068
and how many of you have patched your

44
00:02:11,068 --> 00:02:14,750
Linux system from last year

45
00:02:14,750 --> 00:02:18,330
okay that's good so the rule of Samba is

46
00:02:18,330 --> 00:02:20,910
the way how it's implemented so if you

47
00:02:20,910 --> 00:02:25,950
have never heard about it and you're

48
00:02:25,950 --> 00:02:28,340
sure you're not using it you're safe

49
00:02:28,340 --> 00:02:31,230
well if you're using it but have patched

50
00:02:31,230 --> 00:02:33,300
your system from last year

51
00:02:33,300 --> 00:02:37,080
you're probably reasonably safe and if

52
00:02:37,080 --> 00:02:38,550
you haven't patched your Linux system

53
00:02:38,550 --> 00:02:40,530
from last year so you screwed anyway so

54
00:02:40,530 --> 00:02:42,270
I can't help you

55
00:02:42,270 --> 00:02:46,320
there's much more than that there okay

56
00:02:46,320 --> 00:02:50,130
so what is the USB AP so it does exactly

57
00:02:50,130 --> 00:02:53,610
what it sounds it should do so it's a

58
00:02:53,610 --> 00:02:56,460
way to share a USB device over a network

59
00:02:56,460 --> 00:02:59,190
the interesting part it's implemented in

60
00:02:59,190 --> 00:03:01,530
a device driver agnostic way that is it

61
00:03:01,530 --> 00:03:03,720
does not it's not designed for a

62
00:03:03,720 --> 00:03:06,660
specific type of a device it works on a

63
00:03:06,660 --> 00:03:09,270
lower level USB protocol layer and

64
00:03:09,270 --> 00:03:12,420
allows sharing almost any USB device out

65
00:03:12,420 --> 00:03:16,110
there so it does that by just forwarding

66
00:03:16,110 --> 00:03:18,930
your B's over TCP connection so your B

67
00:03:18,930 --> 00:03:21,930
stands for USB request block which is a

68
00:03:21,930 --> 00:03:24,360
low-level data structure or a packet in

69
00:03:24,360 --> 00:03:27,180
the USB protocol and basically it's

70
00:03:27,180 --> 00:03:29,209
implemented for Linux and Windows

71
00:03:29,209 --> 00:03:33,450
probably Mac I don't know so it's it can

72
00:03:33,450 --> 00:03:39,560
be used in different systems this is the

73
00:03:40,160 --> 00:03:44,100
diagram which shows the high level

74
00:03:44,100 --> 00:03:46,200
architecture of the USB AP framework

75
00:03:46,200 --> 00:03:48,209
it's taken from directly from the USB

76
00:03:48,209 --> 00:03:50,760
a/b project website here the link is

77
00:03:50,760 --> 00:03:53,700
down sorry no HTTP because it's an old

78
00:03:53,700 --> 00:03:59,130
project yeah so and to move further

79
00:03:59,130 --> 00:04:01,290
first of all we have to understand the

80
00:04:01,290 --> 00:04:04,140
terminology in this architecture so this

81
00:04:04,140 --> 00:04:05,610
is a typical client-server architecture

82
00:04:05,610 --> 00:04:10,560
and the roles are server in USB a/b

83
00:04:10,560 --> 00:04:14,280
terminology is a side which shares USB

84
00:04:14,280 --> 00:04:16,048
devices that is this is the side where

85
00:04:16,048 --> 00:04:19,500
you plug in a real device and you're

86
00:04:19,500 --> 00:04:20,910
supposed to share it over the network

87
00:04:20,910 --> 00:04:24,419
and the USB a/b client is the site which

88
00:04:24,419 --> 00:04:26,680
imports USB devices for

89
00:04:26,680 --> 00:04:29,680
the network that is it doesn't have any

90
00:04:29,680 --> 00:04:32,470
physical devices plugged in but when

91
00:04:32,470 --> 00:04:35,110
it's impressive device local system

92
00:04:35,110 --> 00:04:37,720
shows you as if your locally plugged in

93
00:04:37,720 --> 00:04:42,460
your imported device is that clear yeah

94
00:04:42,460 --> 00:04:45,490
so let's now take a brief look how this

95
00:04:45,490 --> 00:04:49,570
architecture maps to Linux components so

96
00:04:49,570 --> 00:04:52,660
basically we have user space components

97
00:04:52,660 --> 00:04:56,919
and kernel space components so they're

98
00:04:56,919 --> 00:04:59,470
shown in green so in user space on

99
00:04:59,470 --> 00:05:02,349
server side you have a demon called USB

100
00:05:02,349 --> 00:05:05,349
APD and then you have two kernel modules

101
00:05:05,349 --> 00:05:08,199
which are USB AP host and USB a peak or

102
00:05:08,199 --> 00:05:10,750
on the client side you have USB AP

103
00:05:10,750 --> 00:05:14,500
client until it in user space and you

104
00:05:14,500 --> 00:05:16,900
have again USB a/b core which is the

105
00:05:16,900 --> 00:05:19,889
same module as server it's like a shared

106
00:05:19,889 --> 00:05:22,720
library in kernel I don't know for some

107
00:05:22,720 --> 00:05:24,520
reason they decided to put it in a

108
00:05:24,520 --> 00:05:27,460
separate kernel model and you have the

109
00:05:27,460 --> 00:05:29,710
HDD which stands for virtual host

110
00:05:29,710 --> 00:05:32,380
controller driver so it's a virtual USB

111
00:05:32,380 --> 00:05:38,050
host on on the client side so how it

112
00:05:38,050 --> 00:05:39,030
works

113
00:05:39,030 --> 00:05:42,190
high-level overview so imagine you have

114
00:05:42,190 --> 00:05:45,250
a server and you plugged in a USB device

115
00:05:45,250 --> 00:05:47,949
what happens under the hood is the USB

116
00:05:47,949 --> 00:05:49,720
device starts communicating with your

117
00:05:49,720 --> 00:05:52,570
real servers us be a cost controller

118
00:05:52,570 --> 00:05:56,050
driver then host controller driver

119
00:05:56,050 --> 00:05:58,659
reports that it enumerates as the USB

120
00:05:58,659 --> 00:06:00,940
device and reports that it found a new

121
00:06:00,940 --> 00:06:03,669
device on the bus and in more than Linux

122
00:06:03,669 --> 00:06:06,460
distribution you probably we all use you

123
00:06:06,460 --> 00:06:08,560
dev which will find an appropriate

124
00:06:08,560 --> 00:06:10,900
device driver for this USB device and

125
00:06:10,900 --> 00:06:13,270
loaded into memory and then driver will

126
00:06:13,270 --> 00:06:15,340
start communicating and controlling the

127
00:06:15,340 --> 00:06:19,330
USB device so ok so now imagine you

128
00:06:19,330 --> 00:06:20,800
plugged in your device that's how it

129
00:06:20,800 --> 00:06:22,810
would work and now you want to export

130
00:06:22,810 --> 00:06:25,690
this device over IP to to the client so

131
00:06:25,690 --> 00:06:29,620
what you do you USB ap demon sends the

132
00:06:29,620 --> 00:06:31,780
comment to make this specific device

133
00:06:31,780 --> 00:06:36,070
exportable so under the hood USB host

134
00:06:36,070 --> 00:06:38,320
controller driver disconnects the real

135
00:06:38,320 --> 00:06:39,969
device driver

136
00:06:39,969 --> 00:06:43,569
start starts forwarding or all your your

137
00:06:43,569 --> 00:06:48,159
bees these small USB packets to the USB

138
00:06:48,159 --> 00:06:51,610
AP framework yeah and it stops there for

139
00:06:51,610 --> 00:06:54,969
some time so it means so the device

140
00:06:54,969 --> 00:06:57,159
disappears from the server's operating

141
00:06:57,159 --> 00:06:59,619
system but since we have no client

142
00:06:59,619 --> 00:07:01,449
nothing happens so it stays in this way

143
00:07:01,449 --> 00:07:04,089
then at some point client comes in and

144
00:07:04,089 --> 00:07:06,309
the client wants to import this device

145
00:07:06,309 --> 00:07:08,139
so it sends an import request to the

146
00:07:08,139 --> 00:07:10,569
server what happens under the hood is

147
00:07:10,569 --> 00:07:13,839
that serving client establish a TCP

148
00:07:13,839 --> 00:07:16,149
connection and then the server starts

149
00:07:16,149 --> 00:07:18,479
forwarding this you'll be devices to the

150
00:07:18,479 --> 00:07:20,889
portal host controller driver on the

151
00:07:20,889 --> 00:07:22,989
client side and then the virtual host

152
00:07:22,989 --> 00:07:25,179
controller driver behaves like a real

153
00:07:25,179 --> 00:07:26,949
host controller driver it reports that

154
00:07:26,949 --> 00:07:28,509
it discovered the new device in the

155
00:07:28,509 --> 00:07:31,149
system and you dev will load the same

156
00:07:31,149 --> 00:07:34,589
device driver on the client system and

157
00:07:34,589 --> 00:07:37,179
that device driver the client will now

158
00:07:37,179 --> 00:07:39,249
be controlling the device on the USB ap

159
00:07:39,249 --> 00:07:42,339
server so this is how it looks from

160
00:07:42,339 --> 00:07:45,119
common line this is a client perspective

161
00:07:45,119 --> 00:07:48,879
so first of all to import the USB device

162
00:07:48,879 --> 00:07:51,399
from a server you have you use USB AP

163
00:07:51,399 --> 00:07:53,439
client utility you issue list comment

164
00:07:53,439 --> 00:07:57,550
and you specify the IP address of the

165
00:07:57,550 --> 00:08:01,300
remote server in this test I did it like

166
00:08:01,300 --> 00:08:03,729
a local host test this is a local host

167
00:08:03,729 --> 00:08:05,949
address and you get a list of all the

168
00:08:05,949 --> 00:08:08,739
devices which are imported from the

169
00:08:08,739 --> 00:08:14,860
server so the native information here is

170
00:08:14,860 --> 00:08:19,569
that ID which is 1/1 which this is like

171
00:08:19,569 --> 00:08:22,749
device ID in USB ap terminology so to

172
00:08:22,749 --> 00:08:26,789
improve this device you just run this

173
00:08:26,789 --> 00:08:29,769
USB AP client utility with attached

174
00:08:29,769 --> 00:08:32,349
common again you specify the IP address

175
00:08:32,349 --> 00:08:33,969
of the server and specify the idea

176
00:08:33,969 --> 00:08:36,279
device you want to import and after that

177
00:08:36,279 --> 00:08:38,769
the magic happens and you get this this

178
00:08:38,769 --> 00:08:41,708
device on your local system so when I

179
00:08:41,708 --> 00:08:44,500
originally resort that what was

180
00:08:44,500 --> 00:08:47,949
interesting for me is that in server

181
00:08:47,949 --> 00:08:52,160
side you have the USB ap demon the

182
00:08:52,160 --> 00:08:53,930
demon which runs in the background can

183
00:08:53,930 --> 00:08:55,899
like providing the server functionality

184
00:08:55,899 --> 00:08:59,509
but on the client side when you issue

185
00:08:59,509 --> 00:09:01,970
both this comment the USB AP client

186
00:09:01,970 --> 00:09:04,910
Attila T exits immediately so if you

187
00:09:04,910 --> 00:09:08,029
kind of alike compare what I would

188
00:09:08,029 --> 00:09:11,209
expect from a framework like this to be

189
00:09:11,209 --> 00:09:14,209
implemented similar to a VPN solution so

190
00:09:14,209 --> 00:09:17,329
this is like how typical VPN work so

191
00:09:17,329 --> 00:09:19,519
basically how EPN works it takes the

192
00:09:19,519 --> 00:09:21,769
underlying network packets encapsulate

193
00:09:21,769 --> 00:09:27,589
them in like other packets and forward

194
00:09:27,589 --> 00:09:29,449
them the connection but the architecture

195
00:09:29,449 --> 00:09:33,560
is so both sides of the BB&T solution

196
00:09:33,560 --> 00:09:35,569
they have some kind of will be an agent

197
00:09:35,569 --> 00:09:36,500
in userspace

198
00:09:36,500 --> 00:09:39,019
which provides the VPN functionality

199
00:09:39,019 --> 00:09:41,540
they and those agents establish a secure

200
00:09:41,540 --> 00:09:44,329
tunnel between themselves and the kernel

201
00:09:44,329 --> 00:09:46,430
only provide this level function of

202
00:09:46,430 --> 00:09:48,199
getting the low-level data data

203
00:09:48,199 --> 00:09:50,540
structure and sending it to the other

204
00:09:50,540 --> 00:09:53,060
side and I was expecting the same

205
00:09:53,060 --> 00:09:57,079
architecture from usb ap but I noticed

206
00:09:57,079 --> 00:10:00,170
that USB ap is like utility it exits

207
00:10:00,170 --> 00:10:03,740
immediately and it doesn't have any

208
00:10:03,740 --> 00:10:07,370
agent running on the client system so I

209
00:10:07,370 --> 00:10:10,040
even tried to search for this agent but

210
00:10:10,040 --> 00:10:12,259
I have never I thought like maybe when

211
00:10:12,259 --> 00:10:14,569
you launch the USB AP client it it's

212
00:10:14,569 --> 00:10:16,880
like Forks and background and runs and

213
00:10:16,880 --> 00:10:19,550
keeps the device connected but there is

214
00:10:19,550 --> 00:10:24,620
no such engine and I was like what then

215
00:10:24,620 --> 00:10:26,120
I start digging into the source code

216
00:10:26,120 --> 00:10:30,290
turns out the under the hood the USB IP

217
00:10:30,290 --> 00:10:33,500
is implemented a bit differently so this

218
00:10:33,500 --> 00:10:37,279
is another perspective so what happens

219
00:10:37,279 --> 00:10:41,779
in reality when you ask the server to

220
00:10:41,779 --> 00:10:44,180
send you a list of exported devices the

221
00:10:44,180 --> 00:10:46,009
kernel is not involved in any way so

222
00:10:46,009 --> 00:10:49,459
just as the USB AP client utility sends

223
00:10:49,459 --> 00:10:51,350
a request to USB demon the demon

224
00:10:51,350 --> 00:10:53,720
maintains a list of exported devices in

225
00:10:53,720 --> 00:10:55,730
memory somewhere and just responds here

226
00:10:55,730 --> 00:10:58,790
are the devices you can import then the

227
00:10:58,790 --> 00:11:00,680
interesting part happens when you import

228
00:11:00,680 --> 00:11:04,009
the device so again a USB ap clients and

229
00:11:04,009 --> 00:11:05,840
the import requests to the server

230
00:11:05,840 --> 00:11:08,120
the server still verifies that this

231
00:11:08,120 --> 00:11:10,880
device has been exported sends the

232
00:11:10,880 --> 00:11:14,590
success request but later there is no

233
00:11:14,590 --> 00:11:18,830
user space communication happening on

234
00:11:18,830 --> 00:11:20,360
the client and the server what they do

235
00:11:20,360 --> 00:11:23,930
is they just pass the established socket

236
00:11:23,930 --> 00:11:26,360
file descriptor directly to the kernel

237
00:11:26,360 --> 00:11:30,470
and then kernel directly establishes

238
00:11:30,470 --> 00:11:35,470
this secure sorry not secure this tunnel

239
00:11:35,470 --> 00:11:39,110
yeah so basically there is no agent the

240
00:11:39,110 --> 00:11:44,450
agent is the kernel itself and and yeah

241
00:11:44,450 --> 00:11:47,210
the kernel handles all the communication

242
00:11:47,210 --> 00:11:52,520
between the USB ap and I will say was

243
00:11:52,520 --> 00:11:55,300
thinking wow this is probably scary and

244
00:11:55,300 --> 00:11:57,830
implementing application level protocol

245
00:11:57,830 --> 00:12:01,550
in kernel I know there is it's a bad

246
00:12:01,550 --> 00:12:03,500
practice in only one the popular

247
00:12:03,500 --> 00:12:05,960
operating system does it with HTTP and

248
00:12:05,960 --> 00:12:08,390
it's continuously source of bugs so I

249
00:12:08,390 --> 00:12:11,870
decided to send it sanity check the USB

250
00:12:11,870 --> 00:12:16,640
AP protocol so that brings out the next

251
00:12:16,640 --> 00:12:19,670
part the vulnerability and to understand

252
00:12:19,670 --> 00:12:21,170
the vulnerability I will briefly

253
00:12:21,170 --> 00:12:23,900
describe the USB AP application level

254
00:12:23,900 --> 00:12:27,350
protocol it's pretty easy and

255
00:12:27,350 --> 00:12:29,570
straightforward and it's documented in

256
00:12:29,570 --> 00:12:34,610
Linux kernel documentation and it's not

257
00:12:34,610 --> 00:12:36,500
any different than any other network

258
00:12:36,500 --> 00:12:39,560
protocol so it has a header section and

259
00:12:39,560 --> 00:12:44,060
the payload section and basically as any

260
00:12:44,060 --> 00:12:47,060
other network protocol this payload has

261
00:12:47,060 --> 00:12:49,459
some length and this length is a field

262
00:12:49,459 --> 00:12:51,350
in the header so what could be easier

263
00:12:51,350 --> 00:12:56,000
than that okay so if you look at the

264
00:12:56,000 --> 00:12:58,490
kernel code these are all the extracts

265
00:12:58,490 --> 00:13:02,900
so the receiving a USB IP packet on the

266
00:13:02,900 --> 00:13:05,660
client side from the server contains two

267
00:13:05,660 --> 00:13:08,680
basic steps one is parse the header and

268
00:13:08,680 --> 00:13:12,410
the second step is get the rest of the

269
00:13:12,410 --> 00:13:15,740
data from the network buffer so if you

270
00:13:15,740 --> 00:13:17,839
take a closer look at the parser header

271
00:13:17,839 --> 00:13:18,580
stage

272
00:13:18,580 --> 00:13:22,950
the code what the code does it just

273
00:13:22,950 --> 00:13:26,430
takes what it receives in the header and

274
00:13:26,430 --> 00:13:29,620
initializes struct you RB which is in

275
00:13:29,620 --> 00:13:34,269
kernel representation of the you RB in

276
00:13:34,269 --> 00:13:36,670
Linux kernels so basically it's not your

277
00:13:36,670 --> 00:13:39,370
ABAP specific it's the the structure

278
00:13:39,370 --> 00:13:41,620
which is used to inter interoperate with

279
00:13:41,620 --> 00:13:44,230
different USB subsystem and Linux kernel

280
00:13:44,230 --> 00:13:46,480
and the interesting point here we take

281
00:13:46,480 --> 00:13:49,000
this actual length and just analyze and

282
00:13:49,000 --> 00:13:51,910
just put it in the data structure then

283
00:13:51,910 --> 00:13:54,399
if you take a closer look at receive of

284
00:13:54,399 --> 00:13:56,680
the rest of the data portion you see

285
00:13:56,680 --> 00:13:59,260
that there is a local size variable

286
00:13:59,260 --> 00:14:01,360
which is initialized from this actual

287
00:14:01,360 --> 00:14:03,940
length and then the size variable is

288
00:14:03,940 --> 00:14:06,010
used to receive the rest of the data

289
00:14:06,010 --> 00:14:08,430
from the network buffer so basically

290
00:14:08,430 --> 00:14:12,040
because of this chain the size variable

291
00:14:12,040 --> 00:14:15,100
here is controlled it comes from the

292
00:14:15,100 --> 00:14:17,079
network and basically can be controlled

293
00:14:17,079 --> 00:14:21,130
by any attacker so technically if you

294
00:14:21,130 --> 00:14:24,610
put some data more than the receiving

295
00:14:24,610 --> 00:14:26,260
buffer can hold you get a buffer

296
00:14:26,260 --> 00:14:29,560
overflow that brings us to the

297
00:14:29,560 --> 00:14:31,390
conclusion that it is possible to write

298
00:14:31,390 --> 00:14:34,540
arbitrary length data to the Yerba

299
00:14:34,540 --> 00:14:37,420
transfer buffer so what is this transfer

300
00:14:37,420 --> 00:14:40,270
buffer Yorba transfer buffer is usually

301
00:14:40,270 --> 00:14:44,560
allocated by USB core code or USB device

302
00:14:44,560 --> 00:14:47,709
driver depending on who is from usb

303
00:14:47,709 --> 00:14:49,510
subsystem is the receiver of the your

304
00:14:49,510 --> 00:14:54,850
beam and technically because how USB

305
00:14:54,850 --> 00:14:57,940
protocol works USB protocol is always

306
00:14:57,940 --> 00:15:03,370
host to device so even though the data

307
00:15:03,370 --> 00:15:05,230
is being received from device to the

308
00:15:05,230 --> 00:15:07,839
host it still been done by the request

309
00:15:07,839 --> 00:15:09,760
from the horse so this buffer allocate

310
00:15:09,760 --> 00:15:13,870
is allocated even before the host or in

311
00:15:13,870 --> 00:15:16,240
USB AP terminal which is a client sends

312
00:15:16,240 --> 00:15:20,110
a request to the data so the code cannot

313
00:15:20,110 --> 00:15:24,430
assume cannot allocate this buffer after

314
00:15:24,430 --> 00:15:26,380
it receives the response so it cannot

315
00:15:26,380 --> 00:15:28,270
allocate large enough buffer to contain

316
00:15:28,270 --> 00:15:28,940
any data

317
00:15:28,940 --> 00:15:30,950
so USB protocol has a lot of these

318
00:15:30,950 --> 00:15:32,810
assumptions that the specific request

319
00:15:32,810 --> 00:15:39,950
will not be bigger than X and according

320
00:15:39,950 --> 00:15:42,050
to the USB a/b protocol the packet with

321
00:15:42,050 --> 00:15:44,420
large amount of data if totally valid so

322
00:15:44,420 --> 00:15:46,160
if you want for example to use some

323
00:15:46,160 --> 00:15:48,920
network analyzer to filter out these bad

324
00:15:48,920 --> 00:15:52,520
packets like like a network which scans

325
00:15:52,520 --> 00:15:54,110
for network vulnerability you won't be

326
00:15:54,110 --> 00:15:56,600
able to do that because from usb ap

327
00:15:56,600 --> 00:15:59,930
perspective this malformed large packet

328
00:15:59,930 --> 00:16:03,640
can is totally valid so ok you have like

329
00:16:03,640 --> 00:16:07,250
a big amount of you have a large number

330
00:16:07,250 --> 00:16:09,170
of the size portion and the header file

331
00:16:09,170 --> 00:16:11,210
but you have the same number of bytes in

332
00:16:11,210 --> 00:16:15,670
the data portion so it's no in any way

333
00:16:15,670 --> 00:16:18,530
invalid but your network analyzer does

334
00:16:18,530 --> 00:16:21,380
not know that probably the receiver side

335
00:16:21,380 --> 00:16:23,210
client buffer cannot contain so much

336
00:16:23,210 --> 00:16:27,800
data okay so this received the CBE

337
00:16:27,800 --> 00:16:33,980
number 2016 3 955 surprisingly to

338
00:16:33,980 --> 00:16:36,710
receive a very high cbss score it's

339
00:16:36,710 --> 00:16:40,370
almost 10 out of 10 and that's because

340
00:16:40,370 --> 00:16:42,680
for a number of reasons but probably

341
00:16:42,680 --> 00:16:45,500
because this is network exploitable and

342
00:16:45,500 --> 00:16:48,170
requires zero authentication to write

343
00:16:48,170 --> 00:16:51,280
arbitrary data to the kernel space and

344
00:16:51,280 --> 00:16:54,320
although i'm not a fan of giving names

345
00:16:54,320 --> 00:16:57,290
nicknames to vulnerabilities i find that

346
00:16:57,290 --> 00:16:59,690
like security researchers find it hard

347
00:16:59,690 --> 00:17:01,670
to remember cv numbers so i just came up

348
00:17:01,670 --> 00:17:04,189
with the name was called u-boat which

349
00:17:04,189 --> 00:17:06,790
stands for USB AP buffer overflow attack

350
00:17:06,790 --> 00:17:08,990
unfortunately I'm not a designer so I

351
00:17:08,990 --> 00:17:11,329
don't have a cool logo but if someone

352
00:17:11,329 --> 00:17:13,550
else wants to contribute a logo please

353
00:17:13,550 --> 00:17:19,970
send me an email okay we've seen the

354
00:17:19,970 --> 00:17:22,339
code might be a little bit confusing but

355
00:17:22,339 --> 00:17:25,849
the what's the conclusion is the

356
00:17:25,849 --> 00:17:28,369
architecture of USB ap it cannot be

357
00:17:28,369 --> 00:17:32,450
exploited easily thankfully so what are

358
00:17:32,450 --> 00:17:34,010
the requisite is the requisite is that

359
00:17:34,010 --> 00:17:37,070
your victim has to actually use usb AP

360
00:17:37,070 --> 00:17:40,520
in the first place because USB ap has

361
00:17:40,520 --> 00:17:41,809
been merged into mainline

362
00:17:41,809 --> 00:17:47,090
since version 3.17 and it's by default

363
00:17:47,090 --> 00:17:49,759
enabled in most major Linux distribution

364
00:17:49,759 --> 00:17:52,669
but the problem is by default it's

365
00:17:52,669 --> 00:17:55,399
compiled the modules are compiled as

366
00:17:55,399 --> 00:17:57,590
kernel separate kernel modules not in

367
00:17:57,590 --> 00:18:00,350
built kernel functionality and all USB

368
00:18:00,350 --> 00:18:02,840
AP tools explicitly load those modules

369
00:18:02,840 --> 00:18:04,879
when you start using this technology so

370
00:18:04,879 --> 00:18:08,049
technically if you don't use USB IP

371
00:18:08,049 --> 00:18:10,580
probably the modules are not loaded so

372
00:18:10,580 --> 00:18:12,019
probably you're safe because you don't

373
00:18:12,019 --> 00:18:14,440
have any vulnerable code in kernel

374
00:18:14,440 --> 00:18:17,299
victim has to be a client in USB AP

375
00:18:17,299 --> 00:18:19,820
terminologies basically the site which

376
00:18:19,820 --> 00:18:22,639
imports USB devices because the code

377
00:18:22,639 --> 00:18:24,529
pass is different from client and server

378
00:18:24,529 --> 00:18:27,279
and I haven't been able to find the same

379
00:18:27,279 --> 00:18:29,419
exploitation pass for the server side

380
00:18:29,419 --> 00:18:31,480
receiving code

381
00:18:31,480 --> 00:18:34,429
okay victim has to import at least one

382
00:18:34,429 --> 00:18:39,559
USB device so as we seen before there is

383
00:18:39,559 --> 00:18:42,830
a small handshake before the socket file

384
00:18:42,830 --> 00:18:44,779
the structure actually gets into the

385
00:18:44,779 --> 00:18:47,240
kernel so it happens only on successful

386
00:18:47,240 --> 00:18:49,700
import of one device so you an attacker

387
00:18:49,700 --> 00:18:52,100
have to somehow force the client or

388
00:18:52,100 --> 00:18:54,619
exploit an existing USB ap connection if

389
00:18:54,619 --> 00:18:57,139
the client does not import the device

390
00:18:57,139 --> 00:18:58,970
you don't have the socket and the kernel

391
00:18:58,970 --> 00:19:00,590
you can't exploit the vulnerable code

392
00:19:00,590 --> 00:19:04,279
and again as an attacker you have to

393
00:19:04,279 --> 00:19:07,999
either do a MMI TM to handcraft these

394
00:19:07,999 --> 00:19:11,629
big data payload packets or you have to

395
00:19:11,629 --> 00:19:14,570
somehow control USB IP server and make

396
00:19:14,570 --> 00:19:16,940
the servers and malicious package to the

397
00:19:16,940 --> 00:19:17,480
client

398
00:19:17,480 --> 00:19:24,440
Oh demo time okay okay just a moment

399
00:19:24,440 --> 00:19:25,090
please

400
00:19:25,090 --> 00:19:29,059
so the demo will involve like how you

401
00:19:29,059 --> 00:19:30,799
can break the clock you need a client

402
00:19:30,799 --> 00:19:32,629
and a server for the demo but again for

403
00:19:32,629 --> 00:19:35,629
the demo I will do it on a single host

404
00:19:35,629 --> 00:19:38,629
like on single virtual machine so this

405
00:19:38,629 --> 00:19:41,869
is like a standard this is a standard

406
00:19:41,869 --> 00:19:44,539
Ubuntu except it has an unpatched kernel

407
00:19:44,539 --> 00:19:48,850
so it's let me login

408
00:20:11,059 --> 00:20:15,470
that visible so for the demo purposes I

409
00:20:15,470 --> 00:20:17,990
imagined that I'm an attacker I won't do

410
00:20:17,990 --> 00:20:20,059
mi TM because it's a little bit harder

411
00:20:20,059 --> 00:20:23,149
so I imagine that I'm controlling the

412
00:20:23,149 --> 00:20:26,269
USB AP server so for that specific for

413
00:20:26,269 --> 00:20:28,759
this specific demo I wrote my own USB IP

414
00:20:28,759 --> 00:20:30,980
server which makes the default behavior

415
00:20:30,980 --> 00:20:34,309
but then sends malicious packets so I

416
00:20:34,309 --> 00:20:45,200
will start it tell me if I'm okay so the

417
00:20:45,200 --> 00:20:48,200
server is running now first we can

418
00:20:48,200 --> 00:20:57,980
verify that it works so sorry I don't

419
00:20:57,980 --> 00:21:00,850
see what I'm typing

420
00:21:06,090 --> 00:21:09,120
so let's first check which devices are

421
00:21:09,120 --> 00:21:12,409
exported on the server

422
00:21:19,559 --> 00:21:22,309
sorry

423
00:21:22,520 --> 00:21:26,440
okay let let me do like this

424
00:21:32,810 --> 00:21:35,530
okay

425
00:21:39,020 --> 00:21:42,260
so yeah we have logging here we see

426
00:21:42,260 --> 00:21:44,870
sending like the white list so I report

427
00:21:44,870 --> 00:21:47,630
to the clients that I'm exporting a very

428
00:21:47,630 --> 00:21:50,660
dangerous device with hardware passes

429
00:21:50,660 --> 00:21:53,450
five dangerous and with product and

430
00:21:53,450 --> 00:21:56,030
vendor ID of that beef and so nothing to

431
00:21:56,030 --> 00:21:57,670
worry about

432
00:21:57,670 --> 00:22:01,460
yeah so the client ah so yeah and as I

433
00:22:01,460 --> 00:22:03,590
mentioned like we want to import this

434
00:22:03,590 --> 00:22:06,620
device but before doing that we need to

435
00:22:06,620 --> 00:22:10,910
explicitly Lord USB ap kernel modules so

436
00:22:10,910 --> 00:22:13,570
I'll do that now

437
00:22:20,850 --> 00:22:26,370
password ok success this USB AP core and

438
00:22:26,370 --> 00:22:32,080
the virtual host controller interface ok

439
00:22:32,080 --> 00:22:34,780
so now we can import this device so

440
00:22:34,780 --> 00:22:48,570
that's we will say touch remote

441
00:22:51,600 --> 00:22:57,539
and the device ID 1/1 okay so it might

442
00:22:57,539 --> 00:23:01,879
crash the system or may not we'll see

443
00:23:02,179 --> 00:23:05,179
something is wrong right

444
00:23:05,179 --> 00:23:09,440
let me check sorry

445
00:23:14,179 --> 00:23:15,970
ah

446
00:23:15,970 --> 00:23:19,110
there is a space here

447
00:23:22,570 --> 00:23:25,800
okay one more try

448
00:23:47,480 --> 00:23:56,570
thank you yes yeah and this is what I

449
00:23:56,570 --> 00:23:58,039
wanted to mention that although to

450
00:23:58,039 --> 00:24:00,860
import you the funny thing is to import

451
00:24:00,860 --> 00:24:02,779
the USB device you should have like

452
00:24:02,779 --> 00:24:04,970
super user privileges but to run a fake

453
00:24:04,970 --> 00:24:07,850
USB ap server and crash other clients

454
00:24:07,850 --> 00:24:11,510
you can run it from normal user ok let's

455
00:24:11,510 --> 00:24:14,419
try it now oh ok so here we see server

456
00:24:14,419 --> 00:24:17,690
logging that the actual buffer of the

457
00:24:17,690 --> 00:24:21,110
receiver 64 byte but we sent him 576

458
00:24:21,110 --> 00:24:23,960
bytes and does it have so we see

459
00:24:23,960 --> 00:24:26,570
something happened right I'm not sure if

460
00:24:26,570 --> 00:24:31,460
it's if it's usable now let's try it's

461
00:24:31,460 --> 00:24:34,809
still live but sometimes it it fails

462
00:24:34,809 --> 00:24:42,500
immediately sometimes it fails later if

463
00:24:42,500 --> 00:24:44,720
I have found it usually fails when you

464
00:24:44,720 --> 00:24:50,269
want to see the mask okay so yeah we

465
00:24:50,269 --> 00:24:53,389
overwritten some weird data and we crash

466
00:24:53,389 --> 00:24:56,299
the server and nothing works anymore so

467
00:24:56,299 --> 00:25:00,919
it should say at some point yeah so it

468
00:25:00,919 --> 00:25:08,419
says like reboot is needed okay let's go

469
00:25:08,419 --> 00:25:11,049
back here

470
00:25:17,200 --> 00:25:20,260
okay so what can you do with that first

471
00:25:20,260 --> 00:25:21,940
of all you can do a denial of service

472
00:25:21,940 --> 00:25:24,490
attack which which is seen but you can

473
00:25:24,490 --> 00:25:26,260
try to do better than that so you can

474
00:25:26,260 --> 00:25:28,840
probably do data injection or even try

475
00:25:28,840 --> 00:25:31,410
to do code execution

476
00:25:31,410 --> 00:25:34,780
it's worse than note that here we have a

477
00:25:34,780 --> 00:25:37,030
standard hip exploit and you choose the

478
00:25:37,030 --> 00:25:40,030
random nature of hips code execution is

479
00:25:40,030 --> 00:25:42,220
rather hard when you have a keeper so it

480
00:25:42,220 --> 00:25:43,720
much harder than you have it when you

481
00:25:43,720 --> 00:25:45,910
have like stack memory overflow because

482
00:25:45,910 --> 00:25:48,100
instead just override the return address

483
00:25:48,100 --> 00:25:51,250
and you're good to go but in hip exploit

484
00:25:51,250 --> 00:25:53,470
it's much harder but it's still possible

485
00:25:53,470 --> 00:25:57,280
I will not describe the full process I

486
00:25:57,280 --> 00:25:59,710
will just reference to you to this blog

487
00:25:59,710 --> 00:26:03,910
post this blog post exploits another

488
00:26:03,910 --> 00:26:05,860
vulnerability which is also a hip

489
00:26:05,860 --> 00:26:07,900
exploit but it has a detailed

490
00:26:07,900 --> 00:26:10,570
step-by-step instruction what should you

491
00:26:10,570 --> 00:26:13,300
do to exploit to make code execution

492
00:26:13,300 --> 00:26:15,220
when you have a hip exploit it's a bit

493
00:26:15,220 --> 00:26:16,810
outdated it doesn't take into account

494
00:26:16,810 --> 00:26:19,560
recent kernel technologies like random

495
00:26:19,560 --> 00:26:23,380
address and rest on the musician and

496
00:26:23,380 --> 00:26:25,090
other security mechanism but still

497
00:26:25,090 --> 00:26:27,460
doable and adaptable to the current

498
00:26:27,460 --> 00:26:31,200
state of the art exploit development I

499
00:26:31,200 --> 00:26:33,820
will briefly this but I will briefly

500
00:26:33,820 --> 00:26:36,370
describe the high-level overview how you

501
00:26:36,370 --> 00:26:40,240
manage what what's the difference

502
00:26:40,240 --> 00:26:44,560
between this exploit and other potential

503
00:26:44,560 --> 00:26:46,360
hip explode out there in the Linux

504
00:26:46,360 --> 00:26:48,210
kernel turns out the USB AP

505
00:26:48,210 --> 00:26:50,230
vulnerability gives an attacker much

506
00:26:50,230 --> 00:26:55,150
more possibilities we'll see in in a

507
00:26:55,150 --> 00:26:58,540
second why so when when you have a hip

508
00:26:58,540 --> 00:27:00,910
exploit so you have to understand how

509
00:27:00,910 --> 00:27:04,510
Linux memory manager works and this is

510
00:27:04,510 --> 00:27:07,300
like the basic stuff so how it works is

511
00:27:07,300 --> 00:27:10,630
that Linux resolves some portion of

512
00:27:10,630 --> 00:27:13,390
memory some addresses and blood breaks

513
00:27:13,390 --> 00:27:16,150
them into equal pieces which are called

514
00:27:16,150 --> 00:27:19,180
slab caches so we have like a slab cache

515
00:27:19,180 --> 00:27:22,360
of 32 we have slab cache 64 which is a

516
00:27:22,360 --> 00:27:25,420
chunks of 64 bytes and we have a slab

517
00:27:25,420 --> 00:27:28,780
cache 128 which are equal chunks on 128

518
00:27:28,780 --> 00:27:30,020
bytes

519
00:27:30,020 --> 00:27:32,300
and it doesn't have to be a power of 2

520
00:27:32,300 --> 00:27:34,010
there are slop caches in between it's

521
00:27:34,010 --> 00:27:36,470
just for illustration purposes and when

522
00:27:36,470 --> 00:27:39,590
your code says like okay I need to

523
00:27:39,590 --> 00:27:43,850
allocate let's say 28 bytes actually

524
00:27:43,850 --> 00:27:45,710
under the hood the colonel will search

525
00:27:45,710 --> 00:27:47,540
for the next available slot in the

526
00:27:47,540 --> 00:27:50,180
smallish lab cache available so in this

527
00:27:50,180 --> 00:27:54,350
point it will it will select a slab

528
00:27:54,350 --> 00:27:57,800
cache 32 and just return you the pointer

529
00:27:57,800 --> 00:28:00,350
to that piece of memory so basically you

530
00:28:00,350 --> 00:28:02,720
always get a little bit more than you

531
00:28:02,720 --> 00:28:05,300
request but as long as not less so it's

532
00:28:05,300 --> 00:28:08,770
fine so what does it mean to have an

533
00:28:08,770 --> 00:28:12,440
exploit where you can overwrite past

534
00:28:12,440 --> 00:28:15,020
some boundary buffers what it means that

535
00:28:15,020 --> 00:28:19,040
you can technically write anything into

536
00:28:19,040 --> 00:28:21,050
your buffer and all the buffers which

537
00:28:21,050 --> 00:28:26,590
happen to be after your buffer and and

538
00:28:26,590 --> 00:28:29,660
it's based on your luck or how you

539
00:28:29,660 --> 00:28:32,060
approach the exploit development so

540
00:28:32,060 --> 00:28:34,370
what's in that buffer so probably these

541
00:28:34,370 --> 00:28:36,590
other pieces were allocated to other

542
00:28:36,590 --> 00:28:38,810
kernel subsystems at some point and if

543
00:28:38,810 --> 00:28:41,540
you're lucky that the adjunct and pieces

544
00:28:41,540 --> 00:28:43,490
contains some kernel control structures

545
00:28:43,490 --> 00:28:46,820
or address pointers you can technically

546
00:28:46,820 --> 00:28:48,680
override them with your values and

547
00:28:48,680 --> 00:28:50,750
change the code execution of some kernel

548
00:28:50,750 --> 00:28:55,510
subsystem do the exploitation

549
00:28:58,350 --> 00:29:02,710
so but the way how us be a bit different

550
00:29:02,710 --> 00:29:05,049
is that the usually normal kernel

551
00:29:05,049 --> 00:29:07,390
exploits are designed in a way they they

552
00:29:07,390 --> 00:29:09,520
can only exploit a single slab cache

553
00:29:09,520 --> 00:29:11,650
that means somebody has a vulnerable

554
00:29:11,650 --> 00:29:15,159
code which can override only slab 32

555
00:29:15,159 --> 00:29:19,950
crashes or slop 128 cache so you have to

556
00:29:19,950 --> 00:29:22,270
build your attack based on that

557
00:29:22,270 --> 00:29:25,120
assumption USB ap vulnerability gives

558
00:29:25,120 --> 00:29:27,640
you much more flexibility in this

559
00:29:27,640 --> 00:29:30,399
because technically because you control

560
00:29:30,399 --> 00:29:34,299
the USB IP protocol the USB packets were

561
00:29:34,299 --> 00:29:35,919
which you sent to the client you can

562
00:29:35,919 --> 00:29:38,590
technically emulate any USB device on

563
00:29:38,590 --> 00:29:41,770
the client side and because the kernel

564
00:29:41,770 --> 00:29:44,380
has a lot of different USB AP drivers

565
00:29:44,380 --> 00:29:46,600
you don't have to necessarily exploit

566
00:29:46,600 --> 00:29:48,669
the first packet you receive you can

567
00:29:48,669 --> 00:29:51,340
just scan the kernel source code and

568
00:29:51,340 --> 00:29:54,760
find this so yes this is what the list

569
00:29:54,760 --> 00:29:59,740
says so - you can literally select which

570
00:29:59,740 --> 00:30:01,659
ever cache you want to exploit so you

571
00:30:01,659 --> 00:30:04,270
you're not bound to the and you can

572
00:30:04,270 --> 00:30:06,669
exploit almost any dynamic data

573
00:30:06,669 --> 00:30:08,289
structure in the kernel so what you have

574
00:30:08,289 --> 00:30:14,320
to do is you just scan the USB USB Drive

575
00:30:14,320 --> 00:30:16,210
all the USB drivers available in

576
00:30:16,210 --> 00:30:18,850
mainline Linux kernel and find the ones

577
00:30:18,850 --> 00:30:22,090
which are locate buffers in the slab

578
00:30:22,090 --> 00:30:25,360
cache of everything okay

579
00:30:25,360 --> 00:30:29,559
and and find and find devices which

580
00:30:29,559 --> 00:30:31,750
allocate buffers in your desired slop

581
00:30:31,750 --> 00:30:33,250
cache is the one you want to exploit

582
00:30:33,250 --> 00:30:37,240
then you don't you not necessarily send

583
00:30:37,240 --> 00:30:38,860
the militia packets at once but you

584
00:30:38,860 --> 00:30:41,860
emulate the full USB protocol and trick

585
00:30:41,860 --> 00:30:45,370
the client that you're that specific

586
00:30:45,370 --> 00:30:47,260
device of your interest so the clients

587
00:30:47,260 --> 00:30:49,029
you dev subsystem will probably lower

588
00:30:49,029 --> 00:30:51,220
the appropriate device driver on the

589
00:30:51,220 --> 00:30:53,049
client subsystem and that device driver

590
00:30:53,049 --> 00:30:55,600
will start allocating memory in the slab

591
00:30:55,600 --> 00:30:57,730
cache of your desire and then you do

592
00:30:57,730 --> 00:31:00,669
your overflow so you can you're not

593
00:31:00,669 --> 00:31:02,799
constrained you if you want to attack a

594
00:31:02,799 --> 00:31:06,100
specific data data structure which is

595
00:31:06,100 --> 00:31:08,080
allocated only in specific slab - you

596
00:31:08,080 --> 00:31:09,610
are not considered constrained by this

597
00:31:09,610 --> 00:31:11,290
exploit so you can adapt your

598
00:31:11,290 --> 00:31:13,360
Floyd to target a specific data

599
00:31:13,360 --> 00:31:20,850
structure okay still want to use usb IP

600
00:31:20,850 --> 00:31:24,790
yeah if you do want to use here are some

601
00:31:24,790 --> 00:31:25,330
tips

602
00:31:25,330 --> 00:31:28,870
first of all reconsider so what are the

603
00:31:28,870 --> 00:31:31,630
advantages so today's USB devices are

604
00:31:31,630 --> 00:31:33,340
rather cheap of Union just buy another

605
00:31:33,340 --> 00:31:36,220
one if your targets you just share a USB

606
00:31:36,220 --> 00:31:40,420
device second one patch your system

607
00:31:40,420 --> 00:31:44,080
patch often it does not relate only to

608
00:31:44,080 --> 00:31:46,000
this vulnerabilities vulnerabilities are

609
00:31:46,000 --> 00:31:49,300
discovered every day bad and worse so

610
00:31:49,300 --> 00:31:51,190
you have to stay on top of security

611
00:31:51,190 --> 00:31:55,090
patches protect your traffic the funny

612
00:31:55,090 --> 00:31:57,760
thing is the whole project provides even

613
00:31:57,760 --> 00:31:59,920
even if you don't have the vulnerability

614
00:31:59,920 --> 00:32:03,910
in USB IP subsystem technically you

615
00:32:03,910 --> 00:32:06,910
still have very dangerous framework

616
00:32:06,910 --> 00:32:10,570
because if I if I'm an attacker and I am

617
00:32:10,570 --> 00:32:13,480
able to hijacked an even valid USB IP

618
00:32:13,480 --> 00:32:15,970
connection I can emulate any USB device

619
00:32:15,970 --> 00:32:20,110
on the client subsystem and luckily

620
00:32:20,110 --> 00:32:23,650
today we all all hurt we all listen to

621
00:32:23,650 --> 00:32:24,910
the talk this morning about the

622
00:32:24,910 --> 00:32:27,790
dangerous USB devices and how much harm

623
00:32:27,790 --> 00:32:30,220
they can do but the main constraint

624
00:32:30,220 --> 00:32:33,400
there was that you have to have physical

625
00:32:33,400 --> 00:32:35,320
access to the machine you want to

626
00:32:35,320 --> 00:32:37,360
exploit but this framework just removes

627
00:32:37,360 --> 00:32:39,550
that constraint so you can now do the

628
00:32:39,550 --> 00:32:42,130
same USB attacks like for physical

629
00:32:42,130 --> 00:32:44,290
devices but over network without 0 on

630
00:32:44,290 --> 00:32:47,950
the k10 occation and original USB AP

631
00:32:47,950 --> 00:32:49,690
project maybe because it's all does not

632
00:32:49,690 --> 00:32:52,990
even recommend you in any way to somehow

633
00:32:52,990 --> 00:32:54,760
protect your traffic and it does not

634
00:32:54,760 --> 00:32:56,890
have any the user space tools do not

635
00:32:56,890 --> 00:32:58,780
have any inbuilt capabilities of

636
00:32:58,780 --> 00:33:00,970
securing your traffic so definitely

637
00:33:00,970 --> 00:33:04,390
protect use TLS or IPSec and even in

638
00:33:04,390 --> 00:33:07,630
internet because people say ok my

639
00:33:07,630 --> 00:33:10,000
internal network is inaccessible and

640
00:33:10,000 --> 00:33:12,640
it's secure but you have tons of IOT

641
00:33:12,640 --> 00:33:15,100
devices and we know how how good a IOT

642
00:33:15,100 --> 00:33:20,230
devices are at security so and

643
00:33:20,230 --> 00:33:24,080
lastly ensure you USB ap server is trust

644
00:33:24,080 --> 00:33:26,690
worth to trustworthy and pro with proper

645
00:33:26,690 --> 00:33:29,150
ACL so if an attacker cannot hijacked

646
00:33:29,150 --> 00:33:32,090
the connection between UN and the you as

647
00:33:32,090 --> 00:33:34,580
a USB AP client and the server so high

648
00:33:34,580 --> 00:33:36,460
the attacker would definitely try to

649
00:33:36,460 --> 00:33:39,290
hijack the server itself and do and try

650
00:33:39,290 --> 00:33:42,760
to make it send you malicious payload so

651
00:33:42,760 --> 00:33:46,280
control locking down USB ap server is

652
00:33:46,280 --> 00:33:49,070
also very important here are some

653
00:33:49,070 --> 00:33:51,590
resources this is the first link is to

654
00:33:51,590 --> 00:33:54,830
is link to my blog post describing this

655
00:33:54,830 --> 00:33:57,130
vulnerability in more details so it has

656
00:33:57,130 --> 00:33:59,720
exact references to the next source code

657
00:33:59,720 --> 00:34:01,580
where the patch is if you want to follow

658
00:34:01,580 --> 00:34:05,330
please do the second one is a source

659
00:34:05,330 --> 00:34:08,469
code of my malicious demo server

660
00:34:08,469 --> 00:34:10,969
originally wrote it in C it was very

661
00:34:10,969 --> 00:34:13,790
ugly so I decided to rewrite it and go

662
00:34:13,790 --> 00:34:16,270
and now it's very easy to understand and

663
00:34:16,270 --> 00:34:20,630
you can adapt it to your needs the third

664
00:34:20,630 --> 00:34:23,989
one is a link to the AC V database which

665
00:34:23,989 --> 00:34:26,630
describes the vulnerability and it

666
00:34:26,630 --> 00:34:28,940
actually has a breakdown why the

667
00:34:28,940 --> 00:34:31,820
vulnerability received so high severity

668
00:34:31,820 --> 00:34:38,000
score sorry so the short link just

669
00:34:38,000 --> 00:34:39,469
describes the vulnerability and the

670
00:34:39,469 --> 00:34:41,630
fourth link describes a breakdown why

671
00:34:41,630 --> 00:34:45,889
the vulnerability received so high CB SS

672
00:34:45,889 --> 00:34:48,230
core so basically as I will repeat it

673
00:34:48,230 --> 00:34:50,389
because it's network exploitable and

674
00:34:50,389 --> 00:34:52,489
requires zero authentication and there

675
00:34:52,489 --> 00:34:56,239
is no like traffic encryption that's it

676
00:34:56,239 --> 00:34:57,750
thank you

677
00:34:57,750 --> 00:35:03,260
[Applause]

