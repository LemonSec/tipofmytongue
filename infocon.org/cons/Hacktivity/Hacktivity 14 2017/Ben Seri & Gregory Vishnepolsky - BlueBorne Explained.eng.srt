1
00:00:00,030 --> 00:00:04,140
okay hi everyone we're going to talk a

2
00:00:04,140 --> 00:00:06,210
bit today about blue born maybe you've

3
00:00:06,210 --> 00:00:08,130
heard of it it's a research that we have

4
00:00:08,130 --> 00:00:12,240
done in the last year my name is Ben

5
00:00:12,240 --> 00:00:13,950
sorry I'm the head of research at Armas

6
00:00:13,950 --> 00:00:18,690
and I'm Greg I also work at Thomas an

7
00:00:18,690 --> 00:00:21,570
Armas the company we work in is an

8
00:00:21,570 --> 00:00:23,640
agentless IOT security company that

9
00:00:23,640 --> 00:00:26,250
allows business to discover profile

10
00:00:26,250 --> 00:00:29,400
sanction their devices in their own

11
00:00:29,400 --> 00:00:34,489
environment and since IT devices usually

12
00:00:34,489 --> 00:00:37,770
communicate not only in Wi-Fi but in

13
00:00:37,770 --> 00:00:39,500
other protocols we we came across

14
00:00:39,500 --> 00:00:42,989
researching bluetooth specifically to

15
00:00:42,989 --> 00:00:46,530
understand that and to better develop

16
00:00:46,530 --> 00:00:49,829
security mechanisms for it in our in our

17
00:00:49,829 --> 00:00:53,760
system so in that aspect when we were

18
00:00:53,760 --> 00:00:56,760
researching bluetooth we came across a

19
00:00:56,760 --> 00:00:58,379
wide variety of vulnerabilities

20
00:00:58,379 --> 00:01:02,449
including different operating systems

21
00:01:03,860 --> 00:01:06,840
this actually is somewhat of a new

22
00:01:06,840 --> 00:01:10,380
attack vector in a sense that it really

23
00:01:10,380 --> 00:01:13,260
allows a wide variety of attacks to be

24
00:01:13,260 --> 00:01:15,540
performed against a wide variety of

25
00:01:15,540 --> 00:01:18,180
operating systems it effects well it's

26
00:01:18,180 --> 00:01:19,560
used to affect but it still affects a

27
00:01:19,560 --> 00:01:22,439
large number of devices around 5.3

28
00:01:22,439 --> 00:01:25,890
billion devices like I said it's a set

29
00:01:25,890 --> 00:01:27,330
of vulnerabilities it's a drone

30
00:01:27,330 --> 00:01:29,820
abilities and four of them are critical

31
00:01:29,820 --> 00:01:31,439
vulnerabilities because it allows remote

32
00:01:31,439 --> 00:01:32,520
code execution

33
00:01:32,520 --> 00:01:35,780
it affects Android Windows Linux and iOS

34
00:01:35,780 --> 00:01:38,579
and it is most severe or serious

35
00:01:38,579 --> 00:01:41,400
Bluetooth abilities in these tasks in

36
00:01:41,400 --> 00:01:46,200
the last 10 years or so this is

37
00:01:46,200 --> 00:01:48,390
primarily because these attacks do not

38
00:01:48,390 --> 00:01:50,840
require any user interaction or

39
00:01:50,840 --> 00:01:53,729
authentication the devices don't need to

40
00:01:53,729 --> 00:01:56,070
be paired for the attack to take place

41
00:01:56,070 --> 00:01:58,380
and also because it enables a wide

42
00:01:58,380 --> 00:02:01,350
variety of vulnerabilities and options

43
00:02:01,350 --> 00:02:03,659
for an attacker either the remote code

44
00:02:03,659 --> 00:02:06,840
is probabilities there are four of these

45
00:02:06,840 --> 00:02:08,818
the man in the middle of our abilities

46
00:02:08,818 --> 00:02:10,639
that

47
00:02:10,639 --> 00:02:12,680
something similar to the Wi-Fi pineapple

48
00:02:12,680 --> 00:02:15,170
only over Bluetooth and information

49
00:02:15,170 --> 00:02:17,570
leaks that are also very important when

50
00:02:17,570 --> 00:02:19,820
attackers in order to bypass mitigations

51
00:02:19,820 --> 00:02:22,280
and we're going to talk about this in

52
00:02:22,280 --> 00:02:25,850
this talk specifically as well like you

53
00:02:25,850 --> 00:02:29,740
can see in this graph here it's very

54
00:02:29,740 --> 00:02:37,160
visually clean and simple all around the

55
00:02:37,160 --> 00:02:39,520
Bluetooth Jack we found vulnerabilities

56
00:02:39,520 --> 00:02:41,840
these are not the same wall abilities in

57
00:02:41,840 --> 00:02:43,459
each operating system it affects each

58
00:02:43,459 --> 00:02:46,490
bit of stat bit differently but we have

59
00:02:46,490 --> 00:02:49,760
the for our CES this there is one in the

60
00:02:49,760 --> 00:02:51,500
eldercare player I don't know if it can

61
00:02:51,500 --> 00:02:55,160
be actually detected but in Linux there

62
00:02:55,160 --> 00:02:58,220
are 2 RC volatilities in Android one in

63
00:02:58,220 --> 00:03:00,500
the beam up service and one in the pan

64
00:03:00,500 --> 00:03:03,920
profile we have one eye or SRC and

65
00:03:03,920 --> 00:03:06,410
prepare to work all of Apple that's

66
00:03:06,410 --> 00:03:09,770
called leap and to manage metal

67
00:03:09,770 --> 00:03:11,300
solubilities one effecting elevate and

68
00:03:11,300 --> 00:03:13,430
one in Windows that are also in the

69
00:03:13,430 --> 00:03:15,310
Panther file and two information leaks

70
00:03:15,310 --> 00:03:18,110
in the SDP service that we're also going

71
00:03:18,110 --> 00:03:21,440
to describe there was effects Linux in

72
00:03:21,440 --> 00:03:26,060
Android today specifically we're going

73
00:03:26,060 --> 00:03:27,799
to talk about the Android or abilities

74
00:03:27,799 --> 00:03:31,299
and the exploitation of the RC

75
00:03:31,299 --> 00:03:33,799
vulnerability in Android so we're going

76
00:03:33,799 --> 00:03:35,060
to start a bit with background on

77
00:03:35,060 --> 00:03:36,170
Bluetooth and what is needed to

78
00:03:36,170 --> 00:03:38,090
understand to exploit these

79
00:03:38,090 --> 00:03:40,040
vulnerabilities and then we're going to

80
00:03:40,040 --> 00:03:41,450
talk about the process of exploitation

81
00:03:41,450 --> 00:03:43,970
for the Android I ve and we're going to

82
00:03:43,970 --> 00:03:45,799
describe two vulnerabilities that we

83
00:03:45,799 --> 00:03:48,010
needed to achieve this one is the SDP

84
00:03:48,010 --> 00:03:51,140
information leak vulnerability that is

85
00:03:51,140 --> 00:03:53,390
used to bypass mitigation bypass is

86
00:03:53,390 --> 00:03:55,730
alarm and the second one is the B net

87
00:03:55,730 --> 00:03:56,959
that is the service of you're going to

88
00:03:56,959 --> 00:04:00,350
discuss in in the Buddhist stack which

89
00:04:00,350 --> 00:04:03,739
we found our C vulnerability and how we

90
00:04:03,739 --> 00:04:05,060
exploited I didn't what the process

91
00:04:05,060 --> 00:04:07,340
needed and lastly if all goes well and

92
00:04:07,340 --> 00:04:09,620
the setup here is and the gods are with

93
00:04:09,620 --> 00:04:11,540
us we're going to do a live demo showing

94
00:04:11,540 --> 00:04:17,470
this as well so I want to start first by

95
00:04:17,470 --> 00:04:20,930
tackling an issue that has some common

96
00:04:20,930 --> 00:04:22,290
misconceptions about it

97
00:04:22,290 --> 00:04:24,930
and that is discoverability and you

98
00:04:24,930 --> 00:04:26,910
might have heard of this concept this is

99
00:04:26,910 --> 00:04:30,210
a term in Bluetooth discuss discoverable

100
00:04:30,210 --> 00:04:33,480
Bluetooth has a mode both devices have a

101
00:04:33,480 --> 00:04:35,520
mode in which they can be found by other

102
00:04:35,520 --> 00:04:37,200
devices around them that is discoverable

103
00:04:37,200 --> 00:04:40,890
mode and it is usually thought of that a

104
00:04:40,890 --> 00:04:42,450
MAC address of ability of device can

105
00:04:42,450 --> 00:04:44,430
only be found when they are in this node

106
00:04:44,430 --> 00:04:46,890
this actually not true and there have

107
00:04:46,890 --> 00:04:48,930
been a pair Awards it's not this is not

108
00:04:48,930 --> 00:04:50,580
something that we made off that we

109
00:04:50,580 --> 00:04:54,020
invented but there have been prior work

110
00:04:54,020 --> 00:04:56,430
showing how MAC addresses both devices

111
00:04:56,430 --> 00:04:59,430
can be found it so it starts by the fact

112
00:04:59,430 --> 00:05:01,380
that Bluetooth devices transmits power

113
00:05:01,380 --> 00:05:04,920
of the Mac the LEP over the air each

114
00:05:04,920 --> 00:05:07,830
time they send packets and once you

115
00:05:07,830 --> 00:05:09,450
sniff one packet of Bluetooth tag I

116
00:05:09,450 --> 00:05:11,480
would have packet you can boot force

117
00:05:11,480 --> 00:05:14,190
another powder from Mac the Mac pretty

118
00:05:14,190 --> 00:05:15,450
easily because there are only three

119
00:05:15,450 --> 00:05:18,450
options and actually only only need two

120
00:05:18,450 --> 00:05:22,340
parts of the Mac in order to in order to

121
00:05:22,340 --> 00:05:24,450
to communicate with the Brutes of device

122
00:05:24,450 --> 00:05:26,400
there is actually an open source tool

123
00:05:26,400 --> 00:05:28,440
that does exactly this it's called uber

124
00:05:28,440 --> 00:05:31,440
tooth and the research around it has

125
00:05:31,440 --> 00:05:33,240
done a lot of work in the mystifying the

126
00:05:33,240 --> 00:05:36,870
discoverability and generally the

127
00:05:36,870 --> 00:05:38,310
mystifying the lower layers of Bluetooth

128
00:05:38,310 --> 00:05:40,740
the files that link layers this still

129
00:05:40,740 --> 00:05:43,800
just allows of automatically for

130
00:05:43,800 --> 00:05:46,530
attackers to find and discover maximum

131
00:05:46,530 --> 00:05:48,510
access power of the devices are not in

132
00:05:48,510 --> 00:05:51,300
discoverable mode so this is one

133
00:05:51,300 --> 00:05:52,620
approach for an attacker in order to

134
00:05:52,620 --> 00:05:54,720
find a MAC address of a beautiful device

135
00:05:54,720 --> 00:05:56,310
another one is just use standard

136
00:05:56,310 --> 00:05:59,280
Bluetooth chips that you have in Europe

137
00:05:59,280 --> 00:06:02,130
enable devices with some firm

138
00:06:02,130 --> 00:06:04,170
identification this is this was done in

139
00:06:04,170 --> 00:06:07,320
the past it does require some research

140
00:06:07,320 --> 00:06:09,810
to do this today because the chips are

141
00:06:09,810 --> 00:06:13,170
different but it can be done and there

142
00:06:13,170 --> 00:06:14,760
is another very simple trick that can be

143
00:06:14,760 --> 00:06:16,890
used by attackers is and that is the

144
00:06:16,890 --> 00:06:20,400
fact that today a lot of chips wireless

145
00:06:20,400 --> 00:06:22,200
communication tips use the Wi-Fi and

146
00:06:22,200 --> 00:06:24,630
Bluetooth in the sanctuary m's

147
00:06:24,630 --> 00:06:27,270
tend to have the MAC addresses of Wi-Fi

148
00:06:27,270 --> 00:06:29,580
and Bluetooth adjacent to one another so

149
00:06:29,580 --> 00:06:31,590
if you have going into monitor mode in

150
00:06:31,590 --> 00:06:33,780
Wi-Fi you can find the Wi-Fi MAC address

151
00:06:33,780 --> 00:06:34,289
but

152
00:06:34,289 --> 00:06:36,830
not but he's plaintext over-the-air and

153
00:06:36,830 --> 00:06:39,059
adjacent MAC address of the blue

154
00:06:39,059 --> 00:06:41,309
beautiful device just by going plus or

155
00:06:41,309 --> 00:06:44,309
minus 1 of that device on top of all of

156
00:06:44,309 --> 00:06:44,610
this

157
00:06:44,610 --> 00:06:47,039
mr. ability is not a prerequisite in

158
00:06:47,039 --> 00:06:48,839
order to establish a connection the

159
00:06:48,839 --> 00:06:50,309
rooted device is always listening to

160
00:06:50,309 --> 00:06:52,050
internet connections even if it's not in

161
00:06:52,050 --> 00:06:54,869
discoverable mode so having found the

162
00:06:54,869 --> 00:06:56,610
MAC address using one of these

163
00:06:56,610 --> 00:06:58,979
techniques in attack we can then go on

164
00:06:58,979 --> 00:07:01,439
and attack device or communicate with a

165
00:07:01,439 --> 00:07:02,520
device that is not in this couple of

166
00:07:02,520 --> 00:07:05,639
world but it is complicated it's

167
00:07:05,639 --> 00:07:07,319
actually twenty eight hundred pages long

168
00:07:07,319 --> 00:07:09,959
with speck alone some of the pages look

169
00:07:09,959 --> 00:07:14,969
like that this this specific page shows

170
00:07:14,969 --> 00:07:17,279
the four layers of fragmentation that

171
00:07:17,279 --> 00:07:18,899
exist in the lower layers of Bluetooth

172
00:07:18,899 --> 00:07:20,759
this is before the application layer

173
00:07:20,759 --> 00:07:22,610
shows there were there are other

174
00:07:22,610 --> 00:07:26,039
permutations of above it and it does

175
00:07:26,039 --> 00:07:28,469
really a poor job in the in the sense

176
00:07:28,469 --> 00:07:30,719
that each we implements a lot of

177
00:07:30,719 --> 00:07:32,399
features over and over again there is no

178
00:07:32,399 --> 00:07:33,360
reason to have four areas of

179
00:07:33,360 --> 00:07:37,339
fragmentation one is quickly free enough

180
00:07:38,209 --> 00:07:41,879
this flow chart here it only shows that

181
00:07:41,879 --> 00:07:45,180
what does a stack look like it's a big

182
00:07:45,180 --> 00:07:48,389
chunk of protocols combined together it

183
00:07:48,389 --> 00:07:51,539
is actually a sampler in a completely do

184
00:07:51,539 --> 00:07:54,120
off seven layer model or the tcp/ip

185
00:07:54,120 --> 00:07:56,129
model it doesn't use standard protocols

186
00:07:56,129 --> 00:07:58,019
that implements the its own for each

187
00:07:58,019 --> 00:08:01,529
step of step in the way the green one on

188
00:08:01,529 --> 00:08:03,449
the in the middle there is the l2 cap

189
00:08:03,449 --> 00:08:06,599
layer which is the Buddhist equivalent

190
00:08:06,599 --> 00:08:10,469
of TCP it is used to open connections

191
00:08:10,469 --> 00:08:13,379
have some quality of service in them to

192
00:08:13,379 --> 00:08:15,269
specific services in there all those the

193
00:08:15,269 --> 00:08:19,349
layer above it account you can see it's

194
00:08:19,349 --> 00:08:21,800
a very wide attack surface a lot of

195
00:08:21,800 --> 00:08:25,229
services are run inside its stack that

196
00:08:25,229 --> 00:08:28,289
can be targeted and specifically we

197
00:08:28,289 --> 00:08:29,819
wanted to start with the one that is

198
00:08:29,819 --> 00:08:32,389
marked during the word that's the SDP

199
00:08:32,389 --> 00:08:35,659
service SDP is Bluetooth

200
00:08:35,659 --> 00:08:38,519
service discovery protocol it is used to

201
00:08:38,519 --> 00:08:41,188
discover and what services what other

202
00:08:41,188 --> 00:08:43,860
services other than SDP are listening on

203
00:08:43,860 --> 00:08:47,040
a specific device so by design it has no

204
00:08:47,040 --> 00:08:48,200
effect ocation

205
00:08:48,200 --> 00:08:49,459
because it is the first step in

206
00:08:49,459 --> 00:08:51,380
communicating devices to find what other

207
00:08:51,380 --> 00:08:53,870
what other services are available inside

208
00:08:53,870 --> 00:08:56,450
the stack the way it works is very

209
00:08:56,450 --> 00:08:58,310
simple you have a client this is one of

210
00:08:58,310 --> 00:09:00,560
the devices in a server that is the

211
00:09:00,560 --> 00:09:03,139
other and the client will probe will

212
00:09:03,139 --> 00:09:04,459
send request to the server

213
00:09:04,459 --> 00:09:07,970
searching for services on that server or

214
00:09:07,970 --> 00:09:10,040
requesting more info on that server and

215
00:09:10,040 --> 00:09:12,380
the server then respond with details on

216
00:09:12,380 --> 00:09:16,040
that service in the case that the

217
00:09:16,040 --> 00:09:18,230
response of the server is larger than a

218
00:09:18,230 --> 00:09:20,529
single routed packet yet another

219
00:09:20,529 --> 00:09:24,440
fermentation exists in STP as if

220
00:09:24,440 --> 00:09:25,940
continuation is the name of this

221
00:09:25,940 --> 00:09:28,550
fermentation mechanism that is

222
00:09:28,550 --> 00:09:30,709
implemented in SDP on top of other

223
00:09:30,709 --> 00:09:34,880
limitation levels that are below it the

224
00:09:34,880 --> 00:09:36,290
right works is actually different than

225
00:09:36,290 --> 00:09:39,320
usual fermentation because in this case

226
00:09:39,320 --> 00:09:41,000
the client needs to send the initial

227
00:09:41,000 --> 00:09:43,670
request and then in order to receive

228
00:09:43,670 --> 00:09:46,399
more fragmenting it needs to send again

229
00:09:46,399 --> 00:09:48,170
they request over and over again until

230
00:09:48,170 --> 00:09:49,850
he receives all the fragments back

231
00:09:49,850 --> 00:09:52,339
action on the server what you can see

232
00:09:52,339 --> 00:09:54,980
there is that the server appends a

233
00:09:54,980 --> 00:09:56,990
continuation stage that's the con state

234
00:09:56,990 --> 00:09:59,360
to each of the response ins is its end

235
00:09:59,360 --> 00:10:01,430
and that continuation set is actually

236
00:10:01,430 --> 00:10:04,279
the internal state of the server as to

237
00:10:04,279 --> 00:10:06,860
where he is inside the full response

238
00:10:06,860 --> 00:10:09,320
that he wants to send the client will

239
00:10:09,320 --> 00:10:12,380
then add the continuation state to each

240
00:10:12,380 --> 00:10:16,070
request he he sends in order to get an

241
00:10:16,070 --> 00:10:18,019
other fragment and that was us will go

242
00:10:18,019 --> 00:10:19,850
on and on until the final response will

243
00:10:19,850 --> 00:10:21,170
be received without a continued

244
00:10:21,170 --> 00:10:23,690
sustained the question that we asked

245
00:10:23,690 --> 00:10:25,459
when we look at this graph is what

246
00:10:25,459 --> 00:10:28,399
happens if this if the client changes

247
00:10:28,399 --> 00:10:30,350
the server that he is searching work for

248
00:10:30,350 --> 00:10:32,600
that is the unique UID in his request

249
00:10:32,600 --> 00:10:35,120
between one request in a second request

250
00:10:35,120 --> 00:10:37,750
before the continuation exchange is over

251
00:10:37,750 --> 00:10:43,579
and this exact state confusion is what

252
00:10:43,579 --> 00:10:46,579
led us to find this vulnerability in

253
00:10:46,579 --> 00:10:48,019
android the information they can over

254
00:10:48,019 --> 00:10:51,110
SDP what you can see here is there is

255
00:10:51,110 --> 00:10:55,339
the number of response handles and this

256
00:10:55,339 --> 00:10:57,380
is the number this is the total size of

257
00:10:57,380 --> 00:10:59,870
the of the response that needs to be

258
00:10:59,870 --> 00:11:02,030
returned each time they

259
00:11:02,030 --> 00:11:04,040
it's processed this is the function that

260
00:11:04,040 --> 00:11:07,070
processes a specific request each time

261
00:11:07,070 --> 00:11:10,280
it is processed the number of the full

262
00:11:10,280 --> 00:11:13,700
response is generated again the

263
00:11:13,700 --> 00:11:16,130
continuation offset here is where we are

264
00:11:16,130 --> 00:11:19,550
is the current condition offset that's

265
00:11:19,550 --> 00:11:21,080
the internal state of the server that's

266
00:11:21,080 --> 00:11:22,370
the con state that we saw before

267
00:11:22,370 --> 00:11:25,430
REM Honduras holds the number of

268
00:11:25,430 --> 00:11:28,400
remaining bytes or remaining data that

269
00:11:28,400 --> 00:11:30,500
should be exchanged sent back in the

270
00:11:30,500 --> 00:11:33,590
exchange so if we change the user ID

271
00:11:33,590 --> 00:11:35,510
that is being searched that is being

272
00:11:35,510 --> 00:11:37,070
requesting during a continuation

273
00:11:37,070 --> 00:11:41,030
exchange the state infusion can be it

274
00:11:41,030 --> 00:11:45,230
can be achieved and the RAM handles can

275
00:11:45,230 --> 00:11:46,970
be under flowed because number of

276
00:11:46,970 --> 00:11:48,770
response handers would be changed

277
00:11:48,770 --> 00:11:51,440
so the code assumes that it had one

278
00:11:51,440 --> 00:11:53,300
value and then it has another value and

279
00:11:53,300 --> 00:11:56,600
then that can under flow once that mo

280
00:11:56,600 --> 00:11:59,600
flow is achieved there is the response

281
00:11:59,600 --> 00:12:02,270
the full response buffer that's the RSP

282
00:12:02,270 --> 00:12:04,370
handles and that can be read out of

283
00:12:04,370 --> 00:12:07,940
bounds and it's actually allocated on

284
00:12:07,940 --> 00:12:10,790
the stack so it really looked something

285
00:12:10,790 --> 00:12:11,330
like this

286
00:12:11,330 --> 00:12:13,310
the client would set an initial request

287
00:12:13,310 --> 00:12:15,140
using a unique UID

288
00:12:15,140 --> 00:12:17,870
the server will send a response reading

289
00:12:17,870 --> 00:12:21,200
from the RSP handles buffer there the

290
00:12:21,200 --> 00:12:23,210
client would change the request he is

291
00:12:23,210 --> 00:12:25,550
looking for but he will use the same

292
00:12:25,550 --> 00:12:27,290
thing in continuation state he won't

293
00:12:27,290 --> 00:12:29,180
break the protocol in the sense he won't

294
00:12:29,180 --> 00:12:30,380
change the continuation system but he

295
00:12:30,380 --> 00:12:32,810
will ask for another unity so that would

296
00:12:32,810 --> 00:12:34,010
lead down to the underfloor frame

297
00:12:34,010 --> 00:12:36,080
handers that would allow to eat out of

298
00:12:36,080 --> 00:12:38,540
bounds from the RSP Henderson into the

299
00:12:38,540 --> 00:12:42,460
stack that inside it it is allocated

300
00:12:42,460 --> 00:12:45,830
that stack would contain pointers that

301
00:12:45,830 --> 00:12:47,360
can be used by an attacker to bypass a

302
00:12:47,360 --> 00:12:49,940
SLR because these pointers can point to

303
00:12:49,940 --> 00:12:52,850
leap C variables leap C functions or to

304
00:12:52,850 --> 00:12:54,590
the global variables from which they

305
00:12:54,590 --> 00:12:56,030
serve our basis can be derived and

306
00:12:56,030 --> 00:13:02,180
completely by placing a solo now I want

307
00:13:02,180 --> 00:13:04,460
to talk specifically about and raise on

308
00:13:04,460 --> 00:13:08,560
due to the stack and in how

309
00:13:08,560 --> 00:13:11,200
and what services does it implement and

310
00:13:11,200 --> 00:13:13,930
what options existing for the attacker

311
00:13:13,930 --> 00:13:16,510
specifically in Android so how do it has

312
00:13:16,510 --> 00:13:18,640
its own belief stack since version 4.2

313
00:13:18,640 --> 00:13:23,320
and this is called blue droid or floor

314
00:13:23,320 --> 00:13:26,650
word in some versions so it doesn't use

315
00:13:26,650 --> 00:13:28,900
the Linux roof stack that is called

316
00:13:28,900 --> 00:13:32,320
Blues at all since version 4.2 it is not

317
00:13:32,320 --> 00:13:33,400
one inside the kernel

318
00:13:33,400 --> 00:13:36,820
it's each one's user space but it runs

319
00:13:36,820 --> 00:13:38,830
on a zygote and it is exceptionally

320
00:13:38,830 --> 00:13:40,960
privileged process because it has a lot

321
00:13:40,960 --> 00:13:43,120
of functions to do inside the system as

322
00:13:43,120 --> 00:13:47,080
it is a Bluetooth stack that needs to

323
00:13:47,080 --> 00:13:49,690
internet a lot of functions if we take a

324
00:13:49,690 --> 00:13:51,100
look specifically in Android what

325
00:13:51,100 --> 00:13:53,980
services does an Android smartphone from

326
00:13:53,980 --> 00:13:56,560
this example of a pixel what service is

327
00:13:56,560 --> 00:14:00,010
bluetooth does it serve and there as you

328
00:14:00,010 --> 00:14:01,210
can see there are quite a lot of these

329
00:14:01,210 --> 00:14:04,930
and they sound interesting as well they

330
00:14:04,930 --> 00:14:07,000
host a lot of features in the data stack

331
00:14:07,000 --> 00:14:10,029
so that big chunk of services that we

332
00:14:10,029 --> 00:14:12,730
sub for this actually does exist or a

333
00:14:12,730 --> 00:14:14,620
lot of it exists inside Android as well

334
00:14:14,620 --> 00:14:17,950
so the attack surfaces is is not small

335
00:14:17,950 --> 00:14:20,410
at all I'm going to try for the demo in

336
00:14:20,410 --> 00:14:21,990
Wang now is going to talk to you without

337
00:14:21,990 --> 00:14:24,820
be nib which is one of the services and

338
00:14:24,820 --> 00:14:27,839
the our sieve only builds we found in it

339
00:14:27,839 --> 00:14:32,650
ok so this is the SDP output for Google

340
00:14:32,650 --> 00:14:35,800
pixel is venison and it basically shows

341
00:14:35,800 --> 00:14:38,589
all the services that are available for

342
00:14:38,589 --> 00:14:43,330
any peer to connect to on that pixel and

343
00:14:43,330 --> 00:14:45,100
one of them caught our eye

344
00:14:45,100 --> 00:14:49,060
it's called and really we didn't

345
00:14:49,060 --> 00:14:51,610
know what it was and but what it

346
00:14:51,610 --> 00:14:52,450
actually is

347
00:14:52,450 --> 00:14:55,480
it's that old technology of Bluetooth

348
00:14:55,480 --> 00:15:00,610
tethering of letting you use an internet

349
00:15:00,610 --> 00:15:01,900
connection to share an internet

350
00:15:01,900 --> 00:15:04,890
connection over Bluetooth and it

351
00:15:04,890 --> 00:15:07,570
surprisingly still works today even

352
00:15:07,570 --> 00:15:09,940
though it's like 1 megabit and don't

353
00:15:09,940 --> 00:15:11,380
know but it uses it but it still works

354
00:15:11,380 --> 00:15:17,020
and basically and how it works is that

355
00:15:17,020 --> 00:15:19,990
is a topology of what they call a

356
00:15:19,990 --> 00:15:24,430
personal area network at that and there

357
00:15:24,430 --> 00:15:27,250
is a nap which is the access point and

358
00:15:27,250 --> 00:15:29,320
which in this case would be say an

359
00:15:29,320 --> 00:15:31,720
Android phone and there are clients and

360
00:15:31,720 --> 00:15:34,000
they're called panels they can connect

361
00:15:34,000 --> 00:15:37,210
to that Network and have ensured that

362
00:15:37,210 --> 00:15:41,200
internet connection and basically the

363
00:15:41,200 --> 00:15:42,820
way the protocol works is simply

364
00:15:42,820 --> 00:15:45,760
Ethernet packets with IP packets in them

365
00:15:45,760 --> 00:15:49,360
and encapsulated inside what's called a

366
00:15:49,360 --> 00:15:53,170
beam app and the pinna protocol and

367
00:15:53,170 --> 00:15:54,670
basically the way it is is it's just

368
00:15:54,670 --> 00:15:57,730
Ethernet packets and some extra control

369
00:15:57,730 --> 00:16:01,390
data over Alto copper which as we've

370
00:16:01,390 --> 00:16:03,640
said previously is like the TCP of

371
00:16:03,640 --> 00:16:05,350
Bluetooth so basically it's like a

372
00:16:05,350 --> 00:16:07,840
tunnel over a network tunnel over

373
00:16:07,840 --> 00:16:12,220
Bluetooth and looking at this code the

374
00:16:12,220 --> 00:16:14,440
very first function that receives those

375
00:16:14,440 --> 00:16:17,170
messages over L 2 cap and again L 2

376
00:16:17,170 --> 00:16:18,760
curve is like this e 3 so there is a

377
00:16:18,760 --> 00:16:22,330
listening TCP server and this is the

378
00:16:22,330 --> 00:16:26,920
handler for the packets and to get to

379
00:16:26,920 --> 00:16:28,720
this point an authentication is required

380
00:16:28,720 --> 00:16:33,480
whatsoever and basically at this stage

381
00:16:33,480 --> 00:16:36,790
the state of the wind up service can be

382
00:16:36,790 --> 00:16:39,490
changed to a connected but while it's

383
00:16:39,490 --> 00:16:42,100
not connected it's supposed to be

384
00:16:42,100 --> 00:16:44,020
possible to send a set of message or

385
00:16:44,020 --> 00:16:47,230
other control messages and to send them

386
00:16:47,230 --> 00:16:48,700
obviously authentication isn't just

387
00:16:48,700 --> 00:16:50,950
required may be required later but now

388
00:16:50,950 --> 00:16:54,820
it isn't and so basically in that very

389
00:16:54,820 --> 00:16:57,040
first function which is quite big and

390
00:16:57,040 --> 00:16:59,410
there is this specific flow which leads

391
00:16:59,410 --> 00:17:03,580
to an off by one heap overflow where the

392
00:17:03,580 --> 00:17:06,310
structure size is of prepending data

393
00:17:06,310 --> 00:17:09,040
there is 8 bytes so it's an overflow of

394
00:17:09,040 --> 00:17:11,980
8 bytes on the heap every time this flow

395
00:17:11,980 --> 00:17:13,900
runs and that's really weird I mean it

396
00:17:13,900 --> 00:17:16,030
means this code never executed not

397
00:17:16,030 --> 00:17:18,010
during testing because it would have

398
00:17:18,010 --> 00:17:20,319
crashed the service and so basically

399
00:17:20,319 --> 00:17:22,209
it's possible to send at the very first

400
00:17:22,209 --> 00:17:25,720
packet as this packet that overflow

401
00:17:25,720 --> 00:17:28,750
triggered there and basically it passes

402
00:17:28,750 --> 00:17:30,010
all the checks based

403
00:17:30,010 --> 00:17:31,990
the state being that it's not connected

404
00:17:31,990 --> 00:17:33,880
and then there are some other fields

405
00:17:33,880 --> 00:17:35,890
like type and control type basically

406
00:17:35,890 --> 00:17:37,900
they lead to that mem copy over there

407
00:17:37,900 --> 00:17:40,450
and what's especially convenient about

408
00:17:40,450 --> 00:17:42,850
this particular vulnerability is that

409
00:17:42,850 --> 00:17:45,520
except for the mem copy the attacker

410
00:17:45,520 --> 00:17:47,620
also controls their location size in

411
00:17:47,620 --> 00:17:50,890
that Melek over there and because Ram

412
00:17:50,890 --> 00:17:53,110
LAN is basically just the length of the

413
00:17:53,110 --> 00:17:54,520
packet that the attacker sent so

414
00:17:54,520 --> 00:17:56,380
basically we have an 8 byte heap

415
00:17:56,380 --> 00:17:58,900
overflow where the attacker selects the

416
00:17:58,900 --> 00:18:01,180
size of the buffer on the heap that is

417
00:18:01,180 --> 00:18:04,080
being overflow so that's very convenient

418
00:18:04,080 --> 00:18:08,290
yeah also we thought well an 8 byte heap

419
00:18:08,290 --> 00:18:10,990
overflow maybe that's an exploitable and

420
00:18:10,990 --> 00:18:14,350
then indeed we've looked a bit deeper

421
00:18:14,350 --> 00:18:16,960
and we found that that Android stack has

422
00:18:16,960 --> 00:18:20,500
a thing called an allocation tracker

423
00:18:20,500 --> 00:18:23,470
that basically adds an 8 byte long

424
00:18:23,470 --> 00:18:25,720
January to every heap buffer so we

425
00:18:25,720 --> 00:18:27,310
thought maybe that's an exploitable now

426
00:18:27,310 --> 00:18:29,680
but they gained a little deeper it's

427
00:18:29,680 --> 00:18:31,390
possible to see that it's just compiled

428
00:18:31,390 --> 00:18:37,180
out on non debug builds so ok and at

429
00:18:37,180 --> 00:18:39,580
that point we just started sending that

430
00:18:39,580 --> 00:18:42,760
a trigger buffer that overflow buffer

431
00:18:42,760 --> 00:18:45,280
just hundreds of times and it's possible

432
00:18:45,280 --> 00:18:49,480
to see the crashes in adb logcat which

433
00:18:49,480 --> 00:18:51,760
is the standard Android development

434
00:18:51,760 --> 00:18:54,250
logging system interestingly you can see

435
00:18:54,250 --> 00:18:56,200
those crashes even if the phone is not

436
00:18:56,200 --> 00:18:57,910
rooted and that's a privileged process

437
00:18:57,910 --> 00:19:02,320
ok and so and what we notice is about

438
00:19:02,320 --> 00:19:05,110
about those crashes is that basically

439
00:19:05,110 --> 00:19:07,510
they're just a repetitions like all

440
00:19:07,510 --> 00:19:09,730
crashes fall into a set of 6 or 7

441
00:19:09,730 --> 00:19:12,160
different crashes and we've looked at

442
00:19:12,160 --> 00:19:14,170
some of them one of them again caught

443
00:19:14,170 --> 00:19:16,870
our eye it occurs naturally if you just

444
00:19:16,870 --> 00:19:19,450
send those air crashes if you do the

445
00:19:19,450 --> 00:19:21,310
crashes again again it occurs about 10

446
00:19:21,310 --> 00:19:24,580
percent of the time and the instruction

447
00:19:24,580 --> 00:19:27,310
pointers are in the source code which

448
00:19:27,310 --> 00:19:29,170
again the Bluetooth stack is Android

449
00:19:29,170 --> 00:19:31,240
it's open source it points to this

450
00:19:31,240 --> 00:19:33,310
function with you HCI message process

451
00:19:33,310 --> 00:19:37,930
and looking there we've seen a bunch of

452
00:19:37,930 --> 00:19:40,260
red flags and

453
00:19:40,260 --> 00:19:43,410
so first what we understood this

454
00:19:43,410 --> 00:19:45,929
function does this function handles the

455
00:19:45,929 --> 00:19:49,500
all the HCI messages HCI it's the

456
00:19:49,500 --> 00:19:51,600
protocol between the hardware Bluetooth

457
00:19:51,600 --> 00:19:54,240
controller and the higher-level OS steps

458
00:19:54,240 --> 00:19:56,010
so basically every message that comes

459
00:19:56,010 --> 00:19:58,950
from the hardware a receiving message

460
00:19:58,950 --> 00:20:00,480
comes from the hardware to the stack

461
00:20:00,480 --> 00:20:02,760
passes right through here for some

462
00:20:02,760 --> 00:20:06,720
reason they decided to add this post to

463
00:20:06,720 --> 00:20:09,570
task and no good horrible hack type of

464
00:20:09,570 --> 00:20:12,570
message actually well we understood what

465
00:20:12,570 --> 00:20:14,370
the reason is it's sort of a thread

466
00:20:14,370 --> 00:20:16,860
synchronization thing where they want to

467
00:20:16,860 --> 00:20:20,940
pass tasks as callbacks into this thread

468
00:20:20,940 --> 00:20:23,419
because this thread does most of the

469
00:20:23,419 --> 00:20:26,580
Bluetooth data structure stuff so this

470
00:20:26,580 --> 00:20:28,410
is kind of a synchronization mechanism

471
00:20:28,410 --> 00:20:30,240
so I don't think they can easily remove

472
00:20:30,240 --> 00:20:33,390
this but I don't know and the crash

473
00:20:33,390 --> 00:20:35,250
itself that was in the crash log is

474
00:20:35,250 --> 00:20:36,510
basically on the on that first

475
00:20:36,510 --> 00:20:38,280
dereference of the message therapy

476
00:20:38,280 --> 00:20:40,919
message event in our case B message was

477
00:20:40,919 --> 00:20:45,410
all forty-ones like in our overflow and

478
00:20:45,410 --> 00:20:47,970
but what's going to happen if we can

479
00:20:47,970 --> 00:20:50,880
point that somewhere with a fake a

480
00:20:50,880 --> 00:20:54,750
horrible hat type a message and then we

481
00:20:54,750 --> 00:20:57,090
can take control of that call back over

482
00:20:57,090 --> 00:21:00,299
there and so basically what this does

483
00:21:00,299 --> 00:21:03,540
again is it takes that a B message it

484
00:21:03,540 --> 00:21:05,610
checks the event type to be horrible

485
00:21:05,610 --> 00:21:09,179
hack and then it takes four bytes oft of

486
00:21:09,179 --> 00:21:11,309
the message as a function pointer and

487
00:21:11,309 --> 00:21:13,410
calls it with the message itself as a

488
00:21:13,410 --> 00:21:19,200
parameter and so at this point it still

489
00:21:19,200 --> 00:21:20,730
wasn't clear what exactly are we

490
00:21:20,730 --> 00:21:22,590
overflowing that causes that flow to

491
00:21:22,590 --> 00:21:26,280
happen so I'm gonna explain now and this

492
00:21:26,280 --> 00:21:28,320
function that I've shown you before with

493
00:21:28,320 --> 00:21:31,679
you HCI message process is called from a

494
00:21:31,679 --> 00:21:35,250
function above it the DQ's an HDI

495
00:21:35,250 --> 00:21:37,350
message from some Q that Q probably

496
00:21:37,350 --> 00:21:39,120
comes from another thread that reads it

497
00:21:39,120 --> 00:21:44,100
from the hardware and basically and when

498
00:21:44,100 --> 00:21:46,080
we looked into it a bit more and what

499
00:21:46,080 --> 00:21:48,150
we've seen is that all the cues and all

500
00:21:48,150 --> 00:21:48,580
the

501
00:21:48,580 --> 00:21:51,190
in that in this little stack in the

502
00:21:51,190 --> 00:21:53,260
skull base are based on a list node

503
00:21:53,260 --> 00:21:54,940
structure which is just a node in the

504
00:21:54,940 --> 00:21:58,600
linked list which is 8 bytes long and

505
00:21:58,600 --> 00:22:00,820
indeed if you recall our trigger

506
00:22:00,820 --> 00:22:03,300
overflow buffer was also 8 bytes long

507
00:22:03,300 --> 00:22:07,690
and on Android they use a the Gmail of

508
00:22:07,690 --> 00:22:11,050
heap and what it does very conveniently

509
00:22:11,050 --> 00:22:13,930
for us now is it places all buffers of a

510
00:22:13,930 --> 00:22:16,960
similar size in the same space space

511
00:22:16,960 --> 00:22:21,400
also a if the if the occasions happen on

512
00:22:21,400 --> 00:22:23,050
the same thread it places them on the

513
00:22:23,050 --> 00:22:25,660
same place and this is the case so

514
00:22:25,660 --> 00:22:27,160
basically what happened with our

515
00:22:27,160 --> 00:22:29,620
overflow is that we've over flown one of

516
00:22:29,620 --> 00:22:31,900
the list nodes that belong to the

517
00:22:31,900 --> 00:22:34,930
incoming HTC I message queue that wasn't

518
00:22:34,930 --> 00:22:36,250
handled yet and the minute it was

519
00:22:36,250 --> 00:22:39,090
handled it got passed to that function

520
00:22:39,090 --> 00:22:42,850
and the HTI message process function and

521
00:22:42,850 --> 00:22:47,800
there we crashed and so basically a now

522
00:22:47,800 --> 00:22:49,660
I'm gonna outline it was the strategy

523
00:22:49,660 --> 00:22:54,160
and for the exploit is going to be and

524
00:22:54,160 --> 00:23:00,100
so we have already the SLR bypass and so

525
00:23:00,100 --> 00:23:01,510
that's good for us we can know address

526
00:23:01,510 --> 00:23:05,020
basis of the cause of liberty functions

527
00:23:05,020 --> 00:23:07,450
which which will use the callback and

528
00:23:07,450 --> 00:23:09,670
some other things and now what we want

529
00:23:09,670 --> 00:23:11,740
to do is write a payload into memory

530
00:23:11,740 --> 00:23:14,820
which will be that horrible hack message

531
00:23:14,820 --> 00:23:17,830
structure a somewhere in memory with the

532
00:23:17,830 --> 00:23:20,080
deterministic address which will become

533
00:23:20,080 --> 00:23:22,770
possible because we've bypassed SLR and

534
00:23:22,770 --> 00:23:25,510
the callback we'll set it to be simply

535
00:23:25,510 --> 00:23:28,330
the system function from Lib C which

536
00:23:28,330 --> 00:23:30,070
again we know the others from the SLR

537
00:23:30,070 --> 00:23:31,840
bypass and the system function will

538
00:23:31,840 --> 00:23:34,240
receive the P message itself so we'll

539
00:23:34,240 --> 00:23:36,070
make the P message

540
00:23:36,070 --> 00:23:39,429
play load dual pour dual purpose so that

541
00:23:39,429 --> 00:23:41,229
it will serve both as the horrible hack

542
00:23:41,229 --> 00:23:44,559
message and a bash script to run a

543
00:23:44,559 --> 00:23:47,679
system and the next thing we do is we

544
00:23:47,679 --> 00:23:51,070
send our overflow trigger again again

545
00:23:51,070 --> 00:23:54,789
until we overflow the HCI a list node

546
00:23:54,789 --> 00:23:58,239
and hopefully it gets processed by the

547
00:23:58,239 --> 00:24:00,399
processing function and our bash script

548
00:24:00,399 --> 00:24:02,799
will be executed and now as I've said

549
00:24:02,799 --> 00:24:06,309
before very conveniently this type this

550
00:24:06,309 --> 00:24:09,190
crash happens naturally 10% of the time

551
00:24:09,190 --> 00:24:13,090
and being a service on Android it runs

552
00:24:13,090 --> 00:24:15,009
under something called Zagat that simply

553
00:24:15,009 --> 00:24:18,759
restarts the service if it crashes so we

554
00:24:18,759 --> 00:24:20,320
don't really need to do any heap shaping

555
00:24:20,320 --> 00:24:22,149
to improve all the tools just the attack

556
00:24:22,149 --> 00:24:23,889
takes more time but we did it just to

557
00:24:23,889 --> 00:24:28,359
shorten the attack so what that payload

558
00:24:28,359 --> 00:24:31,599
actually looks like and above you can

559
00:24:31,599 --> 00:24:33,159
see that what we want is that data

560
00:24:33,159 --> 00:24:35,169
pointer in the list node to point right

561
00:24:35,169 --> 00:24:37,599
in the leftmost byte a of that buffer

562
00:24:37,599 --> 00:24:40,749
and and the way we structure it is that

563
00:24:40,749 --> 00:24:42,549
the first eight bytes are of type a

564
00:24:42,549 --> 00:24:44,139
bitty header which is that structure

565
00:24:44,139 --> 00:24:47,440
that contains the event field that we

566
00:24:47,440 --> 00:24:50,859
need set to 17 17 being that horrible

567
00:24:50,859 --> 00:24:54,039
hack event and the way the code checks

568
00:24:54,039 --> 00:24:55,840
that it checks only the the lower byte

569
00:24:55,840 --> 00:24:58,509
so we we use the higher bite of that

570
00:24:58,509 --> 00:25:01,809
event as quotes in order to make this

571
00:25:01,809 --> 00:25:03,970
whole thing a valid bash script so the

572
00:25:03,970 --> 00:25:06,399
first eight bytes are what I explained

573
00:25:06,399 --> 00:25:09,669
and next is the callback and offset

574
00:25:09,669 --> 00:25:11,440
number eight and the rest of the payload

575
00:25:11,440 --> 00:25:14,200
is simply structured to allow arbitrary

576
00:25:14,200 --> 00:25:20,970
bash commands to be executed and yeah

577
00:25:20,970 --> 00:25:24,359
now what happens in that function now

578
00:25:24,359 --> 00:25:28,299
again is that the first two bytes of our

579
00:25:28,299 --> 00:25:30,789
payload are parsed as that event filled

580
00:25:30,789 --> 00:25:33,729
the mask over there simply checks only

581
00:25:33,729 --> 00:25:38,259
the lower byte and the case for a

582
00:25:38,259 --> 00:25:41,320
no-good horrible hack is 17 so if those

583
00:25:41,320 --> 00:25:43,480
first two bytes are

584
00:25:43,480 --> 00:25:46,510
have 17 is the lower by and our callback

585
00:25:46,510 --> 00:25:48,940
will be executed this whole payload is

586
00:25:48,940 --> 00:25:51,340
passed into the callback which is system

587
00:25:51,340 --> 00:25:56,260
and it is a valid birthday okay so there

588
00:25:56,260 --> 00:25:59,410
one of the last things that is remaining

589
00:25:59,410 --> 00:26:01,570
is where do we place that payload in

590
00:26:01,570 --> 00:26:03,760
memory so that we know it's address

591
00:26:03,760 --> 00:26:07,060
deterministically and what turns out is

592
00:26:07,060 --> 00:26:08,800
that in bluetooth and there is such a

593
00:26:08,800 --> 00:26:09,430
thing called

594
00:26:09,430 --> 00:26:12,490
a remote device name every device has a

595
00:26:12,490 --> 00:26:16,930
name and we make a connection to the

596
00:26:16,930 --> 00:26:19,240
target as appear so we also have a name

597
00:26:19,240 --> 00:26:21,490
and the name is exchanged during the

598
00:26:21,490 --> 00:26:24,100
basic ACL connection that's like the

599
00:26:24,100 --> 00:26:26,110
basic Bluetooth connection between two

600
00:26:26,110 --> 00:26:28,840
Bluetooth controllers and once the

601
00:26:28,840 --> 00:26:30,940
connection is established our name is

602
00:26:30,940 --> 00:26:33,820
written into the memory of the target

603
00:26:33,820 --> 00:26:35,590
Bluetooth stack and it just so happens

604
00:26:35,590 --> 00:26:37,690
that there it's in a global variable and

605
00:26:37,690 --> 00:26:42,190
from the SLR info leak we know the base

606
00:26:42,190 --> 00:26:44,320
of the BSS section which is where all

607
00:26:44,320 --> 00:26:46,570
the global variables are stored and that

608
00:26:46,570 --> 00:26:49,690
means that the name our device name will

609
00:26:49,690 --> 00:26:52,180
have a deterministic offset in memory

610
00:26:52,180 --> 00:26:56,050
once we know the ASLR base yeah so on an

611
00:26:56,050 --> 00:26:57,610
attacker machine say on Linux it's

612
00:26:57,610 --> 00:26:59,230
really easy to change our own device

613
00:26:59,230 --> 00:27:01,300
name so we change the device name to

614
00:27:01,300 --> 00:27:03,910
that payload a conveniently in Bluetooth

615
00:27:03,910 --> 00:27:08,080
the the device name is a 248 bytes long

616
00:27:08,080 --> 00:27:10,780
it just cannot contain any null bites

617
00:27:10,780 --> 00:27:15,300
and ok with that and so now we have

618
00:27:15,300 --> 00:27:18,610
almost all parts of the attack and this

619
00:27:18,610 --> 00:27:19,780
is something that we're not going to

620
00:27:19,780 --> 00:27:22,680
elaborate upon due to lack of time but

621
00:27:22,680 --> 00:27:25,660
we shaped the hip slightly as I said in

622
00:27:25,660 --> 00:27:28,630
order to increase the odds and what we

623
00:27:28,630 --> 00:27:31,600
want the hip to look like and let me

624
00:27:31,600 --> 00:27:33,430
just digress a second into what is it

625
00:27:33,430 --> 00:27:36,340
that you see here and this is what

626
00:27:36,340 --> 00:27:39,850
should be a run on the jml hip iran is

627
00:27:39,850 --> 00:27:43,120
basically in that physical area where

628
00:27:43,120 --> 00:27:44,890
objects of the same size that are

629
00:27:44,890 --> 00:27:46,840
allocated on the same thread will be

630
00:27:46,840 --> 00:27:50,050
placed and so what we want is the

631
00:27:50,050 --> 00:27:52,390
leftmost hole on the front to be 8 bytes

632
00:27:52,390 --> 00:27:54,980
long so our overflow buffer will be

633
00:27:54,980 --> 00:27:57,049
there and immediately after that we want

634
00:27:57,049 --> 00:28:00,500
a veal at least now that belongs to the

635
00:28:00,500 --> 00:28:03,470
HDI message queue and to be there so

636
00:28:03,470 --> 00:28:07,010
that when that hole is allocated and the

637
00:28:07,010 --> 00:28:09,080
overflow happens it overflows this list

638
00:28:09,080 --> 00:28:11,870
now it can be any list note that belongs

639
00:28:11,870 --> 00:28:14,809
to that queue as long it is unhandled

640
00:28:14,809 --> 00:28:15,320
yet

641
00:28:15,320 --> 00:28:19,159
and basically if we do our attack over

642
00:28:19,159 --> 00:28:22,570
and over again either we crushed by a

643
00:28:22,570 --> 00:28:25,490
overflow and something else or this and

644
00:28:25,490 --> 00:28:29,830
lead to our execution of system and

645
00:28:29,830 --> 00:28:32,389
basically to explain shortly what's

646
00:28:32,389 --> 00:28:36,429
going on in in this heap shaping is that

647
00:28:36,429 --> 00:28:38,899
what's usually going on in the Bluetooth

648
00:28:38,899 --> 00:28:41,720
stack is nothing and because no one uses

649
00:28:41,720 --> 00:28:44,929
it so much and if if someone is using it

650
00:28:44,929 --> 00:28:47,299
and we crash it once then no one is

651
00:28:47,299 --> 00:28:49,519
using it at the moment basically so the

652
00:28:49,519 --> 00:28:51,529
hip is really deterministic it will take

653
00:28:51,529 --> 00:28:53,779
some time until it will be something

654
00:28:53,779 --> 00:28:56,539
will happen again and what we do is

655
00:28:56,539 --> 00:28:58,909
eventually we force the beam up service

656
00:28:58,909 --> 00:29:00,559
something else in the beam up servers to

657
00:29:00,559 --> 00:29:02,809
send us lots of response messages in a

658
00:29:02,809 --> 00:29:06,769
certain way in order and these responses

659
00:29:06,769 --> 00:29:08,720
will cause allocations and Fries of

660
00:29:08,720 --> 00:29:11,269
eight bytes objects and again without

661
00:29:11,269 --> 00:29:13,700
saying exactly how it works and we can

662
00:29:13,700 --> 00:29:15,710
make it shape the heap in a way that

663
00:29:15,710 --> 00:29:20,240
increases our odds significantly and so

664
00:29:20,240 --> 00:29:22,309
again let's reiterate on how it works

665
00:29:22,309 --> 00:29:24,139
first of all we do the info leak and we

666
00:29:24,139 --> 00:29:27,830
learn the address basis of SLR and now

667
00:29:27,830 --> 00:29:29,870
we're going to establish a connection

668
00:29:29,870 --> 00:29:33,860
with our payload device name and write

669
00:29:33,860 --> 00:29:35,870
that horrible hack message into memory

670
00:29:35,870 --> 00:29:38,510
and now we're going to do that optional

671
00:29:38,510 --> 00:29:40,820
heap shaping and immediately after will

672
00:29:40,820 --> 00:29:43,399
send starter will will start sending our

673
00:29:43,399 --> 00:29:46,130
overflow triggers in the loop and with

674
00:29:46,130 --> 00:29:48,260
that crafted list no that points to the

675
00:29:48,260 --> 00:29:51,440
horrible hack message until either we

676
00:29:51,440 --> 00:29:53,990
crash and then get restarted or we

677
00:29:53,990 --> 00:29:55,720
succeed then we run a bash command

678
00:29:55,720 --> 00:29:59,779
empirically and this sort of works 50%

679
00:29:59,779 --> 00:30:01,669
of the time on the device we retested

680
00:30:01,669 --> 00:30:04,039
and for like each attempt so that means

681
00:30:04,039 --> 00:30:06,169
that including the restarts it will

682
00:30:06,169 --> 00:30:07,970
like a minute for the attacked of

683
00:30:07,970 --> 00:30:14,000
succeed most and ok and we wanted to

684
00:30:14,000 --> 00:30:16,730
show that the source code for the

685
00:30:16,730 --> 00:30:18,289
exploit will be available very shortly

686
00:30:18,289 --> 00:30:21,320
on github and again there will be a blog

687
00:30:21,320 --> 00:30:24,070
post explaining in a lot more detail and

688
00:30:24,070 --> 00:30:26,510
what I've shown what we've shown in this

689
00:30:26,510 --> 00:30:28,130
presentation and of course there's the

690
00:30:28,130 --> 00:30:30,140
full white paper that we've published in

691
00:30:30,140 --> 00:30:32,210
September and that contains the

692
00:30:32,210 --> 00:30:33,440
description of all the vulnerabilities

693
00:30:33,440 --> 00:30:35,990
not only the Android ones what it

694
00:30:35,990 --> 00:30:37,880
doesn't have is the exploitation which

695
00:30:37,880 --> 00:30:39,890
is that the new thing we're showing

696
00:30:39,890 --> 00:30:42,770
today and now we'll try to do a damn

697
00:30:42,770 --> 00:30:49,370
hopeful up for a second then we'll

698
00:30:49,370 --> 00:30:52,039
explain and what's going to happen what

699
00:30:52,039 --> 00:30:55,159
we have is an attacker in the laptop in

700
00:30:55,159 --> 00:30:57,520
this instance and he would attack the

701
00:30:57,520 --> 00:31:01,909
Google pixel we're going to show the way

702
00:31:01,909 --> 00:31:04,279
it's going to work is first he would

703
00:31:04,279 --> 00:31:07,640
establish a Bluetooth connection using

704
00:31:07,640 --> 00:31:09,470
the SDP vulnerability the information

705
00:31:09,470 --> 00:31:11,360
leaked and the bean app are receiving

706
00:31:11,360 --> 00:31:13,010
ability who would achieve code execution

707
00:31:13,010 --> 00:31:15,169
and the payload the bash commands

708
00:31:15,169 --> 00:31:17,090
themselves that are going to be one is

709
00:31:17,090 --> 00:31:19,309
just a net class connection over the

710
00:31:19,309 --> 00:31:23,090
Internet back to the attacker so once we

711
00:31:23,090 --> 00:31:25,340
have the shell command over the TCP

712
00:31:25,340 --> 00:31:27,230
connection we no longer need the

713
00:31:27,230 --> 00:31:28,789
Bluetooth connection we can run whatever

714
00:31:28,789 --> 00:31:30,980
commands we want and we are running

715
00:31:30,980 --> 00:31:35,630
inside the Bluetooth stack good roid in

716
00:31:35,630 --> 00:31:37,070
what is the important to note is that

717
00:31:37,070 --> 00:31:39,500
the stack is exceptionally privileged

718
00:31:39,500 --> 00:31:43,039
I'm going to show a few things that can

719
00:31:43,039 --> 00:31:47,600
be done once you are inside it so on the

720
00:31:47,600 --> 00:31:51,110
left here on the top is the terminal for

721
00:31:51,110 --> 00:31:54,470
the attack and that Nutella pixel you

722
00:31:54,470 --> 00:31:59,510
can just focus on the pixel no right now

723
00:31:59,510 --> 00:32:01,159
it's nothing is apparent and and

724
00:32:01,159 --> 00:32:02,240
hopefully it will work

725
00:32:02,240 --> 00:32:06,919
okay so it starts by doing the memory

726
00:32:06,919 --> 00:32:13,039
leak it connects to be net and then you

727
00:32:13,039 --> 00:32:16,460
will do the heap shaping and training of

728
00:32:16,460 --> 00:32:17,800
the overflow

729
00:32:17,800 --> 00:32:23,290
and it worked yay so we are inside the

730
00:32:23,290 --> 00:32:25,450
context and warning of the of the brutal

731
00:32:25,450 --> 00:32:29,530
static running a bash bash command line

732
00:32:29,530 --> 00:32:32,560
we can see that the user is Bluetooth

733
00:32:32,560 --> 00:32:34,600
that's the user of the Buddhist jack it

734
00:32:34,600 --> 00:32:37,000
has a lot of - a lot of prodigals inside

735
00:32:37,000 --> 00:32:39,850
the Lotus and inside the Android and all

736
00:32:39,850 --> 00:32:41,740
of these groups that if this power for

737
00:32:41,740 --> 00:32:45,370
example you can see the filesystem know

738
00:32:45,370 --> 00:32:47,050
if you actually can see the text down

739
00:32:47,050 --> 00:32:53,890
but trust me it is and we can also view

740
00:32:53,890 --> 00:32:55,750
in for example images that you have

741
00:32:55,750 --> 00:32:59,020
inserting inside your that you

742
00:32:59,020 --> 00:33:03,670
photographed with your Android phone and

743
00:33:03,670 --> 00:33:06,010
of course we can run whatever executable

744
00:33:06,010 --> 00:33:07,780
exists inside the Android like the

745
00:33:07,780 --> 00:33:09,550
netcat that we used to connect back to

746
00:33:09,550 --> 00:33:12,700
the attacker one answer one interesting

747
00:33:12,700 --> 00:33:14,860
thing that exists inside the booth jack

748
00:33:14,860 --> 00:33:17,800
is its ability to emulate a mouse to

749
00:33:17,800 --> 00:33:19,960
emulate in HIV device this is because

750
00:33:19,960 --> 00:33:22,260
you want the ability to connect

751
00:33:22,260 --> 00:33:24,970
Beautiful's to your phone or keyboard

752
00:33:24,970 --> 00:33:27,490
and for that reason the Buddha stock has

753
00:33:27,490 --> 00:33:30,750
privileges to run to interact with the

754
00:33:30,750 --> 00:33:34,450
WH ID which is a device the kernel

755
00:33:34,450 --> 00:33:39,040
device for playing hid events so we take

756
00:33:39,040 --> 00:33:41,860
it take abuse of that fact and you

757
00:33:41,860 --> 00:33:44,860
upload a script a script just plays

758
00:33:44,860 --> 00:33:48,190
recorder hid events that allows us to

759
00:33:48,190 --> 00:33:51,520
have control of a mouse inside the

760
00:33:51,520 --> 00:33:53,800
texture so here it is here it goes on

761
00:33:53,800 --> 00:33:55,930
and you can see that mouse I hope that

762
00:33:55,930 --> 00:34:01,750
you can see that mouse over there and

763
00:34:01,750 --> 00:34:04,570
that of course emulate whatever user can

764
00:34:04,570 --> 00:34:06,730
do with the phone now the attacker can

765
00:34:06,730 --> 00:34:11,168
do I am on top of that you have Android

766
00:34:11,168 --> 00:34:13,570
intents and that's IPC mechanical

767
00:34:13,570 --> 00:34:16,870
mechanism Android to send all kind of

768
00:34:16,870 --> 00:34:21,880
messages so the little cycling also send

769
00:34:21,880 --> 00:34:23,409
these intents for example you can send

770
00:34:23,409 --> 00:34:24,909
any intent that wishes to open the

771
00:34:24,909 --> 00:34:29,099
camera so this is what I've done now

772
00:34:29,099 --> 00:34:31,179
I'd say oh here it is

773
00:34:31,179 --> 00:34:34,809
and you can switch to the front camera

774
00:34:34,809 --> 00:34:38,319
and take a picture of Gregg or his

775
00:34:38,319 --> 00:34:41,049
camera at least yeah here's the handle

776
00:34:41,049 --> 00:34:45,219
him and we can open the lock screen in

777
00:34:45,219 --> 00:34:47,469
this case it is not password protected

778
00:34:47,469 --> 00:34:49,569
and we can go to the Play Store and

779
00:34:49,569 --> 00:34:53,139
install our own matter of choosing and

780
00:34:53,139 --> 00:34:55,329
whatever actions the user wants to do we

781
00:34:55,329 --> 00:34:57,339
can go to the settings you understand

782
00:34:57,339 --> 00:34:58,299
the gist

783
00:34:58,299 --> 00:35:01,440
it is pond

784
00:35:10,070 --> 00:35:13,110
so we have enough legal something that

785
00:35:13,110 --> 00:35:17,670
we have time to do in that second second

786
00:35:17,670 --> 00:35:20,070
stage of the attack what happens if an

787
00:35:20,070 --> 00:35:22,020
attacker wants to create kind of a

788
00:35:22,020 --> 00:35:22,560
botnet or

789
00:35:22,560 --> 00:35:26,010
start spreading the attack from one

790
00:35:26,010 --> 00:35:29,040
device to another over Bluetooth from

791
00:35:29,040 --> 00:35:30,660
that point the attack would not be

792
00:35:30,660 --> 00:35:32,970
limited no we're no longer be limited to

793
00:35:32,970 --> 00:35:35,970
the Bluetooth range because this Nate

794
00:35:35,970 --> 00:35:38,640
this patient zero of the device that has

795
00:35:38,640 --> 00:35:41,190
been attacked can then go around the

796
00:35:41,190 --> 00:35:43,350
world and attack other devices so we

797
00:35:43,350 --> 00:35:45,390
wanted to test out how something like

798
00:35:45,390 --> 00:35:49,790
this can be achieved and the idea is

799
00:35:49,790 --> 00:35:52,980
first we have the shell command that we

800
00:35:52,980 --> 00:35:56,850
saw right now that the attacker gains on

801
00:35:56,850 --> 00:36:01,140
on the picture phone and from that point

802
00:36:01,140 --> 00:36:02,700
he wants to run his own code that

803
00:36:02,700 --> 00:36:04,980
allowed allows him to control the

804
00:36:04,980 --> 00:36:07,470
Bluetooth of the Android phone in order

805
00:36:07,470 --> 00:36:10,080
to use it to attack other devices the

806
00:36:10,080 --> 00:36:13,980
HCI and connection that exists between

807
00:36:13,980 --> 00:36:15,630
the controller and the Buddhist accent

808
00:36:15,630 --> 00:36:17,970
web already is actually a socket or a

809
00:36:17,970 --> 00:36:20,430
serial file descriptor that is opened

810
00:36:20,430 --> 00:36:22,980
inside the Droid and since our shell the

811
00:36:22,980 --> 00:36:26,540
attackers shell is a child of that of

812
00:36:26,540 --> 00:36:29,220
that process inherits the file

813
00:36:29,220 --> 00:36:31,410
descriptors and you can use that HCIA

814
00:36:31,410 --> 00:36:35,600
connection we use simple java code to

815
00:36:35,600 --> 00:36:39,900
open another TCP connection and we use

816
00:36:39,900 --> 00:36:41,280
the file descriptor of the HCI

817
00:36:41,280 --> 00:36:45,510
as now the file descriptor of that goes

818
00:36:45,510 --> 00:36:47,760
directly to the java process and is

819
00:36:47,760 --> 00:36:49,320
routed over the specific connection to

820
00:36:49,320 --> 00:36:51,690
the attacker so now the attacker can

821
00:36:51,690 --> 00:36:53,730
control the bootephant the bootephant

822
00:36:53,730 --> 00:36:56,340
rotor on the patient zero device since

823
00:36:56,340 --> 00:36:59,310
it can send over the specific relation

824
00:36:59,310 --> 00:37:01,320
whatever ACI commands heal it like and

825
00:37:01,320 --> 00:37:02,850
we're going to demo this now it's pretty

826
00:37:02,850 --> 00:37:04,980
new I really hope it works but

827
00:37:04,980 --> 00:37:07,350
eventually the fact is attacking another

828
00:37:07,350 --> 00:37:10,770
device in this example a SmartWatch in

829
00:37:10,770 --> 00:37:12,450
the demo you're going to do

830
00:37:12,450 --> 00:37:16,270
the next stage is a patient n if you if

831
00:37:16,270 --> 00:37:19,119
you die we won't use danwon abilities

832
00:37:19,119 --> 00:37:20,049
you actually you're going to use that

833
00:37:20,049 --> 00:37:22,089
Linux mobilities that we haven't talked

834
00:37:22,089 --> 00:37:23,619
about but it is in the technical white

835
00:37:23,619 --> 00:37:30,400
paper and do some tricks with so over

836
00:37:30,400 --> 00:37:32,500
here we have on the top the Android

837
00:37:32,500 --> 00:37:35,020
shelf with our bash commands that does

838
00:37:35,020 --> 00:37:38,349
all kind of tricky for us so the first

839
00:37:38,349 --> 00:37:40,690
step is to stop the current Bluetooth

840
00:37:40,690 --> 00:37:42,400
stack in Android because we want to have

841
00:37:42,400 --> 00:37:45,970
the Salkin control over the API socket

842
00:37:45,970 --> 00:37:49,660
so we're going to do that that's command

843
00:37:49,660 --> 00:37:52,569
that stops the booty stack now we're

844
00:37:52,569 --> 00:37:56,920
going to start another another socket

845
00:37:56,920 --> 00:37:59,200
the TCP socket that he's going to

846
00:37:59,200 --> 00:38:02,140
control this HCI socket and then the

847
00:38:02,140 --> 00:38:04,270
Android will attack over its bit of

848
00:38:04,270 --> 00:38:06,329
connection it will track the SmartWatch

849
00:38:06,329 --> 00:38:09,220
so we just launched the java code that

850
00:38:09,220 --> 00:38:13,270
does the regarding of the HCI and and

851
00:38:13,270 --> 00:38:17,799
hopefully it would work okay so you can

852
00:38:17,799 --> 00:38:20,740
see there okay that's that week you can

853
00:38:20,740 --> 00:38:22,750
see that the attack started and one

854
00:38:22,750 --> 00:38:24,130
month will explain specifically this

855
00:38:24,130 --> 00:38:26,470
linux vulnerability but it achieves code

856
00:38:26,470 --> 00:38:28,390
execution via bluetooth as well and now

857
00:38:28,390 --> 00:38:31,359
we can drop into shell we are running as

858
00:38:31,359 --> 00:38:33,430
rude as we're going to see in a minute

859
00:38:33,430 --> 00:38:36,490
inside the Linux system and we have one

860
00:38:36,490 --> 00:38:38,890
more trick up our sleeve in that is the

861
00:38:38,890 --> 00:38:41,279
SmartWatch actually has a server that

862
00:38:41,279 --> 00:38:43,990
does the graphics for the watch

863
00:38:43,990 --> 00:38:47,319
yes I can see the what is still fully

864
00:38:47,319 --> 00:38:51,809
functional and we're running our code

865
00:38:51,809 --> 00:38:57,940
inside of it so we can use the X server

866
00:38:57,940 --> 00:39:00,099
of the watch to display whatever we

867
00:39:00,099 --> 00:39:01,750
would like on its server once we have

868
00:39:01,750 --> 00:39:05,920
our control and like you can see there

869
00:39:05,920 --> 00:39:08,529
is now that blue bonnet logo all over

870
00:39:08,529 --> 00:39:09,779
that watch

871
00:39:09,779 --> 00:39:15,059
that's just our own laughing

872
00:39:16,030 --> 00:39:19,930
particularly listen to this now

873
00:39:19,930 --> 00:39:22,250
so lastly of course we happen for

874
00:39:22,250 --> 00:39:24,350
control and we can reboot will bit to

875
00:39:24,350 --> 00:39:27,590
this SmartWatch just for the sake of

876
00:39:27,590 --> 00:39:32,300
being without bloomin art I think that

877
00:39:32,300 --> 00:39:32,890
is it

878
00:39:32,890 --> 00:39:34,970
do you have any questions we have I

879
00:39:34,970 --> 00:39:36,050
don't know if we have some time but

880
00:39:36,050 --> 00:39:47,510
today maybe five minutes okay it started

881
00:39:47,510 --> 00:39:55,130
see if we can hear you I don't think it

882
00:39:55,130 --> 00:39:57,380
really that much different there are all

883
00:39:57,380 --> 00:40:00,110
kind of callback functions in the memory

884
00:40:00,110 --> 00:40:02,660
in the heap of an android so it it would

885
00:40:02,660 --> 00:40:04,790
take conservative work to remove these

886
00:40:04,790 --> 00:40:07,490
kind of callbacks and JE malloc itself

887
00:40:07,490 --> 00:40:10,820
can also be used like it does there are

888
00:40:10,820 --> 00:40:12,200
techniques to attack J malloc

889
00:40:12,200 --> 00:40:13,280
specifically there are much more

890
00:40:13,280 --> 00:40:15,410
difficult than the horrible hack but

891
00:40:15,410 --> 00:40:17,360
it's just something that will that made

892
00:40:17,360 --> 00:40:18,860
our life much easier

893
00:40:18,860 --> 00:40:23,720
but of course heap heap attacks are here

894
00:40:23,720 --> 00:40:27,380
overflows there are there are infinite

895
00:40:27,380 --> 00:40:30,320
ways in order to gain code execution one

896
00:40:30,320 --> 00:40:31,160
when you do that

897
00:40:31,160 --> 00:40:33,020
so really the big advantage there was

898
00:40:33,020 --> 00:40:36,230
that in the benefit owner ability it was

899
00:40:36,230 --> 00:40:37,850
possible to select the size of the

900
00:40:37,850 --> 00:40:39,320
buffer so we just started with eight

901
00:40:39,320 --> 00:40:41,510
bytes but we could choose any size and

902
00:40:41,510 --> 00:40:43,790
thus target any object in the entire

903
00:40:43,790 --> 00:40:46,310
system if any of them had a callback it

904
00:40:46,310 --> 00:40:48,170
would have been almost the same as long

905
00:40:48,170 --> 00:40:51,110
as it's been like on the first eight

906
00:40:51,110 --> 00:40:51,560
bytes

907
00:40:51,560 --> 00:40:59,060
okay so my question would be could you

908
00:40:59,060 --> 00:41:01,520
also use B nap to establish a TCP

909
00:41:01,520 --> 00:41:03,580
connection to the to the old form

910
00:41:03,580 --> 00:41:08,170
because you use now a separate channel

911
00:41:09,460 --> 00:41:11,480
that we considered when we did the

912
00:41:11,480 --> 00:41:15,800
excitation it did require us to restore

913
00:41:15,800 --> 00:41:18,440
the heat a bit and do and have the code

914
00:41:18,440 --> 00:41:21,080
of the Bluetooth stack keep keep on

915
00:41:21,080 --> 00:41:23,780
running but of course instead of going

916
00:41:23,780 --> 00:41:25,700
to leap see the system what we could

917
00:41:25,700 --> 00:41:27,230
also have done and it's not very

918
00:41:27,230 --> 00:41:28,849
difficult is develop a

919
00:41:28,849 --> 00:41:31,450
warp chain that we would load our code

920
00:41:31,450 --> 00:41:34,940
for a file or just over the internet or

921
00:41:34,940 --> 00:41:38,569
over whatever and um protect to run our

922
00:41:38,569 --> 00:41:40,160
own code and then of course we can also

923
00:41:40,160 --> 00:41:42,769
use once the stack is stabilized we can

924
00:41:42,769 --> 00:41:45,319
use beam app and you can use TCP

925
00:41:45,319 --> 00:41:46,789
connection over that interface as well

926
00:41:46,789 --> 00:41:55,460
yes thanks we have another yeah you

927
00:41:55,460 --> 00:41:57,589
mentioned that there is like a 50 50

928
00:41:57,589 --> 00:42:00,739
percent chance of success if nothing

929
00:42:00,739 --> 00:42:04,160
uses bluetooth how successful is the

930
00:42:04,160 --> 00:42:07,670
exploit if the target is using for

931
00:42:07,670 --> 00:42:10,369
instance able to set headphone to listen

932
00:42:10,369 --> 00:42:12,349
to music or something like that on the

933
00:42:12,349 --> 00:42:14,029
first attempt it will fail and on a

934
00:42:14,029 --> 00:42:15,739
second it will probably succeed with the

935
00:42:15,739 --> 00:42:18,019
50 percent probability because once we

936
00:42:18,019 --> 00:42:19,940
crash the service everything that's been

937
00:42:19,940 --> 00:42:21,650
done will stop and the user won't

938
00:42:21,650 --> 00:42:24,349
restart it in time for a before we

939
00:42:24,349 --> 00:42:26,299
managed to run our thing well I will

940
00:42:26,299 --> 00:42:28,069
tell you that the fact is we really

941
00:42:28,069 --> 00:42:29,599
spend a lot of time on the heap shaping

942
00:42:29,599 --> 00:42:31,910
because this is not a weaponized tool

943
00:42:31,910 --> 00:42:35,239
this is just for our fun and a bit of

944
00:42:35,239 --> 00:42:38,989
profits but so any heaps I think that is

945
00:42:38,989 --> 00:42:40,609
more sophisticated than what you have

946
00:42:40,609 --> 00:42:42,529
done could have could have resulted in

947
00:42:42,529 --> 00:42:47,089
better chance and that yeah that is

948
00:42:47,089 --> 00:42:48,589
really an exploit only for this

949
00:42:48,589 --> 00:42:50,630
particular build it's not weaponized or

950
00:42:50,630 --> 00:42:55,339
anything so yeah it's very hard to make

951
00:42:55,339 --> 00:42:57,859
it more wide there are just a couple of

952
00:42:57,859 --> 00:42:59,839
symbols that needs to be adjusted per

953
00:42:59,839 --> 00:43:03,440
build the Lib C is a system yeah the

954
00:43:03,440 --> 00:43:06,049
blue droid related vulnerabilities you

955
00:43:06,049 --> 00:43:08,089
discovered look pretty much clever

956
00:43:08,089 --> 00:43:11,450
backdoor to me or very just that lucky

957
00:43:11,450 --> 00:43:15,499
really it didn't look like a backdoor no

958
00:43:15,499 --> 00:43:19,430
because don't so many factors played it

959
00:43:19,430 --> 00:43:21,200
was pretty easy as you've seen but I

960
00:43:21,200 --> 00:43:24,289
think that's a matter of of simulation

961
00:43:24,289 --> 00:43:26,089
yeah maybe a little bit of luck and

962
00:43:26,089 --> 00:43:30,200
because um I really think it's just

963
00:43:30,200 --> 00:43:32,150
because there is so much code and it is

964
00:43:32,150 --> 00:43:35,900
so untested that this was there I think

965
00:43:35,900 --> 00:43:37,549
part of the reason is that we didn't

966
00:43:37,549 --> 00:43:38,980
talk about this at all right now but

967
00:43:38,980 --> 00:43:40,270
in the technically white paper that we

968
00:43:40,270 --> 00:43:43,329
wrote there is a assumption in the code

969
00:43:43,329 --> 00:43:45,700
the services that high level services

970
00:43:45,700 --> 00:43:51,220
like Bennet should be only in use with

971
00:43:51,220 --> 00:43:52,930
para devices with devices you have been

972
00:43:52,930 --> 00:43:55,570
paired with and we found a way to bypass

973
00:43:55,570 --> 00:43:57,790
authentication specifically in Android

974
00:43:57,790 --> 00:44:00,670
and Windows as well that's this one we

975
00:44:00,670 --> 00:44:02,290
actually doesn't require it but other

976
00:44:02,290 --> 00:44:04,180
buildings in higher level services does

977
00:44:04,180 --> 00:44:06,550
require some fun occasion bypass in

978
00:44:06,550 --> 00:44:09,300
order to figure them so I think maybe

979
00:44:09,300 --> 00:44:12,490
Android thinks the code is protected by

980
00:44:12,490 --> 00:44:15,940
this false safety mechanism and maybe

981
00:44:15,940 --> 00:44:17,410
that's that's the reason they haven't

982
00:44:17,410 --> 00:44:19,869
gone to all the lengths to make their

983
00:44:19,869 --> 00:44:22,150
code it better do you know do you know

984
00:44:22,150 --> 00:44:26,109
why this betrayed process is granted

985
00:44:26,109 --> 00:44:32,920
with decimals permission maybe you can

986
00:44:32,920 --> 00:44:35,460
maybe there's a feature to just which

987
00:44:35,460 --> 00:44:37,450
they have with the semester

988
00:44:37,450 --> 00:44:40,960
functionality if I'm not mistaken once

989
00:44:40,960 --> 00:44:43,810
back in the early 2000s it was possible

990
00:44:43,810 --> 00:44:47,619
to to use a Bluetooth headset and well

991
00:44:47,619 --> 00:44:49,720
you could use it for calls and I think

992
00:44:49,720 --> 00:44:51,579
there was some feature that would have

993
00:44:51,579 --> 00:44:53,290
allowed you to use it for texts as well

994
00:44:53,290 --> 00:44:56,680
and for sharing your contacts and it can

995
00:44:56,680 --> 00:44:58,420
also transfer files that's why it's

996
00:44:58,420 --> 00:45:00,400
accessible to all your pictures and

997
00:45:00,400 --> 00:45:01,119
everything

998
00:45:01,119 --> 00:45:04,720
Bluetooth like if think of any Bluetooth

999
00:45:04,720 --> 00:45:06,250
functionality or device that you've ever

1000
00:45:06,250 --> 00:45:09,220
seen so this one demon has all those

1001
00:45:09,220 --> 00:45:11,470
privileges which as we've shown are

1002
00:45:11,470 --> 00:45:13,720
effectively what the user can do on the

1003
00:45:13,720 --> 00:45:15,880
device the only thing it doesn't have is

1004
00:45:15,880 --> 00:45:22,980
the ability to route the phone yeah hi

1005
00:45:22,980 --> 00:45:25,839
how much time did you spend not

1006
00:45:25,839 --> 00:45:27,579
considering the emot-- execution

1007
00:45:27,579 --> 00:45:30,220
vulnerabilities on researching this

1008
00:45:30,220 --> 00:45:32,740
bluetooth problem this beautiful already

1009
00:45:32,740 --> 00:45:35,440
it's something that we've been doing in

1010
00:45:35,440 --> 00:45:37,150
the last year but we published in

1011
00:45:37,150 --> 00:45:40,300
September and that back in April it was

1012
00:45:40,300 --> 00:45:42,280
already in the process of doing the

1013
00:45:42,280 --> 00:45:44,500
disclosure process I think maybe three

1014
00:45:44,500 --> 00:45:47,050
months something like that not not of

1015
00:45:47,050 --> 00:45:48,880
something like that I'm just asking

1016
00:45:48,880 --> 00:45:50,020
because

1017
00:45:50,020 --> 00:45:51,430
you've wrote in your publication that

1018
00:45:51,430 --> 00:45:53,890
since Bluetooth 2.1 specification

1019
00:45:53,890 --> 00:45:57,670
withdraws in 2007 I think there was a

1020
00:45:57,670 --> 00:46:01,960
decade 10 years and nobody came up with

1021
00:46:01,960 --> 00:46:05,800
this serious linearity is it not to be

1022
00:46:05,800 --> 00:46:08,470
is it not probable that someone or only

1023
00:46:08,470 --> 00:46:10,630
found these vulnerabilities but didn't

1024
00:46:10,630 --> 00:46:14,880
publish it and it was exploited yeah

1025
00:46:16,530 --> 00:46:19,090
this is such a long time for such a

1026
00:46:19,090 --> 00:46:22,330
serious thing not to be discovered I

1027
00:46:22,330 --> 00:46:25,060
think I think it's the understanding of

1028
00:46:25,060 --> 00:46:27,220
that is that Bluetooth is very

1029
00:46:27,220 --> 00:46:30,670
complicated and it it made researchers

1030
00:46:30,670 --> 00:46:33,280
and attackers stay away from it they

1031
00:46:33,280 --> 00:46:36,130
don't want to read 280 800 pages of spec

1032
00:46:36,130 --> 00:46:39,550
to understand how to attack device so

1033
00:46:39,550 --> 00:46:41,800
another did we the reason we looked at

1034
00:46:41,800 --> 00:46:43,690
Bluetooth is because what our company

1035
00:46:43,690 --> 00:46:45,490
does is monitor among other things

1036
00:46:45,490 --> 00:46:47,710
Bluetooth connections so we already had

1037
00:46:47,710 --> 00:46:51,390
to look at that after that way yeah

1038
00:46:51,390 --> 00:46:58,690
thank you is there any anybody else with

1039
00:46:58,690 --> 00:47:02,470
a question no well in that case thank

1040
00:47:02,470 --> 00:47:04,910
you very much to Ben Thank You Gregory

1041
00:47:04,910 --> 00:47:10,428
[Applause]

