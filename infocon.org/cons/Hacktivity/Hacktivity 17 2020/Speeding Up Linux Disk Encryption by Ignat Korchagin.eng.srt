1
00:00:03,199 --> 00:00:04,319
hello everyone

2
00:00:04,319 --> 00:00:06,480
my name is ignat thanks for tuning in

3
00:00:06,480 --> 00:00:08,400
and today we are going to talk about

4
00:00:08,400 --> 00:00:10,080
how to speed up disk encryption and

5
00:00:10,080 --> 00:00:12,160
linux

6
00:00:12,160 --> 00:00:14,799
first a little bit about myself i work

7
00:00:14,799 --> 00:00:16,800
at cloudflare i mostly do performance

8
00:00:16,800 --> 00:00:18,160
and security

9
00:00:18,160 --> 00:00:21,039
i'm passionate about security and crypto

10
00:00:21,039 --> 00:00:23,199
and i also enjoy low level programming

11
00:00:23,199 --> 00:00:25,519
like linux kernel bootloaders

12
00:00:25,519 --> 00:00:28,840
and other low-level gary c

13
00:00:28,840 --> 00:00:32,238
stuff okay so let's go

14
00:00:32,238 --> 00:00:34,640
uh disk encryption uh before we dive

15
00:00:34,640 --> 00:00:37,280
into linux disk encryption specifically

16
00:00:37,280 --> 00:00:40,719
let's discuss uh first discuss about how

17
00:00:40,719 --> 00:00:42,800
to encrypt data at trust in general and

18
00:00:42,800 --> 00:00:44,000
there are many ways to do

19
00:00:44,000 --> 00:00:47,360
that and to review all of them uh

20
00:00:47,360 --> 00:00:50,480
we probably want first to review the

21
00:00:50,480 --> 00:00:53,120
typical operating system storage stack

22
00:00:53,120 --> 00:00:55,039
and all the different layers it has and

23
00:00:55,039 --> 00:00:56,000
how

24
00:00:56,000 --> 00:00:59,440
this encryption can fit in between so

25
00:00:59,440 --> 00:01:01,440
at the top of any storage stacks you

26
00:01:01,440 --> 00:01:03,920
have your application and services which

27
00:01:03,920 --> 00:01:06,640
run on your hardware and so these

28
00:01:06,640 --> 00:01:08,560
applications typically

29
00:01:08,560 --> 00:01:11,680
read and write data in files so

30
00:01:11,680 --> 00:01:14,479
they send these files to an operating

31
00:01:14,479 --> 00:01:15,360
system primitive

32
00:01:15,360 --> 00:01:18,240
a file system and then the file system

33
00:01:18,240 --> 00:01:20,400
typically translate these files into

34
00:01:20,400 --> 00:01:21,840
some kind of blocks because

35
00:01:21,840 --> 00:01:24,960
most modern persistent storage

36
00:01:24,960 --> 00:01:27,520
are some kind of blog devices so they

37
00:01:27,520 --> 00:01:28,560
store

38
00:01:28,560 --> 00:01:31,439
uh read and store data in blocks so file

39
00:01:31,439 --> 00:01:34,799
system translate files into blocks

40
00:01:34,799 --> 00:01:37,439
but file system cannot communicate with

41
00:01:37,439 --> 00:01:39,439
storage hardware directly there is

42
00:01:39,439 --> 00:01:41,119
usually another layer in the modern

43
00:01:41,119 --> 00:01:42,799
operating system which is called

44
00:01:42,799 --> 00:01:46,399
block subsystem which and knows how to

45
00:01:46,399 --> 00:01:48,399
talk to specific storage hardware so

46
00:01:48,399 --> 00:01:49,680
file systems

47
00:01:49,680 --> 00:01:52,240
uh send blocks to the blocks assist

48
00:01:52,240 --> 00:01:55,119
subsystem and then block subsystem

49
00:01:55,119 --> 00:01:58,320
sends these data blocks to

50
00:01:58,320 --> 00:02:01,520
particular storage hardware

51
00:02:01,520 --> 00:02:05,280
so with respect to disk encryption uh

52
00:02:05,280 --> 00:02:07,439
we and encrypting data interest we can

53
00:02:07,439 --> 00:02:08,318
probably

54
00:02:08,318 --> 00:02:10,239
insert encryption at each of these

55
00:02:10,239 --> 00:02:12,080
layers so first of all

56
00:02:12,080 --> 00:02:16,239
we can just encrypt we can just buy

57
00:02:16,239 --> 00:02:18,640
hardware which supports data encryption

58
00:02:18,640 --> 00:02:20,239
and there are some couple of standards

59
00:02:20,239 --> 00:02:21,280
around that

60
00:02:21,280 --> 00:02:25,520
which is sad as ed which stands for

61
00:02:25,520 --> 00:02:29,360
self-encrypting drives and opal standard

62
00:02:29,360 --> 00:02:32,400
secondly we can just encrypt

63
00:02:32,400 --> 00:02:34,319
the data as it passes through the

64
00:02:34,319 --> 00:02:36,000
operating system block subsystem

65
00:02:36,000 --> 00:02:39,120
and here we have the examples of

66
00:02:39,120 --> 00:02:41,120
lux the encrypt on linux which we're

67
00:02:41,120 --> 00:02:43,680
going to talk about in this presentation

68
00:02:43,680 --> 00:02:46,319
we also have the bitlocker for windows

69
00:02:46,319 --> 00:02:46,720
and

70
00:02:46,720 --> 00:02:50,239
file world on macos we can

71
00:02:50,239 --> 00:02:53,200
encrypt data in the file system layer

72
00:02:53,200 --> 00:02:55,599
and here again we have some examples of

73
00:02:55,599 --> 00:02:59,200
implementations in linux like ecryptfs

74
00:02:59,200 --> 00:03:01,200
which is an older one

75
00:03:01,200 --> 00:03:04,879
or a newer one it started as a hd4

76
00:03:04,879 --> 00:03:06,000
encryption

77
00:03:06,000 --> 00:03:08,400
implementation and later it become more

78
00:03:08,400 --> 00:03:09,920
generic and it's now called

79
00:03:09,920 --> 00:03:14,239
fs correct and finally of course we can

80
00:03:14,239 --> 00:03:16,159
encrypt or decrypt data directly in our

81
00:03:16,159 --> 00:03:17,280
applications

82
00:03:17,280 --> 00:03:20,800
so like there are many

83
00:03:20,800 --> 00:03:23,840
applications which support encryption

84
00:03:23,840 --> 00:03:27,040
natively they use okay they may use some

85
00:03:27,040 --> 00:03:28,799
kind of encryption libraries like open

86
00:03:28,799 --> 00:03:29,440
ssl

87
00:03:29,440 --> 00:03:33,440
tams or pgp

88
00:03:33,440 --> 00:03:35,200
let's review pros and cons of each

89
00:03:35,200 --> 00:03:36,799
prompt so

90
00:03:36,799 --> 00:03:38,799
first of all you can as i mentioned you

91
00:03:38,799 --> 00:03:41,200
can also you can just buy

92
00:03:41,200 --> 00:03:43,360
self-encrypted dives and it's they're

93
00:03:43,360 --> 00:03:44,720
quite easy

94
00:03:44,720 --> 00:03:48,640
so the pros of these solutions is just

95
00:03:48,640 --> 00:03:49,680
there

96
00:03:49,680 --> 00:03:51,280
and you require very little

97
00:03:51,280 --> 00:03:53,920
configuration to encrypt your data

98
00:03:53,920 --> 00:03:56,080
it's also uh this approach is fully

99
00:03:56,080 --> 00:03:58,000
transparent to the application so the

100
00:03:58,000 --> 00:03:59,200
applications do not

101
00:03:59,200 --> 00:04:02,319
even know or care if the data store is

102
00:04:02,319 --> 00:04:05,120
being encrypted because that's handled

103
00:04:05,120 --> 00:04:07,680
for them by the lower layers especially

104
00:04:07,680 --> 00:04:09,680
the storage hardware

105
00:04:09,680 --> 00:04:11,599
and it's usually faster than any other

106
00:04:11,599 --> 00:04:12,799
layers because

107
00:04:12,799 --> 00:04:14,480
the encryption is implemented the

108
00:04:14,480 --> 00:04:16,959
hardware itself and you don't you

109
00:04:16,959 --> 00:04:19,918
waste your main operating system cpu

110
00:04:19,918 --> 00:04:21,040
cycles to do

111
00:04:21,040 --> 00:04:24,160
the encryption the downside of the

112
00:04:24,160 --> 00:04:25,040
approach is

113
00:04:25,040 --> 00:04:27,280
that usually you have no visibility into

114
00:04:27,280 --> 00:04:28,400
the implementation

115
00:04:28,400 --> 00:04:31,840
most of these uh cell phone protein

116
00:04:31,840 --> 00:04:34,800
drives have proprietary firmware so and

117
00:04:34,800 --> 00:04:35,600
you have

118
00:04:35,600 --> 00:04:38,400
no auditability and which sometimes

119
00:04:38,400 --> 00:04:40,560
leads to poor security

120
00:04:40,560 --> 00:04:43,680
and one of the recent security findings

121
00:04:43,680 --> 00:04:44,400
around the

122
00:04:44,400 --> 00:04:47,440
self-encrypting drives were so

123
00:04:47,440 --> 00:04:51,919
bad that microsoft eventually decided

124
00:04:51,919 --> 00:04:55,759
and to use software data encryption by

125
00:04:55,759 --> 00:04:57,600
default in their windows operating

126
00:04:57,600 --> 00:04:59,840
system

127
00:04:59,840 --> 00:05:02,880
then we move upper up the stack

128
00:05:02,880 --> 00:05:05,280
we have our block layer encryption it's

129
00:05:05,280 --> 00:05:06,800
very similar to storage

130
00:05:06,800 --> 00:05:08,400
hardware encryption but it's

131
00:05:08,400 --> 00:05:10,000
implementing actually implemented

132
00:05:10,000 --> 00:05:11,600
actually in software in your operating

133
00:05:11,600 --> 00:05:14,560
system and it shares some of the

134
00:05:14,560 --> 00:05:17,759
characteristics so again

135
00:05:17,759 --> 00:05:21,280
you need little configuration

136
00:05:21,280 --> 00:05:23,440
to configure it again it's fully

137
00:05:23,440 --> 00:05:25,039
transparent to the

138
00:05:25,039 --> 00:05:28,720
application the upside of

139
00:05:28,720 --> 00:05:30,160
this if you have an open source

140
00:05:30,160 --> 00:05:32,880
operating system like linux it's also

141
00:05:32,880 --> 00:05:36,320
open on auditable you can look into the

142
00:05:36,320 --> 00:05:39,039
implementation and make sure it's as

143
00:05:39,039 --> 00:05:41,840
secure as you would like it to be there

144
00:05:41,840 --> 00:05:43,440
are downsides of course

145
00:05:43,440 --> 00:05:45,680
uh it requires somewhat specialized

146
00:05:45,680 --> 00:05:46,639
crypto

147
00:05:46,639 --> 00:05:50,240
because we already know that modern

148
00:05:50,240 --> 00:05:53,039
storage devices are blocked devices so

149
00:05:53,039 --> 00:05:53,919
we need to

150
00:05:53,919 --> 00:05:57,280
encrypt or decrypt data in blocks and

151
00:05:57,280 --> 00:05:58,479
that is

152
00:05:58,479 --> 00:06:01,120
not something which most crypto

153
00:06:01,120 --> 00:06:03,039
algorithms can do because they are based

154
00:06:03,039 --> 00:06:03,759
around

155
00:06:03,759 --> 00:06:06,400
a file or stream encryption so there are

156
00:06:06,400 --> 00:06:07,360
specific

157
00:06:07,360 --> 00:06:10,000
cipher modes which are designed

158
00:06:10,000 --> 00:06:12,080
specifically for storage

159
00:06:12,080 --> 00:06:13,759
uh disk encryption but they don't

160
00:06:13,759 --> 00:06:15,360
receive as much

161
00:06:15,360 --> 00:06:18,840
tension as the typical crypto were all

162
00:06:18,840 --> 00:06:20,240
used

163
00:06:20,240 --> 00:06:22,160
there all can also be some performance

164
00:06:22,160 --> 00:06:24,319
issues because now you have to do

165
00:06:24,319 --> 00:06:27,199
you have to use your main cpu to encrypt

166
00:06:27,199 --> 00:06:28,479
and equip data

167
00:06:28,479 --> 00:06:32,319
so there might be some obviously waste

168
00:06:32,319 --> 00:06:33,199
resource so

169
00:06:33,199 --> 00:06:34,400
there might be some performance

170
00:06:34,400 --> 00:06:37,120
regulation here and they're also

171
00:06:37,120 --> 00:06:39,919
like unlike the hardware disk encryption

172
00:06:39,919 --> 00:06:41,840
the encryption keys are not

173
00:06:41,840 --> 00:06:44,319
now stored in ram in the main operating

174
00:06:44,319 --> 00:06:45,440
system memory

175
00:06:45,440 --> 00:06:48,880
so if for example our operating system

176
00:06:48,880 --> 00:06:50,479
becomes compromised

177
00:06:50,479 --> 00:06:53,520
an attacker can actually grab that disk

178
00:06:53,520 --> 00:06:56,000
encryption

179
00:06:56,080 --> 00:06:57,680
then there is file system layer

180
00:06:57,680 --> 00:07:00,080
encryption it's

181
00:07:00,080 --> 00:07:03,360
like block layer encryption it's

182
00:07:03,360 --> 00:07:06,800
somewhat transparent to applications uh

183
00:07:06,800 --> 00:07:09,360
it's also open and audible if you have

184
00:07:09,360 --> 00:07:11,919
an open source operating system

185
00:07:11,919 --> 00:07:14,880
unlike block layer disk encryption it's

186
00:07:14,880 --> 00:07:17,120
more fine-grained so you can have like

187
00:07:17,120 --> 00:07:20,240
encrypted and unencrypted directories

188
00:07:20,240 --> 00:07:22,880
in your file system and you can have

189
00:07:22,880 --> 00:07:24,479
different directories with different

190
00:07:24,479 --> 00:07:27,520
encryption keys there is also

191
00:07:27,520 --> 00:07:29,440
more choice of crypto and potential

192
00:07:29,440 --> 00:07:31,280
integrity support because the file

193
00:07:31,280 --> 00:07:33,599
system layer has the visibility of a

194
00:07:33,599 --> 00:07:35,039
file

195
00:07:35,039 --> 00:07:38,479
so we can use either software only

196
00:07:38,479 --> 00:07:42,800
block cipher modes for block storage

197
00:07:42,800 --> 00:07:44,479
there are downsides of course again

198
00:07:44,479 --> 00:07:46,400
there are performance issues because

199
00:07:46,400 --> 00:07:48,960
we use our main cpu to do the encryption

200
00:07:48,960 --> 00:07:50,160
encryption

201
00:07:50,160 --> 00:07:52,879
as other software solutions we have our

202
00:07:52,879 --> 00:07:54,720
encryption keys and ram

203
00:07:54,720 --> 00:07:57,199
it's more complex configuration because

204
00:07:57,199 --> 00:07:59,759
all all these fine grain abilities

205
00:07:59,759 --> 00:08:01,599
you need to provide like fine grain

206
00:08:01,599 --> 00:08:04,400
configuration to actually make it work

207
00:08:04,400 --> 00:08:07,840
and the one downside is that

208
00:08:07,840 --> 00:08:09,919
people notice is the unencrypted

209
00:08:09,919 --> 00:08:12,080
metadata because usually with file

210
00:08:12,080 --> 00:08:12,639
system

211
00:08:12,639 --> 00:08:14,960
encryption the dating files are

212
00:08:14,960 --> 00:08:15,680
encrypted

213
00:08:15,680 --> 00:08:18,879
but not the metadata around these files

214
00:08:18,879 --> 00:08:22,160
like file names or file sizes as well as

215
00:08:22,160 --> 00:08:24,319
free space and the disk is not encrypted

216
00:08:24,319 --> 00:08:26,800
as well

217
00:08:26,800 --> 00:08:31,120
which provides some side channel

218
00:08:31,120 --> 00:08:33,919
attacker and of course you have the

219
00:08:33,919 --> 00:08:36,240
application layer encryption

220
00:08:36,240 --> 00:08:38,479
it's open and auditable well mostly

221
00:08:38,479 --> 00:08:39,760
because you if

222
00:08:39,760 --> 00:08:42,399
you as an application layer developer

223
00:08:42,399 --> 00:08:44,080
have to implement it yourself

224
00:08:44,080 --> 00:08:46,000
it's very fine-grained so if you're a

225
00:08:46,000 --> 00:08:47,760
developer you can implement

226
00:08:47,760 --> 00:08:50,560
whatever you want and you have focused

227
00:08:50,560 --> 00:08:53,040
crypto flexibility

228
00:08:53,040 --> 00:08:56,480
like the downside as as other

229
00:08:56,480 --> 00:08:59,920
software implementations so you have

230
00:08:59,920 --> 00:09:00,959
your encryption keys

231
00:09:00,959 --> 00:09:04,720
ram you have to actually code it where

232
00:09:04,720 --> 00:09:05,680
all the previous

233
00:09:05,680 --> 00:09:07,920
approaches were somewhat transparent so

234
00:09:07,920 --> 00:09:09,920
the applications do not need

235
00:09:09,920 --> 00:09:12,080
to have support in their code for data

236
00:09:12,080 --> 00:09:13,360
encryption

237
00:09:13,360 --> 00:09:17,200
now we have to actually write that code

238
00:09:17,200 --> 00:09:19,839
our application also we have the

239
00:09:19,839 --> 00:09:21,519
unencrypted metadata

240
00:09:21,519 --> 00:09:24,320
so we can only encrypt the data we're

241
00:09:24,320 --> 00:09:27,200
going to write in files not the rest

242
00:09:27,200 --> 00:09:29,680
and one of the downsides i think is

243
00:09:29,680 --> 00:09:31,680
again full crypto flexibility

244
00:09:31,680 --> 00:09:35,279
not every developer has the experience

245
00:09:35,279 --> 00:09:35,600
on

246
00:09:35,600 --> 00:09:38,480
proper knowledge to improv implement

247
00:09:38,480 --> 00:09:40,640
cryptography right and sometimes that

248
00:09:40,640 --> 00:09:43,519
may lead to very

249
00:09:43,519 --> 00:09:46,800
poor security and the overall solution

250
00:09:46,800 --> 00:09:47,600
is

251
00:09:47,600 --> 00:09:50,800
not secure even though we use some

252
00:09:50,800 --> 00:09:54,160
encryption in the application

253
00:09:54,240 --> 00:09:57,760
okay so let's move to linux

254
00:09:57,760 --> 00:10:01,279
why linux cloudflare like most

255
00:10:01,279 --> 00:10:04,160
sas companies prefer to use block layer

256
00:10:04,160 --> 00:10:05,440
disk encryption

257
00:10:05,440 --> 00:10:08,640
because from the service

258
00:10:08,640 --> 00:10:10,720
perspective from sas perspective you

259
00:10:10,720 --> 00:10:12,000
don't usually need

260
00:10:12,000 --> 00:10:15,200
defined grain abilities that application

261
00:10:15,200 --> 00:10:17,360
or file system layer

262
00:10:17,360 --> 00:10:20,079
provides but you also want more security

263
00:10:20,079 --> 00:10:22,000
but on the other hand we also don't want

264
00:10:22,000 --> 00:10:22,959
to rely on

265
00:10:22,959 --> 00:10:26,640
insecure hardware and well

266
00:10:26,640 --> 00:10:30,880
basically introduce

267
00:10:31,600 --> 00:10:33,920
introduce bad potentially bad and

268
00:10:33,920 --> 00:10:36,079
unverified crypto implementation

269
00:10:36,079 --> 00:10:38,720
our stack so that's why we choose open

270
00:10:38,720 --> 00:10:41,680
source linux disk

271
00:10:43,519 --> 00:10:46,160
but before we dive into dmcrypt which is

272
00:10:46,160 --> 00:10:48,000
the disk encryption implementation on

273
00:10:48,000 --> 00:10:49,600
linux we need to

274
00:10:49,600 --> 00:10:51,600
review device mapper first because the

275
00:10:51,600 --> 00:10:54,079
encrypt is a device mapper module

276
00:10:54,079 --> 00:10:56,399
so what is device mapper and linux again

277
00:10:56,399 --> 00:10:58,640
we have our applications and we already

278
00:10:58,640 --> 00:11:00,640
established that they do

279
00:11:00,640 --> 00:11:02,399
read and write files from the file

280
00:11:02,399 --> 00:11:05,120
systems then the file systems translate

281
00:11:05,120 --> 00:11:06,800
these files into blocks and

282
00:11:06,800 --> 00:11:09,440
send these blocks to block device

283
00:11:09,440 --> 00:11:10,240
drivers

284
00:11:10,240 --> 00:11:12,480
the device mapper framework in linux can

285
00:11:12,480 --> 00:11:14,720
insert itself in between

286
00:11:14,720 --> 00:11:16,720
the file systems and the block device

287
00:11:16,720 --> 00:11:18,800
drivers and provide some

288
00:11:18,800 --> 00:11:21,440
additional functionality for example we

289
00:11:21,440 --> 00:11:23,600
have the dm raid module which

290
00:11:23,600 --> 00:11:25,600
can help you to build software radio

291
00:11:25,600 --> 00:11:27,040
arrays and linux

292
00:11:27,040 --> 00:11:30,480
and particularly for this presentation

293
00:11:30,480 --> 00:11:32,320
we're interested in the dm

294
00:11:32,320 --> 00:11:34,399
crypt module which provides transparent

295
00:11:34,399 --> 00:11:36,640
disk encryption to the data before

296
00:11:36,640 --> 00:11:39,519
it gets to the block device drivers so

297
00:11:39,519 --> 00:11:40,079
let's

298
00:11:40,079 --> 00:11:43,279
zoom in to the dmcrypt module

299
00:11:43,279 --> 00:11:46,240
again we have our file systems and we

300
00:11:46,240 --> 00:11:46,800
have the

301
00:11:46,800 --> 00:11:49,600
log device drivers so what dmcrip does

302
00:11:49,600 --> 00:11:50,079
it

303
00:11:50,079 --> 00:11:53,040
inserts itself as a rest of device

304
00:11:53,040 --> 00:11:54,240
mapper modules

305
00:11:54,240 --> 00:11:55,839
in between the file system and the block

306
00:11:55,839 --> 00:11:58,160
device driver

307
00:11:58,160 --> 00:12:01,279
so when a file system needs to write a

308
00:12:01,279 --> 00:12:03,120
block to the block device driver the

309
00:12:03,120 --> 00:12:04,480
encrypt intercepts it

310
00:12:04,480 --> 00:12:06,800
and encrypts it and sends it down the

311
00:12:06,800 --> 00:12:07,839
stack

312
00:12:07,839 --> 00:12:10,160
when the file system needs to read some

313
00:12:10,160 --> 00:12:11,600
data from the desk

314
00:12:11,600 --> 00:12:14,959
it inter reads the data decrypts it and

315
00:12:14,959 --> 00:12:15,360
then

316
00:12:15,360 --> 00:12:17,200
sends the decrypted result to the

317
00:12:17,200 --> 00:12:19,360
process

318
00:12:19,360 --> 00:12:21,920
and on top of that dm crypt doesn't

319
00:12:21,920 --> 00:12:23,920
implement its own crypto which is good

320
00:12:23,920 --> 00:12:24,800
it uses

321
00:12:24,800 --> 00:12:27,040
the linux kernel standard crypto api

322
00:12:27,040 --> 00:12:28,160
which have

323
00:12:28,160 --> 00:12:30,880
open source and have been around for a

324
00:12:30,880 --> 00:12:32,720
while so we hope it

325
00:12:32,720 --> 00:12:35,600
received very much attention on the

326
00:12:35,600 --> 00:12:37,040
security cam

327
00:12:37,040 --> 00:12:38,959
community and it's probably secure

328
00:12:38,959 --> 00:12:40,399
enough for

329
00:12:40,399 --> 00:12:43,120
most of these

330
00:12:45,440 --> 00:12:48,480
so it was all well and good but at some

331
00:12:48,480 --> 00:12:50,800
point we noticed that our service

332
00:12:50,800 --> 00:12:55,519
is not performing as we like it to be

333
00:12:55,519 --> 00:12:58,079
and so the performance was poor and we

334
00:12:58,079 --> 00:12:59,680
started to

335
00:12:59,680 --> 00:13:03,680
race it down and we realized that

336
00:13:03,680 --> 00:13:05,760
part of the performance degradation was

337
00:13:05,760 --> 00:13:07,440
attributed to the

338
00:13:07,440 --> 00:13:09,519
transparent disk encryption so we

339
00:13:09,519 --> 00:13:12,240
decided to benchmark it

340
00:13:12,240 --> 00:13:14,240
more thoroughly to understand what it

341
00:13:14,240 --> 00:13:15,920
means

342
00:13:15,920 --> 00:13:20,959
basically for this specific benchmark we

343
00:13:20,959 --> 00:13:23,440
want to avoid any potential bias a

344
00:13:23,440 --> 00:13:25,839
typical

345
00:13:25,839 --> 00:13:27,680
storage hardware might have so we

346
00:13:27,680 --> 00:13:28,959
decided to remove

347
00:13:28,959 --> 00:13:31,760
storage hardware out of the picture this

348
00:13:31,760 --> 00:13:33,279
would help us

349
00:13:33,279 --> 00:13:35,760
share the results with other developers

350
00:13:35,760 --> 00:13:37,360
outside of the company and they can

351
00:13:37,360 --> 00:13:39,600
probably reproduce same results because

352
00:13:39,600 --> 00:13:40,079
they

353
00:13:40,079 --> 00:13:42,399
they are not they may not have access on

354
00:13:42,399 --> 00:13:44,560
to a specific storage hardware

355
00:13:44,560 --> 00:13:48,480
so instead of using a real disk for this

356
00:13:48,480 --> 00:13:49,199
benchmark

357
00:13:49,199 --> 00:13:52,639
we used a so-called ram-based

358
00:13:52,639 --> 00:13:55,839
uh disk which uh

359
00:13:55,839 --> 00:13:59,040
basically a virtual disk emulated in ram

360
00:13:59,040 --> 00:14:00,800
and on linux you can create one very

361
00:14:00,800 --> 00:14:02,079
easily with the

362
00:14:02,079 --> 00:14:04,399
rd module so this command for example

363
00:14:04,399 --> 00:14:05,360
creates

364
00:14:05,360 --> 00:14:10,079
us a four gigabyte ram disk

365
00:14:10,320 --> 00:14:12,480
now uh to test this conclusion we need

366
00:14:12,480 --> 00:14:15,680
to allocate a two megabyte separate file

367
00:14:15,680 --> 00:14:19,199
it's called lux detach header and i will

368
00:14:19,199 --> 00:14:19,760
explain

369
00:14:19,760 --> 00:14:22,800
why we need to detach header in a second

370
00:14:22,800 --> 00:14:26,639
and then we just

371
00:14:26,639 --> 00:14:29,760
prepare our new virtual desk

372
00:14:29,760 --> 00:14:32,959
for encryption we format it with lux

373
00:14:32,959 --> 00:14:35,920
and then we instantiate a dmcrypt

374
00:14:35,920 --> 00:14:36,560
instance

375
00:14:36,560 --> 00:14:39,680
on top of our ram desktop we get an

376
00:14:39,680 --> 00:14:42,720
encrypted random so

377
00:14:42,720 --> 00:14:46,079
here's our test storage stack so at the

378
00:14:46,079 --> 00:14:48,320
bottom layer we have our virtual

379
00:14:48,320 --> 00:14:51,760
ram disk uh on top we can create we

380
00:14:51,760 --> 00:14:54,240
we created the encrypt instance which

381
00:14:54,240 --> 00:14:55,839
provides transparent

382
00:14:55,839 --> 00:14:59,600
encryption and decryption of data

383
00:14:59,600 --> 00:15:01,760
and at the file system we will not use

384
00:15:01,760 --> 00:15:04,399
any file system for this benchmarking

385
00:15:04,399 --> 00:15:06,320
just because again we don't want to

386
00:15:06,320 --> 00:15:08,880
introduce the bias of a particular file

387
00:15:08,880 --> 00:15:10,399
system implementation in

388
00:15:10,399 --> 00:15:14,000
the result instead what we can do is

389
00:15:14,000 --> 00:15:17,199
we can read and write data to this

390
00:15:17,199 --> 00:15:19,680
encrypt instance directly which will be

391
00:15:19,680 --> 00:15:21,680
transparently encrypted or decrypted by

392
00:15:21,680 --> 00:15:23,600
the operating system

393
00:15:23,600 --> 00:15:27,360
and we can compare that throughput

394
00:15:27,360 --> 00:15:30,639
by reading and writing data to the

395
00:15:30,639 --> 00:15:32,800
underlying virtual disk directly by

396
00:15:32,800 --> 00:15:35,040
passing the encryption layer

397
00:15:35,040 --> 00:15:38,079
and that's why we actually needed the

398
00:15:38,079 --> 00:15:39,040
two megabyte

399
00:15:39,040 --> 00:15:41,839
lux header uh we needed we needed a

400
00:15:41,839 --> 00:15:43,600
touch header because if we

401
00:15:43,600 --> 00:15:46,639
use the default non-detached header that

402
00:15:46,639 --> 00:15:49,199
header would be stored on the underlying

403
00:15:49,199 --> 00:15:51,279
virtual ram disk and if we do the

404
00:15:51,279 --> 00:15:53,600
unencrypted read and write operation

405
00:15:53,600 --> 00:15:56,720
into first two megabytes of the disk we

406
00:15:56,720 --> 00:15:58,639
may accidentally erase

407
00:15:58,639 --> 00:16:01,600
that header and break the whole setup so

408
00:16:01,600 --> 00:16:04,800
this logs the touch header enables us to

409
00:16:04,800 --> 00:16:07,120
read and write data both to unincre

410
00:16:07,120 --> 00:16:08,880
unencrypted disk and encrypted disk

411
00:16:08,880 --> 00:16:09,440
without

412
00:16:09,440 --> 00:16:13,440
the risk of breaking this

413
00:16:13,440 --> 00:16:16,880
okay let's first check what is our

414
00:16:16,880 --> 00:16:20,079
the throughput of our ram disk

415
00:16:20,079 --> 00:16:22,720
basically this output of our ram before

416
00:16:22,720 --> 00:16:23,440
we do

417
00:16:23,440 --> 00:16:28,079
any encryption and we we we can

418
00:16:28,079 --> 00:16:31,759
create a artificial io workload

419
00:16:31,759 --> 00:16:35,360
or we have like 4k local

420
00:16:35,360 --> 00:16:38,720
and we do some

421
00:16:38,720 --> 00:16:41,839
sequential read and write and if you run

422
00:16:41,839 --> 00:16:43,759
this

423
00:16:43,759 --> 00:16:45,920
basically we can see our virtual run

424
00:16:45,920 --> 00:16:47,199
disk has

425
00:16:47,199 --> 00:16:49,279
put somewhere around more than one

426
00:16:49,279 --> 00:16:50,800
gigabyte per second

427
00:16:50,800 --> 00:16:52,959
for both reads and writes and the

428
00:16:52,959 --> 00:16:54,000
numbers are

429
00:16:54,000 --> 00:16:56,880
similar because it's a ram disk and ram

430
00:16:56,880 --> 00:16:57,759
it doesn't

431
00:16:57,759 --> 00:17:02,160
like reads and writes we have the same

432
00:17:03,360 --> 00:17:06,799
now we redo the same test

433
00:17:06,799 --> 00:17:09,520
we rerun the same io workflow but now

434
00:17:09,520 --> 00:17:10,480
using the

435
00:17:10,480 --> 00:17:13,760
adm crypt encrypted instance

436
00:17:13,760 --> 00:17:16,000
on top of our ram date so all the data

437
00:17:16,000 --> 00:17:17,520
we're going to read and write will be

438
00:17:17,520 --> 00:17:18,959
transparently encrypted

439
00:17:18,959 --> 00:17:22,559
or decrypted and here we see

440
00:17:22,559 --> 00:17:25,679
that this root put suddenly drops

441
00:17:25,679 --> 00:17:28,640
to 100 and somewhere around 150

442
00:17:28,640 --> 00:17:30,559
megabytes per second

443
00:17:30,559 --> 00:17:33,760
and yes we do understand that now we're

444
00:17:33,760 --> 00:17:36,320
encrypting the data we're wasting some

445
00:17:36,320 --> 00:17:37,440
cpu we're

446
00:17:37,440 --> 00:17:40,640
spending some resource to do that but

447
00:17:40,640 --> 00:17:43,840
basically it's actually more than seven

448
00:17:43,840 --> 00:17:46,799
times slower which is probably not

449
00:17:46,799 --> 00:17:50,320
we were expecting to see

450
00:17:50,400 --> 00:17:53,600
but what is the normal data so

451
00:17:53,600 --> 00:17:57,120
to calculate our desired data of

452
00:17:57,120 --> 00:18:00,240
what we can get we decided to

453
00:18:00,240 --> 00:18:04,000
follow this approach so the grip setup

454
00:18:04,000 --> 00:18:06,400
utility has an embedded benchmark which

455
00:18:06,400 --> 00:18:08,559
we can use to benchmark the performance

456
00:18:08,559 --> 00:18:09,919
or the throughput

457
00:18:09,919 --> 00:18:12,840
for specific crypto algorithm so we use

458
00:18:12,840 --> 00:18:14,080
asxps

459
00:18:14,080 --> 00:18:18,000
it's the default and dmcrypton logs and

460
00:18:18,000 --> 00:18:20,160
and this tool shows us that the raw

461
00:18:20,160 --> 00:18:22,160
performance of the crypto itself

462
00:18:22,160 --> 00:18:26,799
rode throughput somewhere around 100.8

463
00:18:26,799 --> 00:18:30,720
gigabyte per second so

464
00:18:30,720 --> 00:18:33,760
if we assume the worst case let's say if

465
00:18:33,760 --> 00:18:36,000
we just

466
00:18:36,000 --> 00:18:38,640
read the whole data from the desk and

467
00:18:38,640 --> 00:18:40,960
decrypt it later sequentially

468
00:18:40,960 --> 00:18:43,600
the combined throughput of the whole

469
00:18:43,600 --> 00:18:44,400
system

470
00:18:44,400 --> 00:18:46,880
should be still somewhere around 700

471
00:18:46,880 --> 00:18:48,960
megabytes per second

472
00:18:48,960 --> 00:18:51,200
but we are actually getting only 300

473
00:18:51,200 --> 00:18:53,600
megabytes per second

474
00:18:53,600 --> 00:18:56,960
combined through which is more than half

475
00:18:56,960 --> 00:19:02,080
than the expected worst case

476
00:19:02,480 --> 00:19:05,760
so we tried to optimize our setup uh

477
00:19:05,760 --> 00:19:07,919
we tried switching to different

478
00:19:07,919 --> 00:19:10,400
cryptographic algorithms but

479
00:19:10,400 --> 00:19:13,039
is xds seems to be the fastest at least

480
00:19:13,039 --> 00:19:14,240
on x86

481
00:19:14,240 --> 00:19:17,280
platforms and we tried experimenting

482
00:19:17,280 --> 00:19:19,440
with the encrypt optional flags so bm

483
00:19:19,440 --> 00:19:21,200
crypt has some specific

484
00:19:21,200 --> 00:19:24,080
local performance flag encrypt cpu and

485
00:19:24,080 --> 00:19:26,559
submit concrete cpus

486
00:19:26,559 --> 00:19:29,760
which the man page indicates that they

487
00:19:29,760 --> 00:19:30,400
may

488
00:19:30,400 --> 00:19:33,440
improve performance we tried those they

489
00:19:33,440 --> 00:19:36,000
didn't help

490
00:19:36,720 --> 00:19:39,919
we also try to move from disk

491
00:19:39,919 --> 00:19:42,480
layer encryption to file system layer

492
00:19:42,480 --> 00:19:43,440
encryption

493
00:19:43,440 --> 00:19:45,919
because we would probably encrypt less

494
00:19:45,919 --> 00:19:47,280
data

495
00:19:47,280 --> 00:19:49,840
we don't encrypt empty space file system

496
00:19:49,840 --> 00:19:51,520
metadata and so on

497
00:19:51,520 --> 00:19:53,600
but in the end it was still much slower

498
00:19:53,600 --> 00:19:56,959
and potentially less

499
00:19:58,400 --> 00:20:01,120
so we were in despair we tried

500
00:20:01,120 --> 00:20:03,039
everything and nothing helped

501
00:20:03,039 --> 00:20:05,520
we are so desperate so we decided to

502
00:20:05,520 --> 00:20:06,320
write about

503
00:20:06,320 --> 00:20:09,760
our findings in the the encrypt mailing

504
00:20:09,760 --> 00:20:10,320
list

505
00:20:10,320 --> 00:20:14,480
but all the answer we got is

506
00:20:14,480 --> 00:20:18,080
this the answer we got is if the numbers

507
00:20:18,080 --> 00:20:19,039
disturb you

508
00:20:19,039 --> 00:20:20,960
then this is from lack of understanding

509
00:20:20,960 --> 00:20:22,159
on your side

510
00:20:22,159 --> 00:20:24,080
you're probably unaware that encryption

511
00:20:24,080 --> 00:20:26,320
is a heavyweight operation

512
00:20:26,320 --> 00:20:28,240
and at this point i was wondering is

513
00:20:28,240 --> 00:20:31,200
really crypto can be that expensive

514
00:20:31,200 --> 00:20:33,520
so i decided to do a proper scientific

515
00:20:33,520 --> 00:20:35,360
research on that topic

516
00:20:35,360 --> 00:20:38,000
and by proper scientific research what i

517
00:20:38,000 --> 00:20:39,440
mean is i type

518
00:20:39,440 --> 00:20:41,840
is crypto expensive into google search

519
00:20:41,840 --> 00:20:43,520
form

520
00:20:43,520 --> 00:20:46,000
but surprisingly one of the top results

521
00:20:46,000 --> 00:20:47,039
i got

522
00:20:47,039 --> 00:20:49,679
is a blog post from our own company the

523
00:20:49,679 --> 00:20:51,600
cloudflare blog post which

524
00:20:51,600 --> 00:20:54,080
where one of my colleagues uh

525
00:20:54,080 --> 00:20:56,640
investigate the performance of crypto

526
00:20:56,640 --> 00:20:58,159
but not in the context

527
00:20:58,159 --> 00:21:01,280
of data encryption and rust but in the

528
00:21:01,280 --> 00:21:02,799
context of tls

529
00:21:02,799 --> 00:21:05,039
so cloud 4 terminates a lot of tls

530
00:21:05,039 --> 00:21:07,200
connections

531
00:21:07,200 --> 00:21:09,440
and so yeah we do a lot of tls

532
00:21:09,440 --> 00:21:11,440
handshakes and also we encrypt a lot of

533
00:21:11,440 --> 00:21:12,159
data

534
00:21:12,159 --> 00:21:14,640
to send over the network and the

535
00:21:14,640 --> 00:21:16,000
colleague of mine

536
00:21:16,000 --> 00:21:19,039
uh investigated what are the costs

537
00:21:19,039 --> 00:21:22,080
associated with that and surprisingly

538
00:21:22,080 --> 00:21:25,280
uh the conclusion is that using tls is

539
00:21:25,280 --> 00:21:27,840
very cheap even at our scale

540
00:21:27,840 --> 00:21:30,000
and modern crypto is very fast with

541
00:21:30,000 --> 00:21:30,960
asgcm

542
00:21:30,960 --> 00:21:34,240
and d256 being great example so

543
00:21:34,240 --> 00:21:37,440
um in this post

544
00:21:37,440 --> 00:21:40,240
show that like cloudflare uses less than

545
00:21:40,240 --> 00:21:41,280
three percent

546
00:21:41,280 --> 00:21:44,559
cpu basically 40 lessons

547
00:21:44,559 --> 00:21:48,320
so if encryption is so cheap for tls

548
00:21:48,320 --> 00:21:51,520
why should it be very expensive for

549
00:21:51,520 --> 00:21:54,080
disk encryption because under the hood

550
00:21:54,080 --> 00:21:56,840
they mostly use the same crypto

551
00:21:56,840 --> 00:21:58,080
algorithm

552
00:21:58,080 --> 00:22:00,720
this is where we decided to take a

553
00:22:00,720 --> 00:22:01,600
closer look

554
00:22:01,600 --> 00:22:03,760
into the disk encryption implementation

555
00:22:03,760 --> 00:22:04,960
and linux

556
00:22:04,960 --> 00:22:08,080
and we find some interesting things so

557
00:22:08,080 --> 00:22:10,080
again

558
00:22:10,080 --> 00:22:12,559
we have our file system we have the

559
00:22:12,559 --> 00:22:14,880
underlying block device drivers

560
00:22:14,880 --> 00:22:18,080
uh we have the dmcrypt and we have the

561
00:22:18,080 --> 00:22:19,039
crypto api

562
00:22:19,039 --> 00:22:23,440
to actually do the encryption turns out

563
00:22:23,440 --> 00:22:26,320
when the file system issues a write

564
00:22:26,320 --> 00:22:27,120
request so

565
00:22:27,120 --> 00:22:29,280
the file system wants to write a block

566
00:22:29,280 --> 00:22:31,280
the underlying log device

567
00:22:31,280 --> 00:22:33,760
and dmcryp intercepts it but it doesn't

568
00:22:33,760 --> 00:22:34,640
process it

569
00:22:34,640 --> 00:22:36,400
immediately it doesn't encrypt it and

570
00:22:36,400 --> 00:22:38,240
send it to the block device driver

571
00:22:38,240 --> 00:22:39,360
instead

572
00:22:39,360 --> 00:22:43,120
it has a queue implemented in the

573
00:22:43,120 --> 00:22:45,919
encrypt itself called kkrd and it cues

574
00:22:45,919 --> 00:22:49,919
that request for some time

575
00:22:49,919 --> 00:22:53,039
then when the time is right the encrypt

576
00:22:53,039 --> 00:22:57,039
sends that request to the crypto api

577
00:22:57,039 --> 00:22:58,960
to actually being encrypted but crypto

578
00:22:58,960 --> 00:23:00,559
ap modern crypto api

579
00:23:00,559 --> 00:23:03,520
is asynchronous as well so it may not

580
00:23:03,520 --> 00:23:04,640
immediately

581
00:23:04,640 --> 00:23:07,919
encrypt the data it may also cue

582
00:23:07,919 --> 00:23:09,360
internally and unlike

583
00:23:09,360 --> 00:23:12,159
the encrypt which has one queue for the

584
00:23:12,159 --> 00:23:14,320
encrypt instance crypto api has one

585
00:23:14,320 --> 00:23:15,360
queue per cpu

586
00:23:15,360 --> 00:23:19,520
so the more cpus you have more

587
00:23:19,520 --> 00:23:23,200
but still the request may

588
00:23:23,200 --> 00:23:26,240
spend some time in this queue

589
00:23:26,240 --> 00:23:28,080
then when the time is right the crypto

590
00:23:28,080 --> 00:23:29,760
api encrypts the request

591
00:23:29,760 --> 00:23:31,520
and sends it back to the encrypt but the

592
00:23:31,520 --> 00:23:33,600
m crypt does not dispatch is

593
00:23:33,600 --> 00:23:37,039
a dispatcher immediately instead it

594
00:23:37,039 --> 00:23:39,200
stores it into another queue which is

595
00:23:39,200 --> 00:23:41,440
basically a red black tree

596
00:23:41,440 --> 00:23:44,799
for sorting then it sorts

597
00:23:44,799 --> 00:23:47,919
these requests and but does not

598
00:23:47,919 --> 00:23:50,799
dispatch it immediately again it stores

599
00:23:50,799 --> 00:23:52,320
it on yet another queue called the

600
00:23:52,320 --> 00:23:53,840
encrypt write

601
00:23:53,840 --> 00:23:56,000
which later when the time is right

602
00:23:56,000 --> 00:23:59,600
actually sends the data to the blogger

603
00:23:59,600 --> 00:24:01,520
similar things happens on read when the

604
00:24:01,520 --> 00:24:02,720
file system was to

605
00:24:02,720 --> 00:24:05,919
read a blog emcrypt doesn't read the

606
00:24:05,919 --> 00:24:07,039
data

607
00:24:07,039 --> 00:24:09,200
immediately it stores the request and

608
00:24:09,200 --> 00:24:10,480
yet another queue

609
00:24:10,480 --> 00:24:14,320
called k2d then when the time is right

610
00:24:14,320 --> 00:24:16,159
it actually sends a request down the

611
00:24:16,159 --> 00:24:16,640
stack

612
00:24:16,640 --> 00:24:20,400
reads the data and when it gets the data

613
00:24:20,400 --> 00:24:21,279
back

614
00:24:21,279 --> 00:24:23,200
it doesn't decrypt it immediately again

615
00:24:23,200 --> 00:24:25,200
it stores into our family k

616
00:24:25,200 --> 00:24:28,480
group dq or and

617
00:24:28,480 --> 00:24:31,440
sometime later dispatches it to the

618
00:24:31,440 --> 00:24:32,720
crypto api

619
00:24:32,720 --> 00:24:36,320
where the crypto bi can queue it again

620
00:24:36,320 --> 00:24:39,600
it can basically

621
00:24:39,679 --> 00:24:42,320
then when the crypto api decrypts the

622
00:24:42,320 --> 00:24:46,159
data it sends it back to the class

623
00:24:46,159 --> 00:24:48,480
and that's a lot of cueing to just

624
00:24:48,480 --> 00:24:49,520
process one

625
00:24:49,520 --> 00:24:53,120
single block reader right

626
00:24:53,120 --> 00:24:56,320
last year i was at srikon

627
00:24:56,320 --> 00:24:58,240
in singapore and there was a nice

628
00:24:58,240 --> 00:25:00,400
presentation from google engineers about

629
00:25:00,400 --> 00:25:02,720
the relationship between

630
00:25:02,720 --> 00:25:04,640
the queuing and the tail latency in

631
00:25:04,640 --> 00:25:05,840
computer systems

632
00:25:05,840 --> 00:25:08,320
and this is a great presentation on its

633
00:25:08,320 --> 00:25:10,720
own and i encourage everyone to watch it

634
00:25:10,720 --> 00:25:14,000
but one takeaway i got from there is a

635
00:25:14,000 --> 00:25:16,480
significant amount of tail latencies due

636
00:25:16,480 --> 00:25:17,279
to

637
00:25:17,279 --> 00:25:19,919
doing water and basically this is what

638
00:25:19,919 --> 00:25:21,200
we see here

639
00:25:21,200 --> 00:25:25,120
and in this particular implementation

640
00:25:25,120 --> 00:25:28,400
a single request can be queued up to

641
00:25:28,400 --> 00:25:28,799
four

642
00:25:28,799 --> 00:25:32,320
times before actually getting

643
00:25:32,320 --> 00:25:34,960
the process

644
00:25:35,679 --> 00:25:38,320
we assume no malicious intention so like

645
00:25:38,320 --> 00:25:39,039
if these

646
00:25:39,039 --> 00:25:42,320
queues are in there so

647
00:25:42,320 --> 00:25:45,360
there must be a reason luckily most uh

648
00:25:45,360 --> 00:25:48,159
linux source code is in is in source

649
00:25:48,159 --> 00:25:49,440
control doesn't get

650
00:25:49,440 --> 00:25:52,320
so you can actually do some like a

651
00:25:52,320 --> 00:25:54,159
browser history and see why these

652
00:25:54,159 --> 00:25:55,520
specific use

653
00:25:55,520 --> 00:25:57,600
been added so i decided to do some jit

654
00:25:57,600 --> 00:25:59,760
archaeology

655
00:25:59,760 --> 00:26:02,720
and some of the finding that the k-crypt

656
00:26:02,720 --> 00:26:04,559
dq was there from the beginning

657
00:26:04,559 --> 00:26:06,080
when the initial the encrypt

658
00:26:06,080 --> 00:26:08,480
implementation was merged into the

659
00:26:08,480 --> 00:26:12,400
linux mainline but it was only for reads

660
00:26:12,400 --> 00:26:14,720
with the comment it would be very unwise

661
00:26:14,720 --> 00:26:16,480
to the decryption in an interrupt

662
00:26:16,480 --> 00:26:18,799
content

663
00:26:18,799 --> 00:26:20,880
some more queuing was added to reduce

664
00:26:20,880 --> 00:26:25,840
so-called kernel stack usage in 2006

665
00:26:26,320 --> 00:26:30,400
then uh floridian writes

666
00:26:30,400 --> 00:26:32,559
and are you sorting that red black tree

667
00:26:32,559 --> 00:26:33,440
was introduced

668
00:26:33,440 --> 00:26:36,159
somewhere in around 2015 with the common

669
00:26:36,159 --> 00:26:37,919
that

670
00:26:37,919 --> 00:26:40,559
this will improve performance for

671
00:26:40,559 --> 00:26:41,679
spinning discs

672
00:26:41,679 --> 00:26:45,200
but may improve some ssds it also

673
00:26:45,200 --> 00:26:47,520
mentions that it's better for cfq's step

674
00:26:47,520 --> 00:26:48,240
ruler but

675
00:26:48,240 --> 00:26:50,840
actually the scheduler is being

676
00:26:50,840 --> 00:26:53,840
deprecated

677
00:26:56,000 --> 00:26:58,960
and we are not on the first ones who saw

678
00:26:58,960 --> 00:27:02,559
the performance degradation for

679
00:27:02,559 --> 00:27:05,120
the successive queueing so they're like

680
00:27:05,120 --> 00:27:07,919
immediately in 2014 we we can see some

681
00:27:07,919 --> 00:27:10,080
commits we actually

682
00:27:10,080 --> 00:27:12,880
add these flags which we already tried

683
00:27:12,880 --> 00:27:13,440
before

684
00:27:13,440 --> 00:27:16,320
same crypt cpu and submit from cpus

685
00:27:16,320 --> 00:27:18,080
which actually

686
00:27:18,080 --> 00:27:21,439
disable some of these two

687
00:27:24,000 --> 00:27:28,080
but all that tends to believe that

688
00:27:28,080 --> 00:27:31,520
this is what was some time ago and the

689
00:27:31,520 --> 00:27:32,159
landscape

690
00:27:32,159 --> 00:27:35,840
changed a bit so based on all this

691
00:27:35,840 --> 00:27:38,720
archaeology what we understand is that

692
00:27:38,720 --> 00:27:40,799
most code and most that queueing

693
00:27:40,799 --> 00:27:42,880
was added was spinning disk in mind

694
00:27:42,880 --> 00:27:44,080
where we

695
00:27:44,080 --> 00:27:46,480
have this ko latency was much higher

696
00:27:46,480 --> 00:27:48,640
than the current scheduling latency so

697
00:27:48,640 --> 00:27:50,559
it was very easy to add this

698
00:27:50,559 --> 00:27:52,399
asynchronous behavior because the

699
00:27:52,399 --> 00:27:54,720
context switching over cpu's red

700
00:27:54,720 --> 00:27:57,760
was negligible compared to the pinning

701
00:27:57,760 --> 00:28:00,640
disk io later

702
00:28:00,880 --> 00:28:02,960
sorting a block io request in the

703
00:28:02,960 --> 00:28:05,360
encrypt probably violates do one thing

704
00:28:05,360 --> 00:28:07,200
and do it well principle a unix

705
00:28:07,200 --> 00:28:08,640
principle so

706
00:28:08,640 --> 00:28:10,320
the encrypt is for encrypting and

707
00:28:10,320 --> 00:28:12,000
decrypting data

708
00:28:12,000 --> 00:28:14,559
performancing should probably not live

709
00:28:14,559 --> 00:28:16,080
in the encrypt and it's probably

710
00:28:16,080 --> 00:28:20,240
the task for the iosha euro instead

711
00:28:20,399 --> 00:28:23,520
uh okay krypd was basically added

712
00:28:23,520 --> 00:28:24,000
because

713
00:28:24,000 --> 00:28:28,159
back in 2005 the linux crypto api was

714
00:28:28,159 --> 00:28:29,440
synchronous

715
00:28:29,440 --> 00:28:31,919
and that's why as the comment mentions

716
00:28:31,919 --> 00:28:33,039
we need to avoid

717
00:28:33,039 --> 00:28:35,200
and encryption operation and interrupt

718
00:28:35,200 --> 00:28:37,600
context the k2d was added but modern

719
00:28:37,600 --> 00:28:40,240
crypto api is asynchronous as well

720
00:28:40,240 --> 00:28:45,360
so k3d may be just redundant

721
00:28:45,360 --> 00:28:48,159
so we decided to try to clean it up we

722
00:28:48,159 --> 00:28:49,440
decided to throw away

723
00:28:49,440 --> 00:28:51,840
all this extensive queuing and logic and

724
00:28:51,840 --> 00:28:53,279
basically convert

725
00:28:53,279 --> 00:28:56,480
this implementation back

726
00:28:56,480 --> 00:29:00,159
and make it fully synchronous and

727
00:29:00,159 --> 00:29:02,399
make it look like somewhere like this

728
00:29:02,399 --> 00:29:03,600
like we thought it

729
00:29:03,600 --> 00:29:05,039
would like to be so basically the

730
00:29:05,039 --> 00:29:07,200
encrypt just encrypts and decrypts data

731
00:29:07,200 --> 00:29:09,440
without any additional logic

732
00:29:09,440 --> 00:29:12,399
and on top of that we wanted to avoid

733
00:29:12,399 --> 00:29:12,960
even

734
00:29:12,960 --> 00:29:15,039
the asynchronous behavior in linux group

735
00:29:15,039 --> 00:29:17,520
to api so we

736
00:29:17,520 --> 00:29:19,360
wanted to make linux script bi

737
00:29:19,360 --> 00:29:21,440
synchronous as well and see how far can

738
00:29:21,440 --> 00:29:23,840
we go

739
00:29:24,559 --> 00:29:26,720
so we did a simple patch for the dmcrypt

740
00:29:26,720 --> 00:29:29,279
module uh which bypasses all queues or

741
00:29:29,279 --> 00:29:31,360
asynchronous threads but based on a new

742
00:29:31,360 --> 00:29:33,760
runtime flag

743
00:29:33,760 --> 00:29:36,960
uh with linux screw api crypto api it's

744
00:29:36,960 --> 00:29:38,399
a bit more complicated

745
00:29:38,399 --> 00:29:41,520
and by default linux

746
00:29:41,520 --> 00:29:43,679
linux may have different implementations

747
00:29:43,679 --> 00:29:45,279
of the same crypto and build written and

748
00:29:45,279 --> 00:29:47,200
the specific implementation

749
00:29:47,200 --> 00:29:49,440
is selected by the kernel based on the

750
00:29:49,440 --> 00:29:50,480
configured

751
00:29:50,480 --> 00:29:54,080
priorities um uh

752
00:29:54,080 --> 00:29:56,480
but we all want to avoid that kernel

753
00:29:56,480 --> 00:29:58,480
making decision and we wanted to force

754
00:29:58,480 --> 00:30:01,440
our implementation to use is ni which is

755
00:30:01,440 --> 00:30:06,080
x86 hardware accelerated crypto

756
00:30:06,080 --> 00:30:09,360
on our servers but sometimes

757
00:30:09,360 --> 00:30:12,640
and isn't i implementation needs fpu

758
00:30:12,640 --> 00:30:15,840
floating point unit but in linux kernel

759
00:30:15,840 --> 00:30:18,880
sometimes you cannot use that floating

760
00:30:18,880 --> 00:30:20,240
point unit

761
00:30:20,240 --> 00:30:23,840
interrupt contact so we came up with

762
00:30:23,840 --> 00:30:24,480
this

763
00:30:24,480 --> 00:30:27,279
uh new crypto api model called xts proxy

764
00:30:27,279 --> 00:30:28,159
which is a

765
00:30:28,159 --> 00:30:32,640
dedicated synchronous ix xts model

766
00:30:32,640 --> 00:30:34,960
but we know that it's very dangerous to

767
00:30:34,960 --> 00:30:36,000
roll your own crypto

768
00:30:36,000 --> 00:30:38,320
so this module does not implement any

769
00:30:38,320 --> 00:30:39,440
crypto on its own

770
00:30:39,440 --> 00:30:42,399
instead it's just a simple switch where

771
00:30:42,399 --> 00:30:42,799
if

772
00:30:42,799 --> 00:30:45,760
in the current context fpu is available

773
00:30:45,760 --> 00:30:47,520
and happens like 99

774
00:30:47,520 --> 00:30:49,200
of the cases it just forwards the

775
00:30:49,200 --> 00:30:51,279
encryption or decryption request

776
00:30:51,279 --> 00:30:53,279
to the already present in the linux

777
00:30:53,279 --> 00:30:56,399
kernel asnr implementation

778
00:30:56,399 --> 00:30:58,880
and in rare cases where we cannot use a

779
00:30:58,880 --> 00:31:00,960
fpu and thus asni

780
00:31:00,960 --> 00:31:02,960
we direct it to the more generic

781
00:31:02,960 --> 00:31:05,039
software is implementation which

782
00:31:05,039 --> 00:31:08,240
doesn't require the use of the fpu

783
00:31:08,240 --> 00:31:10,000
but still it's all synchronous it

784
00:31:10,000 --> 00:31:12,240
doesn't have any asynchronous behavior

785
00:31:12,240 --> 00:31:12,960
or threats

786
00:31:12,960 --> 00:31:18,399
it processes data as it comes in

787
00:31:18,399 --> 00:31:21,679
so let's benchmark our setup uh

788
00:31:21,679 --> 00:31:24,799
so we restart our synthetic io workflow

789
00:31:24,799 --> 00:31:28,720
on our encrypted disk

790
00:31:28,720 --> 00:31:30,799
luckily because we implemented this as a

791
00:31:30,799 --> 00:31:32,480
runtime flag we can already

792
00:31:32,480 --> 00:31:36,240
start our io uh your workload and

793
00:31:36,240 --> 00:31:38,159
reconfigure the way how the kernel

794
00:31:38,159 --> 00:31:39,440
encrypts data later

795
00:31:39,440 --> 00:31:43,120
just underneath the application live

796
00:31:43,120 --> 00:31:45,840
first of all we just need to load our

797
00:31:45,840 --> 00:31:46,640
new custom

798
00:31:46,640 --> 00:31:49,600
xts proxy encrypted api implementation

799
00:31:49,600 --> 00:31:51,039
into the kernel

800
00:31:51,039 --> 00:31:55,279
and then we run this very scary command

801
00:31:55,279 --> 00:31:59,120
to enable our patches but

802
00:31:59,120 --> 00:32:00,880
and this command basically does two

803
00:32:00,880 --> 00:32:03,679
things first it tells the encrypt

804
00:32:03,679 --> 00:32:06,000
not to rely on the kernel to select a

805
00:32:06,000 --> 00:32:06,880
particular

806
00:32:06,880 --> 00:32:10,000
is implementation for us but explicitly

807
00:32:10,000 --> 00:32:11,120
tell it to

808
00:32:11,120 --> 00:32:14,080
select our new xds proxy module for as

809
00:32:14,080 --> 00:32:15,600
encryption

810
00:32:15,600 --> 00:32:19,279
and secondly we basically enable our

811
00:32:19,279 --> 00:32:21,519
the flag introduced by our patch we tell

812
00:32:21,519 --> 00:32:22,559
the dm crypt

813
00:32:22,559 --> 00:32:25,360
itself to bypass any queueing or

814
00:32:25,360 --> 00:32:26,840
asynchronous threads into the

815
00:32:26,840 --> 00:32:29,120
implemented

816
00:32:29,120 --> 00:32:31,679
and finally for the the settings to take

817
00:32:31,679 --> 00:32:32,640
effect

818
00:32:32,640 --> 00:32:34,720
basically we need to do this suspend and

819
00:32:34,720 --> 00:32:37,760
resume operation

820
00:32:39,279 --> 00:32:42,320
and basically this is a result

821
00:32:42,320 --> 00:32:45,519
and this is the read throughput uh

822
00:32:45,519 --> 00:32:48,720
from our encrypted ram desk and craft on

823
00:32:48,720 --> 00:32:50,960
the fancy grafana dashboard

824
00:32:50,960 --> 00:32:53,840
you can see and this here we can clearly

825
00:32:53,840 --> 00:32:55,360
see the point where we

826
00:32:55,360 --> 00:32:58,640
enable our patch in runtime so before we

827
00:32:58,640 --> 00:32:58,960
had

828
00:32:58,960 --> 00:33:02,240
less than 150 megabyte per second of

829
00:33:02,240 --> 00:33:03,600
reach throughput

830
00:33:03,600 --> 00:33:05,600
after enabling the patch we almost

831
00:33:05,600 --> 00:33:09,600
double more than doubled our throughput

832
00:33:09,600 --> 00:33:12,960
about 300 megabytes and

833
00:33:12,960 --> 00:33:14,960
we see the same picture with rights as

834
00:33:14,960 --> 00:33:17,360
well when we enable our patch and the

835
00:33:17,360 --> 00:33:19,039
rights will put jumps

836
00:33:19,039 --> 00:33:22,799
more than a 100

837
00:33:22,799 --> 00:33:26,399
and thus now we have both 300

838
00:33:26,399 --> 00:33:29,120
megabytes per second of 32k and 300

839
00:33:29,120 --> 00:33:31,679
megabytes per second of right throughput

840
00:33:31,679 --> 00:33:34,799
totally we have uh 600 megabytes per

841
00:33:34,799 --> 00:33:36,799
second of total throughput which is very

842
00:33:36,799 --> 00:33:38,320
close to the

843
00:33:38,320 --> 00:33:42,000
uh worst case uh

844
00:33:42,000 --> 00:33:45,679
upper number of 700 megabytes per second

845
00:33:45,679 --> 00:33:46,960
throughput we calculated

846
00:33:46,960 --> 00:33:49,360
earlier we eliminated most of the

847
00:33:49,360 --> 00:33:51,760
performance bottleneck and

848
00:33:51,760 --> 00:33:53,919
it

849
00:33:54,880 --> 00:33:56,880
just to make sure we're not imagining

850
00:33:56,880 --> 00:33:59,039
things uh

851
00:33:59,039 --> 00:34:03,279
this is how the effect of our patches

852
00:34:03,279 --> 00:34:05,279
and our real production system so this

853
00:34:05,279 --> 00:34:07,600
is now not a virtual ram disk

854
00:34:07,600 --> 00:34:10,239
this is a real ssd from our production

855
00:34:10,239 --> 00:34:11,280
system

856
00:34:11,280 --> 00:34:14,480
and the yellow line shows the perceived

857
00:34:14,480 --> 00:34:16,320
latency i o latency

858
00:34:16,320 --> 00:34:19,918
of the raw ssd itself and the green line

859
00:34:19,918 --> 00:34:20,879
shows

860
00:34:20,879 --> 00:34:23,359
the perceived application latency from

861
00:34:23,359 --> 00:34:25,839
the dmcrypt instance on top of the same

862
00:34:25,839 --> 00:34:26,719
day

863
00:34:26,719 --> 00:34:28,879
as you may notice when we enable the

864
00:34:28,879 --> 00:34:31,440
patch these latencies converge so from

865
00:34:31,440 --> 00:34:32,399
applications

866
00:34:32,399 --> 00:34:34,960
perspective now there is almost no

867
00:34:34,960 --> 00:34:37,040
difference in terms of latency

868
00:34:37,040 --> 00:34:41,119
uses an encrypted disk or not

869
00:34:41,839 --> 00:34:44,480
and this is a cloud for a service impact

870
00:34:44,480 --> 00:34:45,440
so this is

871
00:34:45,440 --> 00:34:49,679
the three-way comparison

872
00:34:49,679 --> 00:34:53,839
of uh cloud for a cache p99 response

873
00:34:53,839 --> 00:34:54,320
time

874
00:34:54,320 --> 00:34:56,399
measured over five minutes on three

875
00:34:56,399 --> 00:34:57,920
servers

876
00:34:57,920 --> 00:35:01,040
so uh here we have a server with

877
00:35:01,040 --> 00:35:04,160
just on a plain ssds unencrypted ssds

878
00:35:04,160 --> 00:35:06,079
this is a green line

879
00:35:06,079 --> 00:35:09,440
then the red line is the same service

880
00:35:09,440 --> 00:35:11,599
run on the same server with same

881
00:35:11,599 --> 00:35:14,000
hardware configuration but the disks

882
00:35:14,000 --> 00:35:17,520
were encrypted with standard linux disk

883
00:35:17,520 --> 00:35:19,359
encryption and you can see

884
00:35:19,359 --> 00:35:23,200
we have these very high spikes of p99

885
00:35:23,200 --> 00:35:26,640
response time from our cdn cache

886
00:35:26,640 --> 00:35:29,440
and then the blue line shows the same

887
00:35:29,440 --> 00:35:30,079
server

888
00:35:30,079 --> 00:35:32,960
but with our patch enabled and here we

889
00:35:32,960 --> 00:35:33,920
can see that

890
00:35:33,920 --> 00:35:36,440
the encrypted server is now almost

891
00:35:36,440 --> 00:35:37,599
indistinguishable

892
00:35:37,599 --> 00:35:40,640
from the unencrypted server so from the

893
00:35:40,640 --> 00:35:43,040
cloud service perspective we basically

894
00:35:43,040 --> 00:35:44,480
get the disk encryption

895
00:35:44,480 --> 00:35:46,800
for you although you know difference

896
00:35:46,800 --> 00:35:48,640
between encrypted servers and

897
00:35:48,640 --> 00:35:49,760
unencrypted

898
00:35:49,760 --> 00:35:54,400
servers from the service later

899
00:35:56,079 --> 00:35:59,599
that's basically it that's what i wanted

900
00:35:59,599 --> 00:36:00,079
to

901
00:36:00,079 --> 00:36:03,200
uh share for today so in conclusions

902
00:36:03,200 --> 00:36:05,599
in this presentation we introduced a

903
00:36:05,599 --> 00:36:07,680
simple patch which may improve the

904
00:36:07,680 --> 00:36:09,280
encrypt performance

905
00:36:09,280 --> 00:36:12,480
by 200 and sometimes 300 percent

906
00:36:12,480 --> 00:36:14,400
it's fully compatible with stock linux

907
00:36:14,400 --> 00:36:16,800
dmcrypt it doesn't introduce any new

908
00:36:16,800 --> 00:36:18,720
crypto you don't have to re-encrypt the

909
00:36:18,720 --> 00:36:19,440
drives

910
00:36:19,440 --> 00:36:21,359
even your encrypted disk to use this

911
00:36:21,359 --> 00:36:22,800
patch you can just use it as

912
00:36:22,800 --> 00:36:25,520
is and basically it can be enabled and

913
00:36:25,520 --> 00:36:27,760
disabled in runtime without any service

914
00:36:27,760 --> 00:36:30,320
disruption

915
00:36:30,560 --> 00:36:32,960
even if your server is serving live

916
00:36:32,960 --> 00:36:35,119
production traffic

917
00:36:35,119 --> 00:36:37,040
we reassured ourselves that modern

918
00:36:37,040 --> 00:36:40,240
crypto is fast and cheap and when

919
00:36:40,240 --> 00:36:42,079
you have a performance degradation don't

920
00:36:42,079 --> 00:36:44,560
rush to blame crypto security

921
00:36:44,560 --> 00:36:47,440
the performance degradation may likely

922
00:36:47,440 --> 00:36:48,079
elsewhere

923
00:36:48,079 --> 00:36:51,599
like architect

924
00:36:52,640 --> 00:36:55,040
we see that extra curing may be hard for

925
00:36:55,040 --> 00:36:57,200
on modern low latency storage so the

926
00:36:57,200 --> 00:36:58,560
whole concept of

927
00:36:58,560 --> 00:37:00,320
data encryption and rest should be

928
00:37:00,320 --> 00:37:02,720
reassessed with respect to modern

929
00:37:02,720 --> 00:37:06,839
low latency storage like ssb or

930
00:37:06,839 --> 00:37:09,599
nvmes

931
00:37:09,599 --> 00:37:12,079
there are some caveats though uh this

932
00:37:12,079 --> 00:37:13,680
patch improved performance

933
00:37:13,680 --> 00:37:18,720
on small block size high iops workloads

934
00:37:18,880 --> 00:37:20,800
like we tested it on the four kilobyte

935
00:37:20,800 --> 00:37:22,000
block size

936
00:37:22,000 --> 00:37:24,000
starting with block sizes of more than

937
00:37:24,000 --> 00:37:26,640
two megabytes these ior flows do not

938
00:37:26,640 --> 00:37:29,280
show a better performance and some

939
00:37:29,280 --> 00:37:31,280
degradation so there is

940
00:37:31,280 --> 00:37:34,640
room for research there that

941
00:37:34,640 --> 00:37:36,880
the whole the current setup assumes that

942
00:37:36,880 --> 00:37:38,640
we have hardware accelerating crypto and

943
00:37:38,640 --> 00:37:39,040
this

944
00:37:39,040 --> 00:37:42,240
view which most modern x86 system

945
00:37:42,240 --> 00:37:44,880
use but the result is that our current

946
00:37:44,880 --> 00:37:47,280
xts proxy module

947
00:37:47,280 --> 00:37:50,000
uh heavily relies on x86 it supports

948
00:37:50,000 --> 00:37:52,800
only 36 platform

949
00:37:52,800 --> 00:37:55,440
and basically your mileage may vary

950
00:37:55,440 --> 00:37:56,320
don't

951
00:37:56,320 --> 00:37:58,960
rush to enable this unconditionally in

952
00:37:58,960 --> 00:37:59,920
your setup

953
00:37:59,920 --> 00:38:03,040
try to measure try to benchmark it

954
00:38:03,040 --> 00:38:06,240
try to compare side by side like

955
00:38:06,240 --> 00:38:09,359
your specific io workload and

956
00:38:09,359 --> 00:38:12,079
with um or without dispatch and see if

957
00:38:12,079 --> 00:38:12,480
you

958
00:38:12,480 --> 00:38:14,079
get an improvement if you get some

959
00:38:14,079 --> 00:38:15,520
meaningful results

960
00:38:15,520 --> 00:38:18,000
even good or bad ones please let us know

961
00:38:18,000 --> 00:38:19,760
we would like to

962
00:38:19,760 --> 00:38:21,599
get more data to see how it can be

963
00:38:21,599 --> 00:38:24,400
improved in the future

964
00:38:24,400 --> 00:38:26,720
finally here are some links first is the

965
00:38:26,720 --> 00:38:28,400
link to the source code of the group

966
00:38:28,400 --> 00:38:30,160
setup utility which is the

967
00:38:30,160 --> 00:38:32,880
user space helper tool to encrypt disks

968
00:38:32,880 --> 00:38:34,079
linux

969
00:38:34,079 --> 00:38:36,480
uh second is the man page for dm setup

970
00:38:36,480 --> 00:38:39,359
low level utility from linux which

971
00:38:39,359 --> 00:38:42,400
to manage uh device mapper devices and

972
00:38:42,400 --> 00:38:43,200
this

973
00:38:43,200 --> 00:38:46,240
gmc devices in particular

974
00:38:46,240 --> 00:38:48,560
the third link is the link to the blog

975
00:38:48,560 --> 00:38:49,680
post

976
00:38:49,680 --> 00:38:51,839
which contains the information all the

977
00:38:51,839 --> 00:38:53,520
information i described today

978
00:38:53,520 --> 00:38:55,839
and even more and even more measurements

979
00:38:55,839 --> 00:38:57,520
so i encourage you to go

980
00:38:57,520 --> 00:39:00,880
and read it the fourth link

981
00:39:00,880 --> 00:39:03,040
is a link to our cloud for linux

982
00:39:03,040 --> 00:39:04,560
repository where

983
00:39:04,560 --> 00:39:07,599
we published the patches i presented

984
00:39:07,599 --> 00:39:09,359
and talked about today so you can

985
00:39:09,359 --> 00:39:11,920
basically go grab them and

986
00:39:11,920 --> 00:39:14,480
find them out yourself and finally

987
00:39:14,480 --> 00:39:16,720
luckily since the first time i presented

988
00:39:16,720 --> 00:39:18,560
this presentation

989
00:39:18,560 --> 00:39:22,079
my work this work was

990
00:39:22,079 --> 00:39:25,359
basically accepted into the in somewhat

991
00:39:25,359 --> 00:39:26,839
reworked

992
00:39:26,839 --> 00:39:29,599
form was accepted into the mainline

993
00:39:29,599 --> 00:39:31,040
links kernel so

994
00:39:31,040 --> 00:39:33,920
you may be able to experiment with this

995
00:39:33,920 --> 00:39:36,160
approach

996
00:39:36,160 --> 00:39:40,400
from with linux kernel starting from 5.9

997
00:39:40,400 --> 00:39:40,960
which is

998
00:39:40,960 --> 00:39:43,040
currently in release candidates still

999
00:39:43,040 --> 00:39:45,599
but it will be available in my instagram

1000
00:39:45,599 --> 00:39:49,200
mainstream linux pretty much

1001
00:39:49,520 --> 00:39:52,640
that's all thank you for the attention

1002
00:39:52,640 --> 00:39:57,598
and i'm now happy to take any questions

