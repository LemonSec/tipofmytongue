1
00:00:06,839 --> 00:00:09,080
foreign

2
00:00:17,740 --> 00:00:20,849
[Music]

3
00:00:30,410 --> 00:00:45,509
[Music]

4
00:00:51,100 --> 00:00:54,199
[Music]

5
00:00:54,199 --> 00:00:56,899
ah cool so it's more of a like

6
00:00:56,899 --> 00:00:59,579
insecticides for the Box again on the

7
00:00:59,579 --> 00:01:02,160
Gopher but we'll get to

8
00:01:02,160 --> 00:01:05,459
um cool so my name is Alexia come by

9
00:01:05,459 --> 00:01:07,920
hexap Punk on the interwebs my lead

10
00:01:07,920 --> 00:01:11,340
security bits I'm also I used to be a

11
00:01:11,340 --> 00:01:13,500
developer probably working in security

12
00:01:13,500 --> 00:01:16,920
for about seven eight years so yeah

13
00:01:16,920 --> 00:01:18,420
cool so this is what we're doing today

14
00:01:18,420 --> 00:01:21,240
we're learning about common boxing go uh

15
00:01:21,240 --> 00:01:23,280
some pretty interesting bugs

16
00:01:23,280 --> 00:01:26,640
um we'll find some fun edge cases for go

17
00:01:26,640 --> 00:01:28,920
specifically uh we'll focus on

18
00:01:28,920 --> 00:01:31,439
concurrency box which are fairly

19
00:01:31,439 --> 00:01:33,060
interesting inside probably one of my

20
00:01:33,060 --> 00:01:34,939
favorite type of books in go

21
00:01:34,939 --> 00:01:36,780
techniques for understanding and

22
00:01:36,780 --> 00:01:39,360
catching those blocks so we'll not only

23
00:01:39,360 --> 00:01:41,939
try to list like a bunch of tools when

24
00:01:41,939 --> 00:01:44,220
I'm trying to avoid is going to you I'm

25
00:01:44,220 --> 00:01:46,200
being like hey here's all these tools

26
00:01:46,200 --> 00:01:48,840
figure them out but we'll actually try

27
00:01:48,840 --> 00:01:51,180
to understand how those tools work in

28
00:01:51,180 --> 00:01:53,460
understanding how the tools work then

29
00:01:53,460 --> 00:01:55,860
that'll allow you to essentially figure

30
00:01:55,860 --> 00:01:58,500
out be able to determine which tool is

31
00:01:58,500 --> 00:02:00,780
best will do the job best for what

32
00:02:00,780 --> 00:02:02,880
you're trying to accomplish of course

33
00:02:02,880 --> 00:02:05,100
uh and we'll also evaluate a little bit

34
00:02:05,100 --> 00:02:06,600
about we'll talk a little bit about the

35
00:02:06,600 --> 00:02:08,818
state of security of tooling and go I

36
00:02:08,818 --> 00:02:10,258
also show you a tool that we've been

37
00:02:10,258 --> 00:02:12,540
working on at a drill bits or at least I

38
00:02:12,540 --> 00:02:15,599
have been working on um so

39
00:02:15,599 --> 00:02:19,020
um it is then release yet but just I'll

40
00:02:19,020 --> 00:02:20,879
give you a little sneak peek of that as

41
00:02:20,879 --> 00:02:22,739
well

42
00:02:22,739 --> 00:02:27,800
um great so why go so I wanted this

43
00:02:27,800 --> 00:02:31,500
demystify the list of how uh static

44
00:02:31,500 --> 00:02:33,360
tools work

45
00:02:33,360 --> 00:02:34,860
um again like I said earlier that will

46
00:02:34,860 --> 00:02:36,720
allow you to basically once you have an

47
00:02:36,720 --> 00:02:38,340
understanding of how static analysis

48
00:02:38,340 --> 00:02:39,720
tools then you'll be able to determine

49
00:02:39,720 --> 00:02:41,940
like you know not all static analysis

50
00:02:41,940 --> 00:02:43,620
tools are the same and then

51
00:02:43,620 --> 00:02:45,959
understanding how they work that allowed

52
00:02:45,959 --> 00:02:47,580
you to you don't have to write your own

53
00:02:47,580 --> 00:02:50,220
so hopefully you will be motivated

54
00:02:50,220 --> 00:02:52,140
enough to start trying to figure out how

55
00:02:52,140 --> 00:02:55,019
to ride your own but uh figuring out how

56
00:02:55,019 --> 00:02:56,519
they work will let you know the

57
00:02:56,519 --> 00:02:58,620
advantages and the disadvantages and I

58
00:02:58,620 --> 00:02:59,640
think that's

59
00:02:59,640 --> 00:03:01,280
fairly important

60
00:03:01,280 --> 00:03:03,780
we also talk about some Core Concepts on

61
00:03:03,780 --> 00:03:05,640
the syndic how static analysis tools

62
00:03:05,640 --> 00:03:09,000
work and go and we'll like I said that

63
00:03:09,000 --> 00:03:11,040
will help us better compare uh tooling

64
00:03:11,040 --> 00:03:13,620
also why go I'll point that out as well

65
00:03:13,620 --> 00:03:15,720
even though it's not in the slide unless

66
00:03:15,720 --> 00:03:19,140
I'm missing it yeah I did add it so go

67
00:03:19,140 --> 00:03:21,180
it's pretty awesome uh and I'm

68
00:03:21,180 --> 00:03:23,099
specifically talking about go because go

69
00:03:23,099 --> 00:03:25,080
it's something that I got into

70
00:03:25,080 --> 00:03:27,420
a few years ago and I just started

71
00:03:27,420 --> 00:03:30,000
trying to like I I picked it as like

72
00:03:30,000 --> 00:03:32,640
sort of my specialty area and that's

73
00:03:32,640 --> 00:03:34,739
basically at trilobits I do a lot of

74
00:03:34,739 --> 00:03:37,200
audits for go code it's most of the

75
00:03:37,200 --> 00:03:39,360
artists that I do actually

76
00:03:39,360 --> 00:03:43,140
um and uh we did usually what we do is

77
00:03:43,140 --> 00:03:45,420
we don't typically just go trying to

78
00:03:45,420 --> 00:03:48,840
find just generic vulnerabilities we are

79
00:03:48,840 --> 00:03:51,480
trying to find you know obviously your

80
00:03:51,480 --> 00:03:53,580
like I don't know SQL injection and

81
00:03:53,580 --> 00:03:54,959
things like that but we're also trying

82
00:03:54,959 --> 00:03:58,140
to look for bugs so things that might

83
00:03:58,140 --> 00:03:59,819
not seem like a vulnerability right away

84
00:03:59,819 --> 00:04:02,640
but might be just a developer bug and

85
00:04:02,640 --> 00:04:04,560
then from there we try to determine okay

86
00:04:04,560 --> 00:04:06,840
here's this bug it might doesn't seem

87
00:04:06,840 --> 00:04:08,640
like it has a security impact but then

88
00:04:08,640 --> 00:04:10,860
we analyze how can this be turned into

89
00:04:10,860 --> 00:04:13,739
our vulnerability how will an attacker

90
00:04:13,739 --> 00:04:17,880
take an advantage with this as well

91
00:04:17,880 --> 00:04:19,680
um go it's pretty awesome it's covered

92
00:04:19,680 --> 00:04:21,418
collected strongly typed mixed

93
00:04:21,418 --> 00:04:23,160
concurrency super easy which is probably

94
00:04:23,160 --> 00:04:25,440
the biggest

95
00:04:25,440 --> 00:04:28,440
you know selling point for go

96
00:04:28,440 --> 00:04:30,180
um it uses composition instead of

97
00:04:30,180 --> 00:04:32,759
inheritance which is also very nice it's

98
00:04:32,759 --> 00:04:36,479
easy to read easy to write uh you if you

99
00:04:36,479 --> 00:04:39,479
haven't worked on with C plus plus or C

100
00:04:39,479 --> 00:04:43,979
or go uh once you you might first get a

101
00:04:43,979 --> 00:04:45,419
little intimidated by looking at the

102
00:04:45,419 --> 00:04:47,940
pointers and you know passing by a

103
00:04:47,940 --> 00:04:50,580
printer reference Etc but uh it's you

104
00:04:50,580 --> 00:04:52,199
know just read a few

105
00:04:52,199 --> 00:04:54,840
pages of do you know about that in you

106
00:04:54,840 --> 00:04:57,060
you're good to go it's also super easy

107
00:04:57,060 --> 00:04:59,340
to fuss so that's another thing that I

108
00:04:59,340 --> 00:05:02,160
like about go it's that it's a great way

109
00:05:02,160 --> 00:05:04,919
to get introduced to fossum

110
00:05:04,919 --> 00:05:06,780
um and it sort of allows you to

111
00:05:06,780 --> 00:05:10,620
demystify also the world of fussing uh

112
00:05:10,620 --> 00:05:12,240
because a lot of times you hear fasting

113
00:05:12,240 --> 00:05:13,800
from the academic world and you see all

114
00:05:13,800 --> 00:05:15,320
these papers with all this complicated

115
00:05:15,320 --> 00:05:18,540
jargon and things like that and go it

116
00:05:18,540 --> 00:05:21,000
just makes a like plus and it's just a

117
00:05:21,000 --> 00:05:22,740
regular thing that developers should be

118
00:05:22,740 --> 00:05:25,139
doing it's not a yeah you know it

119
00:05:25,139 --> 00:05:26,580
doesn't have to be something like super

120
00:05:26,580 --> 00:05:28,800
scientific so that's another reason why

121
00:05:28,800 --> 00:05:30,720
I like go it's very accessible in that

122
00:05:30,720 --> 00:05:31,620
way

123
00:05:31,620 --> 00:05:33,419
so let's first talk about some common

124
00:05:33,419 --> 00:05:37,680
boxing and go so this is gonna be fun

125
00:05:37,680 --> 00:05:39,180
hopefully

126
00:05:39,180 --> 00:05:40,979
great so we'll start with the biggest

127
00:05:40,979 --> 00:05:42,660
one I'll say

128
00:05:42,660 --> 00:05:45,539
uh and again this a lot of this box

129
00:05:45,539 --> 00:05:47,100
might not seem like one of release right

130
00:05:47,100 --> 00:05:50,039
away but uh in my experience working

131
00:05:50,039 --> 00:05:52,199
doing audits for security security

132
00:05:52,199 --> 00:05:55,139
audits for code written and go a lot of

133
00:05:55,139 --> 00:05:57,060
times we uh all these issues that I'm

134
00:05:57,060 --> 00:05:59,639
gonna show you uh have turned into

135
00:05:59,639 --> 00:06:01,919
vulnerabilities which we turn into proof

136
00:06:01,919 --> 00:06:05,160
of concept uh appendixes or code that we

137
00:06:05,160 --> 00:06:07,320
add in our reports as well

138
00:06:07,320 --> 00:06:11,520
so the first one is errors errors and go

139
00:06:11,520 --> 00:06:15,180
are painfully manual so whereas other

140
00:06:15,180 --> 00:06:18,300
programming languages you have uh you

141
00:06:18,300 --> 00:06:21,600
know you have try catch blocks to catch

142
00:06:21,600 --> 00:06:24,300
exceptions although go supposedly it's

143
00:06:24,300 --> 00:06:25,620
going to have something like that in go

144
00:06:25,620 --> 00:06:28,979
2.0 right now this is what cachin Eros

145
00:06:28,979 --> 00:06:31,259
looks like in go so you just call a

146
00:06:31,259 --> 00:06:34,860
function then you have to the function

147
00:06:34,860 --> 00:06:36,960
get profile here it's going to return an

148
00:06:36,960 --> 00:06:38,759
object the profile and it's going to

149
00:06:38,759 --> 00:06:41,460
return an error so then we are like did

150
00:06:41,460 --> 00:06:44,220
they return an error uh if it didn't

151
00:06:44,220 --> 00:06:46,919
return then if it did return an error

152
00:06:46,919 --> 00:06:49,020
we'd return the error otherwise we

153
00:06:49,020 --> 00:06:51,120
continue so this is a common issue that

154
00:06:51,120 --> 00:06:54,259
we see and this might not be uh you know

155
00:06:54,259 --> 00:06:56,940
obvious right away but we have two

156
00:06:56,940 --> 00:06:59,280
functions both return and error and this

157
00:06:59,280 --> 00:07:02,400
is uh in both in the first line where

158
00:07:02,400 --> 00:07:04,440
catching the error in the error variable

159
00:07:04,440 --> 00:07:07,139
the second line where catching the error

160
00:07:07,139 --> 00:07:09,539
in the error again so what happens is in

161
00:07:09,539 --> 00:07:11,220
that second line we're overriding the

162
00:07:11,220 --> 00:07:13,740
error from this first line so if an

163
00:07:13,740 --> 00:07:15,660
error occur in the first line

164
00:07:15,660 --> 00:07:18,960
the programmer forgot to catch it there

165
00:07:18,960 --> 00:07:20,819
um so this is something that's fairly

166
00:07:20,819 --> 00:07:22,979
common this is another way you can catch

167
00:07:22,979 --> 00:07:25,380
errors to the the last three lines there

168
00:07:25,380 --> 00:07:28,800
and go and uh so it's a little bit

169
00:07:28,800 --> 00:07:30,720
different syntax but it's essentially

170
00:07:30,720 --> 00:07:33,120
the same uh here even though you are

171
00:07:33,120 --> 00:07:36,660
saying by Val coma air uh you are never

172
00:07:36,660 --> 00:07:38,340
taken there you're only looking for the

173
00:07:38,340 --> 00:07:39,060
value

174
00:07:39,060 --> 00:07:40,560
so that's another way that you can miss

175
00:07:40,560 --> 00:07:43,620
an error now

176
00:07:43,620 --> 00:07:46,620
so again Arrow handling sucks and go

177
00:07:46,620 --> 00:07:48,960
it's awfully manual there's a lot of

178
00:07:48,960 --> 00:07:50,880
copy paste logic that you'll see so

179
00:07:50,880 --> 00:07:53,460
developer Shields just will we'll just

180
00:07:53,460 --> 00:07:56,039
go ahead and copy and paste that error

181
00:07:56,039 --> 00:08:00,180
catch him block I guess and uh and

182
00:08:00,180 --> 00:08:01,979
what's interesting is that this a lot of

183
00:08:01,979 --> 00:08:03,720
times can turn into let's say you are

184
00:08:03,720 --> 00:08:06,780
catching an authorization failure and

185
00:08:06,780 --> 00:08:09,240
then you overwrite the error and

186
00:08:09,240 --> 00:08:10,380
something that we've seen it's like

187
00:08:10,380 --> 00:08:12,539
maybe you missed the developer missed

188
00:08:12,539 --> 00:08:14,340
that authorization error and they

189
00:08:14,340 --> 00:08:17,099
continue the typical logic allowing the

190
00:08:17,099 --> 00:08:19,379
air the the user to bypass authorization

191
00:08:19,379 --> 00:08:22,099
so that's an example

192
00:08:22,099 --> 00:08:26,400
uh the other one is interface awareness

193
00:08:26,400 --> 00:08:30,120
so uh this is kind of interesting so we

194
00:08:30,120 --> 00:08:32,299
have a function right here on the right

195
00:08:32,299 --> 00:08:35,880
uh it's called print file right and then

196
00:08:35,880 --> 00:08:38,279
right here we have a this function

197
00:08:38,279 --> 00:08:40,740
defines an error and it defines it here

198
00:08:40,740 --> 00:08:43,080
as a path error and then at the end of

199
00:08:43,080 --> 00:08:44,760
the function we return that path error

200
00:08:44,760 --> 00:08:46,560
now what happens is that if we never

201
00:08:46,560 --> 00:08:49,260
assign any value to this and we return

202
00:08:49,260 --> 00:08:51,920
this this function will never

203
00:08:51,920 --> 00:08:54,959
this value as it gets returned will

204
00:08:54,959 --> 00:08:57,360
never be nil

205
00:08:57,360 --> 00:09:01,080
um because go says okay this is not nil

206
00:09:01,080 --> 00:09:03,240
this is regardless of what this is you

207
00:09:03,240 --> 00:09:04,920
already assigned it a type the type is

208
00:09:04,920 --> 00:09:09,120
Os or path error so uh so regardless of

209
00:09:09,120 --> 00:09:11,040
whether an error gets returned here or

210
00:09:11,040 --> 00:09:14,339
not uh it's never going to be nil so

211
00:09:14,339 --> 00:09:15,959
that's another sort of thing that is

212
00:09:15,959 --> 00:09:18,720
interface that it's about when it's

213
00:09:18,720 --> 00:09:20,580
interfaces

214
00:09:20,580 --> 00:09:22,740
um it's actually something that makes

215
00:09:22,740 --> 00:09:25,800
sense when you start learning about the

216
00:09:25,800 --> 00:09:28,019
programming model that go it's based on

217
00:09:28,019 --> 00:09:31,380
but uh but it's something that a lot of

218
00:09:31,380 --> 00:09:34,140
people don't realize that exist and it's

219
00:09:34,140 --> 00:09:36,540
an issue that we've seen in some

220
00:09:36,540 --> 00:09:39,300
instances it's sort of hard to catch but

221
00:09:39,300 --> 00:09:41,399
uh yeah it can cause all sorts of weird

222
00:09:41,399 --> 00:09:44,100
issues as well

223
00:09:44,100 --> 00:09:47,279
um there is a uh I wrote a blog post on

224
00:09:47,279 --> 00:09:49,620
this uh if you're interested and it's on

225
00:09:49,620 --> 00:09:52,440
this site and it'll be in the slides as

226
00:09:52,440 --> 00:09:54,720
well which I'll share with everybody and

227
00:09:54,720 --> 00:09:56,279
it just talks in depth about that

228
00:09:56,279 --> 00:09:58,260
particular issue and goes into the low

229
00:09:58,260 --> 00:10:01,140
level details as well

230
00:10:01,140 --> 00:10:03,660
um another one that's a little simpler

231
00:10:03,660 --> 00:10:06,120
and more common like C C plus plus it's

232
00:10:06,120 --> 00:10:09,420
integer errors so here we are doing a

233
00:10:09,420 --> 00:10:11,640
string conversion uh we have we're

234
00:10:11,640 --> 00:10:13,339
converting this string which is a number

235
00:10:13,339 --> 00:10:16,320
to uh an integer

236
00:10:16,320 --> 00:10:18,540
right and then uh what happens here

237
00:10:18,540 --> 00:10:20,580
we'll go ahead and test this

238
00:10:20,580 --> 00:10:23,279
so we're doing the string conversions uh

239
00:10:23,279 --> 00:10:25,500
passing this string converting it to an

240
00:10:25,500 --> 00:10:27,420
integer and then we're casting that to

241
00:10:27,420 --> 00:10:30,540
an into 32 type

242
00:10:30,540 --> 00:10:32,459
um let's see what that gives us we're

243
00:10:32,459 --> 00:10:35,100
going to go ahead and run that

244
00:10:35,100 --> 00:10:38,040
and so here we have the number right

245
00:10:38,040 --> 00:10:40,140
here that we initially passed and this

246
00:10:40,140 --> 00:10:42,540
is the conversion so it's 81 it

247
00:10:42,540 --> 00:10:44,820
shouldn't be 81. it's obviously what we

248
00:10:44,820 --> 00:10:47,339
have here is an integer overflow so it's

249
00:10:47,339 --> 00:10:48,959
another issue that we kind of see sort

250
00:10:48,959 --> 00:10:51,540
of commonly and this again might not

251
00:10:51,540 --> 00:10:53,579
seem like an immediate issue in other

252
00:10:53,579 --> 00:10:56,279
contexts but at least a trilobits we

253
00:10:56,279 --> 00:10:59,100
work a lot on blockchain applications

254
00:10:59,100 --> 00:11:01,200
and a lot of blockchain applications

255
00:11:01,200 --> 00:11:03,240
nowadays are also for the option

256
00:11:03,240 --> 00:11:05,940
components they are written and go and

257
00:11:05,940 --> 00:11:08,160
when you're dealing with finances you

258
00:11:08,160 --> 00:11:11,459
know money or cryptocurrency then this

259
00:11:11,459 --> 00:11:12,540
is something that you have to Be

260
00:11:12,540 --> 00:11:15,480
watchful for for to make sure that your

261
00:11:15,480 --> 00:11:17,279
calculations are correct and you're not

262
00:11:17,279 --> 00:11:19,860
doing something dumb like this

263
00:11:19,860 --> 00:11:22,260
uh and I call it dump but it's an easy

264
00:11:22,260 --> 00:11:24,779
error to me to make so

265
00:11:24,779 --> 00:11:27,560
uh

266
00:11:29,399 --> 00:11:31,560
I will uh I'll mention those

267
00:11:31,560 --> 00:11:33,180
recommendations but yeah definitely in

268
00:11:33,180 --> 00:11:35,519
this case basically what uh the if if I

269
00:11:35,519 --> 00:11:36,899
were to tell the developer how to

270
00:11:36,899 --> 00:11:39,360
correct it right away it's to uh just do

271
00:11:39,360 --> 00:11:42,240
the conversion to uh instead of int 32

272
00:11:42,240 --> 00:11:44,880
just go ahead and do that and in

273
00:11:44,880 --> 00:11:47,240
conversion which basically matches the

274
00:11:47,240 --> 00:11:49,680
architecture of the of the computer

275
00:11:49,680 --> 00:11:51,360
while you're running it because here

276
00:11:51,360 --> 00:11:53,579
it's a generic integer in the generic

277
00:11:53,579 --> 00:11:55,320
integer is going to match whether you

278
00:11:55,320 --> 00:11:58,860
have ironing this on a in on a int on a

279
00:11:58,860 --> 00:12:01,200
X32 or x64 system

280
00:12:01,200 --> 00:12:03,779
uh but if you're interested to generate

281
00:12:03,779 --> 00:12:07,579
against here you should be fine

282
00:12:07,620 --> 00:12:09,060
this is another

283
00:12:09,060 --> 00:12:11,700
sort of example and I know that code on

284
00:12:11,700 --> 00:12:13,260
the right it's kind of small so let's

285
00:12:13,260 --> 00:12:14,940
just jump into the

286
00:12:14,940 --> 00:12:17,279
the sample here so this is just exactly

287
00:12:17,279 --> 00:12:21,120
the same basically but uh but just with

288
00:12:21,120 --> 00:12:22,980
a different function so instead of uh

289
00:12:22,980 --> 00:12:26,040
you know a2i we're using Parts end and

290
00:12:26,040 --> 00:12:27,839
what we're doing here is we're doing the

291
00:12:27,839 --> 00:12:30,060
Parts end which again matches the the

292
00:12:30,060 --> 00:12:32,160
conversion it's going to be for the

293
00:12:32,160 --> 00:12:34,500
architecture that of the system that

294
00:12:34,500 --> 00:12:36,720
you're running this in and then we do

295
00:12:36,720 --> 00:12:40,980
the conversion to n32 uh and then uh and

296
00:12:40,980 --> 00:12:43,440
then we have that overflow or underflow

297
00:12:43,440 --> 00:12:45,660
issue in this case

298
00:12:45,660 --> 00:12:48,300
uh it doesn't even run so we'll just

299
00:12:48,300 --> 00:12:50,339
skip that something wrong with this one

300
00:12:50,339 --> 00:12:54,200
well line 11.

301
00:12:58,920 --> 00:13:02,130
um ah there we go

302
00:13:02,130 --> 00:13:03,300
[Music]

303
00:13:03,300 --> 00:13:04,740
yeah you're right something happened

304
00:13:04,740 --> 00:13:06,720
with this one so we'll forget about that

305
00:13:06,720 --> 00:13:08,820
one but you get my point there it's

306
00:13:08,820 --> 00:13:11,160
basically the same exactly that's this

307
00:13:11,160 --> 00:13:13,680
one uh except with a different function

308
00:13:13,680 --> 00:13:15,720
that I wanted to show you the example

309
00:13:15,720 --> 00:13:18,540
with but yeah uh the next one is slices

310
00:13:18,540 --> 00:13:22,339
so this go has this concept of slices

311
00:13:22,339 --> 00:13:26,100
which is kind of like an array uh this

312
00:13:26,100 --> 00:13:28,260
is how you define a slice uh in this

313
00:13:28,260 --> 00:13:31,440
case we're designing uh defining a slice

314
00:13:31,440 --> 00:13:34,980
of bytes and we are passing the value

315
00:13:34,980 --> 00:13:38,100
back pag then what we do it's basically

316
00:13:38,100 --> 00:13:42,000
right here we're saying uh S1 equals uh

317
00:13:42,000 --> 00:13:45,300
this is the entire string the entire uh

318
00:13:45,300 --> 00:13:48,660
the try the entire slice of a here is

319
00:13:48,660 --> 00:13:51,000
the entire slice of a as well for S1 and

320
00:13:51,000 --> 00:13:53,339
S2 and then while substituting the

321
00:13:53,339 --> 00:13:56,940
second or you know zero base second

322
00:13:56,940 --> 00:14:00,300
index of the of the string here to D and

323
00:14:00,300 --> 00:14:03,480
then here to T now if we run this

324
00:14:03,480 --> 00:14:06,899
uh the result uh it's bad for both

325
00:14:06,899 --> 00:14:09,060
whereas you might think that one is

326
00:14:09,060 --> 00:14:10,500
going to be bad and the other one is

327
00:14:10,500 --> 00:14:11,700
going to be but

328
00:14:11,700 --> 00:14:14,639
uh what happens here is that the slices

329
00:14:14,639 --> 00:14:17,820
are not a race the slices are Pointers

330
00:14:17,820 --> 00:14:21,420
to our Race So in this case uh basically

331
00:14:21,420 --> 00:14:23,519
when we are assign it here we are

332
00:14:23,519 --> 00:14:26,160
creating we're just basically saying S1

333
00:14:26,160 --> 00:14:28,260
is going to hold the pointer to this

334
00:14:28,260 --> 00:14:29,399
array

335
00:14:29,399 --> 00:14:31,620
uh and S2 is going to hold the same

336
00:14:31,620 --> 00:14:33,360
point a pointer to the same array so

337
00:14:33,360 --> 00:14:34,800
different pointer put it to the same

338
00:14:34,800 --> 00:14:36,720
array so when you are changing those

339
00:14:36,720 --> 00:14:38,579
values you are essentially changing the

340
00:14:38,579 --> 00:14:42,000
same uh data that the pointer points to

341
00:14:42,000 --> 00:14:46,260
right uh so then you end up with issues

342
00:14:46,260 --> 00:14:48,000
like this and this is something else

343
00:14:48,000 --> 00:14:50,519
that we have seen because we're issues

344
00:14:50,519 --> 00:14:53,519
even something as simple as you are

345
00:14:53,519 --> 00:14:56,040
processing logs and then you are using

346
00:14:56,040 --> 00:14:58,440
slices to process your logs and then

347
00:14:58,440 --> 00:15:00,060
you're thinking that you are processing

348
00:15:00,060 --> 00:15:01,920
each log individually but you actually

349
00:15:01,920 --> 00:15:04,740
keep uh keep modifying the same exact

350
00:15:04,740 --> 00:15:08,100
log in your processing logic

351
00:15:08,100 --> 00:15:10,800
um yeah that's another kind of weird and

352
00:15:10,800 --> 00:15:13,800
then it's it's a very easy sort of a

353
00:15:13,800 --> 00:15:16,199
structure to misuse or use incorrectly

354
00:15:16,199 --> 00:15:18,360
and go

355
00:15:18,360 --> 00:15:20,579
uh then we have Co concurrency which is

356
00:15:20,579 --> 00:15:23,519
super interesting uh this is the problem

357
00:15:23,519 --> 00:15:26,459
with go concurrency in uh with with gold

358
00:15:26,459 --> 00:15:28,260
concurrency

359
00:15:28,260 --> 00:15:31,079
um so another reason why I like go it's

360
00:15:31,079 --> 00:15:34,560
one of my focus areas where I work at

361
00:15:34,560 --> 00:15:36,240
it's a cloud native

362
00:15:36,240 --> 00:15:38,699
and a lot of cloud native applications

363
00:15:38,699 --> 00:15:43,019
nowadays are written and go so I've been

364
00:15:43,019 --> 00:15:45,600
asked for people like it's go even that

365
00:15:45,600 --> 00:15:47,699
well you suck like I think it's still

366
00:15:47,699 --> 00:15:50,339
Java and c-sharp and Dot net yeah

367
00:15:50,339 --> 00:15:51,959
there's still Java and c-sharp internet

368
00:15:51,959 --> 00:15:53,820
but if you start looking at Cloud native

369
00:15:53,820 --> 00:15:55,380
applications and you start looking at

370
00:15:55,380 --> 00:15:58,139
the code that's running on kubernetes

371
00:15:58,139 --> 00:16:01,860
and on the essentially applications that

372
00:16:01,860 --> 00:16:04,019
were designed to run and take advantage

373
00:16:04,019 --> 00:16:06,480
of cloud resources so not just

374
00:16:06,480 --> 00:16:08,519
applications that were written to hosts

375
00:16:08,519 --> 00:16:10,380
and servers but applications that were

376
00:16:10,380 --> 00:16:12,360
reaching to take augmentation Cloud

377
00:16:12,360 --> 00:16:15,300
resources typically use concurrency and

378
00:16:15,300 --> 00:16:18,300
are going to be uh you are going to be

379
00:16:18,300 --> 00:16:20,220
designed in such a way that there's uh

380
00:16:20,220 --> 00:16:22,139
they are deployed as distributed systems

381
00:16:22,139 --> 00:16:24,959
micro Services Etc

382
00:16:24,959 --> 00:16:27,000
um so this is our the interesting thing

383
00:16:27,000 --> 00:16:29,579
about writing those applications in go

384
00:16:29,579 --> 00:16:33,300
is that then you think that or you know

385
00:16:33,300 --> 00:16:35,100
it is very easy to write concurrent code

386
00:16:35,100 --> 00:16:37,860
and go but it's so easy that you might

387
00:16:37,860 --> 00:16:39,180
not be thinking about everything that

388
00:16:39,180 --> 00:16:40,740
you need to think about when you're

389
00:16:40,740 --> 00:16:43,380
writing that code which can lead you to

390
00:16:43,380 --> 00:16:44,540
write

391
00:16:44,540 --> 00:16:47,759
a buggy concurrent code we'll see some

392
00:16:47,759 --> 00:16:49,920
examples of that

393
00:16:49,920 --> 00:16:53,339
okay so this is sort of like the Matrix

394
00:16:53,339 --> 00:16:57,120
of concurrency bugs in go uh then you

395
00:16:57,120 --> 00:16:58,860
have two main categories we have misuse

396
00:16:58,860 --> 00:17:02,459
of channels and misuse of share memory

397
00:17:02,459 --> 00:17:05,760
um and these are the you then from there

398
00:17:05,760 --> 00:17:07,980
we have blocking and non-blocking bugs

399
00:17:07,980 --> 00:17:10,799
and these are the different uh bugs that

400
00:17:10,799 --> 00:17:13,619
we have which I listed here and I'll

401
00:17:13,619 --> 00:17:15,119
share the slides but we're gonna go over

402
00:17:15,119 --> 00:17:18,000
a few of them in a little bit of detail

403
00:17:18,000 --> 00:17:19,799
and I think that'll be better than just

404
00:17:19,799 --> 00:17:21,419
showing you coming over this particular

405
00:17:21,419 --> 00:17:22,679
slide

406
00:17:22,679 --> 00:17:24,839
okay let's start with data races this is

407
00:17:24,839 --> 00:17:26,520
probably the most common and one that

408
00:17:26,520 --> 00:17:29,059
you will see languages fairly simple

409
00:17:29,059 --> 00:17:33,120
okay so right here we have a uh our

410
00:17:33,120 --> 00:17:37,500
function on the left side yes left uh

411
00:17:37,500 --> 00:17:41,460
and then we are looping over values in

412
00:17:41,460 --> 00:17:46,580
the FNS variable right from here we are

413
00:17:46,580 --> 00:17:49,860
uh calling a concurring function what's

414
00:17:49,860 --> 00:17:52,620
calling go space Funk anything that you

415
00:17:52,620 --> 00:17:54,539
prepared with the word go and go it's

416
00:17:54,539 --> 00:17:57,299
going to be called concurrently

417
00:17:57,299 --> 00:18:01,440
um great so uh in right here we are

418
00:18:01,440 --> 00:18:04,620
calling each function that is within the

419
00:18:04,620 --> 00:18:07,799
FNS array so FNS contains a series of

420
00:18:07,799 --> 00:18:09,240
functions and then we're calling those

421
00:18:09,240 --> 00:18:11,460
functions in our Loop in a concurrent

422
00:18:11,460 --> 00:18:13,320
way right

423
00:18:13,320 --> 00:18:13,980
um

424
00:18:13,980 --> 00:18:15,900
and this is function one and function

425
00:18:15,900 --> 00:18:18,780
two so ideally what the developer here

426
00:18:18,780 --> 00:18:20,520
is expecting that when you run this

427
00:18:20,520 --> 00:18:22,440
you're gonna see IM function one and

428
00:18:22,440 --> 00:18:24,179
then ion function two

429
00:18:24,179 --> 00:18:26,220
but then if we look at this in the

430
00:18:26,220 --> 00:18:27,900
playground

431
00:18:27,900 --> 00:18:31,640
if I can get it to open

432
00:18:33,000 --> 00:18:36,380
okay semi-sac code

433
00:18:36,419 --> 00:18:38,220
short end

434
00:18:38,220 --> 00:18:40,500
and then what we have is IM function2

435
00:18:40,500 --> 00:18:41,880
it's the only thing that shows and it

436
00:18:41,880 --> 00:18:44,640
shows twice even though we are looping

437
00:18:44,640 --> 00:18:46,200
over a variable that is supposed to

438
00:18:46,200 --> 00:18:48,840
include one declaration for function one

439
00:18:48,840 --> 00:18:52,140
and one declaration for function two

440
00:18:52,140 --> 00:18:55,020
um what happens here then is that we are

441
00:18:55,020 --> 00:18:57,059
uh there's a it's a race condition

442
00:18:57,059 --> 00:19:01,760
essentially so by the time that uh

443
00:19:01,760 --> 00:19:04,880
uh function that the scheduler go

444
00:19:04,880 --> 00:19:07,500
decides to run the go routine that's

445
00:19:07,500 --> 00:19:09,200
going to call this particular function

446
00:19:09,200 --> 00:19:13,799
then it's already uh it's already too

447
00:19:13,799 --> 00:19:15,780
late to schedule the first one so it

448
00:19:15,780 --> 00:19:19,260
ends up calling function two twice

449
00:19:19,260 --> 00:19:21,179
and then what happens here as well is

450
00:19:21,179 --> 00:19:25,500
that you are basically uh doing a

451
00:19:25,500 --> 00:19:28,260
copying the memory that it's pointed to

452
00:19:28,260 --> 00:19:32,220
by the F that by the FN value

453
00:19:32,220 --> 00:19:34,020
um the solution here is basically to

454
00:19:34,020 --> 00:19:36,539
create a copy of that particular value

455
00:19:36,539 --> 00:19:39,539
so you can do anything like

456
00:19:39,539 --> 00:19:40,980
um I don't know even if you do something

457
00:19:40,980 --> 00:19:42,780
like

458
00:19:42,780 --> 00:19:45,260
uh

459
00:19:45,539 --> 00:19:48,059
like a fan

460
00:19:48,059 --> 00:19:50,400
equals a fan I think something like that

461
00:19:50,400 --> 00:19:52,380
should work actually

462
00:19:52,380 --> 00:19:54,419
not just like that but

463
00:19:54,419 --> 00:19:57,780
fnc and then we just do F and C there

464
00:19:57,780 --> 00:20:00,240
are better ways to get it to work but

465
00:20:00,240 --> 00:20:01,500
this is one that should get it to work

466
00:20:01,500 --> 00:20:03,480
yeah so we have ion function two and

467
00:20:03,480 --> 00:20:05,760
then function one so that fixed it but

468
00:20:05,760 --> 00:20:07,620
because we are creating a copy of that

469
00:20:07,620 --> 00:20:09,960
particular variable this is another sort

470
00:20:09,960 --> 00:20:11,700
of like common issue that we've seen and

471
00:20:11,700 --> 00:20:14,340
we've seen again it just looks like a

472
00:20:14,340 --> 00:20:16,980
generic sort of bug but depending on the

473
00:20:16,980 --> 00:20:18,480
context it actually might be a

474
00:20:18,480 --> 00:20:20,580
vulnerability it might not be a directly

475
00:20:20,580 --> 00:20:22,500
exploitable vulnerability but it might

476
00:20:22,500 --> 00:20:23,640
be something that affects your

477
00:20:23,640 --> 00:20:26,700
confidentiality Integrity or your

478
00:20:26,700 --> 00:20:28,860
availability so it can cause in

479
00:20:28,860 --> 00:20:30,600
different contexts it can cause things

480
00:20:30,600 --> 00:20:32,220
like you know the line of service

481
00:20:32,220 --> 00:20:35,059
conditions it can cost inaccurate locks

482
00:20:35,059 --> 00:20:38,640
all that can be tied to uh security

483
00:20:38,640 --> 00:20:42,480
issue now one way or another as well

484
00:20:42,480 --> 00:20:44,520
second one is misuse of channel so why

485
00:20:44,520 --> 00:20:46,740
are channels and go channels is a way

486
00:20:46,740 --> 00:20:50,640
for concurring for uh different

487
00:20:50,640 --> 00:20:52,440
functions I run concurrently to

488
00:20:52,440 --> 00:20:53,760
communicate with each other and pass

489
00:20:53,760 --> 00:20:55,799
values to each other

490
00:20:55,799 --> 00:20:58,080
um so right here for instance this is

491
00:20:58,080 --> 00:21:01,080
not a buggy code uh what we're doing is

492
00:21:01,080 --> 00:21:03,720
basically the typical Fibonacci function

493
00:21:03,720 --> 00:21:07,679
example and then we are saying hey right

494
00:21:07,679 --> 00:21:10,260
here I'm going to give you a channel so

495
00:21:10,260 --> 00:21:11,880
that you can communicate with different

496
00:21:11,880 --> 00:21:14,160
concurring functions here the in the

497
00:21:14,160 --> 00:21:15,419
different recording functions are going

498
00:21:15,419 --> 00:21:16,799
to be all are going to be calling the

499
00:21:16,799 --> 00:21:18,240
Fibonacci function

500
00:21:18,240 --> 00:21:22,260
uh so anytime that we get a value uh in

501
00:21:22,260 --> 00:21:24,900
next year we assign it to we pass it to

502
00:21:24,900 --> 00:21:27,240
that channel C so this is a way it's

503
00:21:27,240 --> 00:21:29,039
again it's just a way for different

504
00:21:29,039 --> 00:21:30,360
concordion functions that are running

505
00:21:30,360 --> 00:21:32,100
concurrently to pass messages to each

506
00:21:32,100 --> 00:21:34,740
other to pass values to each other

507
00:21:34,740 --> 00:21:35,460
um

508
00:21:35,460 --> 00:21:39,299
and it's even though that might sound a

509
00:21:39,299 --> 00:21:42,059
little bit complex once you start going

510
00:21:42,059 --> 00:21:44,760
through the tutorials for go uh really

511
00:21:44,760 --> 00:21:47,640
quickly that becomes sort of easy now

512
00:21:47,640 --> 00:21:49,799
there's an interesting sort of issue

513
00:21:49,799 --> 00:21:51,179
that we've seen

514
00:21:51,179 --> 00:21:53,700
uh and it's actually fairly common still

515
00:21:53,700 --> 00:21:54,840
and go

516
00:21:54,840 --> 00:22:00,000
and this is a uh what we call uh

517
00:22:00,000 --> 00:22:02,940
concurrency leak or go routine leaks now

518
00:22:02,940 --> 00:22:05,520
I'm going to show you an example of that

519
00:22:05,520 --> 00:22:07,919
so we have some code here

520
00:22:07,919 --> 00:22:08,760
um

521
00:22:08,760 --> 00:22:10,679
I'm gonna try to focus rather than

522
00:22:10,679 --> 00:22:12,480
explaining the the entire code I'm going

523
00:22:12,480 --> 00:22:14,039
to try to focus on the actual issue

524
00:22:14,039 --> 00:22:14,940
right

525
00:22:14,940 --> 00:22:17,460
so what I'm doing here is I'm going I'm

526
00:22:17,460 --> 00:22:20,039
calling two uh concurring functions here

527
00:22:20,039 --> 00:22:24,179
and then I'm using a uh I'm using a

528
00:22:24,179 --> 00:22:26,640
channel against for both of these

529
00:22:26,640 --> 00:22:28,260
concurrent functions to be able to

530
00:22:28,260 --> 00:22:30,299
communicate what we're doing here is

531
00:22:30,299 --> 00:22:32,220
we're saying hey once you get a result

532
00:22:32,220 --> 00:22:34,440
in one of those channels I want you to

533
00:22:34,440 --> 00:22:36,000
print the result

534
00:22:36,000 --> 00:22:37,559
however I'm also going to give you a

535
00:22:37,559 --> 00:22:39,480
timeout so if the timeout occurs first

536
00:22:39,480 --> 00:22:42,000
then you're gonna go ahead and print

537
00:22:42,000 --> 00:22:44,640
case you're going to show me this error

538
00:22:44,640 --> 00:22:46,559
message or this and it's not an error

539
00:22:46,559 --> 00:22:47,640
message you want to show me this in the

540
00:22:47,640 --> 00:22:49,919
console case time after and then you're

541
00:22:49,919 --> 00:22:51,480
gonna return

542
00:22:51,480 --> 00:22:55,380
as we run this uh

543
00:22:55,620 --> 00:22:57,659
and I'm going to surely gonna make this

544
00:22:57,659 --> 00:22:59,940
a buggy code right away

545
00:22:59,940 --> 00:23:01,380
and then at the end what this function

546
00:23:01,380 --> 00:23:02,820
is to in the main it's basically

547
00:23:02,820 --> 00:23:05,220
counting the go routines that are

548
00:23:05,220 --> 00:23:07,799
running on the system so that means that

549
00:23:07,799 --> 00:23:10,440
by the time the assistant the the the

550
00:23:10,440 --> 00:23:13,080
program exits we're counting how many go

551
00:23:13,080 --> 00:23:16,620
routines are still running or as I are

552
00:23:16,620 --> 00:23:19,559
still hanging in the application

553
00:23:19,559 --> 00:23:22,559
uh so in in this case we have three goal

554
00:23:22,559 --> 00:23:25,080
routines now this is an issue this tells

555
00:23:25,080 --> 00:23:28,140
us that we didn't kill all the routines

556
00:23:28,140 --> 00:23:29,880
that we needed to kill but the time that

557
00:23:29,880 --> 00:23:32,700
we return from the we exited the

558
00:23:32,700 --> 00:23:35,159
application right uh what we should be

559
00:23:35,159 --> 00:23:36,900
seeing here is one

560
00:23:36,900 --> 00:23:39,299
what happened then it said

561
00:23:39,299 --> 00:23:41,520
we are declaring a channel here and

562
00:23:41,520 --> 00:23:45,000
saying like hey uh before you return

563
00:23:45,000 --> 00:23:49,020
from these functions unless you get data

564
00:23:49,020 --> 00:23:51,360
assigned to this value then you're gonna

565
00:23:51,360 --> 00:23:52,740
be blocking here so basically you're

566
00:23:52,740 --> 00:23:54,539
going to be waiting for this function to

567
00:23:54,539 --> 00:23:56,640
exit you cannot exit until you receive a

568
00:23:56,640 --> 00:23:59,100
message and this is what's happening

569
00:23:59,100 --> 00:24:00,659
here and this is what causes the core

570
00:24:00,659 --> 00:24:03,780
routine leaks go routine leaks costs can

571
00:24:03,780 --> 00:24:07,140
cause memory leaks little by little and

572
00:24:07,140 --> 00:24:09,299
depending on the actual context where

573
00:24:09,299 --> 00:24:11,039
they're being used

574
00:24:11,039 --> 00:24:13,740
so each Co routine it's basically has

575
00:24:13,740 --> 00:24:15,179
its own stack

576
00:24:15,179 --> 00:24:18,000
sign in memory so that means that the

577
00:24:18,000 --> 00:24:19,860
more go routines that you have in the

578
00:24:19,860 --> 00:24:22,679
system the more memory you're using the

579
00:24:22,679 --> 00:24:24,659
more go routine leaks you have that you

580
00:24:24,659 --> 00:24:27,840
forgot to close or you uh the the system

581
00:24:27,840 --> 00:24:29,600
the the garbage collector didn't close

582
00:24:29,600 --> 00:24:32,760
then uh the more memory starts

583
00:24:32,760 --> 00:24:35,100
accumulating on your system

584
00:24:35,100 --> 00:24:36,720
um so that's essentially what happened

585
00:24:36,720 --> 00:24:38,580
this is a memory leak

586
00:24:38,580 --> 00:24:40,559
the way that you fix this is fairly

587
00:24:40,559 --> 00:24:42,419
simple is basically you just give it a

588
00:24:42,419 --> 00:24:46,440
size for the for the uh for for your

589
00:24:46,440 --> 00:24:48,720
for your channel so here you basically

590
00:24:48,720 --> 00:24:51,419
create a buffered Channel

591
00:24:51,419 --> 00:24:54,380
then we run it and that should give us

592
00:24:54,380 --> 00:24:57,480
the uh because the time after record

593
00:24:57,480 --> 00:25:01,500
first we return before closing those uh

594
00:25:01,500 --> 00:25:05,100
go routines but uh because we made a

595
00:25:05,100 --> 00:25:07,080
buffer then go says like hey this only

596
00:25:07,080 --> 00:25:08,820
has a size two so let's go ahead and

597
00:25:08,820 --> 00:25:11,460
kill that ourselves so we only have one

598
00:25:11,460 --> 00:25:12,960
go routine this is what you should see

599
00:25:12,960 --> 00:25:15,299
now this seems like

600
00:25:15,299 --> 00:25:17,100
kind of

601
00:25:17,100 --> 00:25:20,539
like a known issue whoever

602
00:25:20,539 --> 00:25:23,880
this is an example of a bug that was

603
00:25:23,880 --> 00:25:25,679
reported for kubernetes

604
00:25:25,679 --> 00:25:28,080
and what we have here it's basically we

605
00:25:28,080 --> 00:25:30,299
had they had to go routine leak and this

606
00:25:30,299 --> 00:25:32,940
is the way that it was reported uh this

607
00:25:32,940 --> 00:25:34,860
particular goal routine leak just this

608
00:25:34,860 --> 00:25:38,460
super simple fix they did here was uh

609
00:25:38,460 --> 00:25:39,840
let me just make

610
00:25:39,840 --> 00:25:41,880
I don't think I can make it bigger but

611
00:25:41,880 --> 00:25:43,580
here we have the same thing I showed you

612
00:25:43,580 --> 00:25:48,299
we have to make uh where we create the

613
00:25:48,299 --> 00:25:50,580
channel in an on Buffer Manner and then

614
00:25:50,580 --> 00:25:53,340
the only fix which is to add comma one

615
00:25:53,340 --> 00:25:56,400
uh but before that the way that it was

616
00:25:56,400 --> 00:25:59,520
reported was that it was costing 1496 Co

617
00:25:59,520 --> 00:26:02,039
routine running that were basically

618
00:26:02,039 --> 00:26:05,159
hanging uh which was causing the API the

619
00:26:05,159 --> 00:26:07,500
kubernetes API server to crash

620
00:26:07,500 --> 00:26:10,500
so uh again it might not seem like an

621
00:26:10,500 --> 00:26:13,559
immediate issue but over time especially

622
00:26:13,559 --> 00:26:16,919
for applications running on the cloud uh

623
00:26:16,919 --> 00:26:18,419
little by little that starts

624
00:26:18,419 --> 00:26:21,120
accumulating in overtime you start you

625
00:26:21,120 --> 00:26:23,059
might start seeing a service degradation

626
00:26:23,059 --> 00:26:26,159
uh and eventually application crashes

627
00:26:26,159 --> 00:26:28,340
Etc

628
00:26:29,220 --> 00:26:31,860
the next one is uh Missing locks it's

629
00:26:31,860 --> 00:26:33,659
another one that we cannot see it's

630
00:26:33,659 --> 00:26:37,679
fairly simple it's you have a uh a lock

631
00:26:37,679 --> 00:26:40,799
on a particular structure so that you

632
00:26:40,799 --> 00:26:43,320
can synchronize access to that

633
00:26:43,320 --> 00:26:45,779
particular structure so if you're

634
00:26:45,779 --> 00:26:49,620
familiar with concurrent code you call a

635
00:26:49,620 --> 00:26:51,779
function that is and what you call two

636
00:26:51,779 --> 00:26:53,460
functions the both functions are working

637
00:26:53,460 --> 00:26:56,460
on with the same data structure so what

638
00:26:56,460 --> 00:26:59,580
you do is make sure that they uh that

639
00:26:59,580 --> 00:27:03,179
they work in a nice ways with and they

640
00:27:03,179 --> 00:27:04,980
share that in a nice way then

641
00:27:04,980 --> 00:27:06,840
essentially you lock that data structure

642
00:27:06,840 --> 00:27:08,700
say hey I'm working on this don't touch

643
00:27:08,700 --> 00:27:10,559
it I'm gonna be done with it well I'll

644
00:27:10,559 --> 00:27:11,700
let you know when I'm done with this

645
00:27:11,700 --> 00:27:14,100
then I unlock it so that other functions

646
00:27:14,100 --> 00:27:15,360
can go ahead and work with that same

647
00:27:15,360 --> 00:27:18,600
data structure so uh what might happen

648
00:27:18,600 --> 00:27:20,600
and what something that we also see

649
00:27:20,600 --> 00:27:23,520
commonly in go is that you create your

650
00:27:23,520 --> 00:27:24,299
luck

651
00:27:24,299 --> 00:27:27,179
then you call another like an if

652
00:27:27,179 --> 00:27:29,640
condition and then here because you get

653
00:27:29,640 --> 00:27:32,400
an error and then you return the error

654
00:27:32,400 --> 00:27:35,039
uh now you return the error on your if

655
00:27:35,039 --> 00:27:37,559
condition before you and you forgot to

656
00:27:37,559 --> 00:27:40,380
unlock it so you unlock it here but if

657
00:27:40,380 --> 00:27:42,120
an error occurs if you hit this a

658
00:27:42,120 --> 00:27:45,720
specific if block then uh you are

659
00:27:45,720 --> 00:27:47,460
returning before unlocking that object

660
00:27:47,460 --> 00:27:49,500
and that can also cause all kinds of

661
00:27:49,500 --> 00:27:51,659
issues for instance

662
00:27:51,659 --> 00:27:54,120
I've seen it where there's an API

663
00:27:54,120 --> 00:27:56,820
endpoint on a web application uh that

664
00:27:56,820 --> 00:28:00,260
it's handled in a similar man analysis

665
00:28:00,260 --> 00:28:03,840
uh it returns before releasing the lock

666
00:28:03,840 --> 00:28:05,640
and then what happens is that the

667
00:28:05,640 --> 00:28:08,159
application won't crash but anytime you

668
00:28:08,159 --> 00:28:10,919
call that particular API endpoint then

669
00:28:10,919 --> 00:28:13,860
that API endpoint stops it stops working

670
00:28:13,860 --> 00:28:15,659
all together stops responding you don't

671
00:28:15,659 --> 00:28:20,900
see any response so yeah knowledge

672
00:28:20,940 --> 00:28:24,140
see if I can run it

673
00:28:26,760 --> 00:28:29,640
so in this case you get a uh all a

674
00:28:29,640 --> 00:28:30,960
Deadlock

675
00:28:30,960 --> 00:28:32,820
yeah

676
00:28:32,820 --> 00:28:35,279
uh but yeah you you might not always get

677
00:28:35,279 --> 00:28:37,919
a deadlock uh in fact usually what we've

678
00:28:37,919 --> 00:28:39,779
seen is just an issue kind of like the

679
00:28:39,779 --> 00:28:42,299
one I mentioned earlier where the API

680
00:28:42,299 --> 00:28:45,120
endpoint stops responding

681
00:28:45,120 --> 00:28:47,220
uh this is another sort of statement

682
00:28:47,220 --> 00:28:49,620
that I added there's some developers

683
00:28:49,620 --> 00:28:50,580
that

684
00:28:50,580 --> 00:28:54,000
think that if you're using a uh write a

685
00:28:54,000 --> 00:28:55,860
read write lock it's going to be

686
00:28:55,860 --> 00:28:57,720
different than using a read lock but

687
00:28:57,720 --> 00:28:59,700
it's actually eventually going to be the

688
00:28:59,700 --> 00:29:02,039
same so

689
00:29:02,039 --> 00:29:03,360
now

690
00:29:03,360 --> 00:29:05,460
now what so I'll show you all the

691
00:29:05,460 --> 00:29:07,799
problems I didn't show many solutions to

692
00:29:07,799 --> 00:29:09,360
this let's have like manual Solutions

693
00:29:09,360 --> 00:29:11,580
can how can you catch this box order

694
00:29:11,580 --> 00:29:13,320
them by you know reviewing the code

695
00:29:13,320 --> 00:29:14,700
manually

696
00:29:14,700 --> 00:29:16,740
so let's talk about the insecticides

697
00:29:16,740 --> 00:29:18,179
part of this

698
00:29:18,179 --> 00:29:20,159
uh so that you have

699
00:29:20,159 --> 00:29:22,559
we have two sets of tools and we'll

700
00:29:22,559 --> 00:29:24,179
basically talk about this for go

701
00:29:24,179 --> 00:29:26,460
specifically we have obviously Dynamic

702
00:29:26,460 --> 00:29:28,080
analysis which requires running the code

703
00:29:28,080 --> 00:29:31,080
or binary we have a static analysis no

704
00:29:31,080 --> 00:29:33,120
need to run the application though in

705
00:29:33,120 --> 00:29:35,399
many cases your code must build and

706
00:29:35,399 --> 00:29:38,479
we'll see when

707
00:29:38,880 --> 00:29:41,100
um okay these are the dynamic analysis

708
00:29:41,100 --> 00:29:42,899
tools I love specifically for clay for

709
00:29:42,899 --> 00:29:43,799
go

710
00:29:43,799 --> 00:29:45,840
so fasten

711
00:29:45,840 --> 00:29:48,899
um I love when I have

712
00:29:48,899 --> 00:29:51,840
an excuse to to write a fossil for an

713
00:29:51,840 --> 00:29:54,899
application uh especially for go so

714
00:29:54,899 --> 00:29:57,059
passing helps us find bugs in difficult

715
00:29:57,059 --> 00:30:00,419
to reach execution paths in the code so

716
00:30:00,419 --> 00:30:02,279
it generates random program input for a

717
00:30:02,279 --> 00:30:05,220
given Target function uh you basically

718
00:30:05,220 --> 00:30:08,279
give it an initial set of inputs and

719
00:30:08,279 --> 00:30:12,419
then the uh it's anything that is a

720
00:30:12,419 --> 00:30:15,059
complex parsing Logic for instance and

721
00:30:15,059 --> 00:30:17,820
you have some conditions that you rarely

722
00:30:17,820 --> 00:30:18,740
touch

723
00:30:18,740 --> 00:30:21,299
in your execution the execution of your

724
00:30:21,299 --> 00:30:24,179
program then first thing is likely or

725
00:30:24,179 --> 00:30:25,919
more it's going to be more likely to hit

726
00:30:25,919 --> 00:30:28,440
those execution paths and find potential

727
00:30:28,440 --> 00:30:29,520
blocks there

728
00:30:29,520 --> 00:30:30,960
uh

729
00:30:30,960 --> 00:30:34,080
skip there a few slides and then

730
00:30:34,080 --> 00:30:36,480
forego they have there are a few tools

731
00:30:36,480 --> 00:30:40,679
for this so we have and two that are

732
00:30:40,679 --> 00:30:42,120
super confusing actually they are about

733
00:30:42,120 --> 00:30:44,760
three dollars super confusing because of

734
00:30:44,760 --> 00:30:47,760
their names so you have to go that first

735
00:30:47,760 --> 00:30:51,299
which is cover Skydive fossil uh what

736
00:30:51,299 --> 00:30:53,220
that means is basically that as your

737
00:30:53,220 --> 00:30:54,779
faucet runs then it starts generating

738
00:30:54,779 --> 00:30:57,240
input you start seeing a number that

739
00:30:57,240 --> 00:30:59,520
tells you how many uh how many lines of

740
00:30:59,520 --> 00:31:01,980
code or execution paths you were able to

741
00:31:01,980 --> 00:31:04,980
hit so you it basically instruments the

742
00:31:04,980 --> 00:31:07,679
code to keep track of how many line uh

743
00:31:07,679 --> 00:31:10,320
of the execution Parts about that your

744
00:31:10,320 --> 00:31:13,020
input was able to hit then you have go

745
00:31:13,020 --> 00:31:14,220
for us

746
00:31:14,220 --> 00:31:17,880
without the dash different tool but it

747
00:31:17,880 --> 00:31:20,940
can be used with go fuss and it provides

748
00:31:20,940 --> 00:31:23,399
many helper functions in type binding uh

749
00:31:23,399 --> 00:31:25,919
toolbits we have a tool called Gophers

750
00:31:25,919 --> 00:31:28,559
utils it's just basically a library that

751
00:31:28,559 --> 00:31:31,620
allows you to easily dot Transformations

752
00:31:31,620 --> 00:31:33,600
for print functions so if a function

753
00:31:33,600 --> 00:31:36,539
doesn't take integers and strings and

754
00:31:36,539 --> 00:31:41,720
just uh basic data types then you can

755
00:31:41,720 --> 00:31:44,640
you can use our library to basically

756
00:31:44,640 --> 00:31:47,100
create more complex data types their

757
00:31:47,100 --> 00:31:49,980
values and then we have package files

758
00:31:49,980 --> 00:31:53,159
package force is a go native fossil and

759
00:31:53,159 --> 00:31:55,620
this is uh I've been using this a lot

760
00:31:55,620 --> 00:31:57,840
recently it's very easy and it's my

761
00:31:57,840 --> 00:32:00,059
favorite to use so far

762
00:32:00,059 --> 00:32:03,299
it's a native housing package has became

763
00:32:03,299 --> 00:32:07,919
available and go one point T 1.18

764
00:32:07,919 --> 00:32:09,360
um with some beta I don't think it's

765
00:32:09,360 --> 00:32:11,340
better anymore but yeah

766
00:32:11,340 --> 00:32:15,299
and this is how easy is to test to fuss

767
00:32:15,299 --> 00:32:18,659
your go-kart so

768
00:32:18,659 --> 00:32:21,840
a lot of the goals that we audit a

769
00:32:21,840 --> 00:32:24,919
little bit usually they have fairly okay

770
00:32:24,919 --> 00:32:28,980
uh unit testing coverage so what's great

771
00:32:28,980 --> 00:32:30,720
about the native go for

772
00:32:30,720 --> 00:32:34,380
is that it's as easy to write fuzzer

773
00:32:34,380 --> 00:32:37,380
functions as it is to write a unit test

774
00:32:37,380 --> 00:32:40,620
So within your same test files you just

775
00:32:40,620 --> 00:32:42,120
have to write a function that matches

776
00:32:42,120 --> 00:32:45,360
this sort of like template right so you

777
00:32:45,360 --> 00:32:46,980
just call that function says first

778
00:32:46,980 --> 00:32:48,779
whatever it is that you're trying to to

779
00:32:48,779 --> 00:32:52,020
force you create a set of test cases and

780
00:32:52,020 --> 00:32:53,940
you can give it a few your your

781
00:32:53,940 --> 00:32:56,880
essentially your seed let's say the

782
00:32:56,880 --> 00:33:00,240
function takes uh domain names you can

783
00:33:00,240 --> 00:33:04,980
just give it like you know xyz.com or uh

784
00:33:04,980 --> 00:33:07,020
or you and you give it a couple invalid

785
00:33:07,020 --> 00:33:11,940
ones that's all you do there then you uh

786
00:33:11,940 --> 00:33:14,640
iterate your test cases and you add them

787
00:33:14,640 --> 00:33:17,700
to your Corpus this is all this is doing

788
00:33:17,700 --> 00:33:20,220
it's saying like hey all of that that I

789
00:33:20,220 --> 00:33:22,380
defined here I want that in my Corpus

790
00:33:22,380 --> 00:33:24,539
and then the next thing that you do is

791
00:33:24,539 --> 00:33:26,880
you create this function right here

792
00:33:26,880 --> 00:33:29,100
where you call the different parameters

793
00:33:29,100 --> 00:33:30,840
that your function is to be called with

794
00:33:30,840 --> 00:33:32,940
it could be a string it could be an

795
00:33:32,940 --> 00:33:35,720
integer it could be whatever then

796
00:33:35,720 --> 00:33:38,279
go it's going to go ahead and use that

797
00:33:38,279 --> 00:33:41,399
to fuss your functions so it's fairly

798
00:33:41,399 --> 00:33:42,480
easy

799
00:33:42,480 --> 00:33:45,240
uh before I show you an example of that

800
00:33:45,240 --> 00:33:48,299
the other tool that is super easy to use

801
00:33:48,299 --> 00:33:51,899
is go.fuss and this is basically what I

802
00:33:51,899 --> 00:33:57,299
function to false uh to force a function

803
00:33:57,299 --> 00:34:01,140
with uh go plus looks like and this is

804
00:34:01,140 --> 00:34:03,179
actually I grabbed it from flossing

805
00:34:03,179 --> 00:34:05,039
hardness that I used to find a bug for

806
00:34:05,039 --> 00:34:06,360
core DNS

807
00:34:06,360 --> 00:34:09,119
which is a public report that we have in

808
00:34:09,119 --> 00:34:11,280
the trollabits repository so if you go

809
00:34:11,280 --> 00:34:13,440
to google.com slides through a little

810
00:34:13,440 --> 00:34:15,719
better slash Publications you'll see a

811
00:34:15,719 --> 00:34:17,940
series of our reports we have record DNS

812
00:34:17,940 --> 00:34:20,399
report there and this is a function that

813
00:34:20,399 --> 00:34:23,099
we use to find a bug there

814
00:34:23,099 --> 00:34:25,800
um so fairly simple uh they you

815
00:34:25,800 --> 00:34:27,780
basically just

816
00:34:27,780 --> 00:34:30,418
create your structure uh that's going to

817
00:34:30,418 --> 00:34:33,359
be accepted by your function uh and then

818
00:34:33,359 --> 00:34:36,480
you uh here we're using that helper

819
00:34:36,480 --> 00:34:37,980
function that I told you about so that

820
00:34:37,980 --> 00:34:40,320
basically it grabs the data type that

821
00:34:40,320 --> 00:34:43,440
that's going to contain your uh your

822
00:34:43,440 --> 00:34:45,719
Corpus value that default search

823
00:34:45,719 --> 00:34:48,060
generating for you and it's going to use

824
00:34:48,060 --> 00:34:51,540
that in wrap it and insert it in your

825
00:34:51,540 --> 00:34:53,040
data structure and then you're going to

826
00:34:53,040 --> 00:34:54,659
go ahead and call the function that you

827
00:34:54,659 --> 00:34:55,739
actually

828
00:34:55,739 --> 00:34:59,339
fasting with the values that you created

829
00:34:59,339 --> 00:35:01,740
and then hopefully you get a crush so if

830
00:35:01,740 --> 00:35:04,320
you get a crash then that's possibly

831
00:35:04,320 --> 00:35:06,180
going to be a bug just have to do some

832
00:35:06,180 --> 00:35:07,680
triaging and there are different

833
00:35:07,680 --> 00:35:09,359
techniques for that you can use fasting

834
00:35:09,359 --> 00:35:11,339
for so not just like hey find a crash

835
00:35:11,339 --> 00:35:13,200
there are other ways that you can use it

836
00:35:13,200 --> 00:35:16,980
but that's a whole nother Talk itself

837
00:35:16,980 --> 00:35:18,540
this is how it looks like in the native

838
00:35:18,540 --> 00:35:19,619
fusser

839
00:35:19,619 --> 00:35:21,660
fairly simple like I said you define

840
00:35:21,660 --> 00:35:25,020
your test cases this is your Corpus for

841
00:35:25,020 --> 00:35:27,660
here we just are defining a name and a

842
00:35:27,660 --> 00:35:28,500
song

843
00:35:28,500 --> 00:35:30,420
and this is what it looks like this is

844
00:35:30,420 --> 00:35:32,460
my test name and this is my test zone

845
00:35:32,460 --> 00:35:34,260
then I want another test name and

846
00:35:34,260 --> 00:35:36,420
another test zone and then we iterate

847
00:35:36,420 --> 00:35:38,820
overdose we're simply saying add that to

848
00:35:38,820 --> 00:35:41,339
my Corpus for each one of those

849
00:35:41,339 --> 00:35:43,020
and then the next thing that we do it's

850
00:35:43,020 --> 00:35:45,980
simply call the function that we're

851
00:35:45,980 --> 00:35:48,420
fasting when they were targeting pass

852
00:35:48,420 --> 00:35:51,599
requests with the generating name and

853
00:35:51,599 --> 00:35:53,820
song this name and this song is going to

854
00:35:53,820 --> 00:35:58,260
contain the uh basically the the values

855
00:35:58,260 --> 00:36:00,079
that the filter is generating for you

856
00:36:00,079 --> 00:36:03,119
and eventually we will crash and we

857
00:36:03,119 --> 00:36:05,220
notify the court DNS team and it's in

858
00:36:05,220 --> 00:36:08,700
the report it's not a huge impact but

859
00:36:08,700 --> 00:36:12,900
it's not super impactful issue but it's

860
00:36:12,900 --> 00:36:14,820
something that we reported anyways and

861
00:36:14,820 --> 00:36:17,940
it was fun to find

862
00:36:17,940 --> 00:36:20,820
uh great another thing that we use on

863
00:36:20,820 --> 00:36:22,800
our way from Frozen it's a tool called

864
00:36:22,800 --> 00:36:24,839
krf which we developed lateral weights

865
00:36:24,839 --> 00:36:25,800
as well

866
00:36:25,800 --> 00:36:28,800
it's used for fault injection so

867
00:36:28,800 --> 00:36:30,180
basically you are running your

868
00:36:30,180 --> 00:36:35,579
application on or wherever and then what

869
00:36:35,579 --> 00:36:38,099
happens is if the desk starts failing in

870
00:36:38,099 --> 00:36:41,040
that server what happens if there's some

871
00:36:41,040 --> 00:36:43,200
networking issues in that server

872
00:36:43,200 --> 00:36:46,079
Etc this basically causes those issues

873
00:36:46,079 --> 00:36:48,960
in the system so you can see how your

874
00:36:48,960 --> 00:36:51,480
application is reacting to that to those

875
00:36:51,480 --> 00:36:54,240
uh so intercepts system calls eye

876
00:36:54,240 --> 00:36:56,099
operations and injects faults into that

877
00:36:56,099 --> 00:36:58,440
randomly you can always say config

878
00:36:58,440 --> 00:37:01,320
configure it so you define how random

879
00:37:01,320 --> 00:37:03,960
that can be but then you start seeing

880
00:37:03,960 --> 00:37:06,000
how your application reacts to those

881
00:37:06,000 --> 00:37:08,460
uh this is particular particularly

882
00:37:08,460 --> 00:37:10,619
helpful to uh to see how your

883
00:37:10,619 --> 00:37:13,320
application is handling errors and how

884
00:37:13,320 --> 00:37:16,079
it's handling potential Panic conditions

885
00:37:16,079 --> 00:37:18,599
and that sort of thing so something else

886
00:37:18,599 --> 00:37:22,740
fun to use when testing go in depth

887
00:37:22,740 --> 00:37:24,300
all our tools

888
00:37:24,300 --> 00:37:26,520
uh which one we won't cover in detail

889
00:37:26,520 --> 00:37:29,040
but for dynamic testing we have gupter

890
00:37:29,040 --> 00:37:31,920
which is a property testing tool unlike

891
00:37:31,920 --> 00:37:34,200
regular unit tests here you define a set

892
00:37:34,200 --> 00:37:37,380
of properties and then you run your task

893
00:37:37,380 --> 00:37:39,780
and your unit tests need to comply to

894
00:37:39,780 --> 00:37:42,359
those properties that you define so it's

895
00:37:42,359 --> 00:37:43,920
a different approach to sort of a

896
00:37:43,920 --> 00:37:46,260
discipline approach to unit testing you

897
00:37:46,260 --> 00:37:48,420
have package testing just unit testing

898
00:37:48,420 --> 00:37:50,280
you need your native unit testing

899
00:37:50,280 --> 00:37:53,900
package we usually take

900
00:37:54,000 --> 00:37:58,020
ability or audits by mutating existing

901
00:37:58,020 --> 00:38:00,300
unit tests we try to see how the

902
00:38:00,300 --> 00:38:02,880
application reacts to those changes

903
00:38:02,880 --> 00:38:04,859
there's a gold race detector it's just

904
00:38:04,859 --> 00:38:07,560
part of the go package it's useful for

905
00:38:07,560 --> 00:38:11,460
catching some super basic uh race data

906
00:38:11,460 --> 00:38:13,740
races dynamically it's not super

907
00:38:13,740 --> 00:38:15,660
efficient a lot of the bugs that we

908
00:38:15,660 --> 00:38:18,180
found that are concurrent box the go

909
00:38:18,180 --> 00:38:20,040
phrase detector was not able to catch

910
00:38:20,040 --> 00:38:22,740
the sonarity will go gold deadlock which

911
00:38:22,740 --> 00:38:25,400
basically instead of the regular

912
00:38:25,400 --> 00:38:28,380
Mutual execution Library which contains

913
00:38:28,380 --> 00:38:30,960
your functions for dealing with locks

914
00:38:30,960 --> 00:38:33,740
and Deadlocks for locks

915
00:38:33,740 --> 00:38:36,000
you replace it with this other Library

916
00:38:36,000 --> 00:38:38,700
which is uh and run your application and

917
00:38:38,700 --> 00:38:40,020
it's going to tell you hey here's how

918
00:38:40,020 --> 00:38:41,880
deadlock competition should that lock so

919
00:38:41,880 --> 00:38:45,599
kind of funny tool I'll make this slides

920
00:38:45,599 --> 00:38:46,980
available and you can actually click on

921
00:38:46,980 --> 00:38:48,660
these links to get get you there but

922
00:38:48,660 --> 00:38:51,140
they are fairly easy to find as well

923
00:38:51,140 --> 00:38:55,859
okay let's talk about static analysis

924
00:38:55,859 --> 00:38:58,500
all right so when we talk about static

925
00:38:58,500 --> 00:39:00,960
analysis static analysis come from the

926
00:39:00,960 --> 00:39:03,359
world of program analysis uh portable

927
00:39:03,359 --> 00:39:05,460
program analysis it's super interesting

928
00:39:05,460 --> 00:39:10,619
it's basically this feel that uh it

929
00:39:10,619 --> 00:39:12,839
concerns itself it's right in programs

930
00:39:12,839 --> 00:39:15,180
that reads on programs

931
00:39:15,180 --> 00:39:17,520
very interesting in my opinion uh so

932
00:39:17,520 --> 00:39:19,740
basically you give it a sore piece of

933
00:39:19,740 --> 00:39:22,140
source code and then in first facts file

934
00:39:22,140 --> 00:39:24,599
the program by inspecting its code it

935
00:39:24,599 --> 00:39:26,700
does this without executing the code for

936
00:39:26,700 --> 00:39:29,520
the most part there's for instance you

937
00:39:29,520 --> 00:39:33,240
have symbolic execution which in fasting

938
00:39:33,240 --> 00:39:34,740
can also be tied to the world of program

939
00:39:34,740 --> 00:39:37,020
analysis as well

940
00:39:37,020 --> 00:39:40,079
um which we won't cover here but yeah

941
00:39:40,079 --> 00:39:42,780
so this is a general approach that

942
00:39:42,780 --> 00:39:45,480
static analysis tool use to generate an

943
00:39:45,480 --> 00:39:48,180
abstract interpretation of the code so

944
00:39:48,180 --> 00:39:51,060
uh basically we're gonna abstract that

945
00:39:51,060 --> 00:39:52,980
as much as possible but we're going to

946
00:39:52,980 --> 00:39:54,420
remove this stuff that is not important

947
00:39:54,420 --> 00:39:56,820
for our analysis and we're gonna build

948
00:39:56,820 --> 00:39:58,859
what we call an abstract syntax tree

949
00:39:58,859 --> 00:40:01,200
from there we're going to do a control

950
00:40:01,200 --> 00:40:03,300
flow graph where we're basically we're

951
00:40:03,300 --> 00:40:05,099
going to determine where the different

952
00:40:05,099 --> 00:40:08,460
flows uh execution flows that can exist

953
00:40:08,460 --> 00:40:10,920
in your program and then it conducts

954
00:40:10,920 --> 00:40:13,800
analysis based on that abstract program

955
00:40:13,800 --> 00:40:16,079
so basically this is what I might look

956
00:40:16,079 --> 00:40:18,720
like I have something like this four

957
00:40:18,720 --> 00:40:21,960
times two plus three uh return a plus

958
00:40:21,960 --> 00:40:24,240
two and this is how you might extract

959
00:40:24,240 --> 00:40:26,640
that right you have a numbered four then

960
00:40:26,640 --> 00:40:28,680
you have an operator which is your

961
00:40:28,680 --> 00:40:30,960
multiplication operator then you have

962
00:40:30,960 --> 00:40:33,240
number two number three and between that

963
00:40:33,240 --> 00:40:36,240
you have a addition operator and this is

964
00:40:36,240 --> 00:40:38,400
the the what your return statement might

965
00:40:38,400 --> 00:40:40,260
look like you have a battery operator

966
00:40:40,260 --> 00:40:42,480
which is a plus sign you have an ID

967
00:40:42,480 --> 00:40:44,820
which is your variable a you have the

968
00:40:44,820 --> 00:40:47,760
constant uh which is your value too

969
00:40:47,760 --> 00:40:50,220
basically abstracts it in that way and

970
00:40:50,220 --> 00:40:52,020
then after that it's going to create

971
00:40:52,020 --> 00:40:54,780
your control flow graph to determine

972
00:40:54,780 --> 00:40:57,240
what the different execution flows might

973
00:40:57,240 --> 00:40:59,820
look like for different values

974
00:40:59,820 --> 00:41:02,160
and then it conducts analysis at

975
00:41:02,160 --> 00:41:04,680
interpretation of your program

976
00:41:04,680 --> 00:41:06,500
now

977
00:41:06,500 --> 00:41:09,540
for there are some ASD based tooling

978
00:41:09,540 --> 00:41:13,339
tools that essentially all they do is

979
00:41:13,339 --> 00:41:16,079
obtain that abstract interpretation of

980
00:41:16,079 --> 00:41:18,480
your code and then conduct analysis

981
00:41:18,480 --> 00:41:20,579
based on that and only that

982
00:41:20,579 --> 00:41:23,940
these are some of them so gosec are

983
00:41:23,940 --> 00:41:26,820
check in fsine these are super common

984
00:41:26,820 --> 00:41:29,700
for static analysis tools for go and

985
00:41:29,700 --> 00:41:32,640
these are all open source uh there's a

986
00:41:32,640 --> 00:41:35,220
patreon from Sam grab of course but uh

987
00:41:35,220 --> 00:41:37,700
these are all open source easy to find

988
00:41:37,700 --> 00:41:41,220
super common and we use them on every

989
00:41:41,220 --> 00:41:42,980
audit basically

990
00:41:42,980 --> 00:41:47,160
now here's the thing with those this is

991
00:41:47,160 --> 00:41:49,560
what go the go sacred results look like

992
00:41:49,560 --> 00:41:51,900
it just tells you a book gives you a

993
00:41:51,900 --> 00:41:53,280
bunch of results a lot of false

994
00:41:53,280 --> 00:41:55,859
positives usually

995
00:41:55,859 --> 00:41:58,020
um now here's the thing with ASD based

996
00:41:58,020 --> 00:42:01,079
tooling uh he usually finds issues that

997
00:42:01,079 --> 00:42:03,960
are super easy to catch with ASD parsing

998
00:42:03,960 --> 00:42:06,060
all it does is basically passes that AST

999
00:42:06,060 --> 00:42:07,859
tree

1000
00:42:07,859 --> 00:42:08,880
um so you might find things like

1001
00:42:08,880 --> 00:42:11,220
insecure usage of functions so a

1002
00:42:11,220 --> 00:42:12,720
non-function that you're passing it

1003
00:42:12,720 --> 00:42:15,960
you're given it uh a value that's not

1004
00:42:15,960 --> 00:42:19,020
the problematic some configuration

1005
00:42:19,020 --> 00:42:21,300
issues there's going to be lots of false

1006
00:42:21,300 --> 00:42:24,180
positives it doesn't do data flow

1007
00:42:24,180 --> 00:42:26,460
analysis typically so it's just doing a

1008
00:42:26,460 --> 00:42:29,940
a b it's just looking at your AST your

1009
00:42:29,940 --> 00:42:31,980
uh that absolute interpretation that I

1010
00:42:31,980 --> 00:42:33,420
showed you earlier

1011
00:42:33,420 --> 00:42:36,119
so it basically if you have three

1012
00:42:36,119 --> 00:42:39,540
functions uh one two three function two

1013
00:42:39,540 --> 00:42:42,000
calls function three uh in function one

1014
00:42:42,000 --> 00:42:44,460
might also call function three it might

1015
00:42:44,460 --> 00:42:47,099
not be aware of that it just it

1016
00:42:47,099 --> 00:42:49,020
typically just to does what we call

1017
00:42:49,020 --> 00:42:50,820
intra

1018
00:42:50,820 --> 00:42:53,700
functional or intra procedural analysis

1019
00:42:53,700 --> 00:42:55,680
right so looks at one single function

1020
00:42:55,680 --> 00:42:57,599
and says like okay this is how this

1021
00:42:57,599 --> 00:42:59,780
particular function works but it doesn't

1022
00:42:59,780 --> 00:43:03,540
conduct analysis based on what does the

1023
00:43:03,540 --> 00:43:05,700
color for this function look like

1024
00:43:05,700 --> 00:43:07,560
right

1025
00:43:07,560 --> 00:43:10,260
um now usually if you start looking at

1026
00:43:10,260 --> 00:43:12,839
the code for static analysis tools what

1027
00:43:12,839 --> 00:43:14,040
you're going to see is they use this

1028
00:43:14,040 --> 00:43:16,260
package go go waste if you are

1029
00:43:16,260 --> 00:43:18,240
interested in writing your own utilities

1030
00:43:18,240 --> 00:43:21,380
for static analysis looking to go ASD

1031
00:43:21,380 --> 00:43:25,280
and you uh it's fairly easy to use

1032
00:43:25,280 --> 00:43:29,160
and all these tools usually rely on that

1033
00:43:29,160 --> 00:43:31,740
for conducting the analysis

1034
00:43:31,740 --> 00:43:34,920
then you have data flow analysis with go

1035
00:43:34,920 --> 00:43:37,680
which does look at that analysis between

1036
00:43:37,680 --> 00:43:39,240
functions and how the functions are

1037
00:43:39,240 --> 00:43:41,700
calling each other and then what we look

1038
00:43:41,700 --> 00:43:43,619
at is at this particular package called

1039
00:43:43,619 --> 00:43:47,940
go SSA SSA chooses static single

1040
00:43:47,940 --> 00:43:50,880
assignment it's an basically when you

1041
00:43:50,880 --> 00:43:53,880
compile your go code it goes first to

1042
00:43:53,880 --> 00:43:56,579
before it goes to the turning into a

1043
00:43:56,579 --> 00:43:59,460
binary it goes to it turns it into this

1044
00:43:59,460 --> 00:44:02,220
intermediate representation called SSA

1045
00:44:02,220 --> 00:44:06,359
what SSA means basically is that if you

1046
00:44:06,359 --> 00:44:09,000
are using the value X in five different

1047
00:44:09,000 --> 00:44:10,859
places in your function it doesn't

1048
00:44:10,859 --> 00:44:13,079
matter it's going to rename those values

1049
00:44:13,079 --> 00:44:17,460
X1 X2 X4 is five so it gives it one for

1050
00:44:17,460 --> 00:44:18,960
every time that it gets used it's going

1051
00:44:18,960 --> 00:44:21,300
to give it a different name so you can

1052
00:44:21,300 --> 00:44:24,660
understand better how data flows between

1053
00:44:24,660 --> 00:44:27,420
different uh different functions and

1054
00:44:27,420 --> 00:44:29,460
different execution branches

1055
00:44:29,460 --> 00:44:32,819
usually this allows tools it's more

1056
00:44:32,819 --> 00:44:34,319
complex it's more difficult to write

1057
00:44:34,319 --> 00:44:37,859
Tools in this manner and do analysis on

1058
00:44:37,859 --> 00:44:40,440
that intermediate representation but it

1059
00:44:40,440 --> 00:44:43,260
allows you to understand execution flow

1060
00:44:43,260 --> 00:44:44,819
a lot better so you're going to get a

1061
00:44:44,819 --> 00:44:46,740
lot less false positives

1062
00:44:46,740 --> 00:44:49,500
this is what this program for instance

1063
00:44:49,500 --> 00:44:52,440
looks an SSA form so it's just a super

1064
00:44:52,440 --> 00:44:54,599
program there but as you see right here

1065
00:44:54,599 --> 00:44:55,680
we have

1066
00:44:55,680 --> 00:44:57,540
uh it looks like we only have one

1067
00:44:57,540 --> 00:44:59,819
variable there message but then we have

1068
00:44:59,819 --> 00:45:04,859
t0 T1 T2 T1 T3 T4 because again we are

1069
00:45:04,859 --> 00:45:06,839
trying to understand the different

1070
00:45:06,839 --> 00:45:10,200
values that's independent values to

1071
00:45:10,200 --> 00:45:11,520
better understand the flow of the

1072
00:45:11,520 --> 00:45:12,780
program

1073
00:45:12,780 --> 00:45:16,160
so it also builds these Dominator trees

1074
00:45:16,160 --> 00:45:18,480
from these dominated trees we can again

1075
00:45:18,480 --> 00:45:20,819
understand that execution flow a lot

1076
00:45:20,819 --> 00:45:23,280
better and get less false positives

1077
00:45:23,280 --> 00:45:25,560
these are the ssa-based tools that you

1078
00:45:25,560 --> 00:45:28,940
can find so with Sam grab for instance

1079
00:45:28,940 --> 00:45:32,099
you can typically find bugs with any

1080
00:45:32,099 --> 00:45:33,720
specific functions

1081
00:45:33,720 --> 00:45:35,400
there are some functionality there's

1082
00:45:35,400 --> 00:45:38,040
some functionality within Sam grab which

1083
00:45:38,040 --> 00:45:39,240
allows you to write your own custom

1084
00:45:39,240 --> 00:45:43,079
rules to find boxing code but there's

1085
00:45:43,079 --> 00:45:44,640
some functionality in standard that

1086
00:45:44,640 --> 00:45:46,619
allows you to do some data flow analysis

1087
00:45:46,619 --> 00:45:48,720
but all those functions need to live in

1088
00:45:48,720 --> 00:45:50,640
the same file so it's not smart enough

1089
00:45:50,640 --> 00:45:53,520
to determine uh if you have one file

1090
00:45:53,520 --> 00:45:55,740
with function a which calls function B

1091
00:45:55,740 --> 00:45:57,240
which is located in a different file

1092
00:45:57,240 --> 00:45:59,880
it's nowhere to consider that you have

1093
00:45:59,880 --> 00:46:04,260
to use a tool like codeql to do that

1094
00:46:04,260 --> 00:46:07,200
sort of analysis and that where there

1095
00:46:07,200 --> 00:46:09,599
might be a bug because call function a

1096
00:46:09,599 --> 00:46:11,960
it's calling function B in securely

1097
00:46:11,960 --> 00:46:14,700
there's another tool called gcatch in

1098
00:46:14,700 --> 00:46:18,000
g-catch it's a excellent tool for static

1099
00:46:18,000 --> 00:46:21,000
analysis uh for finding a specifically

1100
00:46:21,000 --> 00:46:24,480
go concur currency box concurrency box

1101
00:46:24,480 --> 00:46:26,099
are typically very hard to find

1102
00:46:26,099 --> 00:46:29,280
statically because again it considers

1103
00:46:29,280 --> 00:46:31,800
you have to consider the whole execution

1104
00:46:31,800 --> 00:46:33,300
path between multiple functions

1105
00:46:33,300 --> 00:46:35,579
sometimes those execution paths might

1106
00:46:35,579 --> 00:46:37,040
get very very complex

1107
00:46:37,040 --> 00:46:39,780
g-catch is a tool that comes from

1108
00:46:39,780 --> 00:46:43,260
Academia so it can be pretty hard to set

1109
00:46:43,260 --> 00:46:46,380
up because a lot of academics I'm not

1110
00:46:46,380 --> 00:46:50,000
concerned with usage or usability

1111
00:46:50,000 --> 00:46:54,240
but uh once you get it working it's it's

1112
00:46:54,240 --> 00:46:55,859
great uh you don't have to run the

1113
00:46:55,859 --> 00:46:57,900
application it just needs to build so it

1114
00:46:57,900 --> 00:47:00,240
can construct those uh execution trees

1115
00:47:00,240 --> 00:47:02,400
and then it does a great job of finding

1116
00:47:02,400 --> 00:47:04,020
all the issues that I mentioned earlier

1117
00:47:04,020 --> 00:47:05,099
actually

1118
00:47:05,099 --> 00:47:07,500
uh so all the issues all the specific

1119
00:47:07,500 --> 00:47:09,660
examples that I gave you earlier g-catch

1120
00:47:09,660 --> 00:47:11,220
will be able to find

1121
00:47:11,220 --> 00:47:14,819
then you have a stripe has a a tool

1122
00:47:14,819 --> 00:47:18,440
called save SQL and that's to make sure

1123
00:47:18,440 --> 00:47:22,260
again because it considers the whole

1124
00:47:22,260 --> 00:47:24,359
execution path then you can say like oh

1125
00:47:24,359 --> 00:47:25,859
this value right here that you are

1126
00:47:25,859 --> 00:47:28,200
calling this query with that is user

1127
00:47:28,200 --> 00:47:30,180
control and I know it because I did the

1128
00:47:30,180 --> 00:47:32,099
analysis between the your multiple

1129
00:47:32,099 --> 00:47:34,740
functions there uh and then the next one

1130
00:47:34,740 --> 00:47:38,700
is go-kart go-kart was released by

1131
00:47:38,700 --> 00:47:39,960
um

1132
00:47:39,960 --> 00:47:43,079
I forgot the name just look it up but uh

1133
00:47:43,079 --> 00:47:45,780
it basically finds a lot of uh SQL

1134
00:47:45,780 --> 00:47:49,500
injection issues and also uh like path

1135
00:47:49,500 --> 00:47:52,520
injection issues as well

1136
00:47:52,520 --> 00:47:55,200
doesn't that into procedural analysis

1137
00:47:55,200 --> 00:47:58,020
you write your own queries so basically

1138
00:47:58,020 --> 00:48:00,720
you a construct a database of execution

1139
00:48:00,720 --> 00:48:03,660
flow in your program and then you query

1140
00:48:03,660 --> 00:48:07,140
that database and you say find me a

1141
00:48:07,140 --> 00:48:10,319
function that calls uh function X and Y

1142
00:48:10,319 --> 00:48:13,500
with parameters that look like this and

1143
00:48:13,500 --> 00:48:15,540
then it's going to do what it's called

1144
00:48:15,540 --> 00:48:18,420
chain tracking to see how for instance

1145
00:48:18,420 --> 00:48:20,160
the value of a variable might change

1146
00:48:20,160 --> 00:48:23,700
along a series of functions uh in that

1147
00:48:23,700 --> 00:48:25,319
way it's going to do a smarter analysis

1148
00:48:25,319 --> 00:48:27,480
for you it does have a steep learning

1149
00:48:27,480 --> 00:48:30,780
curve I have started using it and I like

1150
00:48:30,780 --> 00:48:32,520
using it but it takes a long time to

1151
00:48:32,520 --> 00:48:35,700
build your queries I usually prefer same

1152
00:48:35,700 --> 00:48:36,839
group

1153
00:48:36,839 --> 00:48:39,300
uh gcatch already mentioned that earlier

1154
00:48:39,300 --> 00:48:40,560
it's a great tool for finding

1155
00:48:40,560 --> 00:48:43,440
concurrency box I use this SSA analysis

1156
00:48:43,440 --> 00:48:45,300
it finds code routine leaks missing

1157
00:48:45,300 --> 00:48:46,859
unlocks all the issues that I showed you

1158
00:48:46,859 --> 00:48:49,020
earlier and it uses this this thing

1159
00:48:49,020 --> 00:48:50,220
called C3

1160
00:48:50,220 --> 00:48:51,900
to create to do this thing called

1161
00:48:51,900 --> 00:48:54,540
constraint solvent for doing its smart

1162
00:48:54,540 --> 00:48:56,460
sort of analysis

1163
00:48:56,460 --> 00:48:58,200
and this is a g-catching action

1164
00:48:58,200 --> 00:49:00,720
basically we run it and here it's

1165
00:49:00,720 --> 00:49:03,839
finding that execution path for a good

1166
00:49:03,839 --> 00:49:07,440
routine link so here it's actually smart

1167
00:49:07,440 --> 00:49:10,980
enough to to determine that there's this

1168
00:49:10,980 --> 00:49:12,960
execution tree this call which causes

1169
00:49:12,960 --> 00:49:16,280
which called this which calls that and

1170
00:49:16,280 --> 00:49:19,260
the block is occurring right here so you

1171
00:49:19,260 --> 00:49:20,760
can go in your code and find that

1172
00:49:20,760 --> 00:49:23,520
particular issue so it's quite

1173
00:49:23,520 --> 00:49:25,859
sand grab is also great do you have to

1174
00:49:25,859 --> 00:49:27,359
write

1175
00:49:27,359 --> 00:49:30,420
rules so it does that analysis within

1176
00:49:30,420 --> 00:49:32,640
specific functions it's more than grab

1177
00:49:32,640 --> 00:49:35,280
because it does analysis of the AST the

1178
00:49:35,280 --> 00:49:39,119
abstract syntax tree of your program

1179
00:49:39,119 --> 00:49:41,819
um and that can catch easy instances of

1180
00:49:41,819 --> 00:49:44,400
issues found by d-catch 2. so if you

1181
00:49:44,400 --> 00:49:48,000
write your rule your your Sam grab rules

1182
00:49:48,000 --> 00:49:51,420
in a smart way you can find concurrency

1183
00:49:51,420 --> 00:49:54,540
issues as well by identifying patterns

1184
00:49:54,540 --> 00:49:58,640
in the design in in in the way in which

1185
00:49:58,640 --> 00:50:01,740
concurrency box manifests themselves

1186
00:50:01,740 --> 00:50:04,140
so this is what that same grab rule

1187
00:50:04,140 --> 00:50:06,900
might look like so remember that missing

1188
00:50:06,900 --> 00:50:10,020
lock issue that I've I gave you earlier

1189
00:50:10,020 --> 00:50:12,720
this is what the rule for it will look

1190
00:50:12,720 --> 00:50:15,300
like for finding it fairly simple this

1191
00:50:15,300 --> 00:50:17,700
is all you have to write uh I'm not

1192
00:50:17,700 --> 00:50:21,000
going to go over how this works but I'll

1193
00:50:21,000 --> 00:50:23,579
show you their playground and how this

1194
00:50:23,579 --> 00:50:25,740
rule works

1195
00:50:25,740 --> 00:50:28,098
so

1196
00:50:32,579 --> 00:50:35,160
okay good day work

1197
00:50:35,160 --> 00:50:37,619
okay so we have uh the same function

1198
00:50:37,619 --> 00:50:38,579
that I showed you earlier without

1199
00:50:38,579 --> 00:50:41,760
missing on Lock and then we have it's

1200
00:50:41,760 --> 00:50:43,380
not showing the rule here I think the

1201
00:50:43,380 --> 00:50:45,780
data an update recently for this but

1202
00:50:45,780 --> 00:50:48,960
let's just try it yeah so here it shows

1203
00:50:48,960 --> 00:50:50,819
that we're returning here before

1204
00:50:50,819 --> 00:50:53,880
actually showing the uh before actually

1205
00:50:53,880 --> 00:50:55,740
releasing the lock

1206
00:50:55,740 --> 00:50:58,319
so we actually oh yeah here are the

1207
00:50:58,319 --> 00:51:00,059
different cases that we have if we go to

1208
00:51:00,059 --> 00:51:03,059
advanced mode it shows the entire rule

1209
00:51:03,059 --> 00:51:05,940
so we can find this super sort of basic

1210
00:51:05,940 --> 00:51:09,780
uh box and we actually have uh tulabits

1211
00:51:09,780 --> 00:51:11,400
has a uh

1212
00:51:11,400 --> 00:51:15,119
repository of rules for Sam grab that we

1213
00:51:15,119 --> 00:51:17,220
wrote and many of them actually most of

1214
00:51:17,220 --> 00:51:18,660
the ones that we have for go are for

1215
00:51:18,660 --> 00:51:20,579
concurrency issues and it does a great

1216
00:51:20,579 --> 00:51:22,980
job we've been refining those rules over

1217
00:51:22,980 --> 00:51:25,859
time and they have very few very very

1218
00:51:25,859 --> 00:51:27,780
few false positives and most of the

1219
00:51:27,780 --> 00:51:29,760
times that we run it we find

1220
00:51:29,760 --> 00:51:32,339
good issues with and it's super fast as

1221
00:51:32,339 --> 00:51:34,020
well

1222
00:51:34,020 --> 00:51:38,220
all right so this is where the Gap

1223
00:51:38,220 --> 00:51:41,099
exists and tooling so all these issues

1224
00:51:41,099 --> 00:51:44,700
that you that the that you can find VIA

1225
00:51:44,700 --> 00:51:46,319
all the tools that I mentioned

1226
00:51:46,319 --> 00:51:49,619
are typically due to misuse of native

1227
00:51:49,619 --> 00:51:52,920
functions in go right now once you start

1228
00:51:52,920 --> 00:51:56,760
getting into say you have a orm library

1229
00:51:56,760 --> 00:52:00,000
in go or an API library and go that was

1230
00:52:00,000 --> 00:52:03,059
written by some other somebody for like

1231
00:52:03,059 --> 00:52:06,359
another like organizational company then

1232
00:52:06,359 --> 00:52:09,300
uh most tools do not consider you know

1233
00:52:09,300 --> 00:52:11,760
those Frameworks or libraries Etc so

1234
00:52:11,760 --> 00:52:14,280
that's where the gapix is

1235
00:52:14,280 --> 00:52:17,099
um we can use Sam grab or ql to find

1236
00:52:17,099 --> 00:52:19,260
issues in those cases so for instance

1237
00:52:19,260 --> 00:52:22,440
let's say go has a couple well-known

1238
00:52:22,440 --> 00:52:24,599
libraries for apis one is called gorilla

1239
00:52:24,599 --> 00:52:27,559
the only one is called gin

1240
00:52:27,559 --> 00:52:31,020
uh finding issues where you are misusing

1241
00:52:31,020 --> 00:52:32,280
those libraries and using those

1242
00:52:32,280 --> 00:52:34,980
libraries insecurely they are not really

1243
00:52:34,980 --> 00:52:38,400
any tools that find uh that can consider

1244
00:52:38,400 --> 00:52:40,680
those functions and find bugs in those

1245
00:52:40,680 --> 00:52:42,900
so that's why we're trying to cover uh

1246
00:52:42,900 --> 00:52:45,180
so this is for instance at gorilla and

1247
00:52:45,180 --> 00:52:48,240
then we have a csrf bug

1248
00:52:48,240 --> 00:52:51,420
um or you know we have a plain key for

1249
00:52:51,420 --> 00:52:55,819
our csrf token so some of these issues

1250
00:52:55,819 --> 00:52:58,740
functions like this and uh boxing

1251
00:52:58,740 --> 00:53:00,300
functions that look like they start rely

1252
00:53:00,300 --> 00:53:02,400
on external libraries they're not tools

1253
00:53:02,400 --> 00:53:04,740
that specifically cover this you have to

1254
00:53:04,740 --> 00:53:06,960
write your own custom rules same thing

1255
00:53:06,960 --> 00:53:09,119
with like a course issue for instance

1256
00:53:09,119 --> 00:53:11,400
with the gorilla package there are no

1257
00:53:11,400 --> 00:53:13,440
tools that will focus on finding this

1258
00:53:13,440 --> 00:53:15,720
type of issues necessarily this is a big

1259
00:53:15,720 --> 00:53:18,300
gap that exists this is an orm called

1260
00:53:18,300 --> 00:53:21,420
Quorum a different package and this is a

1261
00:53:21,420 --> 00:53:25,200
SQL injection portability here uh there

1262
00:53:25,200 --> 00:53:27,559
are no tools that will find necessarily

1263
00:53:27,559 --> 00:53:30,480
that will focus on misuse of functions

1264
00:53:30,480 --> 00:53:33,180
in warm I think there are some that do

1265
00:53:33,180 --> 00:53:34,859
some work for that focus on SQL

1266
00:53:34,859 --> 00:53:37,559
injections specifically but again going

1267
00:53:37,559 --> 00:53:40,020
further there's nothing like that

1268
00:53:40,020 --> 00:53:41,400
this is the gap that we've been trying

1269
00:53:41,400 --> 00:53:43,440
to cover actual bits it's called a tool

1270
00:53:43,440 --> 00:53:45,300
that we've been working on called gotiko

1271
00:53:45,300 --> 00:53:47,700
uh we're still in development and we

1272
00:53:47,700 --> 00:53:49,020
have analysis for these different

1273
00:53:49,020 --> 00:53:50,940
libraries team gorilla tender mint

1274
00:53:50,940 --> 00:53:52,800
tindermint smartphone blockchain thing

1275
00:53:52,800 --> 00:53:56,040
but we're still covering it Quorum as

1276
00:53:56,040 --> 00:53:58,260
well it relies heavily on ASC parking

1277
00:53:58,260 --> 00:54:00,359
but we have some basic SSA support for

1278
00:54:00,359 --> 00:54:02,640
conducting that data flow analysis as

1279
00:54:02,640 --> 00:54:03,540
well

1280
00:54:03,540 --> 00:54:06,059
uh I'm not sure what happened here image

1281
00:54:06,059 --> 00:54:09,059
is missing but uh it's basically in its

1282
00:54:09,059 --> 00:54:11,220
initial State uh you run and it's going

1283
00:54:11,220 --> 00:54:13,440
to find issues like all the all the

1284
00:54:13,440 --> 00:54:15,059
issues that I showed you earlier it's

1285
00:54:15,059 --> 00:54:17,160
gonna detect that you are using overly

1286
00:54:17,160 --> 00:54:20,579
permissive uh course uh with Gorilla for

1287
00:54:20,579 --> 00:54:22,440
instance

1288
00:54:22,440 --> 00:54:23,220
um

1289
00:54:23,220 --> 00:54:25,559
great so why not just stick to Sangre

1290
00:54:25,559 --> 00:54:27,780
and Google so a custom solution allows

1291
00:54:27,780 --> 00:54:30,660
us to control the logic of each bug this

1292
00:54:30,660 --> 00:54:33,059
is also often needed given how different

1293
00:54:33,059 --> 00:54:35,460
packages are used so this is the goal is

1294
00:54:35,460 --> 00:54:37,260
to make it super easy for people to

1295
00:54:37,260 --> 00:54:39,180
write their own rules that conduct

1296
00:54:39,180 --> 00:54:41,339
analysis on this different libraries and

1297
00:54:41,339 --> 00:54:42,960
so that encourages others to contribute

1298
00:54:42,960 --> 00:54:44,579
new rules

1299
00:54:44,579 --> 00:54:47,700
so that's it uh hopefully that was in

1300
00:54:47,700 --> 00:54:51,180
turanti but uh the takeaway is just to

1301
00:54:51,180 --> 00:54:52,680
leverage Dynamic analysis as much as

1302
00:54:52,680 --> 00:54:55,200
possible review unit tests getting too

1303
00:54:55,200 --> 00:54:57,660
fast especially with go it's gonna be

1304
00:54:57,660 --> 00:55:00,599
easy you'll see uh use ASC tools for

1305
00:55:00,599 --> 00:55:02,819
finding common misuse of native packages

1306
00:55:02,819 --> 00:55:06,000
and use ssa-based tools for finding more

1307
00:55:06,000 --> 00:55:08,280
complex bugs that requires an analysis

1308
00:55:08,280 --> 00:55:10,940
between different functions

1309
00:55:10,940 --> 00:55:13,200
and there's another one similar to that

1310
00:55:13,200 --> 00:55:15,839
called ruleguard for when you need to

1311
00:55:15,839 --> 00:55:17,940
write your own rules in queries super

1312
00:55:17,940 --> 00:55:19,980
easy specially for Sam grab and Rule

1313
00:55:19,980 --> 00:55:21,660
guard codeql is going to be more complex

1314
00:55:21,660 --> 00:55:24,359
more more of a steep learning curve but

1315
00:55:24,359 --> 00:55:26,700
great as well

1316
00:55:26,700 --> 00:55:29,099
contribute to existing tools as well if

1317
00:55:29,099 --> 00:55:30,000
you can

1318
00:55:30,000 --> 00:55:31,680
these are so many resources that I

1319
00:55:31,680 --> 00:55:33,359
showed you

1320
00:55:33,359 --> 00:55:34,140
um

1321
00:55:34,140 --> 00:55:36,599
and that I talked about and this gives

1322
00:55:36,599 --> 00:55:38,460
you a little more information on those

1323
00:55:38,460 --> 00:55:40,079
and these are some of the troll batch

1324
00:55:40,079 --> 00:55:43,079
resources for that apply to the stock so

1325
00:55:43,079 --> 00:55:45,420
the Publications link that has a lot of

1326
00:55:45,420 --> 00:55:47,700
the we have a lot of go audits there so

1327
00:55:47,700 --> 00:55:48,960
you can see the box that we find there

1328
00:55:48,960 --> 00:55:52,319
and how we allow transport right proof

1329
00:55:52,319 --> 00:55:54,420
of concept code as well that's included

1330
00:55:54,420 --> 00:55:56,579
in our reports our Sam Club rules which

1331
00:55:56,579 --> 00:55:58,980
are pretty great all this is open source

1332
00:55:58,980 --> 00:56:01,980
and free of course the krf is the Fault

1333
00:56:01,980 --> 00:56:04,740
injection tool not going anywhere it's a

1334
00:56:04,740 --> 00:56:07,559
repository of go box you can go there

1335
00:56:07,559 --> 00:56:09,420
and experiment with different gold box

1336
00:56:09,420 --> 00:56:11,819
and play with them so it's basically

1337
00:56:11,819 --> 00:56:14,160
intentionally vulnerable microservices

1338
00:56:14,160 --> 00:56:16,020
you can think of that I guess

1339
00:56:16,020 --> 00:56:18,180
and that's it so hopefully you enjoyed

1340
00:56:18,180 --> 00:56:19,859
it and uh

1341
00:56:19,859 --> 00:56:21,660
have a great day

1342
00:56:21,660 --> 00:56:24,140
thanks

