1
00:00:18,040 --> 00:00:23,090
<font color="#CCCCCC">alright thanks everybody for coming</font>

2
00:00:19,880 --> 00:00:25,250
especially it's late on a Friday now

3
00:00:23,090 --> 00:00:26,570
you've probably all want to go home so

4
00:00:25,250 --> 00:00:28,970
today's talk is going<font color="#E5E5E5"> to be about</font>

5
00:00:26,570 --> 00:00:31,310
enforcing authorization controls

6
00:00:28,970 --> 00:00:35,540
essentially data level authorization

7
00:00:31,310 --> 00:00:36,710
controls using cryptography so the

8
00:00:35,540 --> 00:00:38,180
agenda is really going<font color="#CCCCCC"> to be talking</font>

9
00:00:36,710 --> 00:00:40,400
about what the problem is<font color="#CCCCCC"> that we're</font>

10
00:00:38,180 --> 00:00:42,949
<font color="#E5E5E5">trying to solve first of all it's a very</font>

11
00:00:40,400 --> 00:00:44,269
<font color="#E5E5E5">common problem we're going to talk about</font>

12
00:00:42,949 --> 00:00:45,500
<font color="#CCCCCC">some of</font><font color="#E5E5E5"> the common solutions to the</font>

13
00:00:44,269 --> 00:00:47,900
problem and some of the potential

14
00:00:45,500 --> 00:00:49,760
problems with those solutions then we'll

15
00:00:47,900 --> 00:00:52,670
talk<font color="#E5E5E5"> about sort of a new cryptography</font>

16
00:00:49,760 --> 00:00:53,870
based solution not<font color="#E5E5E5"> necessarily new but I</font>

17
00:00:52,670 --> 00:00:56,299
haven't<font color="#E5E5E5"> seen too many people out there</font>

18
00:00:53,870 --> 00:00:58,989
<font color="#CCCCCC">using it and it is something</font><font color="#E5E5E5"> that I've</font>

19
00:00:56,299 --> 00:01:00,979
recommended a lot to some of<font color="#E5E5E5"> our clients</font>

20
00:00:58,989 --> 00:01:02,989
we're<font color="#E5E5E5"> going to do</font><font color="#CCCCCC"> some performance</font>

21
00:01:00,979 --> 00:01:04,548
comparisons of this approach with some

22
00:01:02,989 --> 00:01:07,039
of the existing approaches see how it

23
00:01:04,549 --> 00:01:08,360
really compares so not only looking at

24
00:01:07,040 --> 00:01:10,460
it from a security perspective but also

25
00:01:08,360 --> 00:01:12,140
how does it actually<font color="#E5E5E5"> perform how does it</font>

26
00:01:10,460 --> 00:01:15,679
scale how does it compare to the other

27
00:01:12,140 --> 00:01:19,820
approaches and then we'll do some

28
00:01:15,680 --> 00:01:22,969
conclusions at the end so what's the

29
00:01:19,820 --> 00:01:25,250
problem that we're trying<font color="#E5E5E5"> to solve in</font>

30
00:01:22,969 --> 00:01:26,689
pretty much every application that we

31
00:01:25,250 --> 00:01:29,750
have out there that has user specific

32
00:01:26,689 --> 00:01:31,639
data we have this sort of problem where

33
00:01:29,750 --> 00:01:34,100
<font color="#CCCCCC">we send some list of identifiers</font><font color="#E5E5E5"> to the</font>

34
00:01:31,640 --> 00:01:37,280
client<font color="#E5E5E5"> if your credit card numbers could</font>

35
00:01:34,100 --> 00:01:39,350
be some sort of primary keys for emails

36
00:01:37,280 --> 00:01:41,420
or instant messages whatever that<font color="#CCCCCC"> might</font>

37
00:01:39,350 --> 00:01:44,359
be some user specific data in an

38
00:01:41,420 --> 00:01:45,799
application<font color="#E5E5E5"> the client has to select an</font>

39
00:01:44,359 --> 00:01:47,658
identifier from the list<font color="#E5E5E5"> and send it</font>

40
00:01:45,799 --> 00:01:50,469
<font color="#CCCCCC">back to the server and then the server</font>

41
00:01:47,659 --> 00:01:54,409
returns more data based on that identify

42
00:01:50,469 --> 00:01:56,240
now what does<font color="#E5E5E5"> the server need to do well</font>

43
00:01:54,409 --> 00:01:59,240
we want<font color="#E5E5E5"> to make sure that users data</font>

44
00:01:56,240 --> 00:02:01,219
stays private relative to that user so

45
00:01:59,240 --> 00:02:02,839
we<font color="#E5E5E5"> don't want users to be able to send</font>

46
00:02:01,219 --> 00:02:05,270
identifiers that belong to other people

47
00:02:02,840 --> 00:02:07,340
without detection so I'm<font color="#E5E5E5"> sure you've all</font>

48
00:02:05,270 --> 00:02:08,929
heard of some of<font color="#E5E5E5"> the incidents in</font><font color="#CCCCCC"> the</font>

49
00:02:07,340 --> 00:02:10,490
news<font color="#E5E5E5"> over the past few years about</font>

50
00:02:08,929 --> 00:02:13,430
people being able<font color="#E5E5E5"> to view other people's</font>

51
00:02:10,490 --> 00:02:15,350
tax returns or you'd hope viewing each

52
00:02:13,430 --> 00:02:17,750
other's emails things like that so

53
00:02:15,350 --> 00:02:21,470
that's<font color="#E5E5E5"> the problem that we run into a</font>

54
00:02:17,750 --> 00:02:24,710
fair bit and that's what it often looks

55
00:02:21,470 --> 00:02:27,140
like so you've got some<font color="#CCCCCC"> sort of an</font>

56
00:02:24,710 --> 00:02:29,420
<font color="#E5E5E5">account credit card number bank account</font>

57
00:02:27,140 --> 00:02:30,630
whatever that might be or like I said

58
00:02:29,420 --> 00:02:32,339
<font color="#CCCCCC">earlier you know</font>

59
00:02:30,630 --> 00:02:35,010
<font color="#CCCCCC">elles or anything that's user-specific</font>

60
00:02:32,340 --> 00:02:37,560
the server sends a list of identifiers

61
00:02:35,010 --> 00:02:40,260
to<font color="#E5E5E5"> the client</font><font color="#CCCCCC"> the client picks one sends</font>

62
00:02:37,560 --> 00:02:41,850
it back<font color="#CCCCCC"> to the server now of course if</font>

63
00:02:40,260 --> 00:02:43,950
<font color="#E5E5E5">I'm a malicious user or if I see</font>

64
00:02:41,850 --> 00:02:45,120
something in<font color="#CCCCCC"> the URL what happens if I</font>

65
00:02:43,950 --> 00:02:48,630
<font color="#E5E5E5">increment or decrement one of those</font>

66
00:02:45,120 --> 00:02:51,570
numbers so that's<font color="#E5E5E5"> the problem we're</font>

67
00:02:48,630 --> 00:02:54,690
trying to solve now how common is this

68
00:02:51,570 --> 00:02:58,049
problem since we write an OS conference

69
00:02:54,690 --> 00:03:01,380
let's take<font color="#E5E5E5"> a look at the OWASP top 10 so</font>

70
00:02:58,050 --> 00:03:04,260
number<font color="#E5E5E5"> four on the list in 2007 was</font>

71
00:03:01,380 --> 00:03:06,030
insecure direct object references now

72
00:03:04,260 --> 00:03:08,340
what<font color="#CCCCCC"> exactly is insecure direct object</font>

73
00:03:06,030 --> 00:03:12,690
references<font color="#E5E5E5"> it's that you're essentially</font>

74
00:03:08,340 --> 00:03:14,520
exposing some sort<font color="#CCCCCC"> of a</font><font color="#E5E5E5"> reference to an</font>

75
00:03:12,690 --> 00:03:16,620
<font color="#E5E5E5">internal implementation object like a</font>

76
00:03:14,520 --> 00:03:18,840
file directory database record or so

77
00:03:16,620 --> 00:03:20,880
forth and if a user can change that and

78
00:03:18,840 --> 00:03:24,240
you don't have authorization controls

79
00:03:20,880 --> 00:03:27,920
users can access other users data so

80
00:03:24,240 --> 00:03:33,660
same sort of thing happened in 2010

81
00:03:27,920 --> 00:03:34,799
<font color="#CCCCCC">until</font><font color="#E5E5E5"> number four on the list in 2013 we</font>

82
00:03:33,660 --> 00:03:40,200
all got smarter and the problem

83
00:03:34,800 --> 00:03:43,050
disappeared or not still<font color="#E5E5E5"> number four on</font>

84
00:03:40,200 --> 00:03:45,690
the list<font color="#CCCCCC"> so we keep running into this</font>

85
00:03:43,050 --> 00:03:50,010
problem over and over again right so

86
00:03:45,690 --> 00:03:51,950
what do we do about<font color="#E5E5E5"> it first let's take</font>

87
00:03:50,010 --> 00:03:54,450
a look<font color="#E5E5E5"> at some of the relevant attacks</font>

88
00:03:51,950 --> 00:03:56,310
now when we're talking about insecure

89
00:03:54,450 --> 00:03:57,720
direct object references the main<font color="#CCCCCC"> thing</font>

90
00:03:56,310 --> 00:04:01,590
we're worried about is the thing at the

91
00:03:57,720 --> 00:04:03,840
<font color="#CCCCCC">bottom right there a user who is</font>

92
00:04:01,590 --> 00:04:06,150
<font color="#E5E5E5">potentially malicious is signed into the</font>

93
00:04:03,840 --> 00:04:09,209
application<font color="#CCCCCC"> and uses another user's</font>

94
00:04:06,150 --> 00:04:10,170
<font color="#E5E5E5">identifier from their own session that's</font>

95
00:04:09,209 --> 00:04:13,500
the main thing we're trying<font color="#E5E5E5"> to print</font>

96
00:04:10,170 --> 00:04:15,390
prevent now there's a bunch of other

97
00:04:13,500 --> 00:04:16,920
sort<font color="#E5E5E5"> of related attacks that are</font>

98
00:04:15,390 --> 00:04:18,570
interesting to think about when it<font color="#E5E5E5"> comes</font>

99
00:04:16,920 --> 00:04:22,020
to direct object direct object

100
00:04:18,570 --> 00:04:25,469
references so some of these identifiers

101
00:04:22,019 --> 00:04:27,090
might actually be sensitive so what if

102
00:04:25,470 --> 00:04:29,100
those identifiers get stolen<font color="#E5E5E5"> because</font>

103
00:04:27,090 --> 00:04:30,419
they're cached on the client but if

104
00:04:29,100 --> 00:04:33,000
they're stolen<font color="#CCCCCC"> viola cross-site</font>

105
00:04:30,420 --> 00:04:34,410
scripting attack think about things like

106
00:04:33,000 --> 00:04:40,760
credit card numbers do we<font color="#CCCCCC"> really</font><font color="#E5E5E5"> want</font>

107
00:04:34,410 --> 00:04:40,760
those things to be stolen probably not

108
00:04:41,580 --> 00:04:46,200
performing a cross-site request forgery

109
00:04:43,360 --> 00:04:50,380
attack using predictable identifiers so

110
00:04:46,200 --> 00:04:53,380
this isn't<font color="#CCCCCC"> really a sea surf problem per</font>

111
00:04:50,380 --> 00:04:54,880
se but if our direct object references

112
00:04:53,380 --> 00:04:57,159
happen to be predictable<font color="#E5E5E5"> then it makes</font>

113
00:04:54,880 --> 00:04:59,860
<font color="#E5E5E5">these surfer tax easier we don't want to</font>

114
00:04:57,160 --> 00:05:02,650
make<font color="#E5E5E5"> these server tax easier so that's</font>

115
00:04:59,860 --> 00:05:04,780
going to be sort of a secondary attack

116
00:05:02,650 --> 00:05:05,919
that will worry about<font color="#E5E5E5"> and see if the</font>

117
00:05:04,780 --> 00:05:11,020
various approaches that<font color="#E5E5E5"> we'll talk about</font>

118
00:05:05,920 --> 00:05:13,060
actually helped make<font color="#E5E5E5"> si sirve harder so</font>

119
00:05:11,020 --> 00:05:16,359
just a quick list of attackers and

120
00:05:13,060 --> 00:05:18,400
attack vectors just a summary of the

121
00:05:16,360 --> 00:05:20,110
previous slide now the attack vectors

122
00:05:18,400 --> 00:05:21,969
we're going to<font color="#E5E5E5"> look at with every single</font>

123
00:05:20,110 --> 00:05:27,250
solution to see how<font color="#E5E5E5"> well it actually</font>

124
00:05:21,970 --> 00:05:30,130
solves that problem so here<font color="#E5E5E5"> are the</font>

125
00:05:27,250 --> 00:05:31,450
common solutions to the problem I'm sure

126
00:05:30,130 --> 00:05:34,060
a lot<font color="#CCCCCC"> of you might have seen</font><font color="#E5E5E5"> these</font>

127
00:05:31,450 --> 00:05:37,990
already so we just exposed<font color="#E5E5E5"> the direct</font>

128
00:05:34,060 --> 00:05:39,250
object reference<font color="#E5E5E5"> so you know whether</font>

129
00:05:37,990 --> 00:05:40,990
it's a<font color="#E5E5E5"> credit card number whether it's a</font>

130
00:05:39,250 --> 00:05:43,270
primary key to a database object we just

131
00:05:40,990 --> 00:05:44,470
expose it but when we get it<font color="#E5E5E5"> back when</font>

132
00:05:43,270 --> 00:05:46,780
the client centered back we do an

133
00:05:44,470 --> 00:05:50,350
authorization check pretty

134
00:05:46,780 --> 00:05:53,020
<font color="#E5E5E5">straightforward now the problem with</font>

135
00:05:50,350 --> 00:05:55,300
<font color="#E5E5E5">that approach is well we're potentially</font>

136
00:05:53,020 --> 00:05:57,940
exposing sensitive identifiers we've

137
00:05:55,300 --> 00:06:00,070
seen applications where you know think

138
00:05:57,940 --> 00:06:02,710
of our corporate credit card program

139
00:06:00,070 --> 00:06:03,580
where you have a plan administrator do

140
00:06:02,710 --> 00:06:05,799
you really<font color="#E5E5E5"> want</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> plan administrator</font>

141
00:06:03,580 --> 00:06:10,060
to be able<font color="#E5E5E5"> to see every single person's</font>

142
00:06:05,800 --> 00:06:11,650
credit card number probably not so

143
00:06:10,060 --> 00:06:13,180
direct object references with

144
00:06:11,650 --> 00:06:15,390
authorization checks have some problems

145
00:06:13,180 --> 00:06:18,400
we'll look at them in detail in<font color="#E5E5E5"> a second</font>

146
00:06:15,390 --> 00:06:20,080
now one of the most common ways to<font color="#E5E5E5"> solve</font>

147
00:06:18,400 --> 00:06:22,179
this problem is through indirect object

148
00:06:20,080 --> 00:06:26,440
references or we don't<font color="#E5E5E5"> actually expose</font>

149
00:06:22,180 --> 00:06:27,880
the reference itself to the user we

150
00:06:26,440 --> 00:06:30,280
create some sort of a mapping in the

151
00:06:27,880 --> 00:06:32,200
user session and then we expose the

152
00:06:30,280 --> 00:06:34,390
indirect mapping to the user and we'll

153
00:06:32,200 --> 00:06:35,979
take<font color="#E5E5E5"> a look at how</font><font color="#CCCCCC"> that works the</font>

154
00:06:34,390 --> 00:06:37,479
solution<font color="#CCCCCC"> that I'm going</font><font color="#E5E5E5"> to propose today</font>

155
00:06:35,980 --> 00:06:39,730
is cryptographically protected

156
00:06:37,480 --> 00:06:41,260
references so<font color="#E5E5E5"> using cryptography to</font>

157
00:06:39,730 --> 00:06:42,670
actually protect these references so

158
00:06:41,260 --> 00:06:44,260
they cannot be<font color="#E5E5E5"> modified when they come</font>

159
00:06:42,670 --> 00:06:48,520
back<font color="#E5E5E5"> and we</font><font color="#CCCCCC"> can also protect their</font>

160
00:06:44,260 --> 00:06:51,420
confidentiality so let's go<font color="#CCCCCC"> over the</font>

161
00:06:48,520 --> 00:06:51,419
common solutions first

162
00:06:51,620 --> 00:06:57,449
so direct object references with

163
00:06:54,120 --> 00:06:59,699
authorization<font color="#E5E5E5"> jacks so let's take a look</font>

164
00:06:57,449 --> 00:07:01,139
at<font color="#CCCCCC"> what the client sees and what the</font>

165
00:06:59,699 --> 00:07:02,879
server-side code looks like for

166
00:07:01,139 --> 00:07:05,789
verifying one of these references<font color="#CCCCCC"> when</font>

167
00:07:02,879 --> 00:07:09,979
it comes back<font color="#E5E5E5"> assuming</font><font color="#CCCCCC"> that we're doing</font>

168
00:07:05,789 --> 00:07:12,748
things<font color="#E5E5E5"> properly so on the client side</font>

169
00:07:09,979 --> 00:07:14,849
whenever we have some sensitive data one

170
00:07:12,749 --> 00:07:16,139
of the<font color="#E5E5E5"> things we'll want to do as far</font><font color="#CCCCCC"> as</font>

171
00:07:14,849 --> 00:07:18,719
the things that are<font color="#E5E5E5"> displayed to the</font>

172
00:07:16,139 --> 00:07:20,520
user will want<font color="#E5E5E5"> to mask it that happens a</font>

173
00:07:18,719 --> 00:07:23,370
lot with credit card numbers bank

174
00:07:20,520 --> 00:07:26,698
account numbers and<font color="#E5E5E5"> so forth so what we</font>

175
00:07:23,370 --> 00:07:28,199
display is going to be masked but if you

176
00:07:26,699 --> 00:07:30,150
actually view the source at the web page

177
00:07:28,199 --> 00:07:31,560
you<font color="#CCCCCC"> have to expose the full direct</font>

178
00:07:30,150 --> 00:07:33,330
object reference because the server<font color="#E5E5E5"> has</font>

179
00:07:31,560 --> 00:07:37,379
to know which object you want to operate

180
00:07:33,330 --> 00:07:39,029
on so the client side code sees the full

181
00:07:37,379 --> 00:07:42,330
direct object reference no surprise

182
00:07:39,029 --> 00:07:43,620
<font color="#E5E5E5">there what is the server have to do if</font>

183
00:07:42,330 --> 00:07:47,938
it's<font color="#E5E5E5"> actually performing the</font>

184
00:07:43,620 --> 00:07:50,069
authorization check it has to figure out

185
00:07:47,939 --> 00:07:51,870
which user corresponds to the current

186
00:07:50,069 --> 00:07:55,379
session from which the request is being

187
00:07:51,870 --> 00:07:59,129
made it then has to grab the account ID

188
00:07:55,379 --> 00:08:00,749
that I'm trying<font color="#E5E5E5"> to access so the first</font>

189
00:07:59,129 --> 00:08:03,120
thing<font color="#CCCCCC"> is just from your session so it's</font>

190
00:08:00,749 --> 00:08:04,919
trusted the second<font color="#E5E5E5"> thing I'm getting is</font>

191
00:08:03,120 --> 00:08:08,009
not trusted it's coming from the<font color="#E5E5E5"> client</font>

192
00:08:04,919 --> 00:08:09,740
side then what do we do we check whether

193
00:08:08,009 --> 00:08:12,419
the user has<font color="#E5E5E5"> access to it or not and</font>

194
00:08:09,740 --> 00:08:14,550
<font color="#CCCCCC">we're a lot of</font><font color="#E5E5E5"> people make mistakes is</font>

195
00:08:12,419 --> 00:08:17,628
they forget<font color="#CCCCCC"> to check whether the user</font>

196
00:08:14,550 --> 00:08:19,649
has<font color="#E5E5E5"> access to that piece</font><font color="#CCCCCC"> of data or not</font>

197
00:08:17,629 --> 00:08:20,999
so<font color="#E5E5E5"> we have to do an explicit</font>

198
00:08:19,649 --> 00:08:22,560
authorization check and that's<font color="#E5E5E5"> really</font>

199
00:08:20,999 --> 00:08:23,759
important you<font color="#E5E5E5"> need to grab the user ID</font>

200
00:08:22,560 --> 00:08:25,529
out of the session and you need to

201
00:08:23,759 --> 00:08:27,689
explicitly check to see if that<font color="#E5E5E5"> user has</font>

202
00:08:25,529 --> 00:08:29,610
access to that object which gets kind of

203
00:08:27,689 --> 00:08:30,779
tedious across the large application

204
00:08:29,610 --> 00:08:33,060
every single time you're getting<font color="#CCCCCC"> an</font>

205
00:08:30,779 --> 00:08:36,409
identifier you have to verify explicitly

206
00:08:33,059 --> 00:08:40,159
whether the user has<font color="#E5E5E5"> access to it or not</font>

207
00:08:36,409 --> 00:08:45,480
now if you<font color="#E5E5E5"> look at</font><font color="#CCCCCC"> the attack vectors</font>

208
00:08:40,159 --> 00:08:47,519
well we are not directly<font color="#E5E5E5"> preventing</font>

209
00:08:45,480 --> 00:08:49,350
using another users identify her from

210
00:08:47,519 --> 00:08:50,880
your session you have to do an

211
00:08:49,350 --> 00:08:52,649
authorization check if you forget to<font color="#E5E5E5"> do</font>

212
00:08:50,880 --> 00:08:54,870
that<font color="#E5E5E5"> there</font><font color="#CCCCCC"> is no inherent protection</font>

213
00:08:52,649 --> 00:08:56,880
there once you pass the<font color="#CCCCCC"> identifier to</font>

214
00:08:54,870 --> 00:08:59,250
the client the<font color="#CCCCCC"> client sends it back</font>

215
00:08:56,880 --> 00:09:00,779
<font color="#CCCCCC">there's</font><font color="#E5E5E5"> no way for you to check except</font>

216
00:08:59,250 --> 00:09:02,699
with<font color="#CCCCCC"> the user ID whether the user has</font>

217
00:09:00,779 --> 00:09:04,019
<font color="#E5E5E5">access to the</font><font color="#CCCCCC"> object</font><font color="#E5E5E5"> or not with some of</font>

218
00:09:02,699 --> 00:09:05,630
the other approaches we will have a way

219
00:09:04,019 --> 00:09:07,830
to check and we'll see

220
00:09:05,630 --> 00:09:09,810
reading sensitive identifiers cash on

221
00:09:07,830 --> 00:09:12,180
the client or by exploiting cross-site

222
00:09:09,810 --> 00:09:13,650
scripting very<font color="#CCCCCC"> straightforward you can</font>

223
00:09:12,180 --> 00:09:17,040
read those you're exposing the sensitive

224
00:09:13,650 --> 00:09:19,310
data and see surf attacks really depend

225
00:09:17,040 --> 00:09:21,390
on the predictability of the<font color="#CCCCCC"> identifier</font>

226
00:09:19,310 --> 00:09:22,920
certain identifiers happen to be

227
00:09:21,390 --> 00:09:24,990
predictable<font color="#CCCCCC"> they're sequential or</font>

228
00:09:22,920 --> 00:09:26,640
something relatively predictable in

229
00:09:24,990 --> 00:09:30,150
which case you're<font color="#CCCCCC"> not really stopping</font>

230
00:09:26,640 --> 00:09:32,250
see surf attacks not using your object

231
00:09:30,150 --> 00:09:34,410
references anyways of<font color="#E5E5E5"> course you might</font>

232
00:09:32,250 --> 00:09:36,120
have<font color="#E5E5E5"> see serve tokens and so forth but</font>

233
00:09:34,410 --> 00:09:41,069
the references themselves<font color="#E5E5E5"> don't help</font>

234
00:09:36,120 --> 00:09:43,440
protect you now this<font color="#CCCCCC"> is one other</font>

235
00:09:41,070 --> 00:09:45,870
solution to the problem one<font color="#E5E5E5"> that doesn't</font>

236
00:09:43,440 --> 00:09:47,700
require explicit authorization checks so

237
00:09:45,870 --> 00:09:50,130
we have sequential indirect object

238
00:09:47,700 --> 00:09:53,070
references in this case what is<font color="#CCCCCC"> declined</font>

239
00:09:50,130 --> 00:09:54,990
see you probably<font color="#E5E5E5"> still need to display a</font>

240
00:09:53,070 --> 00:09:57,510
mast account number or some sort of

241
00:09:54,990 --> 00:10:00,060
identifier that's master hidden to the

242
00:09:57,510 --> 00:10:01,470
user may be an account nickname but then

243
00:10:00,060 --> 00:10:03,270
the actual identifiers that you're

244
00:10:01,470 --> 00:10:06,390
sending back to the server there's just

245
00:10:03,270 --> 00:10:08,069
sequential numbers and you<font color="#CCCCCC"> could</font><font color="#E5E5E5"> imagine</font>

246
00:10:06,390 --> 00:10:10,800
<font color="#E5E5E5">that</font><font color="#CCCCCC"> that's just</font><font color="#E5E5E5"> going to be a table in</font>

247
00:10:08,070 --> 00:10:14,010
<font color="#CCCCCC">your session so when a user logs in you</font>

248
00:10:10,800 --> 00:10:16,859
just<font color="#E5E5E5"> create an array and you've got five</font>

249
00:10:14,010 --> 00:10:18,450
items in there now what does the client

250
00:10:16,860 --> 00:10:22,650
do it passes back one of<font color="#E5E5E5"> the five</font>

251
00:10:18,450 --> 00:10:27,000
numbers you grab the account number from

252
00:10:22,650 --> 00:10:29,370
the request you get the array from the

253
00:10:27,000 --> 00:10:31,710
user session and you figure out<font color="#E5E5E5"> which</font>

254
00:10:29,370 --> 00:10:34,500
account number maps to one of those<font color="#E5E5E5"> five</font>

255
00:10:31,710 --> 00:10:36,810
numbers note<font color="#E5E5E5"> that the authorization</font>

256
00:10:34,500 --> 00:10:38,190
check is now being done implicitly we

257
00:10:36,810 --> 00:10:40,739
<font color="#CCCCCC">don't</font><font color="#E5E5E5"> need to grab the user ID and</font>

258
00:10:38,190 --> 00:10:43,140
verify that the user has access to that

259
00:10:40,740 --> 00:10:45,450
object right<font color="#CCCCCC"> straight forward if you try</font>

260
00:10:43,140 --> 00:10:47,939
<font color="#E5E5E5">to pass in negative one</font><font color="#CCCCCC"> or five that</font>

261
00:10:45,450 --> 00:10:50,370
object<font color="#E5E5E5"> just doesn't exist no need to do</font>

262
00:10:47,940 --> 00:10:52,500
an authorization check so that's a<font color="#E5E5E5"> good</font>

263
00:10:50,370 --> 00:10:55,830
thing makes things easier when we're

264
00:10:52,500 --> 00:10:57,470
coding now it mitigates three of the

265
00:10:55,830 --> 00:10:59,850
four<font color="#E5E5E5"> things that were worried about you</font>

266
00:10:57,470 --> 00:11:03,420
<font color="#CCCCCC">can no longer use another users</font>

267
00:10:59,850 --> 00:11:05,460
<font color="#CCCCCC">identifier from another session because</font>

268
00:11:03,420 --> 00:11:07,349
well you're checking against something

269
00:11:05,460 --> 00:11:09,690
that's built in the individual user

270
00:11:07,350 --> 00:11:10,920
session you can't read sensitive

271
00:11:09,690 --> 00:11:13,710
identifiers because they are no longer

272
00:11:10,920 --> 00:11:15,300
sent to the client you can<font color="#E5E5E5"> still use</font><font color="#CCCCCC"> see</font>

273
00:11:13,710 --> 00:11:16,300
surf to perform sensitive transactions

274
00:11:15,300 --> 00:11:18,258
on those accounts

275
00:11:16,300 --> 00:11:23,089
unless of course you have a seat sir of

276
00:11:18,259 --> 00:11:26,240
token another approach<font color="#CCCCCC"> is random</font>

277
00:11:23,089 --> 00:11:27,829
indirect references now this can be

278
00:11:26,240 --> 00:11:32,569
random in many different ways i just

279
00:11:27,829 --> 00:11:35,989
used version 4<font color="#CCCCCC"> u.u IDs it can be any</font>

280
00:11:32,569 --> 00:11:39,769
other form of random data but instead<font color="#CCCCCC"> of</font>

281
00:11:35,990 --> 00:11:43,579
just array 0 1 2 3<font color="#CCCCCC"> 4 I have just random</font>

282
00:11:39,769 --> 00:11:45,319
identifiers and the hash table mapping

283
00:11:43,579 --> 00:11:47,809
these to the actual account numbers is

284
00:11:45,319 --> 00:11:50,110
stored in<font color="#E5E5E5"> my session so the verification</font>

285
00:11:47,809 --> 00:11:53,180
is very similar to with sequential

286
00:11:50,110 --> 00:11:55,579
identifiers you're grabbing whatever the

287
00:11:53,180 --> 00:11:58,128
client sends you look it up inside your

288
00:11:55,579 --> 00:11:59,029
session object if you find a match then

289
00:11:58,129 --> 00:12:03,410
you know the account number for

290
00:11:59,029 --> 00:12:06,559
<font color="#E5E5E5">responding</font><font color="#CCCCCC"> to it great mitigates</font>

291
00:12:03,410 --> 00:12:08,569
everything right you<font color="#CCCCCC"> can no longer use</font>

292
00:12:06,559 --> 00:12:10,749
another users identify her from your

293
00:12:08,569 --> 00:12:13,279
session can't read sensitive identifiers

294
00:12:10,749 --> 00:12:14,720
use plus side you<font color="#E5E5E5"> can't use clustered</font>

295
00:12:13,279 --> 00:12:16,009
request forgery to perform sensitive

296
00:12:14,720 --> 00:12:21,069
transactions because now these

297
00:12:16,009 --> 00:12:23,509
identifiers are highly unpredictable so

298
00:12:21,069 --> 00:12:27,949
aren't we just done why do we need

299
00:12:23,509 --> 00:12:31,329
another solution so what's the problem

300
00:12:27,949 --> 00:12:33,829
<font color="#E5E5E5">with random and direct object references</font>

301
00:12:31,329 --> 00:12:36,229
well there's a couple of big problems

302
00:12:33,829 --> 00:12:39,500
one there's a large memory footprint

303
00:12:36,230 --> 00:12:40,850
sometimes not for all applications but

304
00:12:39,500 --> 00:12:43,639
for applications<font color="#E5E5E5"> that are exposing a</font>

305
00:12:40,850 --> 00:12:46,040
large number of references to<font color="#CCCCCC"> the user</font>

306
00:12:43,639 --> 00:12:49,819
<font color="#CCCCCC">you have to build</font><font color="#E5E5E5"> these giant tables in</font>

307
00:12:46,040 --> 00:12:51,319
memory and think about if you wanted to

308
00:12:49,819 --> 00:12:53,180
make your application server stateless

309
00:12:51,319 --> 00:12:55,069
for scalability how much data do you

310
00:12:53,180 --> 00:12:57,019
have to share between the app servers

311
00:12:55,069 --> 00:12:58,878
you have to share these giant tables

312
00:12:57,019 --> 00:13:00,649
you're building across the app servers

313
00:12:58,879 --> 00:13:02,870
you have to write<font color="#CCCCCC"> all that data to some</font>

314
00:13:00,649 --> 00:13:06,350
common store that's going to slow things

315
00:13:02,870 --> 00:13:08,000
down a lot it's not<font color="#E5E5E5"> very scalable you</font>

316
00:13:06,350 --> 00:13:09,110
could all you could<font color="#E5E5E5"> of</font><font color="#CCCCCC"> course use sticky</font>

317
00:13:08,000 --> 00:13:11,689
sessions and then you<font color="#E5E5E5"> don't have to</font>

318
00:13:09,110 --> 00:13:15,110
worry about<font color="#CCCCCC"> that but if you did</font><font color="#E5E5E5"> want to</font>

319
00:13:11,689 --> 00:13:19,670
<font color="#E5E5E5">make our app server stateless this would</font>

320
00:13:15,110 --> 00:13:22,189
<font color="#E5E5E5">be difficult to do so</font><font color="#CCCCCC"> how do</font><font color="#E5E5E5"> we solve</font>

321
00:13:19,670 --> 00:13:26,300
that<font color="#E5E5E5"> problem let's take</font><font color="#CCCCCC"> a look at a</font>

322
00:13:22,189 --> 00:13:28,610
alternate approach what if<font color="#E5E5E5"> we were to</font>

323
00:13:26,300 --> 00:13:30,140
somehow cryptographically bind direct

324
00:13:28,610 --> 00:13:32,740
references to sessions

325
00:13:30,140 --> 00:13:35,449
a couple of examples are shown there

326
00:13:32,740 --> 00:13:37,340
these examples protect both the

327
00:13:35,450 --> 00:13:39,440
integrity and the confidentiality of the

328
00:13:37,340 --> 00:13:40,670
references however our options are

329
00:13:39,440 --> 00:13:42,260
integrity protection only

330
00:13:40,670 --> 00:13:44,660
confidentiality only or both

331
00:13:42,260 --> 00:13:45,740
confidentiality and integrity for

332
00:13:44,660 --> 00:13:47,209
<font color="#E5E5E5">everything we're going</font><font color="#CCCCCC"> to talk about</font>

333
00:13:45,740 --> 00:13:48,650
we're going<font color="#E5E5E5"> to look at the left take a</font>

334
00:13:47,210 --> 00:13:52,580
look<font color="#E5E5E5"> at the last one the integrity</font><font color="#CCCCCC"> and</font>

335
00:13:48,650 --> 00:13:53,959
confidentiality protection so I hope

336
00:13:52,580 --> 00:13:55,550
that<font color="#E5E5E5"> makes sense there's many different</font>

337
00:13:53,960 --> 00:13:57,830
ways in<font color="#CCCCCC"> which you could use prepare</font>

338
00:13:55,550 --> 00:14:00,290
primitives to do this the two things

339
00:13:57,830 --> 00:14:02,330
<font color="#E5E5E5">about lined or AES in GCM mode which</font>

340
00:14:00,290 --> 00:14:03,589
protects both the confidentiality and

341
00:14:02,330 --> 00:14:05,870
the integrity<font color="#CCCCCC"> of data it's an</font>

342
00:14:03,590 --> 00:14:09,940
authenticated encryption mode or I<font color="#E5E5E5"> could</font>

343
00:14:05,870 --> 00:14:12,380
just use a standard traditional

344
00:14:09,940 --> 00:14:16,580
encryption mode and combine it with a H

345
00:14:12,380 --> 00:14:18,110
Mac and I essentially<font color="#E5E5E5"> have a session key</font>

346
00:14:16,580 --> 00:14:20,030
that I generate for each user when the

347
00:14:18,110 --> 00:14:24,860
user logs in and then I use that session

348
00:14:20,030 --> 00:14:26,810
key for<font color="#E5E5E5"> these crypto operations this is</font>

349
00:14:24,860 --> 00:14:29,150
what the client sees and this is what

350
00:14:26,810 --> 00:14:33,380
the server has<font color="#E5E5E5"> to do</font><font color="#CCCCCC"> referenced has</font>

351
00:14:29,150 --> 00:14:35,329
become pretty big now but it's sort of

352
00:14:33,380 --> 00:14:37,430
<font color="#E5E5E5">similar to the random and direct</font>

353
00:14:35,330 --> 00:14:40,790
references right what you're seeing

354
00:14:37,430 --> 00:14:42,979
looks pretty random what does the server

355
00:14:40,790 --> 00:14:45,050
have to do it grabs the account number

356
00:14:42,980 --> 00:14:48,380
from their<font color="#CCCCCC"> request grabs a session key</font>

357
00:14:45,050 --> 00:14:51,079
from your session and then just verifies

358
00:14:48,380 --> 00:14:53,240
<font color="#CCCCCC">and decrypts there's no need to do an</font>

359
00:14:51,080 --> 00:14:55,010
explicit authorization check if your

360
00:14:53,240 --> 00:14:56,690
crypto primitive is protecting the

361
00:14:55,010 --> 00:14:58,970
confidentiality and the integrity more

362
00:14:56,690 --> 00:15:04,250
importantly the integrity you don't need

363
00:14:58,970 --> 00:15:08,030
<font color="#E5E5E5">to do an austere just great also</font><font color="#CCCCCC"> solves</font>

364
00:15:04,250 --> 00:15:10,760
all of these problems so you can't use

365
00:15:08,030 --> 00:15:12,709
<font color="#E5E5E5">another users identify from another</font>

366
00:15:10,760 --> 00:15:15,020
session you<font color="#CCCCCC"> can read the sensitive</font>

367
00:15:12,710 --> 00:15:17,240
identifiers either by a cross-site

368
00:15:15,020 --> 00:15:19,400
scripting or through client<font color="#E5E5E5"> caching and</font>

369
00:15:17,240 --> 00:15:20,840
you can't use<font color="#E5E5E5"> these serve to perform</font>

370
00:15:19,400 --> 00:15:25,010
sensitive transactions involving these

371
00:15:20,840 --> 00:15:27,230
identifiers so great another possible

372
00:15:25,010 --> 00:15:29,420
solution however<font color="#E5E5E5"> is probably more</font>

373
00:15:27,230 --> 00:15:30,950
scalable now because now the<font color="#E5E5E5"> only state</font>

374
00:15:29,420 --> 00:15:33,410
we need to share between our app servers

375
00:15:30,950 --> 00:15:36,400
is that one session key we don't<font color="#E5E5E5"> need to</font>

376
00:15:33,410 --> 00:15:36,400
share these giant tables

377
00:15:37,790 --> 00:15:41,740
so what about performance how does this

378
00:15:39,770 --> 00:15:44,360
really compare with the other approaches

379
00:15:41,740 --> 00:15:46,130
or all of these crypto<font color="#CCCCCC"> operations</font><font color="#E5E5E5"> going</font>

380
00:15:44,360 --> 00:15:48,620
to slow us down significantly is it

381
00:15:46,130 --> 00:15:55,970
<font color="#E5E5E5">really a viable approach so let's take a</font>

382
00:15:48,620 --> 00:15:59,740
look so here's the setup<font color="#E5E5E5"> I used for</font>

383
00:15:55,970 --> 00:16:02,570
benchmarks why did I use this<font color="#CCCCCC"> setup</font><font color="#E5E5E5"> I</font>

384
00:15:59,740 --> 00:16:07,060
don't know I just felt<font color="#E5E5E5"> like it I'm for</font>

385
00:16:02,570 --> 00:16:10,310
<font color="#E5E5E5">the most part code in Java so is Java 17</font>

386
00:16:07,060 --> 00:16:14,630
for the crypto operations i use the

387
00:16:10,310 --> 00:16:16,250
bouncy castle 1.49 library for direct

388
00:16:14,630 --> 00:16:18,800
object references i implemented two

389
00:16:16,250 --> 00:16:20,840
different versions one without caching

390
00:16:18,800 --> 00:16:23,089
so every single time you want<font color="#CCCCCC"> to verify</font>

391
00:16:20,840 --> 00:16:26,770
a reference to do an authorization check

392
00:16:23,090 --> 00:16:29,330
you have to go back to<font color="#CCCCCC"> the database for</font>

393
00:16:26,770 --> 00:16:31,250
another approach i implemented direct

394
00:16:29,330 --> 00:16:33,190
object references with caching so now my

395
00:16:31,250 --> 00:16:35,780
authorization checks happen a lot faster

396
00:16:33,190 --> 00:16:40,940
but<font color="#E5E5E5"> I need more memory on the app</font>

397
00:16:35,780 --> 00:16:43,100
servers sequential and random indirect

398
00:16:40,940 --> 00:16:44,570
object<font color="#E5E5E5"> preferences the only ones that</font>

399
00:16:43,100 --> 00:16:47,390
are implemented were where<font color="#E5E5E5"> they're</font>

400
00:16:44,570 --> 00:16:49,010
<font color="#E5E5E5">stored in memory</font><font color="#CCCCCC"> so of</font><font color="#E5E5E5"> course you could</font>

401
00:16:47,390 --> 00:16:51,350
persist these things in the database to

402
00:16:49,010 --> 00:16:53,360
make your app servers stateless however

403
00:16:51,350 --> 00:16:55,370
I did<font color="#CCCCCC"> not go down that approach but you</font>

404
00:16:53,360 --> 00:16:57,650
could imagine<font color="#E5E5E5"> as far as some of the</font>

405
00:16:55,370 --> 00:16:58,850
benchmarks how they<font color="#E5E5E5"> would turn out I'll</font>

406
00:16:57,650 --> 00:17:03,319
talk about<font color="#CCCCCC"> those</font><font color="#E5E5E5"> when i get to the</font>

407
00:16:58,850 --> 00:17:05,089
individual ones<font color="#E5E5E5"> i used a local sequel</font>

408
00:17:03,320 --> 00:17:07,760
light database<font color="#CCCCCC"> i know it's not a</font>

409
00:17:05,089 --> 00:17:08,869
necessarily<font color="#E5E5E5"> realistic set up but it's</font>

410
00:17:07,760 --> 00:17:12,650
just what i<font color="#E5E5E5"> could get my hands on</font>

411
00:17:08,869 --> 00:17:14,839
quickly but created 10,000 users with<font color="#CCCCCC"> 10</font>

412
00:17:12,650 --> 00:17:17,540
accounts each and the benchmarking

413
00:17:14,839 --> 00:17:21,139
technique I used was to load the hundred

414
00:17:17,540 --> 00:17:24,500
thousand records but all of<font color="#CCCCCC"> them see how</font>

415
00:17:21,140 --> 00:17:26,150
<font color="#E5E5E5">much time it takes to build the list</font>

416
00:17:24,500 --> 00:17:28,580
that<font color="#E5E5E5"> I'm going</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> send to the client for</font>

417
00:17:26,150 --> 00:17:29,750
each one<font color="#CCCCCC"> and then verify just five</font>

418
00:17:28,580 --> 00:17:31,580
<font color="#CCCCCC">thousand of the references because</font>

419
00:17:29,750 --> 00:17:32,960
verification was just taking too long I

420
00:17:31,580 --> 00:17:35,300
didn't want<font color="#CCCCCC"> to verify every single one</font>

421
00:17:32,960 --> 00:17:37,550
and<font color="#E5E5E5"> then I just divided by the number of</font>

422
00:17:35,300 --> 00:17:41,090
references as I was verifying to get my

423
00:17:37,550 --> 00:17:44,690
numbers so let's<font color="#E5E5E5"> take a look at the</font>

424
00:17:41,090 --> 00:17:46,070
actual benchmark results now this<font color="#E5E5E5"> is</font><font color="#CCCCCC"> the</font>

425
00:17:44,690 --> 00:17:48,590
only graph where this is the case but

426
00:17:46,070 --> 00:17:51,020
note that the x-axis does not actually

427
00:17:48,590 --> 00:17:51,459
start at zero so the variation is

428
00:17:51,020 --> 00:17:53,350
actually

429
00:17:51,460 --> 00:17:56,320
lot smaller than what it looks on<font color="#E5E5E5"> the</font>

430
00:17:53,350 --> 00:17:59,020
screen<font color="#E5E5E5"> so this</font><font color="#CCCCCC"> is</font><font color="#E5E5E5"> the time required to</font>

431
00:17:56,320 --> 00:18:02,950
populate the initial list so when the

432
00:17:59,020 --> 00:18:05,559
server is grabbing all of the references

433
00:18:02,950 --> 00:18:07,179
that a client should have<font color="#E5E5E5"> access to it</font>

434
00:18:05,559 --> 00:18:10,870
generates that list sends it to the

435
00:18:07,179 --> 00:18:12,429
client how long does that take well of

436
00:18:10,870 --> 00:18:15,959
course<font color="#CCCCCC"> the fastest thing to do is just</font>

437
00:18:12,429 --> 00:18:18,100
grab that list<font color="#E5E5E5"> and send it</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> the client</font>

438
00:18:15,960 --> 00:18:20,620
you don't want you you're not doing much

439
00:18:18,100 --> 00:18:22,899
processing that's<font color="#E5E5E5"> going to be but only</font>

440
00:18:20,620 --> 00:18:24,668
the fastest approach if you're caching

441
00:18:22,899 --> 00:18:27,239
things well the whole caching logic is

442
00:18:24,669 --> 00:18:29,529
going to slow things down a little bit

443
00:18:27,240 --> 00:18:33,039
indirect references sequential don't

444
00:18:29,529 --> 00:18:36,399
really take much time indirect reference

445
00:18:33,039 --> 00:18:37,840
is that<font color="#CCCCCC"> our random take a little bit of</font>

446
00:18:36,399 --> 00:18:39,969
<font color="#CCCCCC">time to generate those random numbers</font>

447
00:18:37,840 --> 00:18:42,549
and the cryptographic references take a

448
00:18:39,970 --> 00:18:44,620
little bit<font color="#E5E5E5"> more time it's really</font><font color="#CCCCCC"> only an</font>

449
00:18:42,549 --> 00:18:46,929
extra three percent or so of overhead

450
00:18:44,620 --> 00:18:48,250
it's<font color="#E5E5E5"> not a huge amount but you do need</font>

451
00:18:46,929 --> 00:18:54,490
to<font color="#E5E5E5"> do those crypto operations to</font>

452
00:18:48,250 --> 00:18:56,380
generate these lists time to verify

453
00:18:54,490 --> 00:18:58,390
these references so now when the client

454
00:18:56,380 --> 00:19:00,039
sends the reference back how long does

455
00:18:58,390 --> 00:19:02,590
it take to actually check to see if the

456
00:19:00,039 --> 00:19:04,120
<font color="#CCCCCC">user should have</font><font color="#E5E5E5"> access to it if we</font>

457
00:19:02,590 --> 00:19:05,799
don't<font color="#E5E5E5"> have any caching and we have to go</font>

458
00:19:04,120 --> 00:19:09,100
<font color="#E5E5E5">back to the database for every single</font>

459
00:19:05,799 --> 00:19:13,299
access control check it's a pretty big

460
00:19:09,100 --> 00:19:16,600
hit now direct references with caching

461
00:19:13,299 --> 00:19:17,889
it's pretty quick and direct references

462
00:19:16,600 --> 00:19:19,990
to quench alone random they're

463
00:19:17,890 --> 00:19:22,539
relatively quick because these ones are

464
00:19:19,990 --> 00:19:24,220
in memory implementations if there were

465
00:19:22,539 --> 00:19:25,419
database based implementations to make

466
00:19:24,220 --> 00:19:26,919
our app server stateless you could

467
00:19:25,419 --> 00:19:29,850
imagine that time<font color="#E5E5E5"> would be very similar</font>

468
00:19:26,919 --> 00:19:32,260
<font color="#E5E5E5">to direct references without caching and</font>

469
00:19:29,850 --> 00:19:34,230
finally cryptographic references the

470
00:19:32,260 --> 00:19:38,500
verification time does go up a fair bit

471
00:19:34,230 --> 00:19:40,270
now one thing to<font color="#CCCCCC"> remember is that I am</font>

472
00:19:38,500 --> 00:19:43,149
actually using a local sequel<font color="#CCCCCC"> light</font>

473
00:19:40,270 --> 00:19:44,799
database here for a real<font color="#CCCCCC"> scenario where</font>

474
00:19:43,149 --> 00:19:47,139
<font color="#CCCCCC">I have</font><font color="#E5E5E5"> to go out over the network to</font>

475
00:19:44,799 --> 00:19:49,000
connect to a real database that number

476
00:19:47,140 --> 00:19:50,890
is probably<font color="#E5E5E5"> going to go up so the</font>

477
00:19:49,000 --> 00:19:52,000
difference<font color="#CCCCCC"> between direct references</font>

478
00:19:50,890 --> 00:19:55,320
with no caching and cryptographic

479
00:19:52,000 --> 00:19:55,320
references may not be that much

480
00:19:57,829 --> 00:20:06,799
memory usage well direct references with

481
00:20:04,649 --> 00:20:09,389
no caching you don't need much memory

482
00:20:06,799 --> 00:20:12,539
right I'm not cashing any of this stuff

483
00:20:09,389 --> 00:20:15,570
so that's relatively straightforward

484
00:20:12,539 --> 00:20:17,369
when I do start cashing things with

485
00:20:15,570 --> 00:20:19,109
direct references or with indirect

486
00:20:17,369 --> 00:20:22,109
sequential references the memory usage

487
00:20:19,109 --> 00:20:24,958
goes up goes up quite a bit when these

488
00:20:22,109 --> 00:20:27,779
references become random because well

489
00:20:24,959 --> 00:20:30,839
you need at least 120 bit 28 bits of

490
00:20:27,779 --> 00:20:31,979
randomness for every single<font color="#E5E5E5"> reference so</font>

491
00:20:30,839 --> 00:20:33,389
depending<font color="#CCCCCC"> on how many of these you have</font>

492
00:20:31,979 --> 00:20:36,269
<font color="#E5E5E5">your memory usage is going to go up</font>

493
00:20:33,389 --> 00:20:38,158
quite a bit and remember<font color="#E5E5E5"> all of that</font>

494
00:20:36,269 --> 00:20:39,479
data has<font color="#CCCCCC"> to be shared amongst all your</font>

495
00:20:38,159 --> 00:20:43,079
app servers if you want to make them

496
00:20:39,479 --> 00:20:44,639
stateless cryptographic references you

497
00:20:43,079 --> 00:20:48,678
don't<font color="#E5E5E5"> need a whole lot you're just</font>

498
00:20:44,639 --> 00:20:50,968
capturing a 128-bit<font color="#E5E5E5"> key in memory for a</font>

499
00:20:48,679 --> 00:20:56,809
for every<font color="#E5E5E5"> single session not for every</font>

500
00:20:50,969 --> 00:20:59,579
single<font color="#E5E5E5"> reference the identify our size</font>

501
00:20:56,809 --> 00:21:00,989
pretty<font color="#E5E5E5"> straightforward so how big are</font>

502
00:20:59,579 --> 00:21:02,879
the identifiers<font color="#E5E5E5"> I'm sending to the</font>

503
00:21:00,989 --> 00:21:06,059
client you<font color="#E5E5E5"> probably saw those on the</font>

504
00:21:02,879 --> 00:21:07,408
earlier slides straightforward direct

505
00:21:06,059 --> 00:21:09,629
references with no caching or with

506
00:21:07,409 --> 00:21:11,549
caching is the same size these are just

507
00:21:09,629 --> 00:21:13,529
<font color="#E5E5E5">identifier sizes that I chose these were</font>

508
00:21:11,549 --> 00:21:16,168
<font color="#E5E5E5">just random longs that is generated in</font>

509
00:21:13,529 --> 00:21:17,849
<font color="#E5E5E5">Java and direct references that are</font>

510
00:21:16,169 --> 00:21:19,979
sequential they're going<font color="#E5E5E5"> to be pretty</font>

511
00:21:17,849 --> 00:21:23,489
small especially if you're just<font color="#E5E5E5"> indexing</font>

512
00:21:19,979 --> 00:21:24,989
from<font color="#CCCCCC"> 0 random</font><font color="#E5E5E5"> indirect references the</font>

513
00:21:23,489 --> 00:21:29,820
identifiers size goes up cryptographic

514
00:21:24,989 --> 00:21:31,889
references it goes up a fair bit but now

515
00:21:29,820 --> 00:21:34,200
remember the size of the references is

516
00:21:31,889 --> 00:21:35,758
bigger but all of<font color="#E5E5E5"> these references don't</font>

517
00:21:34,200 --> 00:21:37,859
need to be shared amongst all the app

518
00:21:35,759 --> 00:21:39,809
servers that I might have but with

519
00:21:37,859 --> 00:21:47,418
indirect random references they do have

520
00:21:39,809 --> 00:21:47,418
<font color="#CCCCCC">to be shared so</font>

521
00:21:48,480 --> 00:21:54,730
here's a summary table of everything

522
00:21:51,310 --> 00:21:57,149
that we talked about<font color="#E5E5E5"> as far</font><font color="#CCCCCC"> as the</font>

523
00:21:54,730 --> 00:21:59,590
attacks<font color="#E5E5E5"> that we're concerned about</font>

524
00:21:57,150 --> 00:22:02,230
there's<font color="#E5E5E5"> only two solutions that mitigate</font>

525
00:21:59,590 --> 00:22:04,270
all of them there's the indirect

526
00:22:02,230 --> 00:22:06,040
references that are random<font color="#E5E5E5"> and there's a</font>

527
00:22:04,270 --> 00:22:10,540
cryptographic references they mitigate

528
00:22:06,040 --> 00:22:12,370
off the attacks in our threat model the

529
00:22:10,540 --> 00:22:15,100
time taken<font color="#CCCCCC"> to verify references is</font>

530
00:22:12,370 --> 00:22:16,840
pretty low for random references if they

531
00:22:15,100 --> 00:22:18,370
<font color="#E5E5E5">are cached in memory if they're written</font>

532
00:22:16,840 --> 00:22:21,189
to a database then it's not quick

533
00:22:18,370 --> 00:22:24,790
anymore for cryptographic references yes

534
00:22:21,190 --> 00:22:27,150
the time does go up memory usage is<font color="#E5E5E5"> high</font>

535
00:22:24,790 --> 00:22:29,170
for indirect random references and

536
00:22:27,150 --> 00:22:30,340
<font color="#E5E5E5">remember all that state needs to be</font>

537
00:22:29,170 --> 00:22:32,590
<font color="#E5E5E5">shared amongst multiple servers</font>

538
00:22:30,340 --> 00:22:35,290
potentially cryptographic references

539
00:22:32,590 --> 00:22:36,810
it's low memory usage very little

540
00:22:35,290 --> 00:22:39,639
<font color="#CCCCCC">additional data needs to be stored</font>

541
00:22:36,810 --> 00:22:41,500
<font color="#CCCCCC">identifier size medium for indirect</font>

542
00:22:39,640 --> 00:22:48,150
random references and pretty large for

543
00:22:41,500 --> 00:22:52,180
cryptographic references so relatively

544
00:22:48,150 --> 00:22:54,640
<font color="#E5E5E5">straightforward so what are the</font>

545
00:22:52,180 --> 00:22:56,110
conclusions well there's only two

546
00:22:54,640 --> 00:22:58,360
approaches that solve all of the attacks

547
00:22:56,110 --> 00:23:00,090
we talked about right so those<font color="#CCCCCC"> are the</font>

548
00:22:58,360 --> 00:23:02,530
last two approaches<font color="#E5E5E5"> we talked about</font>

549
00:23:00,090 --> 00:23:04,449
random indirect references do require

550
00:23:02,530 --> 00:23:06,490
more memory and all of that memory needs

551
00:23:04,450 --> 00:23:09,550
<font color="#E5E5E5">to be shared amongst app servers for</font>

552
00:23:06,490 --> 00:23:11,020
stateless operation which can of course

553
00:23:09,550 --> 00:23:13,600
cause performance<font color="#E5E5E5"> issues if you're</font>

554
00:23:11,020 --> 00:23:16,510
writing all<font color="#CCCCCC"> of your indirect references</font>

555
00:23:13,600 --> 00:23:18,730
you're generating to the database how

556
00:23:16,510 --> 00:23:21,180
much is that how much performance

557
00:23:18,730 --> 00:23:23,230
<font color="#E5E5E5">problems is that going to cause</font>

558
00:23:21,180 --> 00:23:24,970
cryptographically protected references

559
00:23:23,230 --> 00:23:27,420
they do require more computation time

560
00:23:24,970 --> 00:23:29,500
more bandwidth<font color="#E5E5E5"> on the front end however</font>

561
00:23:27,420 --> 00:23:30,850
due to the lower memory sharing

562
00:23:29,500 --> 00:23:33,910
requirements for stateless

563
00:23:30,850 --> 00:23:34,929
implementations they do scale better you

564
00:23:33,910 --> 00:23:36,640
don't need<font color="#E5E5E5"> to share as much memory</font>

565
00:23:34,930 --> 00:23:41,710
between your app server instances just

566
00:23:36,640 --> 00:23:43,630
<font color="#CCCCCC">100 128 bits or so however note that it</font>

567
00:23:41,710 --> 00:23:44,800
is or it might<font color="#CCCCCC"> be easier to make</font>

568
00:23:43,630 --> 00:23:47,220
implementation mistakes with the

569
00:23:44,800 --> 00:23:50,230
cryptographic way protected references

570
00:23:47,220 --> 00:23:51,910
people make cryptographic mistakes all

571
00:23:50,230 --> 00:23:53,980
the time so we have to<font color="#E5E5E5"> be careful around</font>

572
00:23:51,910 --> 00:23:55,210
that<font color="#E5E5E5"> so our crypto implementation does</font>

573
00:23:53,980 --> 00:23:58,929
need to<font color="#E5E5E5"> be reviewed if that's the</font>

574
00:23:55,210 --> 00:24:00,490
approach we're using and for consumer

575
00:23:58,929 --> 00:24:01,120
<font color="#CCCCCC">internet scale applications that have</font>

576
00:24:00,490 --> 00:24:02,950
lots of

577
00:24:01,120 --> 00:24:04,629
and current<font color="#CCCCCC"> long-running</font><font color="#E5E5E5"> sessions the</font>

578
00:24:02,950 --> 00:24:06,160
smaller per session footprint of

579
00:24:04,630 --> 00:24:09,790
cryptographically protected references

580
00:24:06,160 --> 00:24:11,430
is probably a<font color="#E5E5E5"> better choice now one of</font>

581
00:24:09,790 --> 00:24:13,750
the<font color="#CCCCCC"> things that</font><font color="#E5E5E5"> you might be thinking</font>

582
00:24:11,430 --> 00:24:16,360
around cryptographically protected

583
00:24:13,750 --> 00:24:19,170
references is why do we need<font color="#E5E5E5"> to share</font>

584
00:24:16,360 --> 00:24:22,059
any state between our app servers at all

585
00:24:19,170 --> 00:24:25,540
<font color="#E5E5E5">all right so why not just configure one</font>

586
00:24:22,059 --> 00:24:29,590
secret key on all our app servers and

587
00:24:25,540 --> 00:24:31,300
then each of<font color="#E5E5E5"> the references could just</font>

588
00:24:29,590 --> 00:24:33,070
be the session ID and the reference

589
00:24:31,300 --> 00:24:35,350
concatenated together and then encrypted

590
00:24:33,070 --> 00:24:37,750
with<font color="#E5E5E5"> mikey and well you needa h mac for</font>

591
00:24:35,350 --> 00:24:45,760
integrity protection so what are<font color="#E5E5E5"> the</font>

592
00:24:37,750 --> 00:24:47,290
problems with that what do sorry you

593
00:24:45,760 --> 00:24:50,230
<font color="#E5E5E5">need</font><font color="#CCCCCC"> to replicate the key that one</font>

594
00:24:47,290 --> 00:24:55,000
shared key amongst all your servers<font color="#CCCCCC"> ok</font>

595
00:24:50,230 --> 00:24:56,410
well why is that a problem well have you

596
00:24:55,000 --> 00:24:58,510
ever<font color="#E5E5E5"> seen a system where you need to</font>

597
00:24:56,410 --> 00:25:00,270
share a symmetric key a secret key

598
00:24:58,510 --> 00:25:05,350
amongst a large number of app servers

599
00:25:00,270 --> 00:25:07,990
how often<font color="#CCCCCC"> does the key get updated never</font>

600
00:25:05,350 --> 00:25:10,990
right so you're introducing a key

601
00:25:07,990 --> 00:25:13,330
management headache with this solution

602
00:25:10,990 --> 00:25:14,890
where you have a in session key there is

603
00:25:13,330 --> 00:25:16,540
no key management to worry about you're

604
00:25:14,890 --> 00:25:18,070
just generating a random key that only

605
00:25:16,540 --> 00:25:21,070
last as long as the session does and

606
00:25:18,070 --> 00:25:23,080
then it's gone so<font color="#CCCCCC"> let stuff to worry</font>

607
00:25:21,070 --> 00:25:24,399
about from<font color="#CCCCCC"> a security perspective so in</font>

608
00:25:23,080 --> 00:25:26,320
this case we're the only way we're

609
00:25:24,400 --> 00:25:27,520
hearing the keys<font color="#E5E5E5"> um between the app</font>

610
00:25:26,320 --> 00:25:30,760
servers is by writing<font color="#E5E5E5"> them to the</font>

611
00:25:27,520 --> 00:25:32,470
<font color="#E5E5E5">database so how we protect that on the</font>

612
00:25:30,760 --> 00:25:34,540
back end is probably going to<font color="#E5E5E5"> be to SSL</font>

613
00:25:32,470 --> 00:25:36,100
<font color="#E5E5E5">connection to the database we don't use</font>

614
00:25:34,540 --> 00:25:39,370
a master key to replicate them

615
00:25:36,100 --> 00:25:40,870
throughout the servers so yeah I<font color="#CCCCCC"> mean</font>

616
00:25:39,370 --> 00:25:43,239
there there could be a potential<font color="#E5E5E5"> issue</font>

617
00:25:40,870 --> 00:25:44,199
with having all these secret keys in the

618
00:25:43,240 --> 00:25:46,390
database but at least they're not

619
00:25:44,200 --> 00:25:48,460
<font color="#E5E5E5">long-lived cheese so if they were to get</font>

620
00:25:46,390 --> 00:25:49,720
compromised there would be a pretty

621
00:25:48,460 --> 00:25:53,260
<font color="#CCCCCC">short lifetime for which they would be</font>

622
00:25:49,720 --> 00:25:55,540
valid anyways yeah the yeah the critical

623
00:25:53,260 --> 00:25:56,860
thing with the cryptographic we

624
00:25:55,540 --> 00:25:58,510
protected references that was that you

625
00:25:56,860 --> 00:26:01,090
do need<font color="#CCCCCC"> to have the integrity protection</font>

626
00:25:58,510 --> 00:26:03,190
in pretty much all cases if you're<font color="#E5E5E5"> just</font>

627
00:26:01,090 --> 00:26:05,169
<font color="#E5E5E5">doing encryption then you might still</font><font color="#CCCCCC"> be</font>

628
00:26:03,190 --> 00:26:07,090
<font color="#E5E5E5">able to modify things and access other</font>

629
00:26:05,170 --> 00:26:09,670
account we've actually run into many

630
00:26:07,090 --> 00:26:11,340
instances like that where in one case we

631
00:26:09,670 --> 00:26:14,680
actually<font color="#CCCCCC"> had encrypted cookies</font>

632
00:26:11,340 --> 00:26:15,909
containing a user ID well there

633
00:26:14,680 --> 00:26:17,740
encrypted there was no integrity

634
00:26:15,910 --> 00:26:20,080
protection so we're able to muck around

635
00:26:17,740 --> 00:26:21,730
with the actual cookie values we

636
00:26:20,080 --> 00:26:23,230
couldn't<font color="#E5E5E5"> really read them but by messing</font>

637
00:26:21,730 --> 00:26:27,550
around with them we could access other

638
00:26:23,230 --> 00:26:31,420
users sessions so yes we do<font color="#E5E5E5"> we do have</font>

639
00:26:27,550 --> 00:26:33,520
<font color="#CCCCCC">to be careful even with cryptography</font>

640
00:26:31,420 --> 00:26:36,550
that we're not introducing things like

641
00:26:33,520 --> 00:26:37,690
<font color="#E5E5E5">that yeah it does discourage if you're</font>

642
00:26:36,550 --> 00:26:38,919
seeing something long and random is

643
00:26:37,690 --> 00:26:42,660
probably going to discourage some people

644
00:26:38,920 --> 00:26:42,660
oh thank you very<font color="#E5E5E5"> much</font>

