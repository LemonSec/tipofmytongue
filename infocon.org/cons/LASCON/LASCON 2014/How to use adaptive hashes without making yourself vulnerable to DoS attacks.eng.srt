1
00:00:18,169 --> 00:00:24,539
<font color="#E5E5E5">okay so before we get started quick show</font>

2
00:00:22,349 --> 00:00:26,189
of hands how many of you actually have

3
00:00:24,539 --> 00:00:29,640
applications that are using adaptive

4
00:00:26,189 --> 00:00:35,640
hashes does<font color="#E5E5E5"> anybody know what adaptive</font>

5
00:00:29,640 --> 00:00:38,430
hashing is<font color="#E5E5E5"> okay so one person</font><font color="#CCCCCC"> knows all</font>

6
00:00:35,640 --> 00:00:41,339
right so we're<font color="#E5E5E5"> going to go</font><font color="#CCCCCC"> into the</font>

7
00:00:38,430 --> 00:00:44,729
history a little bit about password

8
00:00:41,339 --> 00:00:46,710
storage and how we got<font color="#E5E5E5"> into the area of</font>

9
00:00:44,729 --> 00:00:48,390
adaptive hashes why it's important for

10
00:00:46,710 --> 00:00:50,670
us<font color="#CCCCCC"> to use adaptive hashes and then we'll</font>

11
00:00:48,390 --> 00:00:52,559
<font color="#E5E5E5">get</font><font color="#CCCCCC"> into the</font><font color="#E5E5E5"> problem</font><font color="#CCCCCC"> of denial of</font>

12
00:00:50,670 --> 00:00:55,679
service when you are using adaptive

13
00:00:52,559 --> 00:00:57,870
hashes so we're going<font color="#E5E5E5"> to start</font><font color="#CCCCCC"> off by</font>

14
00:00:55,679 --> 00:01:01,079
just talking<font color="#CCCCCC"> about password storage what</font>

15
00:00:57,870 --> 00:01:03,030
the problem is in the context of when

16
00:01:01,079 --> 00:01:05,970
you're storing passwords for your

17
00:01:03,030 --> 00:01:07,440
application caesars and some<font color="#E5E5E5"> cases</font>

18
00:01:05,970 --> 00:01:08,820
you're storing passwords in your

19
00:01:07,440 --> 00:01:11,340
application to authenticate to other

20
00:01:08,820 --> 00:01:13,080
applications<font color="#CCCCCC"> and in that case you can't</font>

21
00:01:11,340 --> 00:01:15,720
use hashing but that's not something

22
00:01:13,080 --> 00:01:17,069
we're going<font color="#E5E5E5"> to address today we're going</font>

23
00:01:15,720 --> 00:01:19,140
to talk about<font color="#E5E5E5"> some solutions to this</font>

24
00:01:17,069 --> 00:01:20,789
problem we're going<font color="#E5E5E5"> to then talk about</font>

25
00:01:19,140 --> 00:01:22,619
<font color="#E5E5E5">some client-side computational</font>

26
00:01:20,789 --> 00:01:24,329
capabilities and compare them to our

27
00:01:22,619 --> 00:01:26,310
<font color="#E5E5E5">server side computational capabilities</font>

28
00:01:24,329 --> 00:01:28,619
as well as our capabilities of our

29
00:01:26,310 --> 00:01:31,590
attackers the reason for<font color="#CCCCCC"> that is</font><font color="#E5E5E5"> when we</font>

30
00:01:28,619 --> 00:01:33,780
<font color="#CCCCCC">start talking</font><font color="#E5E5E5"> about dos attacks a</font><font color="#CCCCCC"> lot of</font>

31
00:01:31,590 --> 00:01:35,310
<font color="#CCCCCC">the stuff we're going to read out there</font>

32
00:01:33,780 --> 00:01:37,799
on the internet<font color="#E5E5E5"> really talks about</font>

33
00:01:35,310 --> 00:01:40,380
pushing the work to the<font color="#E5E5E5"> client side and</font>

34
00:01:37,799 --> 00:01:42,390
we're going to<font color="#E5E5E5"> talk about how just doing</font>

35
00:01:40,380 --> 00:01:49,380
<font color="#E5E5E5">that across the board blindly doesn't</font>

36
00:01:42,390 --> 00:01:55,350
work and so what is the password storage

37
00:01:49,380 --> 00:01:58,619
problem so for a typical web application

38
00:01:55,350 --> 00:02:00,298
we've got<font color="#E5E5E5"> our application server we've</font>

39
00:01:58,619 --> 00:02:02,399
got our database server maybe we've got

40
00:02:00,299 --> 00:02:05,700
<font color="#E5E5E5">some backups of our database and we've</font>

41
00:02:02,399 --> 00:02:06,960
got some browsers we've got people from

42
00:02:05,700 --> 00:02:09,479
the outside connecting into our

43
00:02:06,960 --> 00:02:11,670
application and how do our passwords

44
00:02:09,479 --> 00:02:13,620
typically get stolen and I'm sure you've

45
00:02:11,670 --> 00:02:16,280
<font color="#CCCCCC">heard of many many instances of password</font>

46
00:02:13,620 --> 00:02:18,690
database is getting compromised and

47
00:02:16,280 --> 00:02:20,130
there's<font color="#E5E5E5"> the external attackers that were</font>

48
00:02:18,690 --> 00:02:21,959
worried about who might be<font color="#CCCCCC"> able</font><font color="#E5E5E5"> to</font>

49
00:02:20,130 --> 00:02:24,600
conduct attacks like sequel injection to

50
00:02:21,959 --> 00:02:27,570
get to our passwords or maybe even<font color="#E5E5E5"> get</font>

51
00:02:24,600 --> 00:02:31,579
to our backup tapes so for example

52
00:02:27,570 --> 00:02:31,579
getting stuff from a storage shed

53
00:02:31,970 --> 00:02:37,200
we also<font color="#E5E5E5"> have to worry about compromised</font>

54
00:02:34,680 --> 00:02:39,090
servers and malicious admins there have

55
00:02:37,200 --> 00:02:40,859
<font color="#CCCCCC">been instances in the past of malicious</font>

56
00:02:39,090 --> 00:02:42,750
people malicious employees to get

57
00:02:40,860 --> 00:02:45,360
disgruntled getting a dump of your

58
00:02:42,750 --> 00:02:47,190
database<font color="#E5E5E5"> and selling that to somebody so</font>

59
00:02:45,360 --> 00:02:50,490
another thing we have<font color="#CCCCCC"> to worry</font><font color="#E5E5E5"> about at</font>

60
00:02:47,190 --> 00:02:52,410
the end<font color="#CCCCCC"> of the day though this</font><font color="#E5E5E5"> is what</font>

61
00:02:50,490 --> 00:02:56,760
we have regardless<font color="#CCCCCC"> of</font><font color="#E5E5E5"> the type of</font>

62
00:02:52,410 --> 00:02:58,770
attacker we've got a dump of our<font color="#E5E5E5"> users</font>

63
00:02:56,760 --> 00:03:00,630
table from the database user names and

64
00:02:58,770 --> 00:03:06,090
passwords store in<font color="#E5E5E5"> stored in whatever</font>

65
00:03:00,630 --> 00:03:07,350
format that we're storing them in so how

66
00:03:06,090 --> 00:03:12,840
do we protect ourselves when this

67
00:03:07,350 --> 00:03:15,090
happens well we need to prevent for the

68
00:03:12,840 --> 00:03:18,230
most<font color="#E5E5E5"> part offline attacks against</font>

69
00:03:15,090 --> 00:03:20,220
whatever<font color="#E5E5E5"> the attacker gets access to and</font>

70
00:03:18,230 --> 00:03:22,049
we have to<font color="#E5E5E5"> keep in</font><font color="#CCCCCC"> mind that</font><font color="#E5E5E5"> the</font>

71
00:03:20,220 --> 00:03:23,430
credential store the passwords are only

72
00:03:22,050 --> 00:03:26,280
going to be valid for<font color="#CCCCCC"> a limited amount</font>

73
00:03:23,430 --> 00:03:27,960
of time<font color="#E5E5E5"> eventually hopefully in all</font>

74
00:03:26,280 --> 00:03:29,460
reasonable organizations that have some

75
00:03:27,960 --> 00:03:31,650
reasonable monitoring controls in place

76
00:03:29,460 --> 00:03:34,350
the attack<font color="#E5E5E5"> will get caught in a few</font>

77
00:03:31,650 --> 00:03:36,360
<font color="#CCCCCC">months maybe longer than it should take</font>

78
00:03:34,350 --> 00:03:38,820
but<font color="#E5E5E5"> it eventually does get caught and</font>

79
00:03:36,360 --> 00:03:40,590
users might get might be forced<font color="#E5E5E5"> to</font>

80
00:03:38,820 --> 00:03:43,140
change their credentials so we really

81
00:03:40,590 --> 00:03:46,110
<font color="#E5E5E5">have to the attacker has to operate</font>

82
00:03:43,140 --> 00:03:47,970
pretty<font color="#E5E5E5"> quickly so that passport store is</font>

83
00:03:46,110 --> 00:03:52,290
<font color="#E5E5E5">not going to be valid for the next 5 10</font>

84
00:03:47,970 --> 00:03:54,630
15 years one quick note client-side

85
00:03:52,290 --> 00:03:56,190
attacks before or after that database

86
00:03:54,630 --> 00:03:57,450
gets compromised<font color="#CCCCCC"> or really out of scope</font>

87
00:03:56,190 --> 00:03:58,710
for us that's not something we can

88
00:03:57,450 --> 00:04:06,030
address using password storage

89
00:03:58,710 --> 00:04:08,700
mechanisms so back in the day this was

90
00:04:06,030 --> 00:04:12,120
maybe a long time ago we'll see<font color="#CCCCCC"> it</font>

91
00:04:08,700 --> 00:04:14,220
actually<font color="#CCCCCC"> wasn't but starting</font><font color="#E5E5E5"> in the</font>

92
00:04:12,120 --> 00:04:16,410
1960s with the very<font color="#E5E5E5"> first versions of</font>

93
00:04:14,220 --> 00:04:20,519
<font color="#CCCCCC">Unix how did they use to store passwords</font>

94
00:04:16,410 --> 00:04:22,700
in the clear so what's the problem<font color="#CCCCCC"> with</font>

95
00:04:20,519 --> 00:04:22,700
<font color="#CCCCCC">that</font>

96
00:04:24,670 --> 00:04:33,740
assuming a lot of trust right so there's

97
00:04:31,550 --> 00:04:36,410
essentially no protection once the

98
00:04:33,740 --> 00:04:38,240
password store gets compromised and even

99
00:04:36,410 --> 00:04:42,830
back in the 1960s we kind of learned our

100
00:04:38,240 --> 00:04:45,020
lesson so there's a story about<font color="#E5E5E5"> two</font>

101
00:04:42,830 --> 00:04:48,590
people who worked over at bell labs back

102
00:04:45,020 --> 00:04:50,510
in the day one admin was editing<font color="#CCCCCC"> the</font>

103
00:04:48,590 --> 00:04:54,260
etsy password file and the other one was

104
00:04:50,510 --> 00:04:59,090
editing at sea motd anybody know what

105
00:04:54,260 --> 00:05:01,730
motd is message of the day right so due

106
00:04:59,090 --> 00:05:04,219
to<font color="#CCCCCC"> a glitch in the system when the one</font>

107
00:05:01,730 --> 00:05:05,780
admin tried to save the password file it

108
00:05:04,220 --> 00:05:08,120
actually<font color="#E5E5E5"> over wrote the message of the</font>

109
00:05:05,780 --> 00:05:12,830
day file what do<font color="#E5E5E5"> you think happened</font>

110
00:05:08,120 --> 00:05:14,390
after that every single users password

111
00:05:12,830 --> 00:05:18,380
would get exposed to anybody who logged

112
00:05:14,390 --> 00:05:20,419
into the system after that so I'd like

113
00:05:18,380 --> 00:05:24,290
<font color="#E5E5E5">to say that we fixed that problem but</font>

114
00:05:20,419 --> 00:05:25,700
even april 2014 you know there<font color="#E5E5E5"> was an</font>

115
00:05:24,290 --> 00:05:27,590
application that<font color="#CCCCCC"> was storing users</font>

116
00:05:25,700 --> 00:05:29,300
passwords just in the clear an attacker

117
00:05:27,590 --> 00:05:32,479
with sequel injection was able to get

118
00:05:29,300 --> 00:05:35,750
them all out<font color="#E5E5E5"> so</font><font color="#CCCCCC"> even today many many</font>

119
00:05:32,479 --> 00:05:37,550
applications are doing this and even the

120
00:05:35,750 --> 00:05:40,220
in the absence of any application layer

121
00:05:37,550 --> 00:05:42,380
vulnerabilities we have to<font color="#E5E5E5"> think about</font>

122
00:05:40,220 --> 00:05:45,620
well should<font color="#CCCCCC"> our database administrator</font>

123
00:05:42,380 --> 00:05:47,960
<font color="#CCCCCC">in turn organization really</font><font color="#E5E5E5"> be</font><font color="#CCCCCC"> able to</font>

124
00:05:45,620 --> 00:05:49,100
read<font color="#CCCCCC"> your CEOs password and the password</font>

125
00:05:47,960 --> 00:05:56,030
of every other person in<font color="#CCCCCC"> the</font>

126
00:05:49,100 --> 00:05:59,990
organization so how do<font color="#E5E5E5"> we solve this</font>

127
00:05:56,030 --> 00:06:03,500
problem and we have to talk<font color="#CCCCCC"> about the</font>

128
00:05:59,990 --> 00:06:05,600
history<font color="#CCCCCC"> of solution so that we</font><font color="#E5E5E5"> kind of</font>

129
00:06:03,500 --> 00:06:11,330
understand the context behind adaptive

130
00:06:05,600 --> 00:06:13,970
hashing so this was one<font color="#CCCCCC"> of the first</font>

131
00:06:11,330 --> 00:06:18,380
solutions and unfortunately people still

132
00:06:13,970 --> 00:06:20,090
use it<font color="#E5E5E5"> to this day we</font><font color="#CCCCCC"> just door instead</font>

133
00:06:18,380 --> 00:06:22,490
of the password a cryptographic hash of

134
00:06:20,090 --> 00:06:24,859
the password so in this particular

135
00:06:22,490 --> 00:06:26,360
example instead of storing the two

136
00:06:24,860 --> 00:06:31,849
passwords that I showed you<font color="#E5E5E5"> I just have</font>

137
00:06:26,360 --> 00:06:34,720
sha-1 hashes<font color="#CCCCCC"> of those passwords now the</font>

138
00:06:31,849 --> 00:06:36,520
reason why we do this

139
00:06:34,720 --> 00:06:40,780
because of the<font color="#E5E5E5"> one-way property of hash</font>

140
00:06:36,520 --> 00:06:42,640
functions so given a password we can

141
00:06:40,780 --> 00:06:46,179
compute the hash but<font color="#E5E5E5"> given a hash we</font>

142
00:06:42,640 --> 00:06:48,310
can't compute the password so that's a

143
00:06:46,180 --> 00:06:49,630
desirable property so now if somebody

144
00:06:48,310 --> 00:06:51,730
gets access to our password database

145
00:06:49,630 --> 00:06:55,330
they can't just<font color="#E5E5E5"> compute our passwords</font>

146
00:06:51,730 --> 00:06:57,460
from the hashes however where we get in

147
00:06:55,330 --> 00:07:00,520
trouble<font color="#CCCCCC"> is the ease of computation</font>

148
00:06:57,460 --> 00:07:02,530
property hash functions are designed to

149
00:07:00,520 --> 00:07:04,030
be really fast<font color="#E5E5E5"> and efficient because</font>

150
00:07:02,530 --> 00:07:06,159
they're really designed to hash large

151
00:07:04,030 --> 00:07:09,820
pieces of<font color="#E5E5E5"> data you want to be</font><font color="#CCCCCC"> able to</font>

152
00:07:06,160 --> 00:07:12,910
hash a<font color="#E5E5E5"> 5 gigabyte file in just a matter</font>

153
00:07:09,820 --> 00:07:16,390
of seconds so they're meant to be really

154
00:07:12,910 --> 00:07:19,060
<font color="#E5E5E5">really fast that's what gets us into</font>

155
00:07:16,390 --> 00:07:20,500
trouble so there's three<font color="#CCCCCC"> different types</font>

156
00:07:19,060 --> 00:07:22,180
<font color="#E5E5E5">of attacks that we're going to talk</font>

157
00:07:20,500 --> 00:07:23,740
about here there's<font color="#CCCCCC"> pre computed</font><font color="#E5E5E5"> hash</font>

158
00:07:22,180 --> 00:07:26,620
tables brute force attacks and rainbow

159
00:07:23,740 --> 00:07:28,270
tables so these<font color="#E5E5E5"> are of course attacks</font>

160
00:07:26,620 --> 00:07:30,540
against if you're just<font color="#E5E5E5"> during</font>

161
00:07:28,270 --> 00:07:34,780
cryptographic hashes of<font color="#E5E5E5"> your passwords</font>

162
00:07:30,540 --> 00:07:36,540
so what's<font color="#CCCCCC"> precomputed hash tables it's</font>

163
00:07:34,780 --> 00:07:39,219
<font color="#E5E5E5">really kind of the naive approach of</font>

164
00:07:36,540 --> 00:07:41,250
guessing all possible passwords and

165
00:07:39,220 --> 00:07:43,780
storing the password and their passions

166
00:07:41,250 --> 00:07:46,780
lots of pre-computation lots of storage

167
00:07:43,780 --> 00:07:48,669
required so for<font color="#CCCCCC"> Shawon</font><font color="#E5E5E5"> hashes and eight</font>

168
00:07:46,780 --> 00:07:50,830
character alphanumeric password if you

169
00:07:48,669 --> 00:07:52,690
<font color="#CCCCCC">wanted to have a hash table of every</font>

170
00:07:50,830 --> 00:07:54,450
single<font color="#E5E5E5"> one of those passwords that would</font>

171
00:07:52,690 --> 00:07:57,479
be greater than six petabytes of storage

172
00:07:54,450 --> 00:08:01,210
they're<font color="#E5E5E5"> really kind of fun reasonable</font>

173
00:07:57,479 --> 00:08:02,860
however if we<font color="#CCCCCC"> actually did that once we</font>

174
00:08:01,210 --> 00:08:04,330
<font color="#E5E5E5">got a database of shaolin hashes we</font>

175
00:08:02,860 --> 00:08:05,979
could recover them pretty<font color="#CCCCCC"> much instantly</font>

176
00:08:04,330 --> 00:08:07,990
all we'd have to do is the table lookup

177
00:08:05,979 --> 00:08:10,630
we've already done all<font color="#E5E5E5"> the computation</font>

178
00:08:07,990 --> 00:08:12,160
work brute force is the other end of the

179
00:08:10,630 --> 00:08:13,690
spectrum where we<font color="#E5E5E5"> don't do any</font>

180
00:08:12,160 --> 00:08:17,350
pre-computation we don't store anything

181
00:08:13,690 --> 00:08:19,300
at all and when we get the actual

182
00:08:17,350 --> 00:08:21,669
passwords table we start reversing all

183
00:08:19,300 --> 00:08:24,340
the hashes now in the worst possible

184
00:08:21,669 --> 00:08:26,169
scenario again eight character

185
00:08:24,340 --> 00:08:28,869
alphanumeric password sharwan hashes

186
00:08:26,169 --> 00:08:30,250
just on my laptop cpu it would take me

187
00:08:28,870 --> 00:08:32,409
<font color="#CCCCCC">about two point four years to recover</font>

188
00:08:30,250 --> 00:08:34,599
all those passwords so that's getting a

189
00:08:32,409 --> 00:08:36,580
little bit unreasonable remember<font color="#CCCCCC"> our</font>

190
00:08:34,599 --> 00:08:39,789
table is only valid probably for a few

191
00:08:36,580 --> 00:08:42,039
months however if I wanted to invest<font color="#E5E5E5"> in</font>

192
00:08:39,789 --> 00:08:43,838
a thousand-dollar GPU I can cut that

193
00:08:42,039 --> 00:08:45,910
down<font color="#E5E5E5"> I can cut that time down to about</font>

194
00:08:43,839 --> 00:08:47,920
10 hours now that's a<font color="#E5E5E5"> lot more</font>

195
00:08:45,910 --> 00:08:50,110
reasonable now<font color="#E5E5E5"> think about that</font>

196
00:08:47,920 --> 00:08:52,569
if your password<font color="#E5E5E5"> policy and many</font>

197
00:08:50,110 --> 00:08:55,000
organizations had this allows for<font color="#E5E5E5"> six</font>

198
00:08:52,570 --> 00:08:56,680
<font color="#CCCCCC">seven</font><font color="#E5E5E5"> eight character passwords somebody</font>

199
00:08:55,000 --> 00:08:58,389
with just a thousand-dollar GPU if

200
00:08:56,680 --> 00:09:00,519
you're<font color="#E5E5E5"> storing passwords just as</font><font color="#CCCCCC"> chawan</font>

201
00:08:58,389 --> 00:09:02,860
hashes can reverse them all in just<font color="#E5E5E5"> a</font>

202
00:09:00,519 --> 00:09:05,170
matter of<font color="#CCCCCC"> hours and somebody actually</font>

203
00:09:02,860 --> 00:09:06,519
built a GPU cluster back in 2012 that

204
00:09:05,170 --> 00:09:11,680
could actually do this<font color="#E5E5E5"> job in less than</font>

205
00:09:06,519 --> 00:09:13,630
an hour so pretty scary now rainbow

206
00:09:11,680 --> 00:09:17,560
tables essentially achieve a compromise

207
00:09:13,630 --> 00:09:19,000
<font color="#E5E5E5">between the two approaches where in this</font>

208
00:09:17,560 --> 00:09:20,829
particular case<font color="#CCCCCC"> 48 character</font>

209
00:09:19,000 --> 00:09:22,750
alphanumeric password Xiaolin hashes you

210
00:09:20,829 --> 00:09:26,229
would need about 135 gigabytes of

211
00:09:22,750 --> 00:09:28,420
storage and some pre-computation it

212
00:09:26,230 --> 00:09:31,000
allows for almost instant password

213
00:09:28,420 --> 00:09:33,490
recovery without using gpus so now using

214
00:09:31,000 --> 00:09:34,839
just my laptop cpu and rainbow tables<font color="#CCCCCC"> i</font>

215
00:09:33,490 --> 00:09:41,350
could reverse the passwords pretty

216
00:09:34,839 --> 00:09:43,899
quickly in terms of algorithms back in

217
00:09:41,350 --> 00:09:46,240
the<font color="#E5E5E5"> 1970s there was a</font><font color="#CCCCCC"> Des based hash</font>

218
00:09:43,899 --> 00:09:49,660
function that UNIX used essentially what

219
00:09:46,240 --> 00:09:51,579
<font color="#CCCCCC">it did was you would have a eight up to</font>

220
00:09:49,660 --> 00:09:53,260
eight character password it would

221
00:09:51,579 --> 00:09:55,239
encrypt a constant with that password it

222
00:09:53,260 --> 00:09:58,390
would do the encryption 25 times and it

223
00:09:55,240 --> 00:10:00,490
would store that value anybody know well

224
00:09:58,390 --> 00:10:01,720
sir des is an encryption algorithm right

225
00:10:00,490 --> 00:10:02,949
so normally we wouldn't crypt the

226
00:10:01,720 --> 00:10:06,160
password with a cryptographic key

227
00:10:02,949 --> 00:10:07,750
anybody know why they chose to encrypt

228
00:10:06,160 --> 00:10:11,610
the constant with the<font color="#E5E5E5"> password and</font>

229
00:10:07,750 --> 00:10:11,610
actually did the encryption 25 times

230
00:10:13,199 --> 00:10:17,620
well if you<font color="#CCCCCC"> think about it if your</font>

231
00:10:16,120 --> 00:10:20,529
encrypted passwords with a key what

232
00:10:17,620 --> 00:10:22,269
happens if that key gets compromised now

233
00:10:20,529 --> 00:10:24,160
that person can decrypt all your

234
00:10:22,269 --> 00:10:26,949
passwords if you're using<font color="#E5E5E5"> the password</font>

235
00:10:24,160 --> 00:10:28,930
as the key there<font color="#E5E5E5"> is no key to protect it</font>

236
00:10:26,949 --> 00:10:31,630
essentially turns it into sort of a

237
00:10:28,930 --> 00:10:33,160
one-way type of function hash type of

238
00:10:31,630 --> 00:10:37,300
function where you have to have the

239
00:10:33,160 --> 00:10:39,069
<font color="#E5E5E5">password you can't you</font><font color="#CCCCCC"> can't</font><font color="#E5E5E5"> just go</font>

240
00:10:37,300 --> 00:10:42,189
backwards and the encryption<font color="#E5E5E5"> was</font>

241
00:10:39,069 --> 00:10:43,899
performed 25 times essentially to slow

242
00:10:42,190 --> 00:10:46,060
it down because<font color="#E5E5E5"> people realize des was</font>

243
00:10:43,899 --> 00:10:47,410
too fast and we'll get<font color="#E5E5E5"> back to that</font>

244
00:10:46,060 --> 00:10:50,469
theme when we start talking about

245
00:10:47,410 --> 00:10:52,510
adaptive hashes and of course<font color="#CCCCCC"> we've got</font>

246
00:10:50,470 --> 00:10:56,199
things<font color="#E5E5E5"> like shot one shot two and so</font>

247
00:10:52,510 --> 00:10:58,569
forth these days shot too it's a newer

248
00:10:56,199 --> 00:11:01,270
algorithm no more secure in terms of the

249
00:10:58,569 --> 00:11:03,500
types of<font color="#E5E5E5"> attacks we're talking about</font>

250
00:11:01,270 --> 00:11:07,040
so the problem<font color="#E5E5E5"> with quick towpath</font>

251
00:11:03,500 --> 00:11:08,930
<font color="#CCCCCC">Akash's unsalted is that again depending</font>

252
00:11:07,040 --> 00:11:10,760
on your password<font color="#E5E5E5"> policy most hashes</font>

253
00:11:08,930 --> 00:11:12,439
might be reversible using rainbow tables

254
00:11:10,760 --> 00:11:14,660
and brute force attacks like the

255
00:11:12,440 --> 00:11:18,290
<font color="#E5E5E5">LinkedIn incident back in June 2012</font>

256
00:11:14,660 --> 00:11:21,439
right so in<font color="#E5E5E5"> that incident when attackers</font>

257
00:11:18,290 --> 00:11:23,060
got the<font color="#CCCCCC"> sha-1 hash is sixty percent of</font>

258
00:11:21,440 --> 00:11:28,160
them sixty percent of them were reversed

259
00:11:23,060 --> 00:11:29,959
in just a matter of a couple of days<font color="#CCCCCC"> so</font>

260
00:11:28,160 --> 00:11:32,150
<font color="#CCCCCC">we get to the next approach salted</font>

261
00:11:29,960 --> 00:11:34,250
cryptographic hashes so<font color="#E5E5E5"> before GPU</font>

262
00:11:32,150 --> 00:11:36,380
attacks<font color="#CCCCCC"> fpga attacks ASIC attacks became</font>

263
00:11:34,250 --> 00:11:38,090
popular the main things we were worried

264
00:11:36,380 --> 00:11:41,840
about<font color="#E5E5E5"> for rainbow table attacks and low</font>

265
00:11:38,090 --> 00:11:44,060
entropy passwords so the solution we

266
00:11:41,840 --> 00:11:46,760
came up with was well let's add a unique

267
00:11:44,060 --> 00:11:48,709
cryptographically random value that gets

268
00:11:46,760 --> 00:11:50,840
stored in the clear to the<font color="#E5E5E5"> password</font>

269
00:11:48,710 --> 00:11:52,340
before we hash it and that value we<font color="#CCCCCC"> can</font>

270
00:11:50,840 --> 00:11:54,560
store in the clear along with<font color="#CCCCCC"> a</font><font color="#E5E5E5"> password</font>

271
00:11:52,340 --> 00:11:57,230
so our<font color="#E5E5E5"> password stored looks something</font>

272
00:11:54,560 --> 00:12:00,410
like this<font color="#E5E5E5"> we have the salt and then we</font>

273
00:11:57,230 --> 00:12:05,810
have the hash now how does this protect

274
00:12:00,410 --> 00:12:08,689
us well if we start thinking<font color="#E5E5E5"> about brute</font>

275
00:12:05,810 --> 00:12:10,670
force attacks now and let's say we have

276
00:12:08,690 --> 00:12:14,120
a<font color="#CCCCCC"> database of 10</font><font color="#E5E5E5"> million passwords that</font>

277
00:12:10,670 --> 00:12:17,930
are just salted hashes assuming<font color="#E5E5E5"> that</font>

278
00:12:14,120 --> 00:12:19,250
we're using long random salts the time

279
00:12:17,930 --> 00:12:22,010
to reverse all of them just<font color="#E5E5E5"> becomes</font>

280
00:12:19,250 --> 00:12:27,320
infeasible now because now you have<font color="#E5E5E5"> to</font>

281
00:12:22,010 --> 00:12:30,319
crack every<font color="#E5E5E5"> single hash separately so we</font>

282
00:12:27,320 --> 00:12:31,760
can't now reverse<font color="#CCCCCC"> all the hashes in a</font>

283
00:12:30,320 --> 00:12:34,610
reasonable amount of time but we don't

284
00:12:31,760 --> 00:12:37,819
need to the attacker can just target

285
00:12:34,610 --> 00:12:39,380
individual passwords at a time or the

286
00:12:37,820 --> 00:12:41,720
attacker can just try weak passwords

287
00:12:39,380 --> 00:12:43,730
across all the accounts there's many

288
00:12:41,720 --> 00:12:45,110
different ways around it but typically

289
00:12:43,730 --> 00:12:46,670
<font color="#E5E5E5">the attack from I just targets and</font>

290
00:12:45,110 --> 00:12:48,290
privileged or high-value accounts and

291
00:12:46,670 --> 00:12:49,939
just get those particular passwords and

292
00:12:48,290 --> 00:12:53,390
we can still do<font color="#CCCCCC"> that as</font><font color="#E5E5E5"> long as those</font>

293
00:12:49,940 --> 00:12:55,220
passwords are easy to guess now rainbow

294
00:12:53,390 --> 00:12:57,949
tables we<font color="#E5E5E5"> sometimes hear about rainbow</font>

295
00:12:55,220 --> 00:13:00,290
tables for salted hashes there's really

296
00:12:57,950 --> 00:13:02,480
no advantage in this case it's feasible

297
00:13:00,290 --> 00:13:04,250
if the attacker is able to get salt the

298
00:13:02,480 --> 00:13:07,130
salt value for a bunch of high

299
00:13:04,250 --> 00:13:09,110
privileged<font color="#E5E5E5"> high value targets in advance</font>

300
00:13:07,130 --> 00:13:11,240
<font color="#E5E5E5">so you can compute a rainbow table so as</font>

301
00:13:09,110 --> 00:13:13,250
soon as you get the actual password hash

302
00:13:11,240 --> 00:13:13,889
for that system you can crack it almost

303
00:13:13,250 --> 00:13:16,470
instantly

304
00:13:13,889 --> 00:13:18,660
but in<font color="#CCCCCC"> general you can just do a brute</font>

305
00:13:16,470 --> 00:13:20,399
force attack pretty fast<font color="#E5E5E5"> so there's no</font>

306
00:13:18,660 --> 00:13:24,238
real advantage to rainbow table attacks

307
00:13:20,399 --> 00:13:26,339
now terms of algorithms we've got the

308
00:13:24,239 --> 00:13:30,209
exact<font color="#E5E5E5"> same thing as before we just add</font>

309
00:13:26,339 --> 00:13:32,459
assault to our hash now the problems

310
00:13:30,209 --> 00:13:35,279
with this approach is<font color="#E5E5E5"> that users tend to</font>

311
00:13:32,459 --> 00:13:37,518
choose very weak passwords so according

312
00:13:35,279 --> 00:13:39,929
to<font color="#E5E5E5"> a 2007 study that Microsoft did</font>

313
00:13:37,519 --> 00:13:41,730
twenty percent of users have passwords

314
00:13:39,929 --> 00:13:44,309
with less than<font color="#CCCCCC"> or equal to 20 bits of</font>

315
00:13:41,730 --> 00:13:46,759
entropy that is very<font color="#CCCCCC"> very small that's</font>

316
00:13:44,309 --> 00:13:48,600
<font color="#CCCCCC">very easy</font><font color="#E5E5E5"> to brute force and then</font>

317
00:13:46,759 --> 00:13:50,549
<font color="#E5E5E5">fifty-five percent of users out there</font>

318
00:13:48,600 --> 00:13:53,429
have passwords with 30 bits of entropy

319
00:13:50,549 --> 00:13:55,589
so if we<font color="#E5E5E5"> just want to target these users</font>

320
00:13:53,429 --> 00:13:57,929
how long would it take if we're<font color="#E5E5E5"> just</font>

321
00:13:55,589 --> 00:14:00,299
using salted cryptographic hashes not

322
00:13:57,929 --> 00:14:02,279
very long so twenty percent of your

323
00:14:00,299 --> 00:14:04,019
users passwords can be cracked in just a

324
00:14:02,279 --> 00:14:06,359
matter of 30 minutes<font color="#E5E5E5"> with a</font>

325
00:14:04,019 --> 00:14:09,379
thousand-dollar GPU fifty-five percent

326
00:14:06,359 --> 00:14:11,339
of users passwords maybe<font color="#CCCCCC"> twenty days and</font>

327
00:14:09,379 --> 00:14:16,439
depending on how much<font color="#E5E5E5"> hardware you have</font>

328
00:14:11,339 --> 00:14:19,860
access<font color="#E5E5E5"> to it can be a lot faster so</font>

329
00:14:16,439 --> 00:14:21,748
salted cryptographic hashes the main

330
00:14:19,860 --> 00:14:23,279
concern<font color="#CCCCCC"> we have now is</font><font color="#E5E5E5"> weak passwords</font>

331
00:14:21,749 --> 00:14:25,439
and there's not much we can do about it

332
00:14:23,279 --> 00:14:26,850
we can enforce password policies but at

333
00:14:25,439 --> 00:14:28,559
the end of the day<font color="#CCCCCC"> people will still</font>

334
00:14:26,850 --> 00:14:32,189
want to choose easy to<font color="#E5E5E5"> remember</font>

335
00:14:28,559 --> 00:14:34,019
passwords well one solution to that is

336
00:14:32,189 --> 00:14:38,488
to add a key sometimes also called a

337
00:14:34,019 --> 00:14:41,970
pepper to our salted hashes so our

338
00:14:38,489 --> 00:14:44,549
approach before was to have a salt<font color="#E5E5E5"> and a</font>

339
00:14:41,970 --> 00:14:48,169
hash of the password and the salt well

340
00:14:44,549 --> 00:14:50,850
now we<font color="#E5E5E5"> add a key and now what that does</font>

341
00:14:48,169 --> 00:14:52,379
as long as the key is protected and the

342
00:14:50,850 --> 00:14:57,569
key doesn't get compromised along with

343
00:14:52,379 --> 00:14:59,369
our table of usernames and passwords we

344
00:14:57,569 --> 00:15:01,559
don't have<font color="#E5E5E5"> to worry about brute force</font>

345
00:14:59,369 --> 00:15:04,079
attacks rainbow table attacks and so

346
00:15:01,559 --> 00:15:06,299
forth as long as that key is unknown and

347
00:15:04,079 --> 00:15:08,399
this is the only<font color="#E5E5E5"> approach that actually</font>

348
00:15:06,299 --> 00:15:10,049
offers a fair bit of protection against

349
00:15:08,399 --> 00:15:11,480
a malicious database administrator or a

350
00:15:10,049 --> 00:15:13,769
compromise database server as well

351
00:15:11,480 --> 00:15:15,689
assuming<font color="#E5E5E5"> your key</font><font color="#CCCCCC"> is</font><font color="#E5E5E5"> being managed on</font>

352
00:15:13,769 --> 00:15:18,089
the app server so<font color="#E5E5E5"> you get</font><font color="#CCCCCC"> some</font>

353
00:15:15,689 --> 00:15:19,589
advantages there<font color="#E5E5E5"> however you get no</font>

354
00:15:18,089 --> 00:15:22,230
added protection if that key gets

355
00:15:19,589 --> 00:15:23,879
compromised so<font color="#CCCCCC"> you're back to</font>

356
00:15:22,230 --> 00:15:27,649
essentially salted cryptographic hashes

357
00:15:23,879 --> 00:15:27,649
if that key is compromised

358
00:15:27,950 --> 00:15:31,830
how we<font color="#CCCCCC"> actually do this there's a couple</font>

359
00:15:30,600 --> 00:15:33,780
of approaches you could<font color="#E5E5E5"> just simply</font>

360
00:15:31,830 --> 00:15:35,720
concatenate the key<font color="#E5E5E5"> into the hash or you</font>

361
00:15:33,780 --> 00:15:38,610
could use<font color="#CCCCCC"> a</font><font color="#E5E5E5"> message authentication code</font>

362
00:15:35,720 --> 00:15:42,590
doesn't really matter<font color="#E5E5E5"> it's really the</font>

363
00:15:38,610 --> 00:15:44,730
same<font color="#E5E5E5"> idea but there's problems with this</font>

364
00:15:42,590 --> 00:15:47,070
we've added<font color="#E5E5E5"> the complexity of key</font>

365
00:15:44,730 --> 00:15:50,580
management and now<font color="#E5E5E5"> this is not a</font><font color="#CCCCCC"> simple</font>

366
00:15:47,070 --> 00:15:51,930
problem<font color="#CCCCCC"> to solve right and the</font><font color="#E5E5E5"> problem</font>

367
00:15:50,580 --> 00:15:55,170
is actually<font color="#E5E5E5"> really difficult here</font>

368
00:15:51,930 --> 00:15:56,520
because well whenever you want<font color="#CCCCCC"> to change</font>

369
00:15:55,170 --> 00:15:58,829
the key which you should be doing every

370
00:15:56,520 --> 00:16:00,569
one to two years how do you rehash all

371
00:15:58,830 --> 00:16:02,390
the passwords you remember you can't get

372
00:16:00,570 --> 00:16:04,770
the password back once you've hashed it

373
00:16:02,390 --> 00:16:07,590
so you have to wait until the user logs

374
00:16:04,770 --> 00:16:09,540
in you have<font color="#E5E5E5"> to verify the salted keyed</font>

375
00:16:07,590 --> 00:16:12,990
hash using the old key and then you have

376
00:16:09,540 --> 00:16:15,180
<font color="#E5E5E5">to store the new hash password possible</font>

377
00:16:12,990 --> 00:16:16,980
workaround encrypted salted hashes so

378
00:16:15,180 --> 00:16:19,380
you salt that<font color="#E5E5E5"> you have a salted hash and</font>

379
00:16:16,980 --> 00:16:21,540
then you encrypt it that way you can

380
00:16:19,380 --> 00:16:24,540
just decrypted because the outer<font color="#E5E5E5"> layer</font>

381
00:16:21,540 --> 00:16:25,620
is<font color="#E5E5E5"> what uses the key however combining</font>

382
00:16:24,540 --> 00:16:27,719
crypto primitives like that is

383
00:16:25,620 --> 00:16:29,460
non-trivial and if you make a mistake

384
00:16:27,720 --> 00:16:36,300
<font color="#E5E5E5">that might actually make you vulnerable</font>

385
00:16:29,460 --> 00:16:38,610
to various types<font color="#E5E5E5"> of attacks now that</font>

386
00:16:36,300 --> 00:16:41,180
brings us to adaptive hashes which is

387
00:16:38,610 --> 00:16:43,500
really what the main<font color="#E5E5E5"> point of today is</font>

388
00:16:41,180 --> 00:16:45,959
it's<font color="#E5E5E5"> really a different solution to</font>

389
00:16:43,500 --> 00:16:48,120
brute-force attacks that doesn't add the

390
00:16:45,960 --> 00:16:49,740
complexity of key management so it's an

391
00:16:48,120 --> 00:16:53,430
alternate solution to the keyed salted

392
00:16:49,740 --> 00:16:55,470
hashes what it does<font color="#E5E5E5"> is it removes the</font>

393
00:16:53,430 --> 00:16:59,099
ease of computation property of hash

394
00:16:55,470 --> 00:17:01,650
functions so now hash functions are much

395
00:16:59,100 --> 00:17:03,180
more difficult to compute and it's

396
00:17:01,650 --> 00:17:06,480
equally secure against all potential

397
00:17:03,180 --> 00:17:10,889
threat agents or potentially equally

398
00:17:06,480 --> 00:17:16,860
insecure so what does this do to our

399
00:17:10,890 --> 00:17:21,090
attacks brute<font color="#CCCCCC"> force attacks well we can</font>

400
00:17:16,859 --> 00:17:22,770
make these as slow as we want so if<font color="#E5E5E5"> we</font>

401
00:17:21,089 --> 00:17:26,220
want the time to<font color="#E5E5E5"> compute a particular</font>

402
00:17:22,770 --> 00:17:28,920
hash to be one second two seconds

403
00:17:26,220 --> 00:17:31,740
whatever we can make it so by<font color="#E5E5E5"> just</font>

404
00:17:28,920 --> 00:17:34,320
changing the adaptive hash parameters so

405
00:17:31,740 --> 00:17:36,060
we're slowing down the attacker however

406
00:17:34,320 --> 00:17:37,530
remember every time you you have to

407
00:17:36,060 --> 00:17:38,690
authenticate a user<font color="#E5E5E5"> you</font><font color="#CCCCCC"> have to compute</font>

408
00:17:37,530 --> 00:17:42,620
these hashes yourself

409
00:17:38,690 --> 00:17:46,380
so you're creating load for your server

410
00:17:42,620 --> 00:17:47,820
now<font color="#E5E5E5"> okay well so we have a little</font><font color="#CCCCCC"> bit of</font>

411
00:17:46,380 --> 00:17:49,710
a balancing act and we also<font color="#E5E5E5"> have to</font>

412
00:17:47,820 --> 00:17:51,240
<font color="#E5E5E5">remember that an attacker</font><font color="#CCCCCC"> can build some</font>

413
00:17:49,710 --> 00:17:53,700
specialized hardware that can compute

414
00:17:51,240 --> 00:17:57,059
these typically<font color="#CCCCCC"> about 2000 and 3000</font>

415
00:17:53,700 --> 00:17:58,860
times faster than any high-end server so

416
00:17:57,059 --> 00:18:02,370
the attacker is always going<font color="#E5E5E5"> to have a</font>

417
00:17:58,860 --> 00:18:05,070
bit of<font color="#E5E5E5"> a speed advantage in terms of</font>

418
00:18:02,370 --> 00:18:07,709
rainbow tables again just like with

419
00:18:05,070 --> 00:18:09,629
salted hashes if you<font color="#E5E5E5"> happen</font><font color="#CCCCCC"> to know the</font>

420
00:18:07,710 --> 00:18:11,700
salt for your targets in advance<font color="#E5E5E5"> you can</font>

421
00:18:09,630 --> 00:18:13,980
compute<font color="#E5E5E5"> these in advance and in this</font>

422
00:18:11,700 --> 00:18:15,570
particular case you<font color="#CCCCCC"> might actually get a</font>

423
00:18:13,980 --> 00:18:17,100
significant advantage of a brute<font color="#CCCCCC"> force</font>

424
00:18:15,570 --> 00:18:19,980
because you're<font color="#CCCCCC"> doing</font><font color="#E5E5E5"> all the slow</font>

425
00:18:17,100 --> 00:18:22,169
hashing work before<font color="#E5E5E5"> the table gets</font>

426
00:18:19,980 --> 00:18:23,790
compromised and once the password table

427
00:18:22,170 --> 00:18:25,830
<font color="#E5E5E5">is compromised then it's much much</font>

428
00:18:23,790 --> 00:18:28,520
faster so in this case you might

429
00:18:25,830 --> 00:18:30,750
<font color="#E5E5E5">actually the attacker might actually</font>

430
00:18:28,520 --> 00:18:32,520
want<font color="#E5E5E5"> to build some rainbow tables for</font>

431
00:18:30,750 --> 00:18:35,460
some high-value accounts for example for

432
00:18:32,520 --> 00:18:39,720
your admin account if he can get the

433
00:18:35,460 --> 00:18:40,890
salt in advance in terms of algorithms

434
00:18:39,720 --> 00:18:45,960
you might have<font color="#E5E5E5"> heard of</font><font color="#CCCCCC"> some of</font><font color="#E5E5E5"> these</font>

435
00:18:40,890 --> 00:18:49,830
<font color="#CCCCCC">pbk DF to be krypton s current in terms</font>

436
00:18:45,960 --> 00:18:53,850
of complexity<font color="#CCCCCC"> it's increasing as you go</font>

437
00:18:49,830 --> 00:18:55,320
down<font color="#CCCCCC"> the list here pbk tf2 it's</font><font color="#E5E5E5"> sort of</font>

438
00:18:53,850 --> 00:18:56,699
one of the first adaptive hashing

439
00:18:55,320 --> 00:18:58,950
functions you<font color="#CCCCCC"> can make it arbitrarily</font>

440
00:18:56,700 --> 00:19:00,809
slow however<font color="#CCCCCC"> just due to</font><font color="#E5E5E5"> the nature of</font>

441
00:18:58,950 --> 00:19:02,280
<font color="#E5E5E5">the algorithms you can parallel</font><font color="#CCCCCC"> up you</font>

442
00:19:00,809 --> 00:19:05,610
can parallelize it pretty quickly using

443
00:19:02,280 --> 00:19:08,280
gpus bcrypt makes it a little bit harder

444
00:19:05,610 --> 00:19:11,699
s script makes it even harder but even

445
00:19:08,280 --> 00:19:13,830
with<font color="#CCCCCC"> a script there are a sick based</font>

446
00:19:11,700 --> 00:19:18,059
implementations available that will work

447
00:19:13,830 --> 00:19:20,040
for some s-parameters that'll do hashing

448
00:19:18,059 --> 00:19:24,300
about<font color="#E5E5E5"> 3,000 times faster than any of</font>

449
00:19:20,040 --> 00:19:25,590
your servers could so we still<font color="#E5E5E5"> have to</font>

450
00:19:24,300 --> 00:19:27,629
keep that<font color="#E5E5E5"> in mind even</font><font color="#CCCCCC"> if</font><font color="#E5E5E5"> we are using</font>

451
00:19:25,590 --> 00:19:29,820
<font color="#E5E5E5">adaptive hashes if your attacker is</font>

452
00:19:27,630 --> 00:19:31,679
really really committed<font color="#CCCCCC"> to and really</font>

453
00:19:29,820 --> 00:19:33,030
motivated to try to attack you they will

454
00:19:31,679 --> 00:19:36,110
still be able<font color="#E5E5E5"> to in this case they have</font>

455
00:19:33,030 --> 00:19:38,309
to spend seven thousand dollars but<font color="#CCCCCC"> well</font>

456
00:19:36,110 --> 00:19:42,840
if your attacker is motivated enough

457
00:19:38,309 --> 00:19:45,720
they will do that so what are<font color="#E5E5E5"> the</font>

458
00:19:42,840 --> 00:19:47,520
problems with adaptive hashes then they

459
00:19:45,720 --> 00:19:49,320
require a<font color="#E5E5E5"> lot of computation from your</font>

460
00:19:47,520 --> 00:19:50,820
servers so the more we scale up the

461
00:19:49,320 --> 00:19:52,020
adaptive hashing parameters the more

462
00:19:50,820 --> 00:19:55,740
work our server has to do

463
00:19:52,020 --> 00:19:57,270
<font color="#E5E5E5">login any user now there's a few</font>

464
00:19:55,740 --> 00:20:00,210
different approaches we can use in terms

465
00:19:57,270 --> 00:20:03,690
of when we compute these hashes so

466
00:20:00,210 --> 00:20:05,660
typically<font color="#CCCCCC"> you your users are</font><font color="#E5E5E5"> going to be</font>

467
00:20:03,690 --> 00:20:08,820
supplying a username<font color="#E5E5E5"> and password you</font>

468
00:20:05,660 --> 00:20:10,740
<font color="#CCCCCC">can check the username and then say well</font>

469
00:20:08,820 --> 00:20:13,470
if the user name is<font color="#E5E5E5"> valid then I'll</font>

470
00:20:10,740 --> 00:20:15,660
compute the adaptive hash to see if that

471
00:20:13,470 --> 00:20:17,270
<font color="#E5E5E5">password is correct or maybe</font><font color="#CCCCCC"> a compute</font>

472
00:20:15,660 --> 00:20:19,440
the adaptive hash every single time

473
00:20:17,270 --> 00:20:23,010
what's the problem<font color="#E5E5E5"> with the first</font>

474
00:20:19,440 --> 00:20:25,590
approach where I only compute it if that

475
00:20:23,010 --> 00:20:27,750
user name is<font color="#E5E5E5"> valid just through an</font>

476
00:20:25,590 --> 00:20:29,250
authentication attempt the attacker will

477
00:20:27,750 --> 00:20:31,350
know whether a given user name<font color="#CCCCCC"> is valid</font>

478
00:20:29,250 --> 00:20:33,390
or not because<font color="#E5E5E5"> if</font><font color="#CCCCCC"> that particular user</font>

479
00:20:31,350 --> 00:20:35,250
name is<font color="#E5E5E5"> valid then the response will be</font>

480
00:20:33,390 --> 00:20:36,660
slower because your server is computing

481
00:20:35,250 --> 00:20:40,410
the adaptive hash that's a slow

482
00:20:36,660 --> 00:20:42,150
operation if we compute<font color="#E5E5E5"> the hash every</font>

483
00:20:40,410 --> 00:20:43,740
single time well you're creating an easy

484
00:20:42,150 --> 00:20:46,320
denial of service opportunity for your

485
00:20:43,740 --> 00:20:47,820
attacker all the attacker has to do is

486
00:20:46,320 --> 00:20:50,129
just<font color="#E5E5E5"> far away tons of user name and</font>

487
00:20:47,820 --> 00:20:51,870
password request at your server and your

488
00:20:50,130 --> 00:20:54,240
servers just going to chug away trying

489
00:20:51,870 --> 00:20:59,040
<font color="#E5E5E5">to compute those hashes and it can</font>

490
00:20:54,240 --> 00:21:02,040
service any actual request right so we

491
00:20:59,040 --> 00:21:03,810
also have to<font color="#E5E5E5"> think about well our valid</font>

492
00:21:02,040 --> 00:21:06,980
user names might get locked out so maybe

493
00:21:03,810 --> 00:21:09,270
that somewhat mitigates the attack but

494
00:21:06,980 --> 00:21:12,500
do<font color="#E5E5E5"> we verify these hashes when these</font>

495
00:21:09,270 --> 00:21:14,490
user accounts get locked up if we don't

496
00:21:12,500 --> 00:21:17,940
then that's another<font color="#CCCCCC"> user</font><font color="#E5E5E5"> name</font>

497
00:21:14,490 --> 00:21:20,160
enumeration attack if we do well then

498
00:21:17,940 --> 00:21:23,940
you also have<font color="#CCCCCC"> to track you know about</font>

499
00:21:20,160 --> 00:21:27,210
<font color="#E5E5E5">well if you do actually if you stop</font>

500
00:21:23,940 --> 00:21:28,320
verifying the hashes for accounts when

501
00:21:27,210 --> 00:21:29,850
they get locked up then you have to

502
00:21:28,320 --> 00:21:31,800
emulate<font color="#CCCCCC"> that behavior for invalid</font>

503
00:21:29,850 --> 00:21:34,439
accounts as<font color="#CCCCCC"> well because otherwise I can</font>

504
00:21:31,800 --> 00:21:36,060
figure out by the fact whether a given

505
00:21:34,440 --> 00:21:37,230
user name<font color="#CCCCCC"> is getting locked out or not I</font>

506
00:21:36,060 --> 00:21:39,120
<font color="#E5E5E5">can figure out if that's a valid</font>

507
00:21:37,230 --> 00:21:41,430
username or not now in<font color="#E5E5E5"> user name</font>

508
00:21:39,120 --> 00:21:42,659
enumeration not a huge problem<font color="#E5E5E5"> but still</font>

509
00:21:41,430 --> 00:21:47,490
it's something we do have to worry about

510
00:21:42,660 --> 00:21:49,290
in some cases so let's talk about

511
00:21:47,490 --> 00:21:51,660
client-side computational capabilities

512
00:21:49,290 --> 00:21:53,670
and now this is important<font color="#E5E5E5"> because if you</font>

513
00:21:51,660 --> 00:21:55,050
ever just do a google search about how

514
00:21:53,670 --> 00:21:57,270
to prevent<font color="#E5E5E5"> denial of service attacks</font>

515
00:21:55,050 --> 00:21:59,070
when you're using adaptive hashes a lot

516
00:21:57,270 --> 00:22:00,629
of the approaches talk about well we

517
00:21:59,070 --> 00:22:01,830
could just<font color="#E5E5E5"> make the client-side do it</font>

518
00:22:00,630 --> 00:22:05,639
why<font color="#E5E5E5"> don't we</font><font color="#CCCCCC"> just have the browser</font>

519
00:22:01,830 --> 00:22:07,918
compute the hash or many very

520
00:22:05,639 --> 00:22:13,109
<font color="#CCCCCC">patience of that well this is really</font>

521
00:22:07,919 --> 00:22:16,399
important<font color="#E5E5E5"> to consider so here are</font><font color="#CCCCCC"> some</font>

522
00:22:13,109 --> 00:22:19,199
numbers<font color="#CCCCCC"> for a sha-1 based adaptive hash</font>

523
00:22:16,399 --> 00:22:21,059
so these<font color="#CCCCCC"> numbers aren't going to be true</font>

524
00:22:19,200 --> 00:22:23,129
for be<font color="#E5E5E5"> Krypton a script for example</font>

525
00:22:21,059 --> 00:22:24,089
they're not<font color="#E5E5E5"> going to be there's not</font>

526
00:22:23,129 --> 00:22:27,658
<font color="#E5E5E5">going to be that big of a difference</font>

527
00:22:24,089 --> 00:22:30,678
however<font color="#E5E5E5"> if we take a look at desktop</font>

528
00:22:27,659 --> 00:22:34,139
browsers right if we want<font color="#E5E5E5"> to create a</font>

529
00:22:30,679 --> 00:22:36,869
one-second delay if we want if you

530
00:22:34,139 --> 00:22:38,758
wanted to<font color="#CCCCCC"> if we want a typical laptop</font>

531
00:22:36,869 --> 00:22:41,879
computer to require one second of

532
00:22:38,759 --> 00:22:44,700
computation to submit a adaptive<font color="#E5E5E5"> hash to</font>

533
00:22:41,879 --> 00:22:47,248
our server what does<font color="#CCCCCC"> that mean it means</font>

534
00:22:44,700 --> 00:22:49,950
about a 15 second delay for<font color="#CCCCCC"> a relatively</font>

535
00:22:47,249 --> 00:22:51,649
modern mobile phone if you're supporting

536
00:22:49,950 --> 00:22:54,029
mobile users that<font color="#E5E5E5"> could be a problem</font>

537
00:22:51,649 --> 00:22:56,908
however<font color="#E5E5E5"> how much are you slowing down</font>

538
00:22:54,029 --> 00:22:58,559
the attacker really if the attacker has

539
00:22:56,909 --> 00:23:00,089
some specialized hardware you can

540
00:22:58,559 --> 00:23:04,678
compute up to five<font color="#CCCCCC"> hundred and forty</font>

541
00:23:00,089 --> 00:23:06,839
thousand of these every second so it's

542
00:23:04,679 --> 00:23:08,609
<font color="#E5E5E5">not a level playing field right so we're</font>

543
00:23:06,839 --> 00:23:10,889
if we say during the authentication

544
00:23:08,609 --> 00:23:13,019
attempt let's say<font color="#E5E5E5"> we make the browser do</font>

545
00:23:10,889 --> 00:23:14,699
all the work it's going<font color="#E5E5E5"> to slow down</font>

546
00:23:13,019 --> 00:23:17,339
your users but it's really not going to

547
00:23:14,700 --> 00:23:22,919
slow down the attacker very much so we

548
00:23:17,339 --> 00:23:24,329
can't just blindly do that so how do<font color="#E5E5E5"> we</font>

549
00:23:22,919 --> 00:23:26,099
prevent the denial of service attacks

550
00:23:24,329 --> 00:23:27,749
when we're using adaptive hashes how do

551
00:23:26,099 --> 00:23:31,049
<font color="#E5E5E5">we make sure that an attacker can't just</font>

552
00:23:27,749 --> 00:23:32,249
bring our server down well we're going

553
00:23:31,049 --> 00:23:38,459
<font color="#E5E5E5">to take a look at five different</font>

554
00:23:32,249 --> 00:23:40,499
approaches the first approach<font color="#E5E5E5"> is sort of</font>

555
00:23:38,459 --> 00:23:42,450
the more straightforward approach we

556
00:23:40,499 --> 00:23:46,320
just move all the hashing to the client

557
00:23:42,450 --> 00:23:49,200
side so you<font color="#E5E5E5"> go to a login page</font><font color="#CCCCCC"> for your</font>

558
00:23:46,320 --> 00:23:51,418
application you supply username and the

559
00:23:49,200 --> 00:23:53,519
application<font color="#E5E5E5"> sends back a</font><font color="#CCCCCC"> solved for that</font>

560
00:23:51,419 --> 00:23:55,859
user as well as some adaptive hash

561
00:23:53,519 --> 00:23:59,249
parameter how many times to iterate<font color="#CCCCCC"> the</font>

562
00:23:55,859 --> 00:24:00,839
hash and so forth the browser does the

563
00:23:59,249 --> 00:24:02,579
computation submits the hash to<font color="#E5E5E5"> the</font>

564
00:24:00,839 --> 00:24:05,779
server<font color="#E5E5E5"> and the server verifies that the</font>

565
00:24:02,579 --> 00:24:08,879
hash equals the stored hash value

566
00:24:05,779 --> 00:24:12,299
anybody see any problems with that other

567
00:24:08,879 --> 00:24:14,849
<font color="#E5E5E5">than the fact that well you can to have</font>

568
00:24:12,299 --> 00:24:16,168
the hash parameters very high you can't

569
00:24:14,849 --> 00:24:18,829
have them high enough to actually slow

570
00:24:16,169 --> 00:24:18,829
down attackers

571
00:24:18,919 --> 00:24:23,299
<font color="#E5E5E5">so anybody see any problems with this</font>

572
00:24:25,429 --> 00:24:30,359
there's information leakage you're

573
00:24:27,389 --> 00:24:32,488
sending the salt to the browser so

574
00:24:30,359 --> 00:24:34,589
remember some of the pre-computation

575
00:24:32,489 --> 00:24:41,729
attacks we talked about<font color="#E5E5E5"> it that might</font>

576
00:24:34,589 --> 00:24:43,649
use the<font color="#E5E5E5"> salt for known user accounts if</font>

577
00:24:41,729 --> 00:24:44,999
the user name<font color="#CCCCCC"> is valid yep you</font><font color="#E5E5E5"> can try</font>

578
00:24:43,649 --> 00:24:47,879
to hide that fact by just always

579
00:24:44,999 --> 00:24:49,169
returning something but yeah at the end

580
00:24:47,879 --> 00:24:51,059
<font color="#CCCCCC">of the day you're leaking information</font>

581
00:24:49,169 --> 00:24:53,459
but whether<font color="#E5E5E5"> the user name</font><font color="#CCCCCC"> is valid and</font>

582
00:24:51,059 --> 00:24:56,759
you're leaking salts but there's a much

583
00:24:53,459 --> 00:24:59,039
much bigger<font color="#E5E5E5"> problem</font><font color="#CCCCCC"> here remember what</font>

584
00:24:56,759 --> 00:25:00,329
we're trying to<font color="#E5E5E5"> protect against we're</font>

585
00:24:59,039 --> 00:25:01,769
trying to protect against the scenario

586
00:25:00,329 --> 00:25:05,188
where your password database gets

587
00:25:01,769 --> 00:25:07,319
compromised in this particular protocol

588
00:25:05,189 --> 00:25:08,849
once your password data is compromised

589
00:25:07,319 --> 00:25:11,279
those values that are stored<font color="#E5E5E5"> in the</font>

590
00:25:08,849 --> 00:25:13,589
password<font color="#E5E5E5"> column are the values that the</font>

591
00:25:11,279 --> 00:25:17,099
browser needs to<font color="#E5E5E5"> send to the server so</font>

592
00:25:13,589 --> 00:25:18,928
there's no reversing required right so

593
00:25:17,099 --> 00:25:21,269
if an attacker gets a copy of<font color="#E5E5E5"> your</font>

594
00:25:18,929 --> 00:25:22,349
passwords on table you can just send

595
00:25:21,269 --> 00:25:24,449
those values to<font color="#CCCCCC"> the server and</font>

596
00:25:22,349 --> 00:25:28,918
authenticate as those users those hashes

597
00:25:24,449 --> 00:25:32,129
are the passwords so not a good approach

598
00:25:28,919 --> 00:25:34,319
to use and<font color="#E5E5E5"> also remember that attackers</font>

599
00:25:32,129 --> 00:25:37,918
computational abilities are much much

600
00:25:34,319 --> 00:25:39,418
greater<font color="#E5E5E5"> than your users so it's going to</font>

601
00:25:37,919 --> 00:25:41,069
force you to<font color="#E5E5E5"> use insecure adaptive</font>

602
00:25:39,419 --> 00:25:46,379
hashing parameters that are not going<font color="#CCCCCC"> to</font>

603
00:25:41,069 --> 00:25:51,418
slow the attacker down at all let's<font color="#E5E5E5"> take</font>

604
00:25:46,379 --> 00:25:55,019
a look at<font color="#CCCCCC"> another approach so this</font>

605
00:25:51,419 --> 00:25:56,519
approach involves using two hashes so is

606
00:25:55,019 --> 00:25:58,319
that we're<font color="#CCCCCC"> trying to solve</font><font color="#E5E5E5"> that problem</font>

607
00:25:56,519 --> 00:26:00,569
of well if<font color="#E5E5E5"> the password table gets</font>

608
00:25:58,319 --> 00:26:04,079
compromised those values are<font color="#CCCCCC"> the</font>

609
00:26:00,569 --> 00:26:06,239
passwords so what we do is we do

610
00:26:04,079 --> 00:26:08,789
adaptive hashing on the browser side as

611
00:26:06,239 --> 00:26:11,789
before but what we store on<font color="#CCCCCC"> the server</font>

612
00:26:08,789 --> 00:26:16,199
side is just a traditional cryptographic

613
00:26:11,789 --> 00:26:17,729
hash of what the browser<font color="#CCCCCC"> sends so we</font>

614
00:26:16,199 --> 00:26:20,249
have<font color="#E5E5E5"> essentially two layers of hashing</font>

615
00:26:17,729 --> 00:26:21,749
we have a slow have said the browser has

616
00:26:20,249 --> 00:26:23,369
to compute and then the fast hash that

617
00:26:21,749 --> 00:26:24,689
the server<font color="#E5E5E5"> has to compute so now the</font>

618
00:26:23,369 --> 00:26:26,549
server doesn't have to do a<font color="#E5E5E5"> whole lot of</font>

619
00:26:24,689 --> 00:26:31,229
<font color="#E5E5E5">work and the values that are stored</font>

620
00:26:26,549 --> 00:26:32,120
<font color="#E5E5E5">there well they can't be</font><font color="#CCCCCC"> used to just</font>

621
00:26:31,229 --> 00:26:33,770
log into the server

622
00:26:32,120 --> 00:26:43,280
anybody see any problems with this

623
00:26:33,770 --> 00:26:46,240
approach technically yet the attacker

624
00:26:43,280 --> 00:26:47,810
only needs to break that now one

625
00:26:46,240 --> 00:26:50,000
potentially good thing about this

626
00:26:47,810 --> 00:26:52,129
approaches that you actually have to

627
00:26:50,000 --> 00:26:53,390
start from a password to be<font color="#CCCCCC"> able to get</font>

628
00:26:52,130 --> 00:26:55,520
the values that are stored on the server

629
00:26:53,390 --> 00:26:57,050
right<font color="#E5E5E5"> so you have to if you're building</font>

630
00:26:55,520 --> 00:26:58,940
<font color="#E5E5E5">a hash table you have to compute the</font>

631
00:26:57,050 --> 00:27:03,129
slow hashes as well as well as the fast

632
00:26:58,940 --> 00:27:09,950
hashes so it does maybe slow you down

633
00:27:03,130 --> 00:27:14,060
but the attackers can get the user salts

634
00:27:09,950 --> 00:27:17,060
in advance<font color="#CCCCCC"> right so</font><font color="#E5E5E5"> I can do the</font><font color="#CCCCCC"> slow</font>

635
00:27:14,060 --> 00:27:19,730
hash computation offline before I get

636
00:27:17,060 --> 00:27:23,960
access to the password stable so if I

637
00:27:19,730 --> 00:27:26,390
build hash tables offline when I get

638
00:27:23,960 --> 00:27:28,580
access to the passwords table I just

639
00:27:26,390 --> 00:27:30,380
have to compete the fast hashes so now

640
00:27:28,580 --> 00:27:33,439
the<font color="#E5E5E5"> security kind of falls back down to</font>

641
00:27:30,380 --> 00:27:35,740
just salted cryptographic hashes with a

642
00:27:33,440 --> 00:27:40,190
whole bunch<font color="#CCCCCC"> of pre-computation required</font>

643
00:27:35,740 --> 00:27:41,480
so again not the best<font color="#CCCCCC"> approach because</font>

644
00:27:40,190 --> 00:27:43,450
it<font color="#E5E5E5"> doesn't really protect us against the</font>

645
00:27:41,480 --> 00:27:45,590
types of<font color="#E5E5E5"> attacks for concern about and</font>

646
00:27:43,450 --> 00:27:48,980
of<font color="#CCCCCC"> course just like with the previous</font>

647
00:27:45,590 --> 00:27:54,530
approach we can't scale up the adaptive

648
00:27:48,980 --> 00:27:58,250
hash parameters quite enough now what if

649
00:27:54,530 --> 00:27:59,660
we just<font color="#CCCCCC"> use a simpler approach instead</font>

650
00:27:58,250 --> 00:28:01,940
of offloading the computation to the

651
00:27:59,660 --> 00:28:04,610
client side we just say well you can't

652
00:28:01,940 --> 00:28:07,580
submit more than X number of requests

653
00:28:04,610 --> 00:28:14,300
per second per minute whatever from<font color="#E5E5E5"> a</font>

654
00:28:07,580 --> 00:28:16,189
given IP address does that protect us so

655
00:28:14,300 --> 00:28:18,470
we just say when we get a username and

656
00:28:16,190 --> 00:28:21,470
<font color="#E5E5E5">password we get authentication</font><font color="#CCCCCC"> request</font>

657
00:28:18,470 --> 00:28:23,000
from<font color="#CCCCCC"> the browser we say well does the</font>

658
00:28:21,470 --> 00:28:27,070
number<font color="#E5E5E5"> of authentication attempts from</font>

659
00:28:23,000 --> 00:28:29,120
that IP exceed our limit if so then

660
00:28:27,070 --> 00:28:32,240
<font color="#CCCCCC">throw out the request return an error</font>

661
00:28:29,120 --> 00:28:34,870
otherwise verify the password why

662
00:28:32,240 --> 00:28:34,870
doesn't that work

663
00:28:39,789 --> 00:28:49,279
exactly exactly so and you<font color="#CCCCCC"> don't need a</font>

664
00:28:47,090 --> 00:28:51,289
huge<font color="#E5E5E5"> botnet I know that I'm fudging some</font>

665
00:28:49,279 --> 00:28:53,179
of the numbers here but let's just<font color="#E5E5E5"> go</font>

666
00:28:51,289 --> 00:28:54,500
with<font color="#E5E5E5"> it for now so let's assume you</font>

667
00:28:53,179 --> 00:28:56,690
allow one request from an IP address

668
00:28:54,500 --> 00:29:00,919
every five seconds which is<font color="#E5E5E5"> actually a</font>

669
00:28:56,690 --> 00:29:02,360
pretty slow rate let's say our server

670
00:29:00,919 --> 00:29:03,980
takes 100 milliseconds to verify the

671
00:29:02,360 --> 00:29:06,408
password because well it's a slow

672
00:29:03,980 --> 00:29:08,600
operation and at the server has<font color="#E5E5E5"> eight</font>

673
00:29:06,409 --> 00:29:10,130
cores and access with an attacker with

674
00:29:08,600 --> 00:29:12,408
access to 400<font color="#E5E5E5"> eyepiece can cause a</font>

675
00:29:10,130 --> 00:29:15,799
denial of service I know I'm fudging

676
00:29:12,409 --> 00:29:17,450
numbers here but that's fine eventual

677
00:29:15,799 --> 00:29:18,770
blacklisting of<font color="#E5E5E5"> Phi P so if you see a</font>

678
00:29:17,450 --> 00:29:20,630
whole bunch<font color="#CCCCCC"> of requests coming in from</font>

679
00:29:18,770 --> 00:29:22,700
IPS on<font color="#CCCCCC"> a</font><font color="#E5E5E5"> sustained rage you could just</font>

680
00:29:20,630 --> 00:29:24,529
blacklist those but again if the

681
00:29:22,700 --> 00:29:26,899
attacker has access to thousands of ip's

682
00:29:24,529 --> 00:29:28,159
they'll just try 400 at a time when they

683
00:29:26,899 --> 00:29:30,469
get blacklisted he'll just move on to

684
00:29:28,159 --> 00:29:34,039
the next<font color="#E5E5E5"> 400 so it doesn't really solve</font>

685
00:29:30,470 --> 00:29:35,510
the problem however is something good

686
00:29:34,039 --> 00:29:37,250
that we should<font color="#E5E5E5"> be doing regardless</font>

687
00:29:35,510 --> 00:29:44,090
because it will stop certain<font color="#E5E5E5"> types of</font>

688
00:29:37,250 --> 00:29:47,809
attacks what about<font color="#E5E5E5"> using a proof proof</font>

689
00:29:44,090 --> 00:29:51,649
of<font color="#E5E5E5"> works team does anybody know what</font>

690
00:29:47,809 --> 00:29:55,760
proof of<font color="#E5E5E5"> work is so let's take a look at</font>

691
00:29:51,649 --> 00:29:58,039
<font color="#E5E5E5">the actual idea behind proof of work so</font>

692
00:29:55,760 --> 00:30:00,020
this<font color="#CCCCCC"> is sort of a straightforward proof</font>

693
00:29:58,039 --> 00:30:02,870
of<font color="#E5E5E5"> work scheme with a server sister the</font>

694
00:30:00,020 --> 00:30:06,110
client here's a random<font color="#E5E5E5"> value X give me</font>

695
00:30:02,870 --> 00:30:09,439
another value Y such that the sha-1 hash

696
00:30:06,110 --> 00:30:11,750
of<font color="#E5E5E5"> X concatenated with y starts with a</font>

697
00:30:09,440 --> 00:30:14,690
certain number of zeros<font color="#CCCCCC"> and you can</font><font color="#E5E5E5"> make</font>

698
00:30:11,750 --> 00:30:16,220
<font color="#E5E5E5">that as many zeros as you want and the</font>

699
00:30:14,690 --> 00:30:20,630
more zeros you add the more work the

700
00:30:16,220 --> 00:30:22,370
browser has to do to<font color="#E5E5E5"> find a value</font><font color="#CCCCCC"> Y so</font>

701
00:30:20,630 --> 00:30:24,500
the client has to try random wise until

702
00:30:22,370 --> 00:30:25,969
it gets the required hash that's

703
00:30:24,500 --> 00:30:27,710
typically going<font color="#E5E5E5"> to require about 2 to</font>

704
00:30:25,970 --> 00:30:31,070
the N computations where n is<font color="#CCCCCC"> the number</font>

705
00:30:27,710 --> 00:30:33,860
of zeros that you want up front and the

706
00:30:31,070 --> 00:30:36,470
sha-1 hash then the client<font color="#E5E5E5"> sends the</font>

707
00:30:33,860 --> 00:30:39,620
value of y to<font color="#E5E5E5"> the server server verifies</font>

708
00:30:36,470 --> 00:30:41,500
that that value starts this rubber just

709
00:30:39,620 --> 00:30:43,939
generates one hash<font color="#E5E5E5"> X concatenated</font>

710
00:30:41,500 --> 00:30:45,919
concatenated with why make<font color="#E5E5E5"> sure that it</font>

711
00:30:43,940 --> 00:30:47,450
starts with<font color="#E5E5E5"> n zeros so now the client</font>

712
00:30:45,919 --> 00:30:50,450
has to do a lot<font color="#CCCCCC"> of</font><font color="#E5E5E5"> work to find that</font>

713
00:30:47,450 --> 00:30:55,190
value<font color="#E5E5E5"> why on average this</font>

714
00:30:50,450 --> 00:30:58,310
server has<font color="#E5E5E5"> to just verify one hash so if</font>

715
00:30:55,190 --> 00:31:01,100
<font color="#E5E5E5">we were to use proof of work how would</font>

716
00:30:58,310 --> 00:31:02,780
that work we go to a<font color="#E5E5E5"> login page the</font>

717
00:31:01,100 --> 00:31:05,360
server will send some proof of work

718
00:31:02,780 --> 00:31:07,370
parameters the number of zeros that

719
00:31:05,360 --> 00:31:09,199
algorithm to use and so forth the

720
00:31:07,370 --> 00:31:11,209
browser starts computing it may be right

721
00:31:09,200 --> 00:31:13,610
<font color="#CCCCCC">away the user puts in their username and</font>

722
00:31:11,210 --> 00:31:15,620
password submits them as soon as<font color="#E5E5E5"> the</font>

723
00:31:13,610 --> 00:31:17,120
proof<font color="#E5E5E5"> of work value is ready the</font>

724
00:31:15,620 --> 00:31:19,550
username<font color="#E5E5E5"> password improve work gets</font>

725
00:31:17,120 --> 00:31:22,280
submitted the server verifies that the

726
00:31:19,550 --> 00:31:24,290
proof of work is valid and then verifies

727
00:31:22,280 --> 00:31:26,780
the password if that proof of work<font color="#E5E5E5"> is</font>

728
00:31:24,290 --> 00:31:29,990
valid if it's not valid then it just

729
00:31:26,780 --> 00:31:34,750
throws it<font color="#CCCCCC"> out so now what is this really</font>

730
00:31:29,990 --> 00:31:36,860
doing well this allows us<font color="#E5E5E5"> to</font><font color="#CCCCCC"> use secure</font>

731
00:31:34,750 --> 00:31:38,510
parameters for adaptive hashing on the

732
00:31:36,860 --> 00:31:40,040
<font color="#CCCCCC">backend</font><font color="#E5E5E5"> that are actually relatively</font>

733
00:31:38,510 --> 00:31:42,230
slow we don't have to<font color="#E5E5E5"> rely on the</font>

734
00:31:40,040 --> 00:31:44,659
client-side computational abilities so

735
00:31:42,230 --> 00:31:48,560
we're separating our adaptive hash

736
00:31:44,660 --> 00:31:51,710
parameters from another control that's

737
00:31:48,560 --> 00:32:03,320
slowing down the client side now does

738
00:31:51,710 --> 00:32:05,600
<font color="#CCCCCC">this work exactly right we have the</font><font color="#E5E5E5"> same</font>

739
00:32:03,320 --> 00:32:08,720
problem as before right now it's

740
00:32:05,600 --> 00:32:11,000
something that we probably should do now

741
00:32:08,720 --> 00:32:13,670
does<font color="#CCCCCC"> it work in every scenario now it</font>

742
00:32:11,000 --> 00:32:15,830
will help in some cases so the problem

743
00:32:13,670 --> 00:32:17,060
is again that attackers computational

744
00:32:15,830 --> 00:32:18,530
abilities are much much greater than

745
00:32:17,060 --> 00:32:19,879
<font color="#E5E5E5">your users who might be on mobile</font>

746
00:32:18,530 --> 00:32:21,410
devices who might be on desktop

747
00:32:19,880 --> 00:32:26,930
computers just running<font color="#CCCCCC"> this in</font>

748
00:32:21,410 --> 00:32:28,760
JavaScript now so we can't just scale up

749
00:32:26,930 --> 00:32:30,110
the proof of<font color="#E5E5E5"> work parameters so well we</font>

750
00:32:28,760 --> 00:32:32,000
would be able to<font color="#E5E5E5"> scale proof-of-work</font>

751
00:32:30,110 --> 00:32:34,159
parameters sort of independently of our

752
00:32:32,000 --> 00:32:35,840
adaptive hash parameters so when we're

753
00:32:34,160 --> 00:32:37,460
under attack we start scaling it up to

754
00:32:35,840 --> 00:32:40,490
slow down our clients so our server

755
00:32:37,460 --> 00:32:43,100
doesn't get impacted but when we start

756
00:32:40,490 --> 00:32:45,830
scaling up those parameters it's going

757
00:32:43,100 --> 00:32:49,879
to<font color="#E5E5E5"> impact our users a lot more</font><font color="#CCCCCC"> than the</font>

758
00:32:45,830 --> 00:32:51,290
attackers so if<font color="#E5E5E5"> we have an attacker with</font>

759
00:32:49,880 --> 00:32:53,360
a GPU cluster that<font color="#E5E5E5"> we're worried about</font>

760
00:32:51,290 --> 00:32:55,129
<font color="#E5E5E5">and we want to create a one-second delay</font>

761
00:32:53,360 --> 00:32:57,350
for every single<font color="#E5E5E5"> password that the</font>

762
00:32:55,130 --> 00:32:59,210
attacker submits that's going to mean a

763
00:32:57,350 --> 00:33:01,639
six and a half day delay for a typical

764
00:32:59,210 --> 00:33:04,970
<font color="#E5E5E5">top user and probably a</font><font color="#CCCCCC"> couple of months</font>

765
00:33:01,640 --> 00:33:06,020
<font color="#CCCCCC">for a mobile</font><font color="#E5E5E5"> device user I don't</font><font color="#CCCCCC"> think</font>

766
00:33:04,970 --> 00:33:10,010
anybody's going to wait that long<font color="#CCCCCC"> to</font>

767
00:33:06,020 --> 00:33:12,320
<font color="#CCCCCC">login so alternately we can start</font>

768
00:33:10,010 --> 00:33:14,270
scaling up the parameters by the clients

769
00:33:12,320 --> 00:33:17,120
IP address so that's a little<font color="#E5E5E5"> bit better</font>

770
00:33:14,270 --> 00:33:18,649
<font color="#E5E5E5">now now the advantage of the proof of</font>

771
00:33:17,120 --> 00:33:19,908
work scheme is you can<font color="#E5E5E5"> actually do</font>

772
00:33:18,649 --> 00:33:22,879
things like<font color="#CCCCCC"> that you</font><font color="#E5E5E5"> can scale up</font>

773
00:33:19,909 --> 00:33:24,590
parameters<font color="#E5E5E5"> by IP you can use all sorts</font>

774
00:33:22,880 --> 00:33:26,990
of heuristics so you're<font color="#E5E5E5"> not causing pain</font>

775
00:33:24,590 --> 00:33:30,678
for everybody just the machines that you

776
00:33:26,990 --> 00:33:32,149
think are attacking you now what<font color="#E5E5E5"> happens</font>

777
00:33:30,679 --> 00:33:34,789
if the user happens to be behind<font color="#CCCCCC"> the</font>

778
00:33:32,149 --> 00:33:37,580
same NAT device as the attacker so now

779
00:33:34,789 --> 00:33:39,529
the your legitimate users IP address is

780
00:33:37,580 --> 00:33:41,480
the same as the<font color="#E5E5E5"> attackers IP address as</font>

781
00:33:39,529 --> 00:33:49,760
far as your server is concerned what do

782
00:33:41,480 --> 00:34:01,039
<font color="#E5E5E5">you do about that sorry users might be</font>

783
00:33:49,760 --> 00:34:03,350
out of luck so you do but the attacker

784
00:34:01,039 --> 00:34:05,360
can technically well we're<font color="#E5E5E5"> going to</font>

785
00:34:03,350 --> 00:34:06,260
<font color="#E5E5E5">assume in certain attack models the</font>

786
00:34:05,360 --> 00:34:14,529
attacker might<font color="#E5E5E5"> be</font><font color="#CCCCCC"> able</font><font color="#E5E5E5"> to manipulate</font>

787
00:34:06,260 --> 00:34:14,530
that so yep

788
00:34:17,469 --> 00:34:20,859
it depends<font color="#E5E5E5"> on where the attackers if the</font>

789
00:34:19,418 --> 00:34:22,569
attacker has access to the NAP device

790
00:34:20,859 --> 00:34:24,668
then no but if the attacker doesn't then

791
00:34:22,570 --> 00:34:27,190
maybe that might work but yeah

792
00:34:24,668 --> 00:34:28,480
ultimately you know we have we can use

793
00:34:27,190 --> 00:34:29,889
<font color="#CCCCCC">your poaches like that or we might just</font>

794
00:34:28,480 --> 00:34:31,570
say well<font color="#E5E5E5"> that's only going to impact a</font>

795
00:34:29,889 --> 00:34:33,550
small number of users so maybe that's

796
00:34:31,570 --> 00:34:36,460
<font color="#E5E5E5">okay for a short</font><font color="#CCCCCC"> period of time or</font>

797
00:34:33,550 --> 00:34:38,230
another approach we can say is if our

798
00:34:36,460 --> 00:34:42,159
users email addresses<font color="#E5E5E5"> their</font><font color="#CCCCCC"> phone</font>

799
00:34:38,230 --> 00:34:44,379
numbers are on file what we can do is

800
00:34:42,159 --> 00:34:45,790
for legitimate users when we're under

801
00:34:44,379 --> 00:34:48,098
attack and only<font color="#E5E5E5"> when we're under attack</font>

802
00:34:45,790 --> 00:34:50,679
we can say well you can click here to

803
00:34:48,099 --> 00:34:52,540
get a token sent to your email<font color="#E5E5E5"> address</font>

804
00:34:50,679 --> 00:34:53,980
and instead the<font color="#CCCCCC"> proof of work you can</font>

805
00:34:52,540 --> 00:34:57,009
submit that token along with your

806
00:34:53,980 --> 00:35:00,070
<font color="#E5E5E5">request and it allows you to</font><font color="#CCCCCC"> bypass</font>

807
00:34:57,010 --> 00:35:01,420
proof of<font color="#E5E5E5"> work and just login now we have</font>

808
00:35:00,070 --> 00:35:04,270
to be careful about how many of these

809
00:35:01,420 --> 00:35:06,190
tokens we issue per user<font color="#E5E5E5"> per day per</font>

810
00:35:04,270 --> 00:35:09,430
hour of so forth to<font color="#CCCCCC"> make sure we don't</font>

811
00:35:06,190 --> 00:35:10,420
cause a denial of service attack but the

812
00:35:09,430 --> 00:35:12,190
good<font color="#CCCCCC"> thing about the proof of</font><font color="#E5E5E5"> work</font>

813
00:35:10,420 --> 00:35:15,010
scheme is it allows you to do things

814
00:35:12,190 --> 00:35:16,330
<font color="#E5E5E5">like this</font><font color="#CCCCCC"> so we're not just saying we</font>

815
00:35:15,010 --> 00:35:17,710
have<font color="#E5E5E5"> to use insecure adaptive hash</font>

816
00:35:16,330 --> 00:35:22,859
parameters we just have a separate

817
00:35:17,710 --> 00:35:22,859
control and we can use it as we see fit

818
00:35:24,150 --> 00:35:29,260
now the last reports we're going to talk

819
00:35:26,380 --> 00:35:32,200
about is prioritizing user logins from

820
00:35:29,260 --> 00:35:33,940
known IPS so for a lot of applications

821
00:35:32,200 --> 00:35:35,710
the majority of our users are<font color="#CCCCCC"> going to</font>

822
00:35:33,940 --> 00:35:39,460
log in from IP addresses that they've

823
00:35:35,710 --> 00:35:40,660
logged in from before most users<font color="#E5E5E5"> aren't</font>

824
00:35:39,460 --> 00:35:43,420
going to log in from a completely

825
00:35:40,660 --> 00:35:46,990
different IP every single time and we

826
00:35:43,420 --> 00:35:49,330
can use that to<font color="#E5E5E5"> help us in some cases so</font>

827
00:35:46,990 --> 00:35:51,040
as before<font color="#E5E5E5"> when the user submits a</font>

828
00:35:49,330 --> 00:35:52,390
<font color="#E5E5E5">username and password we have to figure</font>

829
00:35:51,040 --> 00:35:54,220
out whether<font color="#E5E5E5"> we want to verify the</font>

830
00:35:52,390 --> 00:35:56,920
password or not<font color="#E5E5E5"> because that's a</font>

831
00:35:54,220 --> 00:35:58,598
computationally intensive operation so

832
00:35:56,920 --> 00:36:01,900
if<font color="#CCCCCC"> that user has previously</font>

833
00:35:58,599 --> 00:36:03,310
authenticated from that IP<font color="#CCCCCC"> address then</font>

834
00:36:01,900 --> 00:36:06,339
we just go ahead and verify the password

835
00:36:03,310 --> 00:36:07,900
if the user hasn't authenticated from

836
00:36:06,339 --> 00:36:10,000
that IP address before then we just add

837
00:36:07,900 --> 00:36:11,980
that login request to a queue we<font color="#E5E5E5"> add the</font>

838
00:36:10,000 --> 00:36:14,349
<font color="#E5E5E5">username and password maybe some kind of</font>

839
00:36:11,980 --> 00:36:16,660
timeout value and the IP address<font color="#CCCCCC"> that</font>

840
00:36:14,349 --> 00:36:19,240
the user<font color="#E5E5E5"> is logging logging in from we</font>

841
00:36:16,660 --> 00:36:20,529
just add that to a queue and if we're

842
00:36:19,240 --> 00:36:22,240
<font color="#CCCCCC">getting too many requests in the queue</font>

843
00:36:20,530 --> 00:36:24,010
some of those requests<font color="#E5E5E5"> will just timeout</font>

844
00:36:22,240 --> 00:36:26,279
<font color="#E5E5E5">and we just returned errors to those to</font>

845
00:36:24,010 --> 00:36:26,280
the browser

846
00:36:28,310 --> 00:36:35,340
so something we have to be aware<font color="#E5E5E5"> of if</font>

847
00:36:32,730 --> 00:36:37,110
we're using this approach even for

848
00:36:35,340 --> 00:36:38,550
username IP address combinations that

849
00:36:37,110 --> 00:36:40,080
are sort of<font color="#E5E5E5"> white listed the user has</font>

850
00:36:38,550 --> 00:36:41,580
logged in from them before<font color="#E5E5E5"> if you're</font>

851
00:36:40,080 --> 00:36:43,350
getting<font color="#E5E5E5"> too many authentication requests</font>

852
00:36:41,580 --> 00:36:44,549
from that IP for that user we still have

853
00:36:43,350 --> 00:36:48,779
to start adding them to the queue

854
00:36:44,550 --> 00:36:50,100
because it might<font color="#CCCCCC"> be under attack now we</font>

855
00:36:48,780 --> 00:36:52,050
also have to<font color="#E5E5E5"> make sure we only dedicated</font>

856
00:36:50,100 --> 00:36:54,600
a limited number of computational

857
00:36:52,050 --> 00:36:56,280
resources to processing that queue we

858
00:36:54,600 --> 00:36:57,810
<font color="#E5E5E5">don't want you to say well we've got</font>

859
00:36:56,280 --> 00:36:59,790
<font color="#E5E5E5">50,000 requests in</font><font color="#CCCCCC"> the queue let's just</font>

860
00:36:57,810 --> 00:37:02,070
dedicated all of our service resources

861
00:36:59,790 --> 00:37:04,110
to processing it that doesn't<font color="#CCCCCC"> solve the</font>

862
00:37:02,070 --> 00:37:06,140
problem<font color="#E5E5E5"> so we might</font><font color="#CCCCCC"> say well we're</font><font color="#E5E5E5"> going</font>

863
00:37:04,110 --> 00:37:08,580
<font color="#E5E5E5">to dedicate only</font><font color="#CCCCCC"> to server threads to</font>

864
00:37:06,140 --> 00:37:09,990
processing that queue whatever login

865
00:37:08,580 --> 00:37:11,910
<font color="#CCCCCC">requests we don't get too well too bad</font>

866
00:37:09,990 --> 00:37:17,040
but<font color="#E5E5E5"> our legitimate users</font><font color="#CCCCCC"> we're logging</font>

867
00:37:11,910 --> 00:37:18,660
in from known IPS still can now this

868
00:37:17,040 --> 00:37:21,390
approach will only work if the attacker

869
00:37:18,660 --> 00:37:24,990
can't just create 100,000 accounts for

870
00:37:21,390 --> 00:37:28,290
himself and you know<font color="#E5E5E5"> log in from various</font>

871
00:37:24,990 --> 00:37:30,868
<font color="#CCCCCC">IPS and now he's got 100,000 accounts</font>

872
00:37:28,290 --> 00:37:34,680
and a bunch of IP addresses that he can

873
00:37:30,869 --> 00:37:36,210
launch this attack from so<font color="#CCCCCC"> this type of</font>

874
00:37:34,680 --> 00:37:37,919
approach<font color="#E5E5E5"> might work well for online</font>

875
00:37:36,210 --> 00:37:41,720
banking but probably not for something

876
00:37:37,920 --> 00:37:44,760
like<font color="#E5E5E5"> free webmail for</font><font color="#CCCCCC"> obvious reasons</font>

877
00:37:41,720 --> 00:37:46,770
now the attacker in this particular case

878
00:37:44,760 --> 00:37:48,240
can still cause a denial of service for

879
00:37:46,770 --> 00:37:49,770
users<font color="#CCCCCC"> that are trying</font><font color="#E5E5E5"> to log in from new</font>

880
00:37:48,240 --> 00:37:52,529
IPs and we can use the same sort<font color="#E5E5E5"> of</font>

881
00:37:49,770 --> 00:37:54,900
approach as before we can issue tokens

882
00:37:52,530 --> 00:38:03,030
at a<font color="#E5E5E5"> limited great to allow users to</font>

883
00:37:54,900 --> 00:38:04,500
bypass this so at the end<font color="#E5E5E5"> of the day we</font>

884
00:38:03,030 --> 00:38:05,940
probably have to combine several

885
00:38:04,500 --> 00:38:08,070
approaches<font color="#E5E5E5"> because none of these</font>

886
00:38:05,940 --> 00:38:09,840
approaches<font color="#E5E5E5"> is perfect we want to make</font>

887
00:38:08,070 --> 00:38:14,310
<font color="#CCCCCC">sure an attacker</font><font color="#E5E5E5"> can cause a denial of</font>

888
00:38:09,840 --> 00:38:15,900
service attack so what do we do well one

889
00:38:14,310 --> 00:38:17,790
thing you should never do is just

890
00:38:15,900 --> 00:38:20,160
offload hash computation to the client

891
00:38:17,790 --> 00:38:21,930
side it's going<font color="#E5E5E5"> to force you to</font><font color="#CCCCCC"> use</font>

892
00:38:20,160 --> 00:38:23,270
insecure adaptive hash parameters that

893
00:38:21,930 --> 00:38:26,520
are not going to slow down the attacker

894
00:38:23,270 --> 00:38:28,470
there's a huge huge gap between your

895
00:38:26,520 --> 00:38:31,700
typical users resources and<font color="#E5E5E5"> their</font>

896
00:38:28,470 --> 00:38:35,009
computational abilities and an attackers

897
00:38:31,700 --> 00:38:37,759
so at the very least<font color="#E5E5E5"> we want to rate</font>

898
00:38:35,010 --> 00:38:41,670
limit our login request by IP address

899
00:38:37,760 --> 00:38:43,400
so maybe one login<font color="#E5E5E5"> request per five</font>

900
00:38:41,670 --> 00:38:45,780
seconds from an IP<font color="#CCCCCC"> address that will</font>

901
00:38:43,400 --> 00:38:48,860
protect against a handful of malicious

902
00:38:45,780 --> 00:38:50,850
clients which is good it's<font color="#E5E5E5"> not perfect</font>

903
00:38:48,860 --> 00:38:53,700
require clients to submit a proof<font color="#E5E5E5"> of</font>

904
00:38:50,850 --> 00:38:55,500
work and scale it up by IP address and

905
00:38:53,700 --> 00:38:57,779
we want to scale it up exponentially to

906
00:38:55,500 --> 00:38:59,990
really slow the attacker down it will

907
00:38:57,780 --> 00:39:02,660
protect<font color="#E5E5E5"> against some smaller botnets</font>

908
00:38:59,990 --> 00:39:04,740
prioritize user logins from known ip's

909
00:39:02,660 --> 00:39:06,270
it's the<font color="#E5E5E5"> last report we talked about</font>

910
00:39:04,740 --> 00:39:08,310
which will potentially protect against

911
00:39:06,270 --> 00:39:10,050
larger botnets but only if the attacker

912
00:39:08,310 --> 00:39:14,009
can't just create a large number of user

913
00:39:10,050 --> 00:39:15,900
accounts himself and as we talked<font color="#E5E5E5"> about</font>

914
00:39:14,010 --> 00:39:18,120
allow legitimate users to request two or

915
00:39:15,900 --> 00:39:20,270
three tokens per day to bypass

916
00:39:18,120 --> 00:39:23,069
<font color="#CCCCCC">proof-of-work</font><font color="#E5E5E5"> to bypass these um</font>

917
00:39:20,270 --> 00:39:27,360
prioritized logins when you're under

918
00:39:23,070 --> 00:39:30,390
attack again is<font color="#E5E5E5"> this going to protect us</font>

919
00:39:27,360 --> 00:39:31,650
against every possible scenario probably

920
00:39:30,390 --> 00:39:37,069
not but it's going<font color="#E5E5E5"> to be much better</font>

921
00:39:31,650 --> 00:39:37,070
than just<font color="#E5E5E5"> not doing anything yes</font>

922
00:39:46,040 --> 00:39:51,150
so why<font color="#E5E5E5"> not</font><font color="#CCCCCC"> use captchas so</font><font color="#E5E5E5"> I did</font>

923
00:39:49,080 --> 00:39:53,400
<font color="#E5E5E5">actually think about using CAPTCHAs a</font>

924
00:39:51,150 --> 00:39:55,230
couple of reasons why I didn't talk

925
00:39:53,400 --> 00:39:59,790
about that approach one is that it's

926
00:39:55,230 --> 00:40:06,080
really<font color="#E5E5E5"> annoying for users right so yeah</font>

927
00:39:59,790 --> 00:40:06,080
but when<font color="#CCCCCC"> you're under attack yes yes yes</font>

928
00:40:06,530 --> 00:40:13,920
<font color="#CCCCCC">um the problem with that is our AI</font>

929
00:40:11,310 --> 00:40:16,290
algorithms for actually solving CAPTCHAs

930
00:40:13,920 --> 00:40:18,540
automatically have gotten really really

931
00:40:16,290 --> 00:40:19,710
good even better<font color="#E5E5E5"> than people I mean</font>

932
00:40:18,540 --> 00:40:21,900
there's algorithms out there<font color="#CCCCCC"> that</font><font color="#E5E5E5"> can</font>

933
00:40:19,710 --> 00:40:24,450
<font color="#E5E5E5">solve a lot of CAPTCHAs with ninety</font>

934
00:40:21,900 --> 00:40:25,880
percent accuracy I can't solve<font color="#E5E5E5"> those</font>

935
00:40:24,450 --> 00:40:30,299
with ninety percent accuracy myself

936
00:40:25,880 --> 00:40:34,170
right so that it will help it will raise

937
00:40:30,300 --> 00:40:36,360
the<font color="#E5E5E5"> bar which</font><font color="#CCCCCC"> is good however</font><font color="#E5E5E5"> I'm not a</font>

938
00:40:34,170 --> 00:40:38,610
big fan of captions myself because<font color="#E5E5E5"> they</font>

939
00:40:36,360 --> 00:40:40,200
happen to be painful<font color="#CCCCCC"> for users and</font>

940
00:40:38,610 --> 00:40:42,840
they're<font color="#E5E5E5"> really not going to slow down</font>

941
00:40:40,200 --> 00:40:46,100
the attacker quite that much because if

942
00:40:42,840 --> 00:40:48,150
the attacker has access to some good

943
00:40:46,100 --> 00:40:56,610
algorithms for computing these captures

944
00:40:48,150 --> 00:40:58,860
they can<font color="#E5E5E5"> get past it pretty easily yep</font>

945
00:40:56,610 --> 00:41:00,300
and yeah I mean it's<font color="#E5E5E5"> a open research</font>

946
00:40:58,860 --> 00:41:03,480
area and the algorithms<font color="#E5E5E5"> are getting</font>

947
00:41:00,300 --> 00:41:05,790
better and better and I mean for most

948
00:41:03,480 --> 00:41:07,170
CAPTCHAs they're much better computers

949
00:41:05,790 --> 00:41:09,750
are much better at solving them now than

950
00:41:07,170 --> 00:41:11,610
humans are so it's kind of scary but

951
00:41:09,750 --> 00:41:15,690
that's why<font color="#E5E5E5"> I'm not a big</font><font color="#CCCCCC"> fan of capture</font>

952
00:41:11,610 --> 00:41:17,160
approaches myself but if you<font color="#E5E5E5"> wanted to</font>

953
00:41:15,690 --> 00:41:24,240
raise the bar absolutely it's something

954
00:41:17,160 --> 00:41:27,299
you can use so in<font color="#CCCCCC"> conclusion how did we</font>

955
00:41:24,240 --> 00:41:29,279
get here right so we're<font color="#CCCCCC"> trying</font><font color="#E5E5E5"> to solve</font>

956
00:41:27,300 --> 00:41:31,230
the problem<font color="#CCCCCC"> of</font><font color="#E5E5E5"> password storage however</font>

957
00:41:29,280 --> 00:41:33,540
the mechanism that we choose for storing

958
00:41:31,230 --> 00:41:35,880
passwords has side effects in the case

959
00:41:33,540 --> 00:41:37,620
of adaptive hashes which is sort of the

960
00:41:35,880 --> 00:41:40,230
widely<font color="#CCCCCC"> accepted approach these days for</font>

961
00:41:37,620 --> 00:41:44,210
storing passwords it can open<font color="#E5E5E5"> up your</font>

962
00:41:40,230 --> 00:41:46,440
server to denial of service attacks so

963
00:41:44,210 --> 00:41:47,970
how do we<font color="#E5E5E5"> protect ourselves while we</font>

964
00:41:46,440 --> 00:41:49,230
talked about<font color="#E5E5E5"> some approaches that you</font>

965
00:41:47,970 --> 00:41:51,419
might<font color="#CCCCCC"> be able to combine to protect</font>

966
00:41:49,230 --> 00:41:54,180
yourself<font color="#E5E5E5"> keep in mind that attackers</font>

967
00:41:51,420 --> 00:41:55,200
will build custom hardware to still

968
00:41:54,180 --> 00:41:57,270
attack you if they're sufficiently

969
00:41:55,200 --> 00:41:58,118
motivated so none of these<font color="#E5E5E5"> approaches</font>

970
00:41:57,270 --> 00:42:00,220
are necessarily going

971
00:41:58,119 --> 00:42:03,220
be<font color="#E5E5E5"> perfect but it's all</font><font color="#CCCCCC"> about raising</font>

972
00:42:00,220 --> 00:42:05,319
<font color="#CCCCCC">the bar so</font><font color="#E5E5E5"> an attacker with access to</font>

973
00:42:03,220 --> 00:42:06,730
<font color="#E5E5E5">just a botnet of 100 IPS can't do</font>

974
00:42:05,319 --> 00:42:09,640
anything they actually have<font color="#E5E5E5"> to invest</font>

975
00:42:06,730 --> 00:42:10,960
<font color="#CCCCCC">$10,000 and get access to a hundred</font>

976
00:42:09,640 --> 00:42:15,069
<font color="#E5E5E5">thousand eyepiece before they can do</font>

977
00:42:10,960 --> 00:42:16,630
something<font color="#CCCCCC"> just raising the bar and if</font>

978
00:42:15,069 --> 00:42:19,180
this denial of service prevention seems

979
00:42:16,630 --> 00:42:22,630
too difficult just use keyed salted

980
00:42:19,180 --> 00:42:24,249
hashes that's an alternate<font color="#CCCCCC"> approach but</font>

981
00:42:22,630 --> 00:42:25,630
it doesn't reduce that problem of key

982
00:42:24,249 --> 00:42:32,769
management that we talked<font color="#CCCCCC"> about and it's</font>

983
00:42:25,630 --> 00:42:34,660
not a trivial problem to solve at the

984
00:42:32,769 --> 00:42:36,720
end<font color="#E5E5E5"> of the day though remember password</font>

985
00:42:34,660 --> 00:42:39,190
storage is only part of the problem

986
00:42:36,720 --> 00:42:40,839
we're<font color="#E5E5E5"> really trying to make</font><font color="#CCCCCC"> sure that</font>

987
00:42:39,190 --> 00:42:43,150
attackers can't get an authorized access

988
00:42:40,839 --> 00:42:46,720
to our users accounts that's what it's

989
00:42:43,150 --> 00:42:48,700
<font color="#CCCCCC">really about now</font><font color="#E5E5E5"> according to that same</font>

990
00:42:46,720 --> 00:42:50,890
2007 study by<font color="#E5E5E5"> Microsoft that are</font>

991
00:42:48,700 --> 00:42:53,950
referenced<font color="#CCCCCC"> earlier eighty-five percent</font>

992
00:42:50,890 --> 00:42:57,848
of passwords have 40 bits or less of

993
00:42:53,950 --> 00:43:01,509
entropy that makes them all feasible to

994
00:42:57,849 --> 00:43:04,390
brute force may be the solution<font color="#CCCCCC"> to that</font>

995
00:43:01,509 --> 00:43:07,319
is<font color="#E5E5E5"> a strong</font><font color="#CCCCCC"> password policy maybe we</font>

996
00:43:04,390 --> 00:43:10,058
<font color="#E5E5E5">don't allow passwords with low entropy</font>

997
00:43:07,319 --> 00:43:12,308
users tend to reuse usernames and

998
00:43:10,059 --> 00:43:13,989
passwords across multiple sites it

999
00:43:12,309 --> 00:43:17,529
doesn't<font color="#E5E5E5"> matter how secure your password</font>

1000
00:43:13,989 --> 00:43:18,849
storage mechanism is if your user uses

1001
00:43:17,529 --> 00:43:20,200
that same username<font color="#E5E5E5"> and password on</font>

1002
00:43:18,849 --> 00:43:22,059
another website and they're storing

1003
00:43:20,200 --> 00:43:24,220
passwords in the clear<font color="#E5E5E5"> and that sites</font>

1004
00:43:22,059 --> 00:43:25,930
database<font color="#E5E5E5"> gets compromised well those</font>

1005
00:43:24,220 --> 00:43:31,359
users accounts are compromised on your

1006
00:43:25,930 --> 00:43:32,410
machine on your server well one possible

1007
00:43:31,359 --> 00:43:33,759
solution might be additional

1008
00:43:32,410 --> 00:43:36,160
authentication steps from new IP

1009
00:43:33,759 --> 00:43:37,539
addresses so when you get a<font color="#E5E5E5"> login</font>

1010
00:43:36,160 --> 00:43:39,129
request from a different IP that<font color="#E5E5E5"> you've</font>

1011
00:43:37,539 --> 00:43:41,170
never<font color="#CCCCCC"> seen</font><font color="#E5E5E5"> before from a different part</font>

1012
00:43:39,130 --> 00:43:43,269
of the world maybe you require some

1013
00:43:41,170 --> 00:43:45,579
other verification<font color="#CCCCCC"> and many of Google</font>

1014
00:43:43,269 --> 00:43:47,470
services for example<font color="#CCCCCC"> actually do this so</font>

1015
00:43:45,579 --> 00:43:48,759
if you try<font color="#E5E5E5"> logging in from a different</font>

1016
00:43:47,470 --> 00:43:51,098
country that you never logged in from

1017
00:43:48,759 --> 00:43:52,539
before it might ask you for some<font color="#E5E5E5"> kind of</font>

1018
00:43:51,099 --> 00:43:53,920
a one-time password verification

1019
00:43:52,539 --> 00:43:58,029
verifying against your phone number

1020
00:43:53,920 --> 00:44:00,249
something like that users also tend to

1021
00:43:58,029 --> 00:44:01,660
fall for phishing attacks there's some

1022
00:44:00,249 --> 00:44:04,660
really really good phishing attacks out

1023
00:44:01,660 --> 00:44:07,089
there and there's nothing<font color="#E5E5E5"> we can do</font>

1024
00:44:04,660 --> 00:44:10,149
about that really<font color="#E5E5E5"> in terms of protecting</font>

1025
00:44:07,089 --> 00:44:10,580
passwords maybe we require some

1026
00:44:10,150 --> 00:44:12,800
additional

1027
00:44:10,580 --> 00:44:14,450
dedication steps from new IPs but good

1028
00:44:12,800 --> 00:44:16,160
phishing attacks might also be<font color="#CCCCCC"> able to</font>

1029
00:44:14,450 --> 00:44:18,319
get around<font color="#E5E5E5"> those and just get the user</font>

1030
00:44:16,160 --> 00:44:19,040
to provide the information that you

1031
00:44:18,320 --> 00:44:22,220
would need<font color="#CCCCCC"> for the additional</font>

1032
00:44:19,040 --> 00:44:24,410
authentication steps or maybe it's just

1033
00:44:22,220 --> 00:44:26,480
time for two factor authentication time

1034
00:44:24,410 --> 00:44:28,220
to realize that passwords don't really

1035
00:44:26,480 --> 00:44:31,010
cut it they've got way too many problems

1036
00:44:28,220 --> 00:44:32,480
and we really need one-time passwords or

1037
00:44:31,010 --> 00:44:34,670
certificates or something else in

1038
00:44:32,480 --> 00:44:40,220
addition to<font color="#E5E5E5"> passwords to authenticate to</font>

1039
00:44:34,670 --> 00:44:41,900
apps and that's pretty much all the

1040
00:44:40,220 --> 00:44:44,629
material I had just<font color="#E5E5E5"> one quick</font>

1041
00:44:41,900 --> 00:44:49,130
<font color="#CCCCCC">acknowledgement Aurora I actually worked</font>

1042
00:44:44,630 --> 00:44:50,480
with him over the summer<font color="#E5E5E5"> to to actually</font>

1043
00:44:49,130 --> 00:44:52,520
<font color="#CCCCCC">come up with some of the numbers for</font>

1044
00:44:50,480 --> 00:44:53,830
<font color="#E5E5E5">this talk and he implemented the sha-1</font>

1045
00:44:52,520 --> 00:44:56,450
based proof of worth scheme<font color="#E5E5E5"> in</font>

1046
00:44:53,830 --> 00:44:57,740
<font color="#E5E5E5">JavaScript and allowed</font><font color="#CCCCCC"> me to get some of</font>

1047
00:44:56,450 --> 00:45:02,750
<font color="#CCCCCC">the performance numbers that I showed</font>

1048
00:44:57,740 --> 00:45:08,169
you earlier and<font color="#CCCCCC"> that's it so any</font>

1049
00:45:02,750 --> 00:45:08,170
<font color="#CCCCCC">questions yes lots</font><font color="#E5E5E5"> of questions go</font><font color="#CCCCCC"> ahead</font>

1050
00:45:19,810 --> 00:45:28,820
you could do that yeah in theory you

1051
00:45:27,200 --> 00:45:30,740
<font color="#CCCCCC">could do that</font><font color="#E5E5E5"> it's just you know at that</font>

1052
00:45:28,820 --> 00:45:32,570
<font color="#E5E5E5">point it's just a matter of you know who</font>

1053
00:45:30,740 --> 00:45:34,459
<font color="#E5E5E5">can spend more money on it right and</font>

1054
00:45:32,570 --> 00:45:35,990
whatever adaptive has parameters you're

1055
00:45:34,460 --> 00:45:37,580
using they're going to become obsolete

1056
00:45:35,990 --> 00:45:39,850
probably in another four or five years

1057
00:45:37,580 --> 00:45:43,420
<font color="#E5E5E5">so you have to keep updating that and</font>

1058
00:45:39,850 --> 00:45:45,470
also I mean for a typical enterprise

1059
00:45:43,420 --> 00:45:47,150
somebody has to write the software to

1060
00:45:45,470 --> 00:45:48,980
actually run that GPU cluster and all

1061
00:45:47,150 --> 00:45:50,120
that and that implementation you know

1062
00:45:48,980 --> 00:45:52,730
you're not going<font color="#E5E5E5"> to just pull some</font>

1063
00:45:50,120 --> 00:45:54,109
random person software off a website<font color="#E5E5E5"> you</font>

1064
00:45:52,730 --> 00:45:56,480
actually are probably going to do the

1065
00:45:54,110 --> 00:46:00,470
implementation yourself you could do it

1066
00:45:56,480 --> 00:46:03,880
but in theory<font color="#CCCCCC"> yeah you</font><font color="#E5E5E5"> could do it most</font>

1067
00:46:00,470 --> 00:46:03,879
organizations probably won't

1068
00:46:06,730 --> 00:46:15,010
yeah it's<font color="#CCCCCC"> definitely a possibility good</font>

1069
00:46:09,500 --> 00:46:15,010
point yep

1070
00:46:17,420 --> 00:46:22,829
<font color="#E5E5E5">what happens when your primary customer</font>

1071
00:46:20,400 --> 00:46:25,489
base comes from a lot<font color="#E5E5E5"> of people</font><font color="#CCCCCC"> using</font>

1072
00:46:22,829 --> 00:46:25,489
the same ideas

1073
00:46:26,309 --> 00:46:31,439
yep so in that case maybe you have to

1074
00:46:28,890 --> 00:46:34,170
have certain whitelisted IPS from which

1075
00:46:31,439 --> 00:46:36,328
you allow greater numbers of log and

1076
00:46:34,170 --> 00:46:38,969
requests we have to<font color="#E5E5E5"> keep in</font><font color="#CCCCCC"> mind though</font>

1077
00:46:36,329 --> 00:46:42,119
that<font color="#CCCCCC"> even when all your users are behind</font>

1078
00:46:38,969 --> 00:46:44,459
the same NAT device you're not going to

1079
00:46:42,119 --> 00:46:45,630
get<font color="#CCCCCC"> that many concurrent login requests</font>

1080
00:46:44,459 --> 00:46:47,368
you might get a lot of concurrent

1081
00:46:45,630 --> 00:46:50,130
requests but not a lot of concurrent

1082
00:46:47,369 --> 00:46:52,170
login requests normally so we can still

1083
00:46:50,130 --> 00:46:56,160
just limit rate limit the log and

1084
00:46:52,170 --> 00:46:57,390
<font color="#CCCCCC">requests and not other ones and you</font>

1085
00:46:56,160 --> 00:46:59,969
might have<font color="#E5E5E5"> to say well for these</font>

1086
00:46:57,390 --> 00:47:01,709
particular IPS maybe we allow more log

1087
00:46:59,969 --> 00:47:05,059
and requests and we rely more on some of

1088
00:47:01,709 --> 00:47:08,058
the other mechanisms that I talked about

1089
00:47:05,059 --> 00:47:08,059
yep

1090
00:47:14,340 --> 00:47:20,869
apply to any personal<font color="#E5E5E5"> knowledge</font>

1091
00:47:18,480 --> 00:47:24,910
I have assembly when I'm

1092
00:47:20,869 --> 00:47:24,910
noises enesco

1093
00:47:31,470 --> 00:47:34,430
<font color="#E5E5E5">startled you</font>

1094
00:47:37,090 --> 00:47:40,359
exactly<font color="#E5E5E5"> if yes</font>

1095
00:47:42,070 --> 00:47:49,170
30

1096
00:47:44,640 --> 00:47:49,170
you should also<font color="#E5E5E5"> consumers</font>

1097
00:47:52,670 --> 00:47:57,790
yeah so just a cell

1098
00:48:08,880 --> 00:48:14,859
because<font color="#CCCCCC"> Ron</font><font color="#E5E5E5"> is crazy so there's two</font>

1099
00:48:13,180 --> 00:48:16,750
problems with that right number one

1100
00:48:14,859 --> 00:48:18,160
everybody<font color="#CCCCCC"> thinks that their</font><font color="#E5E5E5"> back end is</font>

1101
00:48:16,750 --> 00:48:21,280
sufficiently protected and they don't

1102
00:48:18,160 --> 00:48:23,348
have<font color="#E5E5E5"> to worry about it right there all</font>

1103
00:48:21,280 --> 00:48:26,380
it's going to take is one vulnerability

1104
00:48:23,349 --> 00:48:28,210
that even not even your own software in

1105
00:48:26,380 --> 00:48:29,619
<font color="#CCCCCC">the underlying layers that you're using</font>

1106
00:48:28,210 --> 00:48:31,420
like<font color="#CCCCCC"> card plate or something like that</font>

1107
00:48:29,619 --> 00:48:33,190
right and just a bunch of information

1108
00:48:31,420 --> 00:48:36,640
<font color="#CCCCCC">that you thought was secret now gets</font>

1109
00:48:33,190 --> 00:48:37,990
exposed to the outside right so that's

1110
00:48:36,640 --> 00:48:40,629
one<font color="#CCCCCC"> of the problems so we can't really</font>

1111
00:48:37,990 --> 00:48:43,149
rely on just protecting the back end we

1112
00:48:40,630 --> 00:48:44,799
have to plan for<font color="#CCCCCC"> the fact that at some</font>

1113
00:48:43,150 --> 00:48:47,280
point our passwords might get

1114
00:48:44,799 --> 00:48:47,280
compromised

1115
00:48:54,340 --> 00:48:57,090
if you are

1116
00:48:58,080 --> 00:49:05,400
weathers but there's no such thing as<font color="#E5E5E5"> a</font>

1117
00:49:03,810 --> 00:49:11,900
hundred percent security right i mean at

1118
00:49:05,400 --> 00:49:11,900
the end<font color="#E5E5E5"> of the day you should do</font><font color="#CCCCCC"> that</font>

1119
00:49:14,840 --> 00:49:19,020
well yeah I mean firewalls will protect

1120
00:49:17,760 --> 00:49:20,160
against certain types of attacks they

1121
00:49:19,020 --> 00:49:21,870
are not going to protect<font color="#E5E5E5"> you from a</font>

1122
00:49:20,160 --> 00:49:23,430
player attacks though right so if your

1123
00:49:21,870 --> 00:49:24,630
application happens to have a SQL

1124
00:49:23,430 --> 00:49:26,069
injection vulnerability there's no

1125
00:49:24,630 --> 00:49:28,620
firewall that's going to completely stop

1126
00:49:26,070 --> 00:49:30,990
yes<font color="#E5E5E5"> web application firewalls will stop</font>

1127
00:49:28,620 --> 00:49:32,040
some<font color="#CCCCCC"> of the easier attacks but they're</font>

1128
00:49:30,990 --> 00:49:34,410
<font color="#E5E5E5">not going to stop everything its</font>

1129
00:49:32,040 --> 00:49:36,420
signature based it's only going to stop

1130
00:49:34,410 --> 00:49:38,730
things that have<font color="#E5E5E5"> seen before but at the</font>

1131
00:49:36,420 --> 00:49:40,290
<font color="#CCCCCC">end of the day yes you should do it</font>

1132
00:49:38,730 --> 00:49:42,780
absolutely everything to<font color="#E5E5E5"> protect your</font>

1133
00:49:40,290 --> 00:49:46,170
back end however you<font color="#CCCCCC"> have to plan for</font>

1134
00:49:42,780 --> 00:49:49,020
the<font color="#CCCCCC"> incident</font><font color="#E5E5E5"> where somebody might be</font>

1135
00:49:46,170 --> 00:49:50,160
<font color="#CCCCCC">able to get that even if let's say your</font>

1136
00:49:49,020 --> 00:49:51,960
app is one hundred percent for your

1137
00:49:50,160 --> 00:49:54,710
vulnerabilities what about<font color="#E5E5E5"> your database</font>

1138
00:49:51,960 --> 00:49:57,150
administrator is that<font color="#E5E5E5"> somebody you</font>

1139
00:49:54,710 --> 00:50:00,600
completely 100% trust what if that

1140
00:49:57,150 --> 00:50:01,860
person just decides that you know what

1141
00:50:00,600 --> 00:50:04,740
I'm going<font color="#E5E5E5"> to grab with them for this</font>

1142
00:50:01,860 --> 00:50:05,880
database table and I'm going<font color="#E5E5E5"> to run with</font>

1143
00:50:04,740 --> 00:50:07,680
it I'm going<font color="#E5E5E5"> to sell it</font><font color="#CCCCCC"> to someone or</font>

1144
00:50:05,880 --> 00:50:09,630
what<font color="#E5E5E5"> about your backup tapes what if</font>

1145
00:50:07,680 --> 00:50:12,120
they<font color="#CCCCCC"> get lost your organization doesn't</font>

1146
00:50:09,630 --> 00:50:15,360
typically managed backup tapes I mean

1147
00:50:12,120 --> 00:50:17,100
they get lost sometimes they fall<font color="#CCCCCC"> off</font>

1148
00:50:15,360 --> 00:50:18,150
trucks I mean there's all sorts of

1149
00:50:17,100 --> 00:50:20,730
<font color="#E5E5E5">things that have happened in the past</font>

1150
00:50:18,150 --> 00:50:22,560
you you do everything you can but you

1151
00:50:20,730 --> 00:50:24,570
can't stop at one-hundred percent and

1152
00:50:22,560 --> 00:50:25,799
you know at the end of the day is<font color="#E5E5E5"> backup</font>

1153
00:50:24,570 --> 00:50:27,570
tapes there are many other ways<font color="#E5E5E5"> in which</font>

1154
00:50:25,800 --> 00:50:30,600
it could get stolen it's just a<font color="#E5E5E5"> matter</font>

1155
00:50:27,570 --> 00:50:32,520
of preparing just<font color="#E5E5E5"> in case something</font><font color="#CCCCCC"> like</font>

1156
00:50:30,600 --> 00:50:33,930
that does happen because the last thing

1157
00:50:32,520 --> 00:50:35,640
you want is<font color="#CCCCCC"> to be in the news and</font>

1158
00:50:33,930 --> 00:50:37,379
somebody saying well these guys are

1159
00:50:35,640 --> 00:50:39,900
using<font color="#E5E5E5"> the approach from you know the</font>

1160
00:50:37,380 --> 00:50:41,940
1980s they're not using the most modern

1161
00:50:39,900 --> 00:50:44,130
approaches there's also the issue of

1162
00:50:41,940 --> 00:50:46,070
image as well so you want to do

1163
00:50:44,130 --> 00:50:48,360
everything<font color="#E5E5E5"> you can to protect yourself</font>

1164
00:50:46,070 --> 00:50:50,010
just in case something<font color="#E5E5E5"> does happen and</font>

1165
00:50:48,360 --> 00:50:52,320
these<font color="#E5E5E5"> things do happen I mean every</font>

1166
00:50:50,010 --> 00:50:54,090
organization that's had password hashes

1167
00:50:52,320 --> 00:50:55,910
stolen they all thought they were doing

1168
00:50:54,090 --> 00:50:58,130
<font color="#E5E5E5">a reasonable job nobody thinks</font><font color="#CCCCCC"> that</font>

1169
00:50:55,910 --> 00:51:00,540
we're not<font color="#E5E5E5"> going to worry about security</font>

1170
00:50:58,130 --> 00:51:01,980
right they thought<font color="#CCCCCC"> they had</font><font color="#E5E5E5"> the</font>

1171
00:51:00,540 --> 00:51:03,210
infrastructure security in place they

1172
00:51:01,980 --> 00:51:07,730
<font color="#CCCCCC">thought they were doing the right things</font>

1173
00:51:03,210 --> 00:51:07,730
but at the end of the day things happen

1174
00:51:07,770 --> 00:51:15,090
any other questions not thank you very

1175
00:51:12,880 --> 00:51:15,090
<font color="#CCCCCC">much</font>

