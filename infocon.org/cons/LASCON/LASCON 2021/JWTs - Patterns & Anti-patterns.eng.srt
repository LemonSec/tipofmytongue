1
00:00:17,840 --> 00:00:19,600
thanks for everyone who came to my talk

2
00:00:19,600 --> 00:00:22,160
today i'm excited to present uh at last

3
00:00:22,160 --> 00:00:23,600
con as one of the first conferences i

4
00:00:23,600 --> 00:00:25,279
went to a few years ago when i started

5
00:00:25,279 --> 00:00:27,279
my career so it's cool to be up here on

6
00:00:27,279 --> 00:00:31,199
the other side i am curious um

7
00:00:31,199 --> 00:00:34,800
who here is already familiar with jwts

8
00:00:34,800 --> 00:00:36,640
all right who has strong opinions about

9
00:00:36,640 --> 00:00:38,399
them

10
00:00:38,399 --> 00:00:39,840
okay that's actually reassuring because

11
00:00:39,840 --> 00:00:40,960
i was worried people were going to throw

12
00:00:40,960 --> 00:00:42,640
things depending on

13
00:00:42,640 --> 00:00:45,520
my takes and how spicy they were so

14
00:00:45,520 --> 00:00:47,520
i'm glad to hear it

15
00:00:47,520 --> 00:00:49,280
well wait till the second half of

16
00:00:49,280 --> 00:00:51,280
presentation

17
00:00:51,280 --> 00:00:53,120
so a little bit about myself i'm

18
00:00:53,120 --> 00:00:54,879
currently a senior security engineer at

19
00:00:54,879 --> 00:00:57,520
instacart i previously had a few roles i

20
00:00:57,520 --> 00:00:59,600
started in product management but moved

21
00:00:59,600 --> 00:01:02,719
to security pretty early in my career

22
00:01:02,719 --> 00:01:04,239
i was the first security engineer at

23
00:01:04,239 --> 00:01:05,680
favorite delivery which is a really cool

24
00:01:05,680 --> 00:01:06,960
experience

25
00:01:06,960 --> 00:01:08,960
my educational backgrounds at a m and

26
00:01:08,960 --> 00:01:11,040
georgia tech and

27
00:01:11,040 --> 00:01:12,640
i have a pretty inactive twitter account

28
00:01:12,640 --> 00:01:14,320
but you're welcome to follow it send me

29
00:01:14,320 --> 00:01:16,080
dms if you have any questions after the

30
00:01:16,080 --> 00:01:18,320
talk

31
00:01:19,520 --> 00:01:21,600
and my intended audience here obviously

32
00:01:21,600 --> 00:01:24,080
based on the conference we're at is

33
00:01:24,080 --> 00:01:25,439
application and product security

34
00:01:25,439 --> 00:01:26,479
engineers

35
00:01:26,479 --> 00:01:27,680
also

36
00:01:27,680 --> 00:01:29,680
developers who may be interested in

37
00:01:29,680 --> 00:01:31,680
doing things more securely or

38
00:01:31,680 --> 00:01:35,119
authentication or authorization

39
00:01:35,600 --> 00:01:37,600
and my goals are to give a brief

40
00:01:37,600 --> 00:01:40,640
overview of jwts but assuming some basic

41
00:01:40,640 --> 00:01:42,640
understanding of them and familiarity

42
00:01:42,640 --> 00:01:44,720
and going over obviously the good use

43
00:01:44,720 --> 00:01:47,280
cases or patterns and some potential bad

44
00:01:47,280 --> 00:01:50,960
use cases or anti-patterns

45
00:01:51,439 --> 00:01:53,040
so bear with me if you're already

46
00:01:53,040 --> 00:01:55,040
familiar with this but a quick overview

47
00:01:55,040 --> 00:01:57,600
of jwts

48
00:01:57,600 --> 00:01:59,759
i'll often use the term jot which is the

49
00:01:59,759 --> 00:02:02,399
same as jwt

50
00:02:02,399 --> 00:02:04,719
this my first job where we worked with

51
00:02:04,719 --> 00:02:07,680
jwts i found this really confusing i was

52
00:02:07,680 --> 00:02:08,959
in these meetings and people would be

53
00:02:08,959 --> 00:02:11,280
talking about them and i thought for a

54
00:02:11,280 --> 00:02:13,120
good month that we had two different

55
00:02:13,120 --> 00:02:14,959
types of authentication tokens jots and

56
00:02:14,959 --> 00:02:18,080
jwts but they are in fact

57
00:02:18,080 --> 00:02:19,520
in this context the same thing and of

58
00:02:19,520 --> 00:02:21,680
course it stands for another acronym

59
00:02:21,680 --> 00:02:24,879
json web tokens

60
00:02:26,080 --> 00:02:28,400
this is a screenshot i took from jot.io

61
00:02:28,400 --> 00:02:31,200
which is a useful website when

62
00:02:31,200 --> 00:02:33,120
trying to evangelize shots or when

63
00:02:33,120 --> 00:02:34,720
you're working with them

64
00:02:34,720 --> 00:02:36,400
though i wouldn't paste production data

65
00:02:36,400 --> 00:02:39,360
in strange third-party domains but if

66
00:02:39,360 --> 00:02:41,120
you look at this

67
00:02:41,120 --> 00:02:42,560
color coding is quite useful for

68
00:02:42,560 --> 00:02:45,840
understanding the various parts so a jwt

69
00:02:45,840 --> 00:02:48,480
is made up of three parts the first two

70
00:02:48,480 --> 00:02:52,080
are url base64 json

71
00:02:52,080 --> 00:02:54,959
you can see the header then the payload

72
00:02:54,959 --> 00:02:56,879
and then the signature at the bottom so

73
00:02:56,879 --> 00:02:58,480
the header will

74
00:02:58,480 --> 00:03:02,239
typically include this type or jot

75
00:03:02,239 --> 00:03:04,319
and you can see this is json as implied

76
00:03:04,319 --> 00:03:07,360
in the name so basic sets of like key

77
00:03:07,360 --> 00:03:08,959
value pairs

78
00:03:08,959 --> 00:03:10,720
assigning algorithm which in this case

79
00:03:10,720 --> 00:03:12,879
is hmac sha-256

80
00:03:12,879 --> 00:03:14,480
and then the payload which has these

81
00:03:14,480 --> 00:03:16,480
claims which are really

82
00:03:16,480 --> 00:03:18,159
the most relevant part usually for

83
00:03:18,159 --> 00:03:20,879
developers who are working with these

84
00:03:20,879 --> 00:03:25,200
things like username when it was issued

85
00:03:25,920 --> 00:03:27,680
really anything you theoretically could

86
00:03:27,680 --> 00:03:29,040
include in these

87
00:03:29,040 --> 00:03:30,400
and that's really where the power of

88
00:03:30,400 --> 00:03:32,080
them is coming from in most cases and

89
00:03:32,080 --> 00:03:33,680
then lastly you can see how the

90
00:03:33,680 --> 00:03:35,920
signature is constructed so it takes an

91
00:03:35,920 --> 00:03:38,000
hmac of the

92
00:03:38,000 --> 00:03:39,840
base64 url encoding of the header and

93
00:03:39,840 --> 00:03:41,040
payload

94
00:03:41,040 --> 00:03:44,159
these are delimited by a period and then

95
00:03:44,159 --> 00:03:46,480
you have the secret and that's that last

96
00:03:46,480 --> 00:03:48,480
that blue piece is the

97
00:03:48,480 --> 00:03:50,319
signature and that can be symmetric or

98
00:03:50,319 --> 00:03:52,958
asymmetric

99
00:03:53,280 --> 00:03:54,799
i also wanted to touch on this this is a

100
00:03:54,799 --> 00:03:58,720
screenshot from the rfc for jwts

101
00:03:58,720 --> 00:04:00,000
and i talked a second ago about how

102
00:04:00,000 --> 00:04:01,920
these claims these like

103
00:04:01,920 --> 00:04:03,519
key value pairs

104
00:04:03,519 --> 00:04:05,439
uh there's several that they suggest

105
00:04:05,439 --> 00:04:06,640
they're all optional but several that

106
00:04:06,640 --> 00:04:09,280
they suggest in the rfc so

107
00:04:09,280 --> 00:04:11,280
issuer they're pretty self-explanatory

108
00:04:11,280 --> 00:04:13,519
but you've issuer

109
00:04:13,519 --> 00:04:14,480
subject

110
00:04:14,480 --> 00:04:15,680
so that would be it could be like a

111
00:04:15,680 --> 00:04:16,720
domain

112
00:04:16,720 --> 00:04:20,639
or who the jot is

113
00:04:21,440 --> 00:04:24,160
what domain it might be scoped to

114
00:04:24,160 --> 00:04:26,160
an audience so who

115
00:04:26,160 --> 00:04:28,240
might be intended to actually use the

116
00:04:28,240 --> 00:04:30,720
jot or consume it and this is a lot of

117
00:04:30,720 --> 00:04:32,080
these are most useful when you're

118
00:04:32,080 --> 00:04:34,160
working with

119
00:04:34,160 --> 00:04:36,479
things like federation

120
00:04:36,479 --> 00:04:38,400
you've expiration time

121
00:04:38,400 --> 00:04:39,600
a time

122
00:04:39,600 --> 00:04:41,759
you can specify not before so

123
00:04:41,759 --> 00:04:44,240
in the future or even in the past i

124
00:04:44,240 --> 00:04:46,560
suppose for a token not be valid before

125
00:04:46,560 --> 00:04:47,759
that time

126
00:04:47,759 --> 00:04:49,720
the time it was issued and then a

127
00:04:49,720 --> 00:04:52,560
non-deterministic and unique id for the

128
00:04:52,560 --> 00:04:54,560
jti

129
00:04:54,560 --> 00:04:57,759
and again all optional

130
00:04:57,759 --> 00:04:59,120
so i also wanted to talk a little bit

131
00:04:59,120 --> 00:05:00,960
about terminology to make sure we're on

132
00:05:00,960 --> 00:05:03,680
the same page because i often see people

133
00:05:03,680 --> 00:05:05,199
on the internet debate you know jots

134
00:05:05,199 --> 00:05:06,800
versus cookies

135
00:05:06,800 --> 00:05:08,160
and of course

136
00:05:08,160 --> 00:05:10,000
cookies

137
00:05:10,000 --> 00:05:10,880
in

138
00:05:10,880 --> 00:05:12,720
strictly defined cookies are like an

139
00:05:12,720 --> 00:05:14,960
http cookie so a way to store data in a

140
00:05:14,960 --> 00:05:17,600
web browser adding state to http

141
00:05:17,600 --> 00:05:19,199
but in this jot versus cookies

142
00:05:19,199 --> 00:05:20,320
discussion

143
00:05:20,320 --> 00:05:22,160
people are usually using cookie to refer

144
00:05:22,160 --> 00:05:24,320
to the traditional randomly generated

145
00:05:24,320 --> 00:05:26,639
session key which is often stored in a

146
00:05:26,639 --> 00:05:27,840
cookie but they're not mutually

147
00:05:27,840 --> 00:05:30,799
exclusive with jots

148
00:05:31,120 --> 00:05:32,400
i'm assuming most people here are

149
00:05:32,400 --> 00:05:33,600
relatively familiar with the basics of

150
00:05:33,600 --> 00:05:36,080
cookies

151
00:05:36,320 --> 00:05:38,400
jots we already covered the basics

152
00:05:38,400 --> 00:05:40,080
of what a jot is again they can be

153
00:05:40,080 --> 00:05:41,199
stored in a cookie not mutually

154
00:05:41,199 --> 00:05:43,759
exclusive with that concept

155
00:05:43,759 --> 00:05:45,120
there's also

156
00:05:45,120 --> 00:05:47,280
this term stateless token so jots are a

157
00:05:47,280 --> 00:05:49,600
subset of stateless tokens

158
00:05:49,600 --> 00:05:51,039
there are other implementations

159
00:05:51,039 --> 00:05:53,759
including macaroons and others

160
00:05:53,759 --> 00:05:55,280
i'll touch on a few of these as well

161
00:05:55,280 --> 00:05:57,520
later

162
00:05:59,120 --> 00:06:00,720
in service side session i just mentioned

163
00:06:00,720 --> 00:06:02,880
these so this is where you have like a

164
00:06:02,880 --> 00:06:06,080
random identifier hopefully 16 or 32

165
00:06:06,080 --> 00:06:07,680
bites long

166
00:06:07,680 --> 00:06:09,120
this is your traditional idea of like a

167
00:06:09,120 --> 00:06:11,840
session token

168
00:06:12,479 --> 00:06:14,720
i also have this cookie recipe another

169
00:06:14,720 --> 00:06:16,639
type of cookie from

170
00:06:16,639 --> 00:06:18,080
clifford stoles the cuckoo's egg

171
00:06:18,080 --> 00:06:19,840
excellent book if you haven't read it

172
00:06:19,840 --> 00:06:22,240
excellent cookie recipe as well i prefer

173
00:06:22,240 --> 00:06:24,639
to brown the butter kind of a

174
00:06:24,639 --> 00:06:26,240
intermediate technique to up your cookie

175
00:06:26,240 --> 00:06:29,840
game but another type of cookie

176
00:06:29,840 --> 00:06:31,680
and then i also wanted to talk about

177
00:06:31,680 --> 00:06:33,520
where you might encounter jots as a

178
00:06:33,520 --> 00:06:37,520
developer or as a security engineer

179
00:06:37,840 --> 00:06:39,600
so

180
00:06:39,600 --> 00:06:41,039
there's a few

181
00:06:41,039 --> 00:06:42,560
areas so one would be this like session

182
00:06:42,560 --> 00:06:45,520
token example so web applications or

183
00:06:45,520 --> 00:06:48,400
mobile applications api tokens

184
00:06:48,400 --> 00:06:51,440
you have standards like oauth and oidc

185
00:06:51,440 --> 00:06:53,840
that can make use of dots and then

186
00:06:53,840 --> 00:06:55,759
service to service authentication so

187
00:06:55,759 --> 00:06:58,000
either inside a network or between

188
00:06:58,000 --> 00:07:00,800
multiple networks

189
00:07:01,280 --> 00:07:03,759
uh and then i also wanted to discuss why

190
00:07:03,759 --> 00:07:05,440
people use jots i don't necessarily

191
00:07:05,440 --> 00:07:07,120
endorse all these these are arguments in

192
00:07:07,120 --> 00:07:09,280
favor of jots but particularly as

193
00:07:09,280 --> 00:07:11,039
security engineers will come across

194
00:07:11,039 --> 00:07:13,440
these and it's good to understand what

195
00:07:13,440 --> 00:07:15,680
people were thinking at the time

196
00:07:15,680 --> 00:07:18,960
so firstly is this stateless idea

197
00:07:18,960 --> 00:07:20,560
databases

198
00:07:20,560 --> 00:07:22,479
can be expensive making a call to a

199
00:07:22,479 --> 00:07:24,080
database on every request is something

200
00:07:24,080 --> 00:07:26,639
that developers like to avoid

201
00:07:26,639 --> 00:07:28,560
and the idea with the stateless token is

202
00:07:28,560 --> 00:07:30,720
instead of having a session token you

203
00:07:30,720 --> 00:07:32,080
store on a db

204
00:07:32,080 --> 00:07:33,360
and that you need to check on every

205
00:07:33,360 --> 00:07:35,360
request you can replace them with

206
00:07:35,360 --> 00:07:37,120
stateless tokens

207
00:07:37,120 --> 00:07:39,520
so you sign the token you issue it and

208
00:07:39,520 --> 00:07:41,520
then you can use that instead and you

209
00:07:41,520 --> 00:07:43,120
don't have to make checks against the db

210
00:07:43,120 --> 00:07:45,599
anymore

211
00:07:45,599 --> 00:07:48,160
another reason that people often use

212
00:07:48,160 --> 00:07:51,680
gdps is the service to service auth so

213
00:07:51,680 --> 00:07:53,199
service to service auth is in my

214
00:07:53,199 --> 00:07:55,599
experience very hard there's no silver

215
00:07:55,599 --> 00:07:57,599
bullet i'm aware of that

216
00:07:57,599 --> 00:07:59,280
has no downsides and perfectly solves

217
00:07:59,280 --> 00:08:01,599
the problem but there's a lot of appeal

218
00:08:01,599 --> 00:08:03,840
to using something a stateless token and

219
00:08:03,840 --> 00:08:05,919
in particular a jot

220
00:08:05,919 --> 00:08:07,759
in that if you're already using it as a

221
00:08:07,759 --> 00:08:09,680
session token you can continue to pass

222
00:08:09,680 --> 00:08:11,520
that around from microservice to

223
00:08:11,520 --> 00:08:12,960
microservice

224
00:08:12,960 --> 00:08:14,800
or you can sign requests as they come

225
00:08:14,800 --> 00:08:16,400
into your network some sort of off

226
00:08:16,400 --> 00:08:17,759
service

227
00:08:17,759 --> 00:08:19,759
and then have that be validated with a

228
00:08:19,759 --> 00:08:22,560
shared key that the microservices have

229
00:08:22,560 --> 00:08:23,919
i'm going to talk a little bit more

230
00:08:23,919 --> 00:08:27,280
about this in depth later on

231
00:08:27,280 --> 00:08:29,199
also it's really popular so here's a

232
00:08:29,199 --> 00:08:33,440
tweet i just found a hashtag jwt hashtag

233
00:08:33,440 --> 00:08:34,640
web dev

234
00:08:34,640 --> 00:08:36,479
obviously jots are cool this tweet is 41

235
00:08:36,479 --> 00:08:38,880
likes so it must be good also as

236
00:08:38,880 --> 00:08:41,519
developers know if you just smoosh https

237
00:08:41,519 --> 00:08:43,279
hmac and asymmetric keys together it's

238
00:08:43,279 --> 00:08:45,200
super secure because

239
00:08:45,200 --> 00:08:46,560
i don't know there's a lot of crypto

240
00:08:46,560 --> 00:08:49,920
awards in there so it must be good

241
00:08:50,640 --> 00:08:52,480
uh and then also as a security engineer

242
00:08:52,480 --> 00:08:53,519
this is probably the big reason you'll

243
00:08:53,519 --> 00:08:55,440
encounter jobs they're already there you

244
00:08:55,440 --> 00:08:57,680
might do a security review

245
00:08:57,680 --> 00:08:59,680
you might join a new company and they're

246
00:08:59,680 --> 00:09:01,440
using jots maybe you don't have the

247
00:09:01,440 --> 00:09:03,920
political capital the time the developer

248
00:09:03,920 --> 00:09:07,120
resources to remove them fix them but

249
00:09:07,120 --> 00:09:09,120
still want to discuss ways to improve

250
00:09:09,120 --> 00:09:11,200
them potentially

251
00:09:11,200 --> 00:09:12,800
all right so why do people dislike

252
00:09:12,800 --> 00:09:14,800
droughts why might you or someone else

253
00:09:14,800 --> 00:09:17,519
not use them if they're so great

254
00:09:17,519 --> 00:09:21,120
so first of all my obligatory hackerman

255
00:09:21,120 --> 00:09:22,720
art that you have to include in all

256
00:09:22,720 --> 00:09:25,040
conference presentations so revocation

257
00:09:25,040 --> 00:09:26,880
is a hard problem with stateless tokens

258
00:09:26,880 --> 00:09:27,920
because

259
00:09:27,920 --> 00:09:29,360
if they're purely stateless then

260
00:09:29,360 --> 00:09:31,519
essentially it's impossible to revoke

261
00:09:31,519 --> 00:09:32,800
them because

262
00:09:32,800 --> 00:09:35,839
without removing the signing key

263
00:09:35,839 --> 00:09:37,200
otherwise we'll need to introduce state

264
00:09:37,200 --> 00:09:38,560
in some way and i'm going to talk about

265
00:09:38,560 --> 00:09:41,200
like good and bad ways to do that but

266
00:09:41,200 --> 00:09:45,440
revocation is is a difficult problem

267
00:09:46,959 --> 00:09:49,200
also hacker news doesn't like jots and

268
00:09:49,200 --> 00:09:50,720
so if you tell them you use them you'll

269
00:09:50,720 --> 00:09:52,000
get flamed

270
00:09:52,000 --> 00:09:52,959
um

271
00:09:52,959 --> 00:09:54,720
i don't know if you care about that but

272
00:09:54,720 --> 00:09:56,720
it is a potential downside

273
00:09:56,720 --> 00:09:58,560
also cryptographers don't really like

274
00:09:58,560 --> 00:10:00,160
jwts so

275
00:10:00,160 --> 00:10:01,680
just if you do use them i guess be

276
00:10:01,680 --> 00:10:05,239
careful who you tell

277
00:10:06,240 --> 00:10:08,079
this is just a crude example that i

278
00:10:08,079 --> 00:10:10,079
wrote out of illustrating some of the

279
00:10:10,079 --> 00:10:12,800
potential foot guns that come with jwts

280
00:10:12,800 --> 00:10:13,600
so

281
00:10:13,600 --> 00:10:15,760
by design the specification is very

282
00:10:15,760 --> 00:10:17,360
flexible

283
00:10:17,360 --> 00:10:18,720
i mentioned earlier i talked about the

284
00:10:18,720 --> 00:10:21,200
header where you have this type jot

285
00:10:21,200 --> 00:10:22,399
and then you can specify your signing

286
00:10:22,399 --> 00:10:24,800
algorithm so in the first line we have

287
00:10:24,800 --> 00:10:27,839
an hmac shot 256 great symmetric

288
00:10:27,839 --> 00:10:30,160
we have an rs256

289
00:10:30,160 --> 00:10:34,000
rs8256 i mean you know fine good enough

290
00:10:34,000 --> 00:10:35,279
and then lastly you can specify

291
00:10:35,279 --> 00:10:36,720
algorithm none and this is something

292
00:10:36,720 --> 00:10:38,160
that the spec supports if you're

293
00:10:38,160 --> 00:10:40,240
familiar with jots you may be familiar

294
00:10:40,240 --> 00:10:42,640
with these types of attacks but this is

295
00:10:42,640 --> 00:10:44,800
actually supported you also could just

296
00:10:44,800 --> 00:10:47,040
leave out the algorithm field

297
00:10:47,040 --> 00:10:48,880
and for those who aren't familiar what

298
00:10:48,880 --> 00:10:50,399
this has enabled

299
00:10:50,399 --> 00:10:54,160
fairly often is these attacks where

300
00:10:54,160 --> 00:10:56,320
an attacker can simply

301
00:10:56,320 --> 00:10:58,720
design their own jot specify out none

302
00:10:58,720 --> 00:11:00,160
and then send it to your back end and

303
00:11:00,160 --> 00:11:02,079
then your jot library will say oh that's

304
00:11:02,079 --> 00:11:03,519
fine then because there's no signing

305
00:11:03,519 --> 00:11:05,920
needed it says algorithm none

306
00:11:05,920 --> 00:11:07,360
and then it will let you have like admin

307
00:11:07,360 --> 00:11:09,360
permissions or whatever you want and

308
00:11:09,360 --> 00:11:11,600
while this is a known issue it is also

309
00:11:11,600 --> 00:11:14,160
an issue that has been patched but it is

310
00:11:14,160 --> 00:11:15,680
a recurring theme and something that i

311
00:11:15,680 --> 00:11:17,040
wanted to highlight

312
00:11:17,040 --> 00:11:19,200
in that the specific the flexibility of

313
00:11:19,200 --> 00:11:20,800
the specification

314
00:11:20,800 --> 00:11:23,519
can bite you

315
00:11:24,480 --> 00:11:26,800
it's also in the same vein trying to be

316
00:11:26,800 --> 00:11:28,640
everything to everybody

317
00:11:28,640 --> 00:11:30,320
it's a very

318
00:11:30,320 --> 00:11:32,640
oh and complexity is relative but

319
00:11:32,640 --> 00:11:34,399
there's a lot going on if you read the

320
00:11:34,399 --> 00:11:36,079
rfc and a lot of the uses and

321
00:11:36,079 --> 00:11:38,320
implementations so having a swiss army

322
00:11:38,320 --> 00:11:40,800
knife in security can be a bad thing

323
00:11:40,800 --> 00:11:43,800
sometimes

324
00:11:44,079 --> 00:11:47,680
so again tread carefully

325
00:11:48,320 --> 00:11:50,079
all right so diving into some of the

326
00:11:50,079 --> 00:11:51,200
specific

327
00:11:51,200 --> 00:11:54,800
as advertised anti-patterns and patterns

328
00:11:54,800 --> 00:11:57,200
so this is probably controversial

329
00:11:57,200 --> 00:11:59,519
to some of you but i think that job says

330
00:11:59,519 --> 00:12:00,480
sessions

331
00:12:00,480 --> 00:12:03,680
is a pattern to be avoided if possible

332
00:12:03,680 --> 00:12:05,519
there are ways to put safety rails

333
00:12:05,519 --> 00:12:07,519
around things to do revocation in a

334
00:12:07,519 --> 00:12:09,839
better way that i'll discuss in a minute

335
00:12:09,839 --> 00:12:12,160
but it's really not the exact situation

336
00:12:12,160 --> 00:12:14,480
they were designed for and it's where

337
00:12:14,480 --> 00:12:16,720
you get a lot of these

338
00:12:16,720 --> 00:12:18,000
you have to start putting up a lot of

339
00:12:18,000 --> 00:12:19,519
the guardrails where

340
00:12:19,519 --> 00:12:21,040
for a lot of use cases it would have

341
00:12:21,040 --> 00:12:22,320
been easier to just go with something

342
00:12:22,320 --> 00:12:25,320
simpler

343
00:12:26,480 --> 00:12:28,560
also including secrets and claims this

344
00:12:28,560 --> 00:12:31,600
is a common relatively common issue

345
00:12:31,600 --> 00:12:33,120
where as you can see i've constructed

346
00:12:33,120 --> 00:12:35,440
some json here where i've decided to

347
00:12:35,440 --> 00:12:38,160
include the sign-in key the user social

348
00:12:38,160 --> 00:12:40,079
security number

349
00:12:40,079 --> 00:12:43,839
this i think comes from the fact that

350
00:12:43,839 --> 00:12:45,200
jots look

351
00:12:45,200 --> 00:12:47,279
encrypted if you don't really know about

352
00:12:47,279 --> 00:12:49,920
encoding or the difference between a mac

353
00:12:49,920 --> 00:12:52,079
and like encryption and so developers

354
00:12:52,079 --> 00:12:54,320
who aren't as familiar will just see

355
00:12:54,320 --> 00:12:56,079
something that's base64 encoded and

356
00:12:56,079 --> 00:12:57,600
think oh it's encrypted so i can just

357
00:12:57,600 --> 00:12:59,600
pass this to the user side or anyone who

358
00:12:59,600 --> 00:13:02,079
wants it

359
00:13:02,079 --> 00:13:04,480
the you can actually encrypt jots but

360
00:13:04,480 --> 00:13:06,639
generally speaking information like this

361
00:13:06,639 --> 00:13:07,920
you wouldn't want to pass to the client

362
00:13:07,920 --> 00:13:10,160
side

363
00:13:12,959 --> 00:13:14,800
also this i know is a debate in and of

364
00:13:14,800 --> 00:13:16,800
itself but this is something i've seen

365
00:13:16,800 --> 00:13:18,399
particularly with jots for some reason

366
00:13:18,399 --> 00:13:20,720
there's a propensity to store them

367
00:13:20,720 --> 00:13:22,880
when used as session tokens in local

368
00:13:22,880 --> 00:13:24,959
storage as opposed to in a cookie

369
00:13:24,959 --> 00:13:27,680
so this removes and again i'm happy to

370
00:13:27,680 --> 00:13:29,600
talk about folks uh happy to talk to

371
00:13:29,600 --> 00:13:30,959
folks about this afterwards i know

372
00:13:30,959 --> 00:13:32,880
there's some nuance here but generally

373
00:13:32,880 --> 00:13:34,880
speaking you're removing some potential

374
00:13:34,880 --> 00:13:37,040
xss protections like same site on your

375
00:13:37,040 --> 00:13:38,639
cookies

376
00:13:38,639 --> 00:13:40,399
and

377
00:13:40,399 --> 00:13:42,320
incidentally adding csrf protection

378
00:13:42,320 --> 00:13:43,680
because the browser won't automatically

379
00:13:43,680 --> 00:13:45,680
attach them from local storage but

380
00:13:45,680 --> 00:13:47,120
again for some reason people really like

381
00:13:47,120 --> 00:13:49,120
to put jots in local storage so if you

382
00:13:49,120 --> 00:13:50,720
think it's like to be avoided it should

383
00:13:50,720 --> 00:13:54,560
be especially looked at for with jwts

384
00:13:54,800 --> 00:13:56,320
and then also attaching them with

385
00:13:56,320 --> 00:13:57,680
javascript this is something i've seen

386
00:13:57,680 --> 00:13:59,760
in production before so

387
00:13:59,760 --> 00:14:01,839
same type of thing but can also happen

388
00:14:01,839 --> 00:14:03,680
with cookies where

389
00:14:03,680 --> 00:14:04,959
we have our

390
00:14:04,959 --> 00:14:06,720
jwt

391
00:14:06,720 --> 00:14:08,320
it's signed it's great it has all sorts

392
00:14:08,320 --> 00:14:10,160
of information in it

393
00:14:10,160 --> 00:14:11,839
and then i construct my header on the

394
00:14:11,839 --> 00:14:13,760
client side in javascript to send along

395
00:14:13,760 --> 00:14:16,240
with my request and i'll manually create

396
00:14:16,240 --> 00:14:17,920
this authorization

397
00:14:17,920 --> 00:14:18,959
header

398
00:14:18,959 --> 00:14:21,600
and specify the jwt and stick the auth

399
00:14:21,600 --> 00:14:23,360
cookie on and it's the same sort of risk

400
00:14:23,360 --> 00:14:26,000
here of you're having to allow your

401
00:14:26,000 --> 00:14:27,920
tokens to be accessible to javascript

402
00:14:27,920 --> 00:14:29,760
and therefore having to disable things

403
00:14:29,760 --> 00:14:31,040
like

404
00:14:31,040 --> 00:14:34,319
http only protections

405
00:14:36,800 --> 00:14:39,279
another one that's very jot specific is

406
00:14:39,279 --> 00:14:41,279
weak hmac secrets so if you're going

407
00:14:41,279 --> 00:14:43,920
down the symmetric route

408
00:14:43,920 --> 00:14:46,000
it's important to choose good secrets

409
00:14:46,000 --> 00:14:49,440
and for signing so it should be 32 bytes

410
00:14:49,440 --> 00:14:51,199
you don't want them to be human readable

411
00:14:51,199 --> 00:14:53,680
like a password and definitely don't

412
00:14:53,680 --> 00:14:55,199
reuse them from somewhere else in the

413
00:14:55,199 --> 00:14:57,760
infra and obviously don't mix your

414
00:14:57,760 --> 00:14:58,959
non-product credentials with your

415
00:14:58,959 --> 00:15:01,680
product credentials

416
00:15:04,320 --> 00:15:06,160
all right this is another one i've seen

417
00:15:06,160 --> 00:15:08,160
a lot on the internet or even in

418
00:15:08,160 --> 00:15:11,760
production is this no revocation idea

419
00:15:11,760 --> 00:15:13,680
so the idea is that we have these

420
00:15:13,680 --> 00:15:15,440
stateless tokens

421
00:15:15,440 --> 00:15:17,760
but they only live for 15 minutes so

422
00:15:17,760 --> 00:15:19,199
no one will ever hack us and then be

423
00:15:19,199 --> 00:15:20,560
able to use them within 15 minutes it's

424
00:15:20,560 --> 00:15:24,000
impossible or

425
00:15:24,000 --> 00:15:25,519
our scale means that it won't matter

426
00:15:25,519 --> 00:15:27,360
because we're too big or we're too small

427
00:15:27,360 --> 00:15:29,600
but having the inability to revoke

428
00:15:29,600 --> 00:15:31,920
tokens for a user account for an

429
00:15:31,920 --> 00:15:33,759
individual token

430
00:15:33,759 --> 00:15:35,279
can potentially increase the scope of

431
00:15:35,279 --> 00:15:38,079
things like vulnerability xss

432
00:15:38,079 --> 00:15:40,480
phishing taking over you know atos

433
00:15:40,480 --> 00:15:42,639
things like that

434
00:15:42,639 --> 00:15:45,120
especially for consumer applications

435
00:15:45,120 --> 00:15:46,959
it's yeah it's really useful to be able

436
00:15:46,959 --> 00:15:47,759
to

437
00:15:47,759 --> 00:15:49,440
target individual accounts or even

438
00:15:49,440 --> 00:15:50,880
individual sessions

439
00:15:50,880 --> 00:15:51,839
and

440
00:15:51,839 --> 00:15:53,360
end that session without having to

441
00:15:53,360 --> 00:15:54,959
rotate an entire signing key and

442
00:15:54,959 --> 00:15:56,800
validating everyone's session usually

443
00:15:56,800 --> 00:15:59,199
that's bad for growth metrics and things

444
00:15:59,199 --> 00:16:01,279
that executives care about

445
00:16:01,279 --> 00:16:03,199
i think it's also obviously potentially

446
00:16:03,199 --> 00:16:07,479
important for for b2b as well

447
00:16:08,880 --> 00:16:10,720
um in the same

448
00:16:10,720 --> 00:16:13,839
vein you have no expiration so this

449
00:16:13,839 --> 00:16:15,440
i've seen too with regular session

450
00:16:15,440 --> 00:16:17,199
tokens but

451
00:16:17,199 --> 00:16:19,600
it's if you have a

452
00:16:19,600 --> 00:16:21,360
an application consumer-facing

453
00:16:21,360 --> 00:16:22,880
application maybe it allows you to order

454
00:16:22,880 --> 00:16:25,199
widgets on the widget store it's bad to

455
00:16:25,199 --> 00:16:26,959
make users have to sign in because users

456
00:16:26,959 --> 00:16:28,959
forget their password so if we just

457
00:16:28,959 --> 00:16:31,759
never make them sign in ever again then

458
00:16:31,759 --> 00:16:33,600
that's good we'll make more money

459
00:16:33,600 --> 00:16:35,279
it's hard to argue against that but from

460
00:16:35,279 --> 00:16:37,199
a security perspective

461
00:16:37,199 --> 00:16:39,680
it's less than ideal to have

462
00:16:39,680 --> 00:16:42,240
infinitely lived tokens and

463
00:16:42,240 --> 00:16:44,800
in jobs it's as easy as not implementing

464
00:16:44,800 --> 00:16:48,720
an expiration field or a claim so it's

465
00:16:48,720 --> 00:16:52,639
often overlooked or purposely excluded

466
00:16:55,040 --> 00:16:56,880
this one as well

467
00:16:56,880 --> 00:16:58,560
i'm going to touch back on this in a

468
00:16:58,560 --> 00:17:00,320
second in the pattern section but i

469
00:17:00,320 --> 00:17:02,079
think it's an anti-pattern for jots to

470
00:17:02,079 --> 00:17:04,799
have a revocation database

471
00:17:04,799 --> 00:17:06,640
so the idea here is that okay we have

472
00:17:06,640 --> 00:17:09,119
people who log out we have atos

473
00:17:09,119 --> 00:17:10,319
we have

474
00:17:10,319 --> 00:17:12,160
deleted accounts we want to invalidate

475
00:17:12,160 --> 00:17:14,000
their sessions so we'll create a table

476
00:17:14,000 --> 00:17:15,039
on the db

477
00:17:15,039 --> 00:17:16,480
we'll stick the jot in there or maybe

478
00:17:16,480 --> 00:17:18,559
just the jot id

479
00:17:18,559 --> 00:17:21,280
and then when we get a request we'll go

480
00:17:21,280 --> 00:17:23,520
check that database on every request and

481
00:17:23,520 --> 00:17:25,439
see if this jot or jaw id is in the

482
00:17:25,439 --> 00:17:26,319
table

483
00:17:26,319 --> 00:17:28,480
and you saw the revocation problem but

484
00:17:28,480 --> 00:17:29,760
you've really

485
00:17:29,760 --> 00:17:32,240
gone back to

486
00:17:32,240 --> 00:17:33,520
the most primitive way to do like

487
00:17:33,520 --> 00:17:34,720
session tokens at that point you're

488
00:17:34,720 --> 00:17:36,000
having to make expensive database

489
00:17:36,000 --> 00:17:38,880
requests on every request to your your

490
00:17:38,880 --> 00:17:40,799
back ends

491
00:17:40,799 --> 00:17:43,600
you have this table that if it goes down

492
00:17:43,600 --> 00:17:45,520
i guess it's good in that you could keep

493
00:17:45,520 --> 00:17:47,039
serving requests but you could be

494
00:17:47,039 --> 00:17:50,879
serving requests to malicious users

495
00:17:51,120 --> 00:17:52,640
you could also keep this table from

496
00:17:52,640 --> 00:17:54,240
getting too big so that is an advantage

497
00:17:54,240 --> 00:17:55,760
over like a regular session table it

498
00:17:55,760 --> 00:17:58,400
won't get gigantic as quickly if you're

499
00:17:58,400 --> 00:18:00,320
a fast growing startup for example

500
00:18:00,320 --> 00:18:02,480
because the number of remote tokens

501
00:18:02,480 --> 00:18:03,840
should be a lot smaller than all

502
00:18:03,840 --> 00:18:05,679
existing tokens and you could create a

503
00:18:05,679 --> 00:18:07,440
cron job to clean it up when your tokens

504
00:18:07,440 --> 00:18:10,080
expire anyway but again you're kind of

505
00:18:10,080 --> 00:18:11,600
back to square one in terms of

506
00:18:11,600 --> 00:18:13,039
statefulness

507
00:18:13,039 --> 00:18:14,799
and added latency for authorization

508
00:18:14,799 --> 00:18:17,440
authentication

509
00:18:18,240 --> 00:18:20,080
this one i think is also could be

510
00:18:20,080 --> 00:18:22,080
controversial there's a number of

511
00:18:22,080 --> 00:18:23,760
well-vetted schemes by people smarter

512
00:18:23,760 --> 00:18:25,600
than me that use refresh access token

513
00:18:25,600 --> 00:18:26,720
pattern

514
00:18:26,720 --> 00:18:28,400
i'm referring more to it in the sense of

515
00:18:28,400 --> 00:18:30,160
rolling your own refresh access token

516
00:18:30,160 --> 00:18:31,600
scheme

517
00:18:31,600 --> 00:18:34,320
uh first of all it's complex

518
00:18:34,320 --> 00:18:35,360
and i'm skeptical of some of the

519
00:18:35,360 --> 00:18:36,480
benefits

520
00:18:36,480 --> 00:18:38,400
if you're unfamiliar and again this is

521
00:18:38,400 --> 00:18:40,799
referring less to like a specific

522
00:18:40,799 --> 00:18:42,880
implementation or standard and more to

523
00:18:42,880 --> 00:18:44,640
ways i've seen it

524
00:18:44,640 --> 00:18:45,760
homegrown

525
00:18:45,760 --> 00:18:46,559
but

526
00:18:46,559 --> 00:18:48,160
the idea is that instead of issuing a

527
00:18:48,160 --> 00:18:50,799
single token like your session token

528
00:18:50,799 --> 00:18:53,360
or your jot as a session token or as an

529
00:18:53,360 --> 00:18:54,640
api token

530
00:18:54,640 --> 00:18:55,440
you

531
00:18:55,440 --> 00:18:57,039
issue two tokens

532
00:18:57,039 --> 00:18:59,360
so one is an access token which is like

533
00:18:59,360 --> 00:19:01,679
your normal token it's attached to

534
00:19:01,679 --> 00:19:03,120
requests

535
00:19:03,120 --> 00:19:05,840
and you use it to access the api it's

536
00:19:05,840 --> 00:19:10,240
typically short lived um

537
00:19:10,240 --> 00:19:11,919
and it's sent over the wire more often

538
00:19:11,919 --> 00:19:13,600
because you're making these requests to

539
00:19:13,600 --> 00:19:15,840
order widgets or update your password

540
00:19:15,840 --> 00:19:17,760
then you have the refresh token it's

541
00:19:17,760 --> 00:19:20,480
longer lived and it's only used to hit a

542
00:19:20,480 --> 00:19:22,640
dedicated endpoint to get new access

543
00:19:22,640 --> 00:19:25,520
tokens i've seen people argue for this

544
00:19:25,520 --> 00:19:26,799
in a few different

545
00:19:26,799 --> 00:19:29,200
ways one being that oh well we don't

546
00:19:29,200 --> 00:19:30,799
send the access token over the wires

547
00:19:30,799 --> 00:19:32,320
often so

548
00:19:32,320 --> 00:19:34,480
if someone has like a man-middle attack

549
00:19:34,480 --> 00:19:36,400
then it's unlikely to be able to steal

550
00:19:36,400 --> 00:19:38,640
the refresh token or it's less likely i

551
00:19:38,640 --> 00:19:40,080
don't doesn't really fit with my threat

552
00:19:40,080 --> 00:19:42,400
model with like tls

553
00:19:42,400 --> 00:19:43,679
and how man in the middle attacks might

554
00:19:43,679 --> 00:19:44,720
work in

555
00:19:44,720 --> 00:19:46,720
2021.

556
00:19:46,720 --> 00:19:48,240
additionally

557
00:19:48,240 --> 00:19:49,760
um

558
00:19:49,760 --> 00:19:51,039
you know i've seen it like we can lock

559
00:19:51,039 --> 00:19:52,960
down the refresh token more

560
00:19:52,960 --> 00:19:54,320
again for like web applications and

561
00:19:54,320 --> 00:19:56,080
things like that i just haven't really

562
00:19:56,080 --> 00:19:57,600
seen a convincing argument for that in

563
00:19:57,600 --> 00:19:59,520
my opinion so i would consider an

564
00:19:59,520 --> 00:20:03,360
anti-pattern to add this complexity

565
00:20:04,480 --> 00:20:05,840
another interesting thing i've

566
00:20:05,840 --> 00:20:08,000
encountered is having like fragile

567
00:20:08,000 --> 00:20:09,039
built-in

568
00:20:09,039 --> 00:20:11,600
key rotation in your back end so

569
00:20:11,600 --> 00:20:13,760
uh to rotate a key with a stateless

570
00:20:13,760 --> 00:20:16,240
token like jot it's painful because all

571
00:20:16,240 --> 00:20:17,919
the tokens you've issued will be

572
00:20:17,919 --> 00:20:20,080
invalidated

573
00:20:20,080 --> 00:20:23,520
a scheme that i've seen to mitigate this

574
00:20:23,520 --> 00:20:25,520
is having a bunch of keys

575
00:20:25,520 --> 00:20:27,840
so it could look something like

576
00:20:27,840 --> 00:20:30,960
you have this key generation service

577
00:20:30,960 --> 00:20:32,080
it

578
00:20:32,080 --> 00:20:34,799
every week let's say it makes a new key

579
00:20:34,799 --> 00:20:36,960
and then your service that validates

580
00:20:36,960 --> 00:20:38,159
jots

581
00:20:38,159 --> 00:20:40,960
it has a whole set of valid sign-in keys

582
00:20:40,960 --> 00:20:43,520
and then every 90 days the oldest one it

583
00:20:43,520 --> 00:20:44,400
kills

584
00:20:44,400 --> 00:20:45,200
so

585
00:20:45,200 --> 00:20:47,039
this allows you to limit the blast

586
00:20:47,039 --> 00:20:49,600
radius if you need to kill a sign-in key

587
00:20:49,600 --> 00:20:51,200
for some reason

588
00:20:51,200 --> 00:20:52,000
but

589
00:20:52,000 --> 00:20:53,280
it's hard for me to think of a threat

590
00:20:53,280 --> 00:20:54,799
model in which

591
00:20:54,799 --> 00:20:56,559
you need to invalidate a single sign-in

592
00:20:56,559 --> 00:20:58,159
key like one signing key is compromised

593
00:20:58,159 --> 00:21:00,240
but the rest aren't so you've added on

594
00:21:00,240 --> 00:21:03,200
this complexity that may potentially

595
00:21:03,200 --> 00:21:04,159
open you up to some sort of

596
00:21:04,159 --> 00:21:06,480
vulnerability with in my opinion a

597
00:21:06,480 --> 00:21:10,640
pretty little amount of security gain

598
00:21:11,840 --> 00:21:14,880
another interesting anti-pattern is just

599
00:21:14,880 --> 00:21:17,120
creating fully stable jots so

600
00:21:17,120 --> 00:21:18,799
you buy into jots

601
00:21:18,799 --> 00:21:21,440
you issue them you sign them but

602
00:21:21,440 --> 00:21:22,960
you really get rid of the idea of

603
00:21:22,960 --> 00:21:24,480
statelessness you just take a jot and

604
00:21:24,480 --> 00:21:26,400
you put in your database and on every

605
00:21:26,400 --> 00:21:27,919
request you go check the database and

606
00:21:27,919 --> 00:21:30,559
see if the jot is in the db at that

607
00:21:30,559 --> 00:21:31,919
point you've eliminated a lot of the

608
00:21:31,919 --> 00:21:34,000
potential benefits and you're still

609
00:21:34,000 --> 00:21:35,520
accepting potentially the risks that

610
00:21:35,520 --> 00:21:38,400
come with using a somewhat complex token

611
00:21:38,400 --> 00:21:41,120
type like a jot

612
00:21:42,159 --> 00:21:43,280
additionally

613
00:21:43,280 --> 00:21:44,960
i've seen multiple overlapping

614
00:21:44,960 --> 00:21:46,799
implementations so

615
00:21:46,799 --> 00:21:48,799
obviously with api versioning this can

616
00:21:48,799 --> 00:21:50,880
be done correctly where maybe you're

617
00:21:50,880 --> 00:21:52,960
moving two jots maybe moving off of jots

618
00:21:52,960 --> 00:21:54,320
you increment your version number for

619
00:21:54,320 --> 00:21:56,799
your api and then

620
00:21:56,799 --> 00:21:58,720
your router and code will know how to

621
00:21:58,720 --> 00:22:01,200
handle those different situations

622
00:22:01,200 --> 00:22:02,400
however

623
00:22:02,400 --> 00:22:04,400
in this situation i'm referring to

624
00:22:04,400 --> 00:22:06,240
the same version could accept multiple

625
00:22:06,240 --> 00:22:08,159
types of tokens so it'll accept a

626
00:22:08,159 --> 00:22:10,240
session token and a cookie

627
00:22:10,240 --> 00:22:13,520
a jot a refresh access token pair

628
00:22:13,520 --> 00:22:14,799
i think this is one of those patterns

629
00:22:14,799 --> 00:22:16,960
that goes beyond jwts but

630
00:22:16,960 --> 00:22:19,120
the whole appeal at one point and now

631
00:22:19,120 --> 00:22:20,960
maybe fading popularity i think has led

632
00:22:20,960 --> 00:22:22,559
to this more

633
00:22:22,559 --> 00:22:24,799
and it's not hard to imagine weird and

634
00:22:24,799 --> 00:22:27,600
hard to find vulnerabilities that could

635
00:22:27,600 --> 00:22:29,280
emerge from accepting multiple types of

636
00:22:29,280 --> 00:22:31,120
tokens and authorization for the same

637
00:22:31,120 --> 00:22:33,678
endpoints

638
00:22:34,240 --> 00:22:35,600
all right so i also want to talk about

639
00:22:35,600 --> 00:22:37,440
ways you might improve jots or use them

640
00:22:37,440 --> 00:22:40,600
more safely

641
00:22:42,640 --> 00:22:44,799
this is a brief aside just talking about

642
00:22:44,799 --> 00:22:46,799
service to service off to set up the

643
00:22:46,799 --> 00:22:49,280
stage so this is my crew diagram of like

644
00:22:49,280 --> 00:22:51,440
your classic auction service

645
00:22:51,440 --> 00:22:54,480
we have the internet a load balancer

646
00:22:54,480 --> 00:22:56,720
this like router microservice

647
00:22:56,720 --> 00:22:58,799
and a few other microservices these

648
00:22:58,799 --> 00:23:01,360
services can talk to other internal

649
00:23:01,360 --> 00:23:03,840
services and some databases but there's

650
00:23:03,840 --> 00:23:06,159
no service to service off instead we're

651
00:23:06,159 --> 00:23:08,400
relying on network connectivity rules

652
00:23:08,400 --> 00:23:10,000
and maybe database credentials for the

653
00:23:10,000 --> 00:23:11,919
dbs of course

654
00:23:11,919 --> 00:23:13,440
there's a technically like a perimeter

655
00:23:13,440 --> 00:23:15,039
around here with security groups or

656
00:23:15,039 --> 00:23:17,039
something similar so nothing in the

657
00:23:17,039 --> 00:23:18,640
outside world should be able to

658
00:23:18,640 --> 00:23:20,799
communicate except through our our

659
00:23:20,799 --> 00:23:24,159
firewall and our battery service

660
00:23:24,159 --> 00:23:26,000
and this is really the most common i

661
00:23:26,000 --> 00:23:27,840
think approach to service service auth

662
00:23:27,840 --> 00:23:29,760
is to simply not implement it

663
00:23:29,760 --> 00:23:33,440
it's certainly the least complex and it

664
00:23:33,440 --> 00:23:34,480
can

665
00:23:34,480 --> 00:23:36,320
be sufficient depending on your threat

666
00:23:36,320 --> 00:23:38,159
model and where you need to spend your

667
00:23:38,159 --> 00:23:40,480
resources

668
00:23:40,480 --> 00:23:43,039
so this is a simple illustration of how

669
00:23:43,039 --> 00:23:45,440
someone might add like bear tokens to

670
00:23:45,440 --> 00:23:46,799
this so as you can see i've just

671
00:23:46,799 --> 00:23:48,480
overlaid some like

672
00:23:48,480 --> 00:23:51,200
two short tokens um the idea is that

673
00:23:51,200 --> 00:23:52,799
there's a bearer token attached to every

674
00:23:52,799 --> 00:23:53,919
request

675
00:23:53,919 --> 00:23:55,039
um

676
00:23:55,039 --> 00:23:57,279
the when a quest comes to the network

677
00:23:57,279 --> 00:23:58,159
then

678
00:23:58,159 --> 00:23:59,760
the router service can attach this like

679
00:23:59,760 --> 00:24:01,600
session token like

680
00:24:01,600 --> 00:24:03,679
item and the other services have a copy

681
00:24:03,679 --> 00:24:05,919
of this and they'll see that of the

682
00:24:05,919 --> 00:24:08,080
session token or not quite a session

683
00:24:08,080 --> 00:24:10,080
token but that this bearer token is

684
00:24:10,080 --> 00:24:12,000
attached therefore it must be coming

685
00:24:12,000 --> 00:24:14,000
from someone i can trust

686
00:24:14,000 --> 00:24:15,200
obviously there's some problems with

687
00:24:15,200 --> 00:24:17,520
this and that an attacker in the network

688
00:24:17,520 --> 00:24:21,520
who's able to intercept requests could

689
00:24:21,520 --> 00:24:23,120
grab this token pretty easily and just

690
00:24:23,120 --> 00:24:24,880
send it along

691
00:24:24,880 --> 00:24:26,000
for any requests they want to make

692
00:24:26,000 --> 00:24:28,799
against services

693
00:24:28,960 --> 00:24:31,520
this is another kind of convoluted

694
00:24:31,520 --> 00:24:33,679
illustration of another way you might

695
00:24:33,679 --> 00:24:35,679
approach the problem so you have an auth

696
00:24:35,679 --> 00:24:39,279
service and then every request is

697
00:24:39,279 --> 00:24:41,760
signed or has a token added to it by the

698
00:24:41,760 --> 00:24:43,279
auth service which is then validated by

699
00:24:43,279 --> 00:24:44,799
the auth service again

700
00:24:44,799 --> 00:24:46,159
i don't know if anyone's really doing

701
00:24:46,159 --> 00:24:47,919
anything like this because that's a lot

702
00:24:47,919 --> 00:24:50,000
of latency to add you also had this like

703
00:24:50,000 --> 00:24:51,600
single point of failure in your auth

704
00:24:51,600 --> 00:24:53,200
service

705
00:24:53,200 --> 00:24:54,400
but

706
00:24:54,400 --> 00:24:56,480
draw the problem it's trying to solve

707
00:24:56,480 --> 00:24:58,559
potentially is is

708
00:24:58,559 --> 00:25:00,640
those weaker implementations

709
00:25:00,640 --> 00:25:02,880
can be replaced with signing your

710
00:25:02,880 --> 00:25:04,640
request in the network with a private

711
00:25:04,640 --> 00:25:07,039
key and then just issuing the public key

712
00:25:07,039 --> 00:25:09,039
to all your microservices and having

713
00:25:09,039 --> 00:25:12,159
them validate the jots

714
00:25:12,159 --> 00:25:14,480
that the requests have the valid jot and

715
00:25:14,480 --> 00:25:16,640
if you are using jot succession tokens

716
00:25:16,640 --> 00:25:19,440
or api tokens then you can even use

717
00:25:19,440 --> 00:25:21,360
those uh

718
00:25:21,360 --> 00:25:23,039
tokens as part of this signing scheme

719
00:25:23,039 --> 00:25:25,600
potentially

720
00:25:26,480 --> 00:25:29,120
um if you for example run roadblocks and

721
00:25:29,120 --> 00:25:31,600
you need to ban people then you can use

722
00:25:31,600 --> 00:25:33,520
verification via cache so this can be

723
00:25:33,520 --> 00:25:35,679
implemented on top of the database

724
00:25:35,679 --> 00:25:37,919
example i gave earlier or in and of

725
00:25:37,919 --> 00:25:40,320
itself i know several companies are

726
00:25:40,320 --> 00:25:42,320
using this in production or some version

727
00:25:42,320 --> 00:25:43,520
of this

728
00:25:43,520 --> 00:25:45,279
using an in-memory db

729
00:25:45,279 --> 00:25:48,080
redis a key value store to store a list

730
00:25:48,080 --> 00:25:50,880
of invalid but not yet expired tokens

731
00:25:50,880 --> 00:25:54,000
is a relatively low latency way to have

732
00:25:54,000 --> 00:25:56,720
some ability to derivation

733
00:25:56,720 --> 00:25:58,960
the cache should stay pretty small and

734
00:25:58,960 --> 00:26:01,120
especially with redis it's easy to set

735
00:26:01,120 --> 00:26:03,520
ttls equal to

736
00:26:03,520 --> 00:26:05,520
your already existing expiration time

737
00:26:05,520 --> 00:26:06,880
and so

738
00:26:06,880 --> 00:26:08,559
it'll automatically keep the cache size

739
00:26:08,559 --> 00:26:11,799
pretty low

740
00:26:12,400 --> 00:26:13,760
another useful thing when you're

741
00:26:13,760 --> 00:26:15,360
thinking about like secure library

742
00:26:15,360 --> 00:26:17,039
development or how to make this easier

743
00:26:17,039 --> 00:26:18,720
for developers not to shoot themselves

744
00:26:18,720 --> 00:26:21,520
in the foot is hard coding the algorithm

745
00:26:21,520 --> 00:26:24,159
so this is a little python snippet you

746
00:26:24,159 --> 00:26:28,240
can see i have a very poor key chosen

747
00:26:28,240 --> 00:26:30,320
and then encoded is equal to this jot

748
00:26:30,320 --> 00:26:32,880
token that i'm creating

749
00:26:32,880 --> 00:26:34,720
on the decode part though you'll notice

750
00:26:34,720 --> 00:26:35,600
that

751
00:26:35,600 --> 00:26:37,440
this library allows me to specify the

752
00:26:37,440 --> 00:26:39,919
algorithms manually i can also choose

753
00:26:39,919 --> 00:26:41,520
not to pass it this is just how the

754
00:26:41,520 --> 00:26:44,080
library wrote this function but by

755
00:26:44,080 --> 00:26:45,919
specifying the algorithm i'm helping

756
00:26:45,919 --> 00:26:47,919
insulate myself against potentially

757
00:26:47,919 --> 00:26:51,279
against some of these like algnun type

758
00:26:51,279 --> 00:26:51,760
and attacks

759
00:26:51,760 --> 00:26:53,360
potentially even more robust way of

760
00:26:53,360 --> 00:26:55,760
doing this is write some sort of like

761
00:26:55,760 --> 00:26:57,039
jot

762
00:26:57,039 --> 00:26:59,120
libraries or functions for developers to

763
00:26:59,120 --> 00:27:00,320
use

764
00:27:00,320 --> 00:27:02,080
where inside we've defined where the key

765
00:27:02,080 --> 00:27:04,000
is being pulled from hopefully not hard

766
00:27:04,000 --> 00:27:05,520
coded but

767
00:27:05,520 --> 00:27:06,880
being pulled from somewhere maybe like

768
00:27:06,880 --> 00:27:10,080
an environment file or included on build

769
00:27:10,080 --> 00:27:12,640
and then we specify the algorithm for

770
00:27:12,640 --> 00:27:14,480
them so developers don't have to worry

771
00:27:14,480 --> 00:27:16,960
about all the knobs and levers and i

772
00:27:16,960 --> 00:27:18,399
think this is a useful pattern a lot of

773
00:27:18,399 --> 00:27:20,320
us are probably familiar with with

774
00:27:20,320 --> 00:27:23,760
cryptographic constructs in general

775
00:27:24,640 --> 00:27:26,240
also you can potentially just not use

776
00:27:26,240 --> 00:27:27,760
jots

777
00:27:27,760 --> 00:27:29,360
again some of these other items that are

778
00:27:29,360 --> 00:27:30,480
popular

779
00:27:30,480 --> 00:27:32,640
macaroons are i'm touching them in a

780
00:27:32,640 --> 00:27:34,799
little bit but they're

781
00:27:34,799 --> 00:27:36,559
a somewhat unpopular but interesting

782
00:27:36,559 --> 00:27:39,440
construct with like a stateless token

783
00:27:39,440 --> 00:27:42,320
pacetto in some ways is like a jot with

784
00:27:42,320 --> 00:27:43,120
some

785
00:27:43,120 --> 00:27:44,399
hard coding some of the better

786
00:27:44,399 --> 00:27:46,399
attributes of jots and not having to

787
00:27:46,399 --> 00:27:48,159
worry about as much flexibility to hurt

788
00:27:48,159 --> 00:27:49,360
yourself with

789
00:27:49,360 --> 00:27:51,440
or if you're really just doing

790
00:27:51,440 --> 00:27:53,679
a non-web scale

791
00:27:53,679 --> 00:27:55,200
web application or mobile application

792
00:27:55,200 --> 00:27:57,120
you're probably safe with session tokens

793
00:27:57,120 --> 00:28:00,000
a lot of the scaling issues latency

794
00:28:00,000 --> 00:28:02,880
things that people often want to use

795
00:28:02,880 --> 00:28:04,880
jobs to solve may not be an issue for

796
00:28:04,880 --> 00:28:09,120
you or there may be simpler solutions

797
00:28:09,919 --> 00:28:11,919
this one is also goes way beyond just

798
00:28:11,919 --> 00:28:15,919
jwts but use trusted libraries

799
00:28:15,919 --> 00:28:17,360
io has a list

800
00:28:17,360 --> 00:28:20,000
of libraries and different languages

801
00:28:20,000 --> 00:28:21,520
you should keep it up to date for those

802
00:28:21,520 --> 00:28:25,120
persistent algorithm nun attacks

803
00:28:25,760 --> 00:28:27,200
i mentioned this earlier registered

804
00:28:27,200 --> 00:28:28,399
claims so

805
00:28:28,399 --> 00:28:29,440
there's a few that i think are

806
00:28:29,440 --> 00:28:30,960
particularly useful

807
00:28:30,960 --> 00:28:33,919
a subject expiration and an issue that

808
00:28:33,919 --> 00:28:35,760
time i think are really table stakes

809
00:28:35,760 --> 00:28:38,799
kind of things that should be included

810
00:28:38,799 --> 00:28:42,399
key id is also useful and then chat id

811
00:28:42,399 --> 00:28:44,480
so key id is for like identifying which

812
00:28:44,480 --> 00:28:45,840
signing key you've used for this

813
00:28:45,840 --> 00:28:46,960
particular

814
00:28:46,960 --> 00:28:47,590
jot

815
00:28:47,590 --> 00:28:50,880
[Music]

816
00:28:50,880 --> 00:28:53,600
uh and then job id is for

817
00:28:53,600 --> 00:28:54,960
the specific jaw and that could be used

818
00:28:54,960 --> 00:28:58,679
for like revocation purposes

819
00:28:58,799 --> 00:29:00,399
i just wanted to go over a few like

820
00:29:00,399 --> 00:29:02,240
additional topics and resources that you

821
00:29:02,240 --> 00:29:03,919
might want to explore on your own

822
00:29:03,919 --> 00:29:09,840
so rfc 7519 this is the original jwt rfc

823
00:29:09,840 --> 00:29:12,240
it's an interesting read potentially if

824
00:29:12,240 --> 00:29:14,000
you're working with jwts or

825
00:29:14,000 --> 00:29:16,640
authorization and authentication

826
00:29:16,640 --> 00:29:18,480
it's interesting to understand some of

827
00:29:18,480 --> 00:29:20,159
the more nuanced details

828
00:29:20,159 --> 00:29:22,399
and what the developers of the rfc had

829
00:29:22,399 --> 00:29:24,720
in mind when they were developing jots

830
00:29:24,720 --> 00:29:26,559
there's also this more recent and much

831
00:29:26,559 --> 00:29:29,919
shorter rfc 8725

832
00:29:29,919 --> 00:29:31,919
it has a number of best practices for

833
00:29:31,919 --> 00:29:33,919
using jots and for implementing jot

834
00:29:33,919 --> 00:29:36,480
libraries so some may be more or less

835
00:29:36,480 --> 00:29:38,559
relevant to your use case but i found

836
00:29:38,559 --> 00:29:41,840
that a really interesting read

837
00:29:42,640 --> 00:29:43,840
macarons

838
00:29:43,840 --> 00:29:45,679
this is something that i've never

839
00:29:45,679 --> 00:29:47,679
implemented myself but

840
00:29:47,679 --> 00:29:49,760
you can read the paper on them

841
00:29:49,760 --> 00:29:51,440
they do have a very delicious name

842
00:29:51,440 --> 00:29:52,880
obviously i've heard them macrons

843
00:29:52,880 --> 00:29:54,799
macaroons depending on who's pronouncing

844
00:29:54,799 --> 00:29:55,760
it but

845
00:29:55,760 --> 00:29:57,360
it's it's interesting in that it has

846
00:29:57,360 --> 00:30:00,080
this chained hmac construction so it

847
00:30:00,080 --> 00:30:02,320
allows for things like

848
00:30:02,320 --> 00:30:03,679
delegation

849
00:30:03,679 --> 00:30:06,080
it allows you to issue tokens that can

850
00:30:06,080 --> 00:30:09,520
issue more tokens it allows for caveats

851
00:30:09,520 --> 00:30:11,760
so sort of the inverse of

852
00:30:11,760 --> 00:30:14,000
claims where you can remove specific

853
00:30:14,000 --> 00:30:17,120
accessibility from things

854
00:30:17,760 --> 00:30:20,080
there's also this great blog post stop

855
00:30:20,080 --> 00:30:22,240
using jobs for sessions which it's

856
00:30:22,240 --> 00:30:23,360
two-part

857
00:30:23,360 --> 00:30:25,039
blog post which has this awesome flow

858
00:30:25,039 --> 00:30:27,279
chart about why

859
00:30:27,279 --> 00:30:29,360
the author thinks that jots are not a

860
00:30:29,360 --> 00:30:32,799
good choice for session tokens

861
00:30:33,039 --> 00:30:34,559
and then this is an awesome blog post

862
00:30:34,559 --> 00:30:36,559
from latakora if you haven't read it

863
00:30:36,559 --> 00:30:38,159
it's about just different approaches to

864
00:30:38,159 --> 00:30:40,080
service and service authentication goes

865
00:30:40,080 --> 00:30:42,399
way beyond the few crude examples i gave

866
00:30:42,399 --> 00:30:44,000
into a lot of different options and the

867
00:30:44,000 --> 00:30:47,200
pros and cons potentially

868
00:30:49,440 --> 00:30:50,960
uh and if you're interested in this

869
00:30:50,960 --> 00:30:53,600
topic i'd encourage you to look into a

870
00:30:53,600 --> 00:30:56,080
few other areas so federation this is

871
00:30:56,080 --> 00:30:57,279
something i really didn't touch on and

872
00:30:57,279 --> 00:30:59,760
one of the core use cases for jots in

873
00:30:59,760 --> 00:31:01,519
like 2021

874
00:31:01,519 --> 00:31:03,679
is these popular protocols for things

875
00:31:03,679 --> 00:31:06,159
like single sign-on and federation and

876
00:31:06,159 --> 00:31:07,760
obviously a really valid use case is

877
00:31:07,760 --> 00:31:09,600
when you have to interact with jots to

878
00:31:09,600 --> 00:31:12,799
work with something like an oauth 2.0

879
00:31:12,799 --> 00:31:13,679
there's some other interesting

880
00:31:13,679 --> 00:31:17,120
constructs like json web keys sets

881
00:31:17,120 --> 00:31:20,080
and json web signatures that i'd also

882
00:31:20,080 --> 00:31:21,039
encourage you to look into if you're

883
00:31:21,039 --> 00:31:23,440
interested

884
00:31:23,519 --> 00:31:25,919
i'd love to take questions now i know

885
00:31:25,919 --> 00:31:28,080
also that this wasn't a

886
00:31:28,080 --> 00:31:29,519
instagram specific talk but of course

887
00:31:29,519 --> 00:31:31,440
we're hiring love to talk to anybody

888
00:31:31,440 --> 00:31:34,559
who's interested in what we're doing

889
00:31:34,559 --> 00:31:36,799
yes

890
00:31:42,240 --> 00:31:43,519
yeah i think the

891
00:31:43,519 --> 00:31:45,679
this usually posted i might upload the

892
00:31:45,679 --> 00:31:47,200
slides and like put on my twitter then

893
00:31:47,200 --> 00:31:49,360
too

894
00:31:51,120 --> 00:31:52,960
i'm not sure i think that the the video

895
00:31:52,960 --> 00:31:54,240
is uploaded to the youtube channel at

896
00:31:54,240 --> 00:31:55,679
some point after the conference for one

897
00:31:55,679 --> 00:31:58,399
thing okay

898
00:31:58,399 --> 00:32:01,840
i'll post them on my twitter

899
00:32:02,640 --> 00:32:05,840
a primed mover

900
00:32:05,840 --> 00:32:09,199
or just david gilman

901
00:32:12,399 --> 00:32:15,719
no no worries

902
00:32:37,120 --> 00:32:40,518
any other questions

903
00:32:44,080 --> 00:32:46,310
all right

904
00:32:46,310 --> 00:32:52,339
[Applause]

