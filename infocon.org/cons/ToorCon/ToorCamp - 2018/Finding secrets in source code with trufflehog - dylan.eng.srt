1
00:00:01,640 --> 00:00:07,000
coming up Dylan's gonna be presenting on

2
00:00:03,650 --> 00:00:07,000
that so please welcome him to the stage

3
00:00:11,200 --> 00:00:22,729
thank you for the kind introduction and

4
00:00:19,580 --> 00:00:24,288
most of new before camp so when I mine

5
00:00:22,730 --> 00:00:26,510
invited me to go to a hacker conference

6
00:00:24,289 --> 00:00:31,189
in the middle of the woods I submitted a

7
00:00:26,510 --> 00:00:32,270
rather traditional talk and after kind

8
00:00:31,189 --> 00:00:34,430
of something through some of the other

9
00:00:32,270 --> 00:00:37,040
talks I'm not quite sure if I got the

10
00:00:34,430 --> 00:00:39,890
motif perfect so I apologize to point B

11
00:00:37,040 --> 00:00:42,530
in de creme brulee at this talk I'll

12
00:00:39,890 --> 00:00:45,200
work on that for next time though I made

13
00:00:42,530 --> 00:00:46,370
a tool and I'm trying to give it back to

14
00:00:45,200 --> 00:00:48,850
the community and share it with folks

15
00:00:46,370 --> 00:00:52,550
and that's basically what the talks on

16
00:00:48,850 --> 00:00:55,520
so with that said yeah so like about a

17
00:00:52,550 --> 00:00:59,480
year and a half ago I was struggling

18
00:00:55,520 --> 00:01:01,910
with this problem basically secrets

19
00:00:59,480 --> 00:01:04,369
being committed to source code secrets

20
00:01:01,910 --> 00:01:07,550
being passwords API tokens things like

21
00:01:04,369 --> 00:01:09,110
that it was something that a lot of

22
00:01:07,550 --> 00:01:10,970
developers I was working with we're

23
00:01:09,110 --> 00:01:12,350
struggling with so I'm an application

24
00:01:10,970 --> 00:01:14,960
security engineer and I tend to work

25
00:01:12,350 --> 00:01:16,970
closely with developers but it's also a

26
00:01:14,960 --> 00:01:19,729
problem that I myself have been guilty

27
00:01:16,970 --> 00:01:23,210
of in the past so I wanted to just make

28
00:01:19,730 --> 00:01:25,400
a tool to basically be able to identify

29
00:01:23,210 --> 00:01:26,779
or quickly flag these secrets so that

30
00:01:25,400 --> 00:01:32,150
they don't get buried a mountain of

31
00:01:26,780 --> 00:01:33,920
source code and so that kind of begs the

32
00:01:32,150 --> 00:01:35,210
question of like why is it bad to have

33
00:01:33,920 --> 00:01:37,970
the secrets in the source code in the

34
00:01:35,210 --> 00:01:41,210
first place I'll list a couple reasons

35
00:01:37,970 --> 00:01:44,658
here but really like there's there's a

36
00:01:41,210 --> 00:01:47,869
lot of reasons these secrets can often

37
00:01:44,659 --> 00:01:49,460
lead to really bad problems and you want

38
00:01:47,870 --> 00:01:52,940
to be really careful and sensitive where

39
00:01:49,460 --> 00:01:54,889
you lock them up they can definitely the

40
00:01:52,940 --> 00:01:57,620
breaches they can help with lateral

41
00:01:54,890 --> 00:01:59,060
movement if you've infected one host and

42
00:01:57,620 --> 00:02:00,740
you find the source code on that host

43
00:01:59,060 --> 00:02:03,020
their secrets in it you can move

44
00:02:00,740 --> 00:02:05,179
laterally to another host you'd elevate

45
00:02:03,020 --> 00:02:06,560
privilege if you have a particular for

46
00:02:05,180 --> 00:02:08,840
mission set on one machine you get easy

47
00:02:06,560 --> 00:02:13,160
access to secrets you can move up to

48
00:02:08,840 --> 00:02:15,490
route or move to another system with

49
00:02:13,160 --> 00:02:17,299
elevated privileges

50
00:02:15,490 --> 00:02:20,750
workstations get lost all the time

51
00:02:17,300 --> 00:02:23,030
people's laptops get left on trains if

52
00:02:20,750 --> 00:02:24,290
you don't have full disk encryption and

53
00:02:23,030 --> 00:02:26,950
your secrets are just lying around in

54
00:02:24,290 --> 00:02:30,010
source code on the on the hard drive

55
00:02:26,950 --> 00:02:32,209
even if you revoke access to the

56
00:02:30,010 --> 00:02:33,620
workstation there could be other secrets

57
00:02:32,210 --> 00:02:35,810
in there that you think you have to

58
00:02:33,620 --> 00:02:37,340
worry about and really the last bullet

59
00:02:35,810 --> 00:02:39,470
point here is one that I'm most worried

60
00:02:37,340 --> 00:02:42,620
about source code is like really leaky

61
00:02:39,470 --> 00:02:45,230
um even if you try to keep it like

62
00:02:42,620 --> 00:02:47,300
really locked down ultimately in some

63
00:02:45,230 --> 00:02:48,829
capacity so your source code is gonna

64
00:02:47,300 --> 00:02:51,170
end up on the Internet

65
00:02:48,830 --> 00:02:53,540
whether that's a insider that

66
00:02:51,170 --> 00:02:55,220
intentionally posts it an insider for

67
00:02:53,540 --> 00:03:00,500
convenience that's just temporarily

68
00:02:55,220 --> 00:03:03,130
posting it over paste bin or you

69
00:03:00,500 --> 00:03:05,990
accidentally exposed a dot get directory

70
00:03:03,130 --> 00:03:08,180
you know if you spend some time on an

71
00:03:05,990 --> 00:03:11,420
app SEC team you know that like give it

72
00:03:08,180 --> 00:03:13,280
enough time it happens and if you've got

73
00:03:11,420 --> 00:03:17,109
API T keys and tokens in that source

74
00:03:13,280 --> 00:03:20,690
code you're basically giving an attacker

75
00:03:17,110 --> 00:03:23,660
access to systems directly after they

76
00:03:20,690 --> 00:03:27,770
get that source code so I have some

77
00:03:23,660 --> 00:03:29,720
public examples of when this has been a

78
00:03:27,770 --> 00:03:32,959
problem that I could speak to and then I

79
00:03:29,720 --> 00:03:35,209
have a lot more non-public examples that

80
00:03:32,959 --> 00:03:38,090
I've reported through bug bounties and

81
00:03:35,209 --> 00:03:41,360
such that follow the same motif so this

82
00:03:38,090 --> 00:03:44,030
one is a pretty esteemed

83
00:03:41,360 --> 00:03:45,320
security engineer at hacker one read

84
00:03:44,030 --> 00:03:48,140
he's involved in a local security

85
00:03:45,320 --> 00:03:50,140
community in San Francisco basically a

86
00:03:48,140 --> 00:03:52,309
security researcher came in and was like

87
00:03:50,140 --> 00:03:54,859
you know I went through your personal

88
00:03:52,310 --> 00:03:58,250
github repository and I found an API

89
00:03:54,860 --> 00:04:01,340
access token on your on your github and

90
00:03:58,250 --> 00:04:05,150
you submitted that to hacker what ins

91
00:04:01,340 --> 00:04:07,340
hacker one program and Reid was really

92
00:04:05,150 --> 00:04:10,310
cool about it he paid out the researcher

93
00:04:07,340 --> 00:04:11,900
two grand and ended up making that issue

94
00:04:10,310 --> 00:04:15,880
public so that we can bring some

95
00:04:11,900 --> 00:04:19,010
visibility to the problem but it kind of

96
00:04:15,880 --> 00:04:21,500
helps illustrate how leaky these things

97
00:04:19,010 --> 00:04:23,450
can be where this was like a personal

98
00:04:21,500 --> 00:04:24,560
github and a personal account but it

99
00:04:23,450 --> 00:04:25,750
happened to have like an environment

100
00:04:24,560 --> 00:04:28,060
variable or a

101
00:04:25,750 --> 00:04:33,220
in AWS token that was related to hacker

102
00:04:28,060 --> 00:04:38,890
1 this is a little bit more of a public

103
00:04:33,220 --> 00:04:43,570
example but basically some researcher

104
00:04:38,890 --> 00:04:45,550
went through github searching for slack

105
00:04:43,570 --> 00:04:48,880
API access tokens and found more than

106
00:04:45,550 --> 00:04:51,490
1500 live tokens and if you imagine

107
00:04:48,880 --> 00:04:53,710
slack that's another place where people

108
00:04:51,490 --> 00:04:55,960
potentially put secrets and passwords so

109
00:04:53,710 --> 00:04:58,000
if somebody posted an access token to

110
00:04:55,960 --> 00:04:59,380
their personal github for a work account

111
00:04:58,000 --> 00:05:01,450
for like a bot that working on or

112
00:04:59,380 --> 00:05:03,219
something like that or maybe something

113
00:05:01,450 --> 00:05:04,990
was open source with the slack token an

114
00:05:03,220 --> 00:05:06,610
attacker could use that to dump slack

115
00:05:04,990 --> 00:05:11,230
history and potentially get more keys

116
00:05:06,610 --> 00:05:14,200
and laterally further from that and then

117
00:05:11,230 --> 00:05:15,280
this is you know again stepping it up a

118
00:05:14,200 --> 00:05:17,289
little further

119
00:05:15,280 --> 00:05:20,140
these are a token so we're committed to

120
00:05:17,290 --> 00:05:24,420
github here malicious actor stole these

121
00:05:20,140 --> 00:05:29,860
AWS tokens and use them to mine Bitcoin

122
00:05:24,420 --> 00:05:32,280
which ran up a bill of over $2,000 which

123
00:05:29,860 --> 00:05:35,770
is kind of funny but also kind of sad

124
00:05:32,280 --> 00:05:37,809
but also like if you work AB sick this

125
00:05:35,770 --> 00:05:39,729
is this is all really familiar like devs

126
00:05:37,810 --> 00:05:42,340
committing AWS tokens all the time stuff

127
00:05:39,730 --> 00:05:44,860
gets open-source a bogus tokens end up

128
00:05:42,340 --> 00:05:46,750
in places that they shouldn't and then

129
00:05:44,860 --> 00:05:49,150
last probably the most notable example

130
00:05:46,750 --> 00:05:51,730
that we're all familiar with the the

131
00:05:49,150 --> 00:05:55,150
time that Hooper accidentally committed

132
00:05:51,730 --> 00:05:59,740
an AWS token to public github and a

133
00:05:55,150 --> 00:06:01,150
researcher found it and then maybe

134
00:05:59,740 --> 00:06:05,020
blackmailed them for a hundred thousand

135
00:06:01,150 --> 00:06:08,260
dollars the details on that are though

136
00:06:05,020 --> 00:06:12,430
fuzzy here but it definitely made

137
00:06:08,260 --> 00:06:14,230
national news and the uber see so went

138
00:06:12,430 --> 00:06:17,230
and talked to Frank Congress about it

139
00:06:14,230 --> 00:06:19,570
was it's a big deal for a you know Deb

140
00:06:17,230 --> 00:06:21,490
accidentally pushing an ApS token which

141
00:06:19,570 --> 00:06:25,120
is again a really systemic common

142
00:06:21,490 --> 00:06:27,220
problem we're all familiar with so that

143
00:06:25,120 --> 00:06:28,450
this is not a talk at all on how you

144
00:06:27,220 --> 00:06:30,820
should manage your secrets

145
00:06:28,450 --> 00:06:33,130
there are a ton of answers to that and a

146
00:06:30,820 --> 00:06:34,419
ton of tools for that I have a couple

147
00:06:33,130 --> 00:06:36,789
examples up on the board but that's

148
00:06:34,419 --> 00:06:39,669
completely dependent on your environment

149
00:06:36,789 --> 00:06:41,979
pick the secrets management solution

150
00:06:39,669 --> 00:06:44,770
that is best for for you and for your

151
00:06:41,979 --> 00:06:47,258
environment this this is more of just a

152
00:06:44,770 --> 00:06:50,198
talk of getting those secrets out of

153
00:06:47,259 --> 00:06:52,089
your source code so here you see that

154
00:06:50,199 --> 00:06:55,779
the secrets management solution is like

155
00:06:52,089 --> 00:06:57,580
the defense and then truffle hog is the

156
00:06:55,779 --> 00:06:57,939
border collie up there in the top left

157
00:06:57,580 --> 00:06:59,949
corner

158
00:06:57,939 --> 00:07:02,589
herding the secrets into the secrets

159
00:06:59,949 --> 00:07:06,279
management solution it's it's designed

160
00:07:02,589 --> 00:07:12,180
to identify secrets and get them moved

161
00:07:06,279 --> 00:07:14,949
into your secrets management solution so

162
00:07:12,180 --> 00:07:16,419
the interesting thing here like before I

163
00:07:14,949 --> 00:07:18,669
mentioned a couple of different ways

164
00:07:16,419 --> 00:07:20,109
that source could can get leaked it

165
00:07:18,669 --> 00:07:21,698
seems like source code lives in one

166
00:07:20,110 --> 00:07:23,830
place right it lives in version control

167
00:07:21,699 --> 00:07:27,189
but when you stop to think about it like

168
00:07:23,830 --> 00:07:30,520
we paste source code all over the place

169
00:07:27,189 --> 00:07:31,990
right it lives in package managers your

170
00:07:30,520 --> 00:07:33,039
mobile applications every app you

171
00:07:31,990 --> 00:07:35,349
download you're downloading the whole

172
00:07:33,039 --> 00:07:38,139
source code of that app we pay snippets

173
00:07:35,349 --> 00:07:40,659
of source code and slack when you go to

174
00:07:38,139 --> 00:07:42,610
a website you download you know

175
00:07:40,659 --> 00:07:47,589
tremendous amount of JavaScript in HTML

176
00:07:42,610 --> 00:07:49,089
and then on the bottom there revision

177
00:07:47,589 --> 00:07:51,909
history so not just the current

178
00:07:49,089 --> 00:07:54,310
incarnation of your version control but

179
00:07:51,909 --> 00:07:57,009
also the past incarnations of your

180
00:07:54,310 --> 00:07:59,589
versions of your source code all of

181
00:07:57,009 --> 00:08:02,050
these places are places that I and other

182
00:07:59,589 --> 00:08:04,029
researchers have identified secrets have

183
00:08:02,050 --> 00:08:06,159
have leaked it's kind of just like a law

184
00:08:04,029 --> 00:08:08,259
of large numbers if you have a you have

185
00:08:06,159 --> 00:08:10,659
a large enough volume of source code

186
00:08:08,259 --> 00:08:15,189
somewhere in there secrets are gonna

187
00:08:10,659 --> 00:08:17,409
make their way in AWS tokens it sounds

188
00:08:15,189 --> 00:08:19,479
crazy like who would package an AWS

189
00:08:17,409 --> 00:08:22,599
token in an apk mobile app and then put

190
00:08:19,479 --> 00:08:29,469
it on the public Google Play Store but

191
00:08:22,599 --> 00:08:31,569
sure enough it happens so you know

192
00:08:29,469 --> 00:08:33,969
highlighting that last point there this

193
00:08:31,569 --> 00:08:36,519
is a pretty standard github repository

194
00:08:33,969 --> 00:08:39,490
it's actually the Facebook react one and

195
00:08:36,519 --> 00:08:40,959
on the top this green it's all that

196
00:08:39,490 --> 00:08:42,789
source code that was added to the

197
00:08:40,958 --> 00:08:43,929
project but the red is kind of what I'm

198
00:08:42,789 --> 00:08:45,279
more interested in that's where the

199
00:08:43,929 --> 00:08:47,439
source code was taken away from the

200
00:08:45,279 --> 00:08:49,420
project so as time goes on people are

201
00:08:47,439 --> 00:08:50,150
changing features you're adding new code

202
00:08:49,420 --> 00:08:53,360
but there also

203
00:08:50,150 --> 00:08:56,000
code away but if you go to Facebook's

204
00:08:53,360 --> 00:08:58,550
react repository online all that code

205
00:08:56,000 --> 00:09:01,250
they took away is still there it's just

206
00:08:58,550 --> 00:09:03,500
buried in the version control which for

207
00:09:01,250 --> 00:09:05,810
any other vulnerability isn't a problem

208
00:09:03,500 --> 00:09:06,560
because you bury a cross-site scripting

209
00:09:05,810 --> 00:09:09,199
in the past

210
00:09:06,560 --> 00:09:10,670
nobody's gonna dig it up and become

211
00:09:09,200 --> 00:09:12,620
vulnerable to cross-site scripting but

212
00:09:10,670 --> 00:09:15,800
if you bury a secret in the past and

213
00:09:12,620 --> 00:09:20,330
that secret is live you could still use

214
00:09:15,800 --> 00:09:22,430
it and so that that to me was was a

215
00:09:20,330 --> 00:09:26,030
problem like we could come up with some

216
00:09:22,430 --> 00:09:27,949
reg X's and greps to find the secrets in

217
00:09:26,030 --> 00:09:30,230
the current incarnation of the source

218
00:09:27,950 --> 00:09:34,790
code but there's an equal amount if not

219
00:09:30,230 --> 00:09:36,290
more read in the past source code that

220
00:09:34,790 --> 00:09:40,819
we're just completely ignoring if we

221
00:09:36,290 --> 00:09:43,849
take that approach and so that this is

222
00:09:40,820 --> 00:09:45,470
an example of something that I pulled up

223
00:09:43,850 --> 00:09:47,900
recently but you can run the search

224
00:09:45,470 --> 00:09:50,930
today and it'll be the same thing if you

225
00:09:47,900 --> 00:09:54,590
search removed password in github he'll

226
00:09:50,930 --> 00:09:57,530
just find in this particular instance

227
00:09:54,590 --> 00:10:00,530
this is three hundred thousand results

228
00:09:57,530 --> 00:10:02,900
of commits of people accidentally

229
00:10:00,530 --> 00:10:05,209
committing a password and then the next

230
00:10:02,900 --> 00:10:06,770
commit committing over-the-top pulling

231
00:10:05,210 --> 00:10:09,200
that source code out of the current

232
00:10:06,770 --> 00:10:11,240
incarnation but again you could just

233
00:10:09,200 --> 00:10:15,920
click these links and get access to that

234
00:10:11,240 --> 00:10:18,410
token right hopefully they changed the

235
00:10:15,920 --> 00:10:22,819
password ideally they would have nuked

236
00:10:18,410 --> 00:10:25,730
that commit entirely as well but they

237
00:10:22,820 --> 00:10:27,530
didn't end up nuking the password and

238
00:10:25,730 --> 00:10:31,280
it's a game of law of large numbers like

239
00:10:27,530 --> 00:10:34,430
if you evangelical eyes that you need to

240
00:10:31,280 --> 00:10:36,949
rotate your password given enough devs

241
00:10:34,430 --> 00:10:38,989
at least one of them won't and because

242
00:10:36,950 --> 00:10:42,080
it's really easy to run these searches

243
00:10:38,990 --> 00:10:44,810
and an automated tool to just go through

244
00:10:42,080 --> 00:10:47,440
and check which ones are live a lot of

245
00:10:44,810 --> 00:10:47,439
them are going to be live

246
00:10:49,440 --> 00:10:56,290
yeah yeah well that's another good point

247
00:10:55,330 --> 00:10:58,840
I'm gonna talk more about that later

248
00:10:56,290 --> 00:11:03,730
this is a hard problem uh-huh

249
00:10:58,840 --> 00:11:05,350
it really is but yeah so this is again

250
00:11:03,730 --> 00:11:07,390
just sort of highlighting the scope and

251
00:11:05,350 --> 00:11:08,950
depth of this problem and again if you

252
00:11:07,390 --> 00:11:10,270
run through these you'll find some

253
00:11:08,950 --> 00:11:13,050
they're alive and you'll find some that

254
00:11:10,270 --> 00:11:16,900
point to some pretty notable companies

255
00:11:13,050 --> 00:11:22,540
so some reasons why you may have commits

256
00:11:16,900 --> 00:11:24,329
like this a developer may have like I

257
00:11:22,540 --> 00:11:26,920
mentioned before removed it by a mistake

258
00:11:24,330 --> 00:11:31,750
or like an entire feature may have been

259
00:11:26,920 --> 00:11:35,439
removed maybe you were using AWS sqs

260
00:11:31,750 --> 00:11:36,880
offering for storing large blobs of text

261
00:11:35,440 --> 00:11:39,730
and at some point you decided you wanted

262
00:11:36,880 --> 00:11:41,800
to switch to s3 so you delete a large

263
00:11:39,730 --> 00:11:44,140
swath of source code which includes an

264
00:11:41,800 --> 00:11:47,729
AWS token you're using for sqs and you

265
00:11:44,140 --> 00:11:50,530
replace it with an s3 source code token

266
00:11:47,730 --> 00:11:51,910
maybe we catch the s3 one when we do our

267
00:11:50,530 --> 00:11:53,949
source code review but you're not going

268
00:11:51,910 --> 00:11:56,860
to carry that catch that sqs one that's

269
00:11:53,950 --> 00:11:58,960
buried and more often than not they end

270
00:11:56,860 --> 00:12:00,340
up still being live and the last one

271
00:11:58,960 --> 00:12:03,370
here is kind of a funny one that I've

272
00:12:00,340 --> 00:12:04,900
encountered a lot basically you know

273
00:12:03,370 --> 00:12:07,540
right before you go to open source

274
00:12:04,900 --> 00:12:09,459
something at a company typically you'll

275
00:12:07,540 --> 00:12:11,020
have like a whole approval process like

276
00:12:09,460 --> 00:12:12,820
legal security you'll have to sign off

277
00:12:11,020 --> 00:12:15,310
on it they'll be like an open source

278
00:12:12,820 --> 00:12:17,320
software review that the security team

279
00:12:15,310 --> 00:12:19,239
will quickly do just a quick cursory

280
00:12:17,320 --> 00:12:20,620
that they'll go through look for any

281
00:12:19,240 --> 00:12:22,540
obvious vulnerabilities look for secrets

282
00:12:20,620 --> 00:12:25,210
in the source code well right before

283
00:12:22,540 --> 00:12:26,439
that review the developers are gonna

284
00:12:25,210 --> 00:12:28,360
want to clean it up because they know

285
00:12:26,440 --> 00:12:29,320
it's not in a perfect state and so

286
00:12:28,360 --> 00:12:32,200
they'll go through and they'll just

287
00:12:29,320 --> 00:12:33,760
remove secrets and make it look better

288
00:12:32,200 --> 00:12:37,450
to try to get it through on the first

289
00:12:33,760 --> 00:12:38,950
try but often they don't purge it from

290
00:12:37,450 --> 00:12:41,290
the history they don't rotate those

291
00:12:38,950 --> 00:12:44,980
credentials and so it's kind of ironic

292
00:12:41,290 --> 00:12:46,870
they go in going through the source code

293
00:12:44,980 --> 00:12:49,390
review that action that they do to clean

294
00:12:46,870 --> 00:12:51,310
themselves up makes it such that the

295
00:12:49,390 --> 00:12:53,560
security engineer doing the review often

296
00:12:51,310 --> 00:12:54,699
doesn't catch the hidden secret because

297
00:12:53,560 --> 00:12:58,000
they're only looking at the most recent

298
00:12:54,700 --> 00:13:02,190
incarnation of the code so this is an

299
00:12:58,000 --> 00:13:05,430
example of like basically when I first

300
00:13:02,190 --> 00:13:08,610
when I first got the tool and I ran it

301
00:13:05,430 --> 00:13:10,529
I found this AWS token in one of

302
00:13:08,610 --> 00:13:12,000
Netflix's repositories and I got their

303
00:13:10,529 --> 00:13:15,839
permission at a time before using the

304
00:13:12,000 --> 00:13:17,910
slide but basically this is one of many

305
00:13:15,839 --> 00:13:21,480
companies where I found these tokens

306
00:13:17,910 --> 00:13:24,329
buried some of them live this one gave

307
00:13:21,480 --> 00:13:28,290
him permission some didn't and then this

308
00:13:24,329 --> 00:13:29,719
one was bearing an old incarnation but

309
00:13:28,290 --> 00:13:31,740
not in the current version of the code

310
00:13:29,720 --> 00:13:33,980
and that's still there by the way they

311
00:13:31,740 --> 00:13:36,540
rotated the cred but they didn't pull

312
00:13:33,980 --> 00:13:38,899
pull access token probably worried about

313
00:13:36,540 --> 00:13:44,219
breaking I'm forced pushing all that so

314
00:13:38,899 --> 00:13:45,990
this very commit so we have to have this

315
00:13:44,220 --> 00:13:48,389
we have to solve this problem with being

316
00:13:45,990 --> 00:13:50,189
able to scan old commits and we can't

317
00:13:48,389 --> 00:13:53,480
run grep on the dot yet directory

318
00:13:50,189 --> 00:13:56,009
because I'm not an expert and get

319
00:13:53,480 --> 00:13:58,589
protocol but the way these binary blobs

320
00:13:56,009 --> 00:14:09,420
are stored a dump grep doesn't work on

321
00:13:58,589 --> 00:14:12,089
them right yeah so basically long story

322
00:14:09,420 --> 00:14:13,920
short this was the problem that I was

323
00:14:12,089 --> 00:14:17,759
trying to solve of like we need to go

324
00:14:13,920 --> 00:14:19,410
back and find these keys and so truffle

325
00:14:17,759 --> 00:14:23,939
hog was the the solution that I came up

326
00:14:19,410 --> 00:14:25,620
with that and what's what's kind of

327
00:14:23,939 --> 00:14:27,120
interesting is I actually didn't spike

328
00:14:25,620 --> 00:14:28,769
on doing regex is initially I'll get

329
00:14:27,120 --> 00:14:31,920
more on that later but I ended up adding

330
00:14:28,769 --> 00:14:34,110
reg X's so what is trouble ha it's an

331
00:14:31,920 --> 00:14:36,719
open source tool that specifically sans

332
00:14:34,110 --> 00:14:40,380
git repositories doesn't currently have

333
00:14:36,720 --> 00:14:42,269
SPN or any other support goes all the

334
00:14:40,380 --> 00:14:45,600
way through all old revision history it

335
00:14:42,269 --> 00:14:48,689
searches every branch and it just looks

336
00:14:45,600 --> 00:14:51,480
for secrets I made it as like a security

337
00:14:48,689 --> 00:14:53,160
audit tool but I've tried to pivot that

338
00:14:51,480 --> 00:14:54,930
lately to make it more of a DevOps tool

339
00:14:53,160 --> 00:14:57,240
to switch it to more of a proactive

340
00:14:54,930 --> 00:15:01,649
rather than reactive flow talk more

341
00:14:57,240 --> 00:15:04,170
about that a bit so you know like I

342
00:15:01,649 --> 00:15:06,300
mentioned I I didn't build this out with

343
00:15:04,170 --> 00:15:07,769
reg X's initially because I didn't want

344
00:15:06,300 --> 00:15:10,050
to have to write a reg X for every

345
00:15:07,769 --> 00:15:14,370
secret on the planet which later I

346
00:15:10,050 --> 00:15:15,990
realized I had to do but initially I

347
00:15:14,370 --> 00:15:20,279
just I just looked for high sources

348
00:15:15,990 --> 00:15:23,640
entropy more often than not if it Flags

349
00:15:20,279 --> 00:15:26,670
on a high source of entropy it is a

350
00:15:23,640 --> 00:15:28,370
secret or a key this this won't get

351
00:15:26,670 --> 00:15:31,229
everything it won't get low low entropy

352
00:15:28,370 --> 00:15:32,940
passwords for example and it will false

353
00:15:31,230 --> 00:15:34,830
positive a lot so you'll get things like

354
00:15:32,940 --> 00:15:37,350
URLs YouTube URLs and stuff like that

355
00:15:34,830 --> 00:15:38,940
flagging but if you're just doing like a

356
00:15:37,350 --> 00:15:41,220
one-time open source review we're like a

357
00:15:38,940 --> 00:15:44,190
pen test or using this for offensive

358
00:15:41,220 --> 00:15:46,980
security it it works really well on

359
00:15:44,190 --> 00:15:48,630
entropy mode but if you want to automate

360
00:15:46,980 --> 00:15:50,339
this and stick it in a devops pipeline

361
00:15:48,630 --> 00:15:52,980
and deliver these results to a developer

362
00:15:50,339 --> 00:15:53,750
it's probably too much noise is what I

363
00:15:52,980 --> 00:15:56,970
found

364
00:15:53,750 --> 00:15:58,950
um so like I mentioned before like it's

365
00:15:56,970 --> 00:16:00,390
it's it's great for pen tests great for

366
00:15:58,950 --> 00:16:03,209
doing like a one-time open source review

367
00:16:00,390 --> 00:16:05,490
really good for bug bounties use truffle

368
00:16:03,209 --> 00:16:07,439
hog on every company you can imagine

369
00:16:05,490 --> 00:16:09,720
you'll probably make some loot out of it

370
00:16:07,440 --> 00:16:11,310
I before open sourcing it I definitely

371
00:16:09,720 --> 00:16:15,180
ran it on some big companies and did

372
00:16:11,310 --> 00:16:16,619
that uh-huh but the cons are like I

373
00:16:15,180 --> 00:16:18,000
mentioned before like you can't stick

374
00:16:16,620 --> 00:16:19,649
this in a DevOps pipeline without it

375
00:16:18,000 --> 00:16:22,100
flaring on a ton of false positives

376
00:16:19,649 --> 00:16:24,600
there's an example in the same Netflix

377
00:16:22,100 --> 00:16:27,209
repository where it flagged on a false

378
00:16:24,600 --> 00:16:29,040
positive that's the URL that just has a

379
00:16:27,209 --> 00:16:31,290
lot of entropy in it it's got a commit

380
00:16:29,040 --> 00:16:33,270
hash and the entropy there is is

381
00:16:31,290 --> 00:16:36,680
interesting because it's a 32 character

382
00:16:33,270 --> 00:16:39,449
hex string which is the exact same

383
00:16:36,680 --> 00:16:41,880
entropy source that say a facebook

384
00:16:39,450 --> 00:16:45,690
access token is it's also 32 character

385
00:16:41,880 --> 00:16:46,770
hex string so you know there's there's a

386
00:16:45,690 --> 00:16:48,870
lot of false positives with this

387
00:16:46,770 --> 00:16:51,810
approach doesn't scale well it's not

388
00:16:48,870 --> 00:16:54,720
very good with with reactive it's it's

389
00:16:51,810 --> 00:16:58,709
pretty good with proactive all right I

390
00:16:54,720 --> 00:17:00,329
said that backwards but so I you know I

391
00:16:58,709 --> 00:17:02,609
eventually I caved and I was like

392
00:17:00,329 --> 00:17:03,959
alright I got to just write some some

393
00:17:02,610 --> 00:17:06,870
regular expressions for like the really

394
00:17:03,959 --> 00:17:10,109
sensitive stuff and so I built out the

395
00:17:06,869 --> 00:17:11,938
the regex flag and travel hog and so

396
00:17:10,109 --> 00:17:15,688
that's what this is so basically I I

397
00:17:11,939 --> 00:17:21,449
added explicit checks for RSA tokens for

398
00:17:15,689 --> 00:17:24,030
AWS tokens for slack tokens for a bunch

399
00:17:21,449 --> 00:17:26,100
of different really common tokens that

400
00:17:24,030 --> 00:17:28,020
people commit to repositories and it

401
00:17:26,099 --> 00:17:29,580
made it extensible so that you could run

402
00:17:28,020 --> 00:17:31,230
your own rules

403
00:17:29,580 --> 00:17:32,908
it's better for catching low entropy

404
00:17:31,230 --> 00:17:34,140
stuff if you've got a password that you

405
00:17:32,909 --> 00:17:36,570
know people are committing a ton of

406
00:17:34,140 --> 00:17:38,190
times you could write a regex around

407
00:17:36,570 --> 00:17:41,399
that particular password structure

408
00:17:38,190 --> 00:17:43,020
around the particular topology of the

409
00:17:41,399 --> 00:17:45,689
source code that usually introduces the

410
00:17:43,020 --> 00:17:47,429
password it scales a lot better it

411
00:17:45,690 --> 00:17:48,870
reduces the noise if you turn off the

412
00:17:47,429 --> 00:17:51,120
entropy mode and you just rely on the

413
00:17:48,870 --> 00:17:53,370
regex mode and you can customize it for

414
00:17:51,120 --> 00:17:54,449
your environment which just makes it a

415
00:17:53,370 --> 00:17:58,559
lot better for putting in DevOps

416
00:17:54,450 --> 00:18:01,010
pipelines there's a question in the

417
00:17:58,559 --> 00:18:01,010
front row here

418
00:18:12,790 --> 00:18:16,180
yeah I'm gonna talk a little bit more

419
00:18:14,920 --> 00:18:19,030
about that later the question was

420
00:18:16,180 --> 00:18:20,650
basically is is there is there a way to

421
00:18:19,030 --> 00:18:24,730
run this before you even do the commit

422
00:18:20,650 --> 00:18:28,170
and is there a way to reject commit so

423
00:18:24,730 --> 00:18:30,700
if it looks like there's credentials I

424
00:18:28,170 --> 00:18:32,050
have built out similar things and I'm

425
00:18:30,700 --> 00:18:33,100
gonna talk about how how you can build

426
00:18:32,050 --> 00:18:34,720
out things like that but there's a lot

427
00:18:33,100 --> 00:18:38,050
of pitfalls that go with that approach

428
00:18:34,720 --> 00:18:39,370
and trying to block on things that look

429
00:18:38,050 --> 00:18:41,740
like secrets if you haven't actually

430
00:18:39,370 --> 00:18:43,179
verified them more often than not

431
00:18:41,740 --> 00:18:44,470
becomes a huge blocker because things

432
00:18:43,180 --> 00:18:46,210
like URLs and stuff like that will flag

433
00:18:44,470 --> 00:18:49,360
up so I'll talk about how we kind of

434
00:18:46,210 --> 00:18:51,430
addressed that in a bit but one of the

435
00:18:49,360 --> 00:18:52,570
big disadvantages of the regex mode is

436
00:18:51,430 --> 00:18:54,760
you miss types of keys that you don't

437
00:18:52,570 --> 00:18:56,290
know about so if they're using at while

438
00:18:54,760 --> 00:18:59,290
a off key and you don't have a regex for

439
00:18:56,290 --> 00:19:01,149
twily oh you'll just completely miss

440
00:18:59,290 --> 00:19:02,560
that in this approach and it still does

441
00:19:01,150 --> 00:19:05,470
require some manual triage out of the

442
00:19:02,560 --> 00:19:06,700
box like I said sometimes even with

443
00:19:05,470 --> 00:19:10,030
these regex this will be some false

444
00:19:06,700 --> 00:19:11,410
positives and more often than not a lot

445
00:19:10,030 --> 00:19:14,530
of these keys will have been rolled

446
00:19:11,410 --> 00:19:16,000
but oft in their life and figuring out

447
00:19:14,530 --> 00:19:19,110
which is which requires some manual

448
00:19:16,000 --> 00:19:21,790
triage so this is kind of the initial

449
00:19:19,110 --> 00:19:24,399
pipeline that I had imagined you have an

450
00:19:21,790 --> 00:19:26,379
incoming get commit hook travel hog runs

451
00:19:24,400 --> 00:19:28,180
on the get commit hook and then you have

452
00:19:26,380 --> 00:19:29,890
to have some sort of triage process and

453
00:19:28,180 --> 00:19:33,130
that triage process we'll talk a little

454
00:19:29,890 --> 00:19:35,080
bit more about in a bit but that at this

455
00:19:33,130 --> 00:19:36,610
stage has to be a little bit manual

456
00:19:35,080 --> 00:19:38,050
somebody will have to go and figure out

457
00:19:36,610 --> 00:19:39,280
whether or not that token is live figure

458
00:19:38,050 --> 00:19:41,139
out the right approach and how they

459
00:19:39,280 --> 00:19:42,760
wrote hit it figure out whether or not

460
00:19:41,140 --> 00:19:44,010
they want to block this commit or

461
00:19:42,760 --> 00:19:46,570
whether or not it was a false positive

462
00:19:44,010 --> 00:19:49,629
and then you have to remediate you have

463
00:19:46,570 --> 00:19:52,810
to move that secret out of a source code

464
00:19:49,630 --> 00:19:54,160
get to rotate that secret you have to

465
00:19:52,810 --> 00:19:55,450
handle the dance and appropriately

466
00:19:54,160 --> 00:20:00,960
figure out whether or not you want to

467
00:19:55,450 --> 00:20:03,880
purge it from from commit history so

468
00:20:00,960 --> 00:20:07,840
like we talked about before it can be a

469
00:20:03,880 --> 00:20:10,930
little tricky too if you purge it from

470
00:20:07,840 --> 00:20:12,610
commit history with a tool like BFG repo

471
00:20:10,930 --> 00:20:14,980
cleaner which is a really nice tool for

472
00:20:12,610 --> 00:20:16,810
doing that it'll go through and modify

473
00:20:14,980 --> 00:20:18,730
your history so that it removes that

474
00:20:16,810 --> 00:20:19,840
took and you end up with problems where

475
00:20:18,730 --> 00:20:21,670
you're out of sync with all of your

476
00:20:19,840 --> 00:20:23,230
co-workers so they'll try to pull on all

477
00:20:21,670 --> 00:20:25,090
of a sudden their history isn't the same

478
00:20:23,230 --> 00:20:26,420
as your history and you get all kinds of

479
00:20:25,090 --> 00:20:30,620
emerging issues

480
00:20:26,420 --> 00:20:32,660
and so I you know I don't have a good

481
00:20:30,620 --> 00:20:34,219
solution for addressing that I I do

482
00:20:32,660 --> 00:20:36,320
recommend purging it from the history

483
00:20:34,220 --> 00:20:38,060
that way tools like truffle hog dont

484
00:20:36,320 --> 00:20:41,149
false positive all the time with the

485
00:20:38,060 --> 00:20:42,710
rotated token but it isn't a perfect

486
00:20:41,150 --> 00:20:45,470
solution it does leave to some pain

487
00:20:42,710 --> 00:20:47,390
points you should definitely rotate the

488
00:20:45,470 --> 00:20:49,070
secret because after you pulled it out

489
00:20:47,390 --> 00:20:52,430
like I said before there's so many other

490
00:20:49,070 --> 00:20:54,770
places source code ends up you don't

491
00:20:52,430 --> 00:20:57,860
know where else that secret is it could

492
00:20:54,770 --> 00:20:59,090
be in paste bin it could be in slack and

493
00:20:57,860 --> 00:21:00,110
then you're going to want to keep track

494
00:20:59,090 --> 00:21:01,699
of all the secrets that you've pulled

495
00:21:00,110 --> 00:21:03,050
out of source code just to enforce that

496
00:21:01,700 --> 00:21:06,830
they've been rotated so you'll need some

497
00:21:03,050 --> 00:21:15,590
sort of key value store for that yeah

498
00:21:06,830 --> 00:21:16,490
another question for ya that's a really

499
00:21:15,590 --> 00:21:19,399
good point

500
00:21:16,490 --> 00:21:21,650
the point raised is basically if we're

501
00:21:19,400 --> 00:21:23,720
creating a centralized store of all the

502
00:21:21,650 --> 00:21:26,230
sensitive secrets in the company like

503
00:21:23,720 --> 00:21:28,700
that's the it's it's in itself

504
00:21:26,230 --> 00:21:30,950
introducing a kind of a single point of

505
00:21:28,700 --> 00:21:35,330
failure and that's that's totally a good

506
00:21:30,950 --> 00:21:36,680
a good point these secrets were and get

507
00:21:35,330 --> 00:21:40,280
and anybody could have ran truffle hog

508
00:21:36,680 --> 00:21:42,350
to extract them but putting them in a

509
00:21:40,280 --> 00:21:45,350
single central single point of failure

510
00:21:42,350 --> 00:21:48,610
makes it a little bit easier and that's

511
00:21:45,350 --> 00:21:55,490
you know it's a hard problem

512
00:21:48,610 --> 00:22:05,000
definitely so basically yep one more

513
00:21:55,490 --> 00:22:05,990
question yes the questions like why take

514
00:22:05,000 --> 00:22:08,660
it out of the repo if you're rolling it

515
00:22:05,990 --> 00:22:11,210
and my answer for that is basically if

516
00:22:08,660 --> 00:22:12,980
you run a another tool like truffle hog

517
00:22:11,210 --> 00:22:14,240
or like a static analysis tool it'll

518
00:22:12,980 --> 00:22:17,900
flag up as a false positive in the

519
00:22:14,240 --> 00:22:20,900
future and we we want to minify that

520
00:22:17,900 --> 00:22:24,190
basically looks like there's another

521
00:22:20,900 --> 00:22:24,190
question we kind of hold

522
00:22:24,930 --> 00:22:27,860
we couldn't yeah we could talk about it

523
00:22:26,460 --> 00:22:30,860
when I got through the slides basically

524
00:22:27,860 --> 00:22:34,530
I'll leave some time for Q&A at the end

525
00:22:30,860 --> 00:22:36,059
but if you remember earlier like I

526
00:22:34,530 --> 00:22:38,520
talked about all these other places that

527
00:22:36,059 --> 00:22:44,430
that secrets end up like not just source

528
00:22:38,520 --> 00:22:46,290
code and basically I this tool only

529
00:22:44,430 --> 00:22:48,990
addresses one of those secrets and so

530
00:22:46,290 --> 00:22:51,840
recently I spiked on another one of

531
00:22:48,990 --> 00:22:54,570
those places that source code lives and

532
00:22:51,840 --> 00:22:57,178
that place is package managers and the

533
00:22:54,570 --> 00:22:59,370
two that I put my main focus on was NPM

534
00:22:57,179 --> 00:23:02,460
and pi PI which is no js' is package

535
00:22:59,370 --> 00:23:04,250
manager and pythons package manager so

536
00:23:02,460 --> 00:23:08,160
what's interesting about these is

537
00:23:04,250 --> 00:23:11,010
basically when you package a package to

538
00:23:08,160 --> 00:23:13,830
NPM or pi PI it doesn't pull from your

539
00:23:11,010 --> 00:23:17,670
git source code it doesn't know it get

540
00:23:13,830 --> 00:23:18,960
is it pulls from your file system it in

541
00:23:17,670 --> 00:23:21,020
the case of NPM I think it pays

542
00:23:18,960 --> 00:23:24,840
attention to your dot git ignore file

543
00:23:21,020 --> 00:23:26,400
but if you had a testing script that had

544
00:23:24,840 --> 00:23:27,840
a secret in it that you didn't commit to

545
00:23:26,400 --> 00:23:30,270
source code and then you just package it

546
00:23:27,840 --> 00:23:32,220
up and sent it to MPN or pi PI that

547
00:23:30,270 --> 00:23:34,950
testing script will end up in NPM and pi

548
00:23:32,220 --> 00:23:36,510
PI with your secret and then people will

549
00:23:34,950 --> 00:23:38,130
pull down your package and they'll run

550
00:23:36,510 --> 00:23:40,500
them locally and not note that secret is

551
00:23:38,130 --> 00:23:42,330
there and you've replicated this AWS

552
00:23:40,500 --> 00:23:44,510
token distributed across hundreds of

553
00:23:42,330 --> 00:23:48,419
people running your open-source package

554
00:23:44,510 --> 00:23:51,360
and with worse is like again when you do

555
00:23:48,420 --> 00:23:54,360
this open source review they'll review

556
00:23:51,360 --> 00:23:56,250
the security overview the get code they

557
00:23:54,360 --> 00:23:59,309
probably won't pull down the package and

558
00:23:56,250 --> 00:24:02,820
and review that and similar to source

559
00:23:59,309 --> 00:24:05,370
code package managers have history they

560
00:24:02,820 --> 00:24:07,530
have versions and each of those versions

561
00:24:05,370 --> 00:24:09,149
can have their own keys so an older

562
00:24:07,530 --> 00:24:10,920
version can have a key but a future

563
00:24:09,150 --> 00:24:12,900
version doesn't have but that word that

564
00:24:10,920 --> 00:24:14,670
version can stay up and that key can

565
00:24:12,900 --> 00:24:18,929
stay alive and somebody can go in and

566
00:24:14,670 --> 00:24:21,330
find it later so basically what I found

567
00:24:18,929 --> 00:24:25,710
from experimenting is if you publish to

568
00:24:21,330 --> 00:24:27,419
a tiara to NPM or two pi PI and the

569
00:24:25,710 --> 00:24:30,780
description of your package contains the

570
00:24:27,420 --> 00:24:32,880
string AWS anywhere in it there's a two

571
00:24:30,780 --> 00:24:37,678
percent chance that your package will

572
00:24:32,880 --> 00:24:38,690
have a live AWS token in it so you know

573
00:24:37,679 --> 00:24:40,100
I talked about one of the reasons

574
00:24:38,690 --> 00:24:41,630
stink scripts and other reasons you may

575
00:24:40,100 --> 00:24:44,689
have an environment variable sourcing

576
00:24:41,630 --> 00:24:46,600
script in that same repository that you

577
00:24:44,690 --> 00:24:49,160
you just source when you run your code

578
00:24:46,600 --> 00:24:51,230
and so when you do your packaging to NPM

579
00:24:49,160 --> 00:24:53,360
or pi PI you may accidentally package up

580
00:24:51,230 --> 00:24:55,040
that environmental variable script even

581
00:24:53,360 --> 00:24:57,139
though I never ended up in version

582
00:24:55,040 --> 00:24:58,250
control and then the last version here

583
00:24:57,140 --> 00:25:00,200
the last reason here is like

584
00:24:58,250 --> 00:25:02,090
experimental code when I do experimental

585
00:25:00,200 --> 00:25:04,310
code again I struggle with the same

586
00:25:02,090 --> 00:25:07,490
problem I put secrets temporarily in the

587
00:25:04,310 --> 00:25:08,600
source code and pull them out later when

588
00:25:07,490 --> 00:25:10,280
you may think well that experimental

589
00:25:08,600 --> 00:25:12,439
code isn't tracked to my current version

590
00:25:10,280 --> 00:25:16,340
of yet and then you may package a new

591
00:25:12,440 --> 00:25:18,050
version to NPM or to PI pi thinking that

592
00:25:16,340 --> 00:25:19,370
only the current version of your your

593
00:25:18,050 --> 00:25:21,919
kit is what's getting packaged but

594
00:25:19,370 --> 00:25:23,780
actually the experimental code also gets

595
00:25:21,920 --> 00:25:27,890
packaged and your your secret gets sent

596
00:25:23,780 --> 00:25:29,990
up so I'm introducing this new tool and

597
00:25:27,890 --> 00:25:31,520
I'll just fold this closure ahead of

598
00:25:29,990 --> 00:25:35,120
time this is like a really dumb name

599
00:25:31,520 --> 00:25:37,580
that I gave it my that the thinking was

600
00:25:35,120 --> 00:25:40,189
basically like it's it's you you got

601
00:25:37,580 --> 00:25:42,980
packages so it's Santa Santa going going

602
00:25:40,190 --> 00:25:44,690
through packages and for consistency

603
00:25:42,980 --> 00:25:48,740
there's the hog of that and it didn't it

604
00:25:44,690 --> 00:25:52,850
didn't make sense but basically what

605
00:25:48,740 --> 00:25:55,430
Santa hog does is that's that's true it

606
00:25:52,850 --> 00:25:57,500
does have a very memorable name what

607
00:25:55,430 --> 00:25:59,660
Santa hog does is it goes through NPM

608
00:25:57,500 --> 00:26:00,650
and pipe I specifically and you may be

609
00:25:59,660 --> 00:26:03,200
thinking what about all the other

610
00:26:00,650 --> 00:26:04,760
package managers yeah I just didn't

611
00:26:03,200 --> 00:26:06,650
spike on those but I know for a fact

612
00:26:04,760 --> 00:26:08,690
they have secrets in them as well I

613
00:26:06,650 --> 00:26:09,950
don't have the tool for them but any

614
00:26:08,690 --> 00:26:12,890
other package manager you think oh

615
00:26:09,950 --> 00:26:14,900
probably has the same problem and it

616
00:26:12,890 --> 00:26:16,850
runs the same entropy regex checks the

617
00:26:14,900 --> 00:26:19,730
travel hog does on NPM and Python

618
00:26:16,850 --> 00:26:24,290
packages it's open source and it sits on

619
00:26:19,730 --> 00:26:25,370
my github and so I have a sample here of

620
00:26:24,290 --> 00:26:28,610
it running it doesn't have quite a

621
00:26:25,370 --> 00:26:31,090
pretty of an output it's a as trouble

622
00:26:28,610 --> 00:26:34,699
hog does currently but here I ran it on

623
00:26:31,090 --> 00:26:37,280
an uber package and you can you can see

624
00:26:34,700 --> 00:26:39,080
it's flagged on an AWS token a flyer on

625
00:26:37,280 --> 00:26:40,790
a bunch of private keys

626
00:26:39,080 --> 00:26:42,740
what's interesting here is if you

627
00:26:40,790 --> 00:26:45,700
actually dig into it a little bit and

628
00:26:42,740 --> 00:26:48,350
you look at that full path for the token

629
00:26:45,700 --> 00:26:50,300
it falls in a directory called node

630
00:26:48,350 --> 00:26:52,639
modules and if you know anything about

631
00:26:50,300 --> 00:26:55,070
nodejs the node modules

632
00:26:52,640 --> 00:26:57,410
directory is where all of your packages

633
00:26:55,070 --> 00:26:59,750
dependencies live and in some of these

634
00:26:57,410 --> 00:27:02,120
paths there's many different layers node

635
00:26:59,750 --> 00:27:05,030
modules this basically means these keys

636
00:27:02,120 --> 00:27:07,879
are dependencies of dependencies of

637
00:27:05,030 --> 00:27:10,250
dependencies so uber went to package

638
00:27:07,880 --> 00:27:12,950
this package and they accidentally

639
00:27:10,250 --> 00:27:14,750
packaged up their node modules instead

640
00:27:12,950 --> 00:27:18,049
of allowing that to get installed when

641
00:27:14,750 --> 00:27:20,390
you pull down their package and one of

642
00:27:18,049 --> 00:27:21,770
the dependencies that uber used happen

643
00:27:20,390 --> 00:27:23,240
to have a token in it that had nothing

644
00:27:21,770 --> 00:27:25,299
to do with uber it was just some random

645
00:27:23,240 --> 00:27:28,700
person that open-source this thing and

646
00:27:25,299 --> 00:27:32,480
then uber ended up packaging that

647
00:27:28,700 --> 00:27:36,830
dependency and then sharing that random

648
00:27:32,480 --> 00:27:38,540
strangers AWS token in their package so

649
00:27:36,830 --> 00:27:41,149
you know it kind of just goes back to

650
00:27:38,540 --> 00:27:43,129
like the source code is leaky and even

651
00:27:41,150 --> 00:27:46,460
if this random stranger on the internet

652
00:27:43,130 --> 00:27:47,660
ended up removing that token from their

653
00:27:46,460 --> 00:27:50,750
version of the package

654
00:27:47,660 --> 00:27:53,720
uber has already repackaged it and put

655
00:27:50,750 --> 00:27:55,160
it in their package and it's propagated

656
00:27:53,720 --> 00:27:59,059
and replicated across hundreds of

657
00:27:55,160 --> 00:28:02,020
people's machines at this point so

658
00:27:59,059 --> 00:28:05,149
here's my revised devops pipeline

659
00:28:02,020 --> 00:28:06,290
basically the inputs to the triage are

660
00:28:05,150 --> 00:28:08,299
different depending on what you're

661
00:28:06,290 --> 00:28:12,559
scanning and I've two things here that

662
00:28:08,299 --> 00:28:14,330
I'm scanning it and package managers but

663
00:28:12,559 --> 00:28:17,510
you can imagine building out a scanner

664
00:28:14,330 --> 00:28:19,309
for slack or for G suite or for anywhere

665
00:28:17,510 --> 00:28:22,669
else you may be worried about source

666
00:28:19,309 --> 00:28:24,790
code or secrets ending up and then that

667
00:28:22,669 --> 00:28:26,809
just funnels into the same triage step

668
00:28:24,790 --> 00:28:28,129
none of that's going to change somebody

669
00:28:26,809 --> 00:28:29,870
still has to verify whether or not that

670
00:28:28,130 --> 00:28:34,000
token is live and in the same

671
00:28:29,870 --> 00:28:34,000
remediation step of rotating that token

672
00:28:34,030 --> 00:28:39,530
so basically I've open sourced these

673
00:28:38,059 --> 00:28:41,299
tools and I'm kind of a one-man show

674
00:28:39,530 --> 00:28:44,270
I've had a lot of awesome people submit

675
00:28:41,299 --> 00:28:46,610
pull requests some of them have been

676
00:28:44,270 --> 00:28:47,990
able to service quicker than others it's

677
00:28:46,610 --> 00:28:49,250
kind of backed up recently because I've

678
00:28:47,990 --> 00:28:50,450
been working on a lot of talks and stuff

679
00:28:49,250 --> 00:28:53,150
like that but I could definitely use

680
00:28:50,450 --> 00:28:54,410
help from the community I do get to pull

681
00:28:53,150 --> 00:28:56,419
requests eventually and there's more

682
00:28:54,410 --> 00:28:59,660
features that I want to add definitely

683
00:28:56,419 --> 00:29:01,910
improve the regex isn't add more I'd

684
00:28:59,660 --> 00:29:04,100
like to be able to improve its ability

685
00:29:01,910 --> 00:29:05,750
to scan a range of commits currently it

686
00:29:04,100 --> 00:29:07,759
clones the whole

687
00:29:05,750 --> 00:29:09,529
get source code and then it does the

688
00:29:07,759 --> 00:29:12,529
scan on a range but it'd be nice if it

689
00:29:09,529 --> 00:29:14,779
only fetched the subsection just to

690
00:29:12,529 --> 00:29:16,789
improve on performance currently it's

691
00:29:14,779 --> 00:29:18,080
not multi-threaded single-threaded all

692
00:29:16,789 --> 00:29:19,789
this stuff that I could use community

693
00:29:18,080 --> 00:29:22,428
help for and then lots more features

694
00:29:19,789 --> 00:29:24,740
that I can't even think of it's not my

695
00:29:22,429 --> 00:29:26,269
github but again like feel free to drop

696
00:29:24,740 --> 00:29:27,320
me a message ahead of time if you've got

697
00:29:26,269 --> 00:29:30,740
a feature you're thinking about and you

698
00:29:27,320 --> 00:29:32,389
want to work on we can collaborate and

699
00:29:30,740 --> 00:29:33,350
then I pulled those red x's out because

700
00:29:32,389 --> 00:29:36,289
I know people are going to be building

701
00:29:33,350 --> 00:29:37,370
other tools like slack integrations or

702
00:29:36,289 --> 00:29:40,820
whatever else you want to run these

703
00:29:37,370 --> 00:29:42,559
regex is on so those are available in a

704
00:29:40,820 --> 00:29:44,870
separate repo now and just a JSON file

705
00:29:42,559 --> 00:29:49,820
that you can you can import for your own

706
00:29:44,870 --> 00:29:51,949
needs so the last step here that I want

707
00:29:49,820 --> 00:29:53,990
to highlight we talked about the triage

708
00:29:51,950 --> 00:29:55,820
step and the really gross part is it's

709
00:29:53,990 --> 00:29:59,330
manual like nobody wants to manually go

710
00:29:55,820 --> 00:30:01,279
through a pile of false positives that's

711
00:29:59,330 --> 00:30:03,230
a it's a really gross job that people

712
00:30:01,279 --> 00:30:06,230
would get fed up with and quit it's like

713
00:30:03,230 --> 00:30:07,879
that was their full-time job and so like

714
00:30:06,230 --> 00:30:09,200
you may be thinking like we can automate

715
00:30:07,879 --> 00:30:11,299
this right like I've had the thought a

716
00:30:09,200 --> 00:30:13,580
lot of times and I've actually build out

717
00:30:11,299 --> 00:30:16,309
Automator x' in the past of like if you

718
00:30:13,580 --> 00:30:18,408
know it's an AWS token or it looks and

719
00:30:16,309 --> 00:30:21,610
smells like an AWS token just test it

720
00:30:18,409 --> 00:30:24,350
against AWS see whether or not AWS

721
00:30:21,610 --> 00:30:25,758
returns back yes this is your token and

722
00:30:24,350 --> 00:30:26,990
then you can automate the triage you

723
00:30:25,759 --> 00:30:28,519
don't even need a human to come in and

724
00:30:26,990 --> 00:30:30,769
and see whether or not that token is a

725
00:30:28,519 --> 00:30:36,500
true positive or live token you just

726
00:30:30,769 --> 00:30:39,679
completely automate it well so this is

727
00:30:36,500 --> 00:30:42,940
an example a verifier that does just

728
00:30:39,679 --> 00:30:46,129
that it takes in a token tries to do a

729
00:30:42,940 --> 00:30:47,750
SES call with the AWS token and then

730
00:30:46,129 --> 00:30:50,899
returns true or false for whether or not

731
00:30:47,750 --> 00:30:53,269
that token is there it's really nice

732
00:30:50,899 --> 00:30:56,750
but there are some drawbacks to that

733
00:30:53,269 --> 00:30:59,659
approach I'll start by saying a model

734
00:30:56,750 --> 00:31:02,860
lawyer but if you if you think about

735
00:30:59,659 --> 00:31:06,049
that uber example like uber packaged a

736
00:31:02,860 --> 00:31:07,789
sub dependency of a sub dependency that

737
00:31:06,049 --> 00:31:09,470
included a token from some stranger that

738
00:31:07,789 --> 00:31:10,789
built this package in some weird part of

739
00:31:09,470 --> 00:31:12,529
the planet

740
00:31:10,789 --> 00:31:14,960
uber had nothing to do with that so

741
00:31:12,529 --> 00:31:17,389
let's say uber built a system that

742
00:31:14,960 --> 00:31:19,490
automatically triaged whether or not

743
00:31:17,389 --> 00:31:21,860
tokens were flying through there

744
00:31:19,490 --> 00:31:23,840
DevOps pipeline and let's say it ran on

745
00:31:21,860 --> 00:31:26,449
every package before they package it to

746
00:31:23,840 --> 00:31:28,189
NP amour pi PI what would end up

747
00:31:26,450 --> 00:31:29,750
happening in that case is they would end

748
00:31:28,190 --> 00:31:32,470
up pulling down this random strangers

749
00:31:29,750 --> 00:31:34,910
token and offing against AWS with it and

750
00:31:32,470 --> 00:31:37,460
because that stranger hasn't given you

751
00:31:34,910 --> 00:31:39,290
consent or permission to do that

752
00:31:37,460 --> 00:31:40,429
you're probably violating the Computer

753
00:31:39,290 --> 00:31:41,809
Fraud Abuse Act

754
00:31:40,429 --> 00:31:44,300
you're probably authenticating to a

755
00:31:41,809 --> 00:31:45,800
system that you don't have access to so

756
00:31:44,300 --> 00:31:49,399
you have to be really careful with this

757
00:31:45,800 --> 00:31:50,780
approach rogue keys can appear in your

758
00:31:49,400 --> 00:31:54,320
source code that didn't come from your

759
00:31:50,780 --> 00:31:56,000
environment and you probably shouldn't

760
00:31:54,320 --> 00:31:59,149
use this approach for bug bounties for

761
00:31:56,000 --> 00:32:01,520
the same reason like most time bug

762
00:31:59,150 --> 00:32:03,050
bounties will set up you know rules that

763
00:32:01,520 --> 00:32:04,820
are like you're not allowed to move

764
00:32:03,050 --> 00:32:08,360
laterally or like if you've gained

765
00:32:04,820 --> 00:32:11,000
access to this system stop testing and

766
00:32:08,360 --> 00:32:12,439
so if you set up this automatic verifier

767
00:32:11,000 --> 00:32:14,540
system where you're pulling down their

768
00:32:12,440 --> 00:32:15,890
tokens and offing with it

769
00:32:14,540 --> 00:32:17,450
number one you're gonna give them a big

770
00:32:15,890 --> 00:32:19,370
scare because they're gonna see that

771
00:32:17,450 --> 00:32:21,350
that token was actually used by a random

772
00:32:19,370 --> 00:32:22,790
stranger on the internet but number two

773
00:32:21,350 --> 00:32:25,159
they probably didn't give you permission

774
00:32:22,790 --> 00:32:27,200
you're probably breaking the CFAA if you

775
00:32:25,160 --> 00:32:29,510
do that so I'm not saying you can't use

776
00:32:27,200 --> 00:32:34,220
Auto verifiers I'm just not a lawyer and

777
00:32:29,510 --> 00:32:38,420
I'm not gonna there's some interesting

778
00:32:34,220 --> 00:32:40,730
components to that and then before I

779
00:32:38,420 --> 00:32:42,410
mentioned like there are all these other

780
00:32:40,730 --> 00:32:44,270
things that I didn't build scanners for

781
00:32:42,410 --> 00:32:45,770
fortunately some folks in the internet

782
00:32:44,270 --> 00:32:48,139
have built them for some of these

783
00:32:45,770 --> 00:32:50,809
applications so this is a really nice

784
00:32:48,140 --> 00:32:52,790
tool that some folks may have used

785
00:32:50,809 --> 00:32:54,910
before you put an Android package name

786
00:32:52,790 --> 00:32:57,379
there and it'll just scan for secrets

787
00:32:54,910 --> 00:32:59,380
but again like systemic problem of

788
00:32:57,380 --> 00:33:02,960
people packaging secrets in source code

789
00:32:59,380 --> 00:33:04,900
and in the Android store you can get AWS

790
00:33:02,960 --> 00:33:09,230
tokens and other gnarly secrets from

791
00:33:04,900 --> 00:33:13,460
folks that have packaged and Android

792
00:33:09,230 --> 00:33:15,290
apps too that the public Play Store so

793
00:33:13,460 --> 00:33:17,870
this is a link to all the things I

794
00:33:15,290 --> 00:33:20,059
talked about travel log the most popular

795
00:33:17,870 --> 00:33:22,159
one santa hog the relatively new one and

796
00:33:20,059 --> 00:33:24,610
then just the standalone regex is if you

797
00:33:22,160 --> 00:33:26,929
just want to write your own

798
00:33:24,610 --> 00:33:31,449
infrastructure for slack or whatever

799
00:33:26,929 --> 00:33:33,560
else that's that's basically all I have

800
00:33:31,450 --> 00:33:35,570
but I know there was some question

801
00:33:33,560 --> 00:33:41,169
so I'm gonna open it up to Q&A if we saw

802
00:33:35,570 --> 00:33:41,169
them yeah it's not some questions yes

803
00:33:53,950 --> 00:33:59,770
yeah let me go back to the specific call

804
00:33:57,320 --> 00:34:03,220
the question was whether an ia WS has a

805
00:33:59,770 --> 00:34:05,750
has a an endpoint that allows you to

806
00:34:03,220 --> 00:34:07,100
basically without performing any state

807
00:34:05,750 --> 00:34:11,210
changing actions see whether or not the

808
00:34:07,100 --> 00:34:13,310
token is live this STS token will just

809
00:34:11,210 --> 00:34:14,780
tell you the identity of the token I'll

810
00:34:13,310 --> 00:34:16,790
tell you which AWS account it's

811
00:34:14,780 --> 00:34:18,740
associated with it's relatively

812
00:34:16,790 --> 00:34:22,429
non-destructive but it does return

813
00:34:18,739 --> 00:34:24,020
information that is potentially

814
00:34:22,429 --> 00:34:26,449
privileged information like AWS account

815
00:34:24,020 --> 00:34:28,280
it's associated with you bring up a

816
00:34:26,449 --> 00:34:32,290
really another point that I didn't get a

817
00:34:28,280 --> 00:34:36,170
chance to talk about but like not every

818
00:34:32,290 --> 00:34:37,429
API has a nice friendly API endpoint

819
00:34:36,170 --> 00:34:39,470
that you can hit that tells you whether

820
00:34:37,429 --> 00:34:40,819
or not the token is live and some of

821
00:34:39,469 --> 00:34:43,879
them depending on the scope you give

822
00:34:40,820 --> 00:34:46,400
that ADA that that token it's not really

823
00:34:43,880 --> 00:34:48,950
easy to to test whether or not that

824
00:34:46,400 --> 00:34:50,389
token is live without trying a suite of

825
00:34:48,949 --> 00:34:52,520
endpoints because it was only scopes to

826
00:34:50,389 --> 00:34:54,560
these endpoints and you don't know what

827
00:34:52,520 --> 00:34:56,360
scope the token is has you have to kind

828
00:34:54,560 --> 00:34:59,660
of test its scope and it's kind of messy

829
00:34:56,360 --> 00:35:01,700
and requires multiple requests but yeah

830
00:34:59,660 --> 00:35:04,100
it'd be really nice if people building

831
00:35:01,700 --> 00:35:05,960
API is built an endpoint specifically

832
00:35:04,100 --> 00:35:07,640
designed to see whether or not the token

833
00:35:05,960 --> 00:35:08,840
was live built in terms and conditions

834
00:35:07,640 --> 00:35:11,210
saying we allow strangers on the

835
00:35:08,840 --> 00:35:12,410
Internet to at the send point but that

836
00:35:11,210 --> 00:35:18,340
isn't a feature that I've seen anybody

837
00:35:12,410 --> 00:35:18,339
build yes question

838
00:35:24,550 --> 00:35:34,340
yeah yeah so the question was basically

839
00:35:31,810 --> 00:35:35,990
developers are commonly pushing over the

840
00:35:34,340 --> 00:35:38,110
top of these secrets and they're not

841
00:35:35,990 --> 00:35:40,160
like rotating them and they're not like

842
00:35:38,110 --> 00:35:41,890
rectifying the problem they're just kind

843
00:35:40,160 --> 00:35:43,879
of bearing it is that more of like a

844
00:35:41,890 --> 00:35:44,960
human problem that maybe you can fix

845
00:35:43,880 --> 00:35:46,460
with like training or something like

846
00:35:44,960 --> 00:35:48,140
that as opposed to like a technical

847
00:35:46,460 --> 00:35:51,950
problem that we can solve with it with a

848
00:35:48,140 --> 00:35:53,990
tool I'm kind of approached like I'm an

849
00:35:51,950 --> 00:35:55,669
engineer and maybe this is a bias but

850
00:35:53,990 --> 00:35:59,089
I'm kind of with the approach that like

851
00:35:55,670 --> 00:36:00,260
if you have a human problem like no

852
00:35:59,090 --> 00:36:01,730
amount of training is ever going to

853
00:36:00,260 --> 00:36:04,040
completely get rid of it like law of

854
00:36:01,730 --> 00:36:05,780
large numbers you'll always have some

855
00:36:04,040 --> 00:36:07,640
percentage of your engineers doing this

856
00:36:05,780 --> 00:36:09,080
mistake and that's kind of where I try

857
00:36:07,640 --> 00:36:14,950
to supplement that gap with technical

858
00:36:09,080 --> 00:36:14,950
tools yes yeah that's good

859
00:36:22,859 --> 00:36:29,619
yeah that's a good point

860
00:36:25,559 --> 00:36:31,180
basically she said like that this could

861
00:36:29,619 --> 00:36:32,920
come out of like almost embarrassment of

862
00:36:31,180 --> 00:36:34,269
like if you if you push something and

863
00:36:32,920 --> 00:36:35,500
you want to come it over the top of it

864
00:36:34,269 --> 00:36:37,868
but you don't want to have to deal with

865
00:36:35,500 --> 00:36:40,390
merge conflicts it's just kind of a

866
00:36:37,869 --> 00:36:43,059
quiet way to make this go away without

867
00:36:40,390 --> 00:36:45,368
anyone noticing and that that's a good

868
00:36:43,059 --> 00:36:47,349
point and I think like our technical

869
00:36:45,369 --> 00:36:52,079
solutions should should be accommodating

870
00:36:47,349 --> 00:36:52,079
of that in some in some capacity yes

871
00:37:09,220 --> 00:37:12,279
[Music]

872
00:37:15,089 --> 00:37:20,049
I'm saying

873
00:37:17,000 --> 00:37:23,250
this is an issue it's

874
00:37:20,050 --> 00:37:23,250
raise that

875
00:37:25,610 --> 00:37:30,310
so he had some good automation your

876
00:37:27,260 --> 00:37:30,310
tools right how do you

877
00:37:35,270 --> 00:37:40,440
instead as part of your CI checks yeah a

878
00:37:38,820 --> 00:37:42,450
thing that says hey this is an issue

879
00:37:40,440 --> 00:37:45,210
right you need someone to the ops team

880
00:37:42,450 --> 00:37:46,589
for sign off if it's retroactive it's

881
00:37:45,210 --> 00:37:48,990
always going to be contentious so the

882
00:37:46,590 --> 00:37:50,340
point of this is to is to put automated

883
00:37:48,990 --> 00:37:57,509
checks in place so that's never

884
00:37:50,340 --> 00:37:59,100
retroactive yeah so one yeah one

885
00:37:57,510 --> 00:38:00,810
possible solution is to have this is

886
00:37:59,100 --> 00:38:02,310
like a pre-commit hooker to build it

887
00:38:00,810 --> 00:38:24,660
into the IDE so that it doesn't even

888
00:38:02,310 --> 00:38:27,500
make it in the yes who knows how many

889
00:38:24,660 --> 00:38:27,500
dev teams with

890
00:38:29,150 --> 00:39:08,130
yeah yeah that's a good plan and I think

891
00:39:05,850 --> 00:39:10,560
like more on that like your first

892
00:39:08,130 --> 00:39:13,080
rolling something like this out you want

893
00:39:10,560 --> 00:39:14,790
to be super light touch if you like

894
00:39:13,080 --> 00:39:16,049
aggressively go in with hard blockers

895
00:39:14,790 --> 00:39:17,940
and stuff like that you're going to end

896
00:39:16,050 --> 00:39:19,880
up with a lot of unhappy developers and

897
00:39:17,940 --> 00:39:23,480
breaking production more often than not

898
00:39:19,880 --> 00:39:23,480
yeah question the French

899
00:39:47,920 --> 00:39:52,430
let's face it if you work in the

900
00:39:50,059 --> 00:39:56,589
security there's one of you for every

901
00:39:52,430 --> 00:39:56,589
hundred yeah and so

902
00:39:59,380 --> 00:40:08,930
pipeline from security it's not walking

903
00:40:06,770 --> 00:40:11,119
but as soon as your pipeline triggers

904
00:40:08,930 --> 00:40:13,940
there's a large to look for Thanks yeah

905
00:40:11,119 --> 00:40:17,440
otherwise you still have to pull me

906
00:40:13,940 --> 00:40:17,440
aside every time we can keep in touch

907
00:40:17,500 --> 00:40:22,150
right yeah I'm not confident up to say

908
00:40:20,530 --> 00:40:25,150
this with 100% but almost other

909
00:40:22,150 --> 00:40:26,890
philosophy that like if if you start

910
00:40:25,150 --> 00:40:32,050
building out an AB sect team before you

911
00:40:26,890 --> 00:40:33,670
have a good ops pipeline op story it's

912
00:40:32,050 --> 00:40:37,480
just like what are you doing it's like

913
00:40:33,670 --> 00:40:38,859
you're just like adding issues to you

914
00:40:37,480 --> 00:40:40,680
know when there's more systemic problems

915
00:40:38,859 --> 00:40:47,609
that should be addressed first I think

916
00:40:40,680 --> 00:40:47,609
yeah that's true that's also true

917
00:40:47,910 --> 00:40:50,808
question back

918
00:40:57,940 --> 00:41:02,800
yeah

919
00:41:00,140 --> 00:41:02,799
the thing is

920
00:41:13,470 --> 00:41:16,569
[Music]

921
00:41:17,290 --> 00:41:21,040
yeah I would not have fired that

922
00:41:19,000 --> 00:41:22,390
engineering primer burn because the

923
00:41:21,040 --> 00:41:25,080
difference between a culture of weighing

924
00:41:22,390 --> 00:41:25,080
the culture

925
00:41:33,600 --> 00:41:38,150
you know they couldn't fire their future

926
00:41:47,050 --> 00:41:51,790
yeah an engineering solution is just

927
00:41:51,970 --> 00:41:54,970
something

928
00:42:03,450 --> 00:42:15,029
any more questions yep yeah so right now

929
00:42:11,760 --> 00:42:19,170
what Santa hog is is basically it will

930
00:42:15,030 --> 00:42:22,559
pull down the Reg X's that I have

931
00:42:19,170 --> 00:42:25,500
abstracted out truffle hog and then it

932
00:42:22,559 --> 00:42:27,750
just runs those dumb reg X's on the

933
00:42:25,500 --> 00:42:30,390
unzipped versions of your npm your pi PI

934
00:42:27,750 --> 00:42:32,880
package and it hard codes the NPM and pi

935
00:42:30,390 --> 00:42:34,828
PI hosts I should abstract that out so

936
00:42:32,880 --> 00:42:37,619
you can run them on internal NPM and pi

937
00:42:34,829 --> 00:42:39,329
PI stand-ups but it's not extensible in

938
00:42:37,619 --> 00:42:43,559
the fact that like you couldn't easily

939
00:42:39,329 --> 00:42:44,970
have it scan but yeah exactly I know

940
00:42:43,559 --> 00:42:51,799
another package manager you'd have to

941
00:42:44,970 --> 00:42:54,149
build out API calls for that yeah yeah I

942
00:42:51,799 --> 00:42:56,339
wondered whether or not I should spike

943
00:42:54,150 --> 00:43:00,839
on like maven or something like that and

944
00:42:56,339 --> 00:43:02,670
I just decided because it was like there

945
00:43:00,839 --> 00:43:04,619
was some kind of compliation step there

946
00:43:02,670 --> 00:43:07,200
I decided not to start with that just

947
00:43:04,619 --> 00:43:11,010
start with situations that just have raw

948
00:43:07,200 --> 00:43:12,529
source code being uploaded but yeah all

949
00:43:11,010 --> 00:43:14,970
those things should be explored and

950
00:43:12,530 --> 00:43:18,869
somebody should should help me build

951
00:43:14,970 --> 00:43:23,328
that stuff out definitely I think did

952
00:43:18,869 --> 00:43:27,260
you have a your hand up or your hat I

953
00:43:23,329 --> 00:43:27,260
think in the rear and then the front

954
00:43:36,109 --> 00:43:45,348
thank you appreciate it yeah so actually

955
00:43:42,200 --> 00:43:48,348
I apologize to every hog farmer out

956
00:43:45,349 --> 00:43:51,049
there because of you Google truffle hog

957
00:43:48,349 --> 00:43:57,009
on the front page of Google you get this

958
00:43:51,049 --> 00:44:00,469
tool so for all those poor people

959
00:43:57,009 --> 00:44:05,359
looking for a hog slop and end up with

960
00:44:00,469 --> 00:44:07,069
this weird tech stuff I'm I'm sorry but

961
00:44:05,359 --> 00:44:08,209
yeah trouble trouble looks pretty easy

962
00:44:07,069 --> 00:44:10,670
to find out if you want to find Santa

963
00:44:08,209 --> 00:44:12,140
hog and all the other stuff once you

964
00:44:10,670 --> 00:44:16,099
find trouble hog they're all under my

965
00:44:12,140 --> 00:44:27,440
user name and then the links are at the

966
00:44:16,099 --> 00:44:29,690
end yep yep yeah yeah we're open s3

967
00:44:27,440 --> 00:44:31,670
buckets another one somebody once told

968
00:44:29,690 --> 00:44:34,160
me about a tool that will like

969
00:44:31,670 --> 00:44:37,219
recursively go to an s of an open s3

970
00:44:34,160 --> 00:44:39,319
bucket and then find tokens for more s3

971
00:44:37,219 --> 00:44:46,489
buckets and then off to those look for

972
00:44:39,319 --> 00:44:50,239
more tokens and just yes that that

973
00:44:46,489 --> 00:44:55,539
supposedly works yeah lateral movement

974
00:44:50,239 --> 00:44:58,809
in the cloud any other questions oh

975
00:44:55,539 --> 00:44:58,809
thank you everyone

976
00:44:59,010 --> 00:45:03,189
[Applause]

