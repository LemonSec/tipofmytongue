1
00:00:02,000 --> 00:00:06,839
all right so we're gonna start off this

2
00:00:04,830 --> 00:00:08,580
day's talk with sub Turing machines with

3
00:00:06,839 --> 00:00:11,750
that Falcon dog star here so please

4
00:00:08,580 --> 00:00:17,359
welcome him to the torque up camp stage

5
00:00:11,750 --> 00:00:21,119
[Applause]

6
00:00:17,359 --> 00:00:22,740
to see the stage again and of course I'm

7
00:00:21,119 --> 00:00:25,710
excited these talks for being simulcast

8
00:00:22,740 --> 00:00:27,509
now hello ball um where is that cave

9
00:00:25,710 --> 00:00:30,179
well I don't know if that's a actual

10
00:00:27,510 --> 00:00:31,880
callsign but okay anyways um sub Turing

11
00:00:30,179 --> 00:00:35,339
machines the end of unknown unknowns

12
00:00:31,880 --> 00:00:37,410
this is composed of a lot of information

13
00:00:35,340 --> 00:00:39,660
that I've been working on for the past

14
00:00:37,410 --> 00:00:42,120
few years with much of the language

15
00:00:39,660 --> 00:00:45,089
theoretic security research crowd so I

16
00:00:42,120 --> 00:00:46,800
owe many citations to to Sergei

17
00:00:45,090 --> 00:00:48,390
brightest to Meredith Patterson you got

18
00:00:46,800 --> 00:00:53,459
married on the stage two years ago I

19
00:00:48,390 --> 00:00:54,809
think and to so many others the rest of

20
00:00:53,460 --> 00:00:56,460
the information from this talk comes

21
00:00:54,809 --> 00:00:58,680
from our experience attempting to build

22
00:00:56,460 --> 00:01:00,840
our camp project this year and the the

23
00:00:58,680 --> 00:01:03,420
phone switch that ended up not quite

24
00:01:00,840 --> 00:01:05,640
being ready but we learned a heck of a

25
00:01:03,420 --> 00:01:08,220
lot about electronics design and the

26
00:01:05,640 --> 00:01:10,619
mechanisms in which we designed it were

27
00:01:08,220 --> 00:01:13,650
intended to convey a large amount of the

28
00:01:10,619 --> 00:01:17,729
sense of language theoretic security so

29
00:01:13,650 --> 00:01:19,860
with that mmm with that I'll just

30
00:01:17,729 --> 00:01:21,119
quickly reintroduce myself I'm a

31
00:01:19,860 --> 00:01:24,210
security consultant to Leviathan

32
00:01:21,119 --> 00:01:26,009
security I'm still working on my thesis

33
00:01:24,210 --> 00:01:28,408
so that the basket I just trying to

34
00:01:26,009 --> 00:01:32,369
finish up here I'm and I'm sure you tell

35
00:01:28,409 --> 00:01:33,990
us systems engineer um I also got a

36
00:01:32,369 --> 00:01:35,880
paper published since the last time that

37
00:01:33,990 --> 00:01:38,009
I was here it's called the seven turrets

38
00:01:35,880 --> 00:01:39,899
of Babel a taxonomy of Lange suckers and

39
00:01:38,009 --> 00:01:42,509
how to expunge them what this paper does

40
00:01:39,900 --> 00:01:44,790
is it taxon amazes the various issues

41
00:01:42,509 --> 00:01:46,649
that that language theoretic security

42
00:01:44,790 --> 00:01:48,420
positives exist in programs not as

43
00:01:46,649 --> 00:01:50,369
individual bugs but rather as design

44
00:01:48,420 --> 00:01:52,110
patterns because language theoretic

45
00:01:50,369 --> 00:01:54,479
security is a design pattern and driven

46
00:01:52,110 --> 00:01:56,399
methodology this paper is available

47
00:01:54,479 --> 00:01:59,880
freely it was published at I Triple E

48
00:01:56,399 --> 00:02:01,680
and secure development so it's you don't

49
00:01:59,880 --> 00:02:03,869
have to go through a paywall to access

50
00:02:01,680 --> 00:02:05,310
it some of the content that I give is

51
00:02:03,869 --> 00:02:07,290
also available in that paper merely

52
00:02:05,310 --> 00:02:11,250
because it is necessary background but

53
00:02:07,290 --> 00:02:13,350
so without further ado I know that every

54
00:02:11,250 --> 00:02:14,700
time we come up and talk about laying

55
00:02:13,350 --> 00:02:16,890
there are a lot of people in the crowd

56
00:02:14,700 --> 00:02:19,619
who are already familiar with it

57
00:02:16,890 --> 00:02:21,149
and studied it extensively in school I'm

58
00:02:19,620 --> 00:02:23,130
sure and then there are lots of people

59
00:02:21,150 --> 00:02:24,570
who just kind of wonder what it is and

60
00:02:23,130 --> 00:02:27,090
how they can make it work for them so

61
00:02:24,570 --> 00:02:28,980
language theoretic security and as my

62
00:02:27,090 --> 00:02:31,320
favorite way to explain it there's a lot

63
00:02:28,980 --> 00:02:32,820
of math we do the following math for

64
00:02:31,320 --> 00:02:34,260
example we use this particular piece of

65
00:02:32,820 --> 00:02:36,239
math to describe a finite state

66
00:02:34,260 --> 00:02:41,720
automaton a finite state automaton is a

67
00:02:36,240 --> 00:02:44,280
machine this machine is composed of some

68
00:02:41,720 --> 00:02:45,480
elements I won't bother going through

69
00:02:44,280 --> 00:02:47,820
this math this really is not necessary

70
00:02:45,480 --> 00:02:49,470
tender standard at all a finite state

71
00:02:47,820 --> 00:02:51,480
automaton is a machine it has a number

72
00:02:49,470 --> 00:02:53,190
of states they're defined transitions to

73
00:02:51,480 --> 00:02:54,660
each of those states based on each input

74
00:02:53,190 --> 00:02:56,240
character so it processes an input

75
00:02:54,660 --> 00:02:59,190
character moves to another state and

76
00:02:56,240 --> 00:03:01,200
then at the end if the state is deemed

77
00:02:59,190 --> 00:03:02,910
to be an accepting state it decides the

78
00:03:01,200 --> 00:03:04,440
vet string is real if that states not an

79
00:03:02,910 --> 00:03:07,440
accepting state it deems that that

80
00:03:04,440 --> 00:03:08,790
string is not good rejected you might

81
00:03:07,440 --> 00:03:10,410
recognize this from the way that we

82
00:03:08,790 --> 00:03:12,299
typically implement regular expressions

83
00:03:10,410 --> 00:03:13,650
because the finite state automaton and a

84
00:03:12,300 --> 00:03:17,420
regular expression are precisely

85
00:03:13,650 --> 00:03:19,500
equivalent and so a regex match is

86
00:03:17,420 --> 00:03:21,149
basically just the simplest kind of

87
00:03:19,500 --> 00:03:23,040
parser that you can get if you define

88
00:03:21,150 --> 00:03:24,720
your regular expression correctly you'll

89
00:03:23,040 --> 00:03:26,190
be able to parse the input and check

90
00:03:24,720 --> 00:03:27,510
that it's valid correctly before you

91
00:03:26,190 --> 00:03:29,460
even do anything else with it the only

92
00:03:27,510 --> 00:03:30,780
thing that you have to know is that

93
00:03:29,460 --> 00:03:32,280
you're a non-deterministic finite

94
00:03:30,780 --> 00:03:34,170
automaton that is your regular

95
00:03:32,280 --> 00:03:35,850
expression all of our things have

96
00:03:34,170 --> 00:03:37,730
intimidating sounding names and they're

97
00:03:35,850 --> 00:03:41,130
not really intimidating at all um

98
00:03:37,730 --> 00:03:42,420
accepts or rejected mmm and that gives

99
00:03:41,130 --> 00:03:43,530
you the power of a whole set of

100
00:03:42,420 --> 00:03:45,209
assumptions right

101
00:03:43,530 --> 00:03:47,280
you can now assume that because it's

102
00:03:45,210 --> 00:03:49,170
valid all of your logic code can just

103
00:03:47,280 --> 00:03:52,890
assume that everything is in the right

104
00:03:49,170 --> 00:03:54,540
place that the input itself is valid if

105
00:03:52,890 --> 00:03:57,660
your specification is strong enough that

106
00:03:54,540 --> 00:03:58,880
that input is non malicious and you're

107
00:03:57,660 --> 00:04:01,200
good to go

108
00:03:58,880 --> 00:04:03,269
so that was about three of our design

109
00:04:01,200 --> 00:04:04,920
patterns at once by the way hi but

110
00:04:03,270 --> 00:04:07,140
mostly it was about limiting complexity

111
00:04:04,920 --> 00:04:08,280
and about validating input before you

112
00:04:07,140 --> 00:04:12,029
parsed it which is the opposite of

113
00:04:08,280 --> 00:04:13,650
shotgun parsing so importantly language

114
00:04:12,030 --> 00:04:14,880
theoretic security has absolutely

115
00:04:13,650 --> 00:04:17,640
nothing to do with the programming

116
00:04:14,880 --> 00:04:18,899
language in which you're writing unless

117
00:04:17,640 --> 00:04:20,039
the programming language is really too

118
00:04:18,899 --> 00:04:21,539
weak to support the things you're trying

119
00:04:20,040 --> 00:04:23,370
to do which is another problem entirely

120
00:04:21,540 --> 00:04:24,990
it's more about how the machine that you

121
00:04:23,370 --> 00:04:27,270
built works the machine that emulates

122
00:04:24,990 --> 00:04:28,800
your input more narrowly

123
00:04:27,270 --> 00:04:30,240
it is about what class of machine it is

124
00:04:28,800 --> 00:04:33,060
and how well that machine is specified

125
00:04:30,240 --> 00:04:34,830
so here's a machine um I don't know if

126
00:04:33,060 --> 00:04:36,060
this is gonna come up clearly maybe I

127
00:04:34,830 --> 00:04:38,609
should have blown the diagram up a

128
00:04:36,060 --> 00:04:44,069
little bit um can anyone actually see

129
00:04:38,610 --> 00:04:45,990
this okay good um so this machine is a

130
00:04:44,069 --> 00:04:47,879
little device and what this device is is

131
00:04:45,990 --> 00:04:52,080
as part of the phone switch that we have

132
00:04:47,879 --> 00:04:53,759
about 85% built and the purpose of this

133
00:04:52,080 --> 00:04:55,139
machine in general is when somebody

134
00:04:53,759 --> 00:04:56,909
picks up a phone or some other event

135
00:04:55,139 --> 00:04:59,490
happens on a phone line it's supposed to

136
00:04:56,909 --> 00:05:01,789
figure out where in the switch fabric

137
00:04:59,490 --> 00:05:05,130
that line is supposed to be connected um

138
00:05:01,789 --> 00:05:08,270
so you see this the circuit has a couple

139
00:05:05,130 --> 00:05:10,289
of things in it it has that 157

140
00:05:08,270 --> 00:05:12,719
multiplexer over there for channel

141
00:05:10,289 --> 00:05:13,409
multiplexer and it has a latch over

142
00:05:12,720 --> 00:05:16,110
there

143
00:05:13,409 --> 00:05:18,800
it has five diodes and actually I cut

144
00:05:16,110 --> 00:05:21,930
off the bottom because it's just LEDs

145
00:05:18,800 --> 00:05:23,550
that's and a few passives are actually

146
00:05:21,930 --> 00:05:25,620
the only pieces of complexity in this

147
00:05:23,550 --> 00:05:32,310
machine how many bugs do you think it

148
00:05:25,620 --> 00:05:33,719
has lots okay information theory tells

149
00:05:32,310 --> 00:05:35,880
us that there could only be so many bugs

150
00:05:33,719 --> 00:05:37,409
because this is this representation my

151
00:05:35,880 --> 00:05:39,479
code is an encoding of the bugs that I

152
00:05:37,409 --> 00:05:41,430
write and so if my code is too small

153
00:05:39,479 --> 00:05:46,740
then there can't be that many but

154
00:05:41,430 --> 00:05:48,690
there's at least one um and this one

155
00:05:46,740 --> 00:05:51,000
just because hardware is hard um it's

156
00:05:48,690 --> 00:05:52,349
because state machines also tend to have

157
00:05:51,000 --> 00:05:55,409
emergent properties when you have a

158
00:05:52,349 --> 00:05:58,139
requisite amount of complexity we we

159
00:05:55,409 --> 00:05:59,669
tend to arrive at functionality that we

160
00:05:58,139 --> 00:06:01,529
didn't expect and that's really the

161
00:05:59,669 --> 00:06:03,859
essence of a bug on which we built the

162
00:06:01,529 --> 00:06:06,599
language theoretic security paradigm um

163
00:06:03,860 --> 00:06:09,750
so this is this machine computes three

164
00:06:06,599 --> 00:06:12,840
functions it has its outputs K X 1 K X 2

165
00:06:09,750 --> 00:06:14,849
K X 3 those are the state of the relays

166
00:06:12,840 --> 00:06:17,609
that govern where the input is connected

167
00:06:14,849 --> 00:06:22,620
switch where the input is connected into

168
00:06:17,610 --> 00:06:24,479
the switch sorry it has seven inputs the

169
00:06:22,620 --> 00:06:25,740
inputs are whether there's a call

170
00:06:24,479 --> 00:06:28,109
somewhere in the switch for the line

171
00:06:25,740 --> 00:06:30,060
three times and whether or not there is

172
00:06:28,110 --> 00:06:31,710
free space in the switch three times and

173
00:06:30,060 --> 00:06:35,909
whether or not the phone is off the hook

174
00:06:31,710 --> 00:06:37,680
so with that function from six arguments

175
00:06:35,909 --> 00:06:40,469
to three outputs or those three

176
00:06:37,680 --> 00:06:41,009
functions each from six argues each from

177
00:06:40,469 --> 00:06:44,248
seven are

178
00:06:41,009 --> 00:06:46,080
to each of one output is effectively a

179
00:06:44,249 --> 00:06:53,039
program even though it's effectively

180
00:06:46,080 --> 00:06:54,330
this simple so the the essence of the

181
00:06:53,039 --> 00:06:57,300
design principle that we tried to do

182
00:06:54,330 --> 00:06:59,460
with this was that this this circuit is

183
00:06:57,300 --> 00:07:00,749
an effort to limit complexity instead of

184
00:06:59,460 --> 00:07:02,068
using a microcontroller and writing a

185
00:07:00,749 --> 00:07:04,439
whole bunch of if statements and then

186
00:07:02,069 --> 00:07:06,059
having to figure out you know how to do

187
00:07:04,439 --> 00:07:08,759
the timings correctly and wait for all

188
00:07:06,059 --> 00:07:09,029
of the the various lines to fall into

189
00:07:08,759 --> 00:07:10,529
place

190
00:07:09,029 --> 00:07:12,539
we figured well let's just build a

191
00:07:10,529 --> 00:07:16,469
circuit it's a very simple machine we

192
00:07:12,539 --> 00:07:18,568
know its complexity it's bounded just

193
00:07:16,469 --> 00:07:20,370
for curiosity's sake with a little

194
00:07:18,569 --> 00:07:22,319
machine like that you can see it has one

195
00:07:20,370 --> 00:07:24,539
latch and there's really very very very

196
00:07:22,319 --> 00:07:26,639
little else about it other than that one

197
00:07:24,539 --> 00:07:30,240
multiplexer which is just a function of

198
00:07:26,639 --> 00:07:33,330
end and the diodes which form an or gate

199
00:07:30,240 --> 00:07:34,770
how complex or what language class do

200
00:07:33,330 --> 00:07:36,270
you suppose that might be do you think

201
00:07:34,770 --> 00:07:37,558
that the regular expression would be

202
00:07:36,270 --> 00:07:39,659
enough to express this sort of

203
00:07:37,559 --> 00:07:46,229
computation or is it more than that

204
00:07:39,659 --> 00:07:50,248
because it has state it's good to be

205
00:07:46,229 --> 00:07:51,839
awake so I I think it's regular I think

206
00:07:50,249 --> 00:07:55,469
it's regular and the reason that I think

207
00:07:51,839 --> 00:07:57,209
that is because it has only got four

208
00:07:55,469 --> 00:08:00,120
bits of state and actually only three of

209
00:07:57,209 --> 00:08:02,939
those bits of state are used it can't

210
00:08:00,120 --> 00:08:05,789
nest it can't really do anything other

211
00:08:02,939 --> 00:08:07,529
than like its entire output set is

212
00:08:05,789 --> 00:08:09,120
finite you know it's not even

213
00:08:07,529 --> 00:08:10,649
technically regular it's within regular

214
00:08:09,120 --> 00:08:11,969
it's it's a finite grammar I could

215
00:08:10,649 --> 00:08:13,800
easily make a truth table for this

216
00:08:11,969 --> 00:08:15,539
component and when you're designing

217
00:08:13,800 --> 00:08:16,919
these things that's where you want to be

218
00:08:15,539 --> 00:08:18,479
but as we learned you have to include

219
00:08:16,919 --> 00:08:19,558
your timings in that truth table too or

220
00:08:18,479 --> 00:08:21,779
it's incomplete and you have any

221
00:08:19,559 --> 00:08:21,990
specified it fully so we're to follow on

222
00:08:21,779 --> 00:08:25,949
that

223
00:08:21,990 --> 00:08:28,080
um the essence of language theoretic

224
00:08:25,949 --> 00:08:30,240
security is about loaded complexity and

225
00:08:28,080 --> 00:08:32,779
deterministic behaviors so with our

226
00:08:30,240 --> 00:08:35,159
design here you couldn't possibly say

227
00:08:32,779 --> 00:08:37,620
glitch it out and reprogram it and

228
00:08:35,159 --> 00:08:39,389
there's no serial interface by which you

229
00:08:37,620 --> 00:08:43,828
could send it new firmware and cause it

230
00:08:39,389 --> 00:08:45,060
to do weird things and and there's

231
00:08:43,828 --> 00:08:46,739
certainly going to be no buffer

232
00:08:45,060 --> 00:08:48,599
overflows you can only pick up the phone

233
00:08:46,740 --> 00:08:51,959
so many times before the phone is picked

234
00:08:48,600 --> 00:08:53,370
up uh-huh so it's it's deterministic

235
00:08:51,959 --> 00:08:54,739
context-free or less complex it

236
00:08:53,370 --> 00:08:56,930
certainly falls within that

237
00:08:54,740 --> 00:09:00,290
because the boundary that I'm drawing

238
00:08:56,930 --> 00:09:02,660
here is as long as you can kind of bound

239
00:09:00,290 --> 00:09:04,250
the amount of state that you have in in

240
00:09:02,660 --> 00:09:06,050
this machine of yours or at least you

241
00:09:04,250 --> 00:09:08,149
can define that if things are nested

242
00:09:06,050 --> 00:09:09,589
they're only nested kind of linearly

243
00:09:08,149 --> 00:09:11,360
they don't depend on things that are

244
00:09:09,589 --> 00:09:14,089
across the tree structure after you've

245
00:09:11,360 --> 00:09:17,209
parsed out your your XML document they

246
00:09:14,089 --> 00:09:19,520
don't like everything every every notion

247
00:09:17,209 --> 00:09:21,649
of validity everything that matters is

248
00:09:19,520 --> 00:09:23,240
findable from the place where you are in

249
00:09:21,649 --> 00:09:24,410
that document you don't have to go and

250
00:09:23,240 --> 00:09:27,290
parse the whole document then look

251
00:09:24,410 --> 00:09:28,490
somewhere else and find it that's the

252
00:09:27,290 --> 00:09:32,209
level of complexity that we're looking

253
00:09:28,490 --> 00:09:33,410
for so the point of the exercise in the

254
00:09:32,209 --> 00:09:35,510
shady switch once again to recapitulate

255
00:09:33,410 --> 00:09:37,100
was to limit the complexity available to

256
00:09:35,510 --> 00:09:38,600
phone freaker's you don't expose power

257
00:09:37,100 --> 00:09:39,800
to attackers when you don't need to you

258
00:09:38,600 --> 00:09:43,100
shouldn't make your machines any more

259
00:09:39,800 --> 00:09:44,870
complex than they strictly need to be so

260
00:09:43,100 --> 00:09:46,640
it's not about the language that you

261
00:09:44,870 --> 00:09:48,760
write in it's maybe about the language

262
00:09:46,640 --> 00:09:52,370
that the compiler is written for though

263
00:09:48,760 --> 00:09:54,830
because when you when you write a

264
00:09:52,370 --> 00:09:58,550
program it really is a virtual machine

265
00:09:54,830 --> 00:10:00,560
or a compiler for your input and it's

266
00:09:58,550 --> 00:10:02,149
more it's not about a general theory of

267
00:10:00,560 --> 00:10:04,219
computer network exploitation we don't

268
00:10:02,149 --> 00:10:05,750
hope to solve every possible flaw ever

269
00:10:04,220 --> 00:10:08,329
with language theoretic security and

270
00:10:05,750 --> 00:10:09,829
certainly we don't hope to solve flaws

271
00:10:08,329 --> 00:10:11,359
where you were doing something but it

272
00:10:09,829 --> 00:10:13,910
wasn't necessarily the right thing to do

273
00:10:11,360 --> 00:10:15,350
like build a phone switch we're not

274
00:10:13,910 --> 00:10:17,209
trying to solve memory safety in general

275
00:10:15,350 --> 00:10:18,860
with this it solves memory safety in a

276
00:10:17,209 --> 00:10:20,689
few specific ways but you might notice

277
00:10:18,860 --> 00:10:22,399
that it discusses memory only in

278
00:10:20,690 --> 00:10:24,740
abstract terms this language theoretic

279
00:10:22,399 --> 00:10:27,230
methodology it says things like we have

280
00:10:24,740 --> 00:10:28,640
this much state hmm it doesn't discuss

281
00:10:27,230 --> 00:10:29,959
how big the buffers are be or how

282
00:10:28,640 --> 00:10:31,630
they're going to be allocated or what

283
00:10:29,959 --> 00:10:35,599
your heap allocation mechanism might be

284
00:10:31,630 --> 00:10:37,010
and really above all else it's not a

285
00:10:35,600 --> 00:10:39,020
call for programmers to be more careful

286
00:10:37,010 --> 00:10:40,310
it's a call for people to use different

287
00:10:39,020 --> 00:10:43,399
design patterns so that they don't have

288
00:10:40,310 --> 00:10:45,050
to be more careful the security industry

289
00:10:43,399 --> 00:10:48,110
has for years had this thesis that if

290
00:10:45,050 --> 00:10:52,219
only developers would remember not to X

291
00:10:48,110 --> 00:10:55,040
not to use unchecked stack based buffer

292
00:10:52,220 --> 00:10:56,959
copies not you know not parse their

293
00:10:55,040 --> 00:10:58,730
input without deciding whether it's

294
00:10:56,959 --> 00:11:00,589
valid oh well I do ask them to be

295
00:10:58,730 --> 00:11:02,240
careful not to do that but we ask them

296
00:11:00,589 --> 00:11:03,680
to be careful once not be careful a

297
00:11:02,240 --> 00:11:05,270
hundred thousand times in their program

298
00:11:03,680 --> 00:11:06,949
that every little thing meets each and

299
00:11:05,270 --> 00:11:08,540
every one of its preconditions because

300
00:11:06,949 --> 00:11:11,270
that approach has always failed so

301
00:11:08,540 --> 00:11:15,199
this is really just a call for a new a

302
00:11:11,270 --> 00:11:17,210
new methodology um it's about input

303
00:11:15,200 --> 00:11:19,100
processing it's about data interchange

304
00:11:17,210 --> 00:11:21,440
it's about protocol specifications so

305
00:11:19,100 --> 00:11:23,570
you write a program and the program kind

306
00:11:21,440 --> 00:11:25,550
of perforce ends up having a protocol

307
00:11:23,570 --> 00:11:26,990
that it ends up parsing even my little

308
00:11:25,550 --> 00:11:28,729
circuit that I showed you before has a

309
00:11:26,990 --> 00:11:30,290
protocol that it ends up parsing each of

310
00:11:28,730 --> 00:11:33,350
its seven input lines have a specific

311
00:11:30,290 --> 00:11:35,120
meaning and this this constitutes a

312
00:11:33,350 --> 00:11:38,390
protocol it's not a serialized protocol

313
00:11:35,120 --> 00:11:40,130
it's a parallel protocol there are two

314
00:11:38,390 --> 00:11:43,069
to the seven symbols in my protocol and

315
00:11:40,130 --> 00:11:45,770
one element but nonetheless as soon as I

316
00:11:43,070 --> 00:11:47,180
laid down the design there a protocol

317
00:11:45,770 --> 00:11:48,680
also sprung up and if you're not

318
00:11:47,180 --> 00:11:50,449
deliberate about what that protocol is

319
00:11:48,680 --> 00:11:54,020
then it tends to be a piece of emergent

320
00:11:50,450 --> 00:11:55,820
complexity which is how we get bugs it's

321
00:11:54,020 --> 00:11:57,500
about data interchange as well because

322
00:11:55,820 --> 00:11:59,030
that system has to interconnect to other

323
00:11:57,500 --> 00:12:00,710
systems and if those systems do

324
00:11:59,030 --> 00:12:03,709
unexpected things with the pins for

325
00:12:00,710 --> 00:12:07,100
example what happens if I have a hundred

326
00:12:03,710 --> 00:12:08,630
Hertz AC at five volts on on the line

327
00:12:07,100 --> 00:12:11,450
pickup pin because you're really just

328
00:12:08,630 --> 00:12:13,730
that quick on the hook switch does it

329
00:12:11,450 --> 00:12:15,350
still work well you have to account for

330
00:12:13,730 --> 00:12:19,340
that and if you don't design the

331
00:12:15,350 --> 00:12:21,560
protocol on purpose as we found you you

332
00:12:19,340 --> 00:12:23,060
will tend to end up with emergent bugs

333
00:12:21,560 --> 00:12:24,589
in this case it expresses itself as

334
00:12:23,060 --> 00:12:26,540
timing issues it usually expresses

335
00:12:24,590 --> 00:12:28,130
itself as things like your program

336
00:12:26,540 --> 00:12:31,069
putting itself into a strange unexpected

337
00:12:28,130 --> 00:12:36,140
state and crashing or giving away data

338
00:12:31,070 --> 00:12:37,730
you didn't intend it to give out and so

339
00:12:36,140 --> 00:12:39,890
those two things are supported by input

340
00:12:37,730 --> 00:12:42,740
processing we need to make sure that in

341
00:12:39,890 --> 00:12:44,960
my case the input processing handles the

342
00:12:42,740 --> 00:12:47,540
pins correctly and police's the timings

343
00:12:44,960 --> 00:12:50,000
in in more software related cases we

344
00:12:47,540 --> 00:12:51,740
need to make sure that it is policing

345
00:12:50,000 --> 00:12:53,330
that the protocol that it's getting is

346
00:12:51,740 --> 00:12:55,640
actually the protocol that it expects

347
00:12:53,330 --> 00:12:57,500
that there's not AC on that pin is

348
00:12:55,640 --> 00:13:00,380
roughly the equivalent of this is

349
00:12:57,500 --> 00:13:03,110
actually a PDF document and not an

350
00:13:00,380 --> 00:13:04,760
executable I'm actually sorry I misspoke

351
00:13:03,110 --> 00:13:08,170
PDF documents are almost always

352
00:13:04,760 --> 00:13:09,980
executables but they shouldn't be okay

353
00:13:08,170 --> 00:13:13,490
so it's a software engineering

354
00:13:09,980 --> 00:13:14,690
methodology that's all it is so let me

355
00:13:13,490 --> 00:13:16,790
talk a little bit more about the

356
00:13:14,690 --> 00:13:18,230
background on this product and this

357
00:13:16,790 --> 00:13:21,410
project and this little circuit that I'm

358
00:13:18,230 --> 00:13:22,370
using as an example of how small a

359
00:13:21,410 --> 00:13:24,050
machine can be but

360
00:13:22,370 --> 00:13:27,740
for it starts to have bugs if you don't

361
00:13:24,050 --> 00:13:29,449
follow this methodology well um this

362
00:13:27,740 --> 00:13:32,570
product that we had to build this phone

363
00:13:29,450 --> 00:13:34,640
switch essentially our central idea our

364
00:13:32,570 --> 00:13:36,650
initial idea was let's do this but let's

365
00:13:34,640 --> 00:13:38,720
do it without microcontrollers let's do

366
00:13:36,650 --> 00:13:41,329
it like the equipment that I was talking

367
00:13:38,720 --> 00:13:43,130
about two years ago when I was here all

368
00:13:41,330 --> 00:13:44,420
of the number one number five crossbar

369
00:13:43,130 --> 00:13:45,670
switches that the bell system which were

370
00:13:44,420 --> 00:13:48,529
built with relays and vacuum tubes

371
00:13:45,670 --> 00:13:50,420
entire programs there is a device called

372
00:13:48,529 --> 00:13:52,520
the marker the marker decides where

373
00:13:50,420 --> 00:13:54,439
everything will go and it does this

374
00:13:52,520 --> 00:14:00,230
because it's a cabinet it's a cabinet

375
00:13:54,440 --> 00:14:01,610
about about that big full of relays so

376
00:14:00,230 --> 00:14:03,800
we figured why can't we just do the same

377
00:14:01,610 --> 00:14:05,690
thing it'll probably be about the same

378
00:14:03,800 --> 00:14:08,359
number of components and about as

379
00:14:05,690 --> 00:14:09,740
complex but it'll probably be a few

380
00:14:08,360 --> 00:14:11,150
orders of magnitude less expensive

381
00:14:09,740 --> 00:14:14,510
because we have transistors now so let's

382
00:14:11,150 --> 00:14:17,150
do that so we decided that much like

383
00:14:14,510 --> 00:14:19,130
that system there would be no

384
00:14:17,150 --> 00:14:20,750
microcontrollers unless they're special

385
00:14:19,130 --> 00:14:22,850
microcontrollers they can't be

386
00:14:20,750 --> 00:14:24,380
reprogrammed and the outputs are easily

387
00:14:22,850 --> 00:14:26,210
described as a function of the inputs

388
00:14:24,380 --> 00:14:29,060
that's basically a shortcut oh I need an

389
00:14:26,210 --> 00:14:30,709
ASIC I'd rather not fab an ASIC here's

390
00:14:29,060 --> 00:14:33,770
the microcontroller that exactly does

391
00:14:30,709 --> 00:14:36,260
this one thing and then those verified

392
00:14:33,770 --> 00:14:38,779
so it turns out that you can buy chips

393
00:14:36,260 --> 00:14:41,060
like that for many common purposes and I

394
00:14:38,779 --> 00:14:43,939
will get into that later because it's

395
00:14:41,060 --> 00:14:45,829
another example so um the other kind of

396
00:14:43,940 --> 00:14:47,390
idea with this switch is that the state

397
00:14:45,830 --> 00:14:48,620
should fit in a reasonably regular

398
00:14:47,390 --> 00:14:50,689
expression we don't want to keep track

399
00:14:48,620 --> 00:14:52,970
of a bazillion things everything complex

400
00:14:50,690 --> 00:14:56,930
like for example Billings not not in

401
00:14:52,970 --> 00:15:02,000
there it's outsourced somewhere else so

402
00:14:56,930 --> 00:15:04,219
just kind of to tie that ancient

403
00:15:02,000 --> 00:15:07,250
background skip 60 years and come

404
00:15:04,220 --> 00:15:09,560
straight to the present it turns out

405
00:15:07,250 --> 00:15:11,270
that just like those old systems with

406
00:15:09,560 --> 00:15:13,520
the relays storing all of the state each

407
00:15:11,270 --> 00:15:15,350
relay governed it stores a bit of state

408
00:15:13,520 --> 00:15:17,150
about like is this line up is this path

409
00:15:15,350 --> 00:15:19,550
in use which thing is next in the

410
00:15:17,150 --> 00:15:23,660
priority chain those look a little bit

411
00:15:19,550 --> 00:15:25,689
like bits and RAM and if a computer has

412
00:15:23,660 --> 00:15:27,890
one thing that's finite its bits of RAM

413
00:15:25,690 --> 00:15:30,080
and so it turns out that all working

414
00:15:27,890 --> 00:15:32,150
computing models are trivially regular

415
00:15:30,080 --> 00:15:34,010
or are actually trivially finite you can

416
00:15:32,150 --> 00:15:35,939
technically enumerate all inputs and

417
00:15:34,010 --> 00:15:37,410
outputs and all state of the computer

418
00:15:35,940 --> 00:15:38,850
much like to simulate the universe it

419
00:15:37,410 --> 00:15:41,010
would take you a device approximately as

420
00:15:38,850 --> 00:15:42,210
large as the universe or greater this

421
00:15:41,010 --> 00:15:46,020
turns out not to be a very practical

422
00:15:42,210 --> 00:15:47,880
methodology and so sometimes when when

423
00:15:46,020 --> 00:15:50,130
discussing Liang SEC you you always get

424
00:15:47,880 --> 00:15:52,920
a couple of people who wonder well I

425
00:15:50,130 --> 00:15:54,870
mean sure this language appears to be an

426
00:15:52,920 --> 00:15:57,079
XML document but since there's only five

427
00:15:54,870 --> 00:16:00,870
of them that it can be is it really XML

428
00:15:57,080 --> 00:16:03,180
is it really that bad if if I have this

429
00:16:00,870 --> 00:16:05,880
bad thing just limit it in some way and

430
00:16:03,180 --> 00:16:08,489
the answer is probably it depends on

431
00:16:05,880 --> 00:16:10,740
whether or not the description that is a

432
00:16:08,490 --> 00:16:13,410
finite state machine or a finite

433
00:16:10,740 --> 00:16:15,000
language is actually a useful

434
00:16:13,410 --> 00:16:17,370
description of the way that the machine

435
00:16:15,000 --> 00:16:19,290
works if someone looks at it and they're

436
00:16:17,370 --> 00:16:21,630
like oh this is a truth table it's I

437
00:16:19,290 --> 00:16:23,610
know how to work with this it's great

438
00:16:21,630 --> 00:16:27,090
it's a specification people can work

439
00:16:23,610 --> 00:16:28,860
with that if it's like here's a list of

440
00:16:27,090 --> 00:16:31,080
all possible configurations of bits on

441
00:16:28,860 --> 00:16:32,580
this hard drive you can't reason about

442
00:16:31,080 --> 00:16:33,900
that you you technically could reason

443
00:16:32,580 --> 00:16:34,860
about it a computer could reason about

444
00:16:33,900 --> 00:16:37,410
it in a very long time

445
00:16:34,860 --> 00:16:39,300
it could you could indeed simulate all

446
00:16:37,410 --> 00:16:40,770
possible states of a program and figure

447
00:16:39,300 --> 00:16:42,569
out whether or not in any of those

448
00:16:40,770 --> 00:16:44,040
states represents the state of possible

449
00:16:42,570 --> 00:16:47,520
exploitation and this is largely what we

450
00:16:44,040 --> 00:16:49,980
do with fuzzing and fuzzing doesn't

451
00:16:47,520 --> 00:16:51,900
verify things so no the answer is just

452
00:16:49,980 --> 00:16:54,780
no if you want your verification to be

453
00:16:51,900 --> 00:16:57,720
doable within the year or the decade

454
00:16:54,780 --> 00:17:00,689
you probably shouldn't rely on trivial

455
00:16:57,720 --> 00:17:02,820
representations of things that do have

456
00:17:00,690 --> 00:17:03,690
actual complexity there's also the

457
00:17:02,820 --> 00:17:06,240
question of whether or not the

458
00:17:03,690 --> 00:17:07,830
enumeration is sound so for example even

459
00:17:06,240 --> 00:17:09,630
with the circuit of this size it was

460
00:17:07,829 --> 00:17:10,980
challenging for us to enumerate all of

461
00:17:09,630 --> 00:17:14,540
the possible states in which it may be

462
00:17:10,980 --> 00:17:14,540
to figure out where bugs might lie

463
00:17:14,990 --> 00:17:21,210
imagine doing that for an actual program

464
00:17:18,140 --> 00:17:22,680
so what's left after you take all of the

465
00:17:21,210 --> 00:17:24,990
programmable interface controllers and

466
00:17:22,680 --> 00:17:26,880
all of the Arduinos away in our design

467
00:17:24,990 --> 00:17:32,010
is a whole bunch of 7400 series logic

468
00:17:26,880 --> 00:17:33,780
and one interesting thing about 7400

469
00:17:32,010 --> 00:17:35,150
series logic is that working with it

470
00:17:33,780 --> 00:17:39,290
feels a lot like functional programming

471
00:17:35,150 --> 00:17:41,670
which I'll get into in just a second

472
00:17:39,290 --> 00:17:44,159
no no not really

473
00:17:41,670 --> 00:17:45,780
no because we've just deemed every

474
00:17:44,160 --> 00:17:48,510
variable to be an input line the Haeckel

475
00:17:45,780 --> 00:17:52,660
was no side-effects

476
00:17:48,510 --> 00:17:54,700
so there can be but they exist at the

477
00:17:52,660 --> 00:17:56,020
electrical level so for example as I was

478
00:17:54,700 --> 00:17:57,640
saying language theoretic security is

479
00:17:56,020 --> 00:18:00,820
not a panacea for information security

480
00:17:57,640 --> 00:18:02,920
in general my methodology could not find

481
00:18:00,820 --> 00:18:04,780
her a hammer the shady switch could

482
00:18:02,920 --> 00:18:06,550
potentially have ro hammer although

483
00:18:04,780 --> 00:18:08,550
everything is so coarse and practical

484
00:18:06,550 --> 00:18:11,230
EDC that I don't know how you would

485
00:18:08,550 --> 00:18:16,620
there's actually a timing attack in our

486
00:18:11,230 --> 00:18:16,620
current design by the way so good heck

487
00:18:18,000 --> 00:18:22,630
so all computing models that can

488
00:18:20,650 --> 00:18:24,460
technically be it can be implemented are

489
00:18:22,630 --> 00:18:26,110
technically regular because if they had

490
00:18:24,460 --> 00:18:29,860
infinite amounts of state which the next

491
00:18:26,110 --> 00:18:31,810
one up does it has an infinite stack you

492
00:18:29,860 --> 00:18:34,780
can't actually do anything with it but

493
00:18:31,810 --> 00:18:35,770
this really doesn't matter because what

494
00:18:34,780 --> 00:18:37,480
we want to do is we want to reduce

495
00:18:35,770 --> 00:18:38,470
vulnerabilities by reducing complexity

496
00:18:37,480 --> 00:18:40,300
and if we build a system whose

497
00:18:38,470 --> 00:18:41,860
description is so complex this is

498
00:18:40,300 --> 00:18:44,290
basically equivalent to building a

499
00:18:41,860 --> 00:18:56,020
system whose input grammar is so complex

500
00:18:44,290 --> 00:18:58,510
so with that let's consider some more of

501
00:18:56,020 --> 00:19:01,150
the fundamental things that fell out of

502
00:18:58,510 --> 00:19:04,150
Lang SEC we figured out very very early

503
00:19:01,150 --> 00:19:07,300
on that the most important thing in a

504
00:19:04,150 --> 00:19:08,890
language that was able to allow software

505
00:19:07,300 --> 00:19:11,740
engineers to use a language theoretic

506
00:19:08,890 --> 00:19:15,310
security methodology is that this

507
00:19:11,740 --> 00:19:17,770
language has strong type systems so in

508
00:19:15,310 --> 00:19:19,659
other words unlike JavaScript you can't

509
00:19:17,770 --> 00:19:22,020
simply transduce types to other types

510
00:19:19,660 --> 00:19:25,120
implicitly and just hope for the best

511
00:19:22,020 --> 00:19:26,710
unlike Python programming a lot you

512
00:19:25,120 --> 00:19:27,939
shouldn't like pickle things and then

513
00:19:26,710 --> 00:19:29,890
write them to a file hope that it

514
00:19:27,940 --> 00:19:31,090
remains unchanged forever in stone and

515
00:19:29,890 --> 00:19:33,610
then unpick 'el them because we know

516
00:19:31,090 --> 00:19:35,620
what happens when you do that strong

517
00:19:33,610 --> 00:19:37,360
type systems mean that every time we

518
00:19:35,620 --> 00:19:40,389
take in some input and we've parsed it

519
00:19:37,360 --> 00:19:41,889
it acquires the type the way that this

520
00:19:40,390 --> 00:19:43,720
is expressed in this programming with

521
00:19:41,890 --> 00:19:45,700
solder idea is that each of these pins

522
00:19:43,720 --> 00:19:47,920
fundamentally has a type and I'll get

523
00:19:45,700 --> 00:19:49,330
into that in the next slide but the

524
00:19:47,920 --> 00:19:50,740
strong type system is really the

525
00:19:49,330 --> 00:19:51,879
backbone of this because the strong type

526
00:19:50,740 --> 00:19:53,680
system allows you to make guarantees

527
00:19:51,880 --> 00:19:56,470
about things like yes this part is

528
00:19:53,680 --> 00:19:59,410
validated as to that it allows you to

529
00:19:56,470 --> 00:20:01,660
make guarantees such as of all of the

530
00:19:59,410 --> 00:20:03,520
special cases of this function

531
00:20:01,660 --> 00:20:05,260
because our input parameter was this

532
00:20:03,520 --> 00:20:06,820
it's this particular special case and

533
00:20:05,260 --> 00:20:09,610
you can make your type system as

534
00:20:06,820 --> 00:20:11,230
granular or as coarse as you like but

535
00:20:09,610 --> 00:20:13,959
merely using strings and integers is

536
00:20:11,230 --> 00:20:16,630
simply not enough the strong type system

537
00:20:13,960 --> 00:20:18,010
has to have sufficient complexity in and

538
00:20:16,630 --> 00:20:21,400
of itself to allow the compiler to

539
00:20:18,010 --> 00:20:24,610
verify that bugs do not exist so what do

540
00:20:21,400 --> 00:20:26,740
I mean by this well I mean that imagine

541
00:20:24,610 --> 00:20:29,379
all of those scenarios where like you

542
00:20:26,740 --> 00:20:31,480
have a Unicode string and then you think

543
00:20:29,380 --> 00:20:33,190
that it's actually the utf-8 string is

544
00:20:31,480 --> 00:20:35,770
just an ASCII string so you just process

545
00:20:33,190 --> 00:20:39,310
it as a byte array and you're good to go

546
00:20:35,770 --> 00:20:41,530
right no no you're not what you have to

547
00:20:39,310 --> 00:20:43,149
do is verify it and so what's better

548
00:20:41,530 --> 00:20:45,070
than reading in the unicode string and

549
00:20:43,150 --> 00:20:48,340
having a byte array and then just

550
00:20:45,070 --> 00:20:51,100
outputting a byte array is to have some

551
00:20:48,340 --> 00:20:53,530
kind of string type that guarantees to

552
00:20:51,100 --> 00:20:55,419
you for example whether or not the

553
00:20:53,530 --> 00:20:57,490
string is actually a continuous array of

554
00:20:55,420 --> 00:20:59,200
bytes and to get there you had to parse

555
00:20:57,490 --> 00:21:00,730
the entire unicode string and figure out

556
00:20:59,200 --> 00:21:02,350
whether or not there are any characters

557
00:21:00,730 --> 00:21:04,750
that are larger than 8 bits in it before

558
00:21:02,350 --> 00:21:06,010
you can make that guarantee that sounds

559
00:21:04,750 --> 00:21:11,050
like the perfect job for a constructor

560
00:21:06,010 --> 00:21:13,450
doesn't it anyway constructors are also

561
00:21:11,050 --> 00:21:15,220
awesome because they prevent if you

562
00:21:13,450 --> 00:21:16,960
parse in the constructor you can show

563
00:21:15,220 --> 00:21:19,060
that you don't have the shotgun parsing

564
00:21:16,960 --> 00:21:21,010
anti-pattern in your program so shotgun

565
00:21:19,060 --> 00:21:23,860
parsing I alluded to earlier it's this

566
00:21:21,010 --> 00:21:26,020
thing that we is this thing that happens

567
00:21:23,860 --> 00:21:27,639
when you parse and then you do a little

568
00:21:26,020 --> 00:21:28,810
bit of logic and then you parse some

569
00:21:27,640 --> 00:21:30,160
more to figure out whether the rest of

570
00:21:28,810 --> 00:21:32,050
your input is valid and then you do a

571
00:21:30,160 --> 00:21:33,970
little more logic the reason that this

572
00:21:32,050 --> 00:21:35,649
sucks is because at each step that you

573
00:21:33,970 --> 00:21:36,910
do a little more logic your program is

574
00:21:35,650 --> 00:21:38,920
going into a whole bunch of states in

575
00:21:36,910 --> 00:21:40,720
those states potentially touch valuable

576
00:21:38,920 --> 00:21:43,450
data that you're trying to do the parser

577
00:21:40,720 --> 00:21:44,830
is a toy the parser can do two things it

578
00:21:43,450 --> 00:21:47,140
can pass the input on or throw it in the

579
00:21:44,830 --> 00:21:49,570
garbage the rest of the program is where

580
00:21:47,140 --> 00:21:51,490
your entire threat model lies unless

581
00:21:49,570 --> 00:21:54,340
your parser implementation is bad no yet

582
00:21:51,490 --> 00:21:58,600
to that in a minute but um the the

583
00:21:54,340 --> 00:22:00,580
central idea here is that if you start

584
00:21:58,600 --> 00:22:01,540
to parse and then you do some logic and

585
00:22:00,580 --> 00:22:03,850
then you start to parse with this

586
00:22:01,540 --> 00:22:05,409
shotgun parser the effects of malicious

587
00:22:03,850 --> 00:22:07,300
input spread throughout your program

588
00:22:05,410 --> 00:22:09,550
state much like the pellets out at the

589
00:22:07,300 --> 00:22:10,540
end of a shotgun and it's really

590
00:22:09,550 --> 00:22:12,820
impossible to clean up the mess

591
00:22:10,540 --> 00:22:15,129
afterward so we avoid that by making

592
00:22:12,820 --> 00:22:19,149
sure that we have strong type systems

593
00:22:15,130 --> 00:22:20,200
and hopefully hopefully we architect

594
00:22:19,150 --> 00:22:21,670
them correctly there are methodologies

595
00:22:20,200 --> 00:22:26,140
around that that I won't get into

596
00:22:21,670 --> 00:22:27,460
immediately but the other way around

597
00:22:26,140 --> 00:22:29,640
this and I was just talking about this

598
00:22:27,460 --> 00:22:31,690
in object-oriented terms is that I

599
00:22:29,640 --> 00:22:34,240
remember how I said our deterministic

600
00:22:31,690 --> 00:22:36,610
finite automaton is kind of like a

601
00:22:34,240 --> 00:22:38,620
function and how our circuit has a truth

602
00:22:36,610 --> 00:22:40,899
table which is kind of a thing that

603
00:22:38,620 --> 00:22:43,330
functions have functional programming is

604
00:22:40,900 --> 00:22:45,720
also perfectly fine for this if you have

605
00:22:43,330 --> 00:22:48,669
a function that transduces from input to

606
00:22:45,720 --> 00:22:50,410
verified output that is perfectly as

607
00:22:48,670 --> 00:22:52,000
good as an object with a constructor the

608
00:22:50,410 --> 00:22:54,070
point is that you know that when you

609
00:22:52,000 --> 00:22:55,930
have an object of a particular type that

610
00:22:54,070 --> 00:22:58,689
the things that are in that object meet

611
00:22:55,930 --> 00:23:02,830
the criteria for validity of the thing

612
00:22:58,690 --> 00:23:05,560
that that type is because the shotgun

613
00:23:02,830 --> 00:23:07,090
parsing anti-pattern and effects like if

614
00:23:05,560 --> 00:23:11,169
you remember someone's ability for

615
00:23:07,090 --> 00:23:13,240
example to completely hack stratum zero

616
00:23:11,170 --> 00:23:15,610
NTP servers by simply sending them a

617
00:23:13,240 --> 00:23:18,010
null key and asserting that the time was

618
00:23:15,610 --> 00:23:21,129
1970

619
00:23:18,010 --> 00:23:23,080
if you don't reject this this invalid

620
00:23:21,130 --> 00:23:24,400
input document with that null key before

621
00:23:23,080 --> 00:23:27,790
it gets just somewhere dangerous it

622
00:23:24,400 --> 00:23:31,480
might actually blow up so let's find

623
00:23:27,790 --> 00:23:33,970
some types I mentioned before these two

624
00:23:31,480 --> 00:23:35,440
components um I don't like up verdure

625
00:23:33,970 --> 00:23:37,420
symbols I'm in the middle of getting rid

626
00:23:35,440 --> 00:23:41,170
of it the component on the left is a MUX

627
00:23:37,420 --> 00:23:44,590
the component on the right is a is a

628
00:23:41,170 --> 00:23:45,910
latch um for people who haven't worked

629
00:23:44,590 --> 00:23:47,530
with these particular things before

630
00:23:45,910 --> 00:23:51,190
because I know that this is getting to

631
00:23:47,530 --> 00:23:56,440
be a little bit arcane a multiplexer is

632
00:23:51,190 --> 00:23:58,270
a device it has kind of input it has a

633
00:23:56,440 --> 00:23:59,920
series of input pins and then as a

634
00:23:58,270 --> 00:24:02,020
selector for which of those sets of

635
00:23:59,920 --> 00:24:04,060
input pins goes to the output so this

636
00:24:02,020 --> 00:24:06,970
one has two sets of input pins a 0

637
00:24:04,060 --> 00:24:08,590
through 3 B 0 through 3 and it has an S

638
00:24:06,970 --> 00:24:12,130
pin which selects which one of those two

639
00:24:08,590 --> 00:24:13,780
is valid the one that is selected is the

640
00:24:12,130 --> 00:24:18,070
output on y1 passed directly through

641
00:24:13,780 --> 00:24:20,830
buffered so what is this component if

642
00:24:18,070 --> 00:24:23,530
you were to imagine what that component

643
00:24:20,830 --> 00:24:27,810
is in a program is there may be some

644
00:24:23,530 --> 00:24:27,810
logical structure that that might be

645
00:24:28,090 --> 00:24:33,029
it's an if it's just an if statement it

646
00:24:30,580 --> 00:24:36,399
might also be a case statement depending

647
00:24:33,029 --> 00:24:38,169
so if you wanted to try to consider well

648
00:24:36,399 --> 00:24:39,369
how complex is this program when

649
00:24:38,169 --> 00:24:42,340
exercise that I found that was very

650
00:24:39,369 --> 00:24:45,249
interesting is how much of this program

651
00:24:42,340 --> 00:24:48,999
could just be implemented by by non clot

652
00:24:45,249 --> 00:24:51,429
solid state logic the thing that's after

653
00:24:48,999 --> 00:24:55,119
it a bunch of diodes those form to or

654
00:24:51,429 --> 00:24:57,759
gates the reason that this is true is

655
00:24:55,119 --> 00:24:59,499
fairly obvious if any of the inputs on

656
00:24:57,759 --> 00:25:01,599
the left is high the output at the end

657
00:24:59,499 --> 00:25:04,690
of the diodes will also be high and then

658
00:25:01,599 --> 00:25:06,428
that goes into my latch so at each stage

659
00:25:04,690 --> 00:25:10,179
of this I kind of have some types don't

660
00:25:06,429 --> 00:25:11,889
I so in the beginning I have I have

661
00:25:10,179 --> 00:25:14,139
about seven types I don't know if that's

662
00:25:11,889 --> 00:25:17,738
legible the pins are labeled zai of X

663
00:25:14,139 --> 00:25:21,699
one through three not s of P 1 through 3

664
00:25:17,739 --> 00:25:24,549
and s of X and what that means is I of X

665
00:25:21,700 --> 00:25:26,559
1 through 3 is a line that basically is

666
00:25:24,549 --> 00:25:29,889
one bit it's a one bit type it's is

667
00:25:26,559 --> 00:25:32,440
there an incoming call on this line so I

668
00:25:29,889 --> 00:25:36,908
could model this as a type system and I

669
00:25:32,440 --> 00:25:39,879
could say this input line this bits it

670
00:25:36,909 --> 00:25:42,580
has meaning beyond 1 or 0 it has its

671
00:25:39,879 --> 00:25:44,619
context which is is there an incoming

672
00:25:42,580 --> 00:25:49,119
call for the line that this piece of

673
00:25:44,619 --> 00:25:51,999
logic corresponds to on path 1 2 or 3 so

674
00:25:49,119 --> 00:25:53,889
the type has a value it's 1 or 0 and the

675
00:25:51,999 --> 00:25:59,710
type is put into a particular place in

676
00:25:53,889 --> 00:26:01,809
our state machine pin 1 2 or 3 so the if

677
00:25:59,710 --> 00:26:04,599
statement can also be described as a

678
00:26:01,809 --> 00:26:09,249
function of course because concepts um

679
00:26:04,599 --> 00:26:10,168
and the output lines y 0 through 3 also

680
00:26:09,249 --> 00:26:12,639
have a type

681
00:26:10,169 --> 00:26:14,019
now you could model this type as being

682
00:26:12,639 --> 00:26:15,369
the same as well there's an incoming

683
00:26:14,019 --> 00:26:17,259
call for you on this line but that's

684
00:26:15,369 --> 00:26:19,389
actually not correct because the

685
00:26:17,259 --> 00:26:21,369
function having processed it gives it a

686
00:26:19,389 --> 00:26:23,678
little bit more meaning and so remember

687
00:26:21,369 --> 00:26:29,439
that our our data type is still boolean

688
00:26:23,679 --> 00:26:32,469
we're still 1 or 0 but the function of

689
00:26:29,440 --> 00:26:34,539
this multiplexer has said if the line is

690
00:26:32,469 --> 00:26:36,070
down the path that we should be

691
00:26:34,539 --> 00:26:38,859
connected to corresponds to the path

692
00:26:36,070 --> 00:26:40,989
that has an incoming call for us if the

693
00:26:38,859 --> 00:26:42,639
line has been picked up and there's no

694
00:26:40,989 --> 00:26:44,799
incoming call yeah

695
00:26:42,640 --> 00:26:46,690
the state actually if the line has been

696
00:26:44,799 --> 00:26:48,490
picked up we'll get to the if there's an

697
00:26:46,690 --> 00:26:52,799
incoming call bit later than the state

698
00:26:48,490 --> 00:26:57,820
should be the first free path hmm so

699
00:26:52,799 --> 00:27:00,010
that's what it does if the output is if

700
00:26:57,820 --> 00:27:01,510
the phone receiver is down the output is

701
00:27:00,010 --> 00:27:04,149
whether there's an incoming call on pins

702
00:27:01,510 --> 00:27:06,460
one through three in I in why one

703
00:27:04,149 --> 00:27:08,889
through three and if the receiver is up

704
00:27:06,460 --> 00:27:10,929
then why one through three indicate

705
00:27:08,890 --> 00:27:14,320
whether or not path one through three is

706
00:27:10,929 --> 00:27:18,510
free so really what this is is it's the

707
00:27:14,320 --> 00:27:22,120
type of should we be on this path data

708
00:27:18,510 --> 00:27:25,120
so this is a good example of how type

709
00:27:22,120 --> 00:27:28,510
transaction can work without actually

710
00:27:25,120 --> 00:27:30,729
needing to create an object for this I

711
00:27:28,510 --> 00:27:32,139
won't go into absolutely all of the rest

712
00:27:30,730 --> 00:27:34,779
of the circuit but I will discuss the

713
00:27:32,139 --> 00:27:37,330
timing bug and the timing bug is merely

714
00:27:34,779 --> 00:27:39,279
this so maybe a little bit more about

715
00:27:37,330 --> 00:27:41,199
the circuit you might notice that pin

716
00:27:39,279 --> 00:27:43,179
zero on that multiplexer has nothing to

717
00:27:41,200 --> 00:27:45,130
do with that it's still selected on

718
00:27:43,179 --> 00:27:47,320
whether the line is up or down but it's

719
00:27:45,130 --> 00:27:49,500
actually not having to do with inputs IX

720
00:27:47,320 --> 00:27:52,330
of one two three and s of P 1 through 3

721
00:27:49,500 --> 00:27:55,630
what it has to do with is latch enable

722
00:27:52,330 --> 00:27:59,649
on the 74 sub HC 75 D latch that's right

723
00:27:55,630 --> 00:28:01,029
there um so what latch enable does for

724
00:27:59,649 --> 00:28:03,010
those who have not recently used a latch

725
00:28:01,029 --> 00:28:04,510
is while latch enable is high the output

726
00:28:03,010 --> 00:28:06,370
of the latch is whatever the input of

727
00:28:04,510 --> 00:28:07,990
the latch is while it's low the output

728
00:28:06,370 --> 00:28:09,668
of the latches whatever the output of

729
00:28:07,990 --> 00:28:12,580
the latch just was ignoring the input

730
00:28:09,669 --> 00:28:14,200
completely and that's a latch it's store

731
00:28:12,580 --> 00:28:18,220
state this latch stores four bits of

732
00:28:14,200 --> 00:28:20,980
state and whether or not the latch is

733
00:28:18,220 --> 00:28:23,019
transparent meaning whether or not the

734
00:28:20,980 --> 00:28:25,570
latch enable pins are high depends also

735
00:28:23,019 --> 00:28:29,500
on if or if not the receiver is picked

736
00:28:25,570 --> 00:28:31,269
up where's the timing bug

737
00:28:29,500 --> 00:28:36,389
does anyone see the timing bug already

738
00:28:31,269 --> 00:28:38,409
in this okay so hmm

739
00:28:36,389 --> 00:28:41,889
there's two components here that are

740
00:28:38,409 --> 00:28:43,480
used for timing are 30 and C 30 resistor

741
00:28:41,889 --> 00:28:44,889
and capacitor the resistor is simply a 2

742
00:28:43,480 --> 00:28:47,350
kilo ohm resistor and the capacitor is a

743
00:28:44,889 --> 00:28:49,360
10 nano farad capacitor which means that

744
00:28:47,350 --> 00:28:51,010
to charge up to the gate potential of

745
00:28:49,360 --> 00:28:55,240
the latch enable it takes the capacitor

746
00:28:51,010 --> 00:28:57,220
about maybe 7 sorry about

747
00:28:55,240 --> 00:29:07,960
I think I'm gonna say 7 nanoseconds to

748
00:28:57,220 --> 00:29:11,110
charge up on now it turns out that this

749
00:29:07,960 --> 00:29:12,760
is actually the wrong thing to do um the

750
00:29:11,110 --> 00:29:14,678
reason that we need to have timing

751
00:29:12,760 --> 00:29:16,840
control here is because we can't

752
00:29:14,679 --> 00:29:20,110
simultaneously have parallel processing

753
00:29:16,840 --> 00:29:21,850
goes on that says change all over the

754
00:29:20,110 --> 00:29:23,740
state it also immediately latch it in at

755
00:29:21,850 --> 00:29:26,320
exactly the same time that simply

756
00:29:23,740 --> 00:29:28,179
doesn't work we found in an earlier

757
00:29:26,320 --> 00:29:30,370
iteration of this chip that actually we

758
00:29:28,179 --> 00:29:32,020
ended up exposing of this design that we

759
00:29:30,370 --> 00:29:37,090
ended up exposing the internal timing

760
00:29:32,020 --> 00:29:39,580
rules of this this latch and paths 1 & 2

761
00:29:37,090 --> 00:29:40,928
did the correct thing but path 3 did not

762
00:29:39,580 --> 00:29:42,760
do the correct thing and when we put the

763
00:29:40,929 --> 00:29:46,210
timing capacitor and it exacerbated it

764
00:29:42,760 --> 00:29:47,830
why well here's that emergent

765
00:29:46,210 --> 00:29:49,450
functionality we didn't know that our

766
00:29:47,830 --> 00:29:53,100
implementation was faithful so what

767
00:29:49,450 --> 00:29:58,450
happened is we had these pins

768
00:29:53,100 --> 00:30:00,520
ix of 1 and s of p 1 and the same thing

769
00:29:58,450 --> 00:30:03,970
that switches which one of those is on

770
00:30:00,520 --> 00:30:08,379
the output and goes into the latch it

771
00:30:03,970 --> 00:30:10,360
happens is the pin that is deciding

772
00:30:08,380 --> 00:30:11,890
whether or not that will switch over to

773
00:30:10,360 --> 00:30:15,550
being path occupancy and so what

774
00:30:11,890 --> 00:30:17,230
happened is specifically for path 3 when

775
00:30:15,550 --> 00:30:18,879
you picked it up it would shunt you over

776
00:30:17,230 --> 00:30:21,160
to the first available path instead of

777
00:30:18,880 --> 00:30:23,920
actually picking up the call because it

778
00:30:21,160 --> 00:30:25,870
had already switched over to oh you want

779
00:30:23,920 --> 00:30:31,140
to pick up the phone the state's not

780
00:30:25,870 --> 00:30:31,139
latched in yet so that's what happened

781
00:30:31,380 --> 00:30:36,850
this is why it's really critical that

782
00:30:33,700 --> 00:30:39,490
when when we build programs in general

783
00:30:36,850 --> 00:30:40,928
and we have a very good idea that the

784
00:30:39,490 --> 00:30:43,240
framework which we're using is correct

785
00:30:40,929 --> 00:30:45,160
because for all of the truth tables that

786
00:30:43,240 --> 00:30:48,309
I can draw and for all of the validities

787
00:30:45,160 --> 00:30:51,130
you know I can put a state of outputs K

788
00:30:48,309 --> 00:30:53,500
of X 1 through 3 at t minus 1 into my

789
00:30:51,130 --> 00:30:55,600
truth table but if my circuit is wrong

790
00:30:53,500 --> 00:30:57,309
and the timings are backwards that delay

791
00:30:55,600 --> 00:30:58,990
capacitor should actually be on the

792
00:30:57,309 --> 00:31:01,240
other three lines that are switched or

793
00:30:58,990 --> 00:31:02,860
it could simply be on the S lead into

794
00:31:01,240 --> 00:31:03,669
that multiplexer to delay the state

795
00:31:02,860 --> 00:31:05,320
switch and then I need another

796
00:31:03,669 --> 00:31:07,120
multiplexer to do the state switch

797
00:31:05,320 --> 00:31:08,620
before either of those designs would

798
00:31:07,120 --> 00:31:09,129
work perfectly well and do the timings

799
00:31:08,620 --> 00:31:10,659
correctly

800
00:31:09,130 --> 00:31:12,160
and then the platform would be right and

801
00:31:10,660 --> 00:31:15,430
then all of my verification would be

802
00:31:12,160 --> 00:31:18,700
working this is the same if you happen

803
00:31:15,430 --> 00:31:20,260
to be using a library to parse XML like

804
00:31:18,700 --> 00:31:22,540
for example sax

805
00:31:20,260 --> 00:31:24,400
if you don't configure that platform

806
00:31:22,540 --> 00:31:27,220
correctly and you're using an old buggy

807
00:31:24,400 --> 00:31:29,680
version of it no matter what you do in

808
00:31:27,220 --> 00:31:32,470
terms of writing very good xsv documents

809
00:31:29,680 --> 00:31:34,810
that can strain XML into a context-free

810
00:31:32,470 --> 00:31:36,160
system and make sure that every tag

811
00:31:34,810 --> 00:31:38,260
that's in there is one that you know how

812
00:31:36,160 --> 00:31:39,730
to parse for all that you're probably

813
00:31:38,260 --> 00:31:41,260
still going to be vulnerable because

814
00:31:39,730 --> 00:31:46,270
your parser is vulnerable and so you

815
00:31:41,260 --> 00:31:47,680
this this notion of the platform becomes

816
00:31:46,270 --> 00:31:48,970
very critical if you don't have any

817
00:31:47,680 --> 00:31:52,680
reason to believe that the platform is

818
00:31:48,970 --> 00:31:55,780
good so I don't do this very often

819
00:31:52,680 --> 00:31:57,550
because I find that it often only

820
00:31:55,780 --> 00:32:00,090
succeeds in intimidating people but I'm

821
00:31:57,550 --> 00:32:04,090
going to talk about parser combinators

822
00:32:00,090 --> 00:32:05,889
ok a parser Combinator is not a word

823
00:32:04,090 --> 00:32:07,720
that I like to use because really a

824
00:32:05,890 --> 00:32:09,670
parser Combinator is just a parser

825
00:32:07,720 --> 00:32:12,880
generator library does that sound a

826
00:32:09,670 --> 00:32:13,990
little less intimidating maybe no oh I'm

827
00:32:12,880 --> 00:32:15,730
sorry ok

828
00:32:13,990 --> 00:32:18,400
well what it does is it allows you to

829
00:32:15,730 --> 00:32:21,220
take a specification document like a BNF

830
00:32:18,400 --> 00:32:22,570
copied out of an RFC was the dream and

831
00:32:21,220 --> 00:32:24,160
just generate a piece of code that

832
00:32:22,570 --> 00:32:25,629
parses it correctly so that you don't

833
00:32:24,160 --> 00:32:27,340
have to worry about whether or not

834
00:32:25,630 --> 00:32:30,730
you're you're writing a correct parser

835
00:32:27,340 --> 00:32:32,470
library when you program this is become

836
00:32:30,730 --> 00:32:33,850
a little bit of a mantra it much like

837
00:32:32,470 --> 00:32:37,180
generate your passwords generate your

838
00:32:33,850 --> 00:32:39,730
parsers I kind of built my own parser

839
00:32:37,180 --> 00:32:42,850
sort of here for for the constructor if

840
00:32:39,730 --> 00:32:45,820
you will of K of X 3 and it turned out

841
00:32:42,850 --> 00:32:48,490
to be wrong based on things that we

842
00:32:45,820 --> 00:32:51,460
didn't even anticipate or consider while

843
00:32:48,490 --> 00:32:53,680
we were building this design I won't

844
00:32:51,460 --> 00:32:56,380
recommend any specific library to do

845
00:32:53,680 --> 00:32:57,940
this because I mean a lot of them are

846
00:32:56,380 --> 00:32:59,920
still very academic in purpose but

847
00:32:57,940 --> 00:33:04,810
working implementations have been built

848
00:32:59,920 --> 00:33:06,790
and these are not new concepts yak will

849
00:33:04,810 --> 00:33:09,490
do this we've been using them for a

850
00:33:06,790 --> 00:33:11,110
while to post to parse and process the

851
00:33:09,490 --> 00:33:13,180
more complex input formats that we have

852
00:33:11,110 --> 00:33:16,110
and most importantly take the

853
00:33:13,180 --> 00:33:18,730
specification that we have and generates

854
00:33:16,110 --> 00:33:20,830
into any old language that we intended

855
00:33:18,730 --> 00:33:22,840
to program in a working implementation

856
00:33:20,830 --> 00:33:24,280
of that parser that is exactly

857
00:33:22,840 --> 00:33:29,919
equivalent to its implementation in all

858
00:33:24,280 --> 00:33:30,970
other languages so okay I already went

859
00:33:29,920 --> 00:33:33,760
over this

860
00:33:30,970 --> 00:33:36,280
we found types from our circuit we found

861
00:33:33,760 --> 00:33:37,750
that there were boolean types and there

862
00:33:36,280 --> 00:33:40,660
were floating-point types the

863
00:33:37,750 --> 00:33:45,100
floating-point type is the potential on

864
00:33:40,660 --> 00:33:48,310
this line here line le 1 which goes into

865
00:33:45,100 --> 00:33:51,219
the latch enable pin and this kind of it

866
00:33:48,310 --> 00:33:53,590
gives us two emergent models of how the

867
00:33:51,220 --> 00:33:55,750
circuit works some of the types just

868
00:33:53,590 --> 00:33:58,840
billions while I wish the types are

869
00:33:55,750 --> 00:34:00,520
analog signals and so our program in

870
00:33:58,840 --> 00:34:03,250
those analog signals has to be correct

871
00:34:00,520 --> 00:34:07,180
and the easiest best way to do this is

872
00:34:03,250 --> 00:34:10,480
to crowbar it such that every time you

873
00:34:07,180 --> 00:34:12,100
you have a boolean signal you know that

874
00:34:10,480 --> 00:34:13,360
the the corresponding analog signal

875
00:34:12,100 --> 00:34:14,560
that's supposed to do it is correct

876
00:34:13,360 --> 00:34:16,060
because you arranged your timing

877
00:34:14,560 --> 00:34:18,489
capacitors correctly that constitutes

878
00:34:16,060 --> 00:34:21,580
the platform and when we do this we can

879
00:34:18,489 --> 00:34:24,520
abstract away this notion of well what

880
00:34:21,580 --> 00:34:26,319
is the gate potential and is there a

881
00:34:24,520 --> 00:34:29,259
difference between like each of these

882
00:34:26,320 --> 00:34:31,480
various lines in how soon the gate

883
00:34:29,260 --> 00:34:33,190
potential for the latch enable rises or

884
00:34:31,480 --> 00:34:42,429
falls to the level that it should be to

885
00:34:33,190 --> 00:34:43,870
be the appropriate state yeah I already

886
00:34:42,429 --> 00:34:45,250
went over all of the rest of the things

887
00:34:43,870 --> 00:34:50,920
that I was going to discuss on this

888
00:34:45,250 --> 00:34:52,480
slide but so what happens as well is

889
00:34:50,920 --> 00:34:56,020
it's an interesting thing to think about

890
00:34:52,480 --> 00:34:58,420
if you confuse I of x1 for not s of p1

891
00:34:56,020 --> 00:34:59,800
for example we had a solder bridge or we

892
00:34:58,420 --> 00:35:01,540
didn't layout the board correctly and

893
00:34:59,800 --> 00:35:05,020
those two lines are bridged or those two

894
00:35:01,540 --> 00:35:06,100
lines are swapped well given the

895
00:35:05,020 --> 00:35:07,780
frameworks that I just described

896
00:35:06,100 --> 00:35:09,700
effectively what we did is we violated

897
00:35:07,780 --> 00:35:11,350
the type system these two things are

898
00:35:09,700 --> 00:35:13,569
basically exactly the same when you cast

899
00:35:11,350 --> 00:35:15,490
unsafely the thing that you are doing is

900
00:35:13,570 --> 00:35:17,140
is swapping leads to places where they

901
00:35:15,490 --> 00:35:18,609
don't go and the thing where the input

902
00:35:17,140 --> 00:35:19,900
went doesn't really know what to do with

903
00:35:18,610 --> 00:35:22,600
it because it doesn't mean what the

904
00:35:19,900 --> 00:35:24,790
sender thinks it means and so this is

905
00:35:22,600 --> 00:35:26,110
another example of how you can see in in

906
00:35:24,790 --> 00:35:27,850
the hierarchy of language theoretic

907
00:35:26,110 --> 00:35:30,640
security issues they really do kind of

908
00:35:27,850 --> 00:35:32,350
blend together and I'll I'll get into

909
00:35:30,640 --> 00:35:34,629
that I've stolen a slide from when I

910
00:35:32,350 --> 00:35:36,160
gave the paper for later and I'll

911
00:35:34,630 --> 00:35:36,610
discuss which of those ones blend

912
00:35:36,160 --> 00:35:39,640
together

913
00:35:36,610 --> 00:35:42,430
but when you apply this methodology it's

914
00:35:39,640 --> 00:35:44,440
important to consider that the the

915
00:35:42,430 --> 00:35:46,060
design flaw is the design flaw it's not

916
00:35:44,440 --> 00:35:48,820
one individual bug that you can just go

917
00:35:46,060 --> 00:35:50,470
and fix and in fact when we tried to do

918
00:35:48,820 --> 00:35:52,330
that by putting that capacitor there we

919
00:35:50,470 --> 00:35:53,620
noticed that it actually did the

920
00:35:52,330 --> 00:35:55,930
opposite of what we wanted made the

921
00:35:53,620 --> 00:35:58,930
circuit more unreliable because it let

922
00:35:55,930 --> 00:36:03,730
the state settle more in advance of when

923
00:35:58,930 --> 00:36:06,640
it was supposed to flip over so um this

924
00:36:03,730 --> 00:36:09,370
is basically like an unchecked cast this

925
00:36:06,640 --> 00:36:12,370
is basically like my platform sabotaging

926
00:36:09,370 --> 00:36:13,990
me and when this sort of thing happens

927
00:36:12,370 --> 00:36:16,569
it's really not the machine that I built

928
00:36:13,990 --> 00:36:18,399
anymore it's it's got some kind of

929
00:36:16,570 --> 00:36:20,560
electrical flaw or the type system is

930
00:36:18,400 --> 00:36:21,670
broken is basically the same concept is

931
00:36:20,560 --> 00:36:25,900
the point that I was trying to make with

932
00:36:21,670 --> 00:36:27,190
that whole diagram and so now I'm going

933
00:36:25,900 --> 00:36:28,480
to spend a little bit of time further

934
00:36:27,190 --> 00:36:31,990
breaking down the distinction between

935
00:36:28,480 --> 00:36:32,920
CPUs and programs there's really no

936
00:36:31,990 --> 00:36:34,419
distinction at all there's no

937
00:36:32,920 --> 00:36:37,020
distinction at all in practice and in

938
00:36:34,420 --> 00:36:39,490
fact one thing that we found is that

939
00:36:37,020 --> 00:36:40,720
with with most modern processors you

940
00:36:39,490 --> 00:36:42,069
have a whole heck of a lot of micro code

941
00:36:40,720 --> 00:36:43,319
and the micro code can occasionally have

942
00:36:42,070 --> 00:36:46,270
bugs in it

943
00:36:43,320 --> 00:36:48,730
well is the CPU executing your program

944
00:36:46,270 --> 00:36:51,880
is it executing x86 or is it executing

945
00:36:48,730 --> 00:36:53,740
the microcode on x86 as input you know

946
00:36:51,880 --> 00:36:57,280
the program has to be understood at each

947
00:36:53,740 --> 00:37:00,600
of these levels and so really the CPU is

948
00:36:57,280 --> 00:37:02,950
just a platform for implementing the CPU

949
00:37:00,600 --> 00:37:04,779
hardware acceleration basically works in

950
00:37:02,950 --> 00:37:07,689
the opposite direction I take a thing

951
00:37:04,780 --> 00:37:10,830
and I make a little circuit like this

952
00:37:07,690 --> 00:37:15,910
which without any iterative computation

953
00:37:10,830 --> 00:37:19,029
processes a complex function well now

954
00:37:15,910 --> 00:37:21,100
the program is in solder so the opposite

955
00:37:19,030 --> 00:37:23,440
of micro code we've we've moved the

956
00:37:21,100 --> 00:37:25,270
other way and it turns out that because

957
00:37:23,440 --> 00:37:26,890
these two transitions could be made at

958
00:37:25,270 --> 00:37:30,970
infinitum if you had enough patience to

959
00:37:26,890 --> 00:37:34,330
lay out those boards it turns out that

960
00:37:30,970 --> 00:37:35,649
there's no real distinction at all so

961
00:37:34,330 --> 00:37:37,540
this is one of those microcontrollers

962
00:37:35,650 --> 00:37:43,090
that I talked about earlier this is a

963
00:37:37,540 --> 00:37:45,580
chip that decodes DTMF um you'll notice

964
00:37:43,090 --> 00:37:47,710
that even though it's a chip it comes in

965
00:37:45,580 --> 00:37:50,380
in a package is this like it's fairly

966
00:37:47,710 --> 00:37:52,920
large it has a little inch of algorithms

967
00:37:50,380 --> 00:37:58,600
it has the digital detection algorithm

968
00:37:52,920 --> 00:38:01,930
it has the steering logic these sorts of

969
00:37:58,600 --> 00:38:03,670
things I mean that what this chip is is

970
00:38:01,930 --> 00:38:05,919
it's actually a microcontroller and yes

971
00:38:03,670 --> 00:38:07,480
it was engineered such that you can have

972
00:38:05,920 --> 00:38:10,510
a datasheet that has a truth table for

973
00:38:07,480 --> 00:38:11,890
it and so this is a perfect example of a

974
00:38:10,510 --> 00:38:13,270
microcontroller that we would accept

975
00:38:11,890 --> 00:38:14,859
into this design that's supposed to be

976
00:38:13,270 --> 00:38:16,240
built using language theoretic security

977
00:38:14,860 --> 00:38:18,670
principles and as simple as humanly

978
00:38:16,240 --> 00:38:21,100
possible that complexity can be

979
00:38:18,670 --> 00:38:25,150
abstracted away if you verified it and

980
00:38:21,100 --> 00:38:28,120
ensured that in fact for example these

981
00:38:25,150 --> 00:38:30,190
outputs q1 through 4 is actually a BCD

982
00:38:28,120 --> 00:38:32,319
representation of the input and it's not

983
00:38:30,190 --> 00:38:35,200
possible for me to say strobe q1 and

984
00:38:32,320 --> 00:38:37,360
program the chip we would be comfortable

985
00:38:35,200 --> 00:38:38,799
with that because it doesn't expose the

986
00:38:37,360 --> 00:38:40,750
internal complexity of that

987
00:38:38,800 --> 00:38:42,160
microcontroller existing and the design

988
00:38:40,750 --> 00:38:43,990
is small enough that it's actually

989
00:38:42,160 --> 00:38:45,879
possible to verify that it's correct and

990
00:38:43,990 --> 00:38:47,529
now suddenly we can use it as a building

991
00:38:45,880 --> 00:38:52,030
block I'll get into the danger of using

992
00:38:47,530 --> 00:38:54,730
building blocks in a little bit too but

993
00:38:52,030 --> 00:38:56,860
so when one wonders as well from the

994
00:38:54,730 --> 00:38:58,840
previous slide is this chip a chip is

995
00:38:56,860 --> 00:39:00,820
this chip a program

996
00:38:58,840 --> 00:39:03,550
what is its complexity class is it a

997
00:39:00,820 --> 00:39:04,140
finite state automaton yes it's it's

998
00:39:03,550 --> 00:39:07,300
finite

999
00:39:04,140 --> 00:39:09,549
perfect even though the computational

1000
00:39:07,300 --> 00:39:11,350
model in it is a microcontroller we

1001
00:39:09,550 --> 00:39:13,150
threw all of that complexity away by

1002
00:39:11,350 --> 00:39:14,950
having a very strong type system and

1003
00:39:13,150 --> 00:39:18,520
control flow diagram and a protocol for

1004
00:39:14,950 --> 00:39:20,589
it now it doesn't have Turing complete

1005
00:39:18,520 --> 00:39:24,220
computation within bounds anymore it's

1006
00:39:20,590 --> 00:39:26,470
just a transducer from input signals in

1007
00:39:24,220 --> 00:39:30,279
analog types to output signals and

1008
00:39:26,470 --> 00:39:32,140
digital types easy you can tell that

1009
00:39:30,280 --> 00:39:35,520
it's regular because it acts like a chip

1010
00:39:32,140 --> 00:39:37,390
and it has the truth table anyway um so

1011
00:39:35,520 --> 00:39:39,700
let's talk a little bit more about

1012
00:39:37,390 --> 00:39:41,830
emergent complexity that M ta ta ta is

1013
00:39:39,700 --> 00:39:43,330
vastly more complex than my thing so I

1014
00:39:41,830 --> 00:39:47,140
mean maybe it is good to have some

1015
00:39:43,330 --> 00:39:49,900
concerns about it but this circuit is

1016
00:39:47,140 --> 00:39:52,859
small enough is large enough sorry to

1017
00:39:49,900 --> 00:39:57,970
have some emergent complexity even

1018
00:39:52,860 --> 00:40:00,280
though it has only seven real components

1019
00:39:57,970 --> 00:40:02,020
and five of those components could

1020
00:40:00,280 --> 00:40:03,760
easily be condensed into two if I were

1021
00:40:02,020 --> 00:40:07,810
willing to buy a couple more or gates

1022
00:40:03,760 --> 00:40:10,210
um so what complexity class is my buggy

1023
00:40:07,810 --> 00:40:12,190
implementation in one lunders the

1024
00:40:10,210 --> 00:40:13,750
implementation with this capacitor c30

1025
00:40:12,190 --> 00:40:15,370
in there delaying the line that should

1026
00:40:13,750 --> 00:40:18,760
actually be happening in advance of

1027
00:40:15,370 --> 00:40:22,540
everything else it's really hard to say

1028
00:40:18,760 --> 00:40:23,860
isn't it I mean it's difficult to

1029
00:40:22,540 --> 00:40:28,630
imagine how you might make a regular

1030
00:40:23,860 --> 00:40:30,570
expression that parses for example the

1031
00:40:28,630 --> 00:40:33,190
the problem with this circuit is that

1032
00:40:30,570 --> 00:40:34,170
the effects of that capacitor don't mean

1033
00:40:33,190 --> 00:40:36,090
that the functionality is

1034
00:40:34,170 --> 00:40:39,100
deterministically going to make sure

1035
00:40:36,090 --> 00:40:41,110
that that's when you pick up the call on

1036
00:40:39,100 --> 00:40:43,900
path three it doesn't instead dump you

1037
00:40:41,110 --> 00:40:46,960
right onto path one what happens instead

1038
00:40:43,900 --> 00:40:48,580
is it depends on like how charged up c30

1039
00:40:46,960 --> 00:40:50,890
is whether it does that picks up the

1040
00:40:48,580 --> 00:40:54,310
call picks up some other call whether

1041
00:40:50,890 --> 00:40:56,140
the latch has has time to settle in all

1042
00:40:54,310 --> 00:40:57,520
three states or only just a couple of

1043
00:40:56,140 --> 00:40:59,560
the states or only just one of the

1044
00:40:57,520 --> 00:41:01,360
states depends very much on what just

1045
00:40:59,560 --> 00:41:05,080
happened to the latch the voltages input

1046
00:41:01,360 --> 00:41:06,970
to the circuit several other factors it

1047
00:41:05,080 --> 00:41:09,490
reminds me as well of another issue that

1048
00:41:06,970 --> 00:41:11,529
we created earlier in the design we

1049
00:41:09,490 --> 00:41:13,479
intended to sense whether or not a line

1050
00:41:11,530 --> 00:41:14,590
was up by using an extremely small

1051
00:41:13,480 --> 00:41:16,600
amount of current so that we wouldn't

1052
00:41:14,590 --> 00:41:18,550
disturb anything else on the line and so

1053
00:41:16,600 --> 00:41:22,150
what did we use but we fed the line into

1054
00:41:18,550 --> 00:41:24,730
this loop detector using a 22 mega 22

1055
00:41:22,150 --> 00:41:26,380
mega ohm capacitor and then we curve R

1056
00:41:24,730 --> 00:41:28,750
to the 48 volts down to five with a

1057
00:41:26,380 --> 00:41:30,400
Zener diode and then inverted it with

1058
00:41:28,750 --> 00:41:31,870
the 12 volt op amp and this was how we

1059
00:41:30,400 --> 00:41:33,400
figured out whether there was lines is

1060
00:41:31,870 --> 00:41:34,990
whether there was a return voltage on

1061
00:41:33,400 --> 00:41:38,830
the tip of the line that we'd previously

1062
00:41:34,990 --> 00:41:40,540
sent out on the ring well that 22 mega

1063
00:41:38,830 --> 00:41:43,540
ohm capacitor was just a little bit too

1064
00:41:40,540 --> 00:41:44,980
large and unfortunately what we made for

1065
00:41:43,540 --> 00:41:46,630
this because the current was so small

1066
00:41:44,980 --> 00:41:48,220
was actually a primitive capacitive

1067
00:41:46,630 --> 00:41:49,420
touch sensor if you waved your finger

1068
00:41:48,220 --> 00:41:54,700
close enough to it it would think that

1069
00:41:49,420 --> 00:41:56,800
the line was up what's the complexity

1070
00:41:54,700 --> 00:42:00,960
class of that machine we don't even know

1071
00:41:56,800 --> 00:42:00,960
what its inputs are but it was the pins

1072
00:42:02,640 --> 00:42:06,279
so it turns out that this isn't just

1073
00:42:04,660 --> 00:42:07,810
something that happens to people who try

1074
00:42:06,280 --> 00:42:10,470
to be electrical engineers but don't

1075
00:42:07,810 --> 00:42:13,690
actually know what they're doing um

1076
00:42:10,470 --> 00:42:15,040
there is a model for an x86 processor I

1077
00:42:13,690 --> 00:42:16,630
don't remember what it's called but it's

1078
00:42:15,040 --> 00:42:17,490
an open-source model and academics love

1079
00:42:16,630 --> 00:42:19,950
to use it

1080
00:42:17,490 --> 00:42:22,890
and you can kind of just like take this

1081
00:42:19,950 --> 00:42:24,270
model and compile it it's VHDL and you

1082
00:42:22,890 --> 00:42:26,819
get a working processor at the end and

1083
00:42:24,270 --> 00:42:28,500
you can change it up or you can do what

1084
00:42:26,820 --> 00:42:31,349
these folks did this was a paper

1085
00:42:28,500 --> 00:42:33,119
presented at I Triple E Oakland in 2016

1086
00:42:31,349 --> 00:42:35,160
and it's a paper that I dearly love

1087
00:42:33,119 --> 00:42:37,200
and once I described the exploit you

1088
00:42:35,160 --> 00:42:38,940
will probably love it too um

1089
00:42:37,200 --> 00:42:40,560
the paper is called a to analog

1090
00:42:38,940 --> 00:42:42,440
malicious Hardware in case my text is

1091
00:42:40,560 --> 00:42:45,570
too small and the TV is too reflective

1092
00:42:42,440 --> 00:42:48,390
and what this paper is about is they

1093
00:42:45,570 --> 00:42:51,960
took that x86 model that giant

1094
00:42:48,390 --> 00:42:54,390
complexity machine and um they compiled

1095
00:42:51,960 --> 00:42:56,010
it into VHDL sure but to simulate an

1096
00:42:54,390 --> 00:42:57,839
untrusted fab they drew some extra

1097
00:42:56,010 --> 00:43:03,720
traces on the plates before they got

1098
00:42:57,839 --> 00:43:06,359
laid down into silicon they drew two

1099
00:43:03,720 --> 00:43:07,859
things they drew a resistor and they

1100
00:43:06,359 --> 00:43:09,839
drew a capacitor and then they drew a

1101
00:43:07,859 --> 00:43:14,040
few traces to connect them all up so um

1102
00:43:09,839 --> 00:43:15,690
Oh briefly sidetrack here and explain

1103
00:43:14,040 --> 00:43:17,970
the privilege model on x86 there are

1104
00:43:15,690 --> 00:43:20,609
effectively two privileged modes there

1105
00:43:17,970 --> 00:43:22,649
is privileged mode user or ring three

1106
00:43:20,609 --> 00:43:25,589
and there's privileged mode kernel which

1107
00:43:22,650 --> 00:43:27,660
is ring zero if you want to do certain

1108
00:43:25,589 --> 00:43:30,000
instructions like change the memory

1109
00:43:27,660 --> 00:43:33,660
model or like output directly to a

1110
00:43:30,000 --> 00:43:35,430
hardware device or access kernel memory

1111
00:43:33,660 --> 00:43:37,259
without worrying about the page table um

1112
00:43:35,430 --> 00:43:39,990
you need to be in ring zero to do this

1113
00:43:37,260 --> 00:43:41,369
so if you are trying to exploit the

1114
00:43:39,990 --> 00:43:42,569
kernel or if you want persistence on the

1115
00:43:41,369 --> 00:43:44,670
machine or if you want to update the

1116
00:43:42,570 --> 00:43:47,970
BIOS it's really really really handy for

1117
00:43:44,670 --> 00:43:52,500
you to be running in ring zero this is a

1118
00:43:47,970 --> 00:43:54,089
two bit component of the not the flags

1119
00:43:52,500 --> 00:43:56,330
register but are related registered that

1120
00:43:54,089 --> 00:43:58,349
it's the segment register in x86

1121
00:43:56,330 --> 00:44:00,900
specifically those two bits of the

1122
00:43:58,349 --> 00:44:03,690
segment register for the code segment in

1123
00:44:00,900 --> 00:44:05,670
x86 even in 64-bit mode dictate whether

1124
00:44:03,690 --> 00:44:08,760
or not you're the kernel or or you're

1125
00:44:05,670 --> 00:44:11,760
the user the bits must be exactly

1126
00:44:08,760 --> 00:44:14,880
equivalent um basically nobody used the

1127
00:44:11,760 --> 00:44:17,160
the other two in between zero and three

1128
00:44:14,880 --> 00:44:20,369
so they're basically gone and not usable

1129
00:44:17,160 --> 00:44:22,890
um but so what components would I draw

1130
00:44:20,369 --> 00:44:24,780
on something if I wanted to on command

1131
00:44:22,890 --> 00:44:26,940
to be able to get down into kernel mode

1132
00:44:24,780 --> 00:44:29,160
well I can draw in the chip of course

1133
00:44:26,940 --> 00:44:31,350
this is accessible to me what the

1134
00:44:29,160 --> 00:44:34,020
researchers did is they took

1135
00:44:31,350 --> 00:44:36,660
/ zero line out of the out of the

1136
00:44:34,020 --> 00:44:38,460
exception part of the chip and this is

1137
00:44:36,660 --> 00:44:42,029
just a line there's a pin on the outside

1138
00:44:38,460 --> 00:44:45,930
of the chip for it and so they put a

1139
00:44:42,030 --> 00:44:49,610
resistor from from the capacitor to

1140
00:44:45,930 --> 00:44:52,470
ground and then they basically just

1141
00:44:49,610 --> 00:44:54,180
arranged it so that the / 0 line was

1142
00:44:52,470 --> 00:44:57,149
connected to this capacitor which was

1143
00:44:54,180 --> 00:44:58,620
connected into a not gate that was

1144
00:44:57,150 --> 00:45:02,400
somewhere so sorry they didn't draw just

1145
00:44:58,620 --> 00:45:04,830
- which was then connect or sorry an xor

1146
00:45:02,400 --> 00:45:09,900
gate which was then connected to those

1147
00:45:04,830 --> 00:45:12,090
two lines so this is fun now if I divide

1148
00:45:09,900 --> 00:45:14,070
by zero enough hundred thousand times

1149
00:45:12,090 --> 00:45:20,040
I'm in kernel mode for a while until the

1150
00:45:14,070 --> 00:45:22,620
capacitor discharges and then how do you

1151
00:45:20,040 --> 00:45:25,230
find this you don't even know what your

1152
00:45:22,620 --> 00:45:27,740
inputs are it turns out that divided by

1153
00:45:25,230 --> 00:45:30,270
zero is now something that's a function

1154
00:45:27,740 --> 00:45:31,830
input to what the current privileged

1155
00:45:30,270 --> 00:45:34,290
state is but only if you do it a few

1156
00:45:31,830 --> 00:45:36,480
hundred thousand times so this x plate

1157
00:45:34,290 --> 00:45:38,490
is an analog malicious hardware charging

1158
00:45:36,480 --> 00:45:40,920
because it doesn't fit into the digital

1159
00:45:38,490 --> 00:45:42,240
computation model much like our problem

1160
00:45:40,920 --> 00:45:43,500
with you picking up the phone and then

1161
00:45:42,240 --> 00:45:44,819
accidentally if you do the right thing

1162
00:45:43,500 --> 00:45:47,310
with the hook switch getting shunted to

1163
00:45:44,820 --> 00:45:49,320
a different path and listening in on

1164
00:45:47,310 --> 00:45:51,299
someone else's call this was an issue

1165
00:45:49,320 --> 00:45:53,250
whereby the emergent functionality

1166
00:45:51,300 --> 00:45:54,690
introduced new inputs of completely

1167
00:45:53,250 --> 00:45:56,250
different types to our program that the

1168
00:45:54,690 --> 00:45:58,050
attacker understands but we didn't

1169
00:45:56,250 --> 00:46:01,500
anticipate existed and so aren't part of

1170
00:45:58,050 --> 00:46:02,820
our security or verification level the

1171
00:46:01,500 --> 00:46:04,680
reason that I love this paper is that

1172
00:46:02,820 --> 00:46:06,780
any method that you would use to verify

1173
00:46:04,680 --> 00:46:08,750
whether the x86 processor is correct

1174
00:46:06,780 --> 00:46:11,220
would pass in the presence of this thing

1175
00:46:08,750 --> 00:46:12,810
nobody is going disable what happens if

1176
00:46:11,220 --> 00:46:13,890
I strobe every single line on this chip

1177
00:46:12,810 --> 00:46:15,180
a few million times you've never

1178
00:46:13,890 --> 00:46:16,200
finished testing this is one of those

1179
00:46:15,180 --> 00:46:18,180
scenarios where we're trying to

1180
00:46:16,200 --> 00:46:21,629
enumerate every possible state of the

1181
00:46:18,180 --> 00:46:23,370
machine um the other reason that I like

1182
00:46:21,630 --> 00:46:25,560
it is because if you've ever had the

1183
00:46:23,370 --> 00:46:27,870
opportunity to compile something from

1184
00:46:25,560 --> 00:46:30,840
VHDL into something that a fab can

1185
00:46:27,870 --> 00:46:32,730
create you might find very quickly that

1186
00:46:30,840 --> 00:46:36,300
the thing that comes out of the compiler

1187
00:46:32,730 --> 00:46:38,430
is not really amenable to it's more of

1188
00:46:36,300 --> 00:46:39,660
the class of let's enumerate every bit

1189
00:46:38,430 --> 00:46:42,649
on this hard drive and draw a truth

1190
00:46:39,660 --> 00:46:45,240
table trying to figure out backwards

1191
00:46:42,650 --> 00:46:47,310
then than it is like

1192
00:46:45,240 --> 00:46:50,399
trying to figure out what a small

1193
00:46:47,310 --> 00:46:53,640
circuit does um so yes writing

1194
00:46:50,400 --> 00:46:55,560
specifications is not that hard just try

1195
00:46:53,640 --> 00:46:58,920
to compiler for them just make some

1196
00:46:55,560 --> 00:47:01,110
machines just you know write a compiler

1197
00:46:58,920 --> 00:47:02,610
from the implemented program back into

1198
00:47:01,110 --> 00:47:06,240
its logic and verify it that can't

1199
00:47:02,610 --> 00:47:08,550
possibly be that hard right no so this

1200
00:47:06,240 --> 00:47:09,839
is why I spent a little bit of time

1201
00:47:08,550 --> 00:47:11,970
talking about parser Combinator's

1202
00:47:09,840 --> 00:47:13,619
earlier life is so much easier when you

1203
00:47:11,970 --> 00:47:15,118
can work with the protocol specification

1204
00:47:13,619 --> 00:47:17,070
which is the high level logical entity

1205
00:47:15,119 --> 00:47:19,560
that you intended to have then when you

1206
00:47:17,070 --> 00:47:21,980
have to figure out from the program or

1207
00:47:19,560 --> 00:47:24,360
god forbid from the compiled program

1208
00:47:21,980 --> 00:47:25,770
what its input languages and what all

1209
00:47:24,360 --> 00:47:27,270
the things are that it will accept in

1210
00:47:25,770 --> 00:47:28,890
which states that will put the program

1211
00:47:27,270 --> 00:47:32,340
into and whether or not there's discrete

1212
00:47:28,890 --> 00:47:34,170
parsing and then parsing stages it's way

1213
00:47:32,340 --> 00:47:35,700
better to do this stuff in advance and

1214
00:47:34,170 --> 00:47:39,350
that's what language theoretically

1215
00:47:35,700 --> 00:47:41,160
spends so much time advocating for

1216
00:47:39,350 --> 00:47:43,290
because every time you write a program

1217
00:47:41,160 --> 00:47:45,390
you have an implicit input specification

1218
00:47:43,290 --> 00:47:49,560
every time you lay down some circuits

1219
00:47:45,390 --> 00:47:51,240
you have an implicit truth table and you

1220
00:47:49,560 --> 00:47:52,950
really want to avoid this danger where

1221
00:47:51,240 --> 00:47:55,470
much like this oddball processor that

1222
00:47:52,950 --> 00:47:57,600
has the divide by zero thrashing lead to

1223
00:47:55,470 --> 00:48:00,980
kernel mode your design happens to be

1224
00:47:57,600 --> 00:48:03,210
one of those unique few that has the bug

1225
00:48:00,980 --> 00:48:05,609
um so can't you just determine whether

1226
00:48:03,210 --> 00:48:07,470
the dies in the VHDL match to figure out

1227
00:48:05,609 --> 00:48:09,299
whether or not the analog malicious

1228
00:48:07,470 --> 00:48:10,350
hardware version is present the answer

1229
00:48:09,300 --> 00:48:12,960
is No

1230
00:48:10,350 --> 00:48:15,330
if you've ever compiled a program or you

1231
00:48:12,960 --> 00:48:16,650
don't even have to have used VHDL to do

1232
00:48:15,330 --> 00:48:17,790
this if you've ever compile the program

1233
00:48:16,650 --> 00:48:19,440
you might notice that each time you

1234
00:48:17,790 --> 00:48:21,240
compile it it has a proclivity to be

1235
00:48:19,440 --> 00:48:22,980
slightly different there's a lot of

1236
00:48:21,240 --> 00:48:24,479
non-deterministic minor changes in your

1237
00:48:22,980 --> 00:48:29,100
code can create major changes in the

1238
00:48:24,480 --> 00:48:31,680
output so know um you can't simply take

1239
00:48:29,100 --> 00:48:33,330
your your code unless it's dotnet and

1240
00:48:31,680 --> 00:48:34,859
even then run it through a D compiler

1241
00:48:33,330 --> 00:48:37,259
and get exactly what you had in the

1242
00:48:34,859 --> 00:48:39,210
beginning and verify it this isn't

1243
00:48:37,260 --> 00:48:41,580
really a viable mechanism of checking

1244
00:48:39,210 --> 00:48:44,340
compilers you have to go through all of

1245
00:48:41,580 --> 00:48:45,900
the the things that the D compiler gets

1246
00:48:44,340 --> 00:48:47,280
and figure out whether they actually

1247
00:48:45,900 --> 00:48:50,040
match or you would have to take the

1248
00:48:47,280 --> 00:48:51,000
netlist that you find from looking at

1249
00:48:50,040 --> 00:48:53,369
what's on the die

1250
00:48:51,000 --> 00:48:55,260
and then figure out if that netlist has

1251
00:48:53,369 --> 00:48:56,880
a material deviation because it will

1252
00:48:55,260 --> 00:48:59,000
have many deviations but whether it has

1253
00:48:56,880 --> 00:49:01,470
a material deviation from the program

1254
00:48:59,000 --> 00:49:02,940
it's way better to verify the compiler

1255
00:49:01,470 --> 00:49:04,770
once preferably if somebody else

1256
00:49:02,940 --> 00:49:07,140
verifies the compiler and then use that

1257
00:49:04,770 --> 00:49:08,970
one and that is the essence of why

1258
00:49:07,140 --> 00:49:11,069
generated parsers are better we can

1259
00:49:08,970 --> 00:49:13,109
verify that the generator is correct

1260
00:49:11,069 --> 00:49:15,359
once and then we know that every time it

1261
00:49:13,109 --> 00:49:18,869
outputs something it outputs things that

1262
00:49:15,359 --> 00:49:21,960
match the specification so it could be

1263
00:49:18,869 --> 00:49:23,730
as easy as just figuring out whether or

1264
00:49:21,960 --> 00:49:26,010
not our compiler worked by working

1265
00:49:23,730 --> 00:49:28,349
backwards but it turns out that this is

1266
00:49:26,010 --> 00:49:30,359
actually at least as hard and possibly

1267
00:49:28,349 --> 00:49:32,940
quite a lot harder than implementing the

1268
00:49:30,359 --> 00:49:35,430
compiler yourself to begin with and it's

1269
00:49:32,940 --> 00:49:37,230
better if we write proofs and let

1270
00:49:35,430 --> 00:49:39,240
someone else write those proofs and so

1271
00:49:37,230 --> 00:49:42,540
the reason that the parser Combinator's

1272
00:49:39,240 --> 00:49:44,339
thing i want to try to make less

1273
00:49:42,540 --> 00:49:46,349
intimidating is because it really is

1274
00:49:44,339 --> 00:49:48,390
less intimidating i mean what's more

1275
00:49:46,349 --> 00:49:52,740
intimidating right a specification for

1276
00:49:48,390 --> 00:49:55,140
your protocol or writes a verified

1277
00:49:52,740 --> 00:49:58,160
program that you can show is correct

1278
00:49:55,140 --> 00:50:04,828
that transduces from one to the other

1279
00:49:58,160 --> 00:50:06,029
really um I'll just skip that slide

1280
00:50:04,829 --> 00:50:11,010
since I think I'm running a little bit

1281
00:50:06,030 --> 00:50:12,540
low on time so here again are the basic

1282
00:50:11,010 --> 00:50:15,359
tenets of language theoretic security

1283
00:50:12,540 --> 00:50:17,460
from the paper that I mentioned the the

1284
00:50:15,359 --> 00:50:19,259
seven traits of Babel the first one we

1285
00:50:17,460 --> 00:50:23,869
discussed is shotgun parsing we're

1286
00:50:19,260 --> 00:50:26,880
continually you have this issue whereby

1287
00:50:23,869 --> 00:50:28,470
your your state that is input is

1288
00:50:26,880 --> 00:50:30,210
processed a little bit modifies your

1289
00:50:28,470 --> 00:50:32,040
program state and influences the things

1290
00:50:30,210 --> 00:50:33,750
that are in the threat model and then we

1291
00:50:32,040 --> 00:50:35,630
continue later to decide whether or not

1292
00:50:33,750 --> 00:50:37,890
the input is malicious don't do that

1293
00:50:35,630 --> 00:50:40,230
input languages more complex than

1294
00:50:37,890 --> 00:50:42,779
deterministic context-free um this is

1295
00:50:40,230 --> 00:50:44,760
one that I I often like to explain by

1296
00:50:42,780 --> 00:50:46,290
saying your input protocol should look

1297
00:50:44,760 --> 00:50:48,420
no more complex and intimidating than

1298
00:50:46,290 --> 00:50:50,160
JSON and shouldn't look across to other

1299
00:50:48,420 --> 00:50:52,740
JSON documents to figure out whether the

1300
00:50:50,160 --> 00:50:54,540
current one is valid this is a good way

1301
00:50:52,740 --> 00:50:56,220
of explaining it but it leaves out one

1302
00:50:54,540 --> 00:50:58,470
of the most important things which I was

1303
00:50:56,220 --> 00:51:00,689
talking about in previous slides which

1304
00:50:58,470 --> 00:51:02,730
is that although you might well be able

1305
00:51:00,690 --> 00:51:04,770
to enumerate all of your inputs and

1306
00:51:02,730 --> 00:51:09,170
thereby make it less complex than

1307
00:51:04,770 --> 00:51:12,270
deterministic context-free you shouldn't

1308
00:51:09,170 --> 00:51:12,839
because that model is not amenable to

1309
00:51:12,270 --> 00:51:14,190
figure

1310
00:51:12,839 --> 00:51:15,509
whether the bugs are there you can't

1311
00:51:14,190 --> 00:51:17,130
meaningfully reason about it and the

1312
00:51:15,509 --> 00:51:18,390
reason that the input language shouldn't

1313
00:51:17,130 --> 00:51:20,579
be more complex than deterministic

1314
00:51:18,390 --> 00:51:22,259
context-free is because you've exposed

1315
00:51:20,579 --> 00:51:23,849
if it is more complex too much

1316
00:51:22,259 --> 00:51:27,690
functionality potentially a complete

1317
00:51:23,849 --> 00:51:30,509
Turing machine to your attacker and so

1318
00:51:27,690 --> 00:51:32,160
if you instead of exposing something

1319
00:51:30,509 --> 00:51:34,499
that's high on the Chomsky hierarchy to

1320
00:51:32,160 --> 00:51:37,259
your attacker you just expose a lot of

1321
00:51:34,499 --> 00:51:38,939
very low level complexity we found that

1322
00:51:37,259 --> 00:51:40,979
these things are exactly equivalent and

1323
00:51:38,940 --> 00:51:43,109
we found that in in our experience

1324
00:51:40,979 --> 00:51:45,450
designing this component even with a

1325
00:51:43,109 --> 00:51:48,089
truth table that was only a few columns

1326
00:51:45,450 --> 00:51:49,828
wide we still had immense trouble

1327
00:51:48,089 --> 00:51:51,660
checking that our constant

1328
00:51:49,829 --> 00:51:53,219
implementation actually matched the

1329
00:51:51,660 --> 00:51:55,140
thing that we were intending to do and

1330
00:51:53,219 --> 00:51:57,029
actually a program even though

1331
00:51:55,140 --> 00:52:00,420
turing-complete may well have been much

1332
00:51:57,029 --> 00:52:02,190
easier to check um

1333
00:52:00,420 --> 00:52:03,450
non minimalistic input handling is

1334
00:52:02,190 --> 00:52:05,130
another one that I haven't really gone

1335
00:52:03,450 --> 00:52:06,868
over here but this is effectively the

1336
00:52:05,130 --> 00:52:09,749
same thing as shotgun parsing in many

1337
00:52:06,869 --> 00:52:11,519
respects it's your input handling should

1338
00:52:09,749 --> 00:52:16,069
have as few features as possible this is

1339
00:52:11,519 --> 00:52:19,859
the turn off XML entity expansion in sax

1340
00:52:16,069 --> 00:52:21,690
simple enough um if you the the science

1341
00:52:19,859 --> 00:52:23,578
here is don't expose complexity to your

1342
00:52:21,690 --> 00:52:26,849
attacker that doesn't need to exist and

1343
00:52:23,579 --> 00:52:28,799
so if your input handling does anything

1344
00:52:26,849 --> 00:52:31,559
other than just check the input put it

1345
00:52:28,799 --> 00:52:33,749
into deserialized types and verify

1346
00:52:31,559 --> 00:52:35,309
whether or not it's valid then that's

1347
00:52:33,749 --> 00:52:37,890
additional power given to the attacker

1348
00:52:35,309 --> 00:52:41,130
that didn't necessarily need to be there

1349
00:52:37,890 --> 00:52:43,799
parser differentials is another one this

1350
00:52:41,130 --> 00:52:45,719
one simply explained is I have a line

1351
00:52:43,799 --> 00:52:47,190
and both ends of that line disagree

1352
00:52:45,719 --> 00:52:49,319
about its meaning this is when I cross

1353
00:52:47,190 --> 00:52:51,960
connected and one of the lines that

1354
00:52:49,319 --> 00:52:54,479
detects whether a path is occupied to

1355
00:52:51,960 --> 00:52:57,690
whether or not there's an incoming call

1356
00:52:54,479 --> 00:53:00,598
on a line if both ends don't agree about

1357
00:52:57,690 --> 00:53:02,700
what exactly the protocol means within

1358
00:53:00,599 --> 00:53:04,920
very well enumerated bounds for example

1359
00:53:02,700 --> 00:53:06,089
if you have an X dot 509 parser and it

1360
00:53:04,920 --> 00:53:08,640
doesn't understand what a critical

1361
00:53:06,089 --> 00:53:10,078
section is and so ignores it your

1362
00:53:08,640 --> 00:53:13,019
violation of this specification is

1363
00:53:10,079 --> 00:53:14,819
likely to be material and so avoiding

1364
00:53:13,019 --> 00:53:16,410
parser differentials is something that

1365
00:53:14,819 --> 00:53:18,180
is best done by making sure that your

1366
00:53:16,410 --> 00:53:19,618
specification is not incomplete and that

1367
00:53:18,180 --> 00:53:21,899
people when implementing it actually

1368
00:53:19,619 --> 00:53:23,549
implement the full specification an

1369
00:53:21,900 --> 00:53:25,229
incomplete specification is more or less

1370
00:53:23,549 --> 00:53:26,788
inviting parser differentials because it

1371
00:53:25,229 --> 00:53:28,589
leads people to guess

1372
00:53:26,789 --> 00:53:30,989
what the meaning of particular special

1373
00:53:28,589 --> 00:53:32,549
cases in the protocol are and that ntp

1374
00:53:30,989 --> 00:53:34,679
bug that I mentioned earlier where a

1375
00:53:32,549 --> 00:53:36,538
null key would allow you to just assert

1376
00:53:34,679 --> 00:53:38,400
a syndication and update the time on

1377
00:53:36,539 --> 00:53:42,900
fairly high stratum clocks low stratum

1378
00:53:38,400 --> 00:53:45,179
clocks the problem there was that the

1379
00:53:42,900 --> 00:53:46,799
specification didn't really say and in

1380
00:53:45,179 --> 00:53:48,599
fact the reference code for NTP

1381
00:53:46,799 --> 00:53:50,130
implementations didn't show that this

1382
00:53:48,599 --> 00:53:51,809
particular flow should not be allowed

1383
00:53:50,130 --> 00:53:54,929
and so it was allowed

1384
00:53:51,809 --> 00:53:56,429
oops um overloaded fields is another one

1385
00:53:54,929 --> 00:53:58,199
that's really evil and we try to

1386
00:53:56,429 --> 00:54:00,419
overload fields as little as possible

1387
00:53:58,199 --> 00:54:02,910
when designing circuits one might find

1388
00:54:00,419 --> 00:54:04,979
that fields often get overloaded because

1389
00:54:02,910 --> 00:54:06,808
you have a pin like depending on the

1390
00:54:04,979 --> 00:54:09,390
context that pin might be an input or an

1391
00:54:06,809 --> 00:54:10,709
output um you have to be very careful

1392
00:54:09,390 --> 00:54:12,538
with this that's kind of playing with

1393
00:54:10,709 --> 00:54:14,339
fire because if the circuit isn't in the

1394
00:54:12,539 --> 00:54:15,779
state that you think that it is the pin

1395
00:54:14,339 --> 00:54:17,609
doesn't have the signal on it that you

1396
00:54:15,779 --> 00:54:22,380
think that it has and so thinking back

1397
00:54:17,609 --> 00:54:25,739
to my my circuit diagram from before we

1398
00:54:22,380 --> 00:54:28,769
thought that the pins one D through

1399
00:54:25,739 --> 00:54:30,359
three D on that latch would have the

1400
00:54:28,769 --> 00:54:32,308
correct signal on them for which line

1401
00:54:30,359 --> 00:54:34,499
you should be on when the latch flipped

1402
00:54:32,309 --> 00:54:37,679
over it turned out that that was not

1403
00:54:34,499 --> 00:54:39,689
actually the case and that's why it was

1404
00:54:37,679 --> 00:54:40,859
possible to accidentally be put on two

1405
00:54:39,689 --> 00:54:44,368
paths that you shouldn't have been put

1406
00:54:40,859 --> 00:54:46,469
on effectively because that field was

1407
00:54:44,369 --> 00:54:48,869
was a little bit overloaded and we

1408
00:54:46,469 --> 00:54:51,119
didn't like the pin could have been

1409
00:54:48,869 --> 00:54:52,799
either find the next available path or

1410
00:54:51,119 --> 00:54:54,089
find the path that has an incoming call

1411
00:54:52,799 --> 00:54:59,579
on it for me that's next

1412
00:54:54,089 --> 00:55:01,279
but we didn't well enough define by not

1413
00:54:59,579 --> 00:55:03,689
putting the correct timing capacitors in

1414
00:55:01,279 --> 00:55:05,489
when it was one state or when it was the

1415
00:55:03,689 --> 00:55:06,839
other and so effectively that field had

1416
00:55:05,489 --> 00:55:10,429
two meanings at once and that is the

1417
00:55:06,839 --> 00:55:10,429
thing that you cannot have go on

1418
00:55:13,910 --> 00:55:19,649
ha ha so this isn't the invent signaling

1419
00:55:17,310 --> 00:55:20,640
part of the phone switch um no it does

1420
00:55:19,650 --> 00:55:21,960
sound a little bit like in been

1421
00:55:20,640 --> 00:55:23,940
signaling doesn't it because the phone

1422
00:55:21,960 --> 00:55:27,180
network is when if you wanted to model

1423
00:55:23,940 --> 00:55:30,390
it that way one gargantuan circuit so no

1424
00:55:27,180 --> 00:55:31,980
um it's it's almost in been signaling

1425
00:55:30,390 --> 00:55:34,080
though this is all behind a logic

1426
00:55:31,980 --> 00:55:35,730
boundary on the only input in it that

1427
00:55:34,080 --> 00:55:37,470
depends on the line electrically is

1428
00:55:35,730 --> 00:55:39,030
whether or not the line is picked up but

1429
00:55:37,470 --> 00:55:41,040
if you allow these signals to ingress

1430
00:55:39,030 --> 00:55:42,810
for example their AC or were allowing

1431
00:55:41,040 --> 00:55:45,270
people to charge the capacitor we can

1432
00:55:42,810 --> 00:55:47,060
have emergent in-band signaling and that

1433
00:55:45,270 --> 00:55:49,230
is effectively what the bug is

1434
00:55:47,060 --> 00:55:51,060
permissive processing an invalid input I

1435
00:55:49,230 --> 00:55:52,290
think I went through more than enough

1436
00:55:51,060 --> 00:55:54,840
you have to know that your inputs are

1437
00:55:52,290 --> 00:55:56,910
what they say they are and if you

1438
00:55:54,840 --> 00:55:58,590
intentionally be liberal in what you

1439
00:55:56,910 --> 00:56:00,359
accept without knowing what it is that

1440
00:55:58,590 --> 00:56:01,920
you're accepting you also have our

1441
00:56:00,359 --> 00:56:03,450
proclivity to get bugs in this case

1442
00:56:01,920 --> 00:56:05,040
maybe I should have used an inductor to

1443
00:56:03,450 --> 00:56:06,359
filter out all of the AC because I

1444
00:56:05,040 --> 00:56:10,980
really didn't want that it causes

1445
00:56:06,359 --> 00:56:12,598
glitches and so with that I believe I am

1446
00:56:10,980 --> 00:56:16,770
out of time

1447
00:56:12,599 --> 00:56:17,970
so please if you have any other

1448
00:56:16,770 --> 00:56:20,009
questions for me I'll be at the shady

1449
00:56:17,970 --> 00:56:21,810
tell camp but that's me on Twitter or

1450
00:56:20,010 --> 00:56:24,920
I'm also available by email eventually

1451
00:56:21,810 --> 00:56:24,920
thank you very much

1452
00:56:30,780 --> 00:56:34,060
and apparently I do have time for

1453
00:56:32,620 --> 00:56:37,350
questions so if anyone has any please

1454
00:56:34,060 --> 00:56:44,080
fire away until I get kicked off here

1455
00:56:37,350 --> 00:56:48,190
hey we're gonna get started how to do

1456
00:56:44,080 --> 00:56:50,620
lane sec um so yes the 7 turrets of

1457
00:56:48,190 --> 00:56:52,510
Babel paper is specifically designed to

1458
00:56:50,620 --> 00:56:55,839
be accessible to software engineers with

1459
00:56:52,510 --> 00:56:58,090
no no background in the ways that

1460
00:56:55,840 --> 00:56:59,740
academics prove whether or not something

1461
00:56:58,090 --> 00:57:01,960
falls within the complexity classes that

1462
00:56:59,740 --> 00:57:02,669
we wanted and so I would actually start

1463
00:57:01,960 --> 00:57:05,020
there

1464
00:57:02,670 --> 00:57:08,530
yeah the seven terms of Babel or Lang

1465
00:57:05,020 --> 00:57:10,060
sect org has a lot of material some of

1466
00:57:08,530 --> 00:57:13,630
the material is less accessible and more

1467
00:57:10,060 --> 00:57:14,549
academic but some of it is articles and

1468
00:57:13,630 --> 00:57:18,730
things

1469
00:57:14,550 --> 00:57:22,120
really unfortunately because yeah I'm

1470
00:57:18,730 --> 00:57:25,000
still the best source of knowledge is

1471
00:57:22,120 --> 00:57:26,620
there and the majority of the rest of it

1472
00:57:25,000 --> 00:57:29,680
because it remains very much an academic

1473
00:57:26,620 --> 00:57:32,859
field of study if you happen to have

1474
00:57:29,680 --> 00:57:35,230
access to academic papers on lang stack

1475
00:57:32,860 --> 00:57:38,080
is a good keyword just search and every

1476
00:57:35,230 --> 00:57:40,420
year there's a workshop attached to the

1477
00:57:38,080 --> 00:57:42,279
Oakland conference it was just a few

1478
00:57:40,420 --> 00:57:43,660
months ago I Triple E security and

1479
00:57:42,280 --> 00:57:46,060
privacy workshops has a Lang SEC

1480
00:57:43,660 --> 00:57:48,430
workshop that we present all of the new

1481
00:57:46,060 --> 00:57:55,360
and latest developments in defining the

1482
00:57:48,430 --> 00:57:57,480
terms in our field in anyone else go

1483
00:57:55,360 --> 00:57:57,480
ahead

1484
00:57:59,160 --> 00:58:06,080
like what one way to look at certain

1485
00:58:03,000 --> 00:58:06,080
selection circuit

1486
00:58:06,480 --> 00:58:10,170
the transition from 15 songs in his free

1487
00:58:08,549 --> 00:58:13,079
time there a reason for every industry

1488
00:58:10,170 --> 00:58:16,079
time but of course it's really less

1489
00:58:13,079 --> 00:58:18,559
about a decision that's really also

1490
00:58:16,079 --> 00:58:18,559
around

1491
00:58:19,589 --> 00:58:23,630
like one of the ways to deal

1492
00:58:31,380 --> 00:58:37,770
is like it is a tree off

1493
00:58:46,300 --> 00:58:52,360
okay I'll try and repeat that as much as

1494
00:58:49,700 --> 00:58:55,970
I can so the question was basically

1495
00:58:52,360 --> 00:58:57,350
first pointing out the bug the timing

1496
00:58:55,970 --> 00:58:59,750
attack that we have in here seems to

1497
00:58:57,350 --> 00:59:01,009
derive from the difference between the

1498
00:58:59,750 --> 00:59:02,990
fact that we're reasoning about this

1499
00:59:01,010 --> 00:59:06,230
circuit in discrete time and yet it's

1500
00:59:02,990 --> 00:59:08,509
really a constant time circuit and the

1501
00:59:06,230 --> 00:59:11,930
answer is yes absolutely that's where

1502
00:59:08,510 --> 00:59:15,110
the bug comes from the additional was

1503
00:59:11,930 --> 00:59:16,730
this could be potentially solved by a

1504
00:59:15,110 --> 00:59:17,690
clock although having the clock in the

1505
00:59:16,730 --> 00:59:19,550
additional state adds additional

1506
00:59:17,690 --> 00:59:22,010
complexity which would also then have to

1507
00:59:19,550 --> 00:59:24,770
be reasoned about this is also very

1508
00:59:22,010 --> 00:59:26,960
valid and so the question was is there

1509
00:59:24,770 --> 00:59:29,210
conscious trade-off that we made between

1510
00:59:26,960 --> 00:59:31,970
those two things the answer is

1511
00:59:29,210 --> 00:59:33,560
absolutely yes we found that for a

1512
00:59:31,970 --> 00:59:34,490
circuit of that class the complexity

1513
00:59:33,560 --> 00:59:37,640
that would have been introduced by a

1514
00:59:34,490 --> 00:59:38,600
clock would have been close enough to

1515
00:59:37,640 --> 00:59:40,160
the complexity that would have been

1516
00:59:38,600 --> 00:59:41,600
introduced by a microcontroller we would

1517
00:59:40,160 --> 00:59:43,460
have had to make sure that the states

1518
00:59:41,600 --> 00:59:48,350
had settled before the clock ticked over

1519
00:59:43,460 --> 00:59:50,210
anyway we we chose to make it discrete

1520
00:59:48,350 --> 00:59:51,410
by adding delay capacitors so that the

1521
00:59:50,210 --> 00:59:52,670
latch would have time to settle and we

1522
00:59:51,410 --> 00:59:56,089
would be operating within the datasheet

1523
00:59:52,670 --> 00:59:57,710
and we did that wrong

1524
00:59:56,090 --> 01:00:00,080
so we should have been reasoning about

1525
00:59:57,710 --> 01:00:03,410
it in continuous time but we weren't and

1526
01:00:00,080 --> 01:00:05,000
that is how the bug happens and yes this

1527
01:00:03,410 --> 01:00:06,049
does totally play into the things that I

1528
01:00:05,000 --> 01:00:08,150
was just talking about if you're

1529
01:00:06,050 --> 01:00:10,190
reasoning about the wrong level of your

1530
01:00:08,150 --> 01:00:12,110
computation model then you won't find

1531
01:00:10,190 --> 01:00:13,520
bugs that are there we found all of the

1532
01:00:12,110 --> 01:00:15,830
bugs that were in the discrete

1533
01:00:13,520 --> 01:00:17,630
computation model but we didn't reason

1534
01:00:15,830 --> 01:00:19,460
about it in continuous time and so we

1535
01:00:17,630 --> 01:00:21,440
didn't find any of the bugs in the

1536
01:00:19,460 --> 01:00:23,690
continuous time model and that's really

1537
01:00:21,440 --> 01:00:25,540
also the same thing as the a2 malicious

1538
01:00:23,690 --> 01:00:28,910
heart analog malicious hardware Trojans

1539
01:00:25,540 --> 01:00:32,210
they reasoned about the x86 processor at

1540
01:00:28,910 --> 01:00:35,480
the VHDL level but they didn't really

1541
01:00:32,210 --> 01:00:36,830
reason about it at the compiled VHDL

1542
01:00:35,480 --> 01:00:38,930
level because you can't and that's

1543
01:00:36,830 --> 01:00:42,230
really why that paper is is so wonderful

1544
01:00:38,930 --> 01:00:44,680
um yes the answer is absolutely that's a

1545
01:00:42,230 --> 01:00:44,680
consideration

1546
01:00:46,920 --> 01:00:55,599
[Applause]

1547
01:01:00,320 --> 01:01:08,010
you want to go forward and use a parser

1548
01:01:04,010 --> 01:01:08,940
Combinator to generate yeah just reduce

1549
01:01:08,010 --> 01:01:10,589
the number of things that you have to

1550
01:01:08,940 --> 01:01:12,420
reason about the the question was is the

1551
01:01:10,589 --> 01:01:13,650
thesis the idea that you should use a

1552
01:01:12,420 --> 01:01:15,329
parser Combinator to generate your

1553
01:01:13,650 --> 01:01:16,980
descriptions thereby going forward and

1554
01:01:15,329 --> 01:01:19,619
up the abstraction model um

1555
01:01:16,980 --> 01:01:21,030
yes because you get to take advantage of

1556
01:01:19,619 --> 01:01:22,619
the fact that all the things that are

1557
01:01:21,030 --> 01:01:25,640
underneath it at the other computational

1558
01:01:22,619 --> 01:01:25,640
levels are also verified

