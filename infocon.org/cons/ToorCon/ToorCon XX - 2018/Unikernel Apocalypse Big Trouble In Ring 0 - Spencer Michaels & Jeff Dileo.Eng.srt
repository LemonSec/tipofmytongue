1
00:00:06,830 --> 00:00:13,610
all right next up we have Yoona Colonel

2
00:00:09,780 --> 00:00:17,869
apocalypse by Spencer Michaels and Jeff

3
00:00:13,610 --> 00:00:17,869
DeLeo please give him a warm welcome

4
00:00:18,650 --> 00:00:26,159
hi I'm Jeff and this is Spencer

5
00:00:23,640 --> 00:00:28,590
we work for NCC group we doing consider

6
00:00:26,160 --> 00:00:30,600
consulting and we're here to talk about

7
00:00:28,590 --> 00:00:33,030
some intern research that Spencer was

8
00:00:30,600 --> 00:00:37,920
doing last summer under my sort of

9
00:00:33,030 --> 00:00:38,940
auspices basically we first and foremost

10
00:00:37,920 --> 00:00:39,900
I'd like to mention that all

11
00:00:38,940 --> 00:00:43,110
vulnerabilities we're going to be

12
00:00:39,900 --> 00:00:46,680
discussing in this talk were disclosed

13
00:00:43,110 --> 00:00:49,430
prior last year and some have been fixed

14
00:00:46,680 --> 00:00:51,930
in some heaven for various reasons but

15
00:00:49,430 --> 00:00:54,590
we defined vulnerability here to be an

16
00:00:51,930 --> 00:00:57,450
issue that it may itself be exploited or

17
00:00:54,590 --> 00:00:58,920
any failing of any security protection

18
00:00:57,450 --> 00:01:01,410
or mechanism that was intended to be

19
00:00:58,920 --> 00:01:04,530
there so what are what are you Nicole's

20
00:01:01,410 --> 00:01:06,539
you know Colonel's are these specialized

21
00:01:04,530 --> 00:01:08,880
applications that bundle all of their

22
00:01:06,540 --> 00:01:11,340
application code and resources into a

23
00:01:08,880 --> 00:01:13,949
single binary that runs is a bare metal

24
00:01:11,340 --> 00:01:16,079
VM where the entire application stack

25
00:01:13,950 --> 00:01:18,749
runs in kernel space and what could go

26
00:01:16,079 --> 00:01:21,380
wrong they're intended as an alternative

27
00:01:18,749 --> 00:01:24,749
to sort of full VMS and Linux containers

28
00:01:21,380 --> 00:01:26,548
and so they the thing above them is the

29
00:01:24,749 --> 00:01:28,109
hypervisor where in containers the thing

30
00:01:26,549 --> 00:01:30,929
above them is the kernel and then maybe

31
00:01:28,109 --> 00:01:33,990
a hypervisor on top of that they have

32
00:01:30,929 --> 00:01:35,399
they reimplemented components so they

33
00:01:33,990 --> 00:01:37,109
tend to have their own network stacks

34
00:01:35,399 --> 00:01:38,849
written potentially from scratch in a

35
00:01:37,109 --> 00:01:40,559
different language than one might be

36
00:01:38,849 --> 00:01:42,689
accustomed to and they're very

37
00:01:40,560 --> 00:01:44,099
specialized and sometimes you can port

38
00:01:42,689 --> 00:01:46,859
code to them easily and sometimes you

39
00:01:44,099 --> 00:01:50,340
can't so why look at them basically

40
00:01:46,859 --> 00:01:51,689
there are very new technology and they

41
00:01:50,340 --> 00:01:53,429
might you know I don't think they're

42
00:01:51,689 --> 00:01:54,538
going to completely replace containers

43
00:01:53,429 --> 00:01:56,159
or anything like that but they

44
00:01:54,539 --> 00:01:59,639
definitely will probably find a niche

45
00:01:56,159 --> 00:02:02,369
that they fit well in and they're being

46
00:01:59,639 --> 00:02:04,289
looked seriously at by people to make

47
00:02:02,369 --> 00:02:06,149
things like cubes OS more secure and

48
00:02:04,289 --> 00:02:07,770
anything that people are doing to make

49
00:02:06,149 --> 00:02:09,959
cubes more secure is definitely worth

50
00:02:07,770 --> 00:02:11,430
looking at especially since some of the

51
00:02:09,959 --> 00:02:13,710
security claims from the people writing

52
00:02:11,430 --> 00:02:15,720
these things are really kind of don't

53
00:02:13,710 --> 00:02:17,800
make sense and don't add up and then

54
00:02:15,720 --> 00:02:20,710
there was this blog post by Brian

55
00:02:17,800 --> 00:02:22,240
control from Sun originally who wrote a

56
00:02:20,710 --> 00:02:23,680
blog post basically saying that eunuch

57
00:02:22,240 --> 00:02:25,570
Colonels were unfit for production

58
00:02:23,680 --> 00:02:27,970
because they were impossible to debug

59
00:02:25,570 --> 00:02:30,940
that last part was very prescient as

60
00:02:27,970 --> 00:02:33,400
well we'll find out so there are a lot

61
00:02:30,940 --> 00:02:35,410
of claimed security advantages to Yuna

62
00:02:33,400 --> 00:02:37,300
kernels things like there's no

63
00:02:35,410 --> 00:02:39,190
unnecessary code that you know if it's

64
00:02:37,300 --> 00:02:40,120
not used it's not compiled in because

65
00:02:39,190 --> 00:02:42,640
they link the whole thing together

66
00:02:40,120 --> 00:02:44,440
there's no shell so if somehow an

67
00:02:42,640 --> 00:02:45,940
attacker got remote code execution they

68
00:02:44,440 --> 00:02:48,070
wouldn't just be able to do Ben SH and

69
00:02:45,940 --> 00:02:49,660
they'd be just out of luck

70
00:02:48,070 --> 00:02:51,190
you know they can't they're not

71
00:02:49,660 --> 00:02:52,960
reconfigurable they're completely

72
00:02:51,190 --> 00:02:55,300
immutable if you want to change anything

73
00:02:52,960 --> 00:02:56,860
about them running you have to just

74
00:02:55,300 --> 00:02:58,750
rebuild the whole thing and reload it

75
00:02:56,860 --> 00:03:00,820
and that there are no sis calls only

76
00:02:58,750 --> 00:03:02,530
function calls so so therefore attackers

77
00:03:00,820 --> 00:03:04,870
need to know the memory layout to do

78
00:03:02,530 --> 00:03:06,940
anything so all of these are basically

79
00:03:04,870 --> 00:03:09,370
completely false on their head the

80
00:03:06,940 --> 00:03:11,079
unnecessary code thing even if they were

81
00:03:09,370 --> 00:03:13,330
talking about dead code optimizations

82
00:03:11,080 --> 00:03:14,680
that's not really true in general and

83
00:03:13,330 --> 00:03:16,240
there are a whole bunch of unit kernels

84
00:03:14,680 --> 00:03:18,010
that add in a whole bunch of modules of

85
00:03:16,240 --> 00:03:20,440
code that may or may not be used by the

86
00:03:18,010 --> 00:03:23,170
application code that sit there the

87
00:03:20,440 --> 00:03:24,430
shell doesn't matter binary level you

88
00:03:23,170 --> 00:03:25,630
know you can you can you should write

89
00:03:24,430 --> 00:03:27,610
shell code for things if you get a

90
00:03:25,630 --> 00:03:28,780
buffer overflow if not if you're in a

91
00:03:27,610 --> 00:03:31,540
higher level you know kernel save

92
00:03:28,780 --> 00:03:33,610
running nodejs and you get like an eval

93
00:03:31,540 --> 00:03:35,950
I'm fine running JavaScript if I need to

94
00:03:33,610 --> 00:03:38,890
you know so I'll do that instead of Ben

95
00:03:35,950 --> 00:03:40,839
SH the reconfiguration stuff will find

96
00:03:38,890 --> 00:03:43,059
out that you know kernels are very very

97
00:03:40,840 --> 00:03:44,680
not immutable and some of them even take

98
00:03:43,060 --> 00:03:47,200
like yeah mo configs on the fly or take

99
00:03:44,680 --> 00:03:50,230
binary uploads and just hot load them so

100
00:03:47,200 --> 00:03:52,030
that's just not true and this is calls

101
00:03:50,230 --> 00:03:55,179
thing it's that's just it just doesn't

102
00:03:52,030 --> 00:03:57,790
mean any it's just not even wrong so our

103
00:03:55,180 --> 00:04:00,430
hypothesis is that Yuna kernels may in

104
00:03:57,790 --> 00:04:02,410
fact reduce attack surface by throwing

105
00:04:00,430 --> 00:04:06,820
out a lot of you know the garbage system

106
00:04:02,410 --> 00:04:09,220
D but you know there's that that alone

107
00:04:06,820 --> 00:04:11,290
doesn't make things more secure the rest

108
00:04:09,220 --> 00:04:12,910
of it has to actually be secure too so

109
00:04:11,290 --> 00:04:15,070
once someone gets in though there's like

110
00:04:12,910 --> 00:04:17,200
no process isolation like you don't need

111
00:04:15,070 --> 00:04:19,450
route you are the kernel you can you can

112
00:04:17,200 --> 00:04:21,789
send you can craft arbitrary packets do

113
00:04:19,450 --> 00:04:24,640
disk IO speak PCI to whatever

114
00:04:21,790 --> 00:04:26,350
godforsaken floppy disk is emulated and

115
00:04:24,640 --> 00:04:29,680
given to your VM you know things like

116
00:04:26,350 --> 00:04:30,940
that so back we were doing this we

117
00:04:29,680 --> 00:04:31,720
started out looking at the low-level

118
00:04:30,940 --> 00:04:33,550
stuff with the

119
00:04:31,720 --> 00:04:35,740
intention to go higher and look at all

120
00:04:33,550 --> 00:04:37,300
of the re-implemented application stacks

121
00:04:35,740 --> 00:04:39,730
like networking stacks and things like

122
00:04:37,300 --> 00:04:41,770
that and we just kept finding things in

123
00:04:39,730 --> 00:04:44,140
the lower-level parts so so that's

124
00:04:41,770 --> 00:04:46,390
primarily what this talk is about so

125
00:04:44,140 --> 00:04:48,340
things like do these unit kernels do

126
00:04:46,390 --> 00:04:49,539
address space layout randomization which

127
00:04:48,340 --> 00:04:51,969
is a protection against code reuse

128
00:04:49,540 --> 00:04:54,190
attacks so which memory regions and

129
00:04:51,970 --> 00:04:56,470
sections have randomized base addresses

130
00:04:54,190 --> 00:04:58,719
do they have page protections things

131
00:04:56,470 --> 00:05:00,490
like DEP or an X that you might be

132
00:04:58,720 --> 00:05:02,170
familiar with so if the pages are

133
00:05:00,490 --> 00:05:04,720
read/write/execute that's probably bad

134
00:05:02,170 --> 00:05:06,810
weather or not relocation read-only or

135
00:05:04,720 --> 00:05:09,670
rel Rho applies in many cases it doesn't

136
00:05:06,810 --> 00:05:12,130
which is a protection on dynamic linking

137
00:05:09,670 --> 00:05:14,320
so that the sort of tables of function

138
00:05:12,130 --> 00:05:15,640
calls that your dynamically linking once

139
00:05:14,320 --> 00:05:17,320
they're loaded they're not going to be

140
00:05:15,640 --> 00:05:19,360
then writable as function pointers for

141
00:05:17,320 --> 00:05:21,010
as an exploit primitive whether or not

142
00:05:19,360 --> 00:05:23,200
their guard pages between the sections

143
00:05:21,010 --> 00:05:25,419
so those are gonna mean that you have a

144
00:05:23,200 --> 00:05:28,300
page or a section between your sections

145
00:05:25,419 --> 00:05:30,669
that is not read write execute at all

146
00:05:28,300 --> 00:05:32,470
and such like a continuous buffer

147
00:05:30,669 --> 00:05:34,359
overflow that goes straight into it

148
00:05:32,470 --> 00:05:35,919
would hit a page fault trap and the

149
00:05:34,360 --> 00:05:37,780
whole thing would die without letting

150
00:05:35,919 --> 00:05:39,159
the exploitation continue and then

151
00:05:37,780 --> 00:05:42,369
things like the null page being mapped

152
00:05:39,160 --> 00:05:44,320
so with the no page it's a bit different

153
00:05:42,370 --> 00:05:45,850
in you know kernel world in the normal

154
00:05:44,320 --> 00:05:48,180
world where people think of kernels and

155
00:05:45,850 --> 00:05:50,800
user space those attacks are about

156
00:05:48,180 --> 00:05:52,419
attacking the kernel from user space by

157
00:05:50,800 --> 00:05:54,070
doing shenanigans with a null page

158
00:05:52,419 --> 00:05:56,560
that's that's not we're talking about

159
00:05:54,070 --> 00:05:58,330
here so in the you know kernels if

160
00:05:56,560 --> 00:06:00,580
someone writes Linux tile

161
00:05:58,330 --> 00:06:02,260
malloc code and therefore doesn't check

162
00:06:00,580 --> 00:06:04,150
null because VM overcommit never what

163
00:06:02,260 --> 00:06:05,710
causes it to never return null it always

164
00:06:04,150 --> 00:06:07,419
returns essentially valid pointer and

165
00:06:05,710 --> 00:06:09,219
when you run out of memory the om killer

166
00:06:07,419 --> 00:06:11,650
just kills your process so they never

167
00:06:09,220 --> 00:06:12,940
check null but in embedded sort of

168
00:06:11,650 --> 00:06:15,789
systems and things like you know kernels

169
00:06:12,940 --> 00:06:17,740
it can return though but no it may very

170
00:06:15,790 --> 00:06:20,410
well be a valid writable readable

171
00:06:17,740 --> 00:06:22,720
address and so if no one's checking know

172
00:06:20,410 --> 00:06:24,370
when malloc returns and multiple things

173
00:06:22,720 --> 00:06:26,110
use allocations from malloc that

174
00:06:24,370 --> 00:06:27,700
returned null they're now sharing the

175
00:06:26,110 --> 00:06:30,250
same section of memory and it's

176
00:06:27,700 --> 00:06:31,090
essentially used after free so that's

177
00:06:30,250 --> 00:06:33,190
interesting

178
00:06:31,090 --> 00:06:34,840
stack Canaries are they used are they

179
00:06:33,190 --> 00:06:36,370
gonna be initialized directly are they

180
00:06:34,840 --> 00:06:38,049
gonna be filled with proper random data

181
00:06:36,370 --> 00:06:40,289
keep pardoning is there pointer

182
00:06:38,050 --> 00:06:42,910
validation is there good entropy for it

183
00:06:40,289 --> 00:06:45,130
are the allocations randomized the

184
00:06:42,910 --> 00:06:45,520
Canaries are they good where does the

185
00:06:45,130 --> 00:06:47,319
entropy

186
00:06:45,520 --> 00:06:49,628
come from is a good entropy is the RNG

187
00:06:47,319 --> 00:06:51,310
itself cryptographically secure

188
00:06:49,629 --> 00:06:53,530
is there any reuse of things in

189
00:06:51,310 --> 00:06:55,449
deterministic ways that are going to be

190
00:06:53,530 --> 00:06:58,780
bad across multiple VMs on the same

191
00:06:55,449 --> 00:07:00,370
hypervisor and standard library

192
00:06:58,780 --> 00:07:03,309
hardening things like your percent and

193
00:07:00,370 --> 00:07:05,409
format specifier custom format

194
00:07:03,310 --> 00:07:07,930
specifiers for format strings may lead

195
00:07:05,409 --> 00:07:08,949
to insecure implementations in the Lib C

196
00:07:07,930 --> 00:07:10,389
itself where there's like write a

197
00:07:08,949 --> 00:07:12,250
section of writable memory that just

198
00:07:10,389 --> 00:07:14,409
contains nothing but function pointers

199
00:07:12,250 --> 00:07:16,090
or even potentially code and whether or

200
00:07:14,409 --> 00:07:19,960
not they support or even use fortify

201
00:07:16,090 --> 00:07:22,388
source so our first target was rump run

202
00:07:19,960 --> 00:07:23,680
it is an interesting research target and

203
00:07:22,389 --> 00:07:25,870
it's fairly well known you know kernel

204
00:07:23,680 --> 00:07:28,389
in that circle and it's based on net BS

205
00:07:25,870 --> 00:07:30,669
t's rump kernels which were designed

206
00:07:28,389 --> 00:07:32,560
back in the day so that when you were

207
00:07:30,669 --> 00:07:34,030
writing your kernel drivers and they

208
00:07:32,560 --> 00:07:35,889
crashed they didn't just take out your

209
00:07:34,030 --> 00:07:37,929
system because there were really VMs at

210
00:07:35,889 --> 00:07:40,360
the time that were in use so what they

211
00:07:37,930 --> 00:07:40,750
would do is they had a very sponge of if

212
00:07:40,360 --> 00:07:42,490
deafs

213
00:07:40,750 --> 00:07:44,259
all throughout the net bsd kernel code

214
00:07:42,490 --> 00:07:45,940
base and they still do that allow you to

215
00:07:44,259 --> 00:07:48,729
essentially take the entire kernel of

216
00:07:45,940 --> 00:07:50,380
net bsd and link it against some kernel

217
00:07:48,729 --> 00:07:53,318
driver code or application level code

218
00:07:50,380 --> 00:07:55,060
and run it in user space as a standard

219
00:07:53,319 --> 00:07:57,610
binary so when that thing crashes your

220
00:07:55,060 --> 00:07:59,590
whole system doesn't go with it rump run

221
00:07:57,610 --> 00:08:01,719
flip this on its head took all that

222
00:07:59,590 --> 00:08:03,789
magic linking in if def magic and then

223
00:08:01,719 --> 00:08:06,460
threw it back into kernel space to run

224
00:08:03,789 --> 00:08:09,550
POSIX applications in in you know kernel

225
00:08:06,460 --> 00:08:12,310
space our next target

226
00:08:09,550 --> 00:08:13,930
always include us it wasn't originally

227
00:08:12,310 --> 00:08:15,849
our next target but while we were doing

228
00:08:13,930 --> 00:08:17,650
this a blog post came out claiming that

229
00:08:15,849 --> 00:08:20,289
they were the most secure thing ever and

230
00:08:17,650 --> 00:08:22,750
it was written in C++ and those two

231
00:08:20,289 --> 00:08:25,330
things didn't necessarily add up so we

232
00:08:22,750 --> 00:08:28,300
decided that we would look at it and

233
00:08:25,330 --> 00:08:31,870
then miraj OS fairly well-known in the

234
00:08:28,300 --> 00:08:34,390
circle and anyone who uses cubes is an

235
00:08:31,870 --> 00:08:36,279
eunuch kernel that is primarily used for

236
00:08:34,390 --> 00:08:38,439
writing Oh camel so that you can write

237
00:08:36,279 --> 00:08:40,838
secure services you know camel since its

238
00:08:38,440 --> 00:08:43,390
type safe and memory safe for the most

239
00:08:40,839 --> 00:08:44,410
part but it also has a CF Fi and some of

240
00:08:43,390 --> 00:08:46,360
those components are written in

241
00:08:44,410 --> 00:08:48,310
low-level code so they need to be secure

242
00:08:46,360 --> 00:08:50,589
as well so we looked at how that was

243
00:08:48,310 --> 00:08:52,239
being protected and then the the next

244
00:08:50,589 --> 00:08:53,470
target that we have which is actually

245
00:08:52,240 --> 00:08:56,949
next on the list and we haven't gotten

246
00:08:53,470 --> 00:08:58,990
to it yet is OS V which is a unit kernel

247
00:08:56,949 --> 00:08:59,740
focused on high performance but also

248
00:08:58,990 --> 00:09:02,170
other

249
00:08:59,740 --> 00:09:05,830
things like being able to run the entire

250
00:09:02,170 --> 00:09:07,540
JVM in ring zero so you can have your

251
00:09:05,830 --> 00:09:09,550
vulnerable Java Enterprise web

252
00:09:07,540 --> 00:09:11,439
applications running in kernel space you

253
00:09:09,550 --> 00:09:12,969
know XSS and kernel space sequel

254
00:09:11,440 --> 00:09:15,790
injection kernel space the world is your

255
00:09:12,970 --> 00:09:18,580
oyster and so we're gonna be looking at

256
00:09:15,790 --> 00:09:20,890
that soon enough so I'll hand it over to

257
00:09:18,580 --> 00:09:23,310
Spencer okay so let's get into the gory

258
00:09:20,890 --> 00:09:25,449
details and gory indeed they are so

259
00:09:23,310 --> 00:09:28,390
we'll start with rump run which is a

260
00:09:25,450 --> 00:09:29,620
64-bit yoona kernel it runs on KVM and

261
00:09:28,390 --> 00:09:31,689
Xen as well as bare metal

262
00:09:29,620 --> 00:09:33,400
we tested on Xen because that's mostly

263
00:09:31,690 --> 00:09:35,920
where people are running this so

264
00:09:33,400 --> 00:09:37,569
Rembrandt has a POSIX interface with the

265
00:09:35,920 --> 00:09:40,060
exception of threads and a few other

266
00:09:37,570 --> 00:09:42,100
small things so basically you can run

267
00:09:40,060 --> 00:09:43,920
most POSIX compliant apps with very

268
00:09:42,100 --> 00:09:45,730
little modification sometimes none

269
00:09:43,920 --> 00:09:47,560
supports all these languages

270
00:09:45,730 --> 00:09:49,180
interestingly it also comes with a

271
00:09:47,560 --> 00:09:51,449
separate repository of a bunch of

272
00:09:49,180 --> 00:09:53,530
packages like Apache and nginx that

273
00:09:51,450 --> 00:09:54,910
basically just build on out of the box

274
00:09:53,530 --> 00:09:56,740
on run they've done this weeks already

275
00:09:54,910 --> 00:09:58,630
but these look sort of like POCs it

276
00:09:56,740 --> 00:10:00,220
doesn't seem like they're updated I'll

277
00:09:58,630 --> 00:10:01,570
get to that in a bit

278
00:10:00,220 --> 00:10:03,100
basically the wave are imprint is

279
00:10:01,570 --> 00:10:05,080
constructed is as Jeff said it's just

280
00:10:03,100 --> 00:10:07,180
like the the net bsd kernel and they

281
00:10:05,080 --> 00:10:10,600
strap that on top of Xen mini OS which

282
00:10:07,180 --> 00:10:11,680
is an operating system that it's very

283
00:10:10,600 --> 00:10:12,910
minimal it basically just does

284
00:10:11,680 --> 00:10:14,349
everything by making calls to the

285
00:10:12,910 --> 00:10:16,480
hypervisor so if you want to make a para

286
00:10:14,350 --> 00:10:18,070
virtualized guest on Xen your best bet

287
00:10:16,480 --> 00:10:21,280
is usually to just build it on top of

288
00:10:18,070 --> 00:10:24,460
mini OS so rump run doesn't have any a

289
00:10:21,280 --> 00:10:26,199
SLR it saved a little bit by LD which

290
00:10:24,460 --> 00:10:28,720
we've taken here to calling the poor

291
00:10:26,200 --> 00:10:29,920
man's a SLR basically what that means is

292
00:10:28,720 --> 00:10:31,510
if you're linking in slightly different

293
00:10:29,920 --> 00:10:33,189
code or like if you know you make a

294
00:10:31,510 --> 00:10:35,080
function slightly longer it's gonna push

295
00:10:33,190 --> 00:10:37,060
stuff down or LTS gonna put stuff in

296
00:10:35,080 --> 00:10:38,500
different places so like if you don't

297
00:10:37,060 --> 00:10:40,060
know the underlying code of a binary

298
00:10:38,500 --> 00:10:41,590
then you don't know exactly where

299
00:10:40,060 --> 00:10:44,170
everything is but you can often make a

300
00:10:41,590 --> 00:10:45,220
reasonably decent guess and if you know

301
00:10:44,170 --> 00:10:47,260
the code of course it's all

302
00:10:45,220 --> 00:10:48,400
deterministic what's interesting too is

303
00:10:47,260 --> 00:10:51,010
because this is running as a pair of

304
00:10:48,400 --> 00:10:54,130
virtualized guest Xen maps the hyper

305
00:10:51,010 --> 00:10:56,620
call page into the very very early on in

306
00:10:54,130 --> 00:10:59,170
the memory space so it turns out you may

307
00:10:56,620 --> 00:11:00,400
even be able to use that to do Rob but

308
00:10:59,170 --> 00:11:01,660
it seems like there may not be enough

309
00:11:00,400 --> 00:11:02,709
primitives we just found that recently

310
00:11:01,660 --> 00:11:06,100
we're not actually sure of the full

311
00:11:02,710 --> 00:11:08,590
impact it doesn't really have any extra

312
00:11:06,100 --> 00:11:10,060
page protections the tech tech section

313
00:11:08,590 --> 00:11:13,720
is not writable but data stack and heap

314
00:11:10,060 --> 00:11:16,149
are all rwx there's a little bit

315
00:11:13,720 --> 00:11:18,279
of protection that the null page is not

316
00:11:16,149 --> 00:11:20,050
our WRX but there are also no guard

317
00:11:18,279 --> 00:11:21,550
pages so you know you can just say Stack

318
00:11:20,050 --> 00:11:23,560
Overflow into the heap or something like

319
00:11:21,550 --> 00:11:26,019
that

320
00:11:23,560 --> 00:11:27,729
there are stack Canaries only in a very

321
00:11:26,019 --> 00:11:30,670
sort of edge case if you happen to get

322
00:11:27,730 --> 00:11:32,560
lucky so the core make files of rump run

323
00:11:30,670 --> 00:11:34,420
actually disable it so like rump run

324
00:11:32,560 --> 00:11:37,449
itself is never gonna have stack

325
00:11:34,420 --> 00:11:38,920
Canaries if your compiler happens to

326
00:11:37,449 --> 00:11:40,540
turn them on by default in your

327
00:11:38,920 --> 00:11:42,310
application code that's built separately

328
00:11:40,540 --> 00:11:46,000
and then linked in so your application

329
00:11:42,310 --> 00:11:48,579
code might have it now the random canary

330
00:11:46,000 --> 00:11:51,670
value is generated at runtime properly

331
00:11:48,579 --> 00:11:53,739
using the bsd sysctl crypto api's but it

332
00:11:51,670 --> 00:11:54,969
turns out that because rump run doesn't

333
00:11:53,740 --> 00:11:56,470
have thread support they didn't

334
00:11:54,970 --> 00:12:00,850
implement thread-local storage of course

335
00:11:56,470 --> 00:12:02,019
and GCC expects the canary to be stored

336
00:12:00,850 --> 00:12:04,000
in and retrieved from thread local

337
00:12:02,019 --> 00:12:05,290
storage so it turns out that the canary

338
00:12:04,000 --> 00:12:07,480
even though it's generated correctly it

339
00:12:05,290 --> 00:12:09,009
turns out to be no in practice it's just

340
00:12:07,480 --> 00:12:10,750
eight no bytes on the other hand if you

341
00:12:09,009 --> 00:12:11,949
have up to eight store copies that will

342
00:12:10,750 --> 00:12:14,860
save you from that but anything else

343
00:12:11,949 --> 00:12:16,689
you're on your own the heat protections

344
00:12:14,860 --> 00:12:18,309
are pretty negligible the allocations

345
00:12:16,689 --> 00:12:19,779
are deterministic and contiguous and

346
00:12:18,309 --> 00:12:22,899
there's no pointer validation of any

347
00:12:19,779 --> 00:12:25,689
kind there are Canaries in the heap and

348
00:12:22,899 --> 00:12:27,730
page chunks but they are a compiler

349
00:12:25,689 --> 00:12:29,529
defines and B they're not even

350
00:12:27,730 --> 00:12:31,689
positioned correctly in in in the one

351
00:12:29,529 --> 00:12:34,180
case where where it actually has a null

352
00:12:31,689 --> 00:12:35,349
byte in that define so essentially

353
00:12:34,180 --> 00:12:36,008
they're completely useless if you want

354
00:12:35,350 --> 00:12:37,240
to exploit them

355
00:12:36,009 --> 00:12:44,559
Jeff will talk about the entropy

356
00:12:37,240 --> 00:12:46,569
situation stares right so rump run and

357
00:12:44,559 --> 00:12:47,769
the ROM kernels have an interesting

358
00:12:46,569 --> 00:12:50,229
system where they have a whole bunch of

359
00:12:47,769 --> 00:12:52,449
if deafs and for some reason when you're

360
00:12:50,230 --> 00:12:54,490
building rump kernels the if deafs

361
00:12:52,449 --> 00:12:57,459
basically mean that your are dear and

362
00:12:54,490 --> 00:12:59,439
your cpu rng is disabled even though

363
00:12:57,459 --> 00:13:00,699
that's not a privileged instruction they

364
00:12:59,439 --> 00:13:05,500
could totally could have run that as a

365
00:13:00,699 --> 00:13:07,300
user space binary so rump kernels rump

366
00:13:05,500 --> 00:13:09,579
run using the same if Deaf's

367
00:13:07,300 --> 00:13:12,219
suffers from the same flaw it basically

368
00:13:09,579 --> 00:13:13,870
has no cpu and our cpu rng so it

369
00:13:12,220 --> 00:13:16,149
completely falls back to the vm uptime

370
00:13:13,870 --> 00:13:17,769
and cpu cycle count which are so

371
00:13:16,149 --> 00:13:20,259
deterministic and how this thing starts

372
00:13:17,769 --> 00:13:22,630
up that essentially at start every time

373
00:13:20,259 --> 00:13:24,880
you are getting the same exact random

374
00:13:22,630 --> 00:13:26,410
values out of dev you random which is

375
00:13:24,880 --> 00:13:27,130
spooky

376
00:13:26,410 --> 00:13:29,949
it's

377
00:13:27,130 --> 00:13:31,570
a little bit by the fact that net BST is

378
00:13:29,950 --> 00:13:33,520
sort of complicated has all sorts of

379
00:13:31,570 --> 00:13:35,350
other entropy sources so anything that

380
00:13:33,520 --> 00:13:37,240
you printf which I'm not sure why you

381
00:13:35,350 --> 00:13:39,580
would do on a unit kernel running on AWS

382
00:13:37,240 --> 00:13:41,740
but if you printf something that output

383
00:13:39,580 --> 00:13:43,780
will feed into the entropy system Mac

384
00:13:41,740 --> 00:13:46,120
headers from packets that the system

385
00:13:43,780 --> 00:13:47,920
sees will get added in although those

386
00:13:46,120 --> 00:13:49,510
are probably gonna be you know pretty

387
00:13:47,920 --> 00:13:51,729
much the same values back and forth on a

388
00:13:49,510 --> 00:13:53,740
sub on a given subject between the the

389
00:13:51,730 --> 00:13:56,200
you know kernel host and the Gateway and

390
00:13:53,740 --> 00:13:58,360
then the host uptime which is also known

391
00:13:56,200 --> 00:14:00,790
to all guests on the same hypervisor the

392
00:13:58,360 --> 00:14:03,850
RMG itself is this sort of weird sha-1

393
00:14:00,790 --> 00:14:06,069
thing that actually has a whole bunch of

394
00:14:03,850 --> 00:14:07,720
code in a code comments saying that it

395
00:14:06,070 --> 00:14:09,460
hasn't actually been like audited or

396
00:14:07,720 --> 00:14:11,860
anything so that's we haven't looked at

397
00:14:09,460 --> 00:14:13,510
that but this is all access to the

398
00:14:11,860 --> 00:14:15,340
standard and fbst ways of doing it so

399
00:14:13,510 --> 00:14:18,610
the bsd sysctl syscalls

400
00:14:15,340 --> 00:14:20,170
and also the virtual file system sets up

401
00:14:18,610 --> 00:14:23,860
dev random and Devi random correctly for

402
00:14:20,170 --> 00:14:26,349
all of this okay so the center of the

403
00:14:23,860 --> 00:14:28,780
library is implemented with BSD from our

404
00:14:26,350 --> 00:14:30,250
sorry with Lib C from net BSD um and

405
00:14:28,780 --> 00:14:32,920
that supports percent and doesn't

406
00:14:30,250 --> 00:14:34,600
support custom format specifiers it does

407
00:14:32,920 --> 00:14:36,610
support fortify source and actually the

408
00:14:34,600 --> 00:14:38,230
net BSD like core make files will turn

409
00:14:36,610 --> 00:14:39,610
that on to the highest level but then

410
00:14:38,230 --> 00:14:41,380
the top level run pro and make files

411
00:14:39,610 --> 00:14:43,570
will turn that off again for debug

412
00:14:41,380 --> 00:14:45,370
builds and it turns out if you use the

413
00:14:43,570 --> 00:14:47,740
like rump run build tool chain and

414
00:14:45,370 --> 00:14:49,810
scripts it will always give you debug

415
00:14:47,740 --> 00:14:51,430
builds and there's no flag to disable

416
00:14:49,810 --> 00:14:52,900
and it just sort of does that silently

417
00:14:51,430 --> 00:14:54,130
so if you if the average person is

418
00:14:52,900 --> 00:14:57,939
building a rump on this is gonna be the

419
00:14:54,130 --> 00:14:59,290
case it also has sis calls almost so

420
00:14:57,940 --> 00:15:01,150
they're not triggered by an interrupt

421
00:14:59,290 --> 00:15:02,860
but there's a function called rump sis

422
00:15:01,150 --> 00:15:04,270
call which you I mean basically acts

423
00:15:02,860 --> 00:15:06,760
just like the regular sis call function

424
00:15:04,270 --> 00:15:08,770
arguments and all and the first 24 bytes

425
00:15:06,760 --> 00:15:10,300
of it when we looked at it and all the

426
00:15:08,770 --> 00:15:12,699
run burn unit kernels we generated are

427
00:15:10,300 --> 00:15:14,349
unique so you can scan for this very

428
00:15:12,700 --> 00:15:15,760
trivially as soon as you get RC and then

429
00:15:14,350 --> 00:15:18,700
just fire off as many sis calls as you

430
00:15:15,760 --> 00:15:20,319
want in addition to that to get initial

431
00:15:18,700 --> 00:15:21,700
RCE the sis call table is a really good

432
00:15:20,320 --> 00:15:23,410
target because it is populated

433
00:15:21,700 --> 00:15:27,100
dynamically on startup and then it's

434
00:15:23,410 --> 00:15:28,959
left in a writable state in addition of

435
00:15:27,100 --> 00:15:30,760
this rump run basically the build tool

436
00:15:28,960 --> 00:15:33,070
chain takes a sort of image config that

437
00:15:30,760 --> 00:15:36,189
tells it what libraries to link into

438
00:15:33,070 --> 00:15:39,160
your final unit kernel and the default

439
00:15:36,190 --> 00:15:40,390
is about twice as many modules as we

440
00:15:39,160 --> 00:15:40,719
could get it to build with

441
00:15:40,390 --> 00:15:41,740
so

442
00:15:40,720 --> 00:15:43,990
they're talking about like reduced

443
00:15:41,740 --> 00:15:47,769
attack surface they don't emphasize that

444
00:15:43,990 --> 00:15:49,720
you need to prune this config down so

445
00:15:47,769 --> 00:15:51,310
reference heap implementation is is kind

446
00:15:49,720 --> 00:15:53,529
of interesting they have a basically

447
00:15:51,310 --> 00:15:55,029
it's it there are two major primitives

448
00:15:53,529 --> 00:15:56,560
which is a memo like chunk and a page

449
00:15:55,029 --> 00:15:58,420
chunk the men mallet chunk basically

450
00:15:56,560 --> 00:16:00,069
represents the chunk of memory you get

451
00:15:58,420 --> 00:16:02,199
back when you actually malloc something

452
00:16:00,069 --> 00:16:04,750
and that the two important fields who

453
00:16:02,199 --> 00:16:06,639
are aligned pad and magic magic is the

454
00:16:04,750 --> 00:16:09,009
canary and you'll notice above it's

455
00:16:06,639 --> 00:16:11,470
unprotected is a line pad and what that

456
00:16:09,009 --> 00:16:13,329
does basically it's the amount you have

457
00:16:11,470 --> 00:16:15,250
to subtract from the base pointer to the

458
00:16:13,329 --> 00:16:18,128
memo Alec chunk to get up to the page

459
00:16:15,250 --> 00:16:20,889
chunk above it and the page chunk has

460
00:16:18,129 --> 00:16:23,379
level which is just like a metadata you

461
00:16:20,889 --> 00:16:25,360
can very easily guess and magic which is

462
00:16:23,379 --> 00:16:28,029
a canary but it's four bytes that are

463
00:16:25,360 --> 00:16:29,529
not null so you can and it's in a

464
00:16:28,029 --> 00:16:31,810
compiler defined so it basically doesn't

465
00:16:29,529 --> 00:16:33,220
exist and the next in previous you can

466
00:16:31,810 --> 00:16:35,829
use that to perform the classic on link

467
00:16:33,220 --> 00:16:37,120
bug there's a lot of details about this

468
00:16:35,829 --> 00:16:38,349
if you're interested to look at the

469
00:16:37,120 --> 00:16:40,000
slides but we're not gonna reiterate

470
00:16:38,350 --> 00:16:41,259
like all of malok malefic arm here

471
00:16:40,000 --> 00:16:44,620
because it's basically just classic on

472
00:16:41,259 --> 00:16:45,790
link so if you want to exploit the rump

473
00:16:44,620 --> 00:16:48,370
run heap but basically what you have to

474
00:16:45,790 --> 00:16:50,199
do is get an overflow in a heap chunk

475
00:16:48,370 --> 00:16:52,029
onto another heap junk that'll later be

476
00:16:50,199 --> 00:16:53,559
freed and you just need to overwrite the

477
00:16:52,029 --> 00:16:56,079
first eight bytes the mhm align pad

478
00:16:53,559 --> 00:16:57,399
field such that when it's when that

479
00:16:56,079 --> 00:16:58,660
value is subtracted from the base

480
00:16:57,399 --> 00:17:02,620
pointer of that chunk that you are now

481
00:16:58,660 --> 00:17:04,990
corrupting it points back to a fake page

482
00:17:02,620 --> 00:17:06,730
chunk in your overflow buffer that

483
00:17:04,990 --> 00:17:08,049
you've written out and make sure level

484
00:17:06,730 --> 00:17:09,490
and magic check out that's really easy

485
00:17:08,049 --> 00:17:11,139
and then just set the next in the

486
00:17:09,490 --> 00:17:13,750
previous pointers however you want to do

487
00:17:11,140 --> 00:17:15,669
a write there is a caveat of course with

488
00:17:13,750 --> 00:17:17,439
this kind of exploit that the value that

489
00:17:15,669 --> 00:17:18,880
you're writing must itself be a writable

490
00:17:17,439 --> 00:17:21,520
address otherwise it's going to cause a

491
00:17:18,880 --> 00:17:23,230
crash on the second right although you

492
00:17:21,520 --> 00:17:26,740
may want that actually as we'll show in

493
00:17:23,230 --> 00:17:28,510
a little bit so basically rump runs

494
00:17:26,740 --> 00:17:29,530
security situation is not good there's

495
00:17:28,510 --> 00:17:31,900
no SLR

496
00:17:29,530 --> 00:17:35,530
everything but text and null page are

497
00:17:31,900 --> 00:17:36,850
rwx the canary situation generally

498
00:17:35,530 --> 00:17:38,649
speaking they're not going to be any and

499
00:17:36,850 --> 00:17:41,110
if there are they're pretty useless the

500
00:17:38,650 --> 00:17:42,700
heap is not really protected there are

501
00:17:41,110 --> 00:17:44,979
Canaries but they don't do anything

502
00:17:42,700 --> 00:17:46,179
in practice the entropy situation is

503
00:17:44,980 --> 00:17:47,919
also weakened particularly if you're

504
00:17:46,179 --> 00:17:49,899
attacking from another hypervisor guest

505
00:17:47,919 --> 00:17:52,600
and while a standard library supports

506
00:17:49,899 --> 00:17:54,020
hardening it's explicitly disabled and

507
00:17:52,600 --> 00:17:57,709
you may be thinking

508
00:17:54,020 --> 00:18:00,050
well here he overflows basically in rump

509
00:17:57,710 --> 00:18:01,790
run they will give you our RCE

510
00:18:00,050 --> 00:18:03,740
under pretty much any circumstance

511
00:18:01,790 --> 00:18:06,320
especially if the attacker has a source

512
00:18:03,740 --> 00:18:07,700
code or binary but sometimes even in

513
00:18:06,320 --> 00:18:09,439
cases where you don't because you could

514
00:18:07,700 --> 00:18:12,980
attempt to brute-force the addresses you

515
00:18:09,440 --> 00:18:14,120
need because while they are not you

516
00:18:12,980 --> 00:18:15,860
won't necessarily know where they are

517
00:18:14,120 --> 00:18:17,330
they're not random you basically like if

518
00:18:15,860 --> 00:18:18,949
you know roughly what's what's in the

519
00:18:17,330 --> 00:18:22,100
rump run image you can guess pretty well

520
00:18:18,950 --> 00:18:23,840
where they are and by the way varmints

521
00:18:22,100 --> 00:18:24,919
also completely unmaintained as of just

522
00:18:23,840 --> 00:18:27,800
a little before we started researching

523
00:18:24,920 --> 00:18:29,360
it last summer basically right now they

524
00:18:27,800 --> 00:18:32,240
only updated every few months to like

525
00:18:29,360 --> 00:18:33,740
add compiler flags to disable new GCC

526
00:18:32,240 --> 00:18:35,570
defaults that would make it more secure

527
00:18:33,740 --> 00:18:38,960
but actually break the old run code so

528
00:18:35,570 --> 00:18:41,270
that's interesting and at this point you

529
00:18:38,960 --> 00:18:43,460
may be thinking well what could possibly

530
00:18:41,270 --> 00:18:46,129
be worse than what I've just said and to

531
00:18:43,460 --> 00:18:48,890
this include us says hold my beer so

532
00:18:46,130 --> 00:18:50,450
include us as a 64-bit yoona kernel that

533
00:18:48,890 --> 00:18:53,570
unlike run front is pretty specialized

534
00:18:50,450 --> 00:18:55,760
it's exclusively for C++ services

535
00:18:53,570 --> 00:18:59,090
particularly web services

536
00:18:55,760 --> 00:19:00,650
it runs on KVM and VirtualBox and vmware

537
00:18:59,090 --> 00:19:05,209
but it's primarily developed for and

538
00:19:00,650 --> 00:19:07,580
tested on linux KBM now it's worth

539
00:19:05,210 --> 00:19:10,550
noting here before I go into saying all

540
00:19:07,580 --> 00:19:13,669
I'm going to that include us the version

541
00:19:10,550 --> 00:19:16,010
we looked at is from summer of 2017 so

542
00:19:13,670 --> 00:19:17,450
they have likely fixed some of the stuff

543
00:19:16,010 --> 00:19:18,950
we're talking about given that it's

544
00:19:17,450 --> 00:19:20,330
actually maintained it's probably more

545
00:19:18,950 --> 00:19:22,970
secure than run run at this point but we

546
00:19:20,330 --> 00:19:24,139
haven't actually gone back to check but

547
00:19:22,970 --> 00:19:25,340
before I talk about what I found in

548
00:19:24,140 --> 00:19:26,900
Rumford let me explain a little bit

549
00:19:25,340 --> 00:19:28,429
about how I actually found it because it

550
00:19:26,900 --> 00:19:31,000
turns out that debugging in include us

551
00:19:28,430 --> 00:19:35,030
is like really really really difficult

552
00:19:31,000 --> 00:19:36,890
in fact I suspect that the include us

553
00:19:35,030 --> 00:19:39,139
developers probably have not ever tested

554
00:19:36,890 --> 00:19:40,640
include us running as a yuna kernel be a

555
00:19:39,140 --> 00:19:42,170
rather debugged include us running as a

556
00:19:40,640 --> 00:19:43,700
yuna kernel because it turns out the

557
00:19:42,170 --> 00:19:45,890
boot script they used to do that doesn't

558
00:19:43,700 --> 00:19:47,780
even have a flag to enable the gdb debug

559
00:19:45,890 --> 00:19:48,860
bridge it's trivial to add but the fact

560
00:19:47,780 --> 00:19:52,160
that it wasn't in there is kind of

561
00:19:48,860 --> 00:19:54,020
suspicious if you compiled binaries with

562
00:19:52,160 --> 00:19:55,100
debug symbols and then actually run them

563
00:19:54,020 --> 00:19:57,260
as include I'll see under kernels

564
00:19:55,100 --> 00:19:58,760
they'll just crash on startup most of

565
00:19:57,260 --> 00:20:00,680
the time and we figured out a way around

566
00:19:58,760 --> 00:20:02,990
this which is like if you run the non

567
00:20:00,680 --> 00:20:05,120
symbols version and then attach gdb and

568
00:20:02,990 --> 00:20:07,190
then load symbols from the symbol

569
00:20:05,120 --> 00:20:07,939
version it actually doesn't work either

570
00:20:07,190 --> 00:20:10,220
most

571
00:20:07,940 --> 00:20:11,960
the time generally it'll die with a CRC

572
00:20:10,220 --> 00:20:14,090
mismatch error and we don't even want to

573
00:20:11,960 --> 00:20:15,620
speculate what what causes this if you

574
00:20:14,090 --> 00:20:17,689
manage to get past this which again just

575
00:20:15,620 --> 00:20:19,428
happens sort of randomly breakpoints

576
00:20:17,690 --> 00:20:21,200
also don't really work you usually have

577
00:20:19,429 --> 00:20:23,029
to just start the guest paused and then

578
00:20:21,200 --> 00:20:24,559
like insert jump zero instructions and

579
00:20:23,029 --> 00:20:26,450
then manually put the original bytes

580
00:20:24,559 --> 00:20:30,320
back when you're ready to continue it's

581
00:20:26,450 --> 00:20:31,789
not good so having gone all through this

582
00:20:30,320 --> 00:20:33,470
rigmarole we find that include us

583
00:20:31,789 --> 00:20:35,330
basically the ASL our situation is

584
00:20:33,470 --> 00:20:36,649
exactly the same as from from but what

585
00:20:35,330 --> 00:20:38,600
makes us more embarrassing for them is

586
00:20:36,649 --> 00:20:41,719
that in that include include haces

587
00:20:38,600 --> 00:20:43,759
secure blog post the CEO mentioned that

588
00:20:41,720 --> 00:20:45,320
include ah scrote randomizes address at

589
00:20:43,759 --> 00:20:47,629
each build and it seems like he's just

590
00:20:45,320 --> 00:20:49,519
confusing the linker with like the

591
00:20:47,629 --> 00:20:50,990
normal linker behavior with compile time

592
00:20:49,519 --> 00:20:54,350
a SLR which include us definitely

593
00:20:50,990 --> 00:20:56,570
doesn't have um he also says it include

594
00:20:54,350 --> 00:20:58,580
us is immutable it's it's not it's like

595
00:20:56,570 --> 00:21:00,620
the most mutable anything can possibly

596
00:20:58,580 --> 00:21:04,879
be because every single page of include

597
00:21:00,620 --> 00:21:06,469
us is rwx so you can I mean literally we

598
00:21:04,879 --> 00:21:08,509
actually we didn't have a full POC for

599
00:21:06,470 --> 00:21:11,059
this but we got far enough to realize

600
00:21:08,509 --> 00:21:13,580
that you could probably like inject your

601
00:21:11,059 --> 00:21:16,158
own tcp/ip stack and then like load a

602
00:21:13,580 --> 00:21:17,629
new include ass image on top like into

603
00:21:16,159 --> 00:21:20,960
an existing include us and then start

604
00:21:17,629 --> 00:21:22,340
running that it's pretty terrible as you

605
00:21:20,960 --> 00:21:24,559
can probably expect there are no

606
00:21:22,340 --> 00:21:25,970
additional page protections either there

607
00:21:24,559 --> 00:21:28,309
are no guard pages and even the null

608
00:21:25,970 --> 00:21:29,539
page is mapped rwx you get the use after

609
00:21:28,309 --> 00:21:32,690
free sort of thing that Jeff was

610
00:21:29,539 --> 00:21:35,179
mentioning the snap canary is they're

611
00:21:32,690 --> 00:21:36,889
certainly more prevalent than in in in

612
00:21:35,179 --> 00:21:39,320
rump run but it's not particularly

613
00:21:36,889 --> 00:21:41,928
helpful so they use f protectors F stack

614
00:21:39,320 --> 00:21:44,029
protect are strong in the core kernel

615
00:21:41,929 --> 00:21:45,860
and also they like application preamble

616
00:21:44,029 --> 00:21:46,610
C make files so everything's gonna have

617
00:21:45,860 --> 00:21:48,769
stack Canaries

618
00:21:46,610 --> 00:21:50,508
but the canary values our compiler

619
00:21:48,769 --> 00:21:52,370
defines that are generated randomly by

620
00:21:50,509 --> 00:21:54,139
the like C make random string function

621
00:21:52,370 --> 00:21:56,959
which is really low entropy not

622
00:21:54,139 --> 00:21:58,850
cryptographically secure and that C make

623
00:21:56,960 --> 00:22:01,100
list that builds it is in like the core

624
00:21:58,850 --> 00:22:03,080
of include us so only when you rebuild

625
00:22:01,100 --> 00:22:05,330
it include us the main image itself does

626
00:22:03,080 --> 00:22:07,158
the canary get regenerated so all of the

627
00:22:05,330 --> 00:22:08,120
images you build against one build of

628
00:22:07,159 --> 00:22:10,129
include us are gonna have the same

629
00:22:08,120 --> 00:22:11,449
canary and it'll persist across restarts

630
00:22:10,129 --> 00:22:12,740
so actually you can just brute-force it

631
00:22:11,450 --> 00:22:15,440
pretty easily especially given how fast

632
00:22:12,740 --> 00:22:17,119
it restarts after crashing and by the

633
00:22:15,440 --> 00:22:18,379
way the thread-local storage bug from

634
00:22:17,119 --> 00:22:19,549
rump run pretty much for appears for

635
00:22:18,379 --> 00:22:22,869
verbatim here so just ignore everything

636
00:22:19,549 --> 00:22:22,869
I said the Canaries are actually

637
00:22:22,960 --> 00:22:26,860
the heap doesn't have any protection at

638
00:22:24,940 --> 00:22:28,870
all it contiguous allocations

639
00:22:26,860 --> 00:22:34,209
deterministic no Canaries no point of

640
00:22:28,870 --> 00:22:36,399
validation nothing so the entropy system

641
00:22:34,210 --> 00:22:39,460
is actually one one thing that included

642
00:22:36,399 --> 00:22:42,219
us did fairly well so it just uses

643
00:22:39,460 --> 00:22:45,370
already ran for everything it does some

644
00:22:42,220 --> 00:22:46,990
cpu feature detection to detect if it

645
00:22:45,370 --> 00:22:49,299
has it if not it falls back to cycle

646
00:22:46,990 --> 00:22:52,059
counts but modern CPUs is not going to

647
00:22:49,299 --> 00:22:54,309
be a problem the art actual orangy

648
00:22:52,059 --> 00:22:55,779
applied on top is basically they took

649
00:22:54,309 --> 00:22:56,950
the internal sponge function out of

650
00:22:55,779 --> 00:23:00,159
ketchup

651
00:22:56,950 --> 00:23:02,230
which is fine that works and but to

652
00:23:00,159 --> 00:23:03,909
access the RNG they actually the way you

653
00:23:02,230 --> 00:23:06,429
just open up Devi random or dev random

654
00:23:03,909 --> 00:23:07,809
and right at the beginning of their open

655
00:23:06,429 --> 00:23:10,419
implementation they actually just stir

656
00:23:07,809 --> 00:23:12,190
Kuster compare every single Slyke string

657
00:23:10,419 --> 00:23:13,990
path that's passed in and just literally

658
00:23:12,190 --> 00:23:15,639
just check if it's dev random or Devi

659
00:23:13,990 --> 00:23:18,159
random and then they return you a magic

660
00:23:15,639 --> 00:23:20,168
file descriptor that goes to the the RNG

661
00:23:18,159 --> 00:23:21,309
the interesting thing about this is that

662
00:23:20,169 --> 00:23:23,379
in the middle of when we were looking at

663
00:23:21,309 --> 00:23:25,418
the updated it a little bit because it

664
00:23:23,379 --> 00:23:26,918
used to be at the the magic file

665
00:23:25,419 --> 00:23:28,659
descriptor was number nine nine eight

666
00:23:26,919 --> 00:23:30,100
but they never actually checked if when

667
00:23:28,659 --> 00:23:31,960
they were incrementing file descriptors

668
00:23:30,100 --> 00:23:33,490
elsewhere when they were returning new

669
00:23:31,960 --> 00:23:35,440
ones whether or not that collided with

670
00:23:33,490 --> 00:23:37,809
the magic one and so if you opened up

671
00:23:35,440 --> 00:23:40,330
enough files eventually one of them

672
00:23:37,809 --> 00:23:42,070
would just be dev and 'm and not your

673
00:23:40,330 --> 00:23:46,539
file that you intended to use but they

674
00:23:42,070 --> 00:23:48,908
they later fixed that so the standard

675
00:23:46,539 --> 00:23:51,549
library from that they're using for the

676
00:23:48,909 --> 00:23:53,200
sealy standard library is Red Hat's new

677
00:23:51,549 --> 00:23:56,379
Lib which was designed for embedded

678
00:23:53,200 --> 00:23:58,779
systems and has basically no security

679
00:23:56,379 --> 00:24:00,789
whatsoever as much like other other

680
00:23:58,779 --> 00:24:03,070
things that they provide so it's got

681
00:24:00,789 --> 00:24:04,990
percent and no custom format specifiers

682
00:24:03,070 --> 00:24:06,428
probably just because of space and

683
00:24:04,990 --> 00:24:08,169
complexity constraints and embedded

684
00:24:06,429 --> 00:24:11,259
environments and has no support

685
00:24:08,169 --> 00:24:12,610
whatsoever for a fortify source alright

686
00:24:11,259 --> 00:24:14,080
so we'd like to bring your attention to

687
00:24:12,610 --> 00:24:15,668
this point the very first sentence of

688
00:24:14,080 --> 00:24:17,320
this include oz post says that it was

689
00:24:15,669 --> 00:24:21,639
written with security in mind we'll let

690
00:24:17,320 --> 00:24:24,820
you decide so probably the most

691
00:24:21,639 --> 00:24:27,490
egregious thing the include us project

692
00:24:24,820 --> 00:24:30,399
did was they decided to throw it all all

693
00:24:27,490 --> 00:24:32,529
sort of knowledge about how memory is

694
00:24:30,399 --> 00:24:34,239
supposed to be laid out for applications

695
00:24:32,529 --> 00:24:36,820
and kernels and things like that

696
00:24:34,240 --> 00:24:39,130
so in the include Oz world the stack is

697
00:24:36,820 --> 00:24:40,960
in low memory followed immediately by

698
00:24:39,130 --> 00:24:43,690
the text section followed by data

699
00:24:40,960 --> 00:24:45,520
followed by heap in high memory and so

700
00:24:43,690 --> 00:24:48,190
if you if you see anything odd about

701
00:24:45,520 --> 00:24:50,940
this you remember that when you have a a

702
00:24:48,190 --> 00:24:54,130
buffer you write to increasing addresses

703
00:24:50,940 --> 00:24:56,110
and so what this means is that if we

704
00:24:54,130 --> 00:24:58,120
have a buffer overflow we can actually

705
00:24:56,110 --> 00:24:59,860
just continue past the end of the stack

706
00:24:58,120 --> 00:25:01,300
right into the text section start

707
00:24:59,860 --> 00:25:04,419
overwriting the code and if you're

708
00:25:01,300 --> 00:25:07,178
really lucky the the actual copy loop

709
00:25:04,420 --> 00:25:09,760
that maybe it's it's you know mem copy

710
00:25:07,179 --> 00:25:11,980
store copy some for loop you know that's

711
00:25:09,760 --> 00:25:13,629
gonna be early on and short enough so

712
00:25:11,980 --> 00:25:16,150
that your buffer overflow will be enough

713
00:25:13,630 --> 00:25:17,860
to actually hit it and so when you

714
00:25:16,150 --> 00:25:19,540
overflow the actual you know move

715
00:25:17,860 --> 00:25:21,550
instruction that's implementing that's

716
00:25:19,540 --> 00:25:24,100
performing the buffer overflow you don't

717
00:25:21,550 --> 00:25:26,169
want to use an OP because you know much

718
00:25:24,100 --> 00:25:30,219
like your your buffer writes code

719
00:25:26,170 --> 00:25:33,550
execute down but it increments the the

720
00:25:30,220 --> 00:25:35,530
IP address so basically you actually

721
00:25:33,550 --> 00:25:37,629
want to use jumps that go backwards in a

722
00:25:35,530 --> 00:25:39,220
chain until you go all the way back to

723
00:25:37,630 --> 00:25:42,280
the start and then run your shellcode

724
00:25:39,220 --> 00:25:43,390
going forward and as our demo shows if

725
00:25:42,280 --> 00:25:45,280
you're not that lucky

726
00:25:43,390 --> 00:25:47,020
well you're still pretty good because

727
00:25:45,280 --> 00:25:48,940
include us the way that it links code

728
00:25:47,020 --> 00:25:50,860
together it puts basically all user

729
00:25:48,940 --> 00:25:53,380
application code right at the beginning

730
00:25:50,860 --> 00:25:56,080
of the text section so even if you can't

731
00:25:53,380 --> 00:25:58,150
get you know mem copy when mem copy

732
00:25:56,080 --> 00:25:59,800
returns it's just gonna return right in

733
00:25:58,150 --> 00:26:01,390
your shellcode and it's never even at

734
00:25:59,800 --> 00:26:03,460
your and ideally your shellcode doesn't

735
00:26:01,390 --> 00:26:05,530
check the stack connector is that canary

736
00:26:03,460 --> 00:26:11,620
just don't do that

737
00:26:05,530 --> 00:26:15,190
where's the yeah so we have a demo that

738
00:26:11,620 --> 00:26:16,600
basically we just break on mem copy and

739
00:26:15,190 --> 00:26:17,740
then on the end of it we have to run

740
00:26:16,600 --> 00:26:19,870
through a couple of them because they're

741
00:26:17,740 --> 00:26:21,760
using the upright bring up of include us

742
00:26:19,870 --> 00:26:23,590
and then we just start stepping it and

743
00:26:21,760 --> 00:26:26,140
you can see us stepping through our

744
00:26:23,590 --> 00:26:28,959
reverse jump chain as we like to call it

745
00:26:26,140 --> 00:26:30,880
extreme not slop sledding until we get

746
00:26:28,960 --> 00:26:32,740
to the very start of it with the final

747
00:26:30,880 --> 00:26:34,780
jump and have our actual shellcode

748
00:26:32,740 --> 00:26:36,790
that's a little bit complicated it

749
00:26:34,780 --> 00:26:38,050
prints out you know hello torque on xx

750
00:26:36,790 --> 00:26:39,850
the only reason this complicated is

751
00:26:38,050 --> 00:26:42,809
because I wrote it so that it doesn't

752
00:26:39,850 --> 00:26:42,809
have any no bytes in it

753
00:26:46,380 --> 00:26:50,460
okay so as Jeff said the include us all

754
00:26:49,020 --> 00:26:53,670
the low-level stuff is implemented with

755
00:26:50,460 --> 00:26:56,010
new Lib this is about as insecure as it

756
00:26:53,670 --> 00:26:57,540
sounds it is basically just vanilla

757
00:26:56,010 --> 00:26:58,080
unlink again if you want to know about

758
00:26:57,540 --> 00:27:00,210
this either

759
00:26:58,080 --> 00:27:05,280
like consultant melech malefic arm it

760
00:27:00,210 --> 00:27:07,500
applies verbatim so basically with a nun

761
00:27:05,280 --> 00:27:09,240
link because of chunk coalescing in free

762
00:27:07,500 --> 00:27:10,800
if you corrupt a chunk you can you can

763
00:27:09,240 --> 00:27:12,510
write one two three pointers anywhere

764
00:27:10,800 --> 00:27:15,300
you want so I do you chain this to RC

765
00:27:12,510 --> 00:27:17,160
turns out that to include us has a panic

766
00:27:15,300 --> 00:27:18,330
handler called on panic which is just a

767
00:27:17,160 --> 00:27:20,430
function pointer that if it's nonzero

768
00:27:18,330 --> 00:27:23,129
it'll get called when the OS crashes

769
00:27:20,430 --> 00:27:26,070
like say on a page fault you can

770
00:27:23,130 --> 00:27:28,080
overwrite this now of course if you want

771
00:27:26,070 --> 00:27:30,419
to jump back into your your code in a

772
00:27:28,080 --> 00:27:31,830
heap overflow the heap in fact it's

773
00:27:30,420 --> 00:27:33,030
actually really deterministic you might

774
00:27:31,830 --> 00:27:34,169
know where it is but for the sake of

775
00:27:33,030 --> 00:27:36,780
argument let's suppose you don't know

776
00:27:34,170 --> 00:27:38,490
what you can do is since you're

777
00:27:36,780 --> 00:27:40,200
corrupting a chunk you can induce a

778
00:27:38,490 --> 00:27:43,440
crash inside free and of course at that

779
00:27:40,200 --> 00:27:45,630
point the pointer to the chunk that's

780
00:27:43,440 --> 00:27:47,400
corrupted is going to be on the stack so

781
00:27:45,630 --> 00:27:49,680
what you can do is use the first write

782
00:27:47,400 --> 00:27:51,000
via unlink to point the panic you

783
00:27:49,680 --> 00:27:53,340
overwrite the panic Handler and then

784
00:27:51,000 --> 00:27:55,170
point it at some any known writable

785
00:27:53,340 --> 00:27:57,209
location which is everywhere because

786
00:27:55,170 --> 00:28:00,090
it's include us it also needs to be

787
00:27:57,210 --> 00:28:01,650
executable actually and then use the

788
00:28:00,090 --> 00:28:02,939
second write to write eight bytes of

789
00:28:01,650 --> 00:28:05,340
shell code to that location and what the

790
00:28:02,940 --> 00:28:08,600
shell code needs to do is just increment

791
00:28:05,340 --> 00:28:10,620
RSP up until it's pointing at the

792
00:28:08,600 --> 00:28:12,449
address of that buffer on the stack and

793
00:28:10,620 --> 00:28:13,949
then it calls ret and then that we're

794
00:28:12,450 --> 00:28:15,750
just returns into your buffer and that's

795
00:28:13,950 --> 00:28:18,570
great but there's one more problem which

796
00:28:15,750 --> 00:28:20,430
is that the again new Lib is made for

797
00:28:18,570 --> 00:28:22,139
embedded devices so it's trying to save

798
00:28:20,430 --> 00:28:23,700
space in the way that the malloc chunks

799
00:28:22,140 --> 00:28:25,290
work is that they're part of a linked

800
00:28:23,700 --> 00:28:26,640
list of course when they're free so they

801
00:28:25,290 --> 00:28:27,810
have forward and back pointers when

802
00:28:26,640 --> 00:28:29,160
they're allocated they don't need them

803
00:28:27,810 --> 00:28:33,179
so the buffer starts from where the

804
00:28:29,160 --> 00:28:35,400
forward pointer is so because this the

805
00:28:33,180 --> 00:28:37,350
chunk that gets that that gets passed to

806
00:28:35,400 --> 00:28:38,430
free that gets unlinked first forward

807
00:28:37,350 --> 00:28:39,929
and back at that point need to be

808
00:28:38,430 --> 00:28:42,000
pointers to valid writable addresses

809
00:28:39,930 --> 00:28:44,760
otherwise you're gonna crash too early

810
00:28:42,000 --> 00:28:47,940
but then you return back into it and you

811
00:28:44,760 --> 00:28:49,710
return right to forward and so forward

812
00:28:47,940 --> 00:28:51,930
and back actually also need to be valid

813
00:28:49,710 --> 00:28:53,190
shellcode and the the eight bytes of

814
00:28:51,930 --> 00:28:54,930
shellcode we have doesn't have enough

815
00:28:53,190 --> 00:28:57,000
space to actually increment anywhere

816
00:28:54,930 --> 00:28:59,010
beyond that so we thought this was gonna

817
00:28:57,000 --> 00:29:00,269
be really hard maybe impossible till we

818
00:28:59,010 --> 00:29:01,889
looked at the first instruction

819
00:29:00,269 --> 00:29:03,599
in the include US binary we're looking

820
00:29:01,889 --> 00:29:04,769
at and it appears to be an 8-byte not

821
00:29:03,599 --> 00:29:07,678
that also happens to be a writable

822
00:29:04,769 --> 00:29:10,919
address so thanks clang we have a demo

823
00:29:07,679 --> 00:29:12,989
for this as well oops so here we have a

824
00:29:10,919 --> 00:29:15,239
vulnerable TCP server with a buffer

825
00:29:12,989 --> 00:29:16,379
overflow on the heap and we assume we

826
00:29:15,239 --> 00:29:17,729
don't know the size of the buffer

827
00:29:16,379 --> 00:29:19,468
overflow so basically what I'm doing

828
00:29:17,729 --> 00:29:20,820
here is a sort of exponential back-off

829
00:29:19,469 --> 00:29:22,529
where I'm just sending bigger and bigger

830
00:29:20,820 --> 00:29:23,849
buffers seeing where it crashes and you

831
00:29:22,529 --> 00:29:27,359
see it four starts really fast so it's

832
00:29:23,849 --> 00:29:29,070
great for brute forcing and basically we

833
00:29:27,359 --> 00:29:30,359
are finding the distance to the next

834
00:29:29,070 --> 00:29:32,399
heap chunk header so we know how to

835
00:29:30,359 --> 00:29:34,259
corrupt it and then we're going to use

836
00:29:32,399 --> 00:29:36,869
that to just write to progressively

837
00:29:34,259 --> 00:29:38,099
greater address addresses incrementing

838
00:29:36,869 --> 00:29:41,070
just about like one pointer length

839
00:29:38,099 --> 00:29:44,299
each time and in just a moment it's

840
00:29:41,070 --> 00:29:46,589
going to loop it's going to find the

841
00:29:44,299 --> 00:29:51,959
panic Handler and there it Sprint's at

842
00:29:46,589 --> 00:29:54,869
our address or sorry our message so

843
00:29:51,959 --> 00:29:56,339
include us there basically aren't any

844
00:29:54,869 --> 00:29:59,009
protections with the exception of like

845
00:29:56,339 --> 00:30:01,349
really half-hearted Canaries the ASLR

846
00:29:59,009 --> 00:30:03,089
that there's no ASLR everything's our WX

847
00:30:01,349 --> 00:30:04,619
Canaries are constant across reboots not

848
00:30:03,089 --> 00:30:06,928
cryptographically random and also

849
00:30:04,619 --> 00:30:08,609
they're no all the time the heap has no

850
00:30:06,929 --> 00:30:10,919
protections at all the entropy is

851
00:30:08,609 --> 00:30:13,228
actually ok except for the NSA case and

852
00:30:10,919 --> 00:30:17,159
the standard library doesn't really have

853
00:30:13,229 --> 00:30:19,709
any hardening at all so basically

854
00:30:17,159 --> 00:30:21,179
include us like it doesn't have any

855
00:30:19,709 --> 00:30:22,619
security features like if you get any

856
00:30:21,179 --> 00:30:23,849
kind of memory corruption or like even

857
00:30:22,619 --> 00:30:27,269
just look at it the wrong way it's

858
00:30:23,849 --> 00:30:30,570
you're gonna get RC now in a better note

859
00:30:27,269 --> 00:30:33,059
we have Mirage OS which is an oak Hamel

860
00:30:30,570 --> 00:30:35,099
based unit kernel and what drew our

861
00:30:33,059 --> 00:30:38,489
interest to it is basically it's

862
00:30:35,099 --> 00:30:40,769
intended to be used probably in cubes os

863
00:30:38,489 --> 00:30:43,709
to create these secure minimal attack

864
00:30:40,769 --> 00:30:45,539
surface VMs and in that case it'd be

865
00:30:43,709 --> 00:30:47,759
running on Xen so it supports both KVM

866
00:30:45,539 --> 00:30:49,379
and Xen but we tested it on Xen just

867
00:30:47,759 --> 00:30:52,409
because that seems the most interesting

868
00:30:49,379 --> 00:30:55,109
for this use case and because of renzo

869
00:30:52,409 --> 00:30:56,429
camel it also supports FFI so you can

870
00:30:55,109 --> 00:30:58,589
you can call native code from the Oh

871
00:30:56,429 --> 00:30:59,909
camel and basically the way that it's

872
00:30:58,589 --> 00:31:01,559
constructed is pretty much like rum from

873
00:30:59,909 --> 00:31:04,109
you take the O camel runtime and you put

874
00:31:01,559 --> 00:31:05,428
it on top of Xen mini OS although they

875
00:31:04,109 --> 00:31:07,259
have their own Fork which has just a

876
00:31:05,429 --> 00:31:09,509
little bit of differences so you might

877
00:31:07,259 --> 00:31:10,859
be wondering why would you use o camel

878
00:31:09,509 --> 00:31:12,419
because it's like sort of an obscure

879
00:31:10,859 --> 00:31:13,429
functional language basically the

880
00:31:12,419 --> 00:31:14,780
argument comes down to

881
00:31:13,430 --> 00:31:15,860
that it supports like also

882
00:31:14,780 --> 00:31:17,180
object-oriented programming and

883
00:31:15,860 --> 00:31:19,729
imperative pretty recently but it's also

884
00:31:17,180 --> 00:31:22,190
reasonably memory safe not as much as

885
00:31:19,730 --> 00:31:23,990
something like rust but it's if you're

886
00:31:22,190 --> 00:31:26,240
doing just like regular oh camel things

887
00:31:23,990 --> 00:31:27,140
it's it's you're gonna be fine you're

888
00:31:26,240 --> 00:31:28,910
not gonna run it like a buffer overflow

889
00:31:27,140 --> 00:31:30,650
or anything although it turns out that

890
00:31:28,910 --> 00:31:32,180
vanilla Oh camel does have support for

891
00:31:30,650 --> 00:31:34,520
some operations that are distinctly not

892
00:31:32,180 --> 00:31:37,460
memory safe but if you're writing normal

893
00:31:34,520 --> 00:31:38,090
Oh camel you'll be fine right well no

894
00:31:37,460 --> 00:31:40,700
not exactly

895
00:31:38,090 --> 00:31:42,230
okay ml has some pretty bad cv ease and

896
00:31:40,700 --> 00:31:43,880
you know this one we're pointing to with

897
00:31:42,230 --> 00:31:44,960
the arrow is a 10 that actually is not

898
00:31:43,880 --> 00:31:46,970
applicable to you know colonel because

899
00:31:44,960 --> 00:31:48,230
it uses environment variables but the

900
00:31:46,970 --> 00:31:50,330
top one is a memory corruption that

901
00:31:48,230 --> 00:31:52,340
absolutely would be useful to us

902
00:31:50,330 --> 00:31:54,290
although we haven't done a POC there's

903
00:31:52,340 --> 00:31:56,870
also a spooky library called Marshall

904
00:31:54,290 --> 00:31:58,639
which is for D serialization and if you

905
00:31:56,870 --> 00:32:00,820
basically like specify the wrong type

906
00:31:58,640 --> 00:32:04,700
quote anything can happen at runtime the

907
00:32:00,820 --> 00:32:10,220
only limit is yourself welcome to

908
00:32:04,700 --> 00:32:11,270
zombocom yes so much like include us we

909
00:32:10,220 --> 00:32:14,150
were having quite a bit of trouble

910
00:32:11,270 --> 00:32:16,100
debugging mirage now because right now

911
00:32:14,150 --> 00:32:18,410
mirage only supports running as a para

912
00:32:16,100 --> 00:32:19,490
virtualized guest on Xen and it turns

913
00:32:18,410 --> 00:32:21,590
out that there are no devote good

914
00:32:19,490 --> 00:32:23,540
debuggers for Xen para virtualized

915
00:32:21,590 --> 00:32:25,340
guests and by no good debuggers I mean

916
00:32:23,540 --> 00:32:28,460
literally there are no debuggers for

917
00:32:25,340 --> 00:32:30,169
para virtualized guests on Zen there is

918
00:32:28,460 --> 00:32:32,630
VM Ida bug which is really nice it's

919
00:32:30,170 --> 00:32:34,220
it's modern it's Lybia my based it's you

920
00:32:32,630 --> 00:32:35,600
know supports lots of nice nice things

921
00:32:34,220 --> 00:32:38,510
unfortunately none of the things we are

922
00:32:35,600 --> 00:32:41,300
looking at it only runs with Linux and

923
00:32:38,510 --> 00:32:45,350
windows h vm guests and Miraj obviously

924
00:32:41,300 --> 00:32:48,580
is not linux or windows or h vm there's

925
00:32:45,350 --> 00:32:51,490
also checks which comes packaged with

926
00:32:48,580 --> 00:32:55,040
Xen and it's like a gdb server basically

927
00:32:51,490 --> 00:32:56,570
but it goes downhill very quickly like

928
00:32:55,040 --> 00:32:58,970
if you look into the codebase you

929
00:32:56,570 --> 00:33:01,129
realize it's using these gdb SX branded

930
00:32:58,970 --> 00:33:04,280
syscalls specifically implemented in Xen

931
00:33:01,130 --> 00:33:05,750
40 DB sx and it seems like after a while

932
00:33:04,280 --> 00:33:07,670
I realize this is probably because the

933
00:33:05,750 --> 00:33:10,520
Xen developer 2 documented their vmi and

934
00:33:07,670 --> 00:33:12,080
debugging API so badly that like they

935
00:33:10,520 --> 00:33:13,310
couldn't find them later and so they

936
00:33:12,080 --> 00:33:15,889
just said oh screw it we'll implement

937
00:33:13,310 --> 00:33:18,530
the syscalls specifically for this it

938
00:33:15,890 --> 00:33:20,600
can also only do peak poke so it also

939
00:33:18,530 --> 00:33:22,460
supports reading registers theoretically

940
00:33:20,600 --> 00:33:23,959
but it doesn't speak the gdb Remote

941
00:33:22,460 --> 00:33:27,020
protocol well enough to talk to either

942
00:33:23,960 --> 00:33:30,650
gdb or LD be when it sends registers

943
00:33:27,020 --> 00:33:32,790
so basically eventually I realized that

944
00:33:30,650 --> 00:33:34,080
using these as a nightmare and it's

945
00:33:32,790 --> 00:33:36,480
actually easier just to go and write my

946
00:33:34,080 --> 00:33:38,280
own debugger so I did I call it the Zen

947
00:33:36,480 --> 00:33:39,630
debug and Jeff's calls it the Zen bag

948
00:33:38,280 --> 00:33:43,410
and I kind of don't like that but it's

949
00:33:39,630 --> 00:33:45,720
stuck it uses this time the correct Zen

950
00:33:43,410 --> 00:33:47,400
debugging and vmi api's which I had to

951
00:33:45,720 --> 00:33:48,900
basically hunt down myself and dissect

952
00:33:47,400 --> 00:33:50,520
the implementation because like wow good

953
00:33:48,900 --> 00:33:51,929
luck if you're like even you're looking

954
00:33:50,520 --> 00:33:53,580
for like the comment at the top of the

955
00:33:51,929 --> 00:33:55,440
header file that tells you what it does

956
00:33:53,580 --> 00:33:58,470
no those are like not they are most of

957
00:33:55,440 --> 00:34:00,360
the time it right now it has its own

958
00:33:58,470 --> 00:34:03,059
repla which works pretty nicely but even

959
00:34:00,360 --> 00:34:05,639
more functional is the gdb server it

960
00:34:03,059 --> 00:34:07,559
it's it's like it's a stub gdb server

961
00:34:05,640 --> 00:34:09,300
and by gdb server I mean lltv server

962
00:34:07,559 --> 00:34:10,949
because it turns out that gdb doesn't

963
00:34:09,300 --> 00:34:13,530
actually speak its own remote protocol

964
00:34:10,949 --> 00:34:16,350
to spec and I'm not gonna deal with that

965
00:34:13,530 --> 00:34:17,970
honestly so right now Zenda bug supports

966
00:34:16,350 --> 00:34:19,350
paravirtualized guests and it can read

967
00:34:17,969 --> 00:34:21,118
and write registers in memory and do

968
00:34:19,350 --> 00:34:22,560
breakpoints and stepping and right now

969
00:34:21,119 --> 00:34:24,090
we're trying to work on getting memory

970
00:34:22,560 --> 00:34:25,949
region info so you can like read the

971
00:34:24,090 --> 00:34:27,480
page tables but it turns out that Zen

972
00:34:25,949 --> 00:34:28,980
actually doesn't have an API for this in

973
00:34:27,480 --> 00:34:31,260
paravirtualized guests so it's gonna

974
00:34:28,980 --> 00:34:33,960
take a little while so I've got a demo

975
00:34:31,260 --> 00:34:35,490
of this as well whoops and right now on

976
00:34:33,960 --> 00:34:37,020
the bottom right we've got a simple

977
00:34:35,489 --> 00:34:39,149
Mirage OS yoona kernel it just prints

978
00:34:37,020 --> 00:34:42,149
hello I'm a test every second a hundred

979
00:34:39,149 --> 00:34:44,250
times and we're gonna run it in the

980
00:34:42,149 --> 00:34:46,020
bottom left and then start Zenda bug

981
00:34:44,250 --> 00:34:47,969
with up with the port one two three four

982
00:34:46,020 --> 00:34:51,000
open and we'll stop the guest

983
00:34:47,969 --> 00:34:52,799
automatically and here we see it's it's

984
00:34:51,000 --> 00:34:54,629
this is actually the syscall page it's

985
00:34:52,800 --> 00:34:57,510
stepping through instructions it follows

986
00:34:54,629 --> 00:34:59,900
the ret even and here we're going to now

987
00:34:57,510 --> 00:35:02,910
search memory for the string hello and

988
00:34:59,900 --> 00:35:06,300
then write a magical value into that

989
00:35:02,910 --> 00:35:08,899
area and then continue and we should see

990
00:35:06,300 --> 00:35:14,369
it's now printing our message fabulous

991
00:35:08,900 --> 00:35:16,410
whoops okay so my OS same SLR is the

992
00:35:14,369 --> 00:35:18,720
same situation as the other two it's

993
00:35:16,410 --> 00:35:21,509
basically like you know public code

994
00:35:18,720 --> 00:35:23,399
yields deterministic binaries the

995
00:35:21,510 --> 00:35:25,140
paravirtualized page thing with rum run

996
00:35:23,400 --> 00:35:26,570
is is also here because it's running as

997
00:35:25,140 --> 00:35:29,129
a pair of virtualized guest as well

998
00:35:26,570 --> 00:35:30,359
what's interesting is that Oh camel has

999
00:35:29,130 --> 00:35:32,720
a pretty big runtime and of course

1000
00:35:30,359 --> 00:35:35,400
that's all written in C at some point so

1001
00:35:32,720 --> 00:35:37,350
most of the Oh camel runtime is going to

1002
00:35:35,400 --> 00:35:39,470
be like deterministically ordered and

1003
00:35:37,350 --> 00:35:41,270
placed it like a semi

1004
00:35:39,470 --> 00:35:44,569
random like a location that you won't

1005
00:35:41,270 --> 00:35:46,250
know necessarily so if you can find any

1006
00:35:44,570 --> 00:35:47,540
part of oh camel you probably know where

1007
00:35:46,250 --> 00:35:50,030
the rest of it is and you may be able to

1008
00:35:47,540 --> 00:35:51,770
do something with that the page

1009
00:35:50,030 --> 00:35:53,060
protections are just like rump run text

1010
00:35:51,770 --> 00:35:55,550
isn't writable but data stack and heap

1011
00:35:53,060 --> 00:35:56,690
are all rwx the additional page

1012
00:35:55,550 --> 00:35:57,920
predictions are actually good they've

1013
00:35:56,690 --> 00:36:01,340
pretty much done everything that they

1014
00:35:57,920 --> 00:36:02,359
should they have unmapped or guard pages

1015
00:36:01,340 --> 00:36:04,430
it's hard to tell because we can't

1016
00:36:02,359 --> 00:36:06,049
inspect PT's yet between at least the

1017
00:36:04,430 --> 00:36:08,660
data data in stacked sections and then

1018
00:36:06,050 --> 00:36:10,820
stack and heap and the null page is

1019
00:36:08,660 --> 00:36:12,950
mapped but not our WX that's good and

1020
00:36:10,820 --> 00:36:15,440
railro again doesn't apply because all

1021
00:36:12,950 --> 00:36:16,279
the linking here is static there are no

1022
00:36:15,440 --> 00:36:17,960
snack Canaries

1023
00:36:16,280 --> 00:36:19,670
so unlike rump run and include us it

1024
00:36:17,960 --> 00:36:22,670
doesn't even try here they're explicitly

1025
00:36:19,670 --> 00:36:24,349
disabled in the Mirage OS like Cormac

1026
00:36:22,670 --> 00:36:27,080
files and then when you use the build

1027
00:36:24,349 --> 00:36:29,000
tool chain it also disables for your

1028
00:36:27,080 --> 00:36:32,420
application code even if even if you're

1029
00:36:29,000 --> 00:36:35,090
like GCC turns it on by default the heap

1030
00:36:32,420 --> 00:36:36,440
doesn't have any protections at all with

1031
00:36:35,090 --> 00:36:38,900
the exception of a little bit of pointer

1032
00:36:36,440 --> 00:36:41,030
validation so it's implemented with X

1033
00:36:38,900 --> 00:36:42,349
malloc from any OS and so the

1034
00:36:41,030 --> 00:36:44,450
allocations are deterministic in

1035
00:36:42,349 --> 00:36:46,750
contiguous there are no nono sort of

1036
00:36:44,450 --> 00:36:49,250
like heap or page chunk Canaries

1037
00:36:46,750 --> 00:36:51,230
unlinking small chunks has pointer

1038
00:36:49,250 --> 00:36:53,660
validation but most code paths don't and

1039
00:36:51,230 --> 00:36:56,720
I have a POC for an unlink bug just like

1040
00:36:53,660 --> 00:36:57,980
I showed you with include awesome so the

1041
00:36:56,720 --> 00:36:59,569
entropy situation is interesting because

1042
00:36:57,980 --> 00:37:01,460
there are two packages you can use for

1043
00:36:59,570 --> 00:37:03,050
entropy they don't really specify which

1044
00:37:01,460 --> 00:37:04,520
of them is good and they really should

1045
00:37:03,050 --> 00:37:06,859
because one of them is great and one of

1046
00:37:04,520 --> 00:37:09,020
them is terrible the terrible one of

1047
00:37:06,859 --> 00:37:10,790
course is Mirage random which is a

1048
00:37:09,020 --> 00:37:12,890
wrapper for Oh camels random module

1049
00:37:10,790 --> 00:37:15,470
which is not even cryptographically

1050
00:37:12,890 --> 00:37:17,930
random but that aside the way it

1051
00:37:15,470 --> 00:37:19,640
initializes itself is it gets a seed

1052
00:37:17,930 --> 00:37:20,960
from dev you random but because there's

1053
00:37:19,640 --> 00:37:22,400
no file system and it like doesn't do

1054
00:37:20,960 --> 00:37:25,280
any special casing like crimp run or

1055
00:37:22,400 --> 00:37:26,900
include us opening Devi random just

1056
00:37:25,280 --> 00:37:28,580
returns one and in fact literally the

1057
00:37:26,900 --> 00:37:32,290
implementation for open is just to

1058
00:37:28,580 --> 00:37:36,290
return one it will then fall back to the

1059
00:37:32,290 --> 00:37:37,759
PID and PID so like parent PID as well

1060
00:37:36,290 --> 00:37:40,000
as get time of day but the first two

1061
00:37:37,760 --> 00:37:42,320
don't exist because there are also no

1062
00:37:40,000 --> 00:37:43,970
processes on you know kernels those are

1063
00:37:42,320 --> 00:37:46,099
just hard-coded to return two and one

1064
00:37:43,970 --> 00:37:48,140
respectively and so ultimately the only

1065
00:37:46,099 --> 00:37:50,440
entropy source that it actually gets is

1066
00:37:48,140 --> 00:37:52,549
the current time this is obviously bad

1067
00:37:50,440 --> 00:37:53,390
there's also Mirage entropy which is

1068
00:37:52,550 --> 00:37:55,250
good

1069
00:37:53,390 --> 00:37:57,470
it can do our dear and and our deseed of

1070
00:37:55,250 --> 00:37:59,030
course only on x86 and also has

1071
00:37:57,470 --> 00:38:01,459
something called the whirlwind RNG which

1072
00:37:59,030 --> 00:38:04,010
they refer to with a new research paper

1073
00:38:01,460 --> 00:38:05,810
and it says that it attempts to exploit

1074
00:38:04,010 --> 00:38:07,820
CPU level data races that lead to

1075
00:38:05,810 --> 00:38:09,890
execution time variability of identical

1076
00:38:07,820 --> 00:38:11,660
instructions and we're not crypto

1077
00:38:09,890 --> 00:38:16,430
experts but this sounds kind of spooky

1078
00:38:11,660 --> 00:38:17,899
spectral even where we don't really have

1079
00:38:16,430 --> 00:38:19,759
the expertise to assess this aside from

1080
00:38:17,900 --> 00:38:20,960
like obvious non crypto issues which we

1081
00:38:19,760 --> 00:38:22,490
didn't find but it would be interesting

1082
00:38:20,960 --> 00:38:23,510
if someone with crypto expertise could

1083
00:38:22,490 --> 00:38:26,089
take a look at this because you might

1084
00:38:23,510 --> 00:38:27,260
find something there's no standard

1085
00:38:26,090 --> 00:38:29,090
library hardening they got their own

1086
00:38:27,260 --> 00:38:30,320
standard library called mini Lib C which

1087
00:38:29,090 --> 00:38:33,230
is like a really thin wrapper around

1088
00:38:30,320 --> 00:38:34,520
mini OS and it's the usual that supports

1089
00:38:33,230 --> 00:38:36,350
percent and doesn't support custom

1090
00:38:34,520 --> 00:38:39,590
format specifiers and doesn't have any

1091
00:38:36,350 --> 00:38:41,210
fortify source support something

1092
00:38:39,590 --> 00:38:43,070
interesting in rather unique tomorrow's

1093
00:38:41,210 --> 00:38:45,350
OS is that it's built of course on the

1094
00:38:43,070 --> 00:38:47,690
Oh camel like packaged infrastructure so

1095
00:38:45,350 --> 00:38:49,880
it uses oh pam as a package manager and

1096
00:38:47,690 --> 00:38:52,130
rather like you use OPM to install

1097
00:38:49,880 --> 00:38:53,390
packages to build it and that has a Sat

1098
00:38:52,130 --> 00:38:55,520
solver based dependency resolution

1099
00:38:53,390 --> 00:38:57,109
mechanism and so what this means is it

1100
00:38:55,520 --> 00:38:59,690
can install arbitrarily out of date

1101
00:38:57,110 --> 00:39:01,760
packages without warning you if you have

1102
00:38:59,690 --> 00:39:04,040
something like this diagram you have a

1103
00:39:01,760 --> 00:39:06,170
top-level package a that depends on like

1104
00:39:04,040 --> 00:39:08,000
package C at version greater than 1.0

1105
00:39:06,170 --> 00:39:10,580
and then it depends also on package C

1106
00:39:08,000 --> 00:39:13,250
transitively at say less than 1.0 via

1107
00:39:10,580 --> 00:39:15,529
another dependency no matter how high

1108
00:39:13,250 --> 00:39:18,620
the version of C is currently if you

1109
00:39:15,530 --> 00:39:20,870
install a it OPM doesn't let you install

1110
00:39:18,620 --> 00:39:22,339
two versus the same package so in order

1111
00:39:20,870 --> 00:39:24,109
to satisfy this it'll just install

1112
00:39:22,340 --> 00:39:25,280
version 1.0 a package c and it'll you

1113
00:39:24,110 --> 00:39:27,530
know the interface will give you exactly

1114
00:39:25,280 --> 00:39:28,970
the same readout as if it installed the

1115
00:39:27,530 --> 00:39:30,320
current version of package c like it'll

1116
00:39:28,970 --> 00:39:31,640
show the version and some little things

1117
00:39:30,320 --> 00:39:33,440
somewhere but unless you're really

1118
00:39:31,640 --> 00:39:34,970
looking hard then it's it's not gonna

1119
00:39:33,440 --> 00:39:36,320
act any differently it won't warn you so

1120
00:39:34,970 --> 00:39:38,509
you have to be really careful if you're

1121
00:39:36,320 --> 00:39:39,890
developing any stuff for ramaraju s that

1122
00:39:38,510 --> 00:39:43,370
like you don't let OPM screw you with

1123
00:39:39,890 --> 00:39:45,170
really out-of-date packages so right now

1124
00:39:43,370 --> 00:39:46,940
there are a couple other vulnerabilities

1125
00:39:45,170 --> 00:39:49,580
like real vulnerabilities that we found

1126
00:39:46,940 --> 00:39:50,600
but we can't talk about them because we

1127
00:39:49,580 --> 00:39:51,890
just found them in the past few weeks

1128
00:39:50,600 --> 00:39:53,600
and we're still in the disclosure

1129
00:39:51,890 --> 00:39:54,790
process but rest assured these will be

1130
00:39:53,600 --> 00:39:58,299
in the white paper

1131
00:39:54,790 --> 00:40:00,980
so in short morocco s has no a SLR

1132
00:39:58,300 --> 00:40:02,960
basically no page protections on data

1133
00:40:00,980 --> 00:40:06,440
stack and heap text is okay no pages

1134
00:40:02,960 --> 00:40:07,250
okay there are no Canaries even if you

1135
00:40:06,440 --> 00:40:10,130
try to enable them

1136
00:40:07,250 --> 00:40:12,230
application code nothing nothing at all

1137
00:40:10,130 --> 00:40:13,640
on the heap the entropy is good as long

1138
00:40:12,230 --> 00:40:15,230
as you're using the right package but

1139
00:40:13,640 --> 00:40:17,210
they don't actually specify that that's

1140
00:40:15,230 --> 00:40:18,200
the one you should use and the standard

1141
00:40:17,210 --> 00:40:21,410
library doesn't have any kind of

1142
00:40:18,200 --> 00:40:22,910
hardening so basically if you get a

1143
00:40:21,410 --> 00:40:25,819
stack buffer overflow you're great you

1144
00:40:22,910 --> 00:40:27,410
can get RC pretty much immediately most

1145
00:40:25,820 --> 00:40:28,700
types of heap buffer overflow accepts

1146
00:40:27,410 --> 00:40:30,740
some stuff with small chunks will give

1147
00:40:28,700 --> 00:40:32,870
you an arbitrary pointer right again

1148
00:40:30,740 --> 00:40:34,279
keeping in mind that the function point

1149
00:40:32,870 --> 00:40:35,720
like the function addresses that you

1150
00:40:34,280 --> 00:40:37,280
might want to utilize are gonna be in

1151
00:40:35,720 --> 00:40:40,129
slightly different places but again you

1152
00:40:37,280 --> 00:40:42,830
can brute-force those or scan the

1153
00:40:40,130 --> 00:40:44,690
entropy implementations and the Oh camel

1154
00:40:42,830 --> 00:40:46,100
package manager' Oh Pam you have to be

1155
00:40:44,690 --> 00:40:47,300
pretty careful about how you use them

1156
00:40:46,100 --> 00:40:50,960
because they can shoot you in the foot

1157
00:40:47,300 --> 00:40:52,460
easily so given these three assessments

1158
00:40:50,960 --> 00:40:53,570
I think it's pretty obvious that it is

1159
00:40:52,460 --> 00:40:55,070
not the case that you know kernels are

1160
00:40:53,570 --> 00:40:57,470
secure but they are rather hilariously

1161
00:40:55,070 --> 00:40:59,570
broken and that's basically because they

1162
00:40:57,470 --> 00:41:01,640
don't implement even simple security

1163
00:40:59,570 --> 00:41:03,410
measures so to the point that if you get

1164
00:41:01,640 --> 00:41:05,299
most types of memory corruption on the

1165
00:41:03,410 --> 00:41:07,790
unit kernels we looked at at least they

1166
00:41:05,300 --> 00:41:09,740
will lead you very easily to RCE and

1167
00:41:07,790 --> 00:41:10,940
oftentimes as like in the included mo

1168
00:41:09,740 --> 00:41:12,140
you don't even have to have seen the

1169
00:41:10,940 --> 00:41:14,630
binary or the source of what you're

1170
00:41:12,140 --> 00:41:16,670
attacking so on top of this is the fact

1171
00:41:14,630 --> 00:41:19,580
that everything has kernel level VM

1172
00:41:16,670 --> 00:41:21,290
capabilities so like as soon as you get

1173
00:41:19,580 --> 00:41:22,250
any control it's already full control

1174
00:41:21,290 --> 00:41:23,360
like there's there's no privilege

1175
00:41:22,250 --> 00:41:24,740
separation there's no route or anything

1176
00:41:23,360 --> 00:41:26,420
as soon as you get RCE

1177
00:41:24,740 --> 00:41:28,370
you can start crafting arbitrary packets

1178
00:41:26,420 --> 00:41:31,280
do PCI whatever anything the VM will let

1179
00:41:28,370 --> 00:41:33,109
you do you can do but with that said

1180
00:41:31,280 --> 00:41:34,700
it's worth mentioning that even though

1181
00:41:33,110 --> 00:41:36,470
Mirage at a low level is basically the

1182
00:41:34,700 --> 00:41:37,669
same situation this rump run it is

1183
00:41:36,470 --> 00:41:39,709
actually still an order of magnitude

1184
00:41:37,670 --> 00:41:41,480
more secure than any of the native code

1185
00:41:39,710 --> 00:41:43,070
you know kernels we looked at because

1186
00:41:41,480 --> 00:41:44,390
you're not gonna be writing that much

1187
00:41:43,070 --> 00:41:48,350
native code on mirage

1188
00:41:44,390 --> 00:41:49,520
with that said memory safe language you

1189
00:41:48,350 --> 00:41:51,230
know kernels like knowledge don't need

1190
00:41:49,520 --> 00:41:53,090
to be pretty careful about how their

1191
00:41:51,230 --> 00:41:54,260
low-level components which are most

1192
00:41:53,090 --> 00:41:56,630
likely gonna be written in C are

1193
00:41:54,260 --> 00:41:58,760
hardened and they also need to focus on

1194
00:41:56,630 --> 00:42:00,290
actually providing like secure api's for

1195
00:41:58,760 --> 00:42:01,580
application developers to use because

1196
00:42:00,290 --> 00:42:02,750
they can't just rely on being inherently

1197
00:42:01,580 --> 00:42:04,549
secure they actually have to like help

1198
00:42:02,750 --> 00:42:07,850
application developers develop secure

1199
00:42:04,550 --> 00:42:09,320
applications so basically you know

1200
00:42:07,850 --> 00:42:10,990
kernel is unlike the claims of many of

1201
00:42:09,320 --> 00:42:13,280
their proponents say are not a cure-all

1202
00:42:10,990 --> 00:42:14,750
basically their embedded systems running

1203
00:42:13,280 --> 00:42:16,370
in a VM and they have about the same

1204
00:42:14,750 --> 00:42:18,350
level of security as you'd expect from a

1205
00:42:16,370 --> 00:42:19,759
lot of embedded systems so to put it

1206
00:42:18,350 --> 00:42:20,839
lightly there's a lot of work that needs

1207
00:42:19,760 --> 00:42:22,460
to be done before you

1208
00:42:20,839 --> 00:42:25,249
kernels become at all suitable for

1209
00:42:22,460 --> 00:42:26,599
production in retrospect they should

1210
00:42:25,249 --> 00:42:28,549
have been obvious as soon as we saw that

1211
00:42:26,599 --> 00:42:29,839
there basically wasn't a debugger for

1212
00:42:28,549 --> 00:42:31,219
the overwhelming majority of Yoona

1213
00:42:29,839 --> 00:42:32,660
kernels we looked at and we actually had

1214
00:42:31,219 --> 00:42:36,769
to write our own to assess some of the

1215
00:42:32,660 --> 00:42:40,029
underlying components we'd like to thank

1216
00:42:36,769 --> 00:42:43,368
some people first of all mini Preston of

1217
00:42:40,029 --> 00:42:45,710
the Mirage OS project for being super

1218
00:42:43,369 --> 00:42:47,719
helpful with teaching me all sorts of

1219
00:42:45,710 --> 00:42:50,749
stuff about how a camel's fi works

1220
00:42:47,719 --> 00:42:53,059
during the last CCC in Germany and then

1221
00:42:50,749 --> 00:42:56,319
Brian Cantrell for being an epic troll

1222
00:42:53,059 --> 00:42:56,319
who happened to be right this time

1223
00:42:56,469 --> 00:43:01,160
for future work we're gonna start

1224
00:42:58,700 --> 00:43:02,930
looking at OS v we have white paper at

1225
00:43:01,160 --> 00:43:04,670
least the first one coming out soon it's

1226
00:43:02,930 --> 00:43:06,558
like at a hundred pages right now that

1227
00:43:04,670 --> 00:43:09,499
are mostly diagrams and exploit

1228
00:43:06,559 --> 00:43:12,079
shellcode so that'll that'll be cool

1229
00:43:09,499 --> 00:43:13,549
when it drops and then we are going to

1230
00:43:12,079 --> 00:43:15,769
be looking more for those higher-level

1231
00:43:13,549 --> 00:43:18,229
things where there are issues in the

1232
00:43:15,769 --> 00:43:20,319
kind of stack code of when you you

1233
00:43:18,229 --> 00:43:23,598
decide to re-implement your own tcp/ip

1234
00:43:20,319 --> 00:43:25,339
implementation what can go wrong and and

1235
00:43:23,599 --> 00:43:25,729
that's sort of that kind of level of

1236
00:43:25,339 --> 00:43:28,009
stuff

1237
00:43:25,729 --> 00:43:29,779
is one of the one of the sorts of bugs

1238
00:43:28,009 --> 00:43:31,160
that we already found we weren't really

1239
00:43:29,779 --> 00:43:32,479
looking for that kind of bug but that's

1240
00:43:31,160 --> 00:43:34,519
one of the ones that we we can't talk

1241
00:43:32,479 --> 00:43:38,450
about of what happens when you just

1242
00:43:34,519 --> 00:43:41,149
reimplementation stack from user land to

1243
00:43:38,450 --> 00:43:45,049
kernel to hardware and just throw it all

1244
00:43:41,150 --> 00:43:47,960
in bring zero so we're looking for more

1245
00:43:45,049 --> 00:43:49,400
of that if there are any questions we

1246
00:43:47,960 --> 00:43:51,229
have a little bit of time left actually

1247
00:43:49,400 --> 00:43:54,680
so we actually got through this faster

1248
00:43:51,229 --> 00:43:58,098
than in our demo runs for ourselves I'll

1249
00:43:54,680 --> 00:43:59,649
also add that NCC group is hiring so if

1250
00:43:58,099 --> 00:44:02,719
anyone wants to talk to us about that

1251
00:43:59,650 --> 00:44:07,309
we'll be around so just feel free to

1252
00:44:02,719 --> 00:44:09,670
stop by and ask us questions so any

1253
00:44:07,309 --> 00:44:09,670
questions

1254
00:44:12,730 --> 00:44:16,030
okay thank you

1255
00:44:16,560 --> 00:44:20,759
[Applause]

