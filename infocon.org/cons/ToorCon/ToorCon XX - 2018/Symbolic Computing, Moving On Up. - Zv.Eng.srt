1
00:00:04,620 --> 00:00:09,400
all right next up we have Zephyr giving

2
00:00:07,300 --> 00:00:11,320
a talk on symbolic computing moving on

3
00:00:09,400 --> 00:00:19,749
moving on up please give him a warm

4
00:00:11,320 --> 00:00:22,060
torque on welcome thank you guys how you

5
00:00:19,749 --> 00:00:25,598
guys doing for Turk on 20 it's been so

6
00:00:22,060 --> 00:00:27,668
long I actually remember when I was in

7
00:00:25,599 --> 00:00:34,290
high school I think this was a torque on

8
00:00:27,669 --> 00:00:36,700
seven we've gave a talk about tor hidden

9
00:00:34,290 --> 00:00:39,190
the unknown it's unknown what he gave a

10
00:00:36,700 --> 00:00:43,660
talk about he mentioned he was really

11
00:00:39,190 --> 00:00:46,660
high on LSD about halfway through and it

12
00:00:43,660 --> 00:00:49,050
was a talk it really went from topic to

13
00:00:46,660 --> 00:00:53,410
topic there was accusations there was

14
00:00:49,050 --> 00:00:55,209
some technical talk of Tor and he had a

15
00:00:53,410 --> 00:00:57,550
hype man in the back that would be just

16
00:00:55,210 --> 00:01:01,960
like a Kate like hat backwards for on

17
00:00:57,550 --> 00:01:03,430
favor fave like yeah yeah it was really

18
00:01:01,960 --> 00:01:06,329
great it was a great talk but I I

19
00:01:03,430 --> 00:01:09,729
wondered you know as he got into his

20
00:01:06,329 --> 00:01:12,818
description of how he had come to give

21
00:01:09,729 --> 00:01:14,710
this talk and why this talk was was

22
00:01:12,819 --> 00:01:18,100
important which didn't make any sense at

23
00:01:14,710 --> 00:01:24,669
all i i wondered like what kind of

24
00:01:18,100 --> 00:01:27,399
conference would possibly host such an

25
00:01:24,670 --> 00:01:30,399
event and so when I had my own stream of

26
00:01:27,399 --> 00:01:34,359
consciousness based presentation I knew

27
00:01:30,399 --> 00:01:36,729
who to take it to anyway this is about

28
00:01:34,359 --> 00:01:40,270
symbolic execution which I have been I

29
00:01:36,729 --> 00:01:43,060
have been dealing with now for oh I

30
00:01:40,270 --> 00:01:45,009
would say the past three years I'm sure

31
00:01:43,060 --> 00:01:48,459
many of you here have heard of symbolic

32
00:01:45,009 --> 00:01:50,229
execution maybe even part of like you

33
00:01:48,459 --> 00:01:53,920
know a more broad temperamentally

34
00:01:50,229 --> 00:01:55,479
aligned dynamic paint analysis or maybe

35
00:01:53,920 --> 00:01:57,249
like particular pieces of tooling like

36
00:01:55,479 --> 00:02:00,039
when the cyber Grand Challenge happened

37
00:01:57,249 --> 00:02:01,958
a tool called anger came out of that and

38
00:02:00,039 --> 00:02:08,259
that's been been of considerable

39
00:02:01,959 --> 00:02:11,530
interest and just going over you know

40
00:02:08,258 --> 00:02:12,899
what symbolic execution is you know

41
00:02:11,530 --> 00:02:14,550
rather than

42
00:02:12,900 --> 00:02:17,340
vague description of it it's really

43
00:02:14,550 --> 00:02:20,040
quite simple you provide symbols rather

44
00:02:17,340 --> 00:02:22,290
than concrete input as arguments to

45
00:02:20,040 --> 00:02:25,040
functions and there's a variety of ways

46
00:02:22,290 --> 00:02:27,810
that you can manipulate these symbols

47
00:02:25,040 --> 00:02:31,560
very very common

48
00:02:27,810 --> 00:02:35,459
if antiquated method is to supply some

49
00:02:31,560 --> 00:02:38,010
kind of transformation some description

50
00:02:35,459 --> 00:02:39,630
of what a transformation entails on each

51
00:02:38,010 --> 00:02:41,370
symbolic variable and then as you go

52
00:02:39,630 --> 00:02:44,220
through the program just as if you were

53
00:02:41,370 --> 00:02:46,860
running in an emulator you make a note

54
00:02:44,220 --> 00:02:49,530
of that again very similar to dynamic

55
00:02:46,860 --> 00:02:51,090
taint analysis once you're at the end of

56
00:02:49,530 --> 00:02:54,690
that the end of that being some

57
00:02:51,090 --> 00:02:58,200
arbitrary slice of the time that it took

58
00:02:54,690 --> 00:03:00,180
for a program to get from either you

59
00:02:58,200 --> 00:03:03,290
know one basic block to another or from

60
00:03:00,180 --> 00:03:08,780
you know some wall clock time to another

61
00:03:03,290 --> 00:03:10,260
you can create the set of

62
00:03:08,780 --> 00:03:12,390
transformations that happen to that

63
00:03:10,260 --> 00:03:14,099
variable and then run that through

64
00:03:12,390 --> 00:03:16,488
something like a Sat solver an SMT

65
00:03:14,099 --> 00:03:18,660
solver some general-purpose solver for

66
00:03:16,489 --> 00:03:20,880
determining what input yields what

67
00:03:18,660 --> 00:03:23,549
output which if you're writing computer

68
00:03:20,880 --> 00:03:25,859
exploits you know that's critical like

69
00:03:23,549 --> 00:03:27,930
that's a that's a huge feature if you

70
00:03:25,859 --> 00:03:30,120
can determine what do I need to provide

71
00:03:27,930 --> 00:03:33,030
to this function as input in order to

72
00:03:30,120 --> 00:03:35,220
get it to be in this state if that state

73
00:03:33,030 --> 00:03:38,340
is even possible to be in and even more

74
00:03:35,220 --> 00:03:43,620
broadly like there are tools that exist

75
00:03:38,340 --> 00:03:45,750
that can make they can produce a general

76
00:03:43,620 --> 00:03:49,859
memory model of a computer program and

77
00:03:45,750 --> 00:03:52,410
that memory model is subject to all

78
00:03:49,859 --> 00:03:53,880
kinds of interesting restrictions about

79
00:03:52,410 --> 00:03:57,350
what kinds of things it could handle but

80
00:03:53,880 --> 00:04:01,350
in general it allows you to work with

81
00:03:57,350 --> 00:04:03,780
the most basic case of here's a sized

82
00:04:01,350 --> 00:04:05,940
allocation I have somehow or another

83
00:04:03,780 --> 00:04:08,000
gotten the ability to write out of the

84
00:04:05,940 --> 00:04:11,010
boundaries of this sized allocation and

85
00:04:08,000 --> 00:04:14,340
that's a bug tell me about any condition

86
00:04:11,010 --> 00:04:17,039
that that can happen in either in tandem

87
00:04:14,340 --> 00:04:18,600
with a fuzzer or through you know some

88
00:04:17,039 --> 00:04:21,659
some mechanism like I was discussing

89
00:04:18,600 --> 00:04:23,340
earlier I'm not gonna talk too much

90
00:04:21,659 --> 00:04:27,090
about the history I originally intended

91
00:04:23,340 --> 00:04:30,239
this talk to be you know full

92
00:04:27,090 --> 00:04:32,280
complete understanding of how symbolic

93
00:04:30,240 --> 00:04:34,230
execution works and what it what it

94
00:04:32,280 --> 00:04:37,440
entails and that was a little bit

95
00:04:34,230 --> 00:04:42,080
optimistic this this is just the

96
00:04:37,440 --> 00:04:45,660
original is the paper called select and

97
00:04:42,080 --> 00:04:47,609
select just you know sentence or two

98
00:04:45,660 --> 00:04:50,120
told you everything that I just spent

99
00:04:47,610 --> 00:04:52,620
the past five or ten minutes doing

100
00:04:50,120 --> 00:04:53,970
symbolic execution proceeds as a normal

101
00:04:52,620 --> 00:04:56,400
execution except that values may be

102
00:04:53,970 --> 00:04:58,680
symbolic formulas over the input symbols

103
00:04:56,400 --> 00:05:01,440
just like solving for x with you know

104
00:04:58,680 --> 00:05:03,750
your algebra problem from from middle

105
00:05:01,440 --> 00:05:05,940
school high school whatever you can

106
00:05:03,750 --> 00:05:10,680
solve for X with a little bit more

107
00:05:05,940 --> 00:05:13,229
complex rules just instead of the the

108
00:05:10,680 --> 00:05:16,229
rules of equality and transitivity and

109
00:05:13,229 --> 00:05:19,409
all that you you have the rules of x86

110
00:05:16,229 --> 00:05:23,659
or you know C standard whatever whatever

111
00:05:19,410 --> 00:05:26,340
is appropriate all right select a

112
00:05:23,660 --> 00:05:29,400
fantastic computer program really

113
00:05:26,340 --> 00:05:32,070
groundbreaking and paper called effigy

114
00:05:29,400 --> 00:05:33,929
came about which for reasons that are

115
00:05:32,070 --> 00:05:38,610
some combination of politics and chance

116
00:05:33,930 --> 00:05:40,380
takes off and this methodology of

117
00:05:38,610 --> 00:05:44,010
symbolic execution remains influential

118
00:05:40,380 --> 00:05:46,710
in program verification for years but it

119
00:05:44,010 --> 00:05:50,360
takes a few more until computers are

120
00:05:46,710 --> 00:05:55,799
fast enough and the state of research is

121
00:05:50,360 --> 00:06:00,720
at the point where it is being applied

122
00:05:55,800 --> 00:06:03,900
by non academics to the question of can

123
00:06:00,720 --> 00:06:05,639
we find exploitable vulnerabilities and

124
00:06:03,900 --> 00:06:08,429
computer programs using symbolic

125
00:06:05,639 --> 00:06:10,470
execution and there's been a lot of

126
00:06:08,430 --> 00:06:13,560
doubts about whether this is a feasible

127
00:06:10,470 --> 00:06:17,070
path forward I mean I know that ELQ him

128
00:06:13,560 --> 00:06:20,430
tough who's the author of AFL as well as

129
00:06:17,070 --> 00:06:22,830
puff if you've ever used that you know

130
00:06:20,430 --> 00:06:25,979
he he basically ground it down and said

131
00:06:22,830 --> 00:06:28,080
this will never be used to find any

132
00:06:25,979 --> 00:06:31,530
non-trivial number of vulnerabilities in

133
00:06:28,080 --> 00:06:32,669
real computer systems and I think I'll

134
00:06:31,530 --> 00:06:35,429
be happy to tell you that I actually

135
00:06:32,669 --> 00:06:38,789
show off a few vulnerabilities including

136
00:06:35,430 --> 00:06:41,320
one zero day so get out your cameras

137
00:06:38,790 --> 00:06:44,560
[Music]

138
00:06:41,320 --> 00:06:46,300
and it's it is indeed difficult and it's

139
00:06:44,560 --> 00:06:48,520
a much different procedure than fuzzing

140
00:06:46,300 --> 00:06:52,480
but I think that at the end of this talk

141
00:06:48,520 --> 00:06:54,909
you'll have the power to work with a lot

142
00:06:52,480 --> 00:06:57,580
of these tools like CNBC CLE whatever

143
00:06:54,910 --> 00:07:02,320
the case may be and find and exploit a

144
00:06:57,580 --> 00:07:03,940
very basic stack or heap overflow before

145
00:07:02,320 --> 00:07:07,390
we get into that you know why should you

146
00:07:03,940 --> 00:07:10,870
use a you know tool that employs

147
00:07:07,390 --> 00:07:14,880
symbolic analysis or or more abstractly

148
00:07:10,870 --> 00:07:19,360
abstract analysis of computer programs

149
00:07:14,880 --> 00:07:21,760
you know it's it's tough to say I mean

150
00:07:19,360 --> 00:07:24,700
you always will have manual analysis

151
00:07:21,760 --> 00:07:27,700
given sufficient focus will be superior

152
00:07:24,700 --> 00:07:31,539
to any other form of analysis that I can

153
00:07:27,700 --> 00:07:34,180
foresee in the near future but a tool

154
00:07:31,540 --> 00:07:37,240
like CLE is gonna be able to give you a

155
00:07:34,180 --> 00:07:40,840
very fine grained analysis of what

156
00:07:37,240 --> 00:07:43,750
conditions can be systematically proper

157
00:07:40,840 --> 00:07:47,200
can be problematic and what can be

158
00:07:43,750 --> 00:07:49,870
detected and what kinds of conditions

159
00:07:47,200 --> 00:07:55,000
can be detected that result in whatever

160
00:07:49,870 --> 00:07:59,800
memory corruption or memory leaks

161
00:07:55,000 --> 00:08:04,000
however it's really slow though I can

162
00:07:59,800 --> 00:08:07,540
tell you that even tracing through some

163
00:08:04,000 --> 00:08:09,190
of the variables that I had in Erlang

164
00:08:07,540 --> 00:08:10,240
the Erlang runtime system is one of the

165
00:08:09,190 --> 00:08:13,390
vulnerabilities I'm gonna discuss

166
00:08:10,240 --> 00:08:15,580
finding here you know obviously Erlang

167
00:08:13,390 --> 00:08:19,419
is interpreting computer programming

168
00:08:15,580 --> 00:08:22,120
language it's you know there's bytecode

169
00:08:19,420 --> 00:08:24,700
instructions and then it calls out to C

170
00:08:22,120 --> 00:08:26,680
programs and tracing the value of a

171
00:08:24,700 --> 00:08:29,200
variable through early I mean it took

172
00:08:26,680 --> 00:08:31,480
overnight before I was able to see this

173
00:08:29,200 --> 00:08:32,979
relatively modest set of transformations

174
00:08:31,480 --> 00:08:36,840
that were applied to a particular

175
00:08:32,979 --> 00:08:40,390
variable within the bean virtual machine

176
00:08:36,840 --> 00:08:42,669
I got I told you guys a little bit about

177
00:08:40,390 --> 00:08:45,160
what got me interested in this again

178
00:08:42,669 --> 00:08:47,319
like lots of people on IRC will tell you

179
00:08:45,160 --> 00:08:48,969
that it's useless and and they don't

180
00:08:47,320 --> 00:08:50,290
usually have very good reasons for why

181
00:08:48,970 --> 00:08:53,709
it's useless I don't have a background

182
00:08:50,290 --> 00:08:56,230
in sass solvers or symbolic execution or

183
00:08:53,709 --> 00:08:59,949
or anything like that I I come from the

184
00:08:56,230 --> 00:09:01,809
world of finding vulnerabilities memory

185
00:08:59,949 --> 00:09:04,349
corruption bugs and you know

186
00:09:01,809 --> 00:09:06,490
corresponding exploits in those bugs

187
00:09:04,350 --> 00:09:10,839
what is this new symbolic execution

188
00:09:06,490 --> 00:09:12,970
thing how can it benefit me I did a ton

189
00:09:10,839 --> 00:09:16,089
of work to try to build myself up to the

190
00:09:12,970 --> 00:09:18,069
point where I could you know have a firm

191
00:09:16,089 --> 00:09:19,839
grasp of what is entailed in symbolic

192
00:09:18,069 --> 00:09:20,410
execution I actually wrote my own Sat

193
00:09:19,839 --> 00:09:23,800
solver

194
00:09:20,410 --> 00:09:26,290
I watched video lectures I even wrote my

195
00:09:23,800 --> 00:09:29,229
own like what you might call a lifter

196
00:09:26,290 --> 00:09:31,569
which is like a basic highly idealized

197
00:09:29,230 --> 00:09:34,689
description of the behavior of x86

198
00:09:31,569 --> 00:09:36,579
instructions which is really really

199
00:09:34,689 --> 00:09:38,920
quite quite challenging like there are

200
00:09:36,579 --> 00:09:43,508
hundreds of x86 instructions and once

201
00:09:38,920 --> 00:09:45,910
you think you know how complex x86 is

202
00:09:43,509 --> 00:09:47,920
like you don't yet know how complex no

203
00:09:45,910 --> 00:09:50,759
matter how complex you've said it to be

204
00:09:47,920 --> 00:09:52,990
it is yet more complex than that and

205
00:09:50,759 --> 00:09:54,309
once you you think you're at the limit

206
00:09:52,990 --> 00:09:56,800
then you haven't yet considered like

207
00:09:54,309 --> 00:10:00,730
wrap or shift left or all these other

208
00:09:56,800 --> 00:10:05,319
instructions that are just bizarrely

209
00:10:00,730 --> 00:10:07,509
extremely complex and so by watching

210
00:10:05,319 --> 00:10:11,620
this talk you can all avoid the hassle

211
00:10:07,509 --> 00:10:15,720
of doing this and you won't ever need to

212
00:10:11,620 --> 00:10:17,889
write a description of the

213
00:10:15,720 --> 00:10:22,089
transformations that particular x86

214
00:10:17,889 --> 00:10:25,709
instructions entail so that when you

215
00:10:22,089 --> 00:10:29,379
write your Pete race-based what a

216
00:10:25,709 --> 00:10:31,569
description of the state changing of the

217
00:10:29,379 --> 00:10:38,759
state of a register you can just say no

218
00:10:31,569 --> 00:10:41,649
that's that's useless never mind

219
00:10:38,759 --> 00:10:43,990
so the very first vulnerability I found

220
00:10:41,649 --> 00:10:46,240
with this method and I think I'm gonna

221
00:10:43,990 --> 00:10:47,799
go a little bit into how I I found this

222
00:10:46,240 --> 00:10:50,559
but just as a description of what it is

223
00:10:47,799 --> 00:10:53,350
I said that here it's this is a CMYK

224
00:10:50,559 --> 00:10:56,230
color space bug but this is actually was

225
00:10:53,350 --> 00:11:00,600
a bug in the decoding of the Huffman

226
00:10:56,230 --> 00:11:04,269
tables this was in the plan nine JPEG

227
00:11:00,600 --> 00:11:05,559
library and plan nine I don't know if

228
00:11:04,269 --> 00:11:07,480
you guys have heard of it it's a

229
00:11:05,559 --> 00:11:09,550
research operating system produced by

230
00:11:07,480 --> 00:11:12,880
the labs a lot of people who worked on

231
00:11:09,550 --> 00:11:16,000
it later became really well-known Rob

232
00:11:12,880 --> 00:11:18,910
Pike is intimately tied with going and

233
00:11:16,000 --> 00:11:19,360
Ken Thomson who you know UNIX all that

234
00:11:18,910 --> 00:11:21,969
kind of stuff

235
00:11:19,360 --> 00:11:23,380
so what I mean to say when I when I

236
00:11:21,970 --> 00:11:24,790
bring up all of these rather famous

237
00:11:23,380 --> 00:11:28,389
people is that it's a generally a very

238
00:11:24,790 --> 00:11:31,990
high-quality codebase and um despite a

239
00:11:28,389 --> 00:11:34,420
few nebulous conditions I think if you

240
00:11:31,990 --> 00:11:38,199
were to manually review plan nine it

241
00:11:34,420 --> 00:11:39,399
would not be easy and furthermore if you

242
00:11:38,199 --> 00:11:46,540
wanted to write a fuzzer

243
00:11:39,399 --> 00:11:48,490
I mean you can't really use AFL you're

244
00:11:46,540 --> 00:11:51,130
you're working in a system where you

245
00:11:48,490 --> 00:11:54,660
either need to use a port of the plan

246
00:11:51,130 --> 00:11:58,779
nine utilities to a POSIX system or you

247
00:11:54,660 --> 00:12:05,170
port AFL to some 90s research operating

248
00:11:58,779 --> 00:12:08,139
system so what I did was just as I as I

249
00:12:05,170 --> 00:12:11,410
described before I did this did this

250
00:12:08,139 --> 00:12:14,860
manually and that means breaking out an

251
00:12:11,410 --> 00:12:17,860
SMT solver and hunkering over the Intel

252
00:12:14,860 --> 00:12:21,279
manual and you basically try to write

253
00:12:17,860 --> 00:12:24,430
something that describes what is the

254
00:12:21,279 --> 00:12:26,050
behavior of each x86 instruction and you

255
00:12:24,430 --> 00:12:28,089
don't need to do every instruction of

256
00:12:26,050 --> 00:12:31,870
course there's a huge huge swathes of

257
00:12:28,089 --> 00:12:33,699
the set of x86 instructions that are not

258
00:12:31,870 --> 00:12:36,490
going to be used and furthermore you

259
00:12:33,699 --> 00:12:37,870
know the plan nine x86 compiler doesn't

260
00:12:36,490 --> 00:12:39,699
even recognize and so it could never

261
00:12:37,870 --> 00:12:44,290
omit as the as a consequence of

262
00:12:39,699 --> 00:12:46,180
generating object code you do need to do

263
00:12:44,290 --> 00:12:49,089
everything that's within you know the

264
00:12:46,180 --> 00:12:53,769
program and that's still again hundreds

265
00:12:49,089 --> 00:12:56,740
of instructions and so this is actually

266
00:12:53,769 --> 00:12:58,930
I mean it's kind of ambiguous when I'm

267
00:12:56,740 --> 00:13:01,720
describing it to you here now but what

268
00:12:58,930 --> 00:13:04,719
you're ultimately doing here is starting

269
00:13:01,720 --> 00:13:07,300
with the state of a computer program the

270
00:13:04,720 --> 00:13:09,430
state meaning not even necessarily the

271
00:13:07,300 --> 00:13:11,740
memory but what are the registers at

272
00:13:09,430 --> 00:13:14,260
this particular point and given some

273
00:13:11,740 --> 00:13:19,600
highly idealized description of memory

274
00:13:14,260 --> 00:13:21,759
which you can do in an SMT solver give

275
00:13:19,600 --> 00:13:25,389
me

276
00:13:21,759 --> 00:13:27,459
give me the set of things the set of

277
00:13:25,389 --> 00:13:29,739
inputs that will cause this particular

278
00:13:27,459 --> 00:13:31,899
register to yield this particular output

279
00:13:29,739 --> 00:13:33,429
after these transformations have been

280
00:13:31,899 --> 00:13:35,019
applied to it and so if you're doing a

281
00:13:33,429 --> 00:13:36,279
loop or something like that you know you

282
00:13:35,019 --> 00:13:38,439
just apply every one of those

283
00:13:36,279 --> 00:13:39,999
transformations and this big big list of

284
00:13:38,439 --> 00:13:42,549
transformations to every one of the

285
00:13:39,999 --> 00:13:45,249
registers and that's a very very narrow

286
00:13:42,549 --> 00:13:47,889
case of what symbolic execution can do

287
00:13:45,249 --> 00:13:49,839
that's that's like you know that

288
00:13:47,889 --> 00:13:55,709
basically required me to have some

289
00:13:49,839 --> 00:13:58,269
high-level insight about Jesus about the

290
00:13:55,709 --> 00:14:00,189
nature of what a computer vulnerability

291
00:13:58,269 --> 00:14:03,449
is and how computer vulnerability can be

292
00:14:00,189 --> 00:14:06,639
exploited so then I'm kind of you know

293
00:14:03,449 --> 00:14:09,639
just doing the mechanics of how do I get

294
00:14:06,639 --> 00:14:12,989
from what I suspect is a vulnerability

295
00:14:09,639 --> 00:14:17,619
to what is certainly exploitable using

296
00:14:12,989 --> 00:14:20,049
you know a Sat solver and then I would

297
00:14:17,619 --> 00:14:23,170
not recommend doing it but I do mention

298
00:14:20,049 --> 00:14:25,389
it because it is possible to do and if

299
00:14:23,170 --> 00:14:27,549
you have any friends that run plan 9 you

300
00:14:25,389 --> 00:14:32,829
can go check this function out I have on

301
00:14:27,549 --> 00:14:35,100
my github an image that generates that's

302
00:14:32,829 --> 00:14:39,189
a proof of concept for this and you can

303
00:14:35,100 --> 00:14:40,779
you can pop their box if you if you were

304
00:14:39,189 --> 00:14:47,740
running into any corporate plan 9

305
00:14:40,779 --> 00:14:49,629
networks so after I dealt with plan 9 I

306
00:14:47,740 --> 00:14:53,499
I I don't want to turn this into a

307
00:14:49,629 --> 00:14:56,160
biography but I do want to mention that

308
00:14:53,499 --> 00:14:58,869
a reasonable amount of time

309
00:14:56,160 --> 00:15:01,059
separated the the creation of this

310
00:14:58,869 --> 00:15:03,970
vulnerability in plan or the creation is

311
00:15:01,059 --> 00:15:05,379
exploited for plan 9 and the research

312
00:15:03,970 --> 00:15:07,869
that I was doing in the Erlang virtual

313
00:15:05,379 --> 00:15:09,669
machine and does everyone here know what

314
00:15:07,869 --> 00:15:12,490
Erlang is or have you heard of Erlang

315
00:15:09,669 --> 00:15:15,910
okay it's computer programming language

316
00:15:12,490 --> 00:15:19,529
I think that's suffice to say interpret

317
00:15:15,910 --> 00:15:21,759
it as I mentioned before very very large

318
00:15:19,529 --> 00:15:24,309
source code I mean it's been built up

319
00:15:21,759 --> 00:15:26,110
over years it's a real computer program

320
00:15:24,309 --> 00:15:28,689
and I think that it's not crazy to

321
00:15:26,110 --> 00:15:30,249
imagine that it is within an order of

322
00:15:28,689 --> 00:15:33,009
magnitude of some other computer

323
00:15:30,249 --> 00:15:34,390
programs that you might want to evaluate

324
00:15:33,009 --> 00:15:39,010
like

325
00:15:34,390 --> 00:15:46,180
whatever OpenOffice or Adobe or word a

326
00:15:39,010 --> 00:15:50,200
web browser so the technique that I took

327
00:15:46,180 --> 00:15:53,199
with this one was to you know try a

328
00:15:50,200 --> 00:15:56,610
bunch of different context accusin

329
00:15:53,200 --> 00:16:00,400
engine symbolic execution engines

330
00:15:56,610 --> 00:16:03,040
dynamic taint analysis to try to figure

331
00:16:00,400 --> 00:16:06,839
out where in Erlang might be the

332
00:16:03,040 --> 00:16:10,719
greatest source of vulnerabilities and

333
00:16:06,839 --> 00:16:12,370
in the end I to find this bug I used a

334
00:16:10,720 --> 00:16:14,260
tool called Klee which I'm going to get

335
00:16:12,370 --> 00:16:16,420
into a little bit later it's a tool

336
00:16:14,260 --> 00:16:22,029
produced by University of Stanford I

337
00:16:16,420 --> 00:16:23,680
believe and a critical aspect of

338
00:16:22,029 --> 00:16:26,830
symbolic execution that I didn't get

339
00:16:23,680 --> 00:16:29,439
into in the previous description of plan

340
00:16:26,830 --> 00:16:32,410
nine because it was such a narrow view

341
00:16:29,440 --> 00:16:36,820
into the behavior of the JPEG parser

342
00:16:32,410 --> 00:16:39,579
within plan nine you need to if you are

343
00:16:36,820 --> 00:16:42,250
evaluating a C program for example you

344
00:16:39,580 --> 00:16:44,920
need to prune out everything that is not

345
00:16:42,250 --> 00:16:46,630
conceivably exploitable or that you

346
00:16:44,920 --> 00:16:52,599
don't believe could be reasonably

347
00:16:46,630 --> 00:16:55,000
exploited by some intelligent human III

348
00:16:52,600 --> 00:16:57,279
IDE and the intuition for this is

349
00:16:55,000 --> 00:16:59,170
totally a result of writing software and

350
00:16:57,279 --> 00:17:00,370
breaking other people's software and I

351
00:16:59,170 --> 00:17:02,260
don't know if there's anything I could

352
00:17:00,370 --> 00:17:04,869
give you that could tell you like here's

353
00:17:02,260 --> 00:17:07,480
what you need to look for beyond the

354
00:17:04,869 --> 00:17:11,379
basics of light you know if they're not

355
00:17:07,480 --> 00:17:14,829
doing any sized allocations and it's

356
00:17:11,380 --> 00:17:17,350
just arithmetic that doesn't control the

357
00:17:14,829 --> 00:17:20,819
behavior of any later allocations then

358
00:17:17,349 --> 00:17:24,099
you can forget that just as an example

359
00:17:20,819 --> 00:17:26,409
you need to hone in on what you think is

360
00:17:24,099 --> 00:17:29,110
really hairy code extract that code out

361
00:17:26,410 --> 00:17:32,860
into some place where you can run a

362
00:17:29,110 --> 00:17:34,330
simple a simple text input against that

363
00:17:32,860 --> 00:17:35,830
bug just like you were if you were doing

364
00:17:34,330 --> 00:17:38,860
a fuzzer right like you would want to

365
00:17:35,830 --> 00:17:40,899
create a test harness for some set of

366
00:17:38,860 --> 00:17:42,459
code that you were interested in and

367
00:17:40,900 --> 00:17:45,160
it's the same with symbolic execution

368
00:17:42,460 --> 00:17:46,770
except maybe a little bit more refined

369
00:17:45,160 --> 00:17:51,900
in what you

370
00:17:46,770 --> 00:17:54,900
to be extracted so I took out a piece of

371
00:17:51,900 --> 00:17:57,660
the regular expression matching code the

372
00:17:54,900 --> 00:18:01,230
bug is actually in rigor compiled

373
00:17:57,660 --> 00:18:04,050
regular expressions within Erlang and I

374
00:18:01,230 --> 00:18:08,010
did just this I took out a huge swath of

375
00:18:04,050 --> 00:18:11,399
it used a piece of software called Miffy

376
00:18:08,010 --> 00:18:20,010
which a native native function in in

377
00:18:11,400 --> 00:18:23,700
Erlang is called NIF and you you replace

378
00:18:20,010 --> 00:18:25,350
all of the elements of it that are you

379
00:18:23,700 --> 00:18:28,320
have immediate control over as a user

380
00:18:25,350 --> 00:18:32,250
and replace here means very simply let's

381
00:18:28,320 --> 00:18:34,260
see here sorry I don't have included

382
00:18:32,250 --> 00:18:37,290
here but clean make symbolic that's a

383
00:18:34,260 --> 00:18:40,740
function name clean make symbolic is a

384
00:18:37,290 --> 00:18:44,610
tool that indicates to Cle I'm going to

385
00:18:40,740 --> 00:18:48,450
want you to treat this as if you had

386
00:18:44,610 --> 00:18:50,639
control over its its value and that may

387
00:18:48,450 --> 00:18:53,040
not be true and you can subject CLE to

388
00:18:50,640 --> 00:18:54,690
various assumptions about what kinds of

389
00:18:53,040 --> 00:18:58,250
values you can provide if that's if

390
00:18:54,690 --> 00:19:01,580
that's something that you need to do but

391
00:18:58,250 --> 00:19:04,110
in the end I think as I as I told you I

392
00:19:01,580 --> 00:19:05,699
found a actually I think I found the

393
00:19:04,110 --> 00:19:08,699
very first remotely exploitable

394
00:19:05,700 --> 00:19:12,150
vulnerability in Erlang I don't know if

395
00:19:08,700 --> 00:19:15,660
that's true or not I the first cv4 I

396
00:19:12,150 --> 00:19:19,250
didn't register the CVE and so I I have

397
00:19:15,660 --> 00:19:21,360
I have not taken a serious look into it

398
00:19:19,250 --> 00:19:24,030
and I also found some vulnerabilities in

399
00:19:21,360 --> 00:19:26,310
pcre that were totally unrelated as well

400
00:19:24,030 --> 00:19:28,139
as found some vulnerabilities that had

401
00:19:26,310 --> 00:19:30,030
already been fixed in pcre that were

402
00:19:28,140 --> 00:19:31,800
we're fixed upstream pcr you by the way

403
00:19:30,030 --> 00:19:34,350
is Perl compatible regular expressions

404
00:19:31,800 --> 00:19:40,470
it's a widely used regular expressions

405
00:19:34,350 --> 00:19:42,179
library okay so how do you how do you do

406
00:19:40,470 --> 00:19:43,730
this like where if you want to get your

407
00:19:42,180 --> 00:19:45,960
feet wet where do you get started

408
00:19:43,730 --> 00:19:47,940
there's three tools that I would

409
00:19:45,960 --> 00:19:50,280
recommend to you and once you start

410
00:19:47,940 --> 00:19:52,890
taking a look at these I think you will

411
00:19:50,280 --> 00:19:55,260
immediately branch out into all of the

412
00:19:52,890 --> 00:19:58,440
wide world of other things that

413
00:19:55,260 --> 00:20:01,500
an abstract analysis of computer

414
00:19:58,440 --> 00:20:03,390
programs is concerned with CNBC CLE

415
00:20:01,500 --> 00:20:05,850
Manticore I haven't used Manticore

416
00:20:03,390 --> 00:20:07,830
nearly as much it's something new by

417
00:20:05,850 --> 00:20:10,830
trail of bits or something like that

418
00:20:07,830 --> 00:20:12,179
I I can't I don't include any

419
00:20:10,830 --> 00:20:13,649
information about it but I have heard

420
00:20:12,180 --> 00:20:16,560
really great things about it

421
00:20:13,650 --> 00:20:18,540
um CNBC any CLE I have used extensively

422
00:20:16,560 --> 00:20:22,139
though and so I'm gonna try to show you

423
00:20:18,540 --> 00:20:24,930
guys what exploiting a basic like you

424
00:20:22,140 --> 00:20:27,180
know Aleph one smash in the stack for

425
00:20:24,930 --> 00:20:33,680
fun and profit style vulnerability looks

426
00:20:27,180 --> 00:20:37,470
like inside of these two tools this is

427
00:20:33,680 --> 00:20:42,230
CB mc2 from Oxford as part of the seif

428
00:20:37,470 --> 00:20:46,860
prove ourselves primarily interested in

429
00:20:42,230 --> 00:20:48,570
program correctness and verification but

430
00:20:46,860 --> 00:20:51,959
it does indeed have a lot of facilities

431
00:20:48,570 --> 00:20:54,600
for the conditions that I described

432
00:20:51,960 --> 00:20:58,500
earlier which basically are writing

433
00:20:54,600 --> 00:21:02,189
outside of a region that you should be

434
00:20:58,500 --> 00:21:04,920
able to write outside of um so if you if

435
00:21:02,190 --> 00:21:10,500
you create a new C file with this simple

436
00:21:04,920 --> 00:21:12,750
you know overflow oops obviously you

437
00:21:10,500 --> 00:21:19,770
know 16 byte buffer overflow no

438
00:21:12,750 --> 00:21:21,870
unchecked string copy if you run CNBC on

439
00:21:19,770 --> 00:21:25,230
this alone which is just you know dot

440
00:21:21,870 --> 00:21:28,530
slash CNBC provided trace unwinding

441
00:21:25,230 --> 00:21:31,230
pointer check if you call this with even

442
00:21:28,530 --> 00:21:32,520
without a any kind of special indication

443
00:21:31,230 --> 00:21:36,630
that it should check this it'll let you

444
00:21:32,520 --> 00:21:40,080
know hey this is something that could be

445
00:21:36,630 --> 00:21:42,270
very bad and this can be a little bit

446
00:21:40,080 --> 00:21:47,850
tricky in bigger programs because it

447
00:21:42,270 --> 00:21:50,010
looks at the translation unit of a c

448
00:21:47,850 --> 00:21:53,340
program when it is making these

449
00:21:50,010 --> 00:21:55,650
judgments about where the checking on

450
00:21:53,340 --> 00:21:57,209
variables is and sometimes that's not

451
00:21:55,650 --> 00:21:58,470
the case so sometimes there's actually

452
00:21:57,210 --> 00:22:00,750
you know just like we're calling

453
00:21:58,470 --> 00:22:03,180
overflow here like overflow is safe if

454
00:22:00,750 --> 00:22:07,830
we check the length of the string prior

455
00:22:03,180 --> 00:22:09,059
to passing in the string argument oh you

456
00:22:07,830 --> 00:22:12,918
mean safe in quo

457
00:22:09,059 --> 00:22:12,918
it's theoretically okay

458
00:22:13,159 --> 00:22:19,110
however the check for the safety of that

459
00:22:17,039 --> 00:22:22,769
property can occur anywhere in a

460
00:22:19,110 --> 00:22:24,178
computer program but CNBC isn't

461
00:22:22,769 --> 00:22:25,379
necessarily gonna be aware of that

462
00:22:24,179 --> 00:22:28,909
because it doesn't have high-level

463
00:22:25,379 --> 00:22:31,139
heuristics about that kind of thing but

464
00:22:28,909 --> 00:22:33,059
the vast majority of vulnerabilities

465
00:22:31,139 --> 00:22:34,229
don't fit into that category so you're

466
00:22:33,059 --> 00:22:36,629
going to be great if you look at

467
00:22:34,230 --> 00:22:40,259
something that you suspect is some Harry

468
00:22:36,629 --> 00:22:42,209
C code it will quickly let you know with

469
00:22:40,259 --> 00:22:44,789
a whole lot less false positives than

470
00:22:42,210 --> 00:22:46,139
something like rats or IDs for I don't

471
00:22:44,789 --> 00:22:49,379
know what the current state of the art

472
00:22:46,139 --> 00:22:51,508
for like static analysis is or digital I

473
00:22:49,379 --> 00:22:56,100
have never used it but I assume some

474
00:22:51,509 --> 00:22:57,600
people here have and it's very similar

475
00:22:56,100 --> 00:23:00,119
with clean here's here's clean a

476
00:22:57,600 --> 00:23:03,090
symbolic with clean makes with CLE

477
00:23:00,119 --> 00:23:05,759
you're gonna want to indicate hey I'm

478
00:23:03,090 --> 00:23:11,730
passing in a symbolic value which is

479
00:23:05,759 --> 00:23:13,409
string to overflow and not only is this

480
00:23:11,730 --> 00:23:15,419
symbolic in the terms of the content

481
00:23:13,409 --> 00:23:19,169
it's symbolic in terms of the length up

482
00:23:15,419 --> 00:23:22,919
to this value and you can do that in two

483
00:23:19,169 --> 00:23:24,659
ways you can indicate with with just

484
00:23:22,919 --> 00:23:27,299
like a loop like you can create a

485
00:23:24,659 --> 00:23:31,769
statically sized string and say for

486
00:23:27,299 --> 00:23:33,929
every value of this you can just loop

487
00:23:31,769 --> 00:23:36,779
over and say we make symbolic of this

488
00:23:33,929 --> 00:23:41,009
particular value or clean make symbolic

489
00:23:36,779 --> 00:23:43,320
actually provides a facility for passing

490
00:23:41,009 --> 00:23:47,820
an additional argument with varargs for

491
00:23:43,320 --> 00:23:51,928
hey this is a unsigned buffer let me let

492
00:23:47,820 --> 00:23:54,418
me know what what you think of it and

493
00:23:51,929 --> 00:23:57,559
Klee if you run it Klee works a little

494
00:23:54,419 --> 00:24:00,659
bit differently you have to compile the

495
00:23:57,559 --> 00:24:05,279
code that you're using with LLVM clang

496
00:24:00,659 --> 00:24:07,230
rather and then you run Klee on the

497
00:24:05,279 --> 00:24:10,889
result of this intermediate

498
00:24:07,230 --> 00:24:13,230
representation that's produced and Klee

499
00:24:10,889 --> 00:24:15,809
gives you so much really valuable

500
00:24:13,230 --> 00:24:18,440
information but if you're just trying to

501
00:24:15,809 --> 00:24:21,539
work with something you believe has a

502
00:24:18,440 --> 00:24:22,620
stack-based buffer overflow you're gonna

503
00:24:21,539 --> 00:24:24,450
want to take a

504
00:24:22,620 --> 00:24:26,699
at the air fire air does not mean an

505
00:24:24,450 --> 00:24:30,900
errand CLE it means air is detected by

506
00:24:26,700 --> 00:24:32,460
clay and so you know cat your last clean

507
00:24:30,900 --> 00:24:34,559
analysis and you're gonna see things

508
00:24:32,460 --> 00:24:36,600
like this which this gets cut off a

509
00:24:34,559 --> 00:24:38,850
little bit here but what it says at the

510
00:24:36,600 --> 00:24:40,559
end is basically oh you know what is a

511
00:24:38,850 --> 00:24:43,799
value for this well if you provide

512
00:24:40,559 --> 00:24:46,500
string equals char of blah blah blah

513
00:24:43,799 --> 00:24:49,309
blah up to some ridiculously huge number

514
00:24:46,500 --> 00:24:53,130
you're gonna have a problem and indeed

515
00:24:49,309 --> 00:24:54,320
that would cause a segmentation fault

516
00:24:53,130 --> 00:24:59,370
[Music]

517
00:24:54,320 --> 00:25:03,299
and you can also use CLE to test for

518
00:24:59,370 --> 00:25:10,080
heap overflows as well but there is

519
00:25:03,299 --> 00:25:12,990
within CLE a simple a simple model of an

520
00:25:10,080 --> 00:25:15,049
alligator that I don't to be frank

521
00:25:12,990 --> 00:25:20,610
understand adequately to be able to

522
00:25:15,049 --> 00:25:22,200
describe to you what it's - what

523
00:25:20,610 --> 00:25:24,510
granularity is it's capable of

524
00:25:22,200 --> 00:25:26,130
understanding the behavior of blocks

525
00:25:24,510 --> 00:25:27,840
like you know you allocate a block you

526
00:25:26,130 --> 00:25:30,090
allocate an adjacent block you overwrite

527
00:25:27,840 --> 00:25:32,600
that adjacent blocks keep chunk metadata

528
00:25:30,090 --> 00:25:34,799
I don't think it has enough

529
00:25:32,600 --> 00:25:38,520
understanding to know what is gonna go

530
00:25:34,799 --> 00:25:42,809
on unless you provide the source code to

531
00:25:38,520 --> 00:25:44,070
an alligator which fi cater your your

532
00:25:42,809 --> 00:25:45,330
program has been compiled with but

533
00:25:44,070 --> 00:25:48,629
that's gonna make it a lot slower as

534
00:25:45,330 --> 00:25:50,850
well so what you're gonna do with heap

535
00:25:48,630 --> 00:25:53,070
overflows is very similar to what you're

536
00:25:50,850 --> 00:25:56,699
doing with stack overflows which is that

537
00:25:53,070 --> 00:26:00,120
you just look for a pointer into an area

538
00:25:56,700 --> 00:26:05,039
that you do not you should not control

539
00:26:00,120 --> 00:26:08,668
and what can give me that kind of of a

540
00:26:05,039 --> 00:26:12,570
value for a pointer and this is great I

541
00:26:08,669 --> 00:26:15,299
mean this this works because Klee and

542
00:26:12,570 --> 00:26:17,399
CNBC and tools like this detect buffer

543
00:26:15,299 --> 00:26:19,408
overflows and I suppose that a heap and

544
00:26:17,399 --> 00:26:23,100
a stack overflow or both part of this

545
00:26:19,409 --> 00:26:25,620
broader category of buffer overflows but

546
00:26:23,100 --> 00:26:28,110
if you're doing something against an

547
00:26:25,620 --> 00:26:30,149
alligator that relies on the behavior of

548
00:26:28,110 --> 00:26:31,709
the alligator to trigger the

549
00:26:30,149 --> 00:26:35,610
vulnerability like in this piece of code

550
00:26:31,710 --> 00:26:37,749
here where realloc doesn't actually

551
00:26:35,610 --> 00:26:40,539
doesn't actually perform a check for the

552
00:26:37,749 --> 00:26:44,470
size of the newly allocated block so it

553
00:26:40,539 --> 00:26:46,269
will take an existing block just have a

554
00:26:44,470 --> 00:26:48,460
free list that indicates oh I've just

555
00:26:46,269 --> 00:26:50,200
changed the size of this update The

556
00:26:48,460 --> 00:26:51,490
Associated heap trunk metadata you

557
00:26:50,200 --> 00:26:53,769
allocate another block

558
00:26:51,490 --> 00:26:55,690
well that block if it's within the same

559
00:26:53,769 --> 00:26:59,379
arena that is to say it's of the

560
00:26:55,690 --> 00:27:01,749
approximately the same size it will

561
00:26:59,379 --> 00:27:04,480
allocate it right next to it and so now

562
00:27:01,749 --> 00:27:06,610
you have a memory leak of what was

563
00:27:04,480 --> 00:27:08,259
previously in there you have the heap

564
00:27:06,610 --> 00:27:10,449
chunk metadata for what was previously

565
00:27:08,259 --> 00:27:12,039
in there you can change the heap chunk

566
00:27:10,450 --> 00:27:14,409
metadata for as previously in there and

567
00:27:12,039 --> 00:27:15,820
then in the original block you can

568
00:27:14,409 --> 00:27:18,700
whatever call free or something on I

569
00:27:15,820 --> 00:27:20,110
forget the exact details of whether you

570
00:27:18,700 --> 00:27:22,200
need to coalesce blocks or whether you

571
00:27:20,110 --> 00:27:24,668
need to free or what the what the

572
00:27:22,200 --> 00:27:27,039
there's always a million different ways

573
00:27:24,669 --> 00:27:28,840
to exploit allocators and there you can

574
00:27:27,039 --> 00:27:31,480
get quite sophisticated but in any case

575
00:27:28,840 --> 00:27:33,220
it doesn't matter because symbolic

576
00:27:31,480 --> 00:27:36,720
analysis wouldn't be able to tell you

577
00:27:33,220 --> 00:27:39,429
that this is the path you need to take

578
00:27:36,720 --> 00:27:41,950
so you know not to say that a fuzzer

579
00:27:39,429 --> 00:27:45,340
could either but if you're hoping for

580
00:27:41,950 --> 00:27:47,860
some really high level understanding of

581
00:27:45,340 --> 00:27:49,629
computers and you're the organization of

582
00:27:47,860 --> 00:27:54,189
a C program you're not going to get it

583
00:27:49,629 --> 00:27:58,209
you're getting a pretty low level by the

584
00:27:54,190 --> 00:28:00,279
books understanding of this allocation

585
00:27:58,210 --> 00:28:03,700
occurs outside of the region it should

586
00:28:00,279 --> 00:28:05,080
then excuse me if this right occurs

587
00:28:03,700 --> 00:28:09,879
outside of the region it should then

588
00:28:05,080 --> 00:28:12,129
that's bad and if not it's okay all

589
00:28:09,879 --> 00:28:15,070
right yeah as I mentioned before I

590
00:28:12,129 --> 00:28:19,689
couldn't figure out a way to make this

591
00:28:15,070 --> 00:28:21,039
work with a but symbolic analysis and as

592
00:28:19,690 --> 00:28:24,070
I said you often need this frying

593
00:28:21,039 --> 00:28:27,759
fine-grained model and symbolic analysis

594
00:28:24,070 --> 00:28:30,158
just cannot provide that but symbolic

595
00:28:27,759 --> 00:28:32,049
analysis will and if you get into all of

596
00:28:30,159 --> 00:28:33,999
these tools you know you have a crash

597
00:28:32,049 --> 00:28:36,029
for example just like I'm sure many of

598
00:28:33,999 --> 00:28:39,639
you have heard of the bit blaze project

599
00:28:36,029 --> 00:28:44,590
Klee has very similar facility just

600
00:28:39,639 --> 00:28:47,709
inside of the data that's generated by

601
00:28:44,590 --> 00:28:49,429
clean sorry kay test last or a CLE last

602
00:28:47,710 --> 00:28:51,260
you can run Kay test on

603
00:28:49,430 --> 00:28:56,420
and determine what happened to this

604
00:28:51,260 --> 00:28:58,820
variable prior to some crash and I don't

605
00:28:56,420 --> 00:29:00,110
know if I didn't I didn't my little

606
00:28:58,820 --> 00:29:04,450
timer here so I don't know how much time

607
00:29:00,110 --> 00:29:09,020
I have left but I am open to questions

608
00:29:04,450 --> 00:29:17,120
nobody all right

609
00:29:09,020 --> 00:29:23,300
that's that's it Oh what's up you said

610
00:29:17,120 --> 00:29:26,929
mofo I know I have it I have it I see I

611
00:29:23,300 --> 00:29:46,159
see no I know flow III have nine what's

612
00:29:26,930 --> 00:29:50,210
the story I mean I see I see to do

613
00:29:46,160 --> 00:29:53,330
binary analysis symbolically I mean it's

614
00:29:50,210 --> 00:29:58,730
outside of the most clear cases like

615
00:29:53,330 --> 00:30:00,530
segmentation faults it's seems like a

616
00:29:58,730 --> 00:30:04,070
much trickier problem than we just being

617
00:30:00,530 --> 00:30:05,389
supplied C code and evidently there's

618
00:30:04,070 --> 00:30:07,280
people that are working on it though and

619
00:30:05,390 --> 00:30:08,510
you know BAP and and of course many

620
00:30:07,280 --> 00:30:10,370
other any other project you trying to do

621
00:30:08,510 --> 00:30:13,520
like binary analysis I think that's

622
00:30:10,370 --> 00:30:15,290
actually what BAP stands for but no I

623
00:30:13,520 --> 00:30:22,510
haven't it's great move pho I'll take a

624
00:30:15,290 --> 00:30:24,620
look anyone else

625
00:30:22,510 --> 00:30:27,350
all right I hope you guys enjoy this

626
00:30:24,620 --> 00:30:31,629
song and I hope that you you really dig

627
00:30:27,350 --> 00:30:31,629
torque on 20 take it easy guys

