1
00:00:02,060 --> 00:00:06,390
all right we're gonna be kicking off the

2
00:00:04,319 --> 00:00:08,969
first of our normal talks today right

3
00:00:06,390 --> 00:00:10,320
now on track 1 John Stroh shine is here

4
00:00:08,970 --> 00:00:12,300
who's gonna be speaking about following

5
00:00:10,320 --> 00:00:21,359
a trail of confusion so please welcome

6
00:00:12,300 --> 00:00:24,029
him to the torque on stage all right

7
00:00:21,359 --> 00:00:26,430
well thank you and thank you to Tim and

8
00:00:24,029 --> 00:00:28,650
David and all of the torque on crew that

9
00:00:26,430 --> 00:00:30,390
put this on and allowed me to come and

10
00:00:28,650 --> 00:00:32,399
speak to you for about 50 minutes I

11
00:00:30,390 --> 00:00:32,850
definitely will do my best to keep it to

12
00:00:32,399 --> 00:00:34,530
that

13
00:00:32,850 --> 00:00:36,660
timeline because I know now I'm going

14
00:00:34,530 --> 00:00:38,879
into some of the lunch period so I

15
00:00:36,660 --> 00:00:40,739
titled this calling this this

16
00:00:38,879 --> 00:00:42,839
presentation I titled it following a

17
00:00:40,739 --> 00:00:44,820
trail of confusion because it seemed the

18
00:00:42,840 --> 00:00:46,469
most appropriate title for what I want

19
00:00:44,820 --> 00:00:49,140
to talk about and and part of what I do

20
00:00:46,469 --> 00:00:51,360
on a somewhat regular basis is to look

21
00:00:49,140 --> 00:00:53,070
at malware and try to understand its

22
00:00:51,360 --> 00:00:55,890
behaviors it's intense some of the

23
00:00:53,070 --> 00:00:57,629
tricks that it employs and that's

24
00:00:55,890 --> 00:00:59,430
usually what I end up doing is trying to

25
00:00:57,629 --> 00:01:01,379
solve these puzzles and try to identify

26
00:00:59,430 --> 00:01:03,180
these off eustachian techniques so that

27
00:01:01,379 --> 00:01:05,220
I can unwind them so that I can see what

28
00:01:03,180 --> 00:01:07,760
that malware is actually up to and then

29
00:01:05,220 --> 00:01:10,439
I can provide intelligence indicators

30
00:01:07,760 --> 00:01:12,479
reports summaries to whoever is asking

31
00:01:10,439 --> 00:01:15,600
me to do this work or in some cases

32
00:01:12,479 --> 00:01:17,039
making some training material so my

33
00:01:15,600 --> 00:01:18,479
contact information that's my email

34
00:01:17,040 --> 00:01:20,610
there's anything from this presentation

35
00:01:18,479 --> 00:01:21,539
that you'd like me to provide you send

36
00:01:20,610 --> 00:01:23,549
you the slides I think they'll be

37
00:01:21,540 --> 00:01:25,140
available after the talk questions on

38
00:01:23,549 --> 00:01:26,610
the samples I'll talk about some plugins

39
00:01:25,140 --> 00:01:28,650
that I didn't link to and I don't even

40
00:01:26,610 --> 00:01:29,880
think I've got up on github yet but if I

41
00:01:28,650 --> 00:01:31,500
can send those to you as well please

42
00:01:29,880 --> 00:01:34,439
feel free to contact me at my email

43
00:01:31,500 --> 00:01:36,630
account I'm here representing quite a

44
00:01:34,439 --> 00:01:38,369
few different organizations and places

45
00:01:36,630 --> 00:01:41,460
that I work first and foremost media

46
00:01:38,369 --> 00:01:42,869
labs which is with Jared Demont and we

47
00:01:41,460 --> 00:01:44,100
also do training so I was fortunate to

48
00:01:42,869 --> 00:01:46,770
be here earlier this week and did a

49
00:01:44,100 --> 00:01:49,020
couple days on malware so I think I saw

50
00:01:46,770 --> 00:01:51,149
a couple of familiar faces here earlier

51
00:01:49,020 --> 00:01:53,130
we both also author at Pluralsight I

52
00:01:51,149 --> 00:01:54,600
work with OSF I work with bromium and

53
00:01:53,130 --> 00:02:00,360
then I teach full-time at a university

54
00:01:54,600 --> 00:02:01,979
in the Midwest so the basic flow is that

55
00:02:00,360 --> 00:02:03,600
we're gonna start with these delivery

56
00:02:01,979 --> 00:02:06,810
mechanisms whether it's an office

57
00:02:03,600 --> 00:02:08,098
document or a spearfishing link or some

58
00:02:06,810 --> 00:02:10,229
other content but some sort of a

59
00:02:08,098 --> 00:02:12,589
delivery mechanism we're going to begin

60
00:02:10,229 --> 00:02:14,239
in this talk with the office doc

61
00:02:12,590 --> 00:02:16,370
and that those office documents then

62
00:02:14,239 --> 00:02:18,050
will employ some sort of method to get

63
00:02:16,370 --> 00:02:21,410
code execute oftentimes that's through

64
00:02:18,050 --> 00:02:23,510
macros so the idea is that there's

65
00:02:21,410 --> 00:02:26,180
multiple stages and that these stages

66
00:02:23,510 --> 00:02:28,220
continue to unravel maybe we'd then go

67
00:02:26,180 --> 00:02:30,920
to a batch script or some powershell

68
00:02:28,220 --> 00:02:33,379
maybe we get some shell code eventually

69
00:02:30,920 --> 00:02:35,599
we'd be gen generally tend to get to

70
00:02:33,379 --> 00:02:37,640
some native code so a PE file may be

71
00:02:35,599 --> 00:02:39,230
some dotnet maybe some Java that's the

72
00:02:37,640 --> 00:02:41,390
actual payload that the now our authors

73
00:02:39,230 --> 00:02:43,369
wanted to drop before we then move into

74
00:02:41,390 --> 00:02:46,309
this post a you know post infection

75
00:02:43,370 --> 00:02:48,349
phase so at each stage there is

76
00:02:46,310 --> 00:02:51,230
generally some layers or multiple layers

77
00:02:48,349 --> 00:02:52,548
of a few sophistication and depending on

78
00:02:51,230 --> 00:02:54,410
the type of code that we're looking at

79
00:02:52,549 --> 00:02:56,230
we'll also then greatly determine the

80
00:02:54,410 --> 00:02:58,549
type of off you station that we'll see

81
00:02:56,230 --> 00:02:59,959
towards the outer end of that the

82
00:02:58,549 --> 00:03:02,000
beginnings of the attack there's a

83
00:02:59,959 --> 00:03:04,730
little less effort just in my experience

84
00:03:02,000 --> 00:03:07,069
in making those you know armored

85
00:03:04,730 --> 00:03:08,750
bulletproof documents and we're also

86
00:03:07,069 --> 00:03:11,390
dealing typically with with interpreted

87
00:03:08,750 --> 00:03:12,920
code and so the the level of office

88
00:03:11,390 --> 00:03:14,298
keishon techniques that are available to

89
00:03:12,920 --> 00:03:16,429
an author or maybe a little bit more

90
00:03:14,299 --> 00:03:17,900
limited than when we move a little bit

91
00:03:16,430 --> 00:03:19,670
deeper get a little bit closer to that

92
00:03:17,900 --> 00:03:21,470
payload and now we're dealing with shell

93
00:03:19,670 --> 00:03:22,940
code we're dealing with PE files in

94
00:03:21,470 --> 00:03:24,260
which it's a little bit more difficult

95
00:03:22,940 --> 00:03:27,530
just in general to reverse engineer

96
00:03:24,260 --> 00:03:30,410
those and also to detect any sort of

97
00:03:27,530 --> 00:03:32,359
efficient or anti analysis so there are

98
00:03:30,410 --> 00:03:33,950
many ways we could go about this I'm

99
00:03:32,359 --> 00:03:35,389
gonna focus on if we were gonna analyze

100
00:03:33,950 --> 00:03:37,518
each stage I'm not saying that that's

101
00:03:35,389 --> 00:03:39,139
necessarily the step that you have to

102
00:03:37,519 --> 00:03:40,880
take in each stage if I wanted to

103
00:03:39,139 --> 00:03:43,040
observe the behavior of an office doc I

104
00:03:40,880 --> 00:03:44,660
might go to a sandbox before I decide to

105
00:03:43,040 --> 00:03:46,700
dump the macros and investigate those

106
00:03:44,660 --> 00:03:49,190
but for the purposes of this talk we're

107
00:03:46,700 --> 00:03:52,040
gonna dig into those so our first

108
00:03:49,190 --> 00:03:53,120
document is this Hansa term al doc with

109
00:03:52,040 --> 00:03:55,548
each sample that we're going to talk

110
00:03:53,120 --> 00:03:56,540
about today I'm going to have the MD 5s

111
00:03:55,549 --> 00:03:57,980
there so if you want to grab a sample

112
00:03:56,540 --> 00:04:00,168
you'll be able to pull those down from

113
00:03:57,980 --> 00:04:02,810
virustotal intelligence or maybe hybrid

114
00:04:00,169 --> 00:04:05,359
analysis or your own internal pool so

115
00:04:02,810 --> 00:04:06,560
that you have that as a reference we're

116
00:04:05,359 --> 00:04:08,450
not going to go through all the analysis

117
00:04:06,560 --> 00:04:09,950
I'm just going to focus on a specific

118
00:04:08,450 --> 00:04:11,958
technique that I observed in that

119
00:04:09,950 --> 00:04:14,149
document or that that you know that

120
00:04:11,959 --> 00:04:16,099
piece of software that script that

121
00:04:14,150 --> 00:04:19,548
highlights or exemplifies some of the

122
00:04:16,099 --> 00:04:21,529
you know the application that I see with

123
00:04:19,548 --> 00:04:23,929
this one so it's an office document so

124
00:04:21,529 --> 00:04:26,419
my go-to tool is OA lead um that's a

125
00:04:23,930 --> 00:04:28,160
Python script made by Didier Stevens

126
00:04:26,420 --> 00:04:29,690
and what that allows us to do is you can

127
00:04:28,160 --> 00:04:30,890
see in the screenshot and hopefully

128
00:04:29,690 --> 00:04:32,300
everyone can see this one okay it might

129
00:04:30,890 --> 00:04:34,909
be a little bit hard the further back

130
00:04:32,300 --> 00:04:37,220
you get is it essentially gives us the

131
00:04:34,910 --> 00:04:39,140
table of contents of that document so we

132
00:04:37,220 --> 00:04:40,940
can see indexes those are the numbers

133
00:04:39,140 --> 00:04:42,469
off to the left then you can see the

134
00:04:40,940 --> 00:04:44,270
contents the streams and some

135
00:04:42,470 --> 00:04:46,160
directories what is all stored in this

136
00:04:44,270 --> 00:04:47,599
document itself and then the most

137
00:04:46,160 --> 00:04:49,820
significant thing or at least the most

138
00:04:47,600 --> 00:04:51,740
important for this analysis is that we

139
00:04:49,820 --> 00:04:53,930
have the streams that are identified

140
00:04:51,740 --> 00:04:56,060
with macros so in this case it's 8 and

141
00:04:53,930 --> 00:04:58,670
10 and we know that because there's a

142
00:04:56,060 --> 00:05:00,800
capital M next to those streams so we

143
00:04:58,670 --> 00:05:04,310
can use the tool in order to extract

144
00:05:00,800 --> 00:05:06,230
those that allows us to decompress that

145
00:05:04,310 --> 00:05:08,720
macro code and begin investigating the

146
00:05:06,230 --> 00:05:10,940
VBA the Visual Basic for applications

147
00:05:08,720 --> 00:05:12,410
another thing that I've run across with

148
00:05:10,940 --> 00:05:13,490
office documents and this one took me a

149
00:05:12,410 --> 00:05:16,520
little bit of time to really piece

150
00:05:13,490 --> 00:05:18,620
together was the these streams right

151
00:05:16,520 --> 00:05:19,940
here 17 and 18 for this document of

152
00:05:18,620 --> 00:05:21,710
course the document structure will

153
00:05:19,940 --> 00:05:23,120
change what streams you identify here so

154
00:05:21,710 --> 00:05:25,969
this is the structure for this

155
00:05:23,120 --> 00:05:28,040
particular dock but this one has F and O

156
00:05:25,970 --> 00:05:30,410
and what those actually represent are a

157
00:05:28,040 --> 00:05:32,990
user form so this means that within this

158
00:05:30,410 --> 00:05:35,150
document there's a user form and the

159
00:05:32,990 --> 00:05:37,430
user form generally will contain very

160
00:05:35,150 --> 00:05:39,560
basic objects labels buttons text boxes

161
00:05:37,430 --> 00:05:42,260
that you can then embed content into

162
00:05:39,560 --> 00:05:44,270
shell code PE files octave skated

163
00:05:42,260 --> 00:05:47,659
strings powershell scripts whatever it

164
00:05:44,270 --> 00:05:49,609
happens to be so seeing those referenced

165
00:05:47,660 --> 00:05:51,830
in the macro code isn't always the most

166
00:05:49,610 --> 00:05:53,300
direct or the most obvious and one of

167
00:05:51,830 --> 00:05:55,190
the tools that i use very often if i

168
00:05:53,300 --> 00:05:57,650
really need to actually look into any

169
00:05:55,190 --> 00:05:59,180
particular user form is to actually use

170
00:05:57,650 --> 00:06:00,590
the office ide the integrated

171
00:05:59,180 --> 00:06:02,870
development environment because then you

172
00:06:00,590 --> 00:06:04,700
can you can open up the project kind of

173
00:06:02,870 --> 00:06:06,080
like you would in Visual Studio you can

174
00:06:04,700 --> 00:06:08,240
see the macros you can also see the

175
00:06:06,080 --> 00:06:10,520
forms you can get the controls on the

176
00:06:08,240 --> 00:06:10,730
forums as well now that's not always the

177
00:06:10,520 --> 00:06:12,830
case

178
00:06:10,730 --> 00:06:15,140
oftentimes in a trick that you'll see

179
00:06:12,830 --> 00:06:17,359
really throughout all of the occupation

180
00:06:15,140 --> 00:06:19,219
efforts is to try to identify what

181
00:06:17,360 --> 00:06:22,130
occupation is being used when is it

182
00:06:19,220 --> 00:06:22,940
being dias gated or decrypted catch it

183
00:06:22,130 --> 00:06:24,260
at that point

184
00:06:22,940 --> 00:06:26,510
let them now or do all the work for you

185
00:06:24,260 --> 00:06:28,190
and so it's very rare that I actually

186
00:06:26,510 --> 00:06:29,870
pulled that raw content off of a form

187
00:06:28,190 --> 00:06:31,490
because I just try to figure out where

188
00:06:29,870 --> 00:06:34,130
in the code is being gap you skated so I

189
00:06:31,490 --> 00:06:35,750
can grab it right there you start

190
00:06:34,130 --> 00:06:36,890
looking at VBA code so let's say you

191
00:06:35,750 --> 00:06:39,080
have to dig a little bit deeper into

192
00:06:36,890 --> 00:06:40,169
this document and you're gonna find and

193
00:06:39,080 --> 00:06:41,310
you'll see this across

194
00:06:40,169 --> 00:06:43,799
a lot of interpreted languages

195
00:06:41,310 --> 00:06:46,020
JavaScript and PHP and that there's only

196
00:06:43,800 --> 00:06:48,270
a limited number of ways in which you

197
00:06:46,020 --> 00:06:51,029
can really obfuscate this code you can

198
00:06:48,270 --> 00:06:52,889
create very you know random and

199
00:06:51,029 --> 00:06:54,449
seemingly strange-looking variable names

200
00:06:52,889 --> 00:06:57,569
and function names this just simply

201
00:06:54,449 --> 00:06:58,800
makes it harder to trace the logic so

202
00:06:57,569 --> 00:07:01,409
here's an example we have function

203
00:06:58,800 --> 00:07:04,259
permanent and object parakeet

204
00:07:01,409 --> 00:07:05,849
we have strings and strings and API so

205
00:07:04,259 --> 00:07:07,020
strings and function calls are generally

206
00:07:05,849 --> 00:07:07,860
the most important thing that I'm

207
00:07:07,020 --> 00:07:10,020
looking for

208
00:07:07,860 --> 00:07:12,150
when I'm trying to analyze any form any

209
00:07:10,020 --> 00:07:14,758
sort of malicious content or any program

210
00:07:12,150 --> 00:07:15,810
at all even if it's not malicious what

211
00:07:14,759 --> 00:07:18,689
are the strings being used what are the

212
00:07:15,810 --> 00:07:21,539
functions being called so with this one

213
00:07:18,689 --> 00:07:23,370
again very common to see just enough

214
00:07:21,539 --> 00:07:25,020
string off eustachian to make it that

215
00:07:23,370 --> 00:07:26,819
you can't readily recognize what those

216
00:07:25,020 --> 00:07:28,560
strings are so that they can be

217
00:07:26,819 --> 00:07:30,300
dynamically reconstructed during runtime

218
00:07:28,560 --> 00:07:32,430
and use just at the point that the

219
00:07:30,300 --> 00:07:35,129
malware authors actually need it so this

220
00:07:32,430 --> 00:07:37,139
one has some string reversal and some

221
00:07:35,129 --> 00:07:38,789
sub strings and that's how it's simply

222
00:07:37,139 --> 00:07:40,860
recreating those strings so using those

223
00:07:38,789 --> 00:07:42,839
string manipulation methods on either

224
00:07:40,860 --> 00:07:44,460
the string itself or a subcomponent of a

225
00:07:42,839 --> 00:07:47,189
string and then rebuilding that string

226
00:07:44,460 --> 00:07:49,680
as it goes another technique very common

227
00:07:47,189 --> 00:07:52,169
across the board is also junk

228
00:07:49,680 --> 00:07:53,819
instructions and again my opinion is

229
00:07:52,169 --> 00:07:55,378
it's a little bit easier to identify

230
00:07:53,819 --> 00:07:57,449
these when we're looking at an

231
00:07:55,379 --> 00:07:58,710
interpreted code I can see three

232
00:07:57,449 --> 00:08:00,509
variables here they're doing some very

233
00:07:58,710 --> 00:08:02,279
basic math and each one of those

234
00:08:00,509 --> 00:08:04,620
variables I could highlight like to do a

235
00:08:02,279 --> 00:08:06,029
find in the document and I could quickly

236
00:08:04,620 --> 00:08:07,830
determine if they're being used or not

237
00:08:06,029 --> 00:08:09,060
if they're not being used then I got a

238
00:08:07,830 --> 00:08:11,699
pretty good indication that it's just

239
00:08:09,060 --> 00:08:12,779
junk code so oftentimes the case there

240
00:08:11,699 --> 00:08:14,310
is you get into native code and you

241
00:08:12,779 --> 00:08:16,560
start disassembling things with ayodhya

242
00:08:14,310 --> 00:08:17,849
or binary ninja or some other tool at

243
00:08:16,560 --> 00:08:20,129
least for me it's a little bit more

244
00:08:17,849 --> 00:08:21,779
difficult to recognize those because

245
00:08:20,129 --> 00:08:23,550
you're looking at disassembly so you

246
00:08:21,779 --> 00:08:25,020
have to do more program analysis before

247
00:08:23,550 --> 00:08:27,539
you can determine if it's a junk

248
00:08:25,020 --> 00:08:29,520
instruction or not you might have some

249
00:08:27,539 --> 00:08:30,628
control structures and even those

250
00:08:29,520 --> 00:08:31,740
control structures might look like

251
00:08:30,629 --> 00:08:33,180
they're doing something with string

252
00:08:31,740 --> 00:08:34,890
manipulation so it might look like it's

253
00:08:33,179 --> 00:08:35,880
important but again it's not it's just

254
00:08:34,890 --> 00:08:38,490
there to slow you down if you're

255
00:08:35,880 --> 00:08:40,649
actually analyzing these and the last

256
00:08:38,490 --> 00:08:42,568
thing on this one the last that bladder

257
00:08:40,649 --> 00:08:45,089
pod which is a great variable name

258
00:08:42,568 --> 00:08:46,439
that's actually a legitimate string and

259
00:08:45,089 --> 00:08:49,290
you can see that by looking at the

260
00:08:46,440 --> 00:08:51,540
content from win32 it's just reversed

261
00:08:49,290 --> 00:08:53,099
from 132 and then there's a substring

262
00:08:51,540 --> 00:08:55,139
select star so there it's going

263
00:08:53,100 --> 00:08:56,279
from 1/32 space star so that's the only

264
00:08:55,139 --> 00:08:58,079
legitimate string here so we could

265
00:08:56,279 --> 00:09:00,709
identify that variable and start tracing

266
00:08:58,079 --> 00:09:03,989
it through the macros if we needed to

267
00:09:00,709 --> 00:09:06,569
another technique is to use the windows

268
00:09:03,990 --> 00:09:07,769
API so the windows api is important

269
00:09:06,569 --> 00:09:08,939
we're going to any program that's going

270
00:09:07,769 --> 00:09:10,079
to run in the operating system the

271
00:09:08,940 --> 00:09:11,699
windows operating system is gonna

272
00:09:10,079 --> 00:09:13,888
eventually interface through the windows

273
00:09:11,699 --> 00:09:16,859
API and some environments will allow you

274
00:09:13,889 --> 00:09:18,269
to do that directly so VBA macros are

275
00:09:16,860 --> 00:09:20,430
actually no different you can in fact

276
00:09:18,269 --> 00:09:22,620
call directly into the windows API from

277
00:09:20,430 --> 00:09:23,910
your VBA macros so normally you would

278
00:09:22,620 --> 00:09:25,500
use the functions that are defined in

279
00:09:23,910 --> 00:09:27,029
the language and those are documented on

280
00:09:25,500 --> 00:09:29,880
MSDN as well the Microsoft developer

281
00:09:27,029 --> 00:09:34,139
Network but you can also directly call

282
00:09:29,880 --> 00:09:35,850
so here's an example all the green those

283
00:09:34,139 --> 00:09:38,579
are comments so the authors in this case

284
00:09:35,850 --> 00:09:40,980
decided to take and interject all of

285
00:09:38,579 --> 00:09:43,229
these lyrics from songs in between these

286
00:09:40,980 --> 00:09:44,819
aliases that they're creating and these

287
00:09:43,230 --> 00:09:46,980
aliases are allowing them to call things

288
00:09:44,819 --> 00:09:48,509
like virtual a lock out of kernel 32

289
00:09:46,980 --> 00:09:52,259
which is our memory allocation routine

290
00:09:48,509 --> 00:09:54,779
and RTL move memory which is coming out

291
00:09:52,259 --> 00:09:57,000
of ntdll if we need to identify the

292
00:09:54,779 --> 00:09:58,470
usage of those api's then you have to

293
00:09:57,000 --> 00:10:00,779
look off to the kind of to the left

294
00:09:58,470 --> 00:10:03,360
there and that virtual a lock is going

295
00:10:00,779 --> 00:10:05,339
to be alias with betterment and our tail

296
00:10:03,360 --> 00:10:07,529
move memory is this variable antecedence

297
00:10:05,339 --> 00:10:09,269
e so in order to identify their usage in

298
00:10:07,529 --> 00:10:11,040
the macros now you either need to just

299
00:10:09,269 --> 00:10:12,180
rename them and refactor that code if

300
00:10:11,040 --> 00:10:14,699
you've extracted it and you're working

301
00:10:12,180 --> 00:10:16,589
with this in a text editor or just keep

302
00:10:14,699 --> 00:10:18,060
that mental mapping in mind so if I'm

303
00:10:16,589 --> 00:10:19,560
spending some time here I'm usually

304
00:10:18,060 --> 00:10:21,329
renaming things as I go because it

305
00:10:19,560 --> 00:10:25,920
doesn't take very long to just do a find

306
00:10:21,329 --> 00:10:29,279
replace know this one and this document

307
00:10:25,920 --> 00:10:31,019
is actually using shell code so shell

308
00:10:29,279 --> 00:10:33,149
code is embedded in a user form the

309
00:10:31,019 --> 00:10:35,009
macros begin to execute it used virtual

310
00:10:33,149 --> 00:10:37,230
Alec to allocate some memory it then

311
00:10:35,009 --> 00:10:39,420
used the RTL move memory API in order to

312
00:10:37,230 --> 00:10:41,519
copy that shell code from that user form

313
00:10:39,420 --> 00:10:43,139
after it decrypted it or 2d a few skated

314
00:10:41,519 --> 00:10:46,230
it into the allocation that had just

315
00:10:43,139 --> 00:10:47,639
made so logically we can think about if

316
00:10:46,230 --> 00:10:48,990
we're gonna have shell code in memory it

317
00:10:47,639 --> 00:10:50,370
needs to be staged there so we need to

318
00:10:48,990 --> 00:10:51,959
allocate the memory we need to copy it

319
00:10:50,370 --> 00:10:54,480
into memory and then we need to execute

320
00:10:51,959 --> 00:10:57,089
it and so there's a final API in this

321
00:10:54,480 --> 00:11:00,060
particular example that if you go back

322
00:10:57,089 --> 00:11:01,740
here this was I believe all of them one

323
00:11:00,060 --> 00:11:04,319
of these api's has to be responsible for

324
00:11:01,740 --> 00:11:06,540
executing the code now it doesn't jump

325
00:11:04,319 --> 00:11:07,620
out immediately as an obvious eight

326
00:11:06,540 --> 00:11:09,599
yeah at least it didn't for me the first

327
00:11:07,620 --> 00:11:11,790
time I looked at it however if I

328
00:11:09,600 --> 00:11:13,260
followed or trace those API calls I

329
00:11:11,790 --> 00:11:15,360
found the allocation I found the copy

330
00:11:13,260 --> 00:11:20,870
then the only other API that was being

331
00:11:15,360 --> 00:11:23,550
called was this Cabriolet and this one

332
00:11:20,870 --> 00:11:25,170
you'll see here in just a moment is

333
00:11:23,550 --> 00:11:27,719
actually a function called enum dates

334
00:11:25,170 --> 00:11:30,390
format and so what I decided to you is

335
00:11:27,720 --> 00:11:32,940
to use a debugger so I oftentimes find

336
00:11:30,390 --> 00:11:35,400
myself using a you know a combination of

337
00:11:32,940 --> 00:11:37,350
static and dynamic analysis and in this

338
00:11:35,400 --> 00:11:38,760
case I felt it was easier to just set a

339
00:11:37,350 --> 00:11:40,800
breakpoint on this function call and

340
00:11:38,760 --> 00:11:42,689
then observe the behavior at the time

341
00:11:40,800 --> 00:11:43,949
that the code stopped this allowed me to

342
00:11:42,690 --> 00:11:46,140
not only see the memory that was

343
00:11:43,950 --> 00:11:48,360
allocated but because we're about to go

344
00:11:46,140 --> 00:11:51,060
execute code there that shellcode has to

345
00:11:48,360 --> 00:11:53,970
be in a div skated form so I set a

346
00:11:51,060 --> 00:11:56,400
breakpoint we can see that Cabriolet is

347
00:11:53,970 --> 00:12:00,210
our enum dates formats enum date formats

348
00:11:56,400 --> 00:12:02,640
W and this actually as defined on MSDN

349
00:12:00,210 --> 00:12:04,050
takes the first argument which is a

350
00:12:02,640 --> 00:12:06,449
pointer to an application to find

351
00:12:04,050 --> 00:12:08,310
callback so then it became clear obvious

352
00:12:06,450 --> 00:12:10,530
to me how exactly it was getting this

353
00:12:08,310 --> 00:12:13,290
code in memory to execute from within

354
00:12:10,530 --> 00:12:16,260
those macros so continuing with that

355
00:12:13,290 --> 00:12:18,540
dynamic analysis was able to because it

356
00:12:16,260 --> 00:12:20,730
was running I had runtime analysis I

357
00:12:18,540 --> 00:12:22,890
could look at the value of that first

358
00:12:20,730 --> 00:12:24,840
variable I could dump the content so it

359
00:12:22,890 --> 00:12:27,630
was base ten converted quick to base 16

360
00:12:24,840 --> 00:12:30,000
and you can look at the process memory

361
00:12:27,630 --> 00:12:32,490
this is an office document so when were

362
00:12:30,000 --> 00:12:36,060
dot exe and we can see that at the base

363
00:12:32,490 --> 00:12:37,860
of this allocation we have our W X which

364
00:12:36,060 --> 00:12:38,939
of course we need execute permissions in

365
00:12:37,860 --> 00:12:42,200
that region of memory in order to

366
00:12:38,940 --> 00:12:44,010
execute the shell code so from there I

367
00:12:42,200 --> 00:12:45,480
use process hacker

368
00:12:44,010 --> 00:12:47,910
I like process hacker because it allows

369
00:12:45,480 --> 00:12:50,100
me to see memory I was able to look at

370
00:12:47,910 --> 00:12:52,319
this this really amounts to the entry

371
00:12:50,100 --> 00:12:53,640
point so so not only did this allow me

372
00:12:52,320 --> 00:12:54,990
to identify the shell code pull it out

373
00:12:53,640 --> 00:12:56,790
of memory when it was d off you skated

374
00:12:54,990 --> 00:12:59,100
but it also allowed me to identify the

375
00:12:56,790 --> 00:13:02,040
entry point which is another important

376
00:12:59,100 --> 00:13:04,200
step if you don't have a specific point

377
00:13:02,040 --> 00:13:07,110
to start analyzing some code you should

378
00:13:04,200 --> 00:13:08,790
probably start at start if I took all of

379
00:13:07,110 --> 00:13:09,990
this out of memory you can see that

380
00:13:08,790 --> 00:13:12,810
we're at an offset the base of the

381
00:13:09,990 --> 00:13:15,210
allocation 7 0 D 0 0 0 but we're

382
00:13:12,810 --> 00:13:16,410
actually at an offset of e 5 D so if I

383
00:13:15,210 --> 00:13:17,940
dump that out a memory and sort of

384
00:13:16,410 --> 00:13:19,290
disassembling from the first byte you

385
00:13:17,940 --> 00:13:20,910
might get incorrect to some

386
00:13:19,290 --> 00:13:23,430
the results so I'm gonna take my

387
00:13:20,910 --> 00:13:25,589
disassembler Ida Pro or binary ninja and

388
00:13:23,430 --> 00:13:27,839
I can point it to the entry point which

389
00:13:25,589 --> 00:13:31,050
is this first byte right here and that's

390
00:13:27,839 --> 00:13:32,910
a push EBP the opcode 55 so seeing that

391
00:13:31,050 --> 00:13:37,199
in memory recognizing that opcode to me

392
00:13:32,910 --> 00:13:38,370
was a good thing there are I'm gonna go

393
00:13:37,199 --> 00:13:39,479
kind of fast cuz there's a lot of stuff

394
00:13:38,370 --> 00:13:41,550
I want to have here so if it seems like

395
00:13:39,480 --> 00:13:42,930
I'm just chugging through I am that

396
00:13:41,550 --> 00:13:49,859
night I drank a big thing of caffeine

397
00:13:42,930 --> 00:13:52,258
before I got up here what's that yeah so

398
00:13:49,860 --> 00:13:53,250
embedding content another a this is an

399
00:13:52,259 --> 00:13:55,290
example

400
00:13:53,250 --> 00:13:58,290
there's our Olli dump content you can

401
00:13:55,290 --> 00:13:59,969
see F and 0 this project of you below

402
00:13:58,290 --> 00:14:01,740
that's actually from the office IDE and

403
00:13:59,970 --> 00:14:04,380
so not only can you see the macro

404
00:14:01,740 --> 00:14:06,360
streams this document and cow keeper

405
00:14:04,380 --> 00:14:08,759
another name that I use oftentimes when

406
00:14:06,360 --> 00:14:10,170
I develop but we can see the form as

407
00:14:08,759 --> 00:14:12,180
well this form has a name it's called

408
00:14:10,170 --> 00:14:14,160
discord you can look at the form and

409
00:14:12,180 --> 00:14:15,989
you'll see all the content on the form

410
00:14:14,160 --> 00:14:18,120
not only will you see the content but if

411
00:14:15,990 --> 00:14:20,639
you select any of those objects you can

412
00:14:18,120 --> 00:14:22,589
get the name of that object and what

413
00:14:20,639 --> 00:14:26,430
this helped me connect the dots on was

414
00:14:22,589 --> 00:14:29,430
that when I'm looking at macro code you

415
00:14:26,430 --> 00:14:31,500
may find at times these these objects

416
00:14:29,430 --> 00:14:32,459
being referenced but it's not clear

417
00:14:31,500 --> 00:14:34,649
exactly where they're coming from

418
00:14:32,459 --> 00:14:36,510
because a tool like Olli dump isn't

419
00:14:34,649 --> 00:14:38,160
gonna give you the structure of the form

420
00:14:36,510 --> 00:14:39,240
and the objects within it it's just

421
00:14:38,160 --> 00:14:41,610
gonna simply say hey there's a

422
00:14:39,240 --> 00:14:43,380
potentially there's a form here the IDE

423
00:14:41,610 --> 00:14:45,959
allows me to see that oh this is in fact

424
00:14:43,380 --> 00:14:47,970
an object on that form so that at least

425
00:14:45,959 --> 00:14:49,619
help me connect those dots so it was an

426
00:14:47,970 --> 00:14:51,750
important step in my analysis and in

427
00:14:49,620 --> 00:14:55,620
looking at office documents which I tend

428
00:14:51,750 --> 00:14:58,079
to see quite a few of another document I

429
00:14:55,620 --> 00:14:59,760
ran across not too long ago was another

430
00:14:58,079 --> 00:15:02,310
office stock that has exhibited anti

431
00:14:59,760 --> 00:15:04,260
analysis so there's a variety of

432
00:15:02,310 --> 00:15:06,839
techniques of in which the authors will

433
00:15:04,260 --> 00:15:08,310
try to employ detection of a virtual or

434
00:15:06,839 --> 00:15:10,170
analysis environment so that it can

435
00:15:08,310 --> 00:15:12,660
disrupt its behavior disrupt your tools

436
00:15:10,170 --> 00:15:14,639
disrupt the output this particular

437
00:15:12,660 --> 00:15:16,170
document again I did just did some

438
00:15:14,639 --> 00:15:17,430
runtime analysis because I didn't want

439
00:15:16,170 --> 00:15:20,519
to have to bother with trying to piece

440
00:15:17,430 --> 00:15:23,969
together all these strings and with this

441
00:15:20,519 --> 00:15:26,939
one it had this array of values a VM

442
00:15:23,970 --> 00:15:28,649
QEMU Red Hat virtual VMware exam and it

443
00:15:26,939 --> 00:15:30,750
was looking for the manufacturer in the

444
00:15:28,649 --> 00:15:32,400
model of the host system and so then it

445
00:15:30,750 --> 00:15:33,990
would take those values from the

446
00:15:32,400 --> 00:15:35,310
you it returned or obtained from the

447
00:15:33,990 --> 00:15:37,650
host and do some simple string

448
00:15:35,310 --> 00:15:39,510
comparison if it determined any of these

449
00:15:37,650 --> 00:15:41,040
matched then it said I'm in it I'm in a

450
00:15:39,510 --> 00:15:43,830
sandbox environment and it would really

451
00:15:41,040 --> 00:15:46,469
abort its behavior if it didn't detect

452
00:15:43,830 --> 00:15:49,200
it would do one more check and this one

453
00:15:46,470 --> 00:15:52,020
as you can see by the same string box up

454
00:15:49,200 --> 00:15:52,500
above was using names of common analysis

455
00:15:52,020 --> 00:15:55,890
tools

456
00:15:52,500 --> 00:15:58,410
so using win32 or I'm sorry the wind

457
00:15:55,890 --> 00:15:59,640
management WMI it gets a current listing

458
00:15:58,410 --> 00:16:01,920
of processes compares it to these

459
00:15:59,640 --> 00:16:03,840
hard-coded strings process names if

460
00:16:01,920 --> 00:16:06,479
anything matches again to checks in

461
00:16:03,840 --> 00:16:11,340
order to to deviate or or modify its

462
00:16:06,480 --> 00:16:12,120
behavior alright and office documents

463
00:16:11,340 --> 00:16:13,950
aren't the only one that does that

464
00:16:12,120 --> 00:16:15,540
technique I see it across the board I

465
00:16:13,950 --> 00:16:17,070
see a lot in native code and one of the

466
00:16:15,540 --> 00:16:19,589
first things that native code will do is

467
00:16:17,070 --> 00:16:21,600
use great to help 32 snapshot a Windows

468
00:16:19,590 --> 00:16:23,840
API to get a process listing go through

469
00:16:21,600 --> 00:16:26,880
those processes and see if there's any

470
00:16:23,840 --> 00:16:28,380
known processes that are running that

471
00:16:26,880 --> 00:16:30,390
would indicate that it's being analyzed

472
00:16:28,380 --> 00:16:33,330
or debugged so that it can abort or

473
00:16:30,390 --> 00:16:35,100
changes behavior it's not uncommon to

474
00:16:33,330 --> 00:16:37,110
run across password or documents that

475
00:16:35,100 --> 00:16:39,210
actually password-protected in this

476
00:16:37,110 --> 00:16:41,700
particular case I got a document but I

477
00:16:39,210 --> 00:16:43,080
when I went to analyze it because it's

478
00:16:41,700 --> 00:16:44,970
password protected the macros are

479
00:16:43,080 --> 00:16:47,280
encrypted so you can't use the tool like

480
00:16:44,970 --> 00:16:48,840
only dump to extract those so I really

481
00:16:47,280 --> 00:16:51,000
needed to see for a variety of reasons

482
00:16:48,840 --> 00:16:52,530
what was going on here and I didn't have

483
00:16:51,000 --> 00:16:54,480
the original email that it was sent to

484
00:16:52,530 --> 00:16:56,189
so I didn't have the password now these

485
00:16:54,480 --> 00:16:57,510
passwords are getting sent to users that

486
00:16:56,190 --> 00:16:59,430
means that those passwords are typically

487
00:16:57,510 --> 00:17:00,930
pretty simple four-digit pins a lot of

488
00:16:59,430 --> 00:17:03,900
documents at the time that just had

489
00:17:00,930 --> 00:17:06,599
four-digit pins and so in doing a little

490
00:17:03,900 --> 00:17:07,920
bit of digging discovered that John the

491
00:17:06,599 --> 00:17:10,708
Ripper actually has a Python script

492
00:17:07,920 --> 00:17:12,330
office to John that will extract that

493
00:17:10,709 --> 00:17:14,730
hash put it into a format that you can

494
00:17:12,329 --> 00:17:16,560
then feed into John and begin doing some

495
00:17:14,730 --> 00:17:18,120
brute forcing so in this case I told

496
00:17:16,560 --> 00:17:20,190
John to just incrementally go through

497
00:17:18,119 --> 00:17:22,649
the digits until it found a password and

498
00:17:20,190 --> 00:17:25,650
after actually a few minutes and a one

499
00:17:22,650 --> 00:17:27,600
core CPU VM I had the password to my

500
00:17:25,650 --> 00:17:28,950
document which was four or five five so

501
00:17:27,599 --> 00:17:30,000
then I could open the doc I could

502
00:17:28,950 --> 00:17:32,100
extract the macros I could actually

503
00:17:30,000 --> 00:17:36,000
remove the password altogether and

504
00:17:32,100 --> 00:17:37,770
continue my analysis so I mentioned

505
00:17:36,000 --> 00:17:39,900
shellcode I actually like to talk about

506
00:17:37,770 --> 00:17:42,270
shellcode very early on because it's

507
00:17:39,900 --> 00:17:44,850
used and I see it throughout really all

508
00:17:42,270 --> 00:17:46,049
phases of the different attack stages

509
00:17:44,850 --> 00:17:48,449
that I see we saw

510
00:17:46,049 --> 00:17:51,570
VBA I've seen it in PowerShell you'll

511
00:17:48,450 --> 00:17:53,549
see it native code it's really a very

512
00:17:51,570 --> 00:17:55,289
efficient or I should say effective way

513
00:17:53,549 --> 00:17:57,330
to just you know contain some

514
00:17:55,289 --> 00:17:58,950
functionality into whatever vehicle

515
00:17:57,330 --> 00:18:00,749
you're using to attack or you're seeing

516
00:17:58,950 --> 00:18:04,230
that is being used for attack so

517
00:18:00,749 --> 00:18:06,929
oftentimes seen in malicious code those

518
00:18:04,230 --> 00:18:08,820
things there I see it used for unpacking

519
00:18:06,929 --> 00:18:10,739
and we'll go through an example here in

520
00:18:08,820 --> 00:18:13,080
just a little bit and how the shell code

521
00:18:10,739 --> 00:18:15,480
is used in a very modular form in order

522
00:18:13,080 --> 00:18:16,980
to do some unpacking so that the

523
00:18:15,480 --> 00:18:22,259
original functionality or whatever that

524
00:18:16,980 --> 00:18:24,179
pack sample was can then execute shell

525
00:18:22,259 --> 00:18:26,070
code once you've identified the usage

526
00:18:24,179 --> 00:18:27,779
just like you saw with the VBA document

527
00:18:26,070 --> 00:18:30,090
then we just need to extract it from

528
00:18:27,779 --> 00:18:32,100
memory and because it is likely native

529
00:18:30,090 --> 00:18:33,689
code we can use some tool like Ida Pro

530
00:18:32,100 --> 00:18:36,959
or binary ninja in order to disassemble

531
00:18:33,690 --> 00:18:38,129
that so this is an example that shell

532
00:18:36,960 --> 00:18:40,139
code that you saw earlier this is

533
00:18:38,129 --> 00:18:41,939
actually just assembly from that and of

534
00:18:40,139 --> 00:18:44,939
course I chose a select part of that

535
00:18:41,940 --> 00:18:47,070
disassembly here to talk through there

536
00:18:44,940 --> 00:18:49,129
are lots of differences or nuances with

537
00:18:47,070 --> 00:18:51,600
shell code as far as how it

538
00:18:49,129 --> 00:18:53,340
differentiates between a normal

539
00:18:51,600 --> 00:18:55,168
executable file that you give to the

540
00:18:53,340 --> 00:18:56,580
operating system and loads it through

541
00:18:55,169 --> 00:18:58,619
the operating system loader into memory

542
00:18:56,580 --> 00:19:00,418
and then prepares it for execution one

543
00:18:58,619 --> 00:19:02,279
of those main things is how it calls or

544
00:19:00,419 --> 00:19:03,570
imports functionality so if we're going

545
00:19:02,279 --> 00:19:05,609
to interact with the Windows OS we're

546
00:19:03,570 --> 00:19:06,960
going to use the windows API and if

547
00:19:05,609 --> 00:19:08,580
we're going to do that we're going to

548
00:19:06,960 --> 00:19:09,840
import that functionality so the

549
00:19:08,580 --> 00:19:12,480
operating system will take care of that

550
00:19:09,840 --> 00:19:14,399
for us in a normal situation shell code

551
00:19:12,480 --> 00:19:16,169
is not normal it's put into memory and

552
00:19:14,399 --> 00:19:17,850
then we're just telling the CPU to go to

553
00:19:16,169 --> 00:19:19,619
some location in that shell couldn't

554
00:19:17,850 --> 00:19:21,600
begin executing so the shell code is

555
00:19:19,619 --> 00:19:23,369
responsible amongst other things for

556
00:19:21,600 --> 00:19:25,980
ensuring that it has built its own

557
00:19:23,369 --> 00:19:27,539
import table so you see artifacts of

558
00:19:25,980 --> 00:19:28,830
that or evidence of that when you look

559
00:19:27,539 --> 00:19:30,809
at the shell code because you'll see

560
00:19:28,830 --> 00:19:32,519
calls instead of you know call create

561
00:19:30,809 --> 00:19:34,889
process or call virtual a lock you see

562
00:19:32,519 --> 00:19:36,989
call EBP plus bar 1b0

563
00:19:34,889 --> 00:19:38,668
kind of a non-standard way of calling a

564
00:19:36,989 --> 00:19:40,649
function there's a function pointer

565
00:19:38,669 --> 00:19:42,059
inside of that local variable it's a

566
00:19:40,649 --> 00:19:45,090
local variable because we're referencing

567
00:19:42,059 --> 00:19:46,739
EBP and we're also assuming or we have

568
00:19:45,090 --> 00:19:49,350
analyzed this to know that this function

569
00:19:46,739 --> 00:19:50,730
has a normal stack frame and it's so

570
00:19:49,350 --> 00:19:52,619
it's calling it through a local variable

571
00:19:50,730 --> 00:19:54,299
which again you can do if you write code

572
00:19:52,619 --> 00:19:56,850
you can actually do that but it's not

573
00:19:54,299 --> 00:19:59,009
the normal way for our analysis though

574
00:19:56,850 --> 00:19:59,699
we have to figure out what is that call

575
00:19:59,009 --> 00:20:02,190
I said

576
00:19:59,700 --> 00:20:03,480
strings and api's are important and I

577
00:20:02,190 --> 00:20:05,549
don't know what that API is I don't what

578
00:20:03,480 --> 00:20:07,710
that call is I'm kind of blinded to what

579
00:20:05,549 --> 00:20:09,960
the program is actually doing so in this

580
00:20:07,710 --> 00:20:11,970
example there's two instances of it this

581
00:20:09,960 --> 00:20:13,440
one uses a really well-known technique

582
00:20:11,970 --> 00:20:14,940
so even though it's well known it's

583
00:20:13,440 --> 00:20:17,340
still something that I really regularly

584
00:20:14,940 --> 00:20:19,230
encounter and that it has stacks strings

585
00:20:17,340 --> 00:20:20,820
so it's just taking the variable for

586
00:20:19,230 --> 00:20:22,289
those ASCII characters or the the data

587
00:20:20,820 --> 00:20:24,269
the numeric values for those ASCII

588
00:20:22,289 --> 00:20:25,830
characters and it's moving them into the

589
00:20:24,269 --> 00:20:27,389
stack so it's constructing that string

590
00:20:25,830 --> 00:20:29,220
on the stack at the time that it needs

591
00:20:27,389 --> 00:20:32,039
it so that then it can dynamically

592
00:20:29,220 --> 00:20:34,139
resolve our call to whatever function

593
00:20:32,039 --> 00:20:36,690
it's after so in this example it's going

594
00:20:34,139 --> 00:20:39,120
to call Z W unmapped view of section so

595
00:20:36,690 --> 00:20:40,950
there's our stack variable the BL is our

596
00:20:39,120 --> 00:20:43,469
null byte it was X sort up above so

597
00:20:40,950 --> 00:20:45,210
that's just terminating the string the

598
00:20:43,470 --> 00:20:46,710
other thing that this shows us if you

599
00:20:45,210 --> 00:20:50,010
looked at the sample in its entirety as

600
00:20:46,710 --> 00:20:53,220
this trend or this pattern of string

601
00:20:50,010 --> 00:20:55,549
function call result results are going

602
00:20:53,220 --> 00:20:58,380
to be returned in EAX in this example

603
00:20:55,549 --> 00:21:00,000
that being moved into our local variable

604
00:20:58,380 --> 00:21:02,070
and of course because I've made these

605
00:21:00,000 --> 00:21:05,250
screenshots that local variables right

606
00:21:02,070 --> 00:21:07,470
here so this also tells us that once we

607
00:21:05,250 --> 00:21:10,649
recognize this pattern that are called a

608
00:21:07,470 --> 00:21:12,389
sub CF one that is likely resolving

609
00:21:10,649 --> 00:21:13,590
these api's for us so if you have to

610
00:21:12,389 --> 00:21:15,928
figure out how that works you can trace

611
00:21:13,590 --> 00:21:17,610
into it if not you just maybe rename it

612
00:21:15,929 --> 00:21:19,590
and you're happy with the fact that you

613
00:21:17,610 --> 00:21:23,149
know that anywhere this is being called

614
00:21:19,590 --> 00:21:27,360
it's likely resolving a function for you

615
00:21:23,149 --> 00:21:28,620
the sample does process Halloween so

616
00:21:27,360 --> 00:21:30,658
really there's another layer that we

617
00:21:28,620 --> 00:21:32,250
have to trace into if we continue to

618
00:21:30,659 --> 00:21:34,200
analyze it so what you're seeing in that

619
00:21:32,250 --> 00:21:35,669
shellcode is the fact that it's going to

620
00:21:34,200 --> 00:21:37,889
start a process in a suspended state

621
00:21:35,669 --> 00:21:38,880
it's gonna empty out or replace the

622
00:21:37,889 --> 00:21:41,010
original code so it's going to use

623
00:21:38,880 --> 00:21:44,880
probably a binary a well-known binary on

624
00:21:41,010 --> 00:21:46,950
the system like explorer.exe or SVC host

625
00:21:44,880 --> 00:21:48,630
of anything that it can think of since

626
00:21:46,950 --> 00:21:49,980
it's loading that executable in a

627
00:21:48,630 --> 00:21:51,750
suspended state it looks like it's

628
00:21:49,980 --> 00:21:54,240
coming from that original location you

629
00:21:51,750 --> 00:21:57,029
know so see system32 svchost.exe

630
00:21:54,240 --> 00:21:58,649
but it's suspended so it can use some of

631
00:21:57,029 --> 00:22:00,419
the other api's like on map view of

632
00:21:58,649 --> 00:22:02,340
section in order to get a pointer to

633
00:22:00,419 --> 00:22:04,440
that text section to then replace it

634
00:22:02,340 --> 00:22:06,480
with its own code so now another round

635
00:22:04,440 --> 00:22:09,899
of or stage of shellcodes getting

636
00:22:06,480 --> 00:22:12,000
injected into that memory and once it's

637
00:22:09,899 --> 00:22:13,320
replaced it updates the entry point and

638
00:22:12,000 --> 00:22:15,659
resumes execution

639
00:22:13,320 --> 00:22:16,740
so if we wanted to continue to debug

640
00:22:15,659 --> 00:22:18,480
that we would just have to recognize

641
00:22:16,740 --> 00:22:20,370
that pattern which is why it's important

642
00:22:18,480 --> 00:22:24,529
to find those api's and then continue to

643
00:22:20,370 --> 00:22:26,428
trace in UI also be able to recognize

644
00:22:24,529 --> 00:22:28,289
signatures arguments that are being

645
00:22:26,429 --> 00:22:29,970
pushed onto the stack for that call so

646
00:22:28,289 --> 00:22:31,559
even if you don't recognize because you

647
00:22:29,970 --> 00:22:33,990
can't because this is call to this

648
00:22:31,559 --> 00:22:35,309
location that we can't see you might be

649
00:22:33,990 --> 00:22:38,130
able to recognize some of the arguments

650
00:22:35,309 --> 00:22:40,200
and still identify the API that's being

651
00:22:38,130 --> 00:22:42,059
used that doesn't really scale all that

652
00:22:40,200 --> 00:22:45,559
well but sometimes if you're just doing

653
00:22:42,059 --> 00:22:45,559
some quick analysis that it can't help

654
00:22:45,889 --> 00:22:50,519
this one I called a common dropper and

655
00:22:48,570 --> 00:22:52,830
it is a common dropper and that it

656
00:22:50,519 --> 00:22:54,720
contains very limited functionality it's

657
00:22:52,830 --> 00:22:57,059
just simply trying to go out to some c2

658
00:22:54,720 --> 00:22:58,980
node that is now long dead and download

659
00:22:57,059 --> 00:23:01,620
the next stage what's interesting about

660
00:22:58,980 --> 00:23:03,720
this one is that it exhibits that same

661
00:23:01,620 --> 00:23:06,090
behavior that we're starting to discuss

662
00:23:03,720 --> 00:23:09,120
with the shell code but in a normal full

663
00:23:06,090 --> 00:23:10,980
PE executable file format so you do some

664
00:23:09,120 --> 00:23:12,449
analysis right typically I start by

665
00:23:10,980 --> 00:23:14,129
doing some basic things if it's a PE

666
00:23:12,450 --> 00:23:15,600
file I'll use something like PE studio

667
00:23:14,129 --> 00:23:17,639
look at the imports look at the

668
00:23:15,600 --> 00:23:19,230
libraries look at the strings to try to

669
00:23:17,639 --> 00:23:21,000
understand a little bit about the file

670
00:23:19,230 --> 00:23:22,799
is it is it going to be employing

671
00:23:21,000 --> 00:23:24,059
obfuscation is it going to be employ is

672
00:23:22,799 --> 00:23:27,080
it going to be packed I need to unpack

673
00:23:24,059 --> 00:23:29,100
it first and some of those

674
00:23:27,080 --> 00:23:32,039
characteristics of the file will then

675
00:23:29,100 --> 00:23:34,309
just jump out this one has no libraries

676
00:23:32,039 --> 00:23:36,720
no imports and even though I've

677
00:23:34,309 --> 00:23:38,908
significantly snipped the strings it

678
00:23:36,720 --> 00:23:41,399
really had no strings just strings from

679
00:23:38,909 --> 00:23:44,129
a normal PE file so that tells me that

680
00:23:41,399 --> 00:23:46,080
yeah it's dynamically resolved resolving

681
00:23:44,129 --> 00:23:47,399
its imports it's probably dynamically

682
00:23:46,080 --> 00:23:49,769
resolving strings they're hidden in

683
00:23:47,399 --> 00:23:51,029
there somewhere or it's not even using

684
00:23:49,769 --> 00:23:53,220
them which is actually the case here

685
00:23:51,029 --> 00:23:55,799
with this sample you can disassemble

686
00:23:53,220 --> 00:23:57,509
right it's still a valid PE file so if I

687
00:23:55,799 --> 00:23:59,549
need to take to disassembly to start

688
00:23:57,509 --> 00:24:02,429
trying to get a sense of the code then

689
00:23:59,549 --> 00:24:05,149
in this case I did that and here's the

690
00:24:02,429 --> 00:24:07,769
call EAX alright so what is what is EI x

691
00:24:05,149 --> 00:24:09,870
you can trace above and see that there's

692
00:24:07,769 --> 00:24:11,399
a push and then a pop and then a call so

693
00:24:09,870 --> 00:24:13,110
we know that whatever this D word is

694
00:24:11,399 --> 00:24:15,149
here that's actually what's being called

695
00:24:13,110 --> 00:24:17,699
but that value is populated at runtime

696
00:24:15,149 --> 00:24:18,959
so you navigate to that now in Ida rbn

697
00:24:17,700 --> 00:24:21,330
and you're gonna see that it's a zero

698
00:24:18,960 --> 00:24:24,360
value right so it's runtime dynamically

699
00:24:21,330 --> 00:24:25,860
resolving those again a lot of different

700
00:24:24,360 --> 00:24:26,879
approaches maybe I just jumped to a

701
00:24:25,860 --> 00:24:28,740
debugger

702
00:24:26,880 --> 00:24:30,690
a pro has an integrated debugger set a

703
00:24:28,740 --> 00:24:32,520
breakpoint once I hit that call that

704
00:24:30,690 --> 00:24:33,810
indirect call site the debugger will

705
00:24:32,520 --> 00:24:36,270
likely tell me exactly what's being

706
00:24:33,810 --> 00:24:38,340
called there but again that doesn't

707
00:24:36,270 --> 00:24:39,960
really scale well you can script it you

708
00:24:38,340 --> 00:24:42,750
could script every indirect call site so

709
00:24:39,960 --> 00:24:44,040
that I too could possibly populate those

710
00:24:42,750 --> 00:24:46,260
values for you get a lot of ways you

711
00:24:44,040 --> 00:24:47,820
could do that or you could actually get

712
00:24:46,260 --> 00:24:51,090
in and analyze the code which is what I

713
00:24:47,820 --> 00:24:52,980
did here this technique we could spend

714
00:24:51,090 --> 00:24:55,260
an hour on alone so I just wanted to

715
00:24:52,980 --> 00:24:57,870
give you the high-level overview and

716
00:24:55,260 --> 00:24:59,760
that this is a basic block so if you've

717
00:24:57,870 --> 00:25:01,169
ever looked at Ida and a function graph

718
00:24:59,760 --> 00:25:03,180
in Ida you have all those blocks right

719
00:25:01,170 --> 00:25:04,740
those basic this is a basic block this

720
00:25:03,180 --> 00:25:06,930
is the first basic block in the program

721
00:25:04,740 --> 00:25:10,410
and it exemplifies the problem and that

722
00:25:06,930 --> 00:25:12,600
we have an indirect call and we have two

723
00:25:10,410 --> 00:25:14,850
calls before that and so what we can

724
00:25:12,600 --> 00:25:16,110
determine from from looking at that is

725
00:25:14,850 --> 00:25:19,469
that those two calls have to be

726
00:25:16,110 --> 00:25:21,300
responsible for populating this jumping

727
00:25:19,470 --> 00:25:23,850
into each one they each have a very

728
00:25:21,300 --> 00:25:26,070
specific purpose the first one will then

729
00:25:23,850 --> 00:25:28,709
locate in memory the DLL that we're

730
00:25:26,070 --> 00:25:31,110
going to get an API from so it passes

731
00:25:28,710 --> 00:25:33,090
this hash value which it then calculates

732
00:25:31,110 --> 00:25:34,350
in the function based off of the DLL

733
00:25:33,090 --> 00:25:36,120
that is trying to find so it's going

734
00:25:34,350 --> 00:25:38,100
through all of the dll's in memory

735
00:25:36,120 --> 00:25:40,110
character by character creating that

736
00:25:38,100 --> 00:25:41,790
same check summer hash value and then

737
00:25:40,110 --> 00:25:44,010
comparing it to this so it's avoiding

738
00:25:41,790 --> 00:25:45,330
strings as it's trying to find the dll

739
00:25:44,010 --> 00:25:48,690
that we're after

740
00:25:45,330 --> 00:25:50,580
once it identifies that it returns the

741
00:25:48,690 --> 00:25:52,320
image base for that library and then

742
00:25:50,580 --> 00:25:54,600
this next function takes an array of

743
00:25:52,320 --> 00:25:57,000
basically the same hash values the

744
00:25:54,600 --> 00:26:00,240
exports that it's after it parses the PE

745
00:25:57,000 --> 00:26:02,400
file and builds an import table so once

746
00:26:00,240 --> 00:26:04,470
that import table is constructed then

747
00:26:02,400 --> 00:26:06,600
our program can go ahead and start

748
00:26:04,470 --> 00:26:07,830
making function calls right it could be

749
00:26:06,600 --> 00:26:10,169
a little bit more discreet it could do

750
00:26:07,830 --> 00:26:12,510
it an individual API at a time in this

751
00:26:10,170 --> 00:26:14,310
case it constructs them per deal L at a

752
00:26:12,510 --> 00:26:15,420
time so it's a little bit more noisy a

753
00:26:14,310 --> 00:26:17,820
little bit more obvious once you

754
00:26:15,420 --> 00:26:20,490
recognize the pattern for the sake of

755
00:26:17,820 --> 00:26:23,700
time I'll just really quick highlight

756
00:26:20,490 --> 00:26:25,710
kind of the overall flow here I wanted

757
00:26:23,700 --> 00:26:26,760
this in here more as a reference just in

758
00:26:25,710 --> 00:26:29,520
case you were curious I wanted to look

759
00:26:26,760 --> 00:26:31,320
at the slides you can see the flow this

760
00:26:29,520 --> 00:26:32,879
is the flow of the dll so it's using the

761
00:26:31,320 --> 00:26:35,520
pad the process environment block and

762
00:26:32,880 --> 00:26:39,330
you can recognize that usage at the very

763
00:26:35,520 --> 00:26:40,680
top here FS 30 hex so it's using the FS

764
00:26:39,330 --> 00:26:42,480
register to get the pub

765
00:26:40,680 --> 00:26:44,760
the process environment block this

766
00:26:42,480 --> 00:26:46,500
allows the program to navigate these

767
00:26:44,760 --> 00:26:48,780
somewhat undocumented structures in the

768
00:26:46,500 --> 00:26:50,190
process to get a doubly-linked list of

769
00:26:48,780 --> 00:26:52,320
all the dll's that are in memory and

770
00:26:50,190 --> 00:26:54,150
once it determines the match it can get

771
00:26:52,320 --> 00:26:56,550
the base of that dll and then we can

772
00:26:54,150 --> 00:26:58,320
parse the PE file from there that's what

773
00:26:56,550 --> 00:27:01,110
this next function is doing and that's

774
00:26:58,320 --> 00:27:03,000
the basic flow here so calculating those

775
00:27:01,110 --> 00:27:04,830
hashes after it's found the export table

776
00:27:03,000 --> 00:27:06,840
the PE file comparing those to the

777
00:27:04,830 --> 00:27:08,760
hashes that it has hard-coded and then

778
00:27:06,840 --> 00:27:10,590
if it finds a match gets that function

779
00:27:08,760 --> 00:27:16,830
address and then builds an array of

780
00:27:10,590 --> 00:27:18,689
function pointers right so what do we do

781
00:27:16,830 --> 00:27:21,659
with this this technique in this example

782
00:27:18,690 --> 00:27:23,180
I actually created an Ida plugin and a

783
00:27:21,660 --> 00:27:25,530
binary ninja one for that matter and

784
00:27:23,180 --> 00:27:27,750
actually made it go through the database

785
00:27:25,530 --> 00:27:29,310
and the sale essentially perform the

786
00:27:27,750 --> 00:27:31,740
same logic without having to do runtime

787
00:27:29,310 --> 00:27:34,200
analysis so it went through it populated

788
00:27:31,740 --> 00:27:35,820
all of those those call sites that we

789
00:27:34,200 --> 00:27:37,950
saw it that well I won't back up now but

790
00:27:35,820 --> 00:27:39,419
at the very beginning and added a

791
00:27:37,950 --> 00:27:40,920
comment to rename them with the actual

792
00:27:39,420 --> 00:27:42,210
API so now I could just go through the

793
00:27:40,920 --> 00:27:44,510
database and I could actually see the

794
00:27:42,210 --> 00:27:47,310
functions that were being called so

795
00:27:44,510 --> 00:27:49,350
detecting packing I really bias my

796
00:27:47,310 --> 00:27:50,820
analysis at this point and that I just

797
00:27:49,350 --> 00:27:52,620
assume everything I'm going to look at

798
00:27:50,820 --> 00:27:54,300
is gonna have some layer of packing and

799
00:27:52,620 --> 00:27:54,629
I'm gonna have to do some work to unpack

800
00:27:54,300 --> 00:27:56,370
it

801
00:27:54,630 --> 00:27:57,750
you have to unpack something because if

802
00:27:56,370 --> 00:27:59,639
you want to analyze the functionality

803
00:27:57,750 --> 00:28:01,680
you have to get it out of whatever it's

804
00:27:59,640 --> 00:28:04,070
packed into if you don't do that then

805
00:28:01,680 --> 00:28:06,300
you're analyzing the unpacking code so

806
00:28:04,070 --> 00:28:07,649
probably not of interest to you unless

807
00:28:06,300 --> 00:28:10,110
you're just curious on how it actually

808
00:28:07,650 --> 00:28:10,800
is unpacking lots of different ways you

809
00:28:10,110 --> 00:28:12,360
can do this

810
00:28:10,800 --> 00:28:14,159
looking at entropy in the sections look

811
00:28:12,360 --> 00:28:15,780
at an entropy in the file looking at

812
00:28:14,160 --> 00:28:18,150
things like strings and imports as we've

813
00:28:15,780 --> 00:28:20,840
already discussed and that can give you

814
00:28:18,150 --> 00:28:23,580
some evidence typically there's no one

815
00:28:20,840 --> 00:28:25,409
key piece of information that says 100%

816
00:28:23,580 --> 00:28:26,750
this is packed it's usually for me it's

817
00:28:25,410 --> 00:28:28,920
looking at a variety of different

818
00:28:26,750 --> 00:28:31,470
characteristics or maybe features of

819
00:28:28,920 --> 00:28:33,540
that file in order to detect that you

820
00:28:31,470 --> 00:28:35,490
may open it up in Ida and just get a

821
00:28:33,540 --> 00:28:36,960
feel for the functionality itself

822
00:28:35,490 --> 00:28:38,340
looking at how many functions are there

823
00:28:36,960 --> 00:28:41,190
looking at how complex the functions

824
00:28:38,340 --> 00:28:42,510
appear to be and that can also just you

825
00:28:41,190 --> 00:28:43,860
know you look at enough of it you just

826
00:28:42,510 --> 00:28:45,300
kind of get a sense of whether

827
00:28:43,860 --> 00:28:48,060
something's packed or not by looking at

828
00:28:45,300 --> 00:28:49,260
the disassembly I've got a variety of

829
00:28:48,060 --> 00:28:51,960
ways in which I've been able to unpack

830
00:28:49,260 --> 00:28:53,830
things one of the simpler and one that I

831
00:28:51,960 --> 00:28:55,210
prefer whenever I possibly can

832
00:28:53,830 --> 00:28:57,070
is just to maybe watch memory

833
00:28:55,210 --> 00:29:00,070
allocations so this sample here was a

834
00:28:57,070 --> 00:29:01,689
Tesla crip and what it would do is it

835
00:29:00,070 --> 00:29:04,389
would allocate memory two or three or

836
00:29:01,690 --> 00:29:07,149
four times and as it was after those

837
00:29:04,390 --> 00:29:09,370
allocations if you just let it run for a

838
00:29:07,149 --> 00:29:10,539
while then you could look back in those

839
00:29:09,370 --> 00:29:13,268
allocations and you would eventually

840
00:29:10,539 --> 00:29:16,059
find a PV file so the unpacking here was

841
00:29:13,269 --> 00:29:18,779
an entirely new PE file that it pulled

842
00:29:16,059 --> 00:29:21,279
out into memory and then began executing

843
00:29:18,779 --> 00:29:24,250
you can use tools like window bug or

844
00:29:21,279 --> 00:29:26,610
whatever debugger you prefer I use

845
00:29:24,250 --> 00:29:29,169
window bug so I'm prepared for jeers and

846
00:29:26,610 --> 00:29:31,029
tomatoes to be thrown at me but I like

847
00:29:29,169 --> 00:29:32,799
it I think it's a good debugger at least

848
00:29:31,029 --> 00:29:34,419
for what I use it for and commands like

849
00:29:32,799 --> 00:29:36,490
this simply allow me to search the

850
00:29:34,419 --> 00:29:38,710
process the address space the memory of

851
00:29:36,490 --> 00:29:40,570
that process to find strings like the DA

852
00:29:38,710 --> 00:29:42,010
stub right and then I'm just limiting

853
00:29:40,570 --> 00:29:43,779
the range that I'm looking at that I'm

854
00:29:42,010 --> 00:29:49,179
not looking at PE files up and where the

855
00:29:43,779 --> 00:29:51,519
DLL is typically get loaded this is what

856
00:29:49,179 --> 00:29:52,870
it looked like before limited

857
00:29:51,519 --> 00:29:54,880
functionality although it's kind of hard

858
00:29:52,870 --> 00:29:58,090
to see kind of strange

859
00:29:54,880 --> 00:30:00,370
entry point with the program and no real

860
00:29:58,090 --> 00:30:01,899
discernible strings and then once it was

861
00:30:00,370 --> 00:30:04,000
pulled out of memory I had very

862
00:30:01,899 --> 00:30:06,600
discernible strings base64 encoded data

863
00:30:04,000 --> 00:30:10,059
things like Shadow Copy and delete and

864
00:30:06,600 --> 00:30:12,668
more complex entry point DLL or win main

865
00:30:10,059 --> 00:30:14,200
was identified and things that just made

866
00:30:12,669 --> 00:30:18,309
me feel much more confident that the

867
00:30:14,200 --> 00:30:20,110
sample was in fact unpacked okay here's

868
00:30:18,309 --> 00:30:21,460
an example of dry decks this one that

869
00:30:20,110 --> 00:30:23,469
technique did not work on because

870
00:30:21,460 --> 00:30:25,990
essentially what this sample is doing is

871
00:30:23,470 --> 00:30:29,139
it's using several rounds of shellcode

872
00:30:25,990 --> 00:30:33,299
in order to begin the unpacking process

873
00:30:29,139 --> 00:30:35,799
and ultimately it's it's doing a I

874
00:30:33,299 --> 00:30:37,179
forget the name of the term now but it's

875
00:30:35,799 --> 00:30:39,190
going to replace the code in the main

876
00:30:37,179 --> 00:30:41,080
program when it starts with this

877
00:30:39,190 --> 00:30:42,700
unpacked code so it's going to allocate

878
00:30:41,080 --> 00:30:43,809
some shellcode jump to the shellcode the

879
00:30:42,700 --> 00:30:45,700
shellcode is going to replace the

880
00:30:43,809 --> 00:30:46,990
original code once that's replace it's

881
00:30:45,700 --> 00:30:48,970
going to jump back so it's a little bit

882
00:30:46,990 --> 00:30:51,130
harder to trace through that you also

883
00:30:48,970 --> 00:30:54,130
don't have a blatantly obvious PE file

884
00:30:51,130 --> 00:30:55,809
in memory once it's all done the way

885
00:30:54,130 --> 00:30:57,100
that I attacked that or begin

886
00:30:55,809 --> 00:30:58,779
determining how to trace that

887
00:30:57,100 --> 00:31:00,189
functionality and I've been able to do

888
00:30:58,779 --> 00:31:03,700
this technique with a lot of different

889
00:31:00,190 --> 00:31:06,659
PAC samples is just look for abnormal

890
00:31:03,700 --> 00:31:09,479
behavior and by abnormal behavior I mean

891
00:31:06,659 --> 00:31:11,700
conditional jumps into dynamic locations

892
00:31:09,479 --> 00:31:13,440
maybe an indirect jump into a register

893
00:31:11,700 --> 00:31:15,570
or a global variable that's going to get

894
00:31:13,440 --> 00:31:18,929
populated after the code is executing

895
00:31:15,570 --> 00:31:22,019
this one begins there's an le a an Dax

896
00:31:18,929 --> 00:31:24,479
the subroutine it then pushes and then

897
00:31:22,019 --> 00:31:25,710
rats so pushing before you ret means

898
00:31:24,479 --> 00:31:27,559
that you're pushing on whatever your

899
00:31:25,710 --> 00:31:29,940
return instruction is going to return to

900
00:31:27,559 --> 00:31:32,009
again kind of odd normal functions don't

901
00:31:29,940 --> 00:31:33,570
do that so in this case though we have

902
00:31:32,009 --> 00:31:37,259
the function so we can trace into that

903
00:31:33,570 --> 00:31:39,239
and after analyzing that function again

904
00:31:37,259 --> 00:31:40,440
I look at the context of it and I don't

905
00:31:39,239 --> 00:31:41,460
want to get lost in the weeds I don't

906
00:31:40,440 --> 00:31:43,769
wanna have to go through every single

907
00:31:41,460 --> 00:31:46,739
this assembly instruction so what I what

908
00:31:43,769 --> 00:31:48,359
I generally consider is that if this is

909
00:31:46,739 --> 00:31:50,220
doing some unpacking then it's probably

910
00:31:48,359 --> 00:31:51,869
gonna begin by allocating some memory

911
00:31:50,220 --> 00:31:53,609
it's probably then gonna copy stuff into

912
00:31:51,869 --> 00:31:55,649
memory probably deeossie skating it

913
00:31:53,609 --> 00:31:57,269
along the way and when it's done it's

914
00:31:55,649 --> 00:31:59,039
going to transfer control to whatever it

915
00:31:57,269 --> 00:32:01,229
just do few skated or the shell code

916
00:31:59,039 --> 00:32:03,509
that it just created so I take the

917
00:32:01,229 --> 00:32:05,369
function graph I go to the bottom this

918
00:32:03,509 --> 00:32:07,139
one there really wasn't much there other

919
00:32:05,369 --> 00:32:08,629
than this call so if you disassemble

920
00:32:07,139 --> 00:32:11,369
this you'll see what I'm talking about

921
00:32:08,629 --> 00:32:13,738
this call right here is calling a D word

922
00:32:11,369 --> 00:32:16,559
and again this value is being populated

923
00:32:13,739 --> 00:32:17,789
dynamically during runtime so statically

924
00:32:16,559 --> 00:32:20,970
you can't just double click on that and

925
00:32:17,789 --> 00:32:23,190
see that value set a breakpoint see the

926
00:32:20,970 --> 00:32:26,249
value trace into it that happens to have

927
00:32:23,190 --> 00:32:27,989
gone to this location for 0 AF e0 this

928
00:32:26,249 --> 00:32:29,849
is an already disassembled function

929
00:32:27,989 --> 00:32:31,830
right it just was some for some reason

930
00:32:29,849 --> 00:32:33,629
being dynamically populated in that

931
00:32:31,830 --> 00:32:35,999
global so you might be able to go back

932
00:32:33,629 --> 00:32:37,918
to Ida and find that function so now I

933
00:32:35,999 --> 00:32:38,849
can trace trace the program a little bit

934
00:32:37,919 --> 00:32:40,830
further

935
00:32:38,849 --> 00:32:42,178
same thing here though looking at the

936
00:32:40,830 --> 00:32:44,779
function and its entirety don't to get

937
00:32:42,179 --> 00:32:46,710
lost in the weeds or the details so

938
00:32:44,779 --> 00:32:48,149
eventually see towards the end that

939
00:32:46,710 --> 00:32:50,399
there's another call to a local variable

940
00:32:48,149 --> 00:32:53,248
so something that we saw earlier with

941
00:32:50,399 --> 00:32:57,178
that that shellcode set a breakpoint

942
00:32:53,249 --> 00:32:59,609
here and this is calling into this

943
00:32:57,179 --> 00:33:01,769
location right and seeing this in memory

944
00:32:59,609 --> 00:33:03,570
now we can identify that this is an

945
00:33:01,769 --> 00:33:05,940
address that a dot at the normal image

946
00:33:03,570 --> 00:33:07,529
base of our program and so it must have

947
00:33:05,940 --> 00:33:09,539
been from a memory allocation it must be

948
00:33:07,529 --> 00:33:11,970
shellcode not only do we see this

949
00:33:09,539 --> 00:33:13,529
allocation its unpacked we can pull this

950
00:33:11,970 --> 00:33:15,299
out of memory and we know where the

951
00:33:13,529 --> 00:33:18,749
entry point is because we just followed

952
00:33:15,299 --> 00:33:20,350
the call to this location so taking that

953
00:33:18,749 --> 00:33:21,760
shellcode out of memory

954
00:33:20,350 --> 00:33:23,469
I didn't spend a lot of time looking at

955
00:33:21,760 --> 00:33:25,300
what all of the shellcode was doing

956
00:33:23,470 --> 00:33:27,700
I started tracing down to the bottom of

957
00:33:25,300 --> 00:33:30,760
the shellcode until I found this jump

958
00:33:27,700 --> 00:33:42,070
EAX so we're jumping to whatever EAX is

959
00:33:30,760 --> 00:33:45,490
in this case it took me to this location

960
00:33:42,070 --> 00:33:46,780
4 0 1 a 4 0 so it took me back to the

961
00:33:45,490 --> 00:33:49,300
address space from where that original

962
00:33:46,780 --> 00:33:50,350
program began executed so that was

963
00:33:49,300 --> 00:33:52,570
interesting

964
00:33:50,350 --> 00:33:54,459
it helped me confirm that I was at the

965
00:33:52,570 --> 00:33:56,649
point where it was unpacked I went ahead

966
00:33:54,460 --> 00:33:58,840
and I compared the location and the

967
00:33:56,650 --> 00:34:00,700
instructions that were there in memory

968
00:33:58,840 --> 00:34:02,350
versus what was originally there when I

969
00:34:00,700 --> 00:34:04,090
disassembled it and I saw that they were

970
00:34:02,350 --> 00:34:05,439
different instructions so now I know I'm

971
00:34:04,090 --> 00:34:06,790
at the entry point of the Sun packed

972
00:34:05,440 --> 00:34:08,830
codes and I can begin doing some

973
00:34:06,790 --> 00:34:10,029
analysis so I didn't have to get lost in

974
00:34:08,830 --> 00:34:11,529
the weeds you could do this in the

975
00:34:10,030 --> 00:34:14,140
sample it just takes a couple of minutes

976
00:34:11,530 --> 00:34:15,970
really and it gets you into the inner

977
00:34:14,139 --> 00:34:19,000
workings of whatever is packed inside

978
00:34:15,969 --> 00:34:22,120
here smoke loader is another example

979
00:34:19,000 --> 00:34:23,770
there's the md5 sometimes you're going

980
00:34:22,120 --> 00:34:25,600
to be able to detect packing with tools

981
00:34:23,770 --> 00:34:27,790
that will apply signatures and be able

982
00:34:25,600 --> 00:34:31,389
to identify well-known packing routines

983
00:34:27,790 --> 00:34:36,429
pé compact - then there's tools that can

984
00:34:31,389 --> 00:34:38,440
help you unpack that and then that can

985
00:34:36,429 --> 00:34:40,030
take you to the next stage that doesn't

986
00:34:38,440 --> 00:34:41,620
mean there isn't more layers of packing

987
00:34:40,030 --> 00:34:43,090
and in this case there is more layers of

988
00:34:41,620 --> 00:34:46,359
packing and there's also some anti

989
00:34:43,090 --> 00:34:48,460
analysis so some of that by doing the

990
00:34:46,360 --> 00:34:50,020
same process of analysis that we've been

991
00:34:48,460 --> 00:34:51,280
talking about allows you to determine

992
00:34:50,020 --> 00:34:52,929
whether or not it's packed so this is

993
00:34:51,280 --> 00:34:55,750
just disassembling that unpacked sample

994
00:34:52,929 --> 00:34:57,400
and just recognizing that right we've

995
00:34:55,750 --> 00:34:59,530
got some again some strange code that we

996
00:34:57,400 --> 00:35:02,050
have to start chugging through some of

997
00:34:59,530 --> 00:35:04,000
the techniques that gets the pen at FS

998
00:35:02,050 --> 00:35:06,280
30 hex so that's usually an instruction

999
00:35:04,000 --> 00:35:07,450
that stands out pretty you know it

1000
00:35:06,280 --> 00:35:10,300
really stands out to me when I'm looking

1001
00:35:07,450 --> 00:35:13,089
at any binary it moves that into EAX

1002
00:35:10,300 --> 00:35:14,980
that then moves that into ESI probably

1003
00:35:13,090 --> 00:35:16,900
to save it use it later but the

1004
00:35:14,980 --> 00:35:18,760
important part here is the ax + 2 is

1005
00:35:16,900 --> 00:35:21,730
moved into al it's then tested and a

1006
00:35:18,760 --> 00:35:23,800
conditional jump follows that offset in

1007
00:35:21,730 --> 00:35:25,780
the peb - hex right the peb is a

1008
00:35:23,800 --> 00:35:28,270
structure and you can find it somewhat

1009
00:35:25,780 --> 00:35:32,740
defined on Wikipedia somewhat defined on

1010
00:35:28,270 --> 00:35:34,210
MSDN that that member right there is the

1011
00:35:32,740 --> 00:35:35,589
is being debugged flag

1012
00:35:34,210 --> 00:35:37,059
so it's just simply detecting or

1013
00:35:35,589 --> 00:35:40,000
determining base off of that structure

1014
00:35:37,059 --> 00:35:41,650
in a non API way right there are api's

1015
00:35:40,000 --> 00:35:43,210
that microsoft recommends for detecting

1016
00:35:41,650 --> 00:35:46,000
this behavior looking for that is being

1017
00:35:43,210 --> 00:35:49,990
debugged flight this isn't it it's just

1018
00:35:46,000 --> 00:35:51,280
seeing if it's being debugged okay a

1019
00:35:49,990 --> 00:35:53,919
little bit later on in the code whole

1020
00:35:51,280 --> 00:35:56,020
series of checks ESI if you recall

1021
00:35:53,920 --> 00:35:58,960
that's our peb it's moving an offset of

1022
00:35:56,020 --> 00:36:01,960
68 hex into e in the e ax it then from

1023
00:35:58,960 --> 00:36:04,599
there uses EI x + 10 and what this ends

1024
00:36:01,960 --> 00:36:06,700
up being is a pointer to the process

1025
00:36:04,599 --> 00:36:08,559
heap and if the program is being

1026
00:36:06,700 --> 00:36:10,808
debugged at an offset of 10 from that

1027
00:36:08,559 --> 00:36:13,420
process heap you'll have a value of 70

1028
00:36:10,809 --> 00:36:15,220
hex which is why or where this value

1029
00:36:13,420 --> 00:36:17,260
here for this bit wise end is coming

1030
00:36:15,220 --> 00:36:19,419
from it been tests and again if it

1031
00:36:17,260 --> 00:36:21,520
determines it is in a debug environment

1032
00:36:19,420 --> 00:36:23,760
it can modify its behavior or just abort

1033
00:36:21,520 --> 00:36:25,780
program to hit or the program itself

1034
00:36:23,760 --> 00:36:28,240
there's one more that smoke loader

1035
00:36:25,780 --> 00:36:30,250
exhibits at least in the amount of the

1036
00:36:28,240 --> 00:36:31,899
code that I looked at st. an ESI

1037
00:36:30,250 --> 00:36:34,390
structure this happens to be the process

1038
00:36:31,900 --> 00:36:36,309
heap this gives us at an offset of 10

1039
00:36:34,390 --> 00:36:37,930
hex the force flakes and the force Flags

1040
00:36:36,309 --> 00:36:39,040
is another flag that tells the kernel

1041
00:36:37,930 --> 00:36:40,540
whether or not that process is being

1042
00:36:39,040 --> 00:36:42,130
debug if we started with a debugger

1043
00:36:40,540 --> 00:36:43,900
right so several different well-known

1044
00:36:42,130 --> 00:36:46,960
techniques that are that are still being

1045
00:36:43,900 --> 00:36:50,319
used and employed this one in addition

1046
00:36:46,960 --> 00:36:53,920
uses rc4 encryption and so what you'll

1047
00:36:50,319 --> 00:36:55,150
find is that in some of the functions

1048
00:36:53,920 --> 00:36:57,190
functions are going to use strings

1049
00:36:55,150 --> 00:36:59,109
you're gonna find these sequences of

1050
00:36:57,190 --> 00:37:00,579
what appears like random data it looks

1051
00:36:59,109 --> 00:37:03,160
like a stack string except that if you

1052
00:37:00,579 --> 00:37:04,270
convert that data to ASCII it's not

1053
00:37:03,160 --> 00:37:07,359
going to convert because it's still

1054
00:37:04,270 --> 00:37:10,450
encrypted so one pattern though is

1055
00:37:07,359 --> 00:37:11,828
overlaps and that is the null byte so CL

1056
00:37:10,450 --> 00:37:13,930
if we could see all the code up above

1057
00:37:11,829 --> 00:37:15,549
that register was ex-ored so we have a

1058
00:37:13,930 --> 00:37:18,910
null byte - then we'll terminate this

1059
00:37:15,549 --> 00:37:21,730
this buffer of data and so this process

1060
00:37:18,910 --> 00:37:24,040
repeats so anytime that in this code it

1061
00:37:21,730 --> 00:37:26,109
needs to do a skate or decrypt a string

1062
00:37:24,040 --> 00:37:28,690
it's gonna set them up on the stack and

1063
00:37:26,109 --> 00:37:30,279
then you'll see this call a little bit

1064
00:37:28,690 --> 00:37:32,349
later on and I remain renamed mine

1065
00:37:30,280 --> 00:37:33,790
decrypt string this one took a little

1066
00:37:32,349 --> 00:37:35,740
bit of analysis to figure out exactly

1067
00:37:33,790 --> 00:37:38,799
what it was doing but the gist of it is

1068
00:37:35,740 --> 00:37:42,490
that it's apologises a little bit out of

1069
00:37:38,799 --> 00:37:44,170
sight out of order that's the function

1070
00:37:42,490 --> 00:37:46,509
and I said that there's a little bit of

1071
00:37:44,170 --> 00:37:47,980
occupation first alright that's it

1072
00:37:46,510 --> 00:37:49,750
injected just

1073
00:37:47,980 --> 00:37:51,250
of junk instructions at the beginning of

1074
00:37:49,750 --> 00:37:53,410
this function and that's what the

1075
00:37:51,250 --> 00:37:55,420
function graph looks like just one big

1076
00:37:53,410 --> 00:37:57,009
soft line so you have to figure out

1077
00:37:55,420 --> 00:37:58,900
exactly where those junk instructions

1078
00:37:57,010 --> 00:38:00,640
are and focus on just the functionality

1079
00:37:58,900 --> 00:38:02,530
and again usually you can you can start

1080
00:38:00,640 --> 00:38:06,490
to see the patterns so you know what's

1081
00:38:02,530 --> 00:38:08,410
junk and what isn't so this one pushes

1082
00:38:06,490 --> 00:38:11,618
the size of the string onto the stack so

1083
00:38:08,410 --> 00:38:14,500
it knows what bytes to decrypt it then

1084
00:38:11,619 --> 00:38:15,340
moves a pointer for that string into the

1085
00:38:14,500 --> 00:38:18,790
stack as well

1086
00:38:15,340 --> 00:38:22,330
so into EAX and then push EAX we then

1087
00:38:18,790 --> 00:38:23,830
push a or move a key into ECX so it's a

1088
00:38:22,330 --> 00:38:26,170
hard coded key and that same key is

1089
00:38:23,830 --> 00:38:27,700
actually used for every single string

1090
00:38:26,170 --> 00:38:30,600
that it's encrypted so it's it's a

1091
00:38:27,700 --> 00:38:33,430
constant key the function is called and

1092
00:38:30,600 --> 00:38:35,560
after it's called there you can see the

1093
00:38:33,430 --> 00:38:37,359
key but more importantly if you look at

1094
00:38:35,560 --> 00:38:40,270
the pointer to the stack string it is

1095
00:38:37,359 --> 00:38:42,490
now in its decrypted form so with this

1096
00:38:40,270 --> 00:38:43,960
because it's using well-known crypto you

1097
00:38:42,490 --> 00:38:45,160
could recognize that pattern probably

1098
00:38:43,960 --> 00:38:47,200
write a plug-in go through those stack

1099
00:38:45,160 --> 00:38:48,910
strings decrypt them and add a comment

1100
00:38:47,200 --> 00:38:51,520
or an annotation your Ida database to

1101
00:38:48,910 --> 00:38:53,109
help with your analysis jump chains are

1102
00:38:51,520 --> 00:38:55,350
another problem and this is another

1103
00:38:53,109 --> 00:38:59,950
technique that smoke loader employees

1104
00:38:55,350 --> 00:39:03,250
and here is an example of this problem

1105
00:38:59,950 --> 00:39:05,379
it starts our program start at start not

1106
00:39:03,250 --> 00:39:07,240
at main and from here we have a call

1107
00:39:05,380 --> 00:39:09,130
dollar 5 that just takes us to the next

1108
00:39:07,240 --> 00:39:11,350
instruction and these two instructions

1109
00:39:09,130 --> 00:39:13,630
here this is the jump chain you have two

1110
00:39:11,350 --> 00:39:14,890
conditional jumps jump up zero jump if

1111
00:39:13,630 --> 00:39:17,170
not zero they're complementary

1112
00:39:14,890 --> 00:39:18,970
situations and they're both going to the

1113
00:39:17,170 --> 00:39:22,740
same location right so in this

1114
00:39:18,970 --> 00:39:25,390
disassembly you see 4 0 2 9 9 d plus 2

1115
00:39:22,740 --> 00:39:27,549
because Ida doesn't detect that that's

1116
00:39:25,390 --> 00:39:28,930
not really two separate conditional

1117
00:39:27,550 --> 00:39:30,700
jumps it's really just a single

1118
00:39:28,930 --> 00:39:32,980
conditional jump then what will happen

1119
00:39:30,700 --> 00:39:34,689
is if you put some junk instructions

1120
00:39:32,980 --> 00:39:36,640
after that it will continue to

1121
00:39:34,690 --> 00:39:38,380
disassemble and you'll get incorrect

1122
00:39:36,640 --> 00:39:40,839
disassembly results and you can actually

1123
00:39:38,380 --> 00:39:43,180
see this right here

1124
00:39:40,840 --> 00:39:45,280
and that we're jumping to this location

1125
00:39:43,180 --> 00:39:47,319
plus 2 but Ida didn't create this

1126
00:39:45,280 --> 00:39:49,420
location right here's our label for 0 to

1127
00:39:47,320 --> 00:39:50,740
9 9 d but it's going to plus 2 and

1128
00:39:49,420 --> 00:39:52,869
that's because this disassembly was

1129
00:39:50,740 --> 00:39:55,089
incorrect so you can manually fix that

1130
00:39:52,869 --> 00:39:57,430
up you can convert that back to data and

1131
00:39:55,090 --> 00:39:59,710
then go to the right location which is

1132
00:39:57,430 --> 00:40:00,919
this address plus 2 and then go ahead

1133
00:39:59,710 --> 00:40:03,470
and tell it to disk

1134
00:40:00,920 --> 00:40:05,900
correctly but that's very tedious and

1135
00:40:03,470 --> 00:40:07,100
time-consuming so there's some scripts I

1136
00:40:05,900 --> 00:40:08,960
have some examples and I'm going to link

1137
00:40:07,100 --> 00:40:12,110
to a few here in just a moment that will

1138
00:40:08,960 --> 00:40:13,790
go through and essentially identify all

1139
00:40:12,110 --> 00:40:15,110
of those situations you can look at the

1140
00:40:13,790 --> 00:40:17,120
opcodes so you can look at the actual

1141
00:40:15,110 --> 00:40:19,460
byte values and say oh here's a here's a

1142
00:40:17,120 --> 00:40:21,080
short drum here's a long jump we see two

1143
00:40:19,460 --> 00:40:23,870
of them together so we know that the

1144
00:40:21,080 --> 00:40:25,640
address that you know the jump target is

1145
00:40:23,870 --> 00:40:27,200
actually where we're going so let's just

1146
00:40:25,640 --> 00:40:29,210
replace the first instance with an

1147
00:40:27,200 --> 00:40:31,069
unconditional jump to that location and

1148
00:40:29,210 --> 00:40:33,050
then not about the other one all right

1149
00:40:31,070 --> 00:40:34,700
and then your disassembly can look a lot

1150
00:40:33,050 --> 00:40:37,670
more accurate and it will clean up the

1151
00:40:34,700 --> 00:40:39,290
code a little bit so that's one of the

1152
00:40:37,670 --> 00:40:41,390
techniques and anti disassembly the

1153
00:40:39,290 --> 00:40:43,040
other thing that it's doing then is also

1154
00:40:41,390 --> 00:40:45,140
making your function graphs a little bit

1155
00:40:43,040 --> 00:40:46,940
harder to generate because you have a

1156
00:40:45,140 --> 00:40:48,319
jump and then an instruction to another

1157
00:40:46,940 --> 00:40:50,090
jump and an instruction then another

1158
00:40:48,320 --> 00:40:51,380
jump and so you've got these chains of

1159
00:40:50,090 --> 00:40:54,170
jumps that are just really annoying to

1160
00:40:51,380 --> 00:40:56,000
look at so all of this code if you were

1161
00:40:54,170 --> 00:40:58,790
to trace through it is essentially just

1162
00:40:56,000 --> 00:41:00,440
doing these commands here so with smoke

1163
00:40:58,790 --> 00:41:02,060
loader it is a little bit of jump chains

1164
00:41:00,440 --> 00:41:04,490
at the beginning and then you get back

1165
00:41:02,060 --> 00:41:06,259
into kind of normal functionality we'll

1166
00:41:04,490 --> 00:41:08,540
talk real briefly here because I'm

1167
00:41:06,260 --> 00:41:09,800
running out of time with fin spy and fin

1168
00:41:08,540 --> 00:41:12,200
spy does it just about through the whole

1169
00:41:09,800 --> 00:41:15,140
darn program so it's more prevalent and

1170
00:41:12,200 --> 00:41:16,609
it's a lot more painful to deal with for

1171
00:41:15,140 --> 00:41:19,009
your reference there's a difference

1172
00:41:16,610 --> 00:41:22,550
between the two original disassembly and

1173
00:41:19,010 --> 00:41:23,750
then actually it looks like the same

1174
00:41:22,550 --> 00:41:25,130
thing so I have a saw I had a screen

1175
00:41:23,750 --> 00:41:27,920
shot apparently I failed to post the

1176
00:41:25,130 --> 00:41:29,870
right one what that looks like after the

1177
00:41:27,920 --> 00:41:31,460
plug-in ran and cleaned up all of those

1178
00:41:29,870 --> 00:41:33,319
locations so the plugin was able to go

1179
00:41:31,460 --> 00:41:35,930
through read the actual op codes for all

1180
00:41:33,320 --> 00:41:37,580
the instructions and then clean up the

1181
00:41:35,930 --> 00:41:38,720
entire database for me so that I didn't

1182
00:41:37,580 --> 00:41:41,569
have to go through and do that one

1183
00:41:38,720 --> 00:41:42,850
manually one one of those jump spots at

1184
00:41:41,570 --> 00:41:46,160
a time

1185
00:41:42,850 --> 00:41:47,990
all right the last thing is just to

1186
00:41:46,160 --> 00:41:50,899
discuss a little bit about finfisher fin

1187
00:41:47,990 --> 00:41:53,240
Spy this one I encountered earlier this

1188
00:41:50,900 --> 00:41:55,550
year which seemed to coincide with some

1189
00:41:53,240 --> 00:41:57,919
notable researchers also publishing

1190
00:41:55,550 --> 00:41:59,480
information about analysis on fin spine

1191
00:41:57,920 --> 00:42:01,820
in particular the use of the virtual

1192
00:41:59,480 --> 00:42:03,710
machine so when I first encountered this

1193
00:42:01,820 --> 00:42:05,510
I didn't recognize I'd never encountered

1194
00:42:03,710 --> 00:42:07,550
a virtual machine at least used in

1195
00:42:05,510 --> 00:42:09,080
malware before and I certainly have

1196
00:42:07,550 --> 00:42:10,700
never taken the time to reverse-engineer

1197
00:42:09,080 --> 00:42:12,890
the java virtual machine or anything

1198
00:42:10,700 --> 00:42:14,169
like that so it really threw me off

1199
00:42:12,890 --> 00:42:15,520
because I didn't understand

1200
00:42:14,170 --> 00:42:17,320
what I was looking at it took me some

1201
00:42:15,520 --> 00:42:19,240
time to recognize what it was and

1202
00:42:17,320 --> 00:42:20,620
because some of this research happened

1203
00:42:19,240 --> 00:42:22,419
to come out at the same time became very

1204
00:42:20,620 --> 00:42:23,920
instrumental for me to figure out a

1205
00:42:22,420 --> 00:42:26,110
little bit better what was going on here

1206
00:42:23,920 --> 00:42:27,580
I won't get into finfisher Finn's pie

1207
00:42:26,110 --> 00:42:29,230
because I don't really know a whole lot

1208
00:42:27,580 --> 00:42:31,120
about all the data breach and stuff it's

1209
00:42:29,230 --> 00:42:33,160
out there it's on Wikileaks it's still

1210
00:42:31,120 --> 00:42:37,210
being used it was sold by a German UK

1211
00:42:33,160 --> 00:42:40,270
company as a IT monitoring solution to

1212
00:42:37,210 --> 00:42:41,440
put it very politely and the resources

1213
00:42:40,270 --> 00:42:44,110
that I found the most helpful and

1214
00:42:41,440 --> 00:42:47,290
analyzing this ESET has a white paper

1215
00:42:44,110 --> 00:42:48,880
with some code so it's an almost 100%

1216
00:42:47,290 --> 00:42:49,990
solution there's some gaps that you'd

1217
00:42:48,880 --> 00:42:51,460
have to fill if you were going to try to

1218
00:42:49,990 --> 00:42:54,009
recreate this work based off of their

1219
00:42:51,460 --> 00:42:55,570
paper mobius strip has a site and there

1220
00:42:54,010 --> 00:42:57,370
is an extensive number of articles

1221
00:42:55,570 --> 00:42:59,290
they're a really great resource and then

1222
00:42:57,370 --> 00:43:01,779
Microsoft has also published it some

1223
00:42:59,290 --> 00:43:03,279
technical analysis so three really great

1224
00:43:01,780 --> 00:43:06,160
sources of information came out earlier

1225
00:43:03,280 --> 00:43:08,320
this year so why a virtual machine it's

1226
00:43:06,160 --> 00:43:10,240
another layer of obfuscation so if you

1227
00:43:08,320 --> 00:43:11,560
take a dotnet program for example it's

1228
00:43:10,240 --> 00:43:14,799
byte code it gets interpreted by the

1229
00:43:11,560 --> 00:43:16,270
dotnet runtime the CLR and that bytecode

1230
00:43:14,800 --> 00:43:18,670
is then interpreted in the machine code

1231
00:43:16,270 --> 00:43:20,770
so if you took a dotnet binary and you

1232
00:43:18,670 --> 00:43:22,270
disassembled it with with Ida Pro you'd

1233
00:43:20,770 --> 00:43:24,540
be looking at that bytecode and that

1234
00:43:22,270 --> 00:43:27,220
process of however it's being converted

1235
00:43:24,540 --> 00:43:29,410
or some something that would look pretty

1236
00:43:27,220 --> 00:43:31,240
awful anyway it is not the right tool

1237
00:43:29,410 --> 00:43:33,339
right there are tools that will then be

1238
00:43:31,240 --> 00:43:35,890
able to parse that bytecode and turn it

1239
00:43:33,340 --> 00:43:37,870
back into D compiled code so DN Spy is

1240
00:43:35,890 --> 00:43:38,980
an example it'll it look like the

1241
00:43:37,870 --> 00:43:41,980
original or more like the original

1242
00:43:38,980 --> 00:43:43,960
c-sharp this creates a nice layer of a

1243
00:43:41,980 --> 00:43:45,370
few station and at least for me one that

1244
00:43:43,960 --> 00:43:47,860
was pretty effective when I encountered

1245
00:43:45,370 --> 00:43:49,720
it there's a virtual processor that has

1246
00:43:47,860 --> 00:43:51,010
now built into the program versus having

1247
00:43:49,720 --> 00:43:52,740
that virtual machine running within the

1248
00:43:51,010 --> 00:43:54,760
host so there is a distinction there

1249
00:43:52,740 --> 00:43:56,140
full of byte codes of virtual

1250
00:43:54,760 --> 00:43:58,300
instructions that have to be translated

1251
00:43:56,140 --> 00:44:00,490
through the program into native code in

1252
00:43:58,300 --> 00:44:01,810
order to get the actual functionality so

1253
00:44:00,490 --> 00:44:03,490
in order to understand what the program

1254
00:44:01,810 --> 00:44:05,470
is doing at least from that that static

1255
00:44:03,490 --> 00:44:07,540
analysis perspective is you have to

1256
00:44:05,470 --> 00:44:09,009
understand what those virtual

1257
00:44:07,540 --> 00:44:10,750
instructions are how the virtual machine

1258
00:44:09,010 --> 00:44:12,610
works so that you can understand how

1259
00:44:10,750 --> 00:44:15,810
it's translating those into those native

1260
00:44:12,610 --> 00:44:18,790
code calls so it's quite a bit of work

1261
00:44:15,810 --> 00:44:19,810
those the processor the bytecode that

1262
00:44:18,790 --> 00:44:22,150
that intermediate code that can be

1263
00:44:19,810 --> 00:44:23,590
defined by the developer so you can find

1264
00:44:22,150 --> 00:44:24,700
that it'll be easy if they have of

1265
00:44:23,590 --> 00:44:26,740
course the source to build this

1266
00:44:24,700 --> 00:44:27,549
something that they can easily tweak so

1267
00:44:26,740 --> 00:44:29,979
that your

1268
00:44:27,550 --> 00:44:31,690
scripts or tools or that are tackling

1269
00:44:29,980 --> 00:44:34,300
these problems can change and you have

1270
00:44:31,690 --> 00:44:35,800
to update those as well as of course

1271
00:44:34,300 --> 00:44:37,060
there can be a variety of different VM

1272
00:44:35,800 --> 00:44:39,640
solutions out there and there are there

1273
00:44:37,060 --> 00:44:45,990
are some proprietary ones that that you

1274
00:44:39,640 --> 00:44:49,270
could take a look at okay so this sample

1275
00:44:45,990 --> 00:44:51,250
if you grab a copy the md5 they put it

1276
00:44:49,270 --> 00:44:52,480
the original slide and you disassemble

1277
00:44:51,250 --> 00:44:54,130
it you're gonna find that the beginning

1278
00:44:52,480 --> 00:44:55,960
starts with a bunch of junk instructions

1279
00:44:54,130 --> 00:44:57,970
and as you navigate down those junk

1280
00:44:55,960 --> 00:45:00,310
instructions you'll find this pattern

1281
00:44:57,970 --> 00:45:03,040
which is this push followed by a jump

1282
00:45:00,310 --> 00:45:05,259
this jump to this location is actually

1283
00:45:03,040 --> 00:45:08,080
our entry point so it's like our the

1284
00:45:05,260 --> 00:45:10,300
beginning of our VM and this push value

1285
00:45:08,080 --> 00:45:12,370
right here is identifying the virtual

1286
00:45:10,300 --> 00:45:13,600
instruction so we're calling the entry

1287
00:45:12,370 --> 00:45:15,190
point we're pushing the idea of the

1288
00:45:13,600 --> 00:45:17,890
instruction that we want to call and

1289
00:45:15,190 --> 00:45:19,570
that starts the process one way you can

1290
00:45:17,890 --> 00:45:20,710
recognize this and this is what I was

1291
00:45:19,570 --> 00:45:23,500
referring to with all these junk

1292
00:45:20,710 --> 00:45:25,840
instructions when when you can identify

1293
00:45:23,500 --> 00:45:27,940
this is by looking at the cross

1294
00:45:25,840 --> 00:45:30,190
references to that location and you can

1295
00:45:27,940 --> 00:45:32,800
see in this sample here that there are

1296
00:45:30,190 --> 00:45:34,620
124 different cross references to that

1297
00:45:32,800 --> 00:45:37,840
location so it's a very heavily used

1298
00:45:34,620 --> 00:45:39,339
point in the program so my initial

1299
00:45:37,840 --> 00:45:41,470
assessment was that it was the entry

1300
00:45:39,340 --> 00:45:42,820
point as well as you can I was able to

1301
00:45:41,470 --> 00:45:46,060
confirm that with some of that research

1302
00:45:42,820 --> 00:45:47,980
that was also published from here you're

1303
00:45:46,060 --> 00:45:49,390
gonna run into some jump chains so the

1304
00:45:47,980 --> 00:45:52,300
first thing that you had to do that I

1305
00:45:49,390 --> 00:45:53,830
had to do was you know really adapt the

1306
00:45:52,300 --> 00:45:56,050
script that I have made for smoke loader

1307
00:45:53,830 --> 00:45:58,150
and get it to go through this database

1308
00:45:56,050 --> 00:46:00,160
and try to identify all these sites and

1309
00:45:58,150 --> 00:46:02,890
really clean up the database once I was

1310
00:46:00,160 --> 00:46:06,069
able to do that then I was able to

1311
00:46:02,890 --> 00:46:08,350
create a cleaner call graph so I could

1312
00:46:06,070 --> 00:46:10,390
then convert that location to a function

1313
00:46:08,350 --> 00:46:12,460
and I could toggle from the linear view

1314
00:46:10,390 --> 00:46:14,290
back to the function call graph view and

1315
00:46:12,460 --> 00:46:17,290
I came up with something that looked

1316
00:46:14,290 --> 00:46:20,200
like this we won't have time to go into

1317
00:46:17,290 --> 00:46:22,150
all the details here and so we'll just

1318
00:46:20,200 --> 00:46:24,460
focus on the essentials and what this is

1319
00:46:22,150 --> 00:46:27,040
essentially doing is it's preparing what

1320
00:46:24,460 --> 00:46:29,800
is called the dispatcher so we're taking

1321
00:46:27,040 --> 00:46:32,470
a virtual opcode a virtual instruction

1322
00:46:29,800 --> 00:46:33,640
the virtual machine this entry point

1323
00:46:32,470 --> 00:46:36,189
then is going to do some things to

1324
00:46:33,640 --> 00:46:37,990
prepare this dispatcher to know and

1325
00:46:36,190 --> 00:46:39,610
process what that destruction is and the

1326
00:46:37,990 --> 00:46:40,919
code that can handle its interpretation

1327
00:46:39,610 --> 00:46:43,140
its execution

1328
00:46:40,920 --> 00:46:44,640
so that's all that it's doing so it's

1329
00:46:43,140 --> 00:46:46,350
it's allocating some memory it's

1330
00:46:44,640 --> 00:46:48,870
creating a virtual staff for the VM

1331
00:46:46,350 --> 00:46:51,630
that's going to be running with this

1332
00:46:48,870 --> 00:46:53,430
sample it did do some encryption so the

1333
00:46:51,630 --> 00:46:54,810
instructions had to be XOR decrypted

1334
00:46:53,430 --> 00:46:55,350
they were then packed they had to be

1335
00:46:54,810 --> 00:46:56,850
unpacked

1336
00:46:55,350 --> 00:46:59,819
they were then still encrypted they had

1337
00:46:56,850 --> 00:47:01,170
to be being decrypted again so all of

1338
00:46:59,820 --> 00:47:05,910
this is happening inside of this chunk

1339
00:47:01,170 --> 00:47:09,510
of code and eventually once we get to

1340
00:47:05,910 --> 00:47:12,330
the very end then it's ready to call the

1341
00:47:09,510 --> 00:47:14,100
appropriate dispatcher so that is the

1342
00:47:12,330 --> 00:47:15,930
the section of code that's responsible

1343
00:47:14,100 --> 00:47:19,589
for now interpreting whatever that

1344
00:47:15,930 --> 00:47:22,259
instruction actually is ESET had some

1345
00:47:19,590 --> 00:47:23,700
really good tools available because they

1346
00:47:22,260 --> 00:47:25,530
did a lot of in-depth work here so they

1347
00:47:23,700 --> 00:47:27,120
identified some key structures that are

1348
00:47:25,530 --> 00:47:28,860
available or they're used throughout

1349
00:47:27,120 --> 00:47:30,420
this virtual machine one is the context

1350
00:47:28,860 --> 00:47:32,700
so when instruction is about to be

1351
00:47:30,420 --> 00:47:34,710
executed there is a structure a context

1352
00:47:32,700 --> 00:47:38,960
structure that's created and that

1353
00:47:34,710 --> 00:47:41,250
structure crap I got ahead of myself

1354
00:47:38,960 --> 00:47:42,870
that structure contains important

1355
00:47:41,250 --> 00:47:44,370
elements like where does the stack again

1356
00:47:42,870 --> 00:47:45,630
where does the image begin where where

1357
00:47:44,370 --> 00:47:47,490
are the arguments where is the virtual

1358
00:47:45,630 --> 00:47:51,870
instruction and I have it listed here a

1359
00:47:47,490 --> 00:47:54,270
little bit better later on at the end of

1360
00:47:51,870 --> 00:47:56,609
that that start that entry point of the

1361
00:47:54,270 --> 00:47:59,550
virtual machine you'll find this jump

1362
00:47:56,610 --> 00:48:01,530
and this is the actual transition from

1363
00:47:59,550 --> 00:48:03,660
start to that dispatcher so at this

1364
00:48:01,530 --> 00:48:05,310
point you could set a breakpoint and you

1365
00:48:03,660 --> 00:48:07,620
could see where this is going and where

1366
00:48:05,310 --> 00:48:09,240
this is going is essentially a jump

1367
00:48:07,620 --> 00:48:10,680
table right so it did a little bit of

1368
00:48:09,240 --> 00:48:13,020
analysis there and preparing for the

1369
00:48:10,680 --> 00:48:16,080
execution of that virtual instruction to

1370
00:48:13,020 --> 00:48:23,790
load the right location for that handler

1371
00:48:16,080 --> 00:48:26,460
so it's just a jump table this is what

1372
00:48:23,790 --> 00:48:28,770
the dispatcher looked like and that last

1373
00:48:26,460 --> 00:48:31,140
basic block is where that handler will

1374
00:48:28,770 --> 00:48:32,759
then transfer that control the the

1375
00:48:31,140 --> 00:48:36,509
dispatcher will transfer control to the

1376
00:48:32,760 --> 00:48:38,430
handler so what you can do is you can

1377
00:48:36,510 --> 00:48:40,740
actually add cross references to those

1378
00:48:38,430 --> 00:48:42,720
locations so we had that jump table the

1379
00:48:40,740 --> 00:48:45,149
list of those those those call tools

1380
00:48:42,720 --> 00:48:46,589
jump targets and you can go in HIDA and

1381
00:48:45,150 --> 00:48:47,820
actually add cross references to those

1382
00:48:46,590 --> 00:48:49,320
you can say okay at the end of my

1383
00:48:47,820 --> 00:48:51,300
dispatcher function there's actually a

1384
00:48:49,320 --> 00:48:53,370
cross-reference to this location and if

1385
00:48:51,300 --> 00:48:54,180
you do that then it will make your

1386
00:48:53,370 --> 00:48:56,460
function graph

1387
00:48:54,180 --> 00:48:57,839
like this right which at least to me

1388
00:48:56,460 --> 00:48:59,850
made it look a little bit more obvious

1389
00:48:57,840 --> 00:49:03,150
as to the fact that there was some sort

1390
00:48:59,850 --> 00:49:06,000
of a dispatcher routine here so jump

1391
00:49:03,150 --> 00:49:07,230
then this code here is the dispatchers

1392
00:49:06,000 --> 00:49:09,900
this handles whatever that virtual

1393
00:49:07,230 --> 00:49:12,090
instruction was as I said there's still

1394
00:49:09,900 --> 00:49:15,210
more to go and there's a context

1395
00:49:12,090 --> 00:49:16,850
structure that contains the pointer to

1396
00:49:15,210 --> 00:49:19,350
the bike code they address the VM stack

1397
00:49:16,850 --> 00:49:20,430
the image base the bike code start

1398
00:49:19,350 --> 00:49:23,069
address the virtual instruction

1399
00:49:20,430 --> 00:49:24,509
parameters and instead of linking to it

1400
00:49:23,070 --> 00:49:27,210
here in the slides

1401
00:49:24,510 --> 00:49:28,800
ESET has the entire structure documented

1402
00:49:27,210 --> 00:49:30,690
so what you can do is grab that

1403
00:49:28,800 --> 00:49:32,250
structure and then you can create it in

1404
00:49:30,690 --> 00:49:34,680
Ida and then you can overlay that

1405
00:49:32,250 --> 00:49:36,060
structure and those offsets into where

1406
00:49:34,680 --> 00:49:38,220
that's being used in your code and

1407
00:49:36,060 --> 00:49:39,660
that'll grab add more clarity more

1408
00:49:38,220 --> 00:49:43,319
visibility into what that program is

1409
00:49:39,660 --> 00:49:44,970
actually doing this VM has 34 handlers

1410
00:49:43,320 --> 00:49:46,230
those jump tables those handlers that we

1411
00:49:44,970 --> 00:49:48,240
talked about there's 34 of them that

1412
00:49:46,230 --> 00:49:49,620
means there's 34 op codes so the next

1413
00:49:48,240 --> 00:49:51,540
step is to signature what those are

1414
00:49:49,620 --> 00:49:54,390
doing and then move into the process of

1415
00:49:51,540 --> 00:49:56,509
actually creating a decompiler so this

1416
00:49:54,390 --> 00:49:59,009
was by far for me the most difficult

1417
00:49:56,510 --> 00:50:00,720
level of occupation that I encountered

1418
00:49:59,010 --> 00:50:02,940
because there is so many steps involved

1419
00:50:00,720 --> 00:50:04,680
with it and the time that I had to

1420
00:50:02,940 --> 00:50:07,350
devote to this as a project for some

1421
00:50:04,680 --> 00:50:10,200
work I was doing this far exceeded that

1422
00:50:07,350 --> 00:50:13,290
time so I have a better understanding of

1423
00:50:10,200 --> 00:50:15,629
how they work but again it's a lot of

1424
00:50:13,290 --> 00:50:17,700
time involved here so I thought a

1425
00:50:15,630 --> 00:50:22,530
relatively effective way of slowing down

1426
00:50:17,700 --> 00:50:25,980
the research and the analysis 50 minutes

1427
00:50:22,530 --> 00:50:28,260
so that's all my time I appreciate

1428
00:50:25,980 --> 00:50:29,220
everybody spending the last 50 minutes

1429
00:50:28,260 --> 00:50:31,140
with me talking a little bit about now

1430
00:50:29,220 --> 00:50:33,990
or not be stationed again any questions

1431
00:50:31,140 --> 00:50:35,009
comments anything I said wrong you want

1432
00:50:33,990 --> 00:50:37,589
to correct me on please feel free to

1433
00:50:35,010 --> 00:50:39,300
email me J Stroh shine at VTA labs calm

1434
00:50:37,590 --> 00:50:41,090
and hopefully everyone has a great

1435
00:50:39,300 --> 00:50:41,210
torque on so thank you

1436
00:50:41,090 --> 00:50:42,670
[Music]

1437
00:50:41,210 --> 00:50:45,800
[Applause]

1438
00:50:42,670 --> 00:50:45,800
[Music]

1439
00:50:45,910 --> 00:50:49,920
[Applause]

