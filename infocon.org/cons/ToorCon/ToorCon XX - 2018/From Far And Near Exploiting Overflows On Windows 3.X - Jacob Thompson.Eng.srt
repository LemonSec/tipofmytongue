1
00:00:00,460 --> 00:00:05,240
alright well next up we have Jacob

2
00:00:02,870 --> 00:00:07,220
Thompson giving a talk on exploiting

3
00:00:05,240 --> 00:00:09,320
overflows on windows 3-1 which is

4
00:00:07,220 --> 00:00:10,730
personally one of my favorite OS is from

5
00:00:09,320 --> 00:00:11,509
back in the day and I think this will be

6
00:00:10,730 --> 00:00:18,080
really interesting

7
00:00:11,509 --> 00:00:20,210
please welcome Jacob all right so thanks

8
00:00:18,080 --> 00:00:23,599
everybody so this is called from far and

9
00:00:20,210 --> 00:00:25,430
near exploiting overflows on windows 3.x

10
00:00:23,600 --> 00:00:28,400
or in my case 3.11

11
00:00:25,430 --> 00:00:30,290
so the title if it doesn't make sense

12
00:00:28,400 --> 00:00:32,870
now it will once I get into the C code

13
00:00:30,290 --> 00:00:37,220
and so forth so and we're here at torque

14
00:00:32,870 --> 00:00:40,940
on 20 so I actually did this as a side

15
00:00:37,220 --> 00:00:44,000
project at the office over three or four

16
00:00:40,940 --> 00:00:46,699
weekends so and it's kind of relevant

17
00:00:44,000 --> 00:00:48,860
because what I do day-to-day is we do

18
00:00:46,700 --> 00:00:51,710
high-end custom security assessments and

19
00:00:48,860 --> 00:00:53,390
if there's a custom protocol every now

20
00:00:51,710 --> 00:00:55,190
and then like a custom operating system

21
00:00:53,390 --> 00:00:57,140
custom programming library like tearing

22
00:00:55,190 --> 00:00:58,640
this stuff apart and stuff I get to do

23
00:00:57,140 --> 00:01:00,980
every now and then and this was just

24
00:00:58,640 --> 00:01:02,480
another case of that so white box

25
00:01:00,980 --> 00:01:04,819
security assessment it's kind of what

26
00:01:02,480 --> 00:01:08,030
this is although I guess it was black

27
00:01:04,819 --> 00:01:10,130
box of three 1990 zero internet

28
00:01:08,030 --> 00:01:12,350
applications that I got into and we'll

29
00:01:10,130 --> 00:01:14,149
go through all the details later but

30
00:01:12,350 --> 00:01:16,009
specifically I work at ISE or

31
00:01:14,149 --> 00:01:18,139
independent security evaluators where I

32
00:01:16,009 --> 00:01:20,749
do this kind of stuff sometimes and

33
00:01:18,139 --> 00:01:23,089
we're also running the IOT hacking

34
00:01:20,749 --> 00:01:25,548
contest in the room next door if anybody

35
00:01:23,090 --> 00:01:28,159
wants to get into that it's another semi

36
00:01:25,549 --> 00:01:30,829
obscure set of platforms so if you're

37
00:01:28,159 --> 00:01:32,569
here you might be interested so some

38
00:01:30,829 --> 00:01:35,149
personal background I've been doing this

39
00:01:32,569 --> 00:01:37,130
for six years and specifically in

40
00:01:35,149 --> 00:01:39,560
security consulting I've counted about a

41
00:01:37,130 --> 00:01:41,329
hundred engagements that either

42
00:01:39,560 --> 00:01:44,119
assessments reassessments that I've had

43
00:01:41,329 --> 00:01:46,008
some major role in particular interests

44
00:01:44,119 --> 00:01:49,009
kind of fit right with this reverse

45
00:01:46,009 --> 00:01:50,389
engineering cryptography design flaws

46
00:01:49,009 --> 00:01:52,099
which are kind of an interesting thing

47
00:01:50,389 --> 00:01:55,158
because like a scanner can't find a

48
00:01:52,099 --> 00:01:56,659
design flaw oftentimes where I have some

49
00:01:55,159 --> 00:01:58,999
co-workers out here that are dealing

50
00:01:56,659 --> 00:02:01,909
with some of those right now and this

51
00:01:58,999 --> 00:02:04,399
kind of retro interest because I didn't

52
00:02:01,909 --> 00:02:05,899
do programming or hacking on these

53
00:02:04,399 --> 00:02:08,449
platforms when they were popular but I

54
00:02:05,899 --> 00:02:10,759
did use them and it's interesting to see

55
00:02:08,449 --> 00:02:12,200
how that worked at the time where

56
00:02:10,758 --> 00:02:13,589
obviously we wouldn't have understood

57
00:02:12,200 --> 00:02:18,000
how so

58
00:02:13,590 --> 00:02:19,920
that's kind of interesting as well so

59
00:02:18,000 --> 00:02:21,930
getting into this topic of 16-bit

60
00:02:19,920 --> 00:02:23,458
overflows well first I think it's kind

61
00:02:21,930 --> 00:02:26,790
of interesting and a little amusing like

62
00:02:23,459 --> 00:02:28,410
in popular culture I think 16-bit at 8

63
00:02:26,790 --> 00:02:30,329
bit too a lot of people have something

64
00:02:28,410 --> 00:02:32,430
to do with like really tinny sound and

65
00:02:30,330 --> 00:02:33,750
pixelated images but of course in

66
00:02:32,430 --> 00:02:36,300
programming it has nothing to do with

67
00:02:33,750 --> 00:02:37,860
that in fact 16-bit color is a good

68
00:02:36,300 --> 00:02:41,099
thing right particularly in the days of

69
00:02:37,860 --> 00:02:44,269
Windows 3.1 so that is a little amusing

70
00:02:41,099 --> 00:02:47,069
to me just a little diversion

71
00:02:44,269 --> 00:02:49,110
um so specifically I have a virtual

72
00:02:47,069 --> 00:02:52,290
machine here with windows for workgroups

73
00:02:49,110 --> 00:02:53,580
running if we switch over into that we

74
00:02:52,290 --> 00:02:56,400
can click around and see what I have

75
00:02:53,580 --> 00:02:58,500
installed I took a look at several these

76
00:02:56,400 --> 00:03:00,000
programs here some of them successfully

77
00:02:58,500 --> 00:03:01,530
some of them unsuccessfully and actually

78
00:03:00,000 --> 00:03:05,310
finding anything that I could exploit in

79
00:03:01,530 --> 00:03:07,290
time so we had Acrobat Reader back then

80
00:03:05,310 --> 00:03:10,980
just like now and probably a lot faster

81
00:03:07,290 --> 00:03:13,470
and user-friendly mirc was when I looked

82
00:03:10,980 --> 00:03:15,000
at I no mirc is kind of rampant for

83
00:03:13,470 --> 00:03:16,920
security holes I'm not sure that buffer

84
00:03:15,000 --> 00:03:18,959
overflows necessarily were one of them

85
00:03:16,920 --> 00:03:20,790
and I'm not sure why potentially they

86
00:03:18,959 --> 00:03:22,980
were using C++ with a good string

87
00:03:20,790 --> 00:03:24,810
library or something most of the

88
00:03:22,980 --> 00:03:27,810
problems I found in the three programs I

89
00:03:24,810 --> 00:03:29,519
thought were pretty trivial like taking

90
00:03:27,810 --> 00:03:32,310
a file path that's too long like really

91
00:03:29,519 --> 00:03:33,600
obvious things real player existed back

92
00:03:32,310 --> 00:03:37,350
then I actually can't get it to run

93
00:03:33,600 --> 00:03:39,120
because it requires 256 colors and I'm

94
00:03:37,350 --> 00:03:41,459
not in that mode with the drivers that

95
00:03:39,120 --> 00:03:43,920
are installed so you know our light was

96
00:03:41,459 --> 00:03:45,569
an email client that one I got into some

97
00:03:43,920 --> 00:03:48,208
weird things with a pop protocol and

98
00:03:45,569 --> 00:03:49,560
SMTP but I didn't get anything I think I

99
00:03:48,209 --> 00:03:51,150
was like over writing a novel bite or

100
00:03:49,560 --> 00:03:54,870
something or prematurely terminating a

101
00:03:51,150 --> 00:03:58,769
string it didn't seem to look Overflow

102
00:03:54,870 --> 00:04:00,660
worthy at the time so WS FTP was a

103
00:03:58,769 --> 00:04:02,579
popular FTP client that was the most

104
00:04:00,660 --> 00:04:03,359
amenable one for an interesting exploit

105
00:04:02,579 --> 00:04:07,470
that I came up with

106
00:04:03,359 --> 00:04:09,989
and when zip of course at least up until

107
00:04:07,470 --> 00:04:12,090
what like Windows 2000 or XP that was a

108
00:04:09,989 --> 00:04:15,209
pretty popular tool since it wasn't

109
00:04:12,090 --> 00:04:18,389
built in and then kind of the standard

110
00:04:15,209 --> 00:04:20,789
Windows thing so tcp/ip stack of course

111
00:04:18,389 --> 00:04:23,270
was an optional third party component at

112
00:04:20,789 --> 00:04:26,310
the time and there was one on the

113
00:04:23,270 --> 00:04:27,359
Microsoft FTP server if you can supply

114
00:04:26,310 --> 00:04:29,669
an Ethernet driver for

115
00:04:27,360 --> 00:04:30,900
dial up you're kind of on your own which

116
00:04:29,669 --> 00:04:35,400
you most likely would have been at the

117
00:04:30,900 --> 00:04:37,289
time I also have what became Visual

118
00:04:35,400 --> 00:04:39,508
Studio or wasn't even necessarily

119
00:04:37,289 --> 00:04:43,979
branded that way at the time it comes

120
00:04:39,509 --> 00:04:46,620
with a good set of the IDE debugger and

121
00:04:43,979 --> 00:04:48,900
so forth in some documentation that I

122
00:04:46,620 --> 00:04:49,289
think is actually higher quality than

123
00:04:48,900 --> 00:04:51,900
what

124
00:04:49,289 --> 00:04:53,219
MSDN is today in terms of here's a

125
00:04:51,900 --> 00:04:55,289
function these are the parameters it

126
00:04:53,219 --> 00:04:56,969
takes and this is what it does so we'll

127
00:04:55,289 --> 00:04:58,229
get into that a little bit later but I

128
00:04:56,969 --> 00:04:59,879
think it's actually better than what you

129
00:04:58,229 --> 00:05:02,008
can find today because a lot of that is

130
00:04:59,879 --> 00:05:03,960
devolved into discussion forums or it's

131
00:05:02,009 --> 00:05:05,699
somebody here's an opinion it's right

132
00:05:03,960 --> 00:05:07,198
here's an opinion that's wrong somebody

133
00:05:05,699 --> 00:05:09,599
else says no that's absolutely the wrong

134
00:05:07,199 --> 00:05:12,779
way here's some third-party library you

135
00:05:09,599 --> 00:05:15,900
should use and so forth alright so

136
00:05:12,779 --> 00:05:17,460
getting acquainted there so how did I

137
00:05:15,900 --> 00:05:18,060
get into this why did I get into get

138
00:05:17,460 --> 00:05:20,128
into this

139
00:05:18,060 --> 00:05:21,779
so the IOT stuff is a little bit

140
00:05:20,129 --> 00:05:24,000
relevant we did some really weird things

141
00:05:21,779 --> 00:05:26,639
there back in 2013 when we did our first

142
00:05:24,000 --> 00:05:30,479
round of our own exploits one of those

143
00:05:26,639 --> 00:05:33,870
was some it's all public so in a seuss

144
00:05:30,479 --> 00:05:36,330
router and then some other similar brand

145
00:05:33,870 --> 00:05:38,099
names to that that market is interesting

146
00:05:36,330 --> 00:05:39,990
a lot of them buy like a development kit

147
00:05:38,099 --> 00:05:41,610
off the shelf with like pre-made

148
00:05:39,990 --> 00:05:43,969
firmware and they just kind of brand it

149
00:05:41,610 --> 00:05:46,169
to their version so we found a

150
00:05:43,969 --> 00:05:48,419
background service that ran on some of

151
00:05:46,169 --> 00:05:49,889
these routers that was when you first

152
00:05:48,419 --> 00:05:52,650
booted it up and looked around at what

153
00:05:49,889 --> 00:05:54,150
Wi-Fi channels were being used near your

154
00:05:52,650 --> 00:05:57,270
device and tried to pick one that was

155
00:05:54,150 --> 00:06:00,029
free so like one six and 11 for 2.4 or

156
00:05:57,270 --> 00:06:01,799
whatever one of those services also

157
00:06:00,029 --> 00:06:03,060
listened on the network for some reason

158
00:06:01,800 --> 00:06:04,319
we think they were trying to do like a

159
00:06:03,060 --> 00:06:06,240
local host

160
00:06:04,319 --> 00:06:09,270
bound socket but they had it listening

161
00:06:06,240 --> 00:06:10,740
everywhere and it was armed and well

162
00:06:09,270 --> 00:06:12,240
armed and MIPS and a bunch of other

163
00:06:10,740 --> 00:06:14,550
architectures we got into and made

164
00:06:12,240 --> 00:06:16,020
overflows for and a lot of those share

165
00:06:14,550 --> 00:06:18,180
the same property is what I'm going to

166
00:06:16,020 --> 00:06:19,740
get into here is if you're trying to

167
00:06:18,180 --> 00:06:21,479
invent buffer overflows at the time

168
00:06:19,740 --> 00:06:23,879
those are somewhat challenging

169
00:06:21,479 --> 00:06:26,909
architectures to start with we're 32-bit

170
00:06:23,879 --> 00:06:28,560
x86 is a particularly easy one and I

171
00:06:26,909 --> 00:06:30,029
kind of wondering historically if that's

172
00:06:28,560 --> 00:06:33,719
part of the reason why things happened

173
00:06:30,029 --> 00:06:35,279
in the order they did but we'll see so

174
00:06:33,719 --> 00:06:36,930
one of the things in particular I got

175
00:06:35,279 --> 00:06:39,930
into thinking about this after working

176
00:06:36,930 --> 00:06:41,100
with some of those unusual payloads that

177
00:06:39,930 --> 00:06:43,710
we created is

178
00:06:41,100 --> 00:06:45,210
you search the internet like obviously

179
00:06:43,710 --> 00:06:46,979
at the time people must have written

180
00:06:45,210 --> 00:06:48,690
exploits right if you search the

181
00:06:46,980 --> 00:06:51,450
internet for things like Windows 3.1

182
00:06:48,690 --> 00:06:54,600
shell code you get pretty useless

183
00:06:51,450 --> 00:06:56,460
results in fact it seems to find things

184
00:06:54,600 --> 00:06:57,900
like shell code for an exploit for some

185
00:06:56,460 --> 00:07:00,210
application where that application

186
00:06:57,900 --> 00:07:02,400
version is 3.1 it has nothing to do with

187
00:07:00,210 --> 00:07:05,489
the OS and every now and then they will

188
00:07:02,400 --> 00:07:08,190
allude to a program that someone

189
00:07:05,490 --> 00:07:11,220
exploited on a 32-bit OS but it's also

190
00:07:08,190 --> 00:07:12,990
available for a 16-bit OS but they could

191
00:07:11,220 --> 00:07:15,780
not find like working shell code working

192
00:07:12,990 --> 00:07:18,360
exploit or anything I think now I'm on

193
00:07:15,780 --> 00:07:20,130
like page three or four of these search

194
00:07:18,360 --> 00:07:21,870
results so if anybody is interested in

195
00:07:20,130 --> 00:07:23,460
looking at the white paper that is like

196
00:07:21,870 --> 00:07:25,920
20 pages and go through this in much

197
00:07:23,460 --> 00:07:26,400
better detail I guess PageRank is still

198
00:07:25,920 --> 00:07:29,580
a thing

199
00:07:26,400 --> 00:07:31,020
so that could help bring it to the top

200
00:07:29,580 --> 00:07:33,180
if it's interesting and you link to it

201
00:07:31,020 --> 00:07:36,450
or put it on social media or something

202
00:07:33,180 --> 00:07:38,640
same idea for Windows 3.1 buffer

203
00:07:36,450 --> 00:07:40,830
overflow you get this chat server

204
00:07:38,640 --> 00:07:43,140
version 3.1 like the OS doesn't even

205
00:07:40,830 --> 00:07:45,659
float to the top so I was thinking about

206
00:07:43,140 --> 00:07:47,400
this and so why has nobody written about

207
00:07:45,660 --> 00:07:49,500
this and I kind of thought of a couple

208
00:07:47,400 --> 00:07:50,880
reasons potentially valid potentially

209
00:07:49,500 --> 00:07:56,130
not so but they're interesting to think

210
00:07:50,880 --> 00:07:58,260
about one last thing though the

211
00:07:56,130 --> 00:08:00,240
relevance of this obviously this is not

212
00:07:58,260 --> 00:08:02,190
going to be a very useful skill to put

213
00:08:00,240 --> 00:08:03,990
into Metasploit and take to penetration

214
00:08:02,190 --> 00:08:05,370
test or anything right but I thought

215
00:08:03,990 --> 00:08:08,660
this was a little bit interesting this

216
00:08:05,370 --> 00:08:11,640
was 2015 and they had some kind of

217
00:08:08,660 --> 00:08:14,670
kiosks or something that had been

218
00:08:11,640 --> 00:08:16,590
developed and deployed in the 90s at

219
00:08:14,670 --> 00:08:18,630
some point and they were still existing

220
00:08:16,590 --> 00:08:20,690
and they went down and it had something

221
00:08:18,630 --> 00:08:23,610
to do with weather and a French airport

222
00:08:20,690 --> 00:08:31,170
so just alluding to the relevance a

223
00:08:23,610 --> 00:08:33,590
little bit so proving that an overflow

224
00:08:31,170 --> 00:08:35,370
even exists or would come about I

225
00:08:33,590 --> 00:08:37,620
alluded to that before with the

226
00:08:35,370 --> 00:08:38,909
applications but even like you think

227
00:08:37,620 --> 00:08:40,560
Windows Rupert one you think some

228
00:08:38,909 --> 00:08:42,718
standalone desktop and a lot of them

229
00:08:40,559 --> 00:08:44,729
were probably the majority you also had

230
00:08:42,719 --> 00:08:47,370
like netware or something and

231
00:08:44,730 --> 00:08:49,500
potentially even late in this if you

232
00:08:47,370 --> 00:08:50,880
bought like a used computer in the

233
00:08:49,500 --> 00:08:53,370
mid-90s or something you could easily

234
00:08:50,880 --> 00:08:54,340
have like an early Pentium running

235
00:08:53,370 --> 00:08:56,480
Netscape

236
00:08:54,340 --> 00:08:58,070
trumpet windsock or something or

237
00:08:56,480 --> 00:09:00,080
internet explorer five was available

238
00:08:58,070 --> 00:09:01,370
interestingly enough imagine trying to

239
00:09:00,080 --> 00:09:03,800
write the javascript interpreter for

240
00:09:01,370 --> 00:09:06,680
that and have it compatible in both 16

241
00:09:03,800 --> 00:09:09,349
to 32 so one could a buffer overflow

242
00:09:06,680 --> 00:09:12,920
situation arise here the few that I came

243
00:09:09,350 --> 00:09:16,610
up with that I'll exploit so FTP client

244
00:09:12,920 --> 00:09:19,579
I just have a local FTP server running

245
00:09:16,610 --> 00:09:21,560
to test with this it ends up we'll get

246
00:09:19,580 --> 00:09:23,290
into it later so anything dealing with

247
00:09:21,560 --> 00:09:26,810
file names I think a lot of people

248
00:09:23,290 --> 00:09:29,180
assumed that reading in a file name is

249
00:09:26,810 --> 00:09:30,910
going to be about 256 characters or

250
00:09:29,180 --> 00:09:32,959
something and when you get beyond that

251
00:09:30,910 --> 00:09:34,640
things tend to fall apart pretty quickly

252
00:09:32,960 --> 00:09:38,600
and at least two of the applications I

253
00:09:34,640 --> 00:09:41,689
show here so this is the FTP client this

254
00:09:38,600 --> 00:09:43,100
is Adobe Reader so this one has to do

255
00:09:41,690 --> 00:09:45,620
with hyperlinks that end up being too

256
00:09:43,100 --> 00:09:49,700
long that we'll get into and this one

257
00:09:45,620 --> 00:09:52,880
was winzip so that's just a zip file but

258
00:09:49,700 --> 00:09:54,830
we'll get into parsing you you encoded

259
00:09:52,880 --> 00:09:57,230
files that have a file name inside and

260
00:09:54,830 --> 00:09:59,390
that kind of breaks pretty quickly so

261
00:09:57,230 --> 00:10:01,250
the interesting part here I rediscovered

262
00:09:59,390 --> 00:10:03,230
all of these exploits but it turns out

263
00:10:01,250 --> 00:10:05,000
they all had CVE numbers for somebody

264
00:10:03,230 --> 00:10:07,970
finding them in building an exploit in

265
00:10:05,000 --> 00:10:11,480
the 32-bit version in like the mid-2000s

266
00:10:07,970 --> 00:10:13,460
or late 90s so I was rediscovering

267
00:10:11,480 --> 00:10:15,350
things that are like so blatant trivial

268
00:10:13,460 --> 00:10:16,880
overflows that someone found before but

269
00:10:15,350 --> 00:10:23,780
they didn't necessarily extend it to

270
00:10:16,880 --> 00:10:25,310
16-bit platforms at the time so I was

271
00:10:23,780 --> 00:10:27,339
talking before why wasn't this talked

272
00:10:25,310 --> 00:10:30,770
about earlier so let's get into that my

273
00:10:27,340 --> 00:10:32,360
conjectures about that so maybe it

274
00:10:30,770 --> 00:10:33,980
wasn't interesting let's picture it's

275
00:10:32,360 --> 00:10:36,550
like you're writing smashing this

276
00:10:33,980 --> 00:10:39,110
smashing the stack for fun and profit

277
00:10:36,550 --> 00:10:41,359
it's the mid-90s what is more

278
00:10:39,110 --> 00:10:42,890
interesting you are on a low-end Windows

279
00:10:41,360 --> 00:10:44,990
machine and you are attacking some

280
00:10:42,890 --> 00:10:46,790
Solaris server or the other way around

281
00:10:44,990 --> 00:10:48,920
right maybe this just wasn't interesting

282
00:10:46,790 --> 00:10:50,959
at the time there were far better ways

283
00:10:48,920 --> 00:10:52,729
to go after some low-end Windows machine

284
00:10:50,960 --> 00:10:54,500
than somewhat at the time would have

285
00:10:52,730 --> 00:10:55,850
seen like a far-fetched scenario if

286
00:10:54,500 --> 00:10:57,440
you're gonna have a malicious server and

287
00:10:55,850 --> 00:10:59,240
they're gonna dial in to the Internet

288
00:10:57,440 --> 00:11:01,100
and open this client in this exact order

289
00:10:59,240 --> 00:11:03,500
and of course a lot of that is more

290
00:11:01,100 --> 00:11:05,030
plausible now so maybe it just wasn't

291
00:11:03,500 --> 00:11:07,340
interesting at the time why attack a

292
00:11:05,030 --> 00:11:09,699
desktop when you get a server on a t3 or

293
00:11:07,340 --> 00:11:09,700
something

294
00:11:09,850 --> 00:11:13,610
maybe it was just so obvious that nobody

295
00:11:12,110 --> 00:11:15,500
thought it was even worth writing about

296
00:11:13,610 --> 00:11:17,480
I don't think that's the case but I

297
00:11:15,500 --> 00:11:20,990
guess it could be but I doubt it and

298
00:11:17,480 --> 00:11:24,769
then the third one that I'm going to say

299
00:11:20,990 --> 00:11:33,199
is probably true or the last one so it

300
00:11:24,769 --> 00:11:34,940
could have just been that but so at the

301
00:11:33,199 --> 00:11:38,540
time that this was a common platform

302
00:11:34,940 --> 00:11:40,940
right mid 90s 94 95 96 maybe it depends

303
00:11:38,540 --> 00:11:44,240
on how well to do you were with buying

304
00:11:40,940 --> 00:11:45,980
like an NT 4 machine or something so I'm

305
00:11:44,240 --> 00:11:47,959
going to say and I'm not sure that this

306
00:11:45,980 --> 00:11:49,880
is 100% true and it'll be interesting to

307
00:11:47,959 --> 00:11:51,979
do more research behind it if you look

308
00:11:49,880 --> 00:11:55,399
at publicly available exploitation

309
00:11:51,980 --> 00:11:56,930
techniques right in the mid-90s when

310
00:11:55,399 --> 00:12:00,589
people might have cared about this they

311
00:11:56,930 --> 00:12:04,579
just were not advanced enough to do rap

312
00:12:00,589 --> 00:12:06,529
chains and disabling a SLR or getting

313
00:12:04,579 --> 00:12:09,079
around the SLR disabling memory

314
00:12:06,529 --> 00:12:11,120
protection no execute which I'm going to

315
00:12:09,079 --> 00:12:14,300
show some of that exists in a very weak

316
00:12:11,120 --> 00:12:16,189
form by accident and I'm going to

317
00:12:14,300 --> 00:12:17,810
predict that maybe those techniques just

318
00:12:16,189 --> 00:12:19,399
weren't publicly known enough at the

319
00:12:17,810 --> 00:12:21,319
time for people to build the exploits

320
00:12:19,399 --> 00:12:22,819
that by standing on the shoulders of

321
00:12:21,319 --> 00:12:30,550
giants I was able to do in a couple

322
00:12:22,819 --> 00:12:33,589
weekends maybe so we'll see all right

323
00:12:30,550 --> 00:12:35,269
so how about we doing overflow just to

324
00:12:33,589 --> 00:12:37,160
show that it's possible here I'm going

325
00:12:35,269 --> 00:12:38,810
to do a live demo more than what I have

326
00:12:37,160 --> 00:12:44,240
reserved in the slides let's kind of

327
00:12:38,810 --> 00:12:46,130
build one on our own right so if we open

328
00:12:44,240 --> 00:12:47,779
notepad which is probably one of the

329
00:12:46,130 --> 00:12:50,750
least change applications since this

330
00:12:47,779 --> 00:12:53,420
time so auu encoded file it has begin

331
00:12:50,750 --> 00:12:55,189
permissions file name a bunch of you you

332
00:12:53,420 --> 00:12:57,620
encoded data which is superficially

333
00:12:55,189 --> 00:12:59,930
similar to base64 but uses characters

334
00:12:57,620 --> 00:13:03,949
that are more dangerous and then end at

335
00:12:59,930 --> 00:13:05,989
the bottom so we can build like our mode

336
00:13:03,949 --> 00:13:08,569
here let's say it's 6 6 4 4 unix

337
00:13:05,990 --> 00:13:10,279
permissions and then a file name will

338
00:13:08,569 --> 00:13:11,779
make it longer and then we won't even

339
00:13:10,279 --> 00:13:16,010
need any data because it'll crash before

340
00:13:11,779 --> 00:13:18,459
then so let's get some malicious stuff

341
00:13:16,010 --> 00:13:18,459
here

342
00:13:18,510 --> 00:13:24,810
I've got a lowercase one in there all

343
00:13:23,110 --> 00:13:27,730
right kind of like the classic

344
00:13:24,810 --> 00:13:34,780
demonstration right so that's way too

345
00:13:27,730 --> 00:13:39,820
long let's save it as a uu encoded file

346
00:13:34,780 --> 00:13:42,870
that will open and winzip save and let's

347
00:13:39,820 --> 00:13:42,870
go in and open it

348
00:13:48,300 --> 00:13:53,109
it's shareware I guess that's not really

349
00:13:51,700 --> 00:13:54,820
a thing anymore because of mobile

350
00:13:53,110 --> 00:14:05,650
platforms like there's no friction to

351
00:13:54,820 --> 00:14:07,390
buying something so open it and we have

352
00:14:05,650 --> 00:14:09,880
a problem so it gives an error message

353
00:14:07,390 --> 00:14:14,140
first that you can't read and then when

354
00:14:09,880 --> 00:14:15,880
we hit okay it crashes so the

355
00:14:14,140 --> 00:14:17,530
interesting thing here on a 32-bit

356
00:14:15,880 --> 00:14:19,570
platform when you do this kind of

357
00:14:17,530 --> 00:14:23,890
trivial AAAA exploit where do you expect

358
00:14:19,570 --> 00:14:26,110
it to crash for one for one for one for

359
00:14:23,890 --> 00:14:27,730
one for one right we will see that it

360
00:14:26,110 --> 00:14:29,290
crashes on the instruction before that

361
00:14:27,730 --> 00:14:31,380
because of how the memory segmentation

362
00:14:29,290 --> 00:14:33,790
works so I'll get more into that later

363
00:14:31,380 --> 00:14:38,950
so one of the interesting things you can

364
00:14:33,790 --> 00:14:40,689
do is the crash reporter that comes in

365
00:14:38,950 --> 00:14:42,280
like later versions of Windows the file

366
00:14:40,690 --> 00:14:44,590
name is still dr. Watson

367
00:14:42,280 --> 00:14:46,569
or dr. Watson and T or whatever or at

368
00:14:44,590 --> 00:14:51,760
least it was for a long time that

369
00:14:46,570 --> 00:14:54,400
actually is a crash logging application

370
00:14:51,760 --> 00:14:55,870
that's built in here so if we run that

371
00:14:54,400 --> 00:14:58,840
and have it minimized when we do the

372
00:14:55,870 --> 00:15:01,270
crash it will intercept when Windows

373
00:14:58,840 --> 00:15:09,340
triggers a gpf and log a lot more useful

374
00:15:01,270 --> 00:15:13,630
information about it or not we have to

375
00:15:09,340 --> 00:15:18,310
reboot because there's some lock that is

376
00:15:13,630 --> 00:15:20,290
still acquired somewhere thankfully it

377
00:15:18,310 --> 00:15:26,949
takes a lot less time than it would have

378
00:15:20,290 --> 00:15:33,160
done back then a little video glitch

379
00:15:26,950 --> 00:15:36,360
that resolves itself so the crash

380
00:15:33,160 --> 00:15:36,360
reporting here

381
00:15:37,350 --> 00:15:49,510
and then do this overflow alright and

382
00:15:47,080 --> 00:15:53,950
now we can put some stuff in here that

383
00:15:49,510 --> 00:16:06,130
it's gonna put in a log file and then we

384
00:15:53,950 --> 00:16:10,360
can browse to that file and that's an

385
00:16:06,130 --> 00:16:12,189
old one let's go to the bottom so when

386
00:16:10,360 --> 00:16:17,560
that program crashed it logged a bunch

387
00:16:12,190 --> 00:16:20,050
of information here so September 16th

388
00:16:17,560 --> 00:16:22,569
that's today so register is logged so

389
00:16:20,050 --> 00:16:24,640
what 32-bit will be EAX EBX so forth

390
00:16:22,570 --> 00:16:26,740
well this is 16-bit so if that wasn't

391
00:16:24,640 --> 00:16:29,110
already obvious the e wasn't the error

392
00:16:26,740 --> 00:16:33,760
back end and it was added as a retrofit

393
00:16:29,110 --> 00:16:35,800
for 32-bit so BP is an interesting

394
00:16:33,760 --> 00:16:39,270
register that kind of looks awful like a

395
00:16:35,800 --> 00:16:43,359
lot like the pattern we just ran into so

396
00:16:39,270 --> 00:16:44,829
BP was overwritten and then some things

397
00:16:43,360 --> 00:16:46,510
that aren't quite as relevant today so

398
00:16:44,830 --> 00:16:50,100
we have these segment registers that

399
00:16:46,510 --> 00:16:54,730
I'll get into so CSDs and SS for code

400
00:16:50,100 --> 00:16:56,140
stack and data and an interesting thing

401
00:16:54,730 --> 00:16:58,089
here look at the permissions on those

402
00:16:56,140 --> 00:17:00,790
segments so the code is executable and

403
00:16:58,089 --> 00:17:03,070
readable the data is readable and

404
00:17:00,790 --> 00:17:05,709
writeable and the stack is readable and

405
00:17:03,070 --> 00:17:09,640
writeable so if the code is not writable

406
00:17:05,709 --> 00:17:11,650
and the stack is not executable this

407
00:17:09,640 --> 00:17:14,319
kind of sounds like the high-water mark

408
00:17:11,650 --> 00:17:18,370
for buffer overflow defenses on windows

409
00:17:14,319 --> 00:17:20,770
until XP service pack 3 when no execute

410
00:17:18,369 --> 00:17:22,569
stack came back so that's an interesting

411
00:17:20,770 --> 00:17:25,540
point that I'll get into the details a

412
00:17:22,569 --> 00:17:27,970
little bit so if your code segment and

413
00:17:25,540 --> 00:17:30,340
your if you don't have a code segment

414
00:17:27,970 --> 00:17:32,770
and a data segment overlapping then you

415
00:17:30,340 --> 00:17:35,830
have some form of data execution

416
00:17:32,770 --> 00:17:40,840
prevention by design or by accident so

417
00:17:35,830 --> 00:17:42,159
that's an interesting point and the

418
00:17:40,840 --> 00:17:44,320
other thing that's kind of ring similar

419
00:17:42,160 --> 00:17:46,480
today you could have a 16-bit OS running

420
00:17:44,320 --> 00:17:48,750
on a 32-bit processor just like you have

421
00:17:46,480 --> 00:17:49,929
32-bit OS running on a 64-bit processor

422
00:17:48,750 --> 00:17:52,299
the

423
00:17:49,929 --> 00:17:53,559
has to know this is actually 32-bit

424
00:17:52,299 --> 00:17:56,710
hardware it doesn't just run the same

425
00:17:53,559 --> 00:17:58,749
thing so those EAX and so forth though

426
00:17:56,710 --> 00:18:00,639
still exists the top 16 bits are all

427
00:17:58,749 --> 00:18:04,059
zeros because they're not really being

428
00:18:00,639 --> 00:18:06,189
used so much the stack you can see

429
00:18:04,059 --> 00:18:09,999
actually has some high order bits in

430
00:18:06,190 --> 00:18:13,450
there and that would be likely the

431
00:18:09,999 --> 00:18:15,639
result of some math going on paging

432
00:18:13,450 --> 00:18:21,929
virtual memories is all there so it

433
00:18:15,639 --> 00:18:21,928
could be changing things stack dump here

434
00:18:23,669 --> 00:18:33,759
so look at SSB p1 at five seven four one

435
00:18:29,590 --> 00:18:37,119
four one other information that kind of

436
00:18:33,759 --> 00:18:39,369
give you some code that where it thinks

437
00:18:37,119 --> 00:18:40,570
the program's running right now so

438
00:18:39,369 --> 00:18:42,249
that's some interesting stuff just

439
00:18:40,570 --> 00:18:45,549
coming from dr. Watson we're not even a

440
00:18:42,249 --> 00:18:47,350
debugger or anything else yet so the

441
00:18:45,549 --> 00:18:51,600
other demo I have before we get into

442
00:18:47,350 --> 00:18:56,908
actually constructing an exploit I have

443
00:18:51,600 --> 00:19:00,248
an FTP server running on this machine

444
00:18:56,909 --> 00:19:03,399
where I've put an anonymous directory on

445
00:19:00,249 --> 00:19:06,249
here and I've just put a file name in

446
00:19:03,399 --> 00:19:08,678
there that's just way too long for a one

447
00:19:06,249 --> 00:19:11,200
day 3.1 program to even handle so it's

448
00:19:08,679 --> 00:19:12,490
just the alphabet but creatively done so

449
00:19:11,200 --> 00:19:14,289
you can figure out where you were like

450
00:19:12,490 --> 00:19:16,029
you were using some of the Metasploit

451
00:19:14,289 --> 00:19:19,509
tools that kind of get creative with

452
00:19:16,029 --> 00:19:21,129
that so what happens if we open the FTP

453
00:19:19,509 --> 00:19:23,820
client and just browse to that directory

454
00:19:21,129 --> 00:19:25,928
and try to open that file and for

455
00:19:23,820 --> 00:19:30,970
interesting purposes let's do that in

456
00:19:25,929 --> 00:19:32,830
the debugger so one of the things that

457
00:19:30,970 --> 00:19:34,029
gets interesting here the IDE and the

458
00:19:32,830 --> 00:19:35,470
debugger weren't even written by

459
00:19:34,029 --> 00:19:37,119
Microsoft they were a much smaller

460
00:19:35,470 --> 00:19:38,830
company back then like in the stock

461
00:19:37,119 --> 00:19:41,740
market they were growth not value or

462
00:19:38,830 --> 00:19:47,230
whatever right so the debugger is not

463
00:19:41,740 --> 00:19:51,700
even written by Microsoft so we can open

464
00:19:47,230 --> 00:19:53,679
in a DP client here and you can see if

465
00:19:51,700 --> 00:19:56,409
you think wind a bug or wind bag is

466
00:19:53,679 --> 00:19:59,019
primitive well look at what they dealt

467
00:19:56,409 --> 00:20:01,960
with back then so new mega technologies

468
00:19:59,019 --> 00:20:03,760
apparently wrote it it's all slightly

469
00:20:01,960 --> 00:20:05,830
menu driven but in reality

470
00:20:03,760 --> 00:20:10,480
they're a bunch of commands you can type

471
00:20:05,830 --> 00:20:13,120
in to get around much faster so somewhat

472
00:20:10,480 --> 00:20:14,740
GUI based but in text mode but running

473
00:20:13,120 --> 00:20:17,649
all over top of your Windows desktop at

474
00:20:14,740 --> 00:20:21,250
the same time so a weird combination so

475
00:20:17,650 --> 00:20:24,040
if we start the program with G let's

476
00:20:21,250 --> 00:20:26,920
open it I have two ftp servers running

477
00:20:24,040 --> 00:20:28,270
one that's a script specifically

478
00:20:26,920 --> 00:20:30,130
designed to exploit this and one that's

479
00:20:28,270 --> 00:20:35,800
just a normal ftp server so we'll put it

480
00:20:30,130 --> 00:20:37,090
on 21 anonymous go in here and we have a

481
00:20:35,800 --> 00:20:38,980
problem as soon as we go into that

482
00:20:37,090 --> 00:20:40,720
directory it crashes traps you into

483
00:20:38,980 --> 00:20:42,070
these into this debugger so we can look

484
00:20:40,720 --> 00:20:46,750
what's in the registers and the current

485
00:20:42,070 --> 00:20:49,060
instruction so ax BX CX and so forth the

486
00:20:46,750 --> 00:20:50,920
base pointer is overwritten with some

487
00:20:49,060 --> 00:20:54,940
ASCII characters five three seven three

488
00:20:50,920 --> 00:20:57,340
those are valid the crashing instruction

489
00:20:54,940 --> 00:20:58,900
is a return and this is what I was

490
00:20:57,340 --> 00:21:00,879
alluding to earlier is it's going to

491
00:20:58,900 --> 00:21:03,250
crash on the restruck instruction that

492
00:21:00,880 --> 00:21:06,370
attempts to return to an invalid address

493
00:21:03,250 --> 00:21:08,050
rather than overwriting VIP and crashing

494
00:21:06,370 --> 00:21:10,120
there because it's an invalid address so

495
00:21:08,050 --> 00:21:18,520
that is weird we can look at what's on

496
00:21:10,120 --> 00:21:19,750
the stack here and I'll get a lot more

497
00:21:18,520 --> 00:21:22,810
into the details here in just a minute

498
00:21:19,750 --> 00:21:30,090
so a bunch of ASCII looking values let's

499
00:21:22,810 --> 00:21:31,840
do those in ASCII so and there you go so

500
00:21:30,090 --> 00:21:33,970
interesting thing here when it was

501
00:21:31,840 --> 00:21:35,980
creating that directory listing on the

502
00:21:33,970 --> 00:21:37,780
screen it was trying to put the date and

503
00:21:35,980 --> 00:21:39,460
time in there not even a separate

504
00:21:37,780 --> 00:21:42,940
columns just with like a vertical bar to

505
00:21:39,460 --> 00:21:44,590
separate them and we don't get a bunch

506
00:21:42,940 --> 00:21:46,600
of contiguous bytes here that we can

507
00:21:44,590 --> 00:21:48,220
control for looking at Rob Jaynes

508
00:21:46,600 --> 00:21:50,219
shellcode and so forth after that

509
00:21:48,220 --> 00:21:52,510
because the date is in the middle so

510
00:21:50,220 --> 00:21:54,580
what I ended up having to do and I'll

511
00:21:52,510 --> 00:21:56,770
get into this later is get creative with

512
00:21:54,580 --> 00:21:59,379
jumping over that region that had the

513
00:21:56,770 --> 00:22:01,330
date and writing an SD pre server with a

514
00:21:59,380 --> 00:22:04,990
path so long you can't even create a

515
00:22:01,330 --> 00:22:06,699
file with that name on Linux and that's

516
00:22:04,990 --> 00:22:10,600
why we need to custom implementation of

517
00:22:06,700 --> 00:22:13,240
FTP so I'll get back to the slides

518
00:22:10,600 --> 00:22:14,679
but obviously these crashes are here

519
00:22:13,240 --> 00:22:16,540
they're doing bad things that are worth

520
00:22:14,680 --> 00:22:19,670
further

521
00:22:16,540 --> 00:22:23,240
investigation I have kind of a more

522
00:22:19,670 --> 00:22:25,700
static version of it here I skipped this

523
00:22:23,240 --> 00:22:27,680
a little bit but when you're writing an

524
00:22:25,700 --> 00:22:30,230
overflow on 32-bit like what's kind of

525
00:22:27,680 --> 00:22:32,420
the basic like trivial no way SLR no

526
00:22:30,230 --> 00:22:35,210
depth overflow you would do you have a

527
00:22:32,420 --> 00:22:38,300
program presumably and see maybe C++

528
00:22:35,210 --> 00:22:40,610
that takes untrusted input command line

529
00:22:38,300 --> 00:22:43,040
environment variables standard in a

530
00:22:40,610 --> 00:22:45,800
network socket a file on disk somewhere

531
00:22:43,040 --> 00:22:48,409
that's untrusted tries to stash them on

532
00:22:45,800 --> 00:22:51,409
the stack somewhere so stir coffee s

533
00:22:48,410 --> 00:22:52,820
scanf something from the overflows I ran

534
00:22:51,410 --> 00:22:55,160
into I'm pretty sure those functions

535
00:22:52,820 --> 00:22:57,320
were all over the place and you write

536
00:22:55,160 --> 00:22:59,870
too much on your local variable or local

537
00:22:57,320 --> 00:23:02,450
buffer then it can hold what happens to

538
00:22:59,870 --> 00:23:04,939
be there as the stack grows down and you

539
00:23:02,450 --> 00:23:07,670
write upward the return address is there

540
00:23:04,940 --> 00:23:09,250
you overwrite it with address of code

541
00:23:07,670 --> 00:23:12,200
you've written like shell code or

542
00:23:09,250 --> 00:23:14,060
something slightly more complicated like

543
00:23:12,200 --> 00:23:17,300
a very useful instruction like jump to

544
00:23:14,060 --> 00:23:19,060
the stack a vulnerable program trivially

545
00:23:17,300 --> 00:23:22,310
might look something like that

546
00:23:19,060 --> 00:23:24,830
asked for input and just write it into a

547
00:23:22,310 --> 00:23:27,340
buffer without paying attention to what

548
00:23:24,830 --> 00:23:29,990
was passed versus how many you can hold

549
00:23:27,340 --> 00:23:33,649
will very quickly see that that doesn't

550
00:23:29,990 --> 00:23:37,340
work and the next ten minutes or so

551
00:23:33,650 --> 00:23:42,890
we'll get into why based on memory

552
00:23:37,340 --> 00:23:46,699
layout complications of exploiting on a

553
00:23:42,890 --> 00:23:48,830
16-bit platform so let's think about how

554
00:23:46,700 --> 00:23:51,970
we deal with memory on a 32-bit or even

555
00:23:48,830 --> 00:23:54,980
64-bit platform so a lot of things that

556
00:23:51,970 --> 00:23:56,020
if you read the C standard if you're

557
00:23:54,980 --> 00:23:58,220
writing in C there are a lot of

558
00:23:56,020 --> 00:23:59,360
restraints or restrictions on what

559
00:23:58,220 --> 00:24:01,330
you're allowed to do with pointers that

560
00:23:59,360 --> 00:24:05,090
you can usually get away with anyway

561
00:24:01,330 --> 00:24:07,129
sometimes so if you think about GCC and

562
00:24:05,090 --> 00:24:09,199
like being cautious with pointers

563
00:24:07,130 --> 00:24:10,790
there's this whole idea of like aliasing

564
00:24:09,200 --> 00:24:14,120
or strict aliasing but that's pretty

565
00:24:10,790 --> 00:24:16,159
much it for most purposes and if you

566
00:24:14,120 --> 00:24:17,360
think about pointer 1 and point or 2 if

567
00:24:16,160 --> 00:24:20,240
you want to compare them to see which

568
00:24:17,360 --> 00:24:22,969
one is greater that works if you want to

569
00:24:20,240 --> 00:24:23,990
add a value to a pointer you're pretty

570
00:24:22,970 --> 00:24:26,030
much going to get a valid address

571
00:24:23,990 --> 00:24:27,620
potentially there's integer overflow but

572
00:24:26,030 --> 00:24:29,870
that's about the only complication a

573
00:24:27,620 --> 00:24:30,320
pointer just happens to be a 32-bit

574
00:24:29,870 --> 00:24:32,149
value

575
00:24:30,320 --> 00:24:34,100
that points somewhere that you can do

576
00:24:32,149 --> 00:24:41,959
all the normal arithmetic on it and it's

577
00:24:34,100 --> 00:24:43,850
a single linear memory map if you use

578
00:24:41,960 --> 00:24:46,789
this kind of simple memory model which

579
00:24:43,850 --> 00:24:49,340
ends up being called tiny a 32-bit

580
00:24:46,789 --> 00:24:52,340
machine accesses 32 bits of memory or

581
00:24:49,340 --> 00:24:56,389
32-bit memory addresses so it's 2 to the

582
00:24:52,340 --> 00:24:58,610
32 ends up being 2 squared times 2 to

583
00:24:56,389 --> 00:25:01,360
the 30th which is 4 gigabytes you can do

584
00:24:58,610 --> 00:25:03,139
that pretty easily and a 64-bit machine

585
00:25:01,360 --> 00:25:05,000
assuming there are no hardware

586
00:25:03,139 --> 00:25:08,779
constraints but obviously still exists

587
00:25:05,000 --> 00:25:10,610
could address 2 to the 64th and a 16-bit

588
00:25:08,779 --> 00:25:14,059
machine with this simple straightforward

589
00:25:10,610 --> 00:25:17,269
memory model 0 to 2 to the 16 minus 1

590
00:25:14,059 --> 00:25:21,980
could address 2 to the 16 bytes of

591
00:25:17,269 --> 00:25:24,470
memory how much is 2 to the 16 64 K even

592
00:25:21,980 --> 00:25:27,740
when x86 was being designed that was

593
00:25:24,470 --> 00:25:30,649
already too small so they could increase

594
00:25:27,740 --> 00:25:33,080
the size of the registers or they can do

595
00:25:30,649 --> 00:25:35,870
like Bank switching or what they ended

596
00:25:33,080 --> 00:25:37,519
up doing is segmentation and people that

597
00:25:35,870 --> 00:25:38,629
program this at the time there are a lot

598
00:25:37,519 --> 00:25:40,789
of horror stories one of the

599
00:25:38,629 --> 00:25:44,389
inspirations for this if you've seen the

600
00:25:40,789 --> 00:25:45,799
MSDN blog old new thing by someone who's

601
00:25:44,389 --> 00:25:47,570
been at Microsoft for a long time

602
00:25:45,799 --> 00:25:49,720
there's a lot of horror stories about

603
00:25:47,570 --> 00:25:52,610
the types of things you would have to do

604
00:25:49,720 --> 00:25:57,830
when what I'm about to show enters into

605
00:25:52,610 --> 00:25:59,418
your program registers you deal with on

606
00:25:57,830 --> 00:26:00,460
32 bit and kind of been through this

607
00:25:59,419 --> 00:26:05,779
already

608
00:26:00,460 --> 00:26:08,419
16-bit they're all smaller they're 16

609
00:26:05,779 --> 00:26:10,220
bits instead of EIP you have IP

610
00:26:08,419 --> 00:26:12,379
instead of flag eflags you have flags

611
00:26:10,220 --> 00:26:14,809
and so forth but the other registers

612
00:26:12,379 --> 00:26:17,240
that also exists on 32-bit the segment

613
00:26:14,809 --> 00:26:20,389
registers exist and you care a lot about

614
00:26:17,240 --> 00:26:21,769
this is assembly programming that kind

615
00:26:20,389 --> 00:26:23,360
of creeps its way when you're working

616
00:26:21,769 --> 00:26:30,409
with C when you're doing this

617
00:26:23,360 --> 00:26:36,229
development so first of all the

618
00:26:30,409 --> 00:26:38,029
segmentation so every 16-bit program has

619
00:26:36,230 --> 00:26:40,039
to have a memory model chosen by the

620
00:26:38,029 --> 00:26:43,789
programmer and every one of these is

621
00:26:40,039 --> 00:26:44,299
about trade-offs between code size and

622
00:26:43,789 --> 00:26:47,330
speed

623
00:26:44,299 --> 00:26:49,869
and size of the program so one of the

624
00:26:47,330 --> 00:26:52,849
aspects of a segmented architecture is

625
00:26:49,869 --> 00:26:54,439
that rather than one giant pool of

626
00:26:52,849 --> 00:26:57,109
memory that you number from zero to

627
00:26:54,440 --> 00:26:59,809
number of bits minus one you have to go

628
00:26:57,109 --> 00:27:03,589
through a segment that then in hardware

629
00:26:59,809 --> 00:27:05,779
is mapped to some linear region of

630
00:27:03,589 --> 00:27:09,609
memory based on RAM and ROM how many

631
00:27:05,779 --> 00:27:12,499
memory chips you have and so forth so

632
00:27:09,609 --> 00:27:14,330
even though the nice normal size of a

633
00:27:12,499 --> 00:27:16,789
memory address you work with is 16 bits

634
00:27:14,330 --> 00:27:20,149
in reality there's 16 bit offsets and

635
00:27:16,789 --> 00:27:22,729
some 0 - large number of segments that

636
00:27:20,149 --> 00:27:25,549
you can work with at any given time so

637
00:27:22,729 --> 00:27:28,459
this will be a program that is small or

638
00:27:25,549 --> 00:27:31,369
medium and what that means is that code

639
00:27:28,459 --> 00:27:33,739
is stored over here local variables are

640
00:27:31,369 --> 00:27:35,958
on the stack so they're here global

641
00:27:33,739 --> 00:27:37,159
variables we put in the same region so

642
00:27:35,959 --> 00:27:39,259
what are the good things what are the

643
00:27:37,159 --> 00:27:41,809
bad things about this so this means you

644
00:27:39,259 --> 00:27:44,450
can have up to 64 K of code because

645
00:27:41,809 --> 00:27:46,999
that's 2 to the 16th and your size of

646
00:27:44,450 --> 00:27:50,209
your stack and data combined can be up

647
00:27:46,999 --> 00:27:51,829
to 64 K and in like a small help our

648
00:27:50,209 --> 00:27:54,440
application like notepad or something

649
00:27:51,829 --> 00:27:57,259
that might be totally fine if it's

650
00:27:54,440 --> 00:27:58,940
something like ie 5 I highly doubt they

651
00:27:57,259 --> 00:28:02,659
were able to do this trying to write a

652
00:27:58,940 --> 00:28:06,649
JavaScript interpreter that deals in 64

653
00:28:02,659 --> 00:28:07,489
K overall if anyone has done programming

654
00:28:06,649 --> 00:28:09,649
with Mazza

655
00:28:07,489 --> 00:28:11,119
or ml like oftentimes you'll write a

656
00:28:09,649 --> 00:28:12,649
program and it'll just spit a bunch of

657
00:28:11,119 --> 00:28:14,269
syntax errors about you and they're

658
00:28:12,649 --> 00:28:16,369
resolved by putting the word offset in

659
00:28:14,269 --> 00:28:18,529
and that that's this is where it comes

660
00:28:16,369 --> 00:28:20,988
from it's clarifying to the assembler

661
00:28:18,529 --> 00:28:22,369
that you're not trying to are you trying

662
00:28:20,989 --> 00:28:25,159
to use an address into the current

663
00:28:22,369 --> 00:28:26,749
segment or a 32-bit address which

664
00:28:25,159 --> 00:28:30,379
consists of a different segment number

665
00:28:26,749 --> 00:28:32,629
and an offset this is a lot this is

666
00:28:30,379 --> 00:28:34,339
complicated to try to explain live in

667
00:28:32,629 --> 00:28:35,748
verbally I have the white paper on the

668
00:28:34,339 --> 00:28:37,070
website that goes through all the

669
00:28:35,749 --> 00:28:41,539
different memory models so if you think

670
00:28:37,070 --> 00:28:43,399
about it if 64 K is not enough to store

671
00:28:41,539 --> 00:28:45,229
your combined global variables local

672
00:28:43,399 --> 00:28:47,178
variables you can split them into two

673
00:28:45,229 --> 00:28:49,159
different regions what are the good

674
00:28:47,179 --> 00:28:52,549
things about that now you have 64 K of

675
00:28:49,159 --> 00:28:53,989
stack 64 km data now imagine passing a

676
00:28:52,549 --> 00:28:55,940
local variable to a function that

677
00:28:53,989 --> 00:28:57,240
accepts a pointer to a buffer that it's

678
00:28:55,940 --> 00:28:59,880
going to write something into

679
00:28:57,240 --> 00:29:02,550
that function either needs to know

680
00:28:59,880 --> 00:29:05,400
whether it's on the stack or in the data

681
00:29:02,550 --> 00:29:06,720
segment by taking a far pointer or you

682
00:29:05,400 --> 00:29:08,430
need to have two different functions one

683
00:29:06,720 --> 00:29:10,350
that takes near and one that takes far

684
00:29:08,430 --> 00:29:14,100
and does the right thing and both of

685
00:29:10,350 --> 00:29:17,070
those concepts creep their way into the

686
00:29:14,100 --> 00:29:18,689
standard library so I have another

687
00:29:17,070 --> 00:29:24,600
program to show here that's not an

688
00:29:18,690 --> 00:29:26,190
exploit but going into this IDE I have

689
00:29:24,600 --> 00:29:27,689
something that just takes the addresses

690
00:29:26,190 --> 00:29:30,060
of various things that we can look at

691
00:29:27,690 --> 00:29:34,380
how the segment numbers are created and

692
00:29:30,060 --> 00:29:36,060
how they change at runtime so it's a

693
00:29:34,380 --> 00:29:37,650
fairly straightforward function that

694
00:29:36,060 --> 00:29:42,690
will get more into some of the things

695
00:29:37,650 --> 00:29:44,190
here we use s printf to basically print

696
00:29:42,690 --> 00:29:47,790
off to a message box since there's no

697
00:29:44,190 --> 00:29:50,610
standard i/o so the things I'm taking

698
00:29:47,790 --> 00:29:53,310
addresses of are this F global which is

699
00:29:50,610 --> 00:29:55,110
a global variable I declared as far and

700
00:29:53,310 --> 00:29:58,169
then another global variable that I just

701
00:29:55,110 --> 00:30:01,679
did normally a static variable inside

702
00:29:58,170 --> 00:30:05,010
the function and just a plain local

703
00:30:01,680 --> 00:30:06,900
variable that will be on the stack then

704
00:30:05,010 --> 00:30:08,940
I took a few function pointers one of

705
00:30:06,900 --> 00:30:12,540
when main which is this program itself

706
00:30:08,940 --> 00:30:14,760
and by casting it too far we can get the

707
00:30:12,540 --> 00:30:16,500
segment number and then message box

708
00:30:14,760 --> 00:30:19,950
which is a library function from the

709
00:30:16,500 --> 00:30:22,110
user library or user 32 today and local

710
00:30:19,950 --> 00:30:25,650
Alec which is a function from the kernel

711
00:30:22,110 --> 00:30:27,899
library or kernel 32 today so if we run

712
00:30:25,650 --> 00:30:30,120
this it basically stuffs all this into a

713
00:30:27,900 --> 00:30:30,960
big string and gives us a message box so

714
00:30:30,120 --> 00:30:34,139
there are a couple of things we can

715
00:30:30,960 --> 00:30:37,260
observe here if we run it here we go

716
00:30:34,140 --> 00:30:39,480
so it's segment colon offset the far

717
00:30:37,260 --> 00:30:42,090
global because it was declared as far it

718
00:30:39,480 --> 00:30:44,580
gets its own dedicated segment so that

719
00:30:42,090 --> 00:30:46,560
particular variable is allowed to be its

720
00:30:44,580 --> 00:30:48,870
own 64k memory region without

721
00:30:46,560 --> 00:30:51,120
interfering with anything else but if

722
00:30:48,870 --> 00:30:52,560
you want to pass the address of that to

723
00:30:51,120 --> 00:30:54,449
other functions that want to write

724
00:30:52,560 --> 00:30:56,610
something into it or read from it they

725
00:30:54,450 --> 00:30:59,220
need to accept a far pointer or

726
00:30:56,610 --> 00:31:01,949
otherwise it'll get truncated to 16 bits

727
00:30:59,220 --> 00:31:05,220
and offset from the wrong place the

728
00:31:01,950 --> 00:31:07,500
regular global variable got put into

729
00:31:05,220 --> 00:31:09,000
this combined code plus data segment or

730
00:31:07,500 --> 00:31:10,500
what the documentation will call the

731
00:31:09,000 --> 00:31:13,350
default data segment

732
00:31:10,500 --> 00:31:15,660
so Global static and local all share the

733
00:31:13,350 --> 00:31:18,750
same segment number so you can

734
00:31:15,660 --> 00:31:20,610
interchange those addresses the 16-bit

735
00:31:18,750 --> 00:31:22,110
addresses if a program was expecting

736
00:31:20,610 --> 00:31:27,090
data and you give it stack it will work

737
00:31:22,110 --> 00:31:29,580
just fine the code at the bottom so when

738
00:31:27,090 --> 00:31:31,020
main it's offset as zero makes sense

739
00:31:29,580 --> 00:31:33,840
it's a very first function in this

740
00:31:31,020 --> 00:31:37,770
object file when it builds it message

741
00:31:33,840 --> 00:31:39,780
box gets 0 for 7f ay B 5 D and local

742
00:31:37,770 --> 00:31:42,150
Alec gets zero one one seven zero five

743
00:31:39,780 --> 00:31:43,980
four three so what those numbers at the

744
00:31:42,150 --> 00:31:45,930
bottom end up being the code segment of

745
00:31:43,980 --> 00:31:48,780
this particular executable when it was

746
00:31:45,930 --> 00:31:51,660
loaded was two four a seven the code

747
00:31:48,780 --> 00:31:54,030
segment of the user library is zero four

748
00:31:51,660 --> 00:31:56,790
seven F the code segment of the kernel

749
00:31:54,030 --> 00:31:58,860
is zero one one seven the interesting

750
00:31:56,790 --> 00:32:02,010
thing is if we run this program multiple

751
00:31:58,860 --> 00:32:06,240
times what changes and what does it so

752
00:32:02,010 --> 00:32:09,240
we can do that if we want and what

753
00:32:06,240 --> 00:32:10,800
happens is message box and local Alec

754
00:32:09,240 --> 00:32:12,570
they stay the same

755
00:32:10,800 --> 00:32:15,210
those are in an external library

756
00:32:12,570 --> 00:32:17,610
everything local to that program changes

757
00:32:15,210 --> 00:32:19,530
pretty much it's not random what I call

758
00:32:17,610 --> 00:32:22,409
a very weak ASLR it's probably

759
00:32:19,530 --> 00:32:24,180
predictable and it would depend on the

760
00:32:22,410 --> 00:32:26,730
cow many programs the users running and

761
00:32:24,180 --> 00:32:29,790
what order they started them in but they

762
00:32:26,730 --> 00:32:32,100
do change every time for everything

763
00:32:29,790 --> 00:32:33,870
local to that program so it's not an

764
00:32:32,100 --> 00:32:36,120
obvious pattern to what's happening but

765
00:32:33,870 --> 00:32:38,550
the message box and local I like stay in

766
00:32:36,120 --> 00:32:42,270
the same place so what you have is like

767
00:32:38,550 --> 00:32:43,800
an inverse a SLR where the program moves

768
00:32:42,270 --> 00:32:45,510
around and there's a library stay in the

769
00:32:43,800 --> 00:32:47,280
same place this is the reverse of like

770
00:32:45,510 --> 00:32:50,730
the easy a SLR that you just kind of

771
00:32:47,280 --> 00:32:53,040
flip on with like GCC or any modern

772
00:32:50,730 --> 00:32:54,390
build system out of the box where the

773
00:32:53,040 --> 00:32:56,399
program stays in the same place the

774
00:32:54,390 --> 00:32:58,620
libraries move around unless it's a PI

775
00:32:56,400 --> 00:32:59,970
in this case it's the other way around

776
00:32:58,620 --> 00:33:01,739
the program moves around the library

777
00:32:59,970 --> 00:33:03,270
stay in the same place think of a really

778
00:33:01,740 --> 00:33:07,050
obvious reason why it has to be that way

779
00:33:03,270 --> 00:33:09,060
and it's multiple copies of the same

780
00:33:07,050 --> 00:33:11,310
program running because there's no

781
00:33:09,060 --> 00:33:14,669
memory protection so what I'll end up

782
00:33:11,310 --> 00:33:16,080
doing in a little bit is chaining to Rob

783
00:33:14,670 --> 00:33:16,860
gadgets that aren't even part of the

784
00:33:16,080 --> 00:33:22,560
current process

785
00:33:16,860 --> 00:33:23,449
so that's weird but it works so flipping

786
00:33:22,560 --> 00:33:26,870
back

787
00:33:23,450 --> 00:33:31,250
to the presentation the distinction here

788
00:33:26,870 --> 00:33:33,408
is what you're used to is on 32-bit code

789
00:33:31,250 --> 00:33:36,679
the segmentation is still there but all

790
00:33:33,409 --> 00:33:39,529
they've done is set code data stack and

791
00:33:36,679 --> 00:33:42,740
extra to all be zero to the entire

792
00:33:39,529 --> 00:33:44,990
memory space so this is called the tiny

793
00:33:42,740 --> 00:33:46,820
model which doesn't seem tiny on 32-bit

794
00:33:44,990 --> 00:33:48,380
but it just means the size of your

795
00:33:46,820 --> 00:33:51,439
register that's the size of your memory

796
00:33:48,380 --> 00:33:53,240
space you can do tiny on ms-dos programs

797
00:33:51,440 --> 00:33:55,970
you can't do it very well on Windows

798
00:33:53,240 --> 00:33:59,980
programs because the Windows libraries

799
00:33:55,970 --> 00:33:59,980
themselves are too big to fit in 64 K

800
00:34:01,929 --> 00:34:07,250
alright so the complication this makes

801
00:34:04,850 --> 00:34:11,149
that I showed a little bit of already so

802
00:34:07,250 --> 00:34:13,219
a pointer right if you could make every

803
00:34:11,149 --> 00:34:15,230
pointer be the entire segment address

804
00:34:13,219 --> 00:34:17,540
and the offset what are the downsides of

805
00:34:15,230 --> 00:34:19,339
that one of them is code size so every

806
00:34:17,540 --> 00:34:21,199
memory address like takes twice as many

807
00:34:19,339 --> 00:34:23,810
bytes or twice as many instructions as

808
00:34:21,199 --> 00:34:25,939
it would otherwise and the other part is

809
00:34:23,810 --> 00:34:28,790
one of the particularly slow things on

810
00:34:25,940 --> 00:34:31,399
the early x86 processors like a 286 or

811
00:34:28,790 --> 00:34:34,339
386 is changing the value of a segment

812
00:34:31,399 --> 00:34:37,098
register because that's when they have

813
00:34:34,339 --> 00:34:39,049
to look at the if it's 386 look at the

814
00:34:37,099 --> 00:34:40,280
paging the virtual memory lookup a bunch

815
00:34:39,050 --> 00:34:42,050
of tables that have been set up by the

816
00:34:40,280 --> 00:34:44,119
operating system the determine is this

817
00:34:42,050 --> 00:34:46,730
your segment and what do I need to load

818
00:34:44,119 --> 00:34:49,220
as far as its base and limit so they

819
00:34:46,730 --> 00:34:51,230
wanted to avoid changing the value of

820
00:34:49,219 --> 00:34:53,989
the changing the value of the s and so

821
00:34:51,230 --> 00:34:56,750
forth so an air pointer gives you those

822
00:34:53,989 --> 00:34:58,848
advantages as you can just here's a

823
00:34:56,750 --> 00:35:02,210
here's a variable let's take the address

824
00:34:58,849 --> 00:35:04,880
of it it's a pointer it's good the BA

825
00:35:02,210 --> 00:35:06,560
the problem is if a near pointer is

826
00:35:04,880 --> 00:35:09,609
dereference out of context this is a

827
00:35:06,560 --> 00:35:12,859
disaster right it's like having a

828
00:35:09,609 --> 00:35:14,089
cluster of multiple machines and like

829
00:35:12,859 --> 00:35:15,799
trying to use a pointer from a different

830
00:35:14,089 --> 00:35:18,529
machine that's not even yours are like

831
00:35:15,800 --> 00:35:20,240
trying to process a core dump from the

832
00:35:18,530 --> 00:35:23,690
wrong version of a program right it's

833
00:35:20,240 --> 00:35:24,740
just a disaster what this ends up doing

834
00:35:23,690 --> 00:35:25,220
is they end up having to make a

835
00:35:24,740 --> 00:35:28,819
trade-off

836
00:35:25,220 --> 00:35:30,319
so some functions like F read it doesn't

837
00:35:28,819 --> 00:35:32,509
make a whole lot of sense to create one

838
00:35:30,319 --> 00:35:34,279
version that only works for 64 K and

839
00:35:32,510 --> 00:35:35,720
another version that doesn't so

840
00:35:34,280 --> 00:35:36,710
sometimes they just say here's one

841
00:35:35,720 --> 00:35:38,750
version you have to use

842
00:35:36,710 --> 00:35:40,730
this kind of pointer and in other cases

843
00:35:38,750 --> 00:35:42,740
they create different variants of

844
00:35:40,730 --> 00:35:45,530
functions for what size of data you're

845
00:35:42,740 --> 00:35:51,790
dealing with so that's another thing we

846
00:35:45,530 --> 00:35:51,790
can look at and hear their documentation

847
00:35:52,990 --> 00:35:57,919
so what's a function that would have to

848
00:35:55,760 --> 00:36:00,770
deal with these complications a lot so

849
00:35:57,920 --> 00:36:02,030
stir doop is one that on a flat memory

850
00:36:00,770 --> 00:36:05,720
model is pretty simple it takes a

851
00:36:02,030 --> 00:36:07,760
pointer to a string it allocates using

852
00:36:05,720 --> 00:36:10,069
malloc enough memory to hold a copy of

853
00:36:07,760 --> 00:36:12,500
it makes the copy and returns to you the

854
00:36:10,070 --> 00:36:17,170
pointer and then later on you will free

855
00:36:12,500 --> 00:36:20,869
it but when you add these complications

856
00:36:17,170 --> 00:36:23,240
you need three versions so the first one

857
00:36:20,869 --> 00:36:25,640
is the one you're used to what it does

858
00:36:23,240 --> 00:36:27,319
is depending on the build options used

859
00:36:25,640 --> 00:36:29,980
to compile your program it does the

860
00:36:27,320 --> 00:36:32,420
right thing so if your program is tiny

861
00:36:29,980 --> 00:36:35,810
everything would be near if your program

862
00:36:32,420 --> 00:36:37,820
is huge everything ends up being far and

863
00:36:35,810 --> 00:36:39,500
and then in between it depends on the

864
00:36:37,820 --> 00:36:41,240
particular context of the memory model

865
00:36:39,500 --> 00:36:43,190
you've chosen the details of which are

866
00:36:41,240 --> 00:36:45,830
in the white paper then they need

867
00:36:43,190 --> 00:36:47,660
another version after OOP and far astre

868
00:36:45,830 --> 00:36:49,339
dupe and what these are doing is they're

869
00:36:47,660 --> 00:36:53,540
giving you a different kind of pointer

870
00:36:49,339 --> 00:36:55,130
as a return value they take a far

871
00:36:53,540 --> 00:36:56,480
pointer in both cases but when they call

872
00:36:55,130 --> 00:36:57,980
malloc their end up being different

873
00:36:56,480 --> 00:37:01,609
versions of malloc because there's more

874
00:36:57,980 --> 00:37:03,380
than one heap so there's a near one a

875
00:37:01,609 --> 00:37:05,029
far heap and it will allocate from the

876
00:37:03,380 --> 00:37:06,920
correct place and what you have to do as

877
00:37:05,030 --> 00:37:09,170
a programmer is remember when you free

878
00:37:06,920 --> 00:37:11,000
where you got the pointer from this

879
00:37:09,170 --> 00:37:14,030
somewhat reminds me on even on Windows

880
00:37:11,000 --> 00:37:17,359
programming today if you don't link to

881
00:37:14,030 --> 00:37:19,190
the C library correctly you can have a

882
00:37:17,359 --> 00:37:20,839
program and a dll that are linked to

883
00:37:19,190 --> 00:37:24,320
different slightly different versions of

884
00:37:20,839 --> 00:37:26,900
MSV cart and in this kind of situation

885
00:37:24,320 --> 00:37:28,369
it's malloc is one version and free is a

886
00:37:26,900 --> 00:37:32,089
different version that can be another

887
00:37:28,369 --> 00:37:33,710
disaster that happens this somewhat

888
00:37:32,089 --> 00:37:36,230
reminds me of when you're in C++ and

889
00:37:33,710 --> 00:37:38,990
you're dealing with Const there's a

890
00:37:36,230 --> 00:37:40,880
constant star an int Const star or in

891
00:37:38,990 --> 00:37:43,790
its star Const and there's the third one

892
00:37:40,880 --> 00:37:47,030
is a completely different meeting than

893
00:37:43,790 --> 00:37:49,460
putting it in front so a char four star

894
00:37:47,030 --> 00:37:50,570
means that the return value is going to

895
00:37:49,460 --> 00:37:53,900
be a segment and also

896
00:37:50,570 --> 00:37:56,000
32-bit value the far that comes after

897
00:37:53,900 --> 00:37:57,830
the star is saying that that function is

898
00:37:56,000 --> 00:37:59,120
going to have a 32-bit address so that

899
00:37:57,830 --> 00:38:01,610
it can be called from anywhere in the

900
00:37:59,120 --> 00:38:03,500
program as opposed to a local function

901
00:38:01,610 --> 00:38:05,120
like a static one that can only be

902
00:38:03,500 --> 00:38:08,450
called from the current file

903
00:38:05,120 --> 00:38:09,980
so making a function static in a 16-bit

904
00:38:08,450 --> 00:38:11,839
program is going to trigger a bunch of

905
00:38:09,980 --> 00:38:14,120
compiler optimizations that aren't

906
00:38:11,840 --> 00:38:15,650
necessarily relevant on 32-bit because

907
00:38:14,120 --> 00:38:18,589
static guarantees it won't be called

908
00:38:15,650 --> 00:38:22,520
from outside or unless you have a

909
00:38:18,590 --> 00:38:24,410
function pointer both of them as I said

910
00:38:22,520 --> 00:38:30,259
take a far and give you the right kind

911
00:38:24,410 --> 00:38:32,839
depending on what you've asked for so

912
00:38:30,260 --> 00:38:34,700
how about functions as we just got into

913
00:38:32,840 --> 00:38:36,260
a function can't you can have a fire

914
00:38:34,700 --> 00:38:38,000
function that returns an ear pointer an

915
00:38:36,260 --> 00:38:41,810
ear function that returns a fire pointer

916
00:38:38,000 --> 00:38:45,080
or the other two cases and so it's two

917
00:38:41,810 --> 00:38:47,750
squared so four possibilities where this

918
00:38:45,080 --> 00:38:50,840
becomes relevant so a fire function

919
00:38:47,750 --> 00:38:52,940
means that when it is called the

920
00:38:50,840 --> 00:38:55,400
function calling it may not be in the

921
00:38:52,940 --> 00:38:57,620
same code segment as that function so

922
00:38:55,400 --> 00:38:59,690
when it gets called that function the

923
00:38:57,620 --> 00:39:02,150
caller needs to know the entire 32-bit

924
00:38:59,690 --> 00:39:04,340
address when you return you need to

925
00:39:02,150 --> 00:39:05,960
switch the code segment back so that

926
00:39:04,340 --> 00:39:08,120
means that the size of the return

927
00:39:05,960 --> 00:39:09,640
address on the stack depends on the

928
00:39:08,120 --> 00:39:13,819
context in which a function was called

929
00:39:09,640 --> 00:39:15,410
thankfully it is the same depending on

930
00:39:13,820 --> 00:39:17,060
how that function was declared so

931
00:39:15,410 --> 00:39:19,009
sometimes this might be suboptimal if

932
00:39:17,060 --> 00:39:21,230
you have a far function that happens to

933
00:39:19,010 --> 00:39:23,900
be in the same code segment you swap out

934
00:39:21,230 --> 00:39:27,830
the register anyway but it works it's

935
00:39:23,900 --> 00:39:29,930
just more flexible why this is relevant

936
00:39:27,830 --> 00:39:31,490
well in a buffer overflow a return

937
00:39:29,930 --> 00:39:34,399
address is something we'll particularly

938
00:39:31,490 --> 00:39:36,520
care about how does this affect

939
00:39:34,400 --> 00:39:39,290
exploitability

940
00:39:36,520 --> 00:39:42,710
so as I alluded to this is kind of like

941
00:39:39,290 --> 00:39:47,450
1993 very weak versions of a SLR and a

942
00:39:42,710 --> 00:39:49,550
SLR meaning that you can't use you can't

943
00:39:47,450 --> 00:39:50,839
assume where the stack is and it's the

944
00:39:49,550 --> 00:39:52,250
upper bits that are different rather

945
00:39:50,840 --> 00:39:53,870
than the lower bits you can't assume

946
00:39:52,250 --> 00:39:55,580
where the code segment of the current

947
00:39:53,870 --> 00:39:57,200
program is you can't assume where the

948
00:39:55,580 --> 00:39:59,990
common libraries are so that's what I'll

949
00:39:57,200 --> 00:40:01,759
do and debt meaning you can't just put

950
00:39:59,990 --> 00:40:03,439
shell code on the stack and call it or

951
00:40:01,760 --> 00:40:04,220
jump to it you'll have to mark the stack

952
00:40:03,440 --> 00:40:07,190
as executable

953
00:40:04,220 --> 00:40:08,290
first so I'll have to speed up a little

954
00:40:07,190 --> 00:40:11,510
bit

955
00:40:08,290 --> 00:40:13,160
ASL are no memory attacks no memory

956
00:40:11,510 --> 00:40:18,440
protection a segment is unique across

957
00:40:13,160 --> 00:40:20,270
all processes running it can be bypassed

958
00:40:18,440 --> 00:40:22,430
pretty easily by just knowing where

959
00:40:20,270 --> 00:40:24,140
these very large libraries with lots of

960
00:40:22,430 --> 00:40:25,790
useful things like loading a segment

961
00:40:24,140 --> 00:40:27,410
register finding where the sack is and

962
00:40:25,790 --> 00:40:32,810
so forth that you can call from anywhere

963
00:40:27,410 --> 00:40:34,549
with Rob this version of depth you can't

964
00:40:32,810 --> 00:40:36,290
have an executable code segment what you

965
00:40:34,550 --> 00:40:38,180
can do is have a code and data that

966
00:40:36,290 --> 00:40:41,210
point to the same place so that you can

967
00:40:38,180 --> 00:40:43,160
just access it on a roundabout way to

968
00:40:41,210 --> 00:40:47,330
write to a place that's also executable

969
00:40:43,160 --> 00:40:48,649
so wait a minute the problem why did why

970
00:40:47,330 --> 00:40:50,630
wasn't depth there the whole time when

971
00:40:48,650 --> 00:40:52,640
you switch to 32 bit and you go to the

972
00:40:50,630 --> 00:40:54,260
tiny memory model you can't do this

973
00:40:52,640 --> 00:40:55,520
because you've implicitly created a

974
00:40:54,260 --> 00:40:57,530
situation where everything that's

975
00:40:55,520 --> 00:41:00,710
executable can also be accessed through

976
00:40:57,530 --> 00:41:03,880
the data segment so paging can do read

977
00:41:00,710 --> 00:41:06,080
write or read only but it can't do

978
00:41:03,880 --> 00:41:08,390
executable but not writable until they

979
00:41:06,080 --> 00:41:12,200
added that in the processor like a

980
00:41:08,390 --> 00:41:16,129
Pentium 4 or something calling

981
00:41:12,200 --> 00:41:18,140
conventions another complication so the

982
00:41:16,130 --> 00:41:20,300
one we're used to see deckle when you

983
00:41:18,140 --> 00:41:21,470
call a c function the arguments start at

984
00:41:20,300 --> 00:41:23,140
the end and it passes them to the

985
00:41:21,470 --> 00:41:25,459
beginning what's the reason for that

986
00:41:23,140 --> 00:41:27,410
variable number of arguments a function

987
00:41:25,460 --> 00:41:29,359
is expected to figure out how many they

988
00:41:27,410 --> 00:41:30,799
are by looking at the first one so the

989
00:41:29,359 --> 00:41:32,480
first argument better be somewhere that

990
00:41:30,800 --> 00:41:35,359
it knows where it is so if you pass them

991
00:41:32,480 --> 00:41:36,859
in reverse order that will happen 16-bit

992
00:41:35,359 --> 00:41:39,410
code on Windows tends to use a different

993
00:41:36,859 --> 00:41:41,299
calling convention which is Pascal one

994
00:41:39,410 --> 00:41:42,920
of the differences is you pass arguments

995
00:41:41,300 --> 00:41:45,560
from left to right so they end up upside

996
00:41:42,920 --> 00:41:48,800
down and the other part of it is the

997
00:41:45,560 --> 00:41:51,080
collie is responsible for popping

998
00:41:48,800 --> 00:41:53,000
everything off the stack in terms of the

999
00:41:51,080 --> 00:41:56,450
arguments as opposed to the caller why

1000
00:41:53,000 --> 00:41:58,130
would they do that so by moving the

1001
00:41:56,450 --> 00:41:59,720
stack cleanup code from the caller to

1002
00:41:58,130 --> 00:42:01,190
the callee the code gets somewhat

1003
00:41:59,720 --> 00:42:03,290
smaller and it was small enough to

1004
00:42:01,190 --> 00:42:05,450
reduce the number of floppy disks that

1005
00:42:03,290 --> 00:42:06,849
the first version of Windows needed to

1006
00:42:05,450 --> 00:42:09,080
fit on or something along those lines

1007
00:42:06,849 --> 00:42:12,830
might be an urban legend but the code

1008
00:42:09,080 --> 00:42:15,710
size part is true kind of done this

1009
00:42:12,830 --> 00:42:17,859
already so this is just a some

1010
00:42:15,710 --> 00:42:20,119
screenshots of what we did

1011
00:42:17,859 --> 00:42:23,359
we were in the debugger you see for

1012
00:42:20,119 --> 00:42:25,430
one-for-one everywhere now building the

1013
00:42:23,359 --> 00:42:28,819
rob chain so what we've observed and

1014
00:42:25,430 --> 00:42:31,879
what we need to do so the problems we

1015
00:42:28,820 --> 00:42:33,349
have is our shellcode is on the stack we

1016
00:42:31,880 --> 00:42:35,920
don't know the segment selector of the

1017
00:42:33,349 --> 00:42:39,109
stack so we need to figure that out so

1018
00:42:35,920 --> 00:42:40,790
thankfully there are brought gadgets

1019
00:42:39,109 --> 00:42:42,529
that we can find they'll take SS and put

1020
00:42:40,790 --> 00:42:44,270
it somewhere convenient the other part

1021
00:42:42,530 --> 00:42:46,720
we need to do is get a different view of

1022
00:42:44,270 --> 00:42:49,009
the stack but marked as executable and

1023
00:42:46,720 --> 00:42:59,629
thankfully there's a nice function in

1024
00:42:49,010 --> 00:43:02,930
the API section I closed the entire VM

1025
00:42:59,630 --> 00:43:05,150
so there's a function called Alec ds2 CS

1026
00:43:02,930 --> 00:43:10,368
alias which is basically the virtual

1027
00:43:05,150 --> 00:43:11,960
protect of 1993 so with time it's a

1028
00:43:10,369 --> 00:43:14,000
little short but I can show you in the

1029
00:43:11,960 --> 00:43:20,119
white paper I have a nice diagram that

1030
00:43:14,000 --> 00:43:23,390
goes through all of this so what we end

1031
00:43:20,119 --> 00:43:27,020
up doing this is custom-made for the FTP

1032
00:43:23,390 --> 00:43:29,779
client so the first thing we do is

1033
00:43:27,020 --> 00:43:32,690
overwrite BP you can actually somewhat

1034
00:43:29,780 --> 00:43:34,280
hard code offsets to the stack assuming

1035
00:43:32,690 --> 00:43:37,550
the user uses the program in the same

1036
00:43:34,280 --> 00:43:39,830
way same way that you did because with

1037
00:43:37,550 --> 00:43:43,700
that all the randomness or uncertainty

1038
00:43:39,830 --> 00:43:47,630
is in the selector not the offset so we

1039
00:43:43,700 --> 00:43:49,490
end up doing that and this move a XSS

1040
00:43:47,630 --> 00:43:51,650
we're going to pull the stack selector

1041
00:43:49,490 --> 00:43:53,180
and put it into X and then put it

1042
00:43:51,650 --> 00:43:56,510
somewhere convenient which is an offset

1043
00:43:53,180 --> 00:43:59,270
of BP get that stack selector and pass

1044
00:43:56,510 --> 00:44:04,070
it to Alec ds2 CS elias with some

1045
00:43:59,270 --> 00:44:06,080
complications to deal with no bytes what

1046
00:44:04,070 --> 00:44:08,210
that function will return is a different

1047
00:44:06,080 --> 00:44:10,670
segment selector that when loaded gives

1048
00:44:08,210 --> 00:44:15,260
you the same view as a stack but marked

1049
00:44:10,670 --> 00:44:17,359
as executable so we can hard code the

1050
00:44:15,260 --> 00:44:18,950
offset to the shell code but now we have

1051
00:44:17,359 --> 00:44:22,250
the selector done dynamically and

1052
00:44:18,950 --> 00:44:24,140
finally this plus ax push BX and don't

1053
00:44:22,250 --> 00:44:25,849
pop them and then return you've loaded

1054
00:44:24,140 --> 00:44:30,950
an address on the stack and then jump to

1055
00:44:25,849 --> 00:44:31,609
it as a four-pointer so this is a more

1056
00:44:30,950 --> 00:44:32,149
long-winded

1057
00:44:31,609 --> 00:44:39,288
version

1058
00:44:32,150 --> 00:44:40,910
that so this goes explicitly through the

1059
00:44:39,289 --> 00:44:43,099
individual gadgets I found the way I

1060
00:44:40,910 --> 00:44:45,200
found them was dumping the code segment

1061
00:44:43,099 --> 00:44:46,880
of user and kernel to disk and then just

1062
00:44:45,200 --> 00:44:49,129
writing a Python script that looks for a

1063
00:44:46,880 --> 00:44:51,920
return and then looks backward for

1064
00:44:49,130 --> 00:44:54,650
something convenient so that's exactly

1065
00:44:51,920 --> 00:44:56,270
what we do reposition the stack figure

1066
00:44:54,650 --> 00:44:59,119
out where SS is and put it somewhere

1067
00:44:56,270 --> 00:45:03,650
good pass it to this function that's the

1068
00:44:59,119 --> 00:45:07,520
virtual protect of 1993 and then jump to

1069
00:45:03,650 --> 00:45:09,950
that offset B X which is the offset we

1070
00:45:07,520 --> 00:45:11,210
know a X is this view of the stack is

1071
00:45:09,950 --> 00:45:15,109
executable that we just obtained

1072
00:45:11,210 --> 00:45:17,210
dynamically so the other part that we

1073
00:45:15,109 --> 00:45:20,029
need is shellcode which is comparatively

1074
00:45:17,210 --> 00:45:23,569
easy I just did a calculator one so all

1075
00:45:20,029 --> 00:45:25,880
I did was figure out the win exec get

1076
00:45:23,569 --> 00:45:28,670
the address of that in the same way 0 to

1077
00:45:25,880 --> 00:45:30,380
8f and just make a shell code that puts

1078
00:45:28,670 --> 00:45:32,210
win exec on the stack and then jumps to

1079
00:45:30,380 --> 00:45:34,130
it the only complication is the Pascal

1080
00:45:32,210 --> 00:45:39,589
stuff you have to do it backward from

1081
00:45:34,130 --> 00:45:43,119
what you're used to so a more pre done

1082
00:45:39,589 --> 00:45:48,589
demo here shows that it actually works

1083
00:45:43,119 --> 00:45:54,020
well it's a video a little bit but it

1084
00:45:48,589 --> 00:45:56,180
works so this is connected to a Python

1085
00:45:54,020 --> 00:45:58,730
script that I wrote specifically for the

1086
00:45:56,180 --> 00:46:00,770
purposes of serving as a malicious ftp

1087
00:45:58,730 --> 00:46:02,599
server that deals with all the binary

1088
00:46:00,770 --> 00:46:04,339
characters the correct way and so forth

1089
00:46:02,599 --> 00:46:11,029
and there you go crashes in the

1090
00:46:04,339 --> 00:46:12,828
calculator so that CVE is where somebody

1091
00:46:11,029 --> 00:46:14,299
else found it in the 32-bit version so I

1092
00:46:12,829 --> 00:46:15,619
didn't want to claim it's technically

1093
00:46:14,299 --> 00:46:18,430
not a new it it's not a new

1094
00:46:15,619 --> 00:46:22,400
vulnerability it's a new exploit I guess

1095
00:46:18,430 --> 00:46:24,649
so I've got to wrap up here but some

1096
00:46:22,400 --> 00:46:26,960
static images showing the link overflow

1097
00:46:24,650 --> 00:46:28,460
and Acrobat Reader also works that one

1098
00:46:26,960 --> 00:46:30,020
unfortunately hangs a machine if you

1099
00:46:28,460 --> 00:46:31,339
control delete to the blue screen of

1100
00:46:30,020 --> 00:46:35,000
death and then get rid of it and then

1101
00:46:31,339 --> 00:46:38,119
you get control back and the winzip one

1102
00:46:35,000 --> 00:46:39,559
ends up working as well so the

1103
00:46:38,119 --> 00:46:40,789
interesting thing like trying to get rid

1104
00:46:39,559 --> 00:46:42,109
of that message that will be a whole

1105
00:46:40,789 --> 00:46:45,000
diversion that I didn't even get into

1106
00:46:42,109 --> 00:46:47,190
because you have

1107
00:46:45,000 --> 00:46:48,599
it's possible that's a modal dialogue

1108
00:46:47,190 --> 00:46:50,070
what if it hangs the machine and you're

1109
00:46:48,599 --> 00:46:51,660
trying to do remote shell or something

1110
00:46:50,070 --> 00:46:53,430
like imagine trying to do a remote shell

1111
00:46:51,660 --> 00:46:59,098
on Windows 3.1 in the first place much

1112
00:46:53,430 --> 00:47:00,180
less maliciously so just wrapping up

1113
00:46:59,099 --> 00:47:02,700
here in case there are any questions

1114
00:47:00,180 --> 00:47:04,080
I'll be over in the IOT village after

1115
00:47:02,700 --> 00:47:07,859
this since I'm bubbling up against the

1116
00:47:04,080 --> 00:47:11,609
50 minutes somewhat future work you

1117
00:47:07,859 --> 00:47:13,529
could unfortunately with 64-bit this

1118
00:47:11,609 --> 00:47:16,460
just became not relevant but what about

1119
00:47:13,530 --> 00:47:21,420
16-bit programs running on a 32-bit OS

1120
00:47:16,460 --> 00:47:23,609
what if you have XP with a SLR how does

1121
00:47:21,420 --> 00:47:25,859
it do a SLR on 16-bit programs does it

1122
00:47:23,609 --> 00:47:28,560
even attempt that if you compromise one

1123
00:47:25,859 --> 00:47:30,210
or you sandbox inside ntvdm or can you

1124
00:47:28,560 --> 00:47:33,810
do something much worse like exploit

1125
00:47:30,210 --> 00:47:36,420
ntvdm which is relevant and has happened

1126
00:47:33,810 --> 00:47:38,340
in like local exploits embedded devices

1127
00:47:36,420 --> 00:47:40,230
I don't think there's too much 16-bit

1128
00:47:38,340 --> 00:47:42,510
x86 out there you could have like a

1129
00:47:40,230 --> 00:47:44,970
really old security system or something

1130
00:47:42,510 --> 00:47:47,310
that is still out there industrial stuff

1131
00:47:44,970 --> 00:47:49,500
this definitely exists and then the

1132
00:47:47,310 --> 00:47:51,180
other like more reflective question what

1133
00:47:49,500 --> 00:47:52,710
is like right under our noses now that

1134
00:47:51,180 --> 00:47:55,890
the exploit techniques just don't exist

1135
00:47:52,710 --> 00:47:58,710
yet so when I wrote this last year

1136
00:47:55,890 --> 00:47:59,569
meltdown had not come out yet so there

1137
00:47:58,710 --> 00:48:05,160
you go

1138
00:47:59,570 --> 00:48:07,349
right so the white paper has far more

1139
00:48:05,160 --> 00:48:09,299
interesting details all the technical

1140
00:48:07,349 --> 00:48:13,440
stuff if you go on our website you can

1141
00:48:09,300 --> 00:48:15,390
find it and I will be over in that room

1142
00:48:13,440 --> 00:48:17,190
so I can let the next speaker come in at

1143
00:48:15,390 --> 00:48:22,250
the IOT village for any questions anyone

1144
00:48:17,190 --> 00:48:22,250
has otherwise I will wrap up

