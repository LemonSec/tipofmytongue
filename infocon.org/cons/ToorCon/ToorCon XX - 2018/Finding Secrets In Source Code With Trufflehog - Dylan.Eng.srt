1
00:00:01,970 --> 00:00:07,410
alright guys welcome to the next talk

2
00:00:05,759 --> 00:00:08,730
here on this wonderful wonderful Sunday

3
00:00:07,410 --> 00:00:11,280
morning thank you guys for showing up

4
00:00:08,730 --> 00:00:13,860
and getting out of bed and rolling into

5
00:00:11,280 --> 00:00:15,540
into the track right now I've got the

6
00:00:13,860 --> 00:00:17,038
pleasure Trinity's Dillon on stage who's

7
00:00:15,540 --> 00:00:18,630
gonna be talking about fighting secrets

8
00:00:17,039 --> 00:00:20,250
insource with truffle hog

9
00:00:18,630 --> 00:00:35,550
so please welcome him to the torque on

10
00:00:20,250 --> 00:00:40,559
stage thank you for the kind

11
00:00:35,550 --> 00:00:44,129
introduction folks hear me ok cool

12
00:00:40,559 --> 00:00:48,539
so basically I wrote this tool a little

13
00:00:44,129 --> 00:00:51,629
while ago that does as described it it

14
00:00:48,539 --> 00:00:53,309
helps identify secrets committed to

15
00:00:51,629 --> 00:00:56,849
source code and I'm just going to be

16
00:00:53,309 --> 00:00:59,218
talking about why I wrote it with sort

17
00:00:56,850 --> 00:01:00,780
of motivations were how to use it and

18
00:00:59,219 --> 00:01:02,039
what sort of the path forward looks for

19
00:01:00,780 --> 00:01:06,299
it

20
00:01:02,039 --> 00:01:08,250
so you know at a high level I think I

21
00:01:06,299 --> 00:01:09,479
need to start with like why I'm trying

22
00:01:08,250 --> 00:01:12,140
to solve this problem in the first place

23
00:01:09,479 --> 00:01:17,220
like what is this problem is it problem

24
00:01:12,140 --> 00:01:19,310
so I think most folks are probably at

25
00:01:17,220 --> 00:01:21,929
least at a high level familiar with

26
00:01:19,310 --> 00:01:24,600
certain security incidences and breaches

27
00:01:21,930 --> 00:01:28,229
that have occurred from secrets being

28
00:01:24,600 --> 00:01:30,960
committed to source code that's

29
00:01:28,229 --> 00:01:32,520
generally as a result of secrets being

30
00:01:30,960 --> 00:01:35,220
committed to source code and that source

31
00:01:32,520 --> 00:01:38,970
code becoming open-source but there are

32
00:01:35,220 --> 00:01:41,100
instances that also occur from internal

33
00:01:38,970 --> 00:01:42,750
source code as well it can also be used

34
00:01:41,100 --> 00:01:44,339
for a lateral movement so if you move on

35
00:01:42,750 --> 00:01:46,560
to a machine and that machine has source

36
00:01:44,340 --> 00:01:49,470
code developer workstation or production

37
00:01:46,560 --> 00:01:53,009
machine you can potentially extract

38
00:01:49,470 --> 00:01:55,110
secrets from that source code and then

39
00:01:53,009 --> 00:01:57,570
move laterally with the use of those

40
00:01:55,110 --> 00:01:58,619
credentials you can also help elevate

41
00:01:57,570 --> 00:02:01,380
privilege

42
00:01:58,619 --> 00:02:03,119
same idea you take a credential from the

43
00:02:01,380 --> 00:02:04,469
source code you move to another machine

44
00:02:03,119 --> 00:02:06,829
in the environment and you may have only

45
00:02:04,469 --> 00:02:09,179
elevate your privilege that way

46
00:02:06,829 --> 00:02:12,780
sometimes exploitation can be hard to

47
00:02:09,179 --> 00:02:13,890
detect if this if you grab a shell and

48
00:02:12,780 --> 00:02:15,900
you use it against the public

49
00:02:13,890 --> 00:02:18,299
end point it can be very hard for an

50
00:02:15,900 --> 00:02:21,270
organization to tell whether or not that

51
00:02:18,300 --> 00:02:23,550
credential was used for a legitimate

52
00:02:21,270 --> 00:02:30,390
reason from the application or being

53
00:02:23,550 --> 00:02:33,000
used by the malicious person if if a

54
00:02:30,390 --> 00:02:35,100
workstation gets lost and those secrets

55
00:02:33,000 --> 00:02:37,410
are hard-coded on disk it can be really

56
00:02:35,100 --> 00:02:38,930
easy to pull those secret's out if you

57
00:02:37,410 --> 00:02:41,820
don't have a full disk encryption setup

58
00:02:38,930 --> 00:02:45,360
and then the last bullet point here

59
00:02:41,820 --> 00:02:47,340
source code is kind of leaky like you

60
00:02:45,360 --> 00:02:49,290
may accidentally expose your dot git

61
00:02:47,340 --> 00:02:50,670
directory on your website and then all

62
00:02:49,290 --> 00:02:53,700
of a sudden all your source code becomes

63
00:02:50,670 --> 00:02:55,619
public or someone internally may

64
00:02:53,700 --> 00:02:57,869
intentionally publish your source code

65
00:02:55,620 --> 00:03:00,330
or your source code may get pastebin or

66
00:02:57,870 --> 00:03:02,790
a hundred other reasons I'm sure folks

67
00:03:00,330 --> 00:03:04,800
in in the audience are very familiar

68
00:03:02,790 --> 00:03:08,190
with these types of things but

69
00:03:04,800 --> 00:03:09,690
ultimately source code ends up sort of

70
00:03:08,190 --> 00:03:13,170
leaking out in ways that we can't really

71
00:03:09,690 --> 00:03:16,020
control and so to help prevent the the

72
00:03:13,170 --> 00:03:19,829
fallout from that we we we tried to not

73
00:03:16,020 --> 00:03:23,670
put secrets and source code so this is a

74
00:03:19,830 --> 00:03:26,780
one example so Reed the guy that runs

75
00:03:23,670 --> 00:03:29,339
besides SF he also works at hacker one

76
00:03:26,780 --> 00:03:32,700
paid out two thousand dollars to the

77
00:03:29,340 --> 00:03:35,760
hacker one hacker one bug bounty because

78
00:03:32,700 --> 00:03:39,320
someone submitted an issue basically

79
00:03:35,760 --> 00:03:43,709
saying hey Reed you published your

80
00:03:39,320 --> 00:03:46,579
github token to to public it hub and

81
00:03:43,709 --> 00:03:49,709
they paid him out to ground for that

82
00:03:46,580 --> 00:03:51,959
this is another example some researcher

83
00:03:49,709 --> 00:03:54,540
just went to github and just it's sort

84
00:03:51,959 --> 00:03:56,190
of like a Google dork style let me

85
00:03:54,540 --> 00:03:58,769
search for all the slack tokens and

86
00:03:56,190 --> 00:04:00,840
found 1500 of them so he was able to

87
00:03:58,769 --> 00:04:02,880
just squat and all those slacks

88
00:04:00,840 --> 00:04:04,380
you can imagine like tons of those

89
00:04:02,880 --> 00:04:05,910
tokens probably belong to companies and

90
00:04:04,380 --> 00:04:09,570
he was able to just grab all the chat

91
00:04:05,910 --> 00:04:13,170
history from all those companies there's

92
00:04:09,570 --> 00:04:15,150
another example basically a developer

93
00:04:13,170 --> 00:04:17,399
accidentally committed an AWS token and

94
00:04:15,150 --> 00:04:19,739
in that organization was served with a

95
00:04:17,399 --> 00:04:22,440
two thousand dollar bill that month from

96
00:04:19,738 --> 00:04:24,179
AWS because someone had taken that

97
00:04:22,440 --> 00:04:27,780
credential and used it to mine Bitcoin

98
00:04:24,180 --> 00:04:31,830
on on that of that company's account

99
00:04:27,780 --> 00:04:34,138
so that's a pretty expensive mistake but

100
00:04:31,830 --> 00:04:36,599
does get worse in this particular

101
00:04:34,139 --> 00:04:39,180
instance again AWS token committed to

102
00:04:36,599 --> 00:04:41,550
github this organization was served with

103
00:04:39,180 --> 00:04:44,330
a 64 thousand dollar bill so that's

104
00:04:41,550 --> 00:04:47,370
almost somebody salary because somebody

105
00:04:44,330 --> 00:04:51,240
accidentally committed an AWS credential

106
00:04:47,370 --> 00:04:54,569
to github so these certainly can be very

107
00:04:51,240 --> 00:04:57,569
expensive mistakes and then I'm sure

108
00:04:54,569 --> 00:05:00,320
most folks are familiar with this one

109
00:04:57,569 --> 00:05:01,789
uber recently in the last year

110
00:05:00,320 --> 00:05:05,279
[Music]

111
00:05:01,789 --> 00:05:07,818
researcher identified an AWS credential

112
00:05:05,279 --> 00:05:11,219
that was committed to their github and

113
00:05:07,819 --> 00:05:16,199
that researcher may or may not have

114
00:05:11,219 --> 00:05:19,740
extorted uber for $100,000 and you were

115
00:05:16,199 --> 00:05:22,590
paid out and so it became national news

116
00:05:19,740 --> 00:05:27,120
because that credential had access to

117
00:05:22,590 --> 00:05:28,919
tons of user information and it

118
00:05:27,120 --> 00:05:31,379
definitely got a high amount of

119
00:05:28,919 --> 00:05:32,940
visibility I think the C so uber ended

120
00:05:31,379 --> 00:05:35,699
up testifying in front of Congress about

121
00:05:32,940 --> 00:05:39,210
it what folks may not remember those

122
00:05:35,699 --> 00:05:41,449
just two years prior Hoover had another

123
00:05:39,210 --> 00:05:43,620
AWS token that was committed to github

124
00:05:41,449 --> 00:05:46,199
and this one was actually kind of

125
00:05:43,620 --> 00:05:48,779
interesting because github was

126
00:05:46,199 --> 00:05:51,479
subpoenaed by uber requesting all the IP

127
00:05:48,779 --> 00:05:52,770
addresses that accessed that resource

128
00:05:51,479 --> 00:05:56,818
because they wanted to know if anyone

129
00:05:52,770 --> 00:05:58,589
used this for nefarious purposes so it

130
00:05:56,819 --> 00:06:02,069
kind of just speaks to like this this

131
00:05:58,589 --> 00:06:06,539
mistake can lead to subpoenas litigation

132
00:06:02,069 --> 00:06:09,750
like multi-thousand dollar bills on your

133
00:06:06,539 --> 00:06:12,750
account and it's you know sometimes

134
00:06:09,750 --> 00:06:14,819
really hard to figure out who's used

135
00:06:12,750 --> 00:06:16,889
this credential in this case they had to

136
00:06:14,819 --> 00:06:20,789
subpoena github to get the answer that

137
00:06:16,889 --> 00:06:23,219
and that question so this is not a talk

138
00:06:20,789 --> 00:06:24,479
telling you where you should store your

139
00:06:23,219 --> 00:06:26,400
credentials

140
00:06:24,479 --> 00:06:28,339
there's a ton of options out there and

141
00:06:26,400 --> 00:06:31,138
depending on your infrastructure

142
00:06:28,339 --> 00:06:32,849
you should definitely pick the option

143
00:06:31,139 --> 00:06:34,589
that makes the most sense to you I'm not

144
00:06:32,849 --> 00:06:36,539
here to tell you you should store it in

145
00:06:34,589 --> 00:06:40,800
environment variables or UNIX domain

146
00:06:36,539 --> 00:06:41,248
sockets you should do that research for

147
00:06:40,800 --> 00:06:42,899
yourself

148
00:06:41,249 --> 00:06:47,099
this is a talk more just telling you not

149
00:06:42,899 --> 00:06:49,709
store it in github so you can see

150
00:06:47,099 --> 00:06:51,779
truffle hog up there is that tiny border

151
00:06:49,709 --> 00:06:54,689
collie up in the corner and all those

152
00:06:51,779 --> 00:06:57,119
lambs are your AWS tokens and truffle

153
00:06:54,689 --> 00:07:01,619
hogs goal is to herd them all into your

154
00:06:57,119 --> 00:07:03,209
secrets management solution so sort of

155
00:07:01,619 --> 00:07:04,379
at a high level we think about where

156
00:07:03,209 --> 00:07:07,439
source code lives

157
00:07:04,379 --> 00:07:08,699
it sounds like an obvious like that

158
00:07:07,439 --> 00:07:10,349
there's an obvious answer that lives in

159
00:07:08,699 --> 00:07:12,299
version control but when you stop to

160
00:07:10,349 --> 00:07:13,649
think about it a little further our

161
00:07:12,299 --> 00:07:17,638
source code actually lives a lot of

162
00:07:13,649 --> 00:07:21,299
other places so for example package

163
00:07:17,639 --> 00:07:23,249
managers contain source code and package

164
00:07:21,299 --> 00:07:25,378
managers and version control can be out

165
00:07:23,249 --> 00:07:26,909
of sync with one another so what's

166
00:07:25,379 --> 00:07:30,149
published to your internal or external

167
00:07:26,909 --> 00:07:32,339
NPM pipe I take your pick

168
00:07:30,149 --> 00:07:35,549
may not necessarily reflect what's in

169
00:07:32,339 --> 00:07:38,189
github mobile applications every time

170
00:07:35,549 --> 00:07:39,808
you download a mobile app say an apk for

171
00:07:38,189 --> 00:07:41,729
an Android app you're downloading a

172
00:07:39,809 --> 00:07:44,639
whole bunch of source code for it and

173
00:07:41,729 --> 00:07:47,068
folks have spiked on again identifying

174
00:07:44,639 --> 00:07:49,939
secrets that actually get packaged into

175
00:07:47,069 --> 00:07:53,279
those apks and shipped out to the users

176
00:07:49,939 --> 00:07:55,379
slack like folks will post snippets of

177
00:07:53,279 --> 00:07:56,808
code they'll upload files asking for

178
00:07:55,379 --> 00:08:00,259
help

179
00:07:56,809 --> 00:08:02,459
tons of source code ends up in slack

180
00:08:00,259 --> 00:08:04,379
websites this one's kind of a funny one

181
00:08:02,459 --> 00:08:06,239
but if you if you stop and start

182
00:08:04,379 --> 00:08:09,739
analyzing HTML and looking through

183
00:08:06,239 --> 00:08:12,719
comment blocks and looking through like

184
00:08:09,739 --> 00:08:15,599
like JavaScript variables and stuff like

185
00:08:12,719 --> 00:08:18,179
that you'll find tons of credentials

186
00:08:15,599 --> 00:08:19,739
sometimes commented out basic author

187
00:08:18,179 --> 00:08:21,688
credentials that were used when the

188
00:08:19,739 --> 00:08:23,549
application was internal just as the

189
00:08:21,689 --> 00:08:25,079
first round of off but the password is

190
00:08:23,549 --> 00:08:28,769
still there and it's a sensitive

191
00:08:25,079 --> 00:08:30,239
password used in other contexts but the

192
00:08:28,769 --> 00:08:32,610
bulk of my talk here is gonna focus on

193
00:08:30,239 --> 00:08:35,429
the last bullet point here revision

194
00:08:32,610 --> 00:08:37,199
history right in version control you

195
00:08:35,429 --> 00:08:39,838
have the most recent incarnation of

196
00:08:37,198 --> 00:08:42,029
source code and that's typically where

197
00:08:39,839 --> 00:08:44,279
people go to look for vulnerabilities we

198
00:08:42,029 --> 00:08:46,170
have this entire mountain of buried

199
00:08:44,279 --> 00:08:48,149
source code in the revision history that

200
00:08:46,170 --> 00:08:53,628
we don't tend to pay a lot of attention

201
00:08:48,149 --> 00:08:55,110
to so I have an example here this is the

202
00:08:53,629 --> 00:09:00,149
Facebook's

203
00:08:55,110 --> 00:09:02,760
react public github repository and on

204
00:09:00,149 --> 00:09:04,760
the top in green you can see all the

205
00:09:02,760 --> 00:09:07,800
contributions that were added to github

206
00:09:04,760 --> 00:09:09,240
project but more interestingly on the

207
00:09:07,800 --> 00:09:10,769
bottom here you can see all the code

208
00:09:09,240 --> 00:09:15,959
that was taken away from the project

209
00:09:10,769 --> 00:09:18,390
since it started and there's as much if

210
00:09:15,959 --> 00:09:20,339
not more code buried and revision

211
00:09:18,390 --> 00:09:22,980
control on the bottom there then there

212
00:09:20,339 --> 00:09:26,070
is in the current version on the top and

213
00:09:22,980 --> 00:09:27,630
this is consistent across most projects

214
00:09:26,070 --> 00:09:29,550
you look at there's actually a

215
00:09:27,630 --> 00:09:33,750
tremendous amount of code that's that's

216
00:09:29,550 --> 00:09:35,069
buried an inversion controlled and and

217
00:09:33,750 --> 00:09:36,450
this is a problem when it comes to

218
00:09:35,070 --> 00:09:38,790
secrets and source code for most

219
00:09:36,450 --> 00:09:40,740
vulnerabilities this isn't an issue you

220
00:09:38,790 --> 00:09:42,689
have a problem you can patch it you can

221
00:09:40,740 --> 00:09:45,180
fix it and then folks are only gonna

222
00:09:42,690 --> 00:09:47,730
download the most recent version of the

223
00:09:45,180 --> 00:09:49,170
code going forward but if you commit a

224
00:09:47,730 --> 00:09:51,360
secret to source code and then you push

225
00:09:49,170 --> 00:09:52,949
over the top of it that that revision

226
00:09:51,360 --> 00:09:55,380
control is still accessible and if that

227
00:09:52,950 --> 00:09:58,589
token is live it can still be found and

228
00:09:55,380 --> 00:10:01,740
still be used so this is really common

229
00:09:58,589 --> 00:10:04,829
and one of the top most common reasons I

230
00:10:01,740 --> 00:10:07,140
think is a developer may accidentally

231
00:10:04,829 --> 00:10:09,599
push a credential and then they'll push

232
00:10:07,140 --> 00:10:10,620
that upstream and then other folks will

233
00:10:09,600 --> 00:10:12,690
pull that down on their local

234
00:10:10,620 --> 00:10:14,910
workstations they'll realize they made

235
00:10:12,690 --> 00:10:18,930
the mistake and then they'll know if

236
00:10:14,910 --> 00:10:20,880
they if they modify the source code

237
00:10:18,930 --> 00:10:22,439
further at that point all the other

238
00:10:20,880 --> 00:10:24,089
developers will have to do a force pull

239
00:10:22,440 --> 00:10:26,459
and they'll have to merge and fix there

240
00:10:24,089 --> 00:10:29,040
their get history and it'll be really

241
00:10:26,459 --> 00:10:30,359
visible and it to save themselves the

242
00:10:29,040 --> 00:10:32,750
embarrassment I think often times

243
00:10:30,360 --> 00:10:35,100
they'll just push over the top of it

244
00:10:32,750 --> 00:10:37,260
rationalizing that no one will ever look

245
00:10:35,100 --> 00:10:38,459
back there it can't be found because

246
00:10:37,260 --> 00:10:42,480
it'll be buried a mountain of other

247
00:10:38,459 --> 00:10:44,399
commits that's that's a really common

248
00:10:42,480 --> 00:10:46,770
pattern I've seen another common pattern

249
00:10:44,399 --> 00:10:48,449
is maybe just a new feature comes that

250
00:10:46,770 --> 00:10:50,430
just completely replaces an old feature

251
00:10:48,449 --> 00:10:52,589
so maybe you're you're working on a new

252
00:10:50,430 --> 00:10:56,579
application and you decide to

253
00:10:52,589 --> 00:10:57,810
temporarily store files and s3 and then

254
00:10:56,579 --> 00:11:00,449
at some point you say to yourself

255
00:10:57,810 --> 00:11:01,890
actually I want to move to sqs and I

256
00:11:00,449 --> 00:11:04,319
want to use their pub/sub instead of

257
00:11:01,890 --> 00:11:06,870
temporarily using s3 for that so you

258
00:11:04,320 --> 00:11:09,600
replace that large swath of code

259
00:11:06,870 --> 00:11:11,730
and you put a new credential in you put

260
00:11:09,600 --> 00:11:14,250
an s Q s credential in replacing the s 3

261
00:11:11,730 --> 00:11:16,890
credential but the S 3 credential is

262
00:11:14,250 --> 00:11:19,950
still there it's still in vision control

263
00:11:16,890 --> 00:11:21,360
and later when somebody does a review of

264
00:11:19,950 --> 00:11:22,980
the source code and they find that sqs

265
00:11:21,360 --> 00:11:26,040
credential and they remove that and

266
00:11:22,980 --> 00:11:27,960
rotate it it doesn't actually remove the

267
00:11:26,040 --> 00:11:29,610
old s 3 thread that's still live and

268
00:11:27,960 --> 00:11:31,620
still buried in the source control and

269
00:11:29,610 --> 00:11:33,780
that kind of leads into the next point

270
00:11:31,620 --> 00:11:36,660
here when folks go to do their open

271
00:11:33,780 --> 00:11:37,860
source review if you work for a company

272
00:11:36,660 --> 00:11:39,569
and you want to open source something

273
00:11:37,860 --> 00:11:42,570
usually there's an open source review

274
00:11:39,570 --> 00:11:44,400
process security will do an audit but

275
00:11:42,570 --> 00:11:46,050
the vast majority of the time when

276
00:11:44,400 --> 00:11:47,760
security doesn't audit this includes

277
00:11:46,050 --> 00:11:49,680
myself we only look at the latest

278
00:11:47,760 --> 00:11:51,569
incarnation of the code we don't go back

279
00:11:49,680 --> 00:11:53,790
and read all the old you know buried

280
00:11:51,570 --> 00:11:56,970
history we don't read the the negative

281
00:11:53,790 --> 00:11:58,709
commits that I showed earlier and so if

282
00:11:56,970 --> 00:12:00,060
devs know this going in they're gonna

283
00:11:58,710 --> 00:12:01,800
want to do some cleanup before it

284
00:12:00,060 --> 00:12:04,229
reaches the open source software review

285
00:12:01,800 --> 00:12:06,180
and when they do their cleanup they may

286
00:12:04,230 --> 00:12:09,030
pick some cross-site scripting

287
00:12:06,180 --> 00:12:10,920
vulnerabilities they may you know do

288
00:12:09,030 --> 00:12:12,920
some last-minute tuneups and one of

289
00:12:10,920 --> 00:12:15,900
those tuneups maybe removing credentials

290
00:12:12,920 --> 00:12:17,670
but they may use the pattern I mentioned

291
00:12:15,900 --> 00:12:19,920
before to do that they'll just push over

292
00:12:17,670 --> 00:12:21,870
the top and then the security guy will

293
00:12:19,920 --> 00:12:23,760
get the get the code they'll do the

294
00:12:21,870 --> 00:12:26,100
review and they'll only look at the

295
00:12:23,760 --> 00:12:29,100
latest incarnation of the code they

296
00:12:26,100 --> 00:12:34,080
won't look at the the the buried commit

297
00:12:29,100 --> 00:12:37,740
history so I have nothing up my sleeves

298
00:12:34,080 --> 00:12:39,720
I took this screenshot an hour ago

299
00:12:37,740 --> 00:12:42,990
because I wanted to be as as fresh as

300
00:12:39,720 --> 00:12:45,720
possible I went into github and I did

301
00:12:42,990 --> 00:12:48,450
the same sort of Google Dorking approach

302
00:12:45,720 --> 00:12:50,370
I searched removed password into github

303
00:12:48,450 --> 00:12:53,400
and you can see there's almost half a

304
00:12:50,370 --> 00:12:55,500
million commits here of folks removing

305
00:12:53,400 --> 00:12:56,819
their their password and if you click it

306
00:12:55,500 --> 00:12:58,440
you can see what the password was

307
00:12:56,820 --> 00:13:02,040
because it's still it's still in

308
00:12:58,440 --> 00:13:05,790
revision control there's another one

309
00:13:02,040 --> 00:13:08,520
removed AWS key again those breaches and

310
00:13:05,790 --> 00:13:11,670
bills that I gave you were examples from

311
00:13:08,520 --> 00:13:13,439
a year ago this is from a couple of you

312
00:13:11,670 --> 00:13:16,550
from a couple of days ago or from a day

313
00:13:13,440 --> 00:13:18,660
ago and the top example looks like

314
00:13:16,550 --> 00:13:20,579
there's nothing stopping people from

315
00:13:18,660 --> 00:13:22,738
using these and if I was a bad guy

316
00:13:20,579 --> 00:13:25,829
and I wanted to do some nefarious stuff

317
00:13:22,739 --> 00:13:28,199
I wouldn't want to put down an AWS

318
00:13:25,829 --> 00:13:30,179
credit card and give them a bunch of

319
00:13:28,199 --> 00:13:31,920
attribution how to find me so I probably

320
00:13:30,179 --> 00:13:33,600
either use a stolen credit card or I

321
00:13:31,920 --> 00:13:34,799
just go find somebody else's credential

322
00:13:33,600 --> 00:13:39,119
and do it from their account this is a

323
00:13:34,799 --> 00:13:40,519
really easy way to do that let's say you

324
00:13:39,119 --> 00:13:43,019
want a man-in-the-middle some traffic

325
00:13:40,519 --> 00:13:45,809
this is a really great way to get SSL

326
00:13:43,019 --> 00:13:47,999
Certificates it's really hard to figure

327
00:13:45,809 --> 00:13:50,639
out what cert goes to what without a

328
00:13:47,999 --> 00:13:52,619
tremendous amount of effort so the

329
00:13:50,639 --> 00:13:54,389
effort I'm envisioning here is maybe you

330
00:13:52,619 --> 00:13:56,519
were to go pull all of these private

331
00:13:54,389 --> 00:13:57,989
keys and then you were to go to all the

332
00:13:56,519 --> 00:14:01,139
top web sites maybe the Alexa

333
00:13:57,989 --> 00:14:02,639
one-million Paul their public keys then

334
00:14:01,139 --> 00:14:04,829
you can cross-reference those and try to

335
00:14:02,639 --> 00:14:07,290
figure out what goes to what

336
00:14:04,829 --> 00:14:09,359
so most people aren't doing that and so

337
00:14:07,290 --> 00:14:11,610
there's probably a ton of live valid

338
00:14:09,360 --> 00:14:13,199
creds here and just nobodies in

339
00:14:11,610 --> 00:14:15,119
expanding the effort to figure out

340
00:14:13,199 --> 00:14:18,868
what's live and what's just a test

341
00:14:15,119 --> 00:14:21,360
certificate that doesn't matter and then

342
00:14:18,869 --> 00:14:23,299
you know this talk is on secrets it's

343
00:14:21,360 --> 00:14:26,309
not specifically on tokens or passwords

344
00:14:23,299 --> 00:14:29,189
so another really you know good

345
00:14:26,309 --> 00:14:32,429
exploitation use of this sort of going

346
00:14:29,189 --> 00:14:33,540
through a revision control here let's

347
00:14:32,429 --> 00:14:34,679
say you're doing reconnaissance in a

348
00:14:33,540 --> 00:14:37,259
company because you want to break into

349
00:14:34,679 --> 00:14:38,819
them one of the things you may want to

350
00:14:37,259 --> 00:14:42,600
do is enumerate all of their domains

351
00:14:38,819 --> 00:14:43,649
both internal and external a lot of

352
00:14:42,600 --> 00:14:45,540
times what happens is when you're

353
00:14:43,649 --> 00:14:47,369
developing a project internally before

354
00:14:45,540 --> 00:14:49,230
it becomes open-source you have it's

355
00:14:47,369 --> 00:14:51,480
hunter references to internal host names

356
00:14:49,230 --> 00:14:53,220
which again you'll strip out for the

357
00:14:51,480 --> 00:14:55,439
open source review but they'll still be

358
00:14:53,220 --> 00:14:58,610
in revision control so it's very easy to

359
00:14:55,439 --> 00:15:00,719
go through and find all of those old

360
00:14:58,610 --> 00:15:02,910
internal domain references and then

361
00:15:00,720 --> 00:15:04,489
figure out all kinds of topology about

362
00:15:02,910 --> 00:15:07,169
their internal and external environment

363
00:15:04,489 --> 00:15:10,799
based on the domain names that were

364
00:15:07,169 --> 00:15:13,379
committed to source code so here's an

365
00:15:10,799 --> 00:15:16,499
example that Netflix gave me permission

366
00:15:13,379 --> 00:15:17,549
to show again it's just the same thing

367
00:15:16,499 --> 00:15:20,189
they pushed you over the top of this

368
00:15:17,549 --> 00:15:22,739
credential it was buried it's no longer

369
00:15:20,189 --> 00:15:24,949
live but you can still access the non

370
00:15:22,739 --> 00:15:27,059
live one on Netflix is public github

371
00:15:24,949 --> 00:15:31,019
somebody just committed an AWS

372
00:15:27,059 --> 00:15:33,209
credential and so basically we need some

373
00:15:31,019 --> 00:15:34,320
way to scan these old commits nobody

374
00:15:33,209 --> 00:15:36,510
wants to go through and read

375
00:15:34,320 --> 00:15:39,690
the old negative commits just to look

376
00:15:36,510 --> 00:15:41,280
for this one class of vulnerability so

377
00:15:39,690 --> 00:15:44,340
that's this really the reason why I made

378
00:15:41,280 --> 00:15:46,020
truffle hog you can't really grep for

379
00:15:44,340 --> 00:15:48,090
these I'm not exactly sure why I'm not

380
00:15:46,020 --> 00:15:49,890
an expert in the git protocol but the

381
00:15:48,090 --> 00:15:53,820
blobs that get stores in the dot get

382
00:15:49,890 --> 00:15:56,370
directory are not in a format that can

383
00:15:53,820 --> 00:15:58,110
be easily gripped so basically I just

384
00:15:56,370 --> 00:16:00,000
wanted a tool that could go through all

385
00:15:58,110 --> 00:16:03,210
the old revision history of all the

386
00:16:00,000 --> 00:16:04,830
branches and it can find secrets that

387
00:16:03,210 --> 00:16:08,250
were otherwise not in the latest version

388
00:16:04,830 --> 00:16:11,010
of the source code so it's an open

389
00:16:08,250 --> 00:16:13,950
source tool it does exactly that goes

390
00:16:11,010 --> 00:16:16,430
through all the branches and it's job is

391
00:16:13,950 --> 00:16:19,290
just to identify secrets that were

392
00:16:16,430 --> 00:16:24,300
intentionally or accidentally committed

393
00:16:19,290 --> 00:16:26,490
to see to source code so when I first

394
00:16:24,300 --> 00:16:29,550
started the truffle hog project I wanted

395
00:16:26,490 --> 00:16:31,050
to like sort of just prove a point like

396
00:16:29,550 --> 00:16:34,650
shipped a minimalist amount of effort

397
00:16:31,050 --> 00:16:37,979
that I could to find and identify these

398
00:16:34,650 --> 00:16:40,230
secrets so the way I first set this up

399
00:16:37,980 --> 00:16:42,690
is I said go through all the old

400
00:16:40,230 --> 00:16:44,730
revision history and if anything looks

401
00:16:42,690 --> 00:16:49,470
like it's sort of high entropy let me

402
00:16:44,730 --> 00:16:52,110
know that way I can find sort of a lot

403
00:16:49,470 --> 00:16:54,120
of secrets but there'll be a lot of

404
00:16:52,110 --> 00:16:57,750
noise with it as well like URLs that

405
00:16:54,120 --> 00:17:00,570
have by entropy just large blobs of

406
00:16:57,750 --> 00:17:02,220
basics before how high entropy I put

407
00:17:00,570 --> 00:17:03,870
some restrictions on it like it has to

408
00:17:02,220 --> 00:17:07,050
match certain character sets and certain

409
00:17:03,870 --> 00:17:10,589
lengths and and it was effective it did

410
00:17:07,050 --> 00:17:12,990
find that Netflix AWS token that I

411
00:17:10,589 --> 00:17:15,990
mentioned before but one of the problems

412
00:17:12,990 --> 00:17:17,849
was it false-positive like crazy this is

413
00:17:15,990 --> 00:17:20,280
the exact same repo from Netflix and

414
00:17:17,849 --> 00:17:23,280
just a couple of lines down it falls

415
00:17:20,280 --> 00:17:26,220
positive on a URL because you are all

416
00:17:23,280 --> 00:17:28,560
had a bunch of entropy in it so this

417
00:17:26,220 --> 00:17:30,570
tool was really good for like pen tests

418
00:17:28,560 --> 00:17:32,730
and it was good if you wanted to do like

419
00:17:30,570 --> 00:17:36,179
a one-off open source review a piece of

420
00:17:32,730 --> 00:17:40,380
software great for bug bounties quite

421
00:17:36,180 --> 00:17:42,360
lucrative you can you know a bug bounty

422
00:17:40,380 --> 00:17:43,860
or can run this and go through all the

423
00:17:42,360 --> 00:17:45,560
false positives because they don't care

424
00:17:43,860 --> 00:17:48,090
they're just looking for the one payout

425
00:17:45,560 --> 00:17:50,428
but this is really bad for like

426
00:17:48,090 --> 00:17:52,260
devstack opps this this model doesn't

427
00:17:50,429 --> 00:17:54,059
really scale well if you were to deliver

428
00:17:52,260 --> 00:17:56,840
these results directly to developers

429
00:17:54,059 --> 00:17:58,918
every time they pushed a URL to their

430
00:17:56,840 --> 00:18:01,020
revision control they'd get an alert

431
00:17:58,919 --> 00:18:03,230
saying they pushed a secret and

432
00:18:01,020 --> 00:18:05,908
eventually they just start tuning it out

433
00:18:03,230 --> 00:18:08,820
so this model doesn't really scale that

434
00:18:05,909 --> 00:18:11,130
well and and that goes the same with a

435
00:18:08,820 --> 00:18:13,590
security team like if you have security

436
00:18:11,130 --> 00:18:15,299
alert every time this entropy detection

437
00:18:13,590 --> 00:18:17,699
happened on any source code anywhere in

438
00:18:15,299 --> 00:18:19,200
the company so they'll just start tuning

439
00:18:17,700 --> 00:18:21,120
it out because it's it's tons and tons

440
00:18:19,200 --> 00:18:23,240
of false positives so it's really good

441
00:18:21,120 --> 00:18:26,039
for like one offs for sensitive assets

442
00:18:23,240 --> 00:18:30,210
for bug bounties but not that great for

443
00:18:26,039 --> 00:18:32,070
like a company using its scale so I

444
00:18:30,210 --> 00:18:35,070
pivoted a little bit I did exactly what

445
00:18:32,070 --> 00:18:39,210
I didn't want to do and I wrote a bunch

446
00:18:35,070 --> 00:18:41,399
of really high signal basically regular

447
00:18:39,210 --> 00:18:45,690
expressions to specifically look for

448
00:18:41,399 --> 00:18:47,820
specific types of Secrets that way when

449
00:18:45,690 --> 00:18:49,559
those flagged we can suppress the

450
00:18:47,820 --> 00:18:51,899
entropy detection and only run the Reg

451
00:18:49,559 --> 00:18:53,639
X's and when those flagged we could be a

452
00:18:51,899 --> 00:18:55,918
lot more confident and giving these

453
00:18:53,640 --> 00:18:58,620
results directly to a developer or just

454
00:18:55,919 --> 00:19:01,260
again setting up a triage queue for

455
00:18:58,620 --> 00:19:04,020
security to go through and it wouldn't

456
00:19:01,260 --> 00:19:07,740
it wouldn't be quite as bad so you can

457
00:19:04,020 --> 00:19:11,370
see sort of a screenshot of the some reg

458
00:19:07,740 --> 00:19:13,679
X's up there the big downside to this

459
00:19:11,370 --> 00:19:15,209
though is like there's a ton of

460
00:19:13,679 --> 00:19:17,460
different types of tokens out there that

461
00:19:15,210 --> 00:19:19,289
this doesn't flag on like you can see

462
00:19:17,460 --> 00:19:21,980
the whole list of reg X is up there and

463
00:19:19,289 --> 00:19:25,320
I'm sure you can think of public cloud

464
00:19:21,980 --> 00:19:27,090
API keys that aren't on that list

465
00:19:25,320 --> 00:19:28,200
I do accept new pull requests but that

466
00:19:27,090 --> 00:19:31,168
list is going to continue to grow

467
00:19:28,200 --> 00:19:33,720
forever and and doing things this way

468
00:19:31,169 --> 00:19:36,110
will miss all of those tokens and

469
00:19:33,720 --> 00:19:39,419
another downside is it still does

470
00:19:36,110 --> 00:19:41,520
require some manual triage so after

471
00:19:39,419 --> 00:19:43,409
identifies an AWS token it doesn't know

472
00:19:41,520 --> 00:19:46,590
if it's live or not so somebody has to

473
00:19:43,409 --> 00:19:47,909
come in and figure that out but one of

474
00:19:46,590 --> 00:19:53,158
them one of the upsides are doing it

475
00:19:47,909 --> 00:19:56,250
this way is one of the upsides are doing

476
00:19:53,159 --> 00:19:58,440
it this way is it will in some cases

477
00:19:56,250 --> 00:19:59,490
detect low entropy secrets so for

478
00:19:58,440 --> 00:20:01,710
example I have a regex

479
00:19:59,490 --> 00:20:04,860
that I haven't pushed yet but I will

480
00:20:01,710 --> 00:20:06,570
the next couple days that identifies if

481
00:20:04,860 --> 00:20:12,689
somebody hard-coded a password into a

482
00:20:06,570 --> 00:20:14,460
URL like before the domain and that

483
00:20:12,690 --> 00:20:16,169
password can be super low entropy but

484
00:20:14,460 --> 00:20:21,659
the regex would pick up on in any way

485
00:20:16,169 --> 00:20:23,669
the entropy detection wouldn't so when I

486
00:20:21,659 --> 00:20:25,350
say hi signal this is sort of what I

487
00:20:23,669 --> 00:20:29,340
mean like when I first started on the

488
00:20:25,350 --> 00:20:32,219
left there is what a regex for at github

489
00:20:29,340 --> 00:20:36,090
access token used to look like basically

490
00:20:32,220 --> 00:20:40,140
if the string github followed by a 35 to

491
00:20:36,090 --> 00:20:42,689
40 character hex string showed up in a

492
00:20:40,140 --> 00:20:45,840
single line then I would have it flag

493
00:20:42,690 --> 00:20:49,649
and that false positive like crazy the

494
00:20:45,840 --> 00:20:52,740
reason why any github URL usually had a

495
00:20:49,649 --> 00:20:54,809
commits commit hash in the URL and that

496
00:20:52,740 --> 00:20:57,059
satisfies that regex that false positive

497
00:20:54,809 --> 00:20:58,950
a giant monolith of minified javascript

498
00:20:57,059 --> 00:21:01,200
code with false positive because

499
00:20:58,950 --> 00:21:03,000
somewhere in the monolith this two

500
00:21:01,200 --> 00:21:07,140
megabyte file is the string github and

501
00:21:03,000 --> 00:21:09,510
somewhere else is a hex string so I

502
00:21:07,140 --> 00:21:11,490
spent some time refining and tweaking

503
00:21:09,510 --> 00:21:13,320
these over time to make them more and

504
00:21:11,490 --> 00:21:15,360
more accurate so what I ended up for

505
00:21:13,320 --> 00:21:19,020
this particular one doing is if the

506
00:21:15,360 --> 00:21:24,240
string github shows up in the next 0 to

507
00:21:19,020 --> 00:21:27,299
30 characters if a the quote or a a

508
00:21:24,240 --> 00:21:29,000
whitespace shows up followed by the

509
00:21:27,299 --> 00:21:30,899
right character set in the right length

510
00:21:29,000 --> 00:21:34,649
terminated again by a quote or a

511
00:21:30,899 --> 00:21:36,149
whitespace then alert mean so I'm really

512
00:21:34,649 --> 00:21:37,709
doing the best I can here to make sure

513
00:21:36,149 --> 00:21:41,070
that the rules that I introduce here are

514
00:21:37,710 --> 00:21:42,840
as high signal as possible so that these

515
00:21:41,070 --> 00:21:45,678
can be given directly to developers and

516
00:21:42,840 --> 00:21:47,879
don't have amount of false positives so

517
00:21:45,679 --> 00:21:50,100
sort of when you hook all of that up

518
00:21:47,880 --> 00:21:51,929
this is sort of the model in my head of

519
00:21:50,100 --> 00:21:54,658
what that looks like and I've

520
00:21:51,929 --> 00:21:56,789
implemented this a couple of times you

521
00:21:54,659 --> 00:21:58,559
have some sort of hook that fires this

522
00:21:56,789 --> 00:22:00,000
could be a build pipeline could have

523
00:21:58,559 --> 00:22:02,309
Jenkins or something like that kick this

524
00:22:00,000 --> 00:22:05,520
off where every time I knew commit or

525
00:22:02,309 --> 00:22:07,289
build comes in truffle hog runs you give

526
00:22:05,520 --> 00:22:10,799
trouble all the flag to tell it run from

527
00:22:07,289 --> 00:22:12,658
this commit onward so you keep track of

528
00:22:10,799 --> 00:22:14,668
where you've already scanned you give it

529
00:22:12,659 --> 00:22:15,420
a new commit trouble halt going to scan

530
00:22:14,669 --> 00:22:17,340
that

531
00:22:15,420 --> 00:22:19,830
deliver the results somehow to someone

532
00:22:17,340 --> 00:22:21,209
that could be directly to a developer it

533
00:22:19,830 --> 00:22:23,129
could be to an SRE it could be to a

534
00:22:21,210 --> 00:22:24,960
security engineering then you have to

535
00:22:23,130 --> 00:22:27,180
triage him figure out what's live what's

536
00:22:24,960 --> 00:22:29,430
not deal with what false positives there

537
00:22:27,180 --> 00:22:34,440
are and then finally you got to

538
00:22:29,430 --> 00:22:36,390
remediate so when I say remediate it's

539
00:22:34,440 --> 00:22:38,760
kind of a pain in the butt to remediate

540
00:22:36,390 --> 00:22:41,040
but first you got to pull it out of

541
00:22:38,760 --> 00:22:43,350
source code use something like a big

542
00:22:41,040 --> 00:22:46,860
friendly repo cleaner to do that the bfg

543
00:22:43,350 --> 00:22:49,919
repo cleaner then you got to rotate the

544
00:22:46,860 --> 00:22:51,330
credential you got to keep track of

545
00:22:49,920 --> 00:22:53,640
which one's been rotating which ones

546
00:22:51,330 --> 00:22:55,649
haven't and you got to do that in a

547
00:22:53,640 --> 00:22:58,260
secure way so that's that's another sort

548
00:22:55,650 --> 00:23:00,390
of tricky nuance to this is like once

549
00:22:58,260 --> 00:23:01,560
you set all this automation up and

550
00:23:00,390 --> 00:23:04,710
you're identifying these credentials

551
00:23:01,560 --> 00:23:06,899
like it's a bit dodgy to have like a big

552
00:23:04,710 --> 00:23:08,540
repository of hey look here's exactly

553
00:23:06,900 --> 00:23:11,760
where all the clear text credentials are

554
00:23:08,540 --> 00:23:13,379
and so you have to be sort of clever

555
00:23:11,760 --> 00:23:15,890
about the way you do that you don't want

556
00:23:13,380 --> 00:23:18,060
to log the credentials for example

557
00:23:15,890 --> 00:23:19,800
because then you've got another

558
00:23:18,060 --> 00:23:21,870
repository of clear text credentials

559
00:23:19,800 --> 00:23:23,460
that you don't want so you have to be

560
00:23:21,870 --> 00:23:25,949
careful with the way you're storing them

561
00:23:23,460 --> 00:23:29,100
keeping track of that and then finally

562
00:23:25,950 --> 00:23:30,270
what I mentioned before all the folks

563
00:23:29,100 --> 00:23:32,219
have already moved forward and they're

564
00:23:30,270 --> 00:23:34,560
good histories so if you go back and you

565
00:23:32,220 --> 00:23:37,290
laser something out everybody has to do

566
00:23:34,560 --> 00:23:38,760
a forward force merge and deal with the

567
00:23:37,290 --> 00:23:43,770
annoying merge conflicts that come from

568
00:23:38,760 --> 00:23:47,010
that well if you remember back earlier

569
00:23:43,770 --> 00:23:50,180
like I mentioned most of what I'd be

570
00:23:47,010 --> 00:23:53,340
talking about would be focused on

571
00:23:50,180 --> 00:23:55,440
cleaning up revision history but there

572
00:23:53,340 --> 00:23:59,490
are a ton of other places that we keep

573
00:23:55,440 --> 00:24:02,370
our source code like I gave that big

574
00:23:59,490 --> 00:24:04,890
list and the second one on the list was

575
00:24:02,370 --> 00:24:08,520
package managers and if you remember

576
00:24:04,890 --> 00:24:10,740
what I said earlier package managers can

577
00:24:08,520 --> 00:24:13,710
be completely out of sync with github

578
00:24:10,740 --> 00:24:15,870
and the reason why is in the case of NPM

579
00:24:13,710 --> 00:24:17,430
and pie-pie the two that I spiked on and

580
00:24:15,870 --> 00:24:20,540
this is by no means a complete list of

581
00:24:17,430 --> 00:24:23,610
package managers that have this problem

582
00:24:20,540 --> 00:24:25,379
these package managers only look at the

583
00:24:23,610 --> 00:24:27,240
file system when you package to them

584
00:24:25,380 --> 00:24:28,770
they don't look at what's in git or

585
00:24:27,240 --> 00:24:31,559
what's in github

586
00:24:28,770 --> 00:24:33,929
so for example if you're an engineer and

587
00:24:31,559 --> 00:24:36,570
you're working on a project and you have

588
00:24:33,929 --> 00:24:38,610
some testing script or some environment

589
00:24:36,570 --> 00:24:40,800
variable sourcing script in the

590
00:24:38,610 --> 00:24:43,080
directory of your project you don't

591
00:24:40,800 --> 00:24:45,360
commit it to github when you run your

592
00:24:43,080 --> 00:24:47,970
let me package this up to pipe I script

593
00:24:45,360 --> 00:24:50,219
there's a good chance that those scripts

594
00:24:47,970 --> 00:24:53,220
will end up in pipe I but they won't end

595
00:24:50,220 --> 00:24:55,860
up in github and when again when the

596
00:24:53,220 --> 00:24:58,800
reviewer does the review whether that be

597
00:24:55,860 --> 00:25:00,659
an open source review or just an

598
00:24:58,800 --> 00:25:03,928
internal security audit or maybe just a

599
00:25:00,660 --> 00:25:05,940
code review people are checking what's

600
00:25:03,929 --> 00:25:09,120
in github nobody's pulling down the

601
00:25:05,940 --> 00:25:11,309
package and untiring it and reading that

602
00:25:09,120 --> 00:25:13,169
source code you're already reading

603
00:25:11,309 --> 00:25:16,620
what's in github nobody wants to double

604
00:25:13,170 --> 00:25:19,530
that effort and these packages are also

605
00:25:16,620 --> 00:25:21,178
versioned just like revision control we

606
00:25:19,530 --> 00:25:23,340
have a long history of the same piece of

607
00:25:21,179 --> 00:25:26,100
code that's pushed up again and again

608
00:25:23,340 --> 00:25:27,510
again iterated on all of those old

609
00:25:26,100 --> 00:25:29,610
versions could potentially have these

610
00:25:27,510 --> 00:25:31,170
problems you may have an environment

611
00:25:29,610 --> 00:25:34,889
variable sourcing script that was

612
00:25:31,170 --> 00:25:37,320
committed in one of the old versions and

613
00:25:34,890 --> 00:25:38,880
again like nobody has the time to go

614
00:25:37,320 --> 00:25:40,559
through all the same duplicate

615
00:25:38,880 --> 00:25:43,140
incarnations in the same code looking

616
00:25:40,559 --> 00:25:46,020
for that environment variable script so

617
00:25:43,140 --> 00:25:49,950
recently I spiked on a way to go through

618
00:25:46,020 --> 00:25:53,010
and scan those in the same capacity but

619
00:25:49,950 --> 00:25:55,440
what I found was basically he published

620
00:25:53,010 --> 00:25:56,820
an NPM or pi PI and anywhere in the

621
00:25:55,440 --> 00:26:00,450
description of your project you have a

622
00:25:56,820 --> 00:26:02,040
string AWS there's about a 2% chance of

623
00:26:00,450 --> 00:26:05,490
that package having a live AWS

624
00:26:02,040 --> 00:26:07,470
credential now when I first did this I

625
00:26:05,490 --> 00:26:10,050
notified the folks where I could find

626
00:26:07,470 --> 00:26:12,090
the credential but that was the criteria

627
00:26:10,050 --> 00:26:14,070
I was using to figure out which packages

628
00:26:12,090 --> 00:26:15,570
to scan so I'm sure there's a ton of

629
00:26:14,070 --> 00:26:17,730
other projects out there that have live

630
00:26:15,570 --> 00:26:19,080
credentials and I'm sure since that time

631
00:26:17,730 --> 00:26:22,620
more folks have committed live

632
00:26:19,080 --> 00:26:25,110
credentials I mentioned some of the

633
00:26:22,620 --> 00:26:26,850
reasons I'll say him again so it could

634
00:26:25,110 --> 00:26:29,340
be environment variables you could have

635
00:26:26,850 --> 00:26:31,350
test scripts so maybe you've got some

636
00:26:29,340 --> 00:26:32,939
tests that you haven't staged yet maybe

637
00:26:31,350 --> 00:26:34,469
it's spera mental code like I'm

638
00:26:32,940 --> 00:26:36,120
personally guilty of this when I'm

639
00:26:34,470 --> 00:26:36,630
iterating before I commit to version

640
00:26:36,120 --> 00:26:38,399
control

641
00:26:36,630 --> 00:26:40,050
I'll just inline the credential just

642
00:26:38,400 --> 00:26:42,110
because I want to test something first

643
00:26:40,050 --> 00:26:45,620
when first trying out an API I want to

644
00:26:42,110 --> 00:26:47,299
how it works that code if it's in an

645
00:26:45,620 --> 00:26:49,729
active project where you're committing

646
00:26:47,299 --> 00:26:58,580
stuff could end up getting zipped up and

647
00:26:49,730 --> 00:27:00,980
sent to NPM / so not by any means saying

648
00:26:58,580 --> 00:27:04,340
that this was a good name for it but I

649
00:27:00,980 --> 00:27:08,690
have a new script called Santa Hawk that

650
00:27:04,340 --> 00:27:10,850
basically is designed to do just that

651
00:27:08,690 --> 00:27:12,860
I guess my thinking was like you're

652
00:27:10,850 --> 00:27:14,449
you're getting like goodies out of a

653
00:27:12,860 --> 00:27:17,240
package and that's that's kind of what

654
00:27:14,450 --> 00:27:21,429
Santa does and I kept the hog for

655
00:27:17,240 --> 00:27:23,660
consistency but basically name a site

656
00:27:21,429 --> 00:27:27,200
goes through all the old versions of the

657
00:27:23,660 --> 00:27:30,770
package in NPM and pie-pie and it scans

658
00:27:27,200 --> 00:27:32,090
for the same exact Reg X's and it's got

659
00:27:30,770 --> 00:27:34,309
the high entropy flag as well if you

660
00:27:32,090 --> 00:27:37,250
want to do the entropy detection it's

661
00:27:34,309 --> 00:27:42,320
also open source and it's available and

662
00:27:37,250 --> 00:27:44,179
I github so here's an example of its

663
00:27:42,320 --> 00:27:47,960
output it doesn't quite look as pretty

664
00:27:44,179 --> 00:27:51,350
as the truffle hog output but here I'm

665
00:27:47,960 --> 00:27:53,090
running it on one of overs packages T

666
00:27:51,350 --> 00:27:54,740
Channel and you can see it flagged a

667
00:27:53,090 --> 00:27:56,480
couple of times it flagged on RSA

668
00:27:54,740 --> 00:27:59,780
private keys if flagged on AWS

669
00:27:56,480 --> 00:28:01,160
credential almost one package but if you

670
00:27:59,780 --> 00:28:03,440
look at it a little bit more carefully

671
00:28:01,160 --> 00:28:05,540
you'll notice that these things that

672
00:28:03,440 --> 00:28:07,760
flagged were in a directory called node

673
00:28:05,540 --> 00:28:11,149
modules and if you know anything about

674
00:28:07,760 --> 00:28:13,160
NPM node modules is basically the

675
00:28:11,150 --> 00:28:16,360
directory where all of your dependencies

676
00:28:13,160 --> 00:28:18,049
get stored so T channels dependencies

677
00:28:16,360 --> 00:28:22,189
basically live in the node modules

678
00:28:18,049 --> 00:28:23,900
directory and in this case what T

679
00:28:22,190 --> 00:28:27,650
channel did was they took their node

680
00:28:23,900 --> 00:28:31,760
modules directory and they ended up

681
00:28:27,650 --> 00:28:33,700
pushing that to to version control you

682
00:28:31,760 --> 00:28:36,169
can kind of think of that as like a

683
00:28:33,700 --> 00:28:38,390
statically compiled binary so if most

684
00:28:36,169 --> 00:28:40,309
people don't do this it was probably

685
00:28:38,390 --> 00:28:43,910
done by accident and it was only in one

686
00:28:40,309 --> 00:28:45,500
of the versions of T Channel but what

687
00:28:43,910 --> 00:28:46,850
they did was they introduced a

688
00:28:45,500 --> 00:28:48,080
dependency of a dependency of a

689
00:28:46,850 --> 00:28:50,809
dependency of a dependency of a

690
00:28:48,080 --> 00:28:53,439
dependency that ultimately all the way

691
00:28:50,809 --> 00:28:55,928
down that chain that dependency of

692
00:28:53,440 --> 00:28:59,000
somebody else way outside it uber

693
00:28:55,929 --> 00:29:01,039
committed an RSA private key and an AWS

694
00:28:59,000 --> 00:29:03,799
credential so uber took that other

695
00:29:01,039 --> 00:29:07,100
person's secret package it into their

696
00:29:03,799 --> 00:29:10,990
own package and then shipped it to T

697
00:29:07,100 --> 00:29:13,340
channel so if you were to scan ubers

698
00:29:10,990 --> 00:29:14,870
packages you'd find credentials that

699
00:29:13,340 --> 00:29:16,490
actually have nothing to do with uber

700
00:29:14,870 --> 00:29:18,320
and we're just accidentally included

701
00:29:16,490 --> 00:29:21,950
because they included all of their sub

702
00:29:18,320 --> 00:29:25,189
dependencies so if we go back to our

703
00:29:21,950 --> 00:29:27,620
diagram here basically we have the same

704
00:29:25,190 --> 00:29:30,110
triage and remediation step we're just

705
00:29:27,620 --> 00:29:34,039
adding an additional hook from when we

706
00:29:30,110 --> 00:29:38,479
packaged NPM and pipe I to run again the

707
00:29:34,039 --> 00:29:41,330
santa hog tool and this is what the New

708
00:29:38,480 --> 00:29:43,460
Revised about pipeline could look like

709
00:29:41,330 --> 00:29:49,280
if you were scanning those two sources

710
00:29:43,460 --> 00:29:52,039
of code so because at this point I have

711
00:29:49,280 --> 00:29:54,980
two projects that are relying on these

712
00:29:52,039 --> 00:29:57,169
regular expressions and at this point

713
00:29:54,980 --> 00:29:59,690
like a bunch of other projects started

714
00:29:57,169 --> 00:30:03,080
doing the same thing so for example

715
00:29:59,690 --> 00:30:05,179
somebody wrote a go version of truffle

716
00:30:03,080 --> 00:30:06,799
hog called get leaks and they had

717
00:30:05,179 --> 00:30:09,919
basically copy pasted the regular

718
00:30:06,799 --> 00:30:12,408
expressions over I just decided to pull

719
00:30:09,919 --> 00:30:13,700
the Reg X's out and put there and put

720
00:30:12,409 --> 00:30:15,169
them in their own package that way the

721
00:30:13,700 --> 00:30:16,880
whole community can just point to one

722
00:30:15,169 --> 00:30:20,620
common place we can all write the same

723
00:30:16,880 --> 00:30:23,419
rules some other examples of projects

724
00:30:20,620 --> 00:30:26,090
they're doing similar things Yelp detect

725
00:30:23,419 --> 00:30:27,740
secrets sort of the same deal they wrote

726
00:30:26,090 --> 00:30:29,600
like an enterprise e-version drop a hog

727
00:30:27,740 --> 00:30:30,980
and then lift it to the same thing as

728
00:30:29,600 --> 00:30:33,080
well they fork truffle hog and they have

729
00:30:30,980 --> 00:30:35,720
sort of some enterprise features and

730
00:30:33,080 --> 00:30:38,168
they've also submitted back a bunch of

731
00:30:35,720 --> 00:30:40,429
features to my version of truffle fog

732
00:30:38,169 --> 00:30:41,809
but I pulled these rejections out just

733
00:30:40,429 --> 00:30:44,929
so all these projects can just point to

734
00:30:41,809 --> 00:30:46,639
one unified source of truth for the for

735
00:30:44,929 --> 00:30:50,840
the rule for the rules and then they can

736
00:30:46,640 --> 00:30:52,789
use their own engines so one thing I

737
00:30:50,840 --> 00:30:56,480
want to harken back to for a second is I

738
00:30:52,789 --> 00:30:58,820
mentioned that you have to have this

739
00:30:56,480 --> 00:31:00,049
like manual triage phase where someone

740
00:30:58,820 --> 00:31:03,950
figures out whether or not this

741
00:31:00,049 --> 00:31:07,610
credential is live truffle hog is at its

742
00:31:03,950 --> 00:31:10,399
core a static analysis tool but when you

743
00:31:07,610 --> 00:31:12,408
combine static analysis with dynamic and

744
00:31:10,399 --> 00:31:16,459
you can potentially remove this triage

745
00:31:12,409 --> 00:31:19,070
face and you can automate the testing of

746
00:31:16,460 --> 00:31:21,289
these credentials and just create a

747
00:31:19,070 --> 00:31:24,399
system that only outputs true positives

748
00:31:21,289 --> 00:31:26,869
so basically you could think of that as

749
00:31:24,399 --> 00:31:28,758
truffle hog runs it finds an AWS

750
00:31:26,869 --> 00:31:30,918
credential then you test to see whether

751
00:31:28,759 --> 00:31:32,960
or not that credential is live all

752
00:31:30,919 --> 00:31:36,830
automatically and then if it is live

753
00:31:32,960 --> 00:31:39,980
then you can get notified for it and so

754
00:31:36,830 --> 00:31:43,039
that's really easy to do for public a

755
00:31:39,980 --> 00:31:44,629
public cloud so you can do it for an AWS

756
00:31:43,039 --> 00:31:46,789
credential it's a little bit harder to

757
00:31:44,629 --> 00:31:48,498
do for say an RSA private key

758
00:31:46,789 --> 00:31:50,090
you'd have to again do something like I

759
00:31:48,499 --> 00:31:51,649
mentioned before aggregate a whole bunch

760
00:31:50,090 --> 00:31:53,689
of public keys and cross-reference it

761
00:31:51,649 --> 00:31:56,418
and stuff like that so this can work in

762
00:31:53,690 --> 00:31:58,759
some search situations other situations

763
00:31:56,419 --> 00:32:00,769
it doesn't work as well this is sort of

764
00:31:58,759 --> 00:32:02,720
what that can look like this is just a

765
00:32:00,769 --> 00:32:05,480
really simple Python script I wrote that

766
00:32:02,720 --> 00:32:08,899
takes an ATO AWS key the calls get

767
00:32:05,480 --> 00:32:11,419
caller identity on it that's a an API

768
00:32:08,899 --> 00:32:14,119
endpoint that any AWS credential with

769
00:32:11,419 --> 00:32:16,789
any permissions can always call if we

770
00:32:14,119 --> 00:32:20,869
get an exception we know the key is not

771
00:32:16,789 --> 00:32:22,220
live and if the key if the key

772
00:32:20,869 --> 00:32:24,289
successfully makes the call then we know

773
00:32:22,220 --> 00:32:25,549
the credential is live and now we can

774
00:32:24,289 --> 00:32:28,070
pretty much automate the whole process

775
00:32:25,549 --> 00:32:30,970
when it comes to AWS keys in particular

776
00:32:28,070 --> 00:32:34,700
any time a developer commits an AWS key

777
00:32:30,970 --> 00:32:36,669
we'll know whether or not the credential

778
00:32:34,700 --> 00:32:38,419
is live and we can automatically start

779
00:32:36,669 --> 00:32:40,039
remediation without having to deal with

780
00:32:38,419 --> 00:32:45,139
any kind of false positive in any kind

781
00:32:40,039 --> 00:32:48,279
of triage so that that sounds good but

782
00:32:45,139 --> 00:32:50,928
that comes with a huge like stash tricks

783
00:32:48,279 --> 00:32:53,960
so I'm not I'm not a lawyer I'm not

784
00:32:50,929 --> 00:32:57,649
going to tell you any kind of legal

785
00:32:53,960 --> 00:33:00,980
advice but if you remember back to the

786
00:32:57,649 --> 00:33:03,080
Beryl that wasn't ubers credential that

787
00:33:00,980 --> 00:33:04,789
was some stranger's credential and if

788
00:33:03,080 --> 00:33:06,109
you start taking those and offing with

789
00:33:04,789 --> 00:33:08,658
them

790
00:33:06,109 --> 00:33:10,189
you're probably violating the Computer

791
00:33:08,659 --> 00:33:11,450
Fraud and Abuse Act not a lawyer not

792
00:33:10,190 --> 00:33:13,700
going to tell you whether it is or not

793
00:33:11,450 --> 00:33:15,830
but you're taking somebody else's cred

794
00:33:13,700 --> 00:33:17,269
and signing into something without them

795
00:33:15,830 --> 00:33:21,049
giving you permission to do it with that

796
00:33:17,269 --> 00:33:22,309
cred sounds like a violation the CFAA so

797
00:33:21,049 --> 00:33:23,810
you have to be really careful with that

798
00:33:22,309 --> 00:33:25,820
and you probably shouldn't do this

799
00:33:23,810 --> 00:33:29,450
bug bounties either again for the same

800
00:33:25,820 --> 00:33:32,419
reason companies typically will say if

801
00:33:29,450 --> 00:33:38,140
you find a credential stop testing there

802
00:33:32,420 --> 00:33:40,250
report it to us don't test it and that

803
00:33:38,140 --> 00:33:41,990
you know if you're a setup this

804
00:33:40,250 --> 00:33:44,360
automated process of just automatically

805
00:33:41,990 --> 00:33:46,550
logging into services you'd probably

806
00:33:44,360 --> 00:33:50,120
violate see if they probably violate the

807
00:33:46,550 --> 00:33:53,210
bug bounty terms services so just be

808
00:33:50,120 --> 00:33:55,189
careful with systems like that I say

809
00:33:53,210 --> 00:33:56,690
that knowing that you know the benefit

810
00:33:55,190 --> 00:33:59,980
that you get from this is probably worth

811
00:33:56,690 --> 00:34:02,480
the accidental CFA a violation but I

812
00:33:59,980 --> 00:34:06,350
guess that's something to be cognizant

813
00:34:02,480 --> 00:34:09,020
of nonetheless and then as I mentioned

814
00:34:06,350 --> 00:34:11,929
before source code lives in many places

815
00:34:09,020 --> 00:34:16,520
and I've only spiked on a very small

816
00:34:11,929 --> 00:34:18,290
portion of those places some other folks

817
00:34:16,520 --> 00:34:20,509
wrote this tool that basically does the

818
00:34:18,290 --> 00:34:22,699
same thing for mobile apps you give it

819
00:34:20,510 --> 00:34:26,060
an apk name and it will pull down that

820
00:34:22,699 --> 00:34:28,580
mobile app it'll extract the apk it'll D

821
00:34:26,060 --> 00:34:32,389
compile it and it'll look for secrets in

822
00:34:28,580 --> 00:34:35,330
the apk so this tool is great and I've

823
00:34:32,389 --> 00:34:36,529
definitely used it before but just think

824
00:34:35,330 --> 00:34:41,420
of all the other places that we have

825
00:34:36,530 --> 00:34:43,790
source code Google Drive email wherever

826
00:34:41,420 --> 00:34:46,130
else like these are all potentially

827
00:34:43,790 --> 00:34:50,840
future projections forward of this

828
00:34:46,130 --> 00:34:53,030
project or others similar so you know

829
00:34:50,840 --> 00:34:54,380
that leads right into this point like I

830
00:34:53,030 --> 00:34:55,940
could use the community help for the

831
00:34:54,380 --> 00:34:57,440
rest of that think of all the package

832
00:34:55,940 --> 00:34:59,060
managers out there if only spiked on to

833
00:34:57,440 --> 00:35:00,650
and of all the places source to go we

834
00:34:59,060 --> 00:35:02,180
could live you know if all those bullet

835
00:35:00,650 --> 00:35:05,270
points I had I only looked at two of

836
00:35:02,180 --> 00:35:09,620
those I could really use help building

837
00:35:05,270 --> 00:35:11,450
this out more I do except also pull

838
00:35:09,620 --> 00:35:13,310
requests for new rules provided that

839
00:35:11,450 --> 00:35:14,540
they're high signal enough and I've seen

840
00:35:13,310 --> 00:35:19,880
contributions from companies like

841
00:35:14,540 --> 00:35:21,770
Netflix Microsoft lyft and others so

842
00:35:19,880 --> 00:35:24,950
it's it's all available in my github and

843
00:35:21,770 --> 00:35:26,480
I encourage community support and the

844
00:35:24,950 --> 00:35:28,700
regular expressions are available for

845
00:35:26,480 --> 00:35:33,560
other other related and tangential

846
00:35:28,700 --> 00:35:36,970
projects these are the resources to the

847
00:35:33,560 --> 00:35:36,970
things that I've talked about so far

848
00:35:37,040 --> 00:35:43,790
by all means check them out take a

849
00:35:39,020 --> 00:35:47,000
picture and that's pretty much all I

850
00:35:43,790 --> 00:35:48,140
have for you so I guess I have another

851
00:35:47,000 --> 00:35:52,370
couple of minutes if I have any

852
00:35:48,140 --> 00:35:54,700
questions so there's a question in the

853
00:35:52,370 --> 00:35:54,700
yes

854
00:36:03,790 --> 00:36:07,849
[Music]

855
00:36:05,500 --> 00:36:10,400
yes I had a little bit of hard time

856
00:36:07,849 --> 00:36:12,970
hearing the question I heard plans to

857
00:36:10,400 --> 00:36:12,970
integrate with

858
00:36:36,930 --> 00:36:41,710
carrots of Coca beautiful right yeah

859
00:36:39,670 --> 00:36:45,070
yeah so the question is basically like

860
00:36:41,710 --> 00:36:46,960
are there plans to take chocolate off

861
00:36:45,070 --> 00:36:50,920
and build it into the existing code

862
00:36:46,960 --> 00:36:52,360
which wasn't exactly a scary I don't

863
00:36:50,920 --> 00:36:54,670
have any direct plans to do that but

864
00:36:52,360 --> 00:36:56,650
that being said it sounds like a good

865
00:36:54,670 --> 00:36:58,450
idea and I'd be happy to work with folks

866
00:36:56,650 --> 00:37:01,869
who who would like to integrate it with

867
00:36:58,450 --> 00:37:04,270
other solutions it is important as a

868
00:37:01,869 --> 00:37:07,060
library and so if you're already in

869
00:37:04,270 --> 00:37:09,430
Python it's relatively easy to do but

870
00:37:07,060 --> 00:37:12,540
otherwise feel free to chat to me after

871
00:37:09,430 --> 00:37:12,540
we can figure out a way to do it

872
00:37:18,920 --> 00:37:24,449
yeah so the question is do you have any

873
00:37:20,910 --> 00:37:27,209
benchmarks for how fast it is I don't

874
00:37:24,449 --> 00:37:28,499
but I know that it's changed a lot and a

875
00:37:27,209 --> 00:37:30,868
lot of that has come from the community

876
00:37:28,499 --> 00:37:32,488
who have added performance increases so

877
00:37:30,869 --> 00:37:34,650
when I first rolled this out as its

878
00:37:32,489 --> 00:37:36,890
first proof of concept it used to go

879
00:37:34,650 --> 00:37:39,059
through each branch and scan each commit

880
00:37:36,890 --> 00:37:40,410
even if the commits were the same and

881
00:37:39,059 --> 00:37:42,239
the branches so even if the hashes and

882
00:37:40,410 --> 00:37:43,949
everything exactly matched up which was

883
00:37:42,239 --> 00:37:45,589
a huge waste of time so much in the

884
00:37:43,949 --> 00:37:47,999
community pointed that out and then

885
00:37:45,589 --> 00:37:49,709
added some extra functionality so that

886
00:37:47,999 --> 00:37:52,049
it wouldn't scan those commits and the

887
00:37:49,709 --> 00:37:53,279
time dropped dramatically and then there

888
00:37:52,049 --> 00:37:55,739
were a couple other optimizations there

889
00:37:53,279 --> 00:37:57,179
at it as well so it went from like if

890
00:37:55,739 --> 00:37:59,279
you were to run this on the Linux kernel

891
00:37:57,179 --> 00:38:02,069
originally it would probably take a week

892
00:37:59,279 --> 00:38:03,569
or more finish down to if you were to

893
00:38:02,069 --> 00:38:06,599
run this on the Linux kernel today it

894
00:38:03,569 --> 00:38:10,259
would probably take on the order of like

895
00:38:06,599 --> 00:38:11,789
maybe hours and that's kind of an

896
00:38:10,259 --> 00:38:14,329
extreme example most projects that'll

897
00:38:11,789 --> 00:38:17,719
finish in you know seconds to minutes

898
00:38:14,329 --> 00:38:17,719
yes upfront

899
00:38:23,230 --> 00:38:32,170
for filtering down from that changing

900
00:38:25,810 --> 00:38:35,109
the regex positive entropy because a lot

901
00:38:32,170 --> 00:38:37,119
of hashes in there we go yeah totally so

902
00:38:35,109 --> 00:38:39,490
the question was basically like is there

903
00:38:37,119 --> 00:38:43,980
any way I think to see whether or not it

904
00:38:39,490 --> 00:38:43,979
satisfies both entropy and regex

905
00:38:52,020 --> 00:38:56,259
yes the question question I think was

906
00:38:54,310 --> 00:38:58,390
first run entropy and then from the

907
00:38:56,260 --> 00:39:00,690
results of entropy run the regex tools

908
00:38:58,390 --> 00:39:03,879
is there any functionality for that

909
00:39:00,690 --> 00:39:05,920
there isn't a super native functionality

910
00:39:03,880 --> 00:39:08,290
for that but like I mentioned before you

911
00:39:05,920 --> 00:39:10,720
can just import the library and then run

912
00:39:08,290 --> 00:39:13,180
it twice in that order and and that

913
00:39:10,720 --> 00:39:16,089
should be relatively easy to do happy to

914
00:39:13,180 --> 00:39:19,509
help you out with that if it's something

915
00:39:16,089 --> 00:39:26,140
you want to pursue further any other

916
00:39:19,510 --> 00:39:28,089
questions yes yes and questions what's

917
00:39:26,140 --> 00:39:29,710
the format of the rules it's just it's

918
00:39:28,089 --> 00:39:32,380
currently JSON a lot of people yell at

919
00:39:29,710 --> 00:39:34,359
me and tell me it should be yellow but I

920
00:39:32,380 --> 00:39:37,660
do in JSON because I really don't like a

921
00:39:34,359 --> 00:39:40,450
multi serialization bugs so it's just a

922
00:39:37,660 --> 00:39:43,509
JSON key-value pair of Keats a regular

923
00:39:40,450 --> 00:39:46,290
expression yeah

924
00:39:43,510 --> 00:39:46,290
other questions

925
00:39:48,100 --> 00:40:00,779
cool well thanks for having me everyone

926
00:39:51,600 --> 00:40:00,779
[Applause]

