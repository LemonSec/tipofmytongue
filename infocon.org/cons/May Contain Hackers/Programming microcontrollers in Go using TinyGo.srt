1
00:00:01,280 --> 00:00:12,559
[Music]

2
00:00:15,280 --> 00:00:17,039
hello everybody

3
00:00:17,039 --> 00:00:18,240
um

4
00:00:18,240 --> 00:00:20,720
thank you for the introduction

5
00:00:20,720 --> 00:00:23,359
um i'm arca i'm

6
00:00:23,359 --> 00:00:25,599
i hear echo i'm going to talk about

7
00:00:25,599 --> 00:00:27,840
tarnico which is a

8
00:00:27,840 --> 00:00:30,400
new go compiler for the

9
00:00:30,400 --> 00:00:31,439
for

10
00:00:31,439 --> 00:00:35,440
embedded systems and web assembly

11
00:00:37,680 --> 00:00:40,640
i started the project because the main

12
00:00:40,640 --> 00:00:42,399
go compiler wasn't

13
00:00:42,399 --> 00:00:45,360
able to do this in a good way

14
00:00:45,360 --> 00:00:47,680
um

15
00:00:48,079 --> 00:00:48,879
but

16
00:00:48,879 --> 00:00:52,079
i'll show a demo first

17
00:00:52,079 --> 00:00:53,840
so

18
00:00:53,840 --> 00:00:56,079
let's

19
00:00:56,840 --> 00:01:00,000
see this is the

20
00:01:00,000 --> 00:01:03,039
may recognize this

21
00:01:03,039 --> 00:01:04,000
um

22
00:01:04,000 --> 00:01:05,840
this this is a

23
00:01:05,840 --> 00:01:06,880
basic

24
00:01:06,880 --> 00:01:10,400
this is a small blinky example like you

25
00:01:10,400 --> 00:01:13,280
would use on arduino for example

26
00:01:13,280 --> 00:01:15,200
even if you don't know go you probably

27
00:01:15,200 --> 00:01:18,560
recognize how it works it's

28
00:01:18,560 --> 00:01:20,400
figures and led and then in the loop it

29
00:01:20,400 --> 00:01:23,119
turns it on and off

30
00:01:23,119 --> 00:01:24,960
and

31
00:01:24,960 --> 00:01:27,040
i can

32
00:01:27,040 --> 00:01:29,040
run wait

33
00:01:29,040 --> 00:01:32,079
flash it to my controller

34
00:01:32,079 --> 00:01:34,240
using

35
00:01:34,240 --> 00:01:36,960
this command

36
00:01:38,079 --> 00:01:42,079
it's compiling and flashing

37
00:01:44,159 --> 00:01:47,360
and probably not visible from behind but

38
00:01:47,360 --> 00:01:48,560
there's a

39
00:01:48,560 --> 00:01:50,640
this is the led blinking and it this is

40
00:01:50,640 --> 00:01:53,280
written using go

41
00:01:53,280 --> 00:01:56,960
so i think that's pretty cool

42
00:01:59,600 --> 00:02:00,960
however

43
00:02:00,960 --> 00:02:03,520
so this is what arduino does as well

44
00:02:03,520 --> 00:02:05,280
basically but

45
00:02:05,280 --> 00:02:08,878
um i think we can go even further

46
00:02:08,878 --> 00:02:11,038
by

47
00:02:11,038 --> 00:02:14,080
simulating this board

48
00:02:14,080 --> 00:02:16,879
this is the same program

49
00:02:16,879 --> 00:02:20,800
running inside the rde

50
00:02:20,800 --> 00:02:22,879
and you can see the same led blinking

51
00:02:22,879 --> 00:02:24,239
here

52
00:02:24,239 --> 00:02:26,560
and this is especially useful for

53
00:02:26,560 --> 00:02:28,400
small modifications to see what happens

54
00:02:28,400 --> 00:02:29,520
for example

55
00:02:29,520 --> 00:02:31,200
my trying to

56
00:02:31,200 --> 00:02:33,599
blink a little bit faster

57
00:02:33,599 --> 00:02:37,238
this just works

58
00:02:39,360 --> 00:02:41,599
i won't go into detail how this exactly

59
00:02:41,599 --> 00:02:42,800
works

60
00:02:42,800 --> 00:02:44,560
but basically

61
00:02:44,560 --> 00:02:46,800
it compiles the

62
00:02:46,800 --> 00:02:48,640
same program

63
00:02:48,640 --> 00:02:49,519
to

64
00:02:49,519 --> 00:02:51,200
webassembly instead of to a native

65
00:02:51,200 --> 00:02:52,879
binary

66
00:02:52,879 --> 00:02:54,879
uh but it uses the same hardware

67
00:02:54,879 --> 00:02:56,239
abstraction layer

68
00:02:56,239 --> 00:02:57,760
so

69
00:02:57,760 --> 00:02:59,920
um

70
00:02:59,920 --> 00:03:02,080
the the backend

71
00:03:02,080 --> 00:03:04,080
so to say of the hardware extraction

72
00:03:04,080 --> 00:03:04,959
layer

73
00:03:04,959 --> 00:03:06,959
is

74
00:03:06,959 --> 00:03:08,239
is

75
00:03:08,239 --> 00:03:09,920
talks to the

76
00:03:09,920 --> 00:03:13,599
javascript in the simulator

77
00:03:13,599 --> 00:03:15,760
but it's staying the same

78
00:03:15,760 --> 00:03:18,640
layer so the machine package here just

79
00:03:18,640 --> 00:03:20,879
talks to webassembly instead

80
00:03:20,879 --> 00:03:23,280
to the javascript instead of to the real

81
00:03:23,280 --> 00:03:25,760
hardware

82
00:03:26,239 --> 00:03:29,360
and i think this can be very productive

83
00:03:29,360 --> 00:03:33,040
a product product productive way to

84
00:03:33,040 --> 00:03:35,040
write software

85
00:03:35,040 --> 00:03:37,760
so for example here i have a slightly

86
00:03:37,760 --> 00:03:40,319
more complicated example

87
00:03:40,319 --> 00:03:41,519
and

88
00:03:41,519 --> 00:03:42,720
i

89
00:03:42,720 --> 00:03:44,720
wrote this entirely

90
00:03:44,720 --> 00:03:47,680
in the simulator

91
00:03:47,680 --> 00:03:51,120
and it's visible here

92
00:03:51,120 --> 00:03:53,519
just adjusting the brightness and the

93
00:03:53,519 --> 00:03:56,480
color speed etc all in the simulator

94
00:03:56,480 --> 00:03:57,599
and when i

95
00:03:57,599 --> 00:04:03,040
run it on the first on the so this is

96
00:04:03,040 --> 00:04:05,200
on the simulator and this is how i

97
00:04:05,200 --> 00:04:07,840
run it on the

98
00:04:07,840 --> 00:04:10,720
board itself

99
00:04:11,280 --> 00:04:14,680
it's compiling

100
00:04:16,639 --> 00:04:18,720
and here you see the same program

101
00:04:18,720 --> 00:04:20,478
running

102
00:04:20,478 --> 00:04:21,279
in

103
00:04:21,279 --> 00:04:23,680
sorry oh there you go

104
00:04:23,680 --> 00:04:25,840
i think this is visible because the leds

105
00:04:25,840 --> 00:04:28,160
are pretty bright but this is basically

106
00:04:28,160 --> 00:04:29,919
the same program and i

107
00:04:29,919 --> 00:04:31,759
well i discovered a bug in the simulator

108
00:04:31,759 --> 00:04:35,840
but otherwise it worked on the first try

109
00:04:36,240 --> 00:04:38,479
so

110
00:04:38,479 --> 00:04:41,120
i think that's pretty cool

111
00:04:41,120 --> 00:04:43,680
um

112
00:04:43,680 --> 00:04:46,560
let's see that's a demo

113
00:04:46,560 --> 00:04:48,320
so

114
00:04:48,320 --> 00:04:50,639
if you don't know go

115
00:04:50,639 --> 00:04:53,759
it's a programming language

116
00:04:53,759 --> 00:04:55,360
designed by google

117
00:04:55,360 --> 00:04:58,160
about 12 years ago

118
00:04:58,160 --> 00:05:00,320
which is actually pretty pretty young

119
00:05:00,320 --> 00:05:03,120
for a programming language spartan is 30

120
00:05:03,120 --> 00:05:04,960
years old and

121
00:05:04,960 --> 00:05:08,800
c is probably older than most of you

122
00:05:08,800 --> 00:05:11,520
so it's pretty young

123
00:05:11,520 --> 00:05:13,520
and google designed it for to solve

124
00:05:13,520 --> 00:05:15,600
their problems so

125
00:05:15,600 --> 00:05:19,440
it was intended for large servers

126
00:05:19,440 --> 00:05:21,680
um

127
00:05:21,680 --> 00:05:23,600
with many cores

128
00:05:23,600 --> 00:05:25,600
so it was

129
00:05:25,600 --> 00:05:29,280
entirely not designed to do this

130
00:05:30,479 --> 00:05:32,800
but i like the language it's

131
00:05:32,800 --> 00:05:35,120
quite simple to learn

132
00:05:35,120 --> 00:05:37,039
and

133
00:05:37,039 --> 00:05:38,639
um

134
00:05:38,639 --> 00:05:40,880
yeah

135
00:05:41,520 --> 00:05:45,039
i started getting into

136
00:05:45,039 --> 00:05:47,520
embedded development myself

137
00:05:47,520 --> 00:05:51,280
via arduino like most people probably

138
00:05:51,280 --> 00:05:53,600
and i really liked being able to control

139
00:05:53,600 --> 00:05:55,600
hardware because

140
00:05:55,600 --> 00:05:57,520
electronics was some hobby

141
00:05:57,520 --> 00:05:58,800
of mine

142
00:05:58,800 --> 00:06:01,280
before but i sort of ignored it because

143
00:06:01,280 --> 00:06:04,000
i didn't get any further but

144
00:06:04,000 --> 00:06:05,520
at some point i discovered i could

145
00:06:05,520 --> 00:06:06,960
program this

146
00:06:06,960 --> 00:06:09,520
these electronics using software and i

147
00:06:09,520 --> 00:06:11,360
got very excited

148
00:06:11,360 --> 00:06:12,639
and

149
00:06:12,639 --> 00:06:14,240
but but i really

150
00:06:14,240 --> 00:06:16,160
didn't really like the

151
00:06:16,160 --> 00:06:17,919
c plus plus

152
00:06:17,919 --> 00:06:20,800
dialect that arduino uses

153
00:06:20,800 --> 00:06:25,680
it it's fine but not not what i like

154
00:06:26,400 --> 00:06:28,960
so when i discovered micropython which

155
00:06:28,960 --> 00:06:30,720
is used on the

156
00:06:30,720 --> 00:06:33,840
mch batch for example it's just reds and

157
00:06:33,840 --> 00:06:36,159
parts

158
00:06:36,560 --> 00:06:38,960
i basically fell in love i

159
00:06:38,960 --> 00:06:40,000
i

160
00:06:40,000 --> 00:06:42,400
contributed some patches and i really

161
00:06:42,400 --> 00:06:44,720
liked the project

162
00:06:44,720 --> 00:06:46,840
unfortunately it's

163
00:06:46,840 --> 00:06:49,599
it's um

164
00:06:49,599 --> 00:06:52,319
i also wanted to do any led animations

165
00:06:52,319 --> 00:06:54,560
like this and it it's just a little bit

166
00:06:54,560 --> 00:06:58,000
too slow for what i wanted to do so

167
00:06:58,000 --> 00:07:00,479
at that point i also discovered go as i

168
00:07:00,479 --> 00:07:03,440
previously described and

169
00:07:03,440 --> 00:07:04,960
i was like

170
00:07:04,960 --> 00:07:05,759
i mean

171
00:07:05,759 --> 00:07:07,030
how hard can it be

172
00:07:07,030 --> 00:07:10,639
[Laughter]

173
00:07:10,639 --> 00:07:13,680
so i just hacked around and

174
00:07:13,680 --> 00:07:17,280
see how far gotten four years later

175
00:07:17,280 --> 00:07:18,800
it's

176
00:07:18,800 --> 00:07:21,520
gone quite far

177
00:07:21,520 --> 00:07:23,680
most of the go programming language

178
00:07:23,680 --> 00:07:26,240
features already work

179
00:07:26,240 --> 00:07:28,240
like basically all

180
00:07:28,240 --> 00:07:31,840
basic features and

181
00:07:32,880 --> 00:07:35,280
so what mainly doesn't work is for

182
00:07:35,280 --> 00:07:37,680
example paralysis so you can't use

183
00:07:37,680 --> 00:07:40,000
multiple threads or multiple cores

184
00:07:40,000 --> 00:07:42,400
because like most of the chips these

185
00:07:42,400 --> 00:07:46,400
chips don't even have multiple cores

186
00:07:46,960 --> 00:07:49,520
and the refract packages package which

187
00:07:49,520 --> 00:07:50,319
is

188
00:07:50,319 --> 00:07:52,479
run time flexion like runtime type

189
00:07:52,479 --> 00:07:54,720
information etc

190
00:07:54,720 --> 00:07:56,879
which partially works but

191
00:07:56,879 --> 00:07:57,759
not

192
00:07:57,759 --> 00:07:59,680
it's not complete enough for json

193
00:07:59,680 --> 00:08:01,680
serialization for example

194
00:08:01,680 --> 00:08:04,080
but that's something i work on but

195
00:08:04,080 --> 00:08:05,919
because there are small parts that are

196
00:08:05,919 --> 00:08:07,199
still missing

197
00:08:07,199 --> 00:08:08,720
large parts of the standard library

198
00:08:08,720 --> 00:08:10,879
don't compose because one dependency of

199
00:08:10,879 --> 00:08:12,720
a dependency somewhere

200
00:08:12,720 --> 00:08:15,120
doesn't work yet

201
00:08:15,120 --> 00:08:16,879
but otherwise

202
00:08:16,879 --> 00:08:18,319
it's

203
00:08:18,319 --> 00:08:20,479
most of it just works it's the same

204
00:08:20,479 --> 00:08:22,639
language so

205
00:08:22,639 --> 00:08:24,560
my goal is to

206
00:08:24,560 --> 00:08:27,120
be compatible with the wider

207
00:08:27,120 --> 00:08:29,440
ecosystem

208
00:08:29,440 --> 00:08:32,399
and of course seago which

209
00:08:32,399 --> 00:08:33,919
is a way of

210
00:08:33,919 --> 00:08:38,880
go to interact with c codes

211
00:08:38,880 --> 00:08:41,120
the main go compiler has trouble

212
00:08:41,120 --> 00:08:42,958
uh cross-compiling

213
00:08:42,958 --> 00:08:44,959
when seago is in use

214
00:08:44,959 --> 00:08:47,760
however in tango the main way to use it

215
00:08:47,760 --> 00:08:50,000
is by cross-compiling because the chip

216
00:08:50,000 --> 00:08:52,000
here is different than my

217
00:08:52,000 --> 00:08:54,880
x86

218
00:08:54,880 --> 00:08:56,399
laptop

219
00:08:56,399 --> 00:08:57,760
so

220
00:08:57,760 --> 00:09:00,000
in my opinion in many cases it works

221
00:09:00,000 --> 00:09:02,000
even better than the

222
00:09:02,000 --> 00:09:05,120
normal implementation

223
00:09:06,839 --> 00:09:10,640
um let's see yeah so

224
00:09:10,640 --> 00:09:11,760
i want to

225
00:09:11,760 --> 00:09:14,080
just say quickly i i use

226
00:09:14,080 --> 00:09:16,880
the word embedded software and microcos

227
00:09:16,880 --> 00:09:18,640
somewhat interchangeable but it's not

228
00:09:18,640 --> 00:09:20,959
quite the same

229
00:09:20,959 --> 00:09:24,399
um and but the systems are

230
00:09:24,399 --> 00:09:25,519
um

231
00:09:25,519 --> 00:09:28,000
it's a bit of a fake category but

232
00:09:28,000 --> 00:09:29,120
basically

233
00:09:29,120 --> 00:09:31,519
the way i describe them is everything

234
00:09:31,519 --> 00:09:33,839
that runs code but doesn't look like a

235
00:09:33,839 --> 00:09:36,399
computer

236
00:09:37,040 --> 00:09:39,279
which is

237
00:09:39,279 --> 00:09:43,279
almost every electronic device nowadays

238
00:09:43,279 --> 00:09:45,519
a more specific category is smart

239
00:09:45,519 --> 00:09:48,320
controllers and this is just some

240
00:09:48,320 --> 00:09:50,320
general properties that most of them

241
00:09:50,320 --> 00:09:51,920
have but there are always exceptions of

242
00:09:51,920 --> 00:09:52,800
course

243
00:09:52,800 --> 00:09:54,640
there are many architectures there's a

244
00:09:54,640 --> 00:09:57,040
wide range of ram but it's usually very

245
00:09:57,040 --> 00:09:59,040
limited

246
00:09:59,040 --> 00:10:02,399
they are relatively slow

247
00:10:02,399 --> 00:10:04,800
they execute codes directly from

248
00:10:04,800 --> 00:10:07,519
flash memory instead of loading it into

249
00:10:07,519 --> 00:10:10,640
ram first like windows or linux

250
00:10:10,640 --> 00:10:12,959
do for example

251
00:10:12,959 --> 00:10:14,800
they don't have memory protection

252
00:10:14,800 --> 00:10:16,959
usually and they don't have virtual

253
00:10:16,959 --> 00:10:19,680
memory

254
00:10:19,680 --> 00:10:22,160
however

255
00:10:25,200 --> 00:10:27,440
what they do have is a large range of

256
00:10:27,440 --> 00:10:29,760
peripherals which means they have

257
00:10:29,760 --> 00:10:32,000
various ways of interacting with other

258
00:10:32,000 --> 00:10:35,920
non-programming bullet chips for example

259
00:10:35,920 --> 00:10:40,800
gyroscopes or displays or whatever

260
00:10:42,640 --> 00:10:44,000
programming is

261
00:10:44,000 --> 00:10:47,839
these chips is almost always done in crc

262
00:10:47,839 --> 00:10:49,519
plus

263
00:10:49,519 --> 00:10:53,120
there are some exceptions like the

264
00:10:53,120 --> 00:10:55,360
batch for example but

265
00:10:55,360 --> 00:10:58,560
underneath is also c and c plus plus

266
00:10:58,560 --> 00:11:01,040
sometimes other languages are used like

267
00:11:01,040 --> 00:11:04,320
rust or maybe even other in

268
00:11:04,320 --> 00:11:07,040
some cases but almost always it's c or c

269
00:11:07,040 --> 00:11:08,640
plus plus

270
00:11:08,640 --> 00:11:10,959
um

271
00:11:11,600 --> 00:11:12,839
but

272
00:11:12,839 --> 00:11:14,720
the

273
00:11:14,720 --> 00:11:15,519
and

274
00:11:15,519 --> 00:11:18,480
how this is done is usually by using

275
00:11:18,480 --> 00:11:21,440
uh silicon vendor provided

276
00:11:21,440 --> 00:11:23,200
hardware abstraction layers

277
00:11:23,200 --> 00:11:26,399
which tend to be rather difficult to use

278
00:11:26,399 --> 00:11:27,279
well

279
00:11:27,279 --> 00:11:29,839
not difficult but not very portable

280
00:11:29,839 --> 00:11:31,920
because you're locked into the system

281
00:11:31,920 --> 00:11:33,519
and

282
00:11:33,519 --> 00:11:34,560
well

283
00:11:34,560 --> 00:11:36,800
it's software written by hardware

284
00:11:36,800 --> 00:11:39,279
designers which

285
00:11:39,279 --> 00:11:43,839
is not usually of the greatest quality

286
00:11:45,120 --> 00:11:46,640
so

287
00:11:46,640 --> 00:11:49,440
yeah that's that's one reason why i

288
00:11:49,440 --> 00:11:51,279
don't really like the

289
00:11:51,279 --> 00:11:52,480
using c

290
00:11:52,480 --> 00:11:54,320
but there are also other practical

291
00:11:54,320 --> 00:11:56,399
reasons for example

292
00:11:56,399 --> 00:11:57,600
c is

293
00:11:57,600 --> 00:11:59,120
by default very

294
00:11:59,120 --> 00:12:01,839
memory unsafe

295
00:12:01,839 --> 00:12:04,480
according to both research by microsoft

296
00:12:04,480 --> 00:12:07,120
and google

297
00:12:07,120 --> 00:12:08,079
70

298
00:12:08,079 --> 00:12:11,279
of their security vulnerabilities

299
00:12:11,279 --> 00:12:12,480
were found

300
00:12:12,480 --> 00:12:15,839
where in memory due to memory and safety

301
00:12:15,839 --> 00:12:18,079
for example double freeze or buffer

302
00:12:18,079 --> 00:12:21,360
overruns or things like that

303
00:12:21,360 --> 00:12:23,440
and

304
00:12:23,440 --> 00:12:24,399
um

305
00:12:24,399 --> 00:12:26,800
so that's one reason to not use a

306
00:12:26,800 --> 00:12:30,800
language that has this unsafety

307
00:12:32,160 --> 00:12:34,639
rust for example solved this in a very

308
00:12:34,639 --> 00:12:37,360
interesting way

309
00:12:37,440 --> 00:12:39,920
another reason is undefined behavior

310
00:12:39,920 --> 00:12:41,920
technically memory safety is i guess

311
00:12:41,920 --> 00:12:45,120
also undefined behavior

312
00:12:45,680 --> 00:12:47,040
but

313
00:12:47,040 --> 00:12:48,959
there are also integer overflows for

314
00:12:48,959 --> 00:12:51,680
example and many other things that

315
00:12:51,680 --> 00:12:54,320
seem to work but sometimes i don't

316
00:12:54,320 --> 00:12:57,519
and nc is often presented as

317
00:12:57,519 --> 00:12:59,120
portable

318
00:12:59,120 --> 00:13:01,680
but actually it isn't really

319
00:13:01,680 --> 00:13:04,560
it's sort of but

320
00:13:04,720 --> 00:13:06,240
all the implementations are slightly

321
00:13:06,240 --> 00:13:09,680
different uh integer sizes can therefore

322
00:13:09,680 --> 00:13:12,079
um

323
00:13:13,279 --> 00:13:16,720
available headers can therefore

324
00:13:16,800 --> 00:13:18,160
yeah it's

325
00:13:18,160 --> 00:13:19,760
a little bit of a mess but because of

326
00:13:19,760 --> 00:13:20,399
the

327
00:13:20,399 --> 00:13:23,360
long history of of c

328
00:13:23,360 --> 00:13:25,279
so that's why i

329
00:13:25,279 --> 00:13:28,639
prefer using other languages

330
00:13:28,639 --> 00:13:29,519
um

331
00:13:29,519 --> 00:13:31,839
one contender is of course rust and i

332
00:13:31,839 --> 00:13:35,120
think it's it's a very good language for

333
00:13:35,120 --> 00:13:38,240
programming microcontrollers

334
00:13:38,240 --> 00:13:42,240
especially for safety critical systems

335
00:13:42,560 --> 00:13:44,880
and but there are some

336
00:13:44,880 --> 00:13:48,959
reasons why you might not want to use it

337
00:13:48,959 --> 00:13:51,600
for example

338
00:13:51,600 --> 00:13:52,720
so

339
00:13:52,720 --> 00:13:54,240
it has gotten a lot better over the

340
00:13:54,240 --> 00:13:55,920
years but it's still a little bit hard

341
00:13:55,920 --> 00:13:57,199
to learn

342
00:13:57,199 --> 00:13:59,680
and

343
00:13:59,680 --> 00:14:02,079
but but for example you might also have

344
00:14:02,079 --> 00:14:04,480
existing go code you might want to use

345
00:14:04,480 --> 00:14:06,560
on the microcontroller or existing

346
00:14:06,560 --> 00:14:08,079
developers

347
00:14:08,079 --> 00:14:09,600
that are familiar with go but don't

348
00:14:09,600 --> 00:14:11,040
retrust so

349
00:14:11,040 --> 00:14:13,360
having options is great

350
00:14:13,360 --> 00:14:15,360
but then again

351
00:14:15,360 --> 00:14:17,440
rust is probably a nice language just

352
00:14:17,440 --> 00:14:20,079
not my language

353
00:14:20,079 --> 00:14:21,120
um

354
00:14:21,120 --> 00:14:23,600
let's see

355
00:14:23,839 --> 00:14:26,839
um

356
00:14:31,680 --> 00:14:34,399
so that's why i

357
00:14:34,399 --> 00:14:37,760
like using a different

358
00:14:39,279 --> 00:14:41,120
language

359
00:14:41,120 --> 00:14:43,199
and now i want to would like to go into

360
00:14:43,199 --> 00:14:46,000
a little bit more detail how

361
00:14:46,000 --> 00:14:48,399
a tiny girl is structured because most

362
00:14:48,399 --> 00:14:50,880
people probably think of

363
00:14:50,880 --> 00:14:54,079
compilers as a big block black box and

364
00:14:54,079 --> 00:14:56,480
you put source code in and an object's

365
00:14:56,480 --> 00:14:59,839
file comes out in the end and

366
00:14:59,839 --> 00:15:00,880
so

367
00:15:00,880 --> 00:15:02,959
it is very complicated when you look at

368
00:15:02,959 --> 00:15:04,079
it that's

369
00:15:04,079 --> 00:15:07,360
this way and but like all complicated

370
00:15:07,360 --> 00:15:09,600
problems in software engineering you

371
00:15:09,600 --> 00:15:12,000
just split it up into multiple smaller

372
00:15:12,000 --> 00:15:16,720
parts that are more easily solvable

373
00:15:17,760 --> 00:15:22,079
so for tiny go for example i use the

374
00:15:24,320 --> 00:15:26,399
go has some standard library

375
00:15:26,399 --> 00:15:27,760
packages

376
00:15:27,760 --> 00:15:29,759
which already supports parsing and type

377
00:15:29,759 --> 00:15:34,399
checking the language which is useful

378
00:15:34,880 --> 00:15:36,800
and so what tango basically does is

379
00:15:36,800 --> 00:15:38,800
converts this

380
00:15:38,800 --> 00:15:40,959
um

381
00:15:40,959 --> 00:15:43,120
this intermediate

382
00:15:43,120 --> 00:15:46,000
form that these

383
00:15:46,959 --> 00:15:48,000
okay

384
00:15:48,000 --> 00:15:51,279
let's back up a bit

385
00:15:51,360 --> 00:15:53,360
basically compilers are structured in

386
00:15:53,360 --> 00:15:56,000
layers and every layer

387
00:15:56,000 --> 00:15:58,240
simplifies the code a bit and optimizes

388
00:15:58,240 --> 00:15:59,759
them in a way

389
00:15:59,759 --> 00:16:03,920
that is appropriate for this layer

390
00:16:06,720 --> 00:16:09,519
and in time ago we i use

391
00:16:09,519 --> 00:16:10,800
a few pack

392
00:16:10,800 --> 00:16:12,800
for the first part i use the standard

393
00:16:12,800 --> 00:16:15,920
library packages i said described

394
00:16:15,920 --> 00:16:16,959
and for

395
00:16:16,959 --> 00:16:20,720
generating object files i use lvm

396
00:16:20,720 --> 00:16:25,360
which is a compiler framework

397
00:16:25,360 --> 00:16:27,759
many well-known compilers are using are

398
00:16:27,759 --> 00:16:31,360
written using lvm

399
00:16:31,360 --> 00:16:33,680
for example rust as i

400
00:16:33,680 --> 00:16:35,040
mentioned before

401
00:16:35,040 --> 00:16:37,279
swift clang and

402
00:16:37,279 --> 00:16:38,959
many other

403
00:16:38,959 --> 00:16:40,560
compilers are

404
00:16:40,560 --> 00:16:44,160
using lvm in the back end

405
00:16:44,160 --> 00:16:46,639
what it does is basically

406
00:16:46,639 --> 00:16:49,360
a compiler can generate a language

407
00:16:49,360 --> 00:16:51,680
independent

408
00:16:51,680 --> 00:16:52,320
in

409
00:16:52,320 --> 00:16:53,519
intermediate

410
00:16:53,519 --> 00:16:55,680
representation

411
00:16:55,680 --> 00:16:58,399
and lvm will then optimize

412
00:16:58,399 --> 00:17:00,639
this

413
00:17:00,800 --> 00:17:03,120
language independent form

414
00:17:03,120 --> 00:17:07,039
and generates machine codes in the end

415
00:17:07,039 --> 00:17:08,480
so that

416
00:17:08,480 --> 00:17:10,240
takes away

417
00:17:10,240 --> 00:17:13,839
lots of the hard work of writing a

418
00:17:13,839 --> 00:17:16,079
compiler

419
00:17:16,079 --> 00:17:16,880
so

420
00:17:16,880 --> 00:17:19,839
basically what taniko does is

421
00:17:19,839 --> 00:17:20,959
only

422
00:17:20,959 --> 00:17:22,559
to convert

423
00:17:22,559 --> 00:17:24,319
this

424
00:17:24,319 --> 00:17:25,839
go intermediate

425
00:17:25,839 --> 00:17:30,480
form into lvm intermediate form

426
00:17:30,799 --> 00:17:33,120
which for the most part is pretty simple

427
00:17:33,120 --> 00:17:35,840
but of course in go you can start guard

428
00:17:35,840 --> 00:17:39,360
routines which are kind of green chats

429
00:17:39,360 --> 00:17:41,200
and

430
00:17:41,200 --> 00:17:43,520
but of course lvm doesn't support

431
00:17:43,520 --> 00:17:45,440
things like that so that's basically a

432
00:17:45,440 --> 00:17:48,160
runtime call

433
00:17:52,080 --> 00:17:54,320
so this part of the compiler is not too

434
00:17:54,320 --> 00:17:56,160
difficult

435
00:17:56,160 --> 00:17:58,400
what is more interesting probably is the

436
00:17:58,400 --> 00:18:01,400
runtime

437
00:18:03,200 --> 00:18:05,039
the runtime

438
00:18:05,039 --> 00:18:06,720
basically does a lot of stuff behind the

439
00:18:06,720 --> 00:18:08,960
back

440
00:18:09,679 --> 00:18:13,559
you can see a list here

441
00:18:14,960 --> 00:18:16,400
when the chips

442
00:18:16,400 --> 00:18:19,200
the chip like this resets

443
00:18:19,200 --> 00:18:20,799
um

444
00:18:20,799 --> 00:18:23,520
nothing is initialized yet the

445
00:18:23,520 --> 00:18:24,480
its

446
00:18:24,480 --> 00:18:26,960
memory has to be initialized clocks have

447
00:18:26,960 --> 00:18:29,600
to be initialized

448
00:18:29,600 --> 00:18:30,960
often the

449
00:18:30,960 --> 00:18:33,840
chip has to be set to a higher frequency

450
00:18:33,840 --> 00:18:35,679
stuff like that

451
00:18:35,679 --> 00:18:37,120
so that's the startup code which is in

452
00:18:37,120 --> 00:18:38,480
the runtime

453
00:18:38,480 --> 00:18:40,080
and then it calls the

454
00:18:40,080 --> 00:18:41,440
main function

455
00:18:41,440 --> 00:18:42,640
as i

456
00:18:42,640 --> 00:18:44,960
showed earlier in the

457
00:18:44,960 --> 00:18:46,240
code

458
00:18:46,240 --> 00:18:48,320
like

459
00:18:48,320 --> 00:18:50,559
this one

460
00:18:50,559 --> 00:18:52,000
and of course there are many other

461
00:18:52,000 --> 00:18:53,039
things like

462
00:18:53,039 --> 00:18:54,559
scheduling

463
00:18:54,559 --> 00:18:57,039
go has um

464
00:18:57,039 --> 00:18:58,960
guardings which are

465
00:18:58,960 --> 00:19:02,320
basically green threads

466
00:19:02,400 --> 00:19:03,440
um

467
00:19:03,440 --> 00:19:05,679
and the scheduler is there to

468
00:19:05,679 --> 00:19:08,559
start them and switch between them and

469
00:19:08,559 --> 00:19:10,880
prioritize them etc

470
00:19:10,880 --> 00:19:14,000
and go as channels which are

471
00:19:14,000 --> 00:19:14,960
i

472
00:19:14,960 --> 00:19:18,160
i think other languages have them but

473
00:19:18,160 --> 00:19:19,039
not

474
00:19:19,039 --> 00:19:22,480
frequently are used i think

475
00:19:23,039 --> 00:19:25,039
erlang yeah probably

476
00:19:25,039 --> 00:19:27,440
thank you

477
00:19:28,160 --> 00:19:31,760
uh i think you're correct

478
00:19:32,400 --> 00:19:34,640
so

479
00:19:35,919 --> 00:19:37,039
that's that's one thing that's

480
00:19:37,039 --> 00:19:38,559
implemented in the

481
00:19:38,559 --> 00:19:40,559
runtime

482
00:19:40,559 --> 00:19:44,559
and garbage collection of course um go

483
00:19:44,559 --> 00:19:46,400
the the go language specification

484
00:19:46,400 --> 00:19:48,320
doesn't describe how many memory is

485
00:19:48,320 --> 00:19:50,559
managed it just says this allocates

486
00:19:50,559 --> 00:19:53,360
memory

487
00:19:53,360 --> 00:19:55,200
in practice that means you have to use a

488
00:19:55,200 --> 00:19:57,919
garbage collector

489
00:19:57,919 --> 00:20:01,120
like java or javascript or

490
00:20:01,120 --> 00:20:05,479
i believe erlang but i'm not sure

491
00:20:08,240 --> 00:20:10,000
and i

492
00:20:10,000 --> 00:20:12,159
basically copied the garbage collector

493
00:20:12,159 --> 00:20:14,640
from micro python

494
00:20:14,640 --> 00:20:15,840
more or less

495
00:20:15,840 --> 00:20:18,720
at least the design

496
00:20:18,840 --> 00:20:22,720
um and it's it's just a few 100 lines i

497
00:20:22,720 --> 00:20:24,880
believe it's

498
00:20:24,880 --> 00:20:25,840
like

499
00:20:25,840 --> 00:20:27,919
um a textbook

500
00:20:27,919 --> 00:20:31,440
implementation of a garbage collector

501
00:20:32,000 --> 00:20:33,679
but that's also in the runtime and time

502
00:20:33,679 --> 00:20:35,840
time handling because every chip has a

503
00:20:35,840 --> 00:20:37,360
different

504
00:20:37,360 --> 00:20:39,760
way of

505
00:20:39,760 --> 00:20:42,640
controlling time

506
00:20:42,960 --> 00:20:47,120
many have an rtc a real real-time clock

507
00:20:47,120 --> 00:20:48,480
real time

508
00:20:48,480 --> 00:20:51,200
um because at the chip reset it's set

509
00:20:51,200 --> 00:20:54,080
back to no zero

510
00:20:54,080 --> 00:20:56,559
but but this this specific hardware

511
00:20:56,559 --> 00:20:58,559
implementation has to be converted back

512
00:20:58,559 --> 00:20:59,919
to the

513
00:20:59,919 --> 00:21:02,080
time.now and time.sleep and

514
00:21:02,080 --> 00:21:03,440
go

515
00:21:03,440 --> 00:21:05,360
and that's what the runtime does and of

516
00:21:05,360 --> 00:21:07,200
course other things like the hashmap

517
00:21:07,200 --> 00:21:09,360
implementation

518
00:21:09,360 --> 00:21:10,320
which is

519
00:21:10,320 --> 00:21:12,320
of course optimized for site instead of

520
00:21:12,320 --> 00:21:15,200
for size instead of for speed

521
00:21:15,200 --> 00:21:17,679
and many or

522
00:21:17,679 --> 00:21:19,919
small things that are just a little bit

523
00:21:19,919 --> 00:21:21,360
too complicated

524
00:21:21,360 --> 00:21:24,480
to do directly

525
00:21:24,480 --> 00:21:28,480
in line with our separate functions

526
00:21:28,480 --> 00:21:32,400
let's see i think i have some time left

527
00:21:32,400 --> 00:21:34,640
um

528
00:21:35,520 --> 00:21:38,320
so yeah that's the

529
00:21:38,320 --> 00:21:42,000
runtime and the runtime is also the

530
00:21:42,400 --> 00:21:43,679
i

531
00:21:43,679 --> 00:21:45,840
i've used the different

532
00:21:45,840 --> 00:21:47,760
um

533
00:21:47,760 --> 00:21:50,320
some people have suggested you using the

534
00:21:50,320 --> 00:21:53,280
existing runtime for more compatibility

535
00:21:53,280 --> 00:21:54,960
however

536
00:21:54,960 --> 00:21:56,799
the the goals of tiny car are so

537
00:21:56,799 --> 00:21:59,679
different from normal and go that i

538
00:21:59,679 --> 00:22:03,360
decided to use a different runtime

539
00:22:03,440 --> 00:22:04,480
because for example the garbage

540
00:22:04,480 --> 00:22:06,400
collector is super simple

541
00:22:06,400 --> 00:22:07,840
which is necessary because otherwise

542
00:22:07,840 --> 00:22:10,960
it's just too large and for

543
00:22:10,960 --> 00:22:13,679
like 16k of ram you don't need an

544
00:22:13,679 --> 00:22:14,799
advanced

545
00:22:14,799 --> 00:22:17,280
garbage collector

546
00:22:17,280 --> 00:22:19,919
um a matter of many other things are

547
00:22:19,919 --> 00:22:21,679
designed specifically for a small

548
00:22:21,679 --> 00:22:26,320
embedded system instead of large servers

549
00:22:26,320 --> 00:22:27,760
um

550
00:22:27,760 --> 00:22:30,159
however all of the

551
00:22:30,159 --> 00:22:31,120
my

552
00:22:31,120 --> 00:22:33,679
intention with this project is to be

553
00:22:33,679 --> 00:22:38,150
entirely compatible with the existing

554
00:22:38,150 --> 00:22:39,520
[Music]

555
00:22:39,520 --> 00:22:42,240
go ecosystem so that

556
00:22:42,240 --> 00:22:44,559
existing code can be reused on

557
00:22:44,559 --> 00:22:47,120
microcontrollers

558
00:22:47,120 --> 00:22:50,400
or webassembly which is what many people

559
00:22:50,400 --> 00:22:55,480
are into but i'm not really to be honest

560
00:22:56,880 --> 00:22:57,919
so

561
00:22:57,919 --> 00:22:59,280
so some people have for example

562
00:22:59,280 --> 00:23:02,880
suggested stripping some parts from the

563
00:23:02,880 --> 00:23:05,520
from the language for to make the make

564
00:23:05,520 --> 00:23:07,919
it smaller but then you're breaking

565
00:23:07,919 --> 00:23:09,600
compatibility and that's

566
00:23:09,600 --> 00:23:11,840
the whole point of the compiler being

567
00:23:11,840 --> 00:23:14,240
compatible with existing code

568
00:23:14,240 --> 00:23:16,400
otherwise you might as well just

569
00:23:16,400 --> 00:23:18,720
start a new

570
00:23:18,720 --> 00:23:20,720
language

571
00:23:20,720 --> 00:23:23,840
write a new language

572
00:23:24,400 --> 00:23:26,640
so

573
00:23:26,640 --> 00:23:28,240
yeah that's

574
00:23:28,240 --> 00:23:30,000
mainly my goal i

575
00:23:30,000 --> 00:23:32,960
just want a compiler for existing codes

576
00:23:32,960 --> 00:23:34,840
that

577
00:23:34,840 --> 00:23:36,480
um

578
00:23:36,480 --> 00:23:39,440
but for a very different use case then

579
00:23:39,440 --> 00:23:42,320
it was used before

580
00:23:42,559 --> 00:23:44,500
thank you

581
00:23:44,500 --> 00:23:50,720
[Applause]

582
00:23:50,720 --> 00:23:53,279
any questions so yes we do have time for

583
00:23:53,279 --> 00:23:54,880
questions so please microphone in the

584
00:23:54,880 --> 00:23:56,320
middle front

585
00:23:56,320 --> 00:23:59,440
hi compliments on the uh the idea of

586
00:23:59,440 --> 00:24:02,400
mapping sorry compliments on the idea of

587
00:24:02,400 --> 00:24:05,120
mapping an advanced language to directly

588
00:24:05,120 --> 00:24:08,000
to binary code and making it very thin

589
00:24:08,000 --> 00:24:10,559
two two questions or remarks i don't

590
00:24:10,559 --> 00:24:12,559
know about complexity

591
00:24:12,559 --> 00:24:14,880
first is micro ip i don't know if you've

592
00:24:14,880 --> 00:24:17,039
heard about it but it used to be a tcp

593
00:24:17,039 --> 00:24:19,760
deck that fitted in 16 kilobytes

594
00:24:19,760 --> 00:24:22,159
and it was based on core routines so you

595
00:24:22,159 --> 00:24:24,159
might want to be interested in

596
00:24:24,159 --> 00:24:25,440
sorry

597
00:24:25,440 --> 00:24:28,559
micro micro rb is a micro ip

598
00:24:28,559 --> 00:24:31,600
it's a tcp rp stack that fits in 16

599
00:24:31,600 --> 00:24:33,440
kilobytes it used to use

600
00:24:33,440 --> 00:24:35,679
micro uh controllers

601
00:24:35,679 --> 00:24:38,480
and it works through co routines

602
00:24:38,480 --> 00:24:41,600
two true code routines coroutines so you

603
00:24:41,600 --> 00:24:44,559
might look at and see or yeah

604
00:24:44,559 --> 00:24:47,840
interesting yeah

605
00:24:48,400 --> 00:24:50,080
maybe useful for the uh

606
00:24:50,080 --> 00:24:51,840
then we have to move on to the next

607
00:24:51,840 --> 00:24:55,039
question please just one question

608
00:24:55,039 --> 00:24:56,960
but you can definitely be useful for the

609
00:24:56,960 --> 00:24:59,120
net package which is not implemented yet

610
00:24:59,120 --> 00:25:01,840
but thank you i was wondering you spoke

611
00:25:01,840 --> 00:25:04,480
about the intention to support a full go

612
00:25:04,480 --> 00:25:05,760
ecosystem

613
00:25:05,760 --> 00:25:07,919
how do you plan to deal with like file

614
00:25:07,919 --> 00:25:10,000
system operations or other operations

615
00:25:10,000 --> 00:25:12,159
that would deal with an os that is

616
00:25:12,159 --> 00:25:14,000
definitely not present in the embedded

617
00:25:14,000 --> 00:25:16,320
world

618
00:25:16,400 --> 00:25:19,600
so the file system

619
00:25:19,919 --> 00:25:21,600
in go we have the

620
00:25:21,600 --> 00:25:23,919
os package which is an abstraction layer

621
00:25:23,919 --> 00:25:24,799
over the

622
00:25:24,799 --> 00:25:27,360
well the operating system of course

623
00:25:27,360 --> 00:25:29,760
and

624
00:25:29,760 --> 00:25:32,720
what we've been done in tinyco is

625
00:25:32,720 --> 00:25:34,080
basically

626
00:25:34,080 --> 00:25:38,400
there's a function you can call to set a

627
00:25:38,400 --> 00:25:40,559
virtual file system at a

628
00:25:40,559 --> 00:25:42,720
basically to mount the file system at a

629
00:25:42,720 --> 00:25:44,000
certain

630
00:25:44,000 --> 00:25:46,080
uh path

631
00:25:46,080 --> 00:25:46,880
okay

632
00:25:46,880 --> 00:25:47,679
and

633
00:25:47,679 --> 00:25:50,640
that's why that's how you can

634
00:25:50,640 --> 00:25:52,159
put in some

635
00:25:52,159 --> 00:25:53,919
file systems

636
00:25:53,919 --> 00:25:56,080
okay then the next question please front

637
00:25:56,080 --> 00:25:57,279
micro

638
00:25:57,279 --> 00:25:59,760
hello i was wondering how does the main

639
00:25:59,760 --> 00:26:02,240
issue with go is it's too large to fit

640
00:26:02,240 --> 00:26:05,440
into microcontrollers and therefore you

641
00:26:05,440 --> 00:26:08,180
wrote a new runtime yes which is

642
00:26:08,180 --> 00:26:09,360
[Music]

643
00:26:09,360 --> 00:26:10,799
smaller so it can run on

644
00:26:10,799 --> 00:26:12,320
microcontrollers

645
00:26:12,320 --> 00:26:15,039
but the language itself you you were

646
00:26:15,039 --> 00:26:18,240
just saying you wrote a go compiler

647
00:26:18,240 --> 00:26:20,559
couldn't you you just use the

648
00:26:20,559 --> 00:26:23,840
default compiler instead because

649
00:26:23,840 --> 00:26:25,200
what are the difference there is i was

650
00:26:25,200 --> 00:26:27,279
very curious about that so so

651
00:26:27,279 --> 00:26:28,240
i've

652
00:26:28,240 --> 00:26:31,520
basically tried this i tried to use gcc

653
00:26:31,520 --> 00:26:33,120
go

654
00:26:33,120 --> 00:26:36,080
gcc also has go support

655
00:26:36,080 --> 00:26:39,919
and and my first attempt was

656
00:26:39,919 --> 00:26:43,440
using and gcc also has a extensive port

657
00:26:43,440 --> 00:26:46,159
for the batch for example

658
00:26:46,159 --> 00:26:50,400
and basically what i tried was

659
00:26:51,039 --> 00:26:53,840
um

660
00:26:56,880 --> 00:26:59,919
a compil enabling the go parts and

661
00:26:59,919 --> 00:27:01,919
it did in fact work

662
00:27:01,919 --> 00:27:04,559
surprisingly

663
00:27:04,559 --> 00:27:06,880
however i found that the

664
00:27:06,880 --> 00:27:09,279
the way

665
00:27:09,360 --> 00:27:13,520
so the go part was not very optimized

666
00:27:13,520 --> 00:27:16,640
it uses all variables are when you call

667
00:27:16,640 --> 00:27:19,039
a function for example all

668
00:27:19,039 --> 00:27:21,919
parameters are passed on the stack

669
00:27:21,919 --> 00:27:22,880
and this

670
00:27:22,880 --> 00:27:25,039
weighs a lot of stack space

671
00:27:25,039 --> 00:27:27,360
so it works on the esp which is pretty

672
00:27:27,360 --> 00:27:28,720
pretty large but

673
00:27:28,720 --> 00:27:31,039
on an avr it probably would be very

674
00:27:31,039 --> 00:27:33,200
difficult to get working so i've looked

675
00:27:33,200 --> 00:27:34,480
into it but

676
00:27:34,480 --> 00:27:36,480
the existing design was just not not

677
00:27:36,480 --> 00:27:37,279
great

678
00:27:37,279 --> 00:27:38,240
okay

679
00:27:38,240 --> 00:27:40,399
okay okay are there any questions on the

680
00:27:40,399 --> 00:27:42,080
internet

681
00:27:42,080 --> 00:27:46,320
no then next question please

682
00:27:46,559 --> 00:27:48,399
a question about the garbage collection

683
00:27:48,399 --> 00:27:50,240
um of course garbage collection can get

684
00:27:50,240 --> 00:27:51,919
away with real-time performance which

685
00:27:51,919 --> 00:27:53,679
may be a big problem for an embedded

686
00:27:53,679 --> 00:27:54,720
system

687
00:27:54,720 --> 00:27:56,960
um have you taken care of that for

688
00:27:56,960 --> 00:27:58,559
example by trying to schedule it in

689
00:27:58,559 --> 00:28:00,559
downtime while it's waiting just before

690
00:28:00,559 --> 00:28:02,320
it goes to sleep doing some garbage

691
00:28:02,320 --> 00:28:03,840
collection

692
00:28:03,840 --> 00:28:07,440
i've looked into it a lot but right now

693
00:28:07,440 --> 00:28:10,720
it doesn't support this

694
00:28:10,720 --> 00:28:11,840
however

695
00:28:11,840 --> 00:28:14,240
what you can do is run the time critical

696
00:28:14,240 --> 00:28:17,840
stuff and interrupts

697
00:28:17,840 --> 00:28:20,080
and interrupts are not allowed to

698
00:28:20,080 --> 00:28:22,159
allocate memory

699
00:28:22,159 --> 00:28:23,600
so this way

700
00:28:23,600 --> 00:28:25,840
you can just do a garbage collection

701
00:28:25,840 --> 00:28:28,080
cycle while an interrupt

702
00:28:28,080 --> 00:28:30,480
is run basically

703
00:28:30,480 --> 00:28:33,760
interrupts the cycle with an interrupt

704
00:28:33,760 --> 00:28:36,960
so you can still write uh interrupt a

705
00:28:36,960 --> 00:28:38,399
real-time codes

706
00:28:38,399 --> 00:28:39,760
and just

707
00:28:39,760 --> 00:28:41,200
not use

708
00:28:41,200 --> 00:28:43,360
heap allocation in there so it's

709
00:28:43,360 --> 00:28:44,480
possible

710
00:28:44,480 --> 00:28:46,399
okay and one last really quick question

711
00:28:46,399 --> 00:28:48,719
thank you

712
00:28:48,880 --> 00:28:51,440
sorry front micro

713
00:28:51,440 --> 00:28:53,919
work yeah

714
00:28:53,919 --> 00:28:56,559
i was also thinking about a system which

715
00:28:56,559 --> 00:28:59,279
was also meant for small processors

716
00:28:59,279 --> 00:29:02,240
java java 2 micro edition which run on

717
00:29:02,240 --> 00:29:05,120
the nokia sensor on

718
00:29:05,120 --> 00:29:07,440
could you use ids from there because

719
00:29:07,440 --> 00:29:09,279
that was also a very small system which

720
00:29:09,279 --> 00:29:10,799
is a garbage collector

721
00:29:10,799 --> 00:29:13,840
in case

722
00:29:20,720 --> 00:29:23,039
use ideas which were used in java 2

723
00:29:23,039 --> 00:29:24,880
maker edition because it is also meant

724
00:29:24,880 --> 00:29:26,799
for very small systems

725
00:29:26,799 --> 00:29:29,440
and it's a trend java which also needs

726
00:29:29,440 --> 00:29:30,960
garbage collection

727
00:29:30,960 --> 00:29:36,159
you mean compile go to the java barcodes

728
00:29:36,960 --> 00:29:38,960
thank you did you take a

729
00:29:38,960 --> 00:29:41,279
maybe you could steal some id so to

730
00:29:41,279 --> 00:29:44,080
speak i honestly didn't really look into

731
00:29:44,080 --> 00:29:45,120
it but

732
00:29:45,120 --> 00:29:47,120
i know there are

733
00:29:47,120 --> 00:29:48,880
parts of

734
00:29:48,880 --> 00:29:50,480
javascript to

735
00:29:50,480 --> 00:29:52,159
or java or not

736
00:29:52,159 --> 00:29:54,399
okay so that's something you can maybe

737
00:29:54,399 --> 00:29:56,720
discuss afterwards because time is up

738
00:29:56,720 --> 00:29:57,440
and

739
00:29:57,440 --> 00:29:59,679
yeah if you have more questions i'll be

740
00:29:59,679 --> 00:30:02,000
back here yeah and please give a warm

741
00:30:02,000 --> 00:30:03,520
round of applause because that was a

742
00:30:03,520 --> 00:30:06,679
great talk

743
00:30:17,200 --> 00:30:19,279
you

