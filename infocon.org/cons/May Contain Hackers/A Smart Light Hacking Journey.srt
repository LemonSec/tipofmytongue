1
00:00:01,280 --> 00:00:12,559
[Music]

2
00:00:15,200 --> 00:00:17,039
good morning everyone thanks for coming

3
00:00:17,039 --> 00:00:19,520
this early morning we appreciate it i'm

4
00:00:19,520 --> 00:00:21,199
actually really excited to be here so it

5
00:00:21,199 --> 00:00:23,119
turns out if you organize an event and

6
00:00:23,119 --> 00:00:25,039
do a technical talk it's uh it's quite a

7
00:00:25,039 --> 00:00:27,519
challenge i'm really glad we made it

8
00:00:27,519 --> 00:00:30,480
it was not an early night last night but

9
00:00:30,480 --> 00:00:32,238
i think we're in good shape

10
00:00:32,238 --> 00:00:34,880
okay so so first off does anyone here

11
00:00:34,880 --> 00:00:36,480
have these kinds of smart lights at home

12
00:00:36,480 --> 00:00:38,640
yet can we see a raise of hands

13
00:00:38,640 --> 00:00:41,200
also this may be a quarter to half of

14
00:00:41,200 --> 00:00:42,160
the

15
00:00:42,160 --> 00:00:44,399
of the room here this is very

16
00:00:44,399 --> 00:00:45,280
interesting

17
00:00:45,280 --> 00:00:46,879
hopefully uh

18
00:00:46,879 --> 00:00:48,559
you will uh you will have some new

19
00:00:48,559 --> 00:00:52,480
tricks up your sleeve after our talk

20
00:00:52,480 --> 00:00:56,079
okay so first off um who are we

21
00:00:56,079 --> 00:00:58,320
my name is tom uh i'm one of the

22
00:00:58,320 --> 00:01:00,239
organizers of the camp here i'm a

23
00:01:00,239 --> 00:01:02,640
firmware engineer at ultimaker and i

24
00:01:02,640 --> 00:01:05,040
have a little company that makes quirky

25
00:01:05,040 --> 00:01:07,280
electronics gadgets i'm here with my

26
00:01:07,280 --> 00:01:09,920
long-term friend khilet yes hi my name

27
00:01:09,920 --> 00:01:12,240
is khalid nassar i am a security

28
00:01:12,240 --> 00:01:14,560
engineer and an internal blue team so i

29
00:01:14,560 --> 00:01:19,280
do incident response i also like to

30
00:01:19,280 --> 00:01:21,840
i also i'm quite an avid ctf player i've

31
00:01:21,840 --> 00:01:24,400
been playing for about 10 years with my

32
00:01:24,400 --> 00:01:28,080
ctf team spotless and yeah we do i do

33
00:01:28,080 --> 00:01:29,680
quite a bit of stuff in my free time

34
00:01:29,680 --> 00:01:32,000
including projects such as this i'm

35
00:01:32,000 --> 00:01:33,759
going to move to tom now to introduce

36
00:01:33,759 --> 00:01:35,520
the rest of the first one

37
00:01:35,520 --> 00:01:36,799
all right so what are we talking about

38
00:01:36,799 --> 00:01:39,119
today we're talking about these these

39
00:01:39,119 --> 00:01:43,040
kinds of smart iot lights

40
00:01:43,040 --> 00:01:45,759
first we'll do a quick introduction of

41
00:01:45,759 --> 00:01:47,759
how we dove down the rabbit hole that we

42
00:01:47,759 --> 00:01:49,119
are in now

43
00:01:49,119 --> 00:01:51,680
how we got to this

44
00:01:51,680 --> 00:01:53,680
then we'll talk a bit about

45
00:01:53,680 --> 00:01:57,280
the initial revision of hardware

46
00:01:57,280 --> 00:02:00,399
that we found then a big revamp with a

47
00:02:00,399 --> 00:02:02,479
new type of chip where we found some new

48
00:02:02,479 --> 00:02:03,680
things

49
00:02:03,680 --> 00:02:05,520
and finally we'll show you a

50
00:02:05,520 --> 00:02:08,239
vulnerability that we found out is

51
00:02:08,239 --> 00:02:09,280
running on

52
00:02:09,280 --> 00:02:12,319
millions of devices all over the world

53
00:02:12,319 --> 00:02:14,000
that we use to

54
00:02:14,000 --> 00:02:15,360
break free

55
00:02:15,360 --> 00:02:17,760
of internet connected servers and run

56
00:02:17,760 --> 00:02:20,000
these devices locally only inside of

57
00:02:20,000 --> 00:02:23,120
your own network

58
00:02:23,120 --> 00:02:24,560
hopefully at the end there will be some

59
00:02:24,560 --> 00:02:26,640
room for uh for questions but we'll see

60
00:02:26,640 --> 00:02:29,200
how the time pans out

61
00:02:29,200 --> 00:02:30,239
all right so starting with our

62
00:02:30,239 --> 00:02:32,879
inspiration in 2019

63
00:02:32,879 --> 00:02:37,840
dutch hackerspace hack 42 um

64
00:02:38,160 --> 00:02:39,920
called up all the troops and said we

65
00:02:39,920 --> 00:02:42,239
found these devices at action a local

66
00:02:42,239 --> 00:02:43,599
store

67
00:02:43,599 --> 00:02:45,440
there there are power plug that connect

68
00:02:45,440 --> 00:02:46,879
to your wi-fi

69
00:02:46,879 --> 00:02:49,120
and you can hack them to run locally you

70
00:02:49,120 --> 00:02:50,959
can run whatever firmware you like on

71
00:02:50,959 --> 00:02:52,720
them

72
00:02:52,720 --> 00:02:55,440
and they they organized this session

73
00:02:55,440 --> 00:02:57,599
to to hack these devices together they

74
00:02:57,599 --> 00:02:59,200
put it up on their wiki you see it on

75
00:02:59,200 --> 00:03:01,599
the right

76
00:03:02,800 --> 00:03:04,319
they found that there's this uh this

77
00:03:04,319 --> 00:03:06,800
tool called tuia convert that you can

78
00:03:06,800 --> 00:03:07,920
use

79
00:03:07,920 --> 00:03:10,159
to to break free these devices of the

80
00:03:10,159 --> 00:03:12,319
firmware that they came with and instead

81
00:03:12,319 --> 00:03:15,359
flash your own on it

82
00:03:15,840 --> 00:03:18,480
and this tuja converts an open source

83
00:03:18,480 --> 00:03:20,080
tool

84
00:03:20,080 --> 00:03:21,920
turned out to be based on

85
00:03:21,920 --> 00:03:23,519
research from

86
00:03:23,519 --> 00:03:25,840
ccc

87
00:03:25,840 --> 00:03:27,360
35

88
00:03:27,360 --> 00:03:28,799
c3

89
00:03:28,799 --> 00:03:30,959
by michael from vtrust who's actually

90
00:03:30,959 --> 00:03:33,680
sitting right here in the room

91
00:03:33,680 --> 00:03:37,200
so he he found a really cool bug

92
00:03:37,200 --> 00:03:39,200
that allowed you to

93
00:03:39,200 --> 00:03:40,720
take control of the device and flash

94
00:03:40,720 --> 00:03:43,840
your own firmware to it

95
00:03:44,640 --> 00:03:46,959
how did it work

96
00:03:46,959 --> 00:03:48,319
so the device

97
00:03:48,319 --> 00:03:49,920
connects to the server of the

98
00:03:49,920 --> 00:03:52,640
manufacturer

99
00:03:52,640 --> 00:03:54,640
it has a sort of handshake where it

100
00:03:54,640 --> 00:03:57,120
sends some information including this

101
00:03:57,120 --> 00:04:00,400
thing called the psk id

102
00:04:00,400 --> 00:04:02,239
and then it starts encrypting the

103
00:04:02,239 --> 00:04:04,239
connection with

104
00:04:04,239 --> 00:04:08,159
tls psk pre-shared key

105
00:04:08,560 --> 00:04:10,080
this pre-shared key though it was

106
00:04:10,080 --> 00:04:13,120
derived from the psk id that got sent

107
00:04:13,120 --> 00:04:15,280
so it sent to the server all the

108
00:04:15,280 --> 00:04:18,320
information you need to figure out

109
00:04:18,320 --> 00:04:21,918
how to encrypt and decrypt the data

110
00:04:21,918 --> 00:04:23,520
and so using this knowledge you can

111
00:04:23,520 --> 00:04:25,520
actually get rid of the whole vendor

112
00:04:25,520 --> 00:04:27,600
server act like you're the server and

113
00:04:27,600 --> 00:04:29,600
take control of the device and this is

114
00:04:29,600 --> 00:04:31,840
the the trick that was used to flash

115
00:04:31,840 --> 00:04:34,560
custom firmware then

116
00:04:34,560 --> 00:04:36,720
and so

117
00:04:36,720 --> 00:04:37,919
when

118
00:04:37,919 --> 00:04:39,440
when we bought some of these lights for

119
00:04:39,440 --> 00:04:41,759
our home we figured okay we can just use

120
00:04:41,759 --> 00:04:44,560
this to your convert and uh our entire

121
00:04:44,560 --> 00:04:46,400
home will be cheaply filled with smart

122
00:04:46,400 --> 00:04:48,479
iot devices that we can do fun stuff

123
00:04:48,479 --> 00:04:49,520
with

124
00:04:49,520 --> 00:04:51,360
wrong

125
00:04:51,360 --> 00:04:53,440
at some point

126
00:04:53,440 --> 00:04:56,400
tuia the manufacturer of these devices

127
00:04:56,400 --> 00:05:00,400
and millions of devices like them they

128
00:05:00,400 --> 00:05:02,320
manufacture them white label for

129
00:05:02,320 --> 00:05:05,440
thousands of manufacturers

130
00:05:05,440 --> 00:05:07,120
they change their firmware they patch

131
00:05:07,120 --> 00:05:11,680
this stuff that michael found of course

132
00:05:11,680 --> 00:05:13,120
and from that point onwards the

133
00:05:13,120 --> 00:05:15,120
pre-shared key was no longer derived

134
00:05:15,120 --> 00:05:18,479
from stuff that you could see publicly

135
00:05:18,479 --> 00:05:19,840
instead it was

136
00:05:19,840 --> 00:05:21,600
seemingly we think

137
00:05:21,600 --> 00:05:24,160
generated randomly at the factory flash

138
00:05:24,160 --> 00:05:27,600
to the device unique per device

139
00:05:27,600 --> 00:05:30,479
and you could no longer see it

140
00:05:30,479 --> 00:05:31,680


141
00:05:31,680 --> 00:05:33,280
so now what

142
00:05:33,280 --> 00:05:35,520
we got a whole bunch of these lights and

143
00:05:35,520 --> 00:05:37,199
we cannot do anything with them other

144
00:05:37,199 --> 00:05:38,880
than let them happily connect to their

145
00:05:38,880 --> 00:05:40,560
servers

146
00:05:40,560 --> 00:05:42,639
of tuia

147
00:05:42,639 --> 00:05:44,160
so we figured okay if they're not

148
00:05:44,160 --> 00:05:45,919
vulnerable anymore

149
00:05:45,919 --> 00:05:47,600
we simply have to make them vulnerable

150
00:05:47,600 --> 00:05:50,400
again right how hard could it be

151
00:05:50,400 --> 00:05:52,720
and so

152
00:05:52,720 --> 00:05:55,520
there's a couple options we thought one

153
00:05:55,520 --> 00:05:58,000
we can obtain the psk again

154
00:05:58,000 --> 00:06:00,479
either leaking it or changing it to some

155
00:06:00,479 --> 00:06:01,759
some value

156
00:06:01,759 --> 00:06:03,840
that we want

157
00:06:03,840 --> 00:06:06,960
or we can try to downgrade this version

158
00:06:06,960 --> 00:06:09,039
two of the protocol back to version one

159
00:06:09,039 --> 00:06:10,479
that was vulnerable

160
00:06:10,479 --> 00:06:13,120
and then used to convert again

161
00:06:13,120 --> 00:06:14,160
or

162
00:06:14,160 --> 00:06:16,080
if all else fails

163
00:06:16,080 --> 00:06:17,840
we just get code execution on the light

164
00:06:17,840 --> 00:06:19,600
bulb right

165
00:06:19,600 --> 00:06:21,199
well you can you can guess where we

166
00:06:21,199 --> 00:06:23,680
ended up

167
00:06:25,039 --> 00:06:27,600
so first off we we started with this uh

168
00:06:27,600 --> 00:06:29,840
initial hardware uh revision of them

169
00:06:29,840 --> 00:06:32,240
this this was uh from light light bulbs

170
00:06:32,240 --> 00:06:36,000
we bought in 2019 i think

171
00:06:36,000 --> 00:06:37,400
it contained the

172
00:06:37,400 --> 00:06:39,759
esp8266 chip a very popular

173
00:06:39,759 --> 00:06:42,960
microcontroller that has wifi

174
00:06:42,960 --> 00:06:44,560
super popular and because it's super

175
00:06:44,560 --> 00:06:46,319
popular there's also a whole bunch of

176
00:06:46,319 --> 00:06:48,880
tooling that you could use we could dump

177
00:06:48,880 --> 00:06:50,639
the firmware from these light bulbs

178
00:06:50,639 --> 00:06:53,280
using esp tool a common tool for

179
00:06:53,280 --> 00:06:55,360
handling expressive chips

180
00:06:55,360 --> 00:06:56,880
you get a raw

181
00:06:56,880 --> 00:06:59,520
binary flash dump from that

182
00:06:59,520 --> 00:07:01,039
that you can then load into a tool

183
00:07:01,039 --> 00:07:03,520
called esp bin 12

184
00:07:03,520 --> 00:07:06,240
that gives you an elf executable image

185
00:07:06,240 --> 00:07:08,560
which you can load into gitra

186
00:07:08,560 --> 00:07:10,800
using an extension

187
00:07:10,800 --> 00:07:14,639
a module for extensor architecture

188
00:07:15,520 --> 00:07:17,039
then you uh

189
00:07:17,039 --> 00:07:18,960
you you analyze the the firmware you

190
00:07:18,960 --> 00:07:20,479
dumped and you find a whole bunch of

191
00:07:20,479 --> 00:07:22,160
functions that are not annotated they

192
00:07:22,160 --> 00:07:23,759
don't have symbols so you don't know

193
00:07:23,759 --> 00:07:24,960
what they do

194
00:07:24,960 --> 00:07:26,080
there's a

195
00:07:26,080 --> 00:07:28,720
simple trick that you can use to

196
00:07:28,720 --> 00:07:30,479
get at least symbols for many common

197
00:07:30,479 --> 00:07:32,160
functions

198
00:07:32,160 --> 00:07:34,479
um which is you just compile a demo

199
00:07:34,479 --> 00:07:35,840
application

200
00:07:35,840 --> 00:07:38,319
using the espresso sdk

201
00:07:38,319 --> 00:07:40,240
you analyze that in gitra and then you

202
00:07:40,240 --> 00:07:42,080
can you compare the footprints of

203
00:07:42,080 --> 00:07:43,840
functions with each other so you have a

204
00:07:43,840 --> 00:07:45,360
list of functions on the right the list

205
00:07:45,360 --> 00:07:46,879
of functions on the left and you can map

206
00:07:46,879 --> 00:07:47,599
them

207
00:07:47,599 --> 00:07:49,120
there's tools to do this but of course

208
00:07:49,120 --> 00:07:50,879
we didn't know about it back then so we

209
00:07:50,879 --> 00:07:51,919
uh we

210
00:07:51,919 --> 00:07:54,240
made a simple one of our own

211
00:07:54,240 --> 00:07:56,560
we mapped these functions and

212
00:07:56,560 --> 00:07:59,599
got a sort of lay of the land

213
00:07:59,599 --> 00:08:02,160
we found out that tuia the manufacturer

214
00:08:02,160 --> 00:08:06,000
runs free rtos on these devices

215
00:08:06,000 --> 00:08:08,560
uh in free rtos they they have a whole

216
00:08:08,560 --> 00:08:10,080
bunch of tasks

217
00:08:10,080 --> 00:08:12,400
one task the init task that starts all

218
00:08:12,400 --> 00:08:14,479
the other tasks

219
00:08:14,479 --> 00:08:15,680
and two

220
00:08:15,680 --> 00:08:17,919
to us particularly interesting ones a

221
00:08:17,919 --> 00:08:20,479
task called udp receiver

222
00:08:20,479 --> 00:08:21,280
which

223
00:08:21,280 --> 00:08:23,440
listens for broadcast

224
00:08:23,440 --> 00:08:25,280
traffic on the network

225
00:08:25,280 --> 00:08:28,160
and a task called smart frame task that

226
00:08:28,160 --> 00:08:31,120
handles commands that you send to it via

227
00:08:31,120 --> 00:08:32,320
including

228
00:08:32,320 --> 00:08:34,479
this udp receiver task

229
00:08:34,479 --> 00:08:36,640
and on top of this they have

230
00:08:36,640 --> 00:08:39,360
a bunch of drivers for controlling gpio

231
00:08:39,360 --> 00:08:40,640
and

232
00:08:40,640 --> 00:08:44,479
pwm peripherals and this kind of stuff

233
00:08:45,600 --> 00:08:47,920
all right so now how do we how do we get

234
00:08:47,920 --> 00:08:50,800
root on these things um we found that

235
00:08:50,800 --> 00:08:53,279
there's a bunch of keys used in this

236
00:08:53,279 --> 00:08:54,640
firmware

237
00:08:54,640 --> 00:08:56,480
the psk key that we talked about

238
00:08:56,480 --> 00:08:58,399
previously that encrypts the connection

239
00:08:58,399 --> 00:08:59,760
to the server

240
00:08:59,760 --> 00:09:01,040
you see that in

241
00:09:01,040 --> 00:09:04,000
yellow on the slide

242
00:09:04,000 --> 00:09:07,040
but also other ones and this we did

243
00:09:07,040 --> 00:09:09,120
did not know about before

244
00:09:09,120 --> 00:09:12,240
so data inside of this tls encrypted

245
00:09:12,240 --> 00:09:13,360
connection

246
00:09:13,360 --> 00:09:15,120
is encrypted and signed by something

247
00:09:15,120 --> 00:09:17,120
called the ask key

248
00:09:17,120 --> 00:09:19,680
which after you activate the device

249
00:09:19,680 --> 00:09:21,519
via their servers over the internet gets

250
00:09:21,519 --> 00:09:23,839
replaced by something called the sec key

251
00:09:23,839 --> 00:09:25,360
and all of that is separate from

252
00:09:25,360 --> 00:09:27,760
something called the local key

253
00:09:27,760 --> 00:09:30,080
which you obtain after activation with

254
00:09:30,080 --> 00:09:33,040
the server it's initially empty and

255
00:09:33,040 --> 00:09:35,360
after activation you you can you can get

256
00:09:35,360 --> 00:09:37,200
it to then

257
00:09:37,200 --> 00:09:38,880
use the device on your local network

258
00:09:38,880 --> 00:09:42,240
without an internet connection

259
00:09:42,480 --> 00:09:43,839
well we wanted to use it without

260
00:09:43,839 --> 00:09:45,279
connecting to the server in the first

261
00:09:45,279 --> 00:09:48,720
place right so our goal was to

262
00:09:48,720 --> 00:09:52,640
get ownership of these keys somehow

263
00:09:52,640 --> 00:09:56,000
without connecting to tuia

264
00:09:58,000 --> 00:10:00,480
and for this part i will hand over to

265
00:10:00,480 --> 00:10:02,640
helet yes

266
00:10:02,640 --> 00:10:03,760
so

267
00:10:03,760 --> 00:10:06,160
we've um analyzed and reverse engineered

268
00:10:06,160 --> 00:10:08,320
the firmware for uh this particular

269
00:10:08,320 --> 00:10:11,040
revision for quite a while we actually

270
00:10:11,040 --> 00:10:13,040
uh stumbled on a few vulnerabilities

271
00:10:13,040 --> 00:10:16,240
throughout our analysis however as luck

272
00:10:16,240 --> 00:10:18,399
would have it we would not actually end

273
00:10:18,399 --> 00:10:19,839
up exploiting these particular

274
00:10:19,839 --> 00:10:21,839
vulnerabilities so

275
00:10:21,839 --> 00:10:23,680
there's more later of course otherwise

276
00:10:23,680 --> 00:10:26,000
the talk would pretty much end here but

277
00:10:26,000 --> 00:10:27,839
um yeah so we think these

278
00:10:27,839 --> 00:10:28,959
vulnerabilities are interesting

279
00:10:28,959 --> 00:10:30,640
nonetheless we would like to

280
00:10:30,640 --> 00:10:32,959
share you and share them with you and

281
00:10:32,959 --> 00:10:35,600
let's start with the first one

282
00:10:35,600 --> 00:10:37,200
so

283
00:10:37,200 --> 00:10:38,480
what you see in front of you on the

284
00:10:38,480 --> 00:10:41,040
slide right now is a function in the

285
00:10:41,040 --> 00:10:44,240
firmware it generates a random string

286
00:10:44,240 --> 00:10:45,680
you see it takes three parameters the

287
00:10:45,680 --> 00:10:48,240
first one is completely unused uh the

288
00:10:48,240 --> 00:10:50,560
second one is a character pointer it's

289
00:10:50,560 --> 00:10:53,279
really a pointer to a buffer and then uh

290
00:10:53,279 --> 00:10:55,440
actually the maximum length which is

291
00:10:55,440 --> 00:10:57,120
essentially the length of the buffer

292
00:10:57,120 --> 00:10:58,160
itself

293
00:10:58,160 --> 00:11:00,320
what the function does very briefly is

294
00:11:00,320 --> 00:11:03,279
it takes the current time and do keep in

295
00:11:03,279 --> 00:11:05,839
mind these devices are

296
00:11:05,839 --> 00:11:08,640
set up without a real-time clock

297
00:11:08,640 --> 00:11:10,399
working so essentially this really is

298
00:11:10,399 --> 00:11:12,959
just a counter from the boot time of the

299
00:11:12,959 --> 00:11:16,079
device it just keeps incrementing uh

300
00:11:16,079 --> 00:11:17,839
every second sort of

301
00:11:17,839 --> 00:11:20,880
um and it takes that it um generates

302
00:11:20,880 --> 00:11:24,320
some index uh in it and it indexes into

303
00:11:24,320 --> 00:11:26,480
this interesting string that's

304
00:11:26,480 --> 00:11:28,480
highlighted in red uh this kind of an

305
00:11:28,480 --> 00:11:30,240
artifact from guidrock because that's

306
00:11:30,240 --> 00:11:32,320
where we copied the code from but this

307
00:11:32,320 --> 00:11:36,560
is essentially this really massive uh

308
00:11:36,560 --> 00:11:39,040
long string that is hard coded in the

309
00:11:39,040 --> 00:11:41,440
firmware and

310
00:11:41,440 --> 00:11:43,600
basically what this function does is it

311
00:11:43,600 --> 00:11:46,399
uh it takes a substring of that returns

312
00:11:46,399 --> 00:11:49,279
it and calls it random uh now that's

313
00:11:49,279 --> 00:11:51,760
obviously uh not very random

314
00:11:51,760 --> 00:11:53,680
but of course you know for a lot of

315
00:11:53,680 --> 00:11:55,680
things um

316
00:11:55,680 --> 00:11:57,120
yeah you don't really need a

317
00:11:57,120 --> 00:11:59,200
cryptographically secure uh random

318
00:11:59,200 --> 00:12:00,880
number generator or something of the

319
00:12:00,880 --> 00:12:03,279
sort so would have been fine if you

320
00:12:03,279 --> 00:12:05,600
maybe perhaps come up with a

321
00:12:05,600 --> 00:12:06,959
construction like this for other

322
00:12:06,959 --> 00:12:10,320
purposes however if you use it for tls

323
00:12:10,320 --> 00:12:12,320
then you have other sort of problems

324
00:12:12,320 --> 00:12:14,880
um what we ended up finding out is if

325
00:12:14,880 --> 00:12:16,800
you were to look at the

326
00:12:16,800 --> 00:12:18,000
traffic

327
00:12:18,000 --> 00:12:21,440
between the device and the cloud server

328
00:12:21,440 --> 00:12:24,560
just zooming in here on the client hello

329
00:12:24,560 --> 00:12:26,959
message from the client to the server

330
00:12:26,959 --> 00:12:29,200
you'll see that the random field that's

331
00:12:29,200 --> 00:12:31,279
highlighted in blue

332
00:12:31,279 --> 00:12:34,959
and also in the dump you see it

333
00:12:34,959 --> 00:12:37,680
bordered by red is essentially pretty

334
00:12:37,680 --> 00:12:38,480
much

335
00:12:38,480 --> 00:12:40,320
the first part like the first 30

336
00:12:40,320 --> 00:12:42,720
something characters of that very very

337
00:12:42,720 --> 00:12:46,240
long string now in this particular setup

338
00:12:46,240 --> 00:12:48,639
because they use tls with uh pre-shared

339
00:12:48,639 --> 00:12:51,040
keys this isn't actually much of an

340
00:12:51,040 --> 00:12:54,000
issue uh we actually talked to a friend

341
00:12:54,000 --> 00:12:56,880
who did quite a bit of research on tls

342
00:12:56,880 --> 00:12:59,040
and um we were wondering if this could

343
00:12:59,040 --> 00:13:02,000
be exploitable in the tls psk setup

344
00:13:02,000 --> 00:13:04,880
however turns out tls 1.2 and up are

345
00:13:04,880 --> 00:13:07,760
actually quite resilient protocols and

346
00:13:07,760 --> 00:13:09,360
this doesn't immediately lead to a

347
00:13:09,360 --> 00:13:11,760
vulnerability as far as we know

348
00:13:11,760 --> 00:13:13,200
however

349
00:13:13,200 --> 00:13:14,639
why do we think this vulnerability is

350
00:13:14,639 --> 00:13:17,040
interesting is should they at any point

351
00:13:17,040 --> 00:13:19,760
switch to using cypher suites that uh

352
00:13:19,760 --> 00:13:20,800
actually

353
00:13:20,800 --> 00:13:23,200
utilize a key exchange mechanism such as

354
00:13:23,200 --> 00:13:26,399
diffie-hellman merkle key exchanges um

355
00:13:26,399 --> 00:13:28,480
using perhaps certificates for

356
00:13:28,480 --> 00:13:31,120
validating uh the exchange process then

357
00:13:31,120 --> 00:13:33,040
this would immediately yield a

358
00:13:33,040 --> 00:13:34,959
man-in-the-middle attack because now

359
00:13:34,959 --> 00:13:38,160
that you have the client random

360
00:13:38,160 --> 00:13:40,560
which you can guess with a relatively

361
00:13:40,560 --> 00:13:42,880
high frequency and figure out what the

362
00:13:42,880 --> 00:13:45,519
correct value is if you just capture

363
00:13:45,519 --> 00:13:48,320
the first few handshakes between a

364
00:13:48,320 --> 00:13:50,240
client and a server then you can just go

365
00:13:50,240 --> 00:13:53,519
ahead and derive the tls pre-master key

366
00:13:53,519 --> 00:13:56,320
once just keep reusing it over and over

367
00:13:56,320 --> 00:13:57,839
and

368
00:13:57,839 --> 00:14:01,040
that's pretty much a win

369
00:14:01,519 --> 00:14:05,040
we did some more analysis um now

370
00:14:05,040 --> 00:14:08,160
we found some uh protocols as tom

371
00:14:08,160 --> 00:14:10,800
mentioned there were some uh function

372
00:14:10,800 --> 00:14:12,480
handlers that were handling messages

373
00:14:12,480 --> 00:14:15,120
from the network uh some of them

374
00:14:15,120 --> 00:14:17,199
were actually handling uh

375
00:14:17,199 --> 00:14:19,040
messages from devices on the on the

376
00:14:19,040 --> 00:14:21,839
local network um

377
00:14:21,839 --> 00:14:24,000
in particular these messages were uh

378
00:14:24,000 --> 00:14:26,320
completely unencrypted so we we thought

379
00:14:26,320 --> 00:14:28,240
that they would be uh interesting

380
00:14:28,240 --> 00:14:30,639
candidates to look at the functions that

381
00:14:30,639 --> 00:14:33,199
parse and handle them because well yeah

382
00:14:33,199 --> 00:14:35,040
those are ones that we can easily reach

383
00:14:35,040 --> 00:14:37,360
we don't need any keys to send messages

384
00:14:37,360 --> 00:14:38,720
to these handlers

385
00:14:38,720 --> 00:14:41,040
and so we did and we ended up finding

386
00:14:41,040 --> 00:14:43,760
two bugs there a stack buffer overflow

387
00:14:43,760 --> 00:14:44,720
in the

388
00:14:44,720 --> 00:14:47,440
function that parses it

389
00:14:47,440 --> 00:14:49,839
and a heap buffer overflow and the same

390
00:14:49,839 --> 00:14:52,320
function but for a different message

391
00:14:52,320 --> 00:14:54,639
for the stack buffer overflow

392
00:14:54,639 --> 00:14:56,560
the function is implemented as a free

393
00:14:56,560 --> 00:14:59,199
rtos task what that really kind of means

394
00:14:59,199 --> 00:15:01,519
in traditional terms is it's a long

395
00:15:01,519 --> 00:15:04,160
running process it's essentially in this

396
00:15:04,160 --> 00:15:05,279
case a

397
00:15:05,279 --> 00:15:07,519
an infinite loop that just keeps on

398
00:15:07,519 --> 00:15:10,000
running waiting for messages to come in

399
00:15:10,000 --> 00:15:10,959
and

400
00:15:10,959 --> 00:15:12,959
for every message it just parses it does

401
00:15:12,959 --> 00:15:16,639
some handling etc now um we had control

402
00:15:16,639 --> 00:15:19,519
over the the stack somewhat it was a

403
00:15:19,519 --> 00:15:21,920
bug where we as long as we are not

404
00:15:21,920 --> 00:15:24,320
writing null bytes we can uh modify the

405
00:15:24,320 --> 00:15:27,120
contents on the stack at the location of

406
00:15:27,120 --> 00:15:28,880
the vulnerability

407
00:15:28,880 --> 00:15:30,959
and that allowed us to overwrite the

408
00:15:30,959 --> 00:15:32,800
return address

409
00:15:32,800 --> 00:15:34,639
should be a win right we should be able

410
00:15:34,639 --> 00:15:35,839
to just uh

411
00:15:35,839 --> 00:15:37,199
go ahead and

412
00:15:37,199 --> 00:15:40,160
take control of uh of course take

413
00:15:40,160 --> 00:15:41,920
control of the code flow and then

414
00:15:41,920 --> 00:15:44,399
perhaps do something useful however

415
00:15:44,399 --> 00:15:46,240
well yeah it's an infinitely running

416
00:15:46,240 --> 00:15:48,399
process it at no point does it ever

417
00:15:48,399 --> 00:15:49,360
return

418
00:15:49,360 --> 00:15:51,360
we could not find a way to maybe trigger

419
00:15:51,360 --> 00:15:53,519
it into a fault mode that would have it

420
00:15:53,519 --> 00:15:56,160
to do an early return or some such

421
00:15:56,160 --> 00:15:58,959
and sadly also analyzing the

422
00:15:58,959 --> 00:16:00,320
stack

423
00:16:00,320 --> 00:16:02,480
parameters around it we couldn't really

424
00:16:02,480 --> 00:16:04,639
find anything interesting that we could

425
00:16:04,639 --> 00:16:05,839
use to

426
00:16:05,839 --> 00:16:08,160
make it do something a little bit more

427
00:16:08,160 --> 00:16:10,320
so essentially we could just crash it

428
00:16:10,320 --> 00:16:12,399
and that was pretty much it

429
00:16:12,399 --> 00:16:14,639
for the heat buffer overflow kind of a

430
00:16:14,639 --> 00:16:17,600
similar story we could manipulate the

431
00:16:17,600 --> 00:16:20,480
metadata of the blocks that the heap

432
00:16:20,480 --> 00:16:21,759
allocator

433
00:16:21,759 --> 00:16:24,160
takes uh keeps track of

434
00:16:24,160 --> 00:16:26,160
for allocations and freeze

435
00:16:26,160 --> 00:16:27,920
um

436
00:16:27,920 --> 00:16:29,279
we actually

437
00:16:29,279 --> 00:16:31,279
so we decided to study it a little bit

438
00:16:31,279 --> 00:16:33,120
and we found out that

439
00:16:33,120 --> 00:16:35,440
tuia has just modified one of the heap

440
00:16:35,440 --> 00:16:37,040
implementations that's provided with

441
00:16:37,040 --> 00:16:39,839
free rtos

442
00:16:40,320 --> 00:16:41,199
but

443
00:16:41,199 --> 00:16:43,120
doing so far we've done all of this

444
00:16:43,120 --> 00:16:44,880
statically right we're just we have

445
00:16:44,880 --> 00:16:46,639
guidro open we've got our decompiler

446
00:16:46,639 --> 00:16:48,800
disassemblers and we're just kind of

447
00:16:48,800 --> 00:16:51,839
analyzing code manually going through it

448
00:16:51,839 --> 00:16:53,040
by hand

449
00:16:53,040 --> 00:16:54,560
but when it comes to things like

450
00:16:54,560 --> 00:16:56,240
allocate or misuse

451
00:16:56,240 --> 00:16:57,440
bugs it's

452
00:16:57,440 --> 00:16:59,120
at least in my experience a bit more

453
00:16:59,120 --> 00:17:01,920
tricky to do that just by hand

454
00:17:01,920 --> 00:17:04,319
usually it's quite nice to see if you

455
00:17:04,319 --> 00:17:06,160
can get some dynamic analysis going so

456
00:17:06,160 --> 00:17:08,480
some debugging getting a bit of an

457
00:17:08,480 --> 00:17:10,319
understanding of what's actually

458
00:17:10,319 --> 00:17:11,919
happening in memory when you're doing

459
00:17:11,919 --> 00:17:13,439
all sorts of stuff

460
00:17:13,439 --> 00:17:16,559
so we decided to take a little uh detour

461
00:17:16,559 --> 00:17:18,880
then and

462
00:17:18,880 --> 00:17:21,119
somehow rediscovered a

463
00:17:21,119 --> 00:17:23,839
nice hardware hacking technique which is

464
00:17:23,839 --> 00:17:26,079
if we just trigger the conditions that

465
00:17:26,079 --> 00:17:27,760
we want on the device

466
00:17:27,760 --> 00:17:30,480
reset it into boot rom and then use esp

467
00:17:30,480 --> 00:17:32,480
tool the tool that was already there we

468
00:17:32,480 --> 00:17:34,640
could actually get a really nice ram

469
00:17:34,640 --> 00:17:37,039
dump of the contents of memory at the

470
00:17:37,039 --> 00:17:39,520
time we triggered this process

471
00:17:39,520 --> 00:17:40,640
and

472
00:17:40,640 --> 00:17:42,400
turns out you can just take this ram

473
00:17:42,400 --> 00:17:45,200
dump and overlay it onto your

474
00:17:45,200 --> 00:17:47,520
binary in ghidra it supports that was

475
00:17:47,520 --> 00:17:49,760
quite nice and then you can kind of see

476
00:17:49,760 --> 00:17:51,440
so in this particular screenshot you

477
00:17:51,440 --> 00:17:53,200
actually see one of the the blocks of

478
00:17:53,200 --> 00:17:55,840
the uh heap allocator that the heap

479
00:17:55,840 --> 00:17:57,200
allocator used

480
00:17:57,200 --> 00:17:58,720
and you can kind of see the connections

481
00:17:58,720 --> 00:18:01,360
between them so it's a bit more of a

482
00:18:01,360 --> 00:18:03,520
hybrid you're not just reverse

483
00:18:03,520 --> 00:18:05,360
engineering code you also get some data

484
00:18:05,360 --> 00:18:07,039
in there and you can kind of see how

485
00:18:07,039 --> 00:18:08,160
this

486
00:18:08,160 --> 00:18:10,640
data relates to the instructions that

487
00:18:10,640 --> 00:18:12,960
act upon it

488
00:18:12,960 --> 00:18:15,360
we went a step further actually

489
00:18:15,360 --> 00:18:18,880
um so searching on the internet for uh

490
00:18:18,880 --> 00:18:22,080
uh if we can do uh on-chip debugging

491
00:18:22,080 --> 00:18:25,039
with the esp8266 yielded a whole lot of

492
00:18:25,039 --> 00:18:28,240
no's but there was one yes there was one

493
00:18:28,240 --> 00:18:31,840
tutorial about using visual gdb

494
00:18:31,840 --> 00:18:36,240
to debug applications on the esp8266

495
00:18:36,240 --> 00:18:37,280
however

496
00:18:37,280 --> 00:18:39,440
we would have preferred to utilize

497
00:18:39,440 --> 00:18:41,679
just gdb and open ocd those are the

498
00:18:41,679 --> 00:18:43,840
tools that we're more familiar with so

499
00:18:43,840 --> 00:18:46,799
what we did is we uh took a uh we forked

500
00:18:46,799 --> 00:18:49,679
uh the binital gdb extensor

501
00:18:49,679 --> 00:18:51,919
that's actually been tailored for the

502
00:18:51,919 --> 00:18:54,799
esp32 modified it just a little bit to

503
00:18:54,799 --> 00:18:57,760
get it to to work nicely with the

504
00:18:57,760 --> 00:18:59,600
esp8266

505
00:18:59,600 --> 00:19:02,240
and got some help from some people on

506
00:19:02,240 --> 00:19:04,880
getting open ocd running properly with

507
00:19:04,880 --> 00:19:06,559
our debuggers of choice

508
00:19:06,559 --> 00:19:09,360
uh for the esp8266

509
00:19:09,360 --> 00:19:10,400
now

510
00:19:10,400 --> 00:19:13,039
this helped us a lot we actually were

511
00:19:13,039 --> 00:19:14,080
able to

512
00:19:14,080 --> 00:19:16,160
debug what's happening

513
00:19:16,160 --> 00:19:17,360
on the chip as we're triggering the

514
00:19:17,360 --> 00:19:20,720
vulnerabilities and see how things

515
00:19:20,720 --> 00:19:23,679
progress and put breakpoints sadly just

516
00:19:23,679 --> 00:19:25,200
one break point

517
00:19:25,200 --> 00:19:26,880
so it was a bit of a monkey jumping

518
00:19:26,880 --> 00:19:28,559
around with that one break point it was

519
00:19:28,559 --> 00:19:31,280
not a very nice experience

520
00:19:31,280 --> 00:19:34,160
but it is what it is uh we got somewhere

521
00:19:34,160 --> 00:19:36,400
where we didn't expect to uh

522
00:19:36,400 --> 00:19:38,799
unfortunately as we analyzed it more and

523
00:19:38,799 --> 00:19:41,520
more uh we realized that the conditions

524
00:19:41,520 --> 00:19:44,400
for that heap uh buffer overflow um in

525
00:19:44,400 --> 00:19:46,240
the ways that we found that we could

526
00:19:46,240 --> 00:19:48,400
possibly abuse it would actually need us

527
00:19:48,400 --> 00:19:50,720
to be able to write null bytes uh in

528
00:19:50,720 --> 00:19:52,960
locations where which are not at the end

529
00:19:52,960 --> 00:19:54,720
of that string which we could have

530
00:19:54,720 --> 00:19:57,039
possibly been able to do uh however we

531
00:19:57,039 --> 00:19:58,400
really needed to do it somewhere in the

532
00:19:58,400 --> 00:20:01,039
middle just to get it to to uh trigger

533
00:20:01,039 --> 00:20:03,600
rights just the right way uh so

534
00:20:03,600 --> 00:20:05,840
unfortunately this particular bug was

535
00:20:05,840 --> 00:20:09,200
not usable in this case

536
00:20:09,200 --> 00:20:12,240
so uh kind of wrapping up this stage of

537
00:20:12,240 --> 00:20:13,520
our research

538
00:20:13,520 --> 00:20:15,440
we found a few bugs that as i said

539
00:20:15,440 --> 00:20:17,120
weren't easily exploitable one of them

540
00:20:17,120 --> 00:20:19,039
actually didn't really apply at all but

541
00:20:19,039 --> 00:20:20,559
we thought it was really cool the tls

542
00:20:20,559 --> 00:20:21,600
one

543
00:20:21,600 --> 00:20:22,880
should they ever

544
00:20:22,880 --> 00:20:25,200
move to some sort of implementation with

545
00:20:25,200 --> 00:20:28,240
key exchange mechanisms then that that

546
00:20:28,240 --> 00:20:30,960
would immediately yield an attack

547
00:20:30,960 --> 00:20:33,679
we kind of rediscovered a nice technique

548
00:20:33,679 --> 00:20:35,440
or at least we thought it was quite nice

549
00:20:35,440 --> 00:20:37,440
we got debugging working

550
00:20:37,440 --> 00:20:40,960
and more importantly we learned a lot

551
00:20:40,960 --> 00:20:43,200
about tui stack

552
00:20:43,200 --> 00:20:44,799
this would actually

553
00:20:44,799 --> 00:20:46,880
kind of be the most critical point of

554
00:20:46,880 --> 00:20:48,960
our journey with the the

555
00:20:48,960 --> 00:20:50,720
first revision of the devices as it

556
00:20:50,720 --> 00:20:51,440
would

557
00:20:51,440 --> 00:20:54,720
actually help us a lot in the next stage

558
00:20:54,720 --> 00:20:57,360
and speaking of the next stage moving to

559
00:20:57,360 --> 00:20:59,600
tom

560
00:21:01,200 --> 00:21:03,840
so a few months passed

561
00:21:03,840 --> 00:21:05,200
we

562
00:21:05,200 --> 00:21:07,919
had no progress on the on the esp

563
00:21:07,919 --> 00:21:10,240
um but still we were curious of course

564
00:21:10,240 --> 00:21:12,960
and uh one of us i forget who went to

565
00:21:12,960 --> 00:21:15,919
the action bought more of these lights

566
00:21:15,919 --> 00:21:17,679
different types

567
00:21:17,679 --> 00:21:21,440
and we got we got a bit startled

568
00:21:21,600 --> 00:21:23,200
because all of a sudden there was not an

569
00:21:23,200 --> 00:21:24,720
esp8266

570
00:21:24,720 --> 00:21:27,440
in there anymore but the new chip

571
00:21:27,440 --> 00:21:28,559
chinese

572
00:21:28,559 --> 00:21:30,559
manufacturer beckon

573
00:21:30,559 --> 00:21:32,000
we didn't know anything about it a

574
00:21:32,000 --> 00:21:35,000
bk7231

575
00:21:35,360 --> 00:21:37,520
and we thought oh my god has all of our

576
00:21:37,520 --> 00:21:39,600
research been in vain did they just swap

577
00:21:39,600 --> 00:21:44,000
out a new chip everything is different

578
00:21:44,000 --> 00:21:45,200
um

579
00:21:45,200 --> 00:21:47,520
so we went in search for a data sheet of

580
00:21:47,520 --> 00:21:50,480
this new mystery chip

581
00:21:50,480 --> 00:21:52,960
we searched on mauser and digi-key even

582
00:21:52,960 --> 00:21:56,240
chinese lcsc

583
00:21:56,960 --> 00:21:58,400
we could not find

584
00:21:58,400 --> 00:22:00,960
anyone supplying this chip and having a

585
00:22:00,960 --> 00:22:02,559
data sheet for it

586
00:22:02,559 --> 00:22:05,840
not on the western internet anyway

587
00:22:05,840 --> 00:22:08,240
by due to the rescue so why do a chinese

588
00:22:08,240 --> 00:22:09,679
search engine

589
00:22:09,679 --> 00:22:11,679
is used

590
00:22:11,679 --> 00:22:14,000
almost exclusively in china

591
00:22:14,000 --> 00:22:15,919
of course when we searched there we we

592
00:22:15,919 --> 00:22:18,960
got a whole lot further

593
00:22:19,440 --> 00:22:21,440
some translations later

594
00:22:21,440 --> 00:22:23,440
we we got the data sheet for this for

595
00:22:23,440 --> 00:22:24,840
this

596
00:22:24,840 --> 00:22:27,520
chip inside of the datasheet it's

597
00:22:27,520 --> 00:22:29,919
mentioned that there's an arm9 core

598
00:22:29,919 --> 00:22:31,919
inside

599
00:22:31,919 --> 00:22:34,080
of a specific type

600
00:22:34,080 --> 00:22:36,640
and that arm 9 core that you can find on

601
00:22:36,640 --> 00:22:38,880
the western internet very easily

602
00:22:38,880 --> 00:22:40,880
from there you can get the reference

603
00:22:40,880 --> 00:22:43,280
manual and see all kinds of things about

604
00:22:43,280 --> 00:22:45,200
the debug peripherals it has what kind

605
00:22:45,200 --> 00:22:47,440
of memory mapping is inside and this

606
00:22:47,440 --> 00:22:50,880
gave us a whole lot of information on

607
00:22:50,880 --> 00:22:54,480
how to analyze this new device

608
00:22:54,480 --> 00:22:56,720
and what was even more interesting

609
00:22:56,720 --> 00:22:58,559
is what happened when you searched for

610
00:22:58,559 --> 00:23:00,559
this chip on the western internet not

611
00:23:00,559 --> 00:23:02,400
for a data sheet but just the chip name

612
00:23:02,400 --> 00:23:03,919
itself

613
00:23:03,919 --> 00:23:06,799
we came to this very interesting looking

614
00:23:06,799 --> 00:23:09,840
github repository

615
00:23:11,200 --> 00:23:13,520
do we now have an open source implement

616
00:23:13,520 --> 00:23:14,960
implementation from tuija the

617
00:23:14,960 --> 00:23:17,200
manufacturer of this device

618
00:23:17,200 --> 00:23:19,760
for the sdk

619
00:23:19,760 --> 00:23:22,240
yeah it turned out we did they

620
00:23:22,240 --> 00:23:23,760
completely open sourced all of their

621
00:23:23,760 --> 00:23:24,720
stuff

622
00:23:24,720 --> 00:23:26,159
the sdk

623
00:23:26,159 --> 00:23:28,480
example applications that we found out

624
00:23:28,480 --> 00:23:30,320
are being used by manufacturers of these

625
00:23:30,320 --> 00:23:31,200
lights

626
00:23:31,200 --> 00:23:33,200
almost exclusively

627
00:23:33,200 --> 00:23:35,600
it's all there

628
00:23:35,600 --> 00:23:38,480
of course some of the internals are in

629
00:23:38,480 --> 00:23:41,760
in binary blob libraries

630
00:23:41,760 --> 00:23:43,520
but because they're part of the sdk you

631
00:23:43,520 --> 00:23:45,440
need to be able to link against them

632
00:23:45,440 --> 00:23:46,720
which means that they need to have

633
00:23:46,720 --> 00:23:49,679
symbols which means that now

634
00:23:49,679 --> 00:23:51,520
we can load the library into git drive

635
00:23:51,520 --> 00:23:52,880
we have a complete list of function

636
00:23:52,880 --> 00:23:55,039
names and this kind of stuff structures

637
00:23:55,039 --> 00:23:56,960
so that you can imagine you this helps

638
00:23:56,960 --> 00:23:59,520
tremendously in reverse engineering

639
00:23:59,520 --> 00:24:02,559
and so it did for us

640
00:24:02,559 --> 00:24:04,240
one thing that's interesting is that

641
00:24:04,240 --> 00:24:06,159
they named this new real-time operating

642
00:24:06,159 --> 00:24:08,320
system iot os

643
00:24:08,320 --> 00:24:10,640
and so we were curious to see

644
00:24:10,640 --> 00:24:12,559
if we would have to learn

645
00:24:12,559 --> 00:24:15,039
a different os in our future endeavors

646
00:24:15,039 --> 00:24:17,120
but luckily it ends up

647
00:24:17,120 --> 00:24:20,720
we do not it's just free rtos with some

648
00:24:20,720 --> 00:24:25,120
sauce of them of tuija on top of it

649
00:24:27,120 --> 00:24:29,120
so not only did we not lose progress we

650
00:24:29,120 --> 00:24:31,360
actually gained a lot the stack is still

651
00:24:31,360 --> 00:24:33,919
the same but now we have the source

652
00:24:33,919 --> 00:24:36,000
we have all the symbol names

653
00:24:36,000 --> 00:24:37,840
we have a lot nicer time debugging

654
00:24:37,840 --> 00:24:40,400
because this arm core chip

655
00:24:40,400 --> 00:24:44,080
supports a lot easier debugging than the

656
00:24:44,080 --> 00:24:45,760
espressif chip does

657
00:24:45,760 --> 00:24:47,440
it just has a jtag interface you can

658
00:24:47,440 --> 00:24:49,679
connect to

659
00:24:49,679 --> 00:24:53,120
and so now we uh we dove in again

660
00:24:53,120 --> 00:24:54,400
and for this part i'll hand over to

661
00:24:54,400 --> 00:24:56,960
health again

662
00:24:56,960 --> 00:24:58,880
right

663
00:24:58,880 --> 00:25:01,360
so as tom mentioned

664
00:25:01,360 --> 00:25:04,240
the sdk and the blobs in it actually

665
00:25:04,240 --> 00:25:06,080
helped us quite a lot

666
00:25:06,080 --> 00:25:08,320
we thought hey we could get a really

667
00:25:08,320 --> 00:25:10,480
nice uh

668
00:25:10,480 --> 00:25:12,480
quick start on on analyzing this

669
00:25:12,480 --> 00:25:15,279
particular new revision by just well

670
00:25:15,279 --> 00:25:17,840
looking at the sdk itself

671
00:25:17,840 --> 00:25:20,880
so i started reverse engineering uh sort

672
00:25:20,880 --> 00:25:23,279
of it is mostly simplificated easy to go

673
00:25:23,279 --> 00:25:24,400
through

674
00:25:24,400 --> 00:25:25,120
the

675
00:25:25,120 --> 00:25:28,159
binary blobs that we found in the sdk

676
00:25:28,159 --> 00:25:29,039
and

677
00:25:29,039 --> 00:25:31,039
because we've already seen quite a lot

678
00:25:31,039 --> 00:25:33,039
of what tuia does we've been

679
00:25:33,039 --> 00:25:35,120
familiarized with the protocols had a

680
00:25:35,120 --> 00:25:37,039
pretty good idea of okay what are the

681
00:25:37,039 --> 00:25:39,360
usual suspect protocols that have some

682
00:25:39,360 --> 00:25:42,000
interface to the outside world that we

683
00:25:42,000 --> 00:25:44,480
can perhaps control so i started looking

684
00:25:44,480 --> 00:25:45,919
through these and

685
00:25:45,919 --> 00:25:48,480
um i stumbled upon this particular uh

686
00:25:48,480 --> 00:25:51,600
piece of code it's kind of condensed

687
00:25:51,600 --> 00:25:53,679
from the original of course just for uh

688
00:25:53,679 --> 00:25:55,360
for visuals

689
00:25:55,360 --> 00:25:58,080
but essentially what this is is a task

690
00:25:58,080 --> 00:26:00,960
definition for a free rtos task that the

691
00:26:00,960 --> 00:26:02,480
device runs when you set it in a

692
00:26:02,480 --> 00:26:04,559
particular configuration mode you do so

693
00:26:04,559 --> 00:26:05,520
by

694
00:26:05,520 --> 00:26:07,520
power cycling the device a specific

695
00:26:07,520 --> 00:26:09,120
number of times

696
00:26:09,120 --> 00:26:12,080
this sits at in what's called ap mode

697
00:26:12,080 --> 00:26:14,159
where the device essentially broadcasts

698
00:26:14,159 --> 00:26:17,520
an uh an access point and you connect to

699
00:26:17,520 --> 00:26:19,760
it with your with your mobile phone and

700
00:26:19,760 --> 00:26:21,840
you have uh two years app or any of

701
00:26:21,840 --> 00:26:24,559
their other rebranded apps on your phone

702
00:26:24,559 --> 00:26:27,039
which has a nice ui it tells you exactly

703
00:26:27,039 --> 00:26:29,760
what to do to get that device onboarded

704
00:26:29,760 --> 00:26:31,200
onto your home

705
00:26:31,200 --> 00:26:34,720
access point with your home network

706
00:26:34,880 --> 00:26:37,440
what this function does then is it uh

707
00:26:37,440 --> 00:26:41,120
actually listens on uh that uh access ap

708
00:26:41,120 --> 00:26:44,080
network it listens for udp messages

709
00:26:44,080 --> 00:26:46,640
um that the application sends

710
00:26:46,640 --> 00:26:49,440
and what these messages look like as an

711
00:26:49,440 --> 00:26:51,520
example shown on the right essentially

712
00:26:51,520 --> 00:26:53,919
it's pretty simple it's some simple

713
00:26:53,919 --> 00:26:57,120
format it's a type length value around a

714
00:26:57,120 --> 00:26:59,760
json blob completely unencrypted the app

715
00:26:59,760 --> 00:27:01,760
just sends that when it gets the

716
00:27:01,760 --> 00:27:04,240
parameters from you the user

717
00:27:04,240 --> 00:27:06,480
the first two parameters are the s id

718
00:27:06,480 --> 00:27:08,480
and the passphrase that's your uh home

719
00:27:08,480 --> 00:27:10,640
network configuration parameters that it

720
00:27:10,640 --> 00:27:12,880
will use to connect uh the last one is a

721
00:27:12,880 --> 00:27:15,200
token that it actually gets from the

722
00:27:15,200 --> 00:27:17,440
from 2s servers and it's essentially

723
00:27:17,440 --> 00:27:21,120
just used to get the device to initially

724
00:27:21,120 --> 00:27:24,640
authenticate with the server

725
00:27:24,640 --> 00:27:25,520
so

726
00:27:25,520 --> 00:27:28,240
um looking on the left side how it's

727
00:27:28,240 --> 00:27:31,679
being parsed it's just uh using cjson a

728
00:27:31,679 --> 00:27:36,240
a small library for parsing jason in c

729
00:27:36,240 --> 00:27:38,480
it's used quite uh quite heavily in

730
00:27:38,480 --> 00:27:39,600
embedded

731
00:27:39,600 --> 00:27:41,919
embedded projects as we've seen

732
00:27:41,919 --> 00:27:45,679
um so just use cjson takes that json

733
00:27:45,679 --> 00:27:48,240
payload parses it and then it gets the

734
00:27:48,240 --> 00:27:51,200
data and then copies it into some

735
00:27:51,200 --> 00:27:52,960
structure so there's some global

736
00:27:52,960 --> 00:27:54,720
structures of this lan access point

737
00:27:54,720 --> 00:27:57,120
network config and

738
00:27:57,120 --> 00:27:59,919
it copies the parameters in it

739
00:27:59,919 --> 00:28:02,640
we noticed one particular interesting

740
00:28:02,640 --> 00:28:04,880
copy over here it's highlighted in in

741
00:28:04,880 --> 00:28:07,120
red i hope you can see it

742
00:28:07,120 --> 00:28:10,000
for specifically the token field uh from

743
00:28:10,000 --> 00:28:11,200
the token on the right the ap

744
00:28:11,200 --> 00:28:12,720
configuration token

745
00:28:12,720 --> 00:28:14,320
um the copy process is slightly

746
00:28:14,320 --> 00:28:17,200
different than the other two fields why

747
00:28:17,200 --> 00:28:19,120
not sure

748
00:28:19,120 --> 00:28:20,399
but

749
00:28:20,399 --> 00:28:22,720
what we saw is that the token length is

750
00:28:22,720 --> 00:28:24,720
first calculated as a c string so it

751
00:28:24,720 --> 00:28:27,600
calls strollen on it gets the length of

752
00:28:27,600 --> 00:28:31,279
that and then uses mem copy to copy

753
00:28:31,279 --> 00:28:32,559
that much

754
00:28:32,559 --> 00:28:33,840
data that it just calculated with

755
00:28:33,840 --> 00:28:36,480
sterling into that field

756
00:28:36,480 --> 00:28:37,840
okay

757
00:28:37,840 --> 00:28:40,240
could be okay but there are no no checks

758
00:28:40,240 --> 00:28:41,520
on it

759
00:28:41,520 --> 00:28:43,840
but it depends on how big

760
00:28:43,840 --> 00:28:45,919
that field is and do keep in mind that

761
00:28:45,919 --> 00:28:47,919
the json messages are not allowed to be

762
00:28:47,919 --> 00:28:51,360
more than 256 bytes so it could still be

763
00:28:51,360 --> 00:28:54,080
all right however looking up this is

764
00:28:54,080 --> 00:28:56,640
actually the structure that it copies

765
00:28:56,640 --> 00:28:59,520
into that token field is only 64 bytes

766
00:28:59,520 --> 00:29:00,399
long

767
00:29:00,399 --> 00:29:04,320
we can go up to 256 bytes okay well what

768
00:29:04,320 --> 00:29:07,200
that really means is we can uh

769
00:29:07,200 --> 00:29:09,360
set a token field that is

770
00:29:09,360 --> 00:29:11,919
much much larger or at least just larger

771
00:29:11,919 --> 00:29:14,320
than 64 bytes and then we'll start

772
00:29:14,320 --> 00:29:16,640
overwriting fields in that global

773
00:29:16,640 --> 00:29:18,559
configuration structure

774
00:29:18,559 --> 00:29:20,320
that may actually yield something

775
00:29:20,320 --> 00:29:22,799
interesting and lo and behold there's

776
00:29:22,799 --> 00:29:24,480
something interesting almost way too

777
00:29:24,480 --> 00:29:28,080
convenient really there's this

778
00:29:28,080 --> 00:29:31,360
finish cb that's uh one of the fields in

779
00:29:31,360 --> 00:29:34,000
that structure it's a function pointer

780
00:29:34,000 --> 00:29:36,240
and it happens to be called immediately

781
00:29:36,240 --> 00:29:38,480
after our out of bounds right our mem

782
00:29:38,480 --> 00:29:40,799
copy so that's fantastic so all we have

783
00:29:40,799 --> 00:29:42,799
to do is just have a

784
00:29:42,799 --> 00:29:46,559
token that is uh 72 bytes or well seven

785
00:29:46,559 --> 00:29:48,880
longer than 72 bytes and we'll start

786
00:29:48,880 --> 00:29:50,399
overwriting that

787
00:29:50,399 --> 00:29:53,600
callback function pointer

788
00:29:53,600 --> 00:29:55,600
so

789
00:29:55,600 --> 00:29:58,080
now we have uh control

790
00:29:58,080 --> 00:30:01,360
sorry now we have control over the uh

791
00:30:01,360 --> 00:30:03,919
program counter which essentially

792
00:30:03,919 --> 00:30:06,559
allows us to jump wherever we want in

793
00:30:06,559 --> 00:30:07,760
the firmware

794
00:30:07,760 --> 00:30:08,720
but

795
00:30:08,720 --> 00:30:11,880
all all of this we've done so far on the

796
00:30:11,880 --> 00:30:13,520
[Music]

797
00:30:13,520 --> 00:30:15,440
on the sdk blobs

798
00:30:15,440 --> 00:30:18,240
we don't really know if the devices

799
00:30:18,240 --> 00:30:20,320
themselves are vulnerable

800
00:30:20,320 --> 00:30:22,240
we've tested them a little bit kind of

801
00:30:22,240 --> 00:30:25,039
black box by trying to exploit them but

802
00:30:25,039 --> 00:30:27,520
it's it's it's a little unclear

803
00:30:27,520 --> 00:30:29,200
so

804
00:30:29,200 --> 00:30:31,679
we decided the next step is to get

805
00:30:31,679 --> 00:30:33,120
firmer dumps

806
00:30:33,120 --> 00:30:35,600
the plan here was to uh dump the

807
00:30:35,600 --> 00:30:36,399
firmware

808
00:30:36,399 --> 00:30:38,480
uh analyze it reverse engineer like

809
00:30:38,480 --> 00:30:39,840
we've done so far

810
00:30:39,840 --> 00:30:42,799
kind of uh compare and figure out okay

811
00:30:42,799 --> 00:30:46,159
does this actually exist in the same way

812
00:30:46,159 --> 00:30:48,240
additionally we also get to figure out

813
00:30:48,240 --> 00:30:50,480
which locations in the code are

814
00:30:50,480 --> 00:30:52,000
interesting

815
00:30:52,000 --> 00:30:53,760
however we really did not know much

816
00:30:53,760 --> 00:30:56,399
about this chip so as tom mentioned

817
00:30:56,399 --> 00:30:59,519
um you know documentation is is scarce

818
00:30:59,519 --> 00:31:01,440
if non-existent

819
00:31:01,440 --> 00:31:02,240
so

820
00:31:02,240 --> 00:31:04,399
how are we actually going to

821
00:31:04,399 --> 00:31:07,279
dump the firmware

822
00:31:07,760 --> 00:31:10,159
so turns out there is a

823
00:31:10,159 --> 00:31:11,919
serial protocol that this device

824
00:31:11,919 --> 00:31:12,960
implements

825
00:31:12,960 --> 00:31:17,200
um in its bootloader that allows us to

826
00:31:17,200 --> 00:31:20,320
read flash read some of the device

827
00:31:20,320 --> 00:31:22,640
metadata as well and do keep in mind

828
00:31:22,640 --> 00:31:24,880
that flash is embedded on this device

829
00:31:24,880 --> 00:31:26,960
it's not actually external which is why

830
00:31:26,960 --> 00:31:28,960
this was a little tricky

831
00:31:28,960 --> 00:31:30,399
the only problem is we don't really know

832
00:31:30,399 --> 00:31:32,880
much about this serial protocol besides

833
00:31:32,880 --> 00:31:36,000
that well yeah it exists

834
00:31:36,000 --> 00:31:38,799
well turns out we knew a little bit more

835
00:31:38,799 --> 00:31:41,120
so tuya had some

836
00:31:41,120 --> 00:31:42,240
developer

837
00:31:42,240 --> 00:31:45,039
documentation that actually explained

838
00:31:45,039 --> 00:31:46,399
for

839
00:31:46,399 --> 00:31:48,799
oems that would use their their services

840
00:31:48,799 --> 00:31:50,799
how do you uh

841
00:31:50,799 --> 00:31:54,559
flash your firmware onto the device

842
00:31:54,559 --> 00:31:56,799
both using their own tools as well as

843
00:31:56,799 --> 00:31:58,240
using this

844
00:31:58,240 --> 00:32:00,559
very interesting uh binary called the

845
00:32:00,559 --> 00:32:02,480
bk7231

846
00:32:02,480 --> 00:32:04,240
chip flashing tool

847
00:32:04,240 --> 00:32:07,440
so we started looking around uh for for

848
00:32:07,440 --> 00:32:09,600
information about this based on this uh

849
00:32:09,600 --> 00:32:11,440
newfound knowledge and

850
00:32:11,440 --> 00:32:12,640
luckily

851
00:32:12,640 --> 00:32:14,960
uh we were we actually ended up finding

852
00:32:14,960 --> 00:32:16,799
an open source project from one of uh

853
00:32:16,799 --> 00:32:18,240
beckon employees and beckham is the

854
00:32:18,240 --> 00:32:21,120
company that uh makes these chips and

855
00:32:21,120 --> 00:32:23,200
it's this tool that actually uh

856
00:32:23,200 --> 00:32:25,440
implements this uh bootloader serial

857
00:32:25,440 --> 00:32:26,640
protocol

858
00:32:26,640 --> 00:32:29,120
however not very luckily that tool was

859
00:32:29,120 --> 00:32:30,799
quite unreliable for us we really could

860
00:32:30,799 --> 00:32:33,279
not get it to work to read flash uh at

861
00:32:33,279 --> 00:32:34,000
all

862
00:32:34,000 --> 00:32:36,559
for whatever reason it would just hiccup

863
00:32:36,559 --> 00:32:38,559
or or something would go wrong and we

864
00:32:38,559 --> 00:32:40,559
weren't exactly sure what's wrong with

865
00:32:40,559 --> 00:32:41,760
it

866
00:32:41,760 --> 00:32:43,840
we tried to modify it but that kind of

867
00:32:43,840 --> 00:32:46,480
didn't didn't work out all too well

868
00:32:46,480 --> 00:32:47,440
so

869
00:32:47,440 --> 00:32:50,240
we decided to use the information that

870
00:32:50,240 --> 00:32:52,640
we have from this tool and the fact that

871
00:32:52,640 --> 00:32:54,559
we have a copy of the bootloader in the

872
00:32:54,559 --> 00:32:56,320
sdk

873
00:32:56,320 --> 00:32:57,039
to

874
00:32:57,039 --> 00:32:58,880
both reverse engineer the the boot

875
00:32:58,880 --> 00:33:00,960
loader so we can actually see

876
00:33:00,960 --> 00:33:03,760
what that serial protocol does from the

877
00:33:03,760 --> 00:33:07,279
horse's mouth so to speak as well as use

878
00:33:07,279 --> 00:33:08,480
the

879
00:33:08,480 --> 00:33:10,080
library that we found the tool that we

880
00:33:10,080 --> 00:33:12,960
found as kind of a a quick guide point

881
00:33:12,960 --> 00:33:14,640
because we can then just figure out okay

882
00:33:14,640 --> 00:33:16,240
what sort of artifacts do we really need

883
00:33:16,240 --> 00:33:17,760
to search for in the bootloader so we

884
00:33:17,760 --> 00:33:20,240
don't have to really go through the code

885
00:33:20,240 --> 00:33:22,799
uh in depth uh to figure out where we

886
00:33:22,799 --> 00:33:25,360
need to look for this part

887
00:33:25,360 --> 00:33:28,080
so we spent some time on it and

888
00:33:28,080 --> 00:33:29,360
after a while

889
00:33:29,360 --> 00:33:31,440
we've figured out how it works we

890
00:33:31,440 --> 00:33:33,200
decided to write our own tool it's

891
00:33:33,200 --> 00:33:34,120
called the

892
00:33:34,120 --> 00:33:37,200
bk7231 tools and

893
00:33:37,200 --> 00:33:39,840
essentially it allowed us to

894
00:33:39,840 --> 00:33:42,240
now dump the firmware

895
00:33:42,240 --> 00:33:45,440
but next step we just have a flash dump

896
00:33:45,440 --> 00:33:47,200
we actually need to analyze it before we

897
00:33:47,200 --> 00:33:49,360
can look at any code

898
00:33:49,360 --> 00:33:51,200
so

899
00:33:51,200 --> 00:33:55,200
luckily for us um the the sdk is is uh

900
00:33:55,200 --> 00:33:57,120
open source and this this part of the

901
00:33:57,120 --> 00:33:59,200
the part of the linking of the blobs

902
00:33:59,200 --> 00:34:01,360
together after compilation is is

903
00:34:01,360 --> 00:34:03,279
available so we could just go through it

904
00:34:03,279 --> 00:34:04,960
uh what we learned is that there are two

905
00:34:04,960 --> 00:34:07,679
code partitions on on flash the first

906
00:34:07,679 --> 00:34:09,839
partition is just the bootloader itself

907
00:34:09,839 --> 00:34:11,359
the second stage bootloader after the

908
00:34:11,359 --> 00:34:13,918
boot rom and the second part is well

909
00:34:13,918 --> 00:34:16,000
what's interesting the user application

910
00:34:16,000 --> 00:34:17,839
or so they called it

911
00:34:17,839 --> 00:34:19,440
the user application is essentially what

912
00:34:19,440 --> 00:34:20,960
we're interested in

913
00:34:20,960 --> 00:34:23,199
there are other partitions as well and

914
00:34:23,199 --> 00:34:25,839
they're defined by this user application

915
00:34:25,839 --> 00:34:29,199
but of course in a very uh you know

916
00:34:29,199 --> 00:34:31,679
embedded software fashion

917
00:34:31,679 --> 00:34:34,960
the code sections are encrypted and by

918
00:34:34,960 --> 00:34:36,560
encryption we really mean obfuscation

919
00:34:36,560 --> 00:34:38,639
because the inc the encryption key is

920
00:34:38,639 --> 00:34:40,879
just hard coded in the sdk

921
00:34:40,879 --> 00:34:42,480
so we had to deal with that a little bit

922
00:34:42,480 --> 00:34:43,599
as well

923
00:34:43,599 --> 00:34:45,359
now of course we just implemented all of

924
00:34:45,359 --> 00:34:48,480
that in bk7231 tools so it just does the

925
00:34:48,480 --> 00:34:51,918
whole process now from dumping the uh

926
00:34:51,918 --> 00:34:53,760
the flash from the device with that

927
00:34:53,760 --> 00:34:56,879
serial protocol to uh decrypting uh the

928
00:34:56,879 --> 00:34:58,880
code blocks and actually unwrapping

929
00:34:58,880 --> 00:35:00,720
their custom

930
00:35:00,720 --> 00:35:02,160
sort of uh

931
00:35:02,160 --> 00:35:05,200
format that they use both for um on-chip

932
00:35:05,200 --> 00:35:07,520
uh over-the-air updates it's called an

933
00:35:07,520 --> 00:35:09,760
rbl format so we did a little bit more

934
00:35:09,760 --> 00:35:11,520
reverse engineering around their uh

935
00:35:11,520 --> 00:35:13,599
their binary tools that they had in the

936
00:35:13,599 --> 00:35:14,839
in the

937
00:35:14,839 --> 00:35:18,160
sdk so

938
00:35:18,160 --> 00:35:21,040
now armed with uh all of this

939
00:35:21,040 --> 00:35:23,200
information it's now time to start

940
00:35:23,200 --> 00:35:24,160
making

941
00:35:24,160 --> 00:35:26,079
our bug a little bit more

942
00:35:26,079 --> 00:35:28,160
useful

943
00:35:28,160 --> 00:35:29,119
so

944
00:35:29,119 --> 00:35:32,240
let's do a quick recall this is actually

945
00:35:32,240 --> 00:35:34,400
what we had we had the configuration

946
00:35:34,400 --> 00:35:37,040
message coming in we had the token field

947
00:35:37,040 --> 00:35:39,280
and if it's longer than 72 bytes we

948
00:35:39,280 --> 00:35:41,040
would overwrite this

949
00:35:41,040 --> 00:35:43,040
function pointer so

950
00:35:43,040 --> 00:35:45,839
here's an idea uh we do have uh we don't

951
00:35:45,839 --> 00:35:47,200
actually have control at all on the

952
00:35:47,200 --> 00:35:49,359
stack at the time of invocation here

953
00:35:49,359 --> 00:35:52,400
however um there are some registers that

954
00:35:52,400 --> 00:35:53,599
are uh

955
00:35:53,599 --> 00:35:55,520
that that point to data that we control

956
00:35:55,520 --> 00:35:57,760
namely the data that's parsed in this

957
00:35:57,760 --> 00:35:59,920
json object so hey maybe we can write

958
00:35:59,920 --> 00:36:01,760
shellcode and just

959
00:36:01,760 --> 00:36:03,839
jump to it on the stack you know this

960
00:36:03,839 --> 00:36:05,760
this usually works

961
00:36:05,760 --> 00:36:08,240
uh well turns out that was not quite the

962
00:36:08,240 --> 00:36:09,119
case

963
00:36:09,119 --> 00:36:10,800
this was quite surprising for us because

964
00:36:10,800 --> 00:36:14,079
the rv9 is a very old old old chip

965
00:36:14,079 --> 00:36:15,680
and as far as we can tell it doesn't

966
00:36:15,680 --> 00:36:18,320
have any memory protection units or any

967
00:36:18,320 --> 00:36:20,640
sort of memory management units so there

968
00:36:20,640 --> 00:36:21,599
should be

969
00:36:21,599 --> 00:36:23,200
like almost all memory regions should be

970
00:36:23,200 --> 00:36:25,599
executable but for whatever reason this

971
00:36:25,599 --> 00:36:28,320
really uh did not work at all

972
00:36:28,320 --> 00:36:30,560
so even though we have control floor

973
00:36:30,560 --> 00:36:33,520
direction well we didn't really have

974
00:36:33,520 --> 00:36:36,000
much yet but there are techniques to

975
00:36:36,000 --> 00:36:37,680
deal with that

976
00:36:37,680 --> 00:36:39,040
so we could do

977
00:36:39,040 --> 00:36:41,040
return oriented programming or call

978
00:36:41,040 --> 00:36:43,359
oriented programming or some version of

979
00:36:43,359 --> 00:36:46,240
of them and basically reuse the code

980
00:36:46,240 --> 00:36:48,800
that is already in the

981
00:36:48,800 --> 00:36:50,640
in the firmware to to kind of do our

982
00:36:50,640 --> 00:36:52,320
bidding

983
00:36:52,320 --> 00:36:57,839
now um we did actually end up uh

984
00:36:57,839 --> 00:37:00,079
figuring out something around that

985
00:37:00,079 --> 00:37:01,200
um

986
00:37:01,200 --> 00:37:03,839
we thought that uh and from from

987
00:37:03,839 --> 00:37:06,800
previous runs with the esp version we

988
00:37:06,800 --> 00:37:08,800
knew that there is a way to overwrite

989
00:37:08,800 --> 00:37:10,560
the pre-shared key

990
00:37:10,560 --> 00:37:12,960
through a call to the api

991
00:37:12,960 --> 00:37:15,359
and then the device would pull that new

992
00:37:15,359 --> 00:37:18,240
key from the server and overwrite it in

993
00:37:18,240 --> 00:37:20,480
flash so we found that function and we

994
00:37:20,480 --> 00:37:23,200
thought okay this is a really nice

995
00:37:23,200 --> 00:37:25,920
function that we could jump into so this

996
00:37:25,920 --> 00:37:27,839
is a piece of code that's already on the

997
00:37:27,839 --> 00:37:30,400
device and all we have to do is just

998
00:37:30,400 --> 00:37:32,320
massage the parameters a little bit and

999
00:37:32,320 --> 00:37:34,000
if we just return to that function it'll

1000
00:37:34,000 --> 00:37:36,240
overwrite the appreciate key for us and

1001
00:37:36,240 --> 00:37:39,599
we'll end up with a win condition

1002
00:37:39,599 --> 00:37:40,720
however

1003
00:37:40,720 --> 00:37:43,280
it turns out that this was really not

1004
00:37:43,280 --> 00:37:44,400
sufficient

1005
00:37:44,400 --> 00:37:47,200
um overwriting the psk worked we did

1006
00:37:47,200 --> 00:37:48,880
actually get it to kind of downgrade

1007
00:37:48,880 --> 00:37:51,839
into the previous protocol that it had

1008
00:37:51,839 --> 00:37:54,960
that tui convert abused however

1009
00:37:54,960 --> 00:37:57,680
the sdk is written such that it does not

1010
00:37:57,680 --> 00:37:59,119
actually

1011
00:37:59,119 --> 00:38:01,200
accept unencrypted traffic within the

1012
00:38:01,200 --> 00:38:03,440
tls connection

1013
00:38:03,440 --> 00:38:05,839
which the previous version did

1014
00:38:05,839 --> 00:38:08,880
so we kind of had to reassess what can

1015
00:38:08,880 --> 00:38:11,520
we do here what's what's our pathing to

1016
00:38:11,520 --> 00:38:12,720
to get this

1017
00:38:12,720 --> 00:38:14,960
um so we actually did manage to

1018
00:38:14,960 --> 00:38:17,040
overwrite the psk the downgrade doesn't

1019
00:38:17,040 --> 00:38:19,359
work code execution

1020
00:38:19,359 --> 00:38:21,760
a little bit tricky still but we can

1021
00:38:21,760 --> 00:38:23,119
maybe find a way to overwrite the

1022
00:38:23,119 --> 00:38:24,720
security keys

1023
00:38:24,720 --> 00:38:25,599
which

1024
00:38:25,599 --> 00:38:28,640
turns out is exactly what we did

1025
00:38:28,640 --> 00:38:31,200
so we thought okay they have some

1026
00:38:31,200 --> 00:38:34,320
function that they use to write this

1027
00:38:34,320 --> 00:38:36,560
pre-shared key parameter

1028
00:38:36,560 --> 00:38:38,480
and persist it to flash

1029
00:38:38,480 --> 00:38:40,880
perhaps we could just you know search

1030
00:38:40,880 --> 00:38:42,640
for other functions that maybe use this

1031
00:38:42,640 --> 00:38:45,520
function so we started on this little

1032
00:38:45,520 --> 00:38:48,400
journey for what's called gadget hunting

1033
00:38:48,400 --> 00:38:50,320
and a gadget really is just a piece of

1034
00:38:50,320 --> 00:38:51,839
code that does something useful that we

1035
00:38:51,839 --> 00:38:54,880
want to uh that we want to achieve and

1036
00:38:54,880 --> 00:38:56,240
in this particular case we were looking

1037
00:38:56,240 --> 00:38:58,480
for two two gadgets we were looking for

1038
00:38:58,480 --> 00:39:00,079
something that sets the security keys

1039
00:39:00,079 --> 00:39:02,079
that we can just jump right into and let

1040
00:39:02,079 --> 00:39:05,040
it do our bidding and perhaps one or

1041
00:39:05,040 --> 00:39:07,440
more quote-unquote fix-up gadgets and

1042
00:39:07,440 --> 00:39:09,839
these just do simple tasks of moving

1043
00:39:09,839 --> 00:39:12,079
registers about just to get things in

1044
00:39:12,079 --> 00:39:15,119
the right order

1045
00:39:15,119 --> 00:39:17,680
uh we used a tool called the ropper to

1046
00:39:17,680 --> 00:39:20,079
uh to analyze the firmware it's uh it's

1047
00:39:20,079 --> 00:39:22,320
uh for for for the second type of

1048
00:39:22,320 --> 00:39:24,960
gadgets uh it's a tool commonly used in

1049
00:39:24,960 --> 00:39:26,960
an exploitation also for traditional

1050
00:39:26,960 --> 00:39:29,119
systems

1051
00:39:29,119 --> 00:39:31,200
so

1052
00:39:31,200 --> 00:39:33,200
um as we moved about we actually ended

1053
00:39:33,200 --> 00:39:36,000
up finding out one such nice target

1054
00:39:36,000 --> 00:39:38,000
gadget so that function that overwrites

1055
00:39:38,000 --> 00:39:41,760
all the keys we noticed that this wd

1056
00:39:41,760 --> 00:39:44,640
gw base if right was used to overwrite

1057
00:39:44,640 --> 00:39:46,880
the psk and just by kind of cross

1058
00:39:46,880 --> 00:39:48,640
referencing back what sort of other

1059
00:39:48,640 --> 00:39:51,040
functions refer refer to that function

1060
00:39:51,040 --> 00:39:52,880
we ended up finding this handy dandy

1061
00:39:52,880 --> 00:39:54,640
function that does not seem to be called

1062
00:39:54,640 --> 00:39:57,680
at all by any tasks but seems to exist

1063
00:39:57,680 --> 00:39:59,920
for the purposes of writing these

1064
00:39:59,920 --> 00:40:01,440
configuration

1065
00:40:01,440 --> 00:40:03,520
parameters to the device in the factory

1066
00:40:03,520 --> 00:40:05,599
through some serial protocol it's pretty

1067
00:40:05,599 --> 00:40:07,440
straightforward all it does is it takes

1068
00:40:07,440 --> 00:40:11,440
a json payload over serial parses it and

1069
00:40:11,440 --> 00:40:14,160
then just uses it to overwrite the the

1070
00:40:14,160 --> 00:40:16,640
parameters in flash

1071
00:40:16,640 --> 00:40:18,480
so this looked like a great and

1072
00:40:18,480 --> 00:40:20,800
fantastic candidate for us to use and

1073
00:40:20,800 --> 00:40:23,520
since we already had a json

1074
00:40:23,520 --> 00:40:27,040
blob that we actually sent to the

1075
00:40:27,040 --> 00:40:29,200
to the to the task to actually exploit

1076
00:40:29,200 --> 00:40:30,079
it

1077
00:40:30,079 --> 00:40:31,520
essentially this was just a matter of

1078
00:40:31,520 --> 00:40:33,040
swapping some registers around because

1079
00:40:33,040 --> 00:40:35,040
we already had a nice pre-parsed json

1080
00:40:35,040 --> 00:40:36,160
object

1081
00:40:36,160 --> 00:40:38,000
and in order to do this swapping around

1082
00:40:38,000 --> 00:40:39,839
we have the fixed up gadgets also

1083
00:40:39,839 --> 00:40:41,760
trampoline gadgets on the side as you

1084
00:40:41,760 --> 00:40:44,640
can see this one uh it simply sets uh

1085
00:40:44,640 --> 00:40:47,119
the first register r0 to the value of

1086
00:40:47,119 --> 00:40:49,280
the register r7 i think in this

1087
00:40:49,280 --> 00:40:51,760
particular case it was the json object

1088
00:40:51,760 --> 00:40:54,079
indeed and then it pulls

1089
00:40:54,079 --> 00:40:57,920
r3 on the third line from some other

1090
00:40:57,920 --> 00:40:59,520
data section that we actually had some

1091
00:40:59,520 --> 00:41:01,760
control over so in this way we could do

1092
00:41:01,760 --> 00:41:04,000
some jump that does some

1093
00:41:04,000 --> 00:41:06,079
register swap and then from the register

1094
00:41:06,079 --> 00:41:08,560
swap we can go to a secondary location

1095
00:41:08,560 --> 00:41:10,720
um which essentially should be our

1096
00:41:10,720 --> 00:41:12,960
target gadget and kind of putting

1097
00:41:12,960 --> 00:41:15,280
everything uh together over here

1098
00:41:15,280 --> 00:41:16,800
we had the setup where we had the

1099
00:41:16,800 --> 00:41:18,880
vulnerable function called the fix up

1100
00:41:18,880 --> 00:41:21,440
gadget does some red swaps and then we

1101
00:41:21,440 --> 00:41:24,640
end up in our lovely uh function that

1102
00:41:24,640 --> 00:41:28,000
did all the work for us

1103
00:41:28,079 --> 00:41:28,880
now

1104
00:41:28,880 --> 00:41:30,720
that's not quite over yet so we're just

1105
00:41:30,720 --> 00:41:32,560
moving to tom here to explain what we

1106
00:41:32,560 --> 00:41:34,800
did after that

1107
00:41:34,800 --> 00:41:35,920
yeah so now

1108
00:41:35,920 --> 00:41:38,640
we we have an exploit

1109
00:41:38,640 --> 00:41:41,520
we can can set the keys

1110
00:41:41,520 --> 00:41:44,720
but it's not not usable for people aside

1111
00:41:44,720 --> 00:41:47,280
from the two of us yet right

1112
00:41:47,280 --> 00:41:49,280
so we built a small tool called two year

1113
00:41:49,280 --> 00:41:50,560
cloud cutter

1114
00:41:50,560 --> 00:41:52,960
it contains all of all of this exploit

1115
00:41:52,960 --> 00:41:54,560
tool chain steps

1116
00:41:54,560 --> 00:41:56,960
plus some additional things so you can

1117
00:41:56,960 --> 00:41:59,760
use it to override all of the keys

1118
00:41:59,760 --> 00:42:03,040
psk ascii local key sec key

1119
00:42:03,040 --> 00:42:05,200
by doing that it it

1120
00:42:05,200 --> 00:42:07,040
disallows the device from connecting to

1121
00:42:07,040 --> 00:42:09,760
tuya so it's cut off from the cloud

1122
00:42:09,760 --> 00:42:11,920
it allows you to connect locally with

1123
00:42:11,920 --> 00:42:14,000
this local key

1124
00:42:14,000 --> 00:42:15,440
and so you can use it in complete

1125
00:42:15,440 --> 00:42:18,000
isolation on your own network

1126
00:42:18,000 --> 00:42:19,920
and then also you can use tui cloud

1127
00:42:19,920 --> 00:42:21,040
cutter to

1128
00:42:21,040 --> 00:42:23,280
write your own firmware if you like

1129
00:42:23,280 --> 00:42:24,880
if you're interested in it check it out

1130
00:42:24,880 --> 00:42:26,640
on github there's a there's a link in

1131
00:42:26,640 --> 00:42:29,520
the slides also

1132
00:42:29,520 --> 00:42:32,319
but i think now we should use the last

1133
00:42:32,319 --> 00:42:34,720
final minutes that we have

1134
00:42:34,720 --> 00:42:37,599
for actually trying to show you

1135
00:42:37,599 --> 00:42:39,920
i'm going to put this light bulb from

1136
00:42:39,920 --> 00:42:41,839
action into ap mode by flicking the

1137
00:42:41,839 --> 00:42:44,400
switch six times

1138
00:42:44,400 --> 00:42:47,200
helet is going to connect to it via his

1139
00:42:47,200 --> 00:42:49,680
laptop

1140
00:42:57,200 --> 00:42:58,640
and then he's going to run the first

1141
00:42:58,640 --> 00:43:02,720
step of the exploit tool chain

1142
00:43:03,280 --> 00:43:05,040
so it's blinking slowly now which means

1143
00:43:05,040 --> 00:43:08,759
it's in ap mode

1144
00:43:13,520 --> 00:43:17,200
all right now we have the exploit

1145
00:43:18,560 --> 00:43:20,400
all right so the exploit has run i don't

1146
00:43:20,400 --> 00:43:21,440
know if you can see it it's all the way

1147
00:43:21,440 --> 00:43:23,839
at the bottom of the of the beamer here

1148
00:43:23,839 --> 00:43:27,599
we put it in ap mode once again

1149
00:43:27,599 --> 00:43:29,599
this time to configure it to join a

1150
00:43:29,599 --> 00:43:31,920
different access point that's kellett

1151
00:43:31,920 --> 00:43:33,920
has on this on his mobile phone his

1152
00:43:33,920 --> 00:43:35,100
hotspot

1153
00:43:35,100 --> 00:43:42,409
[Music]

1154
00:43:44,780 --> 00:43:47,999
[Music]

1155
00:43:48,240 --> 00:43:50,240
and then from there we can connect to it

1156
00:43:50,240 --> 00:43:52,319
using the local key

1157
00:43:52,319 --> 00:43:54,880
to make it do something and hopefully we

1158
00:43:54,880 --> 00:43:58,720
can show you that it will do something

1159
00:43:59,040 --> 00:44:00,800
of course these kinds of demos are uh

1160
00:44:00,800 --> 00:44:02,960
super uh super dangerous to do on a camp

1161
00:44:02,960 --> 00:44:05,200
like this huh so this is all connecting

1162
00:44:05,200 --> 00:44:07,440
over wi-fi to each other on a stage with

1163
00:44:07,440 --> 00:44:10,079
i don't know 50 people here and hundreds

1164
00:44:10,079 --> 00:44:12,400
around

1165
00:44:16,560 --> 00:44:18,400
so we've got configuration messages now

1166
00:44:18,400 --> 00:44:20,400
from the device with uh we know the

1167
00:44:20,400 --> 00:44:22,319
exploit work because we can actually see

1168
00:44:22,319 --> 00:44:24,079
them they're plain text so we're doing

1169
00:44:24,079 --> 00:44:26,319
the mana middle correctly and now the

1170
00:44:26,319 --> 00:44:28,880
device should be on our access point so

1171
00:44:28,880 --> 00:44:30,240
let's

1172
00:44:30,240 --> 00:44:33,118
scan for it

1173
00:44:35,520 --> 00:44:38,160
we just need to figure out uh if it was

1174
00:44:38,160 --> 00:44:41,040
onboarded correctly hopefully it is and

1175
00:44:41,040 --> 00:44:44,880
oh i'm on the incorrect network

1176
00:44:44,880 --> 00:44:49,000
tends to happen on live demos

1177
00:44:54,640 --> 00:44:55,839
so right now the bulb should be

1178
00:44:55,839 --> 00:44:57,920
connected to helet's mobile phone it's

1179
00:44:57,920 --> 00:44:59,839
running a hotspot he's connecting his

1180
00:44:59,839 --> 00:45:01,680
laptop to the same hotspot

1181
00:45:01,680 --> 00:45:03,680
and then the laptop can send commands

1182
00:45:03,680 --> 00:45:05,599
directly to the light bulb

1183
00:45:05,599 --> 00:45:07,680
if things work out we'll see yeah

1184
00:45:07,680 --> 00:45:10,000
yeah

1185
00:45:10,160 --> 00:45:12,720
there we go found the device

1186
00:45:12,720 --> 00:45:16,000
just need to get its ip address

1187
00:45:16,000 --> 00:45:17,280
we have a

1188
00:45:17,280 --> 00:45:18,800
little uh

1189
00:45:18,800 --> 00:45:19,839
script

1190
00:45:19,839 --> 00:45:22,160
that we then use the local key that

1191
00:45:22,160 --> 00:45:23,680
we've set on the device to actually make

1192
00:45:23,680 --> 00:45:25,040
it do something a little bit more

1193
00:45:25,040 --> 00:45:26,960
interesting

1194
00:45:26,960 --> 00:45:28,710
such as this

1195
00:45:28,710 --> 00:45:41,040
[Applause]

1196
00:45:43,440 --> 00:45:45,760
so we'll leave this running in the

1197
00:45:45,760 --> 00:45:48,240
background

1198
00:45:48,640 --> 00:45:50,879
oh

1199
00:45:53,920 --> 00:45:56,400
there we go

1200
00:45:56,960 --> 00:46:00,760
right now back to tom

1201
00:46:02,400 --> 00:46:03,920
all right so uh in

1202
00:46:03,920 --> 00:46:06,319
in closing we found a really cool bug

1203
00:46:06,319 --> 00:46:09,040
that seems to be present in all devices

1204
00:46:09,040 --> 00:46:11,040
containing this new chip

1205
00:46:11,040 --> 00:46:11,920
which

1206
00:46:11,920 --> 00:46:14,880
we think is any device made by tuya

1207
00:46:14,880 --> 00:46:19,680
millions of them since around 2020.

1208
00:46:21,440 --> 00:46:23,760
we did a vulnerability disclosure to

1209
00:46:23,760 --> 00:46:25,839
tuia they were really cool about it

1210
00:46:25,839 --> 00:46:27,359
really nice people responded super

1211
00:46:27,359 --> 00:46:29,440
quickly and they gave us a bug bounty

1212
00:46:29,440 --> 00:46:30,319
for it

1213
00:46:30,319 --> 00:46:32,240
we donated it to charity to a foundation

1214
00:46:32,240 --> 00:46:33,920
that teaches kids how to hack which we

1215
00:46:33,920 --> 00:46:36,000
thought was was really cool

1216
00:46:36,000 --> 00:46:38,240
and for us this this was a first

1217
00:46:38,240 --> 00:46:39,920
experience or for me it was the first

1218
00:46:39,920 --> 00:46:41,359
experience of doing a vulnerability

1219
00:46:41,359 --> 00:46:44,800
disclosure hella did it before

1220
00:46:44,800 --> 00:46:47,359
so that was really nice and

1221
00:46:47,359 --> 00:46:48,800
one

1222
00:46:48,800 --> 00:46:51,440
takeaway for us as well was

1223
00:46:51,440 --> 00:46:53,520
embedded security is catching up

1224
00:46:53,520 --> 00:46:55,359
this kind of stuff we had with not being

1225
00:46:55,359 --> 00:46:57,280
able to just

1226
00:46:57,280 --> 00:46:59,200
send shellcode to the device and jump

1227
00:46:59,200 --> 00:47:02,079
into it because of non-executable memory

1228
00:47:02,079 --> 00:47:06,160
it shows that steps are being taken

1229
00:47:06,240 --> 00:47:07,520
however

1230
00:47:07,520 --> 00:47:09,599
it's still far behind personal computing

1231
00:47:09,599 --> 00:47:10,800
that's what this makes it a really

1232
00:47:10,800 --> 00:47:13,040
interesting target for us

1233
00:47:13,040 --> 00:47:14,400
and so

1234
00:47:14,400 --> 00:47:16,640
our message is that it's still juicy to

1235
00:47:16,640 --> 00:47:18,800
look into these embedded devices

1236
00:47:18,800 --> 00:47:20,240
because many of the tricks that have not

1237
00:47:20,240 --> 00:47:22,640
worked in personal computing for quite a

1238
00:47:22,640 --> 00:47:26,799
while now they still work here

1239
00:47:27,440 --> 00:47:29,040
all right and with that we will leave

1240
00:47:29,040 --> 00:47:32,000
you we want to thank a couple people use

1241
00:47:32,000 --> 00:47:35,119
blasty gilles and mvtrust for helping us

1242
00:47:35,119 --> 00:47:36,640
along the way

1243
00:47:36,640 --> 00:47:37,920
if you would like to get in touch with

1244
00:47:37,920 --> 00:47:38,800
us

1245
00:47:38,800 --> 00:47:40,319
our stuff is up there

1246
00:47:40,319 --> 00:47:42,120
thanks a lot for listening

1247
00:47:42,120 --> 00:47:44,240
[Applause]

1248
00:47:44,240 --> 00:47:45,910
[Music]

1249
00:47:45,910 --> 00:47:49,310
[Applause]

1250
00:47:51,360 --> 00:47:55,440
[Applause]

1251
00:47:55,440 --> 00:47:58,000
well thank you so much that was amazing

1252
00:47:58,000 --> 00:47:59,760
i'm not really a tech person and i

1253
00:47:59,760 --> 00:48:01,680
understood so much of it

1254
00:48:01,680 --> 00:48:02,640
um

1255
00:48:02,640 --> 00:48:04,240
we have two

1256
00:48:04,240 --> 00:48:06,000
vacancies open at my school for computer

1257
00:48:06,000 --> 00:48:09,119
science teachers so if you're interested

1258
00:48:09,119 --> 00:48:10,319
um

1259
00:48:10,319 --> 00:48:13,359
now if there are any questions to them

1260
00:48:13,359 --> 00:48:15,440
there are mics in the middle please use

1261
00:48:15,440 --> 00:48:17,280
them to

1262
00:48:17,280 --> 00:48:18,400
ask

1263
00:48:18,400 --> 00:48:21,839
a question if you have one

1264
00:48:22,559 --> 00:48:24,480
no questions well i think if you come up

1265
00:48:24,480 --> 00:48:25,680
with a question

1266
00:48:25,680 --> 00:48:27,280
they're still approachable after the

1267
00:48:27,280 --> 00:48:30,000
talk or somewhere around camp

1268
00:48:30,000 --> 00:48:30,720
and

1269
00:48:30,720 --> 00:48:32,800
thank you so much another big applause

1270
00:48:32,800 --> 00:48:34,060
please

1271
00:48:34,060 --> 00:48:40,080
[Applause]

1272
00:48:40,080 --> 00:48:43,139
[Music]

