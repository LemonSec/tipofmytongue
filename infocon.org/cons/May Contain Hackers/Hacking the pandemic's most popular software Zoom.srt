1
00:00:01,280 --> 00:00:12,559
[Music]

2
00:00:15,440 --> 00:00:17,359
that's going to be a tough act to beat

3
00:00:17,359 --> 00:00:18,720
actually

4
00:00:18,720 --> 00:00:20,240
but i'm going to try

5
00:00:20,240 --> 00:00:21,520
so

6
00:00:21,520 --> 00:00:23,680
welcome everyone um my name is dan

7
00:00:23,680 --> 00:00:25,119
cooper i'm here with my colleague thais

8
00:00:25,119 --> 00:00:27,359
alcamado we work for a company called

9
00:00:27,359 --> 00:00:29,199
computest which is a full server

10
00:00:29,199 --> 00:00:31,359
security provider in the

11
00:00:31,359 --> 00:00:32,719
netherlands

12
00:00:32,719 --> 00:00:34,320
we do everything from presentation

13
00:00:34,320 --> 00:00:36,640
testing to incident response

14
00:00:36,640 --> 00:00:38,879
but we do run the research facility of

15
00:00:38,879 --> 00:00:42,000
computers which means we can hack cool

16
00:00:42,000 --> 00:00:42,879
stuff

17
00:00:42,879 --> 00:00:45,200
and talk about it at conferences we did

18
00:00:45,200 --> 00:00:46,800
a talk yesterday as well and tomorrow

19
00:00:46,800 --> 00:00:49,440
we'll be talking about hacking mac os

20
00:00:49,440 --> 00:00:51,600
for a local privilege escalation

21
00:00:51,600 --> 00:00:53,760
so if you have any questions after this

22
00:00:53,760 --> 00:00:56,719
talk feel free to get to our tent it's

23
00:00:56,719 --> 00:00:59,280
on the retro square with full a tent

24
00:00:59,280 --> 00:01:01,440
full of arcade games if you're into that

25
00:01:01,440 --> 00:01:04,479
but we can also have a beer of course

26
00:01:04,479 --> 00:01:05,360
so

27
00:01:05,360 --> 00:01:08,080
today we would like to talk to you about

28
00:01:08,080 --> 00:01:10,000
something we did last year last year we

29
00:01:10,000 --> 00:01:12,400
participated in pawn to own and we won

30
00:01:12,400 --> 00:01:14,799
by demonstrating a zero day attack

31
00:01:14,799 --> 00:01:17,200
against the zoom message client

32
00:01:17,200 --> 00:01:20,080
so that meant that if somebody had the

33
00:01:20,080 --> 00:01:21,920
app installed and running we could

34
00:01:21,920 --> 00:01:24,240
remotely get code execution

35
00:01:24,240 --> 00:01:26,400
on your machine

36
00:01:26,400 --> 00:01:28,400
so we want to share all the details but

37
00:01:28,400 --> 00:01:30,159
we have very little time and a lot of

38
00:01:30,159 --> 00:01:34,000
ground to cover so i will give

39
00:01:34,000 --> 00:01:36,799
the slides to ties and it will quickly

40
00:01:36,799 --> 00:01:38,720
tell you the vulnerability we found we

41
00:01:38,720 --> 00:01:40,640
mainly used in our exploit and then

42
00:01:40,640 --> 00:01:42,479
we're getting all the nifty details

43
00:01:42,479 --> 00:01:44,799
about how we actually exploited that

44
00:01:44,799 --> 00:01:46,399
vulnerability

45
00:01:46,399 --> 00:01:48,560
thanks

46
00:01:48,560 --> 00:01:49,920
yeah so

47
00:01:49,920 --> 00:01:51,920
the vulnerability we found is in the

48
00:01:51,920 --> 00:01:54,320
chat functionality of zoom so many

49
00:01:54,320 --> 00:01:55,759
people know it for the meetings that

50
00:01:55,759 --> 00:01:57,680
they can have and just send the calendar

51
00:01:57,680 --> 00:02:00,000
invite and people can join it but zoom

52
00:02:00,000 --> 00:02:02,479
actually has a vel very well featured

53
00:02:02,479 --> 00:02:05,119
chat client built in as well

54
00:02:05,119 --> 00:02:06,799
which many people don't really use that

55
00:02:06,799 --> 00:02:09,840
often i think

56
00:02:09,919 --> 00:02:11,760
and when we started to figuring out what

57
00:02:11,760 --> 00:02:14,000
the features are that zoom has when we

58
00:02:14,000 --> 00:02:15,599
started our research

59
00:02:15,599 --> 00:02:17,840
we noticed that

60
00:02:17,840 --> 00:02:19,920
zoom basically uses a couple of

61
00:02:19,920 --> 00:02:21,440
different particles depending on what

62
00:02:21,440 --> 00:02:22,959
you are doing

63
00:02:22,959 --> 00:02:25,680
so there's the xmpp which is used for

64
00:02:25,680 --> 00:02:26,400
that

65
00:02:26,400 --> 00:02:28,560
chat the out of meetings chat

66
00:02:28,560 --> 00:02:30,640
there's an http api for specific

67
00:02:30,640 --> 00:02:32,959
operations like if you're logging in

68
00:02:32,959 --> 00:02:35,519
and they have a custom binary protocol

69
00:02:35,519 --> 00:02:39,680
for meetings which is udp-based

70
00:02:39,680 --> 00:02:41,840
and pretty early on we decided that we

71
00:02:41,840 --> 00:02:43,680
thought that the xmpp connection would

72
00:02:43,680 --> 00:02:46,000
be the most interesting for us

73
00:02:46,000 --> 00:02:46,959
because

74
00:02:46,959 --> 00:02:50,000
by design because xmpp is extensible you

75
00:02:50,000 --> 00:02:53,040
can just basically send arbitrary xml

76
00:02:53,040 --> 00:02:55,440
directly to another user and often the

77
00:02:55,440 --> 00:02:57,360
server doesn't really care about it it

78
00:02:57,360 --> 00:03:00,239
just forwards it to the other end

79
00:03:00,239 --> 00:03:02,879
so a little enforcement by the server

80
00:03:02,879 --> 00:03:04,319
there's a couple of things they block

81
00:03:04,319 --> 00:03:06,800
but really not that much

82
00:03:06,800 --> 00:03:09,440
and because xmpp is an open standard and

83
00:03:09,440 --> 00:03:11,280
was already quite familiar with it it

84
00:03:11,280 --> 00:03:13,120
took less time to reverse engineer than

85
00:03:13,120 --> 00:03:14,560
the meeting protocol which would have

86
00:03:14,560 --> 00:03:15,440
taken

87
00:03:15,440 --> 00:03:17,760
well weeks to figure out just the basic

88
00:03:17,760 --> 00:03:19,440
structure of it probably

89
00:03:19,440 --> 00:03:22,159
but with xmpp yeah we directly knew that

90
00:03:22,159 --> 00:03:24,560
already

91
00:03:24,959 --> 00:03:28,080
and what we noticed is a very obscure

92
00:03:28,080 --> 00:03:29,200
setting

93
00:03:29,200 --> 00:03:32,400
it's the advanced chat encryption

94
00:03:32,400 --> 00:03:34,799
it's a setting that i think

95
00:03:34,799 --> 00:03:36,959
barely anybody uses

96
00:03:36,959 --> 00:03:38,799
you can only enable it on the website

97
00:03:38,799 --> 00:03:41,599
you cannot do it in the in the client

98
00:03:41,599 --> 00:03:43,040
and when you do it if all of your

99
00:03:43,040 --> 00:03:45,120
messages are encrypted

100
00:03:45,120 --> 00:03:46,959
in the chat

101
00:03:46,959 --> 00:03:48,640
and it only exists for paid accounts so

102
00:03:48,640 --> 00:03:50,080
if you have a free zoom account then you

103
00:03:50,080 --> 00:03:51,519
cannot enable it

104
00:03:51,519 --> 00:03:53,200
and also a lot of features in the chat

105
00:03:53,200 --> 00:03:54,879
no longer work i don't think you can

106
00:03:54,879 --> 00:03:57,200
only send gifis to somebody if you

107
00:03:57,200 --> 00:03:59,680
enable this

108
00:03:59,680 --> 00:04:02,239
and what's even more interesting is that

109
00:04:02,239 --> 00:04:04,720
there were two versions of this protocol

110
00:04:04,720 --> 00:04:05,840
in the code

111
00:04:05,840 --> 00:04:07,519
there's an older version one and a

112
00:04:07,519 --> 00:04:08,799
version two

113
00:04:08,799 --> 00:04:10,560
and if you started a new chat then it

114
00:04:10,560 --> 00:04:12,319
would start version two

115
00:04:12,319 --> 00:04:15,760
but uh if you send it the version one

116
00:04:15,760 --> 00:04:17,358
message then it would still respond to

117
00:04:17,358 --> 00:04:18,560
that and the protocol was still

118
00:04:18,560 --> 00:04:20,720
implemented even though it was no longer

119
00:04:20,720 --> 00:04:23,040
in active use

120
00:04:23,040 --> 00:04:25,520
so if you combine all of this

121
00:04:25,520 --> 00:04:27,199
and with the fact that it was just using

122
00:04:27,199 --> 00:04:29,680
openssl then we thought that this was a

123
00:04:29,680 --> 00:04:33,280
good area to focus on for our research

124
00:04:33,280 --> 00:04:35,440
because it's a conversion between c plus

125
00:04:35,440 --> 00:04:36,800
most of the zoom

126
00:04:36,800 --> 00:04:39,199
custom code is c plus plus it had to be

127
00:04:39,199 --> 00:04:42,160
converted to c for the open ssl api

128
00:04:42,160 --> 00:04:44,479
openssl is of course open source so we

129
00:04:44,479 --> 00:04:46,479
can easily read the documentation or

130
00:04:46,479 --> 00:04:48,479
even the source code for it

131
00:04:48,479 --> 00:04:50,400
and it's a relatively

132
00:04:50,400 --> 00:04:52,479
hidden feature that many people don't

133
00:04:52,479 --> 00:04:54,240
know about so probably developers don't

134
00:04:54,240 --> 00:04:56,560
care about as much either and then we

135
00:04:56,560 --> 00:04:58,160
have an older version even of that

136
00:04:58,160 --> 00:05:01,600
protocol so yeah probably nobody really

137
00:05:01,600 --> 00:05:03,600
looks at that part of the code

138
00:05:03,600 --> 00:05:04,800
but that means that it's very

139
00:05:04,800 --> 00:05:07,919
interesting code for us

140
00:05:09,600 --> 00:05:11,759
now the way this chat encryption works

141
00:05:11,759 --> 00:05:12,960
is that

142
00:05:12,960 --> 00:05:15,840
one end that wants to send a message

143
00:05:15,840 --> 00:05:16,880
um

144
00:05:16,880 --> 00:05:19,280
generates a new encryption key and then

145
00:05:19,280 --> 00:05:21,919
encrypts the message with that key with

146
00:05:21,919 --> 00:05:24,160
the symmetric symmetric encryption key

147
00:05:24,160 --> 00:05:27,440
and sends it to the other party

148
00:05:27,440 --> 00:05:29,600
a receiver then sees a new message with

149
00:05:29,600 --> 00:05:31,840
a key they haven't seen before so at

150
00:05:31,840 --> 00:05:33,360
that point they're going to retrieve it

151
00:05:33,360 --> 00:05:36,800
from the sender so they request the key

152
00:05:36,800 --> 00:05:40,160
using a request key message

153
00:05:40,160 --> 00:05:41,600
and then the sender of the message

154
00:05:41,600 --> 00:05:43,919
replies with the response key message

155
00:05:43,919 --> 00:05:45,840
and in this message they encrypt the

156
00:05:45,840 --> 00:05:48,160
message key using the certificate of the

157
00:05:48,160 --> 00:05:49,360
other user

158
00:05:49,360 --> 00:05:50,880
so in the request key there was this

159
00:05:50,880 --> 00:05:52,639
certificate and then they encrypted to

160
00:05:52,639 --> 00:05:55,280
send it to the other person

161
00:05:55,280 --> 00:05:59,039
and what we found in the code was that

162
00:05:59,039 --> 00:06:02,319
they allocated a 1024 byte buffer for

163
00:06:02,319 --> 00:06:04,319
this key

164
00:06:04,319 --> 00:06:06,639
and then they have two variants in the

165
00:06:06,639 --> 00:06:07,680
code

166
00:06:07,680 --> 00:06:10,479
there's rsa and then it works perfectly

167
00:06:10,479 --> 00:06:12,880
fine but it has also implemented some

168
00:06:12,880 --> 00:06:16,080
elliptic curve option that used

169
00:06:16,080 --> 00:06:17,759
some elliptic curve diffie element and

170
00:06:17,759 --> 00:06:19,680
then some aes

171
00:06:19,680 --> 00:06:22,080
but in this case they did not properly

172
00:06:22,080 --> 00:06:24,720
verify that the length of the decrypted

173
00:06:24,720 --> 00:06:27,280
result would fit into that buffer

174
00:06:27,280 --> 00:06:29,280
so what we have here is a

175
00:06:29,280 --> 00:06:31,520
typical buffer overflow because they try

176
00:06:31,520 --> 00:06:34,080
to write too much data arbitrarily long

177
00:06:34,080 --> 00:06:37,039
data into a fixed size buffer

178
00:06:37,039 --> 00:06:39,039
to make it a bit more visual

179
00:06:39,039 --> 00:06:40,880
so we as an attacker are sending a

180
00:06:40,880 --> 00:06:43,280
message to zoom we send we'd like to

181
00:06:43,280 --> 00:06:45,280
send an encrypted message

182
00:06:45,280 --> 00:06:47,199
and then zoom says well sure send me

183
00:06:47,199 --> 00:06:49,840
that encryption key please

184
00:06:49,840 --> 00:06:51,599
and then we send a very long encryption

185
00:06:51,599 --> 00:06:52,720
key

186
00:06:52,720 --> 00:06:54,960
but zoom then tries to put it into a

187
00:06:54,960 --> 00:06:57,120
buffer which is a fixed size

188
00:06:57,120 --> 00:07:01,479
which triggers this buffer overflow

189
00:07:02,080 --> 00:07:05,840
this buffer overflow has a couple of

190
00:07:05,840 --> 00:07:09,440
pros and cons for writing that exploit

191
00:07:09,440 --> 00:07:10,960
so one thing that's nice about it is

192
00:07:10,960 --> 00:07:12,960
that we can just send as much data as we

193
00:07:12,960 --> 00:07:15,680
want there's no practical limits

194
00:07:15,680 --> 00:07:17,840
on what we want

195
00:07:17,840 --> 00:07:19,680
to overwrite

196
00:07:19,680 --> 00:07:20,960
there may be something in the network

197
00:07:20,960 --> 00:07:23,360
traffic or xmbp packet but we can get a

198
00:07:23,360 --> 00:07:25,199
lot of data

199
00:07:25,199 --> 00:07:26,400
so it's all no rejection on the

200
00:07:26,400 --> 00:07:28,000
character's path we're not limited to

201
00:07:28,000 --> 00:07:30,720
utf-8 or something like that and also

202
00:07:30,720 --> 00:07:32,800
very nice for the competition we can

203
00:07:32,800 --> 00:07:35,680
trigger this using only chat messages

204
00:07:35,680 --> 00:07:37,120
without the victim having to do

205
00:07:37,120 --> 00:07:38,639
something they don't need to approve

206
00:07:38,639 --> 00:07:39,840
anything they don't need to click

207
00:07:39,840 --> 00:07:42,319
anything as long as they allow us to

208
00:07:42,319 --> 00:07:45,199
send them a message which is

209
00:07:45,199 --> 00:07:47,120
yeah one step they had to do it before

210
00:07:47,120 --> 00:07:48,720
or they are part of the same

211
00:07:48,720 --> 00:07:50,879
organization we can just send this

212
00:07:50,879 --> 00:07:54,560
message and the buffer overflow triggers

213
00:07:54,560 --> 00:07:56,800
but there's also a couple of cons

214
00:07:56,800 --> 00:07:59,440
which make it harder to exploit this

215
00:07:59,440 --> 00:08:01,840
now the allocation size of that buffer

216
00:08:01,840 --> 00:08:04,080
is 1040 which is a little bit more than

217
00:08:04,080 --> 00:08:07,680
1024 due to some overhead but it's fixed

218
00:08:07,680 --> 00:08:08,879
so we cannot

219
00:08:08,879 --> 00:08:10,560
make it larger or smaller it's always

220
00:08:10,560 --> 00:08:12,479
that size

221
00:08:12,479 --> 00:08:15,440
it's also we're also limited to

222
00:08:15,440 --> 00:08:17,039
how long we go because it needs to be a

223
00:08:17,039 --> 00:08:19,280
multiple of 16 due to certain reasons

224
00:08:19,280 --> 00:08:21,840
with the encryption

225
00:08:21,840 --> 00:08:24,080
but the most tricky one here is the last

226
00:08:24,080 --> 00:08:27,039
one so the buffer is created

227
00:08:27,039 --> 00:08:29,599
and then we trigger the buffer overflow

228
00:08:29,599 --> 00:08:32,240
all when handling one chat message

229
00:08:32,240 --> 00:08:34,080
so the reason why this is

230
00:08:34,080 --> 00:08:35,279
well making us

231
00:08:35,279 --> 00:08:37,519
work harder for this normally when you

232
00:08:37,519 --> 00:08:39,279
trigger want to exploit the buffer

233
00:08:39,279 --> 00:08:41,440
overflow it's nice to put something in

234
00:08:41,440 --> 00:08:42,719
memory

235
00:08:42,719 --> 00:08:44,880
then put something after it

236
00:08:44,880 --> 00:08:47,680
and then use the first object to

237
00:08:47,680 --> 00:08:49,839
overflow and then overwrite the second

238
00:08:49,839 --> 00:08:50,800
object

239
00:08:50,800 --> 00:08:52,399
but we couldn't do that because it was

240
00:08:52,399 --> 00:08:55,040
created in then overflown in just one

241
00:08:55,040 --> 00:08:56,160
message

242
00:08:56,160 --> 00:08:58,399
so whatever we wanted to override

243
00:08:58,399 --> 00:09:02,240
already had to be there in memory

244
00:09:02,640 --> 00:09:04,800
and this really made the exploit a lot

245
00:09:04,800 --> 00:09:06,560
harder

246
00:09:06,560 --> 00:09:07,360
now

247
00:09:07,360 --> 00:09:09,200
we're going to walk through the the

248
00:09:09,200 --> 00:09:11,519
various steps of the exploit

249
00:09:11,519 --> 00:09:13,440
and then first down we'll talk about the

250
00:09:13,440 --> 00:09:14,720
heap grooming

251
00:09:14,720 --> 00:09:17,040
sure yeah

252
00:09:17,040 --> 00:09:18,480
so

253
00:09:18,480 --> 00:09:20,800
there are four steps in every exploit

254
00:09:20,800 --> 00:09:22,640
the first is grooming the heap i will

255
00:09:22,640 --> 00:09:24,560
talk about that

256
00:09:24,560 --> 00:09:25,680
in a minute

257
00:09:25,680 --> 00:09:27,920
then you need to leak some information

258
00:09:27,920 --> 00:09:29,519
we call it an information leak that's

259
00:09:29,519 --> 00:09:31,760
because most things are randomized in

260
00:09:31,760 --> 00:09:33,519
memory so you need to know where stuff

261
00:09:33,519 --> 00:09:34,880
is in memory

262
00:09:34,880 --> 00:09:37,839
then you need to hijack the control flow

263
00:09:37,839 --> 00:09:39,680
you want to determine which function the

264
00:09:39,680 --> 00:09:42,399
application calls and then you build a

265
00:09:42,399 --> 00:09:44,080
what we call rob chain to actually

266
00:09:44,080 --> 00:09:46,399
execute code of your own

267
00:09:46,399 --> 00:09:47,920
let's start with the first one the heap

268
00:09:47,920 --> 00:09:49,600
grooming part

269
00:09:49,600 --> 00:09:50,480
so

270
00:09:50,480 --> 00:09:52,800
the goal of this step is to make sure

271
00:09:52,800 --> 00:09:55,839
the application doesn't crash

272
00:09:55,839 --> 00:09:57,920
and make room for what we need so we

273
00:09:57,920 --> 00:09:59,760
cannot trigger a buffer overflow so we

274
00:09:59,760 --> 00:10:02,160
can override arbitrary data that's on

275
00:10:02,160 --> 00:10:03,200
the heap

276
00:10:03,200 --> 00:10:05,920
however we

277
00:10:05,920 --> 00:10:07,920
don't we don't want to overwrite random

278
00:10:07,920 --> 00:10:09,760
data we want to override some very

279
00:10:09,760 --> 00:10:12,800
specific data that we put there so we

280
00:10:12,800 --> 00:10:14,720
need to make sure that whatever we

281
00:10:14,720 --> 00:10:15,920
overwrite

282
00:10:15,920 --> 00:10:18,480
is behind the buffer that will

283
00:10:18,480 --> 00:10:21,600
eventually be allocated and overflown

284
00:10:21,600 --> 00:10:22,560
the

285
00:10:22,560 --> 00:10:25,440
tricky part here is making sure that the

286
00:10:25,440 --> 00:10:28,800
right object is behind our buffer in in

287
00:10:28,800 --> 00:10:29,760
the heap

288
00:10:29,760 --> 00:10:32,079
because even other object is there that

289
00:10:32,079 --> 00:10:33,680
we didn't expect or

290
00:10:33,680 --> 00:10:35,839
accounted for then the most likely

291
00:10:35,839 --> 00:10:37,440
outcome is that the application will

292
00:10:37,440 --> 00:10:41,200
crash due to some memory invalidation

293
00:10:41,200 --> 00:10:43,360
so we need to make sure that the heap is

294
00:10:43,360 --> 00:10:46,079
in a predictable state

295
00:10:46,079 --> 00:10:47,040
so

296
00:10:47,040 --> 00:10:49,200
for those who are not too familiar with

297
00:10:49,200 --> 00:10:51,519
the heap the heap is something in

298
00:10:51,519 --> 00:10:54,320
software which is used for dynamically

299
00:10:54,320 --> 00:10:56,800
allocating memory so if you at compile

300
00:10:56,800 --> 00:10:58,959
time don't know the size of certain

301
00:10:58,959 --> 00:11:01,519
objects you typically use the heap for

302
00:11:01,519 --> 00:11:03,120
this

303
00:11:03,120 --> 00:11:04,560
those who know c

304
00:11:04,560 --> 00:11:07,680
might know the malloc and free function

305
00:11:07,680 --> 00:11:10,720
those are used to either request a space

306
00:11:10,720 --> 00:11:12,959
some space on the heap or return the

307
00:11:12,959 --> 00:11:14,560
space once you're done with it to give

308
00:11:14,560 --> 00:11:16,880
it back to the heap allocator

309
00:11:16,880 --> 00:11:19,680
so how the heap is actually implemented

310
00:11:19,680 --> 00:11:23,120
varies by platform or even by an any

311
00:11:23,120 --> 00:11:26,000
major minor software update

312
00:11:26,000 --> 00:11:28,800
so

313
00:11:28,800 --> 00:11:31,040
we were targeting windows and windows

314
00:11:31,040 --> 00:11:32,959
has two implementations for the heap the

315
00:11:32,959 --> 00:11:35,360
first one is the old mt heap which is

316
00:11:35,360 --> 00:11:37,760
still commonly used and you have a new

317
00:11:37,760 --> 00:11:40,000
segment heap which is only used for i

318
00:11:40,000 --> 00:11:42,640
think metro applications and some other

319
00:11:42,640 --> 00:11:45,040
applications but almost all applications

320
00:11:45,040 --> 00:11:47,760
use the old nt heap and zoom was no

321
00:11:47,760 --> 00:11:50,240
exception

322
00:11:50,320 --> 00:11:52,959
so how does the mt heap work

323
00:11:52,959 --> 00:11:54,480
well

324
00:11:54,480 --> 00:11:57,519
three blocks are ordered by size in a

325
00:11:57,519 --> 00:12:00,480
linked list and whenever you request the

326
00:12:00,480 --> 00:12:03,680
block it will walk that free list and it

327
00:12:03,680 --> 00:12:04,399
will

328
00:12:04,399 --> 00:12:06,079
take the first

329
00:12:06,079 --> 00:12:07,920
block that fits your needs so if you

330
00:12:07,920 --> 00:12:10,880
request 2024 bytes it will look for the

331
00:12:10,880 --> 00:12:12,399
first block that

332
00:12:12,399 --> 00:12:14,800
contains at least twenty thousand four

333
00:12:14,800 --> 00:12:17,200
uh three bit bytes

334
00:12:17,200 --> 00:12:20,079
so and if you deallocate something using

335
00:12:20,079 --> 00:12:24,000
free it will merge adjacent three blocks

336
00:12:24,000 --> 00:12:27,600
so if your block that you just freeze is

337
00:12:27,600 --> 00:12:29,680
adjacent to a block that was already

338
00:12:29,680 --> 00:12:31,920
free then it will merge that to making

339
00:12:31,920 --> 00:12:33,839
one bigger block and insert that in the

340
00:12:33,839 --> 00:12:36,320
free list

341
00:12:36,320 --> 00:12:39,760
one particular thing is that it the nt

342
00:12:39,760 --> 00:12:41,839
heap has also a function which is called

343
00:12:41,839 --> 00:12:44,079
the low fragmented heap

344
00:12:44,079 --> 00:12:46,959
this is used for allocation size that is

345
00:12:46,959 --> 00:12:49,200
are that are very common then it uses a

346
00:12:49,200 --> 00:12:51,120
whole different heaping

347
00:12:51,120 --> 00:12:53,680
or heat algorithm

348
00:12:53,680 --> 00:12:54,720
the

349
00:12:54,720 --> 00:12:56,800
low fragment heap is triggered whenever

350
00:12:56,800 --> 00:13:00,560
you do 17 allocations of a certain size

351
00:13:00,560 --> 00:13:03,360
so whenever 17 allocations of a certain

352
00:13:03,360 --> 00:13:04,480
size are done

353
00:13:04,480 --> 00:13:06,959
all requests of that specific size are

354
00:13:06,959 --> 00:13:09,600
handled by the low fragment heap

355
00:13:09,600 --> 00:13:12,000
there is no current going back to the mt

356
00:13:12,000 --> 00:13:15,279
heap once a particular size is

357
00:13:15,279 --> 00:13:18,560
sent to the low fragment heap

358
00:13:18,560 --> 00:13:21,040
so the low fragmented heap is used for

359
00:13:21,040 --> 00:13:23,360
common location sizes and it is done so

360
00:13:23,360 --> 00:13:26,079
that you have less fragmentation so less

361
00:13:26,079 --> 00:13:27,920
free space that you can no longer use on

362
00:13:27,920 --> 00:13:29,920
the nt heap

363
00:13:29,920 --> 00:13:32,000
so

364
00:13:32,000 --> 00:13:34,800
similar sizes are handled by what we

365
00:13:34,800 --> 00:13:38,000
call a bucket so uh uh

366
00:13:38,000 --> 00:13:40,079
like in a range of 80 bytes everything

367
00:13:40,079 --> 00:13:43,040
between there so like 24

368
00:13:43,040 --> 00:13:47,040
1024 bytes up until 1080 bytes are all

369
00:13:47,040 --> 00:13:49,760
handled by what we call a bucket

370
00:13:49,760 --> 00:13:51,360
and the

371
00:13:51,360 --> 00:13:53,519
thing with the low fragment heap is

372
00:13:53,519 --> 00:13:56,000
that it is not deterministic the

373
00:13:56,000 --> 00:13:58,720
anti-heap is deterministic you know if

374
00:13:58,720 --> 00:14:00,720
you can predict how the free list will

375
00:14:00,720 --> 00:14:03,600
look like and it will always

376
00:14:03,600 --> 00:14:05,360
pick the same block

377
00:14:05,360 --> 00:14:07,360
so you can reason about how the shape of

378
00:14:07,360 --> 00:14:10,000
the heap will be at the other end

379
00:14:10,000 --> 00:14:13,279
the low fragment heap uses randomization

380
00:14:13,279 --> 00:14:17,040
so it has no fixed block that it will

381
00:14:17,040 --> 00:14:19,360
return if you request some memory

382
00:14:19,360 --> 00:14:22,480
and this is specifically done for making

383
00:14:22,480 --> 00:14:25,279
exploitation more difficult

384
00:14:25,279 --> 00:14:26,480
so

385
00:14:26,480 --> 00:14:28,240
if something is on the low fragment heap

386
00:14:28,240 --> 00:14:30,720
it means that precise grooming so making

387
00:14:30,720 --> 00:14:31,839
sure that

388
00:14:31,839 --> 00:14:34,560
the block behind our buffer it contains

389
00:14:34,560 --> 00:14:36,320
what we wanted to contain

390
00:14:36,320 --> 00:14:38,560
nearly impossible because due to the

391
00:14:38,560 --> 00:14:41,279
randomization

392
00:14:41,279 --> 00:14:44,079
i'm gonna demonstrate that here this is

393
00:14:44,079 --> 00:14:45,920
the low fragment heap

394
00:14:45,920 --> 00:14:48,320
for a particular size it now has three

395
00:14:48,320 --> 00:14:52,079
buckets but it's only using bucket one

396
00:14:52,079 --> 00:14:55,600
and if you request something it will

397
00:14:55,600 --> 00:14:56,880
it will just

398
00:14:56,880 --> 00:14:59,839
pick a random block in the first bucket

399
00:14:59,839 --> 00:15:02,000
up until the point that the first bucket

400
00:15:02,000 --> 00:15:04,160
is full and it will then allocate

401
00:15:04,160 --> 00:15:07,519
randomly in the second bucket

402
00:15:08,079 --> 00:15:09,519
so

403
00:15:09,519 --> 00:15:11,680
our original plan was

404
00:15:11,680 --> 00:15:12,560
that

405
00:15:12,560 --> 00:15:13,839
the

406
00:15:13,839 --> 00:15:15,839
buffer we can overflow is thousand

407
00:15:15,839 --> 00:15:18,000
twenty four thousand forty bytes

408
00:15:18,000 --> 00:15:20,240
and we try to use

409
00:15:20,240 --> 00:15:22,320
the nt heap to shape the heap in a

410
00:15:22,320 --> 00:15:24,079
predictable state

411
00:15:24,079 --> 00:15:27,120
but this is very difficult because

412
00:15:27,120 --> 00:15:28,880
the zoom application

413
00:15:28,880 --> 00:15:31,680
you it creates hundreds of allocations

414
00:15:31,680 --> 00:15:33,920
every second it talks to api endpoints

415
00:15:33,920 --> 00:15:36,560
etc etc so the heap is really messy

416
00:15:36,560 --> 00:15:38,959
but even if the heap if the application

417
00:15:38,959 --> 00:15:41,040
didn't do anything else even sending a

418
00:15:41,040 --> 00:15:42,480
single message

419
00:15:42,480 --> 00:15:43,600
made it

420
00:15:43,600 --> 00:15:45,199
the heap in a very unpredictable state

421
00:15:45,199 --> 00:15:46,959
because for parsing a message it would

422
00:15:46,959 --> 00:15:49,360
copy every string 10 times et cetera et

423
00:15:49,360 --> 00:15:51,440
cetera so

424
00:15:51,440 --> 00:15:54,000
shaping the nte heap was proven to be

425
00:15:54,000 --> 00:15:55,440
very difficult

426
00:15:55,440 --> 00:15:57,519
but with a second problem and that was

427
00:15:57,519 --> 00:16:00,560
every now and then the size we used the

428
00:16:00,560 --> 00:16:03,120
1040 bytes was already handled by the

429
00:16:03,120 --> 00:16:04,720
low fragment heap

430
00:16:04,720 --> 00:16:05,600
so

431
00:16:05,600 --> 00:16:08,399
if that k if that was the case then all

432
00:16:08,399 --> 00:16:10,480
our shaping efforts were useless because

433
00:16:10,480 --> 00:16:12,399
it was handled by a completely different

434
00:16:12,399 --> 00:16:14,720
heap implementation

435
00:16:14,720 --> 00:16:16,160
so

436
00:16:16,160 --> 00:16:18,079
if you read online about

437
00:16:18,079 --> 00:16:20,079
memory exploitation on windows they

438
00:16:20,079 --> 00:16:21,920
always say okay make sure that you're on

439
00:16:21,920 --> 00:16:23,759
the mt heap because once you're on the

440
00:16:23,759 --> 00:16:25,920
low fragment heap exploitation is near

441
00:16:25,920 --> 00:16:28,720
impossible due to the randomization

442
00:16:28,720 --> 00:16:30,560
but we couldn't make it work on the mte

443
00:16:30,560 --> 00:16:32,880
heap so we thought okay there are people

444
00:16:32,880 --> 00:16:34,560
saying that but we're gonna try it

445
00:16:34,560 --> 00:16:35,680
anyway

446
00:16:35,680 --> 00:16:36,639
so

447
00:16:36,639 --> 00:16:38,079
what we did was

448
00:16:38,079 --> 00:16:40,639
we made sure that the buffer size that

449
00:16:40,639 --> 00:16:43,519
we could overflow was on the

450
00:16:43,519 --> 00:16:45,279
low fragment heap

451
00:16:45,279 --> 00:16:46,399
and

452
00:16:46,399 --> 00:16:48,959
rider exploits using

453
00:16:48,959 --> 00:16:50,720
working around the randomness of the low

454
00:16:50,720 --> 00:16:52,480
fragment heap

455
00:16:52,480 --> 00:16:55,199
so how we did that was

456
00:16:55,199 --> 00:16:57,360
by making sure that

457
00:16:57,360 --> 00:17:00,000
we were the only thing that was making

458
00:17:00,000 --> 00:17:02,399
allocations in a certain bucket

459
00:17:02,399 --> 00:17:03,680
and

460
00:17:03,680 --> 00:17:06,240
by just running our exploit multiple

461
00:17:06,240 --> 00:17:07,439
times

462
00:17:07,439 --> 00:17:10,160
it could happen that uh in one of those

463
00:17:10,160 --> 00:17:11,199
attempts

464
00:17:11,199 --> 00:17:13,839
the randomization

465
00:17:13,839 --> 00:17:15,119
didn't matter anymore because the

466
00:17:15,119 --> 00:17:16,640
allocations were right next to each

467
00:17:16,640 --> 00:17:18,480
other

468
00:17:18,480 --> 00:17:20,079
so

469
00:17:20,079 --> 00:17:22,240
what we did was

470
00:17:22,240 --> 00:17:25,039
the bucket one has some random objects

471
00:17:25,039 --> 00:17:27,439
in it already we don't know about

472
00:17:27,439 --> 00:17:29,200
because the application is an unknown

473
00:17:29,200 --> 00:17:31,840
state before we start our exploit

474
00:17:31,840 --> 00:17:33,919
we send a lot of messages from a

475
00:17:33,919 --> 00:17:35,840
particular size to make sure that all

476
00:17:35,840 --> 00:17:37,520
buckets

477
00:17:37,520 --> 00:17:40,080
are full

478
00:17:40,960 --> 00:17:43,200
then we deallocate

479
00:17:43,200 --> 00:17:46,400
most of the last messages we sent and

480
00:17:46,400 --> 00:17:48,559
what that did was it made sure that

481
00:17:48,559 --> 00:17:50,559
bucket three was nearly empty but the

482
00:17:50,559 --> 00:17:52,240
only thing we didn't delete was the last

483
00:17:52,240 --> 00:17:54,240
message we sent so we made sure that the

484
00:17:54,240 --> 00:17:57,200
last message was in bucket three or how

485
00:17:57,200 --> 00:17:59,200
many buckets there were on the system at

486
00:17:59,200 --> 00:18:01,440
that time um but because we didn't

487
00:18:01,440 --> 00:18:03,520
delete the last message bucket three was

488
00:18:03,520 --> 00:18:05,120
still the active bucket

489
00:18:05,120 --> 00:18:07,679
so all allocations will now be handled

490
00:18:07,679 --> 00:18:10,559
by bucket three and due to the fact that

491
00:18:10,559 --> 00:18:12,960
the buckets we chose the bracket size we

492
00:18:12,960 --> 00:18:16,000
had was relatively quiet we could run

493
00:18:16,000 --> 00:18:18,880
the exploit relatively safely multiple

494
00:18:18,880 --> 00:18:20,880
times to try to override the right

495
00:18:20,880 --> 00:18:23,280
object

496
00:18:23,919 --> 00:18:25,600
guys can you tell us a little bit more

497
00:18:25,600 --> 00:18:28,000
about the information leak yes so the

498
00:18:28,000 --> 00:18:30,080
next step for the exploit is the

499
00:18:30,080 --> 00:18:32,640
information leak

500
00:18:32,640 --> 00:18:35,200
and the reason why we need this is that

501
00:18:35,200 --> 00:18:38,080
there's all of these annoying protection

502
00:18:38,080 --> 00:18:40,480
mechanisms in operating systems nowadays

503
00:18:40,480 --> 00:18:43,520
like aslr and this is a protection

504
00:18:43,520 --> 00:18:44,960
mechanism

505
00:18:44,960 --> 00:18:46,640
address space layout randomization is

506
00:18:46,640 --> 00:18:48,799
what it stands for and what it does is

507
00:18:48,799 --> 00:18:51,280
that it places everything in memory at

508
00:18:51,280 --> 00:18:53,200
random locations every time you launch

509
00:18:53,200 --> 00:18:54,960
the application

510
00:18:54,960 --> 00:18:58,799
so we needed some way to know

511
00:18:58,799 --> 00:19:00,720
where certain things are in memory like

512
00:19:00,720 --> 00:19:02,400
certain libraries

513
00:19:02,400 --> 00:19:05,760
to use the code from that library

514
00:19:05,760 --> 00:19:07,280
but um

515
00:19:07,280 --> 00:19:09,760
yeah it was randomized so we needed to

516
00:19:09,760 --> 00:19:11,840
find some way to leak that information

517
00:19:11,840 --> 00:19:13,840
back to us

518
00:19:13,840 --> 00:19:15,039
but this was

519
00:19:15,039 --> 00:19:16,640
quite a challenge because the buffer

520
00:19:16,640 --> 00:19:19,600
overflow we had was a something that can

521
00:19:19,600 --> 00:19:22,480
write to memory and we somehow had to

522
00:19:22,480 --> 00:19:24,240
turn something that can write into

523
00:19:24,240 --> 00:19:26,480
something that can read like

524
00:19:26,480 --> 00:19:27,360
yeah

525
00:19:27,360 --> 00:19:30,559
trying to read a book using a pen

526
00:19:30,559 --> 00:19:33,120
so we had to combine it with another low

527
00:19:33,120 --> 00:19:37,479
impact vulnerability that we found

528
00:19:38,000 --> 00:19:40,000
some point we had decided that we wanted

529
00:19:40,000 --> 00:19:42,240
to leak an address of lip crypto this is

530
00:19:42,240 --> 00:19:44,960
one of the libraries included in openssl

531
00:19:44,960 --> 00:19:46,320
we'll talk more about why we

532
00:19:46,320 --> 00:19:50,399
specifically wanted that library later

533
00:19:50,640 --> 00:19:52,480
and the objects that we wanted to use

534
00:19:52,480 --> 00:19:54,799
they had to fit in the buckets otherwise

535
00:19:54,799 --> 00:19:56,880
our exploit doesn't or our vulnerability

536
00:19:56,880 --> 00:19:58,640
doesn't affect them

537
00:19:58,640 --> 00:20:00,240
but you also needed a way to get that

538
00:20:00,240 --> 00:20:02,240
data sent back to us

539
00:20:02,240 --> 00:20:03,840
we needed to know what the memory

540
00:20:03,840 --> 00:20:05,360
contents are

541
00:20:05,360 --> 00:20:06,799
but

542
00:20:06,799 --> 00:20:09,200
xmpp means it's xml that has to go

543
00:20:09,200 --> 00:20:11,120
through the server and if you send

544
00:20:11,120 --> 00:20:12,960
something that's not valid xml then the

545
00:20:12,960 --> 00:20:14,720
server will close connection and it will

546
00:20:14,720 --> 00:20:16,320
not go to us

547
00:20:16,320 --> 00:20:18,799
so go sending that information leak over

548
00:20:18,799 --> 00:20:22,559
xmpp wasn't really an option

549
00:20:22,559 --> 00:20:24,480
so instead we started looking for a way

550
00:20:24,480 --> 00:20:28,080
to make a https request to us

551
00:20:28,080 --> 00:20:30,559
directly to us instead of a zoom server

552
00:20:30,559 --> 00:20:31,919
because this would be a channel where

553
00:20:31,919 --> 00:20:33,840
the connection is direct instead of to

554
00:20:33,840 --> 00:20:36,320
the server giving us much more control

555
00:20:36,320 --> 00:20:38,880
and making it yeah

556
00:20:38,880 --> 00:20:41,280
easier for us to send some

557
00:20:41,280 --> 00:20:44,159
real data through it

558
00:20:44,159 --> 00:20:46,080
and eventually we found some weird way

559
00:20:46,080 --> 00:20:48,159
to do that

560
00:20:48,159 --> 00:20:51,360
now the zoom chat functionality has

561
00:20:51,360 --> 00:20:53,360
what's called a marketplace

562
00:20:53,360 --> 00:20:54,960
which are basically bots that you can

563
00:20:54,960 --> 00:20:56,480
add to your account that you can then

564
00:20:56,480 --> 00:20:59,120
interact with through the zoom client

565
00:20:59,120 --> 00:21:00,960
whenever you add a new bot to your

566
00:21:00,960 --> 00:21:03,200
account you do that on a website

567
00:21:03,200 --> 00:21:05,679
and then zoom will start downloading the

568
00:21:05,679 --> 00:21:08,720
image of that bot to display it in the

569
00:21:08,720 --> 00:21:11,120
client

570
00:21:11,679 --> 00:21:15,039
and what we noticed is that

571
00:21:15,200 --> 00:21:17,280
it sends that message to uh to zoom but

572
00:21:17,280 --> 00:21:19,600
we can also send that message

573
00:21:19,600 --> 00:21:21,360
and then it takes you the domain

574
00:21:21,360 --> 00:21:24,360
marketplacecontent.zoom.us

575
00:21:24,640 --> 00:21:27,440
and whatever path was sent by the server

576
00:21:27,440 --> 00:21:28,559
for

577
00:21:28,559 --> 00:21:29,679
the image

578
00:21:29,679 --> 00:21:32,400
is put after it

579
00:21:32,400 --> 00:21:34,080
but as you see

580
00:21:34,080 --> 00:21:36,880
what they send starts with a slash

581
00:21:36,880 --> 00:21:39,440
but what if we started with a dot

582
00:21:39,440 --> 00:21:40,880
well then it would start downloading

583
00:21:40,880 --> 00:21:42,159
that image from

584
00:21:42,159 --> 00:21:42,679
marketplacecontent.zoom.us.com.nel

585
00:21:42,679 --> 00:21:45,679
marketplacecontent.zoom

586
00:21:46,320 --> 00:21:48,240
which is now simply a domain under our

587
00:21:48,240 --> 00:21:49,360
control

588
00:21:49,360 --> 00:21:51,520
so it was it would download that image

589
00:21:51,520 --> 00:21:53,600
from us instead of the marketplace

590
00:21:53,600 --> 00:21:55,440
server of zoom

591
00:21:55,440 --> 00:21:57,440
so by sending that message it would

592
00:21:57,440 --> 00:22:00,400
start yeah would initiate an https

593
00:22:00,400 --> 00:22:03,200
connection to us

594
00:22:04,880 --> 00:22:08,000
and then the object that we wanted to

595
00:22:08,000 --> 00:22:09,760
use for our leak

596
00:22:09,760 --> 00:22:12,880
we found the tls1 prfp key context

597
00:22:12,880 --> 00:22:13,840
object

598
00:22:13,840 --> 00:22:16,799
which is in openssl

599
00:22:16,799 --> 00:22:18,640
this is an object that's created during

600
00:22:18,640 --> 00:22:21,840
the tls handshake

601
00:22:22,240 --> 00:22:23,440
to

602
00:22:23,440 --> 00:22:24,840
hash some data i

603
00:22:24,840 --> 00:22:27,360
think was one thing about it that's a

604
00:22:27,360 --> 00:22:29,520
bit annoying for us is that they create

605
00:22:29,520 --> 00:22:32,159
it they fill it with data

606
00:22:32,159 --> 00:22:34,320
and then once the handshake is done they

607
00:22:34,320 --> 00:22:36,400
delete it again so it's

608
00:22:36,400 --> 00:22:38,559
deallocated immediately after it was

609
00:22:38,559 --> 00:22:40,480
used

610
00:22:40,480 --> 00:22:43,360
so that was a bit tricky

611
00:22:43,360 --> 00:22:45,120
but it was a good target for us because

612
00:22:45,120 --> 00:22:47,679
at the first location in that object

613
00:22:47,679 --> 00:22:50,000
is a pointer that we could use for our

614
00:22:50,000 --> 00:22:51,520
information leak

615
00:22:51,520 --> 00:22:53,120
if we have that pointer then we can

616
00:22:53,120 --> 00:22:56,400
compute every part of libcrypto and we

617
00:22:56,400 --> 00:22:59,440
know where everything in memory is

618
00:22:59,440 --> 00:23:02,720
and importantly that first pointer was

619
00:23:02,720 --> 00:23:05,760
not erased if the object was deallocated

620
00:23:05,760 --> 00:23:07,600
so if the object was

621
00:23:07,600 --> 00:23:10,159
cleared it erases some memory but not

622
00:23:10,159 --> 00:23:12,080
this specific pointer

623
00:23:12,080 --> 00:23:15,919
so this is the definition of this object

624
00:23:15,919 --> 00:23:18,000
not really easy to read here but at the

625
00:23:18,000 --> 00:23:20,720
first slot there's a pointer into lip

626
00:23:20,720 --> 00:23:21,679
crypto

627
00:23:21,679 --> 00:23:24,720
and because this one was not erased

628
00:23:24,720 --> 00:23:27,840
we could leak it back to us

629
00:23:27,840 --> 00:23:31,280
so we formulated the following plan

630
00:23:31,280 --> 00:23:33,520
we used that vulnerability we had to set

631
00:23:33,520 --> 00:23:35,200
up two connections

632
00:23:35,200 --> 00:23:38,240
to an https server of us

633
00:23:38,240 --> 00:23:39,919
and on one of these connections we close

634
00:23:39,919 --> 00:23:42,640
it immediately after the handshake

635
00:23:42,640 --> 00:23:44,559
to make sure that these objects are in

636
00:23:44,559 --> 00:23:46,320
memory somewhere although they are

637
00:23:46,320 --> 00:23:48,400
deallocated

638
00:23:48,400 --> 00:23:50,080
on the second connection we request a

639
00:23:50,080 --> 00:23:51,039
path

640
00:23:51,039 --> 00:23:53,679
of 1025 bytes

641
00:23:53,679 --> 00:23:55,440
which is a size that fits within the

642
00:23:55,440 --> 00:23:58,000
same bucket

643
00:23:58,400 --> 00:24:00,720
and then we use the buffer overflow to

644
00:24:00,720 --> 00:24:03,520
override everything up to the first nil

645
00:24:03,520 --> 00:24:07,120
byte after that string

646
00:24:07,919 --> 00:24:09,919
and then we complete the connection

647
00:24:09,919 --> 00:24:11,919
and then when it sends that path to the

648
00:24:11,919 --> 00:24:14,400
server it will keep reading on after the

649
00:24:14,400 --> 00:24:17,360
url and then it will also include that

650
00:24:17,360 --> 00:24:21,120
memory in the request it sends to us

651
00:24:21,120 --> 00:24:21,919
so

652
00:24:21,919 --> 00:24:24,320
we'll try to make that a bit more visual

653
00:24:24,320 --> 00:24:26,240
so this was the url that we could make

654
00:24:26,240 --> 00:24:26,880
it

655
00:24:26,880 --> 00:24:29,760
perform a request to

656
00:24:29,760 --> 00:24:32,799
and the way that c stores strings in

657
00:24:32,799 --> 00:24:33,840
memory

658
00:24:33,840 --> 00:24:36,240
is that it always puts a zero byte at

659
00:24:36,240 --> 00:24:37,520
the end

660
00:24:37,520 --> 00:24:40,159
so in this case there would be a zero

661
00:24:40,159 --> 00:24:41,279
there

662
00:24:41,279 --> 00:24:44,799
to denote the end of the string

663
00:24:45,679 --> 00:24:48,240
and every function that works at strings

664
00:24:48,240 --> 00:24:50,000
just knows that it needs to keep reading

665
00:24:50,000 --> 00:24:52,240
up to that zero byte which means that

666
00:24:52,240 --> 00:24:53,440
you don't need to keep track of the

667
00:24:53,440 --> 00:24:56,080
length of these strings that you have

668
00:24:56,080 --> 00:24:57,679
so if you would complete this request

669
00:24:57,679 --> 00:24:59,679
this was go reading and then see that

670
00:24:59,679 --> 00:25:02,960
zero there and stop

671
00:25:02,960 --> 00:25:06,240
but if we trigger our vulnerability at

672
00:25:06,240 --> 00:25:08,960
this moment before we do this connection

673
00:25:08,960 --> 00:25:12,880
then we can start overwriting

674
00:25:13,200 --> 00:25:14,880
that data

675
00:25:14,880 --> 00:25:16,880
and if you go all the way to that zero

676
00:25:16,880 --> 00:25:20,880
but not as everything afterwards

677
00:25:21,200 --> 00:25:23,200
and then the connection is

678
00:25:23,200 --> 00:25:25,520
continued then it continues reading

679
00:25:25,520 --> 00:25:27,840
after that

680
00:25:27,840 --> 00:25:30,080
so the data that's in memory there is

681
00:25:30,080 --> 00:25:32,720
now also sent back to us and this way we

682
00:25:32,720 --> 00:25:34,400
have read read some memory that we

683
00:25:34,400 --> 00:25:36,880
needed to

684
00:25:36,880 --> 00:25:39,120
compute compute where the entire lib

685
00:25:39,120 --> 00:25:42,080
crypto is in memory

686
00:25:42,080 --> 00:25:43,840
now

687
00:25:43,840 --> 00:25:46,960
this chain was very unreliable

688
00:25:46,960 --> 00:25:48,880
i tried to do this and then it worked

689
00:25:48,880 --> 00:25:51,520
once and then it didn't work again for

690
00:25:51,520 --> 00:25:53,760
at least a day and then it worked twice

691
00:25:53,760 --> 00:25:56,400
in the same day we had to get it to work

692
00:25:56,400 --> 00:25:58,880
within five minutes so we really had to

693
00:25:58,880 --> 00:26:02,640
improve this to make it work better

694
00:26:02,640 --> 00:26:04,640
but one of the things we could do is set

695
00:26:04,640 --> 00:26:08,480
up multiple connections to both servers

696
00:26:08,480 --> 00:26:10,159
to basically increase the chances of the

697
00:26:10,159 --> 00:26:11,679
objects being in memory at the right

698
00:26:11,679 --> 00:26:13,200
places

699
00:26:13,200 --> 00:26:15,039
you could renegotiate the connection

700
00:26:15,039 --> 00:26:16,799
which is a feature in tls that you can

701
00:26:16,799 --> 00:26:18,799
do a handshake on an existing connection

702
00:26:18,799 --> 00:26:19,679
again

703
00:26:19,679 --> 00:26:21,200
which is convenient because it was

704
00:26:21,200 --> 00:26:23,200
faster to renegotiate and open a new

705
00:26:23,200 --> 00:26:24,960
connection

706
00:26:24,960 --> 00:26:26,400
you could trigger the buffer overflow

707
00:26:26,400 --> 00:26:28,159
multiple times to increase the chances

708
00:26:28,159 --> 00:26:30,159
as we would randomly override the right

709
00:26:30,159 --> 00:26:31,120
thing

710
00:26:31,120 --> 00:26:32,400
and eventually

711
00:26:32,400 --> 00:26:36,240
we got it to working reliably

712
00:26:36,240 --> 00:26:38,559
well good enough for the competition

713
00:26:38,559 --> 00:26:41,200
um but really the we spent a lot of time

714
00:26:41,200 --> 00:26:43,840
on getting this to work as reliable as

715
00:26:43,840 --> 00:26:44,880
we could

716
00:26:44,880 --> 00:26:46,880
still wasn't perfect but good enough to

717
00:26:46,880 --> 00:26:50,480
uh to actually make it work

718
00:26:50,720 --> 00:26:53,279
now the next step of the exploit is

719
00:26:53,279 --> 00:26:55,279
hijacking the control flow

720
00:26:55,279 --> 00:26:57,919
which then we'll uh talk about

721
00:26:57,919 --> 00:27:00,480
yeah so we can somewhat predict the

722
00:27:00,480 --> 00:27:01,919
state of the heap

723
00:27:01,919 --> 00:27:03,679
it's not perfect because it's randomized

724
00:27:03,679 --> 00:27:06,880
but uh we can at least kind of predict

725
00:27:06,880 --> 00:27:08,720
that we won't overflow in anything

726
00:27:08,720 --> 00:27:10,960
important we leaked some information

727
00:27:10,960 --> 00:27:13,360
about where lip crypto is in memory

728
00:27:13,360 --> 00:27:15,360
so now we're up to the third step and

729
00:27:15,360 --> 00:27:17,520
then that is actually hijacking the

730
00:27:17,520 --> 00:27:19,440
control flow so making sure that the

731
00:27:19,440 --> 00:27:21,440
application executes code that we wanted

732
00:27:21,440 --> 00:27:24,159
to execute rather than just continuing

733
00:27:24,159 --> 00:27:26,880
on with its normal execution

734
00:27:26,880 --> 00:27:29,120
so

735
00:27:29,360 --> 00:27:30,880
how do you do this

736
00:27:30,880 --> 00:27:31,840
well

737
00:27:31,840 --> 00:27:34,320
we can't modify any of the application

738
00:27:34,320 --> 00:27:36,159
codes because that's a whole different

739
00:27:36,159 --> 00:27:38,480
memory reason we can only

740
00:27:38,480 --> 00:27:41,760
change data on the heap

741
00:27:42,640 --> 00:27:44,720
so the goal of this change is override

742
00:27:44,720 --> 00:27:46,880
something that

743
00:27:46,880 --> 00:27:49,840
determines which function will be called

744
00:27:49,840 --> 00:27:51,760
so we could make it to call the function

745
00:27:51,760 --> 00:27:53,840
foo for example rather than the function

746
00:27:53,840 --> 00:27:57,200
bar it's supposed to be calling

747
00:27:57,200 --> 00:27:58,000
so

748
00:27:58,000 --> 00:27:59,840
there are a couple of options for this

749
00:27:59,840 --> 00:28:02,240
but the most likely one is to find a

750
00:28:02,240 --> 00:28:03,600
function pointer

751
00:28:03,600 --> 00:28:05,600
on the heap that we can override so

752
00:28:05,600 --> 00:28:07,120
sometimes on the heap there will be a

753
00:28:07,120 --> 00:28:09,039
pointer to a function and if we could

754
00:28:09,039 --> 00:28:11,120
override that pointer and that function

755
00:28:11,120 --> 00:28:12,720
pointer would be used then we could

756
00:28:12,720 --> 00:28:16,240
determine which function will get called

757
00:28:16,240 --> 00:28:19,679
the other option is a v table pointer

758
00:28:19,679 --> 00:28:22,640
whenever a v table is being used a v

759
00:28:22,640 --> 00:28:24,399
table is something specific

760
00:28:24,399 --> 00:28:26,720
specific for c plus plus but due to the

761
00:28:26,720 --> 00:28:28,960
fact that zoom is written in c plus plus

762
00:28:28,960 --> 00:28:31,039
overriding a v table pointer is a valid

763
00:28:31,039 --> 00:28:32,320
option as well

764
00:28:32,320 --> 00:28:34,480
the only constraint is that

765
00:28:34,480 --> 00:28:36,399
the allocation must be within the same

766
00:28:36,399 --> 00:28:38,399
buckets of course because otherwise we

767
00:28:38,399 --> 00:28:40,640
couldn't override it

768
00:28:40,640 --> 00:28:42,720
so let's look a little bit closer about

769
00:28:42,720 --> 00:28:45,120
what a v table actually is

770
00:28:45,120 --> 00:28:47,919
it's using c plus for virtual functions

771
00:28:47,919 --> 00:28:50,320
and basically a v table is a list of

772
00:28:50,320 --> 00:28:51,919
function pointers

773
00:28:51,919 --> 00:28:54,880
and every object in memory in c plus

774
00:28:54,880 --> 00:28:58,880
starts with a pointer to a v table

775
00:28:58,880 --> 00:29:00,960
let me quickly demonstrate this for you

776
00:29:00,960 --> 00:29:03,520
so suppose you have a clock class dog in

777
00:29:03,520 --> 00:29:05,200
c plus plus

778
00:29:05,200 --> 00:29:08,320
and you initiate an object for this

779
00:29:08,320 --> 00:29:10,840
how this actually is stored in

780
00:29:10,840 --> 00:29:14,000
memory is

781
00:29:14,399 --> 00:29:17,120
at the first offset you have a pointer

782
00:29:17,120 --> 00:29:20,240
to the v table of the dog object so it's

783
00:29:20,240 --> 00:29:23,120
just a list of pointers to where it can

784
00:29:23,120 --> 00:29:25,440
find for example the function sound or

785
00:29:25,440 --> 00:29:26,960
walk

786
00:29:26,960 --> 00:29:27,760
and

787
00:29:27,760 --> 00:29:29,760
right after the v table pointer there

788
00:29:29,760 --> 00:29:31,840
are all the instance variables

789
00:29:31,840 --> 00:29:34,399
this is how in c plus plus an object is

790
00:29:34,399 --> 00:29:36,720
stored in memory

791
00:29:36,720 --> 00:29:38,240
so

792
00:29:38,240 --> 00:29:39,679
this is all on the heap or at least the

793
00:29:39,679 --> 00:29:41,360
v table pointer and the the instance

794
00:29:41,360 --> 00:29:43,360
variables so

795
00:29:43,360 --> 00:29:46,159
suppose we could overwrite a v table

796
00:29:46,159 --> 00:29:48,240
pointer and we could find a way to

797
00:29:48,240 --> 00:29:50,720
construct our own v table somewhere in

798
00:29:50,720 --> 00:29:52,840
memory so just a list of function

799
00:29:52,840 --> 00:29:55,919
pointers we could possibly hijack the

800
00:29:55,919 --> 00:29:57,919
control flow because if that pointer get

801
00:29:57,919 --> 00:29:59,919
the reference to look for a function

802
00:29:59,919 --> 00:30:01,919
pointer and we could determine which

803
00:30:01,919 --> 00:30:04,640
function that would be then we have

804
00:30:04,640 --> 00:30:06,320
control over the

805
00:30:06,320 --> 00:30:08,720
program counter

806
00:30:08,720 --> 00:30:10,320
so

807
00:30:10,320 --> 00:30:12,880
look simple but that was quite difficult

808
00:30:12,880 --> 00:30:14,559
because first we had to find an object

809
00:30:14,559 --> 00:30:16,960
of the right size that was in our bucket

810
00:30:16,960 --> 00:30:18,799
then we needed to override that fee

811
00:30:18,799 --> 00:30:21,760
table pointer with a memory address we

812
00:30:21,760 --> 00:30:23,760
know about and where we can control the

813
00:30:23,760 --> 00:30:24,960
data

814
00:30:24,960 --> 00:30:28,320
which is a whole different problem

815
00:30:28,320 --> 00:30:29,200
and

816
00:30:29,200 --> 00:30:30,960
we have to make sure that the v table

817
00:30:30,960 --> 00:30:34,240
was actually used so the first step was

818
00:30:34,240 --> 00:30:36,399
let's find a v table point that we can

819
00:30:36,399 --> 00:30:38,080
override that is actually being used by

820
00:30:38,080 --> 00:30:39,440
the application

821
00:30:39,440 --> 00:30:42,320
so we spent quite some time on this

822
00:30:42,320 --> 00:30:44,880
and eventually we found the solution in

823
00:30:44,880 --> 00:30:46,159
this sound

824
00:30:46,159 --> 00:30:49,960
let's hope the sound works

825
00:30:50,799 --> 00:30:52,960
so

826
00:30:53,039 --> 00:30:55,600
i'm so tired of this sound so

827
00:30:55,600 --> 00:30:56,960
that

828
00:30:56,960 --> 00:30:59,679
we call each other daily whole day

829
00:30:59,679 --> 00:31:01,440
in order to generate that sound so

830
00:31:01,440 --> 00:31:03,679
whenever you can request somebody in a

831
00:31:03,679 --> 00:31:06,000
meeting so you can call somebody

832
00:31:06,000 --> 00:31:08,559
and whenever that's done

833
00:31:08,559 --> 00:31:10,799
it will create an object of the right

834
00:31:10,799 --> 00:31:11,919
size

835
00:31:11,919 --> 00:31:14,960
for loading this sound from disk it's

836
00:31:14,960 --> 00:31:17,679
just a audio file it's on disk and it

837
00:31:17,679 --> 00:31:18,480
will

838
00:31:18,480 --> 00:31:20,080
load the file

839
00:31:20,080 --> 00:31:22,080
place it in memory in an object with a v

840
00:31:22,080 --> 00:31:24,240
table pointer and then it will play the

841
00:31:24,240 --> 00:31:25,120
sound

842
00:31:25,120 --> 00:31:27,120
and then it will use that v table for

843
00:31:27,120 --> 00:31:28,880
the close to determine which function to

844
00:31:28,880 --> 00:31:30,880
use to close that sound again

845
00:31:30,880 --> 00:31:33,519
it's a sound of it's only one ring and

846
00:31:33,519 --> 00:31:35,600
it will constantly open the file close

847
00:31:35,600 --> 00:31:37,039
the file open the file close the file

848
00:31:37,039 --> 00:31:38,559
etc

849
00:31:38,559 --> 00:31:40,720
this was an ideal target for us

850
00:31:40,720 --> 00:31:42,720
it was of the right size it was being

851
00:31:42,720 --> 00:31:43,679
used

852
00:31:43,679 --> 00:31:46,240
and we could override that v table

853
00:31:46,240 --> 00:31:48,159
pointer

854
00:31:48,159 --> 00:31:50,240
one problem was

855
00:31:50,240 --> 00:31:51,120
we

856
00:31:51,120 --> 00:31:52,640
don't know where

857
00:31:52,640 --> 00:31:55,039
our data is in memory it's somewhere on

858
00:31:55,039 --> 00:31:56,720
the heap but we don't know where on the

859
00:31:56,720 --> 00:31:59,600
heap that is we only at this point know

860
00:31:59,600 --> 00:32:02,000
a address of lip crypto

861
00:32:02,000 --> 00:32:04,080
so we needed to make sure that we had

862
00:32:04,080 --> 00:32:07,440
some custom data at a well-known place

863
00:32:07,440 --> 00:32:09,440
so

864
00:32:09,440 --> 00:32:13,039
we had a theory about this

865
00:32:13,039 --> 00:32:16,080
zoom is a 32-bit application means that

866
00:32:16,080 --> 00:32:18,399
and that means that the amount of memory

867
00:32:18,399 --> 00:32:20,559
that zoom can use is very limited on

868
00:32:20,559 --> 00:32:23,120
windows it's only two gigabytes

869
00:32:23,120 --> 00:32:25,600
so we thought okay what if we just take

870
00:32:25,600 --> 00:32:28,080
take a random address in memory just

871
00:32:28,080 --> 00:32:29,360
something

872
00:32:29,360 --> 00:32:31,200
which most likely doesn't contain

873
00:32:31,200 --> 00:32:33,039
anything

874
00:32:33,039 --> 00:32:35,840
what if we can find a way to exhaust all

875
00:32:35,840 --> 00:32:36,799
memory

876
00:32:36,799 --> 00:32:38,559
so what if we can make

877
00:32:38,559 --> 00:32:41,440
zoom allocate some large space

878
00:32:41,440 --> 00:32:42,880
and

879
00:32:42,880 --> 00:32:44,880
if we do that often enough

880
00:32:44,880 --> 00:32:47,200
at some points

881
00:32:47,200 --> 00:32:49,440
some data that we control will be at

882
00:32:49,440 --> 00:32:51,279
that location because there is no other

883
00:32:51,279 --> 00:32:53,519
place to put it

884
00:32:53,519 --> 00:32:54,880
so

885
00:32:54,880 --> 00:32:56,960
we were working on this theory and

886
00:32:56,960 --> 00:32:59,120
seeing okay where can we find some

887
00:32:59,120 --> 00:33:02,320
object that we can control contains our

888
00:33:02,320 --> 00:33:05,919
data so we can test test this theory

889
00:33:05,919 --> 00:33:08,480
so one of the things we tried was

890
00:33:08,480 --> 00:33:11,600
sending images to the other party by

891
00:33:11,600 --> 00:33:14,080
just creating a very large image of 100

892
00:33:14,080 --> 00:33:16,240
megabytes or 20 megabytes

893
00:33:16,240 --> 00:33:18,080
and then send that to the other party

894
00:33:18,080 --> 00:33:20,000
because zoom has to show that image to

895
00:33:20,000 --> 00:33:22,080
you so it has to load it in memory and

896
00:33:22,080 --> 00:33:23,840
if we send it multiple times maybe it

897
00:33:23,840 --> 00:33:25,360
will get allocated multiple times in

898
00:33:25,360 --> 00:33:26,720
memory as well

899
00:33:26,720 --> 00:33:28,320
so that's the theory

900
00:33:28,320 --> 00:33:29,440
only

901
00:33:29,440 --> 00:33:31,760
zoom has some protection for this

902
00:33:31,760 --> 00:33:33,519
if you send an image

903
00:33:33,519 --> 00:33:35,279
it will show the image

904
00:33:35,279 --> 00:33:37,440
if the image is under i think one

905
00:33:37,440 --> 00:33:40,799
kilobyte or 100 kilobytes or something

906
00:33:40,799 --> 00:33:43,760
at least a very small amount

907
00:33:43,760 --> 00:33:46,320
and if the image is larger than this it

908
00:33:46,320 --> 00:33:48,480
will first request the user if it wants

909
00:33:48,480 --> 00:33:50,240
to download this image

910
00:33:50,240 --> 00:33:52,399
so that was of no use for us because

911
00:33:52,399 --> 00:33:56,240
then we required some user interaction

912
00:33:56,240 --> 00:33:57,760
so

913
00:33:57,760 --> 00:33:59,679
for this we use a third vulnerability

914
00:33:59,679 --> 00:34:02,240
and the last vulnerability

915
00:34:02,240 --> 00:34:04,399
zoom also has the possibility to send

916
00:34:04,399 --> 00:34:06,880
gify images to each other

917
00:34:06,880 --> 00:34:11,040
those are stored on the server of zoom

918
00:34:11,599 --> 00:34:14,000
those are always downloaded and shown no

919
00:34:14,000 --> 00:34:15,520
matter the size because they think it's

920
00:34:15,520 --> 00:34:17,839
a giphy with control data but we found

921
00:34:17,839 --> 00:34:19,599
some path reversal vulnerability on the

922
00:34:19,599 --> 00:34:21,839
server of zoom so we could actually

923
00:34:21,839 --> 00:34:25,199
upload a very large file

924
00:34:25,199 --> 00:34:28,320
and then send that file as a giphy which

925
00:34:28,320 --> 00:34:30,399
would make sure that zoom would download

926
00:34:30,399 --> 00:34:32,079
it and

927
00:34:32,079 --> 00:34:36,560
display the image regardless of its size

928
00:34:38,560 --> 00:34:39,359
so

929
00:34:39,359 --> 00:34:41,119
we used a gif image that actually

930
00:34:41,119 --> 00:34:43,599
contained our v table

931
00:34:43,599 --> 00:34:45,760
with list of pointers

932
00:34:45,760 --> 00:34:48,159
and we just sent that image multiple

933
00:34:48,159 --> 00:34:49,918
times we created an image of 25

934
00:34:49,918 --> 00:34:52,480
megabytes and we sent that 20 times that

935
00:34:52,480 --> 00:34:54,480
means that 500 megabytes of the two

936
00:34:54,480 --> 00:34:58,079
gigabytes is containing our data and

937
00:34:58,079 --> 00:34:59,920
this was enough data so that we could

938
00:34:59,920 --> 00:35:02,000
predictably say okay this random address

939
00:35:02,000 --> 00:35:04,400
that will always contain our

940
00:35:04,400 --> 00:35:06,960
vague fee table

941
00:35:06,960 --> 00:35:08,880
so we would first send

942
00:35:08,880 --> 00:35:12,000
this givi link to the other party and

943
00:35:12,000 --> 00:35:14,480
then we would

944
00:35:14,480 --> 00:35:16,560
call the other party request them in the

945
00:35:16,560 --> 00:35:18,560
meeting and then we overwrite

946
00:35:18,560 --> 00:35:21,280
the close the v table pointer that would

947
00:35:21,280 --> 00:35:23,359
point to the close function

948
00:35:23,359 --> 00:35:26,640
this is how we actually got code

949
00:35:26,640 --> 00:35:29,200
could hijack the control flow so now we

950
00:35:29,200 --> 00:35:31,280
can control which code the zoom

951
00:35:31,280 --> 00:35:34,240
application will run

952
00:35:37,200 --> 00:35:40,240
so we can now divert it to different

953
00:35:40,240 --> 00:35:42,000
parts of the application

954
00:35:42,000 --> 00:35:43,920
but what you really want is to make it

955
00:35:43,920 --> 00:35:46,800
run our own code instead of zooms code

956
00:35:46,800 --> 00:35:47,920
so we want

957
00:35:47,920 --> 00:35:52,000
arbitrary remote code execution

958
00:35:52,880 --> 00:35:55,040
so

959
00:35:55,760 --> 00:35:57,440
one thing that you might be able to do

960
00:35:57,440 --> 00:35:59,280
is to construct a rock chain

961
00:35:59,280 --> 00:36:01,280
but that

962
00:36:01,280 --> 00:36:03,280
needs to be on the stack and we have a

963
00:36:03,280 --> 00:36:05,680
buffer overflow on the heap

964
00:36:05,680 --> 00:36:07,839
so

965
00:36:08,079 --> 00:36:10,240
first let's talk a bit about warp chain

966
00:36:10,240 --> 00:36:13,119
so rob chain is a way to create a sort

967
00:36:13,119 --> 00:36:15,280
of a fake stack to make sure that

968
00:36:15,280 --> 00:36:17,280
whenever the application returns

969
00:36:17,280 --> 00:36:18,079
it

970
00:36:18,079 --> 00:36:20,400
calls another bit of the application so

971
00:36:20,400 --> 00:36:22,320
in this way you can basically string

972
00:36:22,320 --> 00:36:24,480
together very small bits of code of the

973
00:36:24,480 --> 00:36:26,880
application that already exists

974
00:36:26,880 --> 00:36:29,200
to make it do something you want to do

975
00:36:29,200 --> 00:36:31,520
so i cannot introduce new codes yet but

976
00:36:31,520 --> 00:36:33,119
i can just combine different parts of

977
00:36:33,119 --> 00:36:34,320
the code

978
00:36:34,320 --> 00:36:36,160
to make it do something that i wanted to

979
00:36:36,160 --> 00:36:37,359
do

980
00:36:37,359 --> 00:36:39,040
but we cannot do that yet because we

981
00:36:39,040 --> 00:36:40,720
don't control the stack we could only

982
00:36:40,720 --> 00:36:43,439
control the heap

983
00:36:45,040 --> 00:36:47,280
so that's why we needed to find

984
00:36:47,280 --> 00:36:50,000
something that's known as a stack pivot

985
00:36:50,000 --> 00:36:51,599
and what this basically means is that we

986
00:36:51,599 --> 00:36:53,520
can replace the location of the stack

987
00:36:53,520 --> 00:36:54,560
pointer

988
00:36:54,560 --> 00:36:56,640
so instead of overwriting a stack we

989
00:36:56,640 --> 00:36:58,640
just redefine the stack to be somewhere

990
00:36:58,640 --> 00:37:01,440
else in memory

991
00:37:01,520 --> 00:37:03,200
but something else that we needed to

992
00:37:03,200 --> 00:37:05,119
keep in mind here

993
00:37:05,119 --> 00:37:08,160
is that there's a relatively new

994
00:37:08,160 --> 00:37:09,760
protection mechanism

995
00:37:09,760 --> 00:37:12,400
known as control flow guard

996
00:37:12,400 --> 00:37:14,640
this is yet another protection mechanism

997
00:37:14,640 --> 00:37:16,160
against return

998
00:37:16,160 --> 00:37:18,400
against this types of vulnerability

999
00:37:18,400 --> 00:37:20,079
because it aims to prevent return

1000
00:37:20,079 --> 00:37:22,560
oriented programming

1001
00:37:22,560 --> 00:37:24,240
because whenever you try to call

1002
00:37:24,240 --> 00:37:26,160
function pointer

1003
00:37:26,160 --> 00:37:28,320
the compiler will insert a check that

1004
00:37:28,320 --> 00:37:30,320
will look at that function pointer and

1005
00:37:30,320 --> 00:37:32,079
it will try to determine if that's a

1006
00:37:32,079 --> 00:37:35,280
valid start address of a function

1007
00:37:35,280 --> 00:37:37,359
so the reason why that's annoying is

1008
00:37:37,359 --> 00:37:39,599
that in a warp chain you often just use

1009
00:37:39,599 --> 00:37:41,760
some very small bits of an existing

1010
00:37:41,760 --> 00:37:43,920
function

1011
00:37:43,920 --> 00:37:45,760
but this is no longer possible because

1012
00:37:45,760 --> 00:37:47,680
you can only start at the start of a

1013
00:37:47,680 --> 00:37:51,359
function you cannot just jump in halfway

1014
00:37:51,359 --> 00:37:52,800
so there's basically

1015
00:37:52,800 --> 00:37:54,560
two ways that we could bypass control

1016
00:37:54,560 --> 00:37:56,640
flow guard

1017
00:37:56,640 --> 00:37:59,920
first of all we could call one function

1018
00:37:59,920 --> 00:38:02,000
and that's basically it

1019
00:38:02,000 --> 00:38:03,839
but we really couldn't find anything

1020
00:38:03,839 --> 00:38:06,720
that was usable for that

1021
00:38:06,720 --> 00:38:07,520
or

1022
00:38:07,520 --> 00:38:09,119
we could look at the library that's not

1023
00:38:09,119 --> 00:38:11,520
compiled with control flow guards

1024
00:38:11,520 --> 00:38:13,520
and as we what one thing we noticed is

1025
00:38:13,520 --> 00:38:15,440
that that lib crypto library that we've

1026
00:38:15,440 --> 00:38:16,960
been talking about for the information

1027
00:38:16,960 --> 00:38:19,280
leak did not have control flow guard

1028
00:38:19,280 --> 00:38:20,320
enabled

1029
00:38:20,320 --> 00:38:22,560
apparently openssl has a weird build

1030
00:38:22,560 --> 00:38:24,960
system where control flow guard

1031
00:38:24,960 --> 00:38:28,960
doesn't work for something like that

1032
00:38:29,119 --> 00:38:33,280
so that means basically two things um

1033
00:38:33,280 --> 00:38:35,760
any function pointer being called within

1034
00:38:35,760 --> 00:38:38,640
openssl does not have that check

1035
00:38:38,640 --> 00:38:41,040
but that's not what we wanted to use it

1036
00:38:41,040 --> 00:38:42,480
also means

1037
00:38:42,480 --> 00:38:43,280
that

1038
00:38:43,280 --> 00:38:46,320
valid start addresses are not known for

1039
00:38:46,320 --> 00:38:47,760
libcrypto

1040
00:38:47,760 --> 00:38:49,359
so we can just jump

1041
00:38:49,359 --> 00:38:52,000
into any function at any location

1042
00:38:52,000 --> 00:38:55,359
so that's what we used here

1043
00:38:55,680 --> 00:38:57,520
we found a stackpivot gadget so

1044
00:38:57,520 --> 00:38:59,440
basically something that we could use to

1045
00:38:59,440 --> 00:39:01,520
redefine the stack to be somewhere else

1046
00:39:01,520 --> 00:39:03,040
which meant that we could

1047
00:39:03,040 --> 00:39:06,800
execute more by using evop chain

1048
00:39:06,800 --> 00:39:09,440
then we used the rob chain to make

1049
00:39:09,440 --> 00:39:11,440
some part of the giphy image that we

1050
00:39:11,440 --> 00:39:12,480
sent

1051
00:39:12,480 --> 00:39:14,880
executable so it was now data that we

1052
00:39:14,880 --> 00:39:16,800
sent that was now also allowed to be

1053
00:39:16,800 --> 00:39:18,640
executed

1054
00:39:18,640 --> 00:39:20,480
so we could also only use the gadgets

1055
00:39:20,480 --> 00:39:22,800
from the capital of course

1056
00:39:22,800 --> 00:39:24,880
and then we could jump to the codes

1057
00:39:24,880 --> 00:39:27,760
included in the giphy and then it would

1058
00:39:27,760 --> 00:39:31,680
execute some shell code that we uploaded

1059
00:39:33,440 --> 00:39:35,920
and there was also a bit of

1060
00:39:35,920 --> 00:39:38,640
difficulty with that because we

1061
00:39:38,640 --> 00:39:40,800
didn't have the function that we needed

1062
00:39:40,800 --> 00:39:42,400
but luckily we had a function that you

1063
00:39:42,400 --> 00:39:44,480
could use to look up dynamically the

1064
00:39:44,480 --> 00:39:46,160
address of that function

1065
00:39:46,160 --> 00:39:48,720
so we had get module handle

1066
00:39:48,720 --> 00:39:49,839
we could

1067
00:39:49,839 --> 00:39:52,480
look where kernel 32 was in memory

1068
00:39:52,480 --> 00:39:54,320
we could store that

1069
00:39:54,320 --> 00:39:56,000
and then get the address of virtual

1070
00:39:56,000 --> 00:39:57,440
protect

1071
00:39:57,440 --> 00:39:58,800
this is the function that you could use

1072
00:39:58,800 --> 00:40:01,520
to make our code executable

1073
00:40:01,520 --> 00:40:02,560
um

1074
00:40:02,560 --> 00:40:04,160
and then we could call it to make the

1075
00:40:04,160 --> 00:40:06,160
giphy executable and then jim to it to

1076
00:40:06,160 --> 00:40:09,960
start executing it

1077
00:40:11,760 --> 00:40:13,440
now we have a demonstration of the

1078
00:40:13,440 --> 00:40:14,880
attack

1079
00:40:14,880 --> 00:40:16,240
what you see here on the left is a

1080
00:40:16,240 --> 00:40:18,960
windows vm and it will show that is the

1081
00:40:18,960 --> 00:40:21,920
latest version at this time

1082
00:40:21,920 --> 00:40:23,680
on the right you see the output of our

1083
00:40:23,680 --> 00:40:26,240
exploit

1084
00:40:32,960 --> 00:40:34,400
and we start by

1085
00:40:34,400 --> 00:40:36,000
sending all of those messages for the

1086
00:40:36,000 --> 00:40:37,440
heap grooming

1087
00:40:37,440 --> 00:40:39,280
so if you look very carefully at the top

1088
00:40:39,280 --> 00:40:43,280
you'll see that the counter is going up

1089
00:40:51,119 --> 00:40:53,040
it should go up to about

1090
00:40:53,040 --> 00:40:55,920
90 i think

1091
00:41:03,040 --> 00:41:04,000
and then

1092
00:41:04,000 --> 00:41:06,240
after this we start deleting some of

1093
00:41:06,240 --> 00:41:08,720
those but keeping that last one to keep

1094
00:41:08,720 --> 00:41:11,760
that bucket active to have yeah the room

1095
00:41:11,760 --> 00:41:13,040
that we needed for the rest of our

1096
00:41:13,040 --> 00:41:14,560
exploit

1097
00:41:14,560 --> 00:41:16,000
there's a couple of other steps in here

1098
00:41:16,000 --> 00:41:18,240
that we didn't talk about to

1099
00:41:18,240 --> 00:41:20,160
basically make the memory optimal for

1100
00:41:20,160 --> 00:41:22,400
our exploit

1101
00:41:22,400 --> 00:41:24,400
and now it's deleting those messages by

1102
00:41:24,400 --> 00:41:25,920
deleting the mess

1103
00:41:25,920 --> 00:41:28,800
yeah to revoke those

1104
00:41:28,800 --> 00:41:31,200
blocks

1105
00:41:31,200 --> 00:41:34,400
now we start the information leak we

1106
00:41:34,400 --> 00:41:38,800
make it connect to our http server

1107
00:41:39,119 --> 00:41:40,880
in this case we are pretty lucky this

1108
00:41:40,880 --> 00:41:43,200
needs to run in certain loops

1109
00:41:43,200 --> 00:41:45,680
but in this case we were already in the

1110
00:41:45,680 --> 00:41:48,800
second loop i think it succeeded

1111
00:41:48,800 --> 00:41:50,800
yes at the bottom there it now shows the

1112
00:41:50,800 --> 00:41:53,200
information leak obtained and it has

1113
00:41:53,200 --> 00:41:55,920
devised what the addresses of lip crypto

1114
00:41:55,920 --> 00:41:58,240
now sending those giffies to a load the

1115
00:41:58,240 --> 00:42:01,720
fake fee table

1116
00:42:07,200 --> 00:42:08,720
and now it should

1117
00:42:08,720 --> 00:42:10,480
send a call request

1118
00:42:10,480 --> 00:42:12,720
i think in this case it sounds only

1119
00:42:12,720 --> 00:42:14,160
played twice we don't have it in the

1120
00:42:14,160 --> 00:42:15,839
recording sadly

1121
00:42:15,839 --> 00:42:20,279
but you're also very lucky that it works

1122
00:42:22,310 --> 00:42:35,040
[Applause]

1123
00:42:35,040 --> 00:42:37,359
thank you and as a customary we start

1124
00:42:37,359 --> 00:42:39,680
the calculator many people wonder why is

1125
00:42:39,680 --> 00:42:41,680
there certainly a calculator running but

1126
00:42:41,680 --> 00:42:43,119
it's basically to demonstrate that we

1127
00:42:43,119 --> 00:42:46,640
can now run any application it could be

1128
00:42:46,640 --> 00:42:48,480
anything else you could install some

1129
00:42:48,480 --> 00:42:50,240
ransomware whatever we wanted on this

1130
00:42:50,240 --> 00:42:51,200
machine

1131
00:42:51,200 --> 00:42:53,520
and as you can see we can just also use

1132
00:42:53,520 --> 00:42:55,280
other commands to

1133
00:42:55,280 --> 00:42:59,319
basically take over that computer

1134
00:42:59,520 --> 00:43:00,640
now

1135
00:43:00,640 --> 00:43:02,720
we skipped over a lot of the details

1136
00:43:02,720 --> 00:43:03,920
there's quite a lot of work more

1137
00:43:03,920 --> 00:43:05,839
involved here but we have a more

1138
00:43:05,839 --> 00:43:07,520
complete write-up on our website so if

1139
00:43:07,520 --> 00:43:09,359
you want to read that you can visit that

1140
00:43:09,359 --> 00:43:11,520
link or if you have any other questions

1141
00:43:11,520 --> 00:43:13,839
then please let us know or come visit us

1142
00:43:13,839 --> 00:43:16,560
at our tent

1143
00:43:21,760 --> 00:43:25,480
pretty awesome

1144
00:43:26,480 --> 00:43:29,040
so if there are any questions um please

1145
00:43:29,040 --> 00:43:31,680
uh line up behind the the two mics here

1146
00:43:31,680 --> 00:43:33,440
um do we have any questions from the

1147
00:43:33,440 --> 00:43:35,440
internet at all

1148
00:43:35,440 --> 00:43:37,760
no questions from the internet

1149
00:43:37,760 --> 00:43:39,520
okay i have a question how long did it

1150
00:43:39,520 --> 00:43:42,240
take you to to uh kind of do the whole

1151
00:43:42,240 --> 00:43:45,040
whole process basically two months about

1152
00:43:45,040 --> 00:43:46,960
two months yeah it took about two weeks

1153
00:43:46,960 --> 00:43:48,880
to find the vulnerability and that's

1154
00:43:48,880 --> 00:43:51,440
basically starting from scratch because

1155
00:43:51,440 --> 00:43:54,240
we hadn't used zoom very much so we

1156
00:43:54,240 --> 00:43:55,520
basically had to go through all of the

1157
00:43:55,520 --> 00:43:57,520
functions first and then two more two

1158
00:43:57,520 --> 00:44:00,319
weeks we had the vulnerability and then

1159
00:44:00,319 --> 00:44:02,319
one and a half months to develop the

1160
00:44:02,319 --> 00:44:03,680
exploit

1161
00:44:03,680 --> 00:44:05,200
that you used eventually for the

1162
00:44:05,200 --> 00:44:07,280
competition and then we were out of time

1163
00:44:07,280 --> 00:44:09,920
and yeah we had to uh do it with what we

1164
00:44:09,920 --> 00:44:11,839
had the two one and a half months was

1165
00:44:11,839 --> 00:44:13,359
also because we have never done memory

1166
00:44:13,359 --> 00:44:14,880
corruption on windows we've done a lot

1167
00:44:14,880 --> 00:44:16,880
of it on mac os and linux but this was

1168
00:44:16,880 --> 00:44:18,560
the first on windows so we had to learn

1169
00:44:18,560 --> 00:44:21,200
all the windows internals as well so

1170
00:44:21,200 --> 00:44:23,280
yeah that's part of this yeah awesome so

1171
00:44:23,280 --> 00:44:25,359
i think we've got one uh here go go

1172
00:44:25,359 --> 00:44:26,640
ahead

1173
00:44:26,640 --> 00:44:27,440
okay

1174
00:44:27,440 --> 00:44:29,760
so first of all congratulations the work

1175
00:44:29,760 --> 00:44:30,960
is amazing

1176
00:44:30,960 --> 00:44:33,359
thank you uh my question is about the

1177
00:44:33,359 --> 00:44:35,200
path reversal actually

1178
00:44:35,200 --> 00:44:37,359
how did you know that the image that you

1179
00:44:37,359 --> 00:44:40,319
uploaded on zoom and the jiffys are on

1180
00:44:40,319 --> 00:44:42,240
the same place

1181
00:44:42,240 --> 00:44:43,920
what's on the same host name

1182
00:44:43,920 --> 00:44:44,880
so

1183
00:44:44,880 --> 00:44:47,520
name yeah it was false.zoom.us

1184
00:44:47,520 --> 00:44:48,960
and because we were intercepting all

1185
00:44:48,960 --> 00:44:51,280
traffic we could easily see that it was

1186
00:44:51,280 --> 00:44:53,440
yeah very similar but it wasn't a

1187
00:44:53,440 --> 00:44:55,359
different path i don't really remember

1188
00:44:55,359 --> 00:44:57,280
the full path but

1189
00:44:57,280 --> 00:44:59,040
by sending something with some dotted

1190
00:44:59,040 --> 00:45:02,079
slashes it would think it's a giphy but

1191
00:45:02,079 --> 00:45:04,079
then still download it

1192
00:45:04,079 --> 00:45:06,319
and show it okay and my second question

1193
00:45:06,319 --> 00:45:07,200
is

1194
00:45:07,200 --> 00:45:08,640
how did you know that you will have

1195
00:45:08,640 --> 00:45:09,680
enough

1196
00:45:09,680 --> 00:45:13,359
let's say data after that null byte

1197
00:45:13,359 --> 00:45:15,839
from the link if you remember

1198
00:45:15,839 --> 00:45:17,040
um

1199
00:45:17,040 --> 00:45:19,040
so if the right data would be behind the

1200
00:45:19,040 --> 00:45:22,480
no byte yeah so basically if because you

1201
00:45:22,480 --> 00:45:25,200
can meet another null byte just after a

1202
00:45:25,200 --> 00:45:27,280
little bit of data oh how did you know

1203
00:45:27,280 --> 00:45:29,200
that would be enough yeah it would only

1204
00:45:29,200 --> 00:45:30,480
work if they were

1205
00:45:30,480 --> 00:45:33,040
right next to each other yeah

1206
00:45:33,040 --> 00:45:35,040
which is also why it took a long time so

1207
00:45:35,040 --> 00:45:37,680
we had to retry quite often

1208
00:45:37,680 --> 00:45:38,800
um

1209
00:45:38,800 --> 00:45:40,000
so yeah it might be that there's

1210
00:45:40,000 --> 00:45:41,920
something else in memory then it doesn't

1211
00:45:41,920 --> 00:45:43,359
work

1212
00:45:43,359 --> 00:45:45,760
but if we're lucky and basically the two

1213
00:45:45,760 --> 00:45:46,880
things are

1214
00:45:46,880 --> 00:45:48,160
or basically there need to be three

1215
00:45:48,160 --> 00:45:50,640
things in memory adjacent to each other

1216
00:45:50,640 --> 00:45:52,400
so if we get lucky and that's the case

1217
00:45:52,400 --> 00:45:53,839
then it worked and we got the

1218
00:45:53,839 --> 00:45:55,839
information but because we did all of

1219
00:45:55,839 --> 00:45:58,640
the heap growing we could safely retry a

1220
00:45:58,640 --> 00:46:02,079
couple of times until it would work yeah

1221
00:46:02,079 --> 00:46:04,640
the heap grooming took anywhere between

1222
00:46:04,640 --> 00:46:07,760
30 seconds or five minutes depending if

1223
00:46:07,760 --> 00:46:09,760
we got lucky early in the stage or we

1224
00:46:09,760 --> 00:46:12,319
have to retry multiple times yeah and a

1225
00:46:12,319 --> 00:46:14,319
funny question there's a question at the

1226
00:46:14,319 --> 00:46:16,400
back do you want to ask can we ask the

1227
00:46:16,400 --> 00:46:18,480
question at the back yeah

1228
00:46:18,480 --> 00:46:19,359
all right

1229
00:46:19,359 --> 00:46:22,319
um will this exploit continue to work if

1230
00:46:22,319 --> 00:46:25,280
you have a different a language a muy

1231
00:46:25,280 --> 00:46:29,200
language or a local let's say i

1232
00:46:29,200 --> 00:46:32,160
don't think so i don't see anything that

1233
00:46:32,160 --> 00:46:34,960
is local specific in the exploit yes we

1234
00:46:34,960 --> 00:46:36,880
haven't tried but uh

1235
00:46:36,880 --> 00:46:39,440
i think it it will work yeah

1236
00:46:39,440 --> 00:46:41,599
so we're not safe in europe when we're

1237
00:46:41,599 --> 00:46:43,680
not using english

1238
00:46:43,680 --> 00:46:45,119
no no

1239
00:46:45,119 --> 00:46:47,040
that's great and another question here

1240
00:46:47,040 --> 00:46:48,319
as well

1241
00:46:48,319 --> 00:46:50,000
first of all

1242
00:46:50,000 --> 00:46:51,760
close to the mic first of all this

1243
00:46:51,760 --> 00:46:53,520
exploit is amazing so thank you for

1244
00:46:53,520 --> 00:46:55,119
explaining it to us

1245
00:46:55,119 --> 00:46:57,119
second of all it took you guys

1246
00:46:57,119 --> 00:47:00,240
two months to work this all out yeah um

1247
00:47:00,240 --> 00:47:02,640
for me i'm a very nervous hacker i would

1248
00:47:02,640 --> 00:47:06,240
say um and why would you

1249
00:47:06,240 --> 00:47:08,839
say to start learning about this sort of

1250
00:47:08,839 --> 00:47:11,040
exploitation so just come work as a pen

1251
00:47:11,040 --> 00:47:12,720
tester with us and we'll teach you

1252
00:47:12,720 --> 00:47:13,920
everything

1253
00:47:13,920 --> 00:47:16,319
in a couple of years you can do this

1254
00:47:16,319 --> 00:47:19,520
i'm working as pence's elsewhere so

1255
00:47:19,520 --> 00:47:20,720
but

1256
00:47:20,720 --> 00:47:22,559
there are some

1257
00:47:22,559 --> 00:47:24,240
documentation online about memory

1258
00:47:24,240 --> 00:47:27,040
corruption so like the basics

1259
00:47:27,040 --> 00:47:29,440
some challenge websites that offer some

1260
00:47:29,440 --> 00:47:31,920
playground to do this kind of stuff

1261
00:47:31,920 --> 00:47:34,559
and one thing that i often suggest is to

1262
00:47:34,559 --> 00:47:36,800
look at iot devices because often

1263
00:47:36,800 --> 00:47:38,480
exploitation is simpler there because

1264
00:47:38,480 --> 00:47:40,240
you don't have all of these

1265
00:47:40,240 --> 00:47:42,880
um security mechanisms or maybe you just

1266
00:47:42,880 --> 00:47:45,760
have a couple of them um yeah making it

1267
00:47:45,760 --> 00:47:48,319
easier to get started with something

1268
00:47:48,319 --> 00:47:50,160
okay thank you thanks for the question

1269
00:47:50,160 --> 00:47:52,880
and one last uh anything nothing nothing

1270
00:47:52,880 --> 00:47:54,720
being zoomed in from the internet okay

1271
00:47:54,720 --> 00:47:57,200
great um thank you very much uh so that

1272
00:47:57,200 --> 00:48:00,240
that's that was the talk um just a few

1273
00:48:00,240 --> 00:48:01,839
uh well actually let's thank our

1274
00:48:01,839 --> 00:48:03,520
speakers again

1275
00:48:03,520 --> 00:48:06,680
thank you

1276
00:48:07,500 --> 00:48:13,679
[Applause]

1277
00:48:16,640 --> 00:48:18,720
you

