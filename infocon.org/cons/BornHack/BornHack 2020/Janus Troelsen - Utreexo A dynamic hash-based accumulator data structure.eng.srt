1
00:05:47,280 --> 00:05:51,758
okay

2
00:05:48,720 --> 00:05:55,280
okay hi um so my name is janos

3
00:05:51,759 --> 00:05:58,800
trollson and well i'm presenting a

4
00:05:55,280 --> 00:06:02,799
data structure it's um it's like

5
00:05:58,800 --> 00:06:04,639
it's it's a hash based right accumulator

6
00:06:02,800 --> 00:06:06,479
so i try to describe what it is in the

7
00:06:04,639 --> 00:06:09,199
abstract but um

8
00:06:06,479 --> 00:06:10,159
basically an accumulator is something

9
00:06:09,199 --> 00:06:13,680
that stores

10
00:06:10,160 --> 00:06:15,360
elements and you can then verify that

11
00:06:13,680 --> 00:06:17,680
they exist inside

12
00:06:15,360 --> 00:06:19,360
so you can compare to its set right you

13
00:06:17,680 --> 00:06:20,720
can you can if you have a set you can

14
00:06:19,360 --> 00:06:23,840
say

15
00:06:20,720 --> 00:06:26,400
um we have these elements and

16
00:06:23,840 --> 00:06:28,159
just just the fact that you have the set

17
00:06:26,400 --> 00:06:29,599
is then a proof that every element is

18
00:06:28,160 --> 00:06:31,360
inside the set right

19
00:06:29,600 --> 00:06:33,120
but the problem is it requires the

20
00:06:31,360 --> 00:06:36,560
storage of all the elements

21
00:06:33,120 --> 00:06:38,400
so um so i'm going to present here like

22
00:06:36,560 --> 00:06:40,080
an accumulator that allows you to prove

23
00:06:38,400 --> 00:06:40,799
that elements are inside without

24
00:06:40,080 --> 00:06:42,479
actually

25
00:06:40,800 --> 00:06:43,840
requiring all that storage for all the

26
00:06:42,479 --> 00:06:47,199
elements

27
00:06:43,840 --> 00:06:49,520
and um and yeah and well

28
00:06:47,199 --> 00:06:50,800
it's the only application that i know is

29
00:06:49,520 --> 00:06:53,198
in bitcoin

30
00:06:50,800 --> 00:06:54,960
but uh i want to present it in a way so

31
00:06:53,199 --> 00:06:57,599
that it's not only for bitcoin

32
00:06:54,960 --> 00:06:58,318
so let's see if i can do that and um but

33
00:06:57,599 --> 00:07:00,159
you know

34
00:06:58,319 --> 00:07:02,240
like all the primitives are based on

35
00:07:00,160 --> 00:07:04,400
it's just based on hashing and you know

36
00:07:02,240 --> 00:07:06,319
proving membership and stuff like that

37
00:07:04,400 --> 00:07:08,318
so that's why i'm thinking like this

38
00:07:06,319 --> 00:07:09,840
this should be usable for other things

39
00:07:08,319 --> 00:07:11,919
but since i only have the bitcoin

40
00:07:09,840 --> 00:07:15,039
reference for

41
00:07:11,919 --> 00:07:16,639
for usage i will then try to

42
00:07:15,039 --> 00:07:18,960
you know i would give examples with

43
00:07:16,639 --> 00:07:20,319
bitcoin and because i have a lot of time

44
00:07:18,960 --> 00:07:21,680
i think everybody should just

45
00:07:20,319 --> 00:07:24,240
you know raise a hand if they have a

46
00:07:21,680 --> 00:07:27,039
question and then i can i will explain

47
00:07:24,240 --> 00:07:27,759
if i can um but well i don't i only have

48
00:07:27,039 --> 00:07:30,080
this one

49
00:07:27,759 --> 00:07:31,039
use case so you know every example will

50
00:07:30,080 --> 00:07:33,359
just be like

51
00:07:31,039 --> 00:07:35,199
you know if you need a concrete example

52
00:07:33,360 --> 00:07:38,000
then i will say okay this is how it will

53
00:07:35,199 --> 00:07:41,120
be if it was with bitcoin

54
00:07:38,000 --> 00:07:42,880
okay so here's the agenda and

55
00:07:41,120 --> 00:07:44,960
it's basically just a run through the

56
00:07:42,880 --> 00:07:47,280
algorithm and then you know i have some

57
00:07:44,960 --> 00:07:50,638
questions that i haven't even resolved

58
00:07:47,280 --> 00:07:53,119
and and um

59
00:07:50,639 --> 00:07:54,000
yeah and then i will talk about them so

60
00:07:53,120 --> 00:07:55,919
basically the

61
00:07:54,000 --> 00:07:57,120
like i would i would present all the

62
00:07:55,919 --> 00:07:58,639
stuff i know and then

63
00:07:57,120 --> 00:08:00,319
i would have some questions and then

64
00:07:58,639 --> 00:08:03,759
maybe it can be like a

65
00:08:00,319 --> 00:08:06,720
like a discussion well let's see

66
00:08:03,759 --> 00:08:07,440
so so the the problem with bitcoin is

67
00:08:06,720 --> 00:08:10,720
that

68
00:08:07,440 --> 00:08:12,400
um all the bitcoin that are not spent

69
00:08:10,720 --> 00:08:13,759
right they are called the unspent

70
00:08:12,400 --> 00:08:16,878
bitcoins they

71
00:08:13,759 --> 00:08:18,560
they they are inferred from the whole

72
00:08:16,879 --> 00:08:21,840
blockchain right so

73
00:08:18,560 --> 00:08:23,599
um you have transactions and each

74
00:08:21,840 --> 00:08:26,878
transaction goes into a block

75
00:08:23,599 --> 00:08:29,120
and each transaction will be making

76
00:08:26,879 --> 00:08:30,400
usually it will be making an unspent

77
00:08:29,120 --> 00:08:32,719
transaction output

78
00:08:30,400 --> 00:08:34,559
right this means it's a it's a it's a

79
00:08:32,719 --> 00:08:36,640
bitcoin that could be spent

80
00:08:34,559 --> 00:08:38,319
if you have the right program but it

81
00:08:36,640 --> 00:08:40,799
hasn't been spent yet

82
00:08:38,320 --> 00:08:42,719
and um and this is actually like it's

83
00:08:40,799 --> 00:08:44,399
the most important

84
00:08:42,719 --> 00:08:46,320
if you're a user of bitcoin you want to

85
00:08:44,399 --> 00:08:48,320
know that right you just want to know

86
00:08:46,320 --> 00:08:49,440
has my bitcoin been spent or has it not

87
00:08:48,320 --> 00:08:51,920
been spent

88
00:08:49,440 --> 00:08:53,040
so and this and this set is then

89
00:08:51,920 --> 00:08:55,439
constructed

90
00:08:53,040 --> 00:08:56,800
out of the transactions right you apply

91
00:08:55,440 --> 00:08:59,200
you take the first block

92
00:08:56,800 --> 00:09:00,479
you have some some some some genesis

93
00:08:59,200 --> 00:09:01,040
outputs right that's they're called like

94
00:09:00,480 --> 00:09:03,440
the first

95
00:09:01,040 --> 00:09:05,760
outputs each block makes new outputs but

96
00:09:03,440 --> 00:09:08,080
it's also spending previous outputs

97
00:09:05,760 --> 00:09:09,279
so that means you can't just like if you

98
00:09:08,080 --> 00:09:11,120
have the whole blockchain

99
00:09:09,279 --> 00:09:12,640
and you haven't processed anything you

100
00:09:11,120 --> 00:09:14,640
have to go through the whole thing to

101
00:09:12,640 --> 00:09:15,439
see uh what was spent and where was it

102
00:09:14,640 --> 00:09:18,560
spent too

103
00:09:15,440 --> 00:09:20,080
and all that stuff so so that means this

104
00:09:18,560 --> 00:09:22,000
this thing that i'm talking about the

105
00:09:20,080 --> 00:09:25,279
four gigabyte

106
00:09:22,000 --> 00:09:27,600
set of unspent bitcoin it's like it's

107
00:09:25,279 --> 00:09:28,800
it's it's it's kind of large right for a

108
00:09:27,600 --> 00:09:31,200
phone

109
00:09:28,800 --> 00:09:32,800
and it's super hard to it's super hard

110
00:09:31,200 --> 00:09:34,640
to generate

111
00:09:32,800 --> 00:09:36,240
because you need to process like 300

112
00:09:34,640 --> 00:09:39,760
gigabytes of data just to

113
00:09:36,240 --> 00:09:43,120
just to regenerate it so so um

114
00:09:39,760 --> 00:09:46,399
so the the the thesis of like the the

115
00:09:43,120 --> 00:09:48,480
proposal of utrecht so is that you can

116
00:09:46,399 --> 00:09:51,279
when you give somebody a bitcoin you can

117
00:09:48,480 --> 00:09:53,680
prove that it was not spent

118
00:09:51,279 --> 00:09:54,480
because because we now store all those

119
00:09:53,680 --> 00:09:57,199
on we all

120
00:09:54,480 --> 00:09:58,560
now store all those unspent outputs in

121
00:09:57,200 --> 00:10:00,000
in the accumulator

122
00:09:58,560 --> 00:10:02,160
and we can prove that things are in

123
00:10:00,000 --> 00:10:05,120
there and not so

124
00:10:02,160 --> 00:10:05,760
any any bitcoin user that is like up to

125
00:10:05,120 --> 00:10:08,000
date

126
00:10:05,760 --> 00:10:10,160
with the chain right he's downloading a

127
00:10:08,000 --> 00:10:11,120
block he's applying the changes to his

128
00:10:10,160 --> 00:10:13,680
local

129
00:10:11,120 --> 00:10:14,560
uh set he will then be able to receive

130
00:10:13,680 --> 00:10:17,599
any proof

131
00:10:14,560 --> 00:10:21,279
and it will be it will be specific to to

132
00:10:17,600 --> 00:10:23,839
to his state and um

133
00:10:21,279 --> 00:10:25,600
and and the advantage is that he doesn't

134
00:10:23,839 --> 00:10:27,519
need those four gigabytes

135
00:10:25,600 --> 00:10:30,480
right because he doesn't store the

136
00:10:27,519 --> 00:10:32,480
actual set he just stores like

137
00:10:30,480 --> 00:10:34,160
he just stores a commitment to

138
00:10:32,480 --> 00:10:36,880
everything that's inside the set

139
00:10:34,160 --> 00:10:37,360
and that's just that's that's fine right

140
00:10:36,880 --> 00:10:39,600
because

141
00:10:37,360 --> 00:10:40,959
we all we just want to know that it's

142
00:10:39,600 --> 00:10:42,880
definitely

143
00:10:40,959 --> 00:10:44,399
uh not made up bitcoins when you receive

144
00:10:42,880 --> 00:10:46,640
some bitcoins you want to know

145
00:10:44,399 --> 00:10:48,880
these are not spent at this latest block

146
00:10:46,640 --> 00:10:50,240
right but the accumulator does need to

147
00:10:48,880 --> 00:10:52,640
be updated so

148
00:10:50,240 --> 00:10:53,360
this is the big question and this is

149
00:10:52,640 --> 00:10:57,600
like

150
00:10:53,360 --> 00:11:00,800
what the solution is about um so

151
00:10:57,600 --> 00:11:03,600
we put all the we have all the

152
00:11:00,800 --> 00:11:04,640
the transaction the outputs that are

153
00:11:03,600 --> 00:11:06,959
unsplit bitcoins

154
00:11:04,640 --> 00:11:08,399
we have them as leaves in a tree okay

155
00:11:06,959 --> 00:11:11,359
and it's a perfect

156
00:11:08,399 --> 00:11:12,240
tree that means every every node has two

157
00:11:11,360 --> 00:11:14,560
children

158
00:11:12,240 --> 00:11:16,320
and if it doesn't have two children it's

159
00:11:14,560 --> 00:11:17,839
because it's at the bottom

160
00:11:16,320 --> 00:11:19,519
so that means every it's not an

161
00:11:17,839 --> 00:11:22,720
unbalanced tree and like

162
00:11:19,519 --> 00:11:23,120
every path goes down to the same length

163
00:11:22,720 --> 00:11:24,880
right

164
00:11:23,120 --> 00:11:26,320
so you will see some pictures later and

165
00:11:24,880 --> 00:11:28,720
you will understand that

166
00:11:26,320 --> 00:11:30,800
and it's a hashed as a merkle tree right

167
00:11:28,720 --> 00:11:31,360
so that every node is hashing its

168
00:11:30,800 --> 00:11:34,719
children

169
00:11:31,360 --> 00:11:37,519
and i will show you this too now and

170
00:11:34,720 --> 00:11:38,160
as i talked about you can prove that

171
00:11:37,519 --> 00:11:41,920
that

172
00:11:38,160 --> 00:11:42,640
that an element exists just by providing

173
00:11:41,920 --> 00:11:44,399
the path

174
00:11:42,640 --> 00:11:45,839
right down the tree you provide some

175
00:11:44,399 --> 00:11:48,079
hashes down the tree

176
00:11:45,839 --> 00:11:50,639
and then because the top node is is

177
00:11:48,079 --> 00:11:53,040
committing to everything in the tree

178
00:11:50,639 --> 00:11:54,639
and hashes are made in a way so that

179
00:11:53,040 --> 00:11:55,360
that's that's not supposed to be two

180
00:11:54,639 --> 00:11:59,040
different

181
00:11:55,360 --> 00:11:59,440
sets of data that um i mean you cannot

182
00:11:59,040 --> 00:12:00,959
have

183
00:11:59,440 --> 00:12:01,920
two different sets of data that has to

184
00:12:00,959 --> 00:12:03,119
the same thing right that's the

185
00:12:01,920 --> 00:12:04,479
assumption of the hash

186
00:12:03,120 --> 00:12:06,560
even though it's not actually true we

187
00:12:04,480 --> 00:12:08,160
can assume it to be true and this is why

188
00:12:06,560 --> 00:12:11,279
we can have this space

189
00:12:08,160 --> 00:12:14,880
this space saving because

190
00:12:11,279 --> 00:12:17,920
you know just this as this exists

191
00:12:14,880 --> 00:12:19,680
okay so i will not actually show what an

192
00:12:17,920 --> 00:12:20,639
what a bitcoin output looks like because

193
00:12:19,680 --> 00:12:22,239
it doesn't matter

194
00:12:20,639 --> 00:12:24,079
because we we're talking about set

195
00:12:22,240 --> 00:12:25,200
memberships right so i would only talk

196
00:12:24,079 --> 00:12:27,760
about this tree

197
00:12:25,200 --> 00:12:29,120
and how to manipulate it and then you

198
00:12:27,760 --> 00:12:32,240
have to know that every

199
00:12:29,120 --> 00:12:34,000
every leaf in that tree would have some

200
00:12:32,240 --> 00:12:35,680
bitcoin script associated with it and it

201
00:12:34,000 --> 00:12:38,880
will it will be like you know

202
00:12:35,680 --> 00:12:40,479
this user with this public key can can

203
00:12:38,880 --> 00:12:41,839
spend this right that's what bitcoin

204
00:12:40,480 --> 00:12:44,800
outputs say they say like

205
00:12:41,839 --> 00:12:46,399
i restrict myself to being spent by

206
00:12:44,800 --> 00:12:50,800
somebody who can sign

207
00:12:46,399 --> 00:12:54,639
with this key um so yeah

208
00:12:50,800 --> 00:12:57,439
and um okay so here's our example three

209
00:12:54,639 --> 00:13:00,160
so as you can see it's perfect right and

210
00:12:57,440 --> 00:13:02,079
all the nodes from 0 to 15

211
00:13:00,160 --> 00:13:03,360
they are the leaves so they would be

212
00:13:02,079 --> 00:13:06,719
outputs

213
00:13:03,360 --> 00:13:09,600
and then 30 the top would be the

214
00:13:06,720 --> 00:13:11,760
um it would be the commitment to all of

215
00:13:09,600 --> 00:13:14,720
those nodes

216
00:13:11,760 --> 00:13:15,439
and um and each node like 16 will be a

217
00:13:14,720 --> 00:13:17,920
hash of

218
00:13:15,440 --> 00:13:19,519
of 0 and 1 right and if we want to prove

219
00:13:17,920 --> 00:13:21,519
that any node exists

220
00:13:19,519 --> 00:13:22,800
we have to prove we have to give all the

221
00:13:21,519 --> 00:13:25,200
sibling hashes

222
00:13:22,800 --> 00:13:26,079
like so if we want to prove 4 exists

223
00:13:25,200 --> 00:13:30,079
we'll give

224
00:13:26,079 --> 00:13:34,079
5 and 18 19 25

225
00:13:30,079 --> 00:13:34,079
28 like going up the tree

226
00:13:36,639 --> 00:13:41,760
if you have like some hash that will

227
00:13:38,639 --> 00:13:41,760
commit to every other

228
00:13:42,000 --> 00:13:47,680
okay so

229
00:13:45,760 --> 00:13:50,160
this is kind of what i hinted at earlier

230
00:13:47,680 --> 00:13:52,959
that um we're always changing the tree

231
00:13:50,160 --> 00:13:56,319
because every like every block in

232
00:13:52,959 --> 00:14:00,479
bitcoin will be changing that set right

233
00:13:56,320 --> 00:14:02,240
um so how do we change the trees right

234
00:14:00,480 --> 00:14:03,839
we don't want to rehash everything

235
00:14:02,240 --> 00:14:05,519
because that's a lot of data and we

236
00:14:03,839 --> 00:14:07,199
can't rehash everything because the

237
00:14:05,519 --> 00:14:07,839
point is that we don't store the whole

238
00:14:07,199 --> 00:14:10,079
tree

239
00:14:07,839 --> 00:14:11,040
we can we can manipulate the tree even

240
00:14:10,079 --> 00:14:13,920
though because

241
00:14:11,040 --> 00:14:15,120
if we don't if we only touch things that

242
00:14:13,920 --> 00:14:17,680
are not

243
00:14:15,120 --> 00:14:19,199
um like if we're going down a path right

244
00:14:17,680 --> 00:14:21,040
and we only need data that's

245
00:14:19,199 --> 00:14:22,800
that's from a specific path we actually

246
00:14:21,040 --> 00:14:24,800
don't need the other stuff right

247
00:14:22,800 --> 00:14:26,719
so that means we can manipulate the tree

248
00:14:24,800 --> 00:14:28,479
we can shuffle things around

249
00:14:26,720 --> 00:14:30,000
because we know like for example that a

250
00:14:28,480 --> 00:14:31,760
sibling is committing to a

251
00:14:30,000 --> 00:14:33,120
subtree of this size but if we don't

252
00:14:31,760 --> 00:14:35,360
touch anything

253
00:14:33,120 --> 00:14:37,199
we don't need to know what what that is

254
00:14:35,360 --> 00:14:40,240
so

255
00:14:37,199 --> 00:14:42,000
um so this is also like the second last

256
00:14:40,240 --> 00:14:42,399
bullet point is what i hinted at earlier

257
00:14:42,000 --> 00:14:44,240
like

258
00:14:42,399 --> 00:14:45,920
full blocks they tell us all the data

259
00:14:44,240 --> 00:14:47,519
right but so we can we can

260
00:14:45,920 --> 00:14:50,319
we download the full block and then we

261
00:14:47,519 --> 00:14:52,079
can manipulate that accumulator

262
00:14:50,320 --> 00:14:53,600
and then you say okay if we need to

263
00:14:52,079 --> 00:14:54,800
download the full block what's the point

264
00:14:53,600 --> 00:14:56,320
of all this right then we could just

265
00:14:54,800 --> 00:14:58,240
download all of it and sync like a

266
00:14:56,320 --> 00:14:59,279
normal bitcoin node does now but the

267
00:14:58,240 --> 00:15:01,680
point is that

268
00:14:59,279 --> 00:15:03,279
an old bitcoin node nowadays works in a

269
00:15:01,680 --> 00:15:05,760
way where it actually needs

270
00:15:03,279 --> 00:15:07,680
to store that full set because it's not

271
00:15:05,760 --> 00:15:08,560
smart about how how to reason about the

272
00:15:07,680 --> 00:15:10,399
set

273
00:15:08,560 --> 00:15:12,319
so the the improvement here is like you

274
00:15:10,399 --> 00:15:15,839
have equivalent security

275
00:15:12,320 --> 00:15:18,639
because you trust your hashing and um

276
00:15:15,839 --> 00:15:20,320
you have more bandwidth usage right

277
00:15:18,639 --> 00:15:22,160
because you need to

278
00:15:20,320 --> 00:15:23,440
pass proofs around like if i want to

279
00:15:22,160 --> 00:15:26,399
prove to somebody that a

280
00:15:23,440 --> 00:15:28,079
bitcoin exists i have to prove that that

281
00:15:26,399 --> 00:15:30,639
it wasn't spent in that

282
00:15:28,079 --> 00:15:31,839
in that accumulator root right so this

283
00:15:30,639 --> 00:15:33,440
is something you don't have to do now

284
00:15:31,839 --> 00:15:35,759
because now you don't you just say

285
00:15:33,440 --> 00:15:37,519
okay here's my script and bitcoin node

286
00:15:35,759 --> 00:15:39,920
can just say like okay

287
00:15:37,519 --> 00:15:41,279
i see that there is an unspent output

288
00:15:39,920 --> 00:15:42,639
you know so i don't need to

289
00:15:41,279 --> 00:15:44,160
prove it because there's no data

290
00:15:42,639 --> 00:15:45,120
structure that's just a set right how do

291
00:15:44,160 --> 00:15:46,800
you prove

292
00:15:45,120 --> 00:15:48,240
membership of a set you just assume

293
00:15:46,800 --> 00:15:48,959
people have the set right then you know

294
00:15:48,240 --> 00:15:53,279
that

295
00:15:48,959 --> 00:15:56,638
they know that it's not used okay

296
00:15:53,279 --> 00:15:59,360
so um okay so

297
00:15:56,639 --> 00:16:00,560
now we will this is an example of uh of

298
00:15:59,360 --> 00:16:03,040
the committing

299
00:16:00,560 --> 00:16:03,680
that i showed and here's here's like

300
00:16:03,040 --> 00:16:05,599
again

301
00:16:03,680 --> 00:16:07,439
you can see 27 i don't know if you can

302
00:16:05,600 --> 00:16:10,880
see the colors but

303
00:16:07,440 --> 00:16:13,360
um yeah 27 28

304
00:16:10,880 --> 00:16:15,519
11 20 those are like the auxiliary

305
00:16:13,360 --> 00:16:20,240
hashes right that we need to prove

306
00:16:15,519 --> 00:16:23,440
that 10 exists okay

307
00:16:20,240 --> 00:16:25,440
so um and here's how it would be used if

308
00:16:23,440 --> 00:16:26,399
you if you actually were using utrixo

309
00:16:25,440 --> 00:16:28,399
right you would need

310
00:16:26,399 --> 00:16:30,240
to the receiver you can see the last

311
00:16:28,399 --> 00:16:31,600
bullet point needs to

312
00:16:30,240 --> 00:16:34,399
even though they only have the three

313
00:16:31,600 --> 00:16:36,880
routes they can check that

314
00:16:34,399 --> 00:16:38,480
that the output exists that that so when

315
00:16:36,880 --> 00:16:39,199
you receive coins you will also receive

316
00:16:38,480 --> 00:16:41,839
a proof

317
00:16:39,199 --> 00:16:43,758
that um your new output exists and you

318
00:16:41,839 --> 00:16:46,079
know that you you know you decided

319
00:16:43,759 --> 00:16:47,920
what this output was to be to look like

320
00:16:46,079 --> 00:16:49,599
right when you ask for bitcoin you ask

321
00:16:47,920 --> 00:16:51,360
for somebody to spend to an output that

322
00:16:49,600 --> 00:16:52,959
you decide

323
00:16:51,360 --> 00:16:55,040
and then you can then prove that it

324
00:16:52,959 --> 00:16:57,279
exists and then you can prove that

325
00:16:55,040 --> 00:17:00,319
even without losing security right but

326
00:16:57,279 --> 00:17:03,360
using a few gigabytes less of

327
00:17:00,320 --> 00:17:06,000
of persistent storage

328
00:17:03,360 --> 00:17:07,120
so let's see okay so i'm going through

329
00:17:06,000 --> 00:17:09,359
the algorithm to

330
00:17:07,119 --> 00:17:10,799
to to do the deletion because doing the

331
00:17:09,359 --> 00:17:12,639
addition is easy

332
00:17:10,799 --> 00:17:14,879
but you know maybe i can talk about that

333
00:17:12,640 --> 00:17:16,959
later so the deletion is

334
00:17:14,880 --> 00:17:18,480
is like split up in these rules and

335
00:17:16,959 --> 00:17:19,839
don't worry about the names because the

336
00:17:18,480 --> 00:17:21,839
names are like

337
00:17:19,839 --> 00:17:23,039
they are kind of you know they just have

338
00:17:21,839 --> 00:17:24,559
to be some names you know

339
00:17:23,039 --> 00:17:26,160
there's no name for all this so we just

340
00:17:24,559 --> 00:17:28,160
invent some names so

341
00:17:26,160 --> 00:17:30,000
um so you can see here what what they

342
00:17:28,160 --> 00:17:31,039
actually like correspond to we identify

343
00:17:30,000 --> 00:17:34,080
some subtrees

344
00:17:31,039 --> 00:17:35,520
we move the sub trees around and

345
00:17:34,080 --> 00:17:38,639
you know and then there's okay two

346
00:17:35,520 --> 00:17:41,280
different kind of of ways to swap trees

347
00:17:38,640 --> 00:17:42,559
sub trees but um you know i will show

348
00:17:41,280 --> 00:17:44,480
you how that works

349
00:17:42,559 --> 00:17:46,000
and and that's it you know then you swap

350
00:17:44,480 --> 00:17:48,080
the subtrees you don't need to touch

351
00:17:46,000 --> 00:17:49,440
all the nodes and you have updated your

352
00:17:48,080 --> 00:17:51,760
tree you have deleted some

353
00:17:49,440 --> 00:17:52,720
nodes and you know you can just add new

354
00:17:51,760 --> 00:17:54,799
you um

355
00:17:52,720 --> 00:17:56,640
you could just add new outputs basically

356
00:17:54,799 --> 00:17:58,480
you add new members to a set no problem

357
00:17:56,640 --> 00:18:02,880
that's easy

358
00:17:58,480 --> 00:18:05,280
um okay okay so this is the first step

359
00:18:02,880 --> 00:18:06,160
so we're deleting the nodes four to nine

360
00:18:05,280 --> 00:18:07,760
right

361
00:18:06,160 --> 00:18:10,160
so they are in the middle of the tree as

362
00:18:07,760 --> 00:18:10,640
you see like in the middle of the leaves

363
00:18:10,160 --> 00:18:12,640
right

364
00:18:10,640 --> 00:18:14,240
because only the bottom row is is

365
00:18:12,640 --> 00:18:16,640
outputs they are the

366
00:18:14,240 --> 00:18:18,000
the set members right so we are saying

367
00:18:16,640 --> 00:18:19,840
these these six

368
00:18:18,000 --> 00:18:21,600
outputs have been spent and we want to

369
00:18:19,840 --> 00:18:24,799
remove them so that they cannot be

370
00:18:21,600 --> 00:18:27,039
proven to exist in the tree anymore so

371
00:18:24,799 --> 00:18:30,559
there's this algorithm

372
00:18:27,039 --> 00:18:32,000
um extract twins it's not a very large

373
00:18:30,559 --> 00:18:33,600
you know i don't have the code here

374
00:18:32,000 --> 00:18:35,840
because i don't want to like

375
00:18:33,600 --> 00:18:38,320
go into the minor details but it's like

376
00:18:35,840 --> 00:18:41,439
very simple everything's open source

377
00:18:38,320 --> 00:18:42,320
and um and this is basically just pasted

378
00:18:41,440 --> 00:18:45,679
from my

379
00:18:42,320 --> 00:18:46,320
ghci uh prompt and you know you can see

380
00:18:45,679 --> 00:18:48,720
it takes

381
00:18:46,320 --> 00:18:49,678
a bunch of nodes and then it gives some

382
00:18:48,720 --> 00:18:52,000
nodes on the

383
00:18:49,679 --> 00:18:52,880
on the on the upper row that would be

384
00:18:52,000 --> 00:18:56,000
the parents

385
00:18:52,880 --> 00:18:58,799
right so if you delete four to nine

386
00:18:56,000 --> 00:19:00,720
you will be leading 18 19 20. that's

387
00:18:58,799 --> 00:19:02,879
like the first row what the first row

388
00:19:00,720 --> 00:19:06,799
shows of extract twins then you iterate

389
00:19:02,880 --> 00:19:06,799
up the tree and then at the end you know

390
00:19:08,840 --> 00:19:13,039
that

391
00:19:10,160 --> 00:19:15,600
so you know that 20 and 25 and you can

392
00:19:13,039 --> 00:19:18,080
see that in the tree like it's very easy

393
00:19:15,600 --> 00:19:20,000
like i've highlighted here with blue you

394
00:19:18,080 --> 00:19:22,720
can see that 25 is like

395
00:19:20,000 --> 00:19:24,960
um you know identifying that subtree of

396
00:19:22,720 --> 00:19:27,120
stuff you want to delete and 20 is

397
00:19:24,960 --> 00:19:29,440
identifying another subject right

398
00:19:27,120 --> 00:19:31,600
so we have we have a couple of subtrees

399
00:19:29,440 --> 00:19:33,440
and um and we can now use them in the

400
00:19:31,600 --> 00:19:36,320
next step

401
00:19:33,440 --> 00:19:37,039
okay so there's this algorithm make

402
00:19:36,320 --> 00:19:40,320
swaps

403
00:19:37,039 --> 00:19:41,039
and it's and it's taking those indexes

404
00:19:40,320 --> 00:19:44,159
of

405
00:19:41,039 --> 00:19:45,760
uh subtree roots and then it is

406
00:19:44,160 --> 00:19:48,640
generating swaps

407
00:19:45,760 --> 00:19:50,000
um so you know you don't need to

408
00:19:48,640 --> 00:19:52,480
understand

409
00:19:50,000 --> 00:19:54,000
every parameter but like um for example

410
00:19:52,480 --> 00:19:56,160
the 14

411
00:19:54,000 --> 00:19:58,400
the 22 26 let's not worry about that

412
00:19:56,160 --> 00:19:59,919
right now but um

413
00:19:58,400 --> 00:20:02,080
but basically you you that's just

414
00:19:59,919 --> 00:20:04,640
actually the tree root right the 26

415
00:20:02,080 --> 00:20:06,158
is means that we are dealing with when

416
00:20:04,640 --> 00:20:09,039
we deal with um

417
00:20:06,159 --> 00:20:10,000
with 25 we're also dealing it with 26

418
00:20:09,039 --> 00:20:13,039
because this

419
00:20:10,000 --> 00:20:15,520
the 26 is tree root on that level

420
00:20:13,039 --> 00:20:17,600
right and all these algorithms work like

421
00:20:15,520 --> 00:20:19,440
level by level

422
00:20:17,600 --> 00:20:20,879
so the point is let's look at like the

423
00:20:19,440 --> 00:20:24,400
right row you can see

424
00:20:20,880 --> 00:20:28,320
it results in 22 20

425
00:20:24,400 --> 00:20:30,720
26 25 and 14 8 right and what are those

426
00:20:28,320 --> 00:20:31,760
those are actually like the swaps we

427
00:20:30,720 --> 00:20:35,760
need to make

428
00:20:31,760 --> 00:20:37,600
to reorder the the tree such that

429
00:20:35,760 --> 00:20:39,600
the nodes that we want to delete are

430
00:20:37,600 --> 00:20:40,959
deleted so this is all derived from that

431
00:20:39,600 --> 00:20:46,000
list of of deletion

432
00:20:40,960 --> 00:20:48,320
um elements we wanted to to get rid of

433
00:20:46,000 --> 00:20:49,600
okay but there's an issue like um and

434
00:20:48,320 --> 00:20:52,639
this is like what

435
00:20:49,600 --> 00:20:54,158
why there's not only swaps there's also

436
00:20:52,640 --> 00:20:54,720
these collapses and that's basically

437
00:20:54,159 --> 00:20:57,039
because

438
00:20:54,720 --> 00:20:59,039
um some of the swaps you would do would

439
00:20:57,039 --> 00:21:02,240
get erased later

440
00:20:59,039 --> 00:21:04,799
so i mean so the red arrow is

441
00:21:02,240 --> 00:21:07,919
a is is what is called a collapse right

442
00:21:04,799 --> 00:21:10,960
we're trying to move the 14 to eight

443
00:21:07,919 --> 00:21:12,960
and if you do that then it will get

444
00:21:10,960 --> 00:21:16,240
moved to the end by the next one

445
00:21:12,960 --> 00:21:17,360
right by the by the 20 to because the

446
00:21:16,240 --> 00:21:20,480
2220

447
00:21:17,360 --> 00:21:22,399
thing would move eight and nine with 12

448
00:21:20,480 --> 00:21:25,280
and 13.

449
00:21:22,400 --> 00:21:26,400
so there's another algorithm that takes

450
00:21:25,280 --> 00:21:28,639
care of this and

451
00:21:26,400 --> 00:21:30,640
looks at the swaps looks at the

452
00:21:28,640 --> 00:21:33,039
collapses and then turns the collapses

453
00:21:30,640 --> 00:21:35,600
into swaps so that we can just go up the

454
00:21:33,039 --> 00:21:37,280
tree swap everything and we have done

455
00:21:35,600 --> 00:21:39,280
so this is what it does it changes the

456
00:21:37,280 --> 00:21:42,320
14 8 to 14

457
00:21:39,280 --> 00:21:44,000
4 and then we can run the algorithm

458
00:21:42,320 --> 00:21:46,960
like basically just going through the

459
00:21:44,000 --> 00:21:49,039
swaps we have swapping them

460
00:21:46,960 --> 00:21:50,000
so we have swapped one right you have

461
00:21:49,039 --> 00:21:52,960
seen

462
00:21:50,000 --> 00:21:53,919
now at where uh number four was there's

463
00:21:52,960 --> 00:21:59,600
now number 40

464
00:21:53,919 --> 00:22:01,120
so because 14 was just this root in a in

465
00:21:59,600 --> 00:22:02,879
a one element tree

466
00:22:01,120 --> 00:22:04,158
so it's very small right but it's still

467
00:22:02,880 --> 00:22:07,200
a tree it's just one

468
00:22:04,159 --> 00:22:08,159
it's just one note okay so we did the

469
00:22:07,200 --> 00:22:10,960
bottom row

470
00:22:08,159 --> 00:22:12,000
we do the next row we swapped something

471
00:22:10,960 --> 00:22:15,520
now you can see like the

472
00:22:12,000 --> 00:22:17,840
12 13 in the bottom has been written

473
00:22:15,520 --> 00:22:19,360
and the eight nine is now at the end

474
00:22:17,840 --> 00:22:23,280
like it's the second last

475
00:22:19,360 --> 00:22:26,959
micro tree at the left at the right

476
00:22:23,280 --> 00:22:29,918
okay and here's another swap um

477
00:22:26,960 --> 00:22:31,280
and i've marked like the deleted notes

478
00:22:29,919 --> 00:22:33,919
gray out right because we

479
00:22:31,280 --> 00:22:34,399
we have swapped them out to positions

480
00:22:33,919 --> 00:22:37,679
that

481
00:22:34,400 --> 00:22:39,120
would just be like um you know like

482
00:22:37,679 --> 00:22:40,880
stuff in your file system where you

483
00:22:39,120 --> 00:22:42,320
don't have a file right it's like it's

484
00:22:40,880 --> 00:22:44,320
it's still actually there because it's

485
00:22:42,320 --> 00:22:46,879
just one giant array but

486
00:22:44,320 --> 00:22:48,320
you can imagine as if it doesn't matter

487
00:22:46,880 --> 00:22:49,840
what's in there anymore right

488
00:22:48,320 --> 00:22:52,320
so this is what's been happening like

489
00:22:49,840 --> 00:22:53,280
we've been swapping things to positions

490
00:22:52,320 --> 00:22:55,678
where

491
00:22:53,280 --> 00:22:56,960
we just decide this is not even part of

492
00:22:55,679 --> 00:22:59,200
the structure anymore

493
00:22:56,960 --> 00:23:01,120
because all of this is embeddable into

494
00:22:59,200 --> 00:23:02,640
an array right to to have fast

495
00:23:01,120 --> 00:23:04,080
performance and all that and to

496
00:23:02,640 --> 00:23:08,400
implement it on memory

497
00:23:04,080 --> 00:23:10,158
and on file disk and and and that's why

498
00:23:08,400 --> 00:23:12,000
well yeah so it's convenient to talk

499
00:23:10,159 --> 00:23:13,919
about the indexes

500
00:23:12,000 --> 00:23:16,480
but as you can see what we wanted to do

501
00:23:13,919 --> 00:23:18,640
is we wanted to delete those nodes right

502
00:23:16,480 --> 00:23:19,840
and the four went all the way to the

503
00:23:18,640 --> 00:23:22,159
right and the five

504
00:23:19,840 --> 00:23:23,678
through nine it went just before that

505
00:23:22,159 --> 00:23:25,520
but it doesn't matter right because

506
00:23:23,679 --> 00:23:27,520
those are deleted so now we end up with

507
00:23:25,520 --> 00:23:28,559
one tree and then the second tree with

508
00:23:27,520 --> 00:23:31,760
just one node

509
00:23:28,559 --> 00:23:33,600
but the point is um now we just need to

510
00:23:31,760 --> 00:23:35,120
rehash some of the data right

511
00:23:33,600 --> 00:23:36,719
because we only swapped some of the

512
00:23:35,120 --> 00:23:37,199
trees so we don't need to touch for

513
00:23:36,720 --> 00:23:40,640
example

514
00:23:37,200 --> 00:23:42,880
16 or 24 all that all that left side

515
00:23:40,640 --> 00:23:44,400
all that stuff we don't need to charge

516
00:23:42,880 --> 00:23:46,240
that right but we still need to touch

517
00:23:44,400 --> 00:23:49,600
the root for example because

518
00:23:46,240 --> 00:23:50,799
we swap things in there but but that's

519
00:23:49,600 --> 00:23:54,879
another algorithm right

520
00:23:50,799 --> 00:23:56,720
but it's not very complicated okay

521
00:23:54,880 --> 00:23:59,120
um so now i'm going to talk about like

522
00:23:56,720 --> 00:24:01,200
how it what what are the extra tricks

523
00:23:59,120 --> 00:24:02,879
you can do because i talked all about

524
00:24:01,200 --> 00:24:04,799
all the time i only talked about saving

525
00:24:02,880 --> 00:24:06,480
the roots right because the roots commit

526
00:24:04,799 --> 00:24:09,279
to the whole tree

527
00:24:06,480 --> 00:24:10,000
but you can do you can do it smarter

528
00:24:09,279 --> 00:24:12,960
than that because

529
00:24:10,000 --> 00:24:13,679
if you only store the roots every time

530
00:24:12,960 --> 00:24:16,240
somebody

531
00:24:13,679 --> 00:24:18,240
um tells you something is spent you

532
00:24:16,240 --> 00:24:21,520
would you would need to say okay

533
00:24:18,240 --> 00:24:23,120
then well okay every time somebody says

534
00:24:21,520 --> 00:24:25,760
uh this thing is in the tree right you

535
00:24:23,120 --> 00:24:27,760
had to ask for this for the proof

536
00:24:25,760 --> 00:24:29,919
but you could just you know you can you

537
00:24:27,760 --> 00:24:31,200
can choose to save an arbitrary number

538
00:24:29,919 --> 00:24:33,600
of proof it's just

539
00:24:31,200 --> 00:24:34,720
it's just saving more notes of that tree

540
00:24:33,600 --> 00:24:36,719
like you could

541
00:24:34,720 --> 00:24:38,080
say i only store the root because the

542
00:24:36,720 --> 00:24:39,600
root commits to everything

543
00:24:38,080 --> 00:24:41,279
but this is all about a trade-off

544
00:24:39,600 --> 00:24:44,000
between bandwidth and

545
00:24:41,279 --> 00:24:45,600
and storage so you could say i just

546
00:24:44,000 --> 00:24:48,559
store you know

547
00:24:45,600 --> 00:24:50,480
i just store the the things that will be

548
00:24:48,559 --> 00:24:52,080
not spent for a long time

549
00:24:50,480 --> 00:24:53,840
and maybe if you're like if you're using

550
00:24:52,080 --> 00:24:55,600
it in bitcoin context and you're always

551
00:24:53,840 --> 00:24:57,199
syncing the same tree back up

552
00:24:55,600 --> 00:24:59,918
then you would be sinking from somebody

553
00:24:57,200 --> 00:25:01,760
who knows when a bitcoin will be spent

554
00:24:59,919 --> 00:25:04,159
so you could say

555
00:25:01,760 --> 00:25:05,279
um this thing is going to be spent you

556
00:25:04,159 --> 00:25:07,840
know in the next block

557
00:25:05,279 --> 00:25:09,120
so you don't need to to write it to disk

558
00:25:07,840 --> 00:25:09,678
you know you just you can keep it in

559
00:25:09,120 --> 00:25:11,918
memory

560
00:25:09,679 --> 00:25:12,880
so you can do all these optimizations so

561
00:25:11,919 --> 00:25:14,720
it's like

562
00:25:12,880 --> 00:25:16,640
and it's not it's not breaking the trust

563
00:25:14,720 --> 00:25:18,400
model right because

564
00:25:16,640 --> 00:25:20,240
it's it's all about optimization it's

565
00:25:18,400 --> 00:25:22,559
just an optimization and you can verify

566
00:25:20,240 --> 00:25:25,279
it at the end you know you can you can

567
00:25:22,559 --> 00:25:26,399
you can lie to somebody for 99 years but

568
00:25:25,279 --> 00:25:28,480
like

569
00:25:26,400 --> 00:25:29,919
at last they will find out you know at

570
00:25:28,480 --> 00:25:31,520
the very last moment because they will

571
00:25:29,919 --> 00:25:33,120
see oh it doesn't add up you know you

572
00:25:31,520 --> 00:25:34,720
you didn't spend this thing you you told

573
00:25:33,120 --> 00:25:36,479
me that you would spend

574
00:25:34,720 --> 00:25:38,080
then i need to download more proofs

575
00:25:36,480 --> 00:25:40,720
doesn't matter

576
00:25:38,080 --> 00:25:41,439
okay so these are just the quotes

577
00:25:40,720 --> 00:25:43,279
basically

578
00:25:41,440 --> 00:25:45,440
saying it in the formal way what i just

579
00:25:43,279 --> 00:25:48,559
described that you could do

580
00:25:45,440 --> 00:25:52,080
basically you can no you know up front

581
00:25:48,559 --> 00:25:54,639
so i will show this like how to just um

582
00:25:52,080 --> 00:25:56,158
update the tree and it's called well

583
00:25:54,640 --> 00:25:57,520
it's this is just what i've showed

584
00:25:56,159 --> 00:25:59,600
before actually so

585
00:25:57,520 --> 00:26:01,200
you know you have a node you add another

586
00:25:59,600 --> 00:26:02,158
node and you say okay i want to remember

587
00:26:01,200 --> 00:26:05,200
this node two

588
00:26:02,159 --> 00:26:06,000
right okay and then you add some more

589
00:26:05,200 --> 00:26:08,080
nodes

590
00:26:06,000 --> 00:26:10,000
and you always commit to the top right

591
00:26:08,080 --> 00:26:12,480
the four has always been committed

592
00:26:10,000 --> 00:26:14,799
to that's not even an option but you say

593
00:26:12,480 --> 00:26:16,559
okay i still i i save number two

594
00:26:14,799 --> 00:26:18,240
even though you know i might not care

595
00:26:16,559 --> 00:26:20,000
about it i can still save it and say

596
00:26:18,240 --> 00:26:21,200
because the server told me i will spend

597
00:26:20,000 --> 00:26:23,520
this soon right so

598
00:26:21,200 --> 00:26:24,640
so so you know don't throw away the

599
00:26:23,520 --> 00:26:27,840
proof that you made

600
00:26:24,640 --> 00:26:30,159
when you updated your tree

601
00:26:27,840 --> 00:26:31,678
and you know we we modify the tree more

602
00:26:30,159 --> 00:26:33,840
and the client can just you know

603
00:26:31,679 --> 00:26:35,600
keep that proof because the client knows

604
00:26:33,840 --> 00:26:37,760
where the leave moves around

605
00:26:35,600 --> 00:26:39,320
so the client also knows how to the

606
00:26:37,760 --> 00:26:40,400
client needs to recalculate that

607
00:26:39,320 --> 00:26:42,799
[Music]

608
00:26:40,400 --> 00:26:43,919
that proof anyway right because the

609
00:26:42,799 --> 00:26:47,440
proof is just

610
00:26:43,919 --> 00:26:50,640
nodes it's just hashes so you know

611
00:26:47,440 --> 00:26:53,600
so you can do these trade-offs

612
00:26:50,640 --> 00:26:54,559
okay so yeah we can trade storage for

613
00:26:53,600 --> 00:26:56,959
bandwidth

614
00:26:54,559 --> 00:26:58,960
we can can have bitcoin running on

615
00:26:56,960 --> 00:27:01,600
devices that don't need like

616
00:26:58,960 --> 00:27:04,000
um a lot of storage but can have

617
00:27:01,600 --> 00:27:06,000
bandwidth instead right

618
00:27:04,000 --> 00:27:07,120
we only need to trust that you know

619
00:27:06,000 --> 00:27:08,799
hashes are

620
00:27:07,120 --> 00:27:10,239
trustworthy and we don't delete stuff

621
00:27:08,799 --> 00:27:11,279
that we're not supposed to stuff like

622
00:27:10,240 --> 00:27:13,360
that

623
00:27:11,279 --> 00:27:15,440
um so basically the algorithm i showed

624
00:27:13,360 --> 00:27:18,719
you we need to trust that too right

625
00:27:15,440 --> 00:27:19,440
and then so my so my question was like

626
00:27:18,720 --> 00:27:21,120
also

627
00:27:19,440 --> 00:27:23,200
how can can how can i even think about

628
00:27:21,120 --> 00:27:26,399
this in a functional way

629
00:27:23,200 --> 00:27:27,679
and so that's kind of a different topic

630
00:27:26,399 --> 00:27:30,879
right because all these

631
00:27:27,679 --> 00:27:33,039
all these indexes they they are like so

632
00:27:30,880 --> 00:27:34,000
opaque right you only the index only

633
00:27:33,039 --> 00:27:36,960
means something if you know

634
00:27:34,000 --> 00:27:39,039
the height of the of the of the tree so

635
00:27:36,960 --> 00:27:42,240
if you don't know the height of the tree

636
00:27:39,039 --> 00:27:44,879
how do you how do you how can you say 14

637
00:27:42,240 --> 00:27:46,399
you know it depends how high the tree is

638
00:27:44,880 --> 00:27:47,120
for that position to be somewhere

639
00:27:46,399 --> 00:27:49,039
because we just

640
00:27:47,120 --> 00:27:51,199
we number the notes from the from the

641
00:27:49,039 --> 00:27:51,840
bottom up that's not how trees are made

642
00:27:51,200 --> 00:27:53,760
in

643
00:27:51,840 --> 00:27:54,959
functional programming languages usually

644
00:27:53,760 --> 00:27:57,039
right so

645
00:27:54,960 --> 00:27:58,799
the first the first line shows like a

646
00:27:57,039 --> 00:28:00,000
typical binary tree in haskell right

647
00:27:58,799 --> 00:28:02,960
it's polymorphic

648
00:28:00,000 --> 00:28:04,240
over the type a and it has two child

649
00:28:02,960 --> 00:28:07,279
nodes

650
00:28:04,240 --> 00:28:10,159
or it can just be empty right

651
00:28:07,279 --> 00:28:11,919
um but you know there's no difference

652
00:28:10,159 --> 00:28:13,039
between a node and its child they have

653
00:28:11,919 --> 00:28:16,880
the same type

654
00:28:13,039 --> 00:28:18,879
so so you know there's no restriction

655
00:28:16,880 --> 00:28:20,480
even on on this being a perfect tree

656
00:28:18,880 --> 00:28:22,320
right which i would also like because

657
00:28:20,480 --> 00:28:25,039
all my trees are perfect so why don't i

658
00:28:22,320 --> 00:28:27,520
have a type to describe that

659
00:28:25,039 --> 00:28:29,120
okay so then you know so then i read the

660
00:28:27,520 --> 00:28:29,440
idris book and i was thinking oh you

661
00:28:29,120 --> 00:28:32,559
know

662
00:28:29,440 --> 00:28:34,480
dependent types right not so you know

663
00:28:32,559 --> 00:28:35,678
that's one way to solve this and it

664
00:28:34,480 --> 00:28:37,679
would be interesting if there was

665
00:28:35,679 --> 00:28:40,159
another way but you could say

666
00:28:37,679 --> 00:28:42,000
okay a node has to have children that

667
00:28:40,159 --> 00:28:45,600
has an index type right

668
00:28:42,000 --> 00:28:46,000
a type index type so you know h minus

669
00:28:45,600 --> 00:28:49,120
one

670
00:28:46,000 --> 00:28:52,159
so the the node of the children

671
00:28:49,120 --> 00:28:54,719
have a a lower height than the than the

672
00:28:52,159 --> 00:28:55,200
parent of course and then you could then

673
00:28:54,720 --> 00:28:57,360
you could

674
00:28:55,200 --> 00:28:58,399
then you could actually transfer between

675
00:28:57,360 --> 00:29:00,080
this

676
00:28:58,399 --> 00:29:01,918
then you could calculate the old style

677
00:29:00,080 --> 00:29:03,360
index and then then i could

678
00:29:01,919 --> 00:29:05,520
write a new implementation that was

679
00:29:03,360 --> 00:29:08,879
functional and i could still make it

680
00:29:05,520 --> 00:29:10,960
um i could test it against my

681
00:29:08,880 --> 00:29:12,080
old code right working with these

682
00:29:10,960 --> 00:29:14,000
indexes

683
00:29:12,080 --> 00:29:15,840
because i could then if i you know if

684
00:29:14,000 --> 00:29:18,640
every node knows

685
00:29:15,840 --> 00:29:20,639
um the relative positions of its

686
00:29:18,640 --> 00:29:22,559
children

687
00:29:20,640 --> 00:29:24,240
well then i can transfer between them

688
00:29:22,559 --> 00:29:27,520
right

689
00:29:24,240 --> 00:29:28,559
um so but i don't know actually how to

690
00:29:27,520 --> 00:29:31,440
do that because i'm

691
00:29:28,559 --> 00:29:33,120
a bit worried about like can you really

692
00:29:31,440 --> 00:29:34,399
transfer in both directions right can

693
00:29:33,120 --> 00:29:38,799
you transfer

694
00:29:34,399 --> 00:29:42,799
a um if i have a subtree

695
00:29:38,799 --> 00:29:46,320
can i really know that it is

696
00:29:42,799 --> 00:29:48,240
um well don't i know to all also need to

697
00:29:46,320 --> 00:29:52,080
know how many levels are above it

698
00:29:48,240 --> 00:29:54,320
right well in the in the goal tree

699
00:29:52,080 --> 00:29:55,600
you can see when you hit the bottom just

700
00:29:54,320 --> 00:30:00,480
by

701
00:29:55,600 --> 00:30:02,879
um well if if the indexes are one

702
00:30:00,480 --> 00:30:04,720
um and all the all the other siblings

703
00:30:02,880 --> 00:30:07,679
are just xored with one right

704
00:30:04,720 --> 00:30:09,360
they are just like um the bit is flipped

705
00:30:07,679 --> 00:30:12,240
so it's really easy to for example

706
00:30:09,360 --> 00:30:13,439
uh make a sibling it's also easy to make

707
00:30:12,240 --> 00:30:16,320
parents and children

708
00:30:13,440 --> 00:30:17,600
in the imperative tree but well the goat

709
00:30:16,320 --> 00:30:20,080
tree as i called it before

710
00:30:17,600 --> 00:30:22,399
but in a functional tree it doesn't

711
00:30:20,080 --> 00:30:24,799
really make sense to be able to go

712
00:30:22,399 --> 00:30:26,399
up and to go down at the same time right

713
00:30:24,799 --> 00:30:27,440
because it wouldn't be an algebraic data

714
00:30:26,399 --> 00:30:30,799
type how can you

715
00:30:27,440 --> 00:30:33,360
how can you you know store um

716
00:30:30,799 --> 00:30:34,559
it would be recursive in both directions

717
00:30:33,360 --> 00:30:36,320
right

718
00:30:34,559 --> 00:30:38,080
for me it doesn't really make sense so

719
00:30:36,320 --> 00:30:40,480
what i need to do is i need to reason

720
00:30:38,080 --> 00:30:42,960
about like the indexes i think

721
00:30:40,480 --> 00:30:44,320
and so that's like my question right now

722
00:30:42,960 --> 00:30:45,840
that i

723
00:30:44,320 --> 00:30:47,520
that's what i'm working on and i don't

724
00:30:45,840 --> 00:30:48,639
really know how to solve it but i wanted

725
00:30:47,520 --> 00:30:52,879
to say that

726
00:30:48,640 --> 00:30:56,240
no this is what i'm thinking of um but

727
00:30:52,880 --> 00:30:57,039
yeah it's well the algorithm is not that

728
00:30:56,240 --> 00:30:58,720
big i think it's

729
00:30:57,039 --> 00:31:00,480
it's hard to explain it because it's so

730
00:30:58,720 --> 00:31:05,840
much mutation

731
00:31:00,480 --> 00:31:05,840
but um yeah come on

732
00:31:09,039 --> 00:31:12,480
yeah yeah okay okay so the question was

733
00:31:11,440 --> 00:31:14,720
um

734
00:31:12,480 --> 00:31:16,720
do you know sippers right so there's i

735
00:31:14,720 --> 00:31:19,600
don't know who came up with it first

736
00:31:16,720 --> 00:31:21,760
but yeah i haven't i've tried using that

737
00:31:19,600 --> 00:31:24,879
the zippers i tried using the one from

738
00:31:21,760 --> 00:31:28,399
kimet and

739
00:31:24,880 --> 00:31:29,840
and they are like they they do allow you

740
00:31:28,399 --> 00:31:32,158
to go up and down

741
00:31:29,840 --> 00:31:33,519
but they but they are really hard to

742
00:31:32,159 --> 00:31:34,080
work with i thought they were really

743
00:31:33,519 --> 00:31:35,919
hard like

744
00:31:34,080 --> 00:31:37,760
because they are like if you think lens

745
00:31:35,919 --> 00:31:38,640
stuff is hard then that's even worse

746
00:31:37,760 --> 00:31:41,120
right

747
00:31:38,640 --> 00:31:42,320
and uh and that that's how it is and

748
00:31:41,120 --> 00:31:44,879
then i couldn't do

749
00:31:42,320 --> 00:31:46,720
all the things i wanted to do but what i

750
00:31:44,880 --> 00:31:47,279
what i thought was easier to work with

751
00:31:46,720 --> 00:31:50,159
was

752
00:31:47,279 --> 00:31:50,799
by plate if you saw that thing so

753
00:31:50,159 --> 00:31:54,159
there's

754
00:31:50,799 --> 00:31:56,960
biplate allows you to um

755
00:31:54,159 --> 00:31:58,159
it's like um if the if the children are

756
00:31:56,960 --> 00:32:00,880
self-similar

757
00:31:58,159 --> 00:32:01,679
as they are in in trees you can even

758
00:32:00,880 --> 00:32:04,799
derive

759
00:32:01,679 --> 00:32:06,640
the instance you need to use uh by

760
00:32:04,799 --> 00:32:08,879
plate so you can just derive data i

761
00:32:06,640 --> 00:32:10,640
think so

762
00:32:08,880 --> 00:32:12,880
and that and that gives you a function

763
00:32:10,640 --> 00:32:13,360
for example that will update a tree with

764
00:32:12,880 --> 00:32:16,960
your

765
00:32:13,360 --> 00:32:18,959
chosen uh function as many times as it

766
00:32:16,960 --> 00:32:21,519
can right so you can say okay

767
00:32:18,960 --> 00:32:22,159
like increment all nodes until they

768
00:32:21,519 --> 00:32:24,480
reach

769
00:32:22,159 --> 00:32:25,200
five or whatever you know stuff like

770
00:32:24,480 --> 00:32:27,600
that

771
00:32:25,200 --> 00:32:30,000
so i thought that was kind of useful and

772
00:32:27,600 --> 00:32:33,279
then also i've been writing lenses then

773
00:32:30,000 --> 00:32:35,679
that for example uh swap uh

774
00:32:33,279 --> 00:32:37,120
nodes right so that's not hard either i

775
00:32:35,679 --> 00:32:39,519
mean like

776
00:32:37,120 --> 00:32:41,039
you need to use lenses i don't know how

777
00:32:39,519 --> 00:32:41,679
to do it without lenses right because if

778
00:32:41,039 --> 00:32:43,360
you want to

779
00:32:41,679 --> 00:32:44,880
if you have a functional style tree and

780
00:32:43,360 --> 00:32:45,600
you descend and you descend and you

781
00:32:44,880 --> 00:32:47,840
descend

782
00:32:45,600 --> 00:32:49,600
and then you want to swap within like

783
00:32:47,840 --> 00:32:51,279
after having matched five times

784
00:32:49,600 --> 00:32:53,039
on the tree constructor then you want to

785
00:32:51,279 --> 00:32:55,120
swap the children right

786
00:32:53,039 --> 00:32:57,519
um but that's easy because you can make

787
00:32:55,120 --> 00:32:58,959
a lens that takes a node and gives you

788
00:32:57,519 --> 00:33:00,559
the children as a tuple

789
00:32:58,960 --> 00:33:02,000
and then you have another lens that can

790
00:33:00,559 --> 00:33:02,240
then you have a function that can swap

791
00:33:02,000 --> 00:33:04,399
the

792
00:33:02,240 --> 00:33:06,000
elements of a tuple so it's so it's no

793
00:33:04,399 --> 00:33:06,559
problem to swap the elements like in a

794
00:33:06,000 --> 00:33:09,519
deep

795
00:33:06,559 --> 00:33:11,200
tree or something like that but but it

796
00:33:09,519 --> 00:33:11,600
gets more interesting when you want to

797
00:33:11,200 --> 00:33:14,080
swap

798
00:33:11,600 --> 00:33:16,000
subtrees right because every time i'm

799
00:33:14,080 --> 00:33:18,080
swapping a subtree here i know that the

800
00:33:16,000 --> 00:33:20,559
subtrees are the same size

801
00:33:18,080 --> 00:33:21,600
um so if i had a dependently typed

802
00:33:20,559 --> 00:33:23,039
subtree

803
00:33:21,600 --> 00:33:24,879
then i would have to prove to the

804
00:33:23,039 --> 00:33:26,559
compiler that that

805
00:33:24,880 --> 00:33:28,399
that the soft series were the same

806
00:33:26,559 --> 00:33:31,279
height and that was

807
00:33:28,399 --> 00:33:33,120
i mean that could be pretty hard no so

808
00:33:31,279 --> 00:33:34,799
maybe not dependently typed

809
00:33:33,120 --> 00:33:36,799
but then the question is how do i do the

810
00:33:34,799 --> 00:33:38,559
translation between my go code and my

811
00:33:36,799 --> 00:33:41,918
haskell code because i would like

812
00:33:38,559 --> 00:33:44,399
to to like have tests running on every

813
00:33:41,919 --> 00:33:45,120
on every level but you know sometimes

814
00:33:44,399 --> 00:33:47,518
you reach

815
00:33:45,120 --> 00:33:49,039
like at this point where i think that

816
00:33:47,519 --> 00:33:51,440
the the functional way and the

817
00:33:49,039 --> 00:33:54,320
imperative way seem to be so different

818
00:33:51,440 --> 00:33:56,080
that this thing i wonder if it's just

819
00:33:54,320 --> 00:33:58,158
inherently

820
00:33:56,080 --> 00:34:00,080
imperative right but that would be like

821
00:33:58,159 --> 00:34:01,360
famous less worse i just think i'm not

822
00:34:00,080 --> 00:34:05,760
smart enough to see the

823
00:34:01,360 --> 00:34:05,760
the functional way to do this so

824
00:34:09,280 --> 00:34:13,040
yeah so but the nice thing about the

825
00:34:11,280 --> 00:34:15,839
indexes is that they are really

826
00:34:13,040 --> 00:34:16,639
like for humans it's not so hard to have

827
00:34:15,839 --> 00:34:18,799
like an

828
00:34:16,639 --> 00:34:20,639
integer index and then you know okay

829
00:34:18,800 --> 00:34:22,240
it's supposed to work like this right so

830
00:34:20,639 --> 00:34:22,960
you see it in a tree and then you know

831
00:34:22,239 --> 00:34:25,279
it's in

832
00:34:22,960 --> 00:34:27,359
context to the tree and we have symbols

833
00:34:25,280 --> 00:34:30,399
to talk about it right

834
00:34:27,359 --> 00:34:32,239
so what i what i would want to do in in

835
00:34:30,399 --> 00:34:32,960
functional programming languages is to i

836
00:34:32,239 --> 00:34:35,678
would

837
00:34:32,960 --> 00:34:36,240
i would like to have the nom instance

838
00:34:35,679 --> 00:34:38,079
right

839
00:34:36,239 --> 00:34:39,839
for i would like to have a nominee so

840
00:34:38,079 --> 00:34:42,560
that you write some digits

841
00:34:39,839 --> 00:34:44,239
and then you say okay this is an index

842
00:34:42,560 --> 00:34:46,560
in a tree of this height

843
00:34:44,239 --> 00:34:47,439
and then it says okay i know it's on

844
00:34:46,560 --> 00:34:50,320
level five

845
00:34:47,440 --> 00:34:51,599
i know it's this deep into and i know it

846
00:34:50,320 --> 00:34:55,520
has no children or

847
00:34:51,599 --> 00:34:57,839
whatever you know and yeah

848
00:34:55,520 --> 00:34:59,520
and i don't i i cannot see how you would

849
00:34:57,839 --> 00:35:01,200
do it without dependent types because

850
00:34:59,520 --> 00:35:03,920
that's such a high

851
00:35:01,200 --> 00:35:05,359
such a high ask right so i don't know if

852
00:35:03,920 --> 00:35:08,400
it's possible

853
00:35:05,359 --> 00:35:11,759
um but uh i'd like to leave with a

854
00:35:08,400 --> 00:35:17,839
challenge right so that's my change

855
00:35:11,760 --> 00:35:17,839
and is there anyone oh joe

856
00:35:22,000 --> 00:35:26,800
okay so the question is can i can i

857
00:35:24,560 --> 00:35:30,000
build it with gi dts

858
00:35:26,800 --> 00:35:32,320
and piano okay

859
00:35:30,000 --> 00:35:34,320
well but that's the wrong way i think

860
00:35:32,320 --> 00:35:36,720
because if you have a gdt

861
00:35:34,320 --> 00:35:38,480
like i would let's just say adt i don't

862
00:35:36,720 --> 00:35:41,279
i don't know if we need a g

863
00:35:38,480 --> 00:35:42,320
oh yeah we need a gdt okay well but it

864
00:35:41,280 --> 00:35:45,440
would increment

865
00:35:42,320 --> 00:35:48,000
right because a piano numeral is only it

866
00:35:45,440 --> 00:35:50,400
only has a successor constructor so it

867
00:35:48,000 --> 00:35:53,119
would increment as you go down the tree

868
00:35:50,400 --> 00:35:53,680
but then but i want to say it it counts

869
00:35:53,119 --> 00:35:56,560
down

870
00:35:53,680 --> 00:35:57,520
i think because i want to if it just

871
00:35:56,560 --> 00:35:59,119
increments

872
00:35:57,520 --> 00:36:01,040
then i would have to have some kind of

873
00:35:59,119 --> 00:36:03,520
type equality thing to say

874
00:36:01,040 --> 00:36:05,200
when it reaches five it changes it shall

875
00:36:03,520 --> 00:36:07,119
not increment more

876
00:36:05,200 --> 00:36:09,200
so it's i still think that's dependent

877
00:36:07,119 --> 00:36:11,599
types no because

878
00:36:09,200 --> 00:36:13,279
yeah you're right that i can increment

879
00:36:11,599 --> 00:36:17,280
increment going down but

880
00:36:13,280 --> 00:36:18,800
who builds a tree where where the the

881
00:36:17,280 --> 00:36:21,599
you know you have an adt and what's

882
00:36:18,800 --> 00:36:23,599
inside the adt is not the children

883
00:36:21,599 --> 00:36:25,119
but the parent right because that's what

884
00:36:23,599 --> 00:36:26,880
you would need then because you would

885
00:36:25,119 --> 00:36:28,960
need to say okay

886
00:36:26,880 --> 00:36:30,079
and the problem is i want to type the

887
00:36:28,960 --> 00:36:32,480
tree by its height

888
00:36:30,079 --> 00:36:33,839
at the root it doesn't make any sense to

889
00:36:32,480 --> 00:36:34,960
have it the other way around to like

890
00:36:33,839 --> 00:36:36,880
what would i need to do

891
00:36:34,960 --> 00:36:38,720
store the leaves and say all of them

892
00:36:36,880 --> 00:36:40,079
have the same type because they have so

893
00:36:38,720 --> 00:36:42,560
many levels up to

894
00:36:40,079 --> 00:36:43,839
a root of this hash or something i mean

895
00:36:42,560 --> 00:36:45,200
that's how i would need to prove that

896
00:36:43,839 --> 00:36:48,560
they are in the same tree

897
00:36:45,200 --> 00:36:51,759
so you know yeah

898
00:36:48,560 --> 00:36:55,279
it's like but i'm sure there's some

899
00:36:51,760 --> 00:36:58,000
like theoretical explanation for

900
00:36:55,280 --> 00:36:58,880
this correspondence between piano and

901
00:36:58,000 --> 00:37:02,160
which way you

902
00:36:58,880 --> 00:37:05,280
traverse a tree and

903
00:37:02,160 --> 00:37:09,359
yeah but to me i don't know how you

904
00:37:05,280 --> 00:37:11,280
don't need dependent types for it so

905
00:37:09,359 --> 00:37:13,359
but you're right i tried also with

906
00:37:11,280 --> 00:37:15,599
gadt's i tried it

907
00:37:13,359 --> 00:37:16,960
and i also did stuff like i have a i

908
00:37:15,599 --> 00:37:17,920
have a workaround where i'm just

909
00:37:16,960 --> 00:37:21,599
building in

910
00:37:17,920 --> 00:37:24,720
the go indexes into my leaf type

911
00:37:21,599 --> 00:37:27,119
and then i can use lenses index

912
00:37:24,720 --> 00:37:29,520
traversals index lens and all that stuff

913
00:37:27,119 --> 00:37:30,480
so i could i can work with lens and i

914
00:37:29,520 --> 00:37:32,320
can say okay

915
00:37:30,480 --> 00:37:34,000
lens knows about my indexes and stuff

916
00:37:32,320 --> 00:37:36,000
like that but the problem is

917
00:37:34,000 --> 00:37:37,440
lens doesn't know what the indexes mean

918
00:37:36,000 --> 00:37:38,800
it doesn't know that when i move them

919
00:37:37,440 --> 00:37:39,440
around they actually become other

920
00:37:38,800 --> 00:37:41,520
indexes

921
00:37:39,440 --> 00:37:43,839
so what i have so what i can do is i can

922
00:37:41,520 --> 00:37:46,640
i can write some fancy lens that swaps

923
00:37:43,839 --> 00:37:48,400
trees but then the indexes are all wrong

924
00:37:46,640 --> 00:37:50,480
and i have to re-index them

925
00:37:48,400 --> 00:37:52,720
i mean the trees that you see here in my

926
00:37:50,480 --> 00:37:54,560
slides they are not re-indexed right if

927
00:37:52,720 --> 00:37:56,160
we look at this one

928
00:37:54,560 --> 00:37:57,839
the indexes are all wrong because i have

929
00:37:56,160 --> 00:37:58,799
to i want to show you where they've been

930
00:37:57,839 --> 00:38:00,880
moved to

931
00:37:58,800 --> 00:38:02,720
but of course the indexes are actually

932
00:38:00,880 --> 00:38:05,920
just indexes into an array

933
00:38:02,720 --> 00:38:06,720
so in reality in the go code the indexes

934
00:38:05,920 --> 00:38:08,640
are not

935
00:38:06,720 --> 00:38:10,000
stored anywhere right they are just

936
00:38:08,640 --> 00:38:12,078
abstract

937
00:38:10,000 --> 00:38:13,920
description of what the algorithm would

938
00:38:12,079 --> 00:38:16,960
do it would it would

939
00:38:13,920 --> 00:38:19,680
like it's like saying you know if i say

940
00:38:16,960 --> 00:38:21,440
in c swap the indexes four and five

941
00:38:19,680 --> 00:38:23,200
there's no way to abstractly say that

942
00:38:21,440 --> 00:38:25,680
right

943
00:38:23,200 --> 00:38:26,640
so it's always concrete in c right but

944
00:38:25,680 --> 00:38:30,078
here it's always

945
00:38:26,640 --> 00:38:31,759
it's all abstract okay i don't know if

946
00:38:30,079 --> 00:38:32,000
that makes sense that analogy but it's

947
00:38:31,760 --> 00:38:34,240
like

948
00:38:32,000 --> 00:38:36,400
i just it's important to understand that

949
00:38:34,240 --> 00:38:38,240
the indexes are just

950
00:38:36,400 --> 00:38:40,320
a way to think about it right just like

951
00:38:38,240 --> 00:38:43,279
if you say in c the second element

952
00:38:40,320 --> 00:38:45,040
you know that is index one but it's

953
00:38:43,280 --> 00:38:46,320
always a different second element right

954
00:38:45,040 --> 00:38:47,040
and you can't actually have that

955
00:38:46,320 --> 00:38:51,200
abstract

956
00:38:47,040 --> 00:38:55,759
notion so yeah

957
00:38:51,200 --> 00:38:58,560
yeah but

958
00:38:55,760 --> 00:38:58,560
i think that's it

959
00:38:59,760 --> 00:39:04,079
yeah thank you

960
00:39:04,400 --> 00:39:08,079
okay good

