1
00:00:00,060 --> 00:00:03,899
thanks for the introduction so hi

2
00:00:02,340 --> 00:00:05,100
everyone<font color="#CCCCCC"> i'm david</font><font color="#E5E5E5"> and today i'll be</font>

3
00:00:03,899 --> 00:00:06,629
talking<font color="#E5E5E5"> to you about privately</font>

4
00:00:05,100 --> 00:00:08,070
evaluating decision trees in random

5
00:00:06,629 --> 00:00:09,600
<font color="#E5E5E5">forests this is joint work with</font><font color="#CCCCCC"> tony</font>

6
00:00:08,070 --> 00:00:13,260
phone at<font color="#E5E5E5"> Stanford and Michel ney Drake</font>

7
00:00:09,600 --> 00:00:14,969
and<font color="#CCCCCC"> Kristen Walter at MSR Redmond so in</font>

8
00:00:13,260 --> 00:00:16,560
the last few years one<font color="#E5E5E5"> of the trends</font>

9
00:00:14,970 --> 00:00:18,480
that we've<font color="#E5E5E5"> been seen is this notion of</font>

10
00:00:16,560 --> 00:00:20,668
machine learning at a service right it's

11
00:00:18,480 --> 00:00:22,349
<font color="#CCCCCC">about taking</font><font color="#E5E5E5"> math big data and machine</font>

12
00:00:20,669 --> 00:00:24,150
learning algorithms and putting them in

13
00:00:22,349 --> 00:00:25,589
a cloud so that<font color="#E5E5E5"> many people have access</font>

14
00:00:24,150 --> 00:00:27,959
to<font color="#E5E5E5"> them i'm going to</font><font color="#CCCCCC"> give you an example</font>

15
00:00:25,589 --> 00:00:29,640
from a medical domain so consider we

16
00:00:27,960 --> 00:00:31,349
have suppose we have a physician who's

17
00:00:29,640 --> 00:00:32,700
trying to diagnose<font color="#E5E5E5"> patient with the</font>

18
00:00:31,349 --> 00:00:34,860
disease and<font color="#E5E5E5"> trying to figure out what</font>

19
00:00:32,700 --> 00:00:36,330
the optimal treatment plan is how<font color="#E5E5E5"> can a</font>

20
00:00:34,860 --> 00:00:38,190
physician take advantage of<font color="#CCCCCC"> some of</font><font color="#E5E5E5"> the</font>

21
00:00:36,330 --> 00:00:40,680
big data that's available to help with

22
00:00:38,190 --> 00:00:43,140
<font color="#CCCCCC">this procedure well what the physician</font>

23
00:00:40,680 --> 00:00:45,210
can do nowadays is she can now go and

24
00:00:43,140 --> 00:00:47,010
take a collect a bunch of measurements

25
00:00:45,210 --> 00:00:49,470
about the patient<font color="#E5E5E5"> look at this list of</font>

26
00:00:47,010 --> 00:00:51,210
symptoms and submit those features to

27
00:00:49,470 --> 00:00:53,070
the cloud and hopefully the cloud will

28
00:00:51,210 --> 00:00:54,990
have some new information or some

29
00:00:53,070 --> 00:00:57,600
informants something that will assist

30
00:00:54,990 --> 00:01:00,930
with<font color="#E5E5E5"> the treatment and first potentially</font>

31
00:00:57,600 --> 00:01:03,150
propose a recommended treatment plan so

32
00:01:00,930 --> 00:01:04,319
this<font color="#CCCCCC"> is all good but when we think about</font>

33
00:01:03,150 --> 00:01:05,789
this<font color="#E5E5E5"> from the privacy perspective</font>

34
00:01:04,319 --> 00:01:08,788
<font color="#E5E5E5">something there's a lot more new</font>

35
00:01:05,789 --> 00:01:11,609
challenges<font color="#E5E5E5"> for instance if an adversary</font>

36
00:01:08,789 --> 00:01:13,229
subverts the cloud then it will use

37
00:01:11,609 --> 00:01:15,178
<font color="#CCCCCC">achill ii learns all the patient</font>

38
00:01:13,229 --> 00:01:16,530
information so we have a medical<font color="#CCCCCC"> example</font>

39
00:01:15,179 --> 00:01:18,270
where physicians are sending patient

40
00:01:16,530 --> 00:01:19,829
data to the cloud and the cloud is no

41
00:01:18,270 --> 00:01:21,749
longer trusted or the cloud has been

42
00:01:19,829 --> 00:01:23,579
subverted then suddenly we are

43
00:01:21,749 --> 00:01:26,179
compromising the patient's privacy which

44
00:01:23,579 --> 00:01:28,829
is very significant<font color="#CCCCCC"> in many scenarios</font>

45
00:01:26,179 --> 00:01:30,509
conversely suppose instead that declined

46
00:01:28,829 --> 00:01:32,068
that<font color="#E5E5E5"> the adversaries on the client side</font>

47
00:01:30,509 --> 00:01:33,960
the adversary is going to pretend to be

48
00:01:32,069 --> 00:01:36,840
<font color="#CCCCCC">a physician or</font><font color="#E5E5E5"> a doctor</font><font color="#CCCCCC"> and going to</font>

49
00:01:33,960 --> 00:01:38,280
send malicious data to the cloud in

50
00:01:36,840 --> 00:01:39,960
order<font color="#E5E5E5"> to try and learn something about</font>

51
00:01:38,280 --> 00:01:41,819
that model that's being used<font color="#CCCCCC"> by the</font>

52
00:01:39,960 --> 00:01:43,469
cloud now when<font color="#CCCCCC"> we talked about medical</font>

53
00:01:41,819 --> 00:01:45,240
information when we<font color="#CCCCCC"> trained these models</font>

54
00:01:43,469 --> 00:01:47,369
they're usually trained on patient data

55
00:01:45,240 --> 00:01:49,020
themselves am I making adversarial

56
00:01:47,369 --> 00:01:51,119
queries to the model and potentially

57
00:01:49,020 --> 00:01:53,130
extract the information from it they can

58
00:01:51,119 --> 00:01:55,499
<font color="#E5E5E5">potentially compromise the data that was</font>

59
00:01:53,130 --> 00:01:57,298
used to<font color="#E5E5E5"> train the model itself and so a</font>

60
00:01:55,499 --> 00:01:59,249
malicious client might recover more

61
00:01:57,299 --> 00:02:01,409
information than they should about<font color="#E5E5E5"> that</font>

62
00:01:59,249 --> 00:02:03,420
<font color="#E5E5E5">underlined data and in turn again</font>

63
00:02:01,409 --> 00:02:06,299
compromise the privacy of individuals

64
00:02:03,420 --> 00:02:09,000
whose data went into the<font color="#CCCCCC"> construction of</font>

65
00:02:06,299 --> 00:02:10,560
the model so in this work we're going<font color="#E5E5E5"> to</font>

66
00:02:09,000 --> 00:02:12,550
<font color="#E5E5E5">look at the</font><font color="#CCCCCC"> problem of how do we</font>

67
00:02:10,560 --> 00:02:15,790
privately evaluate a model

68
00:02:12,550 --> 00:02:17,650
in the cloud and for the purposes of

69
00:02:15,790 --> 00:02:19,420
<font color="#CCCCCC">this talk we're going to restrict</font><font color="#E5E5E5"> our</font>

70
00:02:17,650 --> 00:02:21,340
attention to one particular class of

71
00:02:19,420 --> 00:02:23,140
models namely decision trees which are

72
00:02:21,340 --> 00:02:24,880
<font color="#E5E5E5">nonlinear models that are very commonly</font>

73
00:02:23,140 --> 00:02:26,500
used for regression or classification

74
00:02:24,880 --> 00:02:28,510
and these models<font color="#CCCCCC"> are useful because</font>

75
00:02:26,500 --> 00:02:30,250
they're interpretable<font color="#CCCCCC"> oftentimes they</font>

76
00:02:28,510 --> 00:02:31,510
<font color="#E5E5E5">are very simple so here I'm going to</font>

77
00:02:30,250 --> 00:02:33,910
give you a brief overview of<font color="#E5E5E5"> what a</font>

78
00:02:31,510 --> 00:02:35,530
decision tree classifier is so the

79
00:02:33,910 --> 00:02:37,560
implicit these decision trees is going

80
00:02:35,530 --> 00:02:40,000
to be a feature vector so in a medical

81
00:02:37,560 --> 00:02:41,770
diagnostics example this feature vector

82
00:02:40,000 --> 00:02:45,040
might be the patient's weight height

83
00:02:41,770 --> 00:02:48,490
other metrics and potential symptoms

84
00:02:45,040 --> 00:02:50,170
that they are<font color="#E5E5E5"> experiencing to evaluate a</font>

85
00:02:48,490 --> 00:02:52,600
decision tree we begin at<font color="#CCCCCC"> the root node</font>

86
00:02:50,170 --> 00:02:55,570
shown here and we basically<font color="#E5E5E5"> apply a</font>

87
00:02:52,600 --> 00:02:58,269
bunch of tests and these tests or dr

88
00:02:55,570 --> 00:02:59,410
this essentially our comparisons in our

89
00:02:58,270 --> 00:03:00,910
settings so we're going to look at an

90
00:02:59,410 --> 00:03:02,410
entry in the feature vector we're<font color="#E5E5E5"> going</font>

91
00:03:00,910 --> 00:03:04,030
<font color="#E5E5E5">to compare against some fresh hold</font>

92
00:03:02,410 --> 00:03:05,440
depending<font color="#CCCCCC"> on whether it is greater than</font>

93
00:03:04,030 --> 00:03:08,530
or less than we're going<font color="#E5E5E5"> to either move</font>

94
00:03:05,440 --> 00:03:10,660
left or right and this proceeds until we

95
00:03:08,530 --> 00:03:12,490
hit a leaf node and each leaf node in

96
00:03:10,660 --> 00:03:14,320
the tree highlighted in blue here its

97
00:03:12,490 --> 00:03:16,450
associated with some value that is the

98
00:03:14,320 --> 00:03:19,510
value<font color="#E5E5E5"> of the decision tree on the user's</font>

99
00:03:16,450 --> 00:03:21,070
input so when we<font color="#E5E5E5"> talk about the problem</font>

100
00:03:19,510 --> 00:03:23,200
<font color="#CCCCCC">of fully despry vut decision tree</font>

101
00:03:21,070 --> 00:03:24,880
evaluation we can abstract<font color="#CCCCCC"> lee</font>

102
00:03:23,200 --> 00:03:26,950
formulated as a two-party computation

103
00:03:24,880 --> 00:03:28,510
problem and i'm going to only give<font color="#CCCCCC"> you</font>

104
00:03:26,950 --> 00:03:30,369
the abstract idea here all of<font color="#CCCCCC"> this can</font>

105
00:03:28,510 --> 00:03:32,410
be formalized in the real world setting

106
00:03:30,370 --> 00:03:34,480
and<font color="#CCCCCC"> I will refer you to the paper for</font>

107
00:03:32,410 --> 00:03:36,220
<font color="#E5E5E5">the for details on that but abstractly</font>

108
00:03:34,480 --> 00:03:38,260
speaking you<font color="#E5E5E5"> have a client in the server</font>

109
00:03:36,220 --> 00:03:40,959
<font color="#E5E5E5">the client on</font><font color="#CCCCCC"> the left here holds a</font>

110
00:03:38,260 --> 00:03:44,140
feature vector X the server here holds a

111
00:03:40,959 --> 00:03:45,430
decision tree p and basically they're

112
00:03:44,140 --> 00:03:47,559
going<font color="#CCCCCC"> to engage in some kind of true</font>

113
00:03:45,430 --> 00:03:49,630
party computation<font color="#E5E5E5"> protocol such that at</font>

114
00:03:47,560 --> 00:03:52,600
the end of<font color="#E5E5E5"> the two-party computation the</font>

115
00:03:49,630 --> 00:03:54,640
client<font color="#E5E5E5"> only learns the evaluation of the</font>

116
00:03:52,600 --> 00:03:56,739
decision tree on the<font color="#E5E5E5"> chosen input and</font>

117
00:03:54,640 --> 00:03:59,230
maybe some additional metadata or meta

118
00:03:56,739 --> 00:04:01,590
parameters related to the decision tree

119
00:03:59,230 --> 00:04:04,359
itself about nothing more<font color="#E5E5E5"> than that and</font>

120
00:04:01,590 --> 00:04:05,980
privacy for the client says that the

121
00:04:04,360 --> 00:04:07,900
server at the end<font color="#E5E5E5"> of this protocol</font>

122
00:04:05,980 --> 00:04:10,000
execution does not learn anything about

123
00:04:07,900 --> 00:04:13,390
the input that was supplied<font color="#CCCCCC"> by the</font>

124
00:04:10,000 --> 00:04:14,739
client so for the for this talk we're

125
00:04:13,390 --> 00:04:16,298
going to focus on a problem of model

126
00:04:14,739 --> 00:04:18,910
evaluation we're going<font color="#E5E5E5"> to</font><font color="#CCCCCC"> assume that</font>

127
00:04:16,298 --> 00:04:20,560
<font color="#CCCCCC">the server ie a cloud an organization a</font>

128
00:04:18,910 --> 00:04:22,260
company they've already trained some

129
00:04:20,560 --> 00:04:25,090
model and now they're sort of

130
00:04:22,260 --> 00:04:25,900
outsourcing this model evaluation to the

131
00:04:25,090 --> 00:04:27,190
cloud in this

132
00:04:25,900 --> 00:04:30,609
sense of providing it as a useful

133
00:04:27,190 --> 00:04:31,960
service to interested clients so before

134
00:04:30,610 --> 00:04:33,580
<font color="#CCCCCC">I go into the construction of our</font>

135
00:04:31,960 --> 00:04:35,500
particular<font color="#E5E5E5"> protocol I'm going to</font>

136
00:04:33,580 --> 00:04:38,770
elaborate on a few approaches that have

137
00:04:35,500 --> 00:04:40,660
been proposed for solving this so on the

138
00:04:38,770 --> 00:04:42,370
<font color="#E5E5E5">one hand we</font><font color="#CCCCCC"> have a generic methods based</font>

139
00:04:40,660 --> 00:04:44,229
on somewhat holomorphic encryption so

140
00:04:42,370 --> 00:04:46,509
additive homomorphic encryption and

141
00:04:44,229 --> 00:04:49,570
level fully homomorphic encryption this

142
00:04:46,509 --> 00:04:51,430
was proposed by a post at all in ndss of

143
00:04:49,570 --> 00:04:53,110
last year where they show how<font color="#CCCCCC"> they can</font>

144
00:04:51,430 --> 00:04:54,250
use<font color="#CCCCCC"> some of</font><font color="#E5E5E5"> these primitives to build a</font>

145
00:04:53,110 --> 00:04:56,259
wide variety of machine learning

146
00:04:54,250 --> 00:04:58,360
classifiers unfortunately these

147
00:04:56,259 --> 00:05:00,160
protocols tend to rely on fairly<font color="#E5E5E5"> hefty</font>

148
00:04:58,360 --> 00:05:01,780
cryptographic primitives and as a result

149
00:05:00,160 --> 00:05:03,910
they are both computationally and

150
00:05:01,780 --> 00:05:05,710
bandwidth heavy but they do give a

151
00:05:03,910 --> 00:05:07,930
protocol for evaluating arbitrary

152
00:05:05,710 --> 00:05:09,549
decision trees on the<font color="#E5E5E5"> other side of the</font>

153
00:05:07,930 --> 00:05:11,380
<font color="#E5E5E5">spectrum we have yells garbled circuits</font>

154
00:05:09,550 --> 00:05:13,000
which also gives a solution for

155
00:05:11,380 --> 00:05:15,190
evaluating these decision trees in a

156
00:05:13,000 --> 00:05:16,780
privacy-preserving manner these yell

157
00:05:15,190 --> 00:05:18,400
circuits due to the optimizations<font color="#CCCCCC"> in</font>

158
00:05:16,780 --> 00:05:20,559
two-party computation for<font color="#CCCCCC"> the last few</font>

159
00:05:18,400 --> 00:05:22,419
years these are extremely efficient but

160
00:05:20,560 --> 00:05:23,800
again<font color="#CCCCCC"> the communication seems to be the</font>

161
00:05:22,419 --> 00:05:25,780
bottleneck in a lot of<font color="#CCCCCC"> these generic</font>

162
00:05:23,800 --> 00:05:27,639
methods so in our work we're<font color="#E5E5E5"> going to</font>

163
00:05:25,780 --> 00:05:30,219
look at<font color="#CCCCCC"> a look at some</font><font color="#E5E5E5"> trade-offs on a</font>

164
00:05:27,639 --> 00:05:32,320
communication bandwidth spectrum and in

165
00:05:30,220 --> 00:05:34,060
<font color="#E5E5E5">exchange for lower communication costs</font>

166
00:05:32,320 --> 00:05:35,169
we're going<font color="#E5E5E5"> to have the clients and</font>

167
00:05:34,060 --> 00:05:37,090
servers do a little bit more<font color="#CCCCCC"> work</font>

168
00:05:35,169 --> 00:05:38,710
compared<font color="#E5E5E5"> to yells garble circuits but</font>

169
00:05:37,090 --> 00:05:40,388
significantly less work compared<font color="#E5E5E5"> to</font>

170
00:05:38,710 --> 00:05:43,719
using home<font color="#CCCCCC"> morphic encryption based</font>

171
00:05:40,389 --> 00:05:45,130
techniques right<font color="#E5E5E5"> so the fundamental</font>

172
00:05:43,720 --> 00:05:47,229
<font color="#E5E5E5">building block as you might imagine</font>

173
00:05:45,130 --> 00:05:49,120
since we're evaluating decision trees is

174
00:05:47,229 --> 00:05:51,039
some way of doing comparisons we need a

175
00:05:49,120 --> 00:05:52,690
protocol<font color="#E5E5E5"> that allows us to compare the</font>

176
00:05:51,039 --> 00:05:54,610
components<font color="#E5E5E5"> of the clients feature vector</font>

177
00:05:52,690 --> 00:05:57,340
with fixed thresholds on<font color="#E5E5E5"> the server's</font>

178
00:05:54,610 --> 00:05:59,409
model<font color="#E5E5E5"> I'm not going to get into the</font>

179
00:05:57,340 --> 00:06:02,020
details of<font color="#E5E5E5"> this as this is more or</font><font color="#CCCCCC"> less</font>

180
00:05:59,409 --> 00:06:04,240
just prior work there<font color="#E5E5E5"> are many examples</font>

181
00:06:02,020 --> 00:06:06,280
of comparison protocols and the one that

182
00:06:04,240 --> 00:06:08,650
<font color="#E5E5E5">we use in our case is one proposed by</font>

183
00:06:06,280 --> 00:06:12,429
damn guard at all in 2007 and also used

184
00:06:08,650 --> 00:06:13,719
by post in 2015 so abstractly the

185
00:06:12,430 --> 00:06:16,900
comparison protocol provides the

186
00:06:13,720 --> 00:06:19,570
following guarantees both is a tube

187
00:06:16,900 --> 00:06:21,880
<font color="#E5E5E5">hardy computation where post a client</font>

188
00:06:19,570 --> 00:06:24,729
<font color="#E5E5E5">and server have a secret input an</font>

189
00:06:21,880 --> 00:06:26,349
integer X<font color="#CCCCCC"> Rho and y and basically they</font>

190
00:06:24,729 --> 00:06:27,669
engage<font color="#CCCCCC"> in a comparison protocol such</font>

191
00:06:26,349 --> 00:06:29,740
that at the end of<font color="#E5E5E5"> the protocol</font>

192
00:06:27,669 --> 00:06:31,210
execution the client learns whether X

193
00:06:29,740 --> 00:06:33,010
was less<font color="#CCCCCC"> than Y or not it learns the</font>

194
00:06:31,210 --> 00:06:34,779
comparison bit the server learns nothing

195
00:06:33,010 --> 00:06:35,979
this is a<font color="#E5E5E5"> special case of yalls</font>

196
00:06:34,779 --> 00:06:39,670
<font color="#CCCCCC">millionaire's problem if you're familiar</font>

197
00:06:35,979 --> 00:06:43,180
with that so how do we<font color="#CCCCCC"> use</font><font color="#E5E5E5"> this</font>

198
00:06:39,670 --> 00:06:45,280
comparison primitive to build a private

199
00:06:43,180 --> 00:06:46,480
decision tree evaluation protocol well

200
00:06:45,280 --> 00:06:48,429
here<font color="#CCCCCC"> I'm going to give us from and</font>

201
00:06:46,480 --> 00:06:49,780
candidate this doesn't actually work but

202
00:06:48,430 --> 00:06:50,890
I think<font color="#CCCCCC"> it highlights most of the</font>

203
00:06:49,780 --> 00:06:52,989
intuition that goes into the

204
00:06:50,890 --> 00:06:54,669
construction<font color="#CCCCCC"> of this protocol so suppose</font>

205
00:06:52,990 --> 00:06:57,370
for<font color="#E5E5E5"> sake of</font><font color="#CCCCCC"> argument that</font><font color="#E5E5E5"> the clients</font>

206
00:06:54,670 --> 00:06:59,080
for<font color="#E5E5E5"> somehow</font><font color="#CCCCCC"> Nuala decision variables and</font>

207
00:06:57,370 --> 00:07:02,110
each node in the network so in

208
00:06:59,080 --> 00:07:05,440
particular<font color="#E5E5E5"> the client knows that at at</font>

209
00:07:02,110 --> 00:07:07,630
the<font color="#E5E5E5"> first note the value of the decision</font>

210
00:07:05,440 --> 00:07:09,790
variable is<font color="#CCCCCC"> zero</font><font color="#E5E5E5"> and therefore it should</font>

211
00:07:07,630 --> 00:07:11,620
go left and correspondingly Eddie at the

212
00:07:09,790 --> 00:07:13,990
<font color="#CCCCCC">other decision notes what this</font><font color="#E5E5E5"> allows</font>

213
00:07:11,620 --> 00:07:15,550
<font color="#CCCCCC">the compliant to be able to do is a</font>

214
00:07:13,990 --> 00:07:17,500
<font color="#CCCCCC">client can now compute the index of</font><font color="#E5E5E5"> the</font>

215
00:07:15,550 --> 00:07:19,990
<font color="#E5E5E5">leaf node that corresponds to its</font>

216
00:07:17,500 --> 00:07:22,240
evaluation so if the client knew which

217
00:07:19,990 --> 00:07:24,670
this value of each decision variable the

218
00:07:22,240 --> 00:07:26,830
clan can just compute the index of<font color="#CCCCCC"> the</font>

219
00:07:24,670 --> 00:07:28,240
leaf node by itself by just evaluating

220
00:07:26,830 --> 00:07:31,960
or following<font color="#E5E5E5"> the tree traversal</font>

221
00:07:28,240 --> 00:07:33,340
procedure so now what<font color="#CCCCCC"> happens well the</font>

222
00:07:31,960 --> 00:07:35,919
client now knows the index of<font color="#CCCCCC"> the leaf</font>

223
00:07:33,340 --> 00:07:37,840
node that contains its evaluation output

224
00:07:35,920 --> 00:07:39,460
the problem basically reduces to an

225
00:07:37,840 --> 00:07:41,440
oblivious transfer protocol where we

226
00:07:39,460 --> 00:07:43,780
treat the leaves of<font color="#CCCCCC"> the decision tree as</font>

227
00:07:41,440 --> 00:07:46,390
a database and a<font color="#E5E5E5"> client knows the index</font>

228
00:07:43,780 --> 00:07:48,520
it can just simply do okie to learn the

229
00:07:46,390 --> 00:07:53,320
decision tree value at<font color="#CCCCCC"> the indicated</font>

230
00:07:48,520 --> 00:07:54,969
output so just to recap an oblivious

231
00:07:53,320 --> 00:07:56,469
transfer protocol is also a two-round

232
00:07:54,970 --> 00:07:58,480
protocol is a two-party computation

233
00:07:56,470 --> 00:08:00,400
where the server<font color="#E5E5E5"> here contain holds a</font>

234
00:07:58,480 --> 00:08:02,260
database of values so this<font color="#E5E5E5"> is a one out</font>

235
00:08:00,400 --> 00:08:04,539
of n protocol so the database server

236
00:08:02,260 --> 00:08:06,610
holds a database containing values x 1

237
00:08:04,540 --> 00:08:09,190
up to xn and a<font color="#E5E5E5"> client holds a single</font>

238
00:08:06,610 --> 00:08:10,840
index I at the<font color="#E5E5E5"> end of the protocol</font>

239
00:08:09,190 --> 00:08:13,210
execution for an<font color="#CCCCCC"> Okie protocol the</font>

240
00:08:10,840 --> 00:08:15,489
client learns the only X I so they end

241
00:08:13,210 --> 00:08:17,229
the entry<font color="#CCCCCC"> in the ice component or the</font>

242
00:08:15,490 --> 00:08:18,910
ice record of the<font color="#E5E5E5"> server's database and</font>

243
00:08:17,230 --> 00:08:20,800
nothing more<font color="#E5E5E5"> about the other entries in</font>

244
00:08:18,910 --> 00:08:22,720
a<font color="#E5E5E5"> servers database the server learns</font>

245
00:08:20,800 --> 00:08:25,590
nothing it was<font color="#E5E5E5"> in particular it does not</font>

246
00:08:22,720 --> 00:08:29,440
learn which input the client requested

247
00:08:25,590 --> 00:08:31,119
<font color="#E5E5E5">ok so just to come back to the private</font>

248
00:08:29,440 --> 00:08:33,820
decision tree evaluation how do<font color="#E5E5E5"> we use</font>

249
00:08:31,120 --> 00:08:36,130
okie to solve the problem well as I

250
00:08:33,820 --> 00:08:37,900
described earlier we have if<font color="#CCCCCC"> we assume</font>

251
00:08:36,130 --> 00:08:41,169
<font color="#CCCCCC">that</font><font color="#E5E5E5"> the client knew which in which leaf</font>

252
00:08:37,900 --> 00:08:43,360
node it landed that basically it can

253
00:08:41,169 --> 00:08:45,910
<font color="#E5E5E5">just do an</font><font color="#CCCCCC"> OT where</font><font color="#E5E5E5"> request that</font>

254
00:08:43,360 --> 00:08:48,220
particular value and the server runs the

255
00:08:45,910 --> 00:08:50,170
OT protocol with the values of all of

256
00:08:48,220 --> 00:08:51,490
the leaf nodes<font color="#E5E5E5"> and this in turn reveals</font>

257
00:08:50,170 --> 00:08:55,360
to the client

258
00:08:51,490 --> 00:08:57,339
the requested outcome<font color="#CCCCCC"> okay but as I</font>

259
00:08:55,360 --> 00:08:58,899
described earlier this there's a<font color="#E5E5E5"> very</font>

260
00:08:57,339 --> 00:09:00,640
significant problem with this<font color="#E5E5E5"> protocol</font>

261
00:08:58,899 --> 00:09:02,110
in a sense that<font color="#E5E5E5"> it requires the client</font>

262
00:09:00,640 --> 00:09:04,000
to both learn or at least know<font color="#CCCCCC"> the</font>

263
00:09:02,110 --> 00:09:06,399
structure<font color="#CCCCCC"> of</font><font color="#E5E5E5"> the tree in order to carry</font>

264
00:09:04,000 --> 00:09:08,020
out this procedure the client if they do

265
00:09:06,399 --> 00:09:10,690
<font color="#CCCCCC">not know the</font><font color="#E5E5E5"> structure of the tree they</font>

266
00:09:08,020 --> 00:09:13,029
cannot compute the index<font color="#E5E5E5"> of the leaf</font>

267
00:09:10,690 --> 00:09:15,040
node to request a neo ki protocol solo

268
00:09:13,029 --> 00:09:16,689
most of the rest of<font color="#E5E5E5"> the talk will be on</font>

269
00:09:15,040 --> 00:09:18,310
how do we actually address this and it

270
00:09:16,690 --> 00:09:20,350
turns out that for semi honest secure

271
00:09:18,310 --> 00:09:22,540
evaluation is actually quite simple it

272
00:09:20,350 --> 00:09:24,190
contains two steps the first step is

273
00:09:22,540 --> 00:09:26,410
well how do we hide<font color="#E5E5E5"> the structure of the</font>

274
00:09:24,190 --> 00:09:28,270
tree one simple way of doing that if we

275
00:09:26,410 --> 00:09:30,130
can<font color="#E5E5E5"> insert a bunch of</font><font color="#CCCCCC"> dummy notes to pad</font>

276
00:09:28,270 --> 00:09:33,459
the tree in order<font color="#E5E5E5"> to obtain a complete</font>

277
00:09:30,130 --> 00:09:35,050
binary decision tree so of<font color="#E5E5E5"> course this</font>

278
00:09:33,459 --> 00:09:37,660
doesn't current exponential costs are

279
00:09:35,050 --> 00:09:39,250
potentially in the worst case but what

280
00:09:37,660 --> 00:09:40,540
it means is that we can now reveal the

281
00:09:39,250 --> 00:09:42,760
structure of the tree it's always a very

282
00:09:40,540 --> 00:09:44,770
simple tree we just give the tell the

283
00:09:42,760 --> 00:09:46,380
client<font color="#E5E5E5"> the depths of the tree and Alec</font>

284
00:09:44,770 --> 00:09:48,520
client can compute the structure of

285
00:09:46,380 --> 00:09:50,800
course this by itself is not<font color="#E5E5E5"> sufficient</font>

286
00:09:48,520 --> 00:09:52,959
because if we the client knows the

287
00:09:50,800 --> 00:09:55,000
decision variable at every internal node

288
00:09:52,959 --> 00:09:58,239
in a decision<font color="#CCCCCC"> tree it learns the path</font>

289
00:09:55,000 --> 00:10:00,070
that it that her feature vector took in

290
00:09:58,240 --> 00:10:02,380
during a decision tree evaluation

291
00:10:00,070 --> 00:10:03,970
process this task can again reveal

292
00:10:02,380 --> 00:10:05,770
information about the structure of the

293
00:10:03,970 --> 00:10:08,980
<font color="#E5E5E5">tree which</font><font color="#CCCCCC"> reveals information about the</font>

294
00:10:05,770 --> 00:10:11,439
model so to protect<font color="#E5E5E5"> against this type of</font>

295
00:10:08,980 --> 00:10:14,589
attack<font color="#E5E5E5"> we</font><font color="#CCCCCC"> introduce a randomization step</font>

296
00:10:11,440 --> 00:10:16,600
where<font color="#CCCCCC"> we basically randomly swap the</font>

297
00:10:14,589 --> 00:10:19,480
left and right subtrees of each of the

298
00:10:16,600 --> 00:10:21,790
decision node in the graph so as an

299
00:10:19,480 --> 00:10:24,490
example here we're<font color="#E5E5E5"> going to swap the</font>

300
00:10:21,790 --> 00:10:26,170
root node so instead of comparing

301
00:10:24,490 --> 00:10:27,670
against the fixed threshold and going

302
00:10:26,170 --> 00:10:29,199
left if it's less than and going right

303
00:10:27,670 --> 00:10:31,120
if it's greater than we're going<font color="#CCCCCC"> to</font><font color="#E5E5E5"> with</font>

304
00:10:29,200 --> 00:10:33,220
probability<font color="#E5E5E5"> one half flip the left and</font>

305
00:10:31,120 --> 00:10:35,230
right subtrees and correspondingly also

306
00:10:33,220 --> 00:10:36,970
instead of using a normal decision

307
00:10:35,230 --> 00:10:40,300
variable use the negated decision

308
00:10:36,970 --> 00:10:42,130
variable so in particular after we apply

309
00:10:40,300 --> 00:10:44,410
the randomization process we can show

310
00:10:42,130 --> 00:10:46,060
that on any given input vector the pass

311
00:10:44,410 --> 00:10:48,130
<font color="#CCCCCC">through the decision tree is actually</font>

312
00:10:46,060 --> 00:10:50,829
uniformly random over all possible paths

313
00:10:48,130 --> 00:10:52,839
and so this<font color="#CCCCCC"> is a uniformly random string</font>

314
00:10:50,829 --> 00:10:55,000
it does not review any information about

315
00:10:52,839 --> 00:10:58,630
the structure of a tree to the client

316
00:10:55,000 --> 00:11:00,339
that evaluates it so our to summarize

317
00:10:58,630 --> 00:11:02,500
our private decision tree evaluation

318
00:11:00,339 --> 00:11:04,660
protocol consists of the following steps

319
00:11:02,500 --> 00:11:05,230
so first the server<font color="#CCCCCC"> is going</font><font color="#E5E5E5"> to start by</font>

320
00:11:04,660 --> 00:11:07,240
padding

321
00:11:05,230 --> 00:11:08,500
permuting a decision tree then the

322
00:11:07,240 --> 00:11:10,450
<font color="#E5E5E5">survey decline are going to engage in</font>

323
00:11:08,500 --> 00:11:12,430
<font color="#E5E5E5">this comparison protocol to learn the</font>

324
00:11:10,450 --> 00:11:14,110
values of all of the decision notes the

325
00:11:12,430 --> 00:11:16,449
client is going<font color="#E5E5E5"> to then compute the</font>

326
00:11:14,110 --> 00:11:18,940
index of<font color="#E5E5E5"> the leaf node in a commuter</font>

327
00:11:16,450 --> 00:11:20,920
tree and<font color="#CCCCCC"> there go</font><font color="#E5E5E5"> it's going to</font><font color="#CCCCCC"> engage</font>

328
00:11:18,940 --> 00:11:23,920
in an oblivious transfer protocol to

329
00:11:20,920 --> 00:11:26,770
obtain the<font color="#E5E5E5"> value of the decision tree on</font>

330
00:11:23,920 --> 00:11:28,569
her children input and if Piper we<font color="#E5E5E5"> show</font>

331
00:11:26,770 --> 00:11:31,960
that this protocol is secure against

332
00:11:28,570 --> 00:11:33,100
semi honest adversaries so in a full

333
00:11:31,960 --> 00:11:34,420
paper we also describe several

334
00:11:33,100 --> 00:11:36,250
extensions which in<font color="#E5E5E5"> the interest of time</font>

335
00:11:34,420 --> 00:11:37,810
<font color="#E5E5E5">I will not be able to get into I'll just</font>

336
00:11:36,250 --> 00:11:39,820
describe them for<font color="#CCCCCC"> you here and refer you</font>

337
00:11:37,810 --> 00:11:41,439
to the paper for further details one

338
00:11:39,820 --> 00:11:43,480
extension that<font color="#E5E5E5"> we show is that instead</font>

339
00:11:41,440 --> 00:11:44,920
of evaluating a single decision tree we

340
00:11:43,480 --> 00:11:48,190
can actually<font color="#E5E5E5"> evaluate a random forest</font>

341
00:11:44,920 --> 00:11:50,469
which is basically evaluating a cannon

342
00:11:48,190 --> 00:11:52,120
sample of decision trees and aggregating

343
00:11:50,470 --> 00:11:54,670
the results by clicking the mean or like

344
00:11:52,120 --> 00:11:56,170
a majority vote in particular<font color="#E5E5E5"> we can</font>

345
00:11:54,670 --> 00:11:57,910
show that with a simple extension of our

346
00:11:56,170 --> 00:11:59,770
protocol we can evaluate the random

347
00:11:57,910 --> 00:12:01,300
force without revealing individual

348
00:11:59,770 --> 00:12:03,670
classifications of the trees that

349
00:12:01,300 --> 00:12:05,140
comprise the<font color="#E5E5E5"> forest another thing that</font>

350
00:12:03,670 --> 00:12:06,760
<font color="#CCCCCC">we show in a full paper is that we can</font>

351
00:12:05,140 --> 00:12:08,410
actually get a security<font color="#E5E5E5"> against</font>

352
00:12:06,760 --> 00:12:10,510
malicious adversaries without too much

353
00:12:08,410 --> 00:12:12,160
extra effort and this is especially

354
00:12:10,510 --> 00:12:13,600
important because when we talk about

355
00:12:12,160 --> 00:12:14,829
deploying these protocols in a real

356
00:12:13,600 --> 00:12:16,240
world<font color="#E5E5E5"> we're really interested in</font>

357
00:12:14,830 --> 00:12:20,320
malicious settings and send me on a

358
00:12:16,240 --> 00:12:21,790
settings often<font color="#E5E5E5"> not sufficient</font><font color="#CCCCCC"> okay so to</font>

359
00:12:20,320 --> 00:12:23,740
conclude the talk i'm going to give a

360
00:12:21,790 --> 00:12:25,089
few benchmarks of this<font color="#E5E5E5"> protocol and</font>

361
00:12:23,740 --> 00:12:27,940
compare<font color="#CCCCCC"> it</font><font color="#E5E5E5"> to some of the existing</font>

362
00:12:25,090 --> 00:12:29,440
<font color="#E5E5E5">literature so we implemented the private</font>

363
00:12:27,940 --> 00:12:31,120
decision tree<font color="#E5E5E5"> in random forest protocol</font>

364
00:12:29,440 --> 00:12:32,440
and then we took a series of benchmarks

365
00:12:31,120 --> 00:12:35,800
with like<font color="#CCCCCC"> signed running on a laptop and</font>

366
00:12:32,440 --> 00:12:38,080
as server simulating an actual

367
00:12:35,800 --> 00:12:41,410
deployment scenario on any amazon<font color="#E5E5E5"> ec2</font>

368
00:12:38,080 --> 00:12:43,390
instance so here's a toy example that

369
00:12:41,410 --> 00:12:45,640
has been considered for previous work on

370
00:12:43,390 --> 00:12:47,160
private decision tree evaluation so this

371
00:12:45,640 --> 00:12:49,900
<font color="#E5E5E5">is a</font><font color="#CCCCCC"> decision tree trained on like</font>

372
00:12:47,160 --> 00:12:51,760
electrocardiogram data<font color="#E5E5E5"> used for use for</font>

373
00:12:49,900 --> 00:12:54,280
predicting heart disease this is a<font color="#CCCCCC"> very</font>

374
00:12:51,760 --> 00:12:56,110
simple<font color="#E5E5E5"> scenario the data of dimension is</font>

375
00:12:54,280 --> 00:12:57,400
only contains only six features and<font color="#CCCCCC"> the</font>

376
00:12:56,110 --> 00:12:59,530
decision tree that's trained on this

377
00:12:57,400 --> 00:13:01,660
contains only<font color="#E5E5E5"> it steps for and contains</font>

378
00:12:59,530 --> 00:13:03,130
only six comparisons but i think it's

379
00:13:01,660 --> 00:13:04,449
sort of illustrative to see how our

380
00:13:03,130 --> 00:13:06,850
protocol compares to some of the

381
00:13:04,450 --> 00:13:09,850
<font color="#CCCCCC">existing protocols so here at the top we</font>

382
00:13:06,850 --> 00:13:11,770
<font color="#CCCCCC">have a party at</font><font color="#E5E5E5"> all protocol from 2009</font>

383
00:13:09,850 --> 00:13:14,170
they this<font color="#E5E5E5"> is</font><font color="#CCCCCC"> a protocol based on yells</font>

384
00:13:11,770 --> 00:13:16,180
<font color="#E5E5E5">garbled circuits and</font><font color="#CCCCCC"> i post</font><font color="#E5E5E5"> proposed</font>

385
00:13:14,170 --> 00:13:18,490
protocol<font color="#E5E5E5"> based on somewhat homomorphic</font>

386
00:13:16,180 --> 00:13:20,469
encryption from last year

387
00:13:18,490 --> 00:13:22,270
basically the takeaway here is that our

388
00:13:20,470 --> 00:13:23,920
protocols are roughly 10 times faster

389
00:13:22,270 --> 00:13:25,870
than the<font color="#E5E5E5"> previous protocols because</font>

390
00:13:23,920 --> 00:13:27,459
we're really combining efficient

391
00:13:25,870 --> 00:13:31,300
protocols for comparisons with this

392
00:13:27,459 --> 00:13:33,040
oblivious evaluation procedure so that

393
00:13:31,300 --> 00:13:35,319
was a toy example that's not probably

394
00:13:33,040 --> 00:13:38,140
not indicative of many real-world

395
00:13:35,320 --> 00:13:40,300
applications so another second

396
00:13:38,140 --> 00:13:41,890
experiment that we looked at was looking

397
00:13:40,300 --> 00:13:44,319
at the scalability of our decision tree

398
00:13:41,890 --> 00:13:46,000
evaluation protocol and here we're

399
00:13:44,320 --> 00:13:47,320
looking<font color="#CCCCCC"> at evaluating complete</font><font color="#E5E5E5"> decision</font>

400
00:13:46,000 --> 00:13:49,060
trees<font color="#CCCCCC"> while these are not likely to</font>

401
00:13:47,320 --> 00:13:51,190
arise in practice this sort of gives the

402
00:13:49,060 --> 00:13:52,719
worst case<font color="#CCCCCC"> bound on the run time and</font>

403
00:13:51,190 --> 00:13:54,399
performance of our algorithms they're

404
00:13:52,720 --> 00:13:56,920
here we show for evaluating decision

405
00:13:54,399 --> 00:13:59,170
trees rain you from up to four notes to

406
00:13:56,920 --> 00:14:02,229
something about 10,000 notes the

407
00:13:59,170 --> 00:14:04,000
protocol scales reasonably well so for a

408
00:14:02,230 --> 00:14:07,240
<font color="#E5E5E5">decision tree containing almost 10,000</font>

409
00:14:04,000 --> 00:14:08,970
note that the complete protocols a huge

410
00:14:07,240 --> 00:14:11,440
and finishes in a couple minutes so

411
00:14:08,970 --> 00:14:14,140
basically in about five minutes or so

412
00:14:11,440 --> 00:14:16,240
and a bandwidth is on a couple of tens

413
00:14:14,140 --> 00:14:18,640
of megabytes so not ideal but

414
00:14:16,240 --> 00:14:20,080
potentially very practical for a lot<font color="#E5E5E5"> of</font>

415
00:14:18,640 --> 00:14:22,300
these cases<font color="#E5E5E5"> where high throughput is not</font>

416
00:14:20,080 --> 00:14:24,459
essential and certainly<font color="#E5E5E5"> if we're looking</font>

417
00:14:22,300 --> 00:14:27,910
<font color="#CCCCCC">at smaller decision trees our protocol</font>

418
00:14:24,459 --> 00:14:30,369
performs quite reasonably so to conclude

419
00:14:27,910 --> 00:14:32,319
in this talk I<font color="#E5E5E5"> hopefully I have</font>

420
00:14:30,370 --> 00:14:34,899
introduced some simple protocols for

421
00:14:32,320 --> 00:14:36,459
decision tree evaluation I describe how

422
00:14:34,899 --> 00:14:37,990
the protocol works in is semi honest

423
00:14:36,459 --> 00:14:40,930
setting but we can easily<font color="#E5E5E5"> extend it to</font>

424
00:14:37,990 --> 00:14:42,820
the<font color="#E5E5E5"> malicious setting and furthermore we</font>

425
00:14:40,930 --> 00:14:44,140
hope that<font color="#CCCCCC"> I've demonstrated that Semyon</font>

426
00:14:42,820 --> 00:14:45,970
is the militia secure decision tree

427
00:14:44,140 --> 00:14:47,800
protocols building by building custom

428
00:14:45,970 --> 00:14:49,660
protocols we provide new<font color="#CCCCCC"> content</font>

429
00:14:47,800 --> 00:14:51,189
computation and communication trade-offs

430
00:14:49,660 --> 00:14:53,910
and<font color="#E5E5E5"> with</font><font color="#CCCCCC"> that I'll open a Florida</font>

431
00:14:51,190 --> 00:14:53,910
questions thank you

