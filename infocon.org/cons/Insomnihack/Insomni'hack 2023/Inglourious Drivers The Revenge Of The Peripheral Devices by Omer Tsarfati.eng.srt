1
00:00:05,779 --> 00:00:09,120
thank you so hello Insomniac it's really

2
00:00:09,120 --> 00:00:11,160
great having you earlier today it's

3
00:00:11,160 --> 00:00:13,019
really great to be here today

4
00:00:13,019 --> 00:00:14,700
um so today we'll talk about Inglorious

5
00:00:14,700 --> 00:00:17,400
drivers the less glorious drivers that

6
00:00:17,400 --> 00:00:18,840
exist out there

7
00:00:18,840 --> 00:00:20,820
and for those of you who already managed

8
00:00:20,820 --> 00:00:22,740
to detect the typo in my slide so

9
00:00:22,740 --> 00:00:23,880
congrats

10
00:00:23,880 --> 00:00:25,680
um there probably might be more in other

11
00:00:25,680 --> 00:00:28,500
slides uh those are not intended but

12
00:00:28,500 --> 00:00:30,720
this one is so basically it's an homage

13
00:00:30,720 --> 00:00:32,700
to the great movie of Quentin Tarantino

14
00:00:32,700 --> 00:00:35,640
in glorious bastards which just use the

15
00:00:35,640 --> 00:00:37,160
same typo

16
00:00:37,160 --> 00:00:39,059
unfortunately we are not here to talk

17
00:00:39,059 --> 00:00:41,040
about movies right we hate to talk about

18
00:00:41,040 --> 00:00:44,700
current drivers so let's begin my name

19
00:00:44,700 --> 00:00:46,559
is Omar sulfati I'm a senior security

20
00:00:46,559 --> 00:00:48,840
researcher at cyberk Labs I'm doing

21
00:00:48,840 --> 00:00:51,000
security research for more more than

22
00:00:51,000 --> 00:00:53,160
eight years something like this in my

23
00:00:53,160 --> 00:00:54,539
spare time I like playing basketball

24
00:00:54,539 --> 00:00:56,579
when I'm not doing that probably I will

25
00:00:56,579 --> 00:00:58,920
play some video games and when I'm not

26
00:00:58,920 --> 00:01:02,879
doing that I do some research for my own

27
00:01:02,879 --> 00:01:05,519
pleasure then all right so today we'll

28
00:01:05,519 --> 00:01:07,920
talk about few things so at the very

29
00:01:07,920 --> 00:01:09,960
beginning we'll talk about the Windows

30
00:01:09,960 --> 00:01:11,880
driver framework

31
00:01:11,880 --> 00:01:13,680
um right after that we'll talk about

32
00:01:13,680 --> 00:01:15,360
some common mistakes that driver

33
00:01:15,360 --> 00:01:17,420
developers tend to do

34
00:01:17,420 --> 00:01:20,759
and then will talk about one specific

35
00:01:20,759 --> 00:01:22,619
driver that created a really big mess

36
00:01:22,619 --> 00:01:26,220
and for some reason is widely used by a

37
00:01:26,220 --> 00:01:27,360
lot of vendors

38
00:01:27,360 --> 00:01:29,640
right after that we will talk how we

39
00:01:29,640 --> 00:01:31,680
managed to utilize verse total for

40
00:01:31,680 --> 00:01:33,420
finding even more vulnerabilities than

41
00:01:33,420 --> 00:01:35,520
we found in the research that we

42
00:01:35,520 --> 00:01:37,920
conducted and at the very end we'll talk

43
00:01:37,920 --> 00:01:39,540
about some mitigations to the

44
00:01:39,540 --> 00:01:42,240
vulnerabilities we found and how you

45
00:01:42,240 --> 00:01:44,939
guys can mitigate most of them with one

46
00:01:44,939 --> 00:01:47,880
simple trick right so

47
00:01:47,880 --> 00:01:49,259
before we start talking about the

48
00:01:49,259 --> 00:01:51,060
Windows driver framework I want to tell

49
00:01:51,060 --> 00:01:54,360
you a short story so a few years ago I

50
00:01:54,360 --> 00:01:56,159
made a decision maybe not the best

51
00:01:56,159 --> 00:01:58,140
decision that I ever made but it was a

52
00:01:58,140 --> 00:02:00,899
decision and I went to the store and I

53
00:02:00,899 --> 00:02:03,420
bought myself a gaming laptop

54
00:02:03,420 --> 00:02:05,219
um so I got this gaming laptop

55
00:02:05,219 --> 00:02:08,758
manufactured by MSI and as some of you

56
00:02:08,758 --> 00:02:11,580
may know the most important thing when

57
00:02:11,580 --> 00:02:13,319
you're playing video games on your

58
00:02:13,319 --> 00:02:15,060
computer it's not about the graphics

59
00:02:15,060 --> 00:02:17,459
it's not about the all experience of the

60
00:02:17,459 --> 00:02:20,640
game it's more about FPS so basically

61
00:02:20,640 --> 00:02:22,680
the more frames you have the more fun

62
00:02:22,680 --> 00:02:25,860
you'll have eventually so there are a

63
00:02:25,860 --> 00:02:28,260
lot of ways to to achieve FPS one

64
00:02:28,260 --> 00:02:30,900
excellent way is into ensure that your

65
00:02:30,900 --> 00:02:33,599
cooling system is good and everything

66
00:02:33,599 --> 00:02:36,660
will stay chill unfortunately gaming

67
00:02:36,660 --> 00:02:39,480
laptop suffers from overeating so

68
00:02:39,480 --> 00:02:42,300
basically you need to set your fans to

69
00:02:42,300 --> 00:02:44,400
their Max most of the time another way

70
00:02:44,400 --> 00:02:47,220
to solve this problem you can just add a

71
00:02:47,220 --> 00:02:49,620
nice spoiler to your rig it might also

72
00:02:49,620 --> 00:02:51,720
help I don't know about that but it

73
00:02:51,720 --> 00:02:53,760
might uh

74
00:02:53,760 --> 00:02:57,360
right so MSI was kind enough to develop

75
00:02:57,360 --> 00:03:00,239
this program called Dragon Center which

76
00:03:00,239 --> 00:03:01,920
allows you to control a lot of things

77
00:03:01,920 --> 00:03:04,379
around your computer and one of them is

78
00:03:04,379 --> 00:03:06,840
the cooling fans but there is one thing

79
00:03:06,840 --> 00:03:09,060
about that I don't really like its GUI

80
00:03:09,060 --> 00:03:11,280
so I wanted to create my own program

81
00:03:11,280 --> 00:03:13,319
that controlled the cooling fans and

82
00:03:13,319 --> 00:03:15,420
before I started to write any code I

83
00:03:15,420 --> 00:03:17,280
started thinking which component in the

84
00:03:17,280 --> 00:03:19,739
system control controls the coolant the

85
00:03:19,739 --> 00:03:22,860
cooling defense Spin and how and how

86
00:03:22,860 --> 00:03:25,080
everything works around it so basically

87
00:03:25,080 --> 00:03:27,800
I thought that it's a user mode program

88
00:03:27,800 --> 00:03:31,200
application which talks to a low level

89
00:03:31,200 --> 00:03:33,599
kernel driver and before we're talking

90
00:03:33,599 --> 00:03:35,280
about user mode application communicate

91
00:03:35,280 --> 00:03:39,060
with kernel drivers we need at least in

92
00:03:39,060 --> 00:03:40,980
all operation system and specifically in

93
00:03:40,980 --> 00:03:42,780
Windows we need to talk about privilege

94
00:03:42,780 --> 00:03:45,659
level architecture so in Windows we have

95
00:03:45,659 --> 00:03:48,360
four different levels of uh privilege or

96
00:03:48,360 --> 00:03:50,760
four different privilege levels so the

97
00:03:50,760 --> 00:03:52,980
lowest one is the sample process which

98
00:03:52,980 --> 00:03:55,500
most of which there are not a lot of

99
00:03:55,500 --> 00:03:58,319
processes runs in assemble as a Sandbox

100
00:03:58,319 --> 00:04:01,620
process mainly your browser team slack

101
00:04:01,620 --> 00:04:05,400
Discord stuff like this and we have the

102
00:04:05,400 --> 00:04:07,680
non-admin processors which most of your

103
00:04:07,680 --> 00:04:10,860
program on your computer runs has and

104
00:04:10,860 --> 00:04:12,780
then we have the services and the admin

105
00:04:12,780 --> 00:04:14,760
processes which are considered to be a

106
00:04:14,760 --> 00:04:17,639
privileged level which means that if an

107
00:04:17,639 --> 00:04:20,339
attacker runs in as a admin process or a

108
00:04:20,339 --> 00:04:23,520
service probably your computer is uh

109
00:04:23,520 --> 00:04:27,660
um could be ultimately taken over and at

110
00:04:27,660 --> 00:04:30,540
last but not least we have the sorry we

111
00:04:30,540 --> 00:04:32,639
have the OS kernel which includes also

112
00:04:32,639 --> 00:04:34,680
the kernel drivers so some of those

113
00:04:34,680 --> 00:04:36,500
current drivers interact with hardware

114
00:04:36,500 --> 00:04:39,419
and one of them might interact with the

115
00:04:39,419 --> 00:04:40,800
coolant fence

116
00:04:40,800 --> 00:04:44,479
so basically uh MSI needed to develop

117
00:04:44,479 --> 00:04:46,680
kernel driver that interacts with the

118
00:04:46,680 --> 00:04:49,919
cooling fans but when one developing a

119
00:04:49,919 --> 00:04:52,740
kernel driver it takes ee actually takes

120
00:04:52,740 --> 00:04:54,180
a lot of risk and also a lot of

121
00:04:54,180 --> 00:04:55,979
responsibility for this

122
00:04:55,979 --> 00:04:57,479
so

123
00:04:57,479 --> 00:04:59,460
um that's because you are part of the

124
00:04:59,460 --> 00:05:02,160
kernel so all the drivers just share the

125
00:05:02,160 --> 00:05:04,440
same system other space and essentially

126
00:05:04,440 --> 00:05:06,240
all part of the kernel

127
00:05:06,240 --> 00:05:08,880
fortunately nowadays they all need to be

128
00:05:08,880 --> 00:05:10,919
signed so there is a mitigation for that

129
00:05:10,919 --> 00:05:13,380
you can disable it don't do that also

130
00:05:13,380 --> 00:05:15,780
you need to be in admin admin privileges

131
00:05:15,780 --> 00:05:19,500
so yeah it's a good thing and don't

132
00:05:19,500 --> 00:05:22,320
screw up because you're talking to a

133
00:05:22,320 --> 00:05:24,300
hardware you're filtering stuff if

134
00:05:24,300 --> 00:05:27,240
you're not handling and think correctly

135
00:05:27,240 --> 00:05:29,220
you will just crush the system and this

136
00:05:29,220 --> 00:05:31,500
is not a good thing to do list if you

137
00:05:31,500 --> 00:05:33,479
are a developer if you're an attacker do

138
00:05:33,479 --> 00:05:36,960
whatever you want uh all right so here

139
00:05:36,960 --> 00:05:39,060
we are a security researchers right so

140
00:05:39,060 --> 00:05:40,740
from a security perspective when we are

141
00:05:40,740 --> 00:05:42,240
talking about drivers we want to know

142
00:05:42,240 --> 00:05:44,759
two main things we're not we we would

143
00:05:44,759 --> 00:05:46,680
like to know which access we have to the

144
00:05:46,680 --> 00:05:50,580
driver how I can so do I have access to

145
00:05:50,580 --> 00:05:52,020
talk with the driver and what are my

146
00:05:52,020 --> 00:05:54,060
permissions and how do I communicate

147
00:05:54,060 --> 00:05:55,919
with the driver and how does the driver

148
00:05:55,919 --> 00:05:58,139
actually parse data that I'm sending to

149
00:05:58,139 --> 00:05:59,039
it

150
00:05:59,039 --> 00:06:01,800
so let's talk about access in Windows in

151
00:06:01,800 --> 00:06:03,780
order to interact with the driver the

152
00:06:03,780 --> 00:06:06,060
driver needs to create a device so the

153
00:06:06,060 --> 00:06:07,800
driver creates a device object and

154
00:06:07,800 --> 00:06:11,520
should specify which user can access to

155
00:06:11,520 --> 00:06:13,440
access access it so this is actually

156
00:06:13,440 --> 00:06:15,680
done by using a security descriptor

157
00:06:15,680 --> 00:06:18,780
which can be located either in the INF

158
00:06:18,780 --> 00:06:20,759
file that comes along the with the

159
00:06:20,759 --> 00:06:23,759
driver or or in the driver entry and

160
00:06:23,759 --> 00:06:26,160
this is this set by Colleen iocreate

161
00:06:26,160 --> 00:06:28,440
device secure so as you can already

162
00:06:28,440 --> 00:06:30,240
understand there is also a function

163
00:06:30,240 --> 00:06:33,360
called iok device not secure basically

164
00:06:33,360 --> 00:06:34,860
what what's going to happen when you

165
00:06:34,860 --> 00:06:36,720
will call this one so the default

166
00:06:36,720 --> 00:06:38,759
security descriptor will be applied and

167
00:06:38,759 --> 00:06:41,100
basically it means most of the users on

168
00:06:41,100 --> 00:06:43,440
the system can interact with the device

169
00:06:43,440 --> 00:06:46,139
so in order to make sure also the device

170
00:06:46,139 --> 00:06:49,319
object accessible from user space you

171
00:06:49,319 --> 00:06:50,940
need to create a symbolic link and this

172
00:06:50,940 --> 00:06:52,380
can be done by calling i o create

173
00:06:52,380 --> 00:06:54,900
symbolic link or i o register device

174
00:06:54,900 --> 00:06:57,900
interface then the user or the user

175
00:06:57,900 --> 00:07:00,120
application or the driver needs to call

176
00:07:00,120 --> 00:07:02,460
create file or create anti-create file

177
00:07:02,460 --> 00:07:05,460
to have a handle to the device

178
00:07:05,460 --> 00:07:07,319
so here we can see a driver called

179
00:07:07,319 --> 00:07:10,020
vitsys exposing a device object called

180
00:07:10,020 --> 00:07:12,720
vid EXO you probably can't see anything

181
00:07:12,720 --> 00:07:16,380
so let's do a quick Zoom yeah all right

182
00:07:16,380 --> 00:07:17,340
so

183
00:07:17,340 --> 00:07:19,020
um on the left hand side we can see the

184
00:07:19,020 --> 00:07:21,180
driver object and all the devices it

185
00:07:21,180 --> 00:07:25,039
exposes to the object manager and Magic

186
00:07:25,039 --> 00:07:27,660
on the right hand side we can see the

187
00:07:27,660 --> 00:07:29,400
groups and the users that have access to

188
00:07:29,400 --> 00:07:33,000
the device and what they can actually do

189
00:07:33,000 --> 00:07:35,340
with the device

190
00:07:35,340 --> 00:07:36,539
all right so let's talk about

191
00:07:36,539 --> 00:07:38,759
communication so the driver register

192
00:07:38,759 --> 00:07:41,759
need to register and dispatch routines

193
00:07:41,759 --> 00:07:44,539
through using the major function

194
00:07:44,539 --> 00:07:48,180
so basically it means which operation

195
00:07:48,180 --> 00:07:51,000
the driver supports so there are about

196
00:07:51,000 --> 00:07:54,240
27 different major functions that exist

197
00:07:54,240 --> 00:07:57,139
most of them are not commonly used only

198
00:07:57,139 --> 00:08:00,479
mainly those five are in years commonly

199
00:08:00,479 --> 00:08:02,940
so you have the create close read write

200
00:08:02,940 --> 00:08:06,000
and device IO control which is we will

201
00:08:06,000 --> 00:08:08,160
talk about it later is the most is the

202
00:08:08,160 --> 00:08:10,979
most important one for us

203
00:08:10,979 --> 00:08:13,680
um right so this is how a driver entry

204
00:08:13,680 --> 00:08:15,840
will look like so definitely it's like

205
00:08:15,840 --> 00:08:19,500
your main uh function of the driver

206
00:08:19,500 --> 00:08:22,319
um and uh we can see here there is a

207
00:08:22,319 --> 00:08:24,300
call to i o create device which will

208
00:08:24,300 --> 00:08:28,680
create a a device called testing drv and

209
00:08:28,680 --> 00:08:30,539
after that there is the registration of

210
00:08:30,539 --> 00:08:32,760
the major function as and as I told you

211
00:08:32,760 --> 00:08:36,479
before the most important one the io the

212
00:08:36,479 --> 00:08:40,860
IRP MJ device control uh which most of

213
00:08:40,860 --> 00:08:44,279
the interesting logic exists in at least

214
00:08:44,279 --> 00:08:46,080
for our needs

215
00:08:46,080 --> 00:08:49,019
all right so just like in network like

216
00:08:49,019 --> 00:08:51,720
Network Pockets we also here have also

217
00:08:51,720 --> 00:08:54,420
packets but little different Pockets so

218
00:08:54,420 --> 00:08:56,459
those Pockets called i o requests

219
00:08:56,459 --> 00:08:58,920
buckets or IRP for short

220
00:08:58,920 --> 00:09:01,380
so IOP contains any of the dispatch

221
00:09:01,380 --> 00:09:03,480
routine would ever need so the IOP

222
00:09:03,480 --> 00:09:05,279
structure is generated by the i o

223
00:09:05,279 --> 00:09:07,019
manager and it consists of Stack

224
00:09:07,019 --> 00:09:08,820
location which is where all the

225
00:09:08,820 --> 00:09:11,580
important members are reside we have the

226
00:09:11,580 --> 00:09:13,560
requester mode we initiate the call if

227
00:09:13,560 --> 00:09:15,860
it's the kernel if it's the user land

228
00:09:15,860 --> 00:09:18,180
the input and the output buffer is sent

229
00:09:18,180 --> 00:09:20,040
to the driver and the i o status

230
00:09:20,040 --> 00:09:22,080
information which indicate indicates how

231
00:09:22,080 --> 00:09:23,760
many bytes should be written back to the

232
00:09:23,760 --> 00:09:26,459
output buffer enemies use of those

233
00:09:26,459 --> 00:09:29,519
fields would probably cause the bugs so

234
00:09:29,519 --> 00:09:31,320
you might cross the system you might

235
00:09:31,320 --> 00:09:35,220
allow arbitrary read write in the kernel

236
00:09:35,220 --> 00:09:37,800
so this is bad

237
00:09:37,800 --> 00:09:38,580
um

238
00:09:38,580 --> 00:09:41,760
all right so besides besides that the

239
00:09:41,760 --> 00:09:44,160
help struct also contains a field called

240
00:09:44,160 --> 00:09:47,760
IO control a i o control code or ioctal

241
00:09:47,760 --> 00:09:50,640
for short so the actor is just it's a

242
00:09:50,640 --> 00:09:53,640
number that used as an identifier for

243
00:09:53,640 --> 00:09:56,220
other programs to execute specific logic

244
00:09:56,220 --> 00:09:59,399
in the driver so the axle is just a

245
00:09:59,399 --> 00:10:01,680
function identifier right so it's

246
00:10:01,680 --> 00:10:03,660
basically packing a little bit more than

247
00:10:03,660 --> 00:10:07,980
that so it's a 32-bit packed fracture

248
00:10:07,980 --> 00:10:10,980
and so the first two bits indicates

249
00:10:10,980 --> 00:10:14,040
indicates uh what what is the transfer

250
00:10:14,040 --> 00:10:16,500
type of the requested sent and the 13

251
00:10:16,500 --> 00:10:19,500
and 14 are indicates the required access

252
00:10:19,500 --> 00:10:21,560
of the request

253
00:10:21,560 --> 00:10:23,640
all right so let's talk about the

254
00:10:23,640 --> 00:10:26,399
required access so it's actually

255
00:10:26,399 --> 00:10:28,019
described the required permission to

256
00:10:28,019 --> 00:10:30,240
send to the device IO control request it

257
00:10:30,240 --> 00:10:32,160
based on your permission when you called

258
00:10:32,160 --> 00:10:34,560
anti-create file or create file so it

259
00:10:34,560 --> 00:10:36,360
depends on the handle you have so there

260
00:10:36,360 --> 00:10:39,060
are about four different options file

261
00:10:39,060 --> 00:10:41,880
any access file read access file write

262
00:10:41,880 --> 00:10:44,339
access and file read and write access so

263
00:10:44,339 --> 00:10:46,200
those are actually in order from the

264
00:10:46,200 --> 00:10:47,579
least privileged one to the most

265
00:10:47,579 --> 00:10:48,779
privileged one

266
00:10:48,779 --> 00:10:51,300
also we have the transfer type so this

267
00:10:51,300 --> 00:10:54,060
actually describes how the i o manager

268
00:10:54,060 --> 00:10:56,820
fits the user data so here we have a lot

269
00:10:56,820 --> 00:10:58,380
of different nonsense that the driver

270
00:10:58,380 --> 00:11:01,980
developer must know and where when there

271
00:11:01,980 --> 00:11:03,360
are a lot of different downloads that

272
00:11:03,360 --> 00:11:04,980
you need to know you should know there

273
00:11:04,980 --> 00:11:07,620
might be a lot of bugs so there are four

274
00:11:07,620 --> 00:11:09,600
different options here we have the metal

275
00:11:09,600 --> 00:11:11,519
buffered method indirect method

276
00:11:11,519 --> 00:11:14,040
outdirect and Method neither so here

277
00:11:14,040 --> 00:11:16,380
it's also in order from the most secure

278
00:11:16,380 --> 00:11:17,480
one

279
00:11:17,480 --> 00:11:20,180
that is commonly

280
00:11:20,180 --> 00:11:22,380
considered to be the most secure one to

281
00:11:22,380 --> 00:11:24,600
the least secure one so method neither

282
00:11:24,600 --> 00:11:27,240
as one of my colleague call it the

283
00:11:27,240 --> 00:11:30,660
mother of all evil so yeah

284
00:11:30,660 --> 00:11:32,880
all right so in order to send a device

285
00:11:32,880 --> 00:11:34,860
control request we will use the device R

286
00:11:34,860 --> 00:11:37,260
Control Function which takes a handle to

287
00:11:37,260 --> 00:11:39,300
the device it takes a i o control code

288
00:11:39,300 --> 00:11:41,519
and the input buffer and its size and

289
00:11:41,519 --> 00:11:43,980
the output buffer and its size

290
00:11:43,980 --> 00:11:47,100
right so by now we know a lot and we

291
00:11:47,100 --> 00:11:49,620
know how to interact with driver drivers

292
00:11:49,620 --> 00:11:54,300
in Windows so let's talk about mistakes

293
00:11:54,300 --> 00:11:55,680
all right

294
00:11:55,680 --> 00:11:58,200
um so let's talk about method needer

295
00:11:58,200 --> 00:12:00,000
um so in this case the io manager is

296
00:12:00,000 --> 00:12:02,220
actually pretty much lazy so the buffers

297
00:12:02,220 --> 00:12:04,920
and the lamps will will reside in user

298
00:12:04,920 --> 00:12:07,019
mode and the Canon doesn't copy them to

299
00:12:07,019 --> 00:12:09,540
the kernel space they can be paged out

300
00:12:09,540 --> 00:12:13,260
and it can cause some problems the input

301
00:12:13,260 --> 00:12:15,300
the input buffer will be type 3 input

302
00:12:15,300 --> 00:12:16,740
buffer the output buffer will be the

303
00:12:16,740 --> 00:12:19,440
user buffer so the user can allocate and

304
00:12:19,440 --> 00:12:21,779
de-allocate the buffers making those

305
00:12:21,779 --> 00:12:24,660
pages invalid so you need to be cautious

306
00:12:24,660 --> 00:12:26,820
when dealing with them and also you need

307
00:12:26,820 --> 00:12:28,380
to know that every access to the buffers

308
00:12:28,380 --> 00:12:31,140
must be in a try accept block

309
00:12:31,140 --> 00:12:34,320
also you need to do some probing so

310
00:12:34,320 --> 00:12:36,779
whenever you want to read or write to

311
00:12:36,779 --> 00:12:39,180
the buffers you need to use probe for

312
00:12:39,180 --> 00:12:42,060
read and probe for write accordingly but

313
00:12:42,060 --> 00:12:43,620
if you don't do them or you don't use

314
00:12:43,620 --> 00:12:46,560
them correctly it's for it rules for

315
00:12:46,560 --> 00:12:49,620
some errors on invalid address so the

316
00:12:49,620 --> 00:12:51,899
call actually if it's not in try accept

317
00:12:51,899 --> 00:12:54,300
block will cross the system if the

318
00:12:54,300 --> 00:12:56,459
length is zero of the buffer that is

319
00:12:56,459 --> 00:12:59,399
sent by the user so actually it does

320
00:12:59,399 --> 00:13:02,339
probably do nothing and the validation

321
00:13:02,339 --> 00:13:06,060
just passed away uh it just passes

322
00:13:06,060 --> 00:13:07,260
um so

323
00:13:07,260 --> 00:13:09,779
if you if you're not probing correctly

324
00:13:09,779 --> 00:13:12,660
the uh the kernel reads then they cannot

325
00:13:12,660 --> 00:13:14,160
wait from the buffer you will cross the

326
00:13:14,160 --> 00:13:16,920
system at the very least and well at

327
00:13:16,920 --> 00:13:19,200
least for uh for us as security such as

328
00:13:19,200 --> 00:13:21,360
you might have some inflict and if

329
00:13:21,360 --> 00:13:23,940
you're doing it for writing you will see

330
00:13:23,940 --> 00:13:25,740
either of course the system or allow

331
00:13:25,740 --> 00:13:28,200
arbitrary kernel right

332
00:13:28,200 --> 00:13:32,040
right so this is an example of a buggy a

333
00:13:32,040 --> 00:13:35,339
quad from a real driver

334
00:13:35,339 --> 00:13:38,160
um here we can see uh that the driver

335
00:13:38,160 --> 00:13:41,399
developers didn't hear about probing so

336
00:13:41,399 --> 00:13:44,160
in the first in the first box the driver

337
00:13:44,160 --> 00:13:45,839
reads in the input buffer we see there

338
00:13:45,839 --> 00:13:47,760
is no probing function before the usage

339
00:13:47,760 --> 00:13:50,880
in the second box there is a dereference

340
00:13:50,880 --> 00:13:53,100
of a pointer without checking if the

341
00:13:53,100 --> 00:13:55,200
buffer is now so this also might cross

342
00:13:55,200 --> 00:13:57,000
the system

343
00:13:57,000 --> 00:14:00,300
um on the third box the address could

344
00:14:00,300 --> 00:14:02,519
already be paged out because in a crash

345
00:14:02,519 --> 00:14:05,579
when writing to the alpha buffer and

346
00:14:05,579 --> 00:14:08,459
besides that uh the input and the output

347
00:14:08,459 --> 00:14:11,220
buffers access not in a try except block

348
00:14:11,220 --> 00:14:14,220
try catch block so the driver can can

349
00:14:14,220 --> 00:14:16,139
get access denied and crashed the system

350
00:14:16,139 --> 00:14:19,079
and also in the second box just like in

351
00:14:19,079 --> 00:14:21,660
the second box in the also in the fourth

352
00:14:21,660 --> 00:14:24,000
blocks box there is accessing to the

353
00:14:24,000 --> 00:14:26,639
input buffer without any validation and

354
00:14:26,639 --> 00:14:29,220
lastly it's not in a box but the access

355
00:14:29,220 --> 00:14:31,139
to the output buffer doesn't involve

356
00:14:31,139 --> 00:14:33,779
probing which will eventually allow us

357
00:14:33,779 --> 00:14:37,260
to do a arbitrary kernel right A Memory

358
00:14:37,260 --> 00:14:39,720
right so yeah this is also a problem

359
00:14:39,720 --> 00:14:41,880
let's talk about the bed of butter in

360
00:14:41,880 --> 00:14:44,760
the family the metal buffered so metal

361
00:14:44,760 --> 00:14:47,160
buffer in this case the manager copies

362
00:14:47,160 --> 00:14:48,899
the buffers and the lamps to the kernel

363
00:14:48,899 --> 00:14:51,959
in a secure manner so therefore you so

364
00:14:51,959 --> 00:14:53,940
those are resides in kernel memory not

365
00:14:53,940 --> 00:14:56,459
in user user space memory you don't need

366
00:14:56,459 --> 00:14:58,620
to crop anything so this is good but you

367
00:14:58,620 --> 00:15:00,540
have to remember if there's any fields

368
00:15:00,540 --> 00:15:02,760
that are embedded in the buffer you need

369
00:15:02,760 --> 00:15:05,459
to uh to treat them probably so you need

370
00:15:05,459 --> 00:15:07,320
to do validations when you're accessing

371
00:15:07,320 --> 00:15:09,180
those

372
00:15:09,180 --> 00:15:11,160
um in this case that the input buffer

373
00:15:11,160 --> 00:15:12,600
and output buffer will be the system

374
00:15:12,600 --> 00:15:16,620
buffer as part of the IOP structure

375
00:15:16,620 --> 00:15:19,560
um and also we have the iostatus

376
00:15:19,560 --> 00:15:21,899
information which actually as I told you

377
00:15:21,899 --> 00:15:23,339
before indicates how many bytes should

378
00:15:23,339 --> 00:15:26,579
be copied to the user's output buffer if

379
00:15:26,579 --> 00:15:28,440
the io status information is bigger than

380
00:15:28,440 --> 00:15:30,180
the iPhone buffer length and the outer

381
00:15:30,180 --> 00:15:31,860
buffer length is bigger than the input

382
00:15:31,860 --> 00:15:33,540
buffer length the rest of the system

383
00:15:33,540 --> 00:15:35,760
buffer will be copied to the auto buffer

384
00:15:35,760 --> 00:15:39,240
uh we will be uninitialized memory and

385
00:15:39,240 --> 00:15:42,660
this could uh lead to info leak or

386
00:15:42,660 --> 00:15:44,940
crushing the system so let's say we have

387
00:15:44,940 --> 00:15:48,180
a one page of the output buffer length

388
00:15:48,180 --> 00:15:50,399
it's one page the input buffer length

389
00:15:50,399 --> 00:15:54,120
it's 8 bytes and the iost.7 information

390
00:15:54,120 --> 00:15:56,519
will be output buffer lens so we will

391
00:15:56,519 --> 00:15:59,160
link about one page of memory from the

392
00:15:59,160 --> 00:16:01,620
kernel to the user space

393
00:16:01,620 --> 00:16:03,540
um right so here we have also an example

394
00:16:03,540 --> 00:16:04,740
to

395
00:16:04,740 --> 00:16:07,019
um uh to metal buffer to a driver

396
00:16:07,019 --> 00:16:09,420
implements um a I octal form metal

397
00:16:09,420 --> 00:16:11,639
buffer again it's not safe to assume

398
00:16:11,639 --> 00:16:13,860
that this code is about free of course

399
00:16:13,860 --> 00:16:17,100
it's not if it's in the presentation

400
00:16:17,100 --> 00:16:19,320
um all right so on the second box we can

401
00:16:19,320 --> 00:16:21,360
see a nice length checks and beneath

402
00:16:21,360 --> 00:16:24,720
that check they initialize some memory

403
00:16:24,720 --> 00:16:27,779
um after that there is so there is a if

404
00:16:27,779 --> 00:16:33,360
a statement if we fail to to to go into

405
00:16:33,360 --> 00:16:35,220
the first if statement we'll go to the

406
00:16:35,220 --> 00:16:37,620
else and in Dallas there is a I started

407
00:16:37,620 --> 00:16:39,120
this information with a really big

408
00:16:39,120 --> 00:16:42,839
number around 11k of Kernel memory that

409
00:16:42,839 --> 00:16:44,880
could be leaked and in this case we'll

410
00:16:44,880 --> 00:16:46,860
just have a huge memory leak or will

411
00:16:46,860 --> 00:16:49,199
crash the system if we'll get into an

412
00:16:49,199 --> 00:16:50,880
invalid page

413
00:16:50,880 --> 00:16:54,540
right let's talk about direct i o

414
00:16:54,540 --> 00:16:56,820
um so in this case we have two different

415
00:16:56,820 --> 00:16:58,980
methods so we have method interact and

416
00:16:58,980 --> 00:17:01,259
Method I'll direct so in this case there

417
00:17:01,259 --> 00:17:03,540
are two buffers that send into the

418
00:17:03,540 --> 00:17:05,339
kernel so we have the system buffer and

419
00:17:05,339 --> 00:17:07,980
the mdl address the second buffer is a

420
00:17:07,980 --> 00:17:08,780
direct

421
00:17:08,780 --> 00:17:11,459
as the direct buffer which always will

422
00:17:11,459 --> 00:17:15,059
be paged in so faster access for us and

423
00:17:15,059 --> 00:17:17,339
this buffer can be used either for your

424
00:17:17,339 --> 00:17:20,040
input or output a kernel driver can also

425
00:17:20,040 --> 00:17:22,799
create mdl by using iocreate mdl for by

426
00:17:22,799 --> 00:17:25,199
locking it with mm probe logs Pages

427
00:17:25,199 --> 00:17:27,119
which is quite important we'll talk a

428
00:17:27,119 --> 00:17:29,160
little bit about that in the next slide

429
00:17:29,160 --> 00:17:33,179
and if this function fails for some

430
00:17:33,179 --> 00:17:36,960
reason so let's assume that you gave it

431
00:17:36,960 --> 00:17:39,240
a invalid page so it will for an

432
00:17:39,240 --> 00:17:42,120
exception and if this is this one is not

433
00:17:42,120 --> 00:17:44,400
handled properly you will press the

434
00:17:44,400 --> 00:17:45,539
system

435
00:17:45,539 --> 00:17:47,760
all right so you might ask in yourself

436
00:17:47,760 --> 00:17:50,340
what is mdl so mdl is a structure that

437
00:17:50,340 --> 00:17:52,260
describes the fixed physical memory

438
00:17:52,260 --> 00:17:55,140
location that comprise the a contiguous

439
00:17:55,140 --> 00:17:56,940
data buffer in virtual memory or in

440
00:17:56,940 --> 00:17:58,799
simpler Awards so then they'll actually

441
00:17:58,799 --> 00:18:01,320
describes the data buffer in the fixed

442
00:18:01,320 --> 00:18:03,780
position in physical memory which will

443
00:18:03,780 --> 00:18:05,940
be always paged in and locked in memory

444
00:18:05,940 --> 00:18:08,820
so it basically double mapping one for

445
00:18:08,820 --> 00:18:12,000
the user and one for the kernel

446
00:18:12,000 --> 00:18:14,760
um let's see an example of not writing a

447
00:18:14,760 --> 00:18:17,820
good code with uh IO um with a direct i

448
00:18:17,820 --> 00:18:20,640
o so um in this case we can see in the

449
00:18:20,640 --> 00:18:23,580
red box uh we have a full control over

450
00:18:23,580 --> 00:18:26,580
the mdl with the so there is a variable

451
00:18:26,580 --> 00:18:28,799
which an original name control

452
00:18:28,799 --> 00:18:32,100
controllable virtual address and here we

453
00:18:32,100 --> 00:18:34,320
can see that there is a call to mm probe

454
00:18:34,320 --> 00:18:37,020
and log Pages which is not wrapped in

455
00:18:37,020 --> 00:18:39,240
try accept block and if you will send an

456
00:18:39,240 --> 00:18:41,880
invalid virtual address we will trigger

457
00:18:41,880 --> 00:18:44,340
a b sod and we will actually crush the

458
00:18:44,340 --> 00:18:45,299
system

459
00:18:45,299 --> 00:18:48,539
all right so we talked a lot about uh

460
00:18:48,539 --> 00:18:51,419
mistakes the driver developers do we

461
00:18:51,419 --> 00:18:52,320
also

462
00:18:52,320 --> 00:18:55,160
um I also showed you some example

463
00:18:55,160 --> 00:18:59,640
examples let's get back to the MSI thing

464
00:18:59,640 --> 00:19:01,740
all right so

465
00:19:01,740 --> 00:19:02,700
um

466
00:19:02,700 --> 00:19:04,440
um all right so back to my laptop I try

467
00:19:04,440 --> 00:19:06,240
to find a drive the driver of the Dragon

468
00:19:06,240 --> 00:19:08,640
Center interacts with

469
00:19:08,640 --> 00:19:11,039
um lucky me I found the one that didn't

470
00:19:11,039 --> 00:19:13,740
interact with it's win IO which is

471
00:19:13,740 --> 00:19:15,780
loaded by the dragon Center serve

472
00:19:15,780 --> 00:19:18,840
Service uh and I check if I have access

473
00:19:18,840 --> 00:19:21,120
to the device it exposes and fortunately

474
00:19:21,120 --> 00:19:24,059
I do have access to interact with it so

475
00:19:24,059 --> 00:19:26,280
I open Ida and started doing some

476
00:19:26,280 --> 00:19:27,960
reverse engineering

477
00:19:27,960 --> 00:19:29,880
all right so here is the decompile code

478
00:19:29,880 --> 00:19:31,740
of the dispatch routine

479
00:19:31,740 --> 00:19:35,340
um here we can see uh that here we can

480
00:19:35,340 --> 00:19:36,900
see the system buffer which is the

481
00:19:36,900 --> 00:19:38,600
buffer sent by the user to the driver

482
00:19:38,600 --> 00:19:42,960
and its length s and here we can see uh

483
00:19:42,960 --> 00:19:46,799
there is a switch case with di octals a

484
00:19:46,799 --> 00:19:49,140
switch case goes over the different

485
00:19:49,140 --> 00:19:51,299
major function and there's also another

486
00:19:51,299 --> 00:19:54,179
switch case embedded in it which goes

487
00:19:54,179 --> 00:19:55,980
over the different ioctal that the

488
00:19:55,980 --> 00:19:57,960
driver supports

489
00:19:57,960 --> 00:20:00,299
um and for those of you managed to see

490
00:20:00,299 --> 00:20:03,900
line 47 uh you might already found the

491
00:20:03,900 --> 00:20:08,100
bug so in line 47 the there is a mem

492
00:20:08,100 --> 00:20:10,620
copy from the user buffer with a

493
00:20:10,620 --> 00:20:13,260
controllable length to a local variable

494
00:20:13,260 --> 00:20:15,539
so it actually means there is a

495
00:20:15,539 --> 00:20:19,020
potential buffer overflow here right

496
00:20:19,020 --> 00:20:19,760
um

497
00:20:19,760 --> 00:20:23,820
so yeah if you will send a buffer in the

498
00:20:23,820 --> 00:20:28,679
size of 32x Plus 8 we maybe would be

499
00:20:28,679 --> 00:20:31,980
able to overrun the return address right

500
00:20:31,980 --> 00:20:34,620
and this is what we did so we send a

501
00:20:34,620 --> 00:20:36,620
buffer and

502
00:20:36,620 --> 00:20:38,820
we cross the system so basically we

503
00:20:38,820 --> 00:20:40,980
override the return address and we

504
00:20:40,980 --> 00:20:43,919
managed to run code in the kernel

505
00:20:43,919 --> 00:20:45,600
um you're probably asking yourself hold

506
00:20:45,600 --> 00:20:46,700
on

507
00:20:46,700 --> 00:20:49,799
isn't there any spot Cannery there in

508
00:20:49,799 --> 00:20:51,799
that would prevent this

509
00:20:51,799 --> 00:20:54,240
so they didn't compile the driver with

510
00:20:54,240 --> 00:20:56,820
stock Henry and this is bad don't do

511
00:20:56,820 --> 00:21:00,059
that uh you stuck on Words uh all right

512
00:21:00,059 --> 00:21:02,220
so don't worry it's not the only bug

513
00:21:02,220 --> 00:21:05,160
that exists in the driver

514
00:21:05,160 --> 00:21:08,160
um basically uh there are also you can

515
00:21:08,160 --> 00:21:10,460
all the diver also lots a low level

516
00:21:10,460 --> 00:21:13,440
processes to read from IO ports and read

517
00:21:13,440 --> 00:21:16,980
to IOP ports and also it lets you to

518
00:21:16,980 --> 00:21:19,919
yeah all right and also it lets you to

519
00:21:19,919 --> 00:21:22,140
unmap and map physical memory into

520
00:21:22,140 --> 00:21:24,179
virtual addresses so basically you can

521
00:21:24,179 --> 00:21:26,340
read their own memory

522
00:21:26,340 --> 00:21:28,679
um yeah so this driver was a really

523
00:21:28,679 --> 00:21:31,260
buggy one uh I didn't find what I wanted

524
00:21:31,260 --> 00:21:33,600
to find how I control the cooling fans

525
00:21:33,600 --> 00:21:37,260
but I found a lot of bags uh yeah

526
00:21:37,260 --> 00:21:40,380
so this is a lot of process but wait

527
00:21:40,380 --> 00:21:43,919
there is more so as I told you before as

528
00:21:43,919 --> 00:21:47,640
a gamer I want as much fps in games as I

529
00:21:47,640 --> 00:21:50,940
can get and only real Gamers know that

530
00:21:50,940 --> 00:21:54,480
RGB gives you more FPS

531
00:21:54,480 --> 00:21:57,419
um so I made another decision again not

532
00:21:57,419 --> 00:21:59,159
the best decision but it is a decision

533
00:21:59,159 --> 00:22:01,740
and I went to the store and bought

534
00:22:01,740 --> 00:22:03,980
myself a cube a gaming keyboard

535
00:22:03,980 --> 00:22:06,380
manufactured by razor

536
00:22:06,380 --> 00:22:09,179
uh all right so Razer was also kind

537
00:22:09,179 --> 00:22:12,240
enough to develop a a program called

538
00:22:12,240 --> 00:22:15,120
Razer synapse which let you control the

539
00:22:15,120 --> 00:22:17,059
RGB lights on your computer and stuff

540
00:22:17,059 --> 00:22:20,340
and of course as a good gaming program

541
00:22:20,340 --> 00:22:24,419
it's also have its own drivers

542
00:22:24,419 --> 00:22:26,880
so there is a driver that the Razer

543
00:22:26,880 --> 00:22:30,000
signup service loads called r0 Razer

544
00:22:30,000 --> 00:22:32,419
signup service original

545
00:22:32,419 --> 00:22:35,880
and it exposes an or device object named

546
00:22:35,880 --> 00:22:37,740
win green zero

547
00:22:37,740 --> 00:22:39,600
right

548
00:22:39,600 --> 00:22:42,299
um so just like before allocated the

549
00:22:42,299 --> 00:22:43,919
driver file and started doing some

550
00:22:43,919 --> 00:22:45,659
reverse engineering so let's jump into

551
00:22:45,659 --> 00:22:47,280
the code

552
00:22:47,280 --> 00:22:49,919
um so here we also have the uh the main

553
00:22:49,919 --> 00:22:52,020
dispatch routine we will go to the

554
00:22:52,020 --> 00:22:54,900
device Control Function

555
00:22:54,900 --> 00:22:57,480
yep

556
00:22:57,480 --> 00:22:59,760
um so fortunately here we can see that

557
00:22:59,760 --> 00:23:01,559
the driver developers did something

558
00:23:01,559 --> 00:23:04,260
different they did some validation over

559
00:23:04,260 --> 00:23:06,659
the buffer length so this is good right

560
00:23:06,659 --> 00:23:08,880
so we won't find any buffer overflows

561
00:23:08,880 --> 00:23:12,360
here unfortunately yet there are still

562
00:23:12,360 --> 00:23:14,820
some vulnerabilities uh in this as well

563
00:23:14,820 --> 00:23:18,480
so here we have a i o i o Port read and

564
00:23:18,480 --> 00:23:21,419
write Primitives just as before and also

565
00:23:21,419 --> 00:23:25,500
we got this thing so

566
00:23:25,500 --> 00:23:27,659
this is actually interesting because the

567
00:23:27,659 --> 00:23:29,580
driver lets us to read and write to

568
00:23:29,580 --> 00:23:31,679
arbitrary msrs

569
00:23:31,679 --> 00:23:33,780
right so at this point you might ask

570
00:23:33,780 --> 00:23:36,960
yourself what msrs are

571
00:23:36,960 --> 00:23:39,900
all right so msrs are model specific

572
00:23:39,900 --> 00:23:42,600
registers so it's basically any various

573
00:23:42,600 --> 00:23:45,539
control registers in x86 instruction set

574
00:23:45,539 --> 00:23:47,700
used for debugging program execution

575
00:23:47,700 --> 00:23:49,799
pricing computer performance monitoring

576
00:23:49,799 --> 00:23:53,880
toggling certain CPU features and there

577
00:23:53,880 --> 00:23:57,539
is MSL called IA 32 l-star which holds

578
00:23:57,539 --> 00:23:59,520
the pointer to the system call Handler

579
00:23:59,520 --> 00:24:01,740
which upon Cisco's this pointer is

580
00:24:01,740 --> 00:24:04,320
loaded into IRP and as you can already

581
00:24:04,320 --> 00:24:07,200
understand if you will overwrite the

582
00:24:07,200 --> 00:24:11,640
this specific MSR with arbitrary pointer

583
00:24:11,640 --> 00:24:14,900
to whatever we want we will achieve a

584
00:24:14,900 --> 00:24:17,460
arbitrary code execution in kernel

585
00:24:17,460 --> 00:24:20,880
context so this is uh yeah this is not

586
00:24:20,880 --> 00:24:23,520
good uh for the Developers for us it's

587
00:24:23,520 --> 00:24:24,900
great

588
00:24:24,900 --> 00:24:26,400
um all right so

589
00:24:26,400 --> 00:24:28,200
um but we didn't do one thing we didn't

590
00:24:28,200 --> 00:24:30,120
check if we have access to device object

591
00:24:30,120 --> 00:24:33,720
so let's jump into the driver entry to

592
00:24:33,720 --> 00:24:35,700
the i o create device so as I told you

593
00:24:35,700 --> 00:24:38,100
the I occur device it's the not secured

594
00:24:38,100 --> 00:24:40,440
one which will create a device with a

595
00:24:40,440 --> 00:24:42,840
default security descriptor

596
00:24:42,840 --> 00:24:45,240
um so in this case it means that we will

597
00:24:45,240 --> 00:24:48,360
have access to the device and we will be

598
00:24:48,360 --> 00:24:51,000
able to trigger this vulnerability

599
00:24:51,000 --> 00:24:53,640
so previous discoloration confirmed

600
00:24:53,640 --> 00:24:55,679
or is it

601
00:24:55,679 --> 00:24:58,559
um when we went to the device object

602
00:24:58,559 --> 00:25:00,419
properties we looked at the description

603
00:25:00,419 --> 00:25:02,880
this security that apply to the device

604
00:25:02,880 --> 00:25:05,220
and we can see that only administrators

605
00:25:05,220 --> 00:25:07,500
and system can interact with that

606
00:25:07,500 --> 00:25:11,039
so we can see a clear inconsistent

607
00:25:11,039 --> 00:25:13,020
between the driver code and the device

608
00:25:13,020 --> 00:25:15,299
security object so the driver doesn't

609
00:25:15,299 --> 00:25:18,720
enforce any security descriptor so the

610
00:25:18,720 --> 00:25:20,280
only logical explanation for this

611
00:25:20,280 --> 00:25:22,679
phenomena is that some other process

612
00:25:22,679 --> 00:25:27,600
just changes the device object security

613
00:25:27,600 --> 00:25:28,200
um

614
00:25:28,200 --> 00:25:30,000
all right so basically it will look

615
00:25:30,000 --> 00:25:31,860
something like this so we have the

616
00:25:31,860 --> 00:25:34,380
winning zero a driver loaded then the

617
00:25:34,380 --> 00:25:36,059
wind going zero creates a device with

618
00:25:36,059 --> 00:25:38,940
the default security descriptor then uh

619
00:25:38,940 --> 00:25:40,620
some random process just changes the

620
00:25:40,620 --> 00:25:44,520
security descriptor and here we are

621
00:25:44,520 --> 00:25:47,340
um yeah but there is a small time gap

622
00:25:47,340 --> 00:25:48,659
between the creation of the device

623
00:25:48,659 --> 00:25:51,539
object and the time that the some random

624
00:25:51,539 --> 00:25:53,279
process just changes the security script

625
00:25:53,279 --> 00:25:55,440
or so that there there is a rate

626
00:25:55,440 --> 00:25:57,900
condition there and as attackers or

627
00:25:57,900 --> 00:25:59,520
security researchers we can actually

628
00:25:59,520 --> 00:26:01,679
abuse this one

629
00:26:01,679 --> 00:26:04,500
um this is true as long as we all

630
00:26:04,500 --> 00:26:06,720
managed to run our code before the

631
00:26:06,720 --> 00:26:10,140
random process runs each code

632
00:26:10,140 --> 00:26:13,380
um Yeah so basically after doing some

633
00:26:13,380 --> 00:26:17,340
research uh some further research we get

634
00:26:17,340 --> 00:26:19,020
into this one so raise the sign up

635
00:26:19,020 --> 00:26:21,779
service uses a open source project

636
00:26:21,779 --> 00:26:24,720
called Libra arduamontolib which loads

637
00:26:24,720 --> 00:26:27,539
the Wind Creek zero a driver then the

638
00:26:27,539 --> 00:26:29,820
window creates a device object and there

639
00:26:29,820 --> 00:26:31,740
is the worst condition and some random

640
00:26:31,740 --> 00:26:34,320
process changes the device a Securities

641
00:26:34,320 --> 00:26:37,820
crypto fortunately uh the the liberal

642
00:26:37,820 --> 00:26:40,440
montolibits an open source project so we

643
00:26:40,440 --> 00:26:43,020
uh quite easily could find its source

644
00:26:43,020 --> 00:26:46,380
code so let's see what this one does

645
00:26:46,380 --> 00:26:49,200
um right so here we can see

646
00:26:49,200 --> 00:26:51,960
um the so the dll actually open handle

647
00:26:51,960 --> 00:26:54,179
to the service manager and creates a new

648
00:26:54,179 --> 00:26:56,400
service or in other words in this case

649
00:26:56,400 --> 00:26:59,700
creates a new driver and then it's asked

650
00:26:59,700 --> 00:27:03,840
the um the service manager to load the

651
00:27:03,840 --> 00:27:05,880
driver right after that it opens an

652
00:27:05,880 --> 00:27:08,880
handle to uh to the created device yep

653
00:27:08,880 --> 00:27:11,279
all right all right so right after that

654
00:27:11,279 --> 00:27:13,559
it opens handle to it opens handle to

655
00:27:13,559 --> 00:27:16,200
the creative device and it changes the

656
00:27:16,200 --> 00:27:18,059
security descriptor

657
00:27:18,059 --> 00:27:21,059
right that's cool uh unfortunately this

658
00:27:21,059 --> 00:27:24,659
service runs way before us so basically

659
00:27:24,659 --> 00:27:27,539
we won't be and we'll be able to win

660
00:27:27,539 --> 00:27:31,140
this race condition uh as far as I know

661
00:27:31,140 --> 00:27:34,080
we need only to restart the the driver

662
00:27:34,080 --> 00:27:36,480
in order to uh restart the service in

663
00:27:36,480 --> 00:27:39,419
order to achieve to win this press

664
00:27:39,419 --> 00:27:41,340
condition

665
00:27:41,340 --> 00:27:43,380
um yeah so this is bad

666
00:27:43,380 --> 00:27:44,039
um

667
00:27:44,039 --> 00:27:46,740
but they still want to to find a way to

668
00:27:46,740 --> 00:27:50,100
to uh exploit this um this vulnerability

669
00:27:50,100 --> 00:27:51,419
right

670
00:27:51,419 --> 00:27:53,159
um so in order to restart the service

671
00:27:53,159 --> 00:27:56,460
you need to be a admin or in a privilege

672
00:27:56,460 --> 00:28:00,020
uh a privileged level uh or you can just

673
00:28:00,020 --> 00:28:02,700
trigger an update so basically when

674
00:28:02,700 --> 00:28:05,220
there are updates uh there are ways to

675
00:28:05,220 --> 00:28:08,100
sign ups a program commit an update

676
00:28:08,100 --> 00:28:11,039
everything shuts down so all the Razer

677
00:28:11,039 --> 00:28:13,140
sign ups services and all the other

678
00:28:13,140 --> 00:28:15,779
stuff that comes with it just closes the

679
00:28:15,779 --> 00:28:19,799
update is uh is triggering and then

680
00:28:19,799 --> 00:28:21,980
um then you can actually

681
00:28:21,980 --> 00:28:24,360
create a rate condition

682
00:28:24,360 --> 00:28:27,360
unfortunately updates happens

683
00:28:27,360 --> 00:28:31,260
once in a month twice like once in two

684
00:28:31,260 --> 00:28:33,179
months so this is not good for us we

685
00:28:33,179 --> 00:28:35,659
want to trigger it upon our Quest right

686
00:28:35,659 --> 00:28:38,880
so we found that we can abuse the plugin

687
00:28:38,880 --> 00:28:41,520
mechanism to trigger a update like

688
00:28:41,520 --> 00:28:44,520
scenario so yeah

689
00:28:44,520 --> 00:28:48,140
um basically Razer lets you to install

690
00:28:48,140 --> 00:28:51,779
some three plugins maybe more

691
00:28:51,779 --> 00:28:54,179
um and we uh whenever you install

692
00:28:54,179 --> 00:28:56,760
plugins so it will consider as an update

693
00:28:56,760 --> 00:28:59,340
everything will shut down and then we

694
00:28:59,340 --> 00:29:01,100
will we can freak out the race condition

695
00:29:01,100 --> 00:29:04,020
another fun fact about the source code

696
00:29:04,020 --> 00:29:07,620
there is a to-do which replace with call

697
00:29:07,620 --> 00:29:09,900
to iocreate if I secure and Driver

698
00:29:09,900 --> 00:29:13,220
they didn't do that until today so yeah

699
00:29:13,220 --> 00:29:16,260
uh all right so this is how the flow

700
00:29:16,260 --> 00:29:18,299
looks like so we will write our pocx

701
00:29:18,299 --> 00:29:20,520
there it will ask a Razer service to

702
00:29:20,520 --> 00:29:23,220
install the plugin a result GMS service

703
00:29:23,220 --> 00:29:25,380
will initiate an update like scenario

704
00:29:25,380 --> 00:29:27,539
which shut everything down when you're

705
00:29:27,539 --> 00:29:30,960
winning zero will be unloaded then it

706
00:29:30,960 --> 00:29:32,880
will be reloaded and it will create an

707
00:29:32,880 --> 00:29:34,320
object with a default security

708
00:29:34,320 --> 00:29:36,240
descriptor we have a less condition

709
00:29:36,240 --> 00:29:38,820
there and then the dll will change the

710
00:29:38,820 --> 00:29:42,360
device security descriptor right so

711
00:29:42,360 --> 00:29:45,320
let's see a demo

712
00:29:46,080 --> 00:29:50,480
cool so eweb there razor setups

713
00:29:52,440 --> 00:29:54,899
right so here we can see all the plugins

714
00:29:54,899 --> 00:29:56,700
you can install we will install the

715
00:29:56,700 --> 00:29:59,640
Alexa plugin for example

716
00:29:59,640 --> 00:30:02,460
uh yeah we run a slow privilege user

717
00:30:02,460 --> 00:30:04,559
without that many privileges

718
00:30:04,559 --> 00:30:06,140
unfortunately

719
00:30:06,140 --> 00:30:09,600
and we want we will run our exploit so

720
00:30:09,600 --> 00:30:11,220
now actually we download in the Alexa

721
00:30:11,220 --> 00:30:13,860
plugin after it finished downloading we

722
00:30:13,860 --> 00:30:17,460
will send a message to the GMS service

723
00:30:17,460 --> 00:30:19,740
to install the plugin here we can see

724
00:30:19,740 --> 00:30:21,600
that everything shuts down the service

725
00:30:21,600 --> 00:30:25,559
is unloaded and deleted

726
00:30:25,559 --> 00:30:28,140
um now it's reloaded and we will try to

727
00:30:28,140 --> 00:30:29,760
open handle to it we managed to open

728
00:30:29,760 --> 00:30:34,320
Endo we abused the MSR ia32 to run code

729
00:30:34,320 --> 00:30:37,440
and we managed to run to change our

730
00:30:37,440 --> 00:30:39,720
permission into system or application

731
00:30:39,720 --> 00:30:41,470
token

732
00:30:41,470 --> 00:30:47,580
[Applause]

733
00:30:47,580 --> 00:30:50,520
right so let's talk about aggregation

734
00:30:50,520 --> 00:30:52,799
um so basically we use verse total to

735
00:30:52,799 --> 00:30:55,080
find even more vulnerabilities most of

736
00:30:55,080 --> 00:30:56,820
the time you will use first Total to

737
00:30:56,820 --> 00:30:59,340
earn from others so we came up with an

738
00:30:59,340 --> 00:31:03,659
idea to uh to find similar vulnerable

739
00:31:03,659 --> 00:31:06,120
drivers because the one that MSI used is

740
00:31:06,120 --> 00:31:07,679
really similar to the one that Razer

741
00:31:07,679 --> 00:31:10,500
actually is using so we thought that

742
00:31:10,500 --> 00:31:13,140
there might be more so we wrote a simple

743
00:31:13,140 --> 00:31:16,320
Retron job query that includes some

744
00:31:16,320 --> 00:31:18,240
debug strings from the driver and we

745
00:31:18,240 --> 00:31:19,460
found

746
00:31:19,460 --> 00:31:25,380
114 drivers that exist outer uh by that

747
00:31:25,380 --> 00:31:27,960
too many vendors actually using those we

748
00:31:27,960 --> 00:31:30,539
are talking about ASRock MSI Razer Asus

749
00:31:30,539 --> 00:31:32,940
Patriot memory Galax gigabyte and much

750
00:31:32,940 --> 00:31:35,700
more yeah so this actually was really

751
00:31:35,700 --> 00:31:37,860
nice to find even more vulnerable

752
00:31:37,860 --> 00:31:40,980
drivers by just using versatile

753
00:31:40,980 --> 00:31:42,960
um yeah 12 is Handy to find

754
00:31:42,960 --> 00:31:46,200
vulnerabilities by your stuff all right

755
00:31:46,200 --> 00:31:49,440
so um let's talk about mitigations

756
00:31:49,440 --> 00:31:53,399
um so interestingly just by having ipv

757
00:31:53,399 --> 00:31:55,559
enabled on your system you can mitigate

758
00:31:55,559 --> 00:31:57,659
some of the risks we talked about so

759
00:31:57,659 --> 00:32:00,240
hypervisors by Design can intercept any

760
00:32:00,240 --> 00:32:02,340
modification action initiated by the OS

761
00:32:02,340 --> 00:32:05,279
journal and ipv by default prevents any

762
00:32:05,279 --> 00:32:08,039
modification to ih32 l-star because it

763
00:32:08,039 --> 00:32:09,480
doesn't make sense that you will want to

764
00:32:09,480 --> 00:32:11,360
change this one

765
00:32:11,360 --> 00:32:14,820
as long as you're a legitimate user if

766
00:32:14,820 --> 00:32:16,980
you're an attacker so yeah you might

767
00:32:16,980 --> 00:32:19,140
want to do that but I probably won't let

768
00:32:19,140 --> 00:32:22,140
you unfortunately I probably can do that

769
00:32:22,140 --> 00:32:26,039
much and won't protect you from a buffer

770
00:32:26,039 --> 00:32:28,740
overflows and stuff like this

771
00:32:28,740 --> 00:32:30,179
right

772
00:32:30,179 --> 00:32:30,899
um

773
00:32:30,899 --> 00:32:35,039
so is this problem is fixed uh sadly

774
00:32:35,039 --> 00:32:37,620
only partially the kernel driver still

775
00:32:37,620 --> 00:32:40,440
there and it's actually still been used

776
00:32:40,440 --> 00:32:43,380
by different vendors I don't know why

777
00:32:43,380 --> 00:32:45,779
but it still happens

778
00:32:45,779 --> 00:32:48,059
um as an end user I will recommend you

779
00:32:48,059 --> 00:32:50,520
to enable hyperv on the system and use

780
00:32:50,520 --> 00:32:52,559
antivirus that blocks malicious drivers

781
00:32:52,559 --> 00:32:54,419
so some of those drivers consider to be

782
00:32:54,419 --> 00:32:57,299
malicious nowadays as a developer please

783
00:32:57,299 --> 00:33:00,000
don't use the win IO code base and

784
00:33:00,000 --> 00:33:01,740
neither any of the different variation

785
00:33:01,740 --> 00:33:06,360
uh like winning zero antelib MSO 64 and

786
00:33:06,360 --> 00:33:09,659
Etc and if you do please fix the

787
00:33:09,659 --> 00:33:13,440
embedded security issues that there

788
00:33:13,440 --> 00:33:15,539
um yeah right

789
00:33:15,539 --> 00:33:16,140
um

790
00:33:16,140 --> 00:33:19,140
so we got TV is some CVS during the

791
00:33:19,140 --> 00:33:21,720
research we also wrote a blog post about

792
00:33:21,720 --> 00:33:24,360
that the QR code will be also in the

793
00:33:24,360 --> 00:33:27,120
next slide if you want to scan it uh so

794
00:33:27,120 --> 00:33:29,519
yeah thank you very much I'm Al safati I

795
00:33:29,519 --> 00:33:31,260
had great time presenting this talk to

796
00:33:31,260 --> 00:33:33,480
you and feel free to contact me via

797
00:33:33,480 --> 00:33:35,700
Twitter for any questions and I'm also

798
00:33:35,700 --> 00:33:37,799
around there

799
00:33:37,799 --> 00:33:40,340
thank you

800
00:33:47,940 --> 00:33:51,200
do you have any question

801
00:33:51,240 --> 00:33:53,779
yep

802
00:33:53,820 --> 00:33:57,059
might get to the microphone

803
00:33:57,059 --> 00:33:59,720
all right

804
00:34:00,180 --> 00:34:03,410
[Music]

805
00:34:05,600 --> 00:34:08,099
thanks for the great talk so you have

806
00:34:08,099 --> 00:34:11,820
said that uh the hypervisor intercepts

807
00:34:11,820 --> 00:34:14,520
the rights to the msrs but does it do it

808
00:34:14,520 --> 00:34:17,040
for all the emsers no actually so

809
00:34:17,040 --> 00:34:20,099
basically it can catch every uh MSR

810
00:34:20,099 --> 00:34:23,520
change but it treats different msrs like

811
00:34:23,520 --> 00:34:25,800
whenever it needs to block the change it

812
00:34:25,800 --> 00:34:28,020
will whenever it just need to pass it

813
00:34:28,020 --> 00:34:30,119
along so is there still potential that

814
00:34:30,119 --> 00:34:32,219
maybe some other msrs who's actually

815
00:34:32,219 --> 00:34:34,199
allow you to like exploit this further

816
00:34:34,199 --> 00:34:36,480
even on the hypervisors

817
00:34:36,480 --> 00:34:39,480
um maybe it depends on the MSR

818
00:34:39,480 --> 00:34:42,119
um I know you might do some research on

819
00:34:42,119 --> 00:34:45,119
that and find out yeah and I've got also

820
00:34:45,119 --> 00:34:47,339
a question about the uh because you're

821
00:34:47,339 --> 00:34:49,800
changing the l-star MSR so that if I

822
00:34:49,800 --> 00:34:51,000
understood correctly you can then

823
00:34:51,000 --> 00:34:53,399
specify like what will be the Cisco

824
00:34:53,399 --> 00:34:56,099
Handler right but how do you like place

825
00:34:56,099 --> 00:34:58,560
your executable code in the kernel or or

826
00:34:58,560 --> 00:35:00,540
is there like no smap or snap or things

827
00:35:00,540 --> 00:35:02,820
like that in on Windows right so this is

828
00:35:02,820 --> 00:35:04,320
actually a good question so you don't

829
00:35:04,320 --> 00:35:07,680
have so you don't have snap with a you

830
00:35:07,680 --> 00:35:10,560
do have snap with e so you cannot you

831
00:35:10,560 --> 00:35:12,660
cannot actually let the kernel just uh

832
00:35:12,660 --> 00:35:15,060
change in the user space code and it

833
00:35:15,060 --> 00:35:17,520
will just run it as in the internal

834
00:35:17,520 --> 00:35:20,760
context so basically what I did there I

835
00:35:20,760 --> 00:35:22,920
use a really cool open source project

836
00:35:22,920 --> 00:35:26,099
called MSR exec which let you just do

837
00:35:26,099 --> 00:35:29,460
that so basically uh you are creating a

838
00:35:29,460 --> 00:35:33,000
rope on the stack uh to uh disable the

839
00:35:33,000 --> 00:35:34,859
mitigate this map mitigation then you

840
00:35:34,859 --> 00:35:37,020
just jump to your uh use some of the

841
00:35:37,020 --> 00:35:39,599
function and everything okay very nice

842
00:35:39,599 --> 00:35:41,900
thank you

843
00:35:43,380 --> 00:35:46,339
okay so regarding the previous question

844
00:35:46,339 --> 00:35:49,500
uh here all right there's a really good

845
00:35:49,500 --> 00:35:52,320
good blog post about secure kernel page

846
00:35:52,320 --> 00:35:53,760
guard which runs with the hyper-v

847
00:35:53,760 --> 00:35:56,700
mitigation and it explains in detail how

848
00:35:56,700 --> 00:35:58,800
it works what are the extents

849
00:35:58,800 --> 00:36:01,740
ETC so it's it's it describes all the

850
00:36:01,740 --> 00:36:04,440
msrs which are handled which are not and

851
00:36:04,440 --> 00:36:06,660
stuff because there's much more it

852
00:36:06,660 --> 00:36:08,940
protects the core of the wheel nose

853
00:36:08,940 --> 00:36:11,880
kernel so you cannot hijack some of the

854
00:36:11,880 --> 00:36:14,220
pages and more like that you're talking

855
00:36:14,220 --> 00:36:17,339
about the one that Jordan wrote right

856
00:36:17,339 --> 00:36:19,940
probably yes

857
00:36:25,700 --> 00:36:28,920
hello thank you very nice talk I have a

858
00:36:28,920 --> 00:36:31,440
little question so you you say several

859
00:36:31,440 --> 00:36:33,720
times developers have a a lot to know

860
00:36:33,720 --> 00:36:37,380
about how is the documentation it's

861
00:36:37,380 --> 00:36:38,940
pretty good

862
00:36:38,940 --> 00:36:43,079
um well the major problem here was that

863
00:36:43,079 --> 00:36:45,900
these code base actually written in the

864
00:36:45,900 --> 00:36:49,500
early 2000 so and it's still being used

865
00:36:49,500 --> 00:36:53,220
today uh when and actually this was

866
00:36:53,220 --> 00:36:56,099
written as a proof of concept not a not

867
00:36:56,099 --> 00:36:58,740
a production driver for some reason it's

868
00:36:58,740 --> 00:37:00,720
still been used as a production driver

869
00:37:00,720 --> 00:37:02,640
you know why

870
00:37:02,640 --> 00:37:05,220
um yeah so uh it's created a lot of

871
00:37:05,220 --> 00:37:08,000
problems really

872
00:37:13,380 --> 00:37:15,119
any questions

873
00:37:15,119 --> 00:37:17,720
yeah

874
00:37:24,200 --> 00:37:26,400
that's rather a comment maybe maybe

875
00:37:26,400 --> 00:37:27,839
someone should create an AV product

876
00:37:27,839 --> 00:37:29,820
where they would try to disassemble the

877
00:37:29,820 --> 00:37:32,760
drivers uh like custom drivers and try

878
00:37:32,760 --> 00:37:35,460
to like find out those bugs and you know

879
00:37:35,460 --> 00:37:38,760
block them um yeah so um Microsoft tried

880
00:37:38,760 --> 00:37:40,680
to did some of this

881
00:37:40,680 --> 00:37:42,780
um and also some of the variation of

882
00:37:42,780 --> 00:37:44,700
this driver is actually in the block

883
00:37:44,700 --> 00:37:46,380
list of the driver that should not be

884
00:37:46,380 --> 00:37:50,700
loaded so Defender should block this one

885
00:37:50,700 --> 00:37:52,320
um but there are too many variations of

886
00:37:52,320 --> 00:37:54,780
this driver and they're always resign

887
00:37:54,780 --> 00:37:57,660
those so basically you cannot find all

888
00:37:57,660 --> 00:37:59,820
the different variation as long as

889
00:37:59,820 --> 00:38:02,099
you're not really putting a lot of

890
00:38:02,099 --> 00:38:04,380
effort into that and unfortunately

891
00:38:04,380 --> 00:38:08,359
nobody did it by today

892
00:38:09,660 --> 00:38:12,500
other questions

893
00:38:13,980 --> 00:38:16,800
right all right so thank you again thank

894
00:38:16,800 --> 00:38:18,820
you thank you guys

895
00:38:18,820 --> 00:38:22,929
[Applause]

