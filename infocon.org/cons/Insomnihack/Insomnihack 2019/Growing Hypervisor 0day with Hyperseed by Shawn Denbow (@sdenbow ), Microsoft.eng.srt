1
00:00:07,250 --> 00:00:10,619
[Music]

2
00:00:13,120 --> 00:00:17,240
so hi everyone before I get started just

3
00:00:16,219 --> 00:00:18,740
want to give a shout out to the

4
00:00:17,240 --> 00:00:20,930
organizers putting this event on

5
00:00:18,740 --> 00:00:24,020
auto-awesome talks coming off so really

6
00:00:20,930 --> 00:00:26,180
excited to be here and so yeah let's get

7
00:00:24,020 --> 00:00:28,099
started with some introductions so you

8
00:00:26,180 --> 00:00:29,899
may notice I did this work with my

9
00:00:28,099 --> 00:00:32,210
colleague Daniel King he unfortunately

10
00:00:29,899 --> 00:00:34,219
was not able to make it today

11
00:00:32,210 --> 00:00:36,050
he's currently supporting poundtown for

12
00:00:34,219 --> 00:00:38,239
Microsoft which unfortunately is

13
00:00:36,050 --> 00:00:39,800
conflicting with this conference but uh

14
00:00:38,239 --> 00:00:42,410
I just want to give a quick introduction

15
00:00:39,800 --> 00:00:44,480
for who he is so he's the one who pretty

16
00:00:42,410 --> 00:00:46,339
much started this project up he has a

17
00:00:44,480 --> 00:00:48,620
lot of security background he's

18
00:00:46,339 --> 00:00:51,289
currently in nsrc at Microsoft so they

19
00:00:48,620 --> 00:00:53,059
kind of handled the external cases that

20
00:00:51,289 --> 00:00:55,249
are coming in triaging that and also he

21
00:00:53,059 --> 00:00:57,199
gets to do a lot of cool research I was

22
00:00:55,249 --> 00:01:00,409
a prior member of the Keene security lab

23
00:00:57,199 --> 00:01:03,468
I participated in pwned 2-ohm back in

24
00:01:00,409 --> 00:01:05,960
2016 and he was a member of the master

25
00:01:03,469 --> 00:01:08,659
of pone also gave a lot of presentations

26
00:01:05,960 --> 00:01:11,119
on fuzzing and for me so my name is

27
00:01:08,659 --> 00:01:12,980
Shawn Denbo I've been in security for a

28
00:01:11,120 --> 00:01:15,050
little bit now got my start while in

29
00:01:12,980 --> 00:01:19,340
university playing mostly captured flags

30
00:01:15,050 --> 00:01:21,530
and war games college was expensive so I

31
00:01:19,340 --> 00:01:23,540
had a airforce scholarship so after I

32
00:01:21,530 --> 00:01:27,140
graduated did four years active duty in

33
00:01:23,540 --> 00:01:30,080
the Air Force about October 2017 I moved

34
00:01:27,140 --> 00:01:31,790
on to Microsoft and I was doing security

35
00:01:30,080 --> 00:01:33,679
for a while up until about a month ago I

36
00:01:31,790 --> 00:01:38,900
switched over to software development

37
00:01:33,680 --> 00:01:40,370
role also working on the kernel so a

38
00:01:38,900 --> 00:01:43,310
quick overview for what this

39
00:01:40,370 --> 00:01:45,440
presentation is gonna be about today so

40
00:01:43,310 --> 00:01:47,000
it's really structured in two parts the

41
00:01:45,440 --> 00:01:48,560
first half of this presentation we're

42
00:01:47,000 --> 00:01:50,630
just gonna lay out the groundwork and

43
00:01:48,560 --> 00:01:52,880
present the fundamentals we'll go over

44
00:01:50,630 --> 00:01:54,380
the hyper-v architecture really from a

45
00:01:52,880 --> 00:01:56,839
high level we're not gonna go to in

46
00:01:54,380 --> 00:01:58,580
depth will discuss hyper calls this is

47
00:01:56,840 --> 00:01:59,990
what we're gonna be attacking today and

48
00:01:58,580 --> 00:02:02,000
then in the second part we'll actually

49
00:01:59,990 --> 00:02:03,860
discuss the fuzzer that we developed and

50
00:02:02,000 --> 00:02:07,550
talk about some of the findings we got

51
00:02:03,860 --> 00:02:09,709
from this technique so the first

52
00:02:07,550 --> 00:02:12,530
question why hyper calls why was it that

53
00:02:09,709 --> 00:02:15,319
Daniel and I chose to attack these and

54
00:02:12,530 --> 00:02:17,329
it really boils down to the fact that we

55
00:02:15,319 --> 00:02:19,280
were both new to the hyper-v space and

56
00:02:17,329 --> 00:02:19,870
as we started to ramp up and learn a

57
00:02:19,280 --> 00:02:21,580
little bit

58
00:02:19,870 --> 00:02:23,860
or one of the things that stuck out to

59
00:02:21,580 --> 00:02:25,930
us was this interface that is exposed to

60
00:02:23,860 --> 00:02:29,739
a guest so think of it as the virtual

61
00:02:25,930 --> 00:02:31,840
machine and the interesting thing was is

62
00:02:29,739 --> 00:02:34,510
it's accessible from ring 0 so from

63
00:02:31,840 --> 00:02:36,280
kernel mode and it from our perspective

64
00:02:34,510 --> 00:02:38,048
this is a clear security boundary and an

65
00:02:36,280 --> 00:02:39,659
obvious attack surface so we wanted to

66
00:02:38,049 --> 00:02:41,769
keep taking a little deeper an

67
00:02:39,659 --> 00:02:43,239
additionally hyper calls they touch a

68
00:02:41,769 --> 00:02:45,519
number of facilities within the

69
00:02:43,239 --> 00:02:47,560
hypervisor so it was really a natural

70
00:02:45,519 --> 00:02:49,450
starting point for us to learn kind of

71
00:02:47,560 --> 00:02:52,359
more of the internals and understand

72
00:02:49,450 --> 00:02:54,839
what's going on and additionally the

73
00:02:52,359 --> 00:02:56,769
hyper-v dev team they produced this

74
00:02:54,840 --> 00:02:59,560
document known as the top-level

75
00:02:56,769 --> 00:03:01,989
functional spec or TL FS for short and

76
00:02:59,560 --> 00:03:03,489
this goes in great details on a number

77
00:03:01,989 --> 00:03:05,950
of those facilities as well as

78
00:03:03,489 --> 00:03:08,290
documenting the interface of what the

79
00:03:05,950 --> 00:03:09,909
hyper calls are and they also kind of

80
00:03:08,290 --> 00:03:11,760
document what the arguments are and

81
00:03:09,909 --> 00:03:14,769
we'll get more to that later

82
00:03:11,760 --> 00:03:16,569
it's also worth pointing out that Daniel

83
00:03:14,769 --> 00:03:18,069
and I we started this work separately so

84
00:03:16,569 --> 00:03:21,159
if you notice we both are on two

85
00:03:18,069 --> 00:03:23,140
different teams and when I got started I

86
00:03:21,159 --> 00:03:24,400
was just doing pure code review that's

87
00:03:23,140 --> 00:03:26,828
how I generally like to do my bug

88
00:03:24,400 --> 00:03:28,510
hunting and it was through a meet-up I

89
00:03:26,829 --> 00:03:31,239
usually bi-weekly get some drinks with

90
00:03:28,510 --> 00:03:32,739
the nsrc Redmond crew so I was talking

91
00:03:31,239 --> 00:03:36,400
about some of the work I was doing and

92
00:03:32,739 --> 00:03:37,900
shout out to Axel who told me about the

93
00:03:36,400 --> 00:03:39,639
work daniel was doing so daniel was

94
00:03:37,900 --> 00:03:42,730
already fuzzing and he also had some

95
00:03:39,639 --> 00:03:44,379
pretty early results so we kind of

96
00:03:42,730 --> 00:03:46,690
teamed up and we looked at different

97
00:03:44,379 --> 00:03:50,709
scenarios for how we can get this even

98
00:03:46,690 --> 00:03:52,959
further so the next thing why is it that

99
00:03:50,709 --> 00:03:55,930
we Microsoft are here presenting this

100
00:03:52,959 --> 00:03:58,359
work to you so in short we're very

101
00:03:55,930 --> 00:04:00,910
motivated to secure hyper-v it's a

102
00:03:58,359 --> 00:04:04,480
critical work and the work in order to

103
00:04:00,910 --> 00:04:06,129
do this it's non-trivial and the

104
00:04:04,480 --> 00:04:07,988
external research community you guys

105
00:04:06,129 --> 00:04:10,268
have a skill set necessary to do it and

106
00:04:07,989 --> 00:04:12,910
that's why nsrc offers up this bug

107
00:04:10,269 --> 00:04:14,139
bounty so they'll pay up to two hundred

108
00:04:12,910 --> 00:04:16,449
and fifty thousand dollars if you

109
00:04:14,139 --> 00:04:18,549
provide a working exploit but more

110
00:04:16,449 --> 00:04:21,430
interesting if you can provide just a

111
00:04:18,548 --> 00:04:23,109
provable bug that shows remote code

112
00:04:21,430 --> 00:04:25,110
execution you don't need to exploit it

113
00:04:23,110 --> 00:04:27,370
will pay up to two hundred thousand and

114
00:04:25,110 --> 00:04:28,900
additionally I believe it's important

115
00:04:27,370 --> 00:04:31,419
for us to be transparent about the work

116
00:04:28,900 --> 00:04:33,400
we're doing so if we expect external

117
00:04:31,419 --> 00:04:35,590
researchers to contribute

118
00:04:33,400 --> 00:04:37,659
to this I think it's worthwhile so we

119
00:04:35,590 --> 00:04:39,698
can explain what efforts we went through

120
00:04:37,660 --> 00:04:42,130
so you know how to differentiate and

121
00:04:39,699 --> 00:04:44,289
find additional bugs and identify gaps

122
00:04:42,130 --> 00:04:48,639
that we may have had and earn this bug

123
00:04:44,289 --> 00:04:50,949
bounty so as I mentioned in the overview

124
00:04:48,639 --> 00:04:53,020
this next section coming up it's not

125
00:04:50,949 --> 00:04:55,270
going to be a deep dive into the full

126
00:04:53,020 --> 00:04:57,039
architecture this has been presented in

127
00:04:55,270 --> 00:04:59,229
multiple past presentations and there's

128
00:04:57,039 --> 00:05:00,729
a lot of resources online I have an

129
00:04:59,229 --> 00:05:03,430
appendix at the end of this slide deck

130
00:05:00,729 --> 00:05:05,020
for people who are interested but really

131
00:05:03,430 --> 00:05:07,479
the purpose of this section is just to

132
00:05:05,020 --> 00:05:09,430
provide a summary for those that might

133
00:05:07,479 --> 00:05:13,650
not be familiar with this space and kind

134
00:05:09,430 --> 00:05:13,650
of ensure that our terminology is right

135
00:05:14,850 --> 00:05:20,020
so here we have a diagram of the

136
00:05:17,500 --> 00:05:21,850
high-level architecture of hyper-v and

137
00:05:20,020 --> 00:05:23,560
when you first look at the architecture

138
00:05:21,850 --> 00:05:26,260
one of the things you'll notice is that

139
00:05:23,560 --> 00:05:28,360
hyper-v hypervisor is a type 1 or native

140
00:05:26,260 --> 00:05:31,449
hypervisor this essentially means that

141
00:05:28,360 --> 00:05:33,880
it runs on bare metal the hypervisor is

142
00:05:31,449 --> 00:05:35,710
essentially a small microkernel and it

143
00:05:33,880 --> 00:05:37,750
provides a number of services to these

144
00:05:35,710 --> 00:05:39,489
things called partitions and these

145
00:05:37,750 --> 00:05:42,340
services include things like scheduling

146
00:05:39,490 --> 00:05:44,710
virtual processor memory management and

147
00:05:42,340 --> 00:05:46,479
interrupt delivery the hypervisor also

148
00:05:44,710 --> 00:05:47,680
handles hyper calls and that's pretty

149
00:05:46,479 --> 00:05:50,919
much what we're going to be talking

150
00:05:47,680 --> 00:05:52,720
about today and these hyper calls again

151
00:05:50,919 --> 00:05:55,719
they're just an interface that's exposed

152
00:05:52,720 --> 00:05:57,900
to the guest in order for a partition to

153
00:05:55,720 --> 00:06:00,190
communicate with the hypervisor so

154
00:05:57,900 --> 00:06:02,138
partitions they're the main isolation

155
00:06:00,190 --> 00:06:03,490
unit that basically composed of some

156
00:06:02,139 --> 00:06:05,919
physical memory you're going to have one

157
00:06:03,490 --> 00:06:07,900
or more virtual processors and the

158
00:06:05,919 --> 00:06:09,609
hypervisor is ultimately responsible for

159
00:06:07,900 --> 00:06:11,409
managing what's known as the nested page

160
00:06:09,610 --> 00:06:13,659
table or second level address

161
00:06:11,409 --> 00:06:16,389
translation and essentially what this

162
00:06:13,659 --> 00:06:18,760
does is it allows the hypervisor to

163
00:06:16,389 --> 00:06:21,699
enforce physical memory restrictions

164
00:06:18,760 --> 00:06:24,669
between these partitions so this way we

165
00:06:21,699 --> 00:06:27,460
can guarantee that one partition so if

166
00:06:24,669 --> 00:06:29,139
you have a VM in Azure they can't read

167
00:06:27,460 --> 00:06:32,888
whatever you're doing or manipulate or

168
00:06:29,139 --> 00:06:34,539
bring you down so in this architecture

169
00:06:32,889 --> 00:06:36,250
we have what's known as the root

170
00:06:34,539 --> 00:06:39,190
partition this is also commonly known as

171
00:06:36,250 --> 00:06:40,960
the parent partition and the root is the

172
00:06:39,190 --> 00:06:43,260
host operating system and right now we

173
00:06:40,960 --> 00:06:45,359
only currently support Windows

174
00:06:43,260 --> 00:06:47,789
and the root is the only partition that

175
00:06:45,360 --> 00:06:49,620
has direct access to physical memory and

176
00:06:47,790 --> 00:06:51,780
devices and it's therefore ultimately

177
00:06:49,620 --> 00:06:54,630
responsible for managing the virtual

178
00:06:51,780 --> 00:06:56,400
machines so it contains if you zoom in

179
00:06:54,630 --> 00:06:57,420
on the root partition it kind of

180
00:06:56,400 --> 00:06:59,820
contains what's known as the

181
00:06:57,420 --> 00:07:01,320
virtualization stack and virtualization

182
00:06:59,820 --> 00:07:03,000
stack has a number of different

183
00:07:01,320 --> 00:07:06,060
components so if you look at the very

184
00:07:03,000 --> 00:07:08,700
top left you have the VM WP which is the

185
00:07:06,060 --> 00:07:10,850
virtual machine worker process and the

186
00:07:08,700 --> 00:07:12,960
virtual machine worker process is the

187
00:07:10,850 --> 00:07:14,940
executable that's in charge of

188
00:07:12,960 --> 00:07:16,890
orchestrating the life of these VMs and

189
00:07:14,940 --> 00:07:18,690
as you see it kind of communicates down

190
00:07:16,890 --> 00:07:20,640
in this stack so it talks with the vid

191
00:07:18,690 --> 00:07:22,950
the vid is an important drivers that's

192
00:07:20,640 --> 00:07:24,270
the virtualization infrastructure driver

193
00:07:22,950 --> 00:07:26,700
and this is what manages certain

194
00:07:24,270 --> 00:07:28,890
partitions and other services provided

195
00:07:26,700 --> 00:07:32,789
and it essentially wraps the hyper calls

196
00:07:28,890 --> 00:07:35,340
in order to make all this happen so if

197
00:07:32,790 --> 00:07:36,630
we look we have two types of child

198
00:07:35,340 --> 00:07:38,609
partitions you have an enlightened

199
00:07:36,630 --> 00:07:40,409
partition and an unenlightened partition

200
00:07:38,610 --> 00:07:41,910
an enlightened partition essentially

201
00:07:40,410 --> 00:07:44,010
means it's aware that it's running on

202
00:07:41,910 --> 00:07:47,610
top of on type of on top of hyper-v

203
00:07:44,010 --> 00:07:51,810
sorry these are known as virtualization

204
00:07:47,610 --> 00:07:53,370
service consumers and these vsts they

205
00:07:51,810 --> 00:07:57,690
kind of communicate with something known

206
00:07:53,370 --> 00:08:00,030
as vm bus so vm bus is in short virtual

207
00:07:57,690 --> 00:08:02,400
bus that essentially allows hyper-v to

208
00:08:00,030 --> 00:08:04,289
offer up para virtualization it can

209
00:08:02,400 --> 00:08:06,479
create a channel between the host and

210
00:08:04,290 --> 00:08:09,180
these guest partitions and allow them to

211
00:08:06,480 --> 00:08:12,420
share data and also set up synthetic

212
00:08:09,180 --> 00:08:14,010
devices an unenlightened partition it's

213
00:08:12,420 --> 00:08:15,750
pretty much that it has no awareness

214
00:08:14,010 --> 00:08:18,120
that it's running on type of hyper-v so

215
00:08:15,750 --> 00:08:19,920
it's a lot slower because now anytime we

216
00:08:18,120 --> 00:08:24,210
perform some type of hardware access

217
00:08:19,920 --> 00:08:25,830
we're gonna have to emulate it so next I

218
00:08:24,210 --> 00:08:27,539
want to talk about a concept of nested

219
00:08:25,830 --> 00:08:30,000
virtualization not going to go too much

220
00:08:27,540 --> 00:08:32,820
into detail here the main importance is

221
00:08:30,000 --> 00:08:35,520
to understand this terminology so nested

222
00:08:32,820 --> 00:08:37,590
virtualization in short is essentially

223
00:08:35,520 --> 00:08:40,380
the hypervisor will now expose

224
00:08:37,590 --> 00:08:42,750
virtualization extensions which is

225
00:08:40,380 --> 00:08:44,580
implementing the hardware to these guest

226
00:08:42,750 --> 00:08:46,950
partitions and these guest partitions

227
00:08:44,580 --> 00:08:48,960
can now run their own hyper-v so from

228
00:08:46,950 --> 00:08:50,880
our perspective for fuzzing this is

229
00:08:48,960 --> 00:08:52,310
fantastic because now I can run multiple

230
00:08:50,880 --> 00:08:55,029
versions of

231
00:08:52,310 --> 00:08:57,560
multiple hypervisors on a single machine

232
00:08:55,029 --> 00:08:58,819
so looking at this terminology we have

233
00:08:57,560 --> 00:09:01,219
level zero so that's going to be your

234
00:08:58,819 --> 00:09:03,589
bare-metal hypervisor and this is going

235
00:09:01,220 --> 00:09:05,149
to manage your level one which you have

236
00:09:03,589 --> 00:09:07,069
your root OS so that's going to contain

237
00:09:05,149 --> 00:09:09,860
the virtualization stack which manages

238
00:09:07,069 --> 00:09:12,110
its child partitions and the child

239
00:09:09,860 --> 00:09:14,089
partitions can also now run their own

240
00:09:12,110 --> 00:09:17,329
hypervisor and this is going to be known

241
00:09:14,089 --> 00:09:18,860
as your l1 hypervisor and again it just

242
00:09:17,329 --> 00:09:20,930
goes up one more level so you again you

243
00:09:18,860 --> 00:09:23,449
have a root partition which is now level

244
00:09:20,930 --> 00:09:27,189
2 it has its own virtualization stack

245
00:09:23,449 --> 00:09:27,189
and it manages level 2 VMs

246
00:09:27,790 --> 00:09:32,599
so next I want to introduce a more

247
00:09:30,350 --> 00:09:34,579
recent technology virtualization based

248
00:09:32,600 --> 00:09:36,529
security so this is pretty cool it was

249
00:09:34,579 --> 00:09:39,349
introduced in Windows 10 really in order

250
00:09:36,529 --> 00:09:41,569
to help combat kernel-mode malware kind

251
00:09:39,350 --> 00:09:42,980
of came to the realization that you're

252
00:09:41,569 --> 00:09:45,290
always going to get owned so we started

253
00:09:42,980 --> 00:09:46,939
looking for different solutions and so

254
00:09:45,290 --> 00:09:49,639
with VBS it takes advantage of

255
00:09:46,939 --> 00:09:52,069
virtualization technology to essentially

256
00:09:49,639 --> 00:09:53,839
create a new security boundary and we're

257
00:09:52,069 --> 00:09:57,139
gonna refer to this as virtual secure

258
00:09:53,839 --> 00:10:00,290
mode so a hypervisor introduces this

259
00:09:57,139 --> 00:10:03,230
notion of virtual trust levels and the

260
00:10:00,290 --> 00:10:05,569
main idea here is that a higher number a

261
00:10:03,230 --> 00:10:07,610
higher number of trust level is going to

262
00:10:05,569 --> 00:10:10,099
have more privileges than a lower level

263
00:10:07,610 --> 00:10:12,259
and the virtual trust levels are

264
00:10:10,100 --> 00:10:14,959
represented as an attribute associated

265
00:10:12,259 --> 00:10:17,809
with each virtual processor so within

266
00:10:14,959 --> 00:10:20,628
VSM each virtual processor is going to

267
00:10:17,809 --> 00:10:22,189
maintain a running trust level and this

268
00:10:20,629 --> 00:10:24,980
particular trust level is going to be

269
00:10:22,189 --> 00:10:27,290
referred to as your active VTL and when

270
00:10:24,980 --> 00:10:29,449
running the VP can only access memory

271
00:10:27,290 --> 00:10:32,120
that is configured for that trust level

272
00:10:29,449 --> 00:10:35,000
and these trust levels the way they get

273
00:10:32,120 --> 00:10:37,009
these memory restrictions I hinted to it

274
00:10:35,000 --> 00:10:39,230
earlier they used nested page tables or

275
00:10:37,009 --> 00:10:40,850
that second level address translation so

276
00:10:39,230 --> 00:10:43,639
they can essentially program this to

277
00:10:40,850 --> 00:10:45,709
wall off portions of memory you also

278
00:10:43,639 --> 00:10:47,509
have the concept of the iommu which

279
00:10:45,709 --> 00:10:50,359
stands for the i/o memory management

280
00:10:47,509 --> 00:10:52,519
unit so this provides services like DMA

281
00:10:50,360 --> 00:10:54,829
remapping and interrupt remapping so if

282
00:10:52,519 --> 00:10:56,959
you have a malicious device I can't

283
00:10:54,829 --> 00:10:58,819
perform DMA on a higher level trust

284
00:10:56,959 --> 00:11:00,560
level or another partition that it's not

285
00:10:58,819 --> 00:11:03,229
assigned to

286
00:11:00,560 --> 00:11:05,149
so in VSM today we currently only

287
00:11:03,230 --> 00:11:08,420
support two trust levels so you have VTL

288
00:11:05,149 --> 00:11:10,040
0 and VT l 1 VT l 0 is what's called

289
00:11:08,420 --> 00:11:11,839
normal mode and this is what contains

290
00:11:10,040 --> 00:11:15,230
the normal NT kernel and this is what

291
00:11:11,839 --> 00:11:17,209
the user interacts with VP L 1 is the

292
00:11:15,230 --> 00:11:19,490
secure mode and so you see we have this

293
00:11:17,209 --> 00:11:22,219
concept of a secure kernel and really

294
00:11:19,490 --> 00:11:25,069
this is a very it provides very minimal

295
00:11:22,220 --> 00:11:27,430
functionality to these isolated

296
00:11:25,069 --> 00:11:30,079
processes which are really just programs

297
00:11:27,430 --> 00:11:34,430
with law it also contains some secrets

298
00:11:30,079 --> 00:11:36,859
and what's interesting is from a

299
00:11:34,430 --> 00:11:38,689
security perspective this new security

300
00:11:36,860 --> 00:11:40,879
boundary that they set up we want to

301
00:11:38,689 --> 00:11:42,529
find a way to break this and one way to

302
00:11:40,879 --> 00:11:44,059
do it is with these services that the

303
00:11:42,529 --> 00:11:47,509
secure kernel provides so provides

304
00:11:44,059 --> 00:11:48,949
something known as secure calls and as

305
00:11:47,509 --> 00:11:50,629
we get into this presentation we're

306
00:11:48,949 --> 00:11:53,059
going to realize is there just a hyper

307
00:11:50,629 --> 00:11:54,499
call and they have a different same

308
00:11:53,059 --> 00:11:57,699
calling convention but take a different

309
00:11:54,499 --> 00:11:59,990
format so we'll talk about that and that

310
00:11:57,699 --> 00:12:01,998
alright so next I want to dive into

311
00:11:59,990 --> 00:12:03,499
understanding hyper call so here we're

312
00:12:01,999 --> 00:12:05,180
gonna look at the basics we're gonna

313
00:12:03,499 --> 00:12:07,879
look at how we can set up an interface

314
00:12:05,180 --> 00:12:09,170
and actually invoke them and also I'm

315
00:12:07,879 --> 00:12:11,120
gonna talk a little bit about some

316
00:12:09,170 --> 00:12:15,319
restrictions that certain hyper call

317
00:12:11,120 --> 00:12:17,389
handlers might enforce so some basics so

318
00:12:15,319 --> 00:12:19,819
as I mentioned earlier hyper calls are

319
00:12:17,389 --> 00:12:22,339
really just that main interface that's

320
00:12:19,819 --> 00:12:24,019
exposed to a partition in order for it

321
00:12:22,339 --> 00:12:26,059
to communicate with the hypervisor and

322
00:12:24,019 --> 00:12:28,009
there are currently three calling

323
00:12:26,059 --> 00:12:30,469
conventions that are supported so the

324
00:12:28,009 --> 00:12:32,559
first callin convention is the slow or

325
00:12:30,470 --> 00:12:35,750
sometimes referred to as regular and

326
00:12:32,559 --> 00:12:36,949
with this basically your input and

327
00:12:35,750 --> 00:12:39,709
output buffers they're going to be

328
00:12:36,949 --> 00:12:42,920
passed in and out of the hypervisor via

329
00:12:39,709 --> 00:12:45,050
to guest physical pages and additionally

330
00:12:42,920 --> 00:12:46,939
these input and output buffers they need

331
00:12:45,050 --> 00:12:48,920
to be constrained to a page size and

332
00:12:46,939 --> 00:12:52,099
therefore must be aligned to a natural

333
00:12:48,920 --> 00:12:55,009
boundary the second call intervention

334
00:12:52,100 --> 00:12:57,199
supported is fast so here the input and

335
00:12:55,009 --> 00:12:58,490
output is sorry here the input

336
00:12:57,199 --> 00:12:59,990
parameters are going to be passed in

337
00:12:58,490 --> 00:13:02,870
using general-purpose registers

338
00:12:59,990 --> 00:13:04,910
and currently with this calling

339
00:13:02,870 --> 00:13:07,129
convention it only supports passing in

340
00:13:04,910 --> 00:13:09,050
up to two or fewer parameters and

341
00:13:07,129 --> 00:13:11,090
there's no output so if you have a hyper

342
00:13:09,050 --> 00:13:13,400
call that has some type of output

343
00:13:11,090 --> 00:13:15,320
you can't use this calling convention so

344
00:13:13,400 --> 00:13:16,819
this calling convention is much faster

345
00:13:15,320 --> 00:13:18,350
which is why it has its name because

346
00:13:16,820 --> 00:13:21,080
there's no memory allocations or

347
00:13:18,350 --> 00:13:23,510
mappings involved the third one is very

348
00:13:21,080 --> 00:13:25,430
similar to fast it's called xmm fast and

349
00:13:23,510 --> 00:13:27,530
essentially if your processor supports

350
00:13:25,430 --> 00:13:29,750
the X and that registers you can use up

351
00:13:27,530 --> 00:13:32,449
to six of the volatile ones to provide

352
00:13:29,750 --> 00:13:36,080
112 bytes of input and additionally you

353
00:13:32,450 --> 00:13:38,390
can utilize these for output as well so

354
00:13:36,080 --> 00:13:39,650
next we have the hyper call classes and

355
00:13:38,390 --> 00:13:42,530
we have two of them so you have your

356
00:13:39,650 --> 00:13:45,560
simple and repeat so a simple hyper call

357
00:13:42,530 --> 00:13:47,870
simply performs a single operation the

358
00:13:45,560 --> 00:13:49,760
hypervisor tries it's best to ensure

359
00:13:47,870 --> 00:13:53,360
that it will complete a hyper call

360
00:13:49,760 --> 00:13:55,580
within 50 microseconds so for some that

361
00:13:53,360 --> 00:13:57,650
perform more complex operations they

362
00:13:55,580 --> 00:14:00,710
bring in this notion of repeat or

363
00:13:57,650 --> 00:14:02,720
continuation so basically it makes it so

364
00:14:00,710 --> 00:14:04,250
the caller can invoke a hyper call say

365
00:14:02,720 --> 00:14:06,560
you wanted to map a bunch of pages in

366
00:14:04,250 --> 00:14:07,880
and it only processed half of them so

367
00:14:06,560 --> 00:14:09,319
it's going to report back that it only

368
00:14:07,880 --> 00:14:11,780
processed half of them and it's up to

369
00:14:09,320 --> 00:14:14,360
the caller to continue the process and

370
00:14:11,780 --> 00:14:18,439
give it a new index to start mapping the

371
00:14:14,360 --> 00:14:19,940
rest of the pages another kotappa going

372
00:14:18,440 --> 00:14:20,450
to talk about is variable size hyper

373
00:14:19,940 --> 00:14:22,580
calls

374
00:14:20,450 --> 00:14:25,280
so most hyper calls have a fixed size

375
00:14:22,580 --> 00:14:28,100
input but there are a few that required

376
00:14:25,280 --> 00:14:31,100
dynamic data and these variable size the

377
00:14:28,100 --> 00:14:32,840
hyper calls on they come in both simple

378
00:14:31,100 --> 00:14:34,790
and repeat so both the simple hyper

379
00:14:32,840 --> 00:14:37,370
calls and repeat can support variable

380
00:14:34,790 --> 00:14:39,260
size data and the size is going to be

381
00:14:37,370 --> 00:14:40,700
specified within your hyper call input

382
00:14:39,260 --> 00:14:43,910
so I kind of have what the hyper call

383
00:14:40,700 --> 00:14:46,280
input value is listed up there and you

384
00:14:43,910 --> 00:14:51,319
see the variable header size it must be

385
00:14:46,280 --> 00:14:52,730
specified as a multiple of eight finally

386
00:14:51,320 --> 00:14:54,830
I want to talk about the extended hyper

387
00:14:52,730 --> 00:14:57,770
call interface so from a guest

388
00:14:54,830 --> 00:14:59,570
perspective this uses the same calling

389
00:14:57,770 --> 00:15:01,640
convention but an extended hyper call is

390
00:14:59,570 --> 00:15:04,160
going to be handled differently within

391
00:15:01,640 --> 00:15:05,270
the hypervisor it's essentially these

392
00:15:04,160 --> 00:15:07,400
are implemented within that

393
00:15:05,270 --> 00:15:09,920
virtualization infrastructure driver the

394
00:15:07,400 --> 00:15:12,949
vid and the route partition so whenever

395
00:15:09,920 --> 00:15:14,810
you invoke a extended hyper call from a

396
00:15:12,950 --> 00:15:16,430
guest partition it's going to afford

397
00:15:14,810 --> 00:15:17,369
this off to the route and allow handling

398
00:15:16,430 --> 00:15:18,930
there

399
00:15:17,370 --> 00:15:20,850
last time I looked there's about six of

400
00:15:18,930 --> 00:15:22,290
them so there's not too many and they

401
00:15:20,850 --> 00:15:24,060
weren't complex so we just did code

402
00:15:22,290 --> 00:15:28,829
review so I did incorporate this in any

403
00:15:24,060 --> 00:15:30,329
fuzzing all right so next we want to

404
00:15:28,830 --> 00:15:31,980
talk about how do we actually invoke a

405
00:15:30,330 --> 00:15:34,260
hyper call and what that environment

406
00:15:31,980 --> 00:15:35,880
looks like so you can only invoke a

407
00:15:34,260 --> 00:15:37,890
hyper call from the most privileged

408
00:15:35,880 --> 00:15:40,170
guest processor mode so in the case of

409
00:15:37,890 --> 00:15:41,670
x64 this is going to mean protected mode

410
00:15:40,170 --> 00:15:44,279
with a current privilege level of zero

411
00:15:41,670 --> 00:15:45,510
and any attempt to basically invoke it

412
00:15:44,279 --> 00:15:47,100
when you're not in this mode is going to

413
00:15:45,510 --> 00:15:50,400
generate an undefined operation

414
00:15:47,100 --> 00:15:53,100
exception and since hyper-v does support

415
00:15:50,400 --> 00:15:54,480
multiple architectures all hyper calls

416
00:15:53,100 --> 00:15:57,779
must be invoked through their

417
00:15:54,480 --> 00:16:00,120
architectural e defined interface and to

418
00:15:57,779 --> 00:16:03,570
abstract this difference away the

419
00:16:00,120 --> 00:16:05,070
hypervisor provides a synthetic MSR for

420
00:16:03,570 --> 00:16:07,650
setting up what's known as a hyper call

421
00:16:05,070 --> 00:16:10,650
code page and in short we can program

422
00:16:07,650 --> 00:16:13,170
this synthetic MSR and the hypervisor is

423
00:16:10,650 --> 00:16:14,490
going to fill in this code page with the

424
00:16:13,170 --> 00:16:18,930
architectural a defined that way you

425
00:16:14,490 --> 00:16:21,120
don't have to worry about the details so

426
00:16:18,930 --> 00:16:23,790
in order to set this up you've got to go

427
00:16:21,120 --> 00:16:25,680
through a couple steps and the code

428
00:16:23,790 --> 00:16:27,599
snippet that I have here is coming from

429
00:16:25,680 --> 00:16:30,420
the Linux integration services for

430
00:16:27,600 --> 00:16:33,089
hyper-v and it's really one of the best

431
00:16:30,420 --> 00:16:35,550
open-source resources out there for

432
00:16:33,089 --> 00:16:37,260
seeing how to interface with hyper-v so

433
00:16:35,550 --> 00:16:40,109
not only does it contain this hyper call

434
00:16:37,260 --> 00:16:42,990
code but it also contains those virtual

435
00:16:40,110 --> 00:16:44,910
those v SCS the components within a

436
00:16:42,990 --> 00:16:46,920
guest partition in order to communicate

437
00:16:44,910 --> 00:16:48,300
with synthetic devices so if you're

438
00:16:46,920 --> 00:16:49,800
interested in more attack surface

439
00:16:48,300 --> 00:16:53,640
there's been a couple of talks on that I

440
00:16:49,800 --> 00:16:55,680
suggest looking at that so I want to

441
00:16:53,640 --> 00:16:57,209
give a quick shout out to Alex ionesco

442
00:16:55,680 --> 00:17:01,170
who recently started blogging about

443
00:16:57,209 --> 00:17:02,819
creating a hyper-v bridge and he did a

444
00:17:01,170 --> 00:17:04,709
great job here because he basically

445
00:17:02,820 --> 00:17:06,089
covers the same details here and he kind

446
00:17:04,709 --> 00:17:08,189
of took a different approach instead of

447
00:17:06,089 --> 00:17:10,470
doing this whole interfacing himself he

448
00:17:08,189 --> 00:17:12,209
just used an exported routine that we at

449
00:17:10,470 --> 00:17:14,250
Microsoft already implemented so you

450
00:17:12,209 --> 00:17:15,540
didn't have to do with these details but

451
00:17:14,250 --> 00:17:17,369
if you are curious and you wanted to

452
00:17:15,540 --> 00:17:18,720
create your own dryer driver you have to

453
00:17:17,369 --> 00:17:20,428
set up this interface and there's a

454
00:17:18,720 --> 00:17:22,110
couple of steps so after you already

455
00:17:20,429 --> 00:17:24,510
ensure that you're running on top of a

456
00:17:22,109 --> 00:17:27,089
hypervisor and that these synthetic MSRs

457
00:17:24,510 --> 00:17:29,280
are implemented you have to set up this

458
00:17:27,089 --> 00:17:30,270
call page and to do so you first have to

459
00:17:29,280 --> 00:17:32,700
write a guest ID

460
00:17:30,270 --> 00:17:35,220
and register with the hypervisor and the

461
00:17:32,700 --> 00:17:37,740
guest idea is simply a 64-bit entity and

462
00:17:35,220 --> 00:17:41,940
this is going to be specified in the TL

463
00:17:37,740 --> 00:17:43,860
FS the format of it next you simply

464
00:17:41,940 --> 00:17:45,690
allocate a page of memory again the

465
00:17:43,860 --> 00:17:48,120
hyper call code page requires one page

466
00:17:45,690 --> 00:17:50,190
and then you're gonna program the MS are

467
00:17:48,120 --> 00:17:52,439
you have an enable bit and the enable

468
00:17:50,190 --> 00:17:54,300
bit basically says you should check this

469
00:17:52,440 --> 00:17:56,070
first to see if someone else already

470
00:17:54,300 --> 00:17:57,930
programmed it if they did then a hyper

471
00:17:56,070 --> 00:17:59,790
call code page is already exists so

472
00:17:57,930 --> 00:18:03,360
we're just gonna use that otherwise it's

473
00:17:59,790 --> 00:18:04,830
not set so let's set this up now all

474
00:18:03,360 --> 00:18:05,820
right so let's look at an example of

475
00:18:04,830 --> 00:18:07,860
what this looks like

476
00:18:05,820 --> 00:18:10,409
so the hyper call code page is pretty

477
00:18:07,860 --> 00:18:12,780
simple and so by calling into it not

478
00:18:10,410 --> 00:18:14,820
only can you invoke hyper calls but you

479
00:18:12,780 --> 00:18:17,060
can also invoke the secured calls and

480
00:18:14,820 --> 00:18:21,090
normal calls to communicate with those

481
00:18:17,060 --> 00:18:23,970
different virtual trust levels so in

482
00:18:21,090 --> 00:18:26,459
fact to make a secure call it's

483
00:18:23,970 --> 00:18:29,010
basically making a hyper call but their

484
00:18:26,460 --> 00:18:32,820
programming in what the call code is so

485
00:18:29,010 --> 00:18:35,610
here to do a VTL call hex 11 it's kind

486
00:18:32,820 --> 00:18:38,700
of the ID to specify for this interface

487
00:18:35,610 --> 00:18:40,290
and same for reversing it and the reason

488
00:18:38,700 --> 00:18:42,300
they include this here is because in a

489
00:18:40,290 --> 00:18:45,600
later version of hyper-v it's possible

490
00:18:42,300 --> 00:18:46,409
that this call code can change so you

491
00:18:45,600 --> 00:18:47,939
don't have to worry about that

492
00:18:46,410 --> 00:18:51,990
difference they'll program it and once

493
00:18:47,940 --> 00:18:54,630
you setup that and thus are so the flow

494
00:18:51,990 --> 00:18:56,430
for switching ptl's is as such the

495
00:18:54,630 --> 00:18:58,380
normal kernel is gonna request on

496
00:18:56,430 --> 00:19:01,080
specific services from the secure kernel

497
00:18:58,380 --> 00:19:03,720
and it's gonna issue this secure call

498
00:19:01,080 --> 00:19:06,540
and vice versa and if you recall each

499
00:19:03,720 --> 00:19:09,330
virtual processor has an Associated

500
00:19:06,540 --> 00:19:11,190
attribute to indicate its trust level so

501
00:19:09,330 --> 00:19:14,179
when you invoke this hyper call all

502
00:19:11,190 --> 00:19:16,650
what's really doing is switching the

503
00:19:14,180 --> 00:19:19,770
trust level on your virtual processor

504
00:19:16,650 --> 00:19:22,760
and so the routines that I have here

505
00:19:19,770 --> 00:19:26,070
these are really for you to look into

506
00:19:22,760 --> 00:19:28,830
the these are exported for you to

507
00:19:26,070 --> 00:19:31,830
reverse-engineer so the main routine

508
00:19:28,830 --> 00:19:34,770
that this VP enter isolated user mems

509
00:19:31,830 --> 00:19:37,409
secure mode mouthful is the main routine

510
00:19:34,770 --> 00:19:38,430
that executes a communication loop so if

511
00:19:37,410 --> 00:19:40,350
you wanted to see how we go about

512
00:19:38,430 --> 00:19:42,169
invoking these secure calls us where I

513
00:19:40,350 --> 00:19:44,119
would go to the reverse engineer

514
00:19:42,169 --> 00:19:46,309
so it sets up what's known as a secure

515
00:19:44,119 --> 00:19:50,809
call buffer which is the format for

516
00:19:46,309 --> 00:19:53,090
specifying what we want to do so this

517
00:19:50,809 --> 00:19:55,789
secure call buffer it's a pretty simple

518
00:19:53,090 --> 00:19:57,199
format you specify what code you want to

519
00:19:55,789 --> 00:19:58,580
do so this is going to indicate the

520
00:19:57,200 --> 00:20:00,590
certain operation you want to perform

521
00:19:58,580 --> 00:20:02,749
and then you're gonna have various

522
00:20:00,590 --> 00:20:04,129
parameters that map to that and this is

523
00:20:02,749 --> 00:20:08,450
what we're gonna be mutating and this is

524
00:20:04,129 --> 00:20:09,980
what we're gonna be fuzzing all right so

525
00:20:08,450 --> 00:20:11,570
next I want to look into a couple

526
00:20:09,980 --> 00:20:13,940
restrictions that you might encounter

527
00:20:11,570 --> 00:20:15,769
and certain hyper call handlers so

528
00:20:13,940 --> 00:20:17,330
understanding these restrictions is

529
00:20:15,769 --> 00:20:18,379
going to be helpful for creating a more

530
00:20:17,330 --> 00:20:20,629
efficient fuzzer

531
00:20:18,379 --> 00:20:22,759
because some of these restrictions are

532
00:20:20,629 --> 00:20:24,769
going to block you so understanding how

533
00:20:22,759 --> 00:20:26,720
to either get by them or which ones you

534
00:20:24,769 --> 00:20:28,159
just can't invoke from a child partition

535
00:20:26,720 --> 00:20:31,340
is going to save you a lot of compute

536
00:20:28,159 --> 00:20:33,379
power and so these checks they'll

537
00:20:31,340 --> 00:20:35,269
normally show up they're implemented at

538
00:20:33,379 --> 00:20:38,090
the top of the or at the beginning of a

539
00:20:35,269 --> 00:20:40,549
hyper call Handler and I'm gonna go and

540
00:20:38,090 --> 00:20:42,230
show a couple code snippets and I

541
00:20:40,549 --> 00:20:43,789
understand that hyper-v is not open

542
00:20:42,230 --> 00:20:46,039
source so these code snippets probably

543
00:20:43,789 --> 00:20:49,429
won't mean much to you but a couple

544
00:20:46,039 --> 00:20:51,320
months ago sar from nsrc israel he

545
00:20:49,429 --> 00:20:53,419
published a blog post kind of detailing

546
00:20:51,320 --> 00:20:56,590
how to get into researching hyper-v and

547
00:20:53,419 --> 00:20:58,999
he did it from a kind of external

548
00:20:56,590 --> 00:21:01,699
perspective so he showed how to throw it

549
00:20:58,999 --> 00:21:04,070
in Ida start identifying where the hyper

550
00:21:01,700 --> 00:21:05,570
call handlers are so I'm hoping pairing

551
00:21:04,070 --> 00:21:06,889
with that information and these code

552
00:21:05,570 --> 00:21:09,019
snippets you'll be able to recognize

553
00:21:06,889 --> 00:21:12,559
these patterns and be able to speed up

554
00:21:09,019 --> 00:21:16,190
your process so the first restriction

555
00:21:12,559 --> 00:21:19,908
talked about deals with privileges and

556
00:21:16,190 --> 00:21:21,379
particularly with partitions and before

557
00:21:19,909 --> 00:21:22,460
I show the code snippet I think it's

558
00:21:21,379 --> 00:21:25,369
important to understand a little bit

559
00:21:22,460 --> 00:21:28,549
more about their properties so

560
00:21:25,369 --> 00:21:30,019
partitions if you remember you have your

561
00:21:28,549 --> 00:21:31,850
route partition you have a bunch of

562
00:21:30,019 --> 00:21:34,009
child and you represent these by a

563
00:21:31,850 --> 00:21:38,330
unique ID so this is going to be some

564
00:21:34,009 --> 00:21:39,679
type of 64-bit value and one interesting

565
00:21:38,330 --> 00:21:42,408
thing is these are going to be unique

566
00:21:39,679 --> 00:21:44,840
across a hyper-v instance but if you do

567
00:21:42,409 --> 00:21:46,100
reboot you can reuse these IDs but

568
00:21:44,840 --> 00:21:49,580
they're all going to be unique on a

569
00:21:46,100 --> 00:21:50,959
single running instance and why it's

570
00:21:49,580 --> 00:21:53,370
important to know this as many of the

571
00:21:50,960 --> 00:21:55,830
hyper calls they perform action

572
00:21:53,370 --> 00:21:57,179
against a particular partition so this

573
00:21:55,830 --> 00:21:59,490
is one of the main arguments that you're

574
00:21:57,180 --> 00:22:02,010
going to be passing in so in order to

575
00:21:59,490 --> 00:22:03,360
know kind of how to exercise code

576
00:22:02,010 --> 00:22:05,400
properly you need to know how to

577
00:22:03,360 --> 00:22:07,169
reference it so whether you're

578
00:22:05,400 --> 00:22:08,850
referencing a partition that you set up

579
00:22:07,170 --> 00:22:12,660
on your own or you want to reference

580
00:22:08,850 --> 00:22:14,250
self and additionally partitions have

581
00:22:12,660 --> 00:22:16,740
specific properties that you can query

582
00:22:14,250 --> 00:22:18,690
and you can also modify them and again

583
00:22:16,740 --> 00:22:21,420
the ones we're interested here here deal

584
00:22:18,690 --> 00:22:23,570
with privileges and what a partition is

585
00:22:21,420 --> 00:22:26,190
allowed to access and so these

586
00:22:23,570 --> 00:22:30,570
privileges are represented by a bit

587
00:22:26,190 --> 00:22:32,670
field so here I have listed every single

588
00:22:30,570 --> 00:22:34,139
bit field these are the privileges that

589
00:22:32,670 --> 00:22:35,820
you have I'm not going to go through

590
00:22:34,140 --> 00:22:37,320
each one and tell you what they do as it

591
00:22:35,820 --> 00:22:40,020
is documented in that top-level

592
00:22:37,320 --> 00:22:42,510
functional spec but what is important to

593
00:22:40,020 --> 00:22:44,429
understand here is what are your default

594
00:22:42,510 --> 00:22:48,210
privileges whenever you set up a child

595
00:22:44,429 --> 00:22:49,740
partition so highlighted here the

596
00:22:48,210 --> 00:22:52,710
default privileges whenever you create a

597
00:22:49,740 --> 00:22:54,390
partition most of them they're pretty

598
00:22:52,710 --> 00:22:56,220
limited which means that a child

599
00:22:54,390 --> 00:22:58,910
partition you're not going to have so

600
00:22:56,220 --> 00:23:02,340
many hyper call handlers to actually is

601
00:22:58,910 --> 00:23:04,770
within your attack surface one I'll call

602
00:23:02,340 --> 00:23:07,230
out here is the access hyper call MSRs

603
00:23:04,770 --> 00:23:08,820
so that one basically says that this

604
00:23:07,230 --> 00:23:11,220
partition is allowed to set up that

605
00:23:08,820 --> 00:23:13,919
hyper call page and basically program

606
00:23:11,220 --> 00:23:15,540
that synthetic chemists are one

607
00:23:13,920 --> 00:23:17,190
interesting thing though is if you

608
00:23:15,540 --> 00:23:20,820
create a virtual machine using the

609
00:23:17,190 --> 00:23:22,290
hyper-v manager it'll actually add three

610
00:23:20,820 --> 00:23:23,610
additional privileges and this is

611
00:23:22,290 --> 00:23:26,250
actually important because these

612
00:23:23,610 --> 00:23:28,280
privileges gave us three new hyper calls

613
00:23:26,250 --> 00:23:30,480
to attack and we did find bugs and these

614
00:23:28,280 --> 00:23:32,879
the reason they give you these three

615
00:23:30,480 --> 00:23:35,490
privileges is for enlightened partitions

616
00:23:32,880 --> 00:23:39,660
because this is what enables vm bus and

617
00:23:35,490 --> 00:23:41,820
that inner partition communication so

618
00:23:39,660 --> 00:23:43,770
the root partition very privileged

619
00:23:41,820 --> 00:23:46,500
basically has access to every single

620
00:23:43,770 --> 00:23:48,300
privilege except for the extended hyper

621
00:23:46,500 --> 00:23:51,690
calls because it doesn't really make

622
00:23:48,300 --> 00:23:53,280
sense for it to invoke an extended hyper

623
00:23:51,690 --> 00:23:56,550
call and then have the hypervisor send

624
00:23:53,280 --> 00:23:58,260
it back up all right so let's actually

625
00:23:56,550 --> 00:24:00,720
look at what this code snippet is so

626
00:23:58,260 --> 00:24:02,310
very simple we basically set that bit

627
00:24:00,720 --> 00:24:03,840
you're gonna pass it into a function

628
00:24:02,310 --> 00:24:05,790
which is going to get a reference to our

629
00:24:03,840 --> 00:24:06,659
partition and see if we have the proper

630
00:24:05,790 --> 00:24:08,940
privilege

631
00:24:06,660 --> 00:24:11,760
so very simple and this one comes from

632
00:24:08,940 --> 00:24:13,860
the hyper call set logical processor

633
00:24:11,760 --> 00:24:19,200
property so requires that you have the

634
00:24:13,860 --> 00:24:21,600
CPU management privilege so next I want

635
00:24:19,200 --> 00:24:23,669
to talk a little bit about the state of

636
00:24:21,600 --> 00:24:24,719
your partitions so partitions when you

637
00:24:23,669 --> 00:24:27,419
first set them up it's going to be

638
00:24:24,720 --> 00:24:29,309
uninitialized and and an uninitialized

639
00:24:27,419 --> 00:24:31,890
state there's only a handful of hyper

640
00:24:29,309 --> 00:24:33,840
calls that can operate against it such

641
00:24:31,890 --> 00:24:36,929
as querying how much memory it has or

642
00:24:33,840 --> 00:24:38,639
giving it more memory so most of the

643
00:24:36,929 --> 00:24:40,980
times if you want to make it useful you

644
00:24:38,640 --> 00:24:42,419
have to make it active and additionally

645
00:24:40,980 --> 00:24:43,860
there's also checks to make sure that

646
00:24:42,419 --> 00:24:45,950
you're either a parent or a child

647
00:24:43,860 --> 00:24:49,408
so let's look give a reference of this

648
00:24:45,950 --> 00:24:51,450
so this is an example taken from the

649
00:24:49,409 --> 00:24:53,100
inject synthetic machine check hyper

650
00:24:51,450 --> 00:24:54,659
call and basically that's just going to

651
00:24:53,100 --> 00:24:57,870
send in a machine check to this

652
00:24:54,659 --> 00:24:59,970
partition and interesting and what you

653
00:24:57,870 --> 00:25:01,260
need to know about this is it's

654
00:24:59,970 --> 00:25:03,120
requiring that you have an active

655
00:25:01,260 --> 00:25:04,610
partition and that you need to be the

656
00:25:03,120 --> 00:25:08,850
parent of it if you want to be able to

657
00:25:04,610 --> 00:25:10,559
machine check it so it uses the object

658
00:25:08,850 --> 00:25:13,530
manager in order to perform this so you

659
00:25:10,559 --> 00:25:14,908
reference your partition ID and if you

660
00:25:13,530 --> 00:25:17,210
notice here it's coming from your input

661
00:25:14,909 --> 00:25:19,140
header so this is input that you send in

662
00:25:17,210 --> 00:25:21,360
referencing which partition you want to

663
00:25:19,140 --> 00:25:24,210
perform this action in the next one is

664
00:25:21,360 --> 00:25:26,070
basically going to reference the

665
00:25:24,210 --> 00:25:27,750
conditions that need to be met so here

666
00:25:26,070 --> 00:25:30,030
it's saying that the partition must be

667
00:25:27,750 --> 00:25:32,640
active other ones are being alive

668
00:25:30,030 --> 00:25:35,100
deposit deposit able meaning that you

669
00:25:32,640 --> 00:25:38,220
can deposit memory into it or it just

670
00:25:35,100 --> 00:25:40,799
exists the next one is going to check

671
00:25:38,220 --> 00:25:42,450
the privileges of your current partition

672
00:25:40,799 --> 00:25:44,129
so this is saying whether you are the

673
00:25:42,450 --> 00:25:48,750
parent or you want to perform this on

674
00:25:44,130 --> 00:25:51,900
yourself or you must be the route all

675
00:25:48,750 --> 00:25:53,940
right next we have the partition must be

676
00:25:51,900 --> 00:25:55,950
the root so as I mentioned a lot of

677
00:25:53,940 --> 00:25:58,799
these hyper calls they're limited to a

678
00:25:55,950 --> 00:26:00,240
guest but a lot of them explicitly check

679
00:25:58,799 --> 00:26:02,520
that it's coming from a root partition

680
00:26:00,240 --> 00:26:05,220
because again as you saw the vid

681
00:26:02,520 --> 00:26:07,408
added additional privileges so you could

682
00:26:05,220 --> 00:26:09,840
always add more privileges but some of

683
00:26:07,409 --> 00:26:12,240
them say you must be the root and so

684
00:26:09,840 --> 00:26:15,149
it's pretty simple check its reference

685
00:26:12,240 --> 00:26:17,460
within your partition structure and it's

686
00:26:15,150 --> 00:26:20,280
basically going to see if it's set or

687
00:26:17,460 --> 00:26:22,020
not also added a little extra here

688
00:26:20,280 --> 00:26:23,970
there's also hyper calls that must be

689
00:26:22,020 --> 00:26:28,500
invoked from the highest virtual trust

690
00:26:23,970 --> 00:26:29,880
level alright and the last one is your

691
00:26:28,500 --> 00:26:33,140
virtual processor must be in a

692
00:26:29,880 --> 00:26:36,540
particular state so what this means um

693
00:26:33,140 --> 00:26:38,910
we have a concept of basically saving a

694
00:26:36,540 --> 00:26:40,170
memory state and restoring it so if you

695
00:26:38,910 --> 00:26:41,640
want to be able to either save or

696
00:26:40,170 --> 00:26:43,350
restore it you need to ensure that your

697
00:26:41,640 --> 00:26:45,480
virtual processor suspended because if

698
00:26:43,350 --> 00:26:50,189
it's active and running your values are

699
00:26:45,480 --> 00:26:51,690
gonna be changing alright so now that

700
00:26:50,190 --> 00:26:53,160
we've pretty much covered the basics

701
00:26:51,690 --> 00:26:55,290
want to start talking about hyper seed

702
00:26:53,160 --> 00:26:57,300
and before we get into too much details

703
00:26:55,290 --> 00:26:59,100
I want to talk of how we deployed it and

704
00:26:57,300 --> 00:27:00,629
so there are a couple different

705
00:26:59,100 --> 00:27:02,219
scenarios so whenever I picked up on

706
00:27:00,630 --> 00:27:04,470
this project this is what Daniel was

707
00:27:02,220 --> 00:27:07,290
targeting he was interested in looking

708
00:27:04,470 --> 00:27:09,030
for guest the host bugs so he was

709
00:27:07,290 --> 00:27:10,889
running this within a child partition

710
00:27:09,030 --> 00:27:13,110
and trying to see if you can get some

711
00:27:10,890 --> 00:27:15,570
type of bug either in the hypervisor or

712
00:27:13,110 --> 00:27:17,760
in the host but it turns out that uh

713
00:27:15,570 --> 00:27:20,460
these hyper calls do some funny things

714
00:27:17,760 --> 00:27:22,379
so you can end up pretty much blog

715
00:27:20,460 --> 00:27:24,210
checking many different partitions so

716
00:27:22,380 --> 00:27:27,960
you have to kind of monitor this in a

717
00:27:24,210 --> 00:27:29,640
very specific way so whenever I started

718
00:27:27,960 --> 00:27:32,760
on this project I was interested more in

719
00:27:29,640 --> 00:27:34,110
finding bugs within the root so there's

720
00:27:32,760 --> 00:27:36,300
a lot more hyper calls that are

721
00:27:34,110 --> 00:27:38,399
implemented here and they have a lot

722
00:27:36,300 --> 00:27:40,440
more functionality but this only applies

723
00:27:38,400 --> 00:27:41,850
if you have VBS enabled because that's

724
00:27:40,440 --> 00:27:43,560
the security boundary we're trying to

725
00:27:41,850 --> 00:27:45,480
find so if we can find a bug within the

726
00:27:43,560 --> 00:27:48,510
hypervisor we can now get access to

727
00:27:45,480 --> 00:27:50,190
these higher trust levels and so it's

728
00:27:48,510 --> 00:27:52,320
gonna be very similar you're gonna be

729
00:27:50,190 --> 00:27:54,210
able to crash multiple things and you

730
00:27:52,320 --> 00:27:56,040
have to be very careful when fuzzing

731
00:27:54,210 --> 00:27:57,780
from the root as a lot of these hyper

732
00:27:56,040 --> 00:27:59,790
calls will have some abnormal

733
00:27:57,780 --> 00:28:01,950
side-effects that will just end up

734
00:27:59,790 --> 00:28:03,120
killing your host machine before it

735
00:28:01,950 --> 00:28:07,320
actually finds a bug within the

736
00:28:03,120 --> 00:28:10,320
hypervisor so I also mentioned nested

737
00:28:07,320 --> 00:28:12,120
virtualization and so I did this mostly

738
00:28:10,320 --> 00:28:13,770
for just speeding up our development I

739
00:28:12,120 --> 00:28:15,929
was able to run multiple instances on a

740
00:28:13,770 --> 00:28:17,550
single machine but those turn out that

741
00:28:15,930 --> 00:28:20,430
from this configuration you could also

742
00:28:17,550 --> 00:28:22,919
find particular bugs so the way it works

743
00:28:20,430 --> 00:28:25,260
is when you have a nested hypervisor

744
00:28:22,920 --> 00:28:26,580
when it invokes a hyper call it's

745
00:28:25,260 --> 00:28:29,190
actually going to get trapped to your

746
00:28:26,580 --> 00:28:31,409
level zero hypervisor and the level zero

747
00:28:29,190 --> 00:28:32,880
is going to analyze this and see if it

748
00:28:31,410 --> 00:28:34,500
needs to handle it or

749
00:28:32,880 --> 00:28:36,570
if it can pass it back up and let your

750
00:28:34,500 --> 00:28:39,150
nested hypervisor handle it

751
00:28:36,570 --> 00:28:41,520
so in this situation now you can find

752
00:28:39,150 --> 00:28:43,530
bugs and your l1 hypervisor so that's

753
00:28:41,520 --> 00:28:46,530
like bringing you one step closer so

754
00:28:43,530 --> 00:28:48,750
more of an AOP or you get all the way

755
00:28:46,530 --> 00:28:51,960
down to your level zero hypervisor and

756
00:28:48,750 --> 00:28:53,910
this scenario also brings in a concept

757
00:28:51,960 --> 00:28:55,890
that we're not going to cover here but

758
00:28:53,910 --> 00:28:59,100
imagine you had a malicious hypervisor

759
00:28:55,890 --> 00:29:00,960
so now you're getting a little bit more

760
00:28:59,100 --> 00:29:02,189
crazy and finding more bugs but I don't

761
00:29:00,960 --> 00:29:06,300
think too many people have looked too

762
00:29:02,190 --> 00:29:08,160
much into that concept so next is

763
00:29:06,300 --> 00:29:11,520
targeting specifically those secure

764
00:29:08,160 --> 00:29:13,140
codes are the secure calls and that's by

765
00:29:11,520 --> 00:29:15,120
invoking those two hyper calls for

766
00:29:13,140 --> 00:29:17,880
switching near virtual trust levels and

767
00:29:15,120 --> 00:29:19,590
sending in that secure buffer and so for

768
00:29:17,880 --> 00:29:21,780
what we're looking here is for crashes

769
00:29:19,590 --> 00:29:24,750
within the secure kernel and also you

770
00:29:21,780 --> 00:29:28,050
can end up crashing yourself as well all

771
00:29:24,750 --> 00:29:29,850
right so next I want to move on to

772
00:29:28,050 --> 00:29:31,710
talking a little bit about format aware

773
00:29:29,850 --> 00:29:33,360
fuzzing so this is where Daniel usually

774
00:29:31,710 --> 00:29:35,070
starts presenting so for this first

775
00:29:33,360 --> 00:29:37,350
point here it doesn't really apply to me

776
00:29:35,070 --> 00:29:40,710
as Daniel had most of this past

777
00:29:37,350 --> 00:29:42,270
experience but he had a lot of success

778
00:29:40,710 --> 00:29:44,820
with this technique so he wanted to

779
00:29:42,270 --> 00:29:46,260
extend it to the hypervisor and so

780
00:29:44,820 --> 00:29:48,480
format aware fuzzing it's pretty

781
00:29:46,260 --> 00:29:51,450
effective to bypass field constraints

782
00:29:48,480 --> 00:29:53,490
and it's easy to scale so at first you

783
00:29:51,450 --> 00:29:55,890
can pretty much mutate them in a very

784
00:29:53,490 --> 00:29:57,810
dumb fashion and as you start to get a

785
00:29:55,890 --> 00:30:00,060
little bit more knowledge of them you

786
00:29:57,810 --> 00:30:01,950
can start applying certain restraints

787
00:30:00,060 --> 00:30:06,840
and kind of reducing your sample size

788
00:30:01,950 --> 00:30:09,450
down so one of the bad things about

789
00:30:06,840 --> 00:30:10,770
format aware fuzzing is one you need to

790
00:30:09,450 --> 00:30:13,380
understand what that in place structure

791
00:30:10,770 --> 00:30:15,660
looks like so it's kind of easy for us

792
00:30:13,380 --> 00:30:17,430
we have source code you guys don't but

793
00:30:15,660 --> 00:30:19,410
it is documented within that top-level

794
00:30:17,430 --> 00:30:20,850
functional respect and a lot of the bugs

795
00:30:19,410 --> 00:30:22,290
we found you could have just pulled that

796
00:30:20,850 --> 00:30:28,050
information out of there and created

797
00:30:22,290 --> 00:30:30,330
this same set up it's also worth

798
00:30:28,050 --> 00:30:31,860
mentioning that alex ionesco he

799
00:30:30,330 --> 00:30:34,409
published what's called the hypervisor

800
00:30:31,860 --> 00:30:36,300
development kit or the hdk the

801
00:30:34,410 --> 00:30:37,710
unofficial one I should say and it

802
00:30:36,300 --> 00:30:39,240
includes a lot of information that you

803
00:30:37,710 --> 00:30:41,370
can just pull in this header and start

804
00:30:39,240 --> 00:30:43,550
manipulating these structures as you

805
00:30:41,370 --> 00:30:43,550
will

806
00:30:43,940 --> 00:30:48,680
so if we're mat aware fuzzing besides

807
00:30:46,820 --> 00:30:51,889
the resources would be mentioned it's

808
00:30:48,680 --> 00:30:53,810
kind of a learning process so the format

809
00:30:51,890 --> 00:30:56,270
where fuzzer is more like an agile style

810
00:30:53,810 --> 00:30:58,310
of development so each iteration you

811
00:30:56,270 --> 00:31:00,620
kind of gain more insight into what

812
00:30:58,310 --> 00:31:02,300
you're doing so maybe you just had that

813
00:31:00,620 --> 00:31:03,860
dumb fuzzer set up initially and you got

814
00:31:02,300 --> 00:31:06,409
a crash so as you start root cause

815
00:31:03,860 --> 00:31:07,550
analysis or do a root cause analysis on

816
00:31:06,410 --> 00:31:09,620
these exceptions you're going to gain

817
00:31:07,550 --> 00:31:12,740
more insight and be able to learn how to

818
00:31:09,620 --> 00:31:14,179
apply specific conditions within your

819
00:31:12,740 --> 00:31:18,860
fuzzer and make it more of that format

820
00:31:14,180 --> 00:31:20,960
aware alright next I want to talk a

821
00:31:18,860 --> 00:31:23,800
little bit about our mutators so this is

822
00:31:20,960 --> 00:31:26,240
important for fuzzing efficiency and

823
00:31:23,800 --> 00:31:28,970
depending on who you talk to your answer

824
00:31:26,240 --> 00:31:31,370
is going to be different here but for us

825
00:31:28,970 --> 00:31:33,320
we just implemented five very simple

826
00:31:31,370 --> 00:31:36,500
mutators that operate on primitive data

827
00:31:33,320 --> 00:31:38,540
types so the five that we have

828
00:31:36,500 --> 00:31:41,510
implemented starting off we have our

829
00:31:38,540 --> 00:31:44,360
random mutator so again this is more of

830
00:31:41,510 --> 00:31:46,490
a form of generation based fuzzing so

831
00:31:44,360 --> 00:31:48,889
first we generate some random number and

832
00:31:46,490 --> 00:31:51,080
then we have other ones that are going

833
00:31:48,890 --> 00:31:53,840
to operate on this random number such as

834
00:31:51,080 --> 00:31:56,949
a sliding mutator and the sliding

835
00:31:53,840 --> 00:31:59,720
mutator is essentially a circular shift

836
00:31:56,950 --> 00:32:04,010
and it's just going to ship your bits

837
00:31:59,720 --> 00:32:05,630
around the third one is very similar to

838
00:32:04,010 --> 00:32:08,240
the sliding mutator we're gonna swap

839
00:32:05,630 --> 00:32:13,130
halves the reason we like this one is

840
00:32:08,240 --> 00:32:14,990
because it keeps your alignment this one

841
00:32:13,130 --> 00:32:16,130
problem most people know of bit flip so

842
00:32:14,990 --> 00:32:17,960
now we're just going to start a bit

843
00:32:16,130 --> 00:32:20,350
flipping certain bits and we're going to

844
00:32:17,960 --> 00:32:22,460
specify which bit we want to flip it and

845
00:32:20,350 --> 00:32:25,159
the more important one and the more

846
00:32:22,460 --> 00:32:26,630
interesting one is this mask mutator so

847
00:32:25,160 --> 00:32:28,310
if you kind of look at how these

848
00:32:26,630 --> 00:32:31,040
primitive data types are you realize a

849
00:32:28,310 --> 00:32:32,570
lot of them are sparse so by masking off

850
00:32:31,040 --> 00:32:36,500
certain bits you can basically erase

851
00:32:32,570 --> 00:32:38,810
them and get more kind of looking like

852
00:32:36,500 --> 00:32:43,040
these synthetic MSRs or looking more

853
00:32:38,810 --> 00:32:45,710
like pointer types and so with these

854
00:32:43,040 --> 00:32:48,260
five basic primitive types we can create

855
00:32:45,710 --> 00:32:50,240
a dispatcher and apply more random logic

856
00:32:48,260 --> 00:32:53,090
and more complex logic to it so

857
00:32:50,240 --> 00:32:54,740
essentially we take in a random byte and

858
00:32:53,090 --> 00:32:56,030
that's going to determine with

859
00:32:54,740 --> 00:32:57,740
one of these operations we're gonna

860
00:32:56,030 --> 00:33:03,200
perform and this brings a lot of

861
00:32:57,740 --> 00:33:04,580
randomness to to the equation so now we

862
00:33:03,200 --> 00:33:06,650
want to look at some of the components

863
00:33:04,580 --> 00:33:09,620
that make up our fuzzer hyper seed and

864
00:33:06,650 --> 00:33:11,210
we've already discussed kind of how we

865
00:33:09,620 --> 00:33:14,559
invoke these hyper calls we have this

866
00:33:11,210 --> 00:33:17,000
proxy which is just a kernel driver and

867
00:33:14,559 --> 00:33:19,160
we talked about the five primitive

868
00:33:17,000 --> 00:33:21,020
mutators and this is essentially all we

869
00:33:19,160 --> 00:33:22,370
need in order to get more complex logic

870
00:33:21,020 --> 00:33:25,670
and start implementing specific

871
00:33:22,370 --> 00:33:27,739
mutations for Hyper calls so here we use

872
00:33:25,670 --> 00:33:30,679
a divide and conquer way to organize

873
00:33:27,740 --> 00:33:31,850
mutations into a stack so we have some

874
00:33:30,679 --> 00:33:34,340
generic mutations

875
00:33:31,850 --> 00:33:36,020
so these are going to help mutate things

876
00:33:34,340 --> 00:33:37,610
like that call code or what type of

877
00:33:36,020 --> 00:33:41,030
calling convention we want or the class

878
00:33:37,610 --> 00:33:43,550
of it and then we also implement a

879
00:33:41,030 --> 00:33:45,649
default hyper Cole mutation which is

880
00:33:43,550 --> 00:33:47,480
very coarse-grained so it's essentially

881
00:33:45,650 --> 00:33:50,179
going to break up your buffer into Q

882
00:33:47,480 --> 00:33:53,270
words and mutate each one so that says

883
00:33:50,179 --> 00:33:55,280
dumb fuzzy as you can get and this is

884
00:33:53,270 --> 00:33:57,020
represented by our C based mutation

885
00:33:55,280 --> 00:34:00,559
class which is our default for all hyper

886
00:33:57,020 --> 00:34:02,960
calls so next we have classes for each

887
00:34:00,559 --> 00:34:04,910
hyper call and why do we need specific

888
00:34:02,960 --> 00:34:07,610
ones well this is where that format

889
00:34:04,910 --> 00:34:10,159
comes in each hyper call takes in a

890
00:34:07,610 --> 00:34:11,690
particular data structure and the data

891
00:34:10,159 --> 00:34:13,040
structure all the fields are going to be

892
00:34:11,690 --> 00:34:14,780
different and they have different

893
00:34:13,040 --> 00:34:17,570
meanings such as being a partition ID

894
00:34:14,780 --> 00:34:20,450
virtual trust level or some reserved

895
00:34:17,570 --> 00:34:22,490
field that must always be 0 so we can

896
00:34:20,449 --> 00:34:26,210
essentially enlighten our mutations in

897
00:34:22,489 --> 00:34:28,699
order to narrow down our sample size

898
00:34:26,210 --> 00:34:30,409
which makes our inputs essentially

899
00:34:28,699 --> 00:34:32,359
survive basic checks that would normally

900
00:34:30,409 --> 00:34:38,869
get blocked with basic taun fuzzing and

901
00:34:32,359 --> 00:34:40,040
get a little deeper in the code so this

902
00:34:38,869 --> 00:34:42,500
is kind of an example of how we

903
00:34:40,040 --> 00:34:44,418
implemented this within our framework so

904
00:34:42,500 --> 00:34:47,060
here we have a specific hyper call

905
00:34:44,418 --> 00:34:48,888
mutation this is for the flush virtual

906
00:34:47,060 --> 00:34:50,869
address space hyper call which

907
00:34:48,889 --> 00:34:53,210
essentially just invalidates all virtual

908
00:34:50,869 --> 00:34:56,119
tlbs and entries that belong to a

909
00:34:53,210 --> 00:34:57,680
specific address base so on the left

910
00:34:56,119 --> 00:34:59,240
here i have what i pulled out of the

911
00:34:57,680 --> 00:35:00,879
top-level functional spec which just

912
00:34:59,240 --> 00:35:03,290
tells you exactly what the arguments are

913
00:35:00,880 --> 00:35:05,450
so there are three parameters you have

914
00:35:03,290 --> 00:35:08,250
your address based flags processor mask

915
00:35:05,450 --> 00:35:09,990
and the flags is a cue word

916
00:35:08,250 --> 00:35:12,570
that actually acts as a bitwise

917
00:35:09,990 --> 00:35:15,450
composition of several binary options

918
00:35:12,570 --> 00:35:17,490
and so only the lower three bits are

919
00:35:15,450 --> 00:35:20,160
valid where other bits are reserved to

920
00:35:17,490 --> 00:35:22,379
zero so the fuzzy efficiency for this

921
00:35:20,160 --> 00:35:26,790
specific hyper call will be remarkably

922
00:35:22,380 --> 00:35:28,920
boosted by enforcing this format rule we

923
00:35:26,790 --> 00:35:30,509
also have several macros just to kind of

924
00:35:28,920 --> 00:35:33,600
help make our code a little bit more

925
00:35:30,510 --> 00:35:37,530
neat and the VM macro which stands for a

926
00:35:33,600 --> 00:35:39,150
basic mutator is a wrapper and basically

927
00:35:37,530 --> 00:35:41,700
what it does is you can directly apply

928
00:35:39,150 --> 00:35:44,850
this on any primitive data type and due

929
00:35:41,700 --> 00:35:50,129
to some C++ template magic it'll manage

930
00:35:44,850 --> 00:35:52,470
to find the exact type that you need all

931
00:35:50,130 --> 00:35:54,180
right now for the cool part so now that

932
00:35:52,470 --> 00:35:56,850
we understand our fuzzer which overall

933
00:35:54,180 --> 00:35:59,009
is a very basic buzzer and the curious

934
00:35:56,850 --> 00:36:01,049
thing is what results do we get so when

935
00:35:59,010 --> 00:36:02,940
you think of hyper-v it's a supposed to

936
00:36:01,050 --> 00:36:04,980
be a pretty hard and target this is what

937
00:36:02,940 --> 00:36:07,860
Iran's Azure so if you have a bug in

938
00:36:04,980 --> 00:36:09,360
this and we offer up to $250,000 it

939
00:36:07,860 --> 00:36:10,950
means serious business so I wasn't

940
00:36:09,360 --> 00:36:15,150
expecting to find much but it turns out

941
00:36:10,950 --> 00:36:17,549
we found a good bit so overall we

942
00:36:15,150 --> 00:36:19,980
started this a year ago and we got 16

943
00:36:17,550 --> 00:36:23,610
findings running a little behind on time

944
00:36:19,980 --> 00:36:25,470
so gonna speed up we found 8 escalation

945
00:36:23,610 --> 00:36:27,990
privilege or remote code execution and

946
00:36:25,470 --> 00:36:29,910
eight dos and then two of these

947
00:36:27,990 --> 00:36:32,339
qualified for the hyper-v bounty and

948
00:36:29,910 --> 00:36:33,750
seven qualified for the whip so let's

949
00:36:32,340 --> 00:36:36,900
see how much money we would have made if

950
00:36:33,750 --> 00:36:39,750
we reported these as an external so

951
00:36:36,900 --> 00:36:42,090
first here's kind of an outline of where

952
00:36:39,750 --> 00:36:43,470
these components were found in so the

953
00:36:42,090 --> 00:36:45,300
red vector is going to indicate that

954
00:36:43,470 --> 00:36:47,790
this was basically code execution

955
00:36:45,300 --> 00:36:49,890
whereas the blue was DOS and on the y

956
00:36:47,790 --> 00:36:51,720
axis this is going to tell you which

957
00:36:49,890 --> 00:36:54,450
scenario you deployed this from and

958
00:36:51,720 --> 00:36:56,580
where we got a crash in so for instance

959
00:36:54,450 --> 00:36:58,319
if you look at the left one of our bugs

960
00:36:56,580 --> 00:37:01,710
we had an escalation of privilege from

961
00:36:58,320 --> 00:37:03,000
our route VT l0 and we got a crash in

962
00:37:01,710 --> 00:37:05,580
some hyper call handler in the

963
00:37:03,000 --> 00:37:07,590
hypervisor now you'll notice the one

964
00:37:05,580 --> 00:37:08,940
that kind of redirects itself so that's

965
00:37:07,590 --> 00:37:10,740
an interesting one where it ended up

966
00:37:08,940 --> 00:37:13,780
Dawson

967
00:37:10,740 --> 00:37:16,060
so for the two that qualified for bounty

968
00:37:13,780 --> 00:37:17,590
one was a remote code execution and the

969
00:37:16,060 --> 00:37:19,599
host so this would have gotten you a

970
00:37:17,590 --> 00:37:22,090
$200,000 if you just reported the bug

971
00:37:19,599 --> 00:37:24,430
without an exploit and one was a Doss

972
00:37:22,090 --> 00:37:25,869
and we're gonna look at the daus a

973
00:37:24,430 --> 00:37:27,430
little bit later and that would have

974
00:37:25,869 --> 00:37:31,420
netted you fifteen thousand it was very

975
00:37:27,430 --> 00:37:33,040
easy then we also had a bunch that

976
00:37:31,420 --> 00:37:36,400
qualified for our windows insider

977
00:37:33,040 --> 00:37:38,619
preview bounty so to where specifically

978
00:37:36,400 --> 00:37:40,359
within hyper call handlers and five of

979
00:37:38,619 --> 00:37:43,540
them where within those secure service

980
00:37:40,359 --> 00:37:45,369
calls all right so I'm going to talk a

981
00:37:43,540 --> 00:37:48,190
little bit about a bug that was patched

982
00:37:45,369 --> 00:37:50,140
last Patch Tuesday which was unfortunate

983
00:37:48,190 --> 00:37:52,060
because I reported this in July of last

984
00:37:50,140 --> 00:37:53,890
year so that kind of shows you the

985
00:37:52,060 --> 00:37:55,900
timeline it took to patch this even

986
00:37:53,890 --> 00:37:58,118
though it's very simple so we're gonna

987
00:37:55,900 --> 00:37:59,890
work backwards so this is kind of a call

988
00:37:58,119 --> 00:38:02,020
stack that I got whenever we hit this

989
00:37:59,890 --> 00:38:04,629
issue so I highlighted the fields that

990
00:38:02,020 --> 00:38:06,820
are important here so you look at which

991
00:38:04,630 --> 00:38:10,960
hyper cults and so this is they get VP

992
00:38:06,820 --> 00:38:12,760
index from your a pic ID we see that we

993
00:38:10,960 --> 00:38:14,770
basically have an out of bounds for each

994
00:38:12,760 --> 00:38:17,800
so we have this access violation and if

995
00:38:14,770 --> 00:38:20,259
you look at what those registers are RSI

996
00:38:17,800 --> 00:38:22,359
looks like a very valid pointer but if

997
00:38:20,260 --> 00:38:25,060
you look at RDX this looks like a huge

998
00:38:22,359 --> 00:38:26,230
index into this which is why it's

999
00:38:25,060 --> 00:38:31,210
causing so let's see what's going on

1000
00:38:26,230 --> 00:38:34,599
here so this this hyper call is very

1001
00:38:31,210 --> 00:38:37,420
simple it's a repeat hyper call and you

1002
00:38:34,599 --> 00:38:39,550
specify partition your target VTL and if

1003
00:38:37,420 --> 00:38:41,500
you see within where it describes the

1004
00:38:39,550 --> 00:38:44,410
parameters the padding of seven bytes

1005
00:38:41,500 --> 00:38:48,369
these are reserved fields that must be 0

1006
00:38:44,410 --> 00:38:50,319
and then we specify an APEC ID and so

1007
00:38:48,369 --> 00:38:52,810
this is going to be your repeat so

1008
00:38:50,320 --> 00:38:54,580
you're just gonna specify a big array

1009
00:38:52,810 --> 00:38:58,779
and you're gonna have various a pic IDs

1010
00:38:54,580 --> 00:39:00,580
for the number of processors you have so

1011
00:38:58,780 --> 00:39:02,080
this is what our mutation looked like so

1012
00:39:00,580 --> 00:39:03,759
it was very simple essentially we take

1013
00:39:02,080 --> 00:39:06,310
that input structure that we just talked

1014
00:39:03,760 --> 00:39:08,349
about we enlighten it to that give it a

1015
00:39:06,310 --> 00:39:10,660
valid partition ID and invalid target

1016
00:39:08,349 --> 00:39:13,060
VTL and we make sure that those reserved

1017
00:39:10,660 --> 00:39:15,670
fields are set to zero and then we

1018
00:39:13,060 --> 00:39:19,029
basically randomly generate a certain

1019
00:39:15,670 --> 00:39:21,820
number of this array which specifies our

1020
00:39:19,030 --> 00:39:24,430
Hardware IDs

1021
00:39:21,820 --> 00:39:25,840
so if we go look at the restrictions one

1022
00:39:24,430 --> 00:39:27,430
of the interesting things is that this

1023
00:39:25,840 --> 00:39:31,000
had the start virtual processor

1024
00:39:27,430 --> 00:39:33,129
privilege which is if you look back it's

1025
00:39:31,000 --> 00:39:35,830
default for all guests so this makes it

1026
00:39:33,130 --> 00:39:37,300
a guest to hypervisor Doss and we

1027
00:39:35,830 --> 00:39:42,040
explicitly check that those fields are

1028
00:39:37,300 --> 00:39:44,200
zero all right so the bug the bug was

1029
00:39:42,040 --> 00:39:46,779
very simple so here's the snippets of

1030
00:39:44,200 --> 00:39:50,890
code that you need to worry about so the

1031
00:39:46,780 --> 00:39:52,870
first one basically we have this concept

1032
00:39:50,890 --> 00:39:54,549
known as a partition per level context

1033
00:39:52,870 --> 00:39:56,319
so each partition can have multiple

1034
00:39:54,550 --> 00:39:59,260
context and they're gonna be associated

1035
00:39:56,320 --> 00:40:00,910
with each virtual trust level and each

1036
00:39:59,260 --> 00:40:03,430
virtual trust level is going to maintain

1037
00:40:00,910 --> 00:40:04,810
which virtual processes are enabled and

1038
00:40:03,430 --> 00:40:08,049
that's represented by this virtual

1039
00:40:04,810 --> 00:40:09,820
processor set that I colored in blue and

1040
00:40:08,050 --> 00:40:11,320
this is essentially a bit set so they're

1041
00:40:09,820 --> 00:40:13,870
just trying to optimize your space you

1042
00:40:11,320 --> 00:40:16,390
have there the APEC ID which I represent

1043
00:40:13,870 --> 00:40:18,970
in red this is what we pass in so this

1044
00:40:16,390 --> 00:40:21,100
is user controlled so we go into this

1045
00:40:18,970 --> 00:40:22,870
bit set number it's gonna do some type

1046
00:40:21,100 --> 00:40:25,270
of bit shift so if you remember you saw

1047
00:40:22,870 --> 00:40:27,640
that our BP was 41 41 41

1048
00:40:25,270 --> 00:40:29,500
so it's applying your bit shift of six

1049
00:40:27,640 --> 00:40:32,500
to this which brought it down to that

1050
00:40:29,500 --> 00:40:34,930
one zero five zero and then we're simply

1051
00:40:32,500 --> 00:40:38,620
gonna index this into that virtual

1052
00:40:34,930 --> 00:40:40,779
processor set so the virtual processor

1053
00:40:38,620 --> 00:40:42,220
set is a static array so this is just

1054
00:40:40,780 --> 00:40:43,930
simply an index out of bounce very

1055
00:40:42,220 --> 00:40:45,459
simple and it's a one line fix now we

1056
00:40:43,930 --> 00:40:47,560
just need to ensure that we won't go out

1057
00:40:45,460 --> 00:40:50,020
of bounds so this would have been very

1058
00:40:47,560 --> 00:40:53,230
easy if you just picked up the top-level

1059
00:40:50,020 --> 00:40:55,780
functional spec programmed as is would

1060
00:40:53,230 --> 00:40:56,950
have found a nice little bug all right

1061
00:40:55,780 --> 00:40:59,250
so now we're going to talk about the

1062
00:40:56,950 --> 00:41:01,750
future essentially keep improving this

1063
00:40:59,250 --> 00:41:03,580
adopt coverage guide at fuzzing so we

1064
00:41:01,750 --> 00:41:05,530
now have Intel PT working within the

1065
00:41:03,580 --> 00:41:08,740
hypervisor so we can start working with

1066
00:41:05,530 --> 00:41:10,150
getting an AFL set up on this we'd also

1067
00:41:08,740 --> 00:41:12,580
like to get a little bit more details

1068
00:41:10,150 --> 00:41:13,960
after bugs get patched and maybe open

1069
00:41:12,580 --> 00:41:16,690
sourcing that one might be a little bit

1070
00:41:13,960 --> 00:41:20,320
more difficult some acknowledgments I'd

1071
00:41:16,690 --> 00:41:22,630
like to thank nsrc and the team I was

1072
00:41:20,320 --> 00:41:24,040
working on at a time for allowing us to

1073
00:41:22,630 --> 00:41:26,230
one come out and present this work and

1074
00:41:24,040 --> 00:41:28,150
also the hyper-v development team these

1075
00:41:26,230 --> 00:41:30,500
guys are super ly super knowledgeable

1076
00:41:28,150 --> 00:41:33,720
and they are great to work with

1077
00:41:30,500 --> 00:41:35,490
so as promised I do have an appendix of

1078
00:41:33,720 --> 00:41:37,230
some past research this should be

1079
00:41:35,490 --> 00:41:38,640
published at some point and some useful

1080
00:41:37,230 --> 00:41:47,730
public resources for you to go

1081
00:41:38,640 --> 00:41:50,430
investigate so now we will do QA thank

1082
00:41:47,730 --> 00:41:58,530
you very much Sean about the round of

1083
00:41:50,430 --> 00:42:11,160
applause for Sean if you have any

1084
00:41:58,530 --> 00:42:14,040
questions can you tell us a little bit

1085
00:42:11,160 --> 00:42:16,740
about your cross selection functionally

1086
00:42:14,040 --> 00:42:18,150
there are two potential crash tubs call

1087
00:42:16,740 --> 00:42:20,370
stacks that could be going on there's

1088
00:42:18,150 --> 00:42:22,980
some potential complexity there yeah

1089
00:42:20,370 --> 00:42:24,450
yeah so whenever we set out for this we

1090
00:42:22,980 --> 00:42:26,130
weren't expecting to find much so we

1091
00:42:24,450 --> 00:42:28,049
didn't actually do any scale to this so

1092
00:42:26,130 --> 00:42:29,880
we actually just ran them from our test

1093
00:42:28,050 --> 00:42:31,500
machines within our office and I just

1094
00:42:29,880 --> 00:42:33,360
set up a kernel debugger to them so a

1095
00:42:31,500 --> 00:42:36,300
lot of work for actually scaling this in

1096
00:42:33,360 --> 00:42:38,250
future and yeah we had a kernel debugger

1097
00:42:36,300 --> 00:42:41,010
set up on each one of those which is why

1098
00:42:38,250 --> 00:42:43,770
Seoul or showed the deployment so we had

1099
00:42:41,010 --> 00:42:51,570
it on the root partition and the

1100
00:42:43,770 --> 00:42:54,930
hypervisor was that out of bounds error

1101
00:42:51,570 --> 00:42:56,640
or back just a one-line fix why did it

1102
00:42:54,930 --> 00:42:59,640
take so long maybe they just didn't

1103
00:42:56,640 --> 00:43:00,690
handle the error at all yeah I expected

1104
00:42:59,640 --> 00:43:03,120
good question

1105
00:43:00,690 --> 00:43:04,650
um so they handle whenever someone

1106
00:43:03,120 --> 00:43:06,000
internally finds a bug they handle a

1107
00:43:04,650 --> 00:43:07,530
little bit differently they kind of take

1108
00:43:06,000 --> 00:43:09,930
their time with it to ensure that it

1109
00:43:07,530 --> 00:43:12,030
gets pushed out everywhere so since this

1110
00:43:09,930 --> 00:43:13,950
affected the hypervisor they needed to

1111
00:43:12,030 --> 00:43:16,790
ensure that they updated the azure fleet

1112
00:43:13,950 --> 00:43:19,259
before initiating a bulletin and

1113
00:43:16,790 --> 00:43:21,360
additionally it was supposed to be fixed

1114
00:43:19,260 --> 00:43:22,980
back in December I'm not sure what

1115
00:43:21,360 --> 00:43:25,140
happened to make it get pushed out three

1116
00:43:22,980 --> 00:43:29,100
more months but somewhere some

1117
00:43:25,140 --> 00:43:31,520
communications were lost a lot of

1118
00:43:29,100 --> 00:43:31,520
questions

1119
00:43:36,530 --> 00:43:53,330
does it seems length is your last shot

1120
00:43:48,430 --> 00:43:54,290
no one no I thank you everyone happy

1121
00:43:53,330 --> 00:43:57,449
enjoyed

1122
00:43:54,290 --> 00:43:57,449
[Music]

