1
00:00:07,250 --> 00:00:10,619
[Music]

2
00:00:12,330 --> 00:00:16,900
for waiting there was some technical

3
00:00:14,379 --> 00:00:19,830
problems my name is Mackenzie Sinofsky

4
00:00:16,900 --> 00:00:22,090
I'll be presenting a shock wake up new

5
00:00:19,830 --> 00:00:26,799
detecting virtualization for speculative

6
00:00:22,090 --> 00:00:31,140
execution a little bit great a little

7
00:00:26,800 --> 00:00:34,269
bit about me I'm graduates of national

8
00:00:31,140 --> 00:00:36,850
research university machine with an

9
00:00:34,269 --> 00:00:40,690
information security degree I'm reverse

10
00:00:36,850 --> 00:00:43,150
engineering specialist by zone LLC and I

11
00:00:40,690 --> 00:00:45,610
discovered Spectre variant 3 which I'm

12
00:00:43,150 --> 00:00:47,440
going to talk about today I'm generally

13
00:00:45,610 --> 00:00:49,979
interested in applied photography

14
00:00:47,440 --> 00:00:52,540
reverse engineering hardware attacks and

15
00:00:49,979 --> 00:00:55,390
especially side-channel attacks both on

16
00:00:52,540 --> 00:00:59,229
hardware and on cryptography if you want

17
00:00:55,390 --> 00:01:01,420
to contact me due to this talk or for

18
00:00:59,229 --> 00:01:05,619
some other reason you can find me on

19
00:01:01,420 --> 00:01:08,350
this email or by my twitter handle which

20
00:01:05,619 --> 00:01:12,130
is on the screen so without further

21
00:01:08,350 --> 00:01:16,119
adieu let's rush into the talk I'm going

22
00:01:12,130 --> 00:01:18,990
to start well modern CPUs a quite

23
00:01:16,119 --> 00:01:21,789
strange and complex but the modern

24
00:01:18,990 --> 00:01:25,869
architecture started with the most

25
00:01:21,789 --> 00:01:27,130
famous cpu cpu intel 8086 better

26
00:01:25,869 --> 00:01:29,999
communicate was just simple

27
00:01:27,130 --> 00:01:33,249
microcontroller microcontroller which is

28
00:01:29,999 --> 00:01:36,369
which consisted of simple short

29
00:01:33,249 --> 00:01:39,850
registers of 16 bits it had a very small

30
00:01:36,369 --> 00:01:42,310
address space with a maximum addressing

31
00:01:39,850 --> 00:01:45,460
of 20 bits where it could address only

32
00:01:42,310 --> 00:01:48,310
one megabyte of space it had no memory

33
00:01:45,460 --> 00:01:50,740
protections or other ways of addressing

34
00:01:48,310 --> 00:01:53,409
memory other than segments so it had

35
00:01:50,740 --> 00:01:55,749
just real mode the standard feature size

36
00:01:53,409 --> 00:01:59,170
at the time was just free micrometers

37
00:01:55,749 --> 00:02:04,689
it's almost a thousand times more now

38
00:01:59,170 --> 00:02:07,270
around 500 times more right now and the

39
00:02:04,689 --> 00:02:09,369
prefetch which is the number of bytes

40
00:02:07,270 --> 00:02:13,690
which I read before the execution of the

41
00:02:09,369 --> 00:02:17,200
comment was just 6 there was also no

42
00:02:13,690 --> 00:02:20,079
flaws important unit inside obviously to

43
00:02:17,200 --> 00:02:21,390
become the modern computing machines and

44
00:02:20,080 --> 00:02:24,710
to become a

45
00:02:21,390 --> 00:02:27,809
useful as they are today CPUs head table

46
00:02:24,710 --> 00:02:30,690
so with the evolution many new features

47
00:02:27,810 --> 00:02:33,090
came the floating-point HUMINT was one

48
00:02:30,690 --> 00:02:35,210
of the first to be introduced that's why

49
00:02:33,090 --> 00:02:38,400
it's called the x87

50
00:02:35,210 --> 00:02:42,450
we in the register size has increased

51
00:02:38,400 --> 00:02:46,640
with time a nowadays standard register

52
00:02:42,450 --> 00:02:49,350
size on intel and AMD cpus is 64 bits

53
00:02:46,640 --> 00:02:52,109
protected mode was introduced to

54
00:02:49,350 --> 00:02:56,280
separate users and separate different

55
00:02:52,110 --> 00:02:58,530
applications as well as to separate

56
00:02:56,280 --> 00:03:00,330
different protection levels such as user

57
00:02:58,530 --> 00:03:03,810
mode and kernel mode

58
00:03:00,330 --> 00:03:07,739
paging was introduced for the same real

59
00:03:03,810 --> 00:03:12,180
protected mode also single instruction

60
00:03:07,739 --> 00:03:14,760
multiple data modules were introduced to

61
00:03:12,180 --> 00:03:18,209
handle complex separations which could

62
00:03:14,760 --> 00:03:20,310
be a paralyzed as well as the system

63
00:03:18,209 --> 00:03:22,910
management mode which was created for

64
00:03:20,310 --> 00:03:26,370
the purpose of handling hardware devices

65
00:03:22,910 --> 00:03:29,790
without the knowledge of their

66
00:03:26,370 --> 00:03:33,690
particular entry intricacies for the

67
00:03:29,790 --> 00:03:36,390
operating system however it's obvious

68
00:03:33,690 --> 00:03:38,670
that modern sip one of the most

69
00:03:36,390 --> 00:03:41,458
important increases of modern CPUs is

70
00:03:38,670 --> 00:03:45,988
not just in features but in how much

71
00:03:41,459 --> 00:03:48,630
they can compute as in a single time and

72
00:03:45,989 --> 00:03:52,560
there are only three ways to increase

73
00:03:48,630 --> 00:03:55,440
that one and the most obvious way is to

74
00:03:52,560 --> 00:03:57,420
compute to compute more in a single

75
00:03:55,440 --> 00:04:00,660
second so just to increase the frequency

76
00:03:57,420 --> 00:04:03,359
of computation increase the cycles the

77
00:04:00,660 --> 00:04:06,650
second one is well crazy new computing

78
00:04:03,360 --> 00:04:11,549
units which is for example what seemed

79
00:04:06,650 --> 00:04:14,910
SM the instructions are for and last and

80
00:04:11,549 --> 00:04:19,260
not network this one is to get more

81
00:04:14,910 --> 00:04:22,229
cores so these are the most obvious ways

82
00:04:19,260 --> 00:04:25,979
to increase the computer output off a

83
00:04:22,229 --> 00:04:27,840
single CPU but all these approaches have

84
00:04:25,979 --> 00:04:30,270
some problems

85
00:04:27,840 --> 00:04:33,000
the most obvious one especially with the

86
00:04:30,270 --> 00:04:34,060
increasing the increases in frequency is

87
00:04:33,000 --> 00:04:37,120
the memory

88
00:04:34,060 --> 00:04:40,090
access time since however the first

89
00:04:37,120 --> 00:04:44,770
single computation for example of an

90
00:04:40,090 --> 00:04:47,409
arithmetic for example of an arithmetic

91
00:04:44,770 --> 00:04:50,469
computation takes it still has to

92
00:04:47,410 --> 00:04:51,250
retrieve the data somehow and save it

93
00:04:50,470 --> 00:04:54,520
back

94
00:04:51,250 --> 00:04:56,850
so all those loads and stores are some

95
00:04:54,520 --> 00:04:59,740
happened after some time obviously there

96
00:04:56,850 --> 00:05:03,190
becomes a bottleneck where you just

97
00:04:59,740 --> 00:05:07,210
can't access the same data and the the

98
00:05:03,190 --> 00:05:12,550
CPU stalls while it waits for the data

99
00:05:07,210 --> 00:05:15,190
to come and for it to compute on it the

100
00:05:12,550 --> 00:05:19,990
second problem is energy efficiency with

101
00:05:15,190 --> 00:05:22,870
the increase in in computation and with

102
00:05:19,990 --> 00:05:26,020
increasing frequency any CPU would

103
00:05:22,870 --> 00:05:28,870
obviously consume more power and after a

104
00:05:26,020 --> 00:05:33,370
certain amount it just becomes too much

105
00:05:28,870 --> 00:05:35,229
so there has to be some other way with

106
00:05:33,370 --> 00:05:37,270
the increase in power consumption and

107
00:05:35,229 --> 00:05:40,719
with the increasing the amount of

108
00:05:37,270 --> 00:05:42,969
switching obviously there comes although

109
00:05:40,720 --> 00:05:45,570
with the consumption of more energy the

110
00:05:42,970 --> 00:05:49,300
CPU becomes more and more reheated and

111
00:05:45,570 --> 00:05:54,070
for example if you wanted to throttle

112
00:05:49,300 --> 00:05:57,280
the CPU to increase the the frequency up

113
00:05:54,070 --> 00:06:01,840
to 6 gigahertz you'd obviously had to

114
00:05:57,280 --> 00:06:04,929
come up with the the system to cool it

115
00:06:01,840 --> 00:06:07,179
down maybe on liquid nitrogen or some

116
00:06:04,930 --> 00:06:11,160
other way but you'd have to internet a

117
00:06:07,180 --> 00:06:14,560
special system just to cool it with the

118
00:06:11,160 --> 00:06:18,120
parallel with parallelism there's a big

119
00:06:14,560 --> 00:06:20,350
problem which is that while you can

120
00:06:18,120 --> 00:06:21,520
implement certain instructions

121
00:06:20,350 --> 00:06:24,130
consecutively

122
00:06:21,520 --> 00:06:26,590
there's obviously problem with serial

123
00:06:24,130 --> 00:06:28,810
instructions where the computation is

124
00:06:26,590 --> 00:06:32,020
based on previous computation so you

125
00:06:28,810 --> 00:06:35,350
just can't split the task between

126
00:06:32,020 --> 00:06:36,760
different cores and well finally basic

127
00:06:35,350 --> 00:06:40,060
laws of nature although we are not

128
00:06:36,760 --> 00:06:43,060
really approaching them yet but it's

129
00:06:40,060 --> 00:06:44,620
obvious that after some time the the

130
00:06:43,060 --> 00:06:48,520
relative physics is going to come into

131
00:06:44,620 --> 00:06:51,630
play and we won't be able to increase

132
00:06:48,520 --> 00:06:56,198
simple frequency and simple power animal

133
00:06:51,630 --> 00:06:59,349
to address all those issues Intel and

134
00:06:56,199 --> 00:07:01,539
AMD well generally CPU companies have

135
00:06:59,349 --> 00:07:06,880
come up with the new and clever

136
00:07:01,539 --> 00:07:10,719
solutions which increase the throughput

137
00:07:06,880 --> 00:07:13,930
of CPUs without consuming more energy

138
00:07:10,720 --> 00:07:15,280
and without drastically change in the

139
00:07:13,930 --> 00:07:20,470
architecture

140
00:07:15,280 --> 00:07:22,809
so the four most important are the cache

141
00:07:20,470 --> 00:07:24,909
the translation lookaside buffer hyper

142
00:07:22,810 --> 00:07:29,349
threading range prediction and returns

143
00:07:24,909 --> 00:07:33,219
tech matters so as we all know the cache

144
00:07:29,349 --> 00:07:38,110
is a mechanism designed to speed up

145
00:07:33,220 --> 00:07:42,190
access to data in Intel CPUs cache takes

146
00:07:38,110 --> 00:07:46,569
on caches split into three different

147
00:07:42,190 --> 00:07:50,909
levels going from one to three cache

148
00:07:46,569 --> 00:07:54,909
handles data loads and stores and old

149
00:07:50,909 --> 00:07:58,180
loads in stores in the CPU if it is

150
00:07:54,909 --> 00:08:00,360
allowed by if it is allowed impatient

151
00:07:58,180 --> 00:08:03,659
there are different methods of handling

152
00:08:00,360 --> 00:08:07,389
caching and the operating system can

153
00:08:03,659 --> 00:08:11,650
change how it handles cache if caching

154
00:08:07,389 --> 00:08:16,120
is on the caches theorem so these three

155
00:08:11,650 --> 00:08:18,789
levels the third level is you has a

156
00:08:16,120 --> 00:08:22,690
unified data and instructions so the

157
00:08:18,789 --> 00:08:26,979
execution of an instruction good issue a

158
00:08:22,690 --> 00:08:29,259
load from the cache and the same would

159
00:08:26,979 --> 00:08:33,149
be with instructions it's shared by all

160
00:08:29,259 --> 00:08:36,310
cores and levels two and one are

161
00:08:33,149 --> 00:08:37,990
separate for each bore their designated

162
00:08:36,309 --> 00:08:40,958
each for its own

163
00:08:37,990 --> 00:08:43,620
and while the difference between level

164
00:08:40,958 --> 00:08:46,810
one and level two is that level two

165
00:08:43,620 --> 00:08:48,490
doesn't split data and instructions

166
00:08:46,810 --> 00:08:50,770
there are no separate caches for them

167
00:08:48,490 --> 00:08:55,510
but with level one

168
00:08:50,770 --> 00:08:57,040
there are special caches for data and

169
00:08:55,510 --> 00:08:59,800
there are other special caches for

170
00:08:57,040 --> 00:09:01,959
instructions they decrease in size from

171
00:08:59,800 --> 00:09:04,150
level three to level one and the

172
00:09:01,960 --> 00:09:06,880
increase in speed from level one to

173
00:09:04,150 --> 00:09:09,189
level three since level three is split

174
00:09:06,880 --> 00:09:13,540
between all the core so the lookup in

175
00:09:09,190 --> 00:09:15,730
that cache takes most time and level one

176
00:09:13,540 --> 00:09:18,189
is the closest to score and two its

177
00:09:15,730 --> 00:09:21,070
computational units so any lookup in

178
00:09:18,190 --> 00:09:24,520
level one is the fastest way to get some

179
00:09:21,070 --> 00:09:30,940
data from memory also I'd have to show

180
00:09:24,520 --> 00:09:33,490
you that our lookups in cache done in

181
00:09:30,940 --> 00:09:37,060
cache lines so we can't just look up one

182
00:09:33,490 --> 00:09:39,490
byte of data from cache each access to

183
00:09:37,060 --> 00:09:43,479
memory which is not yet cached which

184
00:09:39,490 --> 00:09:49,420
preserve all 64 bytes alkaline memory so

185
00:09:43,480 --> 00:09:52,090
aligned by 64 bytes to cash or and even

186
00:09:49,420 --> 00:09:55,540
if you want it and the same way if you

187
00:09:52,090 --> 00:09:59,850
wanted to store cash back to memory it

188
00:09:55,540 --> 00:10:03,969
would commit all 64 bytes back to memory

189
00:09:59,850 --> 00:10:06,640
so another thing about cache is how its

190
00:10:03,970 --> 00:10:11,010
organized on the inside in each level

191
00:10:06,640 --> 00:10:14,439
cache is split into associate in two

192
00:10:11,010 --> 00:10:17,800
different sets and different caches in

193
00:10:14,440 --> 00:10:22,390
each set are called set associative what

194
00:10:17,800 --> 00:10:25,000
this means is that for four different

195
00:10:22,390 --> 00:10:30,640
addresses those addresses are grouped

196
00:10:25,000 --> 00:10:32,110
into into they're grouped into different

197
00:10:30,640 --> 00:10:35,290
groups where each group consists of

198
00:10:32,110 --> 00:10:42,790
eight cache lines for example for Intel

199
00:10:35,290 --> 00:10:46,150
Sandy Bridge syndrich and you and you'd

200
00:10:42,790 --> 00:10:50,050
have to commit eight different cache

201
00:10:46,150 --> 00:10:54,790
cache lines to each set to evict a

202
00:10:50,050 --> 00:10:58,839
previous cache so the way caching works

203
00:10:54,790 --> 00:11:01,579
is in comparison to real-life is when

204
00:10:58,840 --> 00:11:03,110
you just reason from memory your

205
00:11:01,580 --> 00:11:04,580
to a library and you get the book and

206
00:11:03,110 --> 00:11:08,630
you take it home and you start reading

207
00:11:04,580 --> 00:11:11,450
it with a level to free cash the book is

208
00:11:08,630 --> 00:11:14,870
already sitting in your home at your

209
00:11:11,450 --> 00:11:17,810
home just on a bookshelf somewhere

210
00:11:14,870 --> 00:11:21,079
nearby maybe in another room with the

211
00:11:17,810 --> 00:11:24,229
level 1 cache the book is right beside

212
00:11:21,079 --> 00:11:28,670
your hand and you just have to stretch

213
00:11:24,230 --> 00:11:32,899
it and grab the book to read it so well

214
00:11:28,670 --> 00:11:37,449
it's obvious that the speed is quite

215
00:11:32,899 --> 00:11:41,810
different the second most important

216
00:11:37,450 --> 00:11:44,660
mechanism for increasing the performance

217
00:11:41,810 --> 00:11:48,699
of modern cpus are translation lookaside

218
00:11:44,660 --> 00:11:51,469
buffer modern memory lookups consists of

219
00:11:48,700 --> 00:11:53,990
not just accessing the data that would

220
00:11:51,470 --> 00:11:56,589
be obvious and that would be quite

221
00:11:53,990 --> 00:11:59,690
simple if we only had physical addresses

222
00:11:56,589 --> 00:12:02,540
but today we have this mechanism called

223
00:11:59,690 --> 00:12:05,140
paging which translates virtual

224
00:12:02,540 --> 00:12:09,949
addresses virtual addresses which I used

225
00:12:05,140 --> 00:12:14,240
by problems by in user model and P&L

226
00:12:09,950 --> 00:12:19,120
mode to their physical counterparts this

227
00:12:14,240 --> 00:12:23,510
allows the canal to change process basis

228
00:12:19,120 --> 00:12:26,540
the pages and the mapping of virtual

229
00:12:23,510 --> 00:12:28,790
address is quite quickly when it's

230
00:12:26,540 --> 00:12:32,529
switching between different processes it

231
00:12:28,790 --> 00:12:35,899
allows two separate users and increase

232
00:12:32,529 --> 00:12:39,790
protection and security but because of

233
00:12:35,899 --> 00:12:44,209
how the page and instruction and how its

234
00:12:39,790 --> 00:12:49,270
how it operates it increases the time

235
00:12:44,209 --> 00:12:51,680
needed to look up a single byte from

236
00:12:49,270 --> 00:12:54,829
from an operating system from user mode

237
00:12:51,680 --> 00:12:57,410
so as you can see to look up a single

238
00:12:54,829 --> 00:12:59,649
byte from virtual address without

239
00:12:57,410 --> 00:13:03,890
caching you would have to go through

240
00:12:59,649 --> 00:13:05,660
nowadays four different tables where the

241
00:13:03,890 --> 00:13:08,209
virtual address is fit into different

242
00:13:05,660 --> 00:13:10,790
parts and each time look up in a table

243
00:13:08,209 --> 00:13:12,250
leads to a new table until you finally

244
00:13:10,790 --> 00:13:15,980
reach

245
00:13:12,250 --> 00:13:20,000
officers parts and there you just pick

246
00:13:15,980 --> 00:13:22,610
the bite from the final page whose which

247
00:13:20,000 --> 00:13:24,230
had received computed before and you're

248
00:13:22,610 --> 00:13:26,810
finally in kitchen the bite and sending

249
00:13:24,230 --> 00:13:29,120
it back to the computation unit so it

250
00:13:26,810 --> 00:13:33,079
can finally do sample and it for example

251
00:13:29,120 --> 00:13:37,150
load into a register make some

252
00:13:33,080 --> 00:13:40,760
computation so to speed up that process

253
00:13:37,150 --> 00:13:45,819
Intel and AMD basically created cache

254
00:13:40,760 --> 00:13:50,330
for virtual addresses what it does is

255
00:13:45,820 --> 00:13:54,470
just save most often save virtual

256
00:13:50,330 --> 00:13:55,970
addresses which were recently used in in

257
00:13:54,470 --> 00:13:57,580
a special occasion

258
00:13:55,970 --> 00:14:01,400
well that's basically all the different

259
00:13:57,580 --> 00:14:06,350
the only thing it also have to tell you

260
00:14:01,400 --> 00:14:08,180
is that gob is split into large pages or

261
00:14:06,350 --> 00:14:10,970
small pages that's based on how the

262
00:14:08,180 --> 00:14:14,209
operating system set up page and in

263
00:14:10,970 --> 00:14:17,920
general so for example Windows usually

264
00:14:14,210 --> 00:14:20,870
sets up pages of four kilobyte size but

265
00:14:17,920 --> 00:14:25,370
the maximum as far as I can remember is

266
00:14:20,870 --> 00:14:27,680
one gigabyte so you could set up much

267
00:14:25,370 --> 00:14:30,920
bigger pages and it's also it's

268
00:14:27,680 --> 00:14:33,709
instruction and data since look look up

269
00:14:30,920 --> 00:14:37,010
self instruction and data usually follow

270
00:14:33,710 --> 00:14:38,870
different rules in program so it would

271
00:14:37,010 --> 00:14:43,360
be problematic and it would decrease

272
00:14:38,870 --> 00:14:46,340
performance if those two were united

273
00:14:43,360 --> 00:14:49,610
hyper frettin is a very nice mechanism

274
00:14:46,340 --> 00:14:52,610
which was introduced by Intel after they

275
00:14:49,610 --> 00:14:54,470
understood how much computing units

276
00:14:52,610 --> 00:14:56,780
they're sparing all the time and how

277
00:14:54,470 --> 00:14:59,720
much of computation they are simply not

278
00:14:56,780 --> 00:15:05,270
using as I told you there have been

279
00:14:59,720 --> 00:15:08,870
different there have been many new units

280
00:15:05,270 --> 00:15:16,340
created during the cpu evolution such as

281
00:15:08,870 --> 00:15:17,780
SPU SIMD etc but most of them operating

282
00:15:16,340 --> 00:15:21,740
on different hardware so they're

283
00:15:17,780 --> 00:15:23,990
actually different hardware there are

284
00:15:21,740 --> 00:15:27,320
actually different hardware part

285
00:15:23,990 --> 00:15:30,589
in a single call which constitute those

286
00:15:27,320 --> 00:15:32,990
instructions so there's a no problem

287
00:15:30,589 --> 00:15:36,020
with using them at the same time and

288
00:15:32,990 --> 00:15:41,600
happy and hyper phrasing is the

289
00:15:36,020 --> 00:15:46,300
technology which achieves that if the

290
00:15:41,600 --> 00:15:49,430
CPU detects that it can execute differ

291
00:15:46,300 --> 00:15:51,469
that it can execute different so

292
00:15:49,430 --> 00:15:53,449
comments on the same core just by

293
00:15:51,470 --> 00:15:58,550
setting them to different computation

294
00:15:53,450 --> 00:16:01,520
units it it initializes hyper-threading

295
00:15:58,550 --> 00:16:02,410
and it achieves out for the execution so

296
00:16:01,520 --> 00:16:08,079
it preemptively

297
00:16:02,410 --> 00:16:12,170
starts executing units which executes in

298
00:16:08,080 --> 00:16:14,870
instructions which can be sent to units

299
00:16:12,170 --> 00:16:18,380
which are now free

300
00:16:14,870 --> 00:16:21,890
the only problem will not be on for the

301
00:16:18,380 --> 00:16:25,760
CPU would be how to decide what to

302
00:16:21,890 --> 00:16:29,199
execute net since well the outer for the

303
00:16:25,760 --> 00:16:32,899
execution itself is a problematic from

304
00:16:29,200 --> 00:16:36,589
from the point that the CPU needs to

305
00:16:32,899 --> 00:16:38,860
know which part of the program will be

306
00:16:36,589 --> 00:16:41,660
executed in that so it has this

307
00:16:38,860 --> 00:16:46,430
instruction that it shouldn't hit next

308
00:16:41,660 --> 00:16:49,100
and it has units it looks up beforehand

309
00:16:46,430 --> 00:16:51,680
it sees some instruction somewhere in

310
00:16:49,100 --> 00:16:55,120
the horizon but it should know what to

311
00:16:51,680 --> 00:16:58,130
execute so for that for that purpose

312
00:16:55,120 --> 00:17:01,399
intel introduced branch prediction and

313
00:16:58,130 --> 00:17:03,950
our SBS branch prediction is a

314
00:17:01,399 --> 00:17:08,540
collection of statistics from previous

315
00:17:03,950 --> 00:17:11,870
jumps and calls way just after

316
00:17:08,540 --> 00:17:16,280
collecting some statistics it when it

317
00:17:11,869 --> 00:17:19,969
sees a new call or jump which relates to

318
00:17:16,280 --> 00:17:23,480
previous data so for example the initial

319
00:17:19,970 --> 00:17:27,230
address and the initial address of the

320
00:17:23,480 --> 00:17:31,730
call or an indirect call is the same as

321
00:17:27,230 --> 00:17:34,100
in 10 previous cases and all those 10

322
00:17:31,730 --> 00:17:37,100
previous cases landed in the

323
00:17:34,100 --> 00:17:40,129
same page and at the same address then

324
00:17:37,100 --> 00:17:42,230
the CPU is quite sure that this

325
00:17:40,130 --> 00:17:44,480
particular call will land on the same

326
00:17:42,230 --> 00:17:48,289
page and at the same address so it

327
00:17:44,480 --> 00:17:52,460
starts executing that those instructions

328
00:17:48,289 --> 00:17:56,720
preemptively and the second and the most

329
00:17:52,460 --> 00:17:59,590
among sure we are returns tech butters

330
00:17:56,720 --> 00:18:05,480
these are special registers in each core

331
00:17:59,590 --> 00:18:08,090
which which remember what was the last

332
00:18:05,480 --> 00:18:11,570
address placed during a call on the

333
00:18:08,090 --> 00:18:15,289
stack so the last return address and it

334
00:18:11,570 --> 00:18:16,908
can save up to 16 of them users on

335
00:18:15,289 --> 00:18:20,059
modern architectures and it starts

336
00:18:16,909 --> 00:18:22,220
executing instructions at those return

337
00:18:20,059 --> 00:18:25,100
addresses so from that would get

338
00:18:22,220 --> 00:18:27,710
speculative execution since the CPUs

339
00:18:25,100 --> 00:18:31,639
speculate what is going to be executed

340
00:18:27,710 --> 00:18:34,370
next without knowing it for sure

341
00:18:31,640 --> 00:18:36,710
the only problem with the speculative

342
00:18:34,370 --> 00:18:43,039
execution is that sometimes it can be

343
00:18:36,710 --> 00:18:43,760
bad well sometimes the CPU can get me

344
00:18:43,039 --> 00:18:46,400
wrong

345
00:18:43,760 --> 00:18:49,970
for example or you could compare it to

346
00:18:46,400 --> 00:18:53,809
go into an ice cream store with your

347
00:18:49,970 --> 00:18:55,400
friends and standing in line but maybe

348
00:18:53,809 --> 00:18:58,539
you're a group of lips present you only

349
00:18:55,400 --> 00:19:01,690
take vanilla ice cream with coffee and

350
00:18:58,539 --> 00:19:06,980
you only take chocolate ice cream with

351
00:19:01,690 --> 00:19:09,049
tea so you split and one of you goes to

352
00:19:06,980 --> 00:19:10,789
get drinks and the other goes to get ice

353
00:19:09,049 --> 00:19:15,379
creams and you mispredict once you go

354
00:19:10,789 --> 00:19:18,440
what you're going to get so if the rise

355
00:19:15,380 --> 00:19:20,900
is a wrong prediction you have to change

356
00:19:18,440 --> 00:19:23,270
the overlay again and the one who was

357
00:19:20,900 --> 00:19:26,419
executed serially actually determines

358
00:19:23,270 --> 00:19:33,220
that the decorative execution was wrong

359
00:19:26,419 --> 00:19:37,419
and you have to do it all over again so

360
00:19:33,220 --> 00:19:40,909
while those methods are quite useful

361
00:19:37,419 --> 00:19:42,860
cash has been used for side-channel in

362
00:19:40,909 --> 00:19:45,380
different algorithms and breaking

363
00:19:42,860 --> 00:19:48,439
security for quite some time

364
00:19:45,380 --> 00:19:52,070
as it turned out cache lines can reveal

365
00:19:48,440 --> 00:19:54,680
information about processes and even

366
00:19:52,070 --> 00:19:56,990
before spectral meltdown which road or

367
00:19:54,680 --> 00:19:58,790
last year there were a few attacks

368
00:19:56,990 --> 00:20:03,500
though they were mainly cryptographic

369
00:19:58,790 --> 00:20:06,770
there was a one of the most famous are

370
00:20:03,500 --> 00:20:09,410
the cross V M prime probe attack this is

371
00:20:06,770 --> 00:20:13,629
a evil virtual machine attack where it

372
00:20:09,410 --> 00:20:17,740
could guess the keys which were using

373
00:20:13,630 --> 00:20:22,660
OpenSSL on a different machine just by

374
00:20:17,740 --> 00:20:25,250
observing cache commits and cache fault

375
00:20:22,660 --> 00:20:27,650
then there was a is T table flash

376
00:20:25,250 --> 00:20:31,340
blaster reload attack where a malicious

377
00:20:27,650 --> 00:20:36,500
process on the same on the same call

378
00:20:31,340 --> 00:20:38,600
without access to the victim process

379
00:20:36,500 --> 00:20:42,650
without any special permissions but

380
00:20:38,600 --> 00:20:46,699
handling the same but with the access to

381
00:20:42,650 --> 00:20:49,640
the same library only for repurposes so

382
00:20:46,700 --> 00:20:55,040
only with read access could monitor how

383
00:20:49,640 --> 00:20:57,530
the is you know how they is encryption

384
00:20:55,040 --> 00:21:00,440
was made and the right once again could

385
00:20:57,530 --> 00:21:02,990
derive the key from the encryption well

386
00:21:00,440 --> 00:21:07,160
there are a few more algorithms for

387
00:21:02,990 --> 00:21:10,520
example there was a recent the return of

388
00:21:07,160 --> 00:21:14,720
blasian bar with the denial cat lives by

389
00:21:10,520 --> 00:21:20,330
Shamir and others so those attacks are

390
00:21:14,720 --> 00:21:23,150
still quite prominent the most important

391
00:21:20,330 --> 00:21:25,070
methods with the cash side channels are

392
00:21:23,150 --> 00:21:28,970
the most important techniques are flash

393
00:21:25,070 --> 00:21:32,659
plus reload FX plus time vice prime plus

394
00:21:28,970 --> 00:21:36,350
probe and flash last flash so I'm going

395
00:21:32,660 --> 00:21:38,210
to talk about them a little bit flash

396
00:21:36,350 --> 00:21:40,939
plus reloading is a simple attack where

397
00:21:38,210 --> 00:21:43,429
you first flush the cache lines with an

398
00:21:40,940 --> 00:21:44,660
extraction code Co flash on intro

399
00:21:43,429 --> 00:21:46,340
although there is a new instruction

400
00:21:44,660 --> 00:21:51,230
called Co flash opt which does almost

401
00:21:46,340 --> 00:21:52,939
the same thing so you instead of

402
00:21:51,230 --> 00:21:55,490
committing the cache lines to memory you

403
00:21:52,940 --> 00:21:58,160
free them so

404
00:21:55,490 --> 00:22:02,150
so the memory you are trying to monitor

405
00:21:58,160 --> 00:22:06,620
it doesn't have any any memory committed

406
00:22:02,150 --> 00:22:09,410
to the actual cash then you trigger or

407
00:22:06,620 --> 00:22:12,530
wait for the execution of the process

408
00:22:09,410 --> 00:22:16,130
that you are trying to monitor and to

409
00:22:12,530 --> 00:22:19,570
observe and afterwards you collect the

410
00:22:16,130 --> 00:22:22,580
cache line information by using time in

411
00:22:19,570 --> 00:22:28,879
instructions such as our DTSC or our

412
00:22:22,580 --> 00:22:30,799
DHCP and derive some some info for

413
00:22:28,880 --> 00:22:36,289
example you can derive a key in a CT

414
00:22:30,799 --> 00:22:39,049
table from this this time is a kind of

415
00:22:36,289 --> 00:22:42,049
like flash Plus reload only it has to

416
00:22:39,049 --> 00:22:44,799
operate in systems and in environments

417
00:22:42,049 --> 00:22:48,168
where there is no flash operation or

418
00:22:44,799 --> 00:22:51,770
something interchangeable with it I

419
00:22:48,169 --> 00:22:57,770
talked with you about set associativity

420
00:22:51,770 --> 00:23:00,830
and a victor is a technique which uses

421
00:22:57,770 --> 00:23:04,070
that set associativity so instead of

422
00:23:00,830 --> 00:23:08,330
flash in the cache lines straight it

423
00:23:04,070 --> 00:23:12,110
just loads different addresses which go

424
00:23:08,330 --> 00:23:14,928
to the same set which evict the

425
00:23:12,110 --> 00:23:18,889
monitored address from that set and

426
00:23:14,929 --> 00:23:22,820
after that it's the same as with flash

427
00:23:18,890 --> 00:23:25,100
plus reload prime plus probe wins my

428
00:23:22,820 --> 00:23:27,260
favorite it's a very interesting attack

429
00:23:25,100 --> 00:23:29,330
from the standpoint that you have no

430
00:23:27,260 --> 00:23:33,020
access to the victim address space you

431
00:23:29,330 --> 00:23:35,570
have no interconnections and no

432
00:23:33,020 --> 00:23:37,039
intersection is tall but you still have

433
00:23:35,570 --> 00:23:40,549
to use the same cache since you'll

434
00:23:37,039 --> 00:23:44,390
operate on the same since either you

435
00:23:40,549 --> 00:23:47,120
operate on the same or or you operate on

436
00:23:44,390 --> 00:23:50,270
the same CPU so at least level 3 cache

437
00:23:47,120 --> 00:23:53,030
is the same for both of you what you do

438
00:23:50,270 --> 00:23:56,690
is commit some cache lines from your

439
00:23:53,030 --> 00:23:59,120
address based memory then then wait for

440
00:23:56,690 --> 00:24:01,130
the victim virtual machine and the

441
00:23:59,120 --> 00:24:04,850
victim process in that other virtual

442
00:24:01,130 --> 00:24:06,600
machine to execute to commit to complete

443
00:24:04,850 --> 00:24:10,080
some actions

444
00:24:06,600 --> 00:24:14,909
and then you watch for what which cache

445
00:24:10,080 --> 00:24:19,409
lines were evicted from from cache and

446
00:24:14,910 --> 00:24:23,130
from that you derive some information so

447
00:24:19,410 --> 00:24:27,630
let's talk about what what's so special

448
00:24:23,130 --> 00:24:30,299
about cache side-channel well before the

449
00:24:27,630 --> 00:24:33,510
spectrum meltdown landed known quite

450
00:24:30,299 --> 00:24:34,679
understood this principle but the

451
00:24:33,510 --> 00:24:38,820
problem with the stack weights of

452
00:24:34,679 --> 00:24:40,650
execution and caches is that before a

453
00:24:38,820 --> 00:24:44,039
special execution was considered

454
00:24:40,650 --> 00:24:48,090
especially by its architects to show and

455
00:24:44,039 --> 00:24:51,240
to leak no information from that

456
00:24:48,090 --> 00:24:53,780
particular from that particular state of

457
00:24:51,240 --> 00:24:57,090
the CPU so if it's being speculatively

458
00:24:53,780 --> 00:24:59,309
executed unless the cpu determines that

459
00:24:57,090 --> 00:25:04,470
this particular speculative execution

460
00:24:59,309 --> 00:25:08,850
block is to be really executed so the

461
00:25:04,470 --> 00:25:14,070
execution pointer is going to reach this

462
00:25:08,850 --> 00:25:16,559
block the user or the program could get

463
00:25:14,070 --> 00:25:19,350
no data from it it was as if it was

464
00:25:16,559 --> 00:25:23,760
never executed cache side-channel

465
00:25:19,350 --> 00:25:26,639
changed all of that and now we can leak

466
00:25:23,760 --> 00:25:29,158
some data just because caches don't

467
00:25:26,640 --> 00:25:31,590
change and the state of the cache

468
00:25:29,159 --> 00:25:34,710
doesn't get this discarded after special

469
00:25:31,590 --> 00:25:36,689
speculative execution so simplest way to

470
00:25:34,710 --> 00:25:40,320
trigger speculative execution with a

471
00:25:36,690 --> 00:25:44,610
cache side-channel is to use such a

472
00:25:40,320 --> 00:25:47,580
gadget the first win we do is execute an

473
00:25:44,610 --> 00:25:52,260
EM fence instruction this is an

474
00:25:47,580 --> 00:25:55,220
instruction that stops all that finishes

475
00:25:52,260 --> 00:26:00,030
all load and store operation so it

476
00:25:55,220 --> 00:26:02,220
commits all caches a so so that there

477
00:26:00,030 --> 00:26:05,129
are no problems for the road then we

478
00:26:02,220 --> 00:26:08,970
call a special function which

479
00:26:05,130 --> 00:26:10,880
constitutes of many many heavy

480
00:26:08,970 --> 00:26:13,730
instructions from

481
00:26:10,880 --> 00:26:15,950
I'm from Exim my I meant from usually

482
00:26:13,730 --> 00:26:19,220
those are SIMD instructions so that you

483
00:26:15,950 --> 00:26:22,550
could execute regular instructions in

484
00:26:19,220 --> 00:26:24,500
the special block and it takes a lot of

485
00:26:22,550 --> 00:26:26,690
time so that we would trigger

486
00:26:24,500 --> 00:26:30,830
speculative execution also the herring

487
00:26:26,690 --> 00:26:33,590
function usually doesn't return to line

488
00:26:30,830 --> 00:26:35,830
three it just returns to the instructor

489
00:26:33,590 --> 00:26:40,189
to the function which called this gadget

490
00:26:35,830 --> 00:26:42,530
then lines three to five are actually

491
00:26:40,190 --> 00:26:45,230
already in this speculative region so

492
00:26:42,530 --> 00:26:47,120
the first thing we do is we move some

493
00:26:45,230 --> 00:26:49,430
data which will want to send back from

494
00:26:47,120 --> 00:26:52,159
speculative execution to the right just

495
00:26:49,430 --> 00:26:55,940
row by choice then we shift that

496
00:26:52,160 --> 00:26:59,780
register by 12 to align it with the page

497
00:26:55,940 --> 00:27:04,400
size on with the page size for example

498
00:26:59,780 --> 00:27:06,590
in Windows and then we read some data or

499
00:27:04,400 --> 00:27:11,960
at least attempt to read some data from

500
00:27:06,590 --> 00:27:13,669
the desired page from this set of

501
00:27:11,960 --> 00:27:19,730
consecutive stages which are referenced

502
00:27:13,670 --> 00:27:26,570
by our di2 right so here we would look

503
00:27:19,730 --> 00:27:30,850
up the fifth page and as you see on the

504
00:27:26,570 --> 00:27:34,760
screen well if you were to look to

505
00:27:30,850 --> 00:27:36,649
compute and to time the accesses to

506
00:27:34,760 --> 00:27:39,140
different pages in that region for

507
00:27:36,650 --> 00:27:42,200
example if the region consisted of 16

508
00:27:39,140 --> 00:27:43,820
pages the fifth page would have the

509
00:27:42,200 --> 00:27:46,400
lowest access time and from that you

510
00:27:43,820 --> 00:27:49,159
could derive that the fifth page was

511
00:27:46,400 --> 00:27:52,460
accessed and number five was transmitted

512
00:27:49,160 --> 00:27:57,770
through the side channel or well here

513
00:27:52,460 --> 00:28:00,350
through the Travel Channel so we can

514
00:27:57,770 --> 00:28:03,560
send data through from speculative

515
00:28:00,350 --> 00:28:05,209
execution through the cache what was the

516
00:28:03,560 --> 00:28:06,889
problem with mountainous factories that

517
00:28:05,210 --> 00:28:09,950
speculative execution doesn't actually

518
00:28:06,890 --> 00:28:12,860
abide by the rules set by Intel for its

519
00:28:09,950 --> 00:28:16,060
own instructions so the classic case of

520
00:28:12,860 --> 00:28:19,070
meltdown is that memory protections were

521
00:28:16,060 --> 00:28:22,639
handled and especially Carnell mode and

522
00:28:19,070 --> 00:28:24,040
privilege mode protections were handled

523
00:28:22,640 --> 00:28:26,560
only

524
00:28:24,040 --> 00:28:28,620
after it was determined that the

525
00:28:26,560 --> 00:28:31,450
execution reached a certain point so

526
00:28:28,620 --> 00:28:35,260
instead of execution those checks

527
00:28:31,450 --> 00:28:38,860
weren't yet finished and you could send

528
00:28:35,260 --> 00:28:40,210
the data back but so obviously reason

529
00:28:38,860 --> 00:28:44,169
privilege data is awesome

530
00:28:40,210 --> 00:28:46,510
you can but can we use speculative

531
00:28:44,170 --> 00:28:50,970
execution and the cash side channels for

532
00:28:46,510 --> 00:28:53,320
something else well it turns out that

533
00:28:50,970 --> 00:28:55,480
not everything can be executed

534
00:28:53,320 --> 00:28:58,439
speculatively for example you can't

535
00:28:55,480 --> 00:29:00,760
execute interrupt breakpoints

536
00:28:58,440 --> 00:29:04,350
speculatively you can't execute

537
00:29:00,760 --> 00:29:07,960
privileged instructions in user mode and

538
00:29:04,350 --> 00:29:11,919
you usually can't execute instructions

539
00:29:07,960 --> 00:29:13,750
leading to context switches what can we

540
00:29:11,920 --> 00:29:17,800
do with this well for example we can

541
00:29:13,750 --> 00:29:21,510
test if the program we're looking at is

542
00:29:17,800 --> 00:29:25,090
being traced or debug we can detect

543
00:29:21,510 --> 00:29:27,160
these inside the speculatively executed

544
00:29:25,090 --> 00:29:29,290
area the software software breakpoints

545
00:29:27,160 --> 00:29:34,110
but they're usually easily detectable

546
00:29:29,290 --> 00:29:36,280
without that just by reading the just by

547
00:29:34,110 --> 00:29:38,169
accessing the page and reading from it

548
00:29:36,280 --> 00:29:41,680
hardware breakpoints which are usually

549
00:29:38,170 --> 00:29:43,180
harder to detect since you can't just

550
00:29:41,680 --> 00:29:46,150
read from the page and detect them and

551
00:29:43,180 --> 00:29:51,400
page break point which also usually hard

552
00:29:46,150 --> 00:29:59,020
to detect so let me show you how this

553
00:29:51,400 --> 00:30:03,580
works so this is a simple program we see

554
00:29:59,020 --> 00:30:06,100
the speculative you know speculative

555
00:30:03,580 --> 00:30:11,730
gadget which is being accessed it will

556
00:30:06,100 --> 00:30:11,730
be accessed and about ten thousand times

557
00:30:13,650 --> 00:30:22,810
come on yeah we'll see that the

558
00:30:20,770 --> 00:30:31,480
speculative vision was not debug let's

559
00:30:22,810 --> 00:30:34,230
just try that once more okay so there's

560
00:30:31,480 --> 00:30:37,600
no problem at the same time we see that

561
00:30:34,230 --> 00:30:41,380
this know there's this region my

562
00:30:37,600 --> 00:30:47,469
to some garbage instructions we see that

563
00:30:41,380 --> 00:30:50,169
the X is set to seven that Yeats is set

564
00:30:47,470 --> 00:30:53,440
to 7 then it sort with the number of

565
00:30:50,169 --> 00:30:56,740
page who will want to start it started

566
00:30:53,440 --> 00:31:01,770
which is 32 and then shifted to the page

567
00:30:56,740 --> 00:31:01,770
size let's put a simple breakpoint here

568
00:31:06,330 --> 00:31:15,039
and we see that there's a break point

569
00:31:12,000 --> 00:31:18,130
there's a break point and there have

570
00:31:15,039 --> 00:31:20,590
been many cache misses so basically the

571
00:31:18,130 --> 00:31:23,350
execution hasn't reached this particular

572
00:31:20,590 --> 00:31:28,959
point it works with hardware breakpoints

573
00:31:23,350 --> 00:31:30,418
and it works with software by points now

574
00:31:28,960 --> 00:31:34,299
let's talk about virtualization

575
00:31:30,419 --> 00:31:36,460
virtualization is a method well is the

576
00:31:34,299 --> 00:31:38,918
technique which we obviously all use

577
00:31:36,460 --> 00:31:42,370
nowadays it's a simple way to protect

578
00:31:38,919 --> 00:31:44,980
ourselves from malware to use different

579
00:31:42,370 --> 00:31:47,860
operating systems on the same device but

580
00:31:44,980 --> 00:31:50,470
what it comes down in the end to these

581
00:31:47,860 --> 00:31:53,559
two classes of software the virtual

582
00:31:50,470 --> 00:31:56,740
machine monitor which is kind of the

583
00:31:53,559 --> 00:31:59,110
administrator of the virtualization and

584
00:31:56,740 --> 00:32:02,230
different guest software so different

585
00:31:59,110 --> 00:32:05,969
virtual machines the virtual machine

586
00:32:02,230 --> 00:32:08,080
monitor is the one who initializes

587
00:32:05,970 --> 00:32:12,870
virtualization well usually with the

588
00:32:08,080 --> 00:32:15,250
remix on instruction no on until it can

589
00:32:12,870 --> 00:32:19,199
initialize and launch guest

590
00:32:15,250 --> 00:32:21,520
so with setups the guest virtual CPUs it

591
00:32:19,200 --> 00:32:25,890
initialize all the control structures

592
00:32:21,520 --> 00:32:29,918
which handle guest interactions it

593
00:32:25,890 --> 00:32:32,740
activates after guest exit you know

594
00:32:29,919 --> 00:32:36,450
there's a special state where the guest

595
00:32:32,740 --> 00:32:40,240
exits and handles the execution back to

596
00:32:36,450 --> 00:32:42,850
the vmm it controls the state of the

597
00:32:40,240 --> 00:32:46,990
guest after the VM exit so it can make

598
00:32:42,850 --> 00:32:48,668
any changes it likes and afterwards it

599
00:32:46,990 --> 00:32:50,800
can obviously continue that the guest

600
00:32:48,669 --> 00:32:53,260
execution

601
00:32:50,800 --> 00:32:58,090
guess the software usually well unless

602
00:32:53,260 --> 00:33:01,290
it's hyper aware guest operates as if

603
00:32:58,090 --> 00:33:03,699
there's no virtualization it may have

604
00:33:01,290 --> 00:33:07,149
may not have a single clue that is

605
00:33:03,700 --> 00:33:10,120
virtualized and it constantly gives

606
00:33:07,150 --> 00:33:12,850
control back so there's almost no way

607
00:33:10,120 --> 00:33:14,949
there's no way for the guests not to

608
00:33:12,850 --> 00:33:17,830
handle control through a VM exit after

609
00:33:14,950 --> 00:33:22,350
some time so the user the usual

610
00:33:17,830 --> 00:33:26,110
operation is the VM monitor start in

611
00:33:22,350 --> 00:33:28,929
virtualization with the Maxon then hand

612
00:33:26,110 --> 00:33:32,649
in control to guests with the M entry

613
00:33:28,930 --> 00:33:37,240
which is useful VM launch getting the BM

614
00:33:32,650 --> 00:33:39,550
exit from it showing that guest guest

615
00:33:37,240 --> 00:33:41,920
has stopped operating and then either

616
00:33:39,550 --> 00:33:44,740
swooshing it back on closing in forever

617
00:33:41,920 --> 00:33:48,880
or switch in execution back to a

618
00:33:44,740 --> 00:33:52,540
different guest the next thing is

619
00:33:48,880 --> 00:33:54,880
effectively a context switch from guest

620
00:33:52,540 --> 00:33:57,220
software to virtual machine monitor it

621
00:33:54,880 --> 00:34:00,600
can happen in many cases there are too

622
00:33:57,220 --> 00:34:04,450
many to list there are a few pages of

623
00:34:00,600 --> 00:34:08,319
Intel software guide just showing

624
00:34:04,450 --> 00:34:10,899
different cases of VM exiting so one of

625
00:34:08,320 --> 00:34:13,780
the most prominent ones page folds

626
00:34:10,899 --> 00:34:17,020
exceptions etc certain instructions like

627
00:34:13,780 --> 00:34:21,190
cpuid can trigger it since the vm m

628
00:34:17,020 --> 00:34:23,469
usually has to change and spoof date set

629
00:34:21,190 --> 00:34:26,668
so the not to show that the guest it's

630
00:34:23,469 --> 00:34:30,668
been ritualized especially in cases of

631
00:34:26,668 --> 00:34:32,918
malware virtual monitor enzyme our

632
00:34:30,668 --> 00:34:37,089
virtual monitors such as vm ray for

633
00:34:32,918 --> 00:34:38,739
example and usually and the vm m

634
00:34:37,090 --> 00:34:40,450
receives the information about the

635
00:34:38,739 --> 00:34:42,850
instruction the instruction that caused

636
00:34:40,449 --> 00:34:45,580
the the vm exit although sometimes it's

637
00:34:42,850 --> 00:34:47,230
not just an instruction so it gets all

638
00:34:45,580 --> 00:34:52,870
the register states the states of the

639
00:34:47,230 --> 00:34:55,540
memory etc so the usual ways for detects

640
00:34:52,870 --> 00:34:58,120
in hardware virtualization are either

641
00:34:55,540 --> 00:35:03,009
time in vm exit and instructions with

642
00:34:58,120 --> 00:35:04,690
our dtc or party tcp no instructions

643
00:35:03,010 --> 00:35:08,140
such as CPU I do though

644
00:35:04,690 --> 00:35:10,630
many which could trigger a VM exit or

645
00:35:08,140 --> 00:35:13,359
detection microarchitecture show changes

646
00:35:10,630 --> 00:35:16,030
after them exit for example Hotel by

647
00:35:13,359 --> 00:35:19,650
providing or return stack buffer plush

648
00:35:16,030 --> 00:35:24,730
so tell by profiling is usually just

649
00:35:19,650 --> 00:35:28,109
measuring the accesses memory accesses

650
00:35:24,730 --> 00:35:32,230
since gob is changed during the

651
00:35:28,109 --> 00:35:36,299
execution of vm m and the same works for

652
00:35:32,230 --> 00:35:38,559
its own stack buffers since those

653
00:35:36,299 --> 00:35:40,538
microarchitecture changes and the

654
00:35:38,559 --> 00:35:44,710
changes in those particular registers

655
00:35:40,539 --> 00:35:49,119
are not rolled back after the vm m part

656
00:35:44,710 --> 00:35:51,549
is being has been executed so the

657
00:35:49,119 --> 00:35:53,289
problem is with the time in vm x is that

658
00:35:51,549 --> 00:35:54,970
they are quite obvious to a sandbox for

659
00:35:53,289 --> 00:35:56,410
example vm raid attacks them all the

660
00:35:54,970 --> 00:35:59,169
time

661
00:35:56,410 --> 00:36:02,460
our z TSD values can be easily

662
00:35:59,170 --> 00:36:05,200
manipulated there are several ways for

663
00:36:02,460 --> 00:36:07,990
changing them for example you know you

664
00:36:05,200 --> 00:36:12,879
could just handle in such a way that you

665
00:36:07,990 --> 00:36:16,720
change the value all the that you send

666
00:36:12,880 --> 00:36:20,950
the chosen value back to the guests from

667
00:36:16,720 --> 00:36:23,859
your DMM software or you can create a

668
00:36:20,950 --> 00:36:27,460
all for example intel cpus allow you to

669
00:36:23,859 --> 00:36:29,740
set up an equation consisting of

670
00:36:27,460 --> 00:36:34,599
addition and multiplication which

671
00:36:29,740 --> 00:36:40,180
automatically scales RT DTSC from their

672
00:36:34,599 --> 00:36:43,240
real value which comes from the here

673
00:36:40,180 --> 00:36:46,899
from the TSE register on the real cpu to

674
00:36:43,240 --> 00:36:48,819
the virtual value also timing the MX it

675
00:36:46,900 --> 00:36:53,789
can be evaded with the blue chicken-like

676
00:36:48,819 --> 00:36:55,869
techniques so there what is it to detect

677
00:36:53,789 --> 00:36:59,680
microarchitecture change detection is

678
00:36:55,869 --> 00:37:03,640
much harder to evade its can't always be

679
00:36:59,680 --> 00:37:07,690
detected but the main problem with it is

680
00:37:03,640 --> 00:37:09,379
that it usually requires Cpl zero so

681
00:37:07,690 --> 00:37:14,479
this means that

682
00:37:09,380 --> 00:37:19,309
my word which lands on your p.c wouldn't

683
00:37:14,479 --> 00:37:23,149
be able to use those techniques just

684
00:37:19,309 --> 00:37:25,910
because it without elevating its

685
00:37:23,150 --> 00:37:28,789
privileges and go into Turner mode and

686
00:37:25,910 --> 00:37:31,519
that's obviously a problem since it

687
00:37:28,789 --> 00:37:34,309
wouldn't want to show its technique

688
00:37:31,519 --> 00:37:38,538
before it sure that it's not been

689
00:37:34,309 --> 00:37:40,989
monitored the final thing is that we can

690
00:37:38,539 --> 00:37:45,109
use speculative execution as a detector

691
00:37:40,989 --> 00:37:48,549
it turns out that since our DTSC is an

692
00:37:45,109 --> 00:37:52,220
instruction which is usually handled by

693
00:37:48,549 --> 00:37:55,489
the vmm so it produces a VM exit

694
00:37:52,220 --> 00:37:57,919
it can't be executed in speculative it

695
00:37:55,489 --> 00:38:00,710
can't be executed speculatively on a

696
00:37:57,920 --> 00:38:04,819
virtual machine so this code which does

697
00:38:00,710 --> 00:38:07,539
almost the same as which does almost the

698
00:38:04,819 --> 00:38:11,119
same thing as the previously shown one

699
00:38:07,539 --> 00:38:13,759
would only change that here would take

700
00:38:11,119 --> 00:38:17,359
the result of the our DTSC instruction

701
00:38:13,759 --> 00:38:21,430
in the speculative region we limited to

702
00:38:17,359 --> 00:38:24,950
some bits then we scaled

703
00:38:21,430 --> 00:38:27,710
then we moved to a special predetermine

704
00:38:24,950 --> 00:38:30,439
region and aligned it to a page border

705
00:38:27,710 --> 00:38:34,759
and then we read it so that we get a

706
00:38:30,440 --> 00:38:37,719
side channel so those instructions would

707
00:38:34,759 --> 00:38:40,309
stop with our DTSC on a virtual machine

708
00:38:37,719 --> 00:38:43,910
since the CPU doesn't know what to do

709
00:38:40,309 --> 00:38:47,900
with our DTSC it has to handle the

710
00:38:43,910 --> 00:38:50,598
execution to the virtual machine monitor

711
00:38:47,900 --> 00:38:53,900
from the time it sees our GCSE but it's

712
00:38:50,599 --> 00:38:56,469
not yet sure whether the execution will

713
00:38:53,900 --> 00:39:03,440
actually reach this point so there's no

714
00:38:56,469 --> 00:39:07,630
no need to switch it to switch it to the

715
00:39:03,440 --> 00:39:10,519
vmm yet and on non-virtualized the

716
00:39:07,630 --> 00:39:16,749
operating system on with just regular

717
00:39:10,519 --> 00:39:20,750
execution this will easily execute so

718
00:39:16,749 --> 00:39:22,730
basically so what we can do is

719
00:39:20,750 --> 00:39:25,339
for using speculative execution as a

720
00:39:22,730 --> 00:39:27,170
detector is just execute one of the

721
00:39:25,339 --> 00:39:27,920
immensity instructions which can be

722
00:39:27,170 --> 00:39:31,490
speculative

723
00:39:27,920 --> 00:39:33,410
execute in speculative region then

724
00:39:31,490 --> 00:39:39,109
modified the results to fit a certain

725
00:39:33,410 --> 00:39:42,649
range and read from a selected page the

726
00:39:39,109 --> 00:39:44,480
result will be that more I tried with

727
00:39:42,650 --> 00:39:49,099
those two instructions unfortunately a

728
00:39:44,480 --> 00:39:53,089
reader Messara requires Cpl 0fz TSC can

729
00:39:49,099 --> 00:39:56,270
be used from user mode so when we do

730
00:39:53,089 --> 00:39:59,390
this we get two different pictures let

731
00:39:56,270 --> 00:40:04,579
picture is on non-virtualized software

732
00:39:59,390 --> 00:40:07,940
so you get a clear page with the actual

733
00:40:04,579 --> 00:40:11,690
page region where they were where the

734
00:40:07,940 --> 00:40:13,819
accesses are faster than on all the

735
00:40:11,690 --> 00:40:16,310
other pages so you know that our DTSC

736
00:40:13,819 --> 00:40:20,509
has been executed the results of its

737
00:40:16,310 --> 00:40:25,880
execution were the results of its

738
00:40:20,510 --> 00:40:29,000
execution influenced how the page look

739
00:40:25,880 --> 00:40:33,920
ups were handled and on the right you

740
00:40:29,000 --> 00:40:37,359
see the case where the our DTSC was

741
00:40:33,920 --> 00:40:39,710
virtualized and most executed simply in

742
00:40:37,359 --> 00:40:42,920
virtual environment so the execution

743
00:40:39,710 --> 00:40:46,130
stopped there and the accesses are

744
00:40:42,920 --> 00:41:08,859
randomized so the accesses are for the

745
00:40:46,130 --> 00:41:14,750
most part of the of the same speed so

746
00:41:08,859 --> 00:41:17,200
let me show you that this is the same

747
00:41:14,750 --> 00:41:22,670
[Music]

748
00:41:17,200 --> 00:41:29,569
okay ah that's great dear virtualization

749
00:41:22,670 --> 00:41:35,569
so we see that here we have five cache

750
00:41:29,569 --> 00:41:38,569
misses out of ten thousand and here in

751
00:41:35,569 --> 00:41:42,470
the same file on a virtualized machine

752
00:41:38,569 --> 00:41:46,329
produces well most of the cache look up

753
00:41:42,470 --> 00:41:49,299
so actually misses so we see that our

754
00:41:46,329 --> 00:41:54,470
DTSC's virtualized and we assure that

755
00:41:49,300 --> 00:42:01,900
this that were performing in virtualized

756
00:41:54,470 --> 00:42:04,459
environment so what can this detector do

757
00:42:01,900 --> 00:42:07,550
it can obviously answer a simple

758
00:42:04,460 --> 00:42:10,220
question whether you are virtualized or

759
00:42:07,550 --> 00:42:12,310
not you can make it a binary detector

760
00:42:10,220 --> 00:42:15,618
the only problem with that is that

761
00:42:12,310 --> 00:42:21,200
reverse engineer would just easily

762
00:42:15,619 --> 00:42:24,260
switch switch it back at the jump

763
00:42:21,200 --> 00:42:25,879
instruction and it will execute on so it

764
00:42:24,260 --> 00:42:29,300
would protect against automatic

765
00:42:25,880 --> 00:42:33,410
detection but no skewed reverse engineer

766
00:42:29,300 --> 00:42:35,720
would still easily notice it but the

767
00:42:33,410 --> 00:42:38,720
sweet thing about this particular method

768
00:42:35,720 --> 00:42:41,140
is that it can be used to construct and

769
00:42:38,720 --> 00:42:43,490
send different data through the

770
00:42:41,140 --> 00:42:46,279
speculative region and through the side

771
00:42:43,490 --> 00:42:48,859
channel so it can be manipulated in such

772
00:42:46,280 --> 00:42:52,369
a way that you present two sets of data

773
00:42:48,859 --> 00:42:54,470
one for who and you are in a virtualized

774
00:42:52,369 --> 00:42:56,930
State and one when you are not without

775
00:42:54,470 --> 00:43:00,649
producing a cleave it's done in a very

776
00:42:56,930 --> 00:43:01,640
simple way you just create two sets of

777
00:43:00,650 --> 00:43:05,420
data for exam

778
00:43:01,640 --> 00:43:08,390
two sets of two keys one for when you

779
00:43:05,420 --> 00:43:11,240
want to decrypt data in a virtualized

780
00:43:08,390 --> 00:43:15,319
one in non-virtualized display the page

781
00:43:11,240 --> 00:43:18,140
for detection into two sets you embed

782
00:43:15,320 --> 00:43:21,020
the non virtualized data in one of the

783
00:43:18,140 --> 00:43:25,430
cells and which arise in the other so

784
00:43:21,020 --> 00:43:28,160
this in the simplest way is present but

785
00:43:25,430 --> 00:43:31,190
you get this pinch range you actually

786
00:43:28,160 --> 00:43:34,520
get to places where accesses are faster

787
00:43:31,190 --> 00:43:38,900
than in most others but you only pick

788
00:43:34,520 --> 00:43:41,030
the first one of those and in one you

789
00:43:38,900 --> 00:43:44,180
are virtualized the first one doesn't

790
00:43:41,030 --> 00:43:46,760
exist so the blue page region doesn't

791
00:43:44,180 --> 00:43:49,250
exist so you pick the right one and one

792
00:43:46,760 --> 00:43:51,050
your non-virtuous you pick the blue one

793
00:43:49,250 --> 00:43:54,350
you know in the end you have two keys

794
00:43:51,050 --> 00:43:58,820
which can be used to decrypt different

795
00:43:54,350 --> 00:44:02,290
payloads one benign and one malicious so

796
00:43:58,820 --> 00:44:04,460
in the end I have to conclude that

797
00:44:02,290 --> 00:44:07,700
speculative execution can be used to

798
00:44:04,460 --> 00:44:09,980
detect virtualization and tracing and it

799
00:44:07,700 --> 00:44:14,000
can give a real headache to the security

800
00:44:09,980 --> 00:44:15,770
researchers or malware analysts if you

801
00:44:14,000 --> 00:44:21,050
want to try it yourself

802
00:44:15,770 --> 00:44:24,320
there's poke on this address so please

803
00:44:21,050 --> 00:44:27,220
do thanks for your attention

804
00:44:24,320 --> 00:44:27,220
are there any questions

805
00:44:28,670 --> 00:44:33,310
[Music]

806
00:44:28,990 --> 00:44:33,310
[Applause]

807
00:44:39,660 --> 00:45:00,390
[Music]

808
00:44:41,340 --> 00:45:05,010
don't be shy so yeah let's give

809
00:45:00,390 --> 00:45:05,009
innokenty another round of applause

810
00:45:06,230 --> 00:45:09,340
[Music]

