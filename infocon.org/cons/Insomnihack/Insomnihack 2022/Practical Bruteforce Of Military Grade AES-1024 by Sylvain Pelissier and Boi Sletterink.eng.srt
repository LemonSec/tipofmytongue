1
00:00:06,820 --> 00:00:09,869
[Music]

2
00:00:15,120 --> 00:00:17,440
hello so thank you for joining us um

3
00:00:17,440 --> 00:00:19,680
this is already the last talk of the

4
00:00:19,680 --> 00:00:20,800
conference

5
00:00:20,800 --> 00:00:23,279
so to end in a good uh with a good

6
00:00:23,279 --> 00:00:27,039
presentation let's do more crypto

7
00:00:27,039 --> 00:00:29,840
so first of all i'm silva i'm a security

8
00:00:29,840 --> 00:00:32,800
researcher at kudelski security i mainly

9
00:00:32,800 --> 00:00:35,840
work on applied cryptography topics i

10
00:00:35,840 --> 00:00:38,079
used to do hardware attacks and i'm

11
00:00:38,079 --> 00:00:41,280
occasionally a bad ctf player but i

12
00:00:41,280 --> 00:00:43,680
would be happy to to play with you just

13
00:00:43,680 --> 00:00:46,160
after this talk to them to the context

14
00:00:46,160 --> 00:00:48,879
to the contest

15
00:00:49,600 --> 00:00:52,399
my name is boys lettering

16
00:00:52,399 --> 00:00:54,719
yeah i've i'm a security consultant

17
00:00:54,719 --> 00:00:56,239
freelance

18
00:00:56,239 --> 00:00:58,320
and i have a lot of interesting crypto

19
00:00:58,320 --> 00:00:59,920
so sometimes i get nice crypto

20
00:00:59,920 --> 00:01:01,520
assignments and that's where this all

21
00:01:01,520 --> 00:01:03,920
comes from

22
00:01:05,280 --> 00:01:08,400
so first how this project started so one

23
00:01:08,400 --> 00:01:09,680
of my colleagues

24
00:01:09,680 --> 00:01:12,240
came to me with a usb stick containing a

25
00:01:12,240 --> 00:01:14,320
vault encrypted with a sound disk secure

26
00:01:14,320 --> 00:01:15,840
access software

27
00:01:15,840 --> 00:01:17,360
and he told me okay

28
00:01:17,360 --> 00:01:19,200
is it possible to crack this this vault

29
00:01:19,200 --> 00:01:21,439
to recover the data

30
00:01:21,439 --> 00:01:23,600
so i started my research

31
00:01:23,600 --> 00:01:25,119
meanwhile he was able to find the

32
00:01:25,119 --> 00:01:26,400
password

33
00:01:26,400 --> 00:01:29,200
so basically on the post it

34
00:01:29,200 --> 00:01:31,920
so it could have been end of the story

35
00:01:31,920 --> 00:01:34,479
uh obviously it's not so i will explain

36
00:01:34,479 --> 00:01:36,640
you why

37
00:01:36,640 --> 00:01:38,640
so i didn't know sandisk secure access

38
00:01:38,640 --> 00:01:40,640
software at that time

39
00:01:40,640 --> 00:01:42,960
it's a piece of software you find by

40
00:01:42,960 --> 00:01:45,600
default on a sandisk

41
00:01:45,600 --> 00:01:48,240
ssd or usb stick and it's it's quite

42
00:01:48,240 --> 00:01:50,399
convenient you launch the binary and if

43
00:01:50,399 --> 00:01:52,720
you if you enter the correct password

44
00:01:52,720 --> 00:01:55,360
you you have access to the vault you can

45
00:01:55,360 --> 00:01:58,240
copy your data remove your data

46
00:01:58,240 --> 00:02:00,000
it's really something

47
00:02:00,000 --> 00:02:03,200
convenient and perfectly normal so far

48
00:02:03,200 --> 00:02:05,920
but one thing was interesting was that

49
00:02:05,920 --> 00:02:08,720
when i've been to the settings

50
00:02:08,720 --> 00:02:10,959
you could see that you could upgrade the

51
00:02:10,959 --> 00:02:14,800
software and then use as

52
00:02:14,800 --> 00:02:16,280
i mean up to

53
00:02:16,280 --> 00:02:18,319
1024 bit

54
00:02:18,319 --> 00:02:19,560
so

55
00:02:19,560 --> 00:02:21,760
as1024 does not exist it's not

56
00:02:21,760 --> 00:02:23,360
standardized at least it exists because

57
00:02:23,360 --> 00:02:25,360
it's implemented in the solution but

58
00:02:25,360 --> 00:02:27,920
it's not standardized so it started to

59
00:02:27,920 --> 00:02:29,280
interest me

60
00:02:29,280 --> 00:02:31,280
uh what what was implemented in this

61
00:02:31,280 --> 00:02:32,400
solution

62
00:02:32,400 --> 00:02:34,480
so i dig a bit deeper

63
00:02:34,480 --> 00:02:37,599
and i figure out that this solution is

64
00:02:37,599 --> 00:02:39,920
developed by enc security

65
00:02:39,920 --> 00:02:42,640
and they had a really strong security

66
00:02:42,640 --> 00:02:44,400
claim on their website

67
00:02:44,400 --> 00:02:46,160
they say that they use ultimate

68
00:02:46,160 --> 00:02:50,400
encryption using 1024 as keys military

69
00:02:50,400 --> 00:02:51,360
grade

70
00:02:51,360 --> 00:02:54,400
and then when i hear military grade for

71
00:02:54,400 --> 00:02:57,040
a civilian solution i always think about

72
00:02:57,040 --> 00:02:58,319
these tweets

73
00:02:58,319 --> 00:02:59,920
so then i

74
00:02:59,920 --> 00:03:02,720
definitely wanted to know

75
00:03:02,720 --> 00:03:06,560
which algorithm was in this solution

76
00:03:08,640 --> 00:03:11,599
so joe joker parts this was an

77
00:03:11,599 --> 00:03:12,720
interesting

78
00:03:12,720 --> 00:03:14,959
project because

79
00:03:14,959 --> 00:03:17,599
enc developed this software

80
00:03:17,599 --> 00:03:19,920
as a general solution and it's used by

81
00:03:19,920 --> 00:03:23,200
lexar sony and western digital as well

82
00:03:23,200 --> 00:03:25,760
by default on their product to provide

83
00:03:25,760 --> 00:03:27,200
data encryption

84
00:03:27,200 --> 00:03:29,519
but at that time it was not supported by

85
00:03:29,519 --> 00:03:31,760
ashcat nor john the reaper for password

86
00:03:31,760 --> 00:03:33,760
brute force so my colleague basically

87
00:03:33,760 --> 00:03:36,159
could not breed for the password it was

88
00:03:36,159 --> 00:03:38,480
you you had to to create the

89
00:03:38,480 --> 00:03:41,040
the the plugin for that and obviously i

90
00:03:41,040 --> 00:03:42,879
wanted to know if i'm able to to

91
00:03:42,879 --> 00:03:46,359
breakfast as1024

92
00:03:46,640 --> 00:03:49,040
so i started the reverse

93
00:03:49,040 --> 00:03:52,000
it's a p 32-bit binary it was packed

94
00:03:52,000 --> 00:03:55,280
with upex so i could easily unpack it

95
00:03:55,280 --> 00:03:57,120
with a p explorer

96
00:03:57,120 --> 00:04:00,400
there are no further debug protection it

97
00:04:00,400 --> 00:04:02,400
was written in c plus plus compiled with

98
00:04:02,400 --> 00:04:04,480
visual studio and

99
00:04:04,480 --> 00:04:07,040
it uses a qt for the graphic user

100
00:04:07,040 --> 00:04:11,200
interface and open ssl for crypto

101
00:04:11,200 --> 00:04:13,280
there is one there was one thing which

102
00:04:13,280 --> 00:04:15,920
was uh a bit annoying to me it was that

103
00:04:15,920 --> 00:04:18,560
if you execute the binary outside of the

104
00:04:18,560 --> 00:04:21,040
key it will tell you okay uh you're not

105
00:04:21,040 --> 00:04:22,880
allowed to do that

106
00:04:22,880 --> 00:04:24,000
so

107
00:04:24,000 --> 00:04:26,320
since i i didn't have any for example on

108
00:04:26,320 --> 00:04:28,639
the left it's a sunny solution

109
00:04:28,639 --> 00:04:30,960
so i started in the binary to look for

110
00:04:30,960 --> 00:04:34,400
the message and i found a branch just

111
00:04:34,400 --> 00:04:36,720
before the message i found a branch i

112
00:04:36,720 --> 00:04:39,360
blindly patched this instruction i

113
00:04:39,360 --> 00:04:41,360
change it and then the binary would

114
00:04:41,360 --> 00:04:43,680
execute perfectly fine on my on my

115
00:04:43,680 --> 00:04:45,680
computer so it was quite convenient it

116
00:04:45,680 --> 00:04:48,560
reminded me good memories of cracking

117
00:04:48,560 --> 00:04:49,919
uh easy

118
00:04:49,919 --> 00:04:51,680
so it was okay

119
00:04:51,680 --> 00:04:54,320
uh one thing i massively use for this

120
00:04:54,320 --> 00:04:56,880
project is the github function id it's

121
00:04:56,880 --> 00:04:58,639
really convenient when you have an open

122
00:04:58,639 --> 00:04:59,759
source

123
00:04:59,759 --> 00:05:02,400
library you create signature of this

124
00:05:02,400 --> 00:05:05,199
library you apply the signature on your

125
00:05:05,199 --> 00:05:07,600
the binary you're reversing and then

126
00:05:07,600 --> 00:05:09,199
for example it recover a lot of

127
00:05:09,199 --> 00:05:11,520
cryptography function a lot of graphic

128
00:05:11,520 --> 00:05:13,680
user interface

129
00:05:13,680 --> 00:05:15,919
function as well in the in the binary

130
00:05:15,919 --> 00:05:19,919
and it really speed up the the reverse

131
00:05:19,919 --> 00:05:23,120
then i started the dynamic reverse so i

132
00:05:23,120 --> 00:05:24,800
use process monitor

133
00:05:24,800 --> 00:05:28,320
and i i looked at how it uh

134
00:05:28,320 --> 00:05:30,720
it react when i enter a wrong password

135
00:05:30,720 --> 00:05:33,680
and in fact only one file was read uh it

136
00:05:33,680 --> 00:05:35,520
was filesystem.dot

137
00:05:35,520 --> 00:05:37,280
and the password it means that the

138
00:05:37,280 --> 00:05:38,800
password is compared with something

139
00:05:38,800 --> 00:05:41,280
inside this file so this was already um

140
00:05:41,280 --> 00:05:44,160
a good um pass to follow in my reverse

141
00:05:44,160 --> 00:05:45,840
to see how the

142
00:05:45,840 --> 00:05:48,720
the password is checked

143
00:05:48,720 --> 00:05:51,360
if we just step back a bit now

144
00:05:51,360 --> 00:05:53,280
we are trying to reverse a password

145
00:05:53,280 --> 00:05:56,000
hashing algorithm so basically

146
00:05:56,000 --> 00:05:58,639
we want to derive an encryption key from

147
00:05:58,639 --> 00:06:01,440
a password and we then use this

148
00:06:01,440 --> 00:06:04,000
key to encrypt data

149
00:06:04,000 --> 00:06:06,560
so usually we use unique and random salt

150
00:06:06,560 --> 00:06:09,680
to avoid a pre-computed so dictionary or

151
00:06:09,680 --> 00:06:11,520
rainbow table attack

152
00:06:11,520 --> 00:06:13,759
we have a parameter called iteration

153
00:06:13,759 --> 00:06:16,400
number which allow you to adapt uh how

154
00:06:16,400 --> 00:06:18,960
slow a brute forcer will be to to to

155
00:06:18,960 --> 00:06:21,520
breakfast your um

156
00:06:21,520 --> 00:06:22,800
your password

157
00:06:22,800 --> 00:06:26,479
and nowadays uh we use this algorithm

158
00:06:26,479 --> 00:06:29,120
for that so pbk df2 which stands for

159
00:06:29,120 --> 00:06:31,280
password-based key derivation function

160
00:06:31,280 --> 00:06:32,479
2.

161
00:06:32,479 --> 00:06:35,039
balancing is not well known but it's

162
00:06:35,039 --> 00:06:36,800
recommended by nist

163
00:06:36,800 --> 00:06:39,759
script and we have also argon 2 which is

164
00:06:39,759 --> 00:06:42,720
a more modern algorithm it's the winner

165
00:06:42,720 --> 00:06:43,600
of the

166
00:06:43,600 --> 00:06:46,000
ash pass-through dashing competition so

167
00:06:46,000 --> 00:06:48,560
if you are interesting to do more into

168
00:06:48,560 --> 00:06:51,440
this topic i really recommend you um

169
00:06:51,440 --> 00:06:53,440
reading the literature and password

170
00:06:53,440 --> 00:06:55,199
hashing competition it's really

171
00:06:55,199 --> 00:06:56,400
interesting

172
00:06:56,400 --> 00:06:59,039
but for today i will just stick to pbk

173
00:06:59,039 --> 00:07:00,319
df2

174
00:07:00,319 --> 00:07:02,479
the construction is quite simple

175
00:07:02,479 --> 00:07:05,599
you input the password as a key

176
00:07:05,599 --> 00:07:06,960
you input

177
00:07:06,960 --> 00:07:09,280
the salt concatenated with the constant

178
00:07:09,280 --> 00:07:11,919
one and you iterate the hash mark

179
00:07:11,919 --> 00:07:13,840
function c times so c is the number of

180
00:07:13,840 --> 00:07:15,440
iterations in this case

181
00:07:15,440 --> 00:07:18,160
and you obtain a key so it's quite

182
00:07:18,160 --> 00:07:21,360
simple the only problem is okay

183
00:07:21,360 --> 00:07:23,680
i cannot create a key which is larger

184
00:07:23,680 --> 00:07:26,720
than the hash mark output so how i can

185
00:07:26,720 --> 00:07:29,440
create for example a 1024-bit key with

186
00:07:29,440 --> 00:07:30,960
this construction

187
00:07:30,960 --> 00:07:34,400
and this was the problem of pbk df1 and

188
00:07:34,400 --> 00:07:37,280
it was uh so pbk idf2 integrate this

189
00:07:37,280 --> 00:07:39,199
option so basically you run the

190
00:07:39,199 --> 00:07:41,840
algorithm first with the constant one

191
00:07:41,840 --> 00:07:44,560
you say it's my first key then you run

192
00:07:44,560 --> 00:07:46,639
again the same algorithm but with the

193
00:07:46,639 --> 00:07:48,800
constant 2 concatenated with the same

194
00:07:48,800 --> 00:07:52,240
salt you obtain the second key and so on

195
00:07:52,240 --> 00:07:54,000
and at the end you concatenate all the

196
00:07:54,000 --> 00:07:56,639
key you obtained all the keys you obtain

197
00:07:56,639 --> 00:07:59,039
and you have your your um your key for

198
00:07:59,039 --> 00:08:02,639
example if you want 1024-bit key

199
00:08:02,639 --> 00:08:05,039
you iterate eight times this algorithm

200
00:08:05,039 --> 00:08:06,800
and you will have your yoki

201
00:08:06,800 --> 00:08:10,240
so it's perfectly fine so far

202
00:08:10,240 --> 00:08:13,440
so i started uh to reverse this function

203
00:08:13,440 --> 00:08:15,759
so i figure out that

204
00:08:15,759 --> 00:08:18,319
the number of iteration was hard-coded

205
00:08:18,319 --> 00:08:21,520
and it was 1000 and then i had this loop

206
00:08:21,520 --> 00:08:23,440
with this hash function which was not

207
00:08:23,440 --> 00:08:26,639
identified by uh by war function id

208
00:08:26,639 --> 00:08:30,800
so i reverse a bit more uh the algorithm

209
00:08:30,800 --> 00:08:33,279
and i figure out that

210
00:08:33,279 --> 00:08:35,919
the the solution implement this so it

211
00:08:35,919 --> 00:08:37,919
looks like pbk df2

212
00:08:37,919 --> 00:08:40,559
but instead of using hash marks they use

213
00:08:40,559 --> 00:08:42,479
md5

214
00:08:42,479 --> 00:08:44,399
and otherwise it was

215
00:08:44,399 --> 00:08:46,080
almost the same

216
00:08:46,080 --> 00:08:47,519
but one thing

217
00:08:47,519 --> 00:08:49,440
i struggled in the reverse for one thing

218
00:08:49,440 --> 00:08:50,720
it was how

219
00:08:50,720 --> 00:08:53,200
the salt was generated

220
00:08:53,200 --> 00:08:56,080
so i reversed the the code and i found

221
00:08:56,080 --> 00:08:58,160
the string

222
00:08:58,160 --> 00:08:59,760
which looks random

223
00:08:59,760 --> 00:09:01,519
but since it's in the code obviously

224
00:09:01,519 --> 00:09:03,360
it's not unique

225
00:09:03,360 --> 00:09:05,600
and in fact it was the salt

226
00:09:05,600 --> 00:09:08,240
in the in the code

227
00:09:08,240 --> 00:09:10,160
and it was even worse because it was

228
00:09:10,160 --> 00:09:12,800
shared among all vendors so sony lexa

229
00:09:12,800 --> 00:09:14,959
western digital and

230
00:09:14,959 --> 00:09:18,080
sandisk so it was the first problem i

231
00:09:18,080 --> 00:09:20,000
iphone and it's it's not really good

232
00:09:20,000 --> 00:09:21,519
because you can have a precomputed

233
00:09:21,519 --> 00:09:24,240
attack you can create dictionary

234
00:09:24,240 --> 00:09:25,519
and so on

235
00:09:25,519 --> 00:09:28,560
and also a second less important problem

236
00:09:28,560 --> 00:09:30,399
is that the number of iteration is a bit

237
00:09:30,399 --> 00:09:33,680
low for nowadays standard

238
00:09:33,680 --> 00:09:36,160
1000 was good for the beginning when

239
00:09:36,160 --> 00:09:38,000
pbkf2 was out

240
00:09:38,000 --> 00:09:41,279
but now for example oasp recommends 310

241
00:09:41,279 --> 00:09:43,120
000 iteration

242
00:09:43,120 --> 00:09:45,200
for pbk df2

243
00:09:45,200 --> 00:09:47,360
256.

244
00:09:47,360 --> 00:09:48,080
but

245
00:09:48,080 --> 00:09:50,640
if we think a bit more there is a

246
00:09:50,640 --> 00:09:53,279
construction problem with this function

247
00:09:53,279 --> 00:09:55,519
in blue you can see that all the

248
00:09:55,519 --> 00:09:58,160
computation does not depend of the salt

249
00:09:58,160 --> 00:09:59,680
and the constant

250
00:09:59,680 --> 00:10:02,640
so you can compute once this part and

251
00:10:02,640 --> 00:10:05,519
just reuse it for the next step

252
00:10:05,519 --> 00:10:08,000
so it means that you have to compute

253
00:10:08,000 --> 00:10:10,240
this part only once but even though you

254
00:10:10,240 --> 00:10:13,279
can create a dictionary of this part and

255
00:10:13,279 --> 00:10:14,480
it means that

256
00:10:14,480 --> 00:10:16,560
even though even if the salt would have

257
00:10:16,560 --> 00:10:18,480
been random and unique

258
00:10:18,480 --> 00:10:20,880
you can still compute this part and xor

259
00:10:20,880 --> 00:10:23,519
it with the salt and that that works

260
00:10:23,519 --> 00:10:26,320
exactly the same so even if it was close

261
00:10:26,320 --> 00:10:29,440
to pbk df2 it does not achieve the same

262
00:10:29,440 --> 00:10:32,720
security level at all

263
00:10:32,720 --> 00:10:34,720
and basically the difference between

264
00:10:34,720 --> 00:10:38,560
generating uh 128 bit uh compared to one

265
00:10:38,560 --> 00:10:41,760
on a 1024 bit key is simply xor because

266
00:10:41,760 --> 00:10:44,320
you just keep this value in memory and

267
00:10:44,320 --> 00:10:47,279
and you apply it and you can again do a

268
00:10:47,279 --> 00:10:49,600
dictionary attack so it was really a bad

269
00:10:49,600 --> 00:10:52,000
design

270
00:10:52,320 --> 00:10:55,120
so this was for the key generation and

271
00:10:55,120 --> 00:10:57,279
now let's see how the password is

272
00:10:57,279 --> 00:11:00,720
verified uh to be correct so

273
00:11:00,720 --> 00:11:02,160
as i um

274
00:11:02,160 --> 00:11:04,240
explained before uh

275
00:11:04,240 --> 00:11:06,079
it it choose a value store in

276
00:11:06,079 --> 00:11:08,800
filesystem.dot so it's a magic value

277
00:11:08,800 --> 00:11:10,880
which is decrypted and if the value is

278
00:11:10,880 --> 00:11:14,000
d2 c3 b4 a1 then the password is

279
00:11:14,000 --> 00:11:16,000
concerned to be correct so i needed to

280
00:11:16,000 --> 00:11:17,920
figure out okay what is the encryption

281
00:11:17,920 --> 00:11:20,079
algorithm

282
00:11:20,079 --> 00:11:22,480
it was not easy to me because i'm first

283
00:11:22,480 --> 00:11:24,640
i'm not a good reversal but it was used

284
00:11:24,640 --> 00:11:27,279
it was not identified by the draw id

285
00:11:27,279 --> 00:11:29,680
function it was ssc

286
00:11:29,680 --> 00:11:31,040
instruction

287
00:11:31,040 --> 00:11:31,680
the

288
00:11:31,680 --> 00:11:33,839
decompilation was not working good on

289
00:11:33,839 --> 00:11:35,120
that

290
00:11:35,120 --> 00:11:38,000
but i knew at the end it used up an ssl

291
00:11:38,000 --> 00:11:39,519
so i open

292
00:11:39,519 --> 00:11:41,200
open ssl code

293
00:11:41,200 --> 00:11:44,000
and at some point i found a bell script

294
00:11:44,000 --> 00:11:48,000
in openssl which generate assembly which

295
00:11:48,000 --> 00:11:49,760
looks exactly the same as the

296
00:11:49,760 --> 00:11:52,079
instruction i had in my code and in fact

297
00:11:52,079 --> 00:11:53,760
it was just a yes

298
00:11:53,760 --> 00:11:54,639
so

299
00:11:54,639 --> 00:11:55,720
for the

300
00:11:55,720 --> 00:11:57,920
as128 uh

301
00:11:57,920 --> 00:12:00,880
mode option it was simply aes in contour

302
00:12:00,880 --> 00:12:03,120
mode so standard

303
00:12:03,120 --> 00:12:06,920
so then i think okay for as256 it's a is

304
00:12:06,920 --> 00:12:08,560
256

305
00:12:08,560 --> 00:12:10,480
in control mode no problem

306
00:12:10,480 --> 00:12:12,639
but in fact it was not

307
00:12:12,639 --> 00:12:17,440
it was two iteration of as128

308
00:12:17,440 --> 00:12:19,519
but the second key which was generated

309
00:12:19,519 --> 00:12:21,760
by the key direction function the first

310
00:12:21,760 --> 00:12:23,839
half is solved with the nonce before the

311
00:12:23,839 --> 00:12:26,079
encryption otherwise if you serve two

312
00:12:26,079 --> 00:12:27,440
two times the same thing you will have

313
00:12:27,440 --> 00:12:30,000
nothing so don't worry

314
00:12:30,000 --> 00:12:32,880
and then i could figure out how as500 on

315
00:12:32,880 --> 00:12:35,600
112 and as 1024 mode

316
00:12:35,600 --> 00:12:38,560
worked it was just uh four and eight

317
00:12:38,560 --> 00:12:40,600
iteration of

318
00:12:40,600 --> 00:12:45,440
as128 with each time uh the key xor with

319
00:12:45,440 --> 00:12:47,920
the nonce

320
00:12:47,920 --> 00:12:50,120
the the difference between uh

321
00:12:50,120 --> 00:12:53,440
as128 and as 1024

322
00:12:53,440 --> 00:12:56,320
is just the number of iteration of aes

323
00:12:56,320 --> 00:12:58,639
and in addition we just i mean the

324
00:12:58,639 --> 00:13:00,959
software just used half of the of the

325
00:13:00,959 --> 00:13:03,279
key bits generated already

326
00:13:03,279 --> 00:13:05,920
all the qubits are not used for for this

327
00:13:05,920 --> 00:13:07,279
part

328
00:13:07,279 --> 00:13:09,360
and at the end obviously

329
00:13:09,360 --> 00:13:12,000
if you use a weak password it won't help

330
00:13:12,000 --> 00:13:12,959
you to

331
00:13:12,959 --> 00:13:15,839
to have a such a function you you the

332
00:13:15,839 --> 00:13:17,440
the level of security will be linked to

333
00:13:17,440 --> 00:13:19,200
you to the level of security of your

334
00:13:19,200 --> 00:13:21,839
password

335
00:13:22,079 --> 00:13:25,200
so at this point of the project i got

336
00:13:25,200 --> 00:13:27,600
anything i needed to implement

337
00:13:27,600 --> 00:13:30,160
a plugin for john the reaper

338
00:13:30,160 --> 00:13:31,839
so i create a script which will extract

339
00:13:31,839 --> 00:13:33,519
the data

340
00:13:33,519 --> 00:13:36,320
and format it to to join the reaper

341
00:13:36,320 --> 00:13:38,959
as you may notice the magic rod is 32

342
00:13:38,959 --> 00:13:40,720
bits so you may have false positive

343
00:13:40,720 --> 00:13:44,480
after each 2 to the power 32 candidates

344
00:13:44,480 --> 00:13:47,040
but you can filter out this

345
00:13:47,040 --> 00:13:49,360
this falls positive with the second word

346
00:13:49,360 --> 00:13:51,199
which is the number of volts on the disk

347
00:13:51,199 --> 00:13:52,399
encrypted

348
00:13:52,399 --> 00:13:55,279
and so now it is uh integrated in the

349
00:13:55,279 --> 00:13:57,680
main repository of john the reaper so

350
00:13:57,680 --> 00:14:01,839
now everybody is able to brute force as

351
00:14:01,839 --> 00:14:03,040
you can just

352
00:14:03,040 --> 00:14:04,639
use it

353
00:14:04,639 --> 00:14:07,120
just let's see how it runs so it's it's

354
00:14:07,120 --> 00:14:08,639
quite easy uh

355
00:14:08,639 --> 00:14:10,560
you you input the

356
00:14:10,560 --> 00:14:13,360
the hash which the i mean the file which

357
00:14:13,360 --> 00:14:16,480
with the data extracted from the vault

358
00:14:16,480 --> 00:14:18,880
it will run and if your password is in

359
00:14:18,880 --> 00:14:20,720
your password list or if it's brute

360
00:14:20,720 --> 00:14:22,000
first

361
00:14:22,000 --> 00:14:23,920
it will be recovered for this one it

362
00:14:23,920 --> 00:14:24,880
took

363
00:14:24,880 --> 00:14:27,760
only two seconds to to be brought first

364
00:14:27,760 --> 00:14:29,920
because it was in the password list and

365
00:14:29,920 --> 00:14:32,079
john the reaper on the single core

366
00:14:32,079 --> 00:14:33,639
was able to test

367
00:14:33,639 --> 00:14:36,880
7300 passwords per second

368
00:14:36,880 --> 00:14:40,079
which can be compared with pbk df2 with

369
00:14:40,079 --> 00:14:41,920
310 000

370
00:14:41,920 --> 00:14:44,800
iteration to the same password is found

371
00:14:44,800 --> 00:14:46,639
but after two minutes

372
00:14:46,639 --> 00:14:49,120
and john the ripper is able just to test

373
00:14:49,120 --> 00:14:51,279
30 password per second which is really

374
00:14:51,279 --> 00:14:54,079
really uh slow so it will really slow

375
00:14:54,079 --> 00:14:58,680
down a brute force for this algorithm

376
00:14:58,959 --> 00:15:01,680
so then i i had the johnson report

377
00:15:01,680 --> 00:15:03,519
plugin to crack password but one thing

378
00:15:03,519 --> 00:15:04,639
is missing

379
00:15:04,639 --> 00:15:05,839
is okay

380
00:15:05,839 --> 00:15:07,760
as soon as the keys derive

381
00:15:07,760 --> 00:15:09,519
how the file are encrypted in this in

382
00:15:09,519 --> 00:15:11,600
the solution

383
00:15:11,600 --> 00:15:14,079
so in fact it's uh it's quite standard

384
00:15:14,079 --> 00:15:17,040
uh to have a file containing a file

385
00:15:17,040 --> 00:15:19,199
encryption key which are encrypted with

386
00:15:19,199 --> 00:15:20,160
uh

387
00:15:20,160 --> 00:15:23,279
with uh the derived key because if

388
00:15:23,279 --> 00:15:24,959
if the user changes password you don't

389
00:15:24,959 --> 00:15:26,959
want to re-encrypt all the vault so

390
00:15:26,959 --> 00:15:28,079
there are a

391
00:15:28,079 --> 00:15:29,920
file encryption key which are encrypted

392
00:15:29,920 --> 00:15:31,360
with this um

393
00:15:31,360 --> 00:15:33,680
derived key

394
00:15:33,680 --> 00:15:36,399
and i need it so and then this file were

395
00:15:36,399 --> 00:15:37,839
used to encrypt

396
00:15:37,839 --> 00:15:40,639
those files individually so i needed to

397
00:15:40,639 --> 00:15:41,519
know

398
00:15:41,519 --> 00:15:44,639
how it was encrypted and i assume it

399
00:15:44,639 --> 00:15:46,720
uses the same encryption algorithm i

400
00:15:46,720 --> 00:15:48,639
presented before

401
00:15:48,639 --> 00:15:52,720
and it was the case for aes 128 option

402
00:15:52,720 --> 00:15:55,519
it was aes in ctr mode

403
00:15:55,519 --> 00:15:57,519
so i was like okay it's the same for

404
00:15:57,519 --> 00:16:00,240
as256

405
00:16:00,240 --> 00:16:02,480
but i was surprised it didn't work but

406
00:16:02,480 --> 00:16:06,079
it's not exactly the same now the key

407
00:16:06,079 --> 00:16:08,079
the file encryption key is completely

408
00:16:08,079 --> 00:16:11,199
sold uh with the nonce and the counter

409
00:16:11,199 --> 00:16:12,720
so i was like okay

410
00:16:12,720 --> 00:16:15,759
uh why not so then i was like okay for

411
00:16:15,759 --> 00:16:19,079
as 512 it should be for iteration of s

412
00:16:19,079 --> 00:16:20,639
128

413
00:16:20,639 --> 00:16:22,480
and in fact no it was not working like

414
00:16:22,480 --> 00:16:23,360
that

415
00:16:23,360 --> 00:16:26,000
it's only two iterations but they use

416
00:16:26,000 --> 00:16:30,320
only the last the fourth key for as-512

417
00:16:30,320 --> 00:16:31,320
and for

418
00:16:31,320 --> 00:16:35,279
as1024 the ace key so it has only a two

419
00:16:35,279 --> 00:16:37,839
iteration of as100

420
00:16:37,839 --> 00:16:40,560
yeah 128.

421
00:16:40,560 --> 00:16:43,040
i reverse also the file format of the

422
00:16:43,040 --> 00:16:44,959
encrypted file

423
00:16:44,959 --> 00:16:47,920
there is nothing really

424
00:16:47,920 --> 00:16:50,240
surprising the iv is at the beginning of

425
00:16:50,240 --> 00:16:51,759
the file that the version of the

426
00:16:51,759 --> 00:16:52,800
software

427
00:16:52,800 --> 00:16:56,600
a parameter for the asp lan so for means

428
00:16:56,600 --> 00:16:58,560
as1024

429
00:16:58,560 --> 00:17:00,399
then the filename lan

430
00:17:00,399 --> 00:17:02,560
the file name is encrypted

431
00:17:02,560 --> 00:17:05,359
then we have zero and offset

432
00:17:05,359 --> 00:17:07,919
uh at offset 200 we have the start of

433
00:17:07,919 --> 00:17:10,880
the file content

434
00:17:11,919 --> 00:17:12,880
so

435
00:17:12,880 --> 00:17:15,280
from this uh first

436
00:17:15,280 --> 00:17:17,359
it's a ctr design even if we have two

437
00:17:17,359 --> 00:17:20,480
iterations it's a ctr design so if you

438
00:17:20,480 --> 00:17:23,439
sure something to the encrypted file

439
00:17:23,439 --> 00:17:24,880
when you decrypt it you will have

440
00:17:24,880 --> 00:17:26,880
exactly the same modification without

441
00:17:26,880 --> 00:17:28,480
any notice so it's

442
00:17:28,480 --> 00:17:30,400
it's a problem

443
00:17:30,400 --> 00:17:32,559
and also since there is two iteration uh

444
00:17:32,559 --> 00:17:34,360
you have at most

445
00:17:34,360 --> 00:17:36,559
256 uh

446
00:17:36,559 --> 00:17:39,280
bit of security level

447
00:17:39,280 --> 00:17:41,200
because you will have to break first the

448
00:17:41,200 --> 00:17:43,200
key and the

449
00:17:43,200 --> 00:17:46,480
the second key which is xor with the iv

450
00:17:46,480 --> 00:17:50,880
so yeah it's 256 bit of security at most

451
00:17:50,880 --> 00:17:53,039
but if we do some math

452
00:17:53,039 --> 00:17:55,120
so sorry it's a bit late for that but it

453
00:17:55,120 --> 00:17:57,120
will be quick

454
00:17:57,120 --> 00:17:58,960
assume we have two plain text which are

455
00:17:58,960 --> 00:18:00,559
zero

456
00:18:00,559 --> 00:18:03,760
we can write the encryption equation so

457
00:18:03,760 --> 00:18:06,080
the first ciphertext is equal to the

458
00:18:06,080 --> 00:18:09,039
encryption of the first iv star with the

459
00:18:09,039 --> 00:18:11,360
encryption of the first iv start with

460
00:18:11,360 --> 00:18:12,799
the last key

461
00:18:12,799 --> 00:18:15,280
and exactly the same for the second

462
00:18:15,280 --> 00:18:16,640
cipher text

463
00:18:16,640 --> 00:18:18,480
the plaintext are not involved because

464
00:18:18,480 --> 00:18:21,520
we we assume they are zero

465
00:18:21,520 --> 00:18:23,440
and then if we

466
00:18:23,440 --> 00:18:25,200
decrypt

467
00:18:25,200 --> 00:18:27,679
each part and we saw them together we'll

468
00:18:27,679 --> 00:18:29,919
have on the left this equation which

469
00:18:29,919 --> 00:18:31,280
depends only

470
00:18:31,280 --> 00:18:34,000
on k1 the first key

471
00:18:34,000 --> 00:18:36,400
and on the right part we have the xor of

472
00:18:36,400 --> 00:18:39,520
the two iv ivs which are known

473
00:18:39,520 --> 00:18:41,919
so it means we can theoretically brute

474
00:18:41,919 --> 00:18:45,840
force the left part on 128 bits

475
00:18:45,840 --> 00:18:46,960
until we

476
00:18:46,960 --> 00:18:48,640
figure out

477
00:18:48,640 --> 00:18:51,600
we have the value we expect on the right

478
00:18:51,600 --> 00:18:54,960
so it reduces the security to even 128

479
00:18:54,960 --> 00:19:00,720
bit but wait i assume i have

480
00:19:00,799 --> 00:19:02,880
plain text equals zero

481
00:19:02,880 --> 00:19:04,720
but in fact it is the case because if

482
00:19:04,720 --> 00:19:07,360
you remember well in the file format i

483
00:19:07,360 --> 00:19:09,360
have lots of zeros which are encrypted

484
00:19:09,360 --> 00:19:11,679
in between the file name and the file

485
00:19:11,679 --> 00:19:14,000
content so this reduction

486
00:19:14,000 --> 00:19:16,400
uh applied to this solution so it's at

487
00:19:16,400 --> 00:19:18,799
most 128 bit

488
00:19:18,799 --> 00:19:20,960
security

489
00:19:20,960 --> 00:19:23,200
so it's all for me

490
00:19:23,200 --> 00:19:25,440
i disclose

491
00:19:25,440 --> 00:19:28,880
all the findings to enc security so that

492
00:19:28,880 --> 00:19:31,120
knowledge so it was uh yeah may last

493
00:19:31,120 --> 00:19:34,320
year that knowledge the vulnerabilities

494
00:19:34,320 --> 00:19:36,240
uh the vulnerabilities were disclosed to

495
00:19:36,240 --> 00:19:39,280
the manufacturer as well i got a first

496
00:19:39,280 --> 00:19:42,640
meeting with enc security to agree on a

497
00:19:42,640 --> 00:19:45,120
deadline to patch the problem i received

498
00:19:45,120 --> 00:19:47,039
two cv one for the key derivation

499
00:19:47,039 --> 00:19:48,640
problem one for the

500
00:19:48,640 --> 00:19:50,960
file malleability problem

501
00:19:50,960 --> 00:19:52,720
then we had more meeting with nc

502
00:19:52,720 --> 00:19:54,080
security

503
00:19:54,080 --> 00:19:56,320
and uh we as they figure out that the

504
00:19:56,320 --> 00:19:59,039
key derivation function is using other

505
00:19:59,039 --> 00:20:00,799
western digital applications so we

506
00:20:00,799 --> 00:20:03,280
extend a bit the the deadline and

507
00:20:03,280 --> 00:20:05,840
finally in december

508
00:20:05,840 --> 00:20:07,600
access software a new version of secure

509
00:20:07,600 --> 00:20:09,760
access software um

510
00:20:09,760 --> 00:20:10,960
is released

511
00:20:10,960 --> 00:20:12,880
and it's now available

512
00:20:12,880 --> 00:20:15,600
and also i integrate the new key

513
00:20:15,600 --> 00:20:17,120
derivation function

514
00:20:17,120 --> 00:20:19,520
into john the reaper so you can refer

515
00:20:19,520 --> 00:20:21,480
the new aes

516
00:20:21,480 --> 00:20:24,240
1024-bit version with john the reaper as

517
00:20:24,240 --> 00:20:26,240
well

518
00:20:26,240 --> 00:20:28,720
so that's it for me and now i will let

519
00:20:28,720 --> 00:20:30,080
by uh

520
00:20:30,080 --> 00:20:31,520
explain his

521
00:20:31,520 --> 00:20:35,760
side of the of the story so

522
00:20:35,760 --> 00:20:37,760
thank you so far

523
00:20:37,760 --> 00:20:38,960
yeah

524
00:20:38,960 --> 00:20:41,200
so um

525
00:20:41,200 --> 00:20:42,640
as an overview

526
00:20:42,640 --> 00:20:44,480
i'm gonna talk about our side of the

527
00:20:44,480 --> 00:20:46,960
story from enc point of view some events

528
00:20:46,960 --> 00:20:49,280
that we had challenges choices that we

529
00:20:49,280 --> 00:20:52,640
made and how we got to those choices

530
00:20:52,640 --> 00:20:54,000
at first i'm going to give you a little

531
00:20:54,000 --> 00:20:55,679
bit of background the company has been

532
00:20:55,679 --> 00:20:58,080
around since 2009 so it's been there for

533
00:20:58,080 --> 00:21:00,000
quite a while

534
00:21:00,000 --> 00:21:01,520
currently it's based mostly in the

535
00:21:01,520 --> 00:21:03,200
netherlands

536
00:21:03,200 --> 00:21:06,799
as you can hear i'm from the netherlands

537
00:21:06,799 --> 00:21:08,559
we actually have millions of people

538
00:21:08,559 --> 00:21:10,400
using our software but that's mostly

539
00:21:10,400 --> 00:21:13,360
because we have made oem versions that

540
00:21:13,360 --> 00:21:16,799
are delivered on usb sticks and those

541
00:21:16,799 --> 00:21:20,640
oem versions they come from sandisk sony

542
00:21:20,640 --> 00:21:22,240
and lexar

543
00:21:22,240 --> 00:21:25,039
and soundisc is has been bought by

544
00:21:25,039 --> 00:21:26,799
western digital so that's effectively

545
00:21:26,799 --> 00:21:28,880
western digital and they're actually the

546
00:21:28,880 --> 00:21:31,760
only paying customer uh big customer

547
00:21:31,760 --> 00:21:33,440
that we have right now

548
00:21:33,440 --> 00:21:35,840
and sony and lexar are not paying for

549
00:21:35,840 --> 00:21:37,760
updates or anything anymore

550
00:21:37,760 --> 00:21:40,799
um however sony did respond to

551
00:21:40,799 --> 00:21:42,960
uh to the requests and they said yeah we

552
00:21:42,960 --> 00:21:45,120
please we would like to have an update

553
00:21:45,120 --> 00:21:46,799
when you've got it we never heard

554
00:21:46,799 --> 00:21:50,000
anything from lexar even though we tried

555
00:21:50,000 --> 00:21:51,200
on the other hand

556
00:21:51,200 --> 00:21:53,679
we've been in very close cooperation

557
00:21:53,679 --> 00:21:55,760
with western digital to get this stuff

558
00:21:55,760 --> 00:21:58,559
fixed

559
00:21:58,559 --> 00:21:59,520
so

560
00:21:59,520 --> 00:22:02,720
um actually for me

561
00:22:02,799 --> 00:22:04,720
from my side of the story i want to go

562
00:22:04,720 --> 00:22:07,039
slightly more back than than

563
00:22:07,039 --> 00:22:09,440
in the sense that i was first involved

564
00:22:09,440 --> 00:22:12,799
with enc around april 2021

565
00:22:12,799 --> 00:22:14,240
because they wanted to have a security

566
00:22:14,240 --> 00:22:16,640
assessment of the software

567
00:22:16,640 --> 00:22:19,200
it was a fairly simple assessment

568
00:22:19,200 --> 00:22:21,760
and i found some stuff in it i reported

569
00:22:21,760 --> 00:22:22,480
it

570
00:22:22,480 --> 00:22:24,799
and they said thank you we're going to

571
00:22:24,799 --> 00:22:27,840
fix it and two months later i suddenly

572
00:22:27,840 --> 00:22:29,120
got a call

573
00:22:29,120 --> 00:22:30,880
yeah um

574
00:22:30,880 --> 00:22:33,520
there's this guy sofia

575
00:22:33,520 --> 00:22:36,400
he uh he said he found stuff in our

576
00:22:36,400 --> 00:22:38,400
software is this real do you have time

577
00:22:38,400 --> 00:22:41,360
to look at that sure

578
00:22:41,360 --> 00:22:44,480
so yeah then and then all of the events

579
00:22:44,480 --> 00:22:46,400
in the timeline here

580
00:22:46,400 --> 00:22:48,000
they they happened

581
00:22:48,000 --> 00:22:50,320
um

582
00:22:50,480 --> 00:22:52,799
so the first thing that they asked me

583
00:22:52,799 --> 00:22:56,000
was okay so is this report for real

584
00:22:56,000 --> 00:22:59,200
because you've got a nice looking report

585
00:22:59,200 --> 00:23:00,960
made by a guy who you don't know and

586
00:23:00,960 --> 00:23:03,360
he's claiming all kinds of things

587
00:23:03,360 --> 00:23:04,559
some of the things were actually not

588
00:23:04,559 --> 00:23:05,840
very surprising because they were

589
00:23:05,840 --> 00:23:09,919
basically the same as i found i i used a

590
00:23:09,919 --> 00:23:11,760
lot simpler approach by the way i did

591
00:23:11,760 --> 00:23:14,080
not do any reverse engineering i asked

592
00:23:14,080 --> 00:23:15,440
some questions and got to some

593
00:23:15,440 --> 00:23:17,520
conclusions and actually the ciphertext

594
00:23:17,520 --> 00:23:19,280
and the ability i did try for myself

595
00:23:19,280 --> 00:23:20,799
because it's fairly simple with a hex

596
00:23:20,799 --> 00:23:23,679
editor if you know what the plain text

597
00:23:23,679 --> 00:23:24,960
is already

598
00:23:24,960 --> 00:23:27,200
um so what the first thing that i did is

599
00:23:27,200 --> 00:23:29,919
i i googled for sylvan because i didn't

600
00:23:29,919 --> 00:23:31,120
know him

601
00:23:31,120 --> 00:23:34,000
and then okay so that okay looks serious

602
00:23:34,000 --> 00:23:35,760
looks like you know he's

603
00:23:35,760 --> 00:23:37,360
he's doing this kind of stuff that makes

604
00:23:37,360 --> 00:23:40,000
sense i looked at the report it looked

605
00:23:40,000 --> 00:23:41,440
very well written

606
00:23:41,440 --> 00:23:42,960
um

607
00:23:42,960 --> 00:23:44,720
it was also specific to our product so

608
00:23:44,720 --> 00:23:47,039
it's not like a random scan or source

609
00:23:47,039 --> 00:23:50,080
code or binary analysis with some some

610
00:23:50,080 --> 00:23:51,679
tool and then

611
00:23:51,679 --> 00:23:53,440
auto-generate a report or anything like

612
00:23:53,440 --> 00:23:56,240
that so that that's a good indicator

613
00:23:56,240 --> 00:23:57,760
um

614
00:23:57,760 --> 00:24:00,320
it confirmed the the vulnerabilities

615
00:24:00,320 --> 00:24:04,159
that i already found or well

616
00:24:04,159 --> 00:24:06,960
made made probable by just asking

617
00:24:06,960 --> 00:24:08,159
questions

618
00:24:08,159 --> 00:24:09,039
um

619
00:24:09,039 --> 00:24:11,039
and also his terminology in the report

620
00:24:11,039 --> 00:24:13,039
and the evidence he presented was really

621
00:24:13,039 --> 00:24:15,279
convincing so i was like okay yeah sorry

622
00:24:15,279 --> 00:24:17,120
to say but this is for real you've got

623
00:24:17,120 --> 00:24:18,559
to take this serious

624
00:24:18,559 --> 00:24:20,240
so yeah

625
00:24:20,240 --> 00:24:21,200
all right

626
00:24:21,200 --> 00:24:22,000
so

627
00:24:22,000 --> 00:24:23,919
they asked me can you then please help

628
00:24:23,919 --> 00:24:27,039
us to fix these issues

629
00:24:27,039 --> 00:24:29,600
so i did

630
00:24:29,760 --> 00:24:31,679
i helped fix the issues

631
00:24:31,679 --> 00:24:34,240
right now i'm not that actively involved

632
00:24:34,240 --> 00:24:36,640
with enc anymore i'm still there

633
00:24:36,640 --> 00:24:38,880
for for questions about uh

634
00:24:38,880 --> 00:24:42,880
encryption mostly and some other advice

635
00:24:42,880 --> 00:24:44,640
but in between i

636
00:24:44,640 --> 00:24:48,080
i was the the technical lead for uh

637
00:24:48,080 --> 00:24:50,080
implementing the changes

638
00:24:50,080 --> 00:24:52,960
okay so this sounds easy right just use

639
00:24:52,960 --> 00:24:55,200
a new key derivation function

640
00:24:55,200 --> 00:24:57,360
and just use something else something

641
00:24:57,360 --> 00:24:58,960
else to fix the the ciphertext

642
00:24:58,960 --> 00:25:01,679
reliability because these things are not

643
00:25:01,679 --> 00:25:03,440
new problems and there are proven

644
00:25:03,440 --> 00:25:04,960
solutions to this

645
00:25:04,960 --> 00:25:07,039
so it sounds easy and it always sounds

646
00:25:07,039 --> 00:25:10,159
easy if you don't have to do it yourself

647
00:25:10,159 --> 00:25:11,600
you probably

648
00:25:11,600 --> 00:25:13,760
once or twice had a situation where your

649
00:25:13,760 --> 00:25:14,960
manager thought that something would

650
00:25:14,960 --> 00:25:16,880
take only an hour

651
00:25:16,880 --> 00:25:18,960
yeah

652
00:25:18,960 --> 00:25:21,520
so the company was actually in

653
00:25:21,520 --> 00:25:24,640
sort of like a maintenance mode so

654
00:25:24,640 --> 00:25:27,200
before there has been a lot of

655
00:25:27,200 --> 00:25:29,520
development in the software

656
00:25:29,520 --> 00:25:31,360
but right now the company was actually

657
00:25:31,360 --> 00:25:33,520
in a maintenance mode which meant

658
00:25:33,520 --> 00:25:34,320
only

659
00:25:34,320 --> 00:25:35,760
small changes

660
00:25:35,760 --> 00:25:37,039
bug fixes

661
00:25:37,039 --> 00:25:39,360
not very much development so it also

662
00:25:39,360 --> 00:25:42,799
included a small team

663
00:25:42,799 --> 00:25:44,960
yeah and suddenly we had to do more

664
00:25:44,960 --> 00:25:46,320
things

665
00:25:46,320 --> 00:25:48,400
which made it hard

666
00:25:48,400 --> 00:25:50,720
we now had to like increase our team

667
00:25:50,720 --> 00:25:54,159
size make a plan come up with a design

668
00:25:54,159 --> 00:25:55,919
we had to take a look at the bugs and

669
00:25:55,919 --> 00:25:58,480
and set priorities for fixing them and

670
00:25:58,480 --> 00:26:00,640
we also had to work more closely with

671
00:26:00,640 --> 00:26:04,559
with western digital than we did before

672
00:26:05,360 --> 00:26:08,159
so this upscaling thing yeah imagine

673
00:26:08,159 --> 00:26:09,679
that you need

674
00:26:09,679 --> 00:26:11,840
new programmers

675
00:26:11,840 --> 00:26:14,959
in summer holiday

676
00:26:15,120 --> 00:26:16,799
and you want them actually next week if

677
00:26:16,799 --> 00:26:19,919
possible that that was hard so we did

678
00:26:19,919 --> 00:26:21,520
manage to find some people including

679
00:26:21,520 --> 00:26:24,159
myself i'm not actively programming

680
00:26:24,159 --> 00:26:25,360
anymore

681
00:26:25,360 --> 00:26:26,880
but i can look at the code which is

682
00:26:26,880 --> 00:26:29,120
really helpful because i also found some

683
00:26:29,120 --> 00:26:31,760
minor bugs

684
00:26:32,080 --> 00:26:35,440
and i can review other people's work

685
00:26:35,440 --> 00:26:37,840
but i was working part time for this

686
00:26:37,840 --> 00:26:39,840
company because as a freelancer i

687
00:26:39,840 --> 00:26:41,520
sometimes have different assignments at

688
00:26:41,520 --> 00:26:43,200
the same time

689
00:26:43,200 --> 00:26:45,440
and the other hands that we also found

690
00:26:45,440 --> 00:26:47,919
were also part-time so yeah we had more

691
00:26:47,919 --> 00:26:49,440
people but we didn't have that much

692
00:26:49,440 --> 00:26:52,760
extra capacity

693
00:26:53,039 --> 00:26:55,520
then the next step we took really was

694
00:26:55,520 --> 00:26:58,159
some triage how bad are these findings

695
00:26:58,159 --> 00:27:00,880
really how how bad are they impacting

696
00:27:00,880 --> 00:27:02,400
our customers

697
00:27:02,400 --> 00:27:04,400
now for the key derivation function that

698
00:27:04,400 --> 00:27:06,640
is actually quite easy

699
00:27:06,640 --> 00:27:09,679
it's not good at all it's a bad thing so

700
00:27:09,679 --> 00:27:11,760
we want to have that fixed as soon as

701
00:27:11,760 --> 00:27:13,039
possible

702
00:27:13,039 --> 00:27:15,120
and we looked at the ciphertext movie

703
00:27:15,120 --> 00:27:17,440
ability and if you look at that i'm

704
00:27:17,440 --> 00:27:19,440
going to explain that later but it's it

705
00:27:19,440 --> 00:27:22,640
is not as bad as the key derivation

706
00:27:22,640 --> 00:27:23,679
issue

707
00:27:23,679 --> 00:27:25,360
so we were going to do that later and

708
00:27:25,360 --> 00:27:28,399
have a stage approach

709
00:27:29,120 --> 00:27:30,880
then we had to make a choice on what

710
00:27:30,880 --> 00:27:32,399
kind of key derivation function we were

711
00:27:32,399 --> 00:27:34,159
going to use

712
00:27:34,159 --> 00:27:35,360
and there are several options and

713
00:27:35,360 --> 00:27:38,320
software already mentioned them

714
00:27:38,320 --> 00:27:41,120
and we looked at things like performance

715
00:27:41,120 --> 00:27:43,360
security the time and effort needed to

716
00:27:43,360 --> 00:27:45,440
to implement the stuff

717
00:27:45,440 --> 00:27:48,159
but also compatibility we had to find a

718
00:27:48,159 --> 00:27:50,720
way to to you know for the new software

719
00:27:50,720 --> 00:27:52,880
to open the old folds

720
00:27:52,880 --> 00:27:54,159
um

721
00:27:54,159 --> 00:27:56,480
we also had to take usability into

722
00:27:56,480 --> 00:27:58,159
accounts and we really wanted to make

723
00:27:58,159 --> 00:27:59,919
sure that people were using the new

724
00:27:59,919 --> 00:28:01,200
version and

725
00:28:01,200 --> 00:28:04,960
have the the new kdf in place so that

726
00:28:04,960 --> 00:28:06,640
they were not using it in a

727
00:28:06,640 --> 00:28:08,240
compatibility mode or something like

728
00:28:08,240 --> 00:28:11,200
that and in the end we just made it

729
00:28:11,200 --> 00:28:13,840
not possible because if you open an old

730
00:28:13,840 --> 00:28:16,320
fault with the new software it will

731
00:28:16,320 --> 00:28:18,880
upgrade it immediately right because you

732
00:28:18,880 --> 00:28:20,480
can just use the password that you just

733
00:28:20,480 --> 00:28:22,000
entered

734
00:28:22,000 --> 00:28:24,000
it it knows it's an old sound fault it

735
00:28:24,000 --> 00:28:26,000
can open it and then it will just write

736
00:28:26,000 --> 00:28:28,960
new headers so that you uh

737
00:28:28,960 --> 00:28:32,640
you now have a more secure fault

738
00:28:34,159 --> 00:28:37,039
we also had several options

739
00:28:37,039 --> 00:28:38,240
and

740
00:28:38,240 --> 00:28:39,520
we looked at that

741
00:28:39,520 --> 00:28:43,039
and in the end we decided to use pbk df2

742
00:28:43,039 --> 00:28:46,640
256 simply because it was available in

743
00:28:46,640 --> 00:28:49,679
openssl which we were already using

744
00:28:49,679 --> 00:28:51,520
the other

745
00:28:51,520 --> 00:28:52,880
alternatives

746
00:28:52,880 --> 00:28:55,279
i mean i personally i like them better

747
00:28:55,279 --> 00:28:56,799
in the sense that they're also memory

748
00:28:56,799 --> 00:28:59,679
hard so you can't really easily

749
00:28:59,679 --> 00:29:01,520
accelerate them with a graphics card

750
00:29:01,520 --> 00:29:03,679
with fpgas or asics

751
00:29:03,679 --> 00:29:07,679
with bbk df2 that is possible

752
00:29:08,240 --> 00:29:09,360
but yeah

753
00:29:09,360 --> 00:29:12,080
due to time constraints we decided to go

754
00:29:12,080 --> 00:29:15,199
with pbk df2

755
00:29:15,520 --> 00:29:17,520
so we had some more challenges when we

756
00:29:17,520 --> 00:29:19,279
finally decided on that

757
00:29:19,279 --> 00:29:21,039
um well finally

758
00:29:21,039 --> 00:29:23,520
it didn't take like a long long time but

759
00:29:23,520 --> 00:29:25,679
it took some time

760
00:29:25,679 --> 00:29:27,840
so as i mentioned before we had limited

761
00:29:27,840 --> 00:29:29,360
team capacity

762
00:29:29,360 --> 00:29:31,440
but we're also a new team so we had to

763
00:29:31,440 --> 00:29:33,919
get to know each other we had to to tune

764
00:29:33,919 --> 00:29:35,279
our schedules

765
00:29:35,279 --> 00:29:37,679
because if we also have other stuff to

766
00:29:37,679 --> 00:29:39,760
do you know you need to tune your

767
00:29:39,760 --> 00:29:42,880
schedules and this was actually if you

768
00:29:42,880 --> 00:29:44,480
look at our extended team that also

769
00:29:44,480 --> 00:29:46,480
include people from western digital

770
00:29:46,480 --> 00:29:48,720
because we also had to meet with them on

771
00:29:48,720 --> 00:29:50,720
at least a weekly basis and sometimes

772
00:29:50,720 --> 00:29:52,399
even more often

773
00:29:52,399 --> 00:29:53,440
and

774
00:29:53,440 --> 00:29:54,960
some of the people from western digital

775
00:29:54,960 --> 00:29:57,120
were in india and other people were in

776
00:29:57,120 --> 00:29:59,120
the u.s

777
00:29:59,120 --> 00:30:00,960
so you can see that that might pose a

778
00:30:00,960 --> 00:30:02,640
challenge

779
00:30:02,640 --> 00:30:03,360
and

780
00:30:03,360 --> 00:30:05,279
at some point for example i found out

781
00:30:05,279 --> 00:30:07,919
that for us like four o'clock in the

782
00:30:07,919 --> 00:30:09,760
afternoon was a good time

783
00:30:09,760 --> 00:30:11,600
and then i found out but for the guys in

784
00:30:11,600 --> 00:30:13,279
india that's like nine o'clock in the

785
00:30:13,279 --> 00:30:15,120
aft at night so

786
00:30:15,120 --> 00:30:17,039
you know we rescheduled stuff too early

787
00:30:17,039 --> 00:30:19,279
in the morning which was fine as long as

788
00:30:19,279 --> 00:30:20,880
he did not have

789
00:30:20,880 --> 00:30:22,880
one of their american colleagues on in

790
00:30:22,880 --> 00:30:25,440
the call as well

791
00:30:25,440 --> 00:30:27,520
then there were holidays and festivities

792
00:30:27,520 --> 00:30:31,279
that would take extra time

793
00:30:31,600 --> 00:30:33,120
people getting sick

794
00:30:33,120 --> 00:30:35,200
not surprising in that period of time i

795
00:30:35,200 --> 00:30:37,760
mean it was 20 21

796
00:30:37,760 --> 00:30:38,720
and we

797
00:30:38,720 --> 00:30:40,640
it took some more time than we thought

798
00:30:40,640 --> 00:30:42,799
to prepare statements and and

799
00:30:42,799 --> 00:30:45,520
documentation for the user etc

800
00:30:45,520 --> 00:30:46,799
um

801
00:30:46,799 --> 00:30:49,279
those are all things that i think we

802
00:30:49,279 --> 00:30:52,159
underestimated

803
00:30:52,320 --> 00:30:53,600
then there are some

804
00:30:53,600 --> 00:30:56,399
other challenges that we faced

805
00:30:56,399 --> 00:30:59,039
turned out that apple came out with a

806
00:30:59,039 --> 00:31:02,000
new macos version monterey

807
00:31:02,000 --> 00:31:04,960
and that broke our code so we had to

808
00:31:04,960 --> 00:31:06,480
make a fix for that

809
00:31:06,480 --> 00:31:08,320
that wasn't really that easy in the

810
00:31:08,320 --> 00:31:09,760
beginning in the end it worked out fine

811
00:31:09,760 --> 00:31:11,679
i think um

812
00:31:11,679 --> 00:31:14,720
and then also google decided to upgrade

813
00:31:14,720 --> 00:31:16,320
their security requirements for the play

814
00:31:16,320 --> 00:31:20,480
store so there was an api version update

815
00:31:20,480 --> 00:31:22,640
and you just could not publish new

816
00:31:22,640 --> 00:31:25,360
versions of software if you did not use

817
00:31:25,360 --> 00:31:28,159
that new api version

818
00:31:28,159 --> 00:31:31,200
that broke our code

819
00:31:31,519 --> 00:31:34,720
so yeah that was kind of annoying

820
00:31:34,720 --> 00:31:36,960
we also had to fight scope creep simply

821
00:31:36,960 --> 00:31:38,960
because there were also some more bug

822
00:31:38,960 --> 00:31:41,519
fixes outstanding and feature requests

823
00:31:41,519 --> 00:31:42,640
um

824
00:31:42,640 --> 00:31:44,240
and yeah when you're going to make a new

825
00:31:44,240 --> 00:31:46,320
release soon why not include them well

826
00:31:46,320 --> 00:31:50,080
because it makes it harder to do it soon

827
00:31:51,279 --> 00:31:53,840
yeah the the default upgrade approach i

828
00:31:53,840 --> 00:31:56,960
i just discussed uh so are we going to

829
00:31:56,960 --> 00:31:58,320
make it

830
00:31:58,320 --> 00:32:00,399
voluntary for people so that we just

831
00:32:00,399 --> 00:32:02,480
present them with a pop-up saying like

832
00:32:02,480 --> 00:32:04,320
you can upgrade your vault would you

833
00:32:04,320 --> 00:32:06,159
like to do this

834
00:32:06,159 --> 00:32:08,320
and we decided against that so we we

835
00:32:08,320 --> 00:32:10,480
just always upgrade the fault just to

836
00:32:10,480 --> 00:32:13,519
make sure that people do it

837
00:32:13,519 --> 00:32:14,799
um

838
00:32:14,799 --> 00:32:16,480
we had some limitations in our testing

839
00:32:16,480 --> 00:32:17,760
capability

840
00:32:17,760 --> 00:32:20,320
and that is

841
00:32:20,320 --> 00:32:22,080
on the desktop side for the product that

842
00:32:22,080 --> 00:32:23,840
you've you've seen

843
00:32:23,840 --> 00:32:25,600
there was that was also an issue because

844
00:32:25,600 --> 00:32:27,519
we didn't have uh

845
00:32:27,519 --> 00:32:30,640
dedicated testers at the time

846
00:32:30,640 --> 00:32:33,039
but there's some more complexity here

847
00:32:33,039 --> 00:32:34,880
because we did not

848
00:32:34,880 --> 00:32:36,559
have access to all of the code because

849
00:32:36,559 --> 00:32:38,080
western digital developed mobile

850
00:32:38,080 --> 00:32:41,120
applications and they tested that part

851
00:32:41,120 --> 00:32:43,039
so that

852
00:32:43,039 --> 00:32:44,320
you know you can you can probably

853
00:32:44,320 --> 00:32:47,679
imagine that some of the after testing

854
00:32:47,679 --> 00:32:49,279
you find a problem and then you don't

855
00:32:49,279 --> 00:32:51,120
know is it in my part or is it in your

856
00:32:51,120 --> 00:32:52,080
part

857
00:32:52,080 --> 00:32:52,880
so

858
00:32:52,880 --> 00:32:56,559
that was a bit hard at times

859
00:32:56,559 --> 00:32:59,760
to give you an indication

860
00:33:00,480 --> 00:33:03,519
here you can see

861
00:33:04,399 --> 00:33:07,360
the data fault software

862
00:33:07,360 --> 00:33:10,159
is basically there is a data fault six

863
00:33:10,159 --> 00:33:12,240
software which is

864
00:33:12,240 --> 00:33:14,000
the data fault is the the name of the

865
00:33:14,000 --> 00:33:15,919
software that enc

866
00:33:15,919 --> 00:33:17,039
builds

867
00:33:17,039 --> 00:33:19,679
under their own name

868
00:33:19,679 --> 00:33:21,919
right so we have data fault six which is

869
00:33:21,919 --> 00:33:24,159
the old version and default seven which

870
00:33:24,159 --> 00:33:25,840
is the new version that if you buy it

871
00:33:25,840 --> 00:33:27,679
nowadays or you get the trial version

872
00:33:27,679 --> 00:33:29,600
you get data fault seven

873
00:33:29,600 --> 00:33:32,799
um but and it's honestly that's mostly

874
00:33:32,799 --> 00:33:35,279
just user interface changes but based on

875
00:33:35,279 --> 00:33:37,919
the old user interface there is a

876
00:33:37,919 --> 00:33:41,440
different repository which actually

877
00:33:41,440 --> 00:33:42,880
you can generate

878
00:33:42,880 --> 00:33:44,080
different

879
00:33:44,080 --> 00:33:45,760
other versions of so

880
00:33:45,760 --> 00:33:49,519
data fault lite is the sony version

881
00:33:49,519 --> 00:33:51,360
secure access is the

882
00:33:51,360 --> 00:33:52,720
old version

883
00:33:52,720 --> 00:33:53,919
used by

884
00:33:53,919 --> 00:33:55,120
sandisk

885
00:33:55,120 --> 00:33:56,720
and they wanted to have it renamed to

886
00:33:56,720 --> 00:33:58,559
private access

887
00:33:58,559 --> 00:34:02,000
so private access to new version

888
00:34:02,000 --> 00:34:03,840
and then there's the fault api and the

889
00:34:03,840 --> 00:34:07,200
fault api is a thing we produce to be

890
00:34:07,200 --> 00:34:11,520
included in android and ios applications

891
00:34:11,918 --> 00:34:14,719
and then obviously western digital they

892
00:34:14,719 --> 00:34:15,599
have

893
00:34:15,599 --> 00:34:16,800
as far as i know they have three

894
00:34:16,800 --> 00:34:20,159
different kinds of of apps

895
00:34:20,159 --> 00:34:23,760
and they maintain that part of the code

896
00:34:23,918 --> 00:34:26,000
if you're looking at upgrade paths

897
00:34:26,000 --> 00:34:28,480
you you can clearly see that we have

898
00:34:28,480 --> 00:34:30,399
obviously those three different product

899
00:34:30,399 --> 00:34:31,679
lines

900
00:34:31,679 --> 00:34:34,320
and honestly i forgot to include the

901
00:34:34,320 --> 00:34:37,599
mobile applications here

902
00:34:39,359 --> 00:34:41,280
but you could what we wanted to have is

903
00:34:41,280 --> 00:34:43,918
a situation where if someone was still

904
00:34:43,918 --> 00:34:46,239
using secure access

905
00:34:46,239 --> 00:34:48,560
they can download a new version of the

906
00:34:48,560 --> 00:34:51,280
software and immediately from the

907
00:34:51,280 --> 00:34:53,520
secure access version go to the latest

908
00:34:53,520 --> 00:34:56,000
private access version

909
00:34:56,000 --> 00:34:58,000
without having to do

910
00:34:58,000 --> 00:35:00,320
complicated stuff because it is intended

911
00:35:00,320 --> 00:35:01,280
for

912
00:35:01,280 --> 00:35:04,160
regular users

913
00:35:04,160 --> 00:35:05,839
but we also wanted to make it possible

914
00:35:05,839 --> 00:35:10,079
for people to buy our upgraded version

915
00:35:10,079 --> 00:35:11,560
which has

916
00:35:11,560 --> 00:35:14,160
aes-256 i'm using air quotes for the

917
00:35:14,160 --> 00:35:16,720
reason

918
00:35:16,720 --> 00:35:18,800
and it also has some usability features

919
00:35:18,800 --> 00:35:20,400
that are really nice like you can you

920
00:35:20,400 --> 00:35:22,800
can mount default as a drive or as a

921
00:35:22,800 --> 00:35:25,040
folder

922
00:35:25,040 --> 00:35:27,760
but we also want people to be able to do

923
00:35:27,760 --> 00:35:30,160
an upgrade like this

924
00:35:30,160 --> 00:35:32,480
so you can see that that that gives you

925
00:35:32,480 --> 00:35:34,000
a lot of different

926
00:35:34,000 --> 00:35:37,920
test cases that you you have to test

927
00:35:39,839 --> 00:35:41,440
while on the subject of testing there

928
00:35:41,440 --> 00:35:44,480
wasn't always that easy

929
00:35:44,480 --> 00:35:45,920
and that's because

930
00:35:45,920 --> 00:35:48,400
the software like sofia

931
00:35:48,400 --> 00:35:49,359
showed

932
00:35:49,359 --> 00:35:51,440
the software is made to run only on

933
00:35:51,440 --> 00:35:53,200
specific hardware

934
00:35:53,200 --> 00:35:55,680
and honestly that's

935
00:35:55,680 --> 00:35:57,599
that's a bit of a misnomer

936
00:35:57,599 --> 00:36:00,079
you have to run the application

937
00:36:00,079 --> 00:36:04,400
from the usb stick or or from the the

938
00:36:04,400 --> 00:36:06,480
ixpand charger

939
00:36:06,480 --> 00:36:08,240
because if you don't

940
00:36:08,240 --> 00:36:12,079
then it doesn't see that you're using a

941
00:36:12,079 --> 00:36:13,920
device that has a license for it

942
00:36:13,920 --> 00:36:16,000
basically

943
00:36:16,000 --> 00:36:18,400
so if you just copy the executable to

944
00:36:18,400 --> 00:36:20,880
your hard drive

945
00:36:20,880 --> 00:36:22,800
it doesn't work

946
00:36:22,800 --> 00:36:25,200
unless you fix it

947
00:36:25,200 --> 00:36:27,839
and

948
00:36:28,160 --> 00:36:31,200
and uh it's easy to buy one of those usb

949
00:36:31,200 --> 00:36:33,200
sticks from sandisk nowadays

950
00:36:33,200 --> 00:36:36,000
uh and i'm not sure about the ixpand

951
00:36:36,000 --> 00:36:37,440
charger

952
00:36:37,440 --> 00:36:39,359
but i got one from the company so that

953
00:36:39,359 --> 00:36:41,119
that's easy

954
00:36:41,119 --> 00:36:44,079
but the sony ssds

955
00:36:44,079 --> 00:36:46,640
you can't get him anymore maybe on on

956
00:36:46,640 --> 00:36:48,480
ebay or something like that

957
00:36:48,480 --> 00:36:50,640
but i just couldn't get them anymore

958
00:36:50,640 --> 00:36:52,240
one of my colleagues told me he had a

959
00:36:52,240 --> 00:36:54,480
prototype which is basically the same

960
00:36:54,480 --> 00:36:56,240
contents as this thing but without the

961
00:36:56,240 --> 00:36:58,000
casing

962
00:36:58,000 --> 00:36:59,359
and then i

963
00:36:59,359 --> 00:37:01,599
decided to use something different

964
00:37:01,599 --> 00:37:04,320
i was hacking it like the 20s

965
00:37:04,320 --> 00:37:07,200
so i used an orange pie

966
00:37:07,200 --> 00:37:09,680
and run linux on it

967
00:37:09,680 --> 00:37:11,440
and i used the gadget

968
00:37:11,440 --> 00:37:14,000
kernel module the gmass storage module

969
00:37:14,000 --> 00:37:15,040
to just

970
00:37:15,040 --> 00:37:17,599
fake a usb device with specific fender

971
00:37:17,599 --> 00:37:19,119
and product ids and that worked like a

972
00:37:19,119 --> 00:37:22,119
charm

973
00:37:23,520 --> 00:37:24,880
yeah

974
00:37:24,880 --> 00:37:26,320
so

975
00:37:26,320 --> 00:37:27,359
then

976
00:37:27,359 --> 00:37:30,960
we we had a deadline when um

977
00:37:30,960 --> 00:37:32,560
when savannah was going to make

978
00:37:32,560 --> 00:37:34,839
everything public

979
00:37:34,839 --> 00:37:36,800
um

980
00:37:36,800 --> 00:37:38,960
and we agreed on that line

981
00:37:38,960 --> 00:37:40,560
and then we were not able to make the

982
00:37:40,560 --> 00:37:42,800
deadline that is we were supposed to get

983
00:37:42,800 --> 00:37:44,320
out the fix for at least a key

984
00:37:44,320 --> 00:37:46,640
derivation function issue

985
00:37:46,640 --> 00:37:48,839
before the deadline and we were not able

986
00:37:48,839 --> 00:37:51,839
to so yeah we were actually quite happy

987
00:37:51,839 --> 00:37:52,880
that

988
00:37:52,880 --> 00:37:55,119
was like okay i don't want to endanger

989
00:37:55,119 --> 00:37:59,440
users so let's postpone that

990
00:38:00,000 --> 00:38:02,640
by then the talk for ccc i think was

991
00:38:02,640 --> 00:38:04,400
already confirmed is that right

992
00:38:04,400 --> 00:38:09,359
yeah so we had a much harder deadline

993
00:38:09,760 --> 00:38:12,400
but yeah finally we went live with with

994
00:38:12,400 --> 00:38:14,640
the key derivation function fix in

995
00:38:14,640 --> 00:38:16,839
december

996
00:38:16,839 --> 00:38:19,599
so yeah um

997
00:38:19,599 --> 00:38:21,520
now i'm going to explain a bit

998
00:38:21,520 --> 00:38:24,480
about the ciphertext reliability issue

999
00:38:24,480 --> 00:38:27,200
and to do so i first want to explain to

1000
00:38:27,200 --> 00:38:29,599
you a bit about how stream cycles work i

1001
00:38:29,599 --> 00:38:30,640
mean i

1002
00:38:30,640 --> 00:38:32,640
i'm assuming not everyone knows how this

1003
00:38:32,640 --> 00:38:34,720
stuff works

1004
00:38:34,720 --> 00:38:36,160
so

1005
00:38:36,160 --> 00:38:38,320
basically

1006
00:38:38,320 --> 00:38:40,480
there is you can define ciphers in two

1007
00:38:40,480 --> 00:38:42,000
types

1008
00:38:42,000 --> 00:38:44,320
block ciphers and stream ciphers

1009
00:38:44,320 --> 00:38:47,200
and aes is a block cipher

1010
00:38:47,200 --> 00:38:48,800
but block ciphers also have some

1011
00:38:48,800 --> 00:38:50,800
inconveniences stream ciphers have some

1012
00:38:50,800 --> 00:38:52,640
good properties and there's actually a

1013
00:38:52,640 --> 00:38:55,280
trick to use aes in what's called

1014
00:38:55,280 --> 00:38:57,200
counter mode

1015
00:38:57,200 --> 00:38:59,680
which means that you use a counter to

1016
00:38:59,680 --> 00:39:01,440
create a

1017
00:39:01,440 --> 00:39:03,200
key stream

1018
00:39:03,200 --> 00:39:05,760
and this key stream is not predictable

1019
00:39:05,760 --> 00:39:07,520
by the attacker but it is predictable by

1020
00:39:07,520 --> 00:39:11,359
anyone who knows the the key

1021
00:39:11,359 --> 00:39:15,280
so what you then do is you just xor

1022
00:39:15,280 --> 00:39:16,720
the plain text in the key stream

1023
00:39:16,720 --> 00:39:19,119
together and then you get the ciphertext

1024
00:39:19,119 --> 00:39:23,119
it's a really simple way of doing this

1025
00:39:24,160 --> 00:39:25,760
now

1026
00:39:25,760 --> 00:39:27,760
does anyone in the room

1027
00:39:27,760 --> 00:39:31,359
know what it says over here

1028
00:39:36,640 --> 00:39:38,240
okay we're going to see

1029
00:39:38,240 --> 00:39:39,119
because

1030
00:39:39,119 --> 00:39:40,880
the next thing is

1031
00:39:40,880 --> 00:39:43,520
if the attacker knows the plain text

1032
00:39:43,520 --> 00:39:45,599
what what could possibly go wrong there

1033
00:39:45,599 --> 00:39:48,079
well a lot a lot

1034
00:39:48,079 --> 00:39:50,800
because if you decrypt things

1035
00:39:50,800 --> 00:39:52,400
if you take the cipher text and you

1036
00:39:52,400 --> 00:39:54,160
exert the same key stream on top of it

1037
00:39:54,160 --> 00:39:56,480
then you get the plain text again that's

1038
00:39:56,480 --> 00:39:58,720
one also very nice feature of counter

1039
00:39:58,720 --> 00:40:00,720
mode because for for counter mode

1040
00:40:00,720 --> 00:40:02,560
encryption decryption are exactly the

1041
00:40:02,560 --> 00:40:03,440
same

1042
00:40:03,440 --> 00:40:05,839
there's no change in code whatsoever

1043
00:40:05,839 --> 00:40:07,680
which gives you very efficient

1044
00:40:07,680 --> 00:40:10,079
implementation in software and also in

1045
00:40:10,079 --> 00:40:12,079
hardware

1046
00:40:12,079 --> 00:40:14,640
and this plain text is actually the word

1047
00:40:14,640 --> 00:40:16,960
test

1048
00:40:18,000 --> 00:40:19,599
okay

1049
00:40:19,599 --> 00:40:22,800
but then suppose

1050
00:40:22,800 --> 00:40:25,599
i want to change that word test i want

1051
00:40:25,599 --> 00:40:28,560
to make the first lowercase t a capital

1052
00:40:28,560 --> 00:40:29,520
t

1053
00:40:29,520 --> 00:40:31,680
that's actually quite easy to do because

1054
00:40:31,680 --> 00:40:33,359
that's only that's only one bit

1055
00:40:33,359 --> 00:40:34,560
difference

1056
00:40:34,560 --> 00:40:36,720
and ascii the the difference between

1057
00:40:36,720 --> 00:40:38,720
upper and lower case is always the same

1058
00:40:38,720 --> 00:40:40,480
bit so it's really easy

1059
00:40:40,480 --> 00:40:41,280
so

1060
00:40:41,280 --> 00:40:43,040
like from this angle i can't really see

1061
00:40:43,040 --> 00:40:45,680
it all that well but over here if you

1062
00:40:45,680 --> 00:40:48,560
just flip the bit in the ciphertext

1063
00:40:48,560 --> 00:40:51,200
the corresponding bit that needs to be

1064
00:40:51,200 --> 00:40:53,040
that needs to be changed to make as an

1065
00:40:53,040 --> 00:40:55,440
uppercase character

1066
00:40:55,440 --> 00:40:56,800
on decryption

1067
00:40:56,800 --> 00:40:58,880
this the plain text also gets the

1068
00:40:58,880 --> 00:41:00,880
corresponding bit flipped

1069
00:41:00,880 --> 00:41:02,480
just you can make single bit

1070
00:41:02,480 --> 00:41:03,920
manipulations

1071
00:41:03,920 --> 00:41:06,079
in your ciphertext that give

1072
00:41:06,079 --> 00:41:07,520
corresponding

1073
00:41:07,520 --> 00:41:09,760
single bit manipulations

1074
00:41:09,760 --> 00:41:12,400
in the in the plain text and you can do

1075
00:41:12,400 --> 00:41:14,480
that for every bit it's not not limited

1076
00:41:14,480 --> 00:41:17,280
to only one bit

1077
00:41:17,280 --> 00:41:19,440
so if if an attacker knows the plain

1078
00:41:19,440 --> 00:41:20,480
text

1079
00:41:20,480 --> 00:41:23,040
that's an obvious problem

1080
00:41:23,040 --> 00:41:24,880
now the good news is often attackers

1081
00:41:24,880 --> 00:41:26,720
don't know the plain text

1082
00:41:26,720 --> 00:41:27,520
so

1083
00:41:27,520 --> 00:41:30,000
there are a few conditions for this film

1084
00:41:30,000 --> 00:41:31,599
ability to be used

1085
00:41:31,599 --> 00:41:33,280
and the main one is

1086
00:41:33,280 --> 00:41:34,400
is really

1087
00:41:34,400 --> 00:41:37,920
where is my pointer there it is

1088
00:41:37,920 --> 00:41:40,640
the adversary always has to know

1089
00:41:40,640 --> 00:41:43,680
at least something about the plain text

1090
00:41:43,680 --> 00:41:46,560
at least have to know the format

1091
00:41:46,560 --> 00:41:50,480
and usually it requires knowing a big

1092
00:41:50,480 --> 00:41:53,920
chunk of the plaintext

1093
00:41:53,920 --> 00:41:55,680
and

1094
00:41:55,680 --> 00:41:57,359
the other thing is

1095
00:41:57,359 --> 00:42:01,040
you know it requires an

1096
00:42:01,200 --> 00:42:04,319
there it is it requires to steal the usb

1097
00:42:04,319 --> 00:42:06,480
stick you have to have access to the usb

1098
00:42:06,480 --> 00:42:07,839
stick

1099
00:42:07,839 --> 00:42:10,240
then manipulate it and then put it back

1100
00:42:10,240 --> 00:42:13,040
in such a way that the victim

1101
00:42:13,040 --> 00:42:15,040
does not notice that there's something

1102
00:42:15,040 --> 00:42:16,560
wrong

1103
00:42:16,560 --> 00:42:19,119
because if they notice something's wrong

1104
00:42:19,119 --> 00:42:22,000
you know they might get paranoid and

1105
00:42:22,000 --> 00:42:26,160
not not use the the stick anymore

1106
00:42:26,160 --> 00:42:27,920
and these conditions actually make it

1107
00:42:27,920 --> 00:42:30,079
relatively hard to abuse especially the

1108
00:42:30,079 --> 00:42:32,640
part where it says that you need to know

1109
00:42:32,640 --> 00:42:34,880
the plain text

1110
00:42:34,880 --> 00:42:37,119
however if you do for example if someone

1111
00:42:37,119 --> 00:42:40,400
would have an a windows executable in

1112
00:42:40,400 --> 00:42:41,520
the vault

1113
00:42:41,520 --> 00:42:44,079
and some someone else the attacker knows

1114
00:42:44,079 --> 00:42:46,160
exactly what executable it is

1115
00:42:46,160 --> 00:42:48,640
the attacker can replace that executable

1116
00:42:48,640 --> 00:42:52,079
with anything else any other executable

1117
00:42:52,079 --> 00:42:54,160
of at most the same size

1118
00:42:54,160 --> 00:42:55,920
and by the way making it smaller is also

1119
00:42:55,920 --> 00:42:57,440
easy because you just chop off the bytes

1120
00:42:57,440 --> 00:42:59,280
that you don't need

1121
00:42:59,280 --> 00:43:01,119
so

1122
00:43:01,119 --> 00:43:03,280
it is hard to abuse but if the

1123
00:43:03,280 --> 00:43:05,359
conditions are met it is relatively easy

1124
00:43:05,359 --> 00:43:07,680
to do

1125
00:43:08,480 --> 00:43:10,720
okay

1126
00:43:10,880 --> 00:43:12,960
okay

1127
00:43:12,960 --> 00:43:14,720
the how to fix it

1128
00:43:14,720 --> 00:43:16,079
well there's

1129
00:43:16,079 --> 00:43:18,000
there's a proven solution for this which

1130
00:43:18,000 --> 00:43:20,079
is relatively simple

1131
00:43:20,079 --> 00:43:21,440
you just need to generate a mesh

1132
00:43:21,440 --> 00:43:23,440
authentication code over the entire

1133
00:43:23,440 --> 00:43:25,760
contents of the file

1134
00:43:25,760 --> 00:43:26,720
it's

1135
00:43:26,720 --> 00:43:29,040
best to do this on the ciphertext i'm

1136
00:43:29,040 --> 00:43:30,800
not going to explain here why but that's

1137
00:43:30,800 --> 00:43:34,000
that's generally accepted

1138
00:43:34,000 --> 00:43:37,920
and there are multiple ways to do so for

1139
00:43:38,839 --> 00:43:41,280
example there it is

1140
00:43:41,280 --> 00:43:43,359
you can use instead of our counter mode

1141
00:43:43,359 --> 00:43:45,119
you can use galra counter mode which

1142
00:43:45,119 --> 00:43:46,960
also produces gmac

1143
00:43:46,960 --> 00:43:50,560
and you can use an hmac which is a mac

1144
00:43:50,560 --> 00:43:53,520
construct construction

1145
00:43:53,520 --> 00:43:55,760
and this will solve

1146
00:43:55,760 --> 00:43:58,240
the issue completely

1147
00:43:58,240 --> 00:44:00,319
and it is actually not even that hard to

1148
00:44:00,319 --> 00:44:02,000
implement

1149
00:44:02,000 --> 00:44:04,319
okay

1150
00:44:05,040 --> 00:44:06,880
but why didn't we do that immediately

1151
00:44:06,880 --> 00:44:08,720
then

1152
00:44:08,720 --> 00:44:11,040
we have two usage modes one is that you

1153
00:44:11,040 --> 00:44:12,319
can

1154
00:44:12,319 --> 00:44:14,079
like the the picture you saw the

1155
00:44:14,079 --> 00:44:16,720
screenshot you saw with survey you have

1156
00:44:16,720 --> 00:44:19,359
a drag and drop interface where you can

1157
00:44:19,359 --> 00:44:21,680
drop files into the vault and you can

1158
00:44:21,680 --> 00:44:22,880
drag them out

1159
00:44:22,880 --> 00:44:24,560
you can also double click on them and

1160
00:44:24,560 --> 00:44:27,040
then get them opened which effectively

1161
00:44:27,040 --> 00:44:28,720
what it does is it will decrypt it to

1162
00:44:28,720 --> 00:44:30,160
your hard disk

1163
00:44:30,160 --> 00:44:31,839
and then the application has started to

1164
00:44:31,839 --> 00:44:34,960
handle the the file and if you close it

1165
00:44:34,960 --> 00:44:37,520
and it has changed it will actually

1166
00:44:37,520 --> 00:44:39,200
put the file back into the vault and

1167
00:44:39,200 --> 00:44:42,400
replace the original completely

1168
00:44:42,400 --> 00:44:45,280
that's one way of doing it

1169
00:44:45,280 --> 00:44:48,319
that i guess it is acceptable to do it

1170
00:44:48,319 --> 00:44:51,280
with the with hmac construct as i just

1171
00:44:51,280 --> 00:44:52,480
showed

1172
00:44:52,480 --> 00:44:55,920
however we also have a direct access

1173
00:44:55,920 --> 00:44:58,720
way of using and you can do that for

1174
00:44:58,720 --> 00:45:01,359
example with the mounting of fault on

1175
00:45:01,359 --> 00:45:02,580
the desktop version

1176
00:45:02,580 --> 00:45:03,839
[Music]

1177
00:45:03,839 --> 00:45:08,000
on a drive or on a folder

1178
00:45:08,319 --> 00:45:10,000
similarly

1179
00:45:10,000 --> 00:45:12,240
the the mobile applications they use

1180
00:45:12,240 --> 00:45:14,960
default api and that basically also have

1181
00:45:14,960 --> 00:45:17,280
random access direct random access to

1182
00:45:17,280 --> 00:45:19,520
the files and they also actually use

1183
00:45:19,520 --> 00:45:20,640
that

1184
00:45:20,640 --> 00:45:22,640
because what you can do now is

1185
00:45:22,640 --> 00:45:24,400
you can open

1186
00:45:24,400 --> 00:45:25,520
a file

1187
00:45:25,520 --> 00:45:28,640
but only read a bit a small bit or write

1188
00:45:28,640 --> 00:45:31,520
a small bit of the file

1189
00:45:31,520 --> 00:45:33,839
and then close it again

1190
00:45:33,839 --> 00:45:36,160
and you only have to encrypt and decrypt

1191
00:45:36,160 --> 00:45:40,000
the bits that you're reading or writing

1192
00:45:40,000 --> 00:45:42,319
okay

1193
00:45:42,560 --> 00:45:45,200
now suppose you have

1194
00:45:45,200 --> 00:45:46,480
a folder

1195
00:45:46,480 --> 00:45:49,119
with a lot of large video files

1196
00:45:49,119 --> 00:45:51,520
several several hundred megabytes

1197
00:45:51,520 --> 00:45:53,280
of video

1198
00:45:53,280 --> 00:45:54,480
and

1199
00:45:54,480 --> 00:45:57,920
the many of these video files do contain

1200
00:45:57,920 --> 00:45:59,280
an icon

1201
00:45:59,280 --> 00:46:01,280
right

1202
00:46:01,280 --> 00:46:04,079
if the if the explorer wants to extract

1203
00:46:04,079 --> 00:46:06,800
the icon from the file

1204
00:46:06,800 --> 00:46:08,319
and you have this

1205
00:46:08,319 --> 00:46:11,119
this mac construct this authenticated

1206
00:46:11,119 --> 00:46:12,560
encryption because that's another name

1207
00:46:12,560 --> 00:46:15,599
for it

1208
00:46:15,599 --> 00:46:17,520
it will have to do this this entire

1209
00:46:17,520 --> 00:46:19,280
check over the entire contents of the

1210
00:46:19,280 --> 00:46:20,800
file

1211
00:46:20,800 --> 00:46:22,720
so if that's hundreds of megabytes for

1212
00:46:22,720 --> 00:46:26,480
just a few kilobytes of an icon

1213
00:46:26,480 --> 00:46:28,400
that's a lot of work

1214
00:46:28,400 --> 00:46:30,480
so this makes it really slow and

1215
00:46:30,480 --> 00:46:31,520
similarly

1216
00:46:31,520 --> 00:46:33,680
if you change something even a single

1217
00:46:33,680 --> 00:46:36,000
byte

1218
00:46:37,760 --> 00:46:38,720
yeah

1219
00:46:38,720 --> 00:46:41,200
if you change even a single byte

1220
00:46:41,200 --> 00:46:43,760
then the the the mac will have to be

1221
00:46:43,760 --> 00:46:46,000
recalculated over the entire contents

1222
00:46:46,000 --> 00:46:49,599
again so that's expensive

1223
00:46:50,000 --> 00:46:51,119
okay

1224
00:46:51,119 --> 00:46:53,200
there are other ways to deal with this

1225
00:46:53,200 --> 00:46:54,640
you can do the same thing but over

1226
00:46:54,640 --> 00:46:56,960
smaller chunks over blocks if you if you

1227
00:46:56,960 --> 00:46:59,200
will

1228
00:46:59,359 --> 00:47:01,520
which is a good idea it's

1229
00:47:01,520 --> 00:47:03,760
people have been doing this before

1230
00:47:03,760 --> 00:47:06,960
however it does not fit really well into

1231
00:47:06,960 --> 00:47:08,560
our current design so it's a lot of work

1232
00:47:08,560 --> 00:47:11,280
to change it

1233
00:47:11,280 --> 00:47:13,440
there are other alternatives

1234
00:47:13,440 --> 00:47:15,200
that we considered and at first we

1235
00:47:15,200 --> 00:47:16,400
thought that's what we're going to do

1236
00:47:16,400 --> 00:47:18,800
we're going to use xts mode

1237
00:47:18,800 --> 00:47:21,040
because that's also used by bitlocker

1238
00:47:21,040 --> 00:47:22,480
and by lux

1239
00:47:22,480 --> 00:47:25,440
and that's is well known

1240
00:47:25,440 --> 00:47:27,200
and the thing here is you can there's

1241
00:47:27,200 --> 00:47:29,200
still cipher text meaning ability

1242
00:47:29,200 --> 00:47:30,480
because you can

1243
00:47:30,480 --> 00:47:31,920
you can just

1244
00:47:31,920 --> 00:47:34,240
edit the cipher text and if it's

1245
00:47:34,240 --> 00:47:35,520
decrypted

1246
00:47:35,520 --> 00:47:37,119
it will be different

1247
00:47:37,119 --> 00:47:39,680
however it's now restricted that if you

1248
00:47:39,680 --> 00:47:43,040
make a change even one bit in a block of

1249
00:47:43,040 --> 00:47:44,319
ciphertext

1250
00:47:44,319 --> 00:47:46,240
then a corresponding

1251
00:47:46,240 --> 00:47:47,440
full

1252
00:47:47,440 --> 00:47:49,520
block of the block cipher

1253
00:47:49,520 --> 00:47:51,920
is going to be completely different and

1254
00:47:51,920 --> 00:47:52,960
you can't

1255
00:47:52,960 --> 00:47:55,040
specifically target individual bits or

1256
00:47:55,040 --> 00:47:57,200
anything like that basically you can

1257
00:47:57,200 --> 00:48:00,160
destroy a block but you can't manipulate

1258
00:48:00,160 --> 00:48:02,800
it in a very targeted way and these

1259
00:48:02,800 --> 00:48:04,880
blocks are usually

1260
00:48:04,880 --> 00:48:07,520
in our case it's 128 bits

1261
00:48:07,520 --> 00:48:10,319
right because it's aes so that's like 16

1262
00:48:10,319 --> 00:48:12,720
bytes

1263
00:48:12,960 --> 00:48:14,960
um

1264
00:48:14,960 --> 00:48:18,319
yeah that sounds nice

1265
00:48:18,880 --> 00:48:21,520
but again this doesn't really work with

1266
00:48:21,520 --> 00:48:23,680
our code because our code expects to be

1267
00:48:23,680 --> 00:48:26,559
able to encrypt and decrypt single bytes

1268
00:48:26,559 --> 00:48:27,680
and

1269
00:48:27,680 --> 00:48:30,640
sure it you you can fix this

1270
00:48:30,640 --> 00:48:33,839
um but the the most naive approach is

1271
00:48:33,839 --> 00:48:36,720
very going to be very costly if

1272
00:48:36,720 --> 00:48:38,480
the the program

1273
00:48:38,480 --> 00:48:40,720
actually accessing the file is reading

1274
00:48:40,720 --> 00:48:42,640
or writing single bytes

1275
00:48:42,640 --> 00:48:44,160
that's going to be really expensive so

1276
00:48:44,160 --> 00:48:45,599
you need some kind of a buffering or

1277
00:48:45,599 --> 00:48:49,760
caching layer on top of the crypto layer

1278
00:48:49,760 --> 00:48:51,680
much more effort than you were hoping

1279
00:48:51,680 --> 00:48:53,200
for

1280
00:48:53,200 --> 00:48:55,119
so effectively

1281
00:48:55,119 --> 00:48:58,079
this has not been implemented yet

1282
00:48:58,079 --> 00:48:59,440
and

1283
00:48:59,440 --> 00:49:01,760
it's intended to do this somewhere this

1284
00:49:01,760 --> 00:49:02,960
year

1285
00:49:02,960 --> 00:49:05,520
um we also discussed it with with

1286
00:49:05,520 --> 00:49:07,760
western digital and

1287
00:49:07,760 --> 00:49:09,280
they definitely want to have this fixed

1288
00:49:09,280 --> 00:49:12,160
too um but there are also other bugs

1289
00:49:12,160 --> 00:49:14,720
that we want to have fixed first

1290
00:49:14,720 --> 00:49:16,960
because it's um thank you

1291
00:49:16,960 --> 00:49:17,920
um

1292
00:49:17,920 --> 00:49:19,599
yeah it's it's a trade-off you have to

1293
00:49:19,599 --> 00:49:20,640
make

1294
00:49:20,640 --> 00:49:23,440
these bugs are affecting users most

1295
00:49:23,440 --> 00:49:26,640
users in most use cases more than this

1296
00:49:26,640 --> 00:49:28,559
bug

1297
00:49:28,559 --> 00:49:29,680
so

1298
00:49:29,680 --> 00:49:31,119
one last thing

1299
00:49:31,119 --> 00:49:34,480
aes 1024.

1300
00:49:34,480 --> 00:49:37,040
so when i was starting on when i

1301
00:49:37,040 --> 00:49:39,680
accepted my first assignment

1302
00:49:39,680 --> 00:49:42,160
i started reading the marketing material

1303
00:49:42,160 --> 00:49:47,078
on the website and then i read aes 1024

1304
00:49:47,599 --> 00:49:48,640
right

1305
00:49:48,640 --> 00:49:51,440
what did i start on

1306
00:49:51,440 --> 00:49:53,760
and now that i've i've talked to people

1307
00:49:53,760 --> 00:49:55,440
within the company some of them have

1308
00:49:55,440 --> 00:49:58,079
been around for a long time

1309
00:49:58,079 --> 00:49:59,920
they told me well yeah we know it

1310
00:49:59,920 --> 00:50:01,839
doesn't exist we know it's not a nist

1311
00:50:01,839 --> 00:50:03,920
standard

1312
00:50:03,920 --> 00:50:05,920
but we had expert regulations so we

1313
00:50:05,920 --> 00:50:09,440
could only ship aes 128

1314
00:50:09,440 --> 00:50:11,200
but we wanted to offer something

1315
00:50:11,200 --> 00:50:12,640
stronger than that

1316
00:50:12,640 --> 00:50:13,520
so

1317
00:50:13,520 --> 00:50:16,720
we would just do multiple rounds

1318
00:50:16,720 --> 00:50:17,599
um

1319
00:50:17,599 --> 00:50:20,079
and how to market this well you know

1320
00:50:20,079 --> 00:50:21,839
bigger numbers people understand being

1321
00:50:21,839 --> 00:50:24,640
on bigger numbers it sounds stronger

1322
00:50:24,640 --> 00:50:26,240
especially if you call it military

1323
00:50:26,240 --> 00:50:27,440
encryption

1324
00:50:27,440 --> 00:50:29,760
um

1325
00:50:30,160 --> 00:50:31,119
yeah

1326
00:50:31,119 --> 00:50:34,640
so that's the background of this

1327
00:50:34,640 --> 00:50:37,200
yeah it's our conclusion

1328
00:50:37,200 --> 00:50:40,160
yeah so as as you have seen um it's

1329
00:50:40,160 --> 00:50:41,280
really

1330
00:50:41,280 --> 00:50:43,040
difficult to assess the level of

1331
00:50:43,040 --> 00:50:45,359
security of a solution depends many

1332
00:50:45,359 --> 00:50:48,000
things um the algorithm use the size of

1333
00:50:48,000 --> 00:50:49,280
the key

1334
00:50:49,280 --> 00:50:50,240
uh

1335
00:50:50,240 --> 00:50:52,720
the number of iterations so it's it's

1336
00:50:52,720 --> 00:50:54,640
we have to be careful when we

1337
00:50:54,640 --> 00:50:57,599
we we are done numbers and

1338
00:50:57,599 --> 00:50:59,839
with this talk i wanted to because maybe

1339
00:50:59,839 --> 00:51:01,839
you've seen before in previous talk it

1340
00:51:01,839 --> 00:51:03,920
sometimes it's difficult to do um

1341
00:51:03,920 --> 00:51:06,000
vulnerability disclosure too and

1342
00:51:06,000 --> 00:51:08,319
sometimes it's it's um it's badly done

1343
00:51:08,319 --> 00:51:10,240
and for this project it was really nice

1344
00:51:10,240 --> 00:51:12,559
a nice collaboration and it was under

1345
00:51:12,559 --> 00:51:14,960
really in a good way we had a lot of

1346
00:51:14,960 --> 00:51:17,440
meeting and i'm happy to to show you the

1347
00:51:17,440 --> 00:51:18,880
both side of

1348
00:51:18,880 --> 00:51:19,599
of

1349
00:51:19,599 --> 00:51:21,520
of this analysis and how it should

1350
00:51:21,520 --> 00:51:23,280
happen i think

1351
00:51:23,280 --> 00:51:25,680
most often like defensive side should

1352
00:51:25,680 --> 00:51:27,200
understand the problem from the

1353
00:51:27,200 --> 00:51:29,760
defensive side and same way around so it

1354
00:51:29,760 --> 00:51:31,760
was really nice in this way yeah there's

1355
00:51:31,760 --> 00:51:32,640
a really

1356
00:51:32,640 --> 00:51:34,960
nice and surprising idea if you if i

1357
00:51:34,960 --> 00:51:36,800
would join in

1358
00:51:36,800 --> 00:51:38,880
so yeah

1359
00:51:38,880 --> 00:51:41,920
so if you have any questions and

1360
00:51:41,920 --> 00:51:43,760
you can ask them we have few minutes to

1361
00:51:43,760 --> 00:51:46,480
answer or you can contact us by this

1362
00:51:46,480 --> 00:51:50,400
means so feel free

1363
00:51:50,400 --> 00:51:51,840
thank you

1364
00:51:51,840 --> 00:51:54,319
[Applause]

1365
00:51:54,319 --> 00:51:55,839
thank you very much

1366
00:51:55,839 --> 00:51:59,520
if anyone has a question please please

1367
00:51:59,520 --> 00:52:03,000
yes i took

1368
00:52:09,520 --> 00:52:11,839
sorry

1369
00:52:16,400 --> 00:52:18,960
so are they still branding

1370
00:52:18,960 --> 00:52:22,640
military grades 1024 or did they roll

1371
00:52:22,640 --> 00:52:24,640
back to

1372
00:52:24,640 --> 00:52:28,240
128 and 256.

1373
00:52:28,240 --> 00:52:29,599
it's um

1374
00:52:29,599 --> 00:52:31,680
the marketing material still calls it a

1375
00:52:31,680 --> 00:52:35,040
military-grade encryption

1376
00:52:35,280 --> 00:52:38,400
and so the the actual implementation

1377
00:52:38,400 --> 00:52:39,280
uh

1378
00:52:39,280 --> 00:52:41,040
is in

1379
00:52:41,040 --> 00:52:45,200
the as-256 is not as-256 as designed by

1380
00:52:45,200 --> 00:52:47,200
nist

1381
00:52:47,200 --> 00:52:49,200
and we also are going to fix that

1382
00:52:49,200 --> 00:52:51,359
because it's relatively easy to do

1383
00:52:51,359 --> 00:52:55,200
and aes 512 and 1024 will be then two

1384
00:52:55,200 --> 00:52:58,480
and four rounds of those

1385
00:52:58,640 --> 00:53:00,240
and that will also be done at the same

1386
00:53:00,240 --> 00:53:02,000
time as the ciphertext leadability is

1387
00:53:02,000 --> 00:53:04,400
addressed

1388
00:53:07,839 --> 00:53:09,440
and it's not really a question it's a

1389
00:53:09,440 --> 00:53:12,400
comment on your last site essentially i

1390
00:53:12,400 --> 00:53:14,319
wanted to upload you because in my

1391
00:53:14,319 --> 00:53:16,240
experience it's very rare

1392
00:53:16,240 --> 00:53:18,960
to have such responsible disclosure and

1393
00:53:18,960 --> 00:53:20,720
have both sides of the story story at

1394
00:53:20,720 --> 00:53:23,040
the same time so thank you very much

1395
00:53:23,040 --> 00:53:24,079
thank you

1396
00:53:24,079 --> 00:53:27,240
thank you

