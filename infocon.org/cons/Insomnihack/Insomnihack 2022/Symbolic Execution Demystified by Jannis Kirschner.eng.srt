1
00:00:06,840 --> 00:00:09,900
[Music]

2
00:00:13,840 --> 00:00:15,360
so

3
00:00:15,360 --> 00:00:17,440
it's so cool to finally be here at

4
00:00:17,440 --> 00:00:20,800
insomniac again after two long years

5
00:00:20,800 --> 00:00:22,320
of waiting

6
00:00:22,320 --> 00:00:23,519
um

7
00:00:23,519 --> 00:00:26,080
a question for you who of you is a ctf

8
00:00:26,080 --> 00:00:28,800
player please raise your hand

9
00:00:28,800 --> 00:00:31,359
very nice very nice who of you likes to

10
00:00:31,359 --> 00:00:33,520
do reverse engineering and solving crack

11
00:00:33,520 --> 00:00:34,320
me

12
00:00:34,320 --> 00:00:35,840
even better

13
00:00:35,840 --> 00:00:37,280
that's so awesome

14
00:00:37,280 --> 00:00:38,320
um

15
00:00:38,320 --> 00:00:39,440
so

16
00:00:39,440 --> 00:00:41,840
let's start let's dive in

17
00:00:41,840 --> 00:00:42,640
and

18
00:00:42,640 --> 00:00:46,559
solve a warming crack me challenge

19
00:00:48,160 --> 00:00:50,639
oh no

20
00:00:51,840 --> 00:00:54,879
this doesn't look good

21
00:00:55,280 --> 00:00:58,480
this doesn't look good at all

22
00:00:58,480 --> 00:01:00,960
that's dreadful

23
00:01:00,960 --> 00:01:02,879
so

24
00:01:02,879 --> 00:01:05,280
while the control flow graph before

25
00:01:05,280 --> 00:01:08,080
was really scary

26
00:01:08,080 --> 00:01:10,240
my goal today for today

27
00:01:10,240 --> 00:01:12,720
after this hour is that if you encounter

28
00:01:12,720 --> 00:01:14,799
something like that in a ctf or in the

29
00:01:14,799 --> 00:01:17,600
wild it won't be as scary anymore

30
00:01:17,600 --> 00:01:19,920
because you know how to apply symbolic

31
00:01:19,920 --> 00:01:22,560
execution

32
00:01:22,560 --> 00:01:25,040
my name is janis kirschner i'm a swiss

33
00:01:25,040 --> 00:01:27,680
security researcher ctf player

34
00:01:27,680 --> 00:01:30,320
and today i'm not affiliated with anyone

35
00:01:30,320 --> 00:01:34,158
so just my opinions

36
00:01:35,680 --> 00:01:37,920
so let's look at the roadmap

37
00:01:37,920 --> 00:01:40,240
first we start with the problem state

38
00:01:40,240 --> 00:01:42,720
when do we use symbolic execution why do

39
00:01:42,720 --> 00:01:45,040
we use symbolic execution

40
00:01:45,040 --> 00:01:47,119
from which we gonna branch off and look

41
00:01:47,119 --> 00:01:49,920
how those systems work under the hood

42
00:01:49,920 --> 00:01:52,159
and finally we'll get our hands dirty

43
00:01:52,159 --> 00:01:54,240
and look at anger tricks and how to

44
00:01:54,240 --> 00:01:58,079
apply it in a ctf

45
00:01:58,880 --> 00:02:02,399
connection seems weird

46
00:02:03,280 --> 00:02:05,360
here we go

47
00:02:05,360 --> 00:02:08,360
yeah

48
00:02:10,080 --> 00:02:12,080
better

49
00:02:12,080 --> 00:02:14,560
wonderful

50
00:02:14,640 --> 00:02:15,840
so

51
00:02:15,840 --> 00:02:18,640
why do we use symbolic execution and to

52
00:02:18,640 --> 00:02:20,319
illustrate that

53
00:02:20,319 --> 00:02:22,560
we're gonna solve a crackme challenge

54
00:02:22,560 --> 00:02:25,760
from a ctf from two years ago which is a

55
00:02:25,760 --> 00:02:28,160
perfect example because we can apply all

56
00:02:28,160 --> 00:02:30,160
those techniques

57
00:02:30,160 --> 00:02:31,519
so

58
00:02:31,519 --> 00:02:33,280
when we first look at the crackmeat do

59
00:02:33,280 --> 00:02:36,080
some initial static analysis

60
00:02:36,080 --> 00:02:38,319
we see it just takes some values from

61
00:02:38,319 --> 00:02:41,280
standard input it passes them to a check

62
00:02:41,280 --> 00:02:42,560
flag function

63
00:02:42,560 --> 00:02:45,200
which evaluates your input and based on

64
00:02:45,200 --> 00:02:47,200
that it either says hey you solved the

65
00:02:47,200 --> 00:02:50,000
challenge or no you didn't solve it and

66
00:02:50,000 --> 00:02:53,040
the fitch's robot in this example here

67
00:02:53,040 --> 00:02:55,440
stays asleep

68
00:02:55,440 --> 00:02:57,840
so how can we approach that the first

69
00:02:57,840 --> 00:02:59,040
idea

70
00:02:59,040 --> 00:03:00,959
can be brute force and just solve

71
00:03:00,959 --> 00:03:03,120
another challenge while have that run in

72
00:03:03,120 --> 00:03:05,280
the background no that won't work

73
00:03:05,280 --> 00:03:09,040
because the input is very long

74
00:03:09,840 --> 00:03:12,000
so

75
00:03:12,800 --> 00:03:16,400
we're gonna have to solve it manually

76
00:03:16,400 --> 00:03:19,200
when we look at that check flag function

77
00:03:19,200 --> 00:03:21,440
we see it takes our input

78
00:03:21,440 --> 00:03:24,319
and it applies many constraints to that

79
00:03:24,319 --> 00:03:26,159
it has a lot of assumptions about our

80
00:03:26,159 --> 00:03:29,680
input that needs to be valid in order uh

81
00:03:29,680 --> 00:03:32,080
to return true in in order to say hey

82
00:03:32,080 --> 00:03:35,760
that's the correct input you submitted

83
00:03:35,760 --> 00:03:37,200
so we

84
00:03:37,200 --> 00:03:39,760
take those assumptions

85
00:03:39,760 --> 00:03:41,120
and we put them in a file in a

86
00:03:41,120 --> 00:03:43,599
spreadsheet whatever you prefer

87
00:03:43,599 --> 00:03:45,440
those are a lot of

88
00:03:45,440 --> 00:03:47,840
assumptions

89
00:03:49,280 --> 00:03:50,319
and then

90
00:03:50,319 --> 00:03:52,159
on a piece of paper

91
00:03:52,159 --> 00:03:55,120
we can try to solve them we start with

92
00:03:55,120 --> 00:03:58,000
the simplest one like static assignments

93
00:03:58,000 --> 00:04:00,159
like some calculations and work our way

94
00:04:00,159 --> 00:04:03,760
to the more complicated ones

95
00:04:04,319 --> 00:04:05,439
this is

96
00:04:05,439 --> 00:04:08,480
not very reasonable

97
00:04:08,480 --> 00:04:11,360
especially not in a ctf it just takes

98
00:04:11,360 --> 00:04:13,760
forever

99
00:04:13,760 --> 00:04:16,320
we can do better

100
00:04:16,320 --> 00:04:18,320
we can do better with uh

101
00:04:18,320 --> 00:04:21,440
smt solving a great example of an smt

102
00:04:21,440 --> 00:04:24,479
solver is microsoft set 3

103
00:04:24,479 --> 00:04:26,560
which can determine if a mathematical

104
00:04:26,560 --> 00:04:29,360
formula is satisfiable or not and it

105
00:04:29,360 --> 00:04:31,680
builds the basis for most symbolic

106
00:04:31,680 --> 00:04:34,080
execution frameworks

107
00:04:34,080 --> 00:04:35,680
how does it work

108
00:04:35,680 --> 00:04:38,080
let's do a logic puzzle

109
00:04:38,080 --> 00:04:40,160
imagine you're stranded on a deserted

110
00:04:40,160 --> 00:04:41,360
island

111
00:04:41,360 --> 00:04:44,000
and a storm brews up and you're trying

112
00:04:44,000 --> 00:04:45,919
to seek shelter and you see this big

113
00:04:45,919 --> 00:04:47,440
castle

114
00:04:47,440 --> 00:04:49,040
there are two people in front of the

115
00:04:49,040 --> 00:04:51,600
castle that say hey we can let you in if

116
00:04:51,600 --> 00:04:53,759
you solve a puzzle

117
00:04:53,759 --> 00:04:54,479
so

118
00:04:54,479 --> 00:04:56,400
there are two kinds of people in that

119
00:04:56,400 --> 00:04:58,960
island the knights that always tell the

120
00:04:58,960 --> 00:04:59,759
truth

121
00:04:59,759 --> 00:05:02,560
and knaves that always lie

122
00:05:02,560 --> 00:05:04,479
so you have those two people in front of

123
00:05:04,479 --> 00:05:05,440
you

124
00:05:05,440 --> 00:05:08,080
one is called red and one is called blue

125
00:05:08,080 --> 00:05:11,840
and blue tells you we are both knaves

126
00:05:11,840 --> 00:05:13,919
can you figure out which of them is the

127
00:05:13,919 --> 00:05:16,320
knight

128
00:05:16,320 --> 00:05:19,639
any ideas

129
00:05:26,080 --> 00:05:28,400
i'll show you the solution it must be

130
00:05:28,400 --> 00:05:29,199
red

131
00:05:29,199 --> 00:05:31,840
because blue cannot be a knight if we

132
00:05:31,840 --> 00:05:34,320
apply a logic if blue would have been a

133
00:05:34,320 --> 00:05:35,280
knight

134
00:05:35,280 --> 00:05:37,280
he would have told a lie which is

135
00:05:37,280 --> 00:05:39,039
unfeasible since

136
00:05:39,039 --> 00:05:42,000
knights cannot lie

137
00:05:44,639 --> 00:05:47,680
and this is just what an smt solver is

138
00:05:47,680 --> 00:05:49,919
doing under the hood we gave it a

139
00:05:49,919 --> 00:05:52,639
formula and it tries to evaluate is it

140
00:05:52,639 --> 00:05:55,039
satisfiable by that logic can it return

141
00:05:55,039 --> 00:05:55,919
true

142
00:05:55,919 --> 00:05:58,639
or isn't it

143
00:05:58,639 --> 00:06:01,039
there are two kinds of those solvers

144
00:06:01,039 --> 00:06:03,520
there's boolean satisfiable theory

145
00:06:03,520 --> 00:06:06,000
solvers which just fill in ones and

146
00:06:06,000 --> 00:06:09,120
zeros to try is it satisfiable

147
00:06:09,120 --> 00:06:11,039
and there's the a little bit more

148
00:06:11,039 --> 00:06:13,960
complicated smt solving satisfiable

149
00:06:13,960 --> 00:06:16,800
satisfiability modular theories

150
00:06:16,800 --> 00:06:19,280
which can even put in new formulas

151
00:06:19,280 --> 00:06:21,680
integers strings new functions it's

152
00:06:21,680 --> 00:06:22,960
really cool

153
00:06:22,960 --> 00:06:26,160
um so basically sat solving is the

154
00:06:26,160 --> 00:06:28,800
simple one with propositional logic and

155
00:06:28,800 --> 00:06:31,520
smt solving builds up on that but with

156
00:06:31,520 --> 00:06:35,479
more intricate input

157
00:06:37,039 --> 00:06:39,840
how do we do that in practice we install

158
00:06:39,840 --> 00:06:42,720
set three and please install the set

159
00:06:42,720 --> 00:06:44,960
three solver package because if you're

160
00:06:44,960 --> 00:06:47,360
gonna install set three it's going to be

161
00:06:47,360 --> 00:06:48,720
a tool for

162
00:06:48,720 --> 00:06:51,599
set fs to s3 buckets something

163
00:06:51,599 --> 00:06:53,280
definitely not what you're gonna want to

164
00:06:53,280 --> 00:06:58,080
do for your ctf so set resolver

165
00:06:58,960 --> 00:07:01,280
then it's very simple you

166
00:07:01,280 --> 00:07:04,240
define key space for your input

167
00:07:04,240 --> 00:07:07,199
and you instantiate the solver

168
00:07:07,199 --> 00:07:09,199
and then you're gonna fill in

169
00:07:09,199 --> 00:07:11,199
all the constraints

170
00:07:11,199 --> 00:07:13,120
all the constraints that we've extracted

171
00:07:13,120 --> 00:07:14,000
before

172
00:07:14,000 --> 00:07:15,280
by hand

173
00:07:15,280 --> 00:07:16,960
in python

174
00:07:16,960 --> 00:07:19,520
all the constraints and then you can

175
00:07:19,520 --> 00:07:22,319
check are they satisfiable and if they

176
00:07:22,319 --> 00:07:25,599
are you can concretize them and get a

177
00:07:25,599 --> 00:07:27,520
value back

178
00:07:27,520 --> 00:07:30,319
which in this case will be the flag you

179
00:07:30,319 --> 00:07:34,000
can hear i'm not that excited

180
00:07:34,000 --> 00:07:36,319
about that solution because extracting

181
00:07:36,319 --> 00:07:38,960
all those constraints take forever and

182
00:07:38,960 --> 00:07:40,880
especially in the ctf where time is

183
00:07:40,880 --> 00:07:41,919
everything

184
00:07:41,919 --> 00:07:44,879
so we can do better

185
00:07:44,879 --> 00:07:48,560
100 lines of code 91 constraints

186
00:07:48,560 --> 00:07:53,560
lots of constraints for the quote

187
00:08:04,080 --> 00:08:05,680
so

188
00:08:05,680 --> 00:08:07,199
if we're going to apply symbolic

189
00:08:07,199 --> 00:08:09,759
execution do we have any guesses to how

190
00:08:09,759 --> 00:08:13,280
many lines of code we can reduce it

191
00:08:13,280 --> 00:08:16,960
from around 100

192
00:08:19,759 --> 00:08:23,599
one line possibly but i say we can do

193
00:08:23,599 --> 00:08:28,160
about four if we like clean code

194
00:08:28,160 --> 00:08:30,800
so this would be the exact same solution

195
00:08:30,800 --> 00:08:32,880
for the exact same challenge just with

196
00:08:32,880 --> 00:08:34,719
symbolic execution

197
00:08:34,719 --> 00:08:36,479
what all this code is doing we're going

198
00:08:36,479 --> 00:08:40,958
to look at in the angular hands-on part

199
00:08:40,958 --> 00:08:41,760
so

200
00:08:41,760 --> 00:08:44,480
let's compare them

201
00:08:44,480 --> 00:08:46,399
brute force is infeasible the

202
00:08:46,399 --> 00:08:49,120
computation just takes way too long

203
00:08:49,120 --> 00:08:51,279
solving it by hand

204
00:08:51,279 --> 00:08:53,600
a really really long implementation time

205
00:08:53,600 --> 00:08:55,519
but it could be done

206
00:08:55,519 --> 00:08:58,720
we have reduced that via set 3

207
00:08:58,720 --> 00:09:01,040
and have a long implementation time with

208
00:09:01,040 --> 00:09:02,720
a short computation

209
00:09:02,720 --> 00:09:04,720
and we have even reduced that by

210
00:09:04,720 --> 00:09:08,600
applying symbolic execution

211
00:09:14,240 --> 00:09:15,040
so

212
00:09:15,040 --> 00:09:17,440
how do those sims how do those systems

213
00:09:17,440 --> 00:09:20,440
work

214
00:09:22,560 --> 00:09:24,640
imagine you have a certain state in a

215
00:09:24,640 --> 00:09:26,880
binary that's interesting for example

216
00:09:26,880 --> 00:09:28,640
you have some code that's been

217
00:09:28,640 --> 00:09:31,440
de-obfuscated you have a binary state

218
00:09:31,440 --> 00:09:34,000
that's unpacked or you have like in this

219
00:09:34,000 --> 00:09:37,200
case a crackme that has a solution which

220
00:09:37,200 --> 00:09:38,320
says hey

221
00:09:38,320 --> 00:09:40,080
the correct me solved

222
00:09:40,080 --> 00:09:42,560
the symbolic execution tries to match

223
00:09:42,560 --> 00:09:44,640
those binary states

224
00:09:44,640 --> 00:09:46,399
to an input

225
00:09:46,399 --> 00:09:47,200
so

226
00:09:47,200 --> 00:09:48,839
it can

227
00:09:48,839 --> 00:09:52,399
visualize we can we can visualize the

228
00:09:52,399 --> 00:09:54,640
your binaries as a tree with your basic

229
00:09:54,640 --> 00:09:56,640
blocks in the branches

230
00:09:56,640 --> 00:09:58,080
it walks those

231
00:09:58,080 --> 00:09:59,680
and it matches

232
00:09:59,680 --> 00:10:04,040
binary states to input

233
00:10:07,120 --> 00:10:10,320
let's look at the concrete execution

234
00:10:10,320 --> 00:10:12,880
um this is what you're gonna do if you

235
00:10:12,880 --> 00:10:13,839
just

236
00:10:13,839 --> 00:10:16,320
enter a program normal program run how

237
00:10:16,320 --> 00:10:18,880
you would do it in your shell you enter

238
00:10:18,880 --> 00:10:20,079
some value

239
00:10:20,079 --> 00:10:22,720
the value gets evaluated

240
00:10:22,720 --> 00:10:24,800
and based on that

241
00:10:24,800 --> 00:10:25,600
um

242
00:10:25,600 --> 00:10:27,519
yeah it prints

243
00:10:27,519 --> 00:10:30,079
it works or if you would have

244
00:10:30,079 --> 00:10:31,760
entered something higher than it would

245
00:10:31,760 --> 00:10:35,040
have executed the crash

246
00:10:35,279 --> 00:10:37,120
with symbolic execution you're not

247
00:10:37,120 --> 00:10:39,360
providing a concrete value

248
00:10:39,360 --> 00:10:42,560
but a symbolic one

249
00:10:42,800 --> 00:10:44,800
maybe this looks better

250
00:10:44,800 --> 00:10:46,399
um

251
00:10:46,399 --> 00:10:48,959
so you provide a symbolic

252
00:10:48,959 --> 00:10:51,040
value to your input

253
00:10:51,040 --> 00:10:53,600
and it evaluates both parts of the

254
00:10:53,600 --> 00:10:54,720
branch

255
00:10:54,720 --> 00:10:57,200
it keeps track of both states

256
00:10:57,200 --> 00:10:59,839
for your branch and it keeps track of

257
00:10:59,839 --> 00:11:02,640
the constraint in this case in this case

258
00:11:02,640 --> 00:11:05,360
that's um size your input

259
00:11:05,360 --> 00:11:08,000
has to be smaller than five

260
00:11:08,000 --> 00:11:10,640
if at any point your binary terminates

261
00:11:10,640 --> 00:11:12,880
either via a crash either via normal

262
00:11:12,880 --> 00:11:14,880
termination

263
00:11:14,880 --> 00:11:16,720
it takes those constraints it has

264
00:11:16,720 --> 00:11:19,279
accumulated over time and it solves them

265
00:11:19,279 --> 00:11:22,480
by an smt solver so you get a concrete

266
00:11:22,480 --> 00:11:25,279
example back

267
00:11:25,519 --> 00:11:28,800
this poses some problems

268
00:11:28,800 --> 00:11:30,560
for example if you have a loop

269
00:11:30,560 --> 00:11:33,200
and your loop depends on the symbolic

270
00:11:33,200 --> 00:11:36,000
value on the symbolic bit vector it can

271
00:11:36,000 --> 00:11:38,640
happen that it never exits the loop

272
00:11:38,640 --> 00:11:41,040
because it's it's hard for the symbolic

273
00:11:41,040 --> 00:11:43,519
execution tool to reach deep into the

274
00:11:43,519 --> 00:11:45,279
trees

275
00:11:45,279 --> 00:11:46,880
therefore

276
00:11:46,880 --> 00:11:48,720
there's another technique which is

277
00:11:48,720 --> 00:11:51,360
called concolic testing which is just a

278
00:11:51,360 --> 00:11:54,079
mix between concrete testing and

279
00:11:54,079 --> 00:11:57,600
symbolic execution we can regard it as

280
00:11:57,600 --> 00:11:59,040
seed driven

281
00:11:59,040 --> 00:12:02,319
symbolic execution

282
00:12:02,720 --> 00:12:05,839
so while symbolic execution systems just

283
00:12:05,839 --> 00:12:09,040
work all of your binary usually in a

284
00:12:09,040 --> 00:12:11,440
with the dfs algorithm you can change

285
00:12:11,440 --> 00:12:12,720
that

286
00:12:12,720 --> 00:12:13,600
the

287
00:12:13,600 --> 00:12:16,000
concolic execution

288
00:12:16,000 --> 00:12:18,720
first concretely executes

289
00:12:18,720 --> 00:12:20,880
and based on that concrete execution

290
00:12:20,880 --> 00:12:22,639
branches out

291
00:12:22,639 --> 00:12:25,200
so in this case you never have

292
00:12:25,200 --> 00:12:28,000
um problems that that you can't have a

293
00:12:28,000 --> 00:12:30,399
termination because it has to be it has

294
00:12:30,399 --> 00:12:33,760
to terminate at one point

295
00:12:33,920 --> 00:12:36,160
how does it work in code

296
00:12:36,160 --> 00:12:39,040
we provide our input concretely

297
00:12:39,040 --> 00:12:42,720
with some random seed it gets evaluated

298
00:12:42,720 --> 00:12:45,839
and it executes the printf while it has

299
00:12:45,839 --> 00:12:47,839
executed concretely it has still

300
00:12:47,839 --> 00:12:50,079
accumulated the constraints in this case

301
00:12:50,079 --> 00:12:51,839
that your input has to be smaller than

302
00:12:51,839 --> 00:12:52,880
five

303
00:12:52,880 --> 00:12:55,040
and it inverts them

304
00:12:55,040 --> 00:12:58,639
it inverts the last um

305
00:12:58,639 --> 00:13:02,720
accumulated constraint and that way

306
00:13:02,720 --> 00:13:05,040
you get access to the other side of the

307
00:13:05,040 --> 00:13:06,639
branch

308
00:13:06,639 --> 00:13:08,880
and from there on it can for example

309
00:13:08,880 --> 00:13:11,279
explore the crash function and it does

310
00:13:11,279 --> 00:13:13,920
that with all of your constraints so it

311
00:13:13,920 --> 00:13:16,560
takes the last constraint it negates it

312
00:13:16,560 --> 00:13:18,560
explores goes back to the last

313
00:13:18,560 --> 00:13:21,120
constraint negates it explores until

314
00:13:21,120 --> 00:13:24,399
there are no constraints left

315
00:13:26,480 --> 00:13:27,600
so

316
00:13:27,600 --> 00:13:30,639
if we compare them

317
00:13:30,639 --> 00:13:32,800
we have

318
00:13:32,800 --> 00:13:35,920
the solid the concrete approach

319
00:13:35,920 --> 00:13:37,200
which is

320
00:13:37,200 --> 00:13:38,639
very

321
00:13:38,639 --> 00:13:40,720
very labor intensive for not a lot of

322
00:13:40,720 --> 00:13:43,600
results um we have the more liquid

323
00:13:43,600 --> 00:13:45,600
approach that needs a high amount of

324
00:13:45,600 --> 00:13:47,279
computation

325
00:13:47,279 --> 00:13:49,360
and we have our slushy approach which in

326
00:13:49,360 --> 00:13:51,680
this case is concolic execution best of

327
00:13:51,680 --> 00:13:54,399
both worlds

328
00:13:54,720 --> 00:13:56,560
there are a lot of different frameworks

329
00:13:56,560 --> 00:13:58,160
a lot of different tools that you can

330
00:13:58,160 --> 00:14:01,600
use to achieve that

331
00:14:01,600 --> 00:14:04,720
let's look at some of them

332
00:14:05,199 --> 00:14:06,000
the

333
00:14:06,000 --> 00:14:07,839
squarey

334
00:14:07,839 --> 00:14:08,800
is a

335
00:14:08,800 --> 00:14:10,959
is a very cool tool it was developed by

336
00:14:10,959 --> 00:14:13,279
epfl as far as i know

337
00:14:13,279 --> 00:14:15,440
and you can use it to symbolically

338
00:14:15,440 --> 00:14:18,079
analyze whole systems so if you want to

339
00:14:18,079 --> 00:14:20,880
symbolically analyze a device driver or

340
00:14:20,880 --> 00:14:23,760
if you want to symbolically analyze um

341
00:14:23,760 --> 00:14:25,279
software with lots of complex

342
00:14:25,279 --> 00:14:27,600
interactions it's probably the tool of

343
00:14:27,600 --> 00:14:29,040
your choice

344
00:14:29,040 --> 00:14:31,519
but the downside is

345
00:14:31,519 --> 00:14:32,560
it's

346
00:14:32,560 --> 00:14:34,399
very hard to implement there's like a

347
00:14:34,399 --> 00:14:36,240
lot of stuff you need to consider it's a

348
00:14:36,240 --> 00:14:38,320
lot of code and it's probably not the

349
00:14:38,320 --> 00:14:40,639
best solution for your run-of-the-mill

350
00:14:40,639 --> 00:14:43,120
ctf

351
00:14:43,120 --> 00:14:45,519
a better solution for that

352
00:14:45,519 --> 00:14:48,160
are user level tools for example angular

353
00:14:48,160 --> 00:14:50,720
triton or manticore

354
00:14:50,720 --> 00:14:52,800
they provide a great mix between

355
00:14:52,800 --> 00:14:54,839
convenience and speed and

356
00:14:54,839 --> 00:14:57,120
instrumentability and are really cool

357
00:14:57,120 --> 00:15:00,720
tools for for your ctf

358
00:15:00,720 --> 00:15:03,199
the workflow is a lot smaller

359
00:15:03,199 --> 00:15:04,160
it's a lot

360
00:15:04,160 --> 00:15:06,639
more realistic to implement them

361
00:15:06,639 --> 00:15:10,720
the code is a lot smaller as well

362
00:15:11,680 --> 00:15:14,240
and finally there's also code level

363
00:15:14,240 --> 00:15:17,040
symbolic execution with tools like cli

364
00:15:17,040 --> 00:15:19,199
so if you have access to the source code

365
00:15:19,199 --> 00:15:22,079
or you clean some decompile code up and

366
00:15:22,079 --> 00:15:24,399
you just want to analyze

367
00:15:24,399 --> 00:15:27,360
a certain function you can compile it

368
00:15:27,360 --> 00:15:28,480
with cli

369
00:15:28,480 --> 00:15:30,399
it's llvm based

370
00:15:30,399 --> 00:15:32,320
for receive functions

371
00:15:32,320 --> 00:15:35,279
and yeah then then you can symbolically

372
00:15:35,279 --> 00:15:38,240
execute your custom compile code this is

373
00:15:38,240 --> 00:15:40,240
really cool because you don't have to do

374
00:15:40,240 --> 00:15:42,880
a lot of work you just have to mark your

375
00:15:42,880 --> 00:15:45,440
variables as symbolic you can put some

376
00:15:45,440 --> 00:15:47,040
assertion in it

377
00:15:47,040 --> 00:15:48,720
and basically you're done but the

378
00:15:48,720 --> 00:15:51,199
downside is that you need to have access

379
00:15:51,199 --> 00:15:54,839
to the source code

380
00:15:55,279 --> 00:15:58,800
so not a lot of code

381
00:16:00,160 --> 00:16:01,920
as you can see

382
00:16:01,920 --> 00:16:03,680
there are lots of

383
00:16:03,680 --> 00:16:05,519
different tools for

384
00:16:05,519 --> 00:16:08,160
lots of different jobs

385
00:16:08,160 --> 00:16:10,800
but generally the angle framework is

386
00:16:10,800 --> 00:16:12,160
best

387
00:16:12,160 --> 00:16:15,040
for ctf

388
00:16:18,959 --> 00:16:21,440
let's recap for a second

389
00:16:21,440 --> 00:16:24,720
symbolic execution tries to match input

390
00:16:24,720 --> 00:16:26,240
to binary state

391
00:16:26,240 --> 00:16:28,639
it traverses an execution tree it

392
00:16:28,639 --> 00:16:31,839
accumulates the constraints of a path so

393
00:16:31,839 --> 00:16:33,759
what you will put in an if condition for

394
00:16:33,759 --> 00:16:36,800
example and it solves them using an smt

395
00:16:36,800 --> 00:16:40,079
solver to get a concrete output back

396
00:16:40,079 --> 00:16:42,720
concolic execution builds on that by

397
00:16:42,720 --> 00:16:44,639
first driving it with the seat

398
00:16:44,639 --> 00:16:46,720
and then branching out for that so you

399
00:16:46,720 --> 00:16:49,040
have higher performance the downside is

400
00:16:49,040 --> 00:16:51,040
you might lose some coverage because

401
00:16:51,040 --> 00:16:53,360
symbolic execution explores all of the

402
00:16:53,360 --> 00:16:55,279
system given enough computational

403
00:16:55,279 --> 00:16:56,399
resources

404
00:16:56,399 --> 00:16:58,720
while concolic execution has more of a

405
00:16:58,720 --> 00:17:00,639
fuzzing approach

406
00:17:00,639 --> 00:17:02,959
and there's a lot of different tools for

407
00:17:02,959 --> 00:17:04,880
lots of different jobs you might want to

408
00:17:04,880 --> 00:17:07,520
use anger

409
00:17:07,520 --> 00:17:09,280
which we're going to look at now how

410
00:17:09,280 --> 00:17:11,918
convenient

411
00:17:12,079 --> 00:17:14,160
angular is really cool it has a python 3

412
00:17:14,160 --> 00:17:16,480
interface who doesn't love that

413
00:17:16,480 --> 00:17:20,160
it has been used in countless ctf you

414
00:17:20,160 --> 00:17:22,000
can reverse with it you can build drop

415
00:17:22,000 --> 00:17:24,000
chains with it you it has even been

416
00:17:24,000 --> 00:17:26,480
integrated into fasting tools

417
00:17:26,480 --> 00:17:29,439
it's really convenient

418
00:17:29,520 --> 00:17:30,880
so

419
00:17:30,880 --> 00:17:32,400
angle workflow

420
00:17:32,400 --> 00:17:34,960
you've seen this before we had lots of

421
00:17:34,960 --> 00:17:35,760
code

422
00:17:35,760 --> 00:17:37,440
we reduced it to

423
00:17:37,440 --> 00:17:39,760
not a lot of code

424
00:17:39,760 --> 00:17:42,320
you also seen this before it's the user

425
00:17:42,320 --> 00:17:43,919
mode

426
00:17:43,919 --> 00:17:45,280
workflow

427
00:17:45,280 --> 00:17:47,039
for symbolic execution which we're going

428
00:17:47,039 --> 00:17:50,000
to look at in depth now

429
00:17:50,000 --> 00:17:52,320
so first we want to initialize the

430
00:17:52,320 --> 00:17:54,880
program state we want to get

431
00:17:54,880 --> 00:17:58,000
our input our symbolic input into

432
00:17:58,000 --> 00:18:01,640
our our target

433
00:18:02,400 --> 00:18:03,280
and

434
00:18:03,280 --> 00:18:05,679
this is uh the

435
00:18:05,679 --> 00:18:07,440
this is some code for

436
00:18:07,440 --> 00:18:09,679
the the correct me that we want to solve

437
00:18:09,679 --> 00:18:11,760
so it just takes some values from

438
00:18:11,760 --> 00:18:14,720
standard input puts them into a buffer

439
00:18:14,720 --> 00:18:16,880
evaluates them and based on that it

440
00:18:16,880 --> 00:18:19,919
either says hey the binary solved or hey

441
00:18:19,919 --> 00:18:23,360
the binary isn't solved

442
00:18:24,480 --> 00:18:27,480
so

443
00:18:34,559 --> 00:18:37,450
next time i'm gonna use windows i swear

444
00:18:37,450 --> 00:18:40,559
[Laughter]

445
00:18:40,559 --> 00:18:43,840
so we uh initialize our project uh we

446
00:18:43,840 --> 00:18:47,039
can put in some some load options

447
00:18:47,039 --> 00:18:49,039
let me try something real quick

448
00:18:49,039 --> 00:18:50,880
maybe this is better

449
00:18:50,880 --> 00:18:55,280
um okay we can provide some input

450
00:18:55,360 --> 00:18:57,039
in this case we initialize the project

451
00:18:57,039 --> 00:18:59,440
we can provide the basis address we can

452
00:18:59,440 --> 00:19:01,520
provide if we want to

453
00:19:01,520 --> 00:19:04,320
load external libraries stuff like that

454
00:19:04,320 --> 00:19:06,559
then we initialize the simulation

455
00:19:06,559 --> 00:19:08,640
manager this is important because this

456
00:19:08,640 --> 00:19:10,799
is the component that will explore all

457
00:19:10,799 --> 00:19:13,360
of the tree

458
00:19:13,840 --> 00:19:16,160
we can provide a target address the

459
00:19:16,160 --> 00:19:18,320
address where for example

460
00:19:18,320 --> 00:19:19,679
a solve string

461
00:19:19,679 --> 00:19:20,799
is being

462
00:19:20,799 --> 00:19:22,799
shown

463
00:19:22,799 --> 00:19:24,720
and finally we can print out the

464
00:19:24,720 --> 00:19:27,760
concretized result which usually is the

465
00:19:27,760 --> 00:19:30,400
flag uh by the way i'm gonna release the

466
00:19:30,400 --> 00:19:33,039
slides afterwards so you can just

467
00:19:33,039 --> 00:19:35,360
copy the code it's really convenient to

468
00:19:35,360 --> 00:19:37,760
have some boilerplate anchor code for

469
00:19:37,760 --> 00:19:40,799
whatever ctf you want to play

470
00:19:40,799 --> 00:19:41,919
um

471
00:19:41,919 --> 00:19:43,840
this was like a really really simple

472
00:19:43,840 --> 00:19:46,160
example and this is why i picked the ctf

473
00:19:46,160 --> 00:19:48,720
um the the set three or robot ctf

474
00:19:48,720 --> 00:19:51,360
challenge but there are

475
00:19:51,360 --> 00:19:54,160
sometimes a bit more tricky ones um for

476
00:19:54,160 --> 00:19:56,480
example if you have a complicated time

477
00:19:56,480 --> 00:19:58,799
waste function before your actual code

478
00:19:58,799 --> 00:20:00,960
which just is there to

479
00:20:00,960 --> 00:20:02,320
mess with you

480
00:20:02,320 --> 00:20:04,640
so imagine there are lots of

481
00:20:04,640 --> 00:20:07,039
lots of code in there or long sleep

482
00:20:07,039 --> 00:20:08,960
functions or something that's completely

483
00:20:08,960 --> 00:20:10,880
unrelated to what we actually want to

484
00:20:10,880 --> 00:20:13,280
explore

485
00:20:13,760 --> 00:20:16,320
we can mitigate that by adding a start

486
00:20:16,320 --> 00:20:18,640
address where we want to start our

487
00:20:18,640 --> 00:20:21,520
symbolic execution this is cool for

488
00:20:21,520 --> 00:20:23,919
functions that want to waste time for

489
00:20:23,919 --> 00:20:25,440
bypassing

490
00:20:25,440 --> 00:20:28,400
glyphses setup functions or

491
00:20:28,400 --> 00:20:30,400
if you want to define

492
00:20:30,400 --> 00:20:33,960
custom input

493
00:20:35,760 --> 00:20:37,039
so

494
00:20:37,039 --> 00:20:39,760
by now we didn't have to define input

495
00:20:39,760 --> 00:20:42,000
because anger automatically tries to

496
00:20:42,000 --> 00:20:44,320
provide input for your binary

497
00:20:44,320 --> 00:20:46,720
this works great with simple input but

498
00:20:46,720 --> 00:20:48,720
as soon as it gets a little bit more

499
00:20:48,720 --> 00:20:50,880
complicated we're gonna have to do that

500
00:20:50,880 --> 00:20:52,080
by hand

501
00:20:52,080 --> 00:20:54,320
for example with the complex format

502
00:20:54,320 --> 00:20:57,679
strings with multiple parameters or if

503
00:20:57,679 --> 00:20:59,600
it's over memory of a file over the

504
00:20:59,600 --> 00:21:02,400
network

505
00:21:02,400 --> 00:21:04,000
and for that

506
00:21:04,000 --> 00:21:06,240
um we have a data structure called the

507
00:21:06,240 --> 00:21:07,919
symbolic bit vector

508
00:21:07,919 --> 00:21:10,240
which angular uses for the storage of

509
00:21:10,240 --> 00:21:12,400
its symbolic

510
00:21:12,400 --> 00:21:14,240
variables

511
00:21:14,240 --> 00:21:17,120
you can just instantiate it with the a

512
00:21:17,120 --> 00:21:19,039
name which anger internally uses to

513
00:21:19,039 --> 00:21:20,880
reference it

514
00:21:20,880 --> 00:21:23,919
and with its size and you can put it

515
00:21:23,919 --> 00:21:27,600
into registers into memory arc v onto

516
00:21:27,600 --> 00:21:31,520
the stack whatever you want

517
00:21:31,520 --> 00:21:34,159
so let's look an example

518
00:21:34,159 --> 00:21:35,919
where we don't have to provide one

519
00:21:35,919 --> 00:21:40,039
password but two

520
00:21:44,880 --> 00:21:47,760
in this case we set our state

521
00:21:47,760 --> 00:21:50,559
right after we would have provided our

522
00:21:50,559 --> 00:21:54,399
values normally as a user

523
00:21:54,960 --> 00:21:56,840
then we initialize the

524
00:21:56,840 --> 00:22:01,280
stack define our password bit vectors

525
00:22:01,280 --> 00:22:03,600
we align the stack pointer for our new

526
00:22:03,600 --> 00:22:06,080
password vectors

527
00:22:06,080 --> 00:22:07,919
we push them onto the stack

528
00:22:07,919 --> 00:22:10,080
this is really just like coding basic

529
00:22:10,080 --> 00:22:11,600
assembly

530
00:22:11,600 --> 00:22:12,880
and then

531
00:22:12,880 --> 00:22:16,960
finally we run the exploration algorithm

532
00:22:16,960 --> 00:22:19,360
and then we can solve the bit vector if

533
00:22:19,360 --> 00:22:23,399
the solution has been found

534
00:22:28,240 --> 00:22:31,120
so really easy we just set

535
00:22:31,120 --> 00:22:34,880
our input after uh um we just set our

536
00:22:34,880 --> 00:22:36,720
starting address right after providing

537
00:22:36,720 --> 00:22:39,360
the input we emulate the stack frame and

538
00:22:39,360 --> 00:22:43,600
resolve and concretize the output

539
00:22:44,799 --> 00:22:47,200
very similar is the symbolic file system

540
00:22:47,200 --> 00:22:49,440
imagine you don't provide your input

541
00:22:49,440 --> 00:22:52,400
over standard input but over a file this

542
00:22:52,400 --> 00:22:54,720
can happen in a real world situation or

543
00:22:54,720 --> 00:22:56,960
in a ctf

544
00:22:56,960 --> 00:23:00,080
and the approach is pretty similar

545
00:23:00,080 --> 00:23:03,120
we set our starting address after the

546
00:23:03,120 --> 00:23:05,760
input gets submitted

547
00:23:05,760 --> 00:23:09,120
we define symbolic memory and now comes

548
00:23:09,120 --> 00:23:11,440
some boilerplate code we add our

549
00:23:11,440 --> 00:23:13,440
password bit vector to the symbolic

550
00:23:13,440 --> 00:23:14,640
memory

551
00:23:14,640 --> 00:23:17,760
we add a symbolic file

552
00:23:17,760 --> 00:23:20,320
we define the symbolic file system and

553
00:23:20,320 --> 00:23:23,440
the simulated file and we solve it like

554
00:23:23,440 --> 00:23:25,280
this this code you're probably gonna

555
00:23:25,280 --> 00:23:28,240
write one time or copy one time and just

556
00:23:28,240 --> 00:23:31,440
change the parameters of it

557
00:23:31,440 --> 00:23:32,240
yeah

558
00:23:32,240 --> 00:23:34,880
it's just important that after you have

559
00:23:34,880 --> 00:23:36,799
an exploration and after a solution has

560
00:23:36,799 --> 00:23:39,039
been fined you need to concretize the

561
00:23:39,039 --> 00:23:41,840
bit vector

562
00:23:41,840 --> 00:23:44,559
but still fairly easy as we said we set

563
00:23:44,559 --> 00:23:46,240
our input

564
00:23:46,240 --> 00:23:47,440
right after

565
00:23:47,440 --> 00:23:49,279
getting the state we emulate the file

566
00:23:49,279 --> 00:23:51,600
system and resolve and concretize the

567
00:23:51,600 --> 00:23:54,000
output

568
00:23:54,159 --> 00:23:56,480
now we know how data gets into the

569
00:23:56,480 --> 00:23:59,919
symbolic execution framework

570
00:23:59,919 --> 00:24:02,000
now we have to define a target what do

571
00:24:02,000 --> 00:24:04,480
we want to achieve where to do we want

572
00:24:04,480 --> 00:24:07,440
to explore to

573
00:24:07,520 --> 00:24:09,520
and therefore we can just define an

574
00:24:09,520 --> 00:24:12,559
address pretty simple we we have some

575
00:24:12,559 --> 00:24:14,640
solved function some string

576
00:24:14,640 --> 00:24:16,840
whatever you

577
00:24:16,840 --> 00:24:21,360
want however we can also

578
00:24:21,360 --> 00:24:25,039
enter target conditions so we can say if

579
00:24:25,039 --> 00:24:27,760
a string like solved gets written to

580
00:24:27,760 --> 00:24:30,000
standard output

581
00:24:30,000 --> 00:24:32,320
we have found a solution so we can also

582
00:24:32,320 --> 00:24:36,200
search for that

583
00:24:48,320 --> 00:24:50,240
so now we have

584
00:24:50,240 --> 00:24:52,159
most what it takes for for most

585
00:24:52,159 --> 00:24:54,159
challenges like you should be able to

586
00:24:54,159 --> 00:24:57,120
solve most simple symbolic execution

587
00:24:57,120 --> 00:24:58,159
challenges

588
00:24:58,159 --> 00:24:59,120
um

589
00:24:59,120 --> 00:25:01,520
but sometimes it's a bit more tricky

590
00:25:01,520 --> 00:25:03,600
especially with big binaries

591
00:25:03,600 --> 00:25:04,880
and

592
00:25:04,880 --> 00:25:08,000
there you have to define a void state

593
00:25:08,000 --> 00:25:11,039
so a big problem with symbolic execution

594
00:25:11,039 --> 00:25:11,919
is

595
00:25:11,919 --> 00:25:14,559
that because it takes both sides of

596
00:25:14,559 --> 00:25:16,320
every branch you're dealing with

597
00:25:16,320 --> 00:25:18,640
exponential growth and this can cause

598
00:25:18,640 --> 00:25:20,960
state explosion so

599
00:25:20,960 --> 00:25:23,200
just a massive amount of data that you

600
00:25:23,200 --> 00:25:24,720
have to search through that you have to

601
00:25:24,720 --> 00:25:26,960
concretize that you have to work with

602
00:25:26,960 --> 00:25:30,400
this slows down your your progress a lot

603
00:25:30,400 --> 00:25:33,840
especially with big binaries

604
00:25:33,840 --> 00:25:35,760
but fear not

605
00:25:35,760 --> 00:25:38,320
you can just exclude addresses or

606
00:25:38,320 --> 00:25:39,840
exclude the

607
00:25:39,840 --> 00:25:42,880
data in in standard out as we did before

608
00:25:42,880 --> 00:25:44,640
provided to the symbolic execution

609
00:25:44,640 --> 00:25:47,039
framework and it will try

610
00:25:47,039 --> 00:25:49,679
to avoid it

611
00:25:49,679 --> 00:25:51,919
this works best if you manually reverse

612
00:25:51,919 --> 00:25:54,840
engineer the binary if you

613
00:25:54,840 --> 00:25:56,720
manually

614
00:25:56,720 --> 00:25:59,840
yeah cut out paths that you're not gonna

615
00:25:59,840 --> 00:26:00,720
need

616
00:26:00,720 --> 00:26:01,679
um

617
00:26:01,679 --> 00:26:03,679
it's really cool because you can that

618
00:26:03,679 --> 00:26:05,360
way you can

619
00:26:05,360 --> 00:26:08,240
guide your symbolic execution framework

620
00:26:08,240 --> 00:26:10,799
into the direction of where you actually

621
00:26:10,799 --> 00:26:13,120
want to search instead of exploring

622
00:26:13,120 --> 00:26:14,880
every other stuff that you don't even

623
00:26:14,880 --> 00:26:17,520
need at all

624
00:26:18,640 --> 00:26:21,279
so a big challenge i had when starting

625
00:26:21,279 --> 00:26:23,520
out with anger was that i had no idea

626
00:26:23,520 --> 00:26:26,640
what was going on it's hard to debug it

627
00:26:26,640 --> 00:26:29,200
i i just didn't find out where my issues

628
00:26:29,200 --> 00:26:30,159
were

629
00:26:30,159 --> 00:26:32,559
um and so i came up with it with a

630
00:26:32,559 --> 00:26:33,760
strategy

631
00:26:33,760 --> 00:26:34,720
um

632
00:26:34,720 --> 00:26:37,520
i found a way how you can export

633
00:26:37,520 --> 00:26:39,039
code coverage

634
00:26:39,039 --> 00:26:40,559
which you can simply load into

635
00:26:40,559 --> 00:26:43,120
lighthouse you can

636
00:26:43,120 --> 00:26:45,200
explore the bottlenecks and you can fix

637
00:26:45,200 --> 00:26:47,520
them by for example avoiding states that

638
00:26:47,520 --> 00:26:49,440
get executed that take up a lot of

639
00:26:49,440 --> 00:26:51,279
unneeded time

640
00:26:51,279 --> 00:26:52,880
how do we do that

641
00:26:52,880 --> 00:26:55,440
there's a step function

642
00:26:55,440 --> 00:26:57,120
it's basically a callback for the

643
00:26:57,120 --> 00:26:58,880
exploration algorithm

644
00:26:58,880 --> 00:27:00,000
and

645
00:27:00,000 --> 00:27:01,840
i call this nice function that

646
00:27:01,840 --> 00:27:05,520
visualizes and exports the code coverage

647
00:27:05,520 --> 00:27:07,760
in this case it visualizes what input is

648
00:27:07,760 --> 00:27:11,520
provided to angular right now

649
00:27:12,159 --> 00:27:15,520
it found a solution

650
00:27:15,840 --> 00:27:18,240
and we're going to look at the coverage

651
00:27:18,240 --> 00:27:20,880
and we see we have basic block coverage

652
00:27:20,880 --> 00:27:22,799
that has been exported

653
00:27:22,799 --> 00:27:25,039
which we can load into lighthouse

654
00:27:25,039 --> 00:27:26,640
so that way you can see what

655
00:27:26,640 --> 00:27:28,799
instructions have been hit

656
00:27:28,799 --> 00:27:32,159
and if there are unneeded instructions

657
00:27:32,159 --> 00:27:36,399
unneeded code you can just avoid it

658
00:27:36,720 --> 00:27:39,440
and guide and we're into resolving the

659
00:27:39,440 --> 00:27:41,120
issues the performance issues that you

660
00:27:41,120 --> 00:27:44,080
are experiencing

661
00:27:46,080 --> 00:27:48,880
so this already helps a lot

662
00:27:48,880 --> 00:27:50,720
and another thing that helps a lot is

663
00:27:50,720 --> 00:27:53,279
limiting the constraint space

664
00:27:53,279 --> 00:27:56,399
so in ctf you often have implicit

665
00:27:56,399 --> 00:27:59,039
constraints

666
00:27:59,919 --> 00:28:02,880
so to solve it you just have to

667
00:28:02,880 --> 00:28:04,960
import the constraint solver engine in

668
00:28:04,960 --> 00:28:07,760
this case it's a clarify another packet

669
00:28:07,760 --> 00:28:10,000
to import

670
00:28:10,000 --> 00:28:11,279
then you

671
00:28:11,279 --> 00:28:13,679
have to create a bit vector for for

672
00:28:13,679 --> 00:28:16,080
applying manual constraints you always

673
00:28:16,080 --> 00:28:18,480
need to define your own bit vector it's

674
00:28:18,480 --> 00:28:22,960
pretty easy in this case just over arc v

675
00:28:22,960 --> 00:28:24,960
and then you can apply constraints in

676
00:28:24,960 --> 00:28:26,159
this case

677
00:28:26,159 --> 00:28:28,080
only print out the human readable

678
00:28:28,080 --> 00:28:29,360
characters

679
00:28:29,360 --> 00:28:32,240
it's the case for most ctf and it helps

680
00:28:32,240 --> 00:28:34,080
the framework to be a lot quicker

681
00:28:34,080 --> 00:28:35,919
because it doesn't have to evaluate and

682
00:28:35,919 --> 00:28:39,760
anything just the human readable stuff

683
00:28:39,760 --> 00:28:40,720
or

684
00:28:40,720 --> 00:28:43,120
if you know that your solution will

685
00:28:43,120 --> 00:28:45,679
start with a certain flag format you can

686
00:28:45,679 --> 00:28:47,919
apply manual constraints that it has to

687
00:28:47,919 --> 00:28:50,240
start with that specif

688
00:28:50,240 --> 00:28:52,720
with that specific flag format and also

689
00:28:52,720 --> 00:28:56,399
save a lot of computation time

690
00:28:56,399 --> 00:28:58,559
afterwards you can just explore it as

691
00:28:58,559 --> 00:29:02,639
known and finally evaluate it

692
00:29:03,200 --> 00:29:05,600
so it's uh really helpful for your ctf

693
00:29:05,600 --> 00:29:08,240
to especially the only printable

694
00:29:08,240 --> 00:29:10,399
characters constraint

695
00:29:10,399 --> 00:29:13,840
helped me in the past a lot

696
00:29:14,799 --> 00:29:15,840
so

697
00:29:15,840 --> 00:29:17,760
anger

698
00:29:17,760 --> 00:29:19,760
in its essence is a an emulation

699
00:29:19,760 --> 00:29:21,120
framework

700
00:29:21,120 --> 00:29:23,279
and as you might know emulation

701
00:29:23,279 --> 00:29:26,559
frameworks and low-level stuff

702
00:29:26,559 --> 00:29:27,760
doesn't

703
00:29:27,760 --> 00:29:30,960
like each other so sometimes if if a lot

704
00:29:30,960 --> 00:29:33,200
of low-level stuff is being called

705
00:29:33,200 --> 00:29:36,640
you have to use a simulated procedure

706
00:29:36,640 --> 00:29:38,840
it's very simple it just

707
00:29:38,840 --> 00:29:41,520
overwrites the emulation with some

708
00:29:41,520 --> 00:29:44,960
custom python code that you can submit

709
00:29:44,960 --> 00:29:47,120
so you can basically

710
00:29:47,120 --> 00:29:49,039
write the emulation yourself

711
00:29:49,039 --> 00:29:51,039
or you can if you have some complicated

712
00:29:51,039 --> 00:29:52,960
crypto stuff you can make it always

713
00:29:52,960 --> 00:29:55,760
return the same values and see how they

714
00:29:55,760 --> 00:29:58,480
interact there's a lot there's yeah lots

715
00:29:58,480 --> 00:30:00,880
of approaches you can take

716
00:30:00,880 --> 00:30:03,440
with the simulated procedures

717
00:30:03,440 --> 00:30:07,039
so you just define a new function you

718
00:30:07,039 --> 00:30:11,360
hook the symbol and that's about it

719
00:30:13,279 --> 00:30:16,559
if that's too expensive for you if yeah

720
00:30:16,559 --> 00:30:19,120
a lot of code to write you can also use

721
00:30:19,120 --> 00:30:21,200
project hooks user hooks

722
00:30:21,200 --> 00:30:23,039
where you just specify an address you

723
00:30:23,039 --> 00:30:24,799
specify how many bytes you want to

724
00:30:24,799 --> 00:30:28,080
overwrite and then afterwards you just

725
00:30:28,080 --> 00:30:30,320
specify in

726
00:30:30,320 --> 00:30:33,679
angus sudo python assembly what you want

727
00:30:33,679 --> 00:30:35,600
to do in this case we just set a

728
00:30:35,600 --> 00:30:39,120
register register value

729
00:30:40,480 --> 00:30:44,720
also very quick and simple to implement

730
00:30:46,000 --> 00:30:49,679
and finally we can retrieve our results

731
00:30:49,679 --> 00:30:50,720
so

732
00:30:50,720 --> 00:30:54,159
usually you want to dump standard input

733
00:30:54,159 --> 00:30:55,919
that has been provided

734
00:30:55,919 --> 00:30:58,880
or you want to evaluate your symbolic

735
00:30:58,880 --> 00:31:01,519
bit vector that you have injected into

736
00:31:01,519 --> 00:31:03,200
memory

737
00:31:03,200 --> 00:31:06,080
as we have seen before so those are like

738
00:31:06,080 --> 00:31:08,080
two main ways to

739
00:31:08,080 --> 00:31:11,600
based on what the binary expects to get

740
00:31:11,600 --> 00:31:14,880
the input to get your flag

741
00:31:14,880 --> 00:31:18,320
it's very simple

742
00:31:18,320 --> 00:31:21,200
this was a lot of information i know

743
00:31:21,200 --> 00:31:23,360
and you really should look at the slides

744
00:31:23,360 --> 00:31:25,039
again look at the code

745
00:31:25,039 --> 00:31:26,799
look at some examples

746
00:31:26,799 --> 00:31:27,840
um

747
00:31:27,840 --> 00:31:32,678
but first you can have a cat picture

748
00:31:37,039 --> 00:31:39,760
anger also has some limitations uh like

749
00:31:39,760 --> 00:31:42,640
all symbolic execution frameworks do

750
00:31:42,640 --> 00:31:43,440
um

751
00:31:43,440 --> 00:31:45,919
for example if the control flow is

752
00:31:45,919 --> 00:31:48,240
non-deterministic if you have a lot of

753
00:31:48,240 --> 00:31:51,840
um concurrent stuff going on um

754
00:31:51,840 --> 00:31:53,120
so if a

755
00:31:53,120 --> 00:31:55,840
function based on its input can't really

756
00:31:55,840 --> 00:31:57,679
connect differently then it's going to

757
00:31:57,679 --> 00:31:59,679
be difficult to figure it out with the

758
00:31:59,679 --> 00:32:02,480
symbolic execution framework

759
00:32:02,480 --> 00:32:05,120
state explosion is also a really big

760
00:32:05,120 --> 00:32:06,559
problem

761
00:32:06,559 --> 00:32:08,320
but we learn to deal with that by

762
00:32:08,320 --> 00:32:11,200
avoiding by hooking

763
00:32:11,200 --> 00:32:13,200
so lots of ways to

764
00:32:13,200 --> 00:32:16,159
to deal with the state explosion and you

765
00:32:16,159 --> 00:32:18,360
can't inverse your hash functions

766
00:32:18,360 --> 00:32:21,279
unfortunately like it would also

767
00:32:21,279 --> 00:32:23,200
cause massive state explosion to try and

768
00:32:23,200 --> 00:32:25,360
break crypto algorithms it won't work

769
00:32:25,360 --> 00:32:28,480
for that

770
00:32:28,480 --> 00:32:30,720
however we can improve performance

771
00:32:30,720 --> 00:32:32,320
somehow

772
00:32:32,320 --> 00:32:35,120
a great trick i like to use is to enable

773
00:32:35,120 --> 00:32:37,120
the very testing flag

774
00:32:37,120 --> 00:32:39,039
it's it's so cool because it's so simple

775
00:32:39,039 --> 00:32:41,440
you just have to set one flag before

776
00:32:41,440 --> 00:32:45,279
defining the the project

777
00:32:45,679 --> 00:32:47,039
and then

778
00:32:47,039 --> 00:32:49,919
algorithm automatically tries to reduce

779
00:32:49,919 --> 00:32:52,399
state explosion by merging states that

780
00:32:52,399 --> 00:32:54,399
the binary thinks hey those paths

781
00:32:54,399 --> 00:32:56,960
basically do the same so

782
00:32:56,960 --> 00:32:59,440
it merges them together and we save some

783
00:32:59,440 --> 00:33:01,840
speed

784
00:33:02,240 --> 00:33:05,120
anger also advertises that pi pi would

785
00:33:05,120 --> 00:33:07,760
slow it up up to ten percent

786
00:33:07,760 --> 00:33:11,120
for me it only slowed my

787
00:33:11,120 --> 00:33:14,399
computation down so i profiled it and

788
00:33:14,399 --> 00:33:16,720
it's actually way slower in my machine i

789
00:33:16,720 --> 00:33:18,640
have no idea why but

790
00:33:18,640 --> 00:33:21,120
just take the pi pi with caution test it

791
00:33:21,120 --> 00:33:22,720
on your machine maybe it's faster maybe

792
00:33:22,720 --> 00:33:25,840
it's not

793
00:33:25,840 --> 00:33:26,640
so

794
00:33:26,640 --> 00:33:28,960
to have great results with anger first

795
00:33:28,960 --> 00:33:31,039
avoid all unneeded code

796
00:33:31,039 --> 00:33:34,320
don't load unneeded chat libraries

797
00:33:34,320 --> 00:33:36,640
use simulation procedures and hooks

798
00:33:36,640 --> 00:33:38,559
where appliable

799
00:33:38,559 --> 00:33:40,720
use very testing it's also cool and

800
00:33:40,720 --> 00:33:45,440
maybe use pipe if it's faster for you

801
00:33:46,640 --> 00:33:49,039
error can also be integrated into your

802
00:33:49,039 --> 00:33:50,799
workflow perfectly

803
00:33:50,799 --> 00:33:52,720
there are lots of tools that use it

804
00:33:52,720 --> 00:33:53,919
under the hood

805
00:33:53,919 --> 00:33:56,240
for example anger management which is

806
00:33:56,240 --> 00:33:58,799
the official gui for the angry symbolic

807
00:33:58,799 --> 00:34:00,799
execution framework it's really cool

808
00:34:00,799 --> 00:34:03,200
because you can disassemble with it

809
00:34:03,200 --> 00:34:06,640
it features pseudocode and you can apply

810
00:34:06,640 --> 00:34:10,079
symbolic execution straight from the gui

811
00:34:10,079 --> 00:34:13,040
which is really helpful

812
00:34:13,839 --> 00:34:16,399
there's also angry children which is the

813
00:34:16,399 --> 00:34:19,280
same thing just as a jaidra plugin so

814
00:34:19,280 --> 00:34:23,040
you can mark some

815
00:34:23,040 --> 00:34:24,879
states that you want to explore you can

816
00:34:24,879 --> 00:34:27,119
mark states that you want to avoid and

817
00:34:27,119 --> 00:34:29,359
you solve the can and you can solve them

818
00:34:29,359 --> 00:34:32,560
straight from jaidra

819
00:34:33,839 --> 00:34:35,599
if you're into vulnerability research

820
00:34:35,599 --> 00:34:37,760
and if you're into fussing you can give

821
00:34:37,760 --> 00:34:39,199
driller a try

822
00:34:39,199 --> 00:34:42,399
which is an afl extension

823
00:34:42,399 --> 00:34:46,639
with symbolic execution so if afl at any

824
00:34:46,639 --> 00:34:47,599
point

825
00:34:47,599 --> 00:34:50,480
sets the afl stock flag

826
00:34:50,480 --> 00:34:53,359
doesn't really find new paths then it's

827
00:34:53,359 --> 00:34:56,320
going to use symbolic execution to try

828
00:34:56,320 --> 00:34:59,680
to drive and find new code coverage

829
00:34:59,680 --> 00:35:01,119
which is really cool because you can

830
00:35:01,119 --> 00:35:02,960
explore more of the binary to have

831
00:35:02,960 --> 00:35:06,400
greater chance of success in finding

832
00:35:06,400 --> 00:35:08,640
interesting crashes

833
00:35:08,640 --> 00:35:10,800
and finally

834
00:35:10,800 --> 00:35:13,040
there's obviously angry for your

835
00:35:13,040 --> 00:35:16,440
favorite disassembler

836
00:35:20,800 --> 00:35:23,839
i strongly suggest you to

837
00:35:23,839 --> 00:35:26,480
get hands on with anger to get your

838
00:35:26,480 --> 00:35:29,760
boilerplate code ready um to try it out

839
00:35:29,760 --> 00:35:32,240
yourself and a great resource it's a

840
00:35:32,240 --> 00:35:34,640
jake springer's angry ctf

841
00:35:34,640 --> 00:35:37,680
because they provide a lot of ctf

842
00:35:37,680 --> 00:35:39,839
challenges small ctf challenges

843
00:35:39,839 --> 00:35:41,920
specifically for anger so you don't have

844
00:35:41,920 --> 00:35:45,359
to reverse unneeded code

845
00:35:45,359 --> 00:35:46,800
you don't have to figure out what the

846
00:35:46,800 --> 00:35:48,320
challenge is about

847
00:35:48,320 --> 00:35:52,320
it's just about anger and they even

848
00:35:52,320 --> 00:35:54,800
grouped it into specific angular themes

849
00:35:54,800 --> 00:35:57,680
so you can for example try the symbolic

850
00:35:57,680 --> 00:36:00,400
memory you can try the symbolic file

851
00:36:00,400 --> 00:36:02,160
system stuff

852
00:36:02,160 --> 00:36:05,440
so lots of different challenges that you

853
00:36:05,440 --> 00:36:06,960
can get hands on

854
00:36:06,960 --> 00:36:12,119
and learn more about how anger works

855
00:36:12,720 --> 00:36:16,320
oh i think it's time for a crack me

856
00:36:16,320 --> 00:36:18,720
again

857
00:36:19,200 --> 00:36:20,880
we've seen that before

858
00:36:20,880 --> 00:36:22,160
but

859
00:36:22,160 --> 00:36:26,560
it's just not as scary anymore is it

860
00:36:26,560 --> 00:36:28,320
yeah we can

861
00:36:28,320 --> 00:36:30,240
simply build a symbolic execution

862
00:36:30,240 --> 00:36:31,359
harness

863
00:36:31,359 --> 00:36:34,160
we can continuously monitor and improve

864
00:36:34,160 --> 00:36:35,599
the performance of the symbolic

865
00:36:35,599 --> 00:36:38,079
execution for example by avoiding our

866
00:36:38,079 --> 00:36:40,720
needed code and finally we can run it

867
00:36:40,720 --> 00:36:44,160
and retrieve our flag

868
00:36:45,760 --> 00:36:50,160
i think it's time for a small demo

869
00:36:51,920 --> 00:36:55,680
democrats please don't fail me after

870
00:36:55,680 --> 00:36:57,760
before what

871
00:36:57,760 --> 00:37:00,640
a bit too early

872
00:37:01,599 --> 00:37:05,320
let's see

873
00:37:05,839 --> 00:37:08,839
so

874
00:37:19,599 --> 00:37:23,839
so we have our target correct me

875
00:37:31,119 --> 00:37:34,560
and here's the structure

876
00:37:34,560 --> 00:37:37,839
it takes some input

877
00:37:38,079 --> 00:37:42,160
it passes the input to sim solve me

878
00:37:42,160 --> 00:37:44,400
which just evaluates based on

879
00:37:44,400 --> 00:37:45,520
constraints

880
00:37:45,520 --> 00:37:47,920
and based on that it either says

881
00:37:47,920 --> 00:37:51,839
solved or bad password

882
00:37:59,760 --> 00:38:03,520
i prepared a small anchor harness

883
00:38:03,520 --> 00:38:06,160
which is really simple it just searches

884
00:38:06,160 --> 00:38:06,960
for

885
00:38:06,960 --> 00:38:10,320
the solved string in standard out

886
00:38:10,320 --> 00:38:12,480
and on each step it visualizes it so

887
00:38:12,480 --> 00:38:16,680
it's a bit more interesting for you

888
00:38:19,520 --> 00:38:22,240
let's run it

889
00:38:28,079 --> 00:38:30,640
and we found a solution

890
00:38:30,640 --> 00:38:32,470
thank you for watching my talk

891
00:38:32,470 --> 00:38:33,250
[Applause]

892
00:38:33,250 --> 00:38:36,449
[Music]

893
00:38:43,119 --> 00:38:43,920
so

894
00:38:43,920 --> 00:38:46,400
as your next steps you can download my

895
00:38:46,400 --> 00:38:48,320
slides from my github

896
00:38:48,320 --> 00:38:51,200
i will put them online real quick

897
00:38:51,200 --> 00:38:52,800
then i recommend you to walk through

898
00:38:52,800 --> 00:38:55,839
angular ctf look at all the different

899
00:38:55,839 --> 00:38:58,240
binaries get your hands dirty and

900
00:38:58,240 --> 00:39:02,320
finally pawn all the ctfs

901
00:39:02,320 --> 00:39:04,640
are there any questions anything that i

902
00:39:04,640 --> 00:39:06,720
can clarify for you anything you're

903
00:39:06,720 --> 00:39:10,279
interested in

904
00:39:17,359 --> 00:39:18,800
uh so

905
00:39:18,800 --> 00:39:21,440
i'm interested in

906
00:39:21,440 --> 00:39:22,160
the

907
00:39:22,160 --> 00:39:23,599
ways you can

908
00:39:23,599 --> 00:39:25,359
hook up

909
00:39:25,359 --> 00:39:28,520
you can

910
00:39:28,720 --> 00:39:30,800
states and speed up the execution

911
00:39:30,800 --> 00:39:34,000
because when you're solving uh a

912
00:39:34,000 --> 00:39:37,200
challenge in this way i imagine that the

913
00:39:37,200 --> 00:39:41,760
the computation can take a long time and

914
00:39:41,760 --> 00:39:44,400
uh i'm wondering whether there's any way

915
00:39:44,400 --> 00:39:46,640
to incrementally add

916
00:39:46,640 --> 00:39:48,880
uh hooks that improve the performance

917
00:39:48,880 --> 00:39:52,640
without having to restart your solution

918
00:39:52,640 --> 00:39:54,320
and throw away the computation you

919
00:39:54,320 --> 00:39:57,520
already done i i

920
00:39:57,520 --> 00:39:59,680
get what you see

921
00:39:59,680 --> 00:40:02,560
i'm not quite sure if you can

922
00:40:02,560 --> 00:40:05,280
export the coverage you have

923
00:40:05,280 --> 00:40:07,599
so far

924
00:40:07,599 --> 00:40:09,359
the the only thing

925
00:40:09,359 --> 00:40:11,040
that

926
00:40:11,040 --> 00:40:12,800
would come to mind right now is is

927
00:40:12,800 --> 00:40:14,960
exporting the coverage so you have it

928
00:40:14,960 --> 00:40:17,760
somewhere and if you see that it

929
00:40:17,760 --> 00:40:19,839
obviously hasn't led to a result

930
00:40:19,839 --> 00:40:23,359
excluded by avoiding it that would be it

931
00:40:23,359 --> 00:40:27,119
that um you could try right now but

932
00:40:27,119 --> 00:40:28,000
yeah

933
00:40:28,000 --> 00:40:30,240
okay

934
00:40:31,839 --> 00:40:35,160
hello christian

935
00:40:38,000 --> 00:40:39,599
uh thanks for the

936
00:40:39,599 --> 00:40:41,839
thanks for the talk was a nice a nice

937
00:40:41,839 --> 00:40:43,040
topic

938
00:40:43,040 --> 00:40:45,920
uh my question is about uh anger because

939
00:40:45,920 --> 00:40:48,880
i feel like uh this symbolic execution

940
00:40:48,880 --> 00:40:50,319
framework

941
00:40:50,319 --> 00:40:51,599
a

942
00:40:51,599 --> 00:40:54,000
you lose all the control over the

943
00:40:54,000 --> 00:40:56,800
execution so you just give one point to

944
00:40:56,800 --> 00:40:57,680
start

945
00:40:57,680 --> 00:40:59,520
one point to finish and

946
00:40:59,520 --> 00:41:00,880
you start a

947
00:41:00,880 --> 00:41:02,160
running

948
00:41:02,160 --> 00:41:04,480
but in other in other frameworks like

949
00:41:04,480 --> 00:41:06,720
triton or miasm

950
00:41:06,720 --> 00:41:09,200
you control or at least look at you can

951
00:41:09,200 --> 00:41:12,480
see how symbol symbolically is executed

952
00:41:12,480 --> 00:41:14,480
your program it's true that for example

953
00:41:14,480 --> 00:41:15,680
in myasm

954
00:41:15,680 --> 00:41:18,880
you cannot apply constraint solving a

955
00:41:18,880 --> 00:41:21,599
without with a c3

956
00:41:21,599 --> 00:41:23,920
because you should do it as another step

957
00:41:23,920 --> 00:41:26,400
but i feel like with anger

958
00:41:26,400 --> 00:41:28,319
you are out of

959
00:41:28,319 --> 00:41:30,960
what symbolically is executed is it

960
00:41:30,960 --> 00:41:32,240
possible maybe

961
00:41:32,240 --> 00:41:35,599
to see how everything is executed

962
00:41:35,599 --> 00:41:37,119
or how

963
00:41:37,119 --> 00:41:39,119
it applies to a

964
00:41:39,119 --> 00:41:41,520
improvement in the

965
00:41:41,520 --> 00:41:43,359
intermediate code

966
00:41:43,359 --> 00:41:44,880
to

967
00:41:44,880 --> 00:41:47,440
you can control it somewhat so you can

968
00:41:47,440 --> 00:41:50,400
choose the exploration algorithm so if

969
00:41:50,400 --> 00:41:54,000
you want to use a dfs bfs or some mixed

970
00:41:54,000 --> 00:41:55,920
algorithms that they provide

971
00:41:55,920 --> 00:41:56,800
and

972
00:41:56,800 --> 00:41:59,520
if you want to

973
00:41:59,760 --> 00:42:01,359
see what's going on you can visualize

974
00:42:01,359 --> 00:42:03,680
the state

975
00:42:03,680 --> 00:42:05,839
and as i've shown before

976
00:42:05,839 --> 00:42:09,680
via exporting code coverage you you can

977
00:42:09,680 --> 00:42:12,079
see a bit more what's going on but yes

978
00:42:12,079 --> 00:42:14,319
generally that was before i figured out

979
00:42:14,319 --> 00:42:17,119
the trick that was a problem in anger

980
00:42:17,119 --> 00:42:21,079
thank you thank you very much

981
00:42:30,480 --> 00:42:32,800
thank you for the talk i really enjoyed

982
00:42:32,800 --> 00:42:34,560
the trick with the lighthouse which

983
00:42:34,560 --> 00:42:37,359
helps the visualization

984
00:42:37,359 --> 00:42:39,440
but during the

985
00:42:39,440 --> 00:42:41,760
very complex challenges for

986
00:42:41,760 --> 00:42:44,240
which are for example multiple stage

987
00:42:44,240 --> 00:42:46,319
packers and then you want to apply that

988
00:42:46,319 --> 00:42:49,200
three and you wouldn't want to

989
00:42:49,200 --> 00:42:50,960
waste time reconstructing your

990
00:42:50,960 --> 00:42:53,040
executable

991
00:42:53,040 --> 00:42:56,079
is do you know a way in which you could

992
00:42:56,079 --> 00:42:58,000
save a snapshot from a debugger for

993
00:42:58,000 --> 00:43:00,720
example from x64 and load the entire

994
00:43:00,720 --> 00:43:02,800
state including all this all the stack

995
00:43:02,800 --> 00:43:04,560
all the registers

996
00:43:04,560 --> 00:43:06,640
i know the libraries might be a bit hard

997
00:43:06,640 --> 00:43:07,680
but

998
00:43:07,680 --> 00:43:09,119
anger can deal with that do you know

999
00:43:09,119 --> 00:43:10,000
something

1000
00:43:10,000 --> 00:43:10,960
that will

1001
00:43:10,960 --> 00:43:14,079
do something like that um i think that

1002
00:43:14,079 --> 00:43:16,720
should be possible like there's a lot of

1003
00:43:16,720 --> 00:43:19,920
loaders for anger like uh

1004
00:43:19,920 --> 00:43:22,079
all kinds of architectures including

1005
00:43:22,079 --> 00:43:23,680
brain fog so

1006
00:43:23,680 --> 00:43:26,400
i think it should be

1007
00:43:26,400 --> 00:43:29,359
it should be a solvable talk task um

1008
00:43:29,359 --> 00:43:31,680
under the hood it uses vex cr for

1009
00:43:31,680 --> 00:43:34,720
lifting the stuff um so maybe you could

1010
00:43:34,720 --> 00:43:37,119
write a custom lifter that just

1011
00:43:37,119 --> 00:43:40,079
reconstructs the the state that way this

1012
00:43:40,079 --> 00:43:41,520
would be the first solution that comes

1013
00:43:41,520 --> 00:43:42,640
to mind

1014
00:43:42,640 --> 00:43:45,920
okay thank you of course

1015
00:43:47,040 --> 00:43:49,759
other questions

1016
00:43:53,200 --> 00:43:55,839
okay so thanks again for uh

1017
00:43:55,839 --> 00:43:56,260
sorry

1018
00:43:56,260 --> 00:44:00,180
[Laughter]

1019
00:44:03,280 --> 00:44:05,440
it's more like of a provocative question

1020
00:44:05,440 --> 00:44:07,680
but out of your experience would you

1021
00:44:07,680 --> 00:44:09,040
actually say

1022
00:44:09,040 --> 00:44:11,920
that it's really true that these solvers

1023
00:44:11,920 --> 00:44:14,640
help or people which says i just put in

1024
00:44:14,640 --> 00:44:17,839
a fuzzer and and like a kid typing and i

1025
00:44:17,839 --> 00:44:20,800
find vulnerabilities and that that's all

1026
00:44:20,800 --> 00:44:23,440
um they definitely do help

1027
00:44:23,440 --> 00:44:25,440
especially like if you compare it with

1028
00:44:25,440 --> 00:44:28,480
other it can be used to extend fuzzers

1029
00:44:28,480 --> 00:44:30,880
um for example the driller framework is

1030
00:44:30,880 --> 00:44:33,599
open source and it has been used to find

1031
00:44:33,599 --> 00:44:35,599
real roadblocks

1032
00:44:35,599 --> 00:44:36,560
i

1033
00:44:36,560 --> 00:44:38,640
also from what i know where microsoft

1034
00:44:38,640 --> 00:44:40,880
internally has a father called sage

1035
00:44:40,880 --> 00:44:43,599
which is built on concolic execution

1036
00:44:43,599 --> 00:44:46,079
which also seems to enjoy great success

1037
00:44:46,079 --> 00:44:49,280
there so it definitely like

1038
00:44:49,280 --> 00:44:51,200
a symbiotic relationship between

1039
00:44:51,200 --> 00:44:54,000
phosphorus and symbolic execution

1040
00:44:54,000 --> 00:44:56,160
trade-offs as always

1041
00:44:56,160 --> 00:44:58,480
thank you

1042
00:44:59,200 --> 00:45:01,919
other questions

1043
00:45:03,520 --> 00:45:05,760
okay perfect so this time thank you

1044
00:45:05,760 --> 00:45:09,720
thank you thanks sir

