1
00:00:06,820 --> 00:00:09,869
[Music]

2
00:00:12,960 --> 00:00:14,880
so hello everyone

3
00:00:14,880 --> 00:00:17,119
good afternoon and welcome to our talk

4
00:00:17,119 --> 00:00:18,240
about

5
00:00:18,240 --> 00:00:21,119
a breaking secure boot with smm

6
00:00:21,119 --> 00:00:23,920
so just before we start let us briefly

7
00:00:23,920 --> 00:00:25,680
introduce ourselves

8
00:00:25,680 --> 00:00:28,400
so my name is zavka alsbad

9
00:00:28,400 --> 00:00:31,039
i'm a security researcher at sentinel-1

10
00:00:31,039 --> 00:00:33,760
and co-presenting this talk with me

11
00:00:33,760 --> 00:00:36,559
is my friend and colleague italia who

12
00:00:36,559 --> 00:00:39,600
works with me in the same team

13
00:00:39,600 --> 00:00:42,879
so let's start

14
00:00:42,960 --> 00:00:45,039
um this talk is basically divided into

15
00:00:45,039 --> 00:00:46,559
four parts

16
00:00:46,559 --> 00:00:49,760
first we will do a quick overview of

17
00:00:49,760 --> 00:00:52,399
what smm is and how it operates under

18
00:00:52,399 --> 00:00:53,520
the hood

19
00:00:53,520 --> 00:00:55,680
then we will move on to talk about some

20
00:00:55,680 --> 00:00:58,320
common smm vulnerabilities

21
00:00:58,320 --> 00:01:00,960
and also demonstrate a small tool we

22
00:01:00,960 --> 00:01:04,000
wrote that lets you hunt down these

23
00:01:04,000 --> 00:01:07,680
vulnerabilities in an automated fashion

24
00:01:07,680 --> 00:01:10,159
afterwards itai will take over

25
00:01:10,159 --> 00:01:12,400
and explain in detail how we managed to

26
00:01:12,400 --> 00:01:14,560
exploit some of these vulnerabilities up

27
00:01:14,560 --> 00:01:16,400
to the point where he

28
00:01:16,400 --> 00:01:19,520
completely breaks a secure boot

29
00:01:19,520 --> 00:01:21,600
and finally we will conclude by talking

30
00:01:21,600 --> 00:01:23,759
about some potential mitigations to the

31
00:01:23,759 --> 00:01:26,720
underlying problems

32
00:01:26,720 --> 00:01:29,920
so let's start with smm

33
00:01:29,920 --> 00:01:32,560
smm stands for a system management mode

34
00:01:32,560 --> 00:01:34,560
it's one of the operating modes

35
00:01:34,560 --> 00:01:37,600
available on every intel compatible cpu

36
00:01:37,600 --> 00:01:39,759
alongside some of the more familiar

37
00:01:39,759 --> 00:01:42,000
modes such as real mode protected mode

38
00:01:42,000 --> 00:01:44,399
long mode and so on

39
00:01:44,399 --> 00:01:46,479
and what's special about smm is that

40
00:01:46,479 --> 00:01:49,040
this mode was designed specifically to

41
00:01:49,040 --> 00:01:51,759
be used by the film well to handle a low

42
00:01:51,759 --> 00:01:52,799
level

43
00:01:52,799 --> 00:01:56,880
operation which has a wider effect

44
00:01:56,880 --> 00:01:59,520
so common examples would be things like

45
00:01:59,520 --> 00:02:01,119
power management

46
00:02:01,119 --> 00:02:03,920
thermal regulation emul emulating legacy

47
00:02:03,920 --> 00:02:06,799
devices and basically any other piece of

48
00:02:06,799 --> 00:02:09,038
proprietary code the oem wants to put

49
00:02:09,038 --> 00:02:11,200
into the box

50
00:02:11,200 --> 00:02:13,040
now from the perspective of security

51
00:02:13,040 --> 00:02:14,160
research

52
00:02:14,160 --> 00:02:16,480
the reason we care so much about smm is

53
00:02:16,480 --> 00:02:18,879
that smm is considered to be highly

54
00:02:18,879 --> 00:02:21,200
privileged

55
00:02:21,200 --> 00:02:23,520
so according to the intel model of

56
00:02:23,520 --> 00:02:25,520
privilege rings we can actually think of

57
00:02:25,520 --> 00:02:28,879
smm as being ring a minus two and that

58
00:02:28,879 --> 00:02:31,120
makes it in some sense more powerful

59
00:02:31,120 --> 00:02:33,599
than the os kernel ring zero and even

60
00:02:33,599 --> 00:02:36,640
the hypervisor authoring minus one

61
00:02:36,640 --> 00:02:38,000
so

62
00:02:38,000 --> 00:02:41,040
some of the special capabilities of smm

63
00:02:41,040 --> 00:02:43,920
are its ability to fully access all the

64
00:02:43,920 --> 00:02:45,920
physical memory of the machine so you

65
00:02:45,920 --> 00:02:48,239
might use that if you want to

66
00:02:48,239 --> 00:02:49,280
subvert

67
00:02:49,280 --> 00:02:52,400
a nos kernel and hypervisor you can also

68
00:02:52,400 --> 00:02:54,560
refresh the bios and therefore gain

69
00:02:54,560 --> 00:02:56,720
persistence on the machine and in

70
00:02:56,720 --> 00:02:58,480
addition you can do all of the above

71
00:02:58,480 --> 00:03:00,720
while being completely transparent to

72
00:03:00,720 --> 00:03:02,400
all the layers above you which also

73
00:03:02,400 --> 00:03:04,800
gives you a lot of stealth

74
00:03:04,800 --> 00:03:05,760
um

75
00:03:05,760 --> 00:03:07,760
nowadays the security industry much

76
00:03:07,760 --> 00:03:10,159
better understands the risks that are

77
00:03:10,159 --> 00:03:13,120
involved with smm code and therefore

78
00:03:13,120 --> 00:03:15,280
there are many ongoing attempts to

79
00:03:15,280 --> 00:03:17,280
de-privilege it and some of these

80
00:03:17,280 --> 00:03:19,040
attempts will be discussed towards the

81
00:03:19,040 --> 00:03:21,679
end of this talk

82
00:03:22,800 --> 00:03:25,519
um smm runs from its own isolated

83
00:03:25,519 --> 00:03:27,599
address space called system management

84
00:03:27,599 --> 00:03:30,159
ram or sm ram for short

85
00:03:30,159 --> 00:03:33,920
on modern platform the de facto standard

86
00:03:33,920 --> 00:03:36,799
region of smram is called tseg

87
00:03:36,799 --> 00:03:39,519
and among other things it contains all

88
00:03:39,519 --> 00:03:41,680
the smm binaries that were loaded by the

89
00:03:41,680 --> 00:03:44,560
firmware the smm stuck in heap

90
00:03:44,560 --> 00:03:46,799
the smm save state area which is where

91
00:03:46,799 --> 00:03:49,920
the cpu records its context when

92
00:03:49,920 --> 00:03:51,440
entering smm

93
00:03:51,440 --> 00:03:54,239
and also some architectural tables such

94
00:03:54,239 --> 00:03:58,799
as the gdt idt page table and so on

95
00:03:59,200 --> 00:04:01,519
now the main premise of sm-ram is that

96
00:04:01,519 --> 00:04:03,840
normally it can be only accessed by code

97
00:04:03,840 --> 00:04:06,799
only already running with smm privileges

98
00:04:06,799 --> 00:04:09,280
so the way this works is that usually

99
00:04:09,280 --> 00:04:11,599
the chipset provides some kind

100
00:04:11,599 --> 00:04:12,560
of a

101
00:04:12,560 --> 00:04:14,799
configuration mechanism that lets you

102
00:04:14,799 --> 00:04:16,720
close and lock smram

103
00:04:16,720 --> 00:04:19,519
and when smm is closed and locked

104
00:04:19,519 --> 00:04:21,759
only attempts to access it that

105
00:04:21,759 --> 00:04:24,560
originate from smm will be forwarded to

106
00:04:24,560 --> 00:04:26,080
the memory

107
00:04:26,080 --> 00:04:27,919
all other attempts to access it from a

108
00:04:27,919 --> 00:04:30,960
non-smm context will be remapped by the

109
00:04:30,960 --> 00:04:33,680
chipset or simply discarded and that's

110
00:04:33,680 --> 00:04:38,160
basically how smm gets its isolation

111
00:04:39,440 --> 00:04:42,960
another key concept we have to cover are

112
00:04:42,960 --> 00:04:45,360
system management interrupts or smis for

113
00:04:45,360 --> 00:04:46,240
short

114
00:04:46,240 --> 00:04:48,160
and sms are the events that cause the

115
00:04:48,160 --> 00:04:51,120
processor to transition into smm and

116
00:04:51,120 --> 00:04:53,759
more precisely into a dedicated smi

117
00:04:53,759 --> 00:04:56,240
handler which is a function responsible

118
00:04:56,240 --> 00:04:59,680
for servicing the event

119
00:04:59,680 --> 00:05:01,440
now from the hardware's perspective

120
00:05:01,440 --> 00:05:04,960
there is only a one global smi handler

121
00:05:04,960 --> 00:05:07,280
but as far as the firmware is concerned

122
00:05:07,280 --> 00:05:10,080
it can register additional sub handlers

123
00:05:10,080 --> 00:05:13,039
during boot time to handle more

124
00:05:13,039 --> 00:05:16,639
fine-grained situations

125
00:05:16,639 --> 00:05:18,639
in the uefi standout

126
00:05:18,639 --> 00:05:20,880
smi handlers are installed by calling a

127
00:05:20,880 --> 00:05:22,639
service called

128
00:05:22,639 --> 00:05:24,639
smi handler register

129
00:05:24,639 --> 00:05:27,600
and each smi handler is assigned a guide

130
00:05:27,600 --> 00:05:29,360
which allows

131
00:05:29,360 --> 00:05:31,600
to identify it and also retrieve it

132
00:05:31,600 --> 00:05:34,800
later during runtime

133
00:05:35,759 --> 00:05:39,440
sms can originate both asynchronously by

134
00:05:39,440 --> 00:05:42,000
hardware devices or synchronously by

135
00:05:42,000 --> 00:05:44,080
software running with ring zero

136
00:05:44,080 --> 00:05:46,720
privileges and these software smis are

137
00:05:46,720 --> 00:05:49,039
basically the smm equivalent of a system

138
00:05:49,039 --> 00:05:50,240
call

139
00:05:50,240 --> 00:05:52,479
the way these software smiles work are

140
00:05:52,479 --> 00:05:54,960
that the caller first takes the good

141
00:05:54,960 --> 00:05:57,840
identifying the handler and also all the

142
00:05:57,840 --> 00:05:59,919
arguments for the call and packs them

143
00:05:59,919 --> 00:06:01,440
together in what's known as a

144
00:06:01,440 --> 00:06:05,120
communication buffer or combat for short

145
00:06:05,120 --> 00:06:07,120
then the physical address of the com

146
00:06:07,120 --> 00:06:08,400
buffer

147
00:06:08,400 --> 00:06:10,240
is written into a global structure

148
00:06:10,240 --> 00:06:12,960
called smm core private data

149
00:06:12,960 --> 00:06:15,759
the address of smm core private data is

150
00:06:15,759 --> 00:06:18,400
shared between smm code and non-smm code

151
00:06:18,400 --> 00:06:20,319
and therefore we can use this structure

152
00:06:20,319 --> 00:06:22,319
to pass information between the two

153
00:06:22,319 --> 00:06:25,680
different cpu modes

154
00:06:26,639 --> 00:06:28,319
finally after the contents of the

155
00:06:28,319 --> 00:06:30,400
communication buffer are serialized that

156
00:06:30,400 --> 00:06:31,680
way

157
00:06:31,680 --> 00:06:35,120
the caller can write to io port b2 which

158
00:06:35,120 --> 00:06:37,440
belongs to a small air component called

159
00:06:37,440 --> 00:06:39,360
the apm controller

160
00:06:39,360 --> 00:06:40,800
and

161
00:06:40,800 --> 00:06:43,840
this io port basically asserts the smi

162
00:06:43,840 --> 00:06:46,000
pin of the cpu and causes the hardware

163
00:06:46,000 --> 00:06:49,039
to transition into smm

164
00:06:49,039 --> 00:06:51,440
after transitioning to smm

165
00:06:51,440 --> 00:06:53,199
control flow eventually reaches a

166
00:06:53,199 --> 00:06:56,000
function called the smm entry point and

167
00:06:56,000 --> 00:06:57,919
the smm entry point

168
00:06:57,919 --> 00:07:00,080
takes the address of the com buffer and

169
00:07:00,080 --> 00:07:02,800
its size from the smm core private data

170
00:07:02,800 --> 00:07:03,840
structure

171
00:07:03,840 --> 00:07:06,560
and then it uses the grid found at the

172
00:07:06,560 --> 00:07:09,520
beginning of the com buffer to retrieve

173
00:07:09,520 --> 00:07:10,960
the actual handler that should be

174
00:07:10,960 --> 00:07:13,120
invoked

175
00:07:13,120 --> 00:07:16,160
in the last phase the handler is finally

176
00:07:16,160 --> 00:07:18,720
called and now it can access all the

177
00:07:18,720 --> 00:07:21,360
caller provided arguments by

178
00:07:21,360 --> 00:07:25,680
inspecting the commbuffer parameter

179
00:07:26,000 --> 00:07:28,560
so after we covered enough background

180
00:07:28,560 --> 00:07:30,880
information about smm in general let's

181
00:07:30,880 --> 00:07:32,800
move on to talk a little bit about smm

182
00:07:32,800 --> 00:07:35,680
vulnerabilities

183
00:07:35,919 --> 00:07:37,039
so

184
00:07:37,039 --> 00:07:39,280
when attacking smm probably one of the

185
00:07:39,280 --> 00:07:41,440
best tech surfaces or these software

186
00:07:41,440 --> 00:07:44,080
semis that they just described and there

187
00:07:44,080 --> 00:07:46,560
are two main reasons for that

188
00:07:46,560 --> 00:07:48,160
first they can be triggered in a

189
00:07:48,160 --> 00:07:49,919
controlled fashion from a less

190
00:07:49,919 --> 00:07:52,560
privileged context which is the os

191
00:07:52,560 --> 00:07:54,319
and secondly the contents of the

192
00:07:54,319 --> 00:07:56,400
communication buffer are fully under the

193
00:07:56,400 --> 00:07:58,720
attacker's control control and that and

194
00:07:58,720 --> 00:08:01,919
that gives a lot of flexibility

195
00:08:01,919 --> 00:08:03,919
um most of the attacks follow a pattern

196
00:08:03,919 --> 00:08:06,879
called the the confused deputy problem

197
00:08:06,879 --> 00:08:09,680
in which the privileged smi handler is

198
00:08:09,680 --> 00:08:12,160
somehow a tricked or manipulated into

199
00:08:12,160 --> 00:08:14,319
doing something it shouldn't be doing

200
00:08:14,319 --> 00:08:16,240
and that might include

201
00:08:16,240 --> 00:08:19,039
branching out the contents of sm ram or

202
00:08:19,039 --> 00:08:21,440
maybe leaking out the contents of smram

203
00:08:21,440 --> 00:08:25,440
or corrupting the contents of sm1

204
00:08:25,599 --> 00:08:27,520
um in this presentation we will talk

205
00:08:27,520 --> 00:08:30,240
only about one such attack and that

206
00:08:30,240 --> 00:08:32,559
revolves around the usage of pointers

207
00:08:32,559 --> 00:08:34,240
that are nested within the communication

208
00:08:34,240 --> 00:08:35,279
buffer

209
00:08:35,279 --> 00:08:37,200
so in most cases the communication

210
00:08:37,200 --> 00:08:38,240
buffer

211
00:08:38,240 --> 00:08:41,200
only holds data used by the handler but

212
00:08:41,200 --> 00:08:42,958
from time to time there is on there's

213
00:08:42,958 --> 00:08:46,240
also a pointer that is nested within it

214
00:08:46,240 --> 00:08:48,160
and if the handler operates on the

215
00:08:48,160 --> 00:08:51,360
pointer without first sanitizing it that

216
00:08:51,360 --> 00:08:54,480
can lead to a breach of the smm security

217
00:08:54,480 --> 00:08:56,399
domain

218
00:08:56,399 --> 00:08:58,800
so to better understand the issue let's

219
00:08:58,800 --> 00:09:02,000
take a look at the concrete smi handler

220
00:09:02,000 --> 00:09:04,000
which is very simple

221
00:09:04,000 --> 00:09:06,480
as you can see the handler begins by

222
00:09:06,480 --> 00:09:08,240
taking the first field out of the comm

223
00:09:08,240 --> 00:09:11,920
buffer and inspect and treating it as

224
00:09:11,920 --> 00:09:14,240
some kind of an operation code field

225
00:09:14,240 --> 00:09:16,640
that tells the handler what you do next

226
00:09:16,640 --> 00:09:18,640
we can also see the valid values for

227
00:09:18,640 --> 00:09:22,800
this opcode are either 0 2 or three

228
00:09:22,800 --> 00:09:24,800
and if for some reason the actual value

229
00:09:24,800 --> 00:09:25,839
differs

230
00:09:25,839 --> 00:09:27,360
then the default clause of the handle

231
00:09:27,360 --> 00:09:30,080
will be executed and the default clause

232
00:09:30,080 --> 00:09:32,080
actually takes the second field out of

233
00:09:32,080 --> 00:09:34,480
the com buffer interprets it as a

234
00:09:34,480 --> 00:09:36,959
pointer and then write a status variable

235
00:09:36,959 --> 00:09:40,480
to the pointed memory location

236
00:09:40,480 --> 00:09:41,279
so

237
00:09:41,279 --> 00:09:42,959
let's see how

238
00:09:42,959 --> 00:09:45,839
how an attacker can exploit this handler

239
00:09:45,839 --> 00:09:48,000
so to exploit this the attacker would

240
00:09:48,000 --> 00:09:48,880
first

241
00:09:48,880 --> 00:09:50,800
craft a communication buffer which is

242
00:09:50,800 --> 00:09:53,279
comprised out of these two fields and

243
00:09:53,279 --> 00:09:55,760
then write the serialized cone buffer

244
00:09:55,760 --> 00:09:57,279
into a

245
00:09:57,279 --> 00:09:59,440
location accessible to him outside of

246
00:09:59,440 --> 00:10:01,279
smram

247
00:10:01,279 --> 00:10:03,279
then the attacker will move on to

248
00:10:03,279 --> 00:10:06,560
trigger the vulnerable smi handler

249
00:10:06,560 --> 00:10:09,120
the smi handler will then

250
00:10:09,120 --> 00:10:11,279
inspect the opcode field to determine

251
00:10:11,279 --> 00:10:13,040
what it should do next

252
00:10:13,040 --> 00:10:14,720
but since this field is under the

253
00:10:14,720 --> 00:10:16,320
attacker's control

254
00:10:16,320 --> 00:10:18,560
he or she could choose an invalid value

255
00:10:18,560 --> 00:10:21,279
say 4 and that will force the handler to

256
00:10:21,279 --> 00:10:24,399
fall back into the default clause

257
00:10:24,399 --> 00:10:26,320
in the default clause we know the

258
00:10:26,320 --> 00:10:28,560
handler will fetch a pointer

259
00:10:28,560 --> 00:10:30,480
out of the com buffer

260
00:10:30,480 --> 00:10:32,320
and since this pointer field is also

261
00:10:32,320 --> 00:10:34,480
under the attacker's control he or she

262
00:10:34,480 --> 00:10:36,160
could choose an address that resides in

263
00:10:36,160 --> 00:10:38,640
smram and therefore cause corruption at

264
00:10:38,640 --> 00:10:40,480
that particular address which is

265
00:10:40,480 --> 00:10:43,440
obviously a very bad thing

266
00:10:43,440 --> 00:10:45,839
so to mitigate these issues smi handlers

267
00:10:45,839 --> 00:10:48,480
are always expected to sanitize all the

268
00:10:48,480 --> 00:10:50,320
pointers nested within the communication

269
00:10:50,320 --> 00:10:51,360
buffer

270
00:10:51,360 --> 00:10:53,200
to make sure they do not overlap with

271
00:10:53,200 --> 00:10:55,760
smram and to do so they can use a

272
00:10:55,760 --> 00:10:58,240
smallity a smaller utility function from

273
00:10:58,240 --> 00:11:01,200
edk2 called the smm's buffer outside smm

274
00:11:01,200 --> 00:11:04,959
valid which does exactly that

275
00:11:06,079 --> 00:11:06,880
so

276
00:11:06,880 --> 00:11:10,000
um basically we've seen this error keeps

277
00:11:10,000 --> 00:11:12,560
repeating itself over and over again and

278
00:11:12,560 --> 00:11:14,880
at some point we decided we should write

279
00:11:14,880 --> 00:11:17,519
an automated detection for it

280
00:11:17,519 --> 00:11:20,160
so after several months of development

281
00:11:20,160 --> 00:11:22,880
we ended up with this small tool that we

282
00:11:22,880 --> 00:11:26,160
call a brick and brick is basically

283
00:11:26,160 --> 00:11:28,800
an automated static analysis tool that

284
00:11:28,800 --> 00:11:31,040
lets you hunt down smm related

285
00:11:31,040 --> 00:11:32,880
vulnerabilities

286
00:11:32,880 --> 00:11:36,160
this tool is primarily based on ida and

287
00:11:36,160 --> 00:11:38,480
so far it managed to produce 13

288
00:11:38,480 --> 00:11:40,720
different cves affecting most of the

289
00:11:40,720 --> 00:11:42,959
well-known vendors in the industry

290
00:11:42,959 --> 00:11:45,279
and most importantly

291
00:11:45,279 --> 00:11:46,800
this tool is already

292
00:11:46,800 --> 00:11:49,120
open source and available on github so

293
00:11:49,120 --> 00:11:50,720
you can start using it yourself and

294
00:11:50,720 --> 00:11:52,720
maybe uncover vulnerabilities in your

295
00:11:52,720 --> 00:11:55,120
own film

296
00:11:55,600 --> 00:11:58,320
so um let's see a quick

297
00:11:58,320 --> 00:12:00,160
demo of brick in action

298
00:12:00,160 --> 00:12:02,480
now uh most of the time we use brick to

299
00:12:02,480 --> 00:12:05,120
scan uh entire bios images but in this

300
00:12:05,120 --> 00:12:07,519
demo we wanted to keep it short so we're

301
00:12:07,519 --> 00:12:10,480
just scanning a one particular smm

302
00:12:10,480 --> 00:12:14,079
binary which we extracted out of a dell

303
00:12:14,079 --> 00:12:16,720
latitude laptop

304
00:12:16,720 --> 00:12:21,000
so let's take a look at the demo

305
00:12:30,000 --> 00:12:32,079
so basically brick is written in python

306
00:12:32,079 --> 00:12:34,240
so executing it is just a matter of

307
00:12:34,240 --> 00:12:38,680
running this very simple command line

308
00:12:40,480 --> 00:12:43,200
and right now it executes idea in the

309
00:12:43,200 --> 00:12:45,360
background and first it lets the auto

310
00:12:45,360 --> 00:12:47,360
analysis complete that should take a

311
00:12:47,360 --> 00:12:50,760
couple of seconds

312
00:12:55,120 --> 00:12:56,880
and after the initial auto analysis

313
00:12:56,880 --> 00:12:59,440
completes it basically moves on to run a

314
00:12:59,440 --> 00:13:02,160
bunch of custom either python scripts

315
00:13:02,160 --> 00:13:04,079
and these are the python scripts employ

316
00:13:04,079 --> 00:13:06,399
a wide range of heuristics

317
00:13:06,399 --> 00:13:08,079
and attempts to

318
00:13:08,079 --> 00:13:10,000
pinpoint potential vulnerabilities and

319
00:13:10,000 --> 00:13:13,120
anti-patterns inside the smm code and

320
00:13:13,120 --> 00:13:15,360
that should take roughly one minute to

321
00:13:15,360 --> 00:13:18,360
complete

322
00:13:23,770 --> 00:13:25,920
[Music]

323
00:13:25,920 --> 00:13:28,920
um

324
00:13:36,079 --> 00:13:38,639
and after the analysis completes

325
00:13:38,639 --> 00:13:40,399
all the results are basically dumped

326
00:13:40,399 --> 00:13:43,120
into an html report file that you can

327
00:13:43,120 --> 00:13:45,120
view

328
00:13:45,120 --> 00:13:46,399
so

329
00:13:46,399 --> 00:13:48,560
after scanning we opened this html

330
00:13:48,560 --> 00:13:51,040
report file and

331
00:13:51,040 --> 00:13:54,160
one of the lines immediately drew our

332
00:13:54,160 --> 00:13:56,079
attention and i'm talking of course

333
00:13:56,079 --> 00:13:57,760
about this line here

334
00:13:57,760 --> 00:13:59,600
so basically brick tells us it managed

335
00:13:59,600 --> 00:14:02,959
to find one smi handler that doesn't

336
00:14:02,959 --> 00:14:05,279
sanitize pointers nested within the

337
00:14:05,279 --> 00:14:06,959
communication buffer

338
00:14:06,959 --> 00:14:07,680
so

339
00:14:07,680 --> 00:14:10,480
how did exactly did a brick get to this

340
00:14:10,480 --> 00:14:13,199
conclusion so to answer this question we

341
00:14:13,199 --> 00:14:14,800
will now walk you through the individual

342
00:14:14,800 --> 00:14:17,519
phases of running brick and gradually

343
00:14:17,519 --> 00:14:21,360
see how the detection logic builds up

344
00:14:21,360 --> 00:14:22,959
so at the beginning we are at what's

345
00:14:22,959 --> 00:14:25,519
known as phase zero phase zero is just a

346
00:14:25,519 --> 00:14:28,079
snapshot of the ida database after the

347
00:14:28,079 --> 00:14:30,560
initial auto analysis completed but

348
00:14:30,560 --> 00:14:32,720
before any brick related code got a

349
00:14:32,720 --> 00:14:35,360
chance to run

350
00:14:35,839 --> 00:14:38,000
after it we have the first brick module

351
00:14:38,000 --> 00:14:40,240
that is called to handle any input file

352
00:14:40,240 --> 00:14:43,360
and that's called the pre-processor

353
00:14:43,360 --> 00:14:45,600
so the preprocessor basically sets up

354
00:14:45,600 --> 00:14:47,440
the ground for the next modules in the

355
00:14:47,440 --> 00:14:48,399
chain

356
00:14:48,399 --> 00:14:51,519
and most importantly it traverses the

357
00:14:51,519 --> 00:14:55,760
edk2 repository and attempts to import

358
00:14:55,760 --> 00:14:58,320
as many a uefi protocol definitions as

359
00:14:58,320 --> 00:15:00,720
possible into the database

360
00:15:00,720 --> 00:15:03,279
now for those of you who are not

361
00:15:03,279 --> 00:15:05,760
familiar with all the shenanigans of

362
00:15:05,760 --> 00:15:07,120
uefi

363
00:15:07,120 --> 00:15:08,800
protocols are basically the building

364
00:15:08,800 --> 00:15:10,800
block that allows different modules to

365
00:15:10,800 --> 00:15:13,040
communicate with it with each other

366
00:15:13,040 --> 00:15:14,560
and so

367
00:15:14,560 --> 00:15:17,360
models can either produce protocols or

368
00:15:17,360 --> 00:15:18,959
consume protocols

369
00:15:18,959 --> 00:15:21,600
so if you are a producer you would use a

370
00:15:21,600 --> 00:15:24,000
service such as smm install protocol

371
00:15:24,000 --> 00:15:26,639
interface to expose a protocol

372
00:15:26,639 --> 00:15:28,959
where under the hood a protocol is just

373
00:15:28,959 --> 00:15:31,199
a good identifying it

374
00:15:31,199 --> 00:15:33,600
and an associated interface which

375
00:15:33,600 --> 00:15:37,199
usually takes the form of a v table

376
00:15:37,199 --> 00:15:39,360
if you're a consumer on the other hand

377
00:15:39,360 --> 00:15:42,480
you utilize protocols installed by

378
00:15:42,480 --> 00:15:45,440
other modules and you use services such

379
00:15:45,440 --> 00:15:48,480
as smm locate protocol to do so

380
00:15:48,480 --> 00:15:50,320
so you pass the good of the protocol

381
00:15:50,320 --> 00:15:52,720
you're interested in and as a response

382
00:15:52,720 --> 00:15:55,199
you get back the interface pointer and

383
00:15:55,199 --> 00:15:56,959
afterwards you can use the interface

384
00:15:56,959 --> 00:15:58,880
pointer to invoke all the functions

385
00:15:58,880 --> 00:16:02,320
associated with the interface

386
00:16:02,320 --> 00:16:04,959
so back to the preprocessor after the

387
00:16:04,959 --> 00:16:06,560
pre-process so on

388
00:16:06,560 --> 00:16:09,360
the database is basically filled with

389
00:16:09,360 --> 00:16:12,079
thousands of these protocol definitions

390
00:16:12,079 --> 00:16:13,920
among them we can find one that is

391
00:16:13,920 --> 00:16:17,279
called pchspi protocol and this protocol

392
00:16:17,279 --> 00:16:19,440
will play a vital part in the next few

393
00:16:19,440 --> 00:16:22,079
slides

394
00:16:22,079 --> 00:16:24,240
so following the pre-processor brick

395
00:16:24,240 --> 00:16:26,399
moves on to load and run

396
00:16:26,399 --> 00:16:29,360
an idea plug-in called efi explorer

397
00:16:29,360 --> 00:16:31,360
and dfi explorer is basically the de

398
00:16:31,360 --> 00:16:33,839
facto standard way of analyzing uefi

399
00:16:33,839 --> 00:16:35,440
binaries in ida

400
00:16:35,440 --> 00:16:37,199
and to demonstrate the capabilities of

401
00:16:37,199 --> 00:16:38,480
this tool

402
00:16:38,480 --> 00:16:40,079
here we have

403
00:16:40,079 --> 00:16:42,720
some function before if i explorer

404
00:16:42,720 --> 00:16:44,000
analyzed it

405
00:16:44,000 --> 00:16:45,759
and this is the very same function

406
00:16:45,759 --> 00:16:48,560
afterwards so we can see if i explore

407
00:16:48,560 --> 00:16:51,120
takes care of things such as

408
00:16:51,120 --> 00:16:53,120
identifying calls to smm related

409
00:16:53,120 --> 00:16:54,880
services

410
00:16:54,880 --> 00:16:58,639
identifying known uefi goods and also

411
00:16:58,639 --> 00:17:01,440
assigning correct types to interface

412
00:17:01,440 --> 00:17:03,360
pointers and this is the rather new

413
00:17:03,360 --> 00:17:05,280
addition to the tool and the way it

414
00:17:05,280 --> 00:17:06,240
works

415
00:17:06,240 --> 00:17:08,480
is that the efi explorer managed to

416
00:17:08,480 --> 00:17:11,839
identify a call to smm locate protocol

417
00:17:11,839 --> 00:17:14,400
and they managed to identify the

418
00:17:14,400 --> 00:17:17,119
good as pc-hspi protocol good and

419
00:17:17,119 --> 00:17:20,240
therefore it deduces that

420
00:17:20,240 --> 00:17:22,400
the corresponding interface should be of

421
00:17:22,400 --> 00:17:26,559
type pointer to pchspi protocol and it

422
00:17:26,559 --> 00:17:27,839
just so happens to be that this

423
00:17:27,839 --> 00:17:29,919
particular type definition was imported

424
00:17:29,919 --> 00:17:31,840
earlier by the preprocessor and

425
00:17:31,840 --> 00:17:33,679
therefore this typecasting actually

426
00:17:33,679 --> 00:17:36,080
works

427
00:17:37,760 --> 00:17:40,000
last but not least efi explorer is also

428
00:17:40,000 --> 00:17:42,960
capable of identifying smi handlers that

429
00:17:42,960 --> 00:17:44,720
are installed by the image

430
00:17:44,720 --> 00:17:46,480
and in this particular case there is

431
00:17:46,480 --> 00:17:49,039
only one such handler and this handler

432
00:17:49,039 --> 00:17:50,960
actually makes use of the pch spi

433
00:17:50,960 --> 00:17:52,960
protocol which is also effect we will

434
00:17:52,960 --> 00:17:55,919
visit again later

435
00:17:56,160 --> 00:17:58,080
now before moving on we need to

436
00:17:58,080 --> 00:18:00,960
elaborate a bit about one protocol

437
00:18:00,960 --> 00:18:04,480
called the efi smm access to protocol

438
00:18:04,480 --> 00:18:06,880
so basically this protocol is used to

439
00:18:06,880 --> 00:18:08,880
control the visibility of smram on the

440
00:18:08,880 --> 00:18:11,840
platform and as such it exposes their

441
00:18:11,840 --> 00:18:14,559
respective methods to open close and

442
00:18:14,559 --> 00:18:16,320
lock smram

443
00:18:16,320 --> 00:18:19,360
in addition to those three it exports

444
00:18:19,360 --> 00:18:21,000
yet another method called

445
00:18:21,000 --> 00:18:22,559
getcapabilities

446
00:18:22,559 --> 00:18:24,720
and getcapabilities is actually used to

447
00:18:24,720 --> 00:18:26,799
query the memory controller about the

448
00:18:26,799 --> 00:18:29,600
location of smram in physical memory so

449
00:18:29,600 --> 00:18:31,440
when you call this a

450
00:18:31,440 --> 00:18:34,960
method you get in response an array of

451
00:18:34,960 --> 00:18:38,480
structures of type efi smgram descripto

452
00:18:38,480 --> 00:18:40,799
where each sm descriptor holds

453
00:18:40,799 --> 00:18:42,880
information about one active smram

454
00:18:42,880 --> 00:18:44,799
region and includes important

455
00:18:44,799 --> 00:18:47,840
information such as it such as its base

456
00:18:47,840 --> 00:18:50,960
address its size state attributes and so

457
00:18:50,960 --> 00:18:52,000
on

458
00:18:52,000 --> 00:18:54,640
um now what matters for our purposes is

459
00:18:54,640 --> 00:18:56,720
to know that these smram descriptors are

460
00:18:56,720 --> 00:18:59,120
actually used internally by functions

461
00:18:59,120 --> 00:19:01,360
such as smm's buffer outside the same

462
00:19:01,360 --> 00:19:04,000
valid to determine if the color provided

463
00:19:04,000 --> 00:19:07,520
buffer is safe or not

464
00:19:07,760 --> 00:19:10,559
so back to brick and the next model that

465
00:19:10,559 --> 00:19:13,120
is called to process the input file is

466
00:19:13,120 --> 00:19:15,440
called the post processor and the post

467
00:19:15,440 --> 00:19:17,360
processor completes the analysis

468
00:19:17,360 --> 00:19:20,000
performed earlier by efi explorer

469
00:19:20,000 --> 00:19:22,240
and as part of its operation it goes

470
00:19:22,240 --> 00:19:23,679
through all the calls to get

471
00:19:23,679 --> 00:19:26,559
capabilities and simply marks the smram

472
00:19:26,559 --> 00:19:28,559
descriptors that were returned by the

473
00:19:28,559 --> 00:19:29,840
call

474
00:19:29,840 --> 00:19:31,440
and the importance of this operation

475
00:19:31,440 --> 00:19:34,480
will be explained shortly

476
00:19:35,120 --> 00:19:37,679
okay so just to say a quick reminder

477
00:19:37,679 --> 00:19:39,520
basically what we are looking for are

478
00:19:39,520 --> 00:19:41,039
smi handlers

479
00:19:41,039 --> 00:19:43,840
uh that don't sanitize pointers nested

480
00:19:43,840 --> 00:19:46,080
within their communication buffer but

481
00:19:46,080 --> 00:19:48,080
for that work we first have to figure

482
00:19:48,080 --> 00:19:50,000
out whether or not the com buffer holds

483
00:19:50,000 --> 00:19:52,480
any nested pointers in the first place

484
00:19:52,480 --> 00:19:55,679
so normally we can do it manually as

485
00:19:55,679 --> 00:19:58,000
part of the reverse engineering process

486
00:19:58,000 --> 00:20:00,240
but in in this case in the case of brick

487
00:20:00,240 --> 00:20:01,520
we needed to

488
00:20:01,520 --> 00:20:03,919
be able to do that automatically

489
00:20:03,919 --> 00:20:06,880
so to do to do so we leverage yet

490
00:20:06,880 --> 00:20:09,039
another idea plugin called hexley's code

491
00:20:09,039 --> 00:20:10,080
explorer

492
00:20:10,080 --> 00:20:12,480
and this plugin lets you reconstruct the

493
00:20:12,480 --> 00:20:14,320
internal layout of structures used by

494
00:20:14,320 --> 00:20:16,559
the program so we apply this plugin to

495
00:20:16,559 --> 00:20:19,280
the com buffer and basically that lets

496
00:20:19,280 --> 00:20:22,080
you transform a row pointer notation as

497
00:20:22,080 --> 00:20:23,520
can be seen here

498
00:20:23,520 --> 00:20:25,760
into a much more comprehensible notation

499
00:20:25,760 --> 00:20:27,840
which is also aware of individual

500
00:20:27,840 --> 00:20:29,360
members

501
00:20:29,360 --> 00:20:31,600
and even more importantly along the

502
00:20:31,600 --> 00:20:34,240
process hex codec explorer also

503
00:20:34,240 --> 00:20:37,760
extrapolates the types associated with

504
00:20:37,760 --> 00:20:41,600
different members and in this case it

505
00:20:41,600 --> 00:20:44,240
found out that two members namely field

506
00:20:44,240 --> 00:20:47,120
14 and field 1c are actually pointers by

507
00:20:47,120 --> 00:20:49,280
themselves so

508
00:20:49,280 --> 00:20:51,200
let's understand how we got to this

509
00:20:51,200 --> 00:20:52,960
conclusion

510
00:20:52,960 --> 00:20:54,960
and so from the code of the handle we

511
00:20:54,960 --> 00:20:56,880
can see that at some point

512
00:20:56,880 --> 00:21:00,320
both these fields field 14 and field 1c

513
00:21:00,320 --> 00:21:03,679
are being passed as the

514
00:21:03,679 --> 00:21:06,000
base address and region size

515
00:21:06,000 --> 00:21:08,159
parameters

516
00:21:08,159 --> 00:21:10,320
of the

517
00:21:10,320 --> 00:21:12,400
get region address method which is also

518
00:21:12,400 --> 00:21:15,280
exported by the pch spi protocol

519
00:21:15,280 --> 00:21:17,120
and based on the definition of this

520
00:21:17,120 --> 00:21:19,120
method which was again

521
00:21:19,120 --> 00:21:21,600
imported earlier by the preprocessor we

522
00:21:21,600 --> 00:21:23,520
know these two parameters are actually

523
00:21:23,520 --> 00:21:25,679
pointers and therefore we can deduce

524
00:21:25,679 --> 00:21:27,520
that the respective pointers in the com

525
00:21:27,520 --> 00:21:29,440
buffer

526
00:21:29,440 --> 00:21:32,720
must be pointless as well

527
00:21:33,520 --> 00:21:35,520
so now that it knows the comm buffer

528
00:21:35,520 --> 00:21:37,840
does contain some nested pointers brick

529
00:21:37,840 --> 00:21:38,799
have to

530
00:21:38,799 --> 00:21:40,880
has to make sure that these pointers are

531
00:21:40,880 --> 00:21:42,960
being sanitized properly

532
00:21:42,960 --> 00:21:45,280
usually that boils down to

533
00:21:45,280 --> 00:21:47,200
first identifying

534
00:21:47,200 --> 00:21:49,440
smm's buffer outside smm valid inside

535
00:21:49,440 --> 00:21:52,240
the compiled binary and then checking to

536
00:21:52,240 --> 00:21:53,919
see if all the nested pointers are being

537
00:21:53,919 --> 00:21:55,120
covered by it

538
00:21:55,120 --> 00:21:57,520
so to identify sms buffer outside smm

539
00:21:57,520 --> 00:22:00,240
valid we compiled a simple heuristic

540
00:22:00,240 --> 00:22:02,080
which is made up of three different

541
00:22:02,080 --> 00:22:03,600
conditions

542
00:22:03,600 --> 00:22:06,000
and brick will basically iterate over

543
00:22:06,000 --> 00:22:08,559
all the functions in the either database

544
00:22:08,559 --> 00:22:10,000
and we'll search for a function that

545
00:22:10,000 --> 00:22:11,600
matches all three

546
00:22:11,600 --> 00:22:13,360
so the heuristic is basically pretty

547
00:22:13,360 --> 00:22:14,720
simple and

548
00:22:14,720 --> 00:22:16,720
asserts that first

549
00:22:16,720 --> 00:22:18,880
the candidate function must reference

550
00:22:18,880 --> 00:22:21,600
one of the smram descriptors remember

551
00:22:21,600 --> 00:22:23,679
that all these descriptors were marked

552
00:22:23,679 --> 00:22:25,440
earlier by the post processor and

553
00:22:25,440 --> 00:22:26,400
therefore

554
00:22:26,400 --> 00:22:28,559
at this phase checking for cross

555
00:22:28,559 --> 00:22:30,000
references between functions and

556
00:22:30,000 --> 00:22:33,440
descriptors is actually pretty easy

557
00:22:33,440 --> 00:22:35,440
next it checks the

558
00:22:35,440 --> 00:22:37,440
arguments of the function and more

559
00:22:37,440 --> 00:22:39,200
precisely

560
00:22:39,200 --> 00:22:41,200
expects the candidate function to

561
00:22:41,200 --> 00:22:43,840
receive two integer arguments one used

562
00:22:43,840 --> 00:22:45,679
as the base address of the buffer and

563
00:22:45,679 --> 00:22:48,480
the second used to denote its size

564
00:22:48,480 --> 00:22:50,960
and lastly it checks that the function

565
00:22:50,960 --> 00:22:53,360
returns the boolean value and now from

566
00:22:53,360 --> 00:22:55,440
the perspective of the decompiler

567
00:22:55,440 --> 00:22:57,840
boolean values are just plain integers

568
00:22:57,840 --> 00:23:00,799
so in order to make this a distinction

569
00:23:00,799 --> 00:23:03,919
brick has to scan the ast of the

570
00:23:03,919 --> 00:23:05,039
function

571
00:23:05,039 --> 00:23:07,280
visit all the return statements and

572
00:23:07,280 --> 00:23:09,280
actually check that their return value

573
00:23:09,280 --> 00:23:12,400
is either zero or one

574
00:23:12,400 --> 00:23:14,960
now if all three conditions are met then

575
00:23:14,960 --> 00:23:17,600
brica stops the search and declares that

576
00:23:17,600 --> 00:23:20,559
the match was found

577
00:23:21,280 --> 00:23:24,799
and now that it knows that smm is buffer

578
00:23:24,799 --> 00:23:27,039
outside smm valid is present in the

579
00:23:27,039 --> 00:23:30,080
binary it has to make sure that all the

580
00:23:30,080 --> 00:23:32,559
pointers are being covered by it so for

581
00:23:32,559 --> 00:23:34,320
that it goes through all the calls to

582
00:23:34,320 --> 00:23:35,520
the function

583
00:23:35,520 --> 00:23:38,559
and in this particular case

584
00:23:38,559 --> 00:23:40,880
it finds it found out that there is only

585
00:23:40,880 --> 00:23:42,880
one call to the function which is

586
00:23:42,880 --> 00:23:44,799
actually used to validate the address of

587
00:23:44,799 --> 00:23:47,039
the com buffer itself and while this is

588
00:23:47,039 --> 00:23:49,039
a very important check that actually

589
00:23:49,039 --> 00:23:50,960
mitigates some other classes of

590
00:23:50,960 --> 00:23:53,600
vulnerabilities it basically means

591
00:23:53,600 --> 00:23:55,760
nothing as far as nested pointers are

592
00:23:55,760 --> 00:23:58,000
concerned

593
00:23:58,000 --> 00:23:59,840
so to summarize

594
00:23:59,840 --> 00:24:02,320
using automation and some very simple

595
00:24:02,320 --> 00:24:05,200
heuristics brick managed to find an smi

596
00:24:05,200 --> 00:24:08,080
handler that can be invoked from

597
00:24:08,080 --> 00:24:10,400
a non-smm context

598
00:24:10,400 --> 00:24:12,480
that operates on a tackle controllable

599
00:24:12,480 --> 00:24:14,000
pointers that are nested within the

600
00:24:14,000 --> 00:24:16,640
communication buffer but unfortunately

601
00:24:16,640 --> 00:24:19,440
it does not utilize functions such as

602
00:24:19,440 --> 00:24:21,840
smm is buffer outside the semivalid to

603
00:24:21,840 --> 00:24:23,840
sanitize these pointers before using

604
00:24:23,840 --> 00:24:27,440
them so taking all three into account

605
00:24:27,440 --> 00:24:28,960
this is very likely to be a

606
00:24:28,960 --> 00:24:30,640
vulnerability

607
00:24:30,640 --> 00:24:32,720
and now i'll hand over to itai which

608
00:24:32,720 --> 00:24:34,320
will explain in detail how this

609
00:24:34,320 --> 00:24:37,840
vulnerability can be exploited

610
00:24:38,000 --> 00:24:39,120
hi

611
00:24:39,120 --> 00:24:41,360
hi

612
00:24:41,600 --> 00:24:45,200
so this part of the talk also have a few

613
00:24:45,200 --> 00:24:47,039
goals

614
00:24:47,039 --> 00:24:49,360
first we will expand the vulnerable

615
00:24:49,360 --> 00:24:51,840
function and show how we got to a right

616
00:24:51,840 --> 00:24:53,279
primitive

617
00:24:53,279 --> 00:24:54,960
then show how we can use the right

618
00:24:54,960 --> 00:24:58,000
primitive to get to a read primitive

619
00:24:58,000 --> 00:24:59,520
from there we will

620
00:24:59,520 --> 00:25:02,080
use the sm-ram we are able to read with

621
00:25:02,080 --> 00:25:04,159
the read primitive to

622
00:25:04,159 --> 00:25:06,799
get an execution

623
00:25:06,799 --> 00:25:08,320
and finally

624
00:25:08,320 --> 00:25:10,799
we will break secure boot security

625
00:25:10,799 --> 00:25:12,159
feature

626
00:25:12,159 --> 00:25:15,120
to allow us to load an unsigned os

627
00:25:15,120 --> 00:25:16,799
loader and

628
00:25:16,799 --> 00:25:18,640
break

629
00:25:18,640 --> 00:25:22,720
any os secure boot process

630
00:25:23,360 --> 00:25:26,480
so asop showed us that the smi handler

631
00:25:26,480 --> 00:25:31,760
of sbi smm stub of that dell computer

632
00:25:32,799 --> 00:25:35,039
has

633
00:25:35,679 --> 00:25:37,360
we suspect that is

634
00:25:37,360 --> 00:25:38,559
vulnerable

635
00:25:38,559 --> 00:25:41,120
and

636
00:25:41,120 --> 00:25:44,159
the function itself the

637
00:25:44,159 --> 00:25:48,159
smi handler uses the pch spi protocol

638
00:25:48,159 --> 00:25:50,799
that pro the protocol is used for spi

639
00:25:50,799 --> 00:25:52,640
flash operations like read write and

640
00:25:52,640 --> 00:25:54,320
erase

641
00:25:54,320 --> 00:25:56,640
the protocol functions are called with

642
00:25:56,640 --> 00:25:58,720
argument from the command buffer without

643
00:25:58,720 --> 00:26:01,200
any verification

644
00:26:01,200 --> 00:26:03,440
we wish we could uh we could use the

645
00:26:03,440 --> 00:26:06,080
flash write function in the protocol for

646
00:26:06,080 --> 00:26:09,120
execution and persistency but the flash

647
00:26:09,120 --> 00:26:11,120
content is signed

648
00:26:11,120 --> 00:26:13,760
and protected by boot guard

649
00:26:13,760 --> 00:26:16,320
writing unsigned code to the flash will

650
00:26:16,320 --> 00:26:18,480
prevent the system from booting so that

651
00:26:18,480 --> 00:26:21,360
doesn't work for us

652
00:26:21,360 --> 00:26:23,840
the flash read function is used to read

653
00:26:23,840 --> 00:26:28,080
a buffer from the flash to memory

654
00:26:28,080 --> 00:26:30,960
we can set the smi handler to call flash

655
00:26:30,960 --> 00:26:32,640
read

656
00:26:32,640 --> 00:26:35,679
we can we can provide flash address

657
00:26:35,679 --> 00:26:38,400
buffer size and destination address the

658
00:26:38,400 --> 00:26:40,240
function will write write the flash

659
00:26:40,240 --> 00:26:42,559
contents to the destination without

660
00:26:42,559 --> 00:26:46,399
validating the destination address

661
00:26:47,360 --> 00:26:50,000
we set the buffer argument to point to a

662
00:26:50,000 --> 00:26:53,039
location in smram we wish to override we

663
00:26:53,039 --> 00:26:55,039
can only but we can only control the

664
00:26:55,039 --> 00:26:56,960
value being written by controlling the

665
00:26:56,960 --> 00:26:58,670
flash offsets

666
00:26:58,670 --> 00:27:01,039
[Music]

667
00:27:01,039 --> 00:27:03,679
to write arbitrary data we can set the

668
00:27:03,679 --> 00:27:06,559
handler to call the flash read to read a

669
00:27:06,559 --> 00:27:09,360
block of to normal run

670
00:27:09,360 --> 00:27:13,360
so we can read the flash block

671
00:27:14,559 --> 00:27:16,960
we can use the flash block to generate a

672
00:27:16,960 --> 00:27:20,240
dictionary mapping byte values to flash

673
00:27:20,240 --> 00:27:21,440
offsets

674
00:27:21,440 --> 00:27:23,840
and use the dictionary to write what we

675
00:27:23,840 --> 00:27:26,879
want where we want

676
00:27:27,279 --> 00:27:29,520
after understanding the right primitive

677
00:27:29,520 --> 00:27:32,320
we can we wanted a read primitive so we

678
00:27:32,320 --> 00:27:34,720
can dump smram usually smram is not

679
00:27:34,720 --> 00:27:37,120
accessible to anyone

680
00:27:37,120 --> 00:27:40,720
we found a way to get from a writes

681
00:27:40,720 --> 00:27:42,000
to a read

682
00:27:42,000 --> 00:27:42,880
with

683
00:27:42,880 --> 00:27:46,000
by adding our own smi handler

684
00:27:46,000 --> 00:27:48,480
there is a linked list of smi handlers

685
00:27:48,480 --> 00:27:52,000
in the pi smm core uefi module

686
00:27:52,000 --> 00:27:54,159
the base address of pi smm core is

687
00:27:54,159 --> 00:27:56,960
exposed to the os in the smm core

688
00:27:56,960 --> 00:28:00,159
private data structure used for calling

689
00:28:00,159 --> 00:28:03,159
smis

690
00:28:04,080 --> 00:28:06,080
the head of the linked list is a global

691
00:28:06,080 --> 00:28:08,640
variable in pi smm core and since we

692
00:28:08,640 --> 00:28:11,840
have the image base we know where it is

693
00:28:11,840 --> 00:28:14,000
we can add our own handler by

694
00:28:14,000 --> 00:28:16,399
overwriting the pointer to the first

695
00:28:16,399 --> 00:28:18,799
entry

696
00:28:18,960 --> 00:28:21,360
the linked list connect smi entry

697
00:28:21,360 --> 00:28:22,960
structures

698
00:28:22,960 --> 00:28:25,600
each entry contains a linked list to smi

699
00:28:25,600 --> 00:28:27,520
handler structures

700
00:28:27,520 --> 00:28:29,919
each smi handler structure points to a

701
00:28:29,919 --> 00:28:32,960
function that serves the smi

702
00:28:32,960 --> 00:28:35,679
when called the first argument of the

703
00:28:35,679 --> 00:28:38,000
function is the pointer back to the smi

704
00:28:38,000 --> 00:28:39,679
handler structure and that will be

705
00:28:39,679 --> 00:28:42,559
important later

706
00:28:43,120 --> 00:28:46,320
we can create fake smi entry and smi

707
00:28:46,320 --> 00:28:49,840
handler structures in normal run

708
00:28:49,840 --> 00:28:52,399
then we can use the right primitive to

709
00:28:52,399 --> 00:28:54,480
override the linked list head

710
00:28:54,480 --> 00:28:58,880
with the fake smi entry physical address

711
00:28:58,880 --> 00:29:00,159
in modern

712
00:29:00,159 --> 00:29:03,760
systems smm code must reside in smram

713
00:29:03,760 --> 00:29:06,000
due to the use of the smm code check

714
00:29:06,000 --> 00:29:07,520
mitigation

715
00:29:07,520 --> 00:29:09,200
that means that

716
00:29:09,200 --> 00:29:12,000
the handler will we will add must point

717
00:29:12,000 --> 00:29:14,399
to a function in smrom

718
00:29:14,399 --> 00:29:16,640
we need to find a rope chain or a

719
00:29:16,640 --> 00:29:19,760
function already in smram segment we can

720
00:29:19,760 --> 00:29:21,039
use

721
00:29:21,039 --> 00:29:23,600
we are looking for a mem copy like

722
00:29:23,600 --> 00:29:27,440
function in pi smm core that can that we

723
00:29:27,440 --> 00:29:29,760
can use with the limited control we have

724
00:29:29,760 --> 00:29:32,799
over the arguments

725
00:29:33,279 --> 00:29:36,240
we've found a function that only takes

726
00:29:36,240 --> 00:29:39,520
one argument and call memcopy to copy 16

727
00:29:39,520 --> 00:29:41,039
bytes

728
00:29:41,039 --> 00:29:41,840
the

729
00:29:41,840 --> 00:29:44,000
the source and destination addresses are

730
00:29:44,000 --> 00:29:46,000
derived from the argument

731
00:29:46,000 --> 00:29:48,080
if we can control that argument we

732
00:29:48,080 --> 00:29:51,199
control mem copy

733
00:29:52,080 --> 00:29:54,799
we can set the smi handler to point to

734
00:29:54,799 --> 00:29:57,600
this function and extend the basic smi

735
00:29:57,600 --> 00:30:00,480
handler structure with additional fields

736
00:30:00,480 --> 00:30:02,240
the new fields will be used by the

737
00:30:02,240 --> 00:30:03,760
function to calculate the source and

738
00:30:03,760 --> 00:30:07,200
destination addresses for the mam copy

739
00:30:07,200 --> 00:30:09,760
since the structure is in normal run we

740
00:30:09,760 --> 00:30:11,919
can modify the arguments before every

741
00:30:11,919 --> 00:30:14,720
invocation of the smi

742
00:30:14,720 --> 00:30:17,120
now we can trigger the smi repeatedly

743
00:30:17,120 --> 00:30:22,039
read 16 bytes at a time and dump semron

744
00:30:22,480 --> 00:30:24,559
to complete exploitation we wanted to be

745
00:30:24,559 --> 00:30:27,760
able to run arbitrary code in smm

746
00:30:27,760 --> 00:30:31,279
smm code can only run in smram

747
00:30:31,279 --> 00:30:33,760
and in smram the code segments are

748
00:30:33,760 --> 00:30:35,760
non-writable and the data segments are

749
00:30:35,760 --> 00:30:37,919
non-executable

750
00:30:37,919 --> 00:30:39,520
do we need to look for

751
00:30:39,520 --> 00:30:42,320
a rock chain to change the permission

752
00:30:42,320 --> 00:30:43,279
no

753
00:30:43,279 --> 00:30:45,520
we can disable the write protection by

754
00:30:45,520 --> 00:30:47,600
disabling the right protection bit in

755
00:30:47,600 --> 00:30:51,200
the cr0 register overwrite some existing

756
00:30:51,200 --> 00:30:52,720
smm code

757
00:30:52,720 --> 00:30:56,480
with our shell code and jump there

758
00:30:57,519 --> 00:31:00,640
we've found a rop gadget in the sm-ram

759
00:31:00,640 --> 00:31:01,600
dump

760
00:31:01,600 --> 00:31:04,480
performing performing the stack pivots

761
00:31:04,480 --> 00:31:08,080
of the part of the rope is very complex

762
00:31:08,080 --> 00:31:10,480
so we provided the detailed explanation

763
00:31:10,480 --> 00:31:13,200
in the github repo

764
00:31:13,200 --> 00:31:15,440
here we can see the other stages of the

765
00:31:15,440 --> 00:31:18,000
chain we store the frame buffer in

766
00:31:18,000 --> 00:31:19,919
memory so we can return to regular

767
00:31:19,919 --> 00:31:22,159
execution after the shell code we

768
00:31:22,159 --> 00:31:25,039
disable the write protect bit in cr0 by

769
00:31:25,039 --> 00:31:28,480
writing a and hard coded value to the

770
00:31:28,480 --> 00:31:30,960
where the bit is set to zero

771
00:31:30,960 --> 00:31:33,600
we copy the shell code to from normal

772
00:31:33,600 --> 00:31:35,760
memory to the code segment of pi smm

773
00:31:35,760 --> 00:31:36,559
core

774
00:31:36,559 --> 00:31:40,000
and return to the shell code

775
00:31:40,080 --> 00:31:44,240
now that we can run arbitrary code

776
00:31:44,399 --> 00:31:46,799
we would like to show an example of what

777
00:31:46,799 --> 00:31:48,640
can be done with it

778
00:31:48,640 --> 00:31:51,360
we saw a lot of news about boot kits

779
00:31:51,360 --> 00:31:52,320
lately

780
00:31:52,320 --> 00:31:55,279
but taking a closer look shows that

781
00:31:55,279 --> 00:31:57,519
they target old systems with no secure

782
00:31:57,519 --> 00:32:00,720
boots and boot guard support

783
00:32:00,720 --> 00:32:03,120
we can use our smm code execution to

784
00:32:03,120 --> 00:32:05,200
disable secure boot and allow the

785
00:32:05,200 --> 00:32:09,440
loading of an unsigned os loader

786
00:32:09,440 --> 00:32:11,600
on this system there are two efi

787
00:32:11,600 --> 00:32:14,799
variables for controlling secure boots

788
00:32:14,799 --> 00:32:17,679
secure boot enable let the user set

789
00:32:17,679 --> 00:32:20,559
secure boot on and off in the bios

790
00:32:20,559 --> 00:32:24,799
but it's not accessible during runtime

791
00:32:24,799 --> 00:32:27,200
secure boot mode lets the user choose

792
00:32:27,200 --> 00:32:30,000
between deployed mode and audit mode

793
00:32:30,000 --> 00:32:31,360
deployed mode

794
00:32:31,360 --> 00:32:34,480
enforces secure boot audit mode verifies

795
00:32:34,480 --> 00:32:36,480
the signature but doesn't prevent the

796
00:32:36,480 --> 00:32:39,200
mode of the model from loading

797
00:32:39,200 --> 00:32:41,600
secure boot mode is accessible during

798
00:32:41,600 --> 00:32:45,439
runtime but it's write protected

799
00:32:46,399 --> 00:32:48,399
to bypass the secure boot write

800
00:32:48,399 --> 00:32:52,000
protection we can use the smm variable

801
00:32:52,000 --> 00:32:54,960
set variable function

802
00:32:54,960 --> 00:32:58,159
this function bypasses the

803
00:32:58,159 --> 00:33:00,559
variable write protect check by setting

804
00:33:00,559 --> 00:33:02,559
a global flag

805
00:33:02,559 --> 00:33:05,279
since smm is considered privileged it's

806
00:33:05,279 --> 00:33:06,799
allowed to change write protected

807
00:33:06,799 --> 00:33:09,799
variables

808
00:33:10,640 --> 00:33:13,360
we can set the value to audit mode and

809
00:33:13,360 --> 00:33:15,919
that will allow us to load unsigned and

810
00:33:15,919 --> 00:33:18,000
unsigned os loader

811
00:33:18,000 --> 00:33:20,000
but we've found that setting the value

812
00:33:20,000 --> 00:33:22,799
to any other unsupported value allows

813
00:33:22,799 --> 00:33:24,559
the loading of the

814
00:33:24,559 --> 00:33:26,880
of the unsigned loaders but head adds

815
00:33:26,880 --> 00:33:29,600
the benefit of preventing the user from

816
00:33:29,600 --> 00:33:31,440
switching back to deployed mode in the

817
00:33:31,440 --> 00:33:33,279
bios setup

818
00:33:33,279 --> 00:33:37,399
let's see that in a demo

819
00:33:41,440 --> 00:33:43,039
so we can see that

820
00:33:43,039 --> 00:33:45,200
secure boot is enabled and in deployed

821
00:33:45,200 --> 00:33:47,519
mode

822
00:33:51,279 --> 00:33:53,760
now we can try to load an unsigned os

823
00:33:53,760 --> 00:33:57,919
loader and we get an error message

824
00:33:58,320 --> 00:34:00,880
now we can go to linux

825
00:34:00,880 --> 00:34:01,919
and

826
00:34:01,919 --> 00:34:03,919
execute our

827
00:34:03,919 --> 00:34:06,919
exploit

828
00:34:16,560 --> 00:34:18,960
that's it it's all done we can restart

829
00:34:18,960 --> 00:34:20,719
and try to

830
00:34:20,719 --> 00:34:22,879
load the

831
00:34:22,879 --> 00:34:26,000
unsigned loader again

832
00:34:26,000 --> 00:34:27,679
now it's successful

833
00:34:27,679 --> 00:34:33,000
let's see the changes in the bios setup

834
00:34:42,320 --> 00:34:44,480
we can see that secure boot is enabled

835
00:34:44,480 --> 00:34:45,599
but deployed

836
00:34:45,599 --> 00:34:47,040
is off

837
00:34:47,040 --> 00:34:48,399
if we try to

838
00:34:48,399 --> 00:34:51,679
re-enable deployed mode

839
00:34:54,960 --> 00:34:56,960
we can see that it doesn't work we can

840
00:34:56,960 --> 00:34:58,000
still

841
00:34:58,000 --> 00:35:02,839
boot to the unsigned os loader

842
00:35:07,680 --> 00:35:10,078
all right

843
00:35:10,720 --> 00:35:13,520
a little bit about the bug

844
00:35:13,520 --> 00:35:15,920
we've reported the bug to dell del

845
00:35:15,920 --> 00:35:18,480
informed us that the bug is in intel's

846
00:35:18,480 --> 00:35:20,560
bios reference code

847
00:35:20,560 --> 00:35:22,880
so we reported the bug to intel intel

848
00:35:22,880 --> 00:35:24,830
acknowledged with two cvs

849
00:35:24,830 --> 00:35:26,880
[Music]

850
00:35:26,880 --> 00:35:29,680
intel uh asked for extra time before the

851
00:35:29,680 --> 00:35:32,480
disclosure to allow all the vendors time

852
00:35:32,480 --> 00:35:35,280
to update their biases

853
00:35:35,280 --> 00:35:37,920
the bug affected many pro intel products

854
00:35:37,920 --> 00:35:39,680
which means that we can

855
00:35:39,680 --> 00:35:42,000
encounter similar bugs on many systems

856
00:35:42,000 --> 00:35:44,480
from different vendors we've already

857
00:35:44,480 --> 00:35:46,800
discovered and were able to

858
00:35:46,800 --> 00:35:48,240
exploit

859
00:35:48,240 --> 00:35:53,200
a similar bug on a gigabyte uefi bios

860
00:35:54,160 --> 00:35:55,280
and

861
00:35:55,280 --> 00:35:56,800
from all that

862
00:35:56,800 --> 00:35:58,560
exploitation

863
00:35:58,560 --> 00:35:59,680
work

864
00:35:59,680 --> 00:36:00,640
we

865
00:36:00,640 --> 00:36:03,520
came up with quite a few tools and

866
00:36:03,520 --> 00:36:05,760
techniques so let's talk a little bit

867
00:36:05,760 --> 00:36:08,320
about them

868
00:36:09,200 --> 00:36:12,000
so using chipset from linux and windows

869
00:36:12,000 --> 00:36:15,359
is great for uefi exploration but when

870
00:36:15,359 --> 00:36:18,240
working on exploitation

871
00:36:18,240 --> 00:36:20,160
it's very limiting because you have to

872
00:36:20,160 --> 00:36:23,760
boot to the to an os every time

873
00:36:23,760 --> 00:36:26,240
we can use efi shell it boots very

874
00:36:26,240 --> 00:36:27,440
quickly

875
00:36:27,440 --> 00:36:30,160
if i shell supports executing a shell

876
00:36:30,160 --> 00:36:33,119
scrape at startup

877
00:36:33,119 --> 00:36:35,920
that's very useful for automation

878
00:36:35,920 --> 00:36:38,800
however if i shall wait 5 seconds before

879
00:36:38,800 --> 00:36:41,440
executing the shell script

880
00:36:41,440 --> 00:36:43,040
so we found it

881
00:36:43,040 --> 00:36:45,680
useful to recompile efi shell with no

882
00:36:45,680 --> 00:36:48,480
delay and that allows for

883
00:36:48,480 --> 00:36:52,240
much quicker automation

884
00:36:53,359 --> 00:36:56,000
we can use chipset in efi shell but

885
00:36:56,000 --> 00:36:58,480
we've found that it's even quicker to

886
00:36:58,480 --> 00:37:00,160
use micro python

887
00:37:00,160 --> 00:37:02,560
there's a micro python implementation

888
00:37:02,560 --> 00:37:06,839
for efi shell in the edk2 staging pro

889
00:37:06,839 --> 00:37:10,160
repo but it doesn't have a quick way to

890
00:37:10,160 --> 00:37:12,560
deal with large memory buffers

891
00:37:12,560 --> 00:37:14,880
so we've added support for reading and

892
00:37:14,880 --> 00:37:19,119
writing using python's bytes data type

893
00:37:19,119 --> 00:37:22,640
it can be found in my github repo

894
00:37:22,640 --> 00:37:25,200
[Music]

895
00:37:25,200 --> 00:37:27,040
here is an example of

896
00:37:27,040 --> 00:37:29,440
micro python code calling a function

897
00:37:29,440 --> 00:37:32,320
from a uefi protocol something that is

898
00:37:32,320 --> 00:37:34,839
very hard to do with

899
00:37:34,839 --> 00:37:38,640
chipset uh pitch pi is a small assembler

900
00:37:38,640 --> 00:37:41,359
for python uh that was

901
00:37:41,359 --> 00:37:44,480
relatively easy to pour to micro python

902
00:37:44,480 --> 00:37:47,359
and here we can see an example

903
00:37:47,359 --> 00:37:49,200
of pitch by assembling a small shell

904
00:37:49,200 --> 00:37:52,560
code we can also see that the shellcode

905
00:37:52,560 --> 00:37:54,400
variable

906
00:37:54,400 --> 00:37:56,000
is using the

907
00:37:56,000 --> 00:37:57,280
added

908
00:37:57,280 --> 00:37:59,920
bytes access memory type that we

909
00:37:59,920 --> 00:38:02,800
talked about already

910
00:38:03,040 --> 00:38:05,200
while working on exploitation before

911
00:38:05,200 --> 00:38:07,760
restoring to normal execution we need a

912
00:38:07,760 --> 00:38:10,640
way to return information from smm

913
00:38:10,640 --> 00:38:13,599
before the computer hangs

914
00:38:13,599 --> 00:38:16,640
we were writing information to a

915
00:38:16,640 --> 00:38:19,520
hard-coded physical address

916
00:38:19,520 --> 00:38:23,280
and using a usb 3380

917
00:38:23,280 --> 00:38:26,640
board with a pci leach from another com

918
00:38:26,640 --> 00:38:28,720
computer reading the physical memory and

919
00:38:28,720 --> 00:38:33,839
getting debug information out that way

920
00:38:34,400 --> 00:38:36,400
when messing with bias

921
00:38:36,400 --> 00:38:39,040
writing protected variables directly to

922
00:38:39,040 --> 00:38:40,720
flash

923
00:38:40,720 --> 00:38:43,040
overriding models eventually you end up

924
00:38:43,040 --> 00:38:46,400
with bricks systems in this case

925
00:38:46,400 --> 00:38:49,119
flash programmers and hot air stations

926
00:38:49,119 --> 00:38:50,730
are definitely your friends

927
00:38:50,730 --> 00:38:53,280
[Music]

928
00:38:53,280 --> 00:38:55,520
and

929
00:38:55,520 --> 00:38:57,200
now we can talk a little bit about

930
00:38:57,200 --> 00:38:59,280
mitigations and

931
00:38:59,280 --> 00:39:01,040
what would have prevented us from

932
00:39:01,040 --> 00:39:04,320
exploiting this vulnerability

933
00:39:04,320 --> 00:39:06,880
so intel boot guard is

934
00:39:06,880 --> 00:39:09,680
a relatively new technology that

935
00:39:09,680 --> 00:39:11,680
complements secure boots

936
00:39:11,680 --> 00:39:13,680
while secure boot ensures that the os

937
00:39:13,680 --> 00:39:15,359
loader is signed

938
00:39:15,359 --> 00:39:17,440
bootguard ensures that the bios is

939
00:39:17,440 --> 00:39:19,119
signed

940
00:39:19,119 --> 00:39:21,920
bootguards works by storing the vendor's

941
00:39:21,920 --> 00:39:24,720
public keys in the pcage on every boot

942
00:39:24,720 --> 00:39:27,520
the pcie verifies that the firmware is

943
00:39:27,520 --> 00:39:30,560
indeed signed by the vendor

944
00:39:30,560 --> 00:39:32,560
because intel boot guards

945
00:39:32,560 --> 00:39:34,800
because of intel's boot guard

946
00:39:34,800 --> 00:39:37,040
we didn't look into writing directly to

947
00:39:37,040 --> 00:39:38,720
the flesh

948
00:39:38,720 --> 00:39:41,200
we should mention that other researchers

949
00:39:41,200 --> 00:39:42,400
did show that

950
00:39:42,400 --> 00:39:45,440
on some system boot guard isn't

951
00:39:45,440 --> 00:39:47,920
configured correctly and then they were

952
00:39:47,920 --> 00:39:50,320
able to write modules

953
00:39:50,320 --> 00:39:55,040
into a boot guarded bios

954
00:39:55,680 --> 00:39:57,040
new smm

955
00:39:57,040 --> 00:39:59,440
mitigations were added to the intel vpro

956
00:39:59,440 --> 00:40:01,359
platform starting at the eighth

957
00:40:01,359 --> 00:40:03,760
generation coffee lake

958
00:40:03,760 --> 00:40:07,319
the new mitigations include include

959
00:40:07,319 --> 00:40:09,119
zrcr0 lock

960
00:40:09,119 --> 00:40:10,800
which would have prevented us from

961
00:40:10,800 --> 00:40:14,560
writing on smm code segments

962
00:40:14,560 --> 00:40:17,200
we think it is a good idea if intel

963
00:40:17,200 --> 00:40:18,960
added these mitigations to all its

964
00:40:18,960 --> 00:40:23,800
processors and not just the vpro line

965
00:40:24,079 --> 00:40:26,800
multiple smram addresses are exposed to

966
00:40:26,800 --> 00:40:29,839
the os via the smm core private data

967
00:40:29,839 --> 00:40:31,280
structure

968
00:40:31,280 --> 00:40:33,119
while by design they help the

969
00:40:33,119 --> 00:40:35,920
exploitation of smm vulnerabilities

970
00:40:35,920 --> 00:40:37,440
and we think

971
00:40:37,440 --> 00:40:39,520
it can be avoided by a small number of

972
00:40:39,520 --> 00:40:43,759
changes in the edk2 products

973
00:40:45,119 --> 00:40:48,480
in our exploit we added a handler by

974
00:40:48,480 --> 00:40:51,119
overwriting the first member pointer in

975
00:40:51,119 --> 00:40:54,000
the smi entry link list

976
00:40:54,000 --> 00:40:57,119
the new smi entry is stored in normal

977
00:40:57,119 --> 00:40:58,720
rom

978
00:40:58,720 --> 00:41:00,960
the code assumes that the entries are in

979
00:41:00,960 --> 00:41:02,400
smram but

980
00:41:02,400 --> 00:41:06,079
does not validate this assumption

981
00:41:06,079 --> 00:41:08,480
this can be fixed by verifying that

982
00:41:08,480 --> 00:41:11,280
every entry and handler of pointers are

983
00:41:11,280 --> 00:41:12,800
in smram

984
00:41:12,800 --> 00:41:14,960
we are trying to push this mitigation to

985
00:41:14,960 --> 00:41:18,760
the edk2 project

986
00:41:20,560 --> 00:41:22,480
i'll give your stuff back to talk a

987
00:41:22,480 --> 00:41:24,800
little bit about references and

988
00:41:24,800 --> 00:41:27,440
yeah so uh just before concluding we

989
00:41:27,440 --> 00:41:30,640
wanted to give you a few references for

990
00:41:30,640 --> 00:41:33,599
future reading and so first of all we

991
00:41:33,599 --> 00:41:35,760
have some

992
00:41:35,760 --> 00:41:37,440
links both to

993
00:41:37,440 --> 00:41:38,960
blick which is the

994
00:41:38,960 --> 00:41:40,960
automated scanning tool that i showed

995
00:41:40,960 --> 00:41:43,280
you later and um

996
00:41:43,280 --> 00:41:47,280
an additional repo for the exploit code

997
00:41:47,280 --> 00:41:49,200
uh all the tools that

998
00:41:49,200 --> 00:41:51,760
i mentioned and some additional

999
00:41:51,760 --> 00:41:54,240
explanations for the rock chain which

1000
00:41:54,240 --> 00:41:56,640
was uh pretty complex

1001
00:41:56,640 --> 00:42:00,880
and then we have um a blog post series

1002
00:42:00,880 --> 00:42:04,480
of six parts that we wrote about uefi

1003
00:42:04,480 --> 00:42:06,960
and smm security it starts from like

1004
00:42:06,960 --> 00:42:09,040
baby steps of how to

1005
00:42:09,040 --> 00:42:12,079
dump the the bios from the spi chip and

1006
00:42:12,079 --> 00:42:13,520
ends up with

1007
00:42:13,520 --> 00:42:17,359
exploiting these smm vulnerabilities um

1008
00:42:17,359 --> 00:42:18,720
and finally

1009
00:42:18,720 --> 00:42:21,760
we have some other references

1010
00:42:21,760 --> 00:42:23,839
that were written by other researchers

1011
00:42:23,839 --> 00:42:25,520
and we used these

1012
00:42:25,520 --> 00:42:27,680
references extensively during our

1013
00:42:27,680 --> 00:42:29,599
research to

1014
00:42:29,599 --> 00:42:32,560
learn about the topic and

1015
00:42:32,560 --> 00:42:34,480
get into it basically

1016
00:42:34,480 --> 00:42:35,760
and

1017
00:42:35,760 --> 00:42:37,680
that's it for this talk so thank you

1018
00:42:37,680 --> 00:42:40,480
very much for your attention and have a

1019
00:42:40,480 --> 00:42:43,960
pleasant conference

1020
00:42:45,839 --> 00:42:47,680
thank you thank you guys thank you for

1021
00:42:47,680 --> 00:42:50,240
the presentation if there is any

1022
00:42:50,240 --> 00:42:53,240
questions

1023
00:43:08,000 --> 00:43:09,359
where are you

1024
00:43:09,359 --> 00:43:12,359
okay

1025
00:43:15,930 --> 00:43:17,599
[Music]

1026
00:43:17,599 --> 00:43:21,040
um so from what i understood you were

1027
00:43:21,040 --> 00:43:24,560
debugging on a real machine

1028
00:43:24,560 --> 00:43:27,040
because you are using a pci leach to to

1029
00:43:27,040 --> 00:43:29,200
get debug information so

1030
00:43:29,200 --> 00:43:31,760
is there any emulator or

1031
00:43:31,760 --> 00:43:34,800
tool that could help you to emulate

1032
00:43:34,800 --> 00:43:35,520
the

1033
00:43:35,520 --> 00:43:38,480
exploit the expected code so you don't

1034
00:43:38,480 --> 00:43:39,599
have to

1035
00:43:39,599 --> 00:43:42,400
break device

1036
00:43:43,040 --> 00:43:45,920
so yes there is

1037
00:43:45,920 --> 00:43:49,920
the we did work on adding uefi supports

1038
00:43:49,920 --> 00:43:51,359
to a

1039
00:43:51,359 --> 00:43:52,960
python rap

1040
00:43:52,960 --> 00:43:54,400
an environment

1041
00:43:54,400 --> 00:43:56,960
python environment for emulating cpus

1042
00:43:56,960 --> 00:44:01,440
and os's called chilling

1043
00:44:01,440 --> 00:44:02,400
so

1044
00:44:02,400 --> 00:44:05,760
we could work on this

1045
00:44:05,760 --> 00:44:10,000
vulnerability in chilling and we could

1046
00:44:10,000 --> 00:44:13,119
try the exploit but the

1047
00:44:13,119 --> 00:44:17,119
the exploit part and being able to

1048
00:44:17,119 --> 00:44:20,480
come back from the restore execution and

1049
00:44:20,480 --> 00:44:22,160
stuff like that that you have to do on a

1050
00:44:22,160 --> 00:44:23,280
real machine

1051
00:44:23,280 --> 00:44:25,680
saying that after dumping sm-ram we were

1052
00:44:25,680 --> 00:44:27,359
able to

1053
00:44:27,359 --> 00:44:29,440
load the

1054
00:44:29,440 --> 00:44:32,240
relevant sections from our binary dump

1055
00:44:32,240 --> 00:44:36,400
to the emulator and work on the

1056
00:44:36,400 --> 00:44:40,640
exploitation in emulation as well

1057
00:44:42,400 --> 00:44:45,839
and one more question here

1058
00:44:46,240 --> 00:44:47,920
hello hi

1059
00:44:47,920 --> 00:44:51,119
very nice talk by the way so very stupid

1060
00:44:51,119 --> 00:44:53,680
question in reality um

1061
00:44:53,680 --> 00:44:56,640
if the bios is password protected

1062
00:44:56,640 --> 00:44:58,319
when you then boot the system do you

1063
00:44:58,319 --> 00:44:59,520
have the same

1064
00:44:59,520 --> 00:45:02,079
level of access and privileges

1065
00:45:02,079 --> 00:45:04,079
to the smm

1066
00:45:04,079 --> 00:45:05,119
so

1067
00:45:05,119 --> 00:45:07,040
a bios lock doesn't affect this

1068
00:45:07,040 --> 00:45:08,720
vulnerability at all

1069
00:45:08,720 --> 00:45:13,118
we change the variables from the exploit

1070
00:45:14,079 --> 00:45:17,560
any more questions

1071
00:45:26,960 --> 00:45:29,040
thank you thank you for the presentation

1072
00:45:29,040 --> 00:45:30,960
what next for you are you planning to

1073
00:45:30,960 --> 00:45:32,880
exploit the

1074
00:45:32,880 --> 00:45:35,440
acpi stuff because you know inside the

1075
00:45:35,440 --> 00:45:38,240
smf you have tons of a cpi

1076
00:45:38,240 --> 00:45:40,560
for regarding the power management and

1077
00:45:40,560 --> 00:45:42,720
with this i think you can find a few

1078
00:45:42,720 --> 00:45:44,160
things like

1079
00:45:44,160 --> 00:45:47,200
unlocking some pages and so on so i'm a

1080
00:45:47,200 --> 00:45:48,800
bit interested to have a discussion with

1081
00:45:48,800 --> 00:45:50,880
you regarding this

1082
00:45:50,880 --> 00:45:52,400
i don't know if you know what is a cpi

1083
00:45:52,400 --> 00:45:53,760
stuff

1084
00:45:53,760 --> 00:45:54,560
so

1085
00:45:54,560 --> 00:45:55,440
uh

1086
00:45:55,440 --> 00:45:58,160
we don't have a plan to continue this

1087
00:45:58,160 --> 00:45:59,920
research

1088
00:45:59,920 --> 00:46:02,500
as far as i know

1089
00:46:02,500 --> 00:46:05,610
[Music]

1090
00:46:06,319 --> 00:46:09,119
someone else

1091
00:46:10,079 --> 00:46:13,079
what

1092
00:46:16,880 --> 00:46:19,280
uh thanks for the talk very interesting

1093
00:46:19,280 --> 00:46:22,560
uh i'm kind of confused on how

1094
00:46:22,560 --> 00:46:25,839
the rope chain gets started because you

1095
00:46:25,839 --> 00:46:30,240
only get to overwrite one pointer right

1096
00:46:30,240 --> 00:46:32,319
oh so

1097
00:46:32,319 --> 00:46:34,720
yeah we only override

1098
00:46:34,720 --> 00:46:36,000
one pointer

1099
00:46:36,000 --> 00:46:37,760
but we do

1100
00:46:37,760 --> 00:46:40,720
and i said that that's the the start of

1101
00:46:40,720 --> 00:46:42,880
the drop chain is relatively complex and

1102
00:46:42,880 --> 00:46:44,319
there's a doc

1103
00:46:44,319 --> 00:46:46,640
all about it in the github repo

1104
00:46:46,640 --> 00:46:48,480
because we call the function multiple

1105
00:46:48,480 --> 00:46:49,760
times and

1106
00:46:49,760 --> 00:46:52,079
run around it

1107
00:46:52,079 --> 00:46:54,079
you better read the explanation

1108
00:46:54,079 --> 00:46:57,550
okay thanks so it's simple

1109
00:46:57,550 --> 00:47:00,589
[Music]

1110
00:47:01,680 --> 00:47:04,400
more questions

1111
00:47:04,400 --> 00:47:06,800
if no we can thanks our speakers thank

1112
00:47:06,800 --> 00:47:08,220
you everyone

1113
00:47:08,220 --> 00:47:11,680
[Applause]

1114
00:47:11,680 --> 00:47:13,759
you

