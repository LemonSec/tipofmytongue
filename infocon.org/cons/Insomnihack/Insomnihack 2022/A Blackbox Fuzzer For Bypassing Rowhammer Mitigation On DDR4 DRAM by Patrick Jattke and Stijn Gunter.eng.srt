1
00:00:06,820 --> 00:00:09,869
[Music]

2
00:00:14,160 --> 00:00:16,000
so hi and welcome to my presentation

3
00:00:16,000 --> 00:00:17,920
about blacksmith scalable row hammering

4
00:00:17,920 --> 00:00:19,760
in the frequency domain my name is

5
00:00:19,760 --> 00:00:21,520
patrick and i'm a phd student in the

6
00:00:21,520 --> 00:00:24,720
computer security group at eth surge

7
00:00:24,720 --> 00:00:26,720
and this work blacksmith has been joined

8
00:00:26,720 --> 00:00:29,119
work with qualcomm and v amsterdam

9
00:00:29,119 --> 00:00:32,640
so our our talk has uh two two parts in

10
00:00:32,640 --> 00:00:34,559
the first part i will talk about uh

11
00:00:34,559 --> 00:00:37,360
blacksmith which is a rowhammer fuzzer

12
00:00:37,360 --> 00:00:39,600
so i will explain how

13
00:00:39,600 --> 00:00:40,719
you can

14
00:00:40,719 --> 00:00:42,719
create a primitive that allows you to

15
00:00:42,719 --> 00:00:44,399
trigger bit flips in memory

16
00:00:44,399 --> 00:00:46,399
and in the second part my colleague

17
00:00:46,399 --> 00:00:48,480
stein will show you how you can use

18
00:00:48,480 --> 00:00:51,760
these bit flips to exploit a system

19
00:00:51,760 --> 00:00:53,440
so let's get started

20
00:00:53,440 --> 00:00:56,160
so first i will give you a brief summary

21
00:00:56,160 --> 00:00:58,320
so our work is motivated by the claim

22
00:00:58,320 --> 00:01:00,320
from dram manufacturers

23
00:01:00,320 --> 00:01:02,719
who promise that the dram devices are

24
00:01:02,719 --> 00:01:04,080
row hammer free

25
00:01:04,080 --> 00:01:06,400
so for example samsung promised in their

26
00:01:06,400 --> 00:01:08,000
general assembly presentation that they

27
00:01:08,000 --> 00:01:10,000
have now hammer-free devices that

28
00:01:10,000 --> 00:01:11,520
consume less power and have more

29
00:01:11,520 --> 00:01:12,560
performance

30
00:01:12,560 --> 00:01:14,560
and also micron mentions it in their

31
00:01:14,560 --> 00:01:15,920
product specifications that their

32
00:01:15,920 --> 00:01:18,400
devices are hammer-free

33
00:01:18,400 --> 00:01:20,479
however we show in our work that we can

34
00:01:20,479 --> 00:01:22,640
craft novel frequency based drama access

35
00:01:22,640 --> 00:01:24,560
pattern that allow to bypass all

36
00:01:24,560 --> 00:01:26,880
currently deployed mitigations on ddr4

37
00:01:26,880 --> 00:01:28,000
devices

38
00:01:28,000 --> 00:01:29,600
and for that we build a fuzzer named

39
00:01:29,600 --> 00:01:32,320
blacksmith that uses these news patterns

40
00:01:32,320 --> 00:01:34,320
and allows large-scale testing of dram

41
00:01:34,320 --> 00:01:35,600
devices

42
00:01:35,600 --> 00:01:37,600
and our work also provides novel

43
00:01:37,600 --> 00:01:39,840
insights about mitigations and the

44
00:01:39,840 --> 00:01:42,079
patterns found by blacksmith

45
00:01:42,079 --> 00:01:44,159
and using blacksmith we show that

46
00:01:44,159 --> 00:01:47,520
the trr mitigations on all pc ddr4

47
00:01:47,520 --> 00:01:50,079
devices and also lpddr4x devices are

48
00:01:50,079 --> 00:01:52,479
broken

49
00:01:52,960 --> 00:01:54,880
so before starting

50
00:01:54,880 --> 00:01:57,680
about uh talking about blacksmith let me

51
00:01:57,680 --> 00:01:59,759
quickly give you a brief background on

52
00:01:59,759 --> 00:02:01,200
drum

53
00:02:01,200 --> 00:02:04,079
so i guess everybody of you knows dram

54
00:02:04,079 --> 00:02:06,240
dynamic random access memory that is

55
00:02:06,240 --> 00:02:07,840
today widely used in many different

56
00:02:07,840 --> 00:02:09,840
devices for example servers and also

57
00:02:09,840 --> 00:02:13,120
notebooks smartphones smart watches

58
00:02:13,120 --> 00:02:15,599
and here you can see a pc dim equipped

59
00:02:15,599 --> 00:02:19,200
with eight ddr4 drum chips

60
00:02:19,200 --> 00:02:21,360
and each of these chips contains

61
00:02:21,360 --> 00:02:23,520
multiple dram banks

62
00:02:23,520 --> 00:02:25,120
and these banks are organized in a

63
00:02:25,120 --> 00:02:26,959
matrix-like structure

64
00:02:26,959 --> 00:02:31,040
consisting of rows and columns

65
00:02:31,040 --> 00:02:31,920
and

66
00:02:31,920 --> 00:02:34,640
each dram cell consists of an axis an

67
00:02:34,640 --> 00:02:36,480
access transistor and a capacitor and

68
00:02:36,480 --> 00:02:38,720
holds a single bit

69
00:02:38,720 --> 00:02:41,120
and due to the dynamic nature of dram it

70
00:02:41,120 --> 00:02:42,480
is required

71
00:02:42,480 --> 00:02:43,599
that

72
00:02:43,599 --> 00:02:45,360
you refresh these cells because the

73
00:02:45,360 --> 00:02:47,200
capacitors leak charge and then they

74
00:02:47,200 --> 00:02:50,480
forget the data they stored

75
00:02:50,480 --> 00:02:52,239
and hence it is necessary to refresh

76
00:02:52,239 --> 00:02:53,440
these rows

77
00:02:53,440 --> 00:02:55,360
for example each row every 64

78
00:02:55,360 --> 00:02:58,480
milliseconds in ddr4

79
00:02:58,480 --> 00:03:00,480
and to get an idea how d how a row

80
00:03:00,480 --> 00:03:02,239
hammer works you have to know how dram

81
00:03:02,239 --> 00:03:04,800
works and for that let me show you

82
00:03:04,800 --> 00:03:07,280
how a write operation works on a dram

83
00:03:07,280 --> 00:03:08,720
device

84
00:03:08,720 --> 00:03:10,480
so reading and writing always happens

85
00:03:10,480 --> 00:03:11,599
row wise

86
00:03:11,599 --> 00:03:13,120
so for example if you want to read the

87
00:03:13,120 --> 00:03:14,000
row

88
00:03:14,000 --> 00:03:16,319
in the top so the green one here

89
00:03:16,319 --> 00:03:18,400
so what you would first do is to send

90
00:03:18,400 --> 00:03:21,200
the dram activate command

91
00:03:21,200 --> 00:03:23,040
and then this row gets loaded into the

92
00:03:23,040 --> 00:03:24,400
row buffer

93
00:03:24,400 --> 00:03:27,040
so this happens usually transparently

94
00:03:27,040 --> 00:03:28,879
in the cpu there's a memory controller

95
00:03:28,879 --> 00:03:30,239
that basically

96
00:03:30,239 --> 00:03:31,680
translates your

97
00:03:31,680 --> 00:03:33,519
access request so if you access memory

98
00:03:33,519 --> 00:03:36,959
in in a program into these dram commands

99
00:03:36,959 --> 00:03:38,959
and after this row has been activated

100
00:03:38,959 --> 00:03:41,040
and is loaded into the row buffer

101
00:03:41,040 --> 00:03:42,640
you can for example do a write and

102
00:03:42,640 --> 00:03:45,200
modify the values

103
00:03:45,200 --> 00:03:47,519
and after that before you access another

104
00:03:47,519 --> 00:03:49,599
row you have to issue a pre-charge

105
00:03:49,599 --> 00:03:51,840
command that writes back the modified

106
00:03:51,840 --> 00:03:53,680
data

107
00:03:53,680 --> 00:03:55,360
and let's see how this mechanism can be

108
00:03:55,360 --> 00:03:58,720
exploited by row hammer

109
00:03:58,720 --> 00:04:01,360
so the rohana effect has been discovered

110
00:04:01,360 --> 00:04:03,840
in 2012 for the first time

111
00:04:03,840 --> 00:04:05,920
and the idea basically is

112
00:04:05,920 --> 00:04:07,760
that we exploit the leaking leaking

113
00:04:07,760 --> 00:04:10,560
charges of the capacitors

114
00:04:10,560 --> 00:04:12,640
so what we basically have to do is

115
00:04:12,640 --> 00:04:13,920
activate

116
00:04:13,920 --> 00:04:15,280
two rows

117
00:04:15,280 --> 00:04:18,160
so here the red one and the other one

118
00:04:18,160 --> 00:04:20,880
with one victim row in between so these

119
00:04:20,880 --> 00:04:23,040
two reds are called aggressor rows and

120
00:04:23,040 --> 00:04:24,720
the one the victim row

121
00:04:24,720 --> 00:04:27,759
and if we do these excesses repeatedly

122
00:04:27,759 --> 00:04:30,080
many times over and over again

123
00:04:30,080 --> 00:04:32,479
then these aggressor rows will leak

124
00:04:32,479 --> 00:04:34,800
charges which will impact the data that

125
00:04:34,800 --> 00:04:36,240
is stored in the row in between the

126
00:04:36,240 --> 00:04:37,520
victim row

127
00:04:37,520 --> 00:04:39,280
and at some point if you repeat this

128
00:04:39,280 --> 00:04:41,440
often enough you will see bit flips in

129
00:04:41,440 --> 00:04:44,240
the row in between

130
00:04:45,360 --> 00:04:47,199
and there have been many different rohan

131
00:04:47,199 --> 00:04:49,600
access patterns proposed

132
00:04:49,600 --> 00:04:51,680
by academia in the past so this one here

133
00:04:51,680 --> 00:04:53,759
is called double-sided because you have

134
00:04:53,759 --> 00:04:55,440
two aggressor rows with one victim row

135
00:04:55,440 --> 00:04:57,840
in between

136
00:04:59,680 --> 00:05:01,120
and there are other patterns that i will

137
00:05:01,120 --> 00:05:03,680
discuss later

138
00:05:03,680 --> 00:05:05,919
so now you may ask okay this sounds very

139
00:05:05,919 --> 00:05:07,840
theoretically but what can we actually

140
00:05:07,840 --> 00:05:10,000
do with it and there has been a plethora

141
00:05:10,000 --> 00:05:11,520
of work

142
00:05:11,520 --> 00:05:12,880
that showed that these attacks are

143
00:05:12,880 --> 00:05:15,280
really practical so for example you can

144
00:05:15,280 --> 00:05:17,600
exploit

145
00:05:17,600 --> 00:05:19,759
across vms

146
00:05:19,759 --> 00:05:21,199
applications

147
00:05:21,199 --> 00:05:22,840
that run on the same

148
00:05:22,840 --> 00:05:26,240
host it has been shown that

149
00:05:26,240 --> 00:05:28,240
you can also run raw hammer on

150
00:05:28,240 --> 00:05:30,560
smartphones so smartphones have usually

151
00:05:30,560 --> 00:05:34,240
lpddr memory

152
00:05:35,120 --> 00:05:38,160
even over the network so there is a rdma

153
00:05:38,160 --> 00:05:40,960
basically that allows to access

154
00:05:40,960 --> 00:05:43,039
memory directly via the

155
00:05:43,039 --> 00:05:44,479
network card

156
00:05:44,479 --> 00:05:46,479
and you can use um

157
00:05:46,479 --> 00:05:48,160
rdma to

158
00:05:48,160 --> 00:05:50,720
row hammer the drum device

159
00:05:50,720 --> 00:05:52,080
assuming that your network is fast

160
00:05:52,080 --> 00:05:54,000
enough

161
00:05:54,000 --> 00:05:56,000
then it has been shown that also rohmer

162
00:05:56,000 --> 00:05:59,039
works on devices that employ ecc so ecc

163
00:05:59,039 --> 00:06:03,039
memory is usually used in servers

164
00:06:03,039 --> 00:06:05,360
and also over the network

165
00:06:05,360 --> 00:06:09,199
over in the browser via javascript

166
00:06:09,680 --> 00:06:11,440
and now the reset question

167
00:06:11,440 --> 00:06:14,000
um that motivates our research

168
00:06:14,000 --> 00:06:15,360
are basically the claim from drama

169
00:06:15,360 --> 00:06:18,000
manufacturers that promise that the ddr4

170
00:06:18,000 --> 00:06:20,720
devices are hammer-free

171
00:06:20,720 --> 00:06:24,160
so there was a work before in 2020

172
00:06:24,160 --> 00:06:27,199
called trespass that investigated these

173
00:06:27,199 --> 00:06:29,840
mitigation mechanisms on the drum device

174
00:06:29,840 --> 00:06:31,600
called target draw refresh for the first

175
00:06:31,600 --> 00:06:32,560
time

176
00:06:32,560 --> 00:06:35,440
and they found out that trr so this

177
00:06:35,440 --> 00:06:37,280
mitigation mechanism

178
00:06:37,280 --> 00:06:38,240
um

179
00:06:38,240 --> 00:06:39,840
is like an umbrella term for different

180
00:06:39,840 --> 00:06:42,639
mitigations so different manufacturers

181
00:06:42,639 --> 00:06:44,720
deploy different mitigations

182
00:06:44,720 --> 00:06:46,479
and they could show that if you modify

183
00:06:46,479 --> 00:06:48,880
the existing patterns a bit then you can

184
00:06:48,880 --> 00:06:50,960
still trigger on around 30 percent of

185
00:06:50,960 --> 00:06:54,479
the ddr4 devices rohmer bit flips

186
00:06:54,479 --> 00:06:56,880
and for that they used so called n-sided

187
00:06:56,880 --> 00:06:58,720
patterns which is a generalization of

188
00:06:58,720 --> 00:07:00,720
the double-sided pattern i will show an

189
00:07:00,720 --> 00:07:03,120
example later

190
00:07:03,120 --> 00:07:04,560
and given this work

191
00:07:04,560 --> 00:07:06,160
we asked ourselves

192
00:07:06,160 --> 00:07:09,120
if the majority of today's ddr4 devices

193
00:07:09,120 --> 00:07:11,520
are indeed safe against roehammer or if

194
00:07:11,520 --> 00:07:13,919
we can build better patterns to bypass

195
00:07:13,919 --> 00:07:14,840
these

196
00:07:14,840 --> 00:07:18,400
mitigations and then given that also if

197
00:07:18,400 --> 00:07:19,919
these currently deployed mitigations

198
00:07:19,919 --> 00:07:21,280
have weak spots

199
00:07:21,280 --> 00:07:24,239
that we could exploit

200
00:07:24,800 --> 00:07:26,639
so in the typical approach used by

201
00:07:26,639 --> 00:07:29,120
previous work is reverse engineering

202
00:07:29,120 --> 00:07:30,319
to understand how the deployed

203
00:07:30,319 --> 00:07:32,479
mitigation works to mount

204
00:07:32,479 --> 00:07:34,000
a row hammer attack

205
00:07:34,000 --> 00:07:36,160
and the problem with this approach is

206
00:07:36,160 --> 00:07:38,240
that it's very time intensive so usually

207
00:07:38,240 --> 00:07:40,800
you design experiments to figure out

208
00:07:40,800 --> 00:07:42,960
certain properties of the mitigation

209
00:07:42,960 --> 00:07:45,680
and this makes this approach

210
00:07:45,680 --> 00:07:47,840
not scalable if you want to look at many

211
00:07:47,840 --> 00:07:50,000
different devices

212
00:07:50,000 --> 00:07:51,680
and also it provides only limited

213
00:07:51,680 --> 00:07:52,800
insights

214
00:07:52,800 --> 00:07:55,120
that make may not be transferable among

215
00:07:55,120 --> 00:07:57,520
devices because we have seen in existing

216
00:07:57,520 --> 00:07:58,560
work

217
00:07:58,560 --> 00:08:00,560
that the manufacturers might change

218
00:08:00,560 --> 00:08:02,400
their mitigation

219
00:08:02,400 --> 00:08:04,560
for example across different devices or

220
00:08:04,560 --> 00:08:07,120
device generations

221
00:08:07,120 --> 00:08:08,800
so the insight that you gain is quite

222
00:08:08,800 --> 00:08:10,879
limited

223
00:08:10,879 --> 00:08:12,639
and to give you a better understanding

224
00:08:12,639 --> 00:08:14,720
about roehammer

225
00:08:14,720 --> 00:08:16,560
um let me illustrate a problem from an

226
00:08:16,560 --> 00:08:18,720
attacker's perspective

227
00:08:18,720 --> 00:08:21,280
so i mentioned before that drum is

228
00:08:21,280 --> 00:08:22,879
dynamic right that you have to refresh

229
00:08:22,879 --> 00:08:24,720
these rows in order not to lose the

230
00:08:24,720 --> 00:08:26,800
information

231
00:08:26,800 --> 00:08:28,720
and it is a synchronous protocol which

232
00:08:28,720 --> 00:08:31,120
means that all commands must adhere to

233
00:08:31,120 --> 00:08:33,919
specific timing requirements

234
00:08:33,919 --> 00:08:35,839
and each cell in a dram device must

235
00:08:35,839 --> 00:08:37,919
retain the information for 64

236
00:08:37,919 --> 00:08:40,240
milliseconds so you can see a timeline

237
00:08:40,240 --> 00:08:42,479
that represents this refresh window of

238
00:08:42,479 --> 00:08:44,720
64 milliseconds

239
00:08:44,720 --> 00:08:45,519
and

240
00:08:45,519 --> 00:08:48,320
to refresh each of the dram rows

241
00:08:48,320 --> 00:08:51,040
in that 64 milliseconds

242
00:08:51,040 --> 00:08:53,519
you must send around 8k

243
00:08:53,519 --> 00:08:55,440
refresh commands so each of these

244
00:08:55,440 --> 00:08:57,120
refresh commands

245
00:08:57,120 --> 00:09:00,000
refreshes some of these rows in the dram

246
00:09:00,000 --> 00:09:02,000
device

247
00:09:02,000 --> 00:09:06,240
and we can issue around 166 activations

248
00:09:06,240 --> 00:09:08,800
so what i showed before when you load a

249
00:09:08,800 --> 00:09:11,279
drum row into a row buffer

250
00:09:11,279 --> 00:09:14,560
in between of two um refresh commands

251
00:09:14,560 --> 00:09:16,160
so this is basically the space that the

252
00:09:16,160 --> 00:09:18,240
attacker has right because after these

253
00:09:18,240 --> 00:09:20,720
64 milliseconds the row will be

254
00:09:20,720 --> 00:09:22,399
refreshed so

255
00:09:22,399 --> 00:09:24,240
if you are not able to trigger the bit

256
00:09:24,240 --> 00:09:26,480
flip within this period

257
00:09:26,480 --> 00:09:29,200
and then it's basically over

258
00:09:29,200 --> 00:09:30,959
so from the attacker's perspective we

259
00:09:30,959 --> 00:09:34,959
have basically 1.3 million activations

260
00:09:34,959 --> 00:09:36,640
and depending on how vulnerable the

261
00:09:36,640 --> 00:09:39,680
device is we need around 10k

262
00:09:39,680 --> 00:09:41,160
and

263
00:09:41,160 --> 00:09:44,160
147.5 k activations to a row to trigger

264
00:09:44,160 --> 00:09:46,160
a bit flip that's what i showed before

265
00:09:46,160 --> 00:09:48,240
that you have to repeat hammering many

266
00:09:48,240 --> 00:09:51,040
times so that enough of these charges of

267
00:09:51,040 --> 00:09:52,640
this leaking charges accumulate to

268
00:09:52,640 --> 00:09:55,439
trigger a bit flip

269
00:09:56,000 --> 00:09:58,720
so and now what basically existing

270
00:09:58,720 --> 00:10:00,480
patterns do

271
00:10:00,480 --> 00:10:02,160
is they craft a pattern for example a

272
00:10:02,160 --> 00:10:04,880
double-sided pattern and then

273
00:10:04,880 --> 00:10:06,560
they repeat hammering this pattern over

274
00:10:06,560 --> 00:10:09,040
and over again

275
00:10:09,040 --> 00:10:11,279
and what we asked is basically if there

276
00:10:11,279 --> 00:10:13,279
isn't a way to

277
00:10:13,279 --> 00:10:14,800
to graph patterns in a more effective

278
00:10:14,800 --> 00:10:17,360
way to bypass the mitigations

279
00:10:17,360 --> 00:10:19,680
and now let's switch over to the

280
00:10:19,680 --> 00:10:21,920
defender's perspective to give an idea

281
00:10:21,920 --> 00:10:23,920
how these devices usually protect

282
00:10:23,920 --> 00:10:26,399
against rawhammer so here you can see

283
00:10:26,399 --> 00:10:29,120
how a deterministic mitigation works

284
00:10:29,120 --> 00:10:31,680
so the idea is that we have a component

285
00:10:31,680 --> 00:10:33,680
called sampler

286
00:10:33,680 --> 00:10:36,160
that basically

287
00:10:36,160 --> 00:10:38,079
samples some of these excesses of these

288
00:10:38,079 --> 00:10:40,000
activate commands

289
00:10:40,000 --> 00:10:42,240
and then has a kind of counter that

290
00:10:42,240 --> 00:10:44,320
keeps track of how often these different

291
00:10:44,320 --> 00:10:45,839
rows have been

292
00:10:45,839 --> 00:10:47,440
activated

293
00:10:47,440 --> 00:10:49,680
and if the counter

294
00:10:49,680 --> 00:10:52,480
reaches a certain threshold

295
00:10:52,480 --> 00:10:54,800
then you have to

296
00:10:54,800 --> 00:10:56,160
preventively

297
00:10:56,160 --> 00:10:58,720
refresh the row right before it can

298
00:10:58,720 --> 00:11:00,720
trigger a bit flip

299
00:11:00,720 --> 00:11:01,680
and

300
00:11:01,680 --> 00:11:03,519
i mentioned before that this theorem is

301
00:11:03,519 --> 00:11:05,839
a synchronous protocol this means that

302
00:11:05,839 --> 00:11:09,360
we can only send a refresh

303
00:11:09,360 --> 00:11:11,760
at certain points in time

304
00:11:11,760 --> 00:11:13,600
so at the refresh time

305
00:11:13,600 --> 00:11:16,079
then there is an inhibitor component

306
00:11:16,079 --> 00:11:18,240
that basically looks up into the table

307
00:11:18,240 --> 00:11:20,880
if any of the rows reach this threshold

308
00:11:20,880 --> 00:11:23,360
and then sends a trr so refreshes this

309
00:11:23,360 --> 00:11:27,279
row before it can trigger any bit flips

310
00:11:27,440 --> 00:11:29,279
and this problem um

311
00:11:29,279 --> 00:11:31,279
yeah can be translated to the frequent

312
00:11:31,279 --> 00:11:33,120
item count problem which is well studied

313
00:11:33,120 --> 00:11:34,640
in literature

314
00:11:34,640 --> 00:11:36,480
but the problem is that it's very hard

315
00:11:36,480 --> 00:11:38,800
to solve this in dram because there are

316
00:11:38,800 --> 00:11:41,200
many constraints for example the area is

317
00:11:41,200 --> 00:11:42,480
quite limited

318
00:11:42,480 --> 00:11:44,959
in a dram device in a dram chip

319
00:11:44,959 --> 00:11:46,800
then there are these timing constraints

320
00:11:46,800 --> 00:11:48,560
that i mentioned before so you cannot

321
00:11:48,560 --> 00:11:50,800
send these additional refreshes these

322
00:11:50,800 --> 00:11:54,839
trrs at any time but only at refresh

323
00:11:54,839 --> 00:11:58,079
times and also of course costs like

324
00:11:58,079 --> 00:11:59,760
performance for example or energy

325
00:11:59,760 --> 00:12:03,760
consumption must be taken into account

326
00:12:05,920 --> 00:12:07,120
so and

327
00:12:07,120 --> 00:12:09,200
yeah now back to the question how we can

328
00:12:09,200 --> 00:12:11,519
craft more effective patterns

329
00:12:11,519 --> 00:12:14,959
so we looked into existing patterns

330
00:12:14,959 --> 00:12:16,639
so here are three very prominent

331
00:12:16,639 --> 00:12:18,720
examples so we have the single sided

332
00:12:18,720 --> 00:12:21,680
pattern where we hammer here row x

333
00:12:21,680 --> 00:12:24,000
and then might see bit flips in one of

334
00:12:24,000 --> 00:12:25,279
those

335
00:12:25,279 --> 00:12:27,120
we need another row

336
00:12:27,120 --> 00:12:29,040
somewhere apart to

337
00:12:29,040 --> 00:12:32,880
evict this row from the row buffer right

338
00:12:32,880 --> 00:12:34,880
and then we have to double sided as i

339
00:12:34,880 --> 00:12:37,040
explained before and we have for example

340
00:12:37,040 --> 00:12:39,040
a four-sided you can see this is

341
00:12:39,040 --> 00:12:40,800
basically just an extension of the

342
00:12:40,800 --> 00:12:42,720
double-sided pattern

343
00:12:42,720 --> 00:12:45,200
and four-sided is

344
00:12:45,200 --> 00:12:47,440
an example for an n-sided pattern with n

345
00:12:47,440 --> 00:12:50,000
equals four

346
00:12:50,000 --> 00:12:52,880
and we made the observation um that in

347
00:12:52,880 --> 00:12:54,800
these patterns all the aggressors are

348
00:12:54,800 --> 00:12:56,959
hammered uniformly so the same number of

349
00:12:56,959 --> 00:12:57,920
times

350
00:12:57,920 --> 00:13:00,399
and this is a very simple case um for

351
00:13:00,399 --> 00:13:02,959
the mitigation right because if it knows

352
00:13:02,959 --> 00:13:04,480
uh if it can

353
00:13:04,480 --> 00:13:06,320
track one of those then it already knows

354
00:13:06,320 --> 00:13:08,720
the hammer count of the other ones

355
00:13:08,720 --> 00:13:10,880
so this was our first insight and we

356
00:13:10,880 --> 00:13:12,160
wanted to see

357
00:13:12,160 --> 00:13:14,639
how effective it is if we use

358
00:13:14,639 --> 00:13:16,639
non-uniform access patterns to bypass

359
00:13:16,639 --> 00:13:18,399
the mitigations

360
00:13:18,399 --> 00:13:20,160
and for that we constructed two

361
00:13:20,160 --> 00:13:21,760
experiments

362
00:13:21,760 --> 00:13:23,600
so in the first experiment

363
00:13:23,600 --> 00:13:25,760
what we basically do is we take an

364
00:13:25,760 --> 00:13:28,480
n-sided pattern for example a six-sided

365
00:13:28,480 --> 00:13:30,079
and then at random

366
00:13:30,079 --> 00:13:32,480
repetitions of the pattern we just

367
00:13:32,480 --> 00:13:35,200
access another double-sided aggressor

368
00:13:35,200 --> 00:13:37,200
pair so two other rows

369
00:13:37,200 --> 00:13:39,600
and then basically these two other rows

370
00:13:39,600 --> 00:13:41,680
will have a non-uniform hammer count at

371
00:13:41,680 --> 00:13:43,440
the end

372
00:13:43,440 --> 00:13:45,279
and in the other experiment we just have

373
00:13:45,279 --> 00:13:48,240
a random pattern so random rows and then

374
00:13:48,240 --> 00:13:49,279
at some

375
00:13:49,279 --> 00:13:52,079
randomly picked

376
00:13:52,480 --> 00:13:54,880
locations of where we repeat the pattern

377
00:13:54,880 --> 00:13:56,959
we just access a double-sided aggressor

378
00:13:56,959 --> 00:13:59,199
pair

379
00:13:59,440 --> 00:14:01,600
and to evaluate how good this approach

380
00:14:01,600 --> 00:14:03,040
works

381
00:14:03,040 --> 00:14:04,480
we bought some

382
00:14:04,480 --> 00:14:07,519
ddr4 devices so 40 in total

383
00:14:07,519 --> 00:14:08,959
we tried

384
00:14:08,959 --> 00:14:11,440
to have a very diverse set of devices

385
00:14:11,440 --> 00:14:13,120
from different manufacturing dates with

386
00:14:13,120 --> 00:14:16,399
different frequency sizes and also ranks

387
00:14:16,399 --> 00:14:18,160
and from the three major d-ram

388
00:14:18,160 --> 00:14:21,279
manufacturers samsung hynix and micron

389
00:14:21,279 --> 00:14:23,279
we also had four devices where we

390
00:14:23,279 --> 00:14:26,480
couldn't identify the chip manufacturer

391
00:14:26,480 --> 00:14:28,639
but the device is from from kingston

392
00:14:28,639 --> 00:14:30,959
we're from kingston

393
00:14:30,959 --> 00:14:32,639
and here you can see uh how this looks

394
00:14:32,639 --> 00:14:33,600
like

395
00:14:33,600 --> 00:14:35,519
so we have these very different devices

396
00:14:35,519 --> 00:14:37,680
some of them were yeah like gaming the

397
00:14:37,680 --> 00:14:40,880
gamer drum devices with heat spreaders

398
00:14:40,880 --> 00:14:42,959
and this is our test cluster where we

399
00:14:42,959 --> 00:14:44,800
ever evaluated

400
00:14:44,800 --> 00:14:47,440
our experiments so we used a very

401
00:14:47,440 --> 00:14:49,120
um

402
00:14:49,120 --> 00:14:50,800
common platform

403
00:14:50,800 --> 00:14:55,440
normal pc platform with intel i7 8700k

404
00:14:55,440 --> 00:14:56,839
running on

405
00:14:56,839 --> 00:14:59,360
ubuntu and here you can see the results

406
00:14:59,360 --> 00:15:01,839
of our first experiment

407
00:15:01,839 --> 00:15:04,160
so here we only report the devices where

408
00:15:04,160 --> 00:15:06,480
we could trigger bit flips at all

409
00:15:06,480 --> 00:15:08,560
so in the first column you can see

410
00:15:08,560 --> 00:15:09,839
the results

411
00:15:09,839 --> 00:15:11,680
for trespass for for the existing

412
00:15:11,680 --> 00:15:14,320
patterns that were proposed by

413
00:15:14,320 --> 00:15:16,160
literature before

414
00:15:16,160 --> 00:15:17,279
in the middle

415
00:15:17,279 --> 00:15:19,360
um these encited with a bit of

416
00:15:19,360 --> 00:15:22,320
non-uniformity and in the last column

417
00:15:22,320 --> 00:15:25,279
these fully random patterns

418
00:15:25,279 --> 00:15:26,800
and what we could observe here in this

419
00:15:26,800 --> 00:15:28,000
experiment is

420
00:15:28,000 --> 00:15:29,839
that on some devices it's really

421
00:15:29,839 --> 00:15:31,759
important to have this non-uniformity to

422
00:15:31,759 --> 00:15:33,680
bypass the mitigation

423
00:15:33,680 --> 00:15:35,440
but what we could also see on the other

424
00:15:35,440 --> 00:15:36,720
side

425
00:15:36,720 --> 00:15:37,680
um

426
00:15:37,680 --> 00:15:39,920
on some devices only uniform pattern

427
00:15:39,920 --> 00:15:42,240
worked

428
00:15:43,600 --> 00:15:45,279
so this was our first observation that

429
00:15:45,279 --> 00:15:47,279
non-uniformity leads

430
00:15:47,279 --> 00:15:49,360
to bit flips on some dimms where

431
00:15:49,360 --> 00:15:51,120
previous n-sided patterns failed to

432
00:15:51,120 --> 00:15:53,360
trigger any bit flips

433
00:15:53,360 --> 00:15:55,600
and starting from this first observation

434
00:15:55,600 --> 00:15:57,519
we wanted to reduce the search space

435
00:15:57,519 --> 00:15:59,680
further right so now we have one

436
00:15:59,680 --> 00:16:01,920
property basically that allows us to

437
00:16:01,920 --> 00:16:04,079
find more bit flips on some devices but

438
00:16:04,079 --> 00:16:06,880
still the search base is very huge

439
00:16:06,880 --> 00:16:09,839
so we um designed some more experiments

440
00:16:09,839 --> 00:16:11,040
to figure out

441
00:16:11,040 --> 00:16:13,360
what is very important to

442
00:16:13,360 --> 00:16:15,600
um we have to effectively bypass the

443
00:16:15,600 --> 00:16:17,519
mitigations

444
00:16:17,519 --> 00:16:19,680
and in the first experiment we asked

445
00:16:19,680 --> 00:16:21,600
ourselves when should we hammer an

446
00:16:21,600 --> 00:16:23,040
aggressor

447
00:16:23,040 --> 00:16:25,600
so here you can see

448
00:16:25,600 --> 00:16:26,800
a pattern

449
00:16:26,800 --> 00:16:28,160
with two rows

450
00:16:28,160 --> 00:16:30,560
and here some other random rows so they

451
00:16:30,560 --> 00:16:32,720
do not matter here and the idea is

452
00:16:32,720 --> 00:16:34,880
basically we hammer these two then we

453
00:16:34,880 --> 00:16:37,120
have some other axises until we observe

454
00:16:37,120 --> 00:16:39,440
a refresh so you can observe this by a

455
00:16:39,440 --> 00:16:41,839
by a high memory latency

456
00:16:41,839 --> 00:16:44,480
and then we again repeat hammering

457
00:16:44,480 --> 00:16:46,720
um these two and the other ones to

458
00:16:46,720 --> 00:16:48,959
random ones and we repeat this for like

459
00:16:48,959 --> 00:16:50,639
one million activations and then we

460
00:16:50,639 --> 00:16:52,160
check if we see

461
00:16:52,160 --> 00:16:54,560
any bit flip

462
00:16:54,560 --> 00:16:56,800
and then we repeat the same experiment

463
00:16:56,800 --> 00:16:59,360
but shifted by one so we have one axis

464
00:16:59,360 --> 00:17:01,279
before then our double sided aggressor

465
00:17:01,279 --> 00:17:02,079
pair

466
00:17:02,079 --> 00:17:03,519
and then

467
00:17:03,519 --> 00:17:06,720
until the next refresh random accesses

468
00:17:06,720 --> 00:17:08,319
to rows

469
00:17:08,319 --> 00:17:10,000
and we do the systematically for all

470
00:17:10,000 --> 00:17:11,199
different

471
00:17:11,199 --> 00:17:12,559
possible

472
00:17:12,559 --> 00:17:14,480
offsets in the pattern

473
00:17:14,480 --> 00:17:16,240
and then we check for bit flips and what

474
00:17:16,240 --> 00:17:18,480
we could see in the experiment

475
00:17:18,480 --> 00:17:20,480
is that only if we hammer our

476
00:17:20,480 --> 00:17:22,400
double-sided aggressor pair at very

477
00:17:22,400 --> 00:17:24,240
specific

478
00:17:24,240 --> 00:17:27,039
times we could trigger bit flips

479
00:17:27,039 --> 00:17:28,799
and the reason for that is

480
00:17:28,799 --> 00:17:31,440
that the sampler might not be active all

481
00:17:31,440 --> 00:17:33,760
the time so might only sample specific

482
00:17:33,760 --> 00:17:36,240
accesses and as here is already the next

483
00:17:36,240 --> 00:17:37,600
refresh

484
00:17:37,600 --> 00:17:39,520
it might be that

485
00:17:39,520 --> 00:17:41,520
the assembler is not active here anymore

486
00:17:41,520 --> 00:17:43,600
cannot capture these accesses

487
00:17:43,600 --> 00:17:45,600
so our next observation is basically

488
00:17:45,600 --> 00:17:46,559
that

489
00:17:46,559 --> 00:17:48,320
it's very important when

490
00:17:48,320 --> 00:17:50,960
we access the aggressors in a pattern

491
00:17:50,960 --> 00:17:52,640
and this allows us to bypass the

492
00:17:52,640 --> 00:17:55,039
mitigations more effectively

493
00:17:55,039 --> 00:17:57,120
and here we can see

494
00:17:57,120 --> 00:17:59,440
some data from the experiment

495
00:17:59,440 --> 00:18:02,320
from a real device from a samsung dim

496
00:18:02,320 --> 00:18:04,080
and you can see so if this is the

497
00:18:04,080 --> 00:18:06,400
pattern length 100 excesses

498
00:18:06,400 --> 00:18:08,640
then only if we hammer at the end we can

499
00:18:08,640 --> 00:18:11,039
trigger bit flips and also not at every

500
00:18:11,039 --> 00:18:13,039
offset right so there are some points

501
00:18:13,039 --> 00:18:14,880
when we hammer there then we also don't

502
00:18:14,880 --> 00:18:16,799
see bit flips

503
00:18:16,799 --> 00:18:19,039
and this suggests that the sample is

504
00:18:19,039 --> 00:18:20,240
active

505
00:18:20,240 --> 00:18:22,000
at these points and also here at the

506
00:18:22,000 --> 00:18:24,400
beginning

507
00:18:24,799 --> 00:18:26,320
based on that

508
00:18:26,320 --> 00:18:27,919
we constructed the next experiment we

509
00:18:27,919 --> 00:18:29,760
wanted to know for how long we should

510
00:18:29,760 --> 00:18:31,600
have an aggressor

511
00:18:31,600 --> 00:18:34,160
so as i mentioned before this raw hammer

512
00:18:34,160 --> 00:18:35,679
phenom phenomenon

513
00:18:35,679 --> 00:18:37,760
is based on leaking charges so if you

514
00:18:37,760 --> 00:18:39,840
hammer a longer time you will leak more

515
00:18:39,840 --> 00:18:43,280
charges and you will see more bit flips

516
00:18:43,280 --> 00:18:45,440
but at some point if you

517
00:18:45,440 --> 00:18:47,919
hammer too much it might be that you get

518
00:18:47,919 --> 00:18:49,760
caught by the mitigation and that's why

519
00:18:49,760 --> 00:18:51,520
we wanted to know for how long should we

520
00:18:51,520 --> 00:18:53,120
hammer an aggressor

521
00:18:53,120 --> 00:18:54,960
so we start again with the same

522
00:18:54,960 --> 00:18:56,880
experiment like before

523
00:18:56,880 --> 00:18:58,480
where we have our double-sided aggressor

524
00:18:58,480 --> 00:19:01,760
pair and then some random accesses

525
00:19:01,760 --> 00:19:04,400
but now additionally to just hammering

526
00:19:04,400 --> 00:19:06,320
the aggressor pair once

527
00:19:06,320 --> 00:19:09,039
we also try different intensities so we

528
00:19:09,039 --> 00:19:11,520
repeat for example hammering two times

529
00:19:11,520 --> 00:19:13,679
or three times and so on up to the whole

530
00:19:13,679 --> 00:19:16,640
refresh interval and we try this

531
00:19:16,640 --> 00:19:20,160
for the different offsets in the pattern

532
00:19:20,160 --> 00:19:21,520
and then we again check if we could

533
00:19:21,520 --> 00:19:23,039
observe bit flips

534
00:19:23,039 --> 00:19:24,720
and what we found is

535
00:19:24,720 --> 00:19:28,720
that at some for some um

536
00:19:29,120 --> 00:19:30,880
yeah for some point you can up to some

537
00:19:30,880 --> 00:19:32,960
point you can increase the intensity and

538
00:19:32,960 --> 00:19:34,799
see more bit flips

539
00:19:34,799 --> 00:19:37,200
but if you get over this point then you

540
00:19:37,200 --> 00:19:38,559
don't see bit flips anymore which

541
00:19:38,559 --> 00:19:40,320
suggests again that the mitigation

542
00:19:40,320 --> 00:19:42,160
caught these excesses and then refreshed

543
00:19:42,160 --> 00:19:44,880
these rows before any bit flips could be

544
00:19:44,880 --> 00:19:46,400
induced

545
00:19:46,400 --> 00:19:47,520
and this is basically our next

546
00:19:47,520 --> 00:19:49,520
observation that up to a sweet spot we

547
00:19:49,520 --> 00:19:51,840
can increase the hammering intensity to

548
00:19:51,840 --> 00:19:54,480
see more bit flips

549
00:19:54,480 --> 00:19:56,080
and then after that the number of bit

550
00:19:56,080 --> 00:19:58,160
flips drops

551
00:19:58,160 --> 00:20:00,400
and here again we have some real data so

552
00:20:00,400 --> 00:20:01,919
here we can see

553
00:20:01,919 --> 00:20:04,400
um the number of bit flips and the

554
00:20:04,400 --> 00:20:06,559
aggressor offset so where we hammer in

555
00:20:06,559 --> 00:20:08,080
the pattern

556
00:20:08,080 --> 00:20:10,000
for an intensity of one so we only

557
00:20:10,000 --> 00:20:13,120
hammered the aggressor once

558
00:20:13,760 --> 00:20:16,400
and here for an intensity of two and we

559
00:20:16,400 --> 00:20:19,520
did this for different intensities

560
00:20:19,520 --> 00:20:21,440
and one interesting point is for example

561
00:20:21,440 --> 00:20:24,240
this year here you can see

562
00:20:24,240 --> 00:20:26,320
that if you hammer two times you get way

563
00:20:26,320 --> 00:20:28,159
more bit flips than if you hammer four

564
00:20:28,159 --> 00:20:30,799
times so this indicates that at some of

565
00:20:30,799 --> 00:20:32,720
these repetitions you get called by the

566
00:20:32,720 --> 00:20:35,679
mitigation

567
00:20:35,679 --> 00:20:37,200
and then the last experiment that we

568
00:20:37,200 --> 00:20:38,960
conducted is

569
00:20:38,960 --> 00:20:40,480
if our pattern should be longer than one

570
00:20:40,480 --> 00:20:42,159
refresh interval

571
00:20:42,159 --> 00:20:44,400
so previous patterns were quite short

572
00:20:44,400 --> 00:20:46,640
for example double-sided or four-sided

573
00:20:46,640 --> 00:20:49,600
six-sided and we wanted to know if it

574
00:20:49,600 --> 00:20:52,159
makes sense from perspective from the

575
00:20:52,159 --> 00:20:54,720
attacker to have patents that are longer

576
00:20:54,720 --> 00:20:56,480
so what does it mean

577
00:20:56,480 --> 00:20:58,320
so instead of just building a pattern

578
00:20:58,320 --> 00:21:00,720
that is one refresh interval long we

579
00:21:00,720 --> 00:21:02,080
build patterns that are longer for

580
00:21:02,080 --> 00:21:04,880
example two refresh intervals

581
00:21:04,880 --> 00:21:06,799
and we do this by basically just

582
00:21:06,799 --> 00:21:09,200
extending the previous experiment

583
00:21:09,200 --> 00:21:11,280
so instead of just limiting the pattern

584
00:21:11,280 --> 00:21:12,799
length to one

585
00:21:12,799 --> 00:21:16,240
we also make it longer than one and then

586
00:21:16,240 --> 00:21:18,400
you see that there are some patterns

587
00:21:18,400 --> 00:21:20,559
where we hammer for example one refresh

588
00:21:20,559 --> 00:21:22,640
interval a lot but then the other one

589
00:21:22,640 --> 00:21:25,039
nothing

590
00:21:25,200 --> 00:21:26,960
and then we do this the same again with

591
00:21:26,960 --> 00:21:28,960
the shifting of the offset that we start

592
00:21:28,960 --> 00:21:31,120
later and then yeah we repeat the same

593
00:21:31,120 --> 00:21:32,640
basically

594
00:21:32,640 --> 00:21:34,159
and here we could see

595
00:21:34,159 --> 00:21:36,320
that it makes sense to

596
00:21:36,320 --> 00:21:38,080
only hammer in some of the refresh

597
00:21:38,080 --> 00:21:39,200
intervals

598
00:21:39,200 --> 00:21:40,640
that is more effective to bypass the

599
00:21:40,640 --> 00:21:43,640
mitigation

600
00:21:44,080 --> 00:21:46,720
and yeah this is our last observation

601
00:21:46,720 --> 00:21:47,919
that hammering

602
00:21:47,919 --> 00:21:49,520
patterns

603
00:21:49,520 --> 00:21:51,200
hammering with longer patterns longer

604
00:21:51,200 --> 00:21:53,360
than one refresh interval is effective

605
00:21:53,360 --> 00:21:54,960
on some of the devices to bypass the

606
00:21:54,960 --> 00:21:57,440
mitigations

607
00:21:57,440 --> 00:21:59,360
and here again i have some real data so

608
00:21:59,360 --> 00:22:01,440
here you can see um

609
00:22:01,440 --> 00:22:03,039
so this part is basically one refresh

610
00:22:03,039 --> 00:22:04,880
interval and you see only

611
00:22:04,880 --> 00:22:06,960
like very few bit flips but then if you

612
00:22:06,960 --> 00:22:08,880
extend the pattern to two or three

613
00:22:08,880 --> 00:22:11,520
refresh intervals then you see many more

614
00:22:11,520 --> 00:22:14,080
bit flips

615
00:22:14,080 --> 00:22:17,120
and based on these four observations

616
00:22:17,120 --> 00:22:19,360
um we came up with a general model to

617
00:22:19,360 --> 00:22:22,080
describe this new class of patterns

618
00:22:22,080 --> 00:22:24,720
we found out that the four the concept

619
00:22:24,720 --> 00:22:26,960
of frequency phase and amplitude nicely

620
00:22:26,960 --> 00:22:29,520
matched to these properties for example

621
00:22:29,520 --> 00:22:31,919
the phase when we hammer a pattern so at

622
00:22:31,919 --> 00:22:34,400
which location

623
00:22:34,400 --> 00:22:36,240
and then the frequency how often we

624
00:22:36,240 --> 00:22:38,080
repeat hammering and the amplitude how

625
00:22:38,080 --> 00:22:40,880
intense we hammer the aggressors

626
00:22:40,880 --> 00:22:42,400
and now the question is how can we

627
00:22:42,400 --> 00:22:43,679
determine

628
00:22:43,679 --> 00:22:46,000
effective parameter values so because

629
00:22:46,000 --> 00:22:47,440
these

630
00:22:47,440 --> 00:22:49,120
concepts basically

631
00:22:49,120 --> 00:22:50,559
are very dependent on the deployed

632
00:22:50,559 --> 00:22:52,799
mitigation so different devices might

633
00:22:52,799 --> 00:22:54,400
require different amplitude phase and

634
00:22:54,400 --> 00:22:55,600
frequency

635
00:22:55,600 --> 00:22:59,200
um yeah to trigger bit flips

636
00:22:59,200 --> 00:23:00,799
and for the implementation our goals

637
00:23:00,799 --> 00:23:02,720
were to have a solution that is scalable

638
00:23:02,720 --> 00:23:04,000
so we wanted to have like a

639
00:23:04,000 --> 00:23:06,240
plug-and-play solution that allows

640
00:23:06,240 --> 00:23:07,840
large-scale testing on many different

641
00:23:07,840 --> 00:23:09,280
devices

642
00:23:09,280 --> 00:23:11,440
and also something generic that can

643
00:23:11,440 --> 00:23:15,520
cover many different tr implementations

644
00:23:15,760 --> 00:23:17,520
and last but not least also something

645
00:23:17,520 --> 00:23:19,760
that is extensible because it might be

646
00:23:19,760 --> 00:23:22,320
that drum vendors made tiny changes and

647
00:23:22,320 --> 00:23:24,080
we want to have a solution that allows

648
00:23:24,080 --> 00:23:26,159
to really thoroughly test the

649
00:23:26,159 --> 00:23:28,400
mitigations

650
00:23:28,400 --> 00:23:29,840
and for this we built the blacksmith

651
00:23:29,840 --> 00:23:31,440
rowhammer fuzzer

652
00:23:31,440 --> 00:23:33,679
and the basic idea of blacksmith is that

653
00:23:33,679 --> 00:23:35,440
you have these three parameters

654
00:23:35,440 --> 00:23:37,679
frequency phase and amplitude

655
00:23:37,679 --> 00:23:39,440
and

656
00:23:39,440 --> 00:23:41,840
they are defined over ranges that we

657
00:23:41,840 --> 00:23:43,600
determined experimentally

658
00:23:43,600 --> 00:23:45,600
and then we built a pattern

659
00:23:45,600 --> 00:23:47,919
where each of the different aggressor

660
00:23:47,919 --> 00:23:49,840
pairs has a different set of these

661
00:23:49,840 --> 00:23:51,279
values

662
00:23:51,279 --> 00:23:52,880
and combining them into one pattern

663
00:23:52,880 --> 00:23:55,600
allows us basically to brute force these

664
00:23:55,600 --> 00:23:58,320
parameters more effectively

665
00:23:58,320 --> 00:24:00,320
then we hammer the pattern so we execute

666
00:24:00,320 --> 00:24:02,799
it many times over and over again and

667
00:24:02,799 --> 00:24:05,520
then we check in the memory that we have

668
00:24:05,520 --> 00:24:08,240
initialized before if any of the data

669
00:24:08,240 --> 00:24:09,279
changed

670
00:24:09,279 --> 00:24:11,039
and then basically

671
00:24:11,039 --> 00:24:12,720
based on the location where the change

672
00:24:12,720 --> 00:24:14,960
happened we can figure out which of

673
00:24:14,960 --> 00:24:17,039
these different aggressive pairs

674
00:24:17,039 --> 00:24:18,559
triggered a bit flip

675
00:24:18,559 --> 00:24:21,200
and we repeat this um

676
00:24:21,200 --> 00:24:22,720
for a few hours

677
00:24:22,720 --> 00:24:24,880
for 12 hours in total on the device of

678
00:24:24,880 --> 00:24:26,720
our past pool

679
00:24:26,720 --> 00:24:28,159
and then

680
00:24:28,159 --> 00:24:30,559
yeah we get the following data

681
00:24:30,559 --> 00:24:33,520
so we found out um

682
00:24:33,520 --> 00:24:35,600
that all devices are vulnerable with our

683
00:24:35,600 --> 00:24:36,960
approach we could trigger bit flips on

684
00:24:36,960 --> 00:24:39,360
all 40 devices for our test pool

685
00:24:39,360 --> 00:24:41,760
and previous work so trespass only could

686
00:24:41,760 --> 00:24:47,240
trigger on 15 or 40 devices with flips

687
00:24:47,279 --> 00:24:49,440
and we also found out that the devices

688
00:24:49,440 --> 00:24:52,080
are quite vulnerable more than reported

689
00:24:52,080 --> 00:24:54,240
previously so on some devices from

690
00:24:54,240 --> 00:24:57,360
samsung we could trigger 130

691
00:24:57,360 --> 00:24:58,559
36

692
00:24:58,559 --> 00:25:01,440
000 bit flips and this is impact on the

693
00:25:01,440 --> 00:25:03,360
exploitability because more bit flips

694
00:25:03,360 --> 00:25:05,520
means that it's easier to use these bit

695
00:25:05,520 --> 00:25:08,080
flips to exploit the system

696
00:25:08,080 --> 00:25:09,600
we also

697
00:25:09,600 --> 00:25:11,600
analyzed the exploitability with these

698
00:25:11,600 --> 00:25:13,039
new bit flips

699
00:25:13,039 --> 00:25:15,440
and we found out for example

700
00:25:15,440 --> 00:25:17,360
that a pte exploit that has been

701
00:25:17,360 --> 00:25:18,400
proposed

702
00:25:18,400 --> 00:25:20,480
in existing work

703
00:25:20,480 --> 00:25:23,919
works on 30 or 40 devices within three

704
00:25:23,919 --> 00:25:26,720
seconds and two hours and eight minutes

705
00:25:26,720 --> 00:25:28,400
and then there's also a more difficult

706
00:25:28,400 --> 00:25:30,799
pseudo-exploit that basically

707
00:25:30,799 --> 00:25:32,880
targets the pseudo-binary

708
00:25:32,880 --> 00:25:37,440
and this also worked on 15 or 40 devices

709
00:25:37,679 --> 00:25:40,559
and to summarize the pc results

710
00:25:40,559 --> 00:25:43,120
we can say that all of

711
00:25:43,120 --> 00:25:45,200
pc ddr4 devices are vulnerable to

712
00:25:45,200 --> 00:25:46,400
rohamma

713
00:25:46,400 --> 00:25:48,080
and that the dims are even weaker than

714
00:25:48,080 --> 00:25:50,240
reported before

715
00:25:50,240 --> 00:25:51,360
and these new

716
00:25:51,360 --> 00:25:53,279
results indicate

717
00:25:53,279 --> 00:25:55,120
that exploitation is even easier than

718
00:25:55,120 --> 00:25:56,799
assumed before

719
00:25:56,799 --> 00:25:58,480
and we also did some experiments on

720
00:25:58,480 --> 00:26:00,080
lpddr4x

721
00:26:00,080 --> 00:26:02,400
so on the dram that is used for example

722
00:26:02,400 --> 00:26:06,640
in smartphones but also on laptops

723
00:26:06,640 --> 00:26:09,120
and we found effective patterns on a 16

724
00:26:09,120 --> 00:26:10,960
of 19 devices

725
00:26:10,960 --> 00:26:12,720
you can see also a significant number of

726
00:26:12,720 --> 00:26:16,080
bit flips on some of the devices

727
00:26:16,080 --> 00:26:17,679
and on three device you can see we

728
00:26:17,679 --> 00:26:20,080
didn't find anything initially but then

729
00:26:20,080 --> 00:26:22,960
we reverse engineered those devices

730
00:26:22,960 --> 00:26:24,880
basically by designing some experiments

731
00:26:24,880 --> 00:26:26,640
and figuring out

732
00:26:26,640 --> 00:26:28,720
how these mitigations work

733
00:26:28,720 --> 00:26:30,400
and we found out that if we slightly

734
00:26:30,400 --> 00:26:33,200
change the parameters of our fuzzer we

735
00:26:33,200 --> 00:26:35,279
can also find bit flips in reasonable

736
00:26:35,279 --> 00:26:38,159
time so in less than three hours

737
00:26:38,159 --> 00:26:40,799
and this again shows that all lpddr4x

738
00:26:40,799 --> 00:26:42,240
devices are broken

739
00:26:42,240 --> 00:26:43,600
that the chips are also weaker than

740
00:26:43,600 --> 00:26:46,320
before so here you can see like 12

741
00:26:46,320 --> 00:26:48,159
million bit flips

742
00:26:48,159 --> 00:26:50,320
and this also has impact again on the

743
00:26:50,320 --> 00:26:53,320
exploitation

744
00:26:53,760 --> 00:26:56,559
and based on the insights

745
00:26:56,559 --> 00:26:57,840
based on these new patterns that we

746
00:26:57,840 --> 00:26:58,640
found

747
00:26:58,640 --> 00:27:00,320
we also derived some novel insights so

748
00:27:00,320 --> 00:27:02,400
we found out that on some dims the

749
00:27:02,400 --> 00:27:04,840
patterns are quite sophisticated

750
00:27:04,840 --> 00:27:07,600
complex and very difficult to craft them

751
00:27:07,600 --> 00:27:08,799
manually

752
00:27:08,799 --> 00:27:10,559
we also found out that these tier r

753
00:27:10,559 --> 00:27:12,640
mitigations are chip dependent so on

754
00:27:12,640 --> 00:27:15,440
some devices we could only trigger bit

755
00:27:15,440 --> 00:27:18,559
flips on a very specific byte offset

756
00:27:18,559 --> 00:27:21,360
you have to know that um usually these

757
00:27:21,360 --> 00:27:23,679
chips on the drum device work all in

758
00:27:23,679 --> 00:27:26,320
parallel meaning that um

759
00:27:26,320 --> 00:27:28,720
if you only see a bit flip at a specific

760
00:27:28,720 --> 00:27:31,200
byte offset then only a specific bit is

761
00:27:31,200 --> 00:27:32,799
vulnerable a

762
00:27:32,799 --> 00:27:35,440
specific chip is vulnerable to rowhammer

763
00:27:35,440 --> 00:27:36,960
and we also did some experiments to

764
00:27:36,960 --> 00:27:38,080
figure out

765
00:27:38,080 --> 00:27:40,480
the sampler size so how many of these

766
00:27:40,480 --> 00:27:43,360
aggressors the device can keep track of

767
00:27:43,360 --> 00:27:44,720
and we figured out that most of the

768
00:27:44,720 --> 00:27:46,960
device only can keep a track of less

769
00:27:46,960 --> 00:27:49,840
than 30 aggressors

770
00:27:50,559 --> 00:27:52,960
so we also disclosed our

771
00:27:52,960 --> 00:27:54,640
findings reported into the national

772
00:27:54,640 --> 00:27:57,520
cyber security switzerland we got a cbe

773
00:27:57,520 --> 00:28:00,159
assigned and disclosed our vulnerability

774
00:28:00,159 --> 00:28:03,679
in november of last year

775
00:28:03,679 --> 00:28:04,960
so to conclude

776
00:28:04,960 --> 00:28:07,200
the first part of the talk so blacksmith

777
00:28:07,200 --> 00:28:08,080
is

778
00:28:08,080 --> 00:28:10,480
a very effective and scalable way to

779
00:28:10,480 --> 00:28:12,320
trigger bit flips

780
00:28:12,320 --> 00:28:14,080
and we show that all current trr

781
00:28:14,080 --> 00:28:18,480
mitigations are vulnerable and we also

782
00:28:18,480 --> 00:28:20,559
can say that the approach generalizes

783
00:28:20,559 --> 00:28:23,200
well so for example we received

784
00:28:23,200 --> 00:28:25,120
dram devices from another vendor that we

785
00:28:25,120 --> 00:28:27,200
haven't seen before and blacksmith was

786
00:28:27,200 --> 00:28:31,360
able to find a working patterns on them

787
00:28:31,360 --> 00:28:33,840
and this work shows that we need really

788
00:28:33,840 --> 00:28:35,600
principled mitigations with provable

789
00:28:35,600 --> 00:28:37,760
security guarantees instead of the

790
00:28:37,760 --> 00:28:39,919
obscure proprietary mitigations that the

791
00:28:39,919 --> 00:28:43,120
dram vendors use today

792
00:28:43,120 --> 00:28:44,880
so this is the end of my talk

793
00:28:44,880 --> 00:28:46,880
thank you very much for your attention

794
00:28:46,880 --> 00:28:50,840
are there any questions

795
00:29:06,799 --> 00:29:09,120
hello thanks for the very nice talk it

796
00:29:09,120 --> 00:29:11,440
was very interesting to see all this

797
00:29:11,440 --> 00:29:14,799
i have a just a question um

798
00:29:14,799 --> 00:29:17,120
and it's regarding uh if you can go back

799
00:29:17,120 --> 00:29:19,679
to a slide 29 for example

800
00:29:19,679 --> 00:29:20,480
where

801
00:29:20,480 --> 00:29:23,120
you had all those access patterns

802
00:29:23,120 --> 00:29:25,520
yeah this for example

803
00:29:25,520 --> 00:29:27,120
so for me it's

804
00:29:27,120 --> 00:29:30,720
like black magic like how can you detect

805
00:29:30,720 --> 00:29:32,240
when the reverse signal is being

806
00:29:32,240 --> 00:29:34,159
triggered because this is just the

807
00:29:34,159 --> 00:29:36,799
handle uh by the low level

808
00:29:36,799 --> 00:29:38,960
preferred circuitry right so how do you

809
00:29:38,960 --> 00:29:41,039
know that and how can you align those

810
00:29:41,039 --> 00:29:44,240
accesses properly you can measure um so

811
00:29:44,240 --> 00:29:45,440
for the refresh you can measure the

812
00:29:45,440 --> 00:29:47,200
excess latency you will see that when a

813
00:29:47,200 --> 00:29:48,960
refresh happens the access latency has

814
00:29:48,960 --> 00:29:50,320
like a peak

815
00:29:50,320 --> 00:29:52,159
and then you can detect when the refresh

816
00:29:52,159 --> 00:29:53,440
happened

817
00:29:53,440 --> 00:29:54,720
and for the

818
00:29:54,720 --> 00:29:57,039
addressing so this part uh yeah i

819
00:29:57,039 --> 00:29:58,799
skipped before because there is existing

820
00:29:58,799 --> 00:30:01,120
work that shows basically how you can

821
00:30:01,120 --> 00:30:03,679
use a bank conflicts as a side channel

822
00:30:03,679 --> 00:30:05,520
to reverse engineer these addressing

823
00:30:05,520 --> 00:30:07,440
functions so the memory controller has

824
00:30:07,440 --> 00:30:09,840
some proprietary and non-disclosed

825
00:30:09,840 --> 00:30:12,080
addressing function that basically

826
00:30:12,080 --> 00:30:14,159
translates the physical address into a

827
00:30:14,159 --> 00:30:16,640
dram address so consisting of bank row

828
00:30:16,640 --> 00:30:17,760
and column

829
00:30:17,760 --> 00:30:19,600
and using this bank conflict such and

830
00:30:19,600 --> 00:30:21,600
you can figure them out and then you can

831
00:30:21,600 --> 00:30:23,120
really precisely

832
00:30:23,120 --> 00:30:24,880
address specific rows and then build

833
00:30:24,880 --> 00:30:26,320
your pattern like for example in this

834
00:30:26,320 --> 00:30:28,080
double-sided fashion where you have one

835
00:30:28,080 --> 00:30:31,120
victim row in between

836
00:30:31,919 --> 00:30:34,480
hello hi very nice talk thank you for

837
00:30:34,480 --> 00:30:36,880
your contribution so

838
00:30:36,880 --> 00:30:38,880
um

839
00:30:38,880 --> 00:30:40,960
would you be able to know if you had a

840
00:30:40,960 --> 00:30:43,679
double flip

841
00:30:44,080 --> 00:30:46,240
which means no no

842
00:30:46,240 --> 00:30:47,279
actual

843
00:30:47,279 --> 00:30:49,840
change in the output

844
00:30:49,840 --> 00:30:51,919
you mean that it flips

845
00:30:51,919 --> 00:30:53,679
twice no no you won't see this but it

846
00:30:53,679 --> 00:30:55,840
could be that you have

847
00:30:55,840 --> 00:30:58,080
in one row multiple bit flips this could

848
00:30:58,080 --> 00:31:01,279
happen and also the direction is

849
00:31:01,279 --> 00:31:04,880
depends on the data in the rows adjacent

850
00:31:04,880 --> 00:31:06,399
so it could be that it flips from zero

851
00:31:06,399 --> 00:31:08,720
to one or from one to zero what is the

852
00:31:08,720 --> 00:31:11,519
most frequent zero one or one zero

853
00:31:11,519 --> 00:31:13,600
depends on the data pattern but we use a

854
00:31:13,600 --> 00:31:14,960
random one

855
00:31:14,960 --> 00:31:15,760
um

856
00:31:15,760 --> 00:31:17,360
yeah

857
00:31:17,360 --> 00:31:18,640
but their existing work that

858
00:31:18,640 --> 00:31:20,640
characterizes basically

859
00:31:20,640 --> 00:31:22,880
um yeah these different data patterns

860
00:31:22,880 --> 00:31:25,200
and the impact uh

861
00:31:25,200 --> 00:31:27,360
yeah i'm familiar with the literature so

862
00:31:27,360 --> 00:31:28,159
uh

863
00:31:28,159 --> 00:31:29,760
the initial pattern that you put you

864
00:31:29,760 --> 00:31:32,880
also you do do you also variate that

865
00:31:32,880 --> 00:31:35,840
i mean the way you load the ram before

866
00:31:35,840 --> 00:31:37,279
hammering it

867
00:31:37,279 --> 00:31:38,880
also uh

868
00:31:38,880 --> 00:31:40,640
is gonna change the beats you are going

869
00:31:40,640 --> 00:31:41,519
to

870
00:31:41,519 --> 00:31:44,000
to hammer you know so you do you have

871
00:31:44,000 --> 00:31:46,159
like specific patterns for every byte or

872
00:31:46,159 --> 00:31:48,640
something like that that you used that

873
00:31:48,640 --> 00:31:50,480
work it better on some models or

874
00:31:50,480 --> 00:31:51,919
something like that

875
00:31:51,919 --> 00:31:54,159
we wouldn't look into that but we only

876
00:31:54,159 --> 00:31:56,000
used a random pattern basically

877
00:31:56,000 --> 00:31:57,760
pseudorandom so that we can reconstruct

878
00:31:57,760 --> 00:32:00,640
it and check if bit flips happened

879
00:32:00,640 --> 00:32:03,279
okay yeah i mean if you look at previous

880
00:32:03,279 --> 00:32:05,440
literature people may have been more

881
00:32:05,440 --> 00:32:08,960
successful with a a instead of ff for

882
00:32:08,960 --> 00:32:11,840
example yeah and the reason is unknown

883
00:32:11,840 --> 00:32:13,200
to me too but

884
00:32:13,200 --> 00:32:15,360
i it could be related to the cheap

885
00:32:15,360 --> 00:32:17,440
construction for example yeah yeah

886
00:32:17,440 --> 00:32:18,720
there's definitely one thing that we

887
00:32:18,720 --> 00:32:21,679
want to look more into here

888
00:32:22,880 --> 00:32:26,200
what are questions

889
00:32:29,840 --> 00:32:32,159
hi uh beautiful graphics uh very nice

890
00:32:32,159 --> 00:32:35,120
talking uh i just wonder is this like

891
00:32:35,120 --> 00:32:36,720
physically destructive have you break

892
00:32:36,720 --> 00:32:39,360
like a ton of ram sticks or like

893
00:32:39,360 --> 00:32:40,559
can you do this

894
00:32:40,559 --> 00:32:43,120
millions of times and the memory will

895
00:32:43,120 --> 00:32:44,159
like

896
00:32:44,159 --> 00:32:46,559
survive

897
00:32:46,799 --> 00:32:47,679
so

898
00:32:47,679 --> 00:32:49,679
the worst thing that can happen um

899
00:32:49,679 --> 00:32:51,200
during the execution is that the system

900
00:32:51,200 --> 00:32:53,519
crashes depends on where you do your ram

901
00:32:53,519 --> 00:32:55,440
attack so in our

902
00:32:55,440 --> 00:32:58,080
case um it was really about finding the

903
00:32:58,080 --> 00:32:59,840
patterns right so what we did is just

904
00:32:59,840 --> 00:33:01,840
allocate a super page and the super page

905
00:33:01,840 --> 00:33:03,519
is then only used by our application

906
00:33:03,519 --> 00:33:05,200
right and then we could hammer there but

907
00:33:05,200 --> 00:33:07,360
it could be of course um that you do a

908
00:33:07,360 --> 00:33:08,960
real rohan attack and you have other

909
00:33:08,960 --> 00:33:10,480
data around that you break something

910
00:33:10,480 --> 00:33:12,000
from the system

911
00:33:12,000 --> 00:33:15,600
and then there's this other aspect um

912
00:33:15,600 --> 00:33:17,039
if basically

913
00:33:17,039 --> 00:33:19,120
the devices wear off if you do raw my

914
00:33:19,120 --> 00:33:21,600
decks many times over and over again

915
00:33:21,600 --> 00:33:23,360
and as far as i know there's no existing

916
00:33:23,360 --> 00:33:25,120
work looking into that because it's very

917
00:33:25,120 --> 00:33:25,919
um

918
00:33:25,919 --> 00:33:27,840
difficult um

919
00:33:27,840 --> 00:33:29,679
to analyze this basically right you

920
00:33:29,679 --> 00:33:32,240
wouldn't have to have to buy many um

921
00:33:32,240 --> 00:33:34,559
dram devices and then let it run for

922
00:33:34,559 --> 00:33:36,720
months or years maybe and then look into

923
00:33:36,720 --> 00:33:38,480
rohammer vulnerability

924
00:33:38,480 --> 00:33:40,399
yeah but it could well be right because

925
00:33:40,399 --> 00:33:44,080
a physical phenomenon and yeah

926
00:33:46,159 --> 00:33:48,799
other questions

927
00:33:50,960 --> 00:33:54,480
uh so do you have any thoughts or ideas

928
00:33:54,480 --> 00:33:56,559
on what would be

929
00:33:56,559 --> 00:33:58,240
a good

930
00:33:58,240 --> 00:34:01,200
mitigation or solution to uh rohamer or

931
00:34:01,200 --> 00:34:03,679
is this uh something different that you

932
00:34:03,679 --> 00:34:06,320
you're not familiar with

933
00:34:06,320 --> 00:34:08,079
yes there have been many proposals in

934
00:34:08,079 --> 00:34:09,520
academia

935
00:34:09,520 --> 00:34:11,199
one of those proposals comes actually

936
00:34:11,199 --> 00:34:13,440
from my group from a colleague of mine

937
00:34:13,440 --> 00:34:16,719
and that's a mitigation called protear

938
00:34:16,719 --> 00:34:18,000
that basically

939
00:34:18,000 --> 00:34:19,119
is the first

940
00:34:19,119 --> 00:34:21,040
indira mitigation so it's really in the

941
00:34:21,040 --> 00:34:22,239
dram chip

942
00:34:22,239 --> 00:34:23,520
and comes with provable security

943
00:34:23,520 --> 00:34:25,359
guarantees so my colleague basically

944
00:34:25,359 --> 00:34:28,079
built a formal model showing that

945
00:34:28,079 --> 00:34:30,480
um this mitigation is safe against any

946
00:34:30,480 --> 00:34:33,679
kind of rohana attack so he constructed

947
00:34:33,679 --> 00:34:34,879
what could be considered the best

948
00:34:34,879 --> 00:34:36,800
theoretical attack and then

949
00:34:36,800 --> 00:34:38,800
showed that the mitigation can withstand

950
00:34:38,800 --> 00:34:40,159
it

951
00:34:40,159 --> 00:34:43,199
and this former model is like modeling

952
00:34:43,199 --> 00:34:45,599
the actual physics of dram and proving

953
00:34:45,599 --> 00:34:47,040
things about that

954
00:34:47,040 --> 00:34:49,918
no um modeling basically how raw hammer

955
00:34:49,918 --> 00:34:51,918
works right um that you have to activate

956
00:34:51,918 --> 00:34:53,679
a row a certain number of times and then

957
00:34:53,679 --> 00:34:55,280
there's a distance

958
00:34:55,280 --> 00:34:57,119
so he also takes physical effects into

959
00:34:57,119 --> 00:34:59,920
account like the distance so

960
00:34:59,920 --> 00:35:02,160
actually one thing that i did not

961
00:35:02,160 --> 00:35:04,079
highlight in my talk is

962
00:35:04,079 --> 00:35:05,839
that if you hammer so let me show you

963
00:35:05,839 --> 00:35:08,799
quickly the slide

964
00:35:11,040 --> 00:35:13,280
yeah so if you hammer these two

965
00:35:13,280 --> 00:35:15,440
aggressor rows these red ones then it

966
00:35:15,440 --> 00:35:17,119
might not only impact the one in the

967
00:35:17,119 --> 00:35:20,480
middle but also the one on here outside

968
00:35:20,480 --> 00:35:23,280
and not only um with distance one but

969
00:35:23,280 --> 00:35:26,560
also a higher distance and this is for

970
00:35:26,560 --> 00:35:28,640
example due to the physical effect right

971
00:35:28,640 --> 00:35:31,359
the leaking charges and this for example

972
00:35:31,359 --> 00:35:34,160
protear also takes into account

973
00:35:34,160 --> 00:35:36,399
okay

974
00:35:37,440 --> 00:35:40,160
a lot of questions

975
00:35:40,720 --> 00:35:41,920
okay so

976
00:35:41,920 --> 00:35:43,119
i guess so

977
00:35:43,119 --> 00:35:45,839
let continue

978
00:35:46,800 --> 00:35:50,000
and thanks for the talk

979
00:35:56,839 --> 00:36:00,079
okay um

980
00:36:00,079 --> 00:36:02,000
so essentially what patrick has just

981
00:36:02,000 --> 00:36:03,280
showed you is that we've built

982
00:36:03,280 --> 00:36:06,320
blacksmith and we can use blacksmith

983
00:36:06,320 --> 00:36:07,839
to find

984
00:36:07,839 --> 00:36:09,520
patterns that are effective and that

985
00:36:09,520 --> 00:36:11,200
allow us to flip bits at certain

986
00:36:11,200 --> 00:36:13,599
locations in physical memory now you

987
00:36:13,599 --> 00:36:15,680
might be wondering right why do i care

988
00:36:15,680 --> 00:36:16,800
okay

989
00:36:16,800 --> 00:36:18,800
it might not be nice but can an attacker

990
00:36:18,800 --> 00:36:21,839
actually leverage bit flips like this to

991
00:36:21,839 --> 00:36:24,160
break security guarantees on my system

992
00:36:24,160 --> 00:36:26,400
or do nasty things to my applications or

993
00:36:26,400 --> 00:36:27,920
my data

994
00:36:27,920 --> 00:36:30,160
and the answer perhaps unsurprisingly is

995
00:36:30,160 --> 00:36:31,359
yes

996
00:36:31,359 --> 00:36:32,960
so what i'll be doing in the remainder

997
00:36:32,960 --> 00:36:34,400
of this presentation

998
00:36:34,400 --> 00:36:37,280
is i'll be showing you one example

999
00:36:37,280 --> 00:36:39,520
of one such attack

1000
00:36:39,520 --> 00:36:41,440
you may have briefly seen this also

1001
00:36:41,440 --> 00:36:42,880
highlighted in the evaluation of

1002
00:36:42,880 --> 00:36:45,440
blacksmith with this concerns of paper

1003
00:36:45,440 --> 00:36:47,359
flip feng shui hammering needle and

1004
00:36:47,359 --> 00:36:48,800
software stack that was first introduced

1005
00:36:48,800 --> 00:36:50,560
in 2016 by

1006
00:36:50,560 --> 00:36:54,240
cava razari and benthas among others uh

1007
00:36:54,240 --> 00:36:56,640
cafezavi is a member of our group

1008
00:36:56,640 --> 00:36:59,200
and essentially

1009
00:36:59,200 --> 00:37:01,440
what this paper does or what this work

1010
00:37:01,440 --> 00:37:03,520
does what spring feng shui does is it's

1011
00:37:03,520 --> 00:37:05,200
a technique

1012
00:37:05,200 --> 00:37:07,359
in a situation

1013
00:37:07,359 --> 00:37:10,400
where we have two vms on one

1014
00:37:10,400 --> 00:37:11,839
virtualization host right so we have a

1015
00:37:11,839 --> 00:37:14,800
victim vm we have an attacker vm and

1016
00:37:14,800 --> 00:37:16,560
what this technique allows us to do is

1017
00:37:16,560 --> 00:37:18,640
it allows us to break cpu

1018
00:37:18,640 --> 00:37:20,880
virtualization isolation

1019
00:37:20,880 --> 00:37:22,640
by flipping one bit

1020
00:37:22,640 --> 00:37:25,839
in a memory page physical memory page

1021
00:37:25,839 --> 00:37:29,280
in our co-hosted victim vm okay

1022
00:37:29,280 --> 00:37:30,960
when can we do this so what are the

1023
00:37:30,960 --> 00:37:32,160
assumptions we have to make on the

1024
00:37:32,160 --> 00:37:35,040
system well first we have of course we

1025
00:37:35,040 --> 00:37:36,480
require the

1026
00:37:36,480 --> 00:37:38,240
that we have a victim and an attacker vm

1027
00:37:38,240 --> 00:37:39,680
that are co-hosted

1028
00:37:39,680 --> 00:37:42,960
we also have to have the ability to flip

1029
00:37:42,960 --> 00:37:45,200
bits in physical memory right so it has

1030
00:37:45,200 --> 00:37:47,839
to be a dram device that is

1031
00:37:47,839 --> 00:37:49,760
vulnerable to row armor well happily

1032
00:37:49,760 --> 00:37:52,079
blacksmith has shown that there are lots

1033
00:37:52,079 --> 00:37:54,640
of such devices

1034
00:37:54,640 --> 00:37:56,880
we have to have memory duplication

1035
00:37:56,880 --> 00:37:58,800
enabled on the host and we'll see the

1036
00:37:58,800 --> 00:38:00,720
why and how of this later

1037
00:38:00,720 --> 00:38:02,480
and also

1038
00:38:02,480 --> 00:38:05,200
not unimportantly we have to know

1039
00:38:05,200 --> 00:38:07,440
the content of the page so we have to

1040
00:38:07,440 --> 00:38:09,040
know the content of the memory in which

1041
00:38:09,040 --> 00:38:11,200
we are going to cast a bit flip

1042
00:38:11,200 --> 00:38:12,960
beforehand

1043
00:38:12,960 --> 00:38:14,560
so okay

1044
00:38:14,560 --> 00:38:16,560
if those guarantees are met

1045
00:38:16,560 --> 00:38:20,079
how do we actually perform the attack

1046
00:38:20,079 --> 00:38:22,000
flip feng shui presents a more general

1047
00:38:22,000 --> 00:38:24,960
model in which a hardware vulnerability

1048
00:38:24,960 --> 00:38:26,400
is combined with a physical memory

1049
00:38:26,400 --> 00:38:28,640
massaging primitive

1050
00:38:28,640 --> 00:38:31,040
in order to flip the bit we mentioned in

1051
00:38:31,040 --> 00:38:32,560
this presentation however we'll be

1052
00:38:32,560 --> 00:38:34,240
focusing on

1053
00:38:34,240 --> 00:38:36,000
just one specific instance that's also

1054
00:38:36,000 --> 00:38:37,680
highlighted in the paper and we are

1055
00:38:37,680 --> 00:38:39,760
going to use hardware or we're going to

1056
00:38:39,760 --> 00:38:41,200
use rowhammer

1057
00:38:41,200 --> 00:38:43,599
as the memory glitch

1058
00:38:43,599 --> 00:38:45,280
and we are going to see a technique

1059
00:38:45,280 --> 00:38:47,040
called deduplication

1060
00:38:47,040 --> 00:38:48,720
as the memory massaging primitive now

1061
00:38:48,720 --> 00:38:51,119
why is this massaging primitive

1062
00:38:51,119 --> 00:38:53,599
necessary is you have to remember that

1063
00:38:53,599 --> 00:38:56,720
in row hammer

1064
00:38:56,800 --> 00:38:59,520
not all locations in dram are equally

1065
00:38:59,520 --> 00:39:00,960
vulnerable

1066
00:39:00,960 --> 00:39:03,599
and there is no guarantee that the bit

1067
00:39:03,599 --> 00:39:05,520
flip you want to cause

1068
00:39:05,520 --> 00:39:07,280
right that this location in personal

1069
00:39:07,280 --> 00:39:09,680
memory is actually occupied by data or

1070
00:39:09,680 --> 00:39:11,760
you want to cause your bit flip

1071
00:39:11,760 --> 00:39:13,760
so what you need is you need the ability

1072
00:39:13,760 --> 00:39:15,760
to move around a victim page you need

1073
00:39:15,760 --> 00:39:18,320
ability to move around victim memory in

1074
00:39:18,320 --> 00:39:20,000
physical memory to get it to a spot

1075
00:39:20,000 --> 00:39:22,240
where you can use a blacksmith pattern

1076
00:39:22,240 --> 00:39:24,240
and memory deduplication as we'll see in

1077
00:39:24,240 --> 00:39:25,440
a minute

1078
00:39:25,440 --> 00:39:27,760
is technique that we can employ to

1079
00:39:27,760 --> 00:39:29,440
actually

1080
00:39:29,440 --> 00:39:32,240
get our victim vm page backed by

1081
00:39:32,240 --> 00:39:34,720
physical memory of our choosing to a

1082
00:39:34,720 --> 00:39:36,560
reasonable extent

1083
00:39:36,560 --> 00:39:39,040
so how does this mechanic work well

1084
00:39:39,040 --> 00:39:40,960
first let me talk about deduplication as

1085
00:39:40,960 --> 00:39:43,599
a technique it's basically you have to

1086
00:39:43,599 --> 00:39:45,200
imagine that

1087
00:39:45,200 --> 00:39:47,359
a virtualization host that virtualizes

1088
00:39:47,359 --> 00:39:48,720
many vms

1089
00:39:48,720 --> 00:39:51,599
that these vms have pages have

1090
00:39:51,599 --> 00:39:53,680
ranges of memory that they share that

1091
00:39:53,680 --> 00:39:55,440
have the same contents and that it would

1092
00:39:55,440 --> 00:39:57,839
be an enormous waste of physical memory

1093
00:39:57,839 --> 00:40:01,200
and therefore added cost to say

1094
00:40:01,200 --> 00:40:03,359
cloud providers if

1095
00:40:03,359 --> 00:40:05,119
each of those copies would have to be

1096
00:40:05,119 --> 00:40:06,800
backed by separate sections of physical

1097
00:40:06,800 --> 00:40:07,839
memory

1098
00:40:07,839 --> 00:40:09,920
so what a kernel like linux does for

1099
00:40:09,920 --> 00:40:12,400
example is it employs a technique called

1100
00:40:12,400 --> 00:40:14,240
kernel same page merging

1101
00:40:14,240 --> 00:40:16,720
and it starts to scan

1102
00:40:16,720 --> 00:40:19,200
and hosts physical memory so it scans

1103
00:40:19,200 --> 00:40:21,200
the range of physical memory and it's on

1104
00:40:21,200 --> 00:40:23,599
the lookout for pages for regions of

1105
00:40:23,599 --> 00:40:26,079
memory that are that contain the exact

1106
00:40:26,079 --> 00:40:27,520
same content

1107
00:40:27,520 --> 00:40:29,839
and if it finds pages like these then

1108
00:40:29,839 --> 00:40:32,480
what it decides to do is okay i'm going

1109
00:40:32,480 --> 00:40:35,040
to unmap one of those pages

1110
00:40:35,040 --> 00:40:36,800
and i'm going to instead map it to the

1111
00:40:36,800 --> 00:40:39,280
same location and physical memory

1112
00:40:39,280 --> 00:40:41,440
that the other vm is using thereby

1113
00:40:41,440 --> 00:40:43,760
sparing a lot of

1114
00:40:43,760 --> 00:40:46,400
physical memory in the process

1115
00:40:46,400 --> 00:40:47,920
what is important in this context of

1116
00:40:47,920 --> 00:40:51,040
course is that if we were to change

1117
00:40:51,040 --> 00:40:54,720
uh any of the data in our vm

1118
00:40:54,720 --> 00:40:57,280
then we need to then the kernel employs

1119
00:40:57,280 --> 00:40:59,520
something called copy on write

1120
00:40:59,520 --> 00:41:01,359
to ensure that those changes aren't

1121
00:41:01,359 --> 00:41:03,440
replicated in the victim vm this is of

1122
00:41:03,440 --> 00:41:04,880
course necessary to maintain the

1123
00:41:04,880 --> 00:41:07,359
semantics of this entire operation

1124
00:41:07,359 --> 00:41:10,079
but also any other alternative would be

1125
00:41:10,079 --> 00:41:11,760
a nightmare from a security point of

1126
00:41:11,760 --> 00:41:14,240
view if you could just arbitrarily write

1127
00:41:14,240 --> 00:41:17,040
to victim memory right

1128
00:41:17,040 --> 00:41:19,680
however it's important of course for the

1129
00:41:19,680 --> 00:41:22,000
cpu or a kernel to employ a copy on

1130
00:41:22,000 --> 00:41:23,280
write or to

1131
00:41:23,280 --> 00:41:25,040
use this technique that it needs to be

1132
00:41:25,040 --> 00:41:27,040
able to detect that is written to a page

1133
00:41:27,040 --> 00:41:28,960
in the first place

1134
00:41:28,960 --> 00:41:31,440
now enter row hammer why

1135
00:41:31,440 --> 00:41:33,520
where can the duplication go wrong well

1136
00:41:33,520 --> 00:41:35,200
we return to the situation here where we

1137
00:41:35,200 --> 00:41:36,960
have merged pages

1138
00:41:36,960 --> 00:41:39,040
and the

1139
00:41:39,040 --> 00:41:40,720
both the victim via memory page and the

1140
00:41:40,720 --> 00:41:43,920
attacker vm page are backed by

1141
00:41:43,920 --> 00:41:46,800
physical memory chosen by our attacker

1142
00:41:46,800 --> 00:41:49,520
now what happens if

1143
00:41:49,520 --> 00:41:52,400
we flip a bit we only have a change in

1144
00:41:52,400 --> 00:41:54,400
host physical memory and it's totally

1145
00:41:54,400 --> 00:41:56,480
oblivious right the cpu doesn't notice

1146
00:41:56,480 --> 00:41:58,560
that the kernel doesn't notice this

1147
00:41:58,560 --> 00:42:00,400
because if it would notice this if it

1148
00:42:00,400 --> 00:42:01,920
would be able to detect such bit flips

1149
00:42:01,920 --> 00:42:03,920
well it would be trivial to undo them

1150
00:42:03,920 --> 00:42:06,800
right and bit flips wouldn't be nearly

1151
00:42:06,800 --> 00:42:08,400
as much of a problem

1152
00:42:08,400 --> 00:42:10,000
so because

1153
00:42:10,000 --> 00:42:12,240
it doesn't notice this

1154
00:42:12,240 --> 00:42:15,040
what happens is that these changes are

1155
00:42:15,040 --> 00:42:16,640
visible from both the attacker via

1156
00:42:16,640 --> 00:42:18,880
memory and the victim vm memory right

1157
00:42:18,880 --> 00:42:20,800
and that's why

1158
00:42:20,800 --> 00:42:23,280
this combination of deduplication and

1159
00:42:23,280 --> 00:42:24,720
bit and

1160
00:42:24,720 --> 00:42:26,960
row hammer is so dangerous because we

1161
00:42:26,960 --> 00:42:28,800
can essentially get

1162
00:42:28,800 --> 00:42:31,200
a victim via memory page backed by

1163
00:42:31,200 --> 00:42:33,200
physical memory of our choosing and then

1164
00:42:33,200 --> 00:42:35,359
we can use row hammer and blacksmith as

1165
00:42:35,359 --> 00:42:36,640
a further

1166
00:42:36,640 --> 00:42:38,960
to flip a bit in the surgical page

1167
00:42:38,960 --> 00:42:41,200
without the cpu or the kernel noticing

1168
00:42:41,200 --> 00:42:42,160
anything

1169
00:42:42,160 --> 00:42:43,839
and there's also flapping a bit in

1170
00:42:43,839 --> 00:42:46,880
memory used by the victim

1171
00:42:46,880 --> 00:42:47,680
so

1172
00:42:47,680 --> 00:42:49,440
what we're going to do is we're going to

1173
00:42:49,440 --> 00:42:51,520
use this technique to construct an

1174
00:42:51,520 --> 00:42:53,920
attack against open sh

1175
00:42:53,920 --> 00:42:54,720
so

1176
00:42:54,720 --> 00:42:56,640
imagine this is the following scene all

1177
00:42:56,640 --> 00:42:58,640
right we have a victim vm is running an

1178
00:42:58,640 --> 00:43:02,160
open ssh server and our victim has an

1179
00:43:02,160 --> 00:43:03,280
rsa

1180
00:43:03,280 --> 00:43:06,640
public private keeper and the public key

1181
00:43:06,640 --> 00:43:09,040
is on the in the authorized key list in

1182
00:43:09,040 --> 00:43:10,720
the victim vm

1183
00:43:10,720 --> 00:43:12,800
and the victim uses his private key to

1184
00:43:12,800 --> 00:43:15,280
authenticate himself to the server

1185
00:43:15,280 --> 00:43:17,440
and to gain access now how can we

1186
00:43:17,440 --> 00:43:18,960
leverage

1187
00:43:18,960 --> 00:43:22,480
flip feng shui and row hammer

1188
00:43:22,480 --> 00:43:24,240
to break into

1189
00:43:24,240 --> 00:43:27,680
this vm to gain access to this server

1190
00:43:27,680 --> 00:43:30,319
without actually having access to the

1191
00:43:30,319 --> 00:43:32,400
private key

1192
00:43:32,400 --> 00:43:33,280
um

1193
00:43:33,280 --> 00:43:36,319
if you were to look at what openssh does

1194
00:43:36,319 --> 00:43:38,160
if someone tries

1195
00:43:38,160 --> 00:43:40,319
to connect if someone tries to ssh into

1196
00:43:40,319 --> 00:43:42,240
your server there's this file called

1197
00:43:42,240 --> 00:43:44,160
authorized keys which basically contains

1198
00:43:44,160 --> 00:43:45,839
entries like these

1199
00:43:45,839 --> 00:43:49,359
um it's a list of public keys that are

1200
00:43:49,359 --> 00:43:52,480
authorized to access the server and

1201
00:43:52,480 --> 00:43:54,000
what you can see is if you drop the

1202
00:43:54,000 --> 00:43:56,240
prefix and the comments

1203
00:43:56,240 --> 00:43:58,480
in the in one of these entries and then

1204
00:43:58,480 --> 00:44:01,280
you do a base64 decode is that what this

1205
00:44:01,280 --> 00:44:03,760
really contains is just three length

1206
00:44:03,760 --> 00:44:05,359
prefix fields

1207
00:44:05,359 --> 00:44:08,319
we have a constant string indicating the

1208
00:44:08,319 --> 00:44:09,760
type of the key

1209
00:44:09,760 --> 00:44:13,280
we have a public exponent in rsa which

1210
00:44:13,280 --> 00:44:15,280
is typically set to the static value of

1211
00:44:15,280 --> 00:44:17,359
2 to the power of 16 plus 1.

1212
00:44:17,359 --> 00:44:19,440
and then finally we have

1213
00:44:19,440 --> 00:44:22,319
an rsa modulus which is the product of

1214
00:44:22,319 --> 00:44:23,920
two primes

1215
00:44:23,920 --> 00:44:25,359
just to recap

1216
00:44:25,359 --> 00:44:27,920
for those unfamiliar we have an rsa

1217
00:44:27,920 --> 00:44:30,160
public key is as i mentioned

1218
00:44:30,160 --> 00:44:33,680
this modulus and this public exponent

1219
00:44:33,680 --> 00:44:37,119
we also have a corresponding private key

1220
00:44:37,119 --> 00:44:40,720
which basically also holds this

1221
00:44:40,720 --> 00:44:42,800
modulus on the condition of course that

1222
00:44:42,800 --> 00:44:43,920
the

1223
00:44:43,920 --> 00:44:46,160
person who owns the private key is aware

1224
00:44:46,160 --> 00:44:47,280
of the

1225
00:44:47,280 --> 00:44:48,800
two prime factors of the prime

1226
00:44:48,800 --> 00:44:52,079
factorization and he also has a private

1227
00:44:52,079 --> 00:44:54,800
exponent d which is derived from these

1228
00:44:54,800 --> 00:44:57,520
factors and from e and now what you need

1229
00:44:57,520 --> 00:44:59,440
to imagine is what happens if we flip a

1230
00:44:59,440 --> 00:45:00,319
bit

1231
00:45:00,319 --> 00:45:01,920
in this modulus n

1232
00:45:01,920 --> 00:45:04,960
well as it turns out and prime is easier

1233
00:45:04,960 --> 00:45:06,960
to factorize so the paper contains some

1234
00:45:06,960 --> 00:45:08,000
math

1235
00:45:08,000 --> 00:45:10,160
which i'll not go into here but

1236
00:45:10,160 --> 00:45:12,880
essentially in between 12 and 22 of

1237
00:45:12,880 --> 00:45:14,160
cases

1238
00:45:14,160 --> 00:45:15,359
um

1239
00:45:15,359 --> 00:45:17,760
we can factorize this new and prime

1240
00:45:17,760 --> 00:45:19,760
effectively and if we can factorize m

1241
00:45:19,760 --> 00:45:20,720
prime

1242
00:45:20,720 --> 00:45:22,960
well we can compute d prime so we can

1243
00:45:22,960 --> 00:45:25,440
find and construct a private key

1244
00:45:25,440 --> 00:45:26,960
that allows us to

1245
00:45:26,960 --> 00:45:28,720
gain access

1246
00:45:28,720 --> 00:45:31,040
to a server that's using the

1247
00:45:31,040 --> 00:45:34,079
modified public key with the bit flip

1248
00:45:34,079 --> 00:45:36,640
okay so what's our game plan what's our

1249
00:45:36,640 --> 00:45:39,040
exploitation plan basically first

1250
00:45:39,040 --> 00:45:40,800
we have a stage of templating and in

1251
00:45:40,800 --> 00:45:42,240
templating what we're doing is we're

1252
00:45:42,240 --> 00:45:44,800
using blacksmith to find locations of

1253
00:45:44,800 --> 00:45:47,040
physical memory where we can reliably

1254
00:45:47,040 --> 00:45:48,640
flip a bit

1255
00:45:48,640 --> 00:45:50,640
right and then we use our memory

1256
00:45:50,640 --> 00:45:53,040
duplication technique our massaging to

1257
00:45:53,040 --> 00:45:54,560
get the victim

1258
00:45:54,560 --> 00:45:55,839
public key

1259
00:45:55,839 --> 00:45:57,680
into the physical memory location where

1260
00:45:57,680 --> 00:45:59,280
we can flip a bit

1261
00:45:59,280 --> 00:46:02,240
and then finally

1262
00:46:02,240 --> 00:46:04,480
we flip a bit in the keys modulus by

1263
00:46:04,480 --> 00:46:06,000
using

1264
00:46:06,000 --> 00:46:08,240
the blacksmith pattern that we found on

1265
00:46:08,240 --> 00:46:09,839
the physical memory we've selected and

1266
00:46:09,839 --> 00:46:11,520
where we've moved the

1267
00:46:11,520 --> 00:46:12,839
public

1268
00:46:12,839 --> 00:46:16,319
key once this is done the victim vm is

1269
00:46:16,319 --> 00:46:19,119
only aware of this modified public key

1270
00:46:19,119 --> 00:46:21,920
we can construct our private key and we

1271
00:46:21,920 --> 00:46:23,839
can gain access to the server

1272
00:46:23,839 --> 00:46:26,079
now what does this look like from a

1273
00:46:26,079 --> 00:46:28,800
memory point of view you have to imagine

1274
00:46:28,800 --> 00:46:30,480
that the attacker is of course aware of

1275
00:46:30,480 --> 00:46:32,079
the victim's public key because it's

1276
00:46:32,079 --> 00:46:33,280
well public

1277
00:46:33,280 --> 00:46:34,560
and it

1278
00:46:34,560 --> 00:46:36,560
places this somewhere in its memory

1279
00:46:36,560 --> 00:46:38,640
where we can cause a bit flip

1280
00:46:38,640 --> 00:46:40,800
and next what the attacker wants to do

1281
00:46:40,800 --> 00:46:43,280
is it wants to get the victim to load a

1282
00:46:43,280 --> 00:46:45,520
copy of this public key into its memory

1283
00:46:45,520 --> 00:46:48,079
so that next ksm can do a scan and can

1284
00:46:48,079 --> 00:46:50,160
merge these pages now one technique for

1285
00:46:50,160 --> 00:46:53,040
example that the attacker can employ is

1286
00:46:53,040 --> 00:46:55,680
it can just try to ssh into the victim

1287
00:46:55,680 --> 00:46:57,920
with an invalid or with the wrong

1288
00:46:57,920 --> 00:47:01,599
private key which will cause ssh openssh

1289
00:47:01,599 --> 00:47:03,440
to load the authorized keys file because

1290
00:47:03,440 --> 00:47:05,440
it needs to check ok it is public

1291
00:47:05,440 --> 00:47:07,520
private key corresponding to any

1292
00:47:07,520 --> 00:47:09,040
authorized public key

1293
00:47:09,040 --> 00:47:11,200
and then the linux page cache will take

1294
00:47:11,200 --> 00:47:12,720
care of the fact that it's located in

1295
00:47:12,720 --> 00:47:15,040
memory

1296
00:47:15,040 --> 00:47:17,200
which allows ksm which gives ksm the

1297
00:47:17,200 --> 00:47:20,079
opportunity to merge the pages and now

1298
00:47:20,079 --> 00:47:22,480
voila we have

1299
00:47:22,480 --> 00:47:23,200
the

1300
00:47:23,200 --> 00:47:25,760
victim vm page backed by physical memory

1301
00:47:25,760 --> 00:47:29,520
of our choosing and we can flip the bit

1302
00:47:29,520 --> 00:47:31,440
and b turned into a c here we flipped a

1303
00:47:31,440 --> 00:47:34,240
bit we've modified the public key

1304
00:47:34,240 --> 00:47:35,599
this product

1305
00:47:35,599 --> 00:47:37,599
this change also is visible from the

1306
00:47:37,599 --> 00:47:38,880
victim vm

1307
00:47:38,880 --> 00:47:39,920
and if

1308
00:47:39,920 --> 00:47:42,079
we now try to use a modified private key

1309
00:47:42,079 --> 00:47:44,160
on the victim we will have we will have

1310
00:47:44,160 --> 00:47:47,440
gained access to this server

1311
00:47:47,440 --> 00:47:50,640
now to drive the point home a little

1312
00:47:50,640 --> 00:47:53,119
we have a demo um it's a pre-recorded

1313
00:47:53,119 --> 00:47:54,880
demo we weren't really sure enough now

1314
00:47:54,880 --> 00:47:56,880
that we have enough time to try this

1315
00:47:56,880 --> 00:47:58,400
live

1316
00:47:58,400 --> 00:48:02,280
um let me quickly

1317
00:48:06,079 --> 00:48:07,920
here yeah

1318
00:48:07,920 --> 00:48:10,240
right

1319
00:48:18,000 --> 00:48:19,119
right

1320
00:48:19,119 --> 00:48:21,920
um so basically what this demo will show

1321
00:48:21,920 --> 00:48:24,480
you um it's intended for

1322
00:48:24,480 --> 00:48:26,880
another project but uh it's using the

1323
00:48:26,880 --> 00:48:27,760
same

1324
00:48:27,760 --> 00:48:30,960
uh technique and i'll be pausing at some

1325
00:48:30,960 --> 00:48:32,800
places during the demo

1326
00:48:32,800 --> 00:48:35,119
to showcase some important details so

1327
00:48:35,119 --> 00:48:36,640
what's happening here is we've created

1328
00:48:36,640 --> 00:48:38,400
our vms

1329
00:48:38,400 --> 00:48:40,960
and we've generated a public key for our

1330
00:48:40,960 --> 00:48:44,559
victim and we've highlighted here

1331
00:48:44,559 --> 00:48:45,680
a small

1332
00:48:45,680 --> 00:48:47,440
part of this key because this is the

1333
00:48:47,440 --> 00:48:50,559
part of the key right node psjrs where

1334
00:48:50,559 --> 00:48:53,359
we are going to cause a bit flip

1335
00:48:53,359 --> 00:48:56,480
now that we have basically set this up

1336
00:48:56,480 --> 00:48:58,800
the next step is going to be

1337
00:48:58,800 --> 00:49:00,480
to

1338
00:49:00,480 --> 00:49:02,559
start our blacksmith further or to start

1339
00:49:02,559 --> 00:49:04,400
our end-to-end exploit router

1340
00:49:04,400 --> 00:49:06,079
and what we're going to do is first

1341
00:49:06,079 --> 00:49:07,440
you're going to have to reverse engineer

1342
00:49:07,440 --> 00:49:09,520
some parts of dram which is the first

1343
00:49:09,520 --> 00:49:12,880
thing you'll be seeing in a minute

1344
00:49:14,319 --> 00:49:16,319
right so we are now we have started the

1345
00:49:16,319 --> 00:49:17,520
exploit

1346
00:49:17,520 --> 00:49:18,880
and the first thing we're going to do is

1347
00:49:18,880 --> 00:49:20,880
we're going to reverse engineer

1348
00:49:20,880 --> 00:49:22,720
some aspects of the dram organization

1349
00:49:22,720 --> 00:49:27,399
which will need to run the further

1350
00:49:31,440 --> 00:49:34,480
that's what's happening here

1351
00:49:35,359 --> 00:49:36,880
and once this reverse engineering is

1352
00:49:36,880 --> 00:49:38,800
done we can start our templating phase

1353
00:49:38,800 --> 00:49:40,079
essentially what this means is that we

1354
00:49:40,079 --> 00:49:42,640
are going to start generating patterns

1355
00:49:42,640 --> 00:49:43,920
at different locations and we're going

1356
00:49:43,920 --> 00:49:45,520
to try these patterns out until we've

1357
00:49:45,520 --> 00:49:46,800
hit

1358
00:49:46,800 --> 00:49:48,880
a pattern that's both effective enough

1359
00:49:48,880 --> 00:49:51,839
and that results if applied in a public

1360
00:49:51,839 --> 00:49:54,160
key that we can actually factorize the

1361
00:49:54,160 --> 00:49:55,359
modulus

1362
00:49:55,359 --> 00:49:56,640
right

1363
00:49:56,640 --> 00:49:58,000
so what we've done now is you're

1364
00:49:58,000 --> 00:49:59,440
starting

1365
00:49:59,440 --> 00:50:01,280
to try and sped up but you're starting

1366
00:50:01,280 --> 00:50:05,200
to try all sorts of um

1367
00:50:05,440 --> 00:50:07,200
patterns

1368
00:50:07,200 --> 00:50:09,440
and this will take a while

1369
00:50:09,440 --> 00:50:12,079
um because

1370
00:50:12,079 --> 00:50:14,160
we the pattern not only has to actually

1371
00:50:14,160 --> 00:50:16,079
cause a bit flip it actually has to flip

1372
00:50:16,079 --> 00:50:17,520
the bit in the right direction right we

1373
00:50:17,520 --> 00:50:18,880
have to actually change the one and do a

1374
00:50:18,880 --> 00:50:20,880
zero or vice versa

1375
00:50:20,880 --> 00:50:23,280
um and now this pattern that you've just

1376
00:50:23,280 --> 00:50:24,400
scheduled

1377
00:50:24,400 --> 00:50:25,680
is

1378
00:50:25,680 --> 00:50:27,520
means that we've just tried okay we

1379
00:50:27,520 --> 00:50:29,680
found a revival flip and now we're going

1380
00:50:29,680 --> 00:50:31,520
to try to see if this flip results in a

1381
00:50:31,520 --> 00:50:33,599
key that we can factorize

1382
00:50:33,599 --> 00:50:36,240
this happens in the background

1383
00:50:36,240 --> 00:50:38,160
and i mean in the meantime because like

1384
00:50:38,160 --> 00:50:39,520
it's not guaranteed that this will work

1385
00:50:39,520 --> 00:50:41,599
so we'll just continue searching

1386
00:50:41,599 --> 00:50:44,400
for all sorts of different

1387
00:50:44,400 --> 00:50:46,800
patterns and we'll also schedule those

1388
00:50:46,800 --> 00:50:50,119
if they're interesting

1389
00:51:20,240 --> 00:51:21,839
this takes a while and you can see the

1390
00:51:21,839 --> 00:51:25,200
longer log messages ah right and now

1391
00:51:25,200 --> 00:51:27,440
what you see here is an open ssh a

1392
00:51:27,440 --> 00:51:29,359
private key which means that the key

1393
00:51:29,359 --> 00:51:31,599
that we scheduled key number five was a

1394
00:51:31,599 --> 00:51:33,440
public key that when we applied the bit

1395
00:51:33,440 --> 00:51:35,040
flip we could actually factorize the

1396
00:51:35,040 --> 00:51:37,359
modulus of and therefore we could

1397
00:51:37,359 --> 00:51:39,599
recreate a private key and this is the

1398
00:51:39,599 --> 00:51:41,760
private key that we've generated now

1399
00:51:41,760 --> 00:51:43,359
we basically have our ingredients right

1400
00:51:43,359 --> 00:51:44,960
we have a blacksmith pattern

1401
00:51:44,960 --> 00:51:47,359
we have that we can apply

1402
00:51:47,359 --> 00:51:48,079
to

1403
00:51:48,079 --> 00:51:49,920
the public key

1404
00:51:49,920 --> 00:51:51,680
and if we apply that pattern then the

1405
00:51:51,680 --> 00:51:53,680
public then a bit in public keyword will

1406
00:51:53,680 --> 00:51:55,359
flip in such a way

1407
00:51:55,359 --> 00:51:57,040
that the modulus will change and that we

1408
00:51:57,040 --> 00:51:58,480
can factorize that modulus and that we

1409
00:51:58,480 --> 00:52:00,079
can generate a private key

1410
00:52:00,079 --> 00:52:02,000
now what's next

1411
00:52:02,000 --> 00:52:04,000
on our list of tasks is we have to get

1412
00:52:04,000 --> 00:52:05,280
the public key

1413
00:52:05,280 --> 00:52:07,920
into memory and we have to also get the

1414
00:52:07,920 --> 00:52:12,240
victim vm to get this key into memory

1415
00:52:13,680 --> 00:52:16,640
and then after that it's just waiting

1416
00:52:16,640 --> 00:52:18,960
a little until psm has had a chance to

1417
00:52:18,960 --> 00:52:20,800
look at both pages and to merge the

1418
00:52:20,800 --> 00:52:25,200
pages so that we control physical memory

1419
00:52:27,200 --> 00:52:28,640
so we are just

1420
00:52:28,640 --> 00:52:32,920
preparing to duplicate the page

1421
00:52:36,880 --> 00:52:38,880
it takes a while until ksm has finished

1422
00:52:38,880 --> 00:52:42,680
his pass around all memory

1423
00:52:46,720 --> 00:52:48,400
okay

1424
00:52:48,400 --> 00:52:51,040
so now we've de-duplicated the page and

1425
00:52:51,040 --> 00:52:54,920
we've applied the bit flip

1426
00:53:01,200 --> 00:53:02,559
and now we are going to have to wait

1427
00:53:02,559 --> 00:53:04,880
until

1428
00:53:05,200 --> 00:53:07,119
the changes be

1429
00:53:07,119 --> 00:53:11,400
is also picked up by the victim

1430
00:53:14,240 --> 00:53:16,480
again some more waiting

1431
00:53:16,480 --> 00:53:20,440
until ksm is done

1432
00:53:31,520 --> 00:53:32,319
okay

1433
00:53:32,319 --> 00:53:33,839
and now

1434
00:53:33,839 --> 00:53:35,119
what you can see here in the log

1435
00:53:35,119 --> 00:53:36,960
messages is that we found that the flip

1436
00:53:36,960 --> 00:53:39,200
we found essentially saying okay we are

1437
00:53:39,200 --> 00:53:41,040
expecting the flippy phone to flip a j

1438
00:53:41,040 --> 00:53:42,800
into an n in the key

1439
00:53:42,800 --> 00:53:44,559
and if we just continue the video for a

1440
00:53:44,559 --> 00:53:46,640
moment you'll see that this is exactly

1441
00:53:46,640 --> 00:53:51,160
what happens to the public key

1442
00:53:57,440 --> 00:53:58,800
right and what you'll notice here is

1443
00:53:58,800 --> 00:54:00,720
we've write the original

1444
00:54:00,720 --> 00:54:03,680
so the undamaged private key on the

1445
00:54:03,680 --> 00:54:06,319
victim vm but now it's rejected its own

1446
00:54:06,319 --> 00:54:08,000
private key because it no longer

1447
00:54:08,000 --> 00:54:10,480
corresponds to our public key that we've

1448
00:54:10,480 --> 00:54:13,440
applied the bit flip to

1449
00:54:15,359 --> 00:54:17,040
and finally

1450
00:54:17,040 --> 00:54:19,200
what you see here i'll continue the

1451
00:54:19,200 --> 00:54:22,319
video until it highlights the change

1452
00:54:22,319 --> 00:54:24,480
is that the j has indeed turned into an

1453
00:54:24,480 --> 00:54:25,119
n

1454
00:54:25,119 --> 00:54:28,000
and that we've managed to use this key

1455
00:54:28,000 --> 00:54:30,559
to gain access

1456
00:54:30,559 --> 00:54:33,760
to the victim vm

1457
00:54:35,520 --> 00:54:39,839
thereby completing the end to end

1458
00:54:39,839 --> 00:54:42,400
exploits

1459
00:54:42,480 --> 00:54:44,559
okay

1460
00:54:44,559 --> 00:54:46,799
that's it from our side are there any

1461
00:54:46,799 --> 00:54:48,400
questions

1462
00:54:48,400 --> 00:54:56,869
[Applause]

1463
00:55:00,100 --> 00:55:02,720
[Music]

1464
00:55:02,720 --> 00:55:06,880
hi so my question is is ksm really

1465
00:55:06,880 --> 00:55:09,440
enabled in product production because

1466
00:55:09,440 --> 00:55:11,440
i remember that ksm had a lot of

1467
00:55:11,440 --> 00:55:14,480
problems even before rowhammer like the

1468
00:55:14,480 --> 00:55:17,040
the old flash and reload can be used to

1469
00:55:17,040 --> 00:55:19,599
leak the accessed patterns

1470
00:55:19,599 --> 00:55:22,160
so i thought people certainly are not

1471
00:55:22,160 --> 00:55:23,760
using it at the time of the publication

1472
00:55:23,760 --> 00:55:26,000
of the paper it used to be right this

1473
00:55:26,000 --> 00:55:28,319
service and this serves them as example

1474
00:55:28,319 --> 00:55:30,960
but in security critical context

1475
00:55:30,960 --> 00:55:32,880
um right the recommendation has long

1476
00:55:32,880 --> 00:55:34,559
since been to

1477
00:55:34,559 --> 00:55:36,799
disable it in its entirety or at least

1478
00:55:36,799 --> 00:55:38,319
to consider

1479
00:55:38,319 --> 00:55:40,400
you know like for example how does it

1480
00:55:40,400 --> 00:55:42,559
look in cloud providers like the popular

1481
00:55:42,559 --> 00:55:44,160
ones or

1482
00:55:44,160 --> 00:55:44,960
um

1483
00:55:44,960 --> 00:55:47,040
i know i can only say that at the time

1484
00:55:47,040 --> 00:55:48,960
of publication of the paper

1485
00:55:48,960 --> 00:55:51,040
it was widely used even in public cloud

1486
00:55:51,040 --> 00:55:52,160
providers

1487
00:55:52,160 --> 00:55:55,760
and i would assume given

1488
00:55:55,760 --> 00:55:58,240
right the security implications

1489
00:55:58,240 --> 00:55:59,839
that its users have since been

1490
00:55:59,839 --> 00:56:02,160
discontinued but i can't say for certain

1491
00:56:02,160 --> 00:56:05,359
okay that's boring

1492
00:56:06,079 --> 00:56:07,839
again probably

1493
00:56:07,839 --> 00:56:11,359
but i don't know for sure

1494
00:56:14,319 --> 00:56:16,799
hello hi thank you for the remake of the

1495
00:56:16,799 --> 00:56:18,640
usinix presentation

1496
00:56:18,640 --> 00:56:20,960
it's nice to have it live again

1497
00:56:20,960 --> 00:56:24,079
so um the question is the following

1498
00:56:24,079 --> 00:56:26,960
how much time do you have before

1499
00:56:26,960 --> 00:56:29,839
the public key that you modified gets

1500
00:56:29,839 --> 00:56:32,480
back to the original because i mean the

1501
00:56:32,480 --> 00:56:34,960
file is in ram

1502
00:56:34,960 --> 00:56:37,119
and basically when you forge the new

1503
00:56:37,119 --> 00:56:38,400
private key

1504
00:56:38,400 --> 00:56:39,280
and

1505
00:56:39,280 --> 00:56:41,280
then you have a window of time and then

1506
00:56:41,280 --> 00:56:43,520
it's going to roll back to the old one

1507
00:56:43,520 --> 00:56:45,359
so how do you guys develop the

1508
00:56:45,359 --> 00:56:47,200
experiment to make it work

1509
00:56:47,200 --> 00:56:48,240
um

1510
00:56:48,240 --> 00:56:49,200
well

1511
00:56:49,200 --> 00:56:51,119
yes you're right because right the

1512
00:56:51,119 --> 00:56:53,040
change happens in ram and specifically

1513
00:56:53,040 --> 00:56:54,160
it has in

1514
00:56:54,160 --> 00:56:55,440
ram because

1515
00:56:55,440 --> 00:56:57,440
the victim key is in the page in linux

1516
00:56:57,440 --> 00:56:59,440
page cache

1517
00:56:59,440 --> 00:57:01,040
i can't give you an accurate number on

1518
00:57:01,040 --> 00:57:03,359
exactly how long

1519
00:57:03,359 --> 00:57:05,760
it would remain in the page cache

1520
00:57:05,760 --> 00:57:06,960
but for my

1521
00:57:06,960 --> 00:57:09,520
own observations

1522
00:57:09,520 --> 00:57:11,599
i'll say

1523
00:57:11,599 --> 00:57:13,040
at least a minute

1524
00:57:13,040 --> 00:57:15,760
that's that's a lot of time yeah

1525
00:57:15,760 --> 00:57:16,880
um

1526
00:57:16,880 --> 00:57:19,440
and we've seen like we've seen

1527
00:57:19,440 --> 00:57:22,079
successes up until quite

1528
00:57:22,079 --> 00:57:23,760
a long time afterwards and you have to

1529
00:57:23,760 --> 00:57:25,359
remember that the linux based cache if

1530
00:57:25,359 --> 00:57:26,960
i'm not mistaken uses basically the

1531
00:57:26,960 --> 00:57:28,240
remainder

1532
00:57:28,240 --> 00:57:29,359
of your

1533
00:57:29,359 --> 00:57:31,520
basically all your use unused

1534
00:57:31,520 --> 00:57:33,680
dram right so if

1535
00:57:33,680 --> 00:57:35,440
you don't

1536
00:57:35,440 --> 00:57:38,240
have a lot of io going on a lot of

1537
00:57:38,240 --> 00:57:40,160
file reading going on file writing going

1538
00:57:40,160 --> 00:57:42,079
home then my expectation would be yes it

1539
00:57:42,079 --> 00:57:43,599
would remain there for quite a time

1540
00:57:43,599 --> 00:57:45,120
quite long time

1541
00:57:45,120 --> 00:57:46,799
[Music]

1542
00:57:46,799 --> 00:57:49,839
um yeah just to what uh other than that

1543
00:57:49,839 --> 00:57:51,839
yeah i think i think so actually until

1544
00:57:51,839 --> 00:57:54,400
it will last until it is evicted

1545
00:57:54,400 --> 00:57:56,400
so if you are not under memory pressure

1546
00:57:56,400 --> 00:57:59,200
i think it will last there

1547
00:57:59,200 --> 00:58:00,640
for some minutes or

1548
00:58:00,640 --> 00:58:02,240
who knows

1549
00:58:02,240 --> 00:58:04,000
um

1550
00:58:04,000 --> 00:58:05,599
yeah i

1551
00:58:05,599 --> 00:58:07,680
have a couple of questions

1552
00:58:07,680 --> 00:58:08,880
um so

1553
00:58:08,880 --> 00:58:10,400
i think this

1554
00:58:10,400 --> 00:58:12,400
this one only applies to those

1555
00:58:12,400 --> 00:58:14,160
supervisors that

1556
00:58:14,160 --> 00:58:16,240
that do uh

1557
00:58:16,240 --> 00:58:20,079
this memory the duplication um but i

1558
00:58:20,079 --> 00:58:24,160
don't actually know besides kvm

1559
00:58:24,160 --> 00:58:25,680
did you try the

1560
00:58:25,680 --> 00:58:28,720
others i mean zen whatever

1561
00:58:28,720 --> 00:58:30,720
um

1562
00:58:30,720 --> 00:58:32,400
no i don't

1563
00:58:32,400 --> 00:58:34,559
i can't speak for the original i don't

1564
00:58:34,559 --> 00:58:37,040
think they did but

1565
00:58:37,040 --> 00:58:39,359
yeah i think they stuck to kvm as an

1566
00:58:39,359 --> 00:58:41,520
example of the exploit

1567
00:58:41,520 --> 00:58:43,040
okay thanks

1568
00:58:43,040 --> 00:58:44,880
and uh

1569
00:58:44,880 --> 00:58:46,480
yeah so

1570
00:58:46,480 --> 00:58:48,319
basically this is

1571
00:58:48,319 --> 00:58:50,079
exploiting the fact that

1572
00:58:50,079 --> 00:58:52,160
that the data is still in the base class

1573
00:58:52,160 --> 00:58:53,760
in the linux space cache

1574
00:58:53,760 --> 00:58:56,000
so i guess if the

1575
00:58:56,000 --> 00:58:58,880
target process just bypasses the cache

1576
00:58:58,880 --> 00:59:01,040
like opening the file with all direct

1577
00:59:01,040 --> 00:59:02,839
flag or something this would be this

1578
00:59:02,839 --> 00:59:06,640
would uh probably alleviate

1579
00:59:06,640 --> 00:59:07,599
the

1580
00:59:07,599 --> 00:59:10,559
the the issue i think but yeah just just

1581
00:59:10,559 --> 00:59:13,520
remind me yes but if you prevent it from

1582
00:59:13,520 --> 00:59:16,000
getting into memory in its entirety

1583
00:59:16,000 --> 00:59:18,480
but you need uh

1584
00:59:18,480 --> 00:59:21,200
or if you remove it from memory

1585
00:59:21,200 --> 00:59:22,880
right after you're done with it probably

1586
00:59:22,880 --> 00:59:24,720
like there they you have

1587
00:59:24,720 --> 00:59:27,680
a timing issue probably right

1588
00:59:27,680 --> 00:59:29,119
if you flush it immediately afterwards

1589
00:59:29,119 --> 00:59:31,920
for example but yeah empty empty rising

1590
00:59:31,920 --> 00:59:33,920
here right so

1591
00:59:33,920 --> 00:59:36,720
yeah um so yeah uh thanks again for the

1592
00:59:36,720 --> 00:59:39,680
talk very interesting

1593
00:59:40,880 --> 00:59:43,520
other questions

1594
00:59:45,680 --> 00:59:48,160
okay so thanks for the talk

1595
00:59:48,160 --> 00:59:52,279
and uh yeah that's it

1596
01:00:08,480 --> 01:00:11,480
is

1597
01:00:21,970 --> 01:00:25,620
[Music]

