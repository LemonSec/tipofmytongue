1
00:00:00,240 --> 00:00:02,480
i'm really happy to have uh steve

2
00:00:02,480 --> 00:00:05,040
scooped thomas back on stage

3
00:00:05,040 --> 00:00:07,200
uh first time was

4
00:00:07,200 --> 00:00:08,080
in

5
00:00:08,080 --> 00:00:11,440
paso scott in oslo in december 2012 so

6
00:00:11,440 --> 00:00:13,759
almost 10 years ago

7
00:00:13,759 --> 00:00:17,119
uh a pretty uh fun experience and a good

8
00:00:17,119 --> 00:00:19,279
talk back then uh he's also been with

9
00:00:19,279 --> 00:00:21,520
pascal several times before

10
00:00:21,520 --> 00:00:25,279
and uh about steve i can say for you

11
00:00:25,279 --> 00:00:27,279
know for certain that

12
00:00:27,279 --> 00:00:29,359
i understand maybe two percent of the

13
00:00:29,359 --> 00:00:31,359
stuff he's talking about because i

14
00:00:31,359 --> 00:00:33,920
basically suck at math and crypto

15
00:00:33,920 --> 00:00:36,239
but i can also say that if you have

16
00:00:36,239 --> 00:00:38,960
anything that is using crypto that you

17
00:00:38,960 --> 00:00:40,640
intend to put online

18
00:00:40,640 --> 00:00:42,800
if you haven't hired steve to look into

19
00:00:42,800 --> 00:00:44,879
it first to look for vulnerabilities

20
00:00:44,879 --> 00:00:46,960
you're doing it wrong because he is

21
00:00:46,960 --> 00:00:48,399
incredibly good at finding

22
00:00:48,399 --> 00:00:50,879
vulnerabilities and now

23
00:00:50,879 --> 00:00:52,640
it's steve and

24
00:00:52,640 --> 00:00:55,920
via script a cash hard password hash so

25
00:00:55,920 --> 00:00:57,680
go ahead

26
00:00:57,680 --> 00:00:58,719
okay

27
00:00:58,719 --> 00:01:01,680
uh just for clarification that's crypto

28
00:01:01,680 --> 00:01:04,640
as in cryptography

29
00:01:07,439 --> 00:01:10,560
okay so uh bscrypt

30
00:01:10,560 --> 00:01:13,280
uh it's a new password hashing algorithm

31
00:01:13,280 --> 00:01:15,119
and kdf

32
00:01:15,119 --> 00:01:18,159
so uh password hashing and password kdfs

33
00:01:18,159 --> 00:01:21,360
follow on a fall under this umbrella of

34
00:01:21,360 --> 00:01:23,200
key stretching so

35
00:01:23,200 --> 00:01:24,880
key stretching can be used for other

36
00:01:24,880 --> 00:01:26,560
things like

37
00:01:26,560 --> 00:01:29,920
so if you have a small key

38
00:01:29,920 --> 00:01:31,600
you know you have something with like 30

39
00:01:31,600 --> 00:01:33,200
bits of entropy

40
00:01:33,200 --> 00:01:35,840
and you want 40 bits of strength you can

41
00:01:35,840 --> 00:01:39,040
stretch for 10 extra bits

42
00:01:39,040 --> 00:01:41,280
you can use that for like um

43
00:01:41,280 --> 00:01:43,280
uh fingerprints so you can have a

44
00:01:43,280 --> 00:01:45,280
shorter fingerprint but it's harder to

45
00:01:45,280 --> 00:01:47,520
make a collision or whatever

46
00:01:47,520 --> 00:01:49,040
but we're only going to be talking about

47
00:01:49,040 --> 00:01:50,399
uh password

48
00:01:50,399 --> 00:01:51,280
uh

49
00:01:51,280 --> 00:01:52,960
key stretching in relationship to

50
00:01:52,960 --> 00:01:55,520
passwords so uh

51
00:01:55,520 --> 00:01:57,840
key stretching um so

52
00:01:57,840 --> 00:02:00,399
uh the first thing that people came up

53
00:02:00,399 --> 00:02:04,000
with was uh computationally hard so what

54
00:02:04,000 --> 00:02:05,840
this is is you just hash your password

55
00:02:05,840 --> 00:02:07,280
then you hash that and over and over and

56
00:02:07,280 --> 00:02:09,440
over and

57
00:02:09,440 --> 00:02:11,920
memory hard you just use the

58
00:02:11,920 --> 00:02:14,080
resource of memory and you hash stuff

59
00:02:14,080 --> 00:02:15,680
and you know

60
00:02:15,680 --> 00:02:16,800
uh

61
00:02:16,800 --> 00:02:21,040
whatnot here are some algorithms so

62
00:02:21,120 --> 00:02:24,560
pvk df2 uh you may have heard of maybe

63
00:02:24,560 --> 00:02:27,760
not and you know uh there's argon 2 s

64
00:02:27,760 --> 00:02:30,879
crypt uh balloon hashing which doesn't

65
00:02:30,879 --> 00:02:32,879
actually have like an official

66
00:02:32,879 --> 00:02:35,360
uh spec or anything like that uh yes

67
00:02:35,360 --> 00:02:36,720
crypt

68
00:02:36,720 --> 00:02:37,519
um

69
00:02:37,519 --> 00:02:38,239
so

70
00:02:38,239 --> 00:02:41,280
computationally hard uh there's two

71
00:02:41,280 --> 00:02:43,599
sub sections one that i explained before

72
00:02:43,599 --> 00:02:45,280
where you hash the password then you

73
00:02:45,280 --> 00:02:47,280
hash that then you hash it again it's a

74
00:02:47,280 --> 00:02:50,640
very sequential operation

75
00:02:51,519 --> 00:02:54,720
i realized that i should probably

76
00:02:54,720 --> 00:02:57,599
uh so it's like kind of a new algorithm

77
00:02:57,599 --> 00:02:59,440
people are kind of afraid of it

78
00:02:59,440 --> 00:03:03,360
but pbk df2 has this foot gun where

79
00:03:03,360 --> 00:03:04,560
um

80
00:03:04,560 --> 00:03:09,120
so if you ask for so pbktdf2 sha256

81
00:03:09,120 --> 00:03:13,599
uh that's 32 bytes of so sha-256 is 32

82
00:03:13,599 --> 00:03:16,840
bytes uh if you ask for 32 bytes

83
00:03:16,840 --> 00:03:20,319
from pbk df2 uh you run through all the

84
00:03:20,319 --> 00:03:22,400
iterations but if you ask for any more

85
00:03:22,400 --> 00:03:24,480
it will do all the integrations again

86
00:03:24,480 --> 00:03:25,920
but with like a different counter at the

87
00:03:25,920 --> 00:03:26,799
top

88
00:03:26,799 --> 00:03:29,680
so all those are done

89
00:03:29,680 --> 00:03:32,159
in parallel if you ask for a large

90
00:03:32,159 --> 00:03:34,319
amount of output so

91
00:03:34,319 --> 00:03:35,360
i just

92
00:03:35,360 --> 00:03:37,760
this is the entire algorithm

93
00:03:37,760 --> 00:03:39,599
uh you just

94
00:03:39,599 --> 00:03:42,000
ask for a large amount and then you xor

95
00:03:42,000 --> 00:03:43,760
each of the blocks together and then you

96
00:03:43,760 --> 00:03:46,400
do that uh this should

97
00:03:46,400 --> 00:03:49,760
you know uh nist should um

98
00:03:49,760 --> 00:03:53,519
like fast track this into pbkdf3 or you

99
00:03:53,519 --> 00:03:56,799
know uh something so that we can get

100
00:03:56,799 --> 00:03:59,760
something that's better than pbkdf2 df2

101
00:03:59,760 --> 00:04:02,080
at the end you'll see a benchmark

102
00:04:02,080 --> 00:04:05,120
between this and other algorithms and

103
00:04:05,120 --> 00:04:06,620
yeah

104
00:04:06,620 --> 00:04:07,920
[Music]

105
00:04:07,920 --> 00:04:10,239
so this brings us to cash art this is

106
00:04:10,239 --> 00:04:13,200
relatively new

107
00:04:13,200 --> 00:04:15,519
basically uh

108
00:04:15,519 --> 00:04:17,199
the difference between memory hard and

109
00:04:17,199 --> 00:04:20,000
cash hard memory hard uh reads like

110
00:04:20,000 --> 00:04:21,680
sequential blocks

111
00:04:21,680 --> 00:04:24,080
of memory so you'll read like a kilobyte

112
00:04:24,080 --> 00:04:26,560
from memory randomly and then do

113
00:04:26,560 --> 00:04:28,880
something with it and then you know

114
00:04:28,880 --> 00:04:31,840
what not uh cash hard you want to

115
00:04:31,840 --> 00:04:33,520
do small

116
00:04:33,520 --> 00:04:35,520
fast uh random

117
00:04:35,520 --> 00:04:36,320
uh

118
00:04:36,320 --> 00:04:38,320
lookups so you're looking up

119
00:04:38,320 --> 00:04:41,520
uh eight bytes versus a kilobyte

120
00:04:41,520 --> 00:04:42,560
and doing

121
00:04:42,560 --> 00:04:44,400
a quick operation

122
00:04:44,400 --> 00:04:45,120
so

123
00:04:45,120 --> 00:04:46,240
decrypt

124
00:04:46,240 --> 00:04:49,120
this is minimally catch art

125
00:04:49,120 --> 00:04:51,199
it was kind of accidentally cache hard

126
00:04:51,199 --> 00:04:53,840
because it used this

127
00:04:53,840 --> 00:04:55,520
encryption algorithm called blowfish

128
00:04:55,520 --> 00:05:00,720
which had uh 4k of s boxes and

129
00:05:00,720 --> 00:05:02,639
we didn't know that you know

130
00:05:02,639 --> 00:05:04,960
cash hard was a good thing until gpus

131
00:05:04,960 --> 00:05:07,039
came out and

132
00:05:07,039 --> 00:05:09,360
uh you know

133
00:05:09,360 --> 00:05:12,000
people were noticing that you know the

134
00:05:12,000 --> 00:05:13,199
speed to

135
00:05:13,199 --> 00:05:15,120
generate one of these hashes from a

136
00:05:15,120 --> 00:05:16,240
defender

137
00:05:16,240 --> 00:05:19,360
versus how slow they are for a gpu

138
00:05:19,360 --> 00:05:21,600
attacker you know it was way better than

139
00:05:21,600 --> 00:05:23,360
other things so

140
00:05:23,360 --> 00:05:25,840
uh bs grip that's what we're basically

141
00:05:25,840 --> 00:05:28,240
going to be talking about uh then uh

142
00:05:28,240 --> 00:05:31,680
puffer fish two uh pufferfish was uh

143
00:05:31,680 --> 00:05:33,120
submitted to the password hashing

144
00:05:33,120 --> 00:05:35,680
competition and then uh i forgot exactly

145
00:05:35,680 --> 00:05:37,120
when it changed i think was in the

146
00:05:37,120 --> 00:05:41,280
tweaking round uh or something like that

147
00:05:41,600 --> 00:05:45,120
but we'll also be comparing uh that

148
00:05:45,120 --> 00:05:46,720
uh yes script

149
00:05:46,720 --> 00:05:50,320
and argon 2 ds

150
00:05:50,320 --> 00:05:52,880
those are memory hard algorithms that

151
00:05:52,880 --> 00:05:53,759
have

152
00:05:53,759 --> 00:05:55,680
this extra thing where they do some

153
00:05:55,680 --> 00:05:58,800
cachard operations um

154
00:05:58,800 --> 00:06:01,919
you probably haven't heard of argon 2ds

155
00:06:01,919 --> 00:06:04,240
if you've heard of argon 2 because this

156
00:06:04,240 --> 00:06:07,759
was actually uh created after the

157
00:06:07,759 --> 00:06:10,400
password fashion competition ended

158
00:06:10,400 --> 00:06:14,560
uh i i even keep forgetting about it

159
00:06:14,960 --> 00:06:16,560
uh so we're basically just gonna be

160
00:06:16,560 --> 00:06:19,360
talking about bs grip and puffer fish

161
00:06:19,360 --> 00:06:21,039
too

162
00:06:21,039 --> 00:06:21,840
so

163
00:06:21,840 --> 00:06:24,960
uh how to do a password hashing uh

164
00:06:24,960 --> 00:06:27,280
how to do key stretching well

165
00:06:27,280 --> 00:06:29,680
so what you want to do is hash all the

166
00:06:29,680 --> 00:06:33,520
inputs then do some sort of work

167
00:06:33,520 --> 00:06:34,960
with that

168
00:06:34,960 --> 00:06:37,280
uh so you generate the seed then you do

169
00:06:37,280 --> 00:06:38,800
some amount of work

170
00:06:38,800 --> 00:06:41,120
you generate this value called work and

171
00:06:41,120 --> 00:06:43,199
then you just put it in a kdf and

172
00:06:43,199 --> 00:06:45,600
stretch it for whatever length uh you

173
00:06:45,600 --> 00:06:47,039
know if it's a password hash you

174
00:06:47,039 --> 00:06:48,720
probably want to have that be a fixed

175
00:06:48,720 --> 00:06:51,039
width of like 32 bytes

176
00:06:51,039 --> 00:06:53,440
and if it's kdf you know go

177
00:06:53,440 --> 00:06:54,220
whatever

178
00:06:54,220 --> 00:06:55,599
[Music]

179
00:06:55,599 --> 00:06:56,479
so

180
00:06:56,479 --> 00:06:58,720
um

181
00:06:58,720 --> 00:07:02,160
uh bcrypt they didn't do that first step

182
00:07:02,160 --> 00:07:04,560
uh where you hatch all the inputs so

183
00:07:04,560 --> 00:07:06,560
what ended up happening is

184
00:07:06,560 --> 00:07:07,919
um

185
00:07:07,919 --> 00:07:10,639
there's bugs with null characters where

186
00:07:10,639 --> 00:07:11,520
uh

187
00:07:11,520 --> 00:07:12,800
you know it

188
00:07:12,800 --> 00:07:14,720
so a lot of the implementations are in c

189
00:07:14,720 --> 00:07:16,880
they expect c strings but if you give it

190
00:07:16,880 --> 00:07:19,759
you know utf-16 then you have no

191
00:07:19,759 --> 00:07:21,360
password part

192
00:07:21,360 --> 00:07:22,240
um

193
00:07:22,240 --> 00:07:23,919
then uh there were

194
00:07:23,919 --> 00:07:25,840
bugs where um

195
00:07:25,840 --> 00:07:28,960
the uh with uh unicode characters and

196
00:07:28,960 --> 00:07:32,319
like utf-8 where the sign got extended

197
00:07:32,319 --> 00:07:33,199
and

198
00:07:33,199 --> 00:07:37,360
cleared out parts of the password um but

199
00:07:37,360 --> 00:07:40,960
basically this uh right here is blowfish

200
00:07:40,960 --> 00:07:42,840
encryption

201
00:07:42,840 --> 00:07:45,840
uh so the block right there that's done

202
00:07:45,840 --> 00:07:48,560
like 16 times s uh zero through three

203
00:07:48,560 --> 00:07:50,160
those are s boxes

204
00:07:50,160 --> 00:07:53,759
and so pufferfish made these changes to

205
00:07:53,759 --> 00:07:54,879
uh

206
00:07:54,879 --> 00:07:56,560
uh blowfish

207
00:07:56,560 --> 00:07:59,759
uh also blowfish is 32-bit uh you know

208
00:07:59,759 --> 00:08:01,520
all the variables are 32-bit and these

209
00:08:01,520 --> 00:08:06,479
are 64-bit so that you can have a larger

210
00:08:06,879 --> 00:08:10,560
larger masks so you can have

211
00:08:10,560 --> 00:08:14,319
larger s boxes also the uh mask allowed

212
00:08:14,319 --> 00:08:16,720
for scaling the s boxes to

213
00:08:16,720 --> 00:08:18,160
um you know

214
00:08:18,160 --> 00:08:22,080
nice binary numbers of sizes so like

215
00:08:22,080 --> 00:08:23,520
64k

216
00:08:23,520 --> 00:08:27,440
128k stuff like that um so in

217
00:08:27,440 --> 00:08:30,800
uh april 2019 before bs script was

218
00:08:30,800 --> 00:08:32,559
called bs corrupt i figure it was called

219
00:08:32,559 --> 00:08:35,039
but um i was like oh

220
00:08:35,039 --> 00:08:37,839
i don't really like how pufferfish was

221
00:08:37,839 --> 00:08:40,159
not using some of those bits to do

222
00:08:40,159 --> 00:08:42,559
lookups on so i was like i'll do

223
00:08:42,559 --> 00:08:45,600
eight bit lookups and then just have

224
00:08:45,600 --> 00:08:49,680
uh so this right here is uh 64k

225
00:08:49,680 --> 00:08:52,640
of s boxes

226
00:08:52,640 --> 00:08:57,040
uh 16. did i say 64. whatever uh 16k of

227
00:08:57,040 --> 00:09:00,320
xboxes um and when you wanted to do 32

228
00:09:00,320 --> 00:09:04,000
or uh some weird thing like 48 or you

229
00:09:04,000 --> 00:09:04,640
know

230
00:09:04,640 --> 00:09:07,519
something multiple of 16 you just do

231
00:09:07,519 --> 00:09:09,600
eight more s boxes and then you just do

232
00:09:09,600 --> 00:09:12,480
a for loop around this to do multiple

233
00:09:12,480 --> 00:09:14,000
iterations

234
00:09:14,000 --> 00:09:15,360
um so

235
00:09:15,360 --> 00:09:18,000
what i didn't know was that

236
00:09:18,000 --> 00:09:20,320
cpus were going to have weird sizes for

237
00:09:20,320 --> 00:09:25,360
cash like uh you know 48k or 1.25

238
00:09:25,360 --> 00:09:27,040
meg

239
00:09:27,040 --> 00:09:28,320
uh so

240
00:09:28,320 --> 00:09:31,120
um i tweeted out this uh

241
00:09:31,120 --> 00:09:35,440
benchmark in uh sonya team uh and

242
00:09:35,440 --> 00:09:37,920
so two different cpus one has only two

243
00:09:37,920 --> 00:09:40,080
layers of cache one has three uh you can

244
00:09:40,080 --> 00:09:41,600
probably guess

245
00:09:41,600 --> 00:09:42,800
but um

246
00:09:42,800 --> 00:09:44,320
so the

247
00:09:44,320 --> 00:09:47,279
what i noticed was uh the pink line that

248
00:09:47,279 --> 00:09:51,040
one little duh it it came uh that was at

249
00:09:51,040 --> 00:09:55,120
quote six uh 256k uh which is the cash

250
00:09:55,120 --> 00:09:58,080
size the l2 cache size for

251
00:09:58,080 --> 00:09:59,519
uh one core

252
00:09:59,519 --> 00:10:01,680
on that and i noticed a jump and i was

253
00:10:01,680 --> 00:10:02,720
like oh

254
00:10:02,720 --> 00:10:05,120
that's weird um

255
00:10:05,120 --> 00:10:07,120
so i realized

256
00:10:07,120 --> 00:10:09,040
that it was the p boxes because i think

257
00:10:09,040 --> 00:10:12,560
i actually was using multiple p boxes uh

258
00:10:12,560 --> 00:10:14,640
permutation

259
00:10:14,640 --> 00:10:18,399
uh s box is a substitution box it's like

260
00:10:18,399 --> 00:10:19,120
a

261
00:10:19,120 --> 00:10:22,160
cryptographic term whatever uh anyway so

262
00:10:22,160 --> 00:10:24,160
i removed those because we're not using

263
00:10:24,160 --> 00:10:25,839
this for encryption and that's like

264
00:10:25,839 --> 00:10:28,480
where the key bits were and stuff

265
00:10:28,480 --> 00:10:30,240
so um

266
00:10:30,240 --> 00:10:32,480
because the only part about this being

267
00:10:32,480 --> 00:10:34,079
cash hard are these

268
00:10:34,079 --> 00:10:38,720
s boxes so uh removing those um it then

269
00:10:38,720 --> 00:10:39,920
uh you know

270
00:10:39,920 --> 00:10:42,880
got rid of that little bump before uh

271
00:10:42,880 --> 00:10:43,920
when you

272
00:10:43,920 --> 00:10:45,519
are at that limit

273
00:10:45,519 --> 00:10:47,920
um later uh

274
00:10:47,920 --> 00:10:50,000
i was like you know what uh i should

275
00:10:50,000 --> 00:10:52,640
switch to accumulators because the only

276
00:10:52,640 --> 00:10:54,000
thing that

277
00:10:54,000 --> 00:10:57,040
matters is that you're alternating xor

278
00:10:57,040 --> 00:10:58,160
and add

279
00:10:58,160 --> 00:11:02,000
um so you just do lookups and then xor

280
00:11:02,000 --> 00:11:05,440
or add into the accumulators like this

281
00:11:05,440 --> 00:11:06,880
uh

282
00:11:06,880 --> 00:11:09,519
but there are some issues with them like

283
00:11:09,519 --> 00:11:12,000
if it's zero and then you if your

284
00:11:12,000 --> 00:11:14,800
accumulator is zero which is one into uh

285
00:11:14,800 --> 00:11:17,360
two to the 64. so very rare so it

286
00:11:17,360 --> 00:11:18,720
doesn't really matter

287
00:11:18,720 --> 00:11:21,920
but if you add a value

288
00:11:21,920 --> 00:11:23,040
and then

289
00:11:23,040 --> 00:11:26,839
you xor the same value it'll be zero

290
00:11:26,839 --> 00:11:29,600
um basically i was thinking of having

291
00:11:29,600 --> 00:11:32,000
just like one s box that i you know

292
00:11:32,000 --> 00:11:32,959
scaled

293
00:11:32,959 --> 00:11:35,200
uh because you could actually do that

294
00:11:35,200 --> 00:11:37,200
with an accumulator but you could it's

295
00:11:37,200 --> 00:11:39,839
possible to read the same variable

296
00:11:39,839 --> 00:11:41,440
twice

297
00:11:41,440 --> 00:11:43,839
so

298
00:11:44,320 --> 00:11:46,079
if you did that with you know a non-zero

299
00:11:46,079 --> 00:11:48,320
value then the least significant bit

300
00:11:48,320 --> 00:11:49,680
stays the same

301
00:11:49,680 --> 00:11:53,519
which is also not really a big deal

302
00:11:53,519 --> 00:11:56,639
so i was looking at different sizes for

303
00:11:56,639 --> 00:11:58,880
masks you know how many look-ups i could

304
00:11:58,880 --> 00:12:01,920
do and like what the limits were and

305
00:12:01,920 --> 00:12:03,839
whatnot

306
00:12:03,839 --> 00:12:05,040
and

307
00:12:05,040 --> 00:12:08,040
so

308
00:12:11,120 --> 00:12:12,320
uh

309
00:12:12,320 --> 00:12:16,160
then uh i had like a aha moment

310
00:12:16,160 --> 00:12:18,639
so i have two s boxes that are

311
00:12:18,639 --> 00:12:20,079
overlapping

312
00:12:20,079 --> 00:12:22,480
and you can shift them over to get those

313
00:12:22,480 --> 00:12:25,360
weird cache sizes so now i can hit like

314
00:12:25,360 --> 00:12:28,720
any size you really wanted with within a

315
00:12:28,720 --> 00:12:30,399
eight byte boundary

316
00:12:30,399 --> 00:12:32,959
granted the way that i did things uh

317
00:12:32,959 --> 00:12:35,920
it makes it nice for like 128 byte

318
00:12:35,920 --> 00:12:37,839
boundaries and then

319
00:12:37,839 --> 00:12:41,200
i really like how easy it is to read

320
00:12:41,200 --> 00:12:44,160
the settings and know what they mean so

321
00:12:44,160 --> 00:12:46,880
i just made it uh

322
00:12:46,880 --> 00:12:48,880
kilobyte boundaries so

323
00:12:48,880 --> 00:12:50,959
the m parameter

324
00:12:50,959 --> 00:12:54,240
if you see 256 that's 256k and whatnot

325
00:12:54,240 --> 00:12:57,200
so it makes it uh nice and

326
00:12:57,200 --> 00:12:58,639
easy to

327
00:12:58,639 --> 00:12:59,920
understand

328
00:12:59,920 --> 00:13:00,720
so

329
00:13:00,720 --> 00:13:01,680
um

330
00:13:01,680 --> 00:13:04,480
the largest size that i could do with

331
00:13:04,480 --> 00:13:07,519
these overlapping uh

332
00:13:07,519 --> 00:13:09,200
s boxes where

333
00:13:09,200 --> 00:13:11,279
a special case where they're you know

334
00:13:11,279 --> 00:13:13,600
totally separate for the largest size

335
00:13:13,600 --> 00:13:15,680
would be these values

336
00:13:15,680 --> 00:13:16,639
and

337
00:13:16,639 --> 00:13:18,560
um you know

338
00:13:18,560 --> 00:13:22,000
so obviously 4k that's kind of bad um

339
00:13:22,000 --> 00:13:25,279
and 64-bit masks you know

340
00:13:25,279 --> 00:13:27,920
that that's kind of excessive so

341
00:13:27,920 --> 00:13:29,839
i i got rid of those

342
00:13:29,839 --> 00:13:30,959
and

343
00:13:30,959 --> 00:13:33,120
then i was looking and i'm like well a

344
00:13:33,120 --> 00:13:35,760
megabyte that's kind of low so

345
00:13:35,760 --> 00:13:37,920
and then um

346
00:13:37,920 --> 00:13:39,839
depending on whether you wanted to push

347
00:13:39,839 --> 00:13:41,040
out into

348
00:13:41,040 --> 00:13:45,199
l3 cache some gp some cpus have

349
00:13:45,199 --> 00:13:47,600
more than 32 megs now

350
00:13:47,600 --> 00:13:49,839
so

351
00:13:49,839 --> 00:13:52,560
i guess this one wins

352
00:13:52,560 --> 00:13:53,680
[Music]

353
00:13:53,680 --> 00:13:55,040
so

354
00:13:55,040 --> 00:13:59,839
this is the main operation uh basically

355
00:14:00,839 --> 00:14:03,920
uh all right so green and blue you can

356
00:14:03,920 --> 00:14:06,480
basically consider those like uh l one

357
00:14:06,480 --> 00:14:10,079
uh well l zero through l three and then

358
00:14:10,079 --> 00:14:12,240
r zero through r

359
00:14:12,240 --> 00:14:13,440
three

360
00:14:13,440 --> 00:14:15,839
uh anyway so the reason why i do four of

361
00:14:15,839 --> 00:14:18,560
these in parallel is uh password

362
00:14:18,560 --> 00:14:21,839
crackers for decrypt what they did was

363
00:14:21,839 --> 00:14:25,199
they interlayed two um

364
00:14:25,199 --> 00:14:28,720
password uh you know

365
00:14:28,720 --> 00:14:31,360
they interleaved two um

366
00:14:31,360 --> 00:14:32,560
uh

367
00:14:32,560 --> 00:14:34,480
decrypt hashes with two different

368
00:14:34,480 --> 00:14:36,560
passwords and you got like a slight

369
00:14:36,560 --> 00:14:39,440
speed bump because it was hiding latency

370
00:14:39,440 --> 00:14:42,240
a little bit better so uh i wanted to do

371
00:14:42,240 --> 00:14:45,600
that but now these operations are

372
00:14:45,600 --> 00:14:47,680
just parallel so

373
00:14:47,680 --> 00:14:49,920
i do a block of that then i rotate them

374
00:14:49,920 --> 00:14:52,160
and then i rotate them again and again

375
00:14:52,160 --> 00:14:56,480
so it's basically four blocks of this

376
00:14:56,839 --> 00:15:02,000
and uh it mixes all the uh

377
00:15:03,440 --> 00:15:04,560
uh

378
00:15:04,560 --> 00:15:06,160
you know all the different ones that are

379
00:15:06,160 --> 00:15:07,920
done in parallel and this is basically a

380
00:15:07,920 --> 00:15:11,040
free well it is a free operation

381
00:15:11,040 --> 00:15:12,480
uh so

382
00:15:12,480 --> 00:15:13,760
and then

383
00:15:13,760 --> 00:15:16,079
i just read sequentially and then i also

384
00:15:16,079 --> 00:15:19,040
do uh you know a rotate again when you

385
00:15:19,040 --> 00:15:19,920
write

386
00:15:19,920 --> 00:15:22,160
and

387
00:15:22,160 --> 00:15:24,639
um again you know rotating them at the

388
00:15:24,639 --> 00:15:27,839
end it doesn't really matter too much

389
00:15:27,839 --> 00:15:28,720
but

390
00:15:28,720 --> 00:15:30,639
it's free

391
00:15:30,639 --> 00:15:31,920
so

392
00:15:31,920 --> 00:15:33,680
uh

393
00:15:33,680 --> 00:15:35,600
so following a

394
00:15:35,600 --> 00:15:39,040
uh an accumulator variable a uh you know

395
00:15:39,040 --> 00:15:42,079
you get the add xor and then the s boxes

396
00:15:42,079 --> 00:15:43,600
oh i never

397
00:15:43,600 --> 00:15:47,040
noticed that or whatever oops uh

398
00:15:47,040 --> 00:15:49,360
add x or add x or in the s boxes and

399
00:15:49,360 --> 00:15:54,079
then xor and then add so uh this was uh

400
00:15:54,079 --> 00:15:56,079
a version i had before

401
00:15:56,079 --> 00:15:59,680
then i realized that those two values

402
00:15:59,680 --> 00:16:01,279
could be the same

403
00:16:01,279 --> 00:16:05,120
so i'd be accumulating with add twice

404
00:16:05,120 --> 00:16:06,000
um

405
00:16:06,000 --> 00:16:07,120
so

406
00:16:07,120 --> 00:16:08,560
i then

407
00:16:08,560 --> 00:16:10,639
changed it so that you have a block that

408
00:16:10,639 --> 00:16:13,360
starts with adding and then

409
00:16:13,360 --> 00:16:16,160
every other and then a block that starts

410
00:16:16,160 --> 00:16:17,600
with xor

411
00:16:17,600 --> 00:16:20,079
and then every other so when you look at

412
00:16:20,079 --> 00:16:23,040
what's being accumulated it's always uh

413
00:16:23,040 --> 00:16:25,600
add x or add x or add x or and then what

414
00:16:25,600 --> 00:16:27,759
you're writing add xor

415
00:16:27,759 --> 00:16:28,560
uh

416
00:16:28,560 --> 00:16:30,959
so on

417
00:16:31,839 --> 00:16:33,199
um then

418
00:16:33,199 --> 00:16:34,320
uh

419
00:16:34,320 --> 00:16:36,800
so those are two different blocks uh

420
00:16:36,800 --> 00:16:39,360
then i rotate all the values this is

421
00:16:39,360 --> 00:16:40,240
what

422
00:16:40,240 --> 00:16:42,320
made me uh

423
00:16:42,320 --> 00:16:43,279
so

424
00:16:43,279 --> 00:16:45,759
remember when i said that uh i didn't

425
00:16:45,759 --> 00:16:47,519
like how some of those bits weren't

426
00:16:47,519 --> 00:16:50,000
being used for lookups well when you

427
00:16:50,000 --> 00:16:52,639
rotate the variables uh those bits that

428
00:16:52,639 --> 00:16:55,360
aren't being used will then later be

429
00:16:55,360 --> 00:16:58,079
used in you know other calculation uh

430
00:16:58,079 --> 00:17:01,360
other lookups and all i did was uh do a

431
00:17:01,360 --> 00:17:03,360
through d after the first block and then

432
00:17:03,360 --> 00:17:06,640
e through h after the next

433
00:17:06,640 --> 00:17:08,799
so

434
00:17:09,280 --> 00:17:13,280
uh initial fill and finish um you know

435
00:17:13,280 --> 00:17:14,640
i'm pretty sure you're all bored with

436
00:17:14,640 --> 00:17:17,119
code so you know you can go look it up

437
00:17:17,119 --> 00:17:18,880
if you want

438
00:17:18,880 --> 00:17:24,559
but basically uh i used uh blake 2b

439
00:17:24,559 --> 00:17:28,720
for the hashing of inputs and the

440
00:17:28,720 --> 00:17:32,080
kdf at the end to expand it and you

441
00:17:32,080 --> 00:17:34,400
might be wondering why i use blake 2b

442
00:17:34,400 --> 00:17:36,480
instead of like like three

443
00:17:36,480 --> 00:17:37,679
um

444
00:17:37,679 --> 00:17:42,480
well blake 2b is 64-bit and uh blake

445
00:17:42,480 --> 00:17:46,080
3 is 32-bit so i wanted to basically

446
00:17:46,080 --> 00:17:49,120
have a native write function

447
00:17:49,120 --> 00:17:52,400
on like a native read so um

448
00:17:52,400 --> 00:17:54,080
it doesn't have to do any

449
00:17:54,080 --> 00:17:54,960
uh

450
00:17:54,960 --> 00:17:56,960
bite endian swaps or anything like that

451
00:17:56,960 --> 00:17:57,760
so

452
00:17:57,760 --> 00:18:00,320
you it basically just deals with only

453
00:18:00,320 --> 00:18:02,960
64-bit integers

454
00:18:02,960 --> 00:18:05,760
and then the finish is really simple i

455
00:18:05,760 --> 00:18:08,400
just run over the entire uh

456
00:18:08,400 --> 00:18:09,679
data

457
00:18:09,679 --> 00:18:10,559
by

458
00:18:10,559 --> 00:18:14,240
adding an xoring like 16 in parallel and

459
00:18:14,240 --> 00:18:16,799
then you know combine do some you know

460
00:18:16,799 --> 00:18:21,039
stuff so uh where can you find

461
00:18:21,039 --> 00:18:23,360
this code

462
00:18:23,360 --> 00:18:27,080
well it's

463
00:18:30,320 --> 00:18:32,720
is

464
00:18:34,480 --> 00:18:37,520
let's hope this works

465
00:18:41,120 --> 00:18:45,520
it is on github as soon as this finishes

466
00:18:51,200 --> 00:18:55,240
yeah yeah there we go

467
00:18:56,000 --> 00:18:57,760
so

468
00:18:57,760 --> 00:19:00,720
this could be you

469
00:19:01,039 --> 00:19:03,919
i bet no one knows that i was there when

470
00:19:03,919 --> 00:19:07,799
bs crypt was released

471
00:19:10,640 --> 00:19:13,120
all right so benchmarks

472
00:19:13,120 --> 00:19:14,480
um so

473
00:19:14,480 --> 00:19:19,360
uh pbkdf2 shot 256 uh sha 512 decrypt

474
00:19:19,360 --> 00:19:21,440
and bs crypt so

475
00:19:21,440 --> 00:19:23,840
uh these the settings for all three of

476
00:19:23,840 --> 00:19:26,400
these were uh set to

477
00:19:26,400 --> 00:19:29,840
what a gpu attacker could do uh

478
00:19:29,840 --> 00:19:32,480
for uh bcrypt uh

479
00:19:32,480 --> 00:19:33,760
cost nine

480
00:19:33,760 --> 00:19:34,960
because that was the one that you

481
00:19:34,960 --> 00:19:36,720
couldn't have as much leeway with the

482
00:19:36,720 --> 00:19:40,640
settings so it's basically 53

483
00:19:40,640 --> 00:19:44,480
kilohashes per second per gpu

484
00:19:45,120 --> 00:19:46,880
and so

485
00:19:46,880 --> 00:19:49,840
as a defender you can spend almost 800

486
00:19:49,840 --> 00:19:54,400
milliseconds doing pbk df2 uh sha 256

487
00:19:54,400 --> 00:19:55,520
or

488
00:19:55,520 --> 00:19:58,240
you could spend uh four milliseconds

489
00:19:58,240 --> 00:20:00,080
running the script

490
00:20:00,080 --> 00:20:00,799
so

491
00:20:00,799 --> 00:20:04,080
you know uh so this is on uh actually

492
00:20:04,080 --> 00:20:06,320
this laptop i realized that i should

493
00:20:06,320 --> 00:20:08,640
have i thought of the slide last night

494
00:20:08,640 --> 00:20:10,799
and i was like oh i need to

495
00:20:10,799 --> 00:20:13,679
get a benchmark so i can do this but

496
00:20:13,679 --> 00:20:15,840
yeah

497
00:20:16,240 --> 00:20:18,960
pufferfish2 isn't on this uh

498
00:20:18,960 --> 00:20:21,440
multiple reasons i didn't have the code

499
00:20:21,440 --> 00:20:23,440
and two um

500
00:20:23,440 --> 00:20:26,159
the uh settings are also not as

501
00:20:26,159 --> 00:20:28,640
forgivable like uh

502
00:20:28,640 --> 00:20:31,760
jeremy wanted to have it such that uh

503
00:20:31,760 --> 00:20:33,760
you know he had a t constant m cost

504
00:20:33,760 --> 00:20:36,159
which were uh two to the whatever that

505
00:20:36,159 --> 00:20:39,039
value is like decrypted so it'd be hard

506
00:20:39,039 --> 00:20:39,919
to

507
00:20:39,919 --> 00:20:42,320
get an exact comparison

508
00:20:42,320 --> 00:20:44,559
but

509
00:20:44,880 --> 00:20:48,200
uh so

510
00:20:48,960 --> 00:20:52,960
okay uh so this is again this laptop um

511
00:20:52,960 --> 00:20:57,360
so it only has uh three megs of l3 cache

512
00:20:57,360 --> 00:20:58,960
and uh

513
00:20:58,960 --> 00:21:01,600
if you look at the green line um bs

514
00:21:01,600 --> 00:21:03,600
crypt p equal to so this is with two

515
00:21:03,600 --> 00:21:06,400
threads so it's running on two cores um

516
00:21:06,400 --> 00:21:10,080
with each with uh two megs of cash each

517
00:21:10,080 --> 00:21:12,720
so it's actually now pushing into memory

518
00:21:12,720 --> 00:21:14,960
which uh as you can see gets a lot

519
00:21:14,960 --> 00:21:17,840
slower

520
00:21:17,919 --> 00:21:20,640
basically uh

521
00:21:20,640 --> 00:21:24,960
oh right so uh pufferfish too fast

522
00:21:24,960 --> 00:21:27,440
basically

523
00:21:27,520 --> 00:21:29,679
what puffered fish does after every

524
00:21:29,679 --> 00:21:31,440
round of encrypting

525
00:21:31,440 --> 00:21:34,960
you know encrypting all the uh s boxes

526
00:21:34,960 --> 00:21:38,559
uh it runs it hashes all those

527
00:21:38,559 --> 00:21:40,080
so it has to

528
00:21:40,080 --> 00:21:41,840
run through them with uh

529
00:21:41,840 --> 00:21:46,240
hmac sha 512 it's a hashmall which is a

530
00:21:46,240 --> 00:21:49,039
slow operation and it's not exactly

531
00:21:49,039 --> 00:21:51,360
helping its cache hardness

532
00:21:51,360 --> 00:21:52,159
so

533
00:21:52,159 --> 00:21:53,840
it then

534
00:21:53,840 --> 00:21:57,039
gets a little bit faster

535
00:21:57,200 --> 00:21:59,600
for uh the defender

536
00:21:59,600 --> 00:22:00,880
so uh

537
00:22:00,880 --> 00:22:03,520
different cpu um

538
00:22:03,520 --> 00:22:07,679
this one uh has six megs of l3 cache and

539
00:22:07,679 --> 00:22:09,039
you know uh for

540
00:22:09,039 --> 00:22:11,520
bs grip uh

541
00:22:11,520 --> 00:22:12,400
p4

542
00:22:12,400 --> 00:22:16,799
uh the last two are now hitting memory

543
00:22:17,120 --> 00:22:19,039
um

544
00:22:19,039 --> 00:22:20,240
so

545
00:22:20,240 --> 00:22:22,880
uh the nice thing about it is uh

546
00:22:22,880 --> 00:22:25,600
with multiple cores uh you know

547
00:22:25,600 --> 00:22:27,600
so these are all

548
00:22:27,600 --> 00:22:28,880
uh

549
00:22:28,880 --> 00:22:30,960
i should mention that each one of these

550
00:22:30,960 --> 00:22:31,919
points

551
00:22:31,919 --> 00:22:33,600
is uh

552
00:22:33,600 --> 00:22:36,960
quote the same hardness against a gpu

553
00:22:36,960 --> 00:22:40,480
attacker technically uh you might be

554
00:22:40,480 --> 00:22:43,600
able to be faster on the uh slower side

555
00:22:43,600 --> 00:22:49,600
uh the smaller side so like 16 or 32 64k

556
00:22:49,600 --> 00:22:51,280
those might be

557
00:22:51,280 --> 00:22:55,440
not enough cash hard to you know push

558
00:22:55,440 --> 00:22:59,440
gpus into doing memory lockups

559
00:22:59,440 --> 00:23:03,520
i forgot to mention that earlier so

560
00:23:03,520 --> 00:23:05,919
um so

561
00:23:05,919 --> 00:23:09,440
minimum settings for password hashing

562
00:23:09,440 --> 00:23:11,280
you should aim for

563
00:23:11,280 --> 00:23:14,400
being a gpu being at most

564
00:23:14,400 --> 00:23:17,840
10 000 hashes per second per gpu

565
00:23:17,840 --> 00:23:20,880
and that's not like just any gpu

566
00:23:20,880 --> 00:23:23,280
the best gpu for password cracking at

567
00:23:23,280 --> 00:23:24,240
the time

568
00:23:24,240 --> 00:23:28,720
uh which currently is uh rtx 3080 uh 12

569
00:23:28,720 --> 00:23:30,400
gigabyte

570
00:23:30,400 --> 00:23:32,400
version there's two uh there's one with

571
00:23:32,400 --> 00:23:35,120
10 which is slightly older whatever um

572
00:23:35,120 --> 00:23:37,440
but so when you

573
00:23:37,440 --> 00:23:39,600
put in settings for

574
00:23:39,600 --> 00:23:42,080
vscript with

575
00:23:42,080 --> 00:23:45,440
p1 p2 and p4

576
00:23:45,440 --> 00:23:48,559
it takes roughly one millisecond to get

577
00:23:48,559 --> 00:23:49,360
to

578
00:23:49,360 --> 00:23:51,679
the minimum strength that you should

579
00:23:51,679 --> 00:23:52,480
have

580
00:23:52,480 --> 00:23:53,520
so

581
00:23:53,520 --> 00:23:55,520
um

582
00:23:55,520 --> 00:23:58,559
basically this means that we can push

583
00:23:58,559 --> 00:24:01,600
well beyond and make gpu cracking really

584
00:24:01,600 --> 00:24:04,918
really slow

585
00:24:05,440 --> 00:24:06,559
so

586
00:24:06,559 --> 00:24:08,320
if you're familiar with

587
00:24:08,320 --> 00:24:10,879
decrypt

588
00:24:11,120 --> 00:24:15,440
cost 15 is ridiculously high it takes a

589
00:24:15,440 --> 00:24:17,200
very long time to

590
00:24:17,200 --> 00:24:19,679
generate one of those hashes

591
00:24:19,679 --> 00:24:21,440
but

592
00:24:21,440 --> 00:24:24,480
basically the equivalent settings for

593
00:24:24,480 --> 00:24:27,279
bscrypt

594
00:24:27,520 --> 00:24:28,720
to hit

595
00:24:28,720 --> 00:24:31,919
less than 85 hashes per second per gpu

596
00:24:31,919 --> 00:24:34,720
uh i ran this benchmark uh as you can

597
00:24:34,720 --> 00:24:37,760
see uh i guess it doesn't really help

598
00:24:37,760 --> 00:24:40,880
too much going with a fourth uh thread

599
00:24:40,880 --> 00:24:43,039
even though it's a quad core

600
00:24:43,039 --> 00:24:44,960
but

601
00:24:44,960 --> 00:24:46,799
um

602
00:24:46,799 --> 00:24:48,960
you know uh you can get under 100

603
00:24:48,960 --> 00:24:52,240
milliseconds on uh this cpu is like

604
00:24:52,240 --> 00:24:54,640
seven years old so it's not even that

605
00:24:54,640 --> 00:24:56,000
new

606
00:24:56,000 --> 00:24:57,279
so

607
00:24:57,279 --> 00:24:58,720
uh it's

608
00:24:58,720 --> 00:25:01,600
definitely good because usually your

609
00:25:01,600 --> 00:25:02,640
maximum

610
00:25:02,640 --> 00:25:05,120
time to do a password hatching algorithm

611
00:25:05,120 --> 00:25:05,919
is

612
00:25:05,919 --> 00:25:07,440
100 milliseconds you don't really want

613
00:25:07,440 --> 00:25:09,840
to go much higher than that but with

614
00:25:09,840 --> 00:25:11,520
this you know

615
00:25:11,520 --> 00:25:13,919
uh well technically if you're doing this

616
00:25:13,919 --> 00:25:15,919
on a server you wouldn't want to use uh

617
00:25:15,919 --> 00:25:19,039
parallelism because the uh parallelism

618
00:25:19,039 --> 00:25:21,120
is actually going to uh

619
00:25:21,120 --> 00:25:23,120
lower your throughput

620
00:25:23,120 --> 00:25:25,679
so if you measure with all your cores

621
00:25:25,679 --> 00:25:27,679
doing it and then

622
00:25:27,679 --> 00:25:29,279
you know you're like okay it takes 100

623
00:25:29,279 --> 00:25:31,760
milliseconds well that means your server

624
00:25:31,760 --> 00:25:34,320
can only authenticate 10 users at a time

625
00:25:34,320 --> 00:25:36,879
per second

626
00:25:39,279 --> 00:25:42,279
anyway

627
00:25:42,960 --> 00:25:45,120
uh questions that was

628
00:25:45,120 --> 00:25:45,840
i

629
00:25:45,840 --> 00:25:47,520
definitely skipped something i don't

630
00:25:47,520 --> 00:25:49,039
know what happened

631
00:25:49,039 --> 00:25:51,600
because i was running overtime

632
00:25:51,600 --> 00:25:54,159
before when i was yeah well that was

633
00:25:54,159 --> 00:25:56,320
that was ahead of schedule i don't know

634
00:25:56,320 --> 00:25:59,120
what happened yeah questions for steve

635
00:25:59,120 --> 00:26:03,120
or is everybody totally clear with this

636
00:26:04,320 --> 00:26:06,559
any thoughts on performance against an

637
00:26:06,559 --> 00:26:08,559
fpga or asic

638
00:26:08,559 --> 00:26:10,400
accelerated factor yes

639
00:26:10,400 --> 00:26:12,400
so the question was uh performance

640
00:26:12,400 --> 00:26:16,559
versus uh fpga or asic attacker so with

641
00:26:16,559 --> 00:26:18,559
fpgas um

642
00:26:18,559 --> 00:26:20,960
there's this one uh i forget what it's

643
00:26:20,960 --> 00:26:23,360
called but it basically uh

644
00:26:23,360 --> 00:26:26,400
it's four fpgas on a board you can you

645
00:26:26,400 --> 00:26:29,360
can only get them used uh they're like

646
00:26:29,360 --> 00:26:33,360
uh 200 dollars used but um

647
00:26:33,360 --> 00:26:34,960
uh so

648
00:26:34,960 --> 00:26:38,159
bcrypt on it is really is really nice

649
00:26:38,159 --> 00:26:40,640
and fast because of the onboard cache on

650
00:26:40,640 --> 00:26:41,360
it

651
00:26:41,360 --> 00:26:42,880
well uh

652
00:26:42,880 --> 00:26:46,240
that cache is limiting how many uh

653
00:26:46,240 --> 00:26:49,440
units of bcryp can be put on it can be

654
00:26:49,440 --> 00:26:51,919
running at the same time on the fpga

655
00:26:51,919 --> 00:26:54,400
well when you that's only 4k if you were

656
00:26:54,400 --> 00:26:56,880
doing 256k

657
00:26:56,880 --> 00:26:59,440
you would then be 64

658
00:26:59,440 --> 00:27:00,799
the speed

659
00:27:00,799 --> 00:27:04,000
1 64th the speed

660
00:27:04,000 --> 00:27:04,840
so

661
00:27:04,840 --> 00:27:08,240
um that would drop it well below

662
00:27:08,240 --> 00:27:10,400
gpus

663
00:27:10,400 --> 00:27:14,720
and then i assume a6 are similar

664
00:27:15,600 --> 00:27:18,960
but also no one's using a6

665
00:27:18,960 --> 00:27:20,720
question for me steve

666
00:27:20,720 --> 00:27:22,559
um

667
00:27:22,559 --> 00:27:24,799
let's be paranoid

668
00:27:24,799 --> 00:27:27,279
do we have reasons to think to believe

669
00:27:27,279 --> 00:27:28,240
that

670
00:27:28,240 --> 00:27:32,320
specialized government agencies in

671
00:27:32,559 --> 00:27:34,720
unnamed countries could have

672
00:27:34,720 --> 00:27:38,320
specialized cpus that are not generally

673
00:27:38,320 --> 00:27:40,240
known or available

674
00:27:40,240 --> 00:27:41,520
that can be

675
00:27:41,520 --> 00:27:44,000
in existence today that have either

676
00:27:44,000 --> 00:27:45,600
incredibly large

677
00:27:45,600 --> 00:27:48,320
cash sizes or also can deal with the

678
00:27:48,320 --> 00:27:52,320
memory hardware the cash heart problem

679
00:27:53,520 --> 00:27:55,520
yes

680
00:27:55,520 --> 00:27:57,679
but you know you're not worried i'm not

681
00:27:57,679 --> 00:27:59,279
worried about them

682
00:27:59,279 --> 00:28:00,880
no one really should be you should be

683
00:28:00,880 --> 00:28:03,760
worried about some kid with a gpu

684
00:28:03,760 --> 00:28:05,039
like

685
00:28:05,039 --> 00:28:06,960
and and and the team have hashcat i

686
00:28:06,960 --> 00:28:09,039
guess yes yeah you know some kid that

687
00:28:09,039 --> 00:28:11,279
gets a gpu for christmas and then you

688
00:28:11,279 --> 00:28:14,159
know oh i can crack passwords that's

689
00:28:14,159 --> 00:28:16,559
that's really

690
00:28:16,559 --> 00:28:19,600
any more questions for steve

691
00:28:19,600 --> 00:28:23,840
nope okay well then thank you steve

692
00:28:25,279 --> 00:28:27,679
and we are finished a little bit early

693
00:28:27,679 --> 00:28:30,480
but the last talk of the day why kids

694
00:28:30,480 --> 00:28:32,080
couldn't care less about your password

695
00:28:32,080 --> 00:28:33,919
advice is at

696
00:28:33,919 --> 00:28:35,600
six o'clock i would really recommend

697
00:28:35,600 --> 00:28:40,279
that one as well see you back then

